
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fmindersec%2Fminder%2Fblob%2Fmain%2Finternal%2Fcontrolplane%2Fhandlers_repositories.go)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fmindersec%2Fminder%2Fblob%2Fmain%2Finternal%2Fcontrolplane%2Fhandlers_repositories.go)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=mindersec%2Fminder)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[mindersec](/mindersec)
/
**[minder](/mindersec/minder)**
Public

* [Notifications](/login?return_to=%2Fmindersec%2Fminder) You must be signed in to change notification settings
* [Fork
  41](/login?return_to=%2Fmindersec%2Fminder)
* [Star
   306](/login?return_to=%2Fmindersec%2Fminder)

* [Code](/mindersec/minder)
* [Issues
  127](/mindersec/minder/issues)
* [Pull requests
  11](/mindersec/minder/pulls)
* [Discussions](/mindersec/minder/discussions)
* [Actions](/mindersec/minder/actions)
* [Wiki](/mindersec/minder/wiki)
* [Security](/mindersec/minder/security)
* [Insights](/mindersec/minder/pulse)

Additional navigation options

* [Code](/mindersec/minder)
* [Issues](/mindersec/minder/issues)
* [Pull requests](/mindersec/minder/pulls)
* [Discussions](/mindersec/minder/discussions)
* [Actions](/mindersec/minder/actions)
* [Wiki](/mindersec/minder/wiki)
* [Security](/mindersec/minder/security)
* [Insights](/mindersec/minder/pulse)

## Files

 main
## Breadcrumbs

1. [minder](/mindersec/minder/tree/main)
2. /[internal](/mindersec/minder/tree/main/internal)
3. /[controlplane](/mindersec/minder/tree/main/internal/controlplane)
/
# handlers\_repositories.go

Copy path Blame  Blame
## Latest commit

## History

[History](/mindersec/minder/commits/main/internal/controlplane/handlers_repositories.go)595 lines (514 loc) · 18.6 KB main
## Breadcrumbs

1. [minder](/mindersec/minder/tree/main)
2. /[internal](/mindersec/minder/tree/main/internal)
3. /[controlplane](/mindersec/minder/tree/main/internal/controlplane)
/
# handlers\_repositories.go

Top
## File metadata and controls

* Code
* Blame

595 lines (514 loc) · 18.6 KB[Raw](https://github.com/mindersec/minder/raw/refs/heads/main/internal/controlplane/handlers_repositories.go)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595// SPDX-FileCopyrightText: Copyright 2024 The Minder Authors// SPDX-License-Identifier: Apache-2.0
package controlplane
import ( "context" "database/sql" "errors" "fmt" "slices" "strings"
 "github.com/google/uuid" "github.com/rs/zerolog" "google.golang.org/grpc/codes" "google.golang.org/grpc/status" "google.golang.org/protobuf/types/known/structpb"
 "github.com/mindersec/minder/internal/db" "github.com/mindersec/minder/internal/engine/engcontext" "github.com/mindersec/minder/internal/entities/properties" "github.com/mindersec/minder/internal/logger" "github.com/mindersec/minder/internal/projects/features" "github.com/mindersec/minder/internal/providers" "github.com/mindersec/minder/internal/providers/github" "github.com/mindersec/minder/internal/repositories" "github.com/mindersec/minder/internal/util" cursorutil "github.com/mindersec/minder/internal/util/cursor" "github.com/mindersec/minder/internal/util/ptr" pb "github.com/mindersec/minder/pkg/api/protobuf/go/minder/v1" v1 "github.com/mindersec/minder/pkg/providers/v1")
// maxFetchLimit is the maximum number of repositories that can be fetched from the database in one callconst maxFetchLimit = 100
// RegisterRepository adds repositories to the database and registers a webhook// Once a user had enrolled in a project (they have a valid token), they can register// repositories to be monitored by the minder by provisioning a webhook on the// repository(ies).func (s \*Server) RegisterRepository( ctx context.Context, in \*pb.RegisterRepositoryRequest,) (\*pb.RegisterRepositoryResponse, error) { projectID := GetProjectID(ctx) providerName := GetProviderName(ctx)
 var fetchByProps \*properties.Properties var provider \*db.Provider var err error if in.GetEntity() != nil { fetchByProps, provider, err = s.repoCreateInfoFromUpstreamEntityRef( ctx, projectID, providerName, in.GetEntity()) } else if in.GetRepository() != nil { fetchByProps, provider, err = s.repoCreateInfoFromUpstreamRepositoryRef( ctx, projectID, providerName, in.GetRepository()) } else { return nil, util.UserVisibleError(codes.InvalidArgument, "missing entity or repository field") }
 if err != nil { return nil, err }
 l := zerolog.Ctx(ctx).With(). Dict("properties", fetchByProps.ToLogDict()). Str("projectID", projectID.String()). Logger() ctx = l.WithContext(ctx)
 newRepo, err := s.repos.CreateRepository(ctx, provider, projectID, fetchByProps) if err != nil { if errors.Is(err, repositories.ErrPrivateRepoForbidden) || errors.Is(err, repositories.ErrArchivedRepoForbidden) { return nil, util.UserVisibleError(codes.InvalidArgument, "%s", err.Error()) } return nil, util.UserVisibleError(codes.Internal, "unable to register repository: %v", err) }
 return &pb.RegisterRepositoryResponse{ Result: &pb.RegisterRepoResult{ Status: &pb.RegisterRepoResult\_Status{ Success: true, }, Repository: newRepo, }, }, nil}
func (s \*Server) repoCreateInfoFromUpstreamRepositoryRef( ctx context.Context, projectID uuid.UUID, providerName string, rep \*pb.UpstreamRepositoryRef,) (\*properties.Properties, \*db.Provider, error) { // If the repo owner is missing, GitHub will assume a default value based // on the user's credentials. An explicit check for owner is left out to // avoid breaking backwards compatibility. if rep.GetName() == "" { return nil, nil, util.UserVisibleError(codes.InvalidArgument, "missing repository name") }
 fetchByProps, err := properties.NewProperties(map[string]any{ properties.PropertyUpstreamID: fmt.Sprintf("%d", rep.GetRepoId()), properties.PropertyName: fmt.Sprintf("%s/%s", rep.GetOwner(), rep.GetName()), }) if err != nil { return nil, nil, fmt.Errorf("error creating properties: %w", err) }
 provider, err := s.inferProviderByOwner(ctx, rep.GetOwner(), projectID, providerName) if err != nil { pErr := providers.ErrProviderNotFoundBy{} if errors.As(err, &pErr) { return nil, nil, util.UserVisibleError(codes.NotFound, "no suitable provider found, please enroll a provider") } return nil, nil, status.Errorf(codes.Internal, "cannot get provider: %v", err) }
 return fetchByProps, provider, nil}
func (s \*Server) repoCreateInfoFromUpstreamEntityRef( ctx context.Context, projectID uuid.UUID, providerName string, entity \*pb.UpstreamEntityRef,) (\*properties.Properties, \*db.Provider, error) { inPropsMap := entity.GetProperties().AsMap() fetchByProps, err := properties.NewProperties(inPropsMap) if err != nil { return nil, nil, fmt.Errorf("error creating properties: %w", err) }
 provider, err := s.providerStore.GetByName(ctx, projectID, providerName) if err != nil { if errors.Is(err, sql.ErrNoRows) { return nil, nil, util.UserVisibleError(codes.NotFound, "provider not found") } return nil, nil, status.Errorf(codes.Internal, "cannot get provider: %v", err) }
 return fetchByProps, provider, nil}
// ListRepositories returns a list of repositories for a given project// This function will typically be called by the client to get a list of// repositories that are registered present in the minder databasefunc (s \*Server) ListRepositories(ctx context.Context, in \*pb.ListRepositoriesRequest) (\*pb.ListRepositoriesResponse, error) { entityCtx := engcontext.EntityFromContext(ctx) projectID := entityCtx.Project.ID providerName := entityCtx.Provider.Name
 logger.BusinessRecord(ctx).Provider = providerName logger.BusinessRecord(ctx).Project = projectID
 providerFilter := getNameFilterParam(providerName)
 reqRepoCursor, err := cursorutil.NewRepoCursor(in.GetCursor()) if err != nil { return nil, util.UserVisibleError(codes.InvalidArgument, "%s", err.Error()) }
 repoId := sql.NullInt64{} if reqRepoCursor.ProjectId == projectID.String() && reqRepoCursor.Provider == providerName { repoId = sql.NullInt64{Valid: true, Int64: reqRepoCursor.RepoId} }
 limit := sql.NullInt64{Valid: false, Int64: 0} reqLimit := in.GetLimit() if reqLimit > 0 { if reqLimit > maxFetchLimit { return nil, util.UserVisibleError(codes.InvalidArgument, "limit too high, max is %d", maxFetchLimit) } limit = sql.NullInt64{Valid: true, Int64: reqLimit + 1} }
 repos, err := s.store.ListRepositoriesByProjectID(ctx, db.ListRepositoriesByProjectIDParams{ Provider: providerFilter, ProjectID: projectID, RepoID: repoId, Limit: limit, })
 if err != nil { return nil, err }
 var resp pb.ListRepositoriesResponse var results []\*pb.Repository
 for \_, repo := range repos { projID := repo.ProjectID.String() r := repositories.PBRepositoryFromDB(repo) r.Context = &pb.Context{ Project: &projID, Provider: &repo.Provider, } results = append(results, r) }
 var respRepoCursor \*cursorutil.RepoCursor if limit.Valid && int64(len(repos)) == limit.Int64 { lastRepo := repos[len(repos)-1] respRepoCursor = &cursorutil.RepoCursor{ ProjectId: projectID.String(), Provider: providerName, RepoId: lastRepo.RepoID, }
 // remove the (limit + 1)th element from the results results = results[:len(results)-1] }
 resp.Results = results resp.Cursor = respRepoCursor.String()
 return &resp, nil}
// GetRepositoryById returns a repository for a given repository idfunc (s \*Server) GetRepositoryById(ctx context.Context, in \*pb.GetRepositoryByIdRequest) (\*pb.GetRepositoryByIdResponse, error) { parsedRepositoryID, err := uuid.Parse(in.RepositoryId) if err != nil { return nil, util.UserVisibleError(codes.InvalidArgument, "invalid repository ID") } projectID := GetProjectID(ctx)
 // read the repository repo, err := s.store.GetRepositoryByIDAndProject(ctx, db.GetRepositoryByIDAndProjectParams{ ID: parsedRepositoryID, ProjectID: projectID, }) if errors.Is(err, sql.ErrNoRows) { return nil, status.Errorf(codes.NotFound, "repository not found") } else if err != nil { return nil, status.Errorf(codes.Internal, "cannot read repository: %v", err) }
 projID := repo.ProjectID.String() r := repositories.PBRepositoryFromDB(repo) r.Context = &pb.Context{ Project: &projID, Provider: &repo.Provider, }
 // Telemetry logging logger.BusinessRecord(ctx).ProviderID = repo.ProviderID logger.BusinessRecord(ctx).Project = repo.ProjectID logger.BusinessRecord(ctx).Repository = repo.ID
 return &pb.GetRepositoryByIdResponse{Repository: r}, nil}
// GetRepositoryByName returns information about a repository.// This function will typically be called by the client to get a// repository which is already registered and present in the minder database// The API is called with a project idfunc (s \*Server) GetRepositoryByName(ctx context.Context, in \*pb.GetRepositoryByNameRequest) (\*pb.GetRepositoryByNameResponse, error) { // split repo name in owner and name fragments := strings.Split(in.Name, "/") if len(fragments) != 2 { return nil, util.UserVisibleError(codes.InvalidArgument, "invalid repository name, needs to have the format: owner/name") }
 entityCtx := engcontext.EntityFromContext(ctx) projectID := entityCtx.Project.ID
 // TODO: move this lookup logic out of the controlplane providerFilter := getNameFilterParam(entityCtx.Provider.Name) repo, err := s.store.GetRepositoryByRepoName(ctx, db.GetRepositoryByRepoNameParams{ Provider: providerFilter, RepoOwner: fragments[0], RepoName: fragments[1], ProjectID: projectID, })
 if errors.Is(err, sql.ErrNoRows) { return nil, status.Errorf(codes.NotFound, "repository not found") } else if err != nil { return nil, err }
 projID := repo.ProjectID.String() r := repositories.PBRepositoryFromDB(repo) r.Context = &pb.Context{ Project: &projID, Provider: &repo.Provider, }
 // Telemetry logging logger.BusinessRecord(ctx).ProviderID = repo.ProviderID logger.BusinessRecord(ctx).Project = repo.ProjectID logger.BusinessRecord(ctx).Repository = repo.ID
 return &pb.GetRepositoryByNameResponse{Repository: r}, nil}
// DeleteRepositoryById deletes a repository by its UUIDfunc (s \*Server) DeleteRepositoryById( ctx context.Context, in \*pb.DeleteRepositoryByIdRequest,) (\*pb.DeleteRepositoryByIdResponse, error) { parsedRepositoryID, err := uuid.Parse(in.RepositoryId) if err != nil { return nil, util.UserVisibleError(codes.InvalidArgument, "invalid repository ID") }
 projectID := GetProjectID(ctx)
 err = s.repos.DeleteByID(ctx, parsedRepositoryID, projectID) if errors.Is(err, sql.ErrNoRows) { return nil, status.Errorf(codes.NotFound, "repository not found") } else if err != nil { return nil, status.Errorf(codes.Internal, "unexpected error deleting repo: %v", err) }
 // return the response with the id of the deleted repository return &pb.DeleteRepositoryByIdResponse{ RepositoryId: in.RepositoryId, }, nil}
// DeleteRepositoryByName deletes a repository by namefunc (s \*Server) DeleteRepositoryByName( ctx context.Context, in \*pb.DeleteRepositoryByNameRequest,) (\*pb.DeleteRepositoryByNameResponse, error) { // split repo name in owner and name fragments := strings.Split(in.Name, "/") if len(fragments) != 2 { return nil, util.UserVisibleError(codes.InvalidArgument, "invalid repository name, needs to have the format: owner/name") }
 projectID := GetProjectID(ctx) providerName := GetProviderName(ctx)
 err := s.repos.DeleteByName(ctx, fragments[0], fragments[1], projectID, providerName) if errors.Is(err, sql.ErrNoRows) { return nil, status.Errorf(codes.NotFound, "repository not found") } else if err != nil { return nil, status.Errorf(codes.Internal, "unexpected error deleting repo: %v", err) }
 // return the response with the name of the deleted repository return &pb.DeleteRepositoryByNameResponse{ Name: in.Name, }, nil}
// ListRemoteRepositoriesFromProvider returns a list of repositories from a providerfunc (s \*Server) ListRemoteRepositoriesFromProvider( ctx context.Context, in \*pb.ListRemoteRepositoriesFromProviderRequest,) (\*pb.ListRemoteRepositoriesFromProviderResponse, error) { entityCtx := engcontext.EntityFromContext(ctx) projectID := entityCtx.Project.ID
 // Telemetry logging logger.BusinessRecord(ctx).Project = projectID
 providerName := in.GetContext().GetProvider() provs, errorProvs, err := s.providerManager.BulkInstantiateByTrait( ctx, projectID, db.ProviderTypeRepoLister, providerName) if err != nil { pErr := providers.ErrProviderNotFoundBy{} if errors.As(err, &pErr) { return nil, util.UserVisibleError(codes.NotFound, "no suitable provider found, please enroll a provider") } return nil, providerError(err) }
 out := &pb.ListRemoteRepositoriesFromProviderResponse{ Results: []\*pb.UpstreamRepositoryRef{}, Entities: []\*pb.RegistrableUpstreamEntityRef{}, }
 for providerID, providerT := range provs { results, err := s.fetchRepositoriesForProvider( ctx, projectID, providerID, providerT.Name, providerT.Provider) if err != nil { zerolog.Ctx(ctx).Error().Err(err). Msgf("error listing repositories for provider %s in project %s", providerT.Name, projectID) errorProvs = append(errorProvs, providerT.Name) continue } for \_, result := range results { out.Results = append(out.Results, result.Repo) out.Entities = append(out.Entities, result.Entity) } }
 // If all providers failed, return an error if len(errorProvs) > 0 && len(out.Results) == 0 { return nil, util.UserVisibleError(codes.Internal, "cannot list repositories for providers: %v", errorProvs) }
 return out, nil}
// fetchRepositoriesForProvider fetches repositories for a given provider//// Returns a list of repositories that with an up-to-date status of whether they are registeredfunc (s \*Server) fetchRepositoriesForProvider( ctx context.Context, projectID uuid.UUID, providerID uuid.UUID, providerName string, provider v1.Provider,) ([]\*UpstreamRepoAndEntityRef, error) { zerolog.Ctx(ctx).Trace(). Str("provider\_id", providerID.String()). Str("project\_id", projectID.String()). Msg("listing repositories")
 repoLister, err := v1.As[v1.RepoLister](provider) if err != nil { zerolog.Ctx(ctx).Error().Err(err).Msg("error instantiating repo lister") return nil, err }
 results, err := s.listRemoteRepositoriesForProvider(ctx, providerName, repoLister, projectID) if err != nil { zerolog.Ctx(ctx).Error().Err(err).Msg("cannot list repositories for provider") return nil, err }
 registeredRepos, err := s.repos.ListRepositories( ctx, projectID, providerID, ) if err != nil { zerolog.Ctx(ctx).Error(). Str("project\_id", projectID.String()). Str("provider\_id", providerID.String()). Err(err).Msg("cannot list registered repositories") return nil, util.UserVisibleError( codes.Internal, "cannot list registered repositories", ) }
 registered := make(map[string]bool) for \_, repo := range registeredRepos { uidP := repo.Properties.GetProperty(properties.PropertyUpstreamID) if uidP == nil { zerolog.Ctx(ctx).Warn(). Str("entity\_id", repo.Entity.ID.String()). Str("entity\_name", repo.Entity.Name). Str("provider\_id", providerID.String()). Str("project\_id", projectID.String()). Msg("repository has no upstream ID") continue } registered[uidP.GetString()] = true }
 for \_, result := range results { uprops := result.Entity.GetEntity().GetProperties() upropsMap := uprops.AsMap() if upropsMap == nil { zerolog.Ctx(ctx).Warn(). Str("provider\_id", providerID.String()). Str("project\_id", projectID.String()). Msg("upstream repository entry has no properties") continue } uidAny, ok := upropsMap[properties.PropertyUpstreamID] if !ok { zerolog.Ctx(ctx).Warn(). Str("provider\_id", providerID.String()). Str("project\_id", projectID.String()). Msg("upstream repository entry has no upstream ID") continue }
 uid, ok := uidAny.(string) if !ok { zerolog.Ctx(ctx).Warn(). Str("provider\_id", providerID.String()). Str("project\_id", projectID.String()). Msg("upstream repository entry has invalid upstream ID") continue }
 result.Repo.Registered = registered[uid] result.Entity.Registered = registered[uid] }
 return results, nil}
func (s \*Server) listRemoteRepositoriesForProvider( ctx context.Context, provName string, repoLister v1.RepoLister, projectID uuid.UUID,) ([]\*UpstreamRepoAndEntityRef, error) { tmoutCtx, cancel := context.WithTimeout(ctx, github.ExpensiveRestCallTimeout) defer cancel()
 remoteRepos, err := repoLister.ListAllRepositories(tmoutCtx) if err != nil { return nil, fmt.Errorf("cannot list repositories: %v", err) }
 allowsPrivateRepos := features.ProjectAllowsPrivateRepos(ctx, s.store, projectID) if !allowsPrivateRepos { zerolog.Ctx(ctx).Info().Msg("filtering out private repositories") } else { zerolog.Ctx(ctx).Info().Msg("including private repositories") }
 results := make([]\*UpstreamRepoAndEntityRef, 0, len(remoteRepos))
 for idx, rem := range remoteRepos { // Skip private repositories if rem.IsPrivate && !allowsPrivateRepos { continue } remoteRepo := remoteRepos[idx]
 var props \*structpb.Struct if remoteRepo.Properties != nil { props = remoteRepo.Properties }
 repo := &UpstreamRepoAndEntityRef{ Repo: &pb.UpstreamRepositoryRef{ Context: &pb.Context{ Provider: &provName, Project: ptr.Ptr(projectID.String()), }, Owner: remoteRepo.Owner, Name: remoteRepo.Name, RepoId: remoteRepo.RepoId, }, Entity: &pb.RegistrableUpstreamEntityRef{ Entity: &pb.UpstreamEntityRef{ Context: &pb.ContextV2{ Provider: provName, ProjectId: projectID.String(), }, Type: pb.Entity\_ENTITY\_REPOSITORIES, Properties: props, }, }, } results = append(results, repo) }
 return results, nil}
// TODO: move out of controlplane// inferProviderByOwner returns the provider to use for a given repo ownerfunc (s \*Server) inferProviderByOwner(ctx context.Context, owner string, projectID uuid.UUID, providerName string,) (\*db.Provider, error) { if providerName != "" { return s.providerStore.GetByName(ctx, projectID, providerName) } opts, err := s.providerStore.GetByTraitInHierarchy(ctx, projectID, providerName, db.ProviderTypeGithub) if err != nil { return nil, fmt.Errorf("error getting providers: %v", err) }
 slices.SortFunc(opts, func(a, b db.Provider) int { // Sort GitHub OAuth provider after all GitHub App providers if a.Class == db.ProviderClassGithub && b.Class == db.ProviderClassGithubApp { return 1 } if a.Class == db.ProviderClassGithubApp && b.Class == db.ProviderClassGithub { return -1 } return 0 })
 for \_, prov := range opts { if github.CanHandleOwner(ctx, prov, owner) { return &prov, nil } }
 return nil, fmt.Errorf("no providers can handle repo owned by %s", owner)}
// UpstreamRepoAndEntityRef is a pair of upstream repository and entity referencestype UpstreamRepoAndEntityRef struct { Repo \*pb.UpstreamRepositoryRef Entity \*pb.RegistrableUpstreamEntityRef}

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

