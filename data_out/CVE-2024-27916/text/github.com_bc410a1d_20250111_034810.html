
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fmindersec%2Fminder%2Fblob%2Fa115c8524fbd582b2b277eaadce024bebbded508%2Finternal%2Fcontrolplane%2Fhandlers_repositories.go)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fmindersec%2Fminder%2Fblob%2Fa115c8524fbd582b2b277eaadce024bebbded508%2Finternal%2Fcontrolplane%2Fhandlers_repositories.go)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=mindersec%2Fminder)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[mindersec](/mindersec)
/
**[minder](/mindersec/minder)**
Public

* [Notifications](/login?return_to=%2Fmindersec%2Fminder) You must be signed in to change notification settings
* [Fork
  41](/login?return_to=%2Fmindersec%2Fminder)
* [Star
   306](/login?return_to=%2Fmindersec%2Fminder)

* [Code](/mindersec/minder)
* [Issues
  127](/mindersec/minder/issues)
* [Pull requests
  11](/mindersec/minder/pulls)
* [Discussions](/mindersec/minder/discussions)
* [Actions](/mindersec/minder/actions)
* [Wiki](/mindersec/minder/wiki)
* [Security](/mindersec/minder/security)
* [Insights](/mindersec/minder/pulse)

Additional navigation options

* [Code](/mindersec/minder)
* [Issues](/mindersec/minder/issues)
* [Pull requests](/mindersec/minder/pulls)
* [Discussions](/mindersec/minder/discussions)
* [Actions](/mindersec/minder/actions)
* [Wiki](/mindersec/minder/wiki)
* [Security](/mindersec/minder/security)
* [Insights](/mindersec/minder/pulse)

## Files

 a115c85
## Breadcrumbs

1. [minder](/mindersec/minder/tree/a115c8524fbd582b2b277eaadce024bebbded508)
2. /[internal](/mindersec/minder/tree/a115c8524fbd582b2b277eaadce024bebbded508/internal)
3. /[controlplane](/mindersec/minder/tree/a115c8524fbd582b2b277eaadce024bebbded508/internal/controlplane)
/
# handlers\_repositories.go

Copy path Blame  Blame
## Latest commit

## History

[History](/mindersec/minder/commits/a115c8524fbd582b2b277eaadce024bebbded508/internal/controlplane/handlers_repositories.go)500 lines (417 loc) · 15.7 KB a115c85
## Breadcrumbs

1. [minder](/mindersec/minder/tree/a115c8524fbd582b2b277eaadce024bebbded508)
2. /[internal](/mindersec/minder/tree/a115c8524fbd582b2b277eaadce024bebbded508/internal)
3. /[controlplane](/mindersec/minder/tree/a115c8524fbd582b2b277eaadce024bebbded508/internal/controlplane)
/
# handlers\_repositories.go

Top
## File metadata and controls

* Code
* Blame

500 lines (417 loc) · 15.7 KB[Raw](https://github.com/mindersec/minder/raw/a115c8524fbd582b2b277eaadce024bebbded508/internal/controlplane/handlers_repositories.go)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500// Copyright 2023 Stacklok, Inc//// Licensed under the Apache License, Version 2.0 (the "License");// you may not use this file except in compliance with the License.// You may obtain a copy of the License at//// http://www.apache.org/licenses/LICENSE-2.0//// Unless required by applicable law or agreed to in writing, software// distributed under the License is distributed on an "AS IS" BASIS,// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.// See the License for the specific language governing permissions and// limitations under the License.
package controlplane
import ( "context" "database/sql" "errors" "strings"
 "github.com/google/uuid" "github.com/rs/zerolog" "github.com/rs/zerolog/log" "google.golang.org/grpc/codes" "google.golang.org/grpc/status"
 "github.com/stacklok/minder/internal/db" "github.com/stacklok/minder/internal/engine" "github.com/stacklok/minder/internal/logger" "github.com/stacklok/minder/internal/providers" github "github.com/stacklok/minder/internal/providers/github" "github.com/stacklok/minder/internal/reconcilers" "github.com/stacklok/minder/internal/util" cursorutil "github.com/stacklok/minder/internal/util/cursor" pb "github.com/stacklok/minder/pkg/api/protobuf/go/minder/v1")
// maxFetchLimit is the maximum number of repositories that can be fetched from the database in one callconst maxFetchLimit = 100
// RegisterRepository adds repositories to the database and registers a webhook// Once a user had enrolled in a project (they have a valid token), they can register// repositories to be monitored by the minder by provisioning a webhook on the// repository(ies).func (s \*Server) RegisterRepository(ctx context.Context, in \*pb.RegisterRepositoryRequest) (\*pb.RegisterRepositoryResponse, error) { entityCtx := engine.EntityFromContext(ctx) projectID := entityCtx.Project.ID
 provider, err := getProviderFromRequestOrDefault(ctx, s.store, in, projectID) if err != nil { return nil, providerError(err) }
 pbOpts := []providers.ProviderBuilderOption{ providers.WithProviderMetrics(s.provMt), providers.WithRestClientCache(s.restClientCache), } p, err := providers.GetProviderBuilder(ctx, provider, projectID, s.store, s.cryptoEngine, pbOpts...) if err != nil { return nil, status.Errorf(codes.Internal, "cannot get provider builder: %v", err) }
 // Unmarshal the in.GetRepositories() into a struct Repository if in.GetRepository() == nil || in.GetRepository().Name == "" { return nil, util.UserVisibleError(codes.InvalidArgument, "no repository provided") }
 repo := in.GetRepository()
 result, err := s.registerWebhookForRepository(ctx, p, projectID, repo) if err != nil { return nil, util.UserVisibleError(codes.Internal, "cannot register webhook: %v", err) }
 r := result.Repository
 response := &pb.RegisterRepositoryResponse{ Result: result, }
 // Convert each result to a pb.Repository object if result.Status.Error != nil { return response, nil }
 // update the database dbRepo, err := s.store.CreateRepository(ctx, db.CreateRepositoryParams{ Provider: provider.Name, ProjectID: projectID, RepoOwner: r.Owner, RepoName: r.Name, RepoID: r.RepoId, IsPrivate: r.IsPrivate, IsFork: r.IsFork, WebhookID: sql.NullInt64{ Int64: r.HookId, Valid: true, }, CloneUrl: r.CloneUrl, WebhookUrl: r.HookUrl, DeployUrl: r.DeployUrl, DefaultBranch: sql.NullString{ String: r.DefaultBranch, Valid: true, }, }) // even if we set the webhook, if we couldn't create it in the database, we'll return an error if err != nil { log.Printf("error creating repository '%s/%s' in database: %v", r.Owner, r.Name, err)
 result.Status.Success = false errorStr := "error creating repository in database" result.Status.Error = &errorStr return response, nil }
 repoDBID := dbRepo.ID.String() r.Id = &repoDBID
 // publish a reconciling event for the registered repositories log.Printf("publishing register event for repository: %s/%s", r.Owner, r.Name)
 msg, err := reconcilers.NewRepoReconcilerMessage(provider.Name, r.RepoId, projectID) if err != nil { log.Printf("error creating reconciler event: %v", err) return response, nil }
 // This is a non-fatal error, so we'll just log it and continue with the next ones if err := s.evt.Publish(reconcilers.InternalReconcilerEventTopic, msg); err != nil { log.Printf("error publishing reconciler event: %v", err) }
 // Telemetry logging logger.BusinessRecord(ctx).Provider = provider.Name logger.BusinessRecord(ctx).Project = projectID logger.BusinessRecord(ctx).Repository = dbRepo.ID
 return response, nil}
// ListRepositories returns a list of repositories for a given project// This function will typically be called by the client to get a list of// repositories that are registered present in the minder databasefunc (s \*Server) ListRepositories(ctx context.Context, in \*pb.ListRepositoriesRequest) (\*pb.ListRepositoriesResponse, error) { entityCtx := engine.EntityFromContext(ctx) projectID := entityCtx.Project.ID
 provider, err := getProviderFromRequestOrDefault(ctx, s.store, in, projectID) if err != nil { return nil, providerError(err) }
 reqRepoCursor, err := cursorutil.NewRepoCursor(in.GetCursor()) if err != nil { return nil, util.UserVisibleError(codes.InvalidArgument, err.Error()) }
 repoId := sql.NullInt64{} if reqRepoCursor.ProjectId == projectID.String() && reqRepoCursor.Provider == provider.Name { repoId = sql.NullInt64{Valid: true, Int64: reqRepoCursor.RepoId} }
 limit := sql.NullInt32{Valid: false, Int32: 0} reqLimit := in.GetLimit() if reqLimit > 0 { if reqLimit > maxFetchLimit { return nil, util.UserVisibleError(codes.InvalidArgument, "limit too high, max is %d", maxFetchLimit) } limit = sql.NullInt32{Valid: true, Int32: reqLimit + 1} }
 repos, err := s.store.ListRepositoriesByProjectID(ctx, db.ListRepositoriesByProjectIDParams{ Provider: provider.Name, ProjectID: projectID, RepoID: repoId, Limit: limit, })
 if err != nil { return nil, err }
 var resp pb.ListRepositoriesResponse var results []\*pb.Repository
 for \_, repo := range repos { repo := repo
 projID := repo.ProjectID.String() r := util.PBRepositoryFromDB(repo) r.Context = &pb.Context{ Project: &projID, Provider: &repo.Provider, } results = append(results, r) }
 var respRepoCursor \*cursorutil.RepoCursor if limit.Valid && len(repos) == int(limit.Int32) { lastRepo := repos[len(repos)-1] respRepoCursor = &cursorutil.RepoCursor{ ProjectId: projectID.String(), Provider: provider.Name, RepoId: lastRepo.RepoID, }
 // remove the (limit + 1)th element from the results results = results[:len(results)-1] }
 resp.Results = results resp.Cursor = respRepoCursor.String()
 // Telemetry logging logger.BusinessRecord(ctx).Provider = provider.Name logger.BusinessRecord(ctx).Project = projectID
 return &resp, nil}
// GetRepositoryById returns a repository for a given repository idfunc (s \*Server) GetRepositoryById(ctx context.Context, in \*pb.GetRepositoryByIdRequest) (\*pb.GetRepositoryByIdResponse, error) { parsedRepositoryID, err := uuid.Parse(in.RepositoryId) if err != nil { return nil, util.UserVisibleError(codes.InvalidArgument, "invalid repository ID") }
 // read the repository repo, err := s.store.GetRepositoryByID(ctx, parsedRepositoryID) if errors.Is(err, sql.ErrNoRows) { return nil, status.Errorf(codes.NotFound, "repository not found") } else if err != nil { return nil, status.Errorf(codes.Internal, "cannot read repository: %v", err) }
 projID := repo.ProjectID.String() r := util.PBRepositoryFromDB(repo) r.Context = &pb.Context{ Project: &projID, Provider: &repo.Provider, }
 // Telemetry logging logger.BusinessRecord(ctx).Provider = repo.Provider logger.BusinessRecord(ctx).Project = repo.ProjectID logger.BusinessRecord(ctx).Repository = repo.ID
 return &pb.GetRepositoryByIdResponse{Repository: r}, nil}
// GetRepositoryByName returns information about a repository.// This function will typically be called by the client to get a// repository which is already registered and present in the minder database// The API is called with a project idfunc (s \*Server) GetRepositoryByName(ctx context.Context, in \*pb.GetRepositoryByNameRequest) (\*pb.GetRepositoryByNameResponse, error) { // split repo name in owner and name fragments := strings.Split(in.Name, "/") if len(fragments) != 2 { return nil, util.UserVisibleError(codes.InvalidArgument, "invalid repository name, needs to have the format: owner/name") }
 entityCtx := engine.EntityFromContext(ctx) projectID := entityCtx.Project.ID
 provider, err := getProviderFromRequestOrDefault(ctx, s.store, in, projectID) if err != nil { return nil, providerError(err) }
 repo, err := s.store.GetRepositoryByRepoName(ctx, db.GetRepositoryByRepoNameParams{Provider: provider.Name, RepoOwner: fragments[0], RepoName: fragments[1]})
 if errors.Is(err, sql.ErrNoRows) { return nil, status.Errorf(codes.NotFound, "repository not found") } else if err != nil { return nil, err }
 projID := repo.ProjectID.String() r := util.PBRepositoryFromDB(repo) r.Context = &pb.Context{ Project: &projID, Provider: &repo.Provider, }
 // Telemetry logging logger.BusinessRecord(ctx).Provider = repo.Provider logger.BusinessRecord(ctx).Project = repo.ProjectID logger.BusinessRecord(ctx).Repository = repo.ID
 return &pb.GetRepositoryByNameResponse{Repository: r}, nil}
// DeleteRepositoryById deletes a repository by namefunc (s \*Server) DeleteRepositoryById(ctx context.Context, in \*pb.DeleteRepositoryByIdRequest) (\*pb.DeleteRepositoryByIdResponse, error) { parsedRepositoryID, err := uuid.Parse(in.RepositoryId) if err != nil { return nil, util.UserVisibleError(codes.InvalidArgument, "invalid repository ID") }
 // read the repository repo, err := s.store.GetRepositoryByID(ctx, parsedRepositoryID) if errors.Is(err, sql.ErrNoRows) { return nil, status.Errorf(codes.NotFound, "repository not found") } else if err != nil { return nil, status.Errorf(codes.Internal, "cannot read repository: %v", err) }
 provider, err := getProviderFromRequestOrDefault(ctx, s.store, in, repo.ProjectID) if err != nil { return nil, providerError(err) }
 err = s.deleteRepositoryAndWebhook(ctx, repo, repo.ProjectID, provider) if err != nil { return nil, err }
 // Telemetry logging logger.BusinessRecord(ctx).Provider = repo.Provider logger.BusinessRecord(ctx).Project = repo.ProjectID logger.BusinessRecord(ctx).Repository = repo.ID
 // return the response with the id of the deleted repository return &pb.DeleteRepositoryByIdResponse{ RepositoryId: in.RepositoryId, }, nil}
// DeleteRepositoryByName deletes a repository by namefunc (s \*Server) DeleteRepositoryByName(ctx context.Context, in \*pb.DeleteRepositoryByNameRequest) (\*pb.DeleteRepositoryByNameResponse, error) { // split repo name in owner and name fragments := strings.Split(in.Name, "/") if len(fragments) != 2 { return nil, util.UserVisibleError(codes.InvalidArgument, "invalid repository name, needs to have the format: owner/name") }
 entityCtx := engine.EntityFromContext(ctx) projectID := entityCtx.Project.ID
 provider, err := getProviderFromRequestOrDefault(ctx, s.store, in, projectID) if err != nil { return nil, providerError(err) }
 repo, err := s.store.GetRepositoryByRepoName(ctx, db.GetRepositoryByRepoNameParams{Provider: provider.Name, RepoOwner: fragments[0], RepoName: fragments[1]})
 if errors.Is(err, sql.ErrNoRows) { return nil, status.Errorf(codes.NotFound, "repository not found") } else if err != nil { return nil, err } err = s.deleteRepositoryAndWebhook(ctx, repo, projectID, provider) if err != nil { return nil, err }
 // Telemetry logging logger.BusinessRecord(ctx).Provider = repo.Provider logger.BusinessRecord(ctx).Project = repo.ProjectID logger.BusinessRecord(ctx).Repository = repo.ID
 // return the response with the name of the deleted repository return &pb.DeleteRepositoryByNameResponse{ Name: in.Name, }, nil}
// ListRemoteRepositoriesFromProvider returns a list of repositories from a providerfunc (s \*Server) ListRemoteRepositoriesFromProvider( ctx context.Context, in \*pb.ListRemoteRepositoriesFromProviderRequest,) (\*pb.ListRemoteRepositoriesFromProviderResponse, error) { entityCtx := engine.EntityFromContext(ctx) projectID := entityCtx.Project.ID
 provider, err := getProviderFromRequestOrDefault(ctx, s.store, in, projectID) if err != nil { return nil, providerError(err) }
 zerolog.Ctx(ctx).Debug(). Str("provider", provider.Name). Str("projectID", projectID.String()). Msg("listing repositories")
 // FIXME: this is a hack to get the owner filter from the request \_, owner\_filter, err := s.getProviderAccessToken(ctx, provider.Name, projectID)
 if err != nil { return nil, util.UserVisibleError(codes.PermissionDenied, "cannot get access token for provider: did you run `minder provider enroll`?") }
 pbOpts := []providers.ProviderBuilderOption{ providers.WithProviderMetrics(s.provMt), providers.WithRestClientCache(s.restClientCache), } p, err := providers.GetProviderBuilder(ctx, provider, projectID, s.store, s.cryptoEngine, pbOpts...) if err != nil { return nil, status.Errorf(codes.Internal, "cannot get provider builder: %v", err) }
 if !p.Implements(db.ProviderTypeRepoLister) { return nil, util.UserVisibleError(codes.Unimplemented, "provider does not implement repository listing") }
 client, err := p.GetRepoLister() if err != nil { return nil, status.Errorf(codes.Internal, "cannot create github client: %v", err) }
 tmoutCtx, cancel := context.WithTimeout(ctx, github.ExpensiveRestCallTimeout) defer cancel()
 var remoteRepos []\*pb.Repository isOrg := (owner\_filter != "") if isOrg { zerolog.Ctx(ctx).Debug().Msgf("listing repositories for organization") remoteRepos, err = client.ListOrganizationRepsitories(tmoutCtx, owner\_filter) if err != nil { return nil, util.UserVisibleError(codes.Internal, "cannot list repositories: %v", err) } } else { zerolog.Ctx(ctx).Debug().Msgf("listing repositories for the user") remoteRepos, err = client.ListUserRepositories(tmoutCtx, owner\_filter) if err != nil { return nil, util.UserVisibleError(codes.Internal, "cannot list repositories: %v", err) } }
 out := &pb.ListRemoteRepositoriesFromProviderResponse{ Results: make([]\*pb.UpstreamRepositoryRef, 0, len(remoteRepos)), }
 allowsPrivateRepos := projectAllowsPrivateRepos(ctx, s.store, projectID) if !allowsPrivateRepos { zerolog.Ctx(ctx).Info().Msg("filtering out private repositories") } else { zerolog.Ctx(ctx).Info().Msg("including private repositories") }
 for idx, rem := range remoteRepos { // Skip private repositories if rem.IsPrivate && !allowsPrivateRepos { continue } remoteRepo := remoteRepos[idx] repo := &pb.UpstreamRepositoryRef{ Owner: remoteRepo.Owner, Name: remoteRepo.Name, RepoId: remoteRepo.RepoId, } out.Results = append(out.Results, repo) }
 // Telemetry logging logger.BusinessRecord(ctx).Provider = provider.Name logger.BusinessRecord(ctx).Project = projectID
 return out, nil}
func (s \*Server) deleteRepositoryAndWebhook( ctx context.Context, repo db.Repository, projectID uuid.UUID, provider db.Provider,) error { tx, err := s.store.BeginTransaction() if err != nil { return status.Errorf(codes.Internal, "error deleting repository") } defer s.store.Rollback(tx)
 qtx := s.store.GetQuerierWithTransaction(tx) if err := qtx.DeleteRepository(ctx, repo.ID); err != nil { return status.Errorf(codes.Internal, "error deleting repository: %v", err) }
 if err := s.deleteWebhookFromRepository(ctx, provider, projectID, repo); err != nil { return err }
 if err := s.store.Commit(tx); err != nil { return status.Errorf(codes.Internal, "error deleting repository") }
 return nil}

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

