=== Content from git.kernel.org_216fe423_20250111_112513.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=531dc6780d94245af037c25c2371c8caf652f0f9)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=531dc6780d94245af037c25c2371c8caf652f0f9)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=531dc6780d94245af037c25c2371c8caf652f0f9)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=531dc6780d94245af037c25c2371c8caf652f0f9)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Steven Rostedt <rostedt@goodmis.org> | 2024-07-30 11:06:57 -0400 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-08-14 15:34:33 +0200 |
| commit | [531dc6780d94245af037c25c2371c8caf652f0f9](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=531dc6780d94245af037c25c2371c8caf652f0f9) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=531dc6780d94245af037c25c2371c8caf652f0f9)) | |
| tree | [69bc3c78c908a66bcc1a81b26cb08a564ae0c9ab](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=531dc6780d94245af037c25c2371c8caf652f0f9) | |
| parent | [230ebcdfb3faee1a4f41bdfb6bb2a58fcdb6d14a](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=230ebcdfb3faee1a4f41bdfb6bb2a58fcdb6d14a) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=531dc6780d94245af037c25c2371c8caf652f0f9&id2=230ebcdfb3faee1a4f41bdfb6bb2a58fcdb6d14a)) | |
| download | [linux-531dc6780d94245af037c25c2371c8caf652f0f9.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-531dc6780d94245af037c25c2371c8caf652f0f9.tar.gz) | |

tracing: Have format file honor EVENT\_FILE\_FL\_FREEDcommit b1560408692cd0ab0370cfbe9deb03ce97ab3f6d upstream.
When eventfs was introduced, special care had to be done to coordinate the
freeing of the file meta data with the files that are exposed to user
space. The file meta data would have a ref count that is set when the file
is created and would be decremented and freed after the last user that
opened the file closed it. When the file meta data was to be freed, it
would set a flag (EVENT\_FILE\_FL\_FREED) to denote that the file is freed,
and any new references made (like new opens or reads) would fail as it is
marked freed. This allowed other meta data to be freed after this flag was
set (under the event\_mutex).
All the files that were dynamically created in the events directory had a
pointer to the file meta data and would call event\_release() when the last
reference to the user space file was closed. This would be the time that it
is safe to free the file meta data.
A shortcut was made for the "format" file. It's i\_private would point to
the "call" entry directly and not point to the file's meta data. This is
because all format files are the same for the same "call", so it was
thought there was no reason to differentiate them. The other files
maintain state (like the "enable", "trigger", etc). But this meant if the
file were to disappear, the "format" file would be unaware of it.
This caused a race that could be trigger via the user\_events test (that
would create dynamic events and free them), and running a loop that would
read the user\_events format files:
In one console run:
# cd tools/testing/selftests/user\_events
# while true; do ./ftrace\_test; done
And in another console run:
# cd /sys/kernel/tracing/
# while true; do cat events/user\_events/\_\_test\_event/format; done 2>/dev/null
With KASAN memory checking, it would trigger a use-after-free bug report
(which was a real bug). This was because the format file was not checking
the file's meta data flag "EVENT\_FILE\_FL\_FREED", so it would access the
event that the file meta data pointed to after the event was freed.
After inspection, there are other locations that were found to not check
the EVENT\_FILE\_FL\_FREED flag when accessing the trace\_event\_file. Add a
new helper function: event\_file\_file() that will make sure that the
event\_mutex is held, and will return NULL if the trace\_event\_file has the
EVENT\_FILE\_FL\_FREED flag set. Have the first reference of the struct file
pointer use event\_file\_file() and check for NULL. Later uses can still use
the event\_file\_data() helper function if the event\_mutex is still held and
was not released since the event\_file\_file() call.
Link: [https://lore.kernel.org/all/20240719204701.1605950-1-minipli@grsecurity.net/](https://lore.kernel.org/all/20240719204701.1605950-1-minipli%40grsecurity.net/)
Cc: stable@vger.kernel.org
Cc: Masami Hiramatsu <mhiramat@kernel.org>
Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Cc: Ajay Kaher <ajay.kaher@broadcom.com>
Cc: Ilkka Naulapää <digirigawa@gmail.com>
Cc: Linus Torvalds <torvalds@linux-foundation.org>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Cc: Dan Carpenter <dan.carpenter@linaro.org>
Cc: Beau Belgrave <beaub@linux.microsoft.com>
Cc: Florian Fainelli <florian.fainelli@broadcom.com>
Cc: Alexey Makhalov <alexey.makhalov@broadcom.com>
Cc: Vasavi Sirnapalli <vasavi.sirnapalli@broadcom.com>
Link: [https://lore.kernel.org/20240730110657.3b69d3c1@gandalf.local.home](https://lore.kernel.org/20240730110657.3b69d3c1%40gandalf.local.home)
Fixes: b63db58e2fa5d ("eventfs/tracing: Add callback for release of an eventfs\_inode")
Reported-by: Mathias Krause <minipli@grsecurity.net>
Tested-by: Mathias Krause <minipli@grsecurity.net>
Signed-off-by: Steven Rostedt (Google) <rostedt@goodmis.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=531dc6780d94245af037c25c2371c8caf652f0f9)

| -rw-r--r-- | [kernel/trace/trace.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/trace/trace.h?id=531dc6780d94245af037c25c2371c8caf652f0f9) | 23 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [kernel/trace/trace\_events.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/trace/trace_events.c?id=531dc6780d94245af037c25c2371c8caf652f0f9) | 33 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/trace/trace\_events\_hist.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/trace/trace_events_hist.c?id=531dc6780d94245af037c25c2371c8caf652f0f9) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/trace/trace\_events\_inject.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/trace/trace_events_inject.c?id=531dc6780d94245af037c25c2371c8caf652f0f9) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/trace/trace\_events\_trigger.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/trace/trace_events_trigger.c?id=531dc6780d94245af037c25c2371c8caf652f0f9) | 6 | |  |  |  | | --- | --- | --- | |

5 files changed, 49 insertions, 19 deletions

| diff --git a/kernel/trace/trace.h b/kernel/trace/trace.hindex 749a182dab480c..8edab43580d5a9 100644--- a/[kernel/trace/trace.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace.h?id=230ebcdfb3faee1a4f41bdfb6bb2a58fcdb6d14a)+++ b/[kernel/trace/trace.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace.h?id=531dc6780d94245af037c25c2371c8caf652f0f9)@@ -1573,6 +1573,29 @@ static inline void \*event\_file\_data(struct file \*filp) extern struct mutex event\_mutex; extern struct list\_head ftrace\_events; +/\*+ \* When the trace\_event\_file is the filp->i\_private pointer,+ \* it must be taken under the event\_mutex lock, and then checked+ \* if the EVENT\_FILE\_FL\_FREED flag is set. If it is, then the+ \* data pointed to by the trace\_event\_file can not be trusted.+ \*+ \* Use the event\_file\_file() to access the trace\_event\_file from+ \* the filp the first time under the event\_mutex and check for+ \* NULL. If it is needed to be retrieved again and the event\_mutex+ \* is still held, then the event\_file\_data() can be used and it+ \* is guaranteed to be valid.+ \*/+static inline struct trace\_event\_file \*event\_file\_file(struct file \*filp)+{+ struct trace\_event\_file \*file;++ lockdep\_assert\_held(&event\_mutex);+ file = READ\_ONCE(file\_inode(filp)->i\_private);+ if (!file || file->flags & EVENT\_FILE\_FL\_FREED)+ return NULL;+ return file;+}+ extern const struct file\_operations event\_trigger\_fops; extern const struct file\_operations event\_hist\_fops; extern const struct file\_operations event\_hist\_debug\_fops;diff --git a/kernel/trace/trace\_events.c b/kernel/trace/trace\_events.cindex 6ef29eba90ceb7..f08fbaf8cad676 100644--- a/[kernel/trace/trace\_events.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace_events.c?id=230ebcdfb3faee1a4f41bdfb6bb2a58fcdb6d14a)+++ b/[kernel/trace/trace\_events.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace_events.c?id=531dc6780d94245af037c25c2371c8caf652f0f9)@@ -1386,12 +1386,12 @@ event\_enable\_read(struct file \*filp, char \_\_user \*ubuf, size\_t cnt, char buf[4] = "0";  mutex\_lock(&event\_mutex);- file = event\_file\_data(filp);+ file = event\_file\_file(filp); if (likely(file)) flags = file->flags; mutex\_unlock(&event\_mutex); - if (!file || flags & EVENT\_FILE\_FL\_FREED)+ if (!file) return -ENODEV;  if (flags & EVENT\_FILE\_FL\_ENABLED &&@@ -1424,8 +1424,8 @@ event\_enable\_write(struct file \*filp, const char \_\_user \*ubuf, size\_t cnt, case 1: ret = -ENODEV; mutex\_lock(&event\_mutex);- file = event\_file\_data(filp);- if (likely(file && !(file->flags & EVENT\_FILE\_FL\_FREED))) {+ file = event\_file\_file(filp);+ if (likely(file)) { ret = tracing\_update\_buffers(file->tr); if (ret < 0) { mutex\_unlock(&event\_mutex);@@ -1540,7 +1540,8 @@ enum {  static void \*f\_next(struct seq\_file \*m, void \*v, loff\_t \*pos) {- struct trace\_event\_call \*call = event\_file\_data(m->private);+ struct trace\_event\_file \*file = event\_file\_data(m->private);+ struct trace\_event\_call \*call = file->event\_call; struct list\_head \*common\_head = &ftrace\_common\_fields; struct list\_head \*head = trace\_get\_fields(call); struct list\_head \*node = v;@@ -1572,7 +1573,8 @@ static void \*f\_next(struct seq\_file \*m, void \*v, loff\_t \*pos)  static int f\_show(struct seq\_file \*m, void \*v) {- struct trace\_event\_call \*call = event\_file\_data(m->private);+ struct trace\_event\_file \*file = event\_file\_data(m->private);+ struct trace\_event\_call \*call = file->event\_call; struct ftrace\_event\_field \*field; const char \*array\_descriptor; @@ -1627,12 +1629,14 @@ static int f\_show(struct seq\_file \*m, void \*v)  static void \*f\_start(struct seq\_file \*m, loff\_t \*pos) {+ struct trace\_event\_file \*file; void \*p = (void \*)FORMAT\_HEADER; loff\_t l = 0;  /\* ->stop() is called even if ->start() fails \*/ mutex\_lock(&event\_mutex);- if (!event\_file\_data(m->private))+ file = event\_file\_file(m->private);+ if (!file) return ERR\_PTR(-ENODEV);  while (l < \*pos && p)@@ -1706,8 +1710,8 @@ event\_filter\_read(struct file \*filp, char \_\_user \*ubuf, size\_t cnt, trace\_seq\_init(s);  mutex\_lock(&event\_mutex);- file = event\_file\_data(filp);- if (file && !(file->flags & EVENT\_FILE\_FL\_FREED))+ file = event\_file\_file(filp);+ if (file) print\_event\_filter(file, s); mutex\_unlock(&event\_mutex); @@ -1736,9 +1740,13 @@ event\_filter\_write(struct file \*filp, const char \_\_user \*ubuf, size\_t cnt, return PTR\_ERR(buf);  mutex\_lock(&event\_mutex);- file = event\_file\_data(filp);- if (file)- err = apply\_event\_filter(file, buf);+ file = event\_file\_file(filp);+ if (file) {+ if (file->flags & EVENT\_FILE\_FL\_FREED)+ err = -ENODEV;+ else+ err = apply\_event\_filter(file, buf);+ } mutex\_unlock(&event\_mutex);  kfree(buf);@@ -2485,7 +2493,6 @@ static int event\_callback(const char \*name, umode\_t \*mode, void \*\*data, if (strcmp(name, "format") == 0) { \*mode = TRACE\_MODE\_READ; \*fops = &ftrace\_event\_format\_fops;- \*data = call; return 1; } diff --git a/kernel/trace/trace\_events\_hist.c b/kernel/trace/trace\_events\_hist.cindex 6ece1308d36a02..5f9119eb7c67f6 100644--- a/[kernel/trace/trace\_events\_hist.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace_events_hist.c?id=230ebcdfb3faee1a4f41bdfb6bb2a58fcdb6d14a)+++ b/[kernel/trace/trace\_events\_hist.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace_events_hist.c?id=531dc6780d94245af037c25c2371c8caf652f0f9)@@ -5601,7 +5601,7 @@ static int hist\_show(struct seq\_file \*m, void \*v)  mutex\_lock(&event\_mutex); - event\_file = event\_file\_data(m->private);+ event\_file = event\_file\_file(m->private); if (unlikely(!event\_file)) { ret = -ENODEV; goto out\_unlock;@@ -5880,7 +5880,7 @@ static int hist\_debug\_show(struct seq\_file \*m, void \*v)  mutex\_lock(&event\_mutex); - event\_file = event\_file\_data(m->private);+ event\_file = event\_file\_file(m->private); if (unlikely(!event\_file)) { ret = -ENODEV; goto out\_unlock;diff --git a/kernel/trace/trace\_events\_inject.c b/kernel/trace/trace\_events\_inject.cindex 8650562bdaa988..a8f076809db4d5 100644--- a/[kernel/trace/trace\_events\_inject.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace_events_inject.c?id=230ebcdfb3faee1a4f41bdfb6bb2a58fcdb6d14a)+++ b/[kernel/trace/trace\_events\_inject.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace_events_inject.c?id=531dc6780d94245af037c25c2371c8caf652f0f9)@@ -299,7 +299,7 @@ event\_inject\_write(struct file \*filp, const char \_\_user \*ubuf, size\_t cnt, strim(buf);  mutex\_lock(&event\_mutex);- file = event\_file\_data(filp);+ file = event\_file\_file(filp); if (file) { call = file->event\_call; size = parse\_entry(buf, call, &entry);diff --git a/kernel/trace/trace\_events\_trigger.c b/kernel/trace/trace\_events\_trigger.cindex 4bec043c8690d3..a5e3d6acf1e1e2 100644--- a/[kernel/trace/trace\_events\_trigger.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace_events_trigger.c?id=230ebcdfb3faee1a4f41bdfb6bb2a58fcdb6d14a)+++ b/[kernel/trace/trace\_events\_trigger.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace_events_trigger.c?id=531dc6780d94245af037c25c2371c8caf652f0f9)@@ -159,7 +159,7 @@ static void \*trigger\_start(struct seq\_file \*m, loff\_t \*pos)  /\* ->stop() is called even if ->start() fails \*/ mutex\_lock(&event\_mutex);- event\_file = event\_file\_data(m->private);+ event\_file = event\_file\_file(m->private); if (unlikely(!event\_file)) return ERR\_PTR(-ENODEV); @@ -213,7 +213,7 @@ static int event\_trigger\_regex\_open(struct inode \*inode, struct file \*file)  mutex\_lock(&event\_mutex); - if (unlikely(!event\_file\_data(file))) {+ if (unlikely(!event\_file\_file(file))) { mutex\_unlock(&event\_mutex); return -ENODEV; }@@ -293,7 +293,7 @@ static ssize\_t event\_trigger\_regex\_write(struct file \*file, strim(buf);  mutex\_lock(&event\_mutex);- event\_file = event\_file\_data(file);+ event\_file = event\_file\_file(file); if (unlikely(!event\_file)) { mutex\_unlock(&event\_mutex); kfree(buf); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 10:57:18 +0000



=== Content from git.kernel.org_0d4f02f9_20250111_112513.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=4ed03758ddf0b19d69eed69386d65a92d0091e0c)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=4ed03758ddf0b19d69eed69386d65a92d0091e0c)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=4ed03758ddf0b19d69eed69386d65a92d0091e0c)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=4ed03758ddf0b19d69eed69386d65a92d0091e0c)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Steven Rostedt <rostedt@goodmis.org> | 2024-07-30 11:06:57 -0400 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-09-04 13:28:22 +0200 |
| commit | [4ed03758ddf0b19d69eed69386d65a92d0091e0c](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=4ed03758ddf0b19d69eed69386d65a92d0091e0c) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=4ed03758ddf0b19d69eed69386d65a92d0091e0c)) | |
| tree | [0b9d5e47db580c53d3449584b0e90bc85a55851f](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=4ed03758ddf0b19d69eed69386d65a92d0091e0c) | |
| parent | [9a9716bbbf3dd6b6cbefba3abcc89af8b72631f4](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9a9716bbbf3dd6b6cbefba3abcc89af8b72631f4) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=4ed03758ddf0b19d69eed69386d65a92d0091e0c&id2=9a9716bbbf3dd6b6cbefba3abcc89af8b72631f4)) | |
| download | [linux-4ed03758ddf0b19d69eed69386d65a92d0091e0c.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-4ed03758ddf0b19d69eed69386d65a92d0091e0c.tar.gz) | |

tracing: Have format file honor EVENT\_FILE\_FL\_FREEDcommit b1560408692cd0ab0370cfbe9deb03ce97ab3f6d upstream.
When eventfs was introduced, special care had to be done to coordinate the
freeing of the file meta data with the files that are exposed to user
space. The file meta data would have a ref count that is set when the file
is created and would be decremented and freed after the last user that
opened the file closed it. When the file meta data was to be freed, it
would set a flag (EVENT\_FILE\_FL\_FREED) to denote that the file is freed,
and any new references made (like new opens or reads) would fail as it is
marked freed. This allowed other meta data to be freed after this flag was
set (under the event\_mutex).
All the files that were dynamically created in the events directory had a
pointer to the file meta data and would call event\_release() when the last
reference to the user space file was closed. This would be the time that it
is safe to free the file meta data.
A shortcut was made for the "format" file. It's i\_private would point to
the "call" entry directly and not point to the file's meta data. This is
because all format files are the same for the same "call", so it was
thought there was no reason to differentiate them. The other files
maintain state (like the "enable", "trigger", etc). But this meant if the
file were to disappear, the "format" file would be unaware of it.
This caused a race that could be trigger via the user\_events test (that
would create dynamic events and free them), and running a loop that would
read the user\_events format files:
In one console run:
# cd tools/testing/selftests/user\_events
# while true; do ./ftrace\_test; done
And in another console run:
# cd /sys/kernel/tracing/
# while true; do cat events/user\_events/\_\_test\_event/format; done 2>/dev/null
With KASAN memory checking, it would trigger a use-after-free bug report
(which was a real bug). This was because the format file was not checking
the file's meta data flag "EVENT\_FILE\_FL\_FREED", so it would access the
event that the file meta data pointed to after the event was freed.
After inspection, there are other locations that were found to not check
the EVENT\_FILE\_FL\_FREED flag when accessing the trace\_event\_file. Add a
new helper function: event\_file\_file() that will make sure that the
event\_mutex is held, and will return NULL if the trace\_event\_file has the
EVENT\_FILE\_FL\_FREED flag set. Have the first reference of the struct file
pointer use event\_file\_file() and check for NULL. Later uses can still use
the event\_file\_data() helper function if the event\_mutex is still held and
was not released since the event\_file\_file() call.
Link: [https://lore.kernel.org/all/20240719204701.1605950-1-minipli@grsecurity.net/](https://lore.kernel.org/all/20240719204701.1605950-1-minipli%40grsecurity.net/)
Cc: stable@vger.kernel.org
Cc: Masami Hiramatsu <mhiramat@kernel.org>
Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Cc: Ajay Kaher <ajay.kaher@broadcom.com>
Cc: Ilkka Naulapää <digirigawa@gmail.com>
Cc: Linus Torvalds <torvalds@linux-foundation.org>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Cc: Dan Carpenter <dan.carpenter@linaro.org>
Cc: Beau Belgrave <beaub@linux.microsoft.com>
Cc: Florian Fainelli <florian.fainelli@broadcom.com>
Cc: Alexey Makhalov <alexey.makhalov@broadcom.com>
Cc: Vasavi Sirnapalli <vasavi.sirnapalli@broadcom.com>
Link: [https://lore.kernel.org/20240730110657.3b69d3c1@gandalf.local.home](https://lore.kernel.org/20240730110657.3b69d3c1%40gandalf.local.home)
Fixes: b63db58e2fa5d ("eventfs/tracing: Add callback for release of an eventfs\_inode")
Reported-by: Mathias Krause <minipli@grsecurity.net>
Tested-by: Mathias Krause <minipli@grsecurity.net>
Signed-off-by: Steven Rostedt (Google) <rostedt@goodmis.org>
[Resolve conflict due to lack of commit a1f157c7a3bb ("tracing: Expand all
ring buffers individually") which add tracing\_update\_buffers() in
event\_enable\_write(), that commit is more of a feature than a bugfix
and is not related to the problem fixed by this patch]
Signed-off-by: Zheng Yejian <zhengyejian@huaweicloud.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=4ed03758ddf0b19d69eed69386d65a92d0091e0c)

| -rw-r--r-- | [kernel/trace/trace.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/trace/trace.h?id=4ed03758ddf0b19d69eed69386d65a92d0091e0c) | 23 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [kernel/trace/trace\_events.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/trace/trace_events.c?id=4ed03758ddf0b19d69eed69386d65a92d0091e0c) | 33 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/trace/trace\_events\_hist.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/trace/trace_events_hist.c?id=4ed03758ddf0b19d69eed69386d65a92d0091e0c) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/trace/trace\_events\_inject.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/trace/trace_events_inject.c?id=4ed03758ddf0b19d69eed69386d65a92d0091e0c) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/trace/trace\_events\_trigger.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/trace/trace_events_trigger.c?id=4ed03758ddf0b19d69eed69386d65a92d0091e0c) | 6 | |  |  |  | | --- | --- | --- | |

5 files changed, 49 insertions, 19 deletions

| diff --git a/kernel/trace/trace.h b/kernel/trace/trace.hindex 02b727a54648fc..3db42bae73f8e0 100644--- a/[kernel/trace/trace.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace.h?id=9a9716bbbf3dd6b6cbefba3abcc89af8b72631f4)+++ b/[kernel/trace/trace.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace.h?id=4ed03758ddf0b19d69eed69386d65a92d0091e0c)@@ -1555,6 +1555,29 @@ static inline void \*event\_file\_data(struct file \*filp) extern struct mutex event\_mutex; extern struct list\_head ftrace\_events; +/\*+ \* When the trace\_event\_file is the filp->i\_private pointer,+ \* it must be taken under the event\_mutex lock, and then checked+ \* if the EVENT\_FILE\_FL\_FREED flag is set. If it is, then the+ \* data pointed to by the trace\_event\_file can not be trusted.+ \*+ \* Use the event\_file\_file() to access the trace\_event\_file from+ \* the filp the first time under the event\_mutex and check for+ \* NULL. If it is needed to be retrieved again and the event\_mutex+ \* is still held, then the event\_file\_data() can be used and it+ \* is guaranteed to be valid.+ \*/+static inline struct trace\_event\_file \*event\_file\_file(struct file \*filp)+{+ struct trace\_event\_file \*file;++ lockdep\_assert\_held(&event\_mutex);+ file = READ\_ONCE(file\_inode(filp)->i\_private);+ if (!file || file->flags & EVENT\_FILE\_FL\_FREED)+ return NULL;+ return file;+}+ extern const struct file\_operations event\_trigger\_fops; extern const struct file\_operations event\_hist\_fops; extern const struct file\_operations event\_hist\_debug\_fops;diff --git a/kernel/trace/trace\_events.c b/kernel/trace/trace\_events.cindex 2ae0f2807438a2..c68dc50c8becfb 100644--- a/[kernel/trace/trace\_events.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace_events.c?id=9a9716bbbf3dd6b6cbefba3abcc89af8b72631f4)+++ b/[kernel/trace/trace\_events.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace_events.c?id=4ed03758ddf0b19d69eed69386d65a92d0091e0c)@@ -1386,12 +1386,12 @@ event\_enable\_read(struct file \*filp, char \_\_user \*ubuf, size\_t cnt, char buf[4] = "0";  mutex\_lock(&event\_mutex);- file = event\_file\_data(filp);+ file = event\_file\_file(filp); if (likely(file)) flags = file->flags; mutex\_unlock(&event\_mutex); - if (!file || flags & EVENT\_FILE\_FL\_FREED)+ if (!file) return -ENODEV;  if (flags & EVENT\_FILE\_FL\_ENABLED &&@@ -1428,8 +1428,8 @@ event\_enable\_write(struct file \*filp, const char \_\_user \*ubuf, size\_t cnt, case 1: ret = -ENODEV; mutex\_lock(&event\_mutex);- file = event\_file\_data(filp);- if (likely(file && !(file->flags & EVENT\_FILE\_FL\_FREED)))+ file = event\_file\_file(filp);+ if (likely(file)) ret = ftrace\_event\_enable\_disable(file, val); mutex\_unlock(&event\_mutex); break;@@ -1538,7 +1538,8 @@ enum {  static void \*f\_next(struct seq\_file \*m, void \*v, loff\_t \*pos) {- struct trace\_event\_call \*call = event\_file\_data(m->private);+ struct trace\_event\_file \*file = event\_file\_data(m->private);+ struct trace\_event\_call \*call = file->event\_call; struct list\_head \*common\_head = &ftrace\_common\_fields; struct list\_head \*head = trace\_get\_fields(call); struct list\_head \*node = v;@@ -1570,7 +1571,8 @@ static void \*f\_next(struct seq\_file \*m, void \*v, loff\_t \*pos)  static int f\_show(struct seq\_file \*m, void \*v) {- struct trace\_event\_call \*call = event\_file\_data(m->private);+ struct trace\_event\_file \*file = event\_file\_data(m->private);+ struct trace\_event\_call \*call = file->event\_call; struct ftrace\_event\_field \*field; const char \*array\_descriptor; @@ -1625,12 +1627,14 @@ static int f\_show(struct seq\_file \*m, void \*v)  static void \*f\_start(struct seq\_file \*m, loff\_t \*pos) {+ struct trace\_event\_file \*file; void \*p = (void \*)FORMAT\_HEADER; loff\_t l = 0;  /\* ->stop() is called even if ->start() fails \*/ mutex\_lock(&event\_mutex);- if (!event\_file\_data(m->private))+ file = event\_file\_file(m->private);+ if (!file) return ERR\_PTR(-ENODEV);  while (l < \*pos && p)@@ -1704,8 +1708,8 @@ event\_filter\_read(struct file \*filp, char \_\_user \*ubuf, size\_t cnt, trace\_seq\_init(s);  mutex\_lock(&event\_mutex);- file = event\_file\_data(filp);- if (file && !(file->flags & EVENT\_FILE\_FL\_FREED))+ file = event\_file\_file(filp);+ if (file) print\_event\_filter(file, s); mutex\_unlock(&event\_mutex); @@ -1734,9 +1738,13 @@ event\_filter\_write(struct file \*filp, const char \_\_user \*ubuf, size\_t cnt, return PTR\_ERR(buf);  mutex\_lock(&event\_mutex);- file = event\_file\_data(filp);- if (file)- err = apply\_event\_filter(file, buf);+ file = event\_file\_file(filp);+ if (file) {+ if (file->flags & EVENT\_FILE\_FL\_FREED)+ err = -ENODEV;+ else+ err = apply\_event\_filter(file, buf);+ } mutex\_unlock(&event\_mutex);  kfree(buf);@@ -2451,7 +2459,6 @@ static int event\_callback(const char \*name, umode\_t \*mode, void \*\*data, if (strcmp(name, "format") == 0) { \*mode = TRACE\_MODE\_READ; \*fops = &ftrace\_event\_format\_fops;- \*data = call; return 1; } diff --git a/kernel/trace/trace\_events\_hist.c b/kernel/trace/trace\_events\_hist.cindex 68aaf0bd7a78d3..dd16faf0d1500c 100644--- a/[kernel/trace/trace\_events\_hist.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace_events_hist.c?id=9a9716bbbf3dd6b6cbefba3abcc89af8b72631f4)+++ b/[kernel/trace/trace\_events\_hist.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace_events_hist.c?id=4ed03758ddf0b19d69eed69386d65a92d0091e0c)@@ -5609,7 +5609,7 @@ static int hist\_show(struct seq\_file \*m, void \*v)  mutex\_lock(&event\_mutex); - event\_file = event\_file\_data(m->private);+ event\_file = event\_file\_file(m->private); if (unlikely(!event\_file)) { ret = -ENODEV; goto out\_unlock;@@ -5888,7 +5888,7 @@ static int hist\_debug\_show(struct seq\_file \*m, void \*v)  mutex\_lock(&event\_mutex); - event\_file = event\_file\_data(m->private);+ event\_file = event\_file\_file(m->private); if (unlikely(!event\_file)) { ret = -ENODEV; goto out\_unlock;diff --git a/kernel/trace/trace\_events\_inject.c b/kernel/trace/trace\_events\_inject.cindex 8650562bdaa988..a8f076809db4d5 100644--- a/[kernel/trace/trace\_events\_inject.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace_events_inject.c?id=9a9716bbbf3dd6b6cbefba3abcc89af8b72631f4)+++ b/[kernel/trace/trace\_events\_inject.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace_events_inject.c?id=4ed03758ddf0b19d69eed69386d65a92d0091e0c)@@ -299,7 +299,7 @@ event\_inject\_write(struct file \*filp, const char \_\_user \*ubuf, size\_t cnt, strim(buf);  mutex\_lock(&event\_mutex);- file = event\_file\_data(filp);+ file = event\_file\_file(filp); if (file) { call = file->event\_call; size = parse\_entry(buf, call, &entry);diff --git a/kernel/trace/trace\_events\_trigger.c b/kernel/trace/trace\_events\_trigger.cindex b33c3861fbbbf3..76abc9a45f971a 100644--- a/[kernel/trace/trace\_events\_trigger.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace_events_trigger.c?id=9a9716bbbf3dd6b6cbefba3abcc89af8b72631f4)+++ b/[kernel/trace/trace\_events\_trigger.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace_events_trigger.c?id=4ed03758ddf0b19d69eed69386d65a92d0091e0c)@@ -159,7 +159,7 @@ static void \*trigger\_start(struct seq\_file \*m, loff\_t \*pos)  /\* ->stop() is called even if ->start() fails \*/ mutex\_lock(&event\_mutex);- event\_file = event\_file\_data(m->private);+ event\_file = event\_file\_file(m->private); if (unlikely(!event\_file)) return ERR\_PTR(-ENODEV); @@ -213,7 +213,7 @@ static int event\_trigger\_regex\_open(struct inode \*inode, struct file \*file)  mutex\_lock(&event\_mutex); - if (unlikely(!event\_file\_data(file))) {+ if (unlikely(!event\_file\_file(file))) { mutex\_unlock(&event\_mutex); return -ENODEV; }@@ -293,7 +293,7 @@ static ssize\_t event\_trigger\_regex\_write(struct file \*file, strim(buf);  mutex\_lock(&event\_mutex);- event\_file = event\_file\_data(file);+ event\_file = event\_file\_file(file); if (unlikely(!event\_file)) { mutex\_unlock(&event\_mutex); kfree(buf); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 10:57:18 +0000



=== Content from git.kernel.org_a31ee53e_20250111_112513.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=b1560408692cd0ab0370cfbe9deb03ce97ab3f6d)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=b1560408692cd0ab0370cfbe9deb03ce97ab3f6d)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b1560408692cd0ab0370cfbe9deb03ce97ab3f6d)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b1560408692cd0ab0370cfbe9deb03ce97ab3f6d)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Steven Rostedt <rostedt@goodmis.org> | 2024-07-30 11:06:57 -0400 |
| --- | --- | --- |
| committer | Steven Rostedt (Google) <rostedt@goodmis.org> | 2024-08-07 18:12:46 -0400 |
| commit | [b1560408692cd0ab0370cfbe9deb03ce97ab3f6d](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b1560408692cd0ab0370cfbe9deb03ce97ab3f6d) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=b1560408692cd0ab0370cfbe9deb03ce97ab3f6d)) | |
| tree | [fdea952b8cc595341e75eb8add6f605105445513](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=b1560408692cd0ab0370cfbe9deb03ce97ab3f6d) | |
| parent | [de9c2c66ad8e787abec7c9d7eff4f8c3cdd28aed](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=de9c2c66ad8e787abec7c9d7eff4f8c3cdd28aed) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b1560408692cd0ab0370cfbe9deb03ce97ab3f6d&id2=de9c2c66ad8e787abec7c9d7eff4f8c3cdd28aed)) | |
| download | [linux-b1560408692cd0ab0370cfbe9deb03ce97ab3f6d.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-b1560408692cd0ab0370cfbe9deb03ce97ab3f6d.tar.gz) | |

tracing: Have format file honor EVENT\_FILE\_FL\_FREEDWhen eventfs was introduced, special care had to be done to coordinate the
freeing of the file meta data with the files that are exposed to user
space. The file meta data would have a ref count that is set when the file
is created and would be decremented and freed after the last user that
opened the file closed it. When the file meta data was to be freed, it
would set a flag (EVENT\_FILE\_FL\_FREED) to denote that the file is freed,
and any new references made (like new opens or reads) would fail as it is
marked freed. This allowed other meta data to be freed after this flag was
set (under the event\_mutex).
All the files that were dynamically created in the events directory had a
pointer to the file meta data and would call event\_release() when the last
reference to the user space file was closed. This would be the time that it
is safe to free the file meta data.
A shortcut was made for the "format" file. It's i\_private would point to
the "call" entry directly and not point to the file's meta data. This is
because all format files are the same for the same "call", so it was
thought there was no reason to differentiate them. The other files
maintain state (like the "enable", "trigger", etc). But this meant if the
file were to disappear, the "format" file would be unaware of it.
This caused a race that could be trigger via the user\_events test (that
would create dynamic events and free them), and running a loop that would
read the user\_events format files:
In one console run:
# cd tools/testing/selftests/user\_events
# while true; do ./ftrace\_test; done
And in another console run:
# cd /sys/kernel/tracing/
# while true; do cat events/user\_events/\_\_test\_event/format; done 2>/dev/null
With KASAN memory checking, it would trigger a use-after-free bug report
(which was a real bug). This was because the format file was not checking
the file's meta data flag "EVENT\_FILE\_FL\_FREED", so it would access the
event that the file meta data pointed to after the event was freed.
After inspection, there are other locations that were found to not check
the EVENT\_FILE\_FL\_FREED flag when accessing the trace\_event\_file. Add a
new helper function: event\_file\_file() that will make sure that the
event\_mutex is held, and will return NULL if the trace\_event\_file has the
EVENT\_FILE\_FL\_FREED flag set. Have the first reference of the struct file
pointer use event\_file\_file() and check for NULL. Later uses can still use
the event\_file\_data() helper function if the event\_mutex is still held and
was not released since the event\_file\_file() call.
Link: [https://lore.kernel.org/all/20240719204701.1605950-1-minipli@grsecurity.net/](https://lore.kernel.org/all/20240719204701.1605950-1-minipli%40grsecurity.net/)
Cc: stable@vger.kernel.org
Cc: Masami Hiramatsu <mhiramat@kernel.org>
Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Cc: Ajay Kaher <ajay.kaher@broadcom.com>
Cc: Ilkka Naulapää <digirigawa@gmail.com>
Cc: Linus Torvalds <torvalds@linux-foundation.org>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Cc: Dan Carpenter <dan.carpenter@linaro.org>
Cc: Beau Belgrave <beaub@linux.microsoft.com>
Cc: Florian Fainelli <florian.fainelli@broadcom.com>
Cc: Alexey Makhalov <alexey.makhalov@broadcom.com>
Cc: Vasavi Sirnapalli <vasavi.sirnapalli@broadcom.com>
Link: [https://lore.kernel.org/20240730110657.3b69d3c1@gandalf.local.home](https://lore.kernel.org/20240730110657.3b69d3c1%40gandalf.local.home)
Fixes: b63db58e2fa5d ("eventfs/tracing: Add callback for release of an eventfs\_inode")
Reported-by: Mathias Krause <minipli@grsecurity.net>
Tested-by: Mathias Krause <minipli@grsecurity.net>
Signed-off-by: Steven Rostedt (Google) <rostedt@goodmis.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b1560408692cd0ab0370cfbe9deb03ce97ab3f6d)

| -rw-r--r-- | [kernel/trace/trace.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/trace/trace.h?id=b1560408692cd0ab0370cfbe9deb03ce97ab3f6d) | 23 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [kernel/trace/trace\_events.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/trace/trace_events.c?id=b1560408692cd0ab0370cfbe9deb03ce97ab3f6d) | 33 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/trace/trace\_events\_hist.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/trace/trace_events_hist.c?id=b1560408692cd0ab0370cfbe9deb03ce97ab3f6d) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/trace/trace\_events\_inject.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/trace/trace_events_inject.c?id=b1560408692cd0ab0370cfbe9deb03ce97ab3f6d) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/trace/trace\_events\_trigger.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/trace/trace_events_trigger.c?id=b1560408692cd0ab0370cfbe9deb03ce97ab3f6d) | 6 | |  |  |  | | --- | --- | --- | |

5 files changed, 49 insertions, 19 deletions

| diff --git a/kernel/trace/trace.h b/kernel/trace/trace.hindex 8783bebd0562e5..bd3e3069300e26 100644--- a/[kernel/trace/trace.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace.h?id=de9c2c66ad8e787abec7c9d7eff4f8c3cdd28aed)+++ b/[kernel/trace/trace.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace.h?id=b1560408692cd0ab0370cfbe9deb03ce97ab3f6d)@@ -1634,6 +1634,29 @@ static inline void \*event\_file\_data(struct file \*filp) extern struct mutex event\_mutex; extern struct list\_head ftrace\_events; +/\*+ \* When the trace\_event\_file is the filp->i\_private pointer,+ \* it must be taken under the event\_mutex lock, and then checked+ \* if the EVENT\_FILE\_FL\_FREED flag is set. If it is, then the+ \* data pointed to by the trace\_event\_file can not be trusted.+ \*+ \* Use the event\_file\_file() to access the trace\_event\_file from+ \* the filp the first time under the event\_mutex and check for+ \* NULL. If it is needed to be retrieved again and the event\_mutex+ \* is still held, then the event\_file\_data() can be used and it+ \* is guaranteed to be valid.+ \*/+static inline struct trace\_event\_file \*event\_file\_file(struct file \*filp)+{+ struct trace\_event\_file \*file;++ lockdep\_assert\_held(&event\_mutex);+ file = READ\_ONCE(file\_inode(filp)->i\_private);+ if (!file || file->flags & EVENT\_FILE\_FL\_FREED)+ return NULL;+ return file;+}+ extern const struct file\_operations event\_trigger\_fops; extern const struct file\_operations event\_hist\_fops; extern const struct file\_operations event\_hist\_debug\_fops;diff --git a/kernel/trace/trace\_events.c b/kernel/trace/trace\_events.cindex 6ef29eba90ceb7..f08fbaf8cad676 100644--- a/[kernel/trace/trace\_events.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace_events.c?id=de9c2c66ad8e787abec7c9d7eff4f8c3cdd28aed)+++ b/[kernel/trace/trace\_events.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace_events.c?id=b1560408692cd0ab0370cfbe9deb03ce97ab3f6d)@@ -1386,12 +1386,12 @@ event\_enable\_read(struct file \*filp, char \_\_user \*ubuf, size\_t cnt, char buf[4] = "0";  mutex\_lock(&event\_mutex);- file = event\_file\_data(filp);+ file = event\_file\_file(filp); if (likely(file)) flags = file->flags; mutex\_unlock(&event\_mutex); - if (!file || flags & EVENT\_FILE\_FL\_FREED)+ if (!file) return -ENODEV;  if (flags & EVENT\_FILE\_FL\_ENABLED &&@@ -1424,8 +1424,8 @@ event\_enable\_write(struct file \*filp, const char \_\_user \*ubuf, size\_t cnt, case 1: ret = -ENODEV; mutex\_lock(&event\_mutex);- file = event\_file\_data(filp);- if (likely(file && !(file->flags & EVENT\_FILE\_FL\_FREED))) {+ file = event\_file\_file(filp);+ if (likely(file)) { ret = tracing\_update\_buffers(file->tr); if (ret < 0) { mutex\_unlock(&event\_mutex);@@ -1540,7 +1540,8 @@ enum {  static void \*f\_next(struct seq\_file \*m, void \*v, loff\_t \*pos) {- struct trace\_event\_call \*call = event\_file\_data(m->private);+ struct trace\_event\_file \*file = event\_file\_data(m->private);+ struct trace\_event\_call \*call = file->event\_call; struct list\_head \*common\_head = &ftrace\_common\_fields; struct list\_head \*head = trace\_get\_fields(call); struct list\_head \*node = v;@@ -1572,7 +1573,8 @@ static void \*f\_next(struct seq\_file \*m, void \*v, loff\_t \*pos)  static int f\_show(struct seq\_file \*m, void \*v) {- struct trace\_event\_call \*call = event\_file\_data(m->private);+ struct trace\_event\_file \*file = event\_file\_data(m->private);+ struct trace\_event\_call \*call = file->event\_call; struct ftrace\_event\_field \*field; const char \*array\_descriptor; @@ -1627,12 +1629,14 @@ static int f\_show(struct seq\_file \*m, void \*v)  static void \*f\_start(struct seq\_file \*m, loff\_t \*pos) {+ struct trace\_event\_file \*file; void \*p = (void \*)FORMAT\_HEADER; loff\_t l = 0;  /\* ->stop() is called even if ->start() fails \*/ mutex\_lock(&event\_mutex);- if (!event\_file\_data(m->private))+ file = event\_file\_file(m->private);+ if (!file) return ERR\_PTR(-ENODEV);  while (l < \*pos && p)@@ -1706,8 +1710,8 @@ event\_filter\_read(struct file \*filp, char \_\_user \*ubuf, size\_t cnt, trace\_seq\_init(s);  mutex\_lock(&event\_mutex);- file = event\_file\_data(filp);- if (file && !(file->flags & EVENT\_FILE\_FL\_FREED))+ file = event\_file\_file(filp);+ if (file) print\_event\_filter(file, s); mutex\_unlock(&event\_mutex); @@ -1736,9 +1740,13 @@ event\_filter\_write(struct file \*filp, const char \_\_user \*ubuf, size\_t cnt, return PTR\_ERR(buf);  mutex\_lock(&event\_mutex);- file = event\_file\_data(filp);- if (file)- err = apply\_event\_filter(file, buf);+ file = event\_file\_file(filp);+ if (file) {+ if (file->flags & EVENT\_FILE\_FL\_FREED)+ err = -ENODEV;+ else+ err = apply\_event\_filter(file, buf);+ } mutex\_unlock(&event\_mutex);  kfree(buf);@@ -2485,7 +2493,6 @@ static int event\_callback(const char \*name, umode\_t \*mode, void \*\*data, if (strcmp(name, "format") == 0) { \*mode = TRACE\_MODE\_READ; \*fops = &ftrace\_event\_format\_fops;- \*data = call; return 1; } diff --git a/kernel/trace/trace\_events\_hist.c b/kernel/trace/trace\_events\_hist.cindex 6ece1308d36a02..5f9119eb7c67f6 100644--- a/[kernel/trace/trace\_events\_hist.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace_events_hist.c?id=de9c2c66ad8e787abec7c9d7eff4f8c3cdd28aed)+++ b/[kernel/trace/trace\_events\_hist.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace_events_hist.c?id=b1560408692cd0ab0370cfbe9deb03ce97ab3f6d)@@ -5601,7 +5601,7 @@ static int hist\_show(struct seq\_file \*m, void \*v)  mutex\_lock(&event\_mutex); - event\_file = event\_file\_data(m->private);+ event\_file = event\_file\_file(m->private); if (unlikely(!event\_file)) { ret = -ENODEV; goto out\_unlock;@@ -5880,7 +5880,7 @@ static int hist\_debug\_show(struct seq\_file \*m, void \*v)  mutex\_lock(&event\_mutex); - event\_file = event\_file\_data(m->private);+ event\_file = event\_file\_file(m->private); if (unlikely(!event\_file)) { ret = -ENODEV; goto out\_unlock;diff --git a/kernel/trace/trace\_events\_inject.c b/kernel/trace/trace\_events\_inject.cindex 8650562bdaa988..a8f076809db4d5 100644--- a/[kernel/trace/trace\_events\_inject.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace_events_inject.c?id=de9c2c66ad8e787abec7c9d7eff4f8c3cdd28aed)+++ b/[kernel/trace/trace\_events\_inject.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace_events_inject.c?id=b1560408692cd0ab0370cfbe9deb03ce97ab3f6d)@@ -299,7 +299,7 @@ event\_inject\_write(struct file \*filp, const char \_\_user \*ubuf, size\_t cnt, strim(buf);  mutex\_lock(&event\_mutex);- file = event\_file\_data(filp);+ file = event\_file\_file(filp); if (file) { call = file->event\_call; size = parse\_entry(buf, call, &entry);diff --git a/kernel/trace/trace\_events\_trigger.c b/kernel/trace/trace\_events\_trigger.cindex 4bec043c8690d3..a5e3d6acf1e1e2 100644--- a/[kernel/trace/trace\_events\_trigger.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace_events_trigger.c?id=de9c2c66ad8e787abec7c9d7eff4f8c3cdd28aed)+++ b/[kernel/trace/trace\_events\_trigger.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace_events_trigger.c?id=b1560408692cd0ab0370cfbe9deb03ce97ab3f6d)@@ -159,7 +159,7 @@ static void \*trigger\_start(struct seq\_file \*m, loff\_t \*pos)  /\* ->stop() is called even if ->start() fails \*/ mutex\_lock(&event\_mutex);- event\_file = event\_file\_data(m->private);+ event\_file = event\_file\_file(m->private); if (unlikely(!event\_file)) return ERR\_PTR(-ENODEV); @@ -213,7 +213,7 @@ static int event\_trigger\_regex\_open(struct inode \*inode, struct file \*file)  mutex\_lock(&event\_mutex); - if (unlikely(!event\_file\_data(file))) {+ if (unlikely(!event\_file\_file(file))) { mutex\_unlock(&event\_mutex); return -ENODEV; }@@ -293,7 +293,7 @@ static ssize\_t event\_trigger\_regex\_write(struct file \*file, strim(buf);  mutex\_lock(&event\_mutex);- event\_file = event\_file\_data(file);+ event\_file = event\_file\_file(file); if (unlikely(!event\_file)) { mutex\_unlock(&event\_mutex); kfree(buf); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 10:57:18 +0000


