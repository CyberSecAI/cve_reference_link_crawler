The provided content relates to CVE-2024-49994.

**Root cause of vulnerability:**
An integer overflow vulnerability exists in the `blk_ioctl_secure_erase` function within the Linux kernel's block device handling. This occurs when calculating the end address of the secure erase operation, where the sum of the start address and length could overflow.

**Weaknesses/vulnerabilities present:**
- Integer overflow: The code adds the start sector and length without checking for overflow, potentially resulting in a smaller end address than intended. This can lead to out-of-bounds access.
- Incorrect bounds checking: Instead of checking if `start + len` exceeds the device size, the code performs a direct comparison, which can be circumvented with an overflow resulting in a much smaller value.

**Impact of exploitation:**
- Infinite loop: A carefully crafted `BLKSECDISCARD` ioctl command, with a large length that leads to an integer overflow, could cause the `blkdev_issue_secure_erase` function to enter a near infinite loop, repeatedly trying to access memory beyond the device's bounds.
- Denial of Service (DoS): The infinite loop can lead to system unresponsiveness.
- Potentially arbitrary memory corruption: Although not explicitly stated, out-of-bounds access can potentially lead to memory corruption.

**Attack vectors:**
- Local attacker: An attacker with local access to a block device can send the `BLKSECDISCARD` ioctl command, which triggers the vulnerability.

**Required attacker capabilities/position:**
- Local access to a block device.
- Ability to execute ioctl commands on the block device.
- Knowledge of the overflow condition to be exploited.

**Additional details:**
- The fix involves using the `check_add_overflow` function to prevent integer overflows when calculating the end address of the secure erase operation.
- The vulnerability is present in the `block/ioctl.c` file.
- The provided content includes the patch that resolves the vulnerability
- The commit message clearly states the vulnerability and how to trigger it.
- The patch changes the calculation of the end of range using `start + len` to using `check_add_overflow` to check for overflow and store the end in the `end` variable, which is then used for further checks.