

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=4c089cefe30924fbe20dd1ee92774ea1f5eca834)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=4c089cefe30924fbe20dd1ee92774ea1f5eca834)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=4c089cefe30924fbe20dd1ee92774ea1f5eca834)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=4c089cefe30924fbe20dd1ee92774ea1f5eca834)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Alex Williamson <alex.williamson@redhat.com> | 2024-03-08 16:05:25 -0700 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-04-03 15:11:33 +0200 |
| commit | [4c089cefe30924fbe20dd1ee92774ea1f5eca834](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=4c089cefe30924fbe20dd1ee92774ea1f5eca834) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=4c089cefe30924fbe20dd1ee92774ea1f5eca834)) | |
| tree | [a16615d5e5b13d8d365f5ef52038d0129ed45cc0](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=4c089cefe30924fbe20dd1ee92774ea1f5eca834) | |
| parent | [4c85a7808a1ddbcb16df5d09a1e8a05ffb307f64](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=4c85a7808a1ddbcb16df5d09a1e8a05ffb307f64) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=4c089cefe30924fbe20dd1ee92774ea1f5eca834&id2=4c85a7808a1ddbcb16df5d09a1e8a05ffb307f64)) | |
| download | [linux-4c089cefe30924fbe20dd1ee92774ea1f5eca834.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-4c089cefe30924fbe20dd1ee92774ea1f5eca834.tar.gz) | |

vfio/pci: Create persistent INTx handler[ Upstream commit 18c198c96a815c962adc2b9b77909eec0be7df4d ]
A vulnerability exists where the eventfd for INTx signaling can be
deconfigured, which unregisters the IRQ handler but still allows
eventfds to be signaled with a NULL context through the SET\_IRQS ioctl
or through unmask irqfd if the device interrupt is pending.
Ideally this could be solved with some additional locking; the igate
mutex serializes the ioctl and config space accesses, and the interrupt
handler is unregistered relative to the trigger, but the irqfd path
runs asynchronous to those. The igate mutex cannot be acquired from the
atomic context of the eventfd wake function. Disabling the irqfd
relative to the eventfd registration is potentially incompatible with
existing userspace.
As a result, the solution implemented here moves configuration of the
INTx interrupt handler to track the lifetime of the INTx context object
and irq\_type configuration, rather than registration of a particular
trigger eventfd. Synchronization is added between the ioctl path and
eventfd\_signal() wrapper such that the eventfd trigger can be
dynamically updated relative to in-flight interrupts or irqfd callbacks.
Cc: <stable@vger.kernel.org>
Fixes: 89e1f7d4c66d ("vfio: Add PCI device driver")
Reported-by: Reinette Chatre <reinette.chatre@intel.com>
Reviewed-by: Kevin Tian <kevin.tian@intel.com>
Reviewed-by: Reinette Chatre <reinette.chatre@intel.com>
Reviewed-by: Eric Auger <eric.auger@redhat.com>
Link: [https://lore.kernel.org/r/20240308230557.805580-5-alex.williamson@redhat.com](https://lore.kernel.org/r/20240308230557.805580-5-alex.williamson%40redhat.com)
Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=4c089cefe30924fbe20dd1ee92774ea1f5eca834)

| -rw-r--r-- | [drivers/vfio/pci/vfio\_pci\_intrs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/vfio/pci/vfio_pci_intrs.c?id=4c089cefe30924fbe20dd1ee92774ea1f5eca834) | 145 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 78 insertions, 67 deletions

| diff --git a/drivers/vfio/pci/vfio\_pci\_intrs.c b/drivers/vfio/pci/vfio\_pci\_intrs.cindex 75c85eec21b3c2..fb5392b749fff0 100644--- a/[drivers/vfio/pci/vfio\_pci\_intrs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/vfio/pci/vfio_pci_intrs.c?id=4c85a7808a1ddbcb16df5d09a1e8a05ffb307f64)+++ b/[drivers/vfio/pci/vfio\_pci\_intrs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/vfio/pci/vfio_pci_intrs.c?id=4c089cefe30924fbe20dd1ee92774ea1f5eca834)@@ -90,11 +90,15 @@ static void vfio\_send\_intx\_eventfd(void \*opaque, void \*unused)  if (likely(is\_intx(vdev) && !vdev->virq\_disabled)) { struct vfio\_pci\_irq\_ctx \*ctx;+ struct eventfd\_ctx \*trigger;  ctx = vfio\_irq\_ctx\_get(vdev, 0); if (WARN\_ON\_ONCE(!ctx)) return;- eventfd\_signal(ctx->trigger);++ trigger = READ\_ONCE(ctx->trigger);+ if (likely(trigger))+ eventfd\_signal(trigger); } } @@ -253,100 +257,100 @@ static irqreturn\_t vfio\_intx\_handler(int irq, void \*dev\_id) return ret; } -static int vfio\_intx\_enable(struct vfio\_pci\_core\_device \*vdev)+static int vfio\_intx\_enable(struct vfio\_pci\_core\_device \*vdev,+ struct eventfd\_ctx \*trigger) {+ struct pci\_dev \*pdev = vdev->pdev; struct vfio\_pci\_irq\_ctx \*ctx;+ unsigned long irqflags;+ char \*name;+ int ret;  if (!is\_irq\_none(vdev)) return -EINVAL; - if (!vdev->pdev->irq)+ if (!pdev->irq) return -ENODEV; + name = kasprintf(GFP\_KERNEL\_ACCOUNT, "vfio-intx(%s)", pci\_name(pdev));+ if (!name)+ return -ENOMEM;+ ctx = vfio\_irq\_ctx\_alloc(vdev, 0); if (!ctx) return -ENOMEM; + ctx->name = name;+ ctx->trigger = trigger;+ /\*- \* If the virtual interrupt is masked, restore it. Devices- \* supporting DisINTx can be masked at the hardware level- \* here, non-PCI-2.3 devices will have to wait until the- \* interrupt is enabled.+ \* Fill the initial masked state based on virq\_disabled. After+ \* enable, changing the DisINTx bit in vconfig directly changes INTx+ \* masking. igate prevents races during setup, once running masked+ \* is protected via irqlock.+ \*+ \* Devices supporting DisINTx also reflect the current mask state in+ \* the physical DisINTx bit, which is not affected during IRQ setup.+ \*+ \* Devices without DisINTx support require an exclusive interrupt.+ \* IRQ masking is performed at the IRQ chip. Again, igate protects+ \* against races during setup and IRQ handlers and irqfds are not+ \* yet active, therefore masked is stable and can be used to+ \* conditionally auto-enable the IRQ.+ \*+ \* irq\_type must be stable while the IRQ handler is registered,+ \* therefore it must be set before request\_irq(). \*/ ctx->masked = vdev->virq\_disabled;- if (vdev->pci\_2\_3)- pci\_intx(vdev->pdev, !ctx->masked);+ if (vdev->pci\_2\_3) {+ pci\_intx(pdev, !ctx->masked);+ irqflags = IRQF\_SHARED;+ } else {+ irqflags = ctx->masked ? IRQF\_NO\_AUTOEN : 0;+ }  vdev->irq\_type = VFIO\_PCI\_INTX\_IRQ\_INDEX; + ret = request\_irq(pdev->irq, vfio\_intx\_handler,+ irqflags, ctx->name, vdev);+ if (ret) {+ vdev->irq\_type = VFIO\_PCI\_NUM\_IRQS;+ kfree(name);+ vfio\_irq\_ctx\_free(vdev, ctx, 0);+ return ret;+ }+ return 0; } -static int vfio\_intx\_set\_signal(struct vfio\_pci\_core\_device \*vdev, int fd)+static int vfio\_intx\_set\_signal(struct vfio\_pci\_core\_device \*vdev,+ struct eventfd\_ctx \*trigger) { struct pci\_dev \*pdev = vdev->pdev;- unsigned long irqflags = IRQF\_SHARED; struct vfio\_pci\_irq\_ctx \*ctx;- struct eventfd\_ctx \*trigger;- unsigned long flags;- int ret;+ struct eventfd\_ctx \*old;  ctx = vfio\_irq\_ctx\_get(vdev, 0); if (WARN\_ON\_ONCE(!ctx)) return -EINVAL; - if (ctx->trigger) {- free\_irq(pdev->irq, vdev);- kfree(ctx->name);- eventfd\_ctx\_put(ctx->trigger);- ctx->trigger = NULL;- }-- if (fd < 0) /\* Disable only \*/- return 0;-- ctx->name = kasprintf(GFP\_KERNEL\_ACCOUNT, "vfio-intx(%s)",- pci\_name(pdev));- if (!ctx->name)- return -ENOMEM;-- trigger = eventfd\_ctx\_fdget(fd);- if (IS\_ERR(trigger)) {- kfree(ctx->name);- return PTR\_ERR(trigger);- }+ old = ctx->trigger; - ctx->trigger = trigger;+ WRITE\_ONCE(ctx->trigger, trigger); - /\*- \* Devices without DisINTx support require an exclusive interrupt,- \* IRQ masking is performed at the IRQ chip. The masked status is- \* protected by vdev->irqlock. Setup the IRQ without auto-enable and- \* unmask as necessary below under lock. DisINTx is unmodified by- \* the IRQ configuration and may therefore use auto-enable.- \*/- if (!vdev->pci\_2\_3)- irqflags = IRQF\_NO\_AUTOEN;-- ret = request\_irq(pdev->irq, vfio\_intx\_handler,- irqflags, ctx->name, vdev);- if (ret) {- ctx->trigger = NULL;- kfree(ctx->name);- eventfd\_ctx\_put(trigger);- return ret;+ /\* Releasing an old ctx requires synchronizing in-flight users \*/+ if (old) {+ synchronize\_irq(pdev->irq);+ vfio\_virqfd\_flush\_thread(&ctx->unmask);+ eventfd\_ctx\_put(old); } - spin\_lock\_irqsave(&vdev->irqlock, flags);- if (!vdev->pci\_2\_3 && !ctx->masked)- enable\_irq(pdev->irq);- spin\_unlock\_irqrestore(&vdev->irqlock, flags);- return 0; }  static void vfio\_intx\_disable(struct vfio\_pci\_core\_device \*vdev) {+ struct pci\_dev \*pdev = vdev->pdev; struct vfio\_pci\_irq\_ctx \*ctx;  ctx = vfio\_irq\_ctx\_get(vdev, 0);@@ -354,10 +358,13 @@ static void vfio\_intx\_disable(struct vfio\_pci\_core\_device \*vdev) if (ctx) { vfio\_virqfd\_disable(&ctx->unmask); vfio\_virqfd\_disable(&ctx->mask);+ free\_irq(pdev->irq, vdev);+ if (ctx->trigger)+ eventfd\_ctx\_put(ctx->trigger);+ kfree(ctx->name);+ vfio\_irq\_ctx\_free(vdev, ctx, 0); }- vfio\_intx\_set\_signal(vdev, -1); vdev->irq\_type = VFIO\_PCI\_NUM\_IRQS;- vfio\_irq\_ctx\_free(vdev, ctx, 0); }  /\*@@ -641,19 +648,23 @@ static int vfio\_pci\_set\_intx\_trigger(struct vfio\_pci\_core\_device \*vdev, return -EINVAL;  if (flags & VFIO\_IRQ\_SET\_DATA\_EVENTFD) {+ struct eventfd\_ctx \*trigger = NULL; int32\_t fd = \*(int32\_t \*)data; int ret; - if (is\_intx(vdev))- return vfio\_intx\_set\_signal(vdev, fd);+ if (fd >= 0) {+ trigger = eventfd\_ctx\_fdget(fd);+ if (IS\_ERR(trigger))+ return PTR\_ERR(trigger);+ } - ret = vfio\_intx\_enable(vdev);- if (ret)- return ret;+ if (is\_intx(vdev))+ ret = vfio\_intx\_set\_signal(vdev, trigger);+ else+ ret = vfio\_intx\_enable(vdev, trigger); - ret = vfio\_intx\_set\_signal(vdev, fd);- if (ret)- vfio\_intx\_disable(vdev);+ if (ret && trigger)+ eventfd\_ctx\_put(trigger);  return ret; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 15:21:07 +0000

