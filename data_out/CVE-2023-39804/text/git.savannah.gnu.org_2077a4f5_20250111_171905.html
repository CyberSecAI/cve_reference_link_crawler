

| [cgit logo](/cgit/) | [index](/cgit/) : [tar.git](/cgit/tar.git/ "tar.git") | master new origin |
| --- | --- | --- |
| GNU Tar |  |

| [summary](/cgit/tar.git/?h=release_1_34)[refs](/cgit/tar.git/refs/?h=release_1_34)[log](/cgit/tar.git/log/src/xheader.c?h=release_1_34)[tree](/cgit/tar.git/tree/src/xheader.c?h=release_1_34)[commit](/cgit/tar.git/commit/src/xheader.c?h=release_1_34)[diff](/cgit/tar.git/diff/src/xheader.c?h=release_1_34) | log msg author committer range |
| --- | --- |

path: [root](/cgit/tar.git/tree/?h=release_1_34)/[src](/cgit/tar.git/tree/src?h=release_1_34)/[xheader.c](/cgit/tar.git/tree/src/xheader.c?h=release_1_34)blob: 229137ea1fdd99fc34bc35aaf1d1039b114ceafc ([plain](/cgit/tar.git/plain/src/xheader.c?h=release_1_34))

| ``` [1](#n1) [2](#n2) [3](#n3) [4](#n4) [5](#n5) [6](#n6) [7](#n7) [8](#n8) [9](#n9) [10](#n10) [11](#n11) [12](#n12) [13](#n13) [14](#n14) [15](#n15) [16](#n16) [17](#n17) [18](#n18) [19](#n19) [20](#n20) [21](#n21) [22](#n22) [23](#n23) [24](#n24) [25](#n25) [26](#n26) [27](#n27) [28](#n28) [29](#n29) [30](#n30) [31](#n31) [32](#n32) [33](#n33) [34](#n34) [35](#n35) [36](#n36) [37](#n37) [38](#n38) [39](#n39) [40](#n40) [41](#n41) [42](#n42) [43](#n43) [44](#n44) [45](#n45) [46](#n46) [47](#n47) [48](#n48) [49](#n49) [50](#n50) [51](#n51) [52](#n52) [53](#n53) [54](#n54) [55](#n55) [56](#n56) [57](#n57) [58](#n58) [59](#n59) [60](#n60) [61](#n61) [62](#n62) [63](#n63) [64](#n64) [65](#n65) [66](#n66) [67](#n67) [68](#n68) [69](#n69) [70](#n70) [71](#n71) [72](#n72) [73](#n73) [74](#n74) [75](#n75) [76](#n76) [77](#n77) [78](#n78) [79](#n79) [80](#n80) [81](#n81) [82](#n82) [83](#n83) [84](#n84) [85](#n85) [86](#n86) [87](#n87) [88](#n88) [89](#n89) [90](#n90) [91](#n91) [92](#n92) [93](#n93) [94](#n94) [95](#n95) [96](#n96) [97](#n97) [98](#n98) [99](#n99) [100](#n100) [101](#n101) [102](#n102) [103](#n103) [104](#n104) [105](#n105) [106](#n106) [107](#n107) [108](#n108) [109](#n109) [110](#n110) [111](#n111) [112](#n112) [113](#n113) [114](#n114) [115](#n115) [116](#n116) [117](#n117) [118](#n118) [119](#n119) [120](#n120) [121](#n121) [122](#n122) [123](#n123) [124](#n124) [125](#n125) [126](#n126) [127](#n127) [128](#n128) [129](#n129) [130](#n130) [131](#n131) [132](#n132) [133](#n133) [134](#n134) [135](#n135) [136](#n136) [137](#n137) [138](#n138) [139](#n139) [140](#n140) [141](#n141) [142](#n142) [143](#n143) [144](#n144) [145](#n145) [146](#n146) [147](#n147) [148](#n148) [149](#n149) [150](#n150) [151](#n151) [152](#n152) [153](#n153) [154](#n154) [155](#n155) [156](#n156) [157](#n157) [158](#n158) [159](#n159) [160](#n160) [161](#n161) [162](#n162) [163](#n163) [164](#n164) [165](#n165) [166](#n166) [167](#n167) [168](#n168) [169](#n169) [170](#n170) [171](#n171) [172](#n172) [173](#n173) [174](#n174) [175](#n175) [176](#n176) [177](#n177) [178](#n178) [179](#n179) [180](#n180) [181](#n181) [182](#n182) [183](#n183) [184](#n184) [185](#n185) [186](#n186) [187](#n187) [188](#n188) [189](#n189) [190](#n190) [191](#n191) [192](#n192) [193](#n193) [194](#n194) [195](#n195) [196](#n196) [197](#n197) [198](#n198) [199](#n199) [200](#n200) [201](#n201) [202](#n202) [203](#n203) [204](#n204) [205](#n205) [206](#n206) [207](#n207) [208](#n208) [209](#n209) [210](#n210) [211](#n211) [212](#n212) [213](#n213) [214](#n214) [215](#n215) [216](#n216) [217](#n217) [218](#n218) [219](#n219) [220](#n220) [221](#n221) [222](#n222) [223](#n223) [224](#n224) [225](#n225) [226](#n226) [227](#n227) [228](#n228) [229](#n229) [230](#n230) [231](#n231) [232](#n232) [233](#n233) [234](#n234) [235](#n235) [236](#n236) [237](#n237) [238](#n238) [239](#n239) [240](#n240) [241](#n241) [242](#n242) [243](#n243) [244](#n244) [245](#n245) [246](#n246) [247](#n247) [248](#n248) [249](#n249) [250](#n250) [251](#n251) [252](#n252) [253](#n253) [254](#n254) [255](#n255) [256](#n256) [257](#n257) [258](#n258) [259](#n259) [260](#n260) [261](#n261) [262](#n262) [263](#n263) [264](#n264) [265](#n265) [266](#n266) [267](#n267) [268](#n268) [269](#n269) [270](#n270) [271](#n271) [272](#n272) [273](#n273) [274](#n274) [275](#n275) [276](#n276) [277](#n277) [278](#n278) [279](#n279) [280](#n280) [281](#n281) [282](#n282) [283](#n283) [284](#n284) [285](#n285) [286](#n286) [287](#n287) [288](#n288) [289](#n289) [290](#n290) [291](#n291) [292](#n292) [293](#n293) [294](#n294) [295](#n295) [296](#n296) [297](#n297) [298](#n298) [299](#n299) [300](#n300) [301](#n301) [302](#n302) [303](#n303) [304](#n304) [305](#n305) [306](#n306) [307](#n307) [308](#n308) [309](#n309) [310](#n310) [311](#n311) [312](#n312) [313](#n313) [314](#n314) [315](#n315) [316](#n316) [317](#n317) [318](#n318) [319](#n319) [320](#n320) [321](#n321) [322](#n322) [323](#n323) [324](#n324) [325](#n325) [326](#n326) [327](#n327) [328](#n328) [329](#n329) [330](#n330) [331](#n331) [332](#n332) [333](#n333) [334](#n334) [335](#n335) [336](#n336) [337](#n337) [338](#n338) [339](#n339) [340](#n340) [341](#n341) [342](#n342) [343](#n343) [344](#n344) [345](#n345) [346](#n346) [347](#n347) [348](#n348) [349](#n349) [350](#n350) [351](#n351) [352](#n352) [353](#n353) [354](#n354) [355](#n355) [356](#n356) [357](#n357) [358](#n358) [359](#n359) [360](#n360) [361](#n361) [362](#n362) [363](#n363) [364](#n364) [365](#n365) [366](#n366) [367](#n367) [368](#n368) [369](#n369) [370](#n370) [371](#n371) [372](#n372) [373](#n373) [374](#n374) [375](#n375) [376](#n376) [377](#n377) [378](#n378) [379](#n379) [380](#n380) [381](#n381) [382](#n382) [383](#n383) [384](#n384) [385](#n385) [386](#n386) [387](#n387) [388](#n388) [389](#n389) [390](#n390) [391](#n391) [392](#n392) [393](#n393) [394](#n394) [395](#n395) [396](#n396) [397](#n397) [398](#n398) [399](#n399) [400](#n400) [401](#n401) [402](#n402) [403](#n403) [404](#n404) [405](#n405) [406](#n406) [407](#n407) [408](#n408) [409](#n409) [410](#n410) [411](#n411) [412](#n412) [413](#n413) [414](#n414) [415](#n415) [416](#n416) [417](#n417) [418](#n418) [419](#n419) [420](#n420) [421](#n421) [422](#n422) [423](#n423) [424](#n424) [425](#n425) [426](#n426) [427](#n427) [428](#n428) [429](#n429) [430](#n430) [431](#n431) [432](#n432) [433](#n433) [434](#n434) [435](#n435) [436](#n436) [437](#n437) [438](#n438) [439](#n439) [440](#n440) [441](#n441) [442](#n442) [443](#n443) [444](#n444) [445](#n445) [446](#n446) [447](#n447) [448](#n448) [449](#n449) [450](#n450) [451](#n451) [452](#n452) [453](#n453) [454](#n454) [455](#n455) [456](#n456) [457](#n457) [458](#n458) [459](#n459) [460](#n460) [461](#n461) [462](#n462) [463](#n463) [464](#n464) [465](#n465) [466](#n466) [467](#n467) [468](#n468) [469](#n469) [470](#n470) [471](#n471) [472](#n472) [473](#n473) [474](#n474) [475](#n475) [476](#n476) [477](#n477) [478](#n478) [479](#n479) [480](#n480) [481](#n481) [482](#n482) [483](#n483) [484](#n484) [485](#n485) [486](#n486) [487](#n487) [488](#n488) [489](#n489) [490](#n490) [491](#n491) [492](#n492) [493](#n493) [494](#n494) [495](#n495) [496](#n496) [497](#n497) [498](#n498) [499](#n499) [500](#n500) [501](#n501) [502](#n502) [503](#n503) [504](#n504) [505](#n505) [506](#n506) [507](#n507) [508](#n508) [509](#n509) [510](#n510) [511](#n511) [512](#n512) [513](#n513) [514](#n514) [515](#n515) [516](#n516) [517](#n517) [518](#n518) [519](#n519) [520](#n520) [521](#n521) [522](#n522) [523](#n523) [524](#n524) [525](#n525) [526](#n526) [527](#n527) [528](#n528) [529](#n529) [530](#n530) [531](#n531) [532](#n532) [533](#n533) [534](#n534) [535](#n535) [536](#n536) [537](#n537) [538](#n538) [539](#n539) [540](#n540) [541](#n541) [542](#n542) [543](#n543) [544](#n544) [545](#n545) [546](#n546) [547](#n547) [548](#n548) [549](#n549) [550](#n550) [551](#n551) [552](#n552) [553](#n553) [554](#n554) [555](#n555) [556](#n556) [557](#n557) [558](#n558) [559](#n559) [560](#n560) [561](#n561) [562](#n562) [563](#n563) [564](#n564) [565](#n565) [566](#n566) [567](#n567) [568](#n568) [569](#n569) [570](#n570) [571](#n571) [572](#n572) [573](#n573) [574](#n574) [575](#n575) [576](#n576) [577](#n577) [578](#n578) [579](#n579) [580](#n580) [581](#n581) [582](#n582) [583](#n583) [584](#n584) [585](#n585) [586](#n586) [587](#n587) [588](#n588) [589](#n589) [590](#n590) [591](#n591) [592](#n592) [593](#n593) [594](#n594) [595](#n595) [596](#n596) [597](#n597) [598](#n598) [599](#n599) [600](#n600) [601](#n601) [602](#n602) [603](#n603) [604](#n604) [605](#n605) [606](#n606) [607](#n607) [608](#n608) [609](#n609) [610](#n610) [611](#n611) [612](#n612) [613](#n613) [614](#n614) [615](#n615) [616](#n616) [617](#n617) [618](#n618) [619](#n619) [620](#n620) [621](#n621) [622](#n622) [623](#n623) [624](#n624) [625](#n625) [626](#n626) [627](#n627) [628](#n628) [629](#n629) [630](#n630) [631](#n631) [632](#n632) [633](#n633) [634](#n634) [635](#n635) [636](#n636) [637](#n637) [638](#n638) [639](#n639) [640](#n640) [641](#n641) [642](#n642) [643](#n643) [644](#n644) [645](#n645) [646](#n646) [647](#n647) [648](#n648) [649](#n649) [650](#n650) [651](#n651) [652](#n652) [653](#n653) [654](#n654) [655](#n655) [656](#n656) [657](#n657) [658](#n658) [659](#n659) [660](#n660) [661](#n661) [662](#n662) [663](#n663) [664](#n664) [665](#n665) [666](#n666) [667](#n667) [668](#n668) [669](#n669) [670](#n670) [671](#n671) [672](#n672) [673](#n673) [674](#n674) [675](#n675) [676](#n676) [677](#n677) [678](#n678) [679](#n679) [680](#n680) [681](#n681) [682](#n682) [683](#n683) [684](#n684) [685](#n685) [686](#n686) [687](#n687) [688](#n688) [689](#n689) [690](#n690) [691](#n691) [692](#n692) [693](#n693) [694](#n694) [695](#n695) [696](#n696) [697](#n697) [698](#n698) [699](#n699) [700](#n700) [701](#n701) [702](#n702) [703](#n703) [704](#n704) [705](#n705) [706](#n706) [707](#n707) [708](#n708) [709](#n709) [710](#n710) [711](#n711) [712](#n712) [713](#n713) [714](#n714) [715](#n715) [716](#n716) [717](#n717) [718](#n718) [719](#n719) [720](#n720) [721](#n721) [722](#n722) [723](#n723) [724](#n724) [725](#n725) [726](#n726) [727](#n727) [728](#n728) [729](#n729) [730](#n730) [731](#n731) [732](#n732) [733](#n733) [734](#n734) [735](#n735) [736](#n736) [737](#n737) [738](#n738) [739](#n739) [740](#n740) [741](#n741) [742](#n742) [743](#n743) [744](#n744) [745](#n745) [746](#n746) [747](#n747) [748](#n748) [749](#n749) [750](#n750) [751](#n751) [752](#n752) [753](#n753) [754](#n754) [755](#n755) [756](#n756) [757](#n757) [758](#n758) [759](#n759) [760](#n760) [761](#n761) [762](#n762) [763](#n763) [764](#n764) [765](#n765) [766](#n766) [767](#n767) [768](#n768) [769](#n769) [770](#n770) [771](#n771) [772](#n772) [773](#n773) [774](#n774) [775](#n775) [776](#n776) [777](#n777) [778](#n778) [779](#n779) [780](#n780) [781](#n781) [782](#n782) [783](#n783) [784](#n784) [785](#n785) [786](#n786) [787](#n787) [788](#n788) [789](#n789) [790](#n790) [791](#n791) [792](#n792) [793](#n793) [794](#n794) [795](#n795) [796](#n796) [797](#n797) [798](#n798) [799](#n799) [800](#n800) [801](#n801) [802](#n802) [803](#n803) [804](#n804) [805](#n805) [806](#n806) [807](#n807) [808](#n808) [809](#n809) [810](#n810) [811](#n811) [812](#n812) [813](#n813) [814](#n814) [815](#n815) [816](#n816) [817](#n817) [818](#n818) [819](#n819) [820](#n820) [821](#n821) [822](#n822) [823](#n823) [824](#n824) [825](#n825) [826](#n826) [827](#n827) [828](#n828) [829](#n829) [830](#n830) [831](#n831) [832](#n832) [833](#n833) [834](#n834) [835](#n835) [836](#n836) [837](#n837) [838](#n838) [839](#n839) [840](#n840) [841](#n841) [842](#n842) [843](#n843) [844](#n844) [845](#n845) [846](#n846) [847](#n847) [848](#n848) [849](#n849) [850](#n850) [851](#n851) [852](#n852) [853](#n853) [854](#n854) [855](#n855) [856](#n856) [857](#n857) [858](#n858) [859](#n859) [860](#n860) [861](#n861) [862](#n862) [863](#n863) [864](#n864) [865](#n865) [866](#n866) [867](#n867) [868](#n868) [869](#n869) [870](#n870) [871](#n871) [872](#n872) [873](#n873) [874](#n874) [875](#n875) [876](#n876) [877](#n877) [878](#n878) [879](#n879) [880](#n880) [881](#n881) [882](#n882) [883](#n883) [884](#n884) [885](#n885) [886](#n886) [887](#n887) [888](#n888) [889](#n889) [890](#n890) [891](#n891) [892](#n892) [893](#n893) [894](#n894) [895](#n895) [896](#n896) [897](#n897) [898](#n898) [899](#n899) [900](#n900) [901](#n901) [902](#n902) [903](#n903) [904](#n904) [905](#n905) [906](#n906) [907](#n907) [908](#n908) [909](#n909) [910](#n910) [911](#n911) [912](#n912) [913](#n913) [914](#n914) [915](#n915) [916](#n916) [917](#n917) [918](#n918) [919](#n919) [920](#n920) [921](#n921) [922](#n922) [923](#n923) [924](#n924) [925](#n925) [926](#n926) [927](#n927) [928](#n928) [929](#n929) [930](#n930) [931](#n931) [932](#n932) [933](#n933) [934](#n934) [935](#n935) [936](#n936) [937](#n937) [938](#n938) [939](#n939) [940](#n940) [941](#n941) [942](#n942) [943](#n943) [944](#n944) [945](#n945) [946](#n946) [947](#n947) [948](#n948) [949](#n949) [950](#n950) [951](#n951) [952](#n952) [953](#n953) [954](#n954) [955](#n955) [956](#n956) [957](#n957) [958](#n958) [959](#n959) [960](#n960) [961](#n961) [962](#n962) [963](#n963) [964](#n964) [965](#n965) [966](#n966) [967](#n967) [968](#n968) [969](#n969) [970](#n970) [971](#n971) [972](#n972) [973](#n973) [974](#n974) [975](#n975) [976](#n976) [977](#n977) [978](#n978) [979](#n979) [980](#n980) [981](#n981) [982](#n982) [983](#n983) [984](#n984) [985](#n985) [986](#n986) [987](#n987) [988](#n988) [989](#n989) [990](#n990) [991](#n991) [992](#n992) [993](#n993) [994](#n994) [995](#n995) [996](#n996) [997](#n997) [998](#n998) [999](#n999) [1000](#n1000) [1001](#n1001) [1002](#n1002) [1003](#n1003) [1004](#n1004) [1005](#n1005) [1006](#n1006) [1007](#n1007) [1008](#n1008) [1009](#n1009) [1010](#n1010) [1011](#n1011) [1012](#n1012) [1013](#n1013) [1014](#n1014) [1015](#n1015) [1016](#n1016) [1017](#n1017) [1018](#n1018) [1019](#n1019) [1020](#n1020) [1021](#n1021) [1022](#n1022) [1023](#n1023) [1024](#n1024) [1025](#n1025) [1026](#n1026) [1027](#n1027) [1028](#n1028) [1029](#n1029) [1030](#n1030) [1031](#n1031) [1032](#n1032) [1033](#n1033) [1034](#n1034) [1035](#n1035) [1036](#n1036) [1037](#n1037) [1038](#n1038) [1039](#n1039) [1040](#n1040) [1041](#n1041) [1042](#n1042) [1043](#n1043) [1044](#n1044) [1045](#n1045) [1046](#n1046) [1047](#n1047) [1048](#n1048) [1049](#n1049) [1050](#n1050) [1051](#n1051) [1052](#n1052) [1053](#n1053) [1054](#n1054) [1055](#n1055) [1056](#n1056) [1057](#n1057) [1058](#n1058) [1059](#n1059) [1060](#n1060) [1061](#n1061) [1062](#n1062) [1063](#n1063) [1064](#n1064) [1065](#n1065) [1066](#n1066) [1067](#n1067) [1068](#n1068) [1069](#n1069) [1070](#n1070) [1071](#n1071) [1072](#n1072) [1073](#n1073) [1074](#n1074) [1075](#n1075) [1076](#n1076) [1077](#n1077) [1078](#n1078) [1079](#n1079) [1080](#n1080) [1081](#n1081) [1082](#n1082) [1083](#n1083) [1084](#n1084) [1085](#n1085) [1086](#n1086) [1087](#n1087) [1088](#n1088) [1089](#n1089) [1090](#n1090) [1091](#n1091) [1092](#n1092) [1093](#n1093) [1094](#n1094) [1095](#n1095) [1096](#n1096) [1097](#n1097) [1098](#n1098) [1099](#n1099) [1100](#n1100) [1101](#n1101) [1102](#n1102) [1103](#n1103) [1104](#n1104) [1105](#n1105) [1106](#n1106) [1107](#n1107) [1108](#n1108) [1109](#n1109) [1110](#n1110) [1111](#n1111) [1112](#n1112) [1113](#n1113) [1114](#n1114) [1115](#n1115) [1116](#n1116) [1117](#n1117) [1118](#n1118) [1119](#n1119) [1120](#n1120) [1121](#n1121) [1122](#n1122) [1123](#n1123) [1124](#n1124) [1125](#n1125) [1126](#n1126) [1127](#n1127) [1128](#n1128) [1129](#n1129) [1130](#n1130) [1131](#n1131) [1132](#n1132) [1133](#n1133) [1134](#n1134) [1135](#n1135) [1136](#n1136) [1137](#n1137) [1138](#n1138) [1139](#n1139) [1140](#n1140) [1141](#n1141) [1142](#n1142) [1143](#n1143) [1144](#n1144) [1145](#n1145) [1146](#n1146) [1147](#n1147) [1148](#n1148) [1149](#n1149) [1150](#n1150) [1151](#n1151) [1152](#n1152) [1153](#n1153) [1154](#n1154) [1155](#n1155) [1156](#n1156) [1157](#n1157) [1158](#n1158) [1159](#n1159) [1160](#n1160) [1161](#n1161) [1162](#n1162) [1163](#n1163) [1164](#n1164) [1165](#n1165) [1166](#n1166) [1167](#n1167) [1168](#n1168) [1169](#n1169) [1170](#n1170) [1171](#n1171) [1172](#n1172) [1173](#n1173) [1174](#n1174) [1175](#n1175) [1176](#n1176) [1177](#n1177) [1178](#n1178) [1179](#n1179) [1180](#n1180) [1181](#n1181) [1182](#n1182) [1183](#n1183) [1184](#n1184) [1185](#n1185) [1186](#n1186) [1187](#n1187) [1188](#n1188) [1189](#n1189) [1190](#n1190) [1191](#n1191) [1192](#n1192) [1193](#n1193) [1194](#n1194) [1195](#n1195) [1196](#n1196) [1197](#n1197) [1198](#n1198) [1199](#n1199) [1200](#n1200) [1201](#n1201) [1202](#n1202) [1203](#n1203) [1204](#n1204) [1205](#n1205) [1206](#n1206) [1207](#n1207) [1208](#n1208) [1209](#n1209) [1210](#n1210) [1211](#n1211) [1212](#n1212) [1213](#n1213) [1214](#n1214) [1215](#n1215) [1216](#n1216) [1217](#n1217) [1218](#n1218) [1219](#n1219) [1220](#n1220) [1221](#n1221) [1222](#n1222) [1223](#n1223) [1224](#n1224) [1225](#n1225) [1226](#n1226) [1227](#n1227) [1228](#n1228) [1229](#n1229) [1230](#n1230) [1231](#n1231) [1232](#n1232) [1233](#n1233) [1234](#n1234) [1235](#n1235) [1236](#n1236) [1237](#n1237) [1238](#n1238) [1239](#n1239) [1240](#n1240) [1241](#n1241) [1242](#n1242) [1243](#n1243) [1244](#n1244) [1245](#n1245) [1246](#n1246) [1247](#n1247) [1248](#n1248) [1249](#n1249) [1250](#n1250) [1251](#n1251) [1252](#n1252) [1253](#n1253) [1254](#n1254) [1255](#n1255) [1256](#n1256) [1257](#n1257) [1258](#n1258) [1259](#n1259) [1260](#n1260) [1261](#n1261) [1262](#n1262) [1263](#n1263) [1264](#n1264) [1265](#n1265) [1266](#n1266) [1267](#n1267) [1268](#n1268) [1269](#n1269) [1270](#n1270) [1271](#n1271) [1272](#n1272) [1273](#n1273) [1274](#n1274) [1275](#n1275) [1276](#n1276) [1277](#n1277) [1278](#n1278) [1279](#n1279) [1280](#n1280) [1281](#n1281) [1282](#n1282) [1283](#n1283) [1284](#n1284) [1285](#n1285) [1286](#n1286) [1287](#n1287) [1288](#n1288) [1289](#n1289) [1290](#n1290) [1291](#n1291) [1292](#n1292) [1293](#n1293) [1294](#n1294) [1295](#n1295) [1296](#n1296) [1297](#n1297) [1298](#n1298) [1299](#n1299) [1300](#n1300) [1301](#n1301) [1302](#n1302) [1303](#n1303) [1304](#n1304) [1305](#n1305) [1306](#n1306) [1307](#n1307) [1308](#n1308) [1309](#n1309) [1310](#n1310) [1311](#n1311) [1312](#n1312) [1313](#n1313) [1314](#n1314) [1315](#n1315) [1316](#n1316) [1317](#n1317) [1318](#n1318) [1319](#n1319) [1320](#n1320) [1321](#n1321) [1322](#n1322) [1323](#n1323) [1324](#n1324) [1325](#n1325) [1326](#n1326) [1327](#n1327) [1328](#n1328) [1329](#n1329) [1330](#n1330) [1331](#n1331) [1332](#n1332) [1333](#n1333) [1334](#n1334) [1335](#n1335) [1336](#n1336) [1337](#n1337) [1338](#n1338) [1339](#n1339) [1340](#n1340) [1341](#n1341) [1342](#n1342) [1343](#n1343) [1344](#n1344) [1345](#n1345) [1346](#n1346) [1347](#n1347) [1348](#n1348) [1349](#n1349) [1350](#n1350) [1351](#n1351) [1352](#n1352) [1353](#n1353) [1354](#n1354) [1355](#n1355) [1356](#n1356) [1357](#n1357) [1358](#n1358) [1359](#n1359) [1360](#n1360) [1361](#n1361) [1362](#n1362) [1363](#n1363) [1364](#n1364) [1365](#n1365) [1366](#n1366) [1367](#n1367) [1368](#n1368) [1369](#n1369) [1370](#n1370) [1371](#n1371) [1372](#n1372) [1373](#n1373) [1374](#n1374) [1375](#n1375) [1376](#n1376) [1377](#n1377) [1378](#n1378) [1379](#n1379) [1380](#n1380) [1381](#n1381) [1382](#n1382) [1383](#n1383) [1384](#n1384) [1385](#n1385) [1386](#n1386) [1387](#n1387) [1388](#n1388) [1389](#n1389) [1390](#n1390) [1391](#n1391) [1392](#n1392) [1393](#n1393) [1394](#n1394) [1395](#n1395) [1396](#n1396) [1397](#n1397) [1398](#n1398) [1399](#n1399) [1400](#n1400) [1401](#n1401) [1402](#n1402) [1403](#n1403) [1404](#n1404) [1405](#n1405) [1406](#n1406) [1407](#n1407) [1408](#n1408) [1409](#n1409) [1410](#n1410) [1411](#n1411) [1412](#n1412) [1413](#n1413) [1414](#n1414) [1415](#n1415) [1416](#n1416) [1417](#n1417) [1418](#n1418) [1419](#n1419) [1420](#n1420) [1421](#n1421) [1422](#n1422) [1423](#n1423) [1424](#n1424) [1425](#n1425) [1426](#n1426) [1427](#n1427) [1428](#n1428) [1429](#n1429) [1430](#n1430) [1431](#n1431) [1432](#n1432) [1433](#n1433) [1434](#n1434) [1435](#n1435) [1436](#n1436) [1437](#n1437) [1438](#n1438) [1439](#n1439) [1440](#n1440) [1441](#n1441) [1442](#n1442) [1443](#n1443) [1444](#n1444) [1445](#n1445) [1446](#n1446) [1447](#n1447) [1448](#n1448) [1449](#n1449) [1450](#n1450) [1451](#n1451) [1452](#n1452) [1453](#n1453) [1454](#n1454) [1455](#n1455) [1456](#n1456) [1457](#n1457) [1458](#n1458) [1459](#n1459) [1460](#n1460) [1461](#n1461) [1462](#n1462) [1463](#n1463) [1464](#n1464) [1465](#n1465) [1466](#n1466) [1467](#n1467) [1468](#n1468) [1469](#n1469) [1470](#n1470) [1471](#n1471) [1472](#n1472) [1473](#n1473) [1474](#n1474) [1475](#n1475) [1476](#n1476) [1477](#n1477) [1478](#n1478) [1479](#n1479) [1480](#n1480) [1481](#n1481) [1482](#n1482) [1483](#n1483) [1484](#n1484) [1485](#n1485) [1486](#n1486) [1487](#n1487) [1488](#n1488) [1489](#n1489) [1490](#n1490) [1491](#n1491) [1492](#n1492) [1493](#n1493) [1494](#n1494) [1495](#n1495) [1496](#n1496) [1497](#n1497) [1498](#n1498) [1499](#n1499) [1500](#n1500) [1501](#n1501) [1502](#n1502) [1503](#n1503) [1504](#n1504) [1505](#n1505) [1506](#n1506) [1507](#n1507) [1508](#n1508) [1509](#n1509) [1510](#n1510) [1511](#n1511) [1512](#n1512) [1513](#n1513) [1514](#n1514) [1515](#n1515) [1516](#n1516) [1517](#n1517) [1518](#n1518) [1519](#n1519) [1520](#n1520) [1521](#n1521) [1522](#n1522) [1523](#n1523) [1524](#n1524) [1525](#n1525) [1526](#n1526) [1527](#n1527) [1528](#n1528) [1529](#n1529) [1530](#n1530) [1531](#n1531) [1532](#n1532) [1533](#n1533) [1534](#n1534) [1535](#n1535) [1536](#n1536) [1537](#n1537) [1538](#n1538) [1539](#n1539) [1540](#n1540) [1541](#n1541) [1542](#n1542) [1543](#n1543) [1544](#n1544) [1545](#n1545) [1546](#n1546) [1547](#n1547) [1548](#n1548) [1549](#n1549) [1550](#n1550) [1551](#n1551) [1552](#n1552) [1553](#n1553) [1554](#n1554) [1555](#n1555) [1556](#n1556) [1557](#n1557) [1558](#n1558) [1559](#n1559) [1560](#n1560) [1561](#n1561) [1562](#n1562) [1563](#n1563) [1564](#n1564) [1565](#n1565) [1566](#n1566) [1567](#n1567) [1568](#n1568) [1569](#n1569) [1570](#n1570) [1571](#n1571) [1572](#n1572) [1573](#n1573) [1574](#n1574) [1575](#n1575) [1576](#n1576) [1577](#n1577) [1578](#n1578) [1579](#n1579) [1580](#n1580) [1581](#n1581) [1582](#n1582) [1583](#n1583) [1584](#n1584) [1585](#n1585) [1586](#n1586) [1587](#n1587) [1588](#n1588) [1589](#n1589) [1590](#n1590) [1591](#n1591) [1592](#n1592) [1593](#n1593) [1594](#n1594) [1595](#n1595) [1596](#n1596) [1597](#n1597) [1598](#n1598) [1599](#n1599) [1600](#n1600) [1601](#n1601) [1602](#n1602) [1603](#n1603) [1604](#n1604) [1605](#n1605) [1606](#n1606) [1607](#n1607) [1608](#n1608) [1609](#n1609) [1610](#n1610) [1611](#n1611) [1612](#n1612) [1613](#n1613) [1614](#n1614) [1615](#n1615) [1616](#n1616) [1617](#n1617) [1618](#n1618) [1619](#n1619) [1620](#n1620) [1621](#n1621) [1622](#n1622) [1623](#n1623) [1624](#n1624) [1625](#n1625) [1626](#n1626) [1627](#n1627) [1628](#n1628) [1629](#n1629) [1630](#n1630) [1631](#n1631) [1632](#n1632) [1633](#n1633) [1634](#n1634) [1635](#n1635) [1636](#n1636) [1637](#n1637) [1638](#n1638) [1639](#n1639) [1640](#n1640) [1641](#n1641) [1642](#n1642) [1643](#n1643) [1644](#n1644) [1645](#n1645) [1646](#n1646) [1647](#n1647) [1648](#n1648) [1649](#n1649) [1650](#n1650) [1651](#n1651) [1652](#n1652) [1653](#n1653) [1654](#n1654) [1655](#n1655) [1656](#n1656) [1657](#n1657) [1658](#n1658) [1659](#n1659) [1660](#n1660) [1661](#n1661) [1662](#n1662) [1663](#n1663) [1664](#n1664) [1665](#n1665) [1666](#n1666) [1667](#n1667) [1668](#n1668) [1669](#n1669) [1670](#n1670) [1671](#n1671) [1672](#n1672) [1673](#n1673) [1674](#n1674) [1675](#n1675) [1676](#n1676) [1677](#n1677) [1678](#n1678) [1679](#n1679) [1680](#n1680) [1681](#n1681) [1682](#n1682) [1683](#n1683) [1684](#n1684) [1685](#n1685) [1686](#n1686) [1687](#n1687) [1688](#n1688) [1689](#n1689) [1690](#n1690) [1691](#n1691) [1692](#n1692) [1693](#n1693) [1694](#n1694) [1695](#n1695) [1696](#n1696) [1697](#n1697) [1698](#n1698) [1699](#n1699) [1700](#n1700) [1701](#n1701) [1702](#n1702) [1703](#n1703) [1704](#n1704) [1705](#n1705) [1706](#n1706) [1707](#n1707) [1708](#n1708) [1709](#n1709) [1710](#n1710) [1711](#n1711) [1712](#n1712) [1713](#n1713) [1714](#n1714) [1715](#n1715) [1716](#n1716) [1717](#n1717) [1718](#n1718) [1719](#n1719) [1720](#n1720) [1721](#n1721) [1722](#n1722) [1723](#n1723) [1724](#n1724) [1725](#n1725) [1726](#n1726) [1727](#n1727) [1728](#n1728) [1729](#n1729) [1730](#n1730) [1731](#n1731) [1732](#n1732) [1733](#n1733) [1734](#n1734) [1735](#n1735) [1736](#n1736) [1737](#n1737) [1738](#n1738) [1739](#n1739) [1740](#n1740) [1741](#n1741) [1742](#n1742) [1743](#n1743) [1744](#n1744) [1745](#n1745) [1746](#n1746) [1747](#n1747) [1748](#n1748) [1749](#n1749) [1750](#n1750) [1751](#n1751) [1752](#n1752) [1753](#n1753) [1754](#n1754) [1755](#n1755) [1756](#n1756) [1757](#n1757) [1758](#n1758) [1759](#n1759) [1760](#n1760) [1761](#n1761) [1762](#n1762) [1763](#n1763) [1764](#n1764) [1765](#n1765) [1766](#n1766) [1767](#n1767) [1768](#n1768) [1769](#n1769) [1770](#n1770) [1771](#n1771) [1772](#n1772) [1773](#n1773) [1774](#n1774) [1775](#n1775) [1776](#n1776) [1777](#n1777) [1778](#n1778) [1779](#n1779) [1780](#n1780) [1781](#n1781) [1782](#n1782) [1783](#n1783) [1784](#n1784) [1785](#n1785) [1786](#n1786) [1787](#n1787) [1788](#n1788) [1789](#n1789) [1790](#n1790) [1791](#n1791) [1792](#n1792) [1793](#n1793) [1794](#n1794) [1795](#n1795) [1796](#n1796) [1797](#n1797) [1798](#n1798) [1799](#n1799) [1800](#n1800) [1801](#n1801) [1802](#n1802) [1803](#n1803) [1804](#n1804) [1805](#n1805) [1806](#n1806) [1807](#n1807) [1808](#n1808) [1809](#n1809) [1810](#n1810) [1811](#n1811) [1812](#n1812) [1813](#n1813) [1814](#n1814) [1815](#n1815) [1816](#n1816) [1817](#n1817) [1818](#n1818) [1819](#n1819) [1820](#n1820) [1821](#n1821) [1822](#n1822) [1823](#n1823) [1824](#n1824) [1825](#n1825) [1826](#n1826) [1827](#n1827) [1828](#n1828) [1829](#n1829) [1830](#n1830) [1831](#n1831) [1832](#n1832) [1833](#n1833) [1834](#n1834) [1835](#n1835) [1836](#n1836) [1837](#n1837) [1838](#n1838) [1839](#n1839) [1840](#n1840) [1841](#n1841) [1842](#n1842) [1843](#n1843) [1844](#n1844) [1845](#n1845) [1846](#n1846) [1847](#n1847) [1848](#n1848) [1849](#n1849) [1850](#n1850) [1851](#n1851)  ``` | ``` /* POSIX extended headers for tar.     Copyright (C) 2003-2021 Free Software Foundation, Inc.     This file is part of GNU tar.     GNU tar is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 3 of the License, or    (at your option) any later version.     GNU tar is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */  #include <system.h>  #include <fnmatch.h> #include <hash.h> #include <inttostr.h> #include <quotearg.h>  #include "common.h"  static void xheader_init (struct xheader *xhdr); static bool xheader_protected_pattern_p (char const *pattern); static bool xheader_protected_keyword_p (char const *keyword); static void xheader_set_single_keyword (char *) __attribute__ ((noreturn));  /* Used by xheader_finish() */ static void code_string (char const *string, char const *keyword, 			 struct xheader *xhdr);  /* Number of global headers written so far. */ static size_t global_header_count; /* FIXME: Possibly it should be reset after changing the volume.    POSIX %n specification says that it is expanded to the sequence    number of current global header in *the* archive. However, for    multi-volume archives this will yield duplicate header names    in different volumes, which I'd like to avoid. The best way    to solve this would be to use per-archive header count as required    by POSIX *and* set globexthdr.name to, say,    $TMPDIR/GlobalHead.%p.$NUMVOLUME.%n.     However it should wait until buffer.c is finally rewritten */   /* Interface functions to obstacks */  static void x_obstack_grow (struct xheader *xhdr, const char *ptr, size_t length) {   obstack_grow (xhdr->stk, ptr, length);   xhdr->size += length; }  static void x_obstack_1grow (struct xheader *xhdr, char c) {   obstack_1grow (xhdr->stk, c);   xhdr->size++; }  static void x_obstack_blank (struct xheader *xhdr, size_t length) {   obstack_blank (xhdr->stk, length);   xhdr->size += length; }   /* Keyword options */  struct keyword_list {   struct keyword_list *next;   char *pattern;   char *value; };   /* List of keyword patterns set by delete= option */ static struct keyword_list *keyword_pattern_list;  /* List of keyword/value pairs set by 'keyword=value' option */ static struct keyword_list *keyword_global_override_list;  /* List of keyword/value pairs set by 'keyword:=value' option */ static struct keyword_list *keyword_override_list;  /* List of keyword/value pairs decoded from the last 'g' type header */ static struct keyword_list *global_header_override_list;  /* Template for the name field of an 'x' type header */ static char *exthdr_name;  static char *exthdr_mtime_option; static time_t exthdr_mtime;  /* Template for the name field of a 'g' type header */ static char *globexthdr_name;  static char *globexthdr_mtime_option; static time_t globexthdr_mtime;  bool xheader_keyword_deleted_p (const char *kw) {   struct keyword_list *kp;    for (kp = keyword_pattern_list; kp; kp = kp->next)     if (fnmatch (kp->pattern, kw, 0) == 0)       return true;   return false; }  static bool xheader_keyword_override_p (const char *keyword) {   struct keyword_list *kp;    for (kp = keyword_override_list; kp; kp = kp->next)     if (strcmp (kp->pattern, keyword) == 0)       return true;   return false; }  static void xheader_list_append (struct keyword_list **root, char const *kw, 		     char const *value) {   struct keyword_list *kp = xmalloc (sizeof *kp);   kp->pattern = xstrdup (kw);   kp->value = value ? xstrdup (value) : NULL;   kp->next = *root;   *root = kp; }  static void xheader_list_destroy (struct keyword_list **root) {   if (root)     {       struct keyword_list *kw = *root;       while (kw) 	{ 	  struct keyword_list *next = kw->next; 	  free (kw->pattern); 	  free (kw->value); 	  free (kw); 	  kw = next; 	}       *root = NULL;     } }  static void xheader_set_single_keyword (char *kw) {   USAGE_ERROR ((0, 0, _("Keyword %s is unknown or not yet implemented"), kw)); }  static void assign_time_option (char **sval, time_t *tval, const char *input) {   char *p;   struct timespec t = decode_timespec (input, &p, false);   if (! valid_timespec (t) || *p)     ERROR ((0, 0, _("Time stamp is out of allowed range")));   else     {       *tval = t.tv_sec;       assign_string (sval, input);     } }  static void xheader_set_keyword_equal (char *kw, char *eq) {   bool global = true;   char *p = eq;    if (eq == kw)     USAGE_ERROR ((0, 0, _("Malformed pax option: %s"), quote (kw)));        if (eq[-1] == ':')     {       p--;       global = false;     }    while (p > kw && isspace ((unsigned char) *p))     p--;    *p = 0;    for (p = eq + 1; *p && isspace ((unsigned char) *p); p++)     ;    if (strcmp (kw, "delete") == 0)     {       if (xheader_protected_pattern_p (p)) 	USAGE_ERROR ((0, 0, _("Pattern %s cannot be used"), quote (p)));       xheader_list_append (&keyword_pattern_list, p, NULL);     }   else if (strcmp (kw, "exthdr.name") == 0)     assign_string (&exthdr_name, p);   else if (strcmp (kw, "globexthdr.name") == 0)     assign_string (&globexthdr_name, p);   else if (strcmp (kw, "exthdr.mtime") == 0)     assign_time_option (&exthdr_mtime_option, &exthdr_mtime, p);   else if (strcmp (kw, "globexthdr.mtime") == 0)     assign_time_option (&globexthdr_mtime_option, &globexthdr_mtime, p);   else     {       if (xheader_protected_keyword_p (kw)) 	USAGE_ERROR ((0, 0, _("Keyword %s cannot be overridden"), kw));       if (global) 	xheader_list_append (&keyword_global_override_list, kw, p);       else 	xheader_list_append (&keyword_override_list, kw, p);     } }  void xheader_set_option (char *string) {   char *token;   for (token = strtok (string, ","); token; token = strtok (NULL, ","))     {       char *p = strchr (token, '=');       if (!p) 	xheader_set_single_keyword (token);       else 	xheader_set_keyword_equal (token, p);     } }  /*     string Includes:          Replaced By:      %d                       The directory name of the file,                               equivalent to the result of the                               dirname utility on the translated                               file name.      %f                       The filename of the file, equivalent                               to the result of the basename                               utility on the translated file name.      %p                       The process ID of the pax process.      %n                       The value of the 3rd argument.      %%                       A '%' character. */  char * xheader_format_name (struct tar_stat_info *st, const char *fmt, size_t n) {   char *buf;   size_t len;   char *q;   const char *p;   char *dirp = NULL;   char *dir = NULL;   char *base = NULL;   char pidbuf[UINTMAX_STRSIZE_BOUND];   char const *pptr = NULL;   char nbuf[UINTMAX_STRSIZE_BOUND];   char const *nptr = NULL;    len = 0;   for (p = fmt; *p; p++)     {       if (*p == '%' && p[1]) 	{ 	  switch (*++p) 	    { 	    case '%': 	      len++; 	      break;  	    case 'd': 	      if (st) 		{ 		  if (!dirp) 		    dirp = dir_name (st->orig_file_name); 		  dir = safer_name_suffix (dirp, false, absolute_names_option); 		  len += strlen (dir); 		} 	      break;  	    case 'f': 	      if (st) 		{ 		  base = last_component (st->orig_file_name); 		  len += strlen (base); 		} 	      break;  	    case 'p': 	      pptr = umaxtostr (getpid (), pidbuf); 	      len += pidbuf + sizeof pidbuf - 1 - pptr; 	      break;  	    case 'n': 	      nptr = umaxtostr (n, nbuf); 	      len += nbuf + sizeof nbuf - 1 - nptr; 	      break; 	       	    default: 	      len += 2; 	    } 	}       else 	len++;     }    buf = xmalloc (len + 1);   for (q = buf, p = fmt; *p; )     {       if (*p == '%') 	{ 	  switch (p[1]) 	    { 	    case '%': 	      *q++ = *p++; 	      p++; 	      break;  	    case 'd': 	      if (dir) 		q = stpcpy (q, dir); 	      p += 2; 	      break;  	    case 'f': 	      if (base) 		q = stpcpy (q, base); 	      p += 2; 	      break;  	    case 'p': 	      q = stpcpy (q, pptr); 	      p += 2; 	      break;  	    case 'n': 	      q = stpcpy (q, nptr); 	      p += 2; 	      break;   	    default: 	      *q++ = *p++; 	      if (*p) 		*q++ = *p++; 	    } 	}       else 	*q++ = *p++;     }    free (dirp);    /* Do not allow it to end in a slash */   while (q > buf && ISSLASH (q[-1]))     q--;   *q = 0;   return buf; }  /* Table of templates for the names of POSIX extended headers.    Indexed by the the type of the header (per-file or global)    and POSIX compliance mode (0 or q depending on whether    POSIXLY_CORRECT environment variable is set. */ static const char *header_template[][2] = {   /* Individual header templates: */   { "%d/PaxHeaders/%f", "%d/PaxHeaders.%p/%f" },   /* Global header templates: */   { "/GlobalHead.%n", "/GlobalHead.%p.%n" } }; /* Indices to the above table */ enum {   pax_file_header,   pax_global_header }; /* Return the name for the POSIX extended header T */ #define HEADER_TEMPLATE(t) header_template[t][posixly_correct]  char * xheader_xhdr_name (struct tar_stat_info *st) {   if (!exthdr_name)     assign_string (&exthdr_name, HEADER_TEMPLATE (pax_file_header));   return xheader_format_name (st, exthdr_name, 0); }  char * xheader_ghdr_name (void) {   if (!globexthdr_name)     {       size_t len;       const char *global_header_template = HEADER_TEMPLATE (pax_global_header);       const char *tmp = getenv ("TMPDIR");       if (!tmp) 	tmp = "/tmp";       len = strlen (tmp) + strlen (global_header_template) + 1;       globexthdr_name = xmalloc (len);       strcpy(globexthdr_name, tmp);       strcat(globexthdr_name, global_header_template);     }    return xheader_format_name (NULL, globexthdr_name, global_header_count + 1); }  void xheader_write (char type, char *name, time_t t, struct xheader *xhdr) {   union block *header;   size_t size;   char *p;    size = xhdr->size;   switch (type)     {     case XGLTYPE:       if (globexthdr_mtime_option) 	t = globexthdr_mtime;       break;      case XHDTYPE:       if (exthdr_mtime_option) 	t = exthdr_mtime;       break;     }   header = start_private_header (name, size, t);   header->header.typeflag = type;    simple_finish_header (header);    p = xhdr->buffer;    do     {       size_t len;        header = find_next_block ();       len = BLOCKSIZE;       if (len > size) 	len = size;       memcpy (header->buffer, p, len);       if (len < BLOCKSIZE) 	memset (header->buffer + len, 0, BLOCKSIZE - len);       p += len;       size -= len;       set_next_block_after (header);     }   while (size > 0);   xheader_destroy (xhdr);    if (type == XGLTYPE)     global_header_count++; }  void xheader_write_global (struct xheader *xhdr) {   if (keyword_global_override_list)     {       struct keyword_list *kp;        xheader_init (xhdr);       for (kp = keyword_global_override_list; kp; kp = kp->next) 	code_string (kp->value, kp->pattern, xhdr);     }   if (xhdr->stk)     {       char *name;        xheader_finish (xhdr);       name = xheader_ghdr_name ();       xheader_write (XGLTYPE, name, start_time.tv_sec, xhdr);       free (name);     } }  /* Forbid modifications of the global extended header */ void xheader_forbid_global (void) {   if (keyword_global_override_list)     USAGE_ERROR ((0, 0, _("can't update global extended header record"))); }  void xheader_xattr_init (struct tar_stat_info *st) {   st->xattr_map = NULL;   st->xattr_map_size = 0;    st->acls_a_ptr = NULL;   st->acls_a_len = 0;   st->acls_d_ptr = NULL;   st->acls_d_len = 0;   st->cntx_name = NULL; }  void xheader_xattr_free (struct xattr_array *xattr_map, size_t xattr_map_size) {   size_t scan = 0;    while (scan < xattr_map_size)     {       free (xattr_map[scan].xkey);       free (xattr_map[scan].xval_ptr);        ++scan;     }   free (xattr_map); }  static void xheader_xattr__add (struct xattr_array **xattr_map, 		    size_t *xattr_map_size, 		    const char *key, const char *val, size_t len) {   size_t pos = (*xattr_map_size)++;    *xattr_map = xrealloc (*xattr_map,                          *xattr_map_size * sizeof(struct xattr_array));   (*xattr_map)[pos].xkey = xstrdup (key);   (*xattr_map)[pos].xval_ptr = xmemdup (val, len + 1);   (*xattr_map)[pos].xval_len = len; }  /* This is reversal function for xattr_encode_keyword.  See comment for    xattr_encode_keyword() for more info. */ static void xattr_decode_keyword (char *keyword) {   char *kpr, *kpl; /* keyword pointer left/right */   kpr = kpl = keyword;    for (;;)     {       if (*kpr == '%')         {           if (kpr[1] == '3' && kpr[2] == 'D')             {               *kpl = '=';               kpr += 3;               kpl ++;               continue;             }           else if (kpr[1] == '2' && kpr[2] == '5')             {               *kpl = '%';               kpr += 3;               kpl ++;               continue;             }         }        *kpl = *kpr;        if (*kpr == 0)         break;        kpr++;       kpl++;     } }  void xheader_xattr_add (struct tar_stat_info *st, 		   const char *key, const char *val, size_t len) {   size_t klen = strlen (key);   char *xkey = xmalloc (strlen("SCHILY.xattr.") + klen + 1);   char *tmp = xkey;    tmp = stpcpy (tmp, "SCHILY.xattr.");   stpcpy (tmp, key);    xheader_xattr__add (&st->xattr_map, &st->xattr_map_size, xkey, val, len);    free (xkey); }  void xheader_xattr_copy (const struct tar_stat_info *st, 		    struct xattr_array **xattr_map, size_t *xattr_map_size) {   size_t scan = 0;    *xattr_map = NULL;   *xattr_map_size = 0;    while (scan < st->xattr_map_size)     {       char  *key = st->xattr_map[scan].xkey;       char  *val = st->xattr_map[scan].xval_ptr;       size_t len = st->xattr_map[scan].xval_len;        xheader_xattr__add(xattr_map, xattr_map_size, key, val, len);        ++scan;     } }   /* General Interface */  #define XHDR_PROTECTED 0x01 #define XHDR_GLOBAL    0x02  struct xhdr_tab {   char const *keyword;   void (*coder) (struct tar_stat_info const *, char const *, 		 struct xheader *, void const *data);   void (*decoder) (struct tar_stat_info *, char const *, char const *, size_t);   int flags;   bool prefix; /* select handler comparing prefix only */ };  /* This declaration must be extern, because ISO C99 section 6.9.2    prohibits a tentative definition that has both internal linkage and    incomplete type.  If we made it static, we'd have to declare its    size which would be a maintenance pain; if we put its initializer    here, we'd need a boatload of forward declarations, which would be    even more of a pain.  */ extern struct xhdr_tab const xhdr_tab[];  static struct xhdr_tab const * locate_handler (char const *keyword) {   struct xhdr_tab const *p;    for (p = xhdr_tab; p->keyword; p++)     if (p->prefix)       {         if (strncmp (p->keyword, keyword, strlen(p->keyword)) == 0)           return p;       }     else       {         if (strcmp (p->keyword, keyword) == 0)           return p;       }    return NULL; }  static bool xheader_protected_pattern_p (const char *pattern) {   struct xhdr_tab const *p;    for (p = xhdr_tab; p->keyword; p++)     if (!p->prefix && (p->flags & XHDR_PROTECTED)         && fnmatch (pattern, p->keyword, 0) == 0)       return true;   return false; }  static bool xheader_protected_keyword_p (const char *keyword) {   struct xhdr_tab const *p;    for (p = xhdr_tab; p->keyword; p++)     if (!p->prefix && (p->flags & XHDR_PROTECTED)         && strcmp (p->keyword, keyword) == 0)       return true;   return false; }  /* Decode a single extended header record, advancing *PTR to the next record.    Return true on success, false otherwise.  */ static bool decode_record (struct xheader *xhdr, 	       char **ptr, 	       void (*handler) (void *, char const *, char const *, size_t), 	       void *data) {   char *start = *ptr;   char *p = start;   size_t len;   char *len_lim;   char const *keyword;   char *nextp;   size_t len_max = xhdr->buffer + xhdr->size - start;    while (*p == ' ' || *p == '\t')     p++;    if (! ISDIGIT (*p))     {       if (*p) 	ERROR ((0, 0, _("Malformed extended header: missing length")));       return false;     }    len = strtoumax (p, &len_lim, 10);    if (len_max < len)     {       int len_len = len_lim - p;       ERROR ((0, 0, _("Extended header length %*s is out of range"), 	      len_len, p));       return false;     }    nextp = start + len;    for (p = len_lim; *p == ' ' || *p == '\t'; p++)     continue;   if (p == len_lim)     {       ERROR ((0, 0, 	      _("Malformed extended header: missing blank after length")));       return false;     }    keyword = p;   p = strchr (p, '=');   if (! (p && p < nextp))     {       ERROR ((0, 0, _("Malformed extended header: missing equal sign")));       return false;     }    if (nextp[-1] != '\n')     {       ERROR ((0, 0, _("Malformed extended header: missing newline")));       return false;     }    *p = nextp[-1] = '\0';   handler (data, keyword, p + 1, nextp - p - 2); /* '=' + trailing '\n' */   *p = '=';   nextp[-1] = '\n';   *ptr = nextp;   return true; }  static void run_override_list (struct keyword_list *kp, struct tar_stat_info *st) {   for (; kp; kp = kp->next)     {       struct xhdr_tab const *t = locate_handler (kp->pattern);       if (t) 	t->decoder (st, t->keyword, kp->value, strlen (kp->value));     } }  static void decx (void *data, char const *keyword, char const *value, size_t size) {   struct xhdr_tab const *t;   struct tar_stat_info *st = data;    if (xheader_keyword_deleted_p (keyword)       || xheader_keyword_override_p (keyword))     return;    t = locate_handler (keyword);   if (t)     t->decoder (st, keyword, value, size);   else     WARNOPT (WARN_UNKNOWN_KEYWORD, 	     (0, 0, _("Ignoring unknown extended header keyword '%s'"), 	      keyword)); }  void xheader_decode (struct tar_stat_info *st) {   run_override_list (keyword_global_override_list, st);   run_override_list (global_header_override_list, st);    if (st->xhdr.size)     {       char *p = st->xhdr.buffer + BLOCKSIZE;       while (decode_record (&st->xhdr, &p, decx, st)) 	continue;     }   run_override_list (keyword_override_list, st);    /* The archived (effective) file size is always set directly in tar header      field, possibly overridden by "size" extended header - in both cases,      result is now decoded in st->stat.st_size */   st->archive_file_size = st->stat.st_size;    /* The real file size (given by stat()) may be redefined for sparse      files in "GNU.sparse.realsize" extended header */   if (st->real_size_set)     st->stat.st_size = st->real_size; }  static void decg (void *data, char const *keyword, char const *value,       size_t size __attribute__((unused))) {   struct keyword_list **kwl = data;   struct xhdr_tab const *tab = locate_handler (keyword);   if (tab && (tab->flags & XHDR_GLOBAL))     tab->decoder (data, keyword, value, size);   else     xheader_list_append (kwl, keyword, value); }  void xheader_decode_global (struct xheader *xhdr) {   if (xhdr->size)     {       char *p = xhdr->buffer + BLOCKSIZE;        xheader_list_destroy (&global_header_override_list);       while (decode_record (xhdr, &p, decg, &global_header_override_list)) 	continue;     } }  static void xheader_init (struct xheader *xhdr) {   if (!xhdr->stk)     {       xhdr->stk = xmalloc (sizeof *xhdr->stk);       obstack_init (xhdr->stk);     } }  void xheader_store (char const *keyword, struct tar_stat_info *st, 	       void const *data) {   struct xhdr_tab const *t;    if (st->xhdr.buffer)     return;   t = locate_handler (keyword);   if (!t || !t->coder)     return;   if (xheader_keyword_deleted_p (keyword))     return;   xheader_init (&st->xhdr);   if (!xheader_keyword_override_p (keyword))     t->coder (st, keyword, &st->xhdr, data); }  void xheader_read (struct xheader *xhdr, union block *p, off_t size) {   size_t j = 0;    if (size < 0)     size = 0; /* Already diagnosed.  */    if (SIZE_MAX - BLOCKSIZE <= size)     xalloc_die ();    size += BLOCKSIZE;   xhdr->size = size;   xhdr->buffer = xmalloc (size + 1);   xhdr->buffer[size] = '\0';    do     {       size_t len = size;        if (len > BLOCKSIZE) 	len = BLOCKSIZE;        if (!p) 	FATAL_ERROR ((0, 0, _("Unexpected EOF in archive")));        memcpy (&xhdr->buffer[j], p->buffer, len);       set_next_block_after (p);        p = find_next_block ();        j += len;       size -= len;     }   while (size > 0); }  /* xattr_encode_keyword() substitutes '=' ~~> '%3D' and '%' ~~> '%25'    in extended attribute keywords.  This is needed because the '=' character    has special purpose in extended attribute header - it splits keyword and    value part of header.  If there was the '=' occurrence allowed inside    keyword, there would be no unambiguous way how to decode this extended    attribute.     (http://lists.gnu.org/archive/html/bug-tar/2012-10/msg00017.html)  */ static char * xattr_encode_keyword(const char *keyword) {   static char *encode_buffer = NULL;   static size_t encode_buffer_size = 0;   size_t bp; /* keyword/buffer pointers */    if (!encode_buffer)     {       encode_buffer_size = 256;       encode_buffer = xmalloc (encode_buffer_size);     }   else     *encode_buffer = 0;    for (bp = 0; *keyword != 0; ++bp, ++keyword)     {       char c = *keyword;        if (bp + 2 /* enough for URL encoding also.. */ >= encode_buffer_size)         {           encode_buffer = x2realloc (encode_buffer, &encode_buffer_size);         }        if (c == '%')         {           strcpy (encode_buffer + bp, "%25");           bp += 2;         }       else if (c == '=')         {           strcpy (encode_buffer + bp, "%3D");           bp += 2;         }       else         encode_buffer[bp] = c;     }    encode_buffer[bp] = 0;    return encode_buffer; }  static void xheader_print_n (struct xheader *xhdr, char const *keyword, 		 char const *value, size_t vsize) {   size_t p;   size_t n = 0;   char nbuf[UINTMAX_STRSIZE_BOUND];   char const *np;   size_t len, klen;    keyword = xattr_encode_keyword (keyword);   klen = strlen (keyword);   len = klen + vsize + 3; /* ' ' + '=' + '\n' */    do     {       p = n;       np = umaxtostr (len + p, nbuf);       n = nbuf + sizeof nbuf - 1 - np;     }   while (n != p);    x_obstack_grow (xhdr, np, n);   x_obstack_1grow (xhdr, ' ');   x_obstack_grow (xhdr, keyword, klen);   x_obstack_1grow (xhdr, '=');   x_obstack_grow (xhdr, value, vsize);   x_obstack_1grow (xhdr, '\n'); }  static void xheader_print (struct xheader *xhdr, char const *keyword, char const *value) {   xheader_print_n (xhdr, keyword, value, strlen (value)); }  void xheader_finish (struct xheader *xhdr) {   struct keyword_list *kp;    for (kp = keyword_override_list; kp; kp = kp->next)     code_string (kp->value, kp->pattern, xhdr);    xhdr->buffer = obstack_finish (xhdr->stk); }  void xheader_destroy (struct xheader *xhdr) {   if (xhdr->stk)     {       obstack_free (xhdr->stk, NULL);       free (xhdr->stk);       xhdr->stk = NULL;     }   else     free (xhdr->buffer);   xhdr->buffer = 0;   xhdr->size = 0; }   /* Buildable strings */  void xheader_string_begin (struct xheader *xhdr) {   xhdr->string_length = 0; }  void xheader_string_add (struct xheader *xhdr, char const *s) {   if (xhdr->buffer)     return;   xheader_init (xhdr);   xhdr->string_length += strlen (s);   x_obstack_grow (xhdr, s, strlen (s)); }  bool xheader_string_end (struct xheader *xhdr, char const *keyword) {   uintmax_t len;   uintmax_t p;   uintmax_t n = 0;   size_t size;   char nbuf[UINTMAX_STRSIZE_BOUND];   char const *np;   char *cp;    if (xhdr->buffer)     return false;   xheader_init (xhdr);    len = strlen (keyword) + xhdr->string_length + 3; /* ' ' + '=' + '\n' */    do     {       p = n;       np = umaxtostr (len + p, nbuf);       n = nbuf + sizeof nbuf - 1 - np;     }   while (n != p);    p = strlen (keyword) + n + 2;   size = p;   if (size != p)     {       ERROR ((0, 0,         _("Generated keyword/value pair is too long (keyword=%s, length=%s)"), 	      keyword, nbuf));       obstack_free (xhdr->stk, obstack_finish (xhdr->stk));       return false;     }   x_obstack_blank (xhdr, p);   x_obstack_1grow (xhdr, '\n');   cp = (char*) obstack_next_free (xhdr->stk) - xhdr->string_length - p - 1;   memmove (cp + p, cp, xhdr->string_length);   cp = stpcpy (cp, np);   *cp++ = ' ';   cp = stpcpy (cp, keyword);   *cp++ = '=';   return true; }   /* Implementations */  static void out_of_range_header (char const *keyword, char const *value, 		     intmax_t minval, uintmax_t maxval) {   char minval_buf[INT_BUFSIZE_BOUND (intmax_t)];   char maxval_buf[UINTMAX_STRSIZE_BOUND];   char *minval_string = imaxtostr (minval, minval_buf);   char *maxval_string = umaxtostr (maxval, maxval_buf);    /* TRANSLATORS: The first %s is the pax extended header keyword      (atime, gid, etc.).  */   ERROR ((0, 0, _("Extended header %s=%s is out of range %s..%s"), 	  keyword, value, minval_string, maxval_string)); }  static void code_string (char const *string, char const *keyword, struct xheader *xhdr) {   char *outstr;   if (!utf8_convert (true, string, &outstr))     {       /* FIXME: report error */       outstr = xstrdup (string);     }   xheader_print (xhdr, keyword, outstr);   free (outstr); }  static void decode_string (char **string, char const *arg) {   if (*string)     {       free (*string);       *string = NULL;     }   if (!utf8_convert (false, arg, string))     {       /* FIXME: report error and act accordingly to --pax invalid=UTF-8 */       assign_string (string, arg);     } }  static void code_time (struct timespec t, char const *keyword, struct xheader *xhdr) {   char buf[TIMESPEC_STRSIZE_BOUND];   xheader_print (xhdr, keyword, code_timespec (t, buf)); }  static bool decode_time (struct timespec *ts, char const *arg, char const *keyword) {   char *arg_lim;   struct timespec t = decode_timespec (arg, &arg_lim, true);    if (! valid_timespec (t))     {       if (arg < arg_lim && !*arg_lim) 	out_of_range_header (keyword, arg, TYPE_MINIMUM (time_t), 			     TYPE_MAXIMUM (time_t));       else 	ERROR ((0, 0, _("Malformed extended header: invalid %s=%s"), 		keyword, arg));       return false;     }    *ts = t;   return true; }  static void code_signed_num (uintmax_t value, char const *keyword, 		 intmax_t minval, uintmax_t maxval, struct xheader *xhdr) {   char sbuf[SYSINT_BUFSIZE];   xheader_print (xhdr, keyword, sysinttostr (value, minval, maxval, sbuf)); }  static void code_num (uintmax_t value, char const *keyword, struct xheader *xhdr) {   code_signed_num (value, keyword, 0, UINTMAX_MAX, xhdr); }  static bool decode_signed_num (intmax_t *num, char const *arg, 		   intmax_t minval, uintmax_t maxval, 		   char const *keyword) {   char *arg_lim;   intmax_t u = strtosysint (arg, &arg_lim, minval, maxval);    if (errno == EINVAL || *arg_lim)     {       ERROR ((0, 0, _("Malformed extended header: invalid %s=%s"), 	      keyword, arg));       return false;     }    if (errno == ERANGE)     {       out_of_range_header (keyword, arg, minval, maxval);       return false;     }    *num = u;   return true; }  static bool decode_num (uintmax_t *num, char const *arg, uintmax_t maxval, 	    char const *keyword) {   intmax_t i;   if (! decode_signed_num (&i, arg, 0, maxval, keyword))     return false;   *num = i;   return true; }  static void dummy_coder (struct tar_stat_info const *st __attribute__ ((unused)), 	     char const *keyword __attribute__ ((unused)), 	     struct xheader *xhdr __attribute__ ((unused)), 	     void const *data __attribute__ ((unused))) { }  static void dummy_decoder (struct tar_stat_info *st __attribute__ ((unused)), 	       char const *keyword __attribute__ ((unused)), 	       char const *arg __attribute__ ((unused)), 	       size_t size __attribute__((unused))) { }  static void atime_coder (struct tar_stat_info const *st, char const *keyword, 	     struct xheader *xhdr, void const *data __attribute__ ((unused))) {   code_time (st->atime, keyword, xhdr); }  static void atime_decoder (struct tar_stat_info *st, 	       char const *keyword, 	       char const *arg, 	       size_t size __attribute__((unused))) {   struct timespec ts;   if (decode_time (&ts, arg, keyword))     st->atime = ts; }  static void gid_coder (struct tar_stat_info const *st, char const *keyword, 	   struct xheader *xhdr, void const *data __attribute__ ((unused))) {   code_signed_num (st->stat.st_gid, keyword, 		   TYPE_MINIMUM (gid_t), TYPE_MAXIMUM (gid_t), xhdr); }  static void gid_decoder (struct tar_stat_info *st, 	     char const *keyword, 	     char const *arg, 	     size_t size __attribute__((unused))) {   intmax_t u;   if (decode_signed_num (&u, arg, TYPE_MINIMUM (gid_t), 			 TYPE_MAXIMUM (gid_t), keyword))     st->stat.st_gid = u; }  static void gname_coder (struct tar_stat_info const *st, char const *keyword, 	     struct xheader *xhdr, void const *data __attribute__ ((unused))) {   code_string (st->gname, keyword, xhdr); }  static void gname_decoder (struct tar_stat_info *st, 	       char const *keyword __attribute__((unused)), 	       char const *arg, 	       size_t size __attribute__((unused))) {   decode_string (&st->gname, arg); }  static void linkpath_coder (struct tar_stat_info const *st, char const *keyword, 		struct xheader *xhdr, void const *data __attribute__ ((unused))) {   code_string (st->link_name, keyword, xhdr); }  static void linkpath_decoder (struct tar_stat_info *st, 		  char const *keyword __attribute__((unused)), 		  char const *arg, 		  size_t size __attribute__((unused))) {   decode_string (&st->link_name, arg); }  static void ctime_coder (struct tar_stat_info const *st, char const *keyword, 	     struct xheader *xhdr, void const *data __attribute__ ((unused))) {   code_time (st->ctime, keyword, xhdr); }  static void ctime_decoder (struct tar_stat_info *st, 	       char const *keyword, 	       char const *arg, 	       size_t size __attribute__((unused))) {   struct timespec ts;   if (decode_time (&ts, arg, keyword))     st->ctime = ts; }  static void mtime_coder (struct tar_stat_info const *st, char const *keyword, 	     struct xheader *xhdr, void const *data) {   struct timespec const *mtime = data;   code_time (mtime ? *mtime : st->mtime, keyword, xhdr); }  static void mtime_decoder (struct tar_stat_info *st, 	       char const *keyword, 	       char const *arg, 	       size_t size __attribute__((unused))) {   struct timespec ts;   if (decode_time (&ts, arg, keyword))     st->mtime = ts; }  static void path_coder (struct tar_stat_info const *st, char const *keyword, 	    struct xheader *xhdr, void const *data __attribute__ ((unused))) {   code_string (st->file_name, keyword, xhdr); }  static void raw_path_decoder (struct tar_stat_info *st, char const *arg) {   decode_string (&st->orig_file_name, arg);   decode_string (&st->file_name, arg);   st->had_trailing_slash = strip_trailing_slashes (st->file_name); }   static void path_decoder (struct tar_stat_info *st, 	      char const *keyword __attribute__((unused)), 	      char const *arg, 	      size_t size __attribute__((unused))) {   if (! st->sparse_name_done)     raw_path_decoder (st, arg); }  static void sparse_path_decoder (struct tar_stat_info *st,                      char const *keyword __attribute__((unused)),                      char const *arg,                      size_t size __attribute__((unused))) {   st->sparse_name_done = true;   raw_path_decoder (st, arg); }  static void size_coder (struct tar_stat_info const *st, char const *keyword, 	    struct xheader *xhdr, void const *data __attribute__ ((unused))) {   code_num (st->stat.st_size, keyword, xhdr); }  static void size_decoder (struct tar_stat_info *st, 	      char const *keyword, 	      char const *arg, 	      size_t size __attribute__((unused))) {   uintmax_t u;   if (decode_num (&u, arg, TYPE_MAXIMUM (off_t), keyword))     st->stat.st_size = u; }  static void uid_coder (struct tar_stat_info const *st, char const *keyword, 	   struct xheader *xhdr, void const *data __attribute__ ((unused))) {   code_signed_num (st->stat.st_uid, keyword, 		   TYPE_MINIMUM (uid_t), TYPE_MAXIMUM (uid_t), xhdr); }  static void uid_decoder (struct tar_stat_info *st, 	     char const *keyword, 	     char const *arg, 	     size_t size __attribute__((unused))) {   intmax_t u;   if (decode_signed_num (&u, arg, TYPE_MINIMUM (uid_t), 			 TYPE_MAXIMUM (uid_t), keyword))     st->stat.st_uid = u; }  static void uname_coder (struct tar_stat_info const *st, char const *keyword, 	     struct xheader *xhdr, void const *data __attribute__ ((unused))) {   code_string (st->uname, keyword, xhdr); }  static void uname_decoder (struct tar_stat_info *st, 	       char const *keyword __attribute__((unused)), 	       char const *arg, 	       size_t size __attribute__((unused))) {   decode_string (&st->uname, arg); }  static void sparse_size_coder (struct tar_stat_info const *st, char const *keyword, 	     struct xheader *xhdr, void const *data) {   size_coder (st, keyword, xhdr, data); }  static void sparse_size_decoder (struct tar_stat_info *st, 		     char const *keyword, 		     char const *arg, 		     size_t size __attribute__((unused))) {   uintmax_t u;   if (decode_num (&u, arg, TYPE_MAXIMUM (off_t), keyword))     {       st->real_size_set = true;       st->real_size = u;     } }  static void sparse_numblocks_coder (struct tar_stat_info const *st, char const *keyword, 			struct xheader *xhdr, 			void const *data __attribute__ ((unused))) {   code_num (st->sparse_map_avail, keyword, xhdr); }  static void sparse_numblocks_decoder (struct tar_stat_info *st, 			  char const *keyword, 			  char const *arg, 			  size_t size __attribute__((unused))) {   uintmax_t u;   if (decode_num (&u, arg, SIZE_MAX, keyword))     {       st->sparse_map_size = u;       st->sparse_map = xcalloc (u, sizeof st->sparse_map[0]);       st->sparse_map_avail = 0;     } }  static void sparse_offset_coder (struct tar_stat_info const *st, char const *keyword, 		     struct xheader *xhdr, void const *data) {   size_t const *pi = data;   code_num (st->sparse_map[*pi].offset, keyword, xhdr); }  static void sparse_offset_decoder (struct tar_stat_info *st, 		       char const *keyword, 		       char const *arg, 		       size_t size __attribute__((unused))) {   uintmax_t u;   if (decode_num (&u, arg, TYPE_MAXIMUM (off_t), keyword))     {       if (st->sparse_map_avail < st->sparse_map_size) 	st->sparse_map[st->sparse_map_avail].offset = u;       else 	ERROR ((0, 0, _("Malformed extended header: excess %s=%s"), 		"GNU.sparse.offset", arg));     } }  static void sparse_numbytes_coder (struct tar_stat_info const *st, char const *keyword, 		       struct xheader *xhdr, void const *data) {   size_t const *pi = data;   code_num (st->sparse_map[*pi].numbytes, keyword, xhdr); }  static void sparse_numbytes_decoder (struct tar_stat_info *st, 			 char const *keyword, 			 char const *arg, 			 size_t size __attribute__((unused))) {   uintmax_t u;   if (decode_num (&u, arg, TYPE_MAXIMUM (off_t), keyword))     {       if (st->sparse_map_avail < st->sparse_map_size) 	st->sparse_map[st->sparse_map_avail++].numbytes = u;       else 	ERROR ((0, 0, _("Malformed extended header: excess %s=%s"), 		keyword, arg));     } }  static void sparse_map_decoder (struct tar_stat_info *st, 		    char const *keyword, 		    char const *arg, 		    size_t size __attribute__((unused))) {   int offset = 1;   struct sp_array e;    st->sparse_map_avail = 0;   while (1)     {       intmax_t u;       char *delim;        if (!ISDIGIT (*arg)) 	{ 	  ERROR ((0, 0, _("Malformed extended header: invalid %s=%s"), 		  keyword, arg)); 	  return; 	}        errno = 0;       u = strtoimax (arg, &delim, 10);       if (TYPE_MAXIMUM (off_t) < u) 	{ 	  u = TYPE_MAXIMUM (off_t); 	  errno = ERANGE; 	}       if (offset) 	{ 	  e.offset = u; 	  if (errno == ERANGE) 	    { 	      out_of_range_header (keyword, arg, 0, TYPE_MAXIMUM (off_t)); 	      return; 	    } 	}       else 	{ 	  e.numbytes = u; 	  if (errno == ERANGE) 	    { 	      out_of_range_header (keyword, arg, 0, TYPE_MAXIMUM (off_t)); 	      return; 	    } 	  if (st->sparse_map_avail < st->sparse_map_size) 	    st->sparse_map[st->sparse_map_avail++] = e; 	  else 	    { 	      ERROR ((0, 0, _("Malformed extended header: excess %s=%s"), 		      keyword, arg)); 	      return; 	    } 	}        offset = !offset;        if (*delim == 0) 	break;       else if (*delim != ',') 	{ 	  ERROR ((0, 0, 		  _("Malformed extended header: invalid %s: unexpected delimiter %c"), 		  keyword, *delim)); 	  return; 	}        arg = delim + 1;     }    if (!offset)     ERROR ((0, 0, 	    _("Malformed extended header: invalid %s: odd number of values"), 	    keyword)); }  static void dumpdir_coder (struct tar_stat_info const *st, char const *keyword, 	       struct xheader *xhdr, void const *data) {   xheader_print_n (xhdr, keyword, data, dumpdir_size (data)); }  static void dumpdir_decoder (struct tar_stat_info *st, 		 char const *keyword __attribute__((unused)), 		 char const *arg, 		 size_t size) {   st->dumpdir = xmalloc (size);   memcpy (st->dumpdir, arg, size); }  static void volume_label_coder (struct tar_stat_info const *st, char const *keyword, 		    struct xheader *xhdr, void const *data) {   code_string (data, keyword, xhdr); }  static void volume_label_decoder (struct tar_stat_info *st, 		      char const *keyword __attribute__((unused)), 		      char const *arg, 		      size_t size __attribute__((unused))) {   decode_string (&volume_label, arg); }  static void volume_size_coder (struct tar_stat_info const *st, char const *keyword, 		   struct xheader *xhdr, void const *data) {   off_t const *v = data;   code_num (*v, keyword, xhdr); }  static void volume_size_decoder (struct tar_stat_info *st, 		     char const *keyword, 		     char const *arg, size_t size) {   uintmax_t u;   if (decode_num (&u, arg, TYPE_MAXIMUM (uintmax_t), keyword))     continued_file_size = u; }  /* FIXME: Merge with volume_size_coder */ static void volume_offset_coder (struct tar_stat_info const *st, char const *keyword, 		     struct xheader *xhdr, void const *data) {   off_t const *v = data;   code_num (*v, keyword, xhdr); }  static void volume_offset_decoder (struct tar_stat_info *st, 		       char const *keyword, 		       char const *arg, size_t size) {   uintmax_t u;   if (decode_num (&u, arg, TYPE_MAXIMUM (uintmax_t), keyword))     continued_file_offset = u; }  static void volume_filename_decoder (struct tar_stat_info *st, 			 char const *keyword __attribute__((unused)), 			 char const *arg, 			 size_t size __attribute__((unused))) {   decode_string (&continued_file_name, arg); }  static void xattr_selinux_coder (struct tar_stat_info const *st, char const *keyword,                      struct xheader *xhdr, void const *data) {   code_string (st->cntx_name, keyword, xhdr); }  static void xattr_selinux_decoder (struct tar_stat_info *st,                        char const *keyword, char const *arg, size_t size) {   decode_string (&st->cntx_name, arg); }  static void xattr_acls_a_coder (struct tar_stat_info const *st , char const *keyword,                     struct xheader *xhdr, void const *data) {   xheader_print_n (xhdr, keyword, st->acls_a_ptr, st->acls_a_len); }  static void xattr_acls_a_decoder (struct tar_stat_info *st,                       char const *keyword, char const *arg, size_t size) {   st->acls_a_ptr = xmemdup (arg, size + 1);   st->acls_a_len = size; }  static void xattr_acls_d_coder (struct tar_stat_info const *st , char const *keyword,                     struct xheader *xhdr, void const *data) {   xheader_print_n (xhdr, keyword, st->acls_d_ptr, st->acls_d_len); }  static void xattr_acls_d_decoder (struct tar_stat_info *st,                       char const *keyword, char const *arg, size_t size) {   st->acls_d_ptr = xmemdup (arg, size + 1);   st->acls_d_len = size; }  static void xattr_coder (struct tar_stat_info const *st, char const *keyword,              struct xheader *xhdr, void const *data) {   struct xattr_array *xattr_map = st->xattr_map;   const size_t *off = data;   xheader_print_n (xhdr, keyword,                    xattr_map[*off].xval_ptr, xattr_map[*off].xval_len); }  static void xattr_decoder (struct tar_stat_info *st,                char const *keyword, char const *arg, size_t size) {   char *xstr, *xkey;    /* copy keyword */   size_t klen_raw = strlen (keyword);   xkey = alloca (klen_raw + 1);   memcpy (xkey, keyword, klen_raw + 1) /* including null-terminating */;    /* copy value */   xstr = alloca (size + 1);   memcpy (xstr, arg, size + 1); /* separator included, for GNU tar '\n' */;    xattr_decode_keyword (xkey);    xheader_xattr_add (st, xkey + strlen("SCHILY.xattr."), xstr, size); }  static void sparse_major_coder (struct tar_stat_info const *st, char const *keyword, 		    struct xheader *xhdr, void const *data) {   code_num (st->sparse_major, keyword, xhdr); }  static void sparse_major_decoder (struct tar_stat_info *st, 		      char const *keyword, 		      char const *arg, 		      size_t size) {   uintmax_t u;   if (decode_num (&u, arg, TYPE_MAXIMUM (unsigned), keyword))     st->sparse_major = u; }  static void sparse_minor_coder (struct tar_stat_info const *st, char const *keyword, 		      struct xheader *xhdr, void const *data) {   code_num (st->sparse_minor, keyword, xhdr); }  static void sparse_minor_decoder (struct tar_stat_info *st, 		      char const *keyword, 		      char const *arg, 		      size_t size) {   uintmax_t u;   if (decode_num (&u, arg, TYPE_MAXIMUM (unsigned), keyword))     st->sparse_minor = u; }  struct xhdr_tab const xhdr_tab[] = {   { "atime",    atime_coder,    atime_decoder,    0, false },   { "comment",  dummy_coder,    dummy_decoder,    0, false },   { "charset",  dummy_coder,    dummy_decoder,    0, false },   { "ctime",    ctime_coder,    ctime_decoder,    0, false },   { "gid",      gid_coder,      gid_decoder,      0, false },   { "gname",    gname_coder,    gname_decoder,    0, false },   { "linkpath", linkpath_coder, linkpath_decoder, 0, false },   { "mtime",    mtime_coder,    mtime_decoder,    0, false },   { "path",     path_coder,     path_decoder,     0, false },   { "size",     size_coder,     size_decoder,     0, false },   { "uid",      uid_coder,      uid_decoder,      0, false },   { "uname",    uname_coder,    uname_decoder,    0, false },    /* Sparse file handling */   { "GNU.sparse.name",       path_coder, sparse_path_decoder,     XHDR_PROTECTED, false },   { "GNU.sparse.major",      sparse_major_coder, sparse_major_decoder,     XHDR_PROTECTED, false },   { "GNU.sparse.minor",      sparse_minor_coder, sparse_minor_decoder,     XHDR_PROTECTED, false },   { "GNU.sparse.realsize",   sparse_size_coder, sparse_size_decoder,     XHDR_PROTECTED, false },   { "GNU.sparse.numblocks",  sparse_numblocks_coder, sparse_numblocks_decoder,     XHDR_PROTECTED, false },    /* tar 1.14 - 1.15.90 keywords. */   { "GNU.sparse.size",       sparse_size_coder, sparse_size_decoder,     XHDR_PROTECTED, false },   /* tar 1.14 - 1.15.1 keywords. Multiple instances of these appeared in 'x'      headers, and each of them was meaningful. It confilcted with POSIX specs,      which requires that "when extended header records conflict, the last one      given in the header shall take precedence." */   { "GNU.sparse.offset",     sparse_offset_coder, sparse_offset_decoder,     XHDR_PROTECTED, false },   { "GNU.sparse.numbytes",   sparse_numbytes_coder, sparse_numbytes_decoder,     XHDR_PROTECTED, false },   /* tar 1.15.90 keyword, introduced to remove the above-mentioned conflict. */   { "GNU.sparse.map",        NULL /* Unused, see pax_dump_header() */,     sparse_map_decoder, 0, false },    { "GNU.dumpdir",           dumpdir_coder, dumpdir_decoder,     XHDR_PROTECTED, false },    /* Keeps the tape/volume label. May be present only in the global headers.      Equivalent to GNUTYPE_VOLHDR.  */   { "GNU.volume.label", volume_label_coder, volume_label_decoder,     XHDR_PROTECTED | XHDR_GLOBAL, false },    /* These may be present in a first global header of the archive.      They provide the same functionality as GNUTYPE_MULTIVOL header.      The GNU.volume.size keeps the real_s_sizeleft value, which is      otherwise kept in the size field of a multivolume header.  The      GNU.volume.offset keeps the offset of the start of this volume,      otherwise kept in oldgnu_header.offset.  */   { "GNU.volume.filename", volume_label_coder, volume_filename_decoder,     XHDR_PROTECTED | XHDR_GLOBAL, false },   { "GNU.volume.size", volume_size_coder, volume_size_decoder,     XHDR_PROTECTED | XHDR_GLOBAL, false },   { "GNU.volume.offset", volume_offset_coder, volume_offset_decoder,     XHDR_PROTECTED | XHDR_GLOBAL, false },    /* We get the SELinux value from filecon, so add a namespace for SELinux      instead of storing it in SCHILY.xattr.* (which would be RAW). */   { "RHT.security.selinux",     xattr_selinux_coder, xattr_selinux_decoder, 0, false },    /* ACLs, use the star format... */   { "SCHILY.acl.access",     xattr_acls_a_coder, xattr_acls_a_decoder, 0, false },    { "SCHILY.acl.default",     xattr_acls_d_coder, xattr_acls_d_decoder, 0, false },    /* We are storing all extended attributes using this rule even if some of them      were stored by some previous rule (duplicates) -- we just have to make sure      they are restored *only once* during extraction later on. */   { "SCHILY.xattr", xattr_coder, xattr_decoder, 0, true },    { NULL, NULL, NULL, 0, false } };  ``` |
| --- | --- |

generated by [cgit v1.1](https://git.zx2c4.com/cgit/about/) at 2025-01-11 17:19:04 +0000

