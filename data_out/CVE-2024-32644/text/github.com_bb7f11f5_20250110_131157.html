
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fevmos%2Fevmos%2Fblob%2Fb196a522ba4951890b40992e9f97aa610f8b5f9c%2Fx%2Fevm%2Fstatedb%2Fstatedb.go)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fevmos%2Fevmos%2Fblob%2Fb196a522ba4951890b40992e9f97aa610f8b5f9c%2Fx%2Fevm%2Fstatedb%2Fstatedb.go)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=evmos%2Fevmos)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[evmos](/evmos)
/
**[evmos](/evmos/evmos)**
Public

* [Notifications](/login?return_to=%2Fevmos%2Fevmos) You must be signed in to change notification settings
* [Fork
  876](/login?return_to=%2Fevmos%2Fevmos)
* [Star
   1.7k](/login?return_to=%2Fevmos%2Fevmos)

* [Code](/evmos/evmos)
* [Issues
  13](/evmos/evmos/issues)
* [Pull requests
  12](/evmos/evmos/pulls)
* [Discussions](/evmos/evmos/discussions)
* [Actions](/evmos/evmos/actions)
* [Security](/evmos/evmos/security)
* [Insights](/evmos/evmos/pulse)

Additional navigation options

* [Code](/evmos/evmos)
* [Issues](/evmos/evmos/issues)
* [Pull requests](/evmos/evmos/pulls)
* [Discussions](/evmos/evmos/discussions)
* [Actions](/evmos/evmos/actions)
* [Security](/evmos/evmos/security)
* [Insights](/evmos/evmos/pulse)

## Files

 b196a52
## Breadcrumbs

1. [evmos](/evmos/evmos/tree/b196a522ba4951890b40992e9f97aa610f8b5f9c)
2. /[x](/evmos/evmos/tree/b196a522ba4951890b40992e9f97aa610f8b5f9c/x)
3. /[evm](/evmos/evmos/tree/b196a522ba4951890b40992e9f97aa610f8b5f9c/x/evm)
4. /[statedb](/evmos/evmos/tree/b196a522ba4951890b40992e9f97aa610f8b5f9c/x/evm/statedb)
/
# statedb.go

 Blame  Blame
## Latest commit

## History

[History](/evmos/evmos/commits/b196a522ba4951890b40992e9f97aa610f8b5f9c/x/evm/statedb/statedb.go)470 lines (413 loc) · 13.9 KB b196a52
## Breadcrumbs

1. [evmos](/evmos/evmos/tree/b196a522ba4951890b40992e9f97aa610f8b5f9c)
2. /[x](/evmos/evmos/tree/b196a522ba4951890b40992e9f97aa610f8b5f9c/x)
3. /[evm](/evmos/evmos/tree/b196a522ba4951890b40992e9f97aa610f8b5f9c/x/evm)
4. /[statedb](/evmos/evmos/tree/b196a522ba4951890b40992e9f97aa610f8b5f9c/x/evm/statedb)
/
# statedb.go

Top
## File metadata and controls

* Code
* Blame

470 lines (413 loc) · 13.9 KB[Raw](https://github.com/evmos/evmos/raw/b196a522ba4951890b40992e9f97aa610f8b5f9c/x/evm/statedb/statedb.go)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470// Copyright Tharsis Labs Ltd.(Evmos)// SPDX-License-Identifier:ENCL-1.0(https://github.com/evmos/evmos/blob/main/LICENSE)package statedb
import ( "fmt" "math/big" "sort"
 errorsmod "cosmossdk.io/errors" sdk "github.com/cosmos/cosmos-sdk/types" "github.com/ethereum/go-ethereum/common" ethtypes "github.com/ethereum/go-ethereum/core/types" "github.com/ethereum/go-ethereum/core/vm" "github.com/ethereum/go-ethereum/crypto")
// revision is the identifier of a version of state.// it consists of an auto-increment id and a journal index.// it's safer to use than using journal index alone.type revision struct { id int journalIndex int}
var \_ vm.StateDB = &StateDB{}
// StateDB structs within the ethereum protocol are used to store anything// within the merkle trie. StateDBs take care of caching and storing// nested states. It's the general query interface to retrieve:// \* Contracts// \* Accountstype StateDB struct { keeper Keeper ctx sdk.Context
 // Journal of state modifications. This is the backbone of // Snapshot and RevertToSnapshot. journal \*journal validRevisions []revision nextRevisionID int
 stateObjects map[common.Address]\*stateObject
 txConfig TxConfig
 // The refund counter, also used by state transitioning. refund uint64
 // Per-transaction logs logs []\*ethtypes.Log
 // Per-transaction access list accessList \*accessList}
// New creates a new state from a given trie.func New(ctx sdk.Context, keeper Keeper, txConfig TxConfig) \*StateDB { return &StateDB{ keeper: keeper, ctx: ctx, stateObjects: make(map[common.Address]\*stateObject), journal: newJournal(), accessList: newAccessList(),
 txConfig: txConfig, }}
// Keeper returns the underlying `Keeper`func (s \*StateDB) Keeper() Keeper { return s.keeper}
// GetContext returns the transaction Context.func (s \*StateDB) GetContext() sdk.Context { return s.ctx}
// AddLog adds a log, called by evm.func (s \*StateDB) AddLog(log \*ethtypes.Log) { s.journal.append(addLogChange{})
 log.TxHash = s.txConfig.TxHash log.BlockHash = s.txConfig.BlockHash log.TxIndex = s.txConfig.TxIndex log.Index = s.txConfig.LogIndex + uint(len(s.logs)) s.logs = append(s.logs, log)}
// Logs returns the logs of current transaction.func (s \*StateDB) Logs() []\*ethtypes.Log { return s.logs}
// AddRefund adds gas to the refund counterfunc (s \*StateDB) AddRefund(gas uint64) { s.journal.append(refundChange{prev: s.refund}) s.refund += gas}
// SubRefund removes gas from the refund counter.// This method will panic if the refund counter goes below zerofunc (s \*StateDB) SubRefund(gas uint64) { s.journal.append(refundChange{prev: s.refund}) if gas > s.refund { panic(fmt.Sprintf("Refund counter below zero (gas: %d > refund: %d)", gas, s.refund)) } s.refund -= gas}
// Exist reports whether the given account address exists in the state.// Notably this also returns true for suicided accounts.func (s \*StateDB) Exist(addr common.Address) bool { return s.getStateObject(addr) != nil}
// Empty returns whether the state object is either non-existent// or empty according to the EIP161 specification (balance = nonce = code = 0)func (s \*StateDB) Empty(addr common.Address) bool { so := s.getStateObject(addr) return so == nil || so.empty()}
// GetBalance retrieves the balance from the given address or 0 if object not foundfunc (s \*StateDB) GetBalance(addr common.Address) \*big.Int { stateObject := s.getStateObject(addr) if stateObject != nil { return stateObject.Balance() } return common.Big0}
// GetNonce returns the nonce of account, 0 if not exists.func (s \*StateDB) GetNonce(addr common.Address) uint64 { stateObject := s.getStateObject(addr) if stateObject != nil { return stateObject.Nonce() }
 return 0}
// GetCode returns the code of account, nil if not exists.func (s \*StateDB) GetCode(addr common.Address) []byte { stateObject := s.getStateObject(addr) if stateObject != nil { return stateObject.Code() } return nil}
// GetCodeSize returns the code size of account.func (s \*StateDB) GetCodeSize(addr common.Address) int { stateObject := s.getStateObject(addr) if stateObject != nil { return stateObject.CodeSize() } return 0}
// GetCodeHash returns the code hash of account.func (s \*StateDB) GetCodeHash(addr common.Address) common.Hash { stateObject := s.getStateObject(addr) if stateObject == nil { return common.Hash{} } return common.BytesToHash(stateObject.CodeHash())}
// GetState retrieves a value from the given account's storage trie.func (s \*StateDB) GetState(addr common.Address, hash common.Hash) common.Hash { stateObject := s.getStateObject(addr) if stateObject != nil { return stateObject.GetState(hash) } return common.Hash{}}
// GetCommittedState retrieves a value from the given account's committed storage trie.func (s \*StateDB) GetCommittedState(addr common.Address, hash common.Hash) common.Hash { stateObject := s.getStateObject(addr) if stateObject != nil { return stateObject.GetCommittedState(hash) } return common.Hash{}}
// GetRefund returns the current value of the refund counter.func (s \*StateDB) GetRefund() uint64 { return s.refund}
// HasSuicided returns if the contract is suicided in current transaction.func (s \*StateDB) HasSuicided(addr common.Address) bool { stateObject := s.getStateObject(addr) if stateObject != nil { return stateObject.suicided } return false}
// AddPreimage records a SHA3 preimage seen by the VM.// AddPreimage performs a no-op since the EnablePreimageRecording flag is disabled// on the vm.Config during state transitions. No store trie preimages are written// to the database.func (s \*StateDB) AddPreimage(\_ common.Hash, \_ []byte) {}
// getStateObject retrieves a state object given by the address, returning nil if// the object is not found.func (s \*StateDB) getStateObject(addr common.Address) \*stateObject { // Prefer live objects if any is available if obj := s.stateObjects[addr]; obj != nil { return obj } // If no live objects are available, load it from keeper account := s.keeper.GetAccount(s.ctx, addr) if account == nil { return nil } // Insert into the live set obj := newObject(s, addr, \*account) s.setStateObject(obj) return obj}
// getOrNewStateObject retrieves a state object or create a new state object if nil.func (s \*StateDB) getOrNewStateObject(addr common.Address) \*stateObject { stateObject := s.getStateObject(addr) if stateObject == nil { stateObject, \_ = s.createObject(addr) } return stateObject}
// createObject creates a new state object. If there is an existing account with// the given address, it is overwritten and returned as the second return value.func (s \*StateDB) createObject(addr common.Address) (newobj, prev \*stateObject) { prev = s.getStateObject(addr)
 newobj = newObject(s, addr, Account{}) if prev == nil { s.journal.append(createObjectChange{account: &addr}) } else { s.journal.append(resetObjectChange{prev: prev}) } s.setStateObject(newobj) if prev != nil { return newobj, prev } return newobj, nil}
// CreateAccount explicitly creates a state object. If a state object with the address// already exists the balance is carried over to the new account.//// CreateAccount is called during the EVM CREATE operation. The situation might arise that// a contract does the following://// 1. sends funds to sha(account ++ (nonce + 1))// 2. tx\_create(sha(account ++ nonce)) (note that this gets the address of 1)//// Carrying over the balance ensures that Ether doesn't disappear.func (s \*StateDB) CreateAccount(addr common.Address) { newObj, prev := s.createObject(addr) if prev != nil { newObj.setBalance(prev.account.Balance) }}
// ForEachStorage iterate the contract storage, the iteration order is not defined.func (s \*StateDB) ForEachStorage(addr common.Address, cb func(key, value common.Hash) bool) error { so := s.getStateObject(addr) if so == nil { return nil } s.keeper.ForEachStorage(s.ctx, addr, func(key, value common.Hash) bool { if value, dirty := so.dirtyStorage[key]; dirty { return cb(key, value) } if len(value) > 0 { return cb(key, value) } return true }) return nil}
func (s \*StateDB) setStateObject(object \*stateObject) { s.stateObjects[object.Address()] = object}
/\* \* SETTERS \*/
// AddBalance adds amount to the account associated with addr.func (s \*StateDB) AddBalance(addr common.Address, amount \*big.Int) { stateObject := s.getOrNewStateObject(addr) if stateObject != nil { stateObject.AddBalance(amount) }}
// SubBalance subtracts amount from the account associated with addr.func (s \*StateDB) SubBalance(addr common.Address, amount \*big.Int) { stateObject := s.getOrNewStateObject(addr) if stateObject != nil { stateObject.SubBalance(amount) }}
// SetNonce sets the nonce of account.func (s \*StateDB) SetNonce(addr common.Address, nonce uint64) { stateObject := s.getOrNewStateObject(addr) if stateObject != nil { stateObject.SetNonce(nonce) }}
// SetCode sets the code of account.func (s \*StateDB) SetCode(addr common.Address, code []byte) { stateObject := s.getOrNewStateObject(addr) if stateObject != nil { stateObject.SetCode(crypto.Keccak256Hash(code), code) }}
// SetState sets the contract state.func (s \*StateDB) SetState(addr common.Address, key, value common.Hash) { stateObject := s.getOrNewStateObject(addr) if stateObject != nil { stateObject.SetState(key, value) }}
// Suicide marks the given account as suicided.// This clears the account balance.//// The account's state object is still available until the state is committed,// getStateObject will return a non-nil account after Suicide.func (s \*StateDB) Suicide(addr common.Address) bool { stateObject := s.getStateObject(addr) if stateObject == nil { return false } s.journal.append(suicideChange{ account: &addr, prev: stateObject.suicided, prevbalance: new(big.Int).Set(stateObject.Balance()), }) stateObject.markSuicided() stateObject.account.Balance = new(big.Int)
 return true}
// PrepareAccessList handles the preparatory steps for executing a state transition with// regards to both EIP-2929 and EIP-2930://// - Add sender to access list (2929)// - Add destination to access list (2929)// - Add precompiles to access list (2929)// - Add the contents of the optional tx access list (2930)//// This method should only be called if Yolov3/Berlin/2929+2930 is applicable at the current number.func (s \*StateDB) PrepareAccessList(sender common.Address, dst \*common.Address, precompiles []common.Address, list ethtypes.AccessList) { s.AddAddressToAccessList(sender) if dst != nil { s.AddAddressToAccessList(\*dst) // If it's a create-tx, the destination will be added inside evm.create } for \_, addr := range precompiles { s.AddAddressToAccessList(addr) } for \_, el := range list { s.AddAddressToAccessList(el.Address) for \_, key := range el.StorageKeys { s.AddSlotToAccessList(el.Address, key) } }}
// AddAddressToAccessList adds the given address to the access listfunc (s \*StateDB) AddAddressToAccessList(addr common.Address) { if s.accessList.AddAddress(addr) { s.journal.append(accessListAddAccountChange{&addr}) }}
// AddSlotToAccessList adds the given (address, slot)-tuple to the access listfunc (s \*StateDB) AddSlotToAccessList(addr common.Address, slot common.Hash) { addrMod, slotMod := s.accessList.AddSlot(addr, slot) if addrMod { // In practice, this should not happen, since there is no way to enter the // scope of 'address' without having the 'address' become already added // to the access list (via call-variant, create, etc). // Better safe than sorry, though s.journal.append(accessListAddAccountChange{&addr}) } if slotMod { s.journal.append(accessListAddSlotChange{ address: &addr, slot: &slot, }) }}
// AddressInAccessList returns true if the given address is in the access list.func (s \*StateDB) AddressInAccessList(addr common.Address) bool { return s.accessList.ContainsAddress(addr)}
// SlotInAccessList returns true if the given (address, slot)-tuple is in the access list.func (s \*StateDB) SlotInAccessList(addr common.Address, slot common.Hash) (addressPresent bool, slotPresent bool) { return s.accessList.Contains(addr, slot)}
// Snapshot returns an identifier for the current revision of the state.func (s \*StateDB) Snapshot() int { id := s.nextRevisionID s.nextRevisionID++ s.validRevisions = append(s.validRevisions, revision{id, s.journal.length()}) return id}
// RevertToSnapshot reverts all state changes made since the given revision.func (s \*StateDB) RevertToSnapshot(revid int) { // Find the snapshot in the stack of valid snapshots. idx := sort.Search(len(s.validRevisions), func(i int) bool { return s.validRevisions[i].id >= revid }) if idx == len(s.validRevisions) || s.validRevisions[idx].id != revid { panic(fmt.Errorf("revision id %v cannot be reverted", revid)) } snapshot := s.validRevisions[idx].journalIndex
 // Replay the journal to undo changes and remove invalidated snapshots s.journal.Revert(s, snapshot) s.validRevisions = s.validRevisions[:idx]}
// Commit writes the dirty states to keeper// the StateDB object should be discarded after committed.func (s \*StateDB) Commit() error { for \_, addr := range s.journal.sortedDirties() { obj := s.stateObjects[addr] if obj.suicided { if err := s.keeper.DeleteAccount(s.ctx, obj.Address()); err != nil { return errorsmod.Wrap(err, "failed to delete account") } } else { if obj.code != nil && obj.dirtyCode { s.keeper.SetCode(s.ctx, obj.CodeHash(), obj.code) } if err := s.keeper.SetAccount(s.ctx, obj.Address(), obj.account); err != nil { return errorsmod.Wrap(err, "failed to set account") } for \_, key := range obj.dirtyStorage.SortedKeys() { value := obj.dirtyStorage[key] // Skip noop changes, persist actual changes if value == obj.originStorage[key] { continue } s.keeper.SetState(s.ctx, obj.Address(), key, value.Bytes()) } } } return nil}

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

