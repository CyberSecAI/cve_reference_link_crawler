
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fcloudevents%2Fsdk-go%2Fblob%2F67e389964131d55d65cd14b4eb32d57a47312695%2Fv2%2Fprotocol%2Fhttp%2Fprotocol.go)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fcloudevents%2Fsdk-go%2Fblob%2F67e389964131d55d65cd14b4eb32d57a47312695%2Fv2%2Fprotocol%2Fhttp%2Fprotocol.go)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=cloudevents%2Fsdk-go)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[cloudevents](/cloudevents)
/
**[sdk-go](/cloudevents/sdk-go)**
Public

* [Notifications](/login?return_to=%2Fcloudevents%2Fsdk-go) You must be signed in to change notification settings
* [Fork
  225](/login?return_to=%2Fcloudevents%2Fsdk-go)
* [Star
   851](/login?return_to=%2Fcloudevents%2Fsdk-go)

* [Code](/cloudevents/sdk-go)
* [Issues
  112](/cloudevents/sdk-go/issues)
* [Pull requests
  11](/cloudevents/sdk-go/pulls)
* [Actions](/cloudevents/sdk-go/actions)
* [Security](/cloudevents/sdk-go/security)
* [Insights](/cloudevents/sdk-go/pulse)

Additional navigation options

* [Code](/cloudevents/sdk-go)
* [Issues](/cloudevents/sdk-go/issues)
* [Pull requests](/cloudevents/sdk-go/pulls)
* [Actions](/cloudevents/sdk-go/actions)
* [Security](/cloudevents/sdk-go/security)
* [Insights](/cloudevents/sdk-go/pulse)

## Files

 67e3899
## Breadcrumbs

1. [sdk-go](/cloudevents/sdk-go/tree/67e389964131d55d65cd14b4eb32d57a47312695)
2. /[v2](/cloudevents/sdk-go/tree/67e389964131d55d65cd14b4eb32d57a47312695/v2)
3. /[protocol](/cloudevents/sdk-go/tree/67e389964131d55d65cd14b4eb32d57a47312695/v2/protocol)
4. /[http](/cloudevents/sdk-go/tree/67e389964131d55d65cd14b4eb32d57a47312695/v2/protocol/http)
/
# protocol.go

Copy path Blame  Blame
## Latest commit

## History

[History](/cloudevents/sdk-go/commits/67e389964131d55d65cd14b4eb32d57a47312695/v2/protocol/http/protocol.go)408 lines (350 loc) · 10 KB 67e3899
## Breadcrumbs

1. [sdk-go](/cloudevents/sdk-go/tree/67e389964131d55d65cd14b4eb32d57a47312695)
2. /[v2](/cloudevents/sdk-go/tree/67e389964131d55d65cd14b4eb32d57a47312695/v2)
3. /[protocol](/cloudevents/sdk-go/tree/67e389964131d55d65cd14b4eb32d57a47312695/v2/protocol)
4. /[http](/cloudevents/sdk-go/tree/67e389964131d55d65cd14b4eb32d57a47312695/v2/protocol/http)
/
# protocol.go

Top
## File metadata and controls

* Code
* Blame

408 lines (350 loc) · 10 KB[Raw](https://github.com/cloudevents/sdk-go/raw/67e389964131d55d65cd14b4eb32d57a47312695/v2/protocol/http/protocol.go)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408/\* Copyright 2021 The CloudEvents Authors SPDX-License-Identifier: Apache-2.0\*/
package http
import ( "bytes" "context" "errors" "fmt" "io" "net/http" "net/url" "strconv" "sync" "sync/atomic" "time"
 "github.com/cloudevents/sdk-go/v2/binding" cecontext "github.com/cloudevents/sdk-go/v2/context" "github.com/cloudevents/sdk-go/v2/event" "github.com/cloudevents/sdk-go/v2/protocol")
const ( // DefaultShutdownTimeout defines the default timeout given to the http.Server when calling Shutdown. DefaultShutdownTimeout = time.Minute \* 1)
type msgErr struct { msg \*Message respFn protocol.ResponseFn err error}
// Default error codes that we retry on - string isn't used, it's just there so// people know what each error code's title is.// To modify this use Optionvar defaultRetriableErrors = map[int]string{ 404: "Not Found", 413: "Payload Too Large", 425: "Too Early", 429: "Too Many Requests", 502: "Bad Gateway", 503: "Service Unavailable", 504: "Gateway Timeout",}
// Protocol acts as both a http client and a http handler.type Protocol struct { Target \*url.URL RequestTemplate \*http.Request Client \*http.Client incoming chan msgErr
 // OptionsHandlerFn handles the OPTIONS method requests and is intended to // implement the abuse protection spec: // https://github.com/cloudevents/spec/blob/v1.0/http-webhook.md#4-abuse-protection OptionsHandlerFn http.HandlerFunc WebhookConfig \*WebhookConfig
 GetHandlerFn http.HandlerFunc DeleteHandlerFn http.HandlerFunc
 // To support Opener:
 // ShutdownTimeout defines the timeout given to the http.Server when calling Shutdown. // If 0, DefaultShutdownTimeout is used. ShutdownTimeout time.Duration
 // Port is the port configured to bind the receiver to. Defaults to 8080. // If you want to know the effective port you're listening to, use GetListeningPort() Port int // Path is the path to bind the receiver to. Defaults to "/". Path string
 // Receive Mutex reMu sync.Mutex // Handler is the handler the http Server will use. Use this to reuse the // http server. If nil, the Protocol will create a one. Handler \*http.ServeMux
 listener atomic.Value roundTripper http.RoundTripper server \*http.Server handlerRegistered bool middleware []Middleware limiter RateLimiter
 isRetriableFunc IsRetriable}
func New(opts ...Option) (\*Protocol, error) { p := &Protocol{ incoming: make(chan msgErr), Port: -1, } if err := p.applyOptions(opts...); err != nil { return nil, err }
 if p.Client == nil { p.Client = http.DefaultClient }
 if p.roundTripper != nil { p.Client.Transport = p.roundTripper }
 if p.ShutdownTimeout == 0 { p.ShutdownTimeout = DefaultShutdownTimeout }
 if p.isRetriableFunc == nil { p.isRetriableFunc = defaultIsRetriableFunc }
 if p.limiter == nil { p.limiter = noOpLimiter{} }
 return p, nil}
// NewObserved creates an HTTP protocol with trace propagating middleware.// Deprecated: now this behaves like New and it will be removed in future releases,// setup the http observed protocol using the opencensus separate module NewObservedHttpvar NewObserved = New
func (p \*Protocol) applyOptions(opts ...Option) error { for \_, fn := range opts { if err := fn(p); err != nil { return err } } return nil}
// Send implements binding.Senderfunc (p \*Protocol) Send(ctx context.Context, m binding.Message, transformers ...binding.Transformer) error { if ctx == nil { return fmt.Errorf("nil Context") } else if m == nil { return fmt.Errorf("nil Message") }
 msg, err := p.Request(ctx, m, transformers...) if msg != nil { defer func() { \_ = msg.Finish(err) }() } if err != nil && !protocol.IsACK(err) { var res \*Result if protocol.ResultAs(err, &res) { if message, ok := msg.(\*Message); ok { buf := new(bytes.Buffer) buf.ReadFrom(message.BodyReader) errorStr := buf.String() // If the error is not wrapped, then append the original error string. if og, ok := err.(\*Result); ok { og.Format = og.Format + "%s" og.Args = append(og.Args, errorStr) err = og } else { err = NewResult(res.StatusCode, "%w: %s", err, errorStr) } } } } return err}
// Request implements binding.Requesterfunc (p \*Protocol) Request(ctx context.Context, m binding.Message, transformers ...binding.Transformer) (binding.Message, error) { if ctx == nil { return nil, fmt.Errorf("nil Context") } else if m == nil { return nil, fmt.Errorf("nil Message") }
 var err error defer func() { \_ = m.Finish(err) }()
 req := p.makeRequest(ctx)
 if p.Client == nil || req == nil || req.URL == nil { return nil, fmt.Errorf("not initialized: %#v", p) }
 if err = WriteRequest(ctx, m, req, transformers...); err != nil { return nil, err }
 return p.do(ctx, req)}
func (p \*Protocol) makeRequest(ctx context.Context) \*http.Request { req := &http.Request{ Method: http.MethodPost, Header: HeaderFrom(ctx), }
 if p.RequestTemplate != nil { req.Method = p.RequestTemplate.Method req.URL = p.RequestTemplate.URL req.Close = p.RequestTemplate.Close req.Host = p.RequestTemplate.Host copyHeadersEnsure(p.RequestTemplate.Header, &req.Header) }
 if p.Target != nil { req.URL = p.Target }
 // Override the default request with target from context. if target := cecontext.TargetFrom(ctx); target != nil { req.URL = target } return req.WithContext(ctx)}
// Ensure to is a non-nil map before copyingfunc copyHeadersEnsure(from http.Header, to \*http.Header) { if len(from) > 0 { if \*to == nil { \*to = http.Header{} } copyHeaders(from, \*to) }}
func copyHeaders(from, to http.Header) { if from == nil || to == nil { return } for header, values := range from { for \_, value := range values { to.Add(header, value) } }}
// Receive the next incoming HTTP request as a CloudEvent.// Returns non-nil error if the incoming HTTP request fails to parse as a CloudEvent// Returns io.EOF if the receiver is closed.func (p \*Protocol) Receive(ctx context.Context) (binding.Message, error) { if ctx == nil { return nil, fmt.Errorf("nil Context") }
 msg, fn, err := p.Respond(ctx) // No-op the response when finish is invoked. if msg != nil { return binding.WithFinish(msg, func(err error) { if fn != nil { \_ = fn(ctx, nil, nil) } }), err } else { return nil, err }}
// Respond receives the next incoming HTTP request as a CloudEvent and waits// for the response callback to invoked before continuing.// Returns non-nil error if the incoming HTTP request fails to parse as a CloudEvent// Returns io.EOF if the receiver is closed.func (p \*Protocol) Respond(ctx context.Context) (binding.Message, protocol.ResponseFn, error) { if ctx == nil { return nil, nil, fmt.Errorf("nil Context") }
 select { case in, ok := <-p.incoming: if !ok { return nil, nil, io.EOF }
 if in.msg == nil { return nil, in.respFn, in.err } return in.msg, in.respFn, in.err
 case <-ctx.Done(): return nil, nil, io.EOF }}
// ServeHTTP implements http.Handler.// Blocks until ResponseFn is invoked.func (p \*Protocol) ServeHTTP(rw http.ResponseWriter, req \*http.Request) { // always apply limiter first using req context ok, reset, err := p.limiter.Allow(req.Context(), req) if err != nil { p.incoming <- msgErr{msg: nil, err: fmt.Errorf("unable to acquire rate limit token: %w", err)} rw.WriteHeader(http.StatusInternalServerError) return }
 if !ok { rw.Header().Add("Retry-After", strconv.Itoa(int(reset))) http.Error(rw, "limit exceeded", 429) return }
 // Filter the GET style methods: switch req.Method { case http.MethodOptions: if p.OptionsHandlerFn == nil { rw.WriteHeader(http.StatusMethodNotAllowed) return } p.OptionsHandlerFn(rw, req) return
 case http.MethodGet: if p.GetHandlerFn == nil { rw.WriteHeader(http.StatusMethodNotAllowed) return } p.GetHandlerFn(rw, req) return
 case http.MethodDelete: if p.DeleteHandlerFn == nil { rw.WriteHeader(http.StatusMethodNotAllowed) return } p.DeleteHandlerFn(rw, req) return }
 m := NewMessageFromHttpRequest(req) if m == nil { // Should never get here unless ServeHTTP is called directly. p.incoming <- msgErr{msg: nil, err: binding.ErrUnknownEncoding} rw.WriteHeader(http.StatusBadRequest) return // if there was no message, return. }
 var finishErr error m.OnFinish = func(err error) error { finishErr = err return nil }
 wg := sync.WaitGroup{} wg.Add(1) var fn protocol.ResponseFn = func(ctx context.Context, respMsg binding.Message, res protocol.Result, transformers ...binding.Transformer) error { // Unblock the ServeHTTP after the reply is written defer func() { wg.Done() }()
 if finishErr != nil { http.Error(rw, fmt.Sprintf("Cannot forward CloudEvent: %s", finishErr), http.StatusInternalServerError) return finishErr }
 status := http.StatusOK var errMsg string if res != nil { var result \*Result switch { case protocol.ResultAs(res, &result): if result.StatusCode > 100 && result.StatusCode < 600 { status = result.StatusCode } errMsg = fmt.Errorf(result.Format, result.Args...).Error() case !protocol.IsACK(res): // Map client errors to http status code validationError := event.ValidationError{} if errors.As(res, &validationError) { status = http.StatusBadRequest rw.Header().Set("content-type", "text/plain") rw.WriteHeader(status) \_, \_ = rw.Write([]byte(validationError.Error())) return validationError } else if errors.Is(res, binding.ErrUnknownEncoding) { status = http.StatusUnsupportedMediaType } else { status = http.StatusInternalServerError } } }
 if respMsg != nil { err := WriteResponseWriter(ctx, respMsg, status, rw, transformers...) return respMsg.Finish(err) }
 rw.WriteHeader(status) if \_, err := rw.Write([]byte(errMsg)); err != nil { return err } return nil }
 p.incoming <- msgErr{msg: m, respFn: fn} // Send to Request // Block until ResponseFn is invoked wg.Wait()}
func defaultIsRetriableFunc(sc int) bool { \_, ok := defaultRetriableErrors[sc] return ok}

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

