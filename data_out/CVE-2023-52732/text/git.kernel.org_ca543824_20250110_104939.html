

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=a68e564adcaa69b0930809fb64d9d5f7d9c32ba9)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a68e564adcaa69b0930809fb64d9d5f7d9c32ba9)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a68e564adcaa69b0930809fb64d9d5f7d9c32ba9)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a68e564adcaa69b0930809fb64d9d5f7d9c32ba9)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Xiubo Li <xiubli@redhat.com> | 2023-02-01 09:36:45 +0800 |
| --- | --- | --- |
| committer | Ilya Dryomov <idryomov@gmail.com> | 2023-02-02 13:58:15 +0100 |
| commit | [a68e564adcaa69b0930809fb64d9d5f7d9c32ba9](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a68e564adcaa69b0930809fb64d9d5f7d9c32ba9) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=a68e564adcaa69b0930809fb64d9d5f7d9c32ba9)) | |
| tree | [061fa00fa614c4a83aec06c620905dfe2a0eff5e](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a68e564adcaa69b0930809fb64d9d5f7d9c32ba9) | |
| parent | [b38b17b6a01ca4e738af097a1529910646ef4270](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b38b17b6a01ca4e738af097a1529910646ef4270) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a68e564adcaa69b0930809fb64d9d5f7d9c32ba9&id2=b38b17b6a01ca4e738af097a1529910646ef4270)) | |
| download | [linux-a68e564adcaa69b0930809fb64d9d5f7d9c32ba9.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-a68e564adcaa69b0930809fb64d9d5f7d9c32ba9.tar.gz) | |

ceph: blocklist the kclient when receiving corrupted snap traceWhen received corrupted snap trace we don't know what exactly has
happened in MDS side. And we shouldn't continue IOs and metadatas
access to MDS, which may corrupt or get incorrect contents.
This patch will just block all the further IO/MDS requests
immediately and then evict the kclient itself.
The reason why we still need to evict the kclient just after
blocking all the further IOs is that the MDS could revoke the caps
faster.
Link: <https://tracker.ceph.com/issues/57686>
Signed-off-by: Xiubo Li <xiubli@redhat.com>
Reviewed-by: Venky Shankar <vshankar@redhat.com>
Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a68e564adcaa69b0930809fb64d9d5f7d9c32ba9)

| -rw-r--r-- | [fs/ceph/addr.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/ceph/addr.c?id=a68e564adcaa69b0930809fb64d9d5f7d9c32ba9) | 17 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/ceph/caps.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/ceph/caps.c?id=a68e564adcaa69b0930809fb64d9d5f7d9c32ba9) | 16 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/ceph/file.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/ceph/file.c?id=a68e564adcaa69b0930809fb64d9d5f7d9c32ba9) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/ceph/mds\_client.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/ceph/mds_client.c?id=a68e564adcaa69b0930809fb64d9d5f7d9c32ba9) | 30 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/ceph/snap.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/ceph/snap.c?id=a68e564adcaa69b0930809fb64d9d5f7d9c32ba9) | 36 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/ceph/super.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/ceph/super.h?id=a68e564adcaa69b0930809fb64d9d5f7d9c32ba9) | 1 | |  |  |  | | --- | --- | --- | |

6 files changed, 93 insertions, 10 deletions

| diff --git a/fs/ceph/addr.c b/fs/ceph/addr.cindex 8c74871e37c9dc..cac4083e387a50 100644--- a/[fs/ceph/addr.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/addr.c?id=b38b17b6a01ca4e738af097a1529910646ef4270)+++ b/[fs/ceph/addr.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/addr.c?id=a68e564adcaa69b0930809fb64d9d5f7d9c32ba9)@@ -305,7 +305,7 @@ static void ceph\_netfs\_issue\_read(struct netfs\_io\_subrequest \*subreq) struct inode \*inode = rreq->inode; struct ceph\_inode\_info \*ci = ceph\_inode(inode); struct ceph\_fs\_client \*fsc = ceph\_inode\_to\_client(inode);- struct ceph\_osd\_request \*req;+ struct ceph\_osd\_request \*req = NULL; struct ceph\_vino vino = ceph\_vino(inode); struct iov\_iter iter; struct page \*\*pages;@@ -313,6 +313,11 @@ static void ceph\_netfs\_issue\_read(struct netfs\_io\_subrequest \*subreq) int err = 0; u64 len = subreq->len; + if (ceph\_inode\_is\_shutdown(inode)) {+ err = -EIO;+ goto out;+ }+ if (ceph\_has\_inline\_data(ci) && ceph\_netfs\_issue\_op\_inline(subreq)) return; @@ -563,6 +568,9 @@ static int writepage\_nounlock(struct page \*page, struct writeback\_control \*wbc)  dout("writepage %p idx %lu\n", page, page->index); + if (ceph\_inode\_is\_shutdown(inode))+ return -EIO;+ /\* verify this is a writeable snap context \*/ snapc = page\_snap\_context(page); if (!snapc) {@@ -1643,7 +1651,7 @@ int ceph\_uninline\_data(struct file \*file) struct ceph\_inode\_info \*ci = ceph\_inode(inode); struct ceph\_fs\_client \*fsc = ceph\_inode\_to\_client(inode); struct ceph\_osd\_request \*req = NULL;- struct ceph\_cap\_flush \*prealloc\_cf;+ struct ceph\_cap\_flush \*prealloc\_cf = NULL; struct folio \*folio = NULL; u64 inline\_version = CEPH\_INLINE\_NONE; struct page \*pages[1];@@ -1657,6 +1665,11 @@ int ceph\_uninline\_data(struct file \*file) dout("uninline\_data %p %llx.%llx inline\_version %llu\n", inode, ceph\_vinop(inode), inline\_version); + if (ceph\_inode\_is\_shutdown(inode)) {+ err = -EIO;+ goto out;+ }+ if (inline\_version == CEPH\_INLINE\_NONE) return 0; diff --git a/fs/ceph/caps.c b/fs/ceph/caps.cindex f75ad432f375f8..210e4003788183 100644--- a/[fs/ceph/caps.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/caps.c?id=b38b17b6a01ca4e738af097a1529910646ef4270)+++ b/[fs/ceph/caps.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/caps.c?id=a68e564adcaa69b0930809fb64d9d5f7d9c32ba9)@@ -4078,6 +4078,7 @@ void ceph\_handle\_caps(struct ceph\_mds\_session \*session, void \*p, \*end; struct cap\_extra\_info extra\_info = {}; bool queue\_trunc;+ bool close\_sessions = false;  dout("handle\_caps from mds%d\n", session->s\_mds); @@ -4215,9 +4216,13 @@ void ceph\_handle\_caps(struct ceph\_mds\_session \*session, realm = NULL; if (snaptrace\_len) { down\_write(&mdsc->snap\_rwsem);- ceph\_update\_snap\_trace(mdsc, snaptrace,- snaptrace + snaptrace\_len,- false, &realm);+ if (ceph\_update\_snap\_trace(mdsc, snaptrace,+ snaptrace + snaptrace\_len,+ false, &realm)) {+ up\_write(&mdsc->snap\_rwsem);+ close\_sessions = true;+ goto done;+ } downgrade\_write(&mdsc->snap\_rwsem); } else { down\_read(&mdsc->snap\_rwsem);@@ -4277,6 +4282,11 @@ done\_unlocked: iput(inode); out: ceph\_put\_string(extra\_info.pool\_ns);++ /\* Defer closing the sessions after s\_mutex lock being released \*/+ if (close\_sessions)+ ceph\_mdsc\_close\_sessions(mdsc);+ return;  flush\_cap\_releases:diff --git a/fs/ceph/file.c b/fs/ceph/file.cindex 764598e1efd91f..b5cff85925a109 100644--- a/[fs/ceph/file.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/file.c?id=b38b17b6a01ca4e738af097a1529910646ef4270)+++ b/[fs/ceph/file.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/file.c?id=a68e564adcaa69b0930809fb64d9d5f7d9c32ba9)@@ -2011,6 +2011,9 @@ static int ceph\_zero\_partial\_object(struct inode \*inode, loff\_t zero = 0; int op; + if (ceph\_inode\_is\_shutdown(inode))+ return -EIO;+ if (!length) { op = offset ? CEPH\_OSD\_OP\_DELETE : CEPH\_OSD\_OP\_TRUNCATE; length = &zero;diff --git a/fs/ceph/mds\_client.c b/fs/ceph/mds\_client.cindex 26a0a8b9975ef3..e163f58ff3c505 100644--- a/[fs/ceph/mds\_client.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/mds_client.c?id=b38b17b6a01ca4e738af097a1529910646ef4270)+++ b/[fs/ceph/mds\_client.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/mds_client.c?id=a68e564adcaa69b0930809fb64d9d5f7d9c32ba9)@@ -806,6 +806,9 @@ static struct ceph\_mds\_session \*register\_session(struct ceph\_mds\_client \*mdsc, { struct ceph\_mds\_session \*s; + if (READ\_ONCE(mdsc->fsc->mount\_state) == CEPH\_MOUNT\_FENCE\_IO)+ return ERR\_PTR(-EIO);+ if (mds >= mdsc->mdsmap->possible\_max\_rank) return ERR\_PTR(-EINVAL); @@ -1478,6 +1481,9 @@ static int \_\_open\_session(struct ceph\_mds\_client \*mdsc, int mstate; int mds = session->s\_mds; + if (READ\_ONCE(mdsc->fsc->mount\_state) == CEPH\_MOUNT\_FENCE\_IO)+ return -EIO;+ /\* wait for mds to go active? \*/ mstate = ceph\_mdsmap\_get\_state(mdsc->mdsmap, mds); dout("open\_session to mds%d (%s)\n", mds,@@ -2860,6 +2866,11 @@ static void \_\_do\_request(struct ceph\_mds\_client \*mdsc, return; } + if (READ\_ONCE(mdsc->fsc->mount\_state) == CEPH\_MOUNT\_FENCE\_IO) {+ dout("do\_request metadata corrupted\n");+ err = -EIO;+ goto finish;+ } if (req->r\_timeout && time\_after\_eq(jiffies, req->r\_started + req->r\_timeout)) { dout("do\_request timed out\n");@@ -3245,6 +3256,7 @@ static void handle\_reply(struct ceph\_mds\_session \*session, struct ceph\_msg \*msg) u64 tid; int err, result; int mds = session->s\_mds;+ bool close\_sessions = false;  if (msg->front.iov\_len < sizeof(\*head)) { pr\_err("mdsc\_handle\_reply got corrupt (short) reply\n");@@ -3351,10 +3363,17 @@ static void handle\_reply(struct ceph\_mds\_session \*session, struct ceph\_msg \*msg) realm = NULL; if (rinfo->snapblob\_len) { down\_write(&mdsc->snap\_rwsem);- ceph\_update\_snap\_trace(mdsc, rinfo->snapblob,+ err = ceph\_update\_snap\_trace(mdsc, rinfo->snapblob, rinfo->snapblob + rinfo->snapblob\_len, le32\_to\_cpu(head->op) == CEPH\_MDS\_OP\_RMSNAP, &realm);+ if (err) {+ up\_write(&mdsc->snap\_rwsem);+ close\_sessions = true;+ if (err == -EIO)+ ceph\_msg\_dump(msg);+ goto out\_err;+ } downgrade\_write(&mdsc->snap\_rwsem); } else { down\_read(&mdsc->snap\_rwsem);@@ -3412,6 +3431,10 @@ out\_err: req->r\_end\_latency, err); out: ceph\_mdsc\_put\_request(req);++ /\* Defer closing the sessions after s\_mutex lock being released \*/+ if (close\_sessions)+ ceph\_mdsc\_close\_sessions(mdsc); return; } @@ -5011,7 +5034,7 @@ static bool done\_closing\_sessions(struct ceph\_mds\_client \*mdsc, int skipped) }  /\*- \* called after sb is ro.+ \* called after sb is ro or when metadata corrupted. \*/ void ceph\_mdsc\_close\_sessions(struct ceph\_mds\_client \*mdsc) {@@ -5301,7 +5324,8 @@ static void mds\_peer\_reset(struct ceph\_connection \*con) struct ceph\_mds\_client \*mdsc = s->s\_mdsc;  pr\_warn("mds%d closed our session\n", s->s\_mds);- send\_mds\_reconnect(mdsc, s);+ if (READ\_ONCE(mdsc->fsc->mount\_state) != CEPH\_MOUNT\_FENCE\_IO)+ send\_mds\_reconnect(mdsc, s); }  static void mds\_dispatch(struct ceph\_connection \*con, struct ceph\_msg \*msg)diff --git a/fs/ceph/snap.c b/fs/ceph/snap.cindex e4151852184e04..87007203f130e1 100644--- a/[fs/ceph/snap.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/snap.c?id=b38b17b6a01ca4e738af097a1529910646ef4270)+++ b/[fs/ceph/snap.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/snap.c?id=a68e564adcaa69b0930809fb64d9d5f7d9c32ba9)@@ -1,6 +1,7 @@ // SPDX-License-Identifier: GPL-2.0 #include <linux/ceph/ceph\_debug.h> +#include <linux/fs.h> #include <linux/sort.h> #include <linux/slab.h> #include <linux/iversion.h>@@ -766,8 +767,10 @@ int ceph\_update\_snap\_trace(struct ceph\_mds\_client \*mdsc, struct ceph\_snap\_realm \*realm; struct ceph\_snap\_realm \*first\_realm = NULL; struct ceph\_snap\_realm \*realm\_to\_rebuild = NULL;+ struct ceph\_client \*client = mdsc->fsc->client; int rebuild\_snapcs; int err = -ENOMEM;+ int ret; LIST\_HEAD(dirty\_realms);  lockdep\_assert\_held\_write(&mdsc->snap\_rwsem);@@ -884,6 +887,27 @@ fail: if (first\_realm) ceph\_put\_snap\_realm(mdsc, first\_realm); pr\_err("%s error %d\n", \_\_func\_\_, err);++ /\*+ \* When receiving a corrupted snap trace we don't know what+ \* exactly has happened in MDS side. And we shouldn't continue+ \* writing to OSD, which may corrupt the snapshot contents.+ \*+ \* Just try to blocklist this kclient and then this kclient+ \* must be remounted to continue after the corrupted metadata+ \* fixed in the MDS side.+ \*/+ WRITE\_ONCE(mdsc->fsc->mount\_state, CEPH\_MOUNT\_FENCE\_IO);+ ret = ceph\_monc\_blocklist\_add(&client->monc, &client->msgr.inst.addr);+ if (ret)+ pr\_err("%s failed to blocklist %s: %d\n", \_\_func\_\_,+ ceph\_pr\_addr(&client->msgr.inst.addr), ret);++ WARN(1, "%s: %s%sdo remount to continue%s",+ \_\_func\_\_, ret ? "" : ceph\_pr\_addr(&client->msgr.inst.addr),+ ret ? "" : " was blocklisted, ",+ err == -EIO ? " after corrupted snaptrace is fixed" : "");+ return err; } @@ -984,6 +1008,7 @@ void ceph\_handle\_snap(struct ceph\_mds\_client \*mdsc, \_\_le64 \*split\_inos = NULL, \*split\_realms = NULL; int i; int locked\_rwsem = 0;+ bool close\_sessions = false;  /\* decode \*/ if (msg->front.iov\_len < sizeof(\*h))@@ -1092,8 +1117,12 @@ skip\_inode: \* update using the provided snap trace. if we are deleting a \* snap, we can avoid queueing cap\_snaps. \*/- ceph\_update\_snap\_trace(mdsc, p, e,- op == CEPH\_SNAP\_OP\_DESTROY, NULL);+ if (ceph\_update\_snap\_trace(mdsc, p, e,+ op == CEPH\_SNAP\_OP\_DESTROY,+ NULL)) {+ close\_sessions = true;+ goto bad;+ }  if (op == CEPH\_SNAP\_OP\_SPLIT) /\* we took a reference when we created the realm, above \*/@@ -1112,6 +1141,9 @@ bad: out: if (locked\_rwsem) up\_write(&mdsc->snap\_rwsem);++ if (close\_sessions)+ ceph\_mdsc\_close\_sessions(mdsc); return; } diff --git a/fs/ceph/super.h b/fs/ceph/super.hindex cd95b426ee00c8..07c6906cda70d6 100644--- a/[fs/ceph/super.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/super.h?id=b38b17b6a01ca4e738af097a1529910646ef4270)+++ b/[fs/ceph/super.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/super.h?id=a68e564adcaa69b0930809fb64d9d5f7d9c32ba9)@@ -108,6 +108,7 @@ enum { CEPH\_MOUNT\_UNMOUNTED, CEPH\_MOUNT\_SHUTDOWN, CEPH\_MOUNT\_RECOVER,+ CEPH\_MOUNT\_FENCE\_IO, };  #define CEPH\_ASYNC\_CREATE\_CONFLICT\_BITS 8 |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 10:48:16 +0000

