

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=66ec619e4591f8350f99c5269a7ce160cccc7a7c)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=66ec619e4591f8350f99c5269a7ce160cccc7a7c)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=66ec619e4591f8350f99c5269a7ce160cccc7a7c)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=66ec619e4591f8350f99c5269a7ce160cccc7a7c)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Xiubo Li <xiubli@redhat.com> | 2023-02-01 09:36:45 +0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2023-02-22 12:59:45 +0100 |
| commit | [66ec619e4591f8350f99c5269a7ce160cccc7a7c](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=66ec619e4591f8350f99c5269a7ce160cccc7a7c) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=66ec619e4591f8350f99c5269a7ce160cccc7a7c)) | |
| tree | [514062f2153f04ccd53a72e2a5d58afb383c4d30](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=66ec619e4591f8350f99c5269a7ce160cccc7a7c) | |
| parent | [eb253f83d403a4d5f9a6160fe95a56257d358601](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=eb253f83d403a4d5f9a6160fe95a56257d358601) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=66ec619e4591f8350f99c5269a7ce160cccc7a7c&id2=eb253f83d403a4d5f9a6160fe95a56257d358601)) | |
| download | [linux-66ec619e4591f8350f99c5269a7ce160cccc7a7c.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-66ec619e4591f8350f99c5269a7ce160cccc7a7c.tar.gz) | |

ceph: blocklist the kclient when receiving corrupted snap trace[ Upstream commit a68e564adcaa69b0930809fb64d9d5f7d9c32ba9 ]
When received corrupted snap trace we don't know what exactly has
happened in MDS side. And we shouldn't continue IOs and metadatas
access to MDS, which may corrupt or get incorrect contents.
This patch will just block all the further IO/MDS requests
immediately and then evict the kclient itself.
The reason why we still need to evict the kclient just after
blocking all the further IOs is that the MDS could revoke the caps
faster.
Link: <https://tracker.ceph.com/issues/57686>
Signed-off-by: Xiubo Li <xiubli@redhat.com>
Reviewed-by: Venky Shankar <vshankar@redhat.com>
Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=66ec619e4591f8350f99c5269a7ce160cccc7a7c)

| -rw-r--r-- | [fs/ceph/addr.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/ceph/addr.c?id=66ec619e4591f8350f99c5269a7ce160cccc7a7c) | 17 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/ceph/caps.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/ceph/caps.c?id=66ec619e4591f8350f99c5269a7ce160cccc7a7c) | 16 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/ceph/file.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/ceph/file.c?id=66ec619e4591f8350f99c5269a7ce160cccc7a7c) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/ceph/mds\_client.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/ceph/mds_client.c?id=66ec619e4591f8350f99c5269a7ce160cccc7a7c) | 30 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/ceph/snap.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/ceph/snap.c?id=66ec619e4591f8350f99c5269a7ce160cccc7a7c) | 36 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/ceph/super.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/ceph/super.h?id=66ec619e4591f8350f99c5269a7ce160cccc7a7c) | 1 | |  |  |  | | --- | --- | --- | |

6 files changed, 93 insertions, 10 deletions

| diff --git a/fs/ceph/addr.c b/fs/ceph/addr.cindex 61f47debec5ac6..478c03bfba663a 100644--- a/[fs/ceph/addr.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/addr.c?id=eb253f83d403a4d5f9a6160fe95a56257d358601)+++ b/[fs/ceph/addr.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/addr.c?id=66ec619e4591f8350f99c5269a7ce160cccc7a7c)@@ -305,7 +305,7 @@ static void ceph\_netfs\_issue\_read(struct netfs\_io\_subrequest \*subreq) struct inode \*inode = rreq->inode; struct ceph\_inode\_info \*ci = ceph\_inode(inode); struct ceph\_fs\_client \*fsc = ceph\_inode\_to\_client(inode);- struct ceph\_osd\_request \*req;+ struct ceph\_osd\_request \*req = NULL; struct ceph\_vino vino = ceph\_vino(inode); struct iov\_iter iter; struct page \*\*pages;@@ -313,6 +313,11 @@ static void ceph\_netfs\_issue\_read(struct netfs\_io\_subrequest \*subreq) int err = 0; u64 len = subreq->len; + if (ceph\_inode\_is\_shutdown(inode)) {+ err = -EIO;+ goto out;+ }+ if (ceph\_has\_inline\_data(ci) && ceph\_netfs\_issue\_op\_inline(subreq)) return; @@ -563,6 +568,9 @@ static int writepage\_nounlock(struct page \*page, struct writeback\_control \*wbc)  dout("writepage %p idx %lu\n", page, page->index); + if (ceph\_inode\_is\_shutdown(inode))+ return -EIO;+ /\* verify this is a writeable snap context \*/ snapc = page\_snap\_context(page); if (!snapc) {@@ -1643,7 +1651,7 @@ int ceph\_uninline\_data(struct file \*file) struct ceph\_inode\_info \*ci = ceph\_inode(inode); struct ceph\_fs\_client \*fsc = ceph\_inode\_to\_client(inode); struct ceph\_osd\_request \*req = NULL;- struct ceph\_cap\_flush \*prealloc\_cf;+ struct ceph\_cap\_flush \*prealloc\_cf = NULL; struct folio \*folio = NULL; u64 inline\_version = CEPH\_INLINE\_NONE; struct page \*pages[1];@@ -1657,6 +1665,11 @@ int ceph\_uninline\_data(struct file \*file) dout("uninline\_data %p %llx.%llx inline\_version %llu\n", inode, ceph\_vinop(inode), inline\_version); + if (ceph\_inode\_is\_shutdown(inode)) {+ err = -EIO;+ goto out;+ }+ if (inline\_version == CEPH\_INLINE\_NONE) return 0; diff --git a/fs/ceph/caps.c b/fs/ceph/caps.cindex cd69bf267d1b10..795fd6d84bde01 100644--- a/[fs/ceph/caps.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/caps.c?id=eb253f83d403a4d5f9a6160fe95a56257d358601)+++ b/[fs/ceph/caps.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/caps.c?id=66ec619e4591f8350f99c5269a7ce160cccc7a7c)@@ -4081,6 +4081,7 @@ void ceph\_handle\_caps(struct ceph\_mds\_session \*session, void \*p, \*end; struct cap\_extra\_info extra\_info = {}; bool queue\_trunc;+ bool close\_sessions = false;  dout("handle\_caps from mds%d\n", session->s\_mds); @@ -4218,9 +4219,13 @@ void ceph\_handle\_caps(struct ceph\_mds\_session \*session, realm = NULL; if (snaptrace\_len) { down\_write(&mdsc->snap\_rwsem);- ceph\_update\_snap\_trace(mdsc, snaptrace,- snaptrace + snaptrace\_len,- false, &realm);+ if (ceph\_update\_snap\_trace(mdsc, snaptrace,+ snaptrace + snaptrace\_len,+ false, &realm)) {+ up\_write(&mdsc->snap\_rwsem);+ close\_sessions = true;+ goto done;+ } downgrade\_write(&mdsc->snap\_rwsem); } else { down\_read(&mdsc->snap\_rwsem);@@ -4280,6 +4285,11 @@ done\_unlocked: iput(inode); out: ceph\_put\_string(extra\_info.pool\_ns);++ /\* Defer closing the sessions after s\_mutex lock being released \*/+ if (close\_sessions)+ ceph\_mdsc\_close\_sessions(mdsc);+ return;  flush\_cap\_releases:diff --git a/fs/ceph/file.c b/fs/ceph/file.cindex 6f9580defb2b39..5895797f3104a6 100644--- a/[fs/ceph/file.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/file.c?id=eb253f83d403a4d5f9a6160fe95a56257d358601)+++ b/[fs/ceph/file.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/file.c?id=66ec619e4591f8350f99c5269a7ce160cccc7a7c)@@ -2004,6 +2004,9 @@ static int ceph\_zero\_partial\_object(struct inode \*inode, loff\_t zero = 0; int op; + if (ceph\_inode\_is\_shutdown(inode))+ return -EIO;+ if (!length) { op = offset ? CEPH\_OSD\_OP\_DELETE : CEPH\_OSD\_OP\_TRUNCATE; length = &zero;diff --git a/fs/ceph/mds\_client.c b/fs/ceph/mds\_client.cindex 756560df3bdbd8..27a245d959c0ad 100644--- a/[fs/ceph/mds\_client.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/mds_client.c?id=eb253f83d403a4d5f9a6160fe95a56257d358601)+++ b/[fs/ceph/mds\_client.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/mds_client.c?id=66ec619e4591f8350f99c5269a7ce160cccc7a7c)@@ -806,6 +806,9 @@ static struct ceph\_mds\_session \*register\_session(struct ceph\_mds\_client \*mdsc, { struct ceph\_mds\_session \*s; + if (READ\_ONCE(mdsc->fsc->mount\_state) == CEPH\_MOUNT\_FENCE\_IO)+ return ERR\_PTR(-EIO);+ if (mds >= mdsc->mdsmap->possible\_max\_rank) return ERR\_PTR(-EINVAL); @@ -1478,6 +1481,9 @@ static int \_\_open\_session(struct ceph\_mds\_client \*mdsc, int mstate; int mds = session->s\_mds; + if (READ\_ONCE(mdsc->fsc->mount\_state) == CEPH\_MOUNT\_FENCE\_IO)+ return -EIO;+ /\* wait for mds to go active? \*/ mstate = ceph\_mdsmap\_get\_state(mdsc->mdsmap, mds); dout("open\_session to mds%d (%s)\n", mds,@@ -2860,6 +2866,11 @@ static void \_\_do\_request(struct ceph\_mds\_client \*mdsc, return; } + if (READ\_ONCE(mdsc->fsc->mount\_state) == CEPH\_MOUNT\_FENCE\_IO) {+ dout("do\_request metadata corrupted\n");+ err = -EIO;+ goto finish;+ } if (req->r\_timeout && time\_after\_eq(jiffies, req->r\_started + req->r\_timeout)) { dout("do\_request timed out\n");@@ -3245,6 +3256,7 @@ static void handle\_reply(struct ceph\_mds\_session \*session, struct ceph\_msg \*msg) u64 tid; int err, result; int mds = session->s\_mds;+ bool close\_sessions = false;  if (msg->front.iov\_len < sizeof(\*head)) { pr\_err("mdsc\_handle\_reply got corrupt (short) reply\n");@@ -3351,10 +3363,17 @@ static void handle\_reply(struct ceph\_mds\_session \*session, struct ceph\_msg \*msg) realm = NULL; if (rinfo->snapblob\_len) { down\_write(&mdsc->snap\_rwsem);- ceph\_update\_snap\_trace(mdsc, rinfo->snapblob,+ err = ceph\_update\_snap\_trace(mdsc, rinfo->snapblob, rinfo->snapblob + rinfo->snapblob\_len, le32\_to\_cpu(head->op) == CEPH\_MDS\_OP\_RMSNAP, &realm);+ if (err) {+ up\_write(&mdsc->snap\_rwsem);+ close\_sessions = true;+ if (err == -EIO)+ ceph\_msg\_dump(msg);+ goto out\_err;+ } downgrade\_write(&mdsc->snap\_rwsem); } else { down\_read(&mdsc->snap\_rwsem);@@ -3412,6 +3431,10 @@ out\_err: req->r\_end\_latency, err); out: ceph\_mdsc\_put\_request(req);++ /\* Defer closing the sessions after s\_mutex lock being released \*/+ if (close\_sessions)+ ceph\_mdsc\_close\_sessions(mdsc); return; } @@ -5017,7 +5040,7 @@ static bool done\_closing\_sessions(struct ceph\_mds\_client \*mdsc, int skipped) }  /\*- \* called after sb is ro.+ \* called after sb is ro or when metadata corrupted. \*/ void ceph\_mdsc\_close\_sessions(struct ceph\_mds\_client \*mdsc) {@@ -5307,7 +5330,8 @@ static void mds\_peer\_reset(struct ceph\_connection \*con) struct ceph\_mds\_client \*mdsc = s->s\_mdsc;  pr\_warn("mds%d closed our session\n", s->s\_mds);- send\_mds\_reconnect(mdsc, s);+ if (READ\_ONCE(mdsc->fsc->mount\_state) != CEPH\_MOUNT\_FENCE\_IO)+ send\_mds\_reconnect(mdsc, s); }  static void mds\_dispatch(struct ceph\_connection \*con, struct ceph\_msg \*msg)diff --git a/fs/ceph/snap.c b/fs/ceph/snap.cindex e4151852184e04..87007203f130e1 100644--- a/[fs/ceph/snap.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/snap.c?id=eb253f83d403a4d5f9a6160fe95a56257d358601)+++ b/[fs/ceph/snap.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/snap.c?id=66ec619e4591f8350f99c5269a7ce160cccc7a7c)@@ -1,6 +1,7 @@ // SPDX-License-Identifier: GPL-2.0 #include <linux/ceph/ceph\_debug.h> +#include <linux/fs.h> #include <linux/sort.h> #include <linux/slab.h> #include <linux/iversion.h>@@ -766,8 +767,10 @@ int ceph\_update\_snap\_trace(struct ceph\_mds\_client \*mdsc, struct ceph\_snap\_realm \*realm; struct ceph\_snap\_realm \*first\_realm = NULL; struct ceph\_snap\_realm \*realm\_to\_rebuild = NULL;+ struct ceph\_client \*client = mdsc->fsc->client; int rebuild\_snapcs; int err = -ENOMEM;+ int ret; LIST\_HEAD(dirty\_realms);  lockdep\_assert\_held\_write(&mdsc->snap\_rwsem);@@ -884,6 +887,27 @@ fail: if (first\_realm) ceph\_put\_snap\_realm(mdsc, first\_realm); pr\_err("%s error %d\n", \_\_func\_\_, err);++ /\*+ \* When receiving a corrupted snap trace we don't know what+ \* exactly has happened in MDS side. And we shouldn't continue+ \* writing to OSD, which may corrupt the snapshot contents.+ \*+ \* Just try to blocklist this kclient and then this kclient+ \* must be remounted to continue after the corrupted metadata+ \* fixed in the MDS side.+ \*/+ WRITE\_ONCE(mdsc->fsc->mount\_state, CEPH\_MOUNT\_FENCE\_IO);+ ret = ceph\_monc\_blocklist\_add(&client->monc, &client->msgr.inst.addr);+ if (ret)+ pr\_err("%s failed to blocklist %s: %d\n", \_\_func\_\_,+ ceph\_pr\_addr(&client->msgr.inst.addr), ret);++ WARN(1, "%s: %s%sdo remount to continue%s",+ \_\_func\_\_, ret ? "" : ceph\_pr\_addr(&client->msgr.inst.addr),+ ret ? "" : " was blocklisted, ",+ err == -EIO ? " after corrupted snaptrace is fixed" : "");+ return err; } @@ -984,6 +1008,7 @@ void ceph\_handle\_snap(struct ceph\_mds\_client \*mdsc, \_\_le64 \*split\_inos = NULL, \*split\_realms = NULL; int i; int locked\_rwsem = 0;+ bool close\_sessions = false;  /\* decode \*/ if (msg->front.iov\_len < sizeof(\*h))@@ -1092,8 +1117,12 @@ skip\_inode: \* update using the provided snap trace. if we are deleting a \* snap, we can avoid queueing cap\_snaps. \*/- ceph\_update\_snap\_trace(mdsc, p, e,- op == CEPH\_SNAP\_OP\_DESTROY, NULL);+ if (ceph\_update\_snap\_trace(mdsc, p, e,+ op == CEPH\_SNAP\_OP\_DESTROY,+ NULL)) {+ close\_sessions = true;+ goto bad;+ }  if (op == CEPH\_SNAP\_OP\_SPLIT) /\* we took a reference when we created the realm, above \*/@@ -1112,6 +1141,9 @@ bad: out: if (locked\_rwsem) up\_write(&mdsc->snap\_rwsem);++ if (close\_sessions)+ ceph\_mdsc\_close\_sessions(mdsc); return; } diff --git a/fs/ceph/super.h b/fs/ceph/super.hindex 735279b2ceb55f..3599fefa91f99b 100644--- a/[fs/ceph/super.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/super.h?id=eb253f83d403a4d5f9a6160fe95a56257d358601)+++ b/[fs/ceph/super.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/super.h?id=66ec619e4591f8350f99c5269a7ce160cccc7a7c)@@ -108,6 +108,7 @@ enum { CEPH\_MOUNT\_UNMOUNTED, CEPH\_MOUNT\_SHUTDOWN, CEPH\_MOUNT\_RECOVER,+ CEPH\_MOUNT\_FENCE\_IO, };  #define CEPH\_ASYNC\_CREATE\_CONFLICT\_BITS 8 |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 10:48:16 +0000

