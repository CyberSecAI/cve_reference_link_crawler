=== Content from git.kernel.org_57e6b0c0_20250111_063706.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=3f3ef1d9f66b93913ce2171120d9226b55acd41d)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=3f3ef1d9f66b93913ce2171120d9226b55acd41d)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3f3ef1d9f66b93913ce2171120d9226b55acd41d)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3f3ef1d9f66b93913ce2171120d9226b55acd41d)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Amir Goldstein <amir73il@gmail.com> | 2024-05-12 13:30:07 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-09-12 11:06:41 +0200 |
| commit | [3f3ef1d9f66b93913ce2171120d9226b55acd41d](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3f3ef1d9f66b93913ce2171120d9226b55acd41d) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=3f3ef1d9f66b93913ce2171120d9226b55acd41d)) | |
| tree | [e88bb8a13299e6c3fb0db8509db442858e691b5a](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=3f3ef1d9f66b93913ce2171120d9226b55acd41d) | |
| parent | [7e64cabe81c303bdf6fd26b6a09a3289b33bc870](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7e64cabe81c303bdf6fd26b6a09a3289b33bc870) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3f3ef1d9f66b93913ce2171120d9226b55acd41d&id2=7e64cabe81c303bdf6fd26b6a09a3289b33bc870)) | |
| download | [linux-3f3ef1d9f66b93913ce2171120d9226b55acd41d.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-3f3ef1d9f66b93913ce2171120d9226b55acd41d.tar.gz) | |

fsnotify: clear PARENT\_WATCHED flags lazily[ Upstream commit 172e422ffea20a89bfdc672741c1aad6fbb5044e ]
In some setups directories can have many (usually negative) dentries.
Hence \_\_fsnotify\_update\_child\_dentry\_flags() function can take a
significant amount of time. Since the bulk of this function happens
under inode->i\_lock this causes a significant contention on the lock
when we remove the watch from the directory as the
\_\_fsnotify\_update\_child\_dentry\_flags() call from fsnotify\_recalc\_mask()
races with \_\_fsnotify\_update\_child\_dentry\_flags() calls from
\_\_fsnotify\_parent() happening on children. This can lead upto softlockup
reports reported by users.
Fix the problem by calling fsnotify\_update\_children\_dentry\_flags() to
set PARENT\_WATCHED flags only when parent starts watching children.
When parent stops watching children, clear false positive PARENT\_WATCHED
flags lazily in \_\_fsnotify\_parent() for each accessed child.
Suggested-by: Jan Kara <jack@suse.cz>
Signed-off-by: Amir Goldstein <amir73il@gmail.com>
Signed-off-by: Stephen Brennan <stephen.s.brennan@oracle.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3f3ef1d9f66b93913ce2171120d9226b55acd41d)

| -rw-r--r-- | [fs/notify/fsnotify.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/notify/fsnotify.c?id=3f3ef1d9f66b93913ce2171120d9226b55acd41d) | 31 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/notify/fsnotify.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/notify/fsnotify.h?id=3f3ef1d9f66b93913ce2171120d9226b55acd41d) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/notify/mark.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/notify/mark.c?id=3f3ef1d9f66b93913ce2171120d9226b55acd41d) | 32 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/fsnotify\_backend.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/fsnotify_backend.h?id=3f3ef1d9f66b93913ce2171120d9226b55acd41d) | 8 | |  |  |  | | --- | --- | --- | |

4 files changed, 56 insertions, 17 deletions

| diff --git a/fs/notify/fsnotify.c b/fs/notify/fsnotify.cindex 7974e91ffe134f..b5d8f238fce42a 100644--- a/[fs/notify/fsnotify.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/fsnotify.c?id=7e64cabe81c303bdf6fd26b6a09a3289b33bc870)+++ b/[fs/notify/fsnotify.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/fsnotify.c?id=3f3ef1d9f66b93913ce2171120d9226b55acd41d)@@ -103,17 +103,13 @@ void fsnotify\_sb\_delete(struct super\_block \*sb) \* parent cares. Thus when an event happens on a child it can quickly tell \* if there is a need to find a parent and send the event to the parent. \*/-void \_\_fsnotify\_update\_child\_dentry\_flags(struct inode \*inode)+void fsnotify\_set\_children\_dentry\_flags(struct inode \*inode) { struct dentry \*alias;- int watched;  if (!S\_ISDIR(inode->i\_mode)) return; - /\* determine if the children should tell inode about their events \*/- watched = fsnotify\_inode\_watches\_children(inode);- spin\_lock(&inode->i\_lock); /\* run all of the dentries associated with this inode. Since this is a \* directory, there damn well better only be one item on this list \*/@@ -129,10 +125,7 @@ void \_\_fsnotify\_update\_child\_dentry\_flags(struct inode \*inode) continue;  spin\_lock\_nested(&child->d\_lock, DENTRY\_D\_LOCK\_NESTED);- if (watched)- child->d\_flags |= DCACHE\_FSNOTIFY\_PARENT\_WATCHED;- else- child->d\_flags &= ~DCACHE\_FSNOTIFY\_PARENT\_WATCHED;+ child->d\_flags |= DCACHE\_FSNOTIFY\_PARENT\_WATCHED; spin\_unlock(&child->d\_lock); } spin\_unlock(&alias->d\_lock);@@ -140,6 +133,24 @@ void \_\_fsnotify\_update\_child\_dentry\_flags(struct inode \*inode) spin\_unlock(&inode->i\_lock); } +/\*+ \* Lazily clear false positive PARENT\_WATCHED flag for child whose parent had+ \* stopped watching children.+ \*/+static void fsnotify\_clear\_child\_dentry\_flag(struct inode \*pinode,+ struct dentry \*dentry)+{+ spin\_lock(&dentry->d\_lock);+ /\*+ \* d\_lock is a sufficient barrier to prevent observing a non-watched+ \* parent state from before the fsnotify\_set\_children\_dentry\_flags()+ \* or fsnotify\_update\_flags() call that had set PARENT\_WATCHED.+ \*/+ if (!fsnotify\_inode\_watches\_children(pinode))+ dentry->d\_flags &= ~DCACHE\_FSNOTIFY\_PARENT\_WATCHED;+ spin\_unlock(&dentry->d\_lock);+}+ /\* Are inode/sb/mount interested in parent and name info with this event? \*/ static bool fsnotify\_event\_needs\_parent(struct inode \*inode, struct mount \*mnt, \_\_u32 mask)@@ -208,7 +219,7 @@ int \_\_fsnotify\_parent(struct dentry \*dentry, \_\_u32 mask, const void \*data, p\_inode = parent->d\_inode; p\_mask = fsnotify\_inode\_watches\_children(p\_inode); if (unlikely(parent\_watched && !p\_mask))- \_\_fsnotify\_update\_child\_dentry\_flags(p\_inode);+ fsnotify\_clear\_child\_dentry\_flag(p\_inode, dentry);  /\* \* Include parent/name in notification either if some notificationdiff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.hindex fde74eb333cc93..2b4267de86e6b2 100644--- a/[fs/notify/fsnotify.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/fsnotify.h?id=7e64cabe81c303bdf6fd26b6a09a3289b33bc870)+++ b/[fs/notify/fsnotify.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/fsnotify.h?id=3f3ef1d9f66b93913ce2171120d9226b55acd41d)@@ -74,7 +74,7 @@ static inline void fsnotify\_clear\_marks\_by\_sb(struct super\_block \*sb) \* update the dentry->d\_flags of all of inode's children to indicate if inode cares \* about events that happen to its children. \*/-extern void \_\_fsnotify\_update\_child\_dentry\_flags(struct inode \*inode);+extern void fsnotify\_set\_children\_dentry\_flags(struct inode \*inode);  extern struct kmem\_cache \*fsnotify\_mark\_connector\_cachep; diff --git a/fs/notify/mark.c b/fs/notify/mark.cindex c74ef947447d67..4be6e883d492f6 100644--- a/[fs/notify/mark.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/mark.c?id=7e64cabe81c303bdf6fd26b6a09a3289b33bc870)+++ b/[fs/notify/mark.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/mark.c?id=3f3ef1d9f66b93913ce2171120d9226b55acd41d)@@ -176,6 +176,24 @@ static void \*\_\_fsnotify\_recalc\_mask(struct fsnotify\_mark\_connector \*conn) return fsnotify\_update\_iref(conn, want\_iref); } +static bool fsnotify\_conn\_watches\_children(+ struct fsnotify\_mark\_connector \*conn)+{+ if (conn->type != FSNOTIFY\_OBJ\_TYPE\_INODE)+ return false;++ return fsnotify\_inode\_watches\_children(fsnotify\_conn\_inode(conn));+}++static void fsnotify\_conn\_set\_children\_dentry\_flags(+ struct fsnotify\_mark\_connector \*conn)+{+ if (conn->type != FSNOTIFY\_OBJ\_TYPE\_INODE)+ return;++ fsnotify\_set\_children\_dentry\_flags(fsnotify\_conn\_inode(conn));+}+ /\* \* Calculate mask of events for a list of marks. The caller must make sure \* connector and connector->obj cannot disappear under us. Callers achieve@@ -184,15 +202,23 @@ static void \*\_\_fsnotify\_recalc\_mask(struct fsnotify\_mark\_connector \*conn) \*/ void fsnotify\_recalc\_mask(struct fsnotify\_mark\_connector \*conn) {+ bool update\_children;+ if (!conn) return;  spin\_lock(&conn->lock);+ update\_children = !fsnotify\_conn\_watches\_children(conn); \_\_fsnotify\_recalc\_mask(conn);+ update\_children &= fsnotify\_conn\_watches\_children(conn); spin\_unlock(&conn->lock);- if (conn->type == FSNOTIFY\_OBJ\_TYPE\_INODE)- \_\_fsnotify\_update\_child\_dentry\_flags(- fsnotify\_conn\_inode(conn));+ /\*+ \* Set children's PARENT\_WATCHED flags only if parent started watching.+ \* When parent stops watching, we clear false positive PARENT\_WATCHED+ \* flags lazily in \_\_fsnotify\_parent().+ \*/+ if (update\_children)+ fsnotify\_conn\_set\_children\_dentry\_flags(conn); }  /\* Free all connectors queued for freeing once SRCU period ends \*/diff --git a/include/linux/fsnotify\_backend.h b/include/linux/fsnotify\_backend.hindex d7d96c806bff2b..096b79e4373f4c 100644--- a/[include/linux/fsnotify\_backend.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fsnotify_backend.h?id=7e64cabe81c303bdf6fd26b6a09a3289b33bc870)+++ b/[include/linux/fsnotify\_backend.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fsnotify_backend.h?id=3f3ef1d9f66b93913ce2171120d9226b55acd41d)@@ -563,12 +563,14 @@ static inline \_\_u32 fsnotify\_parent\_needed\_mask(\_\_u32 mask)  static inline int fsnotify\_inode\_watches\_children(struct inode \*inode) {+ \_\_u32 parent\_mask = READ\_ONCE(inode->i\_fsnotify\_mask);+ /\* FS\_EVENT\_ON\_CHILD is set if the inode may care \*/- if (!(inode->i\_fsnotify\_mask & FS\_EVENT\_ON\_CHILD))+ if (!(parent\_mask & FS\_EVENT\_ON\_CHILD)) return 0; /\* this inode might care about child events, does it care about the \* specific set of events that can happen on a child? \*/- return inode->i\_fsnotify\_mask & FS\_EVENTS\_POSS\_ON\_CHILD;+ return parent\_mask & FS\_EVENTS\_POSS\_ON\_CHILD; }  /\*@@ -582,7 +584,7 @@ static inline void fsnotify\_update\_flags(struct dentry \*dentry) /\* \* Serialisation of setting PARENT\_WATCHED on the dentries is provided \* by d\_lock. If inotify\_inode\_watched changes after we have taken- \* d\_lock, the following \_\_fsnotify\_update\_child\_dentry\_flags call will+ \* d\_lock, the following fsnotify\_set\_children\_dentry\_flags call will \* find our entry, so it will spin until we complete here, and update \* us with the new state. \*/ |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 06:35:43 +0000



=== Content from git.kernel.org_8981dd8e_20250111_063708.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=fc1b1e135c3f72382f792e6c319fc088d5523ad5)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=fc1b1e135c3f72382f792e6c319fc088d5523ad5)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=fc1b1e135c3f72382f792e6c319fc088d5523ad5)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=fc1b1e135c3f72382f792e6c319fc088d5523ad5)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Amir Goldstein <amir73il@gmail.com> | 2024-05-12 13:30:07 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-09-08 07:54:44 +0200 |
| commit | [fc1b1e135c3f72382f792e6c319fc088d5523ad5](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=fc1b1e135c3f72382f792e6c319fc088d5523ad5) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=fc1b1e135c3f72382f792e6c319fc088d5523ad5)) | |
| tree | [408435f790c9e00cf369ef512f739007d81881ca](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=fc1b1e135c3f72382f792e6c319fc088d5523ad5) | |
| parent | [3b9f2d9301ae67070fe77a0c06758722fd7172b7](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3b9f2d9301ae67070fe77a0c06758722fd7172b7) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=fc1b1e135c3f72382f792e6c319fc088d5523ad5&id2=3b9f2d9301ae67070fe77a0c06758722fd7172b7)) | |
| download | [linux-fc1b1e135c3f72382f792e6c319fc088d5523ad5.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-fc1b1e135c3f72382f792e6c319fc088d5523ad5.tar.gz) | |

fsnotify: clear PARENT\_WATCHED flags lazily[ Upstream commit 172e422ffea20a89bfdc672741c1aad6fbb5044e ]
In some setups directories can have many (usually negative) dentries.
Hence \_\_fsnotify\_update\_child\_dentry\_flags() function can take a
significant amount of time. Since the bulk of this function happens
under inode->i\_lock this causes a significant contention on the lock
when we remove the watch from the directory as the
\_\_fsnotify\_update\_child\_dentry\_flags() call from fsnotify\_recalc\_mask()
races with \_\_fsnotify\_update\_child\_dentry\_flags() calls from
\_\_fsnotify\_parent() happening on children. This can lead upto softlockup
reports reported by users.
Fix the problem by calling fsnotify\_update\_children\_dentry\_flags() to
set PARENT\_WATCHED flags only when parent starts watching children.
When parent stops watching children, clear false positive PARENT\_WATCHED
flags lazily in \_\_fsnotify\_parent() for each accessed child.
Suggested-by: Jan Kara <jack@suse.cz>
Signed-off-by: Amir Goldstein <amir73il@gmail.com>
Signed-off-by: Stephen Brennan <stephen.s.brennan@oracle.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=fc1b1e135c3f72382f792e6c319fc088d5523ad5)

| -rw-r--r-- | [fs/notify/fsnotify.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/notify/fsnotify.c?id=fc1b1e135c3f72382f792e6c319fc088d5523ad5) | 31 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/notify/fsnotify.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/notify/fsnotify.h?id=fc1b1e135c3f72382f792e6c319fc088d5523ad5) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/notify/mark.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/notify/mark.c?id=fc1b1e135c3f72382f792e6c319fc088d5523ad5) | 32 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/fsnotify\_backend.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/fsnotify_backend.h?id=fc1b1e135c3f72382f792e6c319fc088d5523ad5) | 8 | |  |  |  | | --- | --- | --- | |

4 files changed, 56 insertions, 17 deletions

| diff --git a/fs/notify/fsnotify.c b/fs/notify/fsnotify.cindex 7974e91ffe134f..b5d8f238fce42a 100644--- a/[fs/notify/fsnotify.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/fsnotify.c?id=3b9f2d9301ae67070fe77a0c06758722fd7172b7)+++ b/[fs/notify/fsnotify.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/fsnotify.c?id=fc1b1e135c3f72382f792e6c319fc088d5523ad5)@@ -103,17 +103,13 @@ void fsnotify\_sb\_delete(struct super\_block \*sb) \* parent cares. Thus when an event happens on a child it can quickly tell \* if there is a need to find a parent and send the event to the parent. \*/-void \_\_fsnotify\_update\_child\_dentry\_flags(struct inode \*inode)+void fsnotify\_set\_children\_dentry\_flags(struct inode \*inode) { struct dentry \*alias;- int watched;  if (!S\_ISDIR(inode->i\_mode)) return; - /\* determine if the children should tell inode about their events \*/- watched = fsnotify\_inode\_watches\_children(inode);- spin\_lock(&inode->i\_lock); /\* run all of the dentries associated with this inode. Since this is a \* directory, there damn well better only be one item on this list \*/@@ -129,10 +125,7 @@ void \_\_fsnotify\_update\_child\_dentry\_flags(struct inode \*inode) continue;  spin\_lock\_nested(&child->d\_lock, DENTRY\_D\_LOCK\_NESTED);- if (watched)- child->d\_flags |= DCACHE\_FSNOTIFY\_PARENT\_WATCHED;- else- child->d\_flags &= ~DCACHE\_FSNOTIFY\_PARENT\_WATCHED;+ child->d\_flags |= DCACHE\_FSNOTIFY\_PARENT\_WATCHED; spin\_unlock(&child->d\_lock); } spin\_unlock(&alias->d\_lock);@@ -140,6 +133,24 @@ void \_\_fsnotify\_update\_child\_dentry\_flags(struct inode \*inode) spin\_unlock(&inode->i\_lock); } +/\*+ \* Lazily clear false positive PARENT\_WATCHED flag for child whose parent had+ \* stopped watching children.+ \*/+static void fsnotify\_clear\_child\_dentry\_flag(struct inode \*pinode,+ struct dentry \*dentry)+{+ spin\_lock(&dentry->d\_lock);+ /\*+ \* d\_lock is a sufficient barrier to prevent observing a non-watched+ \* parent state from before the fsnotify\_set\_children\_dentry\_flags()+ \* or fsnotify\_update\_flags() call that had set PARENT\_WATCHED.+ \*/+ if (!fsnotify\_inode\_watches\_children(pinode))+ dentry->d\_flags &= ~DCACHE\_FSNOTIFY\_PARENT\_WATCHED;+ spin\_unlock(&dentry->d\_lock);+}+ /\* Are inode/sb/mount interested in parent and name info with this event? \*/ static bool fsnotify\_event\_needs\_parent(struct inode \*inode, struct mount \*mnt, \_\_u32 mask)@@ -208,7 +219,7 @@ int \_\_fsnotify\_parent(struct dentry \*dentry, \_\_u32 mask, const void \*data, p\_inode = parent->d\_inode; p\_mask = fsnotify\_inode\_watches\_children(p\_inode); if (unlikely(parent\_watched && !p\_mask))- \_\_fsnotify\_update\_child\_dentry\_flags(p\_inode);+ fsnotify\_clear\_child\_dentry\_flag(p\_inode, dentry);  /\* \* Include parent/name in notification either if some notificationdiff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.hindex fde74eb333cc93..2b4267de86e6b2 100644--- a/[fs/notify/fsnotify.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/fsnotify.h?id=3b9f2d9301ae67070fe77a0c06758722fd7172b7)+++ b/[fs/notify/fsnotify.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/fsnotify.h?id=fc1b1e135c3f72382f792e6c319fc088d5523ad5)@@ -74,7 +74,7 @@ static inline void fsnotify\_clear\_marks\_by\_sb(struct super\_block \*sb) \* update the dentry->d\_flags of all of inode's children to indicate if inode cares \* about events that happen to its children. \*/-extern void \_\_fsnotify\_update\_child\_dentry\_flags(struct inode \*inode);+extern void fsnotify\_set\_children\_dentry\_flags(struct inode \*inode);  extern struct kmem\_cache \*fsnotify\_mark\_connector\_cachep; diff --git a/fs/notify/mark.c b/fs/notify/mark.cindex c74ef947447d67..4be6e883d492f6 100644--- a/[fs/notify/mark.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/mark.c?id=3b9f2d9301ae67070fe77a0c06758722fd7172b7)+++ b/[fs/notify/mark.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/mark.c?id=fc1b1e135c3f72382f792e6c319fc088d5523ad5)@@ -176,6 +176,24 @@ static void \*\_\_fsnotify\_recalc\_mask(struct fsnotify\_mark\_connector \*conn) return fsnotify\_update\_iref(conn, want\_iref); } +static bool fsnotify\_conn\_watches\_children(+ struct fsnotify\_mark\_connector \*conn)+{+ if (conn->type != FSNOTIFY\_OBJ\_TYPE\_INODE)+ return false;++ return fsnotify\_inode\_watches\_children(fsnotify\_conn\_inode(conn));+}++static void fsnotify\_conn\_set\_children\_dentry\_flags(+ struct fsnotify\_mark\_connector \*conn)+{+ if (conn->type != FSNOTIFY\_OBJ\_TYPE\_INODE)+ return;++ fsnotify\_set\_children\_dentry\_flags(fsnotify\_conn\_inode(conn));+}+ /\* \* Calculate mask of events for a list of marks. The caller must make sure \* connector and connector->obj cannot disappear under us. Callers achieve@@ -184,15 +202,23 @@ static void \*\_\_fsnotify\_recalc\_mask(struct fsnotify\_mark\_connector \*conn) \*/ void fsnotify\_recalc\_mask(struct fsnotify\_mark\_connector \*conn) {+ bool update\_children;+ if (!conn) return;  spin\_lock(&conn->lock);+ update\_children = !fsnotify\_conn\_watches\_children(conn); \_\_fsnotify\_recalc\_mask(conn);+ update\_children &= fsnotify\_conn\_watches\_children(conn); spin\_unlock(&conn->lock);- if (conn->type == FSNOTIFY\_OBJ\_TYPE\_INODE)- \_\_fsnotify\_update\_child\_dentry\_flags(- fsnotify\_conn\_inode(conn));+ /\*+ \* Set children's PARENT\_WATCHED flags only if parent started watching.+ \* When parent stops watching, we clear false positive PARENT\_WATCHED+ \* flags lazily in \_\_fsnotify\_parent().+ \*/+ if (update\_children)+ fsnotify\_conn\_set\_children\_dentry\_flags(conn); }  /\* Free all connectors queued for freeing once SRCU period ends \*/diff --git a/include/linux/fsnotify\_backend.h b/include/linux/fsnotify\_backend.hindex c0892d75ce3339..575415b5134972 100644--- a/[include/linux/fsnotify\_backend.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fsnotify_backend.h?id=3b9f2d9301ae67070fe77a0c06758722fd7172b7)+++ b/[include/linux/fsnotify\_backend.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fsnotify_backend.h?id=fc1b1e135c3f72382f792e6c319fc088d5523ad5)@@ -563,12 +563,14 @@ static inline \_\_u32 fsnotify\_parent\_needed\_mask(\_\_u32 mask)  static inline int fsnotify\_inode\_watches\_children(struct inode \*inode) {+ \_\_u32 parent\_mask = READ\_ONCE(inode->i\_fsnotify\_mask);+ /\* FS\_EVENT\_ON\_CHILD is set if the inode may care \*/- if (!(inode->i\_fsnotify\_mask & FS\_EVENT\_ON\_CHILD))+ if (!(parent\_mask & FS\_EVENT\_ON\_CHILD)) return 0; /\* this inode might care about child events, does it care about the \* specific set of events that can happen on a child? \*/- return inode->i\_fsnotify\_mask & FS\_EVENTS\_POSS\_ON\_CHILD;+ return parent\_mask & FS\_EVENTS\_POSS\_ON\_CHILD; }  /\*@@ -582,7 +584,7 @@ static inline void fsnotify\_update\_flags(struct dentry \*dentry) /\* \* Serialisation of setting PARENT\_WATCHED on the dentries is provided \* by d\_lock. If inotify\_inode\_watched changes after we have taken- \* d\_lock, the following \_\_fsnotify\_update\_child\_dentry\_flags call will+ \* d\_lock, the following fsnotify\_set\_children\_dentry\_flags call will \* find our entry, so it will spin until we complete here, and update \* us with the new state. \*/ |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 06:35:46 +0000



=== Content from git.kernel.org_936384df_20250111_063708.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=f9a48bc3dd9099935751458a5bbbea4b7c28abc8)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f9a48bc3dd9099935751458a5bbbea4b7c28abc8)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f9a48bc3dd9099935751458a5bbbea4b7c28abc8)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f9a48bc3dd9099935751458a5bbbea4b7c28abc8)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Amir Goldstein <amir73il@gmail.com> | 2024-05-12 13:30:07 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-09-12 11:07:41 +0200 |
| commit | [f9a48bc3dd9099935751458a5bbbea4b7c28abc8](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f9a48bc3dd9099935751458a5bbbea4b7c28abc8) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=f9a48bc3dd9099935751458a5bbbea4b7c28abc8)) | |
| tree | [8484dced1dee685edba883475b3321002c57cf2c](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f9a48bc3dd9099935751458a5bbbea4b7c28abc8) | |
| parent | [3aa56313b0de06ce1911950b2cc0c269614a87a9](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3aa56313b0de06ce1911950b2cc0c269614a87a9) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f9a48bc3dd9099935751458a5bbbea4b7c28abc8&id2=3aa56313b0de06ce1911950b2cc0c269614a87a9)) | |
| download | [linux-f9a48bc3dd9099935751458a5bbbea4b7c28abc8.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-f9a48bc3dd9099935751458a5bbbea4b7c28abc8.tar.gz) | |

fsnotify: clear PARENT\_WATCHED flags lazily[ Upstream commit 172e422ffea20a89bfdc672741c1aad6fbb5044e ]
In some setups directories can have many (usually negative) dentries.
Hence \_\_fsnotify\_update\_child\_dentry\_flags() function can take a
significant amount of time. Since the bulk of this function happens
under inode->i\_lock this causes a significant contention on the lock
when we remove the watch from the directory as the
\_\_fsnotify\_update\_child\_dentry\_flags() call from fsnotify\_recalc\_mask()
races with \_\_fsnotify\_update\_child\_dentry\_flags() calls from
\_\_fsnotify\_parent() happening on children. This can lead upto softlockup
reports reported by users.
Fix the problem by calling fsnotify\_update\_children\_dentry\_flags() to
set PARENT\_WATCHED flags only when parent starts watching children.
When parent stops watching children, clear false positive PARENT\_WATCHED
flags lazily in \_\_fsnotify\_parent() for each accessed child.
Suggested-by: Jan Kara <jack@suse.cz>
Signed-off-by: Amir Goldstein <amir73il@gmail.com>
Signed-off-by: Stephen Brennan <stephen.s.brennan@oracle.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f9a48bc3dd9099935751458a5bbbea4b7c28abc8)

| -rw-r--r-- | [fs/notify/fsnotify.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/notify/fsnotify.c?id=f9a48bc3dd9099935751458a5bbbea4b7c28abc8) | 31 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/notify/fsnotify.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/notify/fsnotify.h?id=f9a48bc3dd9099935751458a5bbbea4b7c28abc8) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/notify/mark.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/notify/mark.c?id=f9a48bc3dd9099935751458a5bbbea4b7c28abc8) | 32 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/fsnotify\_backend.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/fsnotify_backend.h?id=f9a48bc3dd9099935751458a5bbbea4b7c28abc8) | 8 | |  |  |  | | --- | --- | --- | |

4 files changed, 56 insertions, 17 deletions

| diff --git a/fs/notify/fsnotify.c b/fs/notify/fsnotify.cindex 7974e91ffe134f..b5d8f238fce42a 100644--- a/[fs/notify/fsnotify.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/fsnotify.c?id=3aa56313b0de06ce1911950b2cc0c269614a87a9)+++ b/[fs/notify/fsnotify.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/fsnotify.c?id=f9a48bc3dd9099935751458a5bbbea4b7c28abc8)@@ -103,17 +103,13 @@ void fsnotify\_sb\_delete(struct super\_block \*sb) \* parent cares. Thus when an event happens on a child it can quickly tell \* if there is a need to find a parent and send the event to the parent. \*/-void \_\_fsnotify\_update\_child\_dentry\_flags(struct inode \*inode)+void fsnotify\_set\_children\_dentry\_flags(struct inode \*inode) { struct dentry \*alias;- int watched;  if (!S\_ISDIR(inode->i\_mode)) return; - /\* determine if the children should tell inode about their events \*/- watched = fsnotify\_inode\_watches\_children(inode);- spin\_lock(&inode->i\_lock); /\* run all of the dentries associated with this inode. Since this is a \* directory, there damn well better only be one item on this list \*/@@ -129,10 +125,7 @@ void \_\_fsnotify\_update\_child\_dentry\_flags(struct inode \*inode) continue;  spin\_lock\_nested(&child->d\_lock, DENTRY\_D\_LOCK\_NESTED);- if (watched)- child->d\_flags |= DCACHE\_FSNOTIFY\_PARENT\_WATCHED;- else- child->d\_flags &= ~DCACHE\_FSNOTIFY\_PARENT\_WATCHED;+ child->d\_flags |= DCACHE\_FSNOTIFY\_PARENT\_WATCHED; spin\_unlock(&child->d\_lock); } spin\_unlock(&alias->d\_lock);@@ -140,6 +133,24 @@ void \_\_fsnotify\_update\_child\_dentry\_flags(struct inode \*inode) spin\_unlock(&inode->i\_lock); } +/\*+ \* Lazily clear false positive PARENT\_WATCHED flag for child whose parent had+ \* stopped watching children.+ \*/+static void fsnotify\_clear\_child\_dentry\_flag(struct inode \*pinode,+ struct dentry \*dentry)+{+ spin\_lock(&dentry->d\_lock);+ /\*+ \* d\_lock is a sufficient barrier to prevent observing a non-watched+ \* parent state from before the fsnotify\_set\_children\_dentry\_flags()+ \* or fsnotify\_update\_flags() call that had set PARENT\_WATCHED.+ \*/+ if (!fsnotify\_inode\_watches\_children(pinode))+ dentry->d\_flags &= ~DCACHE\_FSNOTIFY\_PARENT\_WATCHED;+ spin\_unlock(&dentry->d\_lock);+}+ /\* Are inode/sb/mount interested in parent and name info with this event? \*/ static bool fsnotify\_event\_needs\_parent(struct inode \*inode, struct mount \*mnt, \_\_u32 mask)@@ -208,7 +219,7 @@ int \_\_fsnotify\_parent(struct dentry \*dentry, \_\_u32 mask, const void \*data, p\_inode = parent->d\_inode; p\_mask = fsnotify\_inode\_watches\_children(p\_inode); if (unlikely(parent\_watched && !p\_mask))- \_\_fsnotify\_update\_child\_dentry\_flags(p\_inode);+ fsnotify\_clear\_child\_dentry\_flag(p\_inode, dentry);  /\* \* Include parent/name in notification either if some notificationdiff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.hindex fde74eb333cc93..2b4267de86e6b2 100644--- a/[fs/notify/fsnotify.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/fsnotify.h?id=3aa56313b0de06ce1911950b2cc0c269614a87a9)+++ b/[fs/notify/fsnotify.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/fsnotify.h?id=f9a48bc3dd9099935751458a5bbbea4b7c28abc8)@@ -74,7 +74,7 @@ static inline void fsnotify\_clear\_marks\_by\_sb(struct super\_block \*sb) \* update the dentry->d\_flags of all of inode's children to indicate if inode cares \* about events that happen to its children. \*/-extern void \_\_fsnotify\_update\_child\_dentry\_flags(struct inode \*inode);+extern void fsnotify\_set\_children\_dentry\_flags(struct inode \*inode);  extern struct kmem\_cache \*fsnotify\_mark\_connector\_cachep; diff --git a/fs/notify/mark.c b/fs/notify/mark.cindex c74ef947447d67..4be6e883d492f6 100644--- a/[fs/notify/mark.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/mark.c?id=3aa56313b0de06ce1911950b2cc0c269614a87a9)+++ b/[fs/notify/mark.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/mark.c?id=f9a48bc3dd9099935751458a5bbbea4b7c28abc8)@@ -176,6 +176,24 @@ static void \*\_\_fsnotify\_recalc\_mask(struct fsnotify\_mark\_connector \*conn) return fsnotify\_update\_iref(conn, want\_iref); } +static bool fsnotify\_conn\_watches\_children(+ struct fsnotify\_mark\_connector \*conn)+{+ if (conn->type != FSNOTIFY\_OBJ\_TYPE\_INODE)+ return false;++ return fsnotify\_inode\_watches\_children(fsnotify\_conn\_inode(conn));+}++static void fsnotify\_conn\_set\_children\_dentry\_flags(+ struct fsnotify\_mark\_connector \*conn)+{+ if (conn->type != FSNOTIFY\_OBJ\_TYPE\_INODE)+ return;++ fsnotify\_set\_children\_dentry\_flags(fsnotify\_conn\_inode(conn));+}+ /\* \* Calculate mask of events for a list of marks. The caller must make sure \* connector and connector->obj cannot disappear under us. Callers achieve@@ -184,15 +202,23 @@ static void \*\_\_fsnotify\_recalc\_mask(struct fsnotify\_mark\_connector \*conn) \*/ void fsnotify\_recalc\_mask(struct fsnotify\_mark\_connector \*conn) {+ bool update\_children;+ if (!conn) return;  spin\_lock(&conn->lock);+ update\_children = !fsnotify\_conn\_watches\_children(conn); \_\_fsnotify\_recalc\_mask(conn);+ update\_children &= fsnotify\_conn\_watches\_children(conn); spin\_unlock(&conn->lock);- if (conn->type == FSNOTIFY\_OBJ\_TYPE\_INODE)- \_\_fsnotify\_update\_child\_dentry\_flags(- fsnotify\_conn\_inode(conn));+ /\*+ \* Set children's PARENT\_WATCHED flags only if parent started watching.+ \* When parent stops watching, we clear false positive PARENT\_WATCHED+ \* flags lazily in \_\_fsnotify\_parent().+ \*/+ if (update\_children)+ fsnotify\_conn\_set\_children\_dentry\_flags(conn); }  /\* Free all connectors queued for freeing once SRCU period ends \*/diff --git a/include/linux/fsnotify\_backend.h b/include/linux/fsnotify\_backend.hindex d7d96c806bff2b..096b79e4373f4c 100644--- a/[include/linux/fsnotify\_backend.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fsnotify_backend.h?id=3aa56313b0de06ce1911950b2cc0c269614a87a9)+++ b/[include/linux/fsnotify\_backend.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fsnotify_backend.h?id=f9a48bc3dd9099935751458a5bbbea4b7c28abc8)@@ -563,12 +563,14 @@ static inline \_\_u32 fsnotify\_parent\_needed\_mask(\_\_u32 mask)  static inline int fsnotify\_inode\_watches\_children(struct inode \*inode) {+ \_\_u32 parent\_mask = READ\_ONCE(inode->i\_fsnotify\_mask);+ /\* FS\_EVENT\_ON\_CHILD is set if the inode may care \*/- if (!(inode->i\_fsnotify\_mask & FS\_EVENT\_ON\_CHILD))+ if (!(parent\_mask & FS\_EVENT\_ON\_CHILD)) return 0; /\* this inode might care about child events, does it care about the \* specific set of events that can happen on a child? \*/- return inode->i\_fsnotify\_mask & FS\_EVENTS\_POSS\_ON\_CHILD;+ return parent\_mask & FS\_EVENTS\_POSS\_ON\_CHILD; }  /\*@@ -582,7 +584,7 @@ static inline void fsnotify\_update\_flags(struct dentry \*dentry) /\* \* Serialisation of setting PARENT\_WATCHED on the dentries is provided \* by d\_lock. If inotify\_inode\_watched changes after we have taken- \* d\_lock, the following \_\_fsnotify\_update\_child\_dentry\_flags call will+ \* d\_lock, the following fsnotify\_set\_children\_dentry\_flags call will \* find our entry, so it will spin until we complete here, and update \* us with the new state. \*/ |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 06:35:45 +0000



=== Content from git.kernel.org_4aa176ae_20250111_063707.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Amir Goldstein <amir73il@gmail.com> | 2024-05-12 13:30:07 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-09-08 07:53:10 +0200 |
| commit | [d8c42405fc3507cc43ba7e4986a773c3fc633f6e](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e)) | |
| tree | [49a4d7f5b8897605bab6229c42fae6f1767fd1eb](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e) | |
| parent | [b4243c05d7e3db0bdbf9124e6fa59b4ca7c807ae](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b4243c05d7e3db0bdbf9124e6fa59b4ca7c807ae) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e&id2=b4243c05d7e3db0bdbf9124e6fa59b4ca7c807ae)) | |
| download | [linux-d8c42405fc3507cc43ba7e4986a773c3fc633f6e.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-d8c42405fc3507cc43ba7e4986a773c3fc633f6e.tar.gz) | |

fsnotify: clear PARENT\_WATCHED flags lazily[ Upstream commit 172e422ffea20a89bfdc672741c1aad6fbb5044e ]
In some setups directories can have many (usually negative) dentries.
Hence \_\_fsnotify\_update\_child\_dentry\_flags() function can take a
significant amount of time. Since the bulk of this function happens
under inode->i\_lock this causes a significant contention on the lock
when we remove the watch from the directory as the
\_\_fsnotify\_update\_child\_dentry\_flags() call from fsnotify\_recalc\_mask()
races with \_\_fsnotify\_update\_child\_dentry\_flags() calls from
\_\_fsnotify\_parent() happening on children. This can lead upto softlockup
reports reported by users.
Fix the problem by calling fsnotify\_update\_children\_dentry\_flags() to
set PARENT\_WATCHED flags only when parent starts watching children.
When parent stops watching children, clear false positive PARENT\_WATCHED
flags lazily in \_\_fsnotify\_parent() for each accessed child.
Suggested-by: Jan Kara <jack@suse.cz>
Signed-off-by: Amir Goldstein <amir73il@gmail.com>
Signed-off-by: Stephen Brennan <stephen.s.brennan@oracle.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e)

| -rw-r--r-- | [fs/notify/fsnotify.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/notify/fsnotify.c?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e) | 31 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/notify/fsnotify.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/notify/fsnotify.h?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/notify/mark.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/notify/mark.c?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e) | 32 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/fsnotify\_backend.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/fsnotify_backend.h?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e) | 8 | |  |  |  | | --- | --- | --- | |

4 files changed, 56 insertions, 17 deletions

| diff --git a/fs/notify/fsnotify.c b/fs/notify/fsnotify.cindex 7974e91ffe134f..b5d8f238fce42a 100644--- a/[fs/notify/fsnotify.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/fsnotify.c?id=b4243c05d7e3db0bdbf9124e6fa59b4ca7c807ae)+++ b/[fs/notify/fsnotify.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/fsnotify.c?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e)@@ -103,17 +103,13 @@ void fsnotify\_sb\_delete(struct super\_block \*sb) \* parent cares. Thus when an event happens on a child it can quickly tell \* if there is a need to find a parent and send the event to the parent. \*/-void \_\_fsnotify\_update\_child\_dentry\_flags(struct inode \*inode)+void fsnotify\_set\_children\_dentry\_flags(struct inode \*inode) { struct dentry \*alias;- int watched;  if (!S\_ISDIR(inode->i\_mode)) return; - /\* determine if the children should tell inode about their events \*/- watched = fsnotify\_inode\_watches\_children(inode);- spin\_lock(&inode->i\_lock); /\* run all of the dentries associated with this inode. Since this is a \* directory, there damn well better only be one item on this list \*/@@ -129,10 +125,7 @@ void \_\_fsnotify\_update\_child\_dentry\_flags(struct inode \*inode) continue;  spin\_lock\_nested(&child->d\_lock, DENTRY\_D\_LOCK\_NESTED);- if (watched)- child->d\_flags |= DCACHE\_FSNOTIFY\_PARENT\_WATCHED;- else- child->d\_flags &= ~DCACHE\_FSNOTIFY\_PARENT\_WATCHED;+ child->d\_flags |= DCACHE\_FSNOTIFY\_PARENT\_WATCHED; spin\_unlock(&child->d\_lock); } spin\_unlock(&alias->d\_lock);@@ -140,6 +133,24 @@ void \_\_fsnotify\_update\_child\_dentry\_flags(struct inode \*inode) spin\_unlock(&inode->i\_lock); } +/\*+ \* Lazily clear false positive PARENT\_WATCHED flag for child whose parent had+ \* stopped watching children.+ \*/+static void fsnotify\_clear\_child\_dentry\_flag(struct inode \*pinode,+ struct dentry \*dentry)+{+ spin\_lock(&dentry->d\_lock);+ /\*+ \* d\_lock is a sufficient barrier to prevent observing a non-watched+ \* parent state from before the fsnotify\_set\_children\_dentry\_flags()+ \* or fsnotify\_update\_flags() call that had set PARENT\_WATCHED.+ \*/+ if (!fsnotify\_inode\_watches\_children(pinode))+ dentry->d\_flags &= ~DCACHE\_FSNOTIFY\_PARENT\_WATCHED;+ spin\_unlock(&dentry->d\_lock);+}+ /\* Are inode/sb/mount interested in parent and name info with this event? \*/ static bool fsnotify\_event\_needs\_parent(struct inode \*inode, struct mount \*mnt, \_\_u32 mask)@@ -208,7 +219,7 @@ int \_\_fsnotify\_parent(struct dentry \*dentry, \_\_u32 mask, const void \*data, p\_inode = parent->d\_inode; p\_mask = fsnotify\_inode\_watches\_children(p\_inode); if (unlikely(parent\_watched && !p\_mask))- \_\_fsnotify\_update\_child\_dentry\_flags(p\_inode);+ fsnotify\_clear\_child\_dentry\_flag(p\_inode, dentry);  /\* \* Include parent/name in notification either if some notificationdiff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.hindex fde74eb333cc93..2b4267de86e6b2 100644--- a/[fs/notify/fsnotify.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/fsnotify.h?id=b4243c05d7e3db0bdbf9124e6fa59b4ca7c807ae)+++ b/[fs/notify/fsnotify.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/fsnotify.h?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e)@@ -74,7 +74,7 @@ static inline void fsnotify\_clear\_marks\_by\_sb(struct super\_block \*sb) \* update the dentry->d\_flags of all of inode's children to indicate if inode cares \* about events that happen to its children. \*/-extern void \_\_fsnotify\_update\_child\_dentry\_flags(struct inode \*inode);+extern void fsnotify\_set\_children\_dentry\_flags(struct inode \*inode);  extern struct kmem\_cache \*fsnotify\_mark\_connector\_cachep; diff --git a/fs/notify/mark.c b/fs/notify/mark.cindex c74ef947447d67..4be6e883d492f6 100644--- a/[fs/notify/mark.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/mark.c?id=b4243c05d7e3db0bdbf9124e6fa59b4ca7c807ae)+++ b/[fs/notify/mark.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/mark.c?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e)@@ -176,6 +176,24 @@ static void \*\_\_fsnotify\_recalc\_mask(struct fsnotify\_mark\_connector \*conn) return fsnotify\_update\_iref(conn, want\_iref); } +static bool fsnotify\_conn\_watches\_children(+ struct fsnotify\_mark\_connector \*conn)+{+ if (conn->type != FSNOTIFY\_OBJ\_TYPE\_INODE)+ return false;++ return fsnotify\_inode\_watches\_children(fsnotify\_conn\_inode(conn));+}++static void fsnotify\_conn\_set\_children\_dentry\_flags(+ struct fsnotify\_mark\_connector \*conn)+{+ if (conn->type != FSNOTIFY\_OBJ\_TYPE\_INODE)+ return;++ fsnotify\_set\_children\_dentry\_flags(fsnotify\_conn\_inode(conn));+}+ /\* \* Calculate mask of events for a list of marks. The caller must make sure \* connector and connector->obj cannot disappear under us. Callers achieve@@ -184,15 +202,23 @@ static void \*\_\_fsnotify\_recalc\_mask(struct fsnotify\_mark\_connector \*conn) \*/ void fsnotify\_recalc\_mask(struct fsnotify\_mark\_connector \*conn) {+ bool update\_children;+ if (!conn) return;  spin\_lock(&conn->lock);+ update\_children = !fsnotify\_conn\_watches\_children(conn); \_\_fsnotify\_recalc\_mask(conn);+ update\_children &= fsnotify\_conn\_watches\_children(conn); spin\_unlock(&conn->lock);- if (conn->type == FSNOTIFY\_OBJ\_TYPE\_INODE)- \_\_fsnotify\_update\_child\_dentry\_flags(- fsnotify\_conn\_inode(conn));+ /\*+ \* Set children's PARENT\_WATCHED flags only if parent started watching.+ \* When parent stops watching, we clear false positive PARENT\_WATCHED+ \* flags lazily in \_\_fsnotify\_parent().+ \*/+ if (update\_children)+ fsnotify\_conn\_set\_children\_dentry\_flags(conn); }  /\* Free all connectors queued for freeing once SRCU period ends \*/diff --git a/include/linux/fsnotify\_backend.h b/include/linux/fsnotify\_backend.hindex d7d96c806bff2b..096b79e4373f4c 100644--- a/[include/linux/fsnotify\_backend.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fsnotify_backend.h?id=b4243c05d7e3db0bdbf9124e6fa59b4ca7c807ae)+++ b/[include/linux/fsnotify\_backend.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fsnotify_backend.h?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e)@@ -563,12 +563,14 @@ static inline \_\_u32 fsnotify\_parent\_needed\_mask(\_\_u32 mask)  static inline int fsnotify\_inode\_watches\_children(struct inode \*inode) {+ \_\_u32 parent\_mask = READ\_ONCE(inode->i\_fsnotify\_mask);+ /\* FS\_EVENT\_ON\_CHILD is set if the inode may care \*/- if (!(inode->i\_fsnotify\_mask & FS\_EVENT\_ON\_CHILD))+ if (!(parent\_mask & FS\_EVENT\_ON\_CHILD)) return 0; /\* this inode might care about child events, does it care about the \* specific set of events that can happen on a child? \*/- return inode->i\_fsnotify\_mask & FS\_EVENTS\_POSS\_ON\_CHILD;+ return parent\_mask & FS\_EVENTS\_POSS\_ON\_CHILD; }  /\*@@ -582,7 +584,7 @@ static inline void fsnotify\_update\_flags(struct dentry \*dentry) /\* \* Serialisation of setting PARENT\_WATCHED on the dentries is provided \* by d\_lock. If inotify\_inode\_watched changes after we have taken- \* d\_lock, the following \_\_fsnotify\_update\_child\_dentry\_flags call will+ \* d\_lock, the following fsnotify\_set\_children\_dentry\_flags call will \* find our entry, so it will spin until we complete here, and update \* us with the new state. \*/ |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 06:35:44 +0000



=== Content from git.kernel.org_a4ede0a6_20250111_063707.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=7ef1d2e240c32b1f337a37232d037b07e3919e1a)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=7ef1d2e240c32b1f337a37232d037b07e3919e1a)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7ef1d2e240c32b1f337a37232d037b07e3919e1a)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7ef1d2e240c32b1f337a37232d037b07e3919e1a)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Amir Goldstein <amir73il@gmail.com> | 2024-05-12 13:30:07 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-09-08 07:56:34 +0200 |
| commit | [7ef1d2e240c32b1f337a37232d037b07e3919e1a](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7ef1d2e240c32b1f337a37232d037b07e3919e1a) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=7ef1d2e240c32b1f337a37232d037b07e3919e1a)) | |
| tree | [ba0bb34de5766c9fcdd356194e435cdce5852e36](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=7ef1d2e240c32b1f337a37232d037b07e3919e1a) | |
| parent | [4ff3d3d18d8f9d19e42b037c8bd2c746c524c9a7](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=4ff3d3d18d8f9d19e42b037c8bd2c746c524c9a7) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7ef1d2e240c32b1f337a37232d037b07e3919e1a&id2=4ff3d3d18d8f9d19e42b037c8bd2c746c524c9a7)) | |
| download | [linux-7ef1d2e240c32b1f337a37232d037b07e3919e1a.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-7ef1d2e240c32b1f337a37232d037b07e3919e1a.tar.gz) | |

fsnotify: clear PARENT\_WATCHED flags lazily[ Upstream commit 172e422ffea20a89bfdc672741c1aad6fbb5044e ]
In some setups directories can have many (usually negative) dentries.
Hence \_\_fsnotify\_update\_child\_dentry\_flags() function can take a
significant amount of time. Since the bulk of this function happens
under inode->i\_lock this causes a significant contention on the lock
when we remove the watch from the directory as the
\_\_fsnotify\_update\_child\_dentry\_flags() call from fsnotify\_recalc\_mask()
races with \_\_fsnotify\_update\_child\_dentry\_flags() calls from
\_\_fsnotify\_parent() happening on children. This can lead upto softlockup
reports reported by users.
Fix the problem by calling fsnotify\_update\_children\_dentry\_flags() to
set PARENT\_WATCHED flags only when parent starts watching children.
When parent stops watching children, clear false positive PARENT\_WATCHED
flags lazily in \_\_fsnotify\_parent() for each accessed child.
Suggested-by: Jan Kara <jack@suse.cz>
Signed-off-by: Amir Goldstein <amir73il@gmail.com>
Signed-off-by: Stephen Brennan <stephen.s.brennan@oracle.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7ef1d2e240c32b1f337a37232d037b07e3919e1a)

| -rw-r--r-- | [fs/notify/fsnotify.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/notify/fsnotify.c?id=7ef1d2e240c32b1f337a37232d037b07e3919e1a) | 31 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/notify/fsnotify.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/notify/fsnotify.h?id=7ef1d2e240c32b1f337a37232d037b07e3919e1a) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/notify/mark.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/notify/mark.c?id=7ef1d2e240c32b1f337a37232d037b07e3919e1a) | 32 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/fsnotify\_backend.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/fsnotify_backend.h?id=7ef1d2e240c32b1f337a37232d037b07e3919e1a) | 8 | |  |  |  | | --- | --- | --- | |

4 files changed, 56 insertions, 17 deletions

| diff --git a/fs/notify/fsnotify.c b/fs/notify/fsnotify.cindex ff69ae24c4e891..272c8a1dab3c27 100644--- a/[fs/notify/fsnotify.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/fsnotify.c?id=4ff3d3d18d8f9d19e42b037c8bd2c746c524c9a7)+++ b/[fs/notify/fsnotify.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/fsnotify.c?id=7ef1d2e240c32b1f337a37232d037b07e3919e1a)@@ -117,17 +117,13 @@ void fsnotify\_sb\_free(struct super\_block \*sb) \* parent cares. Thus when an event happens on a child it can quickly tell \* if there is a need to find a parent and send the event to the parent. \*/-void \_\_fsnotify\_update\_child\_dentry\_flags(struct inode \*inode)+void fsnotify\_set\_children\_dentry\_flags(struct inode \*inode) { struct dentry \*alias;- int watched;  if (!S\_ISDIR(inode->i\_mode)) return; - /\* determine if the children should tell inode about their events \*/- watched = fsnotify\_inode\_watches\_children(inode);- spin\_lock(&inode->i\_lock); /\* run all of the dentries associated with this inode. Since this is a \* directory, there damn well better only be one item on this list \*/@@ -143,10 +139,7 @@ void \_\_fsnotify\_update\_child\_dentry\_flags(struct inode \*inode) continue;  spin\_lock\_nested(&child->d\_lock, DENTRY\_D\_LOCK\_NESTED);- if (watched)- child->d\_flags |= DCACHE\_FSNOTIFY\_PARENT\_WATCHED;- else- child->d\_flags &= ~DCACHE\_FSNOTIFY\_PARENT\_WATCHED;+ child->d\_flags |= DCACHE\_FSNOTIFY\_PARENT\_WATCHED; spin\_unlock(&child->d\_lock); } spin\_unlock(&alias->d\_lock);@@ -154,6 +147,24 @@ void \_\_fsnotify\_update\_child\_dentry\_flags(struct inode \*inode) spin\_unlock(&inode->i\_lock); } +/\*+ \* Lazily clear false positive PARENT\_WATCHED flag for child whose parent had+ \* stopped watching children.+ \*/+static void fsnotify\_clear\_child\_dentry\_flag(struct inode \*pinode,+ struct dentry \*dentry)+{+ spin\_lock(&dentry->d\_lock);+ /\*+ \* d\_lock is a sufficient barrier to prevent observing a non-watched+ \* parent state from before the fsnotify\_set\_children\_dentry\_flags()+ \* or fsnotify\_update\_flags() call that had set PARENT\_WATCHED.+ \*/+ if (!fsnotify\_inode\_watches\_children(pinode))+ dentry->d\_flags &= ~DCACHE\_FSNOTIFY\_PARENT\_WATCHED;+ spin\_unlock(&dentry->d\_lock);+}+ /\* Are inode/sb/mount interested in parent and name info with this event? \*/ static bool fsnotify\_event\_needs\_parent(struct inode \*inode, \_\_u32 mnt\_mask, \_\_u32 mask)@@ -228,7 +239,7 @@ int \_\_fsnotify\_parent(struct dentry \*dentry, \_\_u32 mask, const void \*data, p\_inode = parent->d\_inode; p\_mask = fsnotify\_inode\_watches\_children(p\_inode); if (unlikely(parent\_watched && !p\_mask))- \_\_fsnotify\_update\_child\_dentry\_flags(p\_inode);+ fsnotify\_clear\_child\_dentry\_flag(p\_inode, dentry);  /\* \* Include parent/name in notification either if some notificationdiff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.hindex 2d059f789ee355..663759ed6fbc1b 100644--- a/[fs/notify/fsnotify.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/fsnotify.h?id=4ff3d3d18d8f9d19e42b037c8bd2c746c524c9a7)+++ b/[fs/notify/fsnotify.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/fsnotify.h?id=7ef1d2e240c32b1f337a37232d037b07e3919e1a)@@ -93,7 +93,7 @@ static inline void fsnotify\_clear\_marks\_by\_sb(struct super\_block \*sb) \* update the dentry->d\_flags of all of inode's children to indicate if inode cares \* about events that happen to its children. \*/-extern void \_\_fsnotify\_update\_child\_dentry\_flags(struct inode \*inode);+extern void fsnotify\_set\_children\_dentry\_flags(struct inode \*inode);  extern struct kmem\_cache \*fsnotify\_mark\_connector\_cachep; diff --git a/fs/notify/mark.c b/fs/notify/mark.cindex c3eefa70633c4d..5e170e71308868 100644--- a/[fs/notify/mark.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/mark.c?id=4ff3d3d18d8f9d19e42b037c8bd2c746c524c9a7)+++ b/[fs/notify/mark.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/mark.c?id=7ef1d2e240c32b1f337a37232d037b07e3919e1a)@@ -250,6 +250,24 @@ static void \*\_\_fsnotify\_recalc\_mask(struct fsnotify\_mark\_connector \*conn) return fsnotify\_update\_iref(conn, want\_iref); } +static bool fsnotify\_conn\_watches\_children(+ struct fsnotify\_mark\_connector \*conn)+{+ if (conn->type != FSNOTIFY\_OBJ\_TYPE\_INODE)+ return false;++ return fsnotify\_inode\_watches\_children(fsnotify\_conn\_inode(conn));+}++static void fsnotify\_conn\_set\_children\_dentry\_flags(+ struct fsnotify\_mark\_connector \*conn)+{+ if (conn->type != FSNOTIFY\_OBJ\_TYPE\_INODE)+ return;++ fsnotify\_set\_children\_dentry\_flags(fsnotify\_conn\_inode(conn));+}+ /\* \* Calculate mask of events for a list of marks. The caller must make sure \* connector and connector->obj cannot disappear under us. Callers achieve@@ -258,15 +276,23 @@ static void \*\_\_fsnotify\_recalc\_mask(struct fsnotify\_mark\_connector \*conn) \*/ void fsnotify\_recalc\_mask(struct fsnotify\_mark\_connector \*conn) {+ bool update\_children;+ if (!conn) return;  spin\_lock(&conn->lock);+ update\_children = !fsnotify\_conn\_watches\_children(conn); \_\_fsnotify\_recalc\_mask(conn);+ update\_children &= fsnotify\_conn\_watches\_children(conn); spin\_unlock(&conn->lock);- if (conn->type == FSNOTIFY\_OBJ\_TYPE\_INODE)- \_\_fsnotify\_update\_child\_dentry\_flags(- fsnotify\_conn\_inode(conn));+ /\*+ \* Set children's PARENT\_WATCHED flags only if parent started watching.+ \* When parent stops watching, we clear false positive PARENT\_WATCHED+ \* flags lazily in \_\_fsnotify\_parent().+ \*/+ if (update\_children)+ fsnotify\_conn\_set\_children\_dentry\_flags(conn); }  /\* Free all connectors queued for freeing once SRCU period ends \*/diff --git a/include/linux/fsnotify\_backend.h b/include/linux/fsnotify\_backend.hindex 4dd6143db27165..8be029bc50b1e3 100644--- a/[include/linux/fsnotify\_backend.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fsnotify_backend.h?id=4ff3d3d18d8f9d19e42b037c8bd2c746c524c9a7)+++ b/[include/linux/fsnotify\_backend.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fsnotify_backend.h?id=7ef1d2e240c32b1f337a37232d037b07e3919e1a)@@ -594,12 +594,14 @@ static inline \_\_u32 fsnotify\_parent\_needed\_mask(\_\_u32 mask)  static inline int fsnotify\_inode\_watches\_children(struct inode \*inode) {+ \_\_u32 parent\_mask = READ\_ONCE(inode->i\_fsnotify\_mask);+ /\* FS\_EVENT\_ON\_CHILD is set if the inode may care \*/- if (!(inode->i\_fsnotify\_mask & FS\_EVENT\_ON\_CHILD))+ if (!(parent\_mask & FS\_EVENT\_ON\_CHILD)) return 0; /\* this inode might care about child events, does it care about the \* specific set of events that can happen on a child? \*/- return inode->i\_fsnotify\_mask & FS\_EVENTS\_POSS\_ON\_CHILD;+ return parent\_mask & FS\_EVENTS\_POSS\_ON\_CHILD; }  /\*@@ -613,7 +615,7 @@ static inline void fsnotify\_update\_flags(struct dentry \*dentry) /\* \* Serialisation of setting PARENT\_WATCHED on the dentries is provided \* by d\_lock. If inotify\_inode\_watched changes after we have taken- \* d\_lock, the following \_\_fsnotify\_update\_child\_dentry\_flags call will+ \* d\_lock, the following fsnotify\_set\_children\_dentry\_flags call will \* find our entry, so it will spin until we complete here, and update \* us with the new state. \*/ |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 06:35:44 +0000



=== Content from git.kernel.org_fd7ade49_20250111_063705.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=172e422ffea20a89bfdc672741c1aad6fbb5044e)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=172e422ffea20a89bfdc672741c1aad6fbb5044e)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=172e422ffea20a89bfdc672741c1aad6fbb5044e)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=172e422ffea20a89bfdc672741c1aad6fbb5044e)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Amir Goldstein <amir73il@gmail.com> | 2024-05-12 13:30:07 +0200 |
| --- | --- | --- |
| committer | Jan Kara <jack@suse.cz> | 2024-06-05 09:52:38 +0200 |
| commit | [172e422ffea20a89bfdc672741c1aad6fbb5044e](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=172e422ffea20a89bfdc672741c1aad6fbb5044e) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=172e422ffea20a89bfdc672741c1aad6fbb5044e)) | |
| tree | [2ac8a1902891722aa44047a41848c446fd35c34a](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=172e422ffea20a89bfdc672741c1aad6fbb5044e) | |
| parent | [32f88d65f01bf6f45476d7edbe675e44fb9e1d58](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=32f88d65f01bf6f45476d7edbe675e44fb9e1d58) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=172e422ffea20a89bfdc672741c1aad6fbb5044e&id2=32f88d65f01bf6f45476d7edbe675e44fb9e1d58)) | |
| download | [linux-172e422ffea20a89bfdc672741c1aad6fbb5044e.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-172e422ffea20a89bfdc672741c1aad6fbb5044e.tar.gz) | |

fsnotify: clear PARENT\_WATCHED flags lazilyIn some setups directories can have many (usually negative) dentries.
Hence \_\_fsnotify\_update\_child\_dentry\_flags() function can take a
significant amount of time. Since the bulk of this function happens
under inode->i\_lock this causes a significant contention on the lock
when we remove the watch from the directory as the
\_\_fsnotify\_update\_child\_dentry\_flags() call from fsnotify\_recalc\_mask()
races with \_\_fsnotify\_update\_child\_dentry\_flags() calls from
\_\_fsnotify\_parent() happening on children. This can lead upto softlockup
reports reported by users.
Fix the problem by calling fsnotify\_update\_children\_dentry\_flags() to
set PARENT\_WATCHED flags only when parent starts watching children.
When parent stops watching children, clear false positive PARENT\_WATCHED
flags lazily in \_\_fsnotify\_parent() for each accessed child.
Suggested-by: Jan Kara <jack@suse.cz>
Signed-off-by: Amir Goldstein <amir73il@gmail.com>
Signed-off-by: Stephen Brennan <stephen.s.brennan@oracle.com>
Signed-off-by: Jan Kara <jack@suse.cz>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=172e422ffea20a89bfdc672741c1aad6fbb5044e)

| -rw-r--r-- | [fs/notify/fsnotify.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/notify/fsnotify.c?id=172e422ffea20a89bfdc672741c1aad6fbb5044e) | 31 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/notify/fsnotify.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/notify/fsnotify.h?id=172e422ffea20a89bfdc672741c1aad6fbb5044e) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/notify/mark.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/notify/mark.c?id=172e422ffea20a89bfdc672741c1aad6fbb5044e) | 32 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/fsnotify\_backend.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/fsnotify_backend.h?id=172e422ffea20a89bfdc672741c1aad6fbb5044e) | 8 | |  |  |  | | --- | --- | --- | |

4 files changed, 56 insertions, 17 deletions

| diff --git a/fs/notify/fsnotify.c b/fs/notify/fsnotify.cindex ff69ae24c4e891..272c8a1dab3c27 100644--- a/[fs/notify/fsnotify.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/fsnotify.c?id=32f88d65f01bf6f45476d7edbe675e44fb9e1d58)+++ b/[fs/notify/fsnotify.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/fsnotify.c?id=172e422ffea20a89bfdc672741c1aad6fbb5044e)@@ -117,17 +117,13 @@ void fsnotify\_sb\_free(struct super\_block \*sb) \* parent cares. Thus when an event happens on a child it can quickly tell \* if there is a need to find a parent and send the event to the parent. \*/-void \_\_fsnotify\_update\_child\_dentry\_flags(struct inode \*inode)+void fsnotify\_set\_children\_dentry\_flags(struct inode \*inode) { struct dentry \*alias;- int watched;  if (!S\_ISDIR(inode->i\_mode)) return; - /\* determine if the children should tell inode about their events \*/- watched = fsnotify\_inode\_watches\_children(inode);- spin\_lock(&inode->i\_lock); /\* run all of the dentries associated with this inode. Since this is a \* directory, there damn well better only be one item on this list \*/@@ -143,10 +139,7 @@ void \_\_fsnotify\_update\_child\_dentry\_flags(struct inode \*inode) continue;  spin\_lock\_nested(&child->d\_lock, DENTRY\_D\_LOCK\_NESTED);- if (watched)- child->d\_flags |= DCACHE\_FSNOTIFY\_PARENT\_WATCHED;- else- child->d\_flags &= ~DCACHE\_FSNOTIFY\_PARENT\_WATCHED;+ child->d\_flags |= DCACHE\_FSNOTIFY\_PARENT\_WATCHED; spin\_unlock(&child->d\_lock); } spin\_unlock(&alias->d\_lock);@@ -154,6 +147,24 @@ void \_\_fsnotify\_update\_child\_dentry\_flags(struct inode \*inode) spin\_unlock(&inode->i\_lock); } +/\*+ \* Lazily clear false positive PARENT\_WATCHED flag for child whose parent had+ \* stopped watching children.+ \*/+static void fsnotify\_clear\_child\_dentry\_flag(struct inode \*pinode,+ struct dentry \*dentry)+{+ spin\_lock(&dentry->d\_lock);+ /\*+ \* d\_lock is a sufficient barrier to prevent observing a non-watched+ \* parent state from before the fsnotify\_set\_children\_dentry\_flags()+ \* or fsnotify\_update\_flags() call that had set PARENT\_WATCHED.+ \*/+ if (!fsnotify\_inode\_watches\_children(pinode))+ dentry->d\_flags &= ~DCACHE\_FSNOTIFY\_PARENT\_WATCHED;+ spin\_unlock(&dentry->d\_lock);+}+ /\* Are inode/sb/mount interested in parent and name info with this event? \*/ static bool fsnotify\_event\_needs\_parent(struct inode \*inode, \_\_u32 mnt\_mask, \_\_u32 mask)@@ -228,7 +239,7 @@ int \_\_fsnotify\_parent(struct dentry \*dentry, \_\_u32 mask, const void \*data, p\_inode = parent->d\_inode; p\_mask = fsnotify\_inode\_watches\_children(p\_inode); if (unlikely(parent\_watched && !p\_mask))- \_\_fsnotify\_update\_child\_dentry\_flags(p\_inode);+ fsnotify\_clear\_child\_dentry\_flag(p\_inode, dentry);  /\* \* Include parent/name in notification either if some notificationdiff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.hindex 2d059f789ee355..663759ed6fbc1b 100644--- a/[fs/notify/fsnotify.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/fsnotify.h?id=32f88d65f01bf6f45476d7edbe675e44fb9e1d58)+++ b/[fs/notify/fsnotify.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/fsnotify.h?id=172e422ffea20a89bfdc672741c1aad6fbb5044e)@@ -93,7 +93,7 @@ static inline void fsnotify\_clear\_marks\_by\_sb(struct super\_block \*sb) \* update the dentry->d\_flags of all of inode's children to indicate if inode cares \* about events that happen to its children. \*/-extern void \_\_fsnotify\_update\_child\_dentry\_flags(struct inode \*inode);+extern void fsnotify\_set\_children\_dentry\_flags(struct inode \*inode);  extern struct kmem\_cache \*fsnotify\_mark\_connector\_cachep; diff --git a/fs/notify/mark.c b/fs/notify/mark.cindex c3eefa70633c4d..5e170e71308868 100644--- a/[fs/notify/mark.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/mark.c?id=32f88d65f01bf6f45476d7edbe675e44fb9e1d58)+++ b/[fs/notify/mark.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/mark.c?id=172e422ffea20a89bfdc672741c1aad6fbb5044e)@@ -250,6 +250,24 @@ static void \*\_\_fsnotify\_recalc\_mask(struct fsnotify\_mark\_connector \*conn) return fsnotify\_update\_iref(conn, want\_iref); } +static bool fsnotify\_conn\_watches\_children(+ struct fsnotify\_mark\_connector \*conn)+{+ if (conn->type != FSNOTIFY\_OBJ\_TYPE\_INODE)+ return false;++ return fsnotify\_inode\_watches\_children(fsnotify\_conn\_inode(conn));+}++static void fsnotify\_conn\_set\_children\_dentry\_flags(+ struct fsnotify\_mark\_connector \*conn)+{+ if (conn->type != FSNOTIFY\_OBJ\_TYPE\_INODE)+ return;++ fsnotify\_set\_children\_dentry\_flags(fsnotify\_conn\_inode(conn));+}+ /\* \* Calculate mask of events for a list of marks. The caller must make sure \* connector and connector->obj cannot disappear under us. Callers achieve@@ -258,15 +276,23 @@ static void \*\_\_fsnotify\_recalc\_mask(struct fsnotify\_mark\_connector \*conn) \*/ void fsnotify\_recalc\_mask(struct fsnotify\_mark\_connector \*conn) {+ bool update\_children;+ if (!conn) return;  spin\_lock(&conn->lock);+ update\_children = !fsnotify\_conn\_watches\_children(conn); \_\_fsnotify\_recalc\_mask(conn);+ update\_children &= fsnotify\_conn\_watches\_children(conn); spin\_unlock(&conn->lock);- if (conn->type == FSNOTIFY\_OBJ\_TYPE\_INODE)- \_\_fsnotify\_update\_child\_dentry\_flags(- fsnotify\_conn\_inode(conn));+ /\*+ \* Set children's PARENT\_WATCHED flags only if parent started watching.+ \* When parent stops watching, we clear false positive PARENT\_WATCHED+ \* flags lazily in \_\_fsnotify\_parent().+ \*/+ if (update\_children)+ fsnotify\_conn\_set\_children\_dentry\_flags(conn); }  /\* Free all connectors queued for freeing once SRCU period ends \*/diff --git a/include/linux/fsnotify\_backend.h b/include/linux/fsnotify\_backend.hindex 4dd6143db27165..8be029bc50b1e3 100644--- a/[include/linux/fsnotify\_backend.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fsnotify_backend.h?id=32f88d65f01bf6f45476d7edbe675e44fb9e1d58)+++ b/[include/linux/fsnotify\_backend.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fsnotify_backend.h?id=172e422ffea20a89bfdc672741c1aad6fbb5044e)@@ -594,12 +594,14 @@ static inline \_\_u32 fsnotify\_parent\_needed\_mask(\_\_u32 mask)  static inline int fsnotify\_inode\_watches\_children(struct inode \*inode) {+ \_\_u32 parent\_mask = READ\_ONCE(inode->i\_fsnotify\_mask);+ /\* FS\_EVENT\_ON\_CHILD is set if the inode may care \*/- if (!(inode->i\_fsnotify\_mask & FS\_EVENT\_ON\_CHILD))+ if (!(parent\_mask & FS\_EVENT\_ON\_CHILD)) return 0; /\* this inode might care about child events, does it care about the \* specific set of events that can happen on a child? \*/- return inode->i\_fsnotify\_mask & FS\_EVENTS\_POSS\_ON\_CHILD;+ return parent\_mask & FS\_EVENTS\_POSS\_ON\_CHILD; }  /\*@@ -613,7 +615,7 @@ static inline void fsnotify\_update\_flags(struct dentry \*dentry) /\* \* Serialisation of setting PARENT\_WATCHED on the dentries is provided \* by d\_lock. If inotify\_inode\_watched changes after we have taken- \* d\_lock, the following \_\_fsnotify\_update\_child\_dentry\_flags call will+ \* d\_lock, the following fsnotify\_set\_children\_dentry\_flags call will \* find our entry, so it will spin until we complete here, and update \* us with the new state. \*/ |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 06:35:43 +0000


