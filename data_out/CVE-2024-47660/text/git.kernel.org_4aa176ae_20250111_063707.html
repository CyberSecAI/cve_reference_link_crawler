

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Amir Goldstein <amir73il@gmail.com> | 2024-05-12 13:30:07 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-09-08 07:53:10 +0200 |
| commit | [d8c42405fc3507cc43ba7e4986a773c3fc633f6e](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e)) | |
| tree | [49a4d7f5b8897605bab6229c42fae6f1767fd1eb](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e) | |
| parent | [b4243c05d7e3db0bdbf9124e6fa59b4ca7c807ae](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b4243c05d7e3db0bdbf9124e6fa59b4ca7c807ae) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e&id2=b4243c05d7e3db0bdbf9124e6fa59b4ca7c807ae)) | |
| download | [linux-d8c42405fc3507cc43ba7e4986a773c3fc633f6e.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-d8c42405fc3507cc43ba7e4986a773c3fc633f6e.tar.gz) | |

fsnotify: clear PARENT\_WATCHED flags lazily[ Upstream commit 172e422ffea20a89bfdc672741c1aad6fbb5044e ]
In some setups directories can have many (usually negative) dentries.
Hence \_\_fsnotify\_update\_child\_dentry\_flags() function can take a
significant amount of time. Since the bulk of this function happens
under inode->i\_lock this causes a significant contention on the lock
when we remove the watch from the directory as the
\_\_fsnotify\_update\_child\_dentry\_flags() call from fsnotify\_recalc\_mask()
races with \_\_fsnotify\_update\_child\_dentry\_flags() calls from
\_\_fsnotify\_parent() happening on children. This can lead upto softlockup
reports reported by users.
Fix the problem by calling fsnotify\_update\_children\_dentry\_flags() to
set PARENT\_WATCHED flags only when parent starts watching children.
When parent stops watching children, clear false positive PARENT\_WATCHED
flags lazily in \_\_fsnotify\_parent() for each accessed child.
Suggested-by: Jan Kara <jack@suse.cz>
Signed-off-by: Amir Goldstein <amir73il@gmail.com>
Signed-off-by: Stephen Brennan <stephen.s.brennan@oracle.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e)

| -rw-r--r-- | [fs/notify/fsnotify.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/notify/fsnotify.c?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e) | 31 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/notify/fsnotify.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/notify/fsnotify.h?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/notify/mark.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/notify/mark.c?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e) | 32 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/fsnotify\_backend.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/fsnotify_backend.h?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e) | 8 | |  |  |  | | --- | --- | --- | |

4 files changed, 56 insertions, 17 deletions

| diff --git a/fs/notify/fsnotify.c b/fs/notify/fsnotify.cindex 7974e91ffe134f..b5d8f238fce42a 100644--- a/[fs/notify/fsnotify.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/fsnotify.c?id=b4243c05d7e3db0bdbf9124e6fa59b4ca7c807ae)+++ b/[fs/notify/fsnotify.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/fsnotify.c?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e)@@ -103,17 +103,13 @@ void fsnotify\_sb\_delete(struct super\_block \*sb) \* parent cares. Thus when an event happens on a child it can quickly tell \* if there is a need to find a parent and send the event to the parent. \*/-void \_\_fsnotify\_update\_child\_dentry\_flags(struct inode \*inode)+void fsnotify\_set\_children\_dentry\_flags(struct inode \*inode) { struct dentry \*alias;- int watched;  if (!S\_ISDIR(inode->i\_mode)) return; - /\* determine if the children should tell inode about their events \*/- watched = fsnotify\_inode\_watches\_children(inode);- spin\_lock(&inode->i\_lock); /\* run all of the dentries associated with this inode. Since this is a \* directory, there damn well better only be one item on this list \*/@@ -129,10 +125,7 @@ void \_\_fsnotify\_update\_child\_dentry\_flags(struct inode \*inode) continue;  spin\_lock\_nested(&child->d\_lock, DENTRY\_D\_LOCK\_NESTED);- if (watched)- child->d\_flags |= DCACHE\_FSNOTIFY\_PARENT\_WATCHED;- else- child->d\_flags &= ~DCACHE\_FSNOTIFY\_PARENT\_WATCHED;+ child->d\_flags |= DCACHE\_FSNOTIFY\_PARENT\_WATCHED; spin\_unlock(&child->d\_lock); } spin\_unlock(&alias->d\_lock);@@ -140,6 +133,24 @@ void \_\_fsnotify\_update\_child\_dentry\_flags(struct inode \*inode) spin\_unlock(&inode->i\_lock); } +/\*+ \* Lazily clear false positive PARENT\_WATCHED flag for child whose parent had+ \* stopped watching children.+ \*/+static void fsnotify\_clear\_child\_dentry\_flag(struct inode \*pinode,+ struct dentry \*dentry)+{+ spin\_lock(&dentry->d\_lock);+ /\*+ \* d\_lock is a sufficient barrier to prevent observing a non-watched+ \* parent state from before the fsnotify\_set\_children\_dentry\_flags()+ \* or fsnotify\_update\_flags() call that had set PARENT\_WATCHED.+ \*/+ if (!fsnotify\_inode\_watches\_children(pinode))+ dentry->d\_flags &= ~DCACHE\_FSNOTIFY\_PARENT\_WATCHED;+ spin\_unlock(&dentry->d\_lock);+}+ /\* Are inode/sb/mount interested in parent and name info with this event? \*/ static bool fsnotify\_event\_needs\_parent(struct inode \*inode, struct mount \*mnt, \_\_u32 mask)@@ -208,7 +219,7 @@ int \_\_fsnotify\_parent(struct dentry \*dentry, \_\_u32 mask, const void \*data, p\_inode = parent->d\_inode; p\_mask = fsnotify\_inode\_watches\_children(p\_inode); if (unlikely(parent\_watched && !p\_mask))- \_\_fsnotify\_update\_child\_dentry\_flags(p\_inode);+ fsnotify\_clear\_child\_dentry\_flag(p\_inode, dentry);  /\* \* Include parent/name in notification either if some notificationdiff --git a/fs/notify/fsnotify.h b/fs/notify/fsnotify.hindex fde74eb333cc93..2b4267de86e6b2 100644--- a/[fs/notify/fsnotify.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/fsnotify.h?id=b4243c05d7e3db0bdbf9124e6fa59b4ca7c807ae)+++ b/[fs/notify/fsnotify.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/fsnotify.h?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e)@@ -74,7 +74,7 @@ static inline void fsnotify\_clear\_marks\_by\_sb(struct super\_block \*sb) \* update the dentry->d\_flags of all of inode's children to indicate if inode cares \* about events that happen to its children. \*/-extern void \_\_fsnotify\_update\_child\_dentry\_flags(struct inode \*inode);+extern void fsnotify\_set\_children\_dentry\_flags(struct inode \*inode);  extern struct kmem\_cache \*fsnotify\_mark\_connector\_cachep; diff --git a/fs/notify/mark.c b/fs/notify/mark.cindex c74ef947447d67..4be6e883d492f6 100644--- a/[fs/notify/mark.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/mark.c?id=b4243c05d7e3db0bdbf9124e6fa59b4ca7c807ae)+++ b/[fs/notify/mark.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/notify/mark.c?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e)@@ -176,6 +176,24 @@ static void \*\_\_fsnotify\_recalc\_mask(struct fsnotify\_mark\_connector \*conn) return fsnotify\_update\_iref(conn, want\_iref); } +static bool fsnotify\_conn\_watches\_children(+ struct fsnotify\_mark\_connector \*conn)+{+ if (conn->type != FSNOTIFY\_OBJ\_TYPE\_INODE)+ return false;++ return fsnotify\_inode\_watches\_children(fsnotify\_conn\_inode(conn));+}++static void fsnotify\_conn\_set\_children\_dentry\_flags(+ struct fsnotify\_mark\_connector \*conn)+{+ if (conn->type != FSNOTIFY\_OBJ\_TYPE\_INODE)+ return;++ fsnotify\_set\_children\_dentry\_flags(fsnotify\_conn\_inode(conn));+}+ /\* \* Calculate mask of events for a list of marks. The caller must make sure \* connector and connector->obj cannot disappear under us. Callers achieve@@ -184,15 +202,23 @@ static void \*\_\_fsnotify\_recalc\_mask(struct fsnotify\_mark\_connector \*conn) \*/ void fsnotify\_recalc\_mask(struct fsnotify\_mark\_connector \*conn) {+ bool update\_children;+ if (!conn) return;  spin\_lock(&conn->lock);+ update\_children = !fsnotify\_conn\_watches\_children(conn); \_\_fsnotify\_recalc\_mask(conn);+ update\_children &= fsnotify\_conn\_watches\_children(conn); spin\_unlock(&conn->lock);- if (conn->type == FSNOTIFY\_OBJ\_TYPE\_INODE)- \_\_fsnotify\_update\_child\_dentry\_flags(- fsnotify\_conn\_inode(conn));+ /\*+ \* Set children's PARENT\_WATCHED flags only if parent started watching.+ \* When parent stops watching, we clear false positive PARENT\_WATCHED+ \* flags lazily in \_\_fsnotify\_parent().+ \*/+ if (update\_children)+ fsnotify\_conn\_set\_children\_dentry\_flags(conn); }  /\* Free all connectors queued for freeing once SRCU period ends \*/diff --git a/include/linux/fsnotify\_backend.h b/include/linux/fsnotify\_backend.hindex d7d96c806bff2b..096b79e4373f4c 100644--- a/[include/linux/fsnotify\_backend.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fsnotify_backend.h?id=b4243c05d7e3db0bdbf9124e6fa59b4ca7c807ae)+++ b/[include/linux/fsnotify\_backend.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fsnotify_backend.h?id=d8c42405fc3507cc43ba7e4986a773c3fc633f6e)@@ -563,12 +563,14 @@ static inline \_\_u32 fsnotify\_parent\_needed\_mask(\_\_u32 mask)  static inline int fsnotify\_inode\_watches\_children(struct inode \*inode) {+ \_\_u32 parent\_mask = READ\_ONCE(inode->i\_fsnotify\_mask);+ /\* FS\_EVENT\_ON\_CHILD is set if the inode may care \*/- if (!(inode->i\_fsnotify\_mask & FS\_EVENT\_ON\_CHILD))+ if (!(parent\_mask & FS\_EVENT\_ON\_CHILD)) return 0; /\* this inode might care about child events, does it care about the \* specific set of events that can happen on a child? \*/- return inode->i\_fsnotify\_mask & FS\_EVENTS\_POSS\_ON\_CHILD;+ return parent\_mask & FS\_EVENTS\_POSS\_ON\_CHILD; }  /\*@@ -582,7 +584,7 @@ static inline void fsnotify\_update\_flags(struct dentry \*dentry) /\* \* Serialisation of setting PARENT\_WATCHED on the dentries is provided \* by d\_lock. If inotify\_inode\_watched changes after we have taken- \* d\_lock, the following \_\_fsnotify\_update\_child\_dentry\_flags call will+ \* d\_lock, the following fsnotify\_set\_children\_dentry\_flags call will \* find our entry, so it will spin until we complete here, and update \* us with the new state. \*/ |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 06:35:44 +0000

