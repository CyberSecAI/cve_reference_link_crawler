
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FAcademySoftwareFoundation%2FOpenImageIO%2Fblob%2F7c486a1121a4bf71d50ff555fab2770294b748d7%2Fsrc%2Fheif.imageio%2Fheifinput.cpp)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FAcademySoftwareFoundation%2FOpenImageIO%2Fblob%2F7c486a1121a4bf71d50ff555fab2770294b748d7%2Fsrc%2Fheif.imageio%2Fheifinput.cpp)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=AcademySoftwareFoundation%2FOpenImageIO)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[AcademySoftwareFoundation](/AcademySoftwareFoundation)
/
**[OpenImageIO](/AcademySoftwareFoundation/OpenImageIO)**
Public

* [Notifications](/login?return_to=%2FAcademySoftwareFoundation%2FOpenImageIO) You must be signed in to change notification settings
* [Fork
  606](/login?return_to=%2FAcademySoftwareFoundation%2FOpenImageIO)
* [Star
   2k](/login?return_to=%2FAcademySoftwareFoundation%2FOpenImageIO)

* [Code](/AcademySoftwareFoundation/OpenImageIO)
* [Issues
  124](/AcademySoftwareFoundation/OpenImageIO/issues)
* [Pull requests
  20](/AcademySoftwareFoundation/OpenImageIO/pulls)
* [Discussions](/AcademySoftwareFoundation/OpenImageIO/discussions)
* [Actions](/AcademySoftwareFoundation/OpenImageIO/actions)
* [Projects
  1](/AcademySoftwareFoundation/OpenImageIO/projects)
* [Wiki](/AcademySoftwareFoundation/OpenImageIO/wiki)
* [Security](/AcademySoftwareFoundation/OpenImageIO/security)
* [Insights](/AcademySoftwareFoundation/OpenImageIO/pulse)

Additional navigation options

* [Code](/AcademySoftwareFoundation/OpenImageIO)
* [Issues](/AcademySoftwareFoundation/OpenImageIO/issues)
* [Pull requests](/AcademySoftwareFoundation/OpenImageIO/pulls)
* [Discussions](/AcademySoftwareFoundation/OpenImageIO/discussions)
* [Actions](/AcademySoftwareFoundation/OpenImageIO/actions)
* [Projects](/AcademySoftwareFoundation/OpenImageIO/projects)
* [Wiki](/AcademySoftwareFoundation/OpenImageIO/wiki)
* [Security](/AcademySoftwareFoundation/OpenImageIO/security)
* [Insights](/AcademySoftwareFoundation/OpenImageIO/pulse)

## Files

 7c486a1
## Breadcrumbs

1. [OpenImageIO](/AcademySoftwareFoundation/OpenImageIO/tree/7c486a1121a4bf71d50ff555fab2770294b748d7)
2. /[src](/AcademySoftwareFoundation/OpenImageIO/tree/7c486a1121a4bf71d50ff555fab2770294b748d7/src)
3. /[heif.imageio](/AcademySoftwareFoundation/OpenImageIO/tree/7c486a1121a4bf71d50ff555fab2770294b748d7/src/heif.imageio)
/
# heifinput.cpp

Copy path Blame  Blame
## Latest commit

## History

[History](/AcademySoftwareFoundation/OpenImageIO/commits/7c486a1121a4bf71d50ff555fab2770294b748d7/src/heif.imageio/heifinput.cpp)434 lines (373 loc) · 15.2 KB 7c486a1
## Breadcrumbs

1. [OpenImageIO](/AcademySoftwareFoundation/OpenImageIO/tree/7c486a1121a4bf71d50ff555fab2770294b748d7)
2. /[src](/AcademySoftwareFoundation/OpenImageIO/tree/7c486a1121a4bf71d50ff555fab2770294b748d7/src)
3. /[heif.imageio](/AcademySoftwareFoundation/OpenImageIO/tree/7c486a1121a4bf71d50ff555fab2770294b748d7/src/heif.imageio)
/
# heifinput.cpp

Top
## File metadata and controls

* Code
* Blame

434 lines (373 loc) · 15.2 KB[Raw](https://github.com/AcademySoftwareFoundation/OpenImageIO/raw/7c486a1121a4bf71d50ff555fab2770294b748d7/src/heif.imageio/heifinput.cpp)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434// Copyright Contributors to the OpenImageIO project.// SPDX-License-Identifier: Apache-2.0// https://github.com/AcademySoftwareFoundation/OpenImageIO
#include <OpenImageIO/filesystem.h>#include <OpenImageIO/imageio.h>#include <OpenImageIO/tiffutils.h>
#include <libheif/heif\_cxx.h>
#define MAKE\_LIBHEIF\_VERSION(a, b, c, d) \ (((a) << 24) | ((b) << 16) | ((c) << 8) | (d))
#if LIBHEIF\_NUMERIC\_VERSION >= MAKE\_LIBHEIF\_VERSION(1, 17, 0, 0)# include <libheif/heif\_properties.h>#endif
// This plugin utilises libheif:// https://github.com/strukturag/libheif//// General information about HEIF/HEIC/AVIF://// Sources of sample images:// https://github.com/nokiatech/heif/tree/gh-pages/content
OIIO\_PLUGIN\_NAMESPACE\_BEGIN
class HeifInput final : public ImageInput {public: HeifInput() {} ~HeifInput() override { close(); } const char\* format\_name(void) const override { return "heif"; } int supports(string\_view feature) const override { return feature == "exif"; }#if LIBHEIF\_HAVE\_VERSION(1, 4, 0) bool valid\_file(const std::string& filename) const override;#endif bool open(const std::string& name, ImageSpec& newspec) override; bool open(const std::string& name, ImageSpec& newspec, const ImageSpec& config) override; bool close() override; bool seek\_subimage(int subimage, int miplevel) override; bool read\_native\_scanline(int subimage, int miplevel, int y, int z, void\* data) override; bool read\_scanline(int y, int z, TypeDesc format, void\* data, stride\_t xstride) override;
private: std::string m\_filename; int m\_subimage = -1; int m\_num\_subimages = 0; int m\_has\_alpha = false; bool m\_associated\_alpha = true; bool m\_keep\_unassociated\_alpha = false; bool m\_do\_associate = false; bool m\_reorient = true; std::unique\_ptr<heif::Context> m\_ctx; heif\_item\_id m\_primary\_id; // id of primary image std::vector<heif\_item\_id> m\_item\_ids; // ids of all other images heif::ImageHandle m\_ihandle; heif::Image m\_himage;};
voidoiio\_heif\_init(){#if LIBHEIF\_HAVE\_VERSION(1, 16, 0) static std::once\_flag flag; std::call\_once(flag, []() { heif\_init(nullptr); });#endif}
// Export version number and create function symbolsOIIO\_PLUGIN\_EXPORTS\_BEGIN
OIIO\_EXPORT int heif\_imageio\_version = OIIO\_PLUGIN\_VERSION;
OIIO\_EXPORT const char\*heif\_imageio\_library\_version(){ return "libheif " LIBHEIF\_VERSION;}
OIIO\_EXPORT ImageInput\*heif\_input\_imageio\_create(){ oiio\_heif\_init(); return new HeifInput;}
OIIO\_EXPORT const char\* heif\_input\_extensions[] = { "heic", "heif", "heics", "hif",#if LIBHEIF\_HAVE\_VERSION(1, 7, 0) "avif",#endif nullptr };
OIIO\_PLUGIN\_EXPORTS\_END
#if LIBHEIF\_HAVE\_VERSION(1, 4, 0)boolHeifInput::valid\_file(const std::string& filename) const{ uint8\_t magic[12]; if (Filesystem::read\_bytes(filename, magic, sizeof(magic)) != sizeof(magic)) return false; heif\_filetype\_result filetype\_check = heif\_check\_filetype(magic, sizeof(magic)); return filetype\_check != heif\_filetype\_no && filetype\_check != heif\_filetype\_yes\_unsupported;}#endif
boolHeifInput::open(const std::string& name, ImageSpec& newspec){ // If user doesn't want to provide any config, just use an empty spec. ImageSpec config; return open(name, newspec, config);}
boolHeifInput::open(const std::string& name, ImageSpec& newspec, const ImageSpec& config){ m\_filename = name; m\_subimage = -1;
 m\_ctx.reset(new heif::Context); m\_himage = heif::Image(); m\_ihandle = heif::ImageHandle();
 m\_keep\_unassociated\_alpha = (config.get\_int\_attribute("oiio:UnassociatedAlpha") != 0); m\_reorient = config.get\_int\_attribute("oiio:reorient", 1);
 try { m\_ctx->read\_from\_file(name); // FIXME: should someday be read\_from\_reader to give full flexibility
 m\_item\_ids = m\_ctx->get\_list\_of\_top\_level\_image\_IDs(); m\_primary\_id = m\_ctx->get\_primary\_image\_ID(); for (size\_t i = 0; i < m\_item\_ids.size(); ++i) if (m\_item\_ids[i] == m\_primary\_id) { m\_item\_ids.erase(m\_item\_ids.begin() + i); break; } // std::cout << " primary id: " << m\_primary\_id << "\n"; // std::cout << " item ids: " << Strutil::join(m\_item\_ids, ", ") << "\n"; m\_num\_subimages = 1 + int(m\_item\_ids.size());
 } catch (const heif::Error& err) { std::string e = err.get\_message(); errorfmt("{}", e.empty() ? "unknown exception" : e.c\_str()); return false; } catch (const std::exception& err) { std::string e = err.what(); errorfmt("{}", e.empty() ? "unknown exception" : e.c\_str()); return false; }
 bool ok = seek\_subimage(0, 0); newspec = spec(); return ok;}
boolHeifInput::close(){ m\_himage = heif::Image(); m\_ihandle = heif::ImageHandle(); m\_ctx.reset(); m\_subimage = -1; m\_num\_subimages = 0; m\_associated\_alpha = true; m\_keep\_unassociated\_alpha = false; m\_do\_associate = false; return true;}
boolHeifInput::seek\_subimage(int subimage, int miplevel){ if (miplevel != 0) return false;
 if (subimage == m\_subimage) { return true; // already there }
 if (subimage >= m\_num\_subimages) { return false; }
 auto id = (subimage == 0) ? m\_primary\_id : m\_item\_ids[subimage - 1]; m\_ihandle = m\_ctx->get\_image\_handle(id); m\_has\_alpha = m\_ihandle.has\_alpha\_channel(); auto chroma = m\_has\_alpha ? heif\_chroma\_interleaved\_RGBA : heif\_chroma\_interleaved\_RGB;#if 0 try { m\_himage = m\_ihandle.decode\_image(heif\_colorspace\_RGB, chroma); } catch (const heif::Error& err) { std::string e = err.get\_message(); errorfmt("{}", e.empty() ? "unknown exception" : e.c\_str()); return false; } catch (const std::exception& err) { std::string e = err.what(); errorfmt("{}", e.empty() ? "unknown exception" : e.c\_str()); return false; }#else std::unique\_ptr<heif\_decoding\_options, void (\*)(heif\_decoding\_options\*)> options(heif\_decoding\_options\_alloc(), heif\_decoding\_options\_free); options->ignore\_transformations = !m\_reorient; // print("Got decoding options version {}\n", options->version); struct heif\_image\* img\_tmp = nullptr; struct heif\_error herr = heif\_decode\_image(m\_ihandle.get\_raw\_image\_handle(), &img\_tmp, heif\_colorspace\_RGB, chroma, options.get()); if (img\_tmp) m\_himage = heif::Image(img\_tmp); if (herr.code != heif\_error\_Ok || !img\_tmp) { errorfmt("Could not decode image ({})", herr.message); m\_ctx.reset(); return false; }#endif
 int bits = m\_himage.get\_bits\_per\_pixel(heif\_channel\_interleaved); m\_spec = ImageSpec(m\_ihandle.get\_width(), m\_ihandle.get\_height(), bits / 8, TypeUInt8);
 m\_spec.attribute("oiio:ColorSpace", "sRGB");
#if LIBHEIF\_HAVE\_VERSION(1, 12, 0) // Libheif >= 1.12 added API call to find out if the image is associated // alpha (i.e. colors are premultiplied). m\_associated\_alpha = m\_himage.is\_premultiplied\_alpha(); m\_do\_associate = (!m\_associated\_alpha && m\_spec.alpha\_channel >= 0 && !m\_keep\_unassociated\_alpha); if (!m\_associated\_alpha && m\_spec.nchannels >= 4) { // Indicate that file stored unassociated alpha data m\_spec.attribute("heif:UnassociatedAlpha", 1); // If we don't have 4 chans, we need not consider m\_keep\_unassociated\_alpha &= (m\_spec.nchannels >= 4); if (m\_keep\_unassociated\_alpha) { // Indicate that we are returning unassociated data if the file // had associated and we were asked to keep it that way. m\_spec.attribute("oiio:UnassociatedAlpha", 1); } }#else m\_associated\_alpha = true; // assume/hope#endif
 auto meta\_ids = m\_ihandle.get\_list\_of\_metadata\_block\_IDs(); // std::cout << "nmeta? " << meta\_ids.size() << "\n"; for (auto m : meta\_ids) { std::vector<uint8\_t> metacontents; try { metacontents = m\_ihandle.get\_metadata(m); } catch (const heif::Error& err) { if (err.get\_code() == heif\_error\_Usage\_error && err.get\_subcode() == heif\_suberror\_Null\_pointer\_argument) { // a bug in heif\_cxx.h means a 0 byte metadata causes a null // ptr error code, which we ignore continue; } } if (Strutil::iequals(m\_ihandle.get\_metadata\_type(m), "Exif") && metacontents.size() >= 10) { cspan<uint8\_t> s(&metacontents[10], metacontents.size() - 10); decode\_exif(s, m\_spec); } else if (0 // For now, skip this, I haven't seen anything useful && Strutil::iequals(m\_ihandle.get\_metadata\_type(m), "mime") && Strutil::iequals(m\_ihandle.get\_metadata\_content\_type(m), "application/rdf+xml")) { decode\_xmp(metacontents, m\_spec); } else {#ifdef DEBUG print( "Don't know how to decode meta {} type='{}' contenttype='{}'\n", m, m\_ihandle.get\_metadata\_type(m), m\_ihandle.get\_metadata\_content\_type(m)); print("---\n{}\n---\n", string\_view((const char\*)metacontents.data(), metacontents.size()));#endif } }
#if LIBHEIF\_NUMERIC\_VERSION >= MAKE\_LIBHEIF\_VERSION(1, 16, 0, 0) // Try to discover the orientation. The Exif is unreliable. We have to go // through the transformation properties ourselves. A tricky bit is that // the C++ API doesn't give us a direct way to get the context ptr, we // need to resort to some casting trickery, with knowledge that the C++ // heif::Context class consists solely of a std::shared\_ptr to a // heif\_context. // NO int orientation = m\_spec.get\_int\_attribute("Orientation", 1); int orientation = 1; const heif\_context\* raw\_ctx = reinterpret\_cast<std::shared\_ptr<heif\_context>\*>(m\_ctx.get())->get(); int xpcount = heif\_item\_get\_transformation\_properties(raw\_ctx, id, nullptr, 100); xpcount = std::min(xpcount, 100); // clamp to some reasonable limit std::vector<heif\_property\_id> xprops(xpcount); heif\_item\_get\_transformation\_properties(raw\_ctx, id, xprops.data(), xpcount); for (int i = 0; i < xpcount; ++i) { auto type = heif\_item\_get\_property\_type(raw\_ctx, id, xprops[i]); if (type == heif\_item\_property\_type\_transform\_rotation) { int rot = heif\_item\_get\_property\_transform\_rotation\_ccw(raw\_ctx, id, xprops[i]); // cw[] maps to one additional clockwise 90 degree turn static const int cw[] = { 0, 6, 7, 8, 5, 2, 3, 4, 1 }; for (int i = 0; i < rot / 90; ++i) orientation = cw[orientation]; } else if (type == heif\_item\_property\_type\_transform\_mirror) { int mirror = heif\_item\_get\_property\_transform\_mirror(raw\_ctx, id, xprops[i]); // 1 2 3 4 5 6 7 8 static const int mirrorh[] = { 0, 2, 1, 4, 3, 6, 5, 8, 7 }; static const int mirrorv[] = { 0, 4, 3, 2, 1, 8, 7, 6, 5 }; if (mirror == heif\_transform\_mirror\_direction\_vertical) { orientation = mirrorv[orientation]; } else if (mirror == heif\_transform\_mirror\_direction\_horizontal) { orientation = mirrorh[orientation]; } } }#else // Prior to libheif 1.16, the get\_transformation\_properties API was not // available, so we have to rely on the Exif orientation tag. int orientation = m\_spec.get\_int\_attribute("Orientation", 1);#endif
 // Erase the orientation metadata because libheif appears to be doing // the rotation-to-canonical-direction for us. if (orientation != 1) { if (m\_reorient) { // If libheif auto-reoriented, record the original orientation in // "oiio:OriginalOrientation" and set the "Orientation" attribute // to 1 since we're presenting the image to the caller in the // usual orientation. m\_spec.attribute("oiio:OriginalOrientation", orientation); m\_spec.attribute("Orientation", 1); } else { // libheif supplies oriented width & height, so if we are NOT // auto-reorienting and it's one of the orientations that swaps // width and height, we need to do that swap ourselves. // Note: all the orientations that swap width and height are 5-8, // whereas 1-4 preserve aspect ratio. if (orientation >= 5) { std::swap(m\_spec.width, m\_spec.height); std::swap(m\_spec.full\_width, m\_spec.full\_height); } } }
 m\_subimage = subimage; return true;}
boolHeifInput::read\_native\_scanline(int subimage, int miplevel, int y, int /\*z\*/, void\* data){ lock\_guard lock(\*this); if (!seek\_subimage(subimage, miplevel)) return false; if (y < 0 || y >= m\_spec.height) // out of range scanline return false;
 int ystride = 0; const uint8\_t\* hdata = m\_himage.get\_plane(heif\_channel\_interleaved, &ystride); if (!hdata) { errorfmt("Unknown read error"); return false; } hdata += (y - m\_spec.y) \* ystride; memcpy(data, hdata, m\_spec.width \* m\_spec.pixel\_bytes()); return true;}
boolHeifInput::read\_scanline(int y, int z, TypeDesc format, void\* data, stride\_t xstride){ bool ok = ImageInput::read\_scanline(y, z, format, data, xstride); if (ok && m\_do\_associate) { // If alpha is unassociated and we aren't requested to keep it that // way, multiply the colors by alpha per the usual OIIO conventions // to deliver associated color & alpha. Any auto-premultiplication // by alpha should happen after we've already done data format // conversions. That's why we do it here, rather than in // read\_native\_blah. { lock\_guard lock(\*this); if (format == TypeUnknown) // unknown -> retrieve native type format = m\_spec.format; } OIIO::premult(m\_spec.nchannels, m\_spec.width, 1, 1, 0 /\*chbegin\*/, m\_spec.nchannels /\*chend\*/, format, data, xstride, AutoStride, AutoStride, m\_spec.alpha\_channel); } return ok;}
OIIO\_PLUGIN\_NAMESPACE\_END

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

