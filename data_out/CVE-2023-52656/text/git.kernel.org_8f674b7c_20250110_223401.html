

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jens Axboe <axboe@kernel.dk> | 2024-03-13 18:15:05 -0600 |
| --- | --- | --- |
| committer | Sasha Levin <sashal@kernel.org> | 2024-03-26 18:20:22 -0400 |
| commit | [a3812a47a32022ca76bf46ddacdd823dc2aabf8b](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b)) | |
| tree | [b7ebee07de035b1ac9934fd96d01e77dff43e444](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b) | |
| parent | [28fe81bcd3ea932e280f04e087ff0c75a4995a46](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=28fe81bcd3ea932e280f04e087ff0c75a4995a46) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b&id2=28fe81bcd3ea932e280f04e087ff0c75a4995a46)) | |
| download | [linux-a3812a47a32022ca76bf46ddacdd823dc2aabf8b.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-a3812a47a32022ca76bf46ddacdd823dc2aabf8b.tar.gz) | |

io\_uring: drop any code related to SCM\_RIGHTSCommit 6e5e6d274956305f1fc0340522b38f5f5be74bdb upstream.
This is dead code after we dropped support for passing io\_uring fds
over SCM\_RIGHTS, get rid of it.
Signed-off-by: Jens Axboe <axboe@kernel.dk>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b)

| -rw-r--r-- | [include/linux/io\_uring\_types.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/io_uring_types.h?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b) | 3 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [io\_uring/filetable.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/io_uring/filetable.c?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b) | 10 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [io\_uring/io\_uring.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/io_uring/io_uring.c?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b) | 31 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [io\_uring/rsrc.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/io_uring/rsrc.c?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b) | 151 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [io\_uring/rsrc.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/io_uring/rsrc.h?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b) | 15 | |  |  |  | | --- | --- | --- | |

5 files changed, 8 insertions, 202 deletions

| diff --git a/include/linux/io\_uring\_types.h b/include/linux/io\_uring\_types.hindex f5b687a787a34d..37aeea266ebb32 100644--- a/[include/linux/io\_uring\_types.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/io_uring_types.h?id=28fe81bcd3ea932e280f04e087ff0c75a4995a46)+++ b/[include/linux/io\_uring\_types.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/io_uring_types.h?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b)@@ -330,9 +330,6 @@ struct io\_ring\_ctx {  struct list\_head io\_buffers\_pages; - #if defined(CONFIG\_UNIX)- struct socket \*ring\_sock;- #endif /\* hashed buffered write serialization \*/ struct io\_wq\_hash \*hash\_map; diff --git a/io\_uring/filetable.c b/io\_uring/filetable.cindex b80614e7d60511..4660cb89ea9f52 100644--- a/[io\_uring/filetable.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/filetable.c?id=28fe81bcd3ea932e280f04e087ff0c75a4995a46)+++ b/[io\_uring/filetable.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/filetable.c?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b)@@ -95,12 +95,10 @@ static int io\_install\_fixed\_file(struct io\_ring\_ctx \*ctx, struct file \*file, needs\_switch = true; } - ret = io\_scm\_file\_account(ctx, file);- if (!ret) {- \*io\_get\_tag\_slot(ctx->file\_data, slot\_index) = 0;- io\_fixed\_file\_set(file\_slot, file);- io\_file\_bitmap\_set(&ctx->file\_table, slot\_index);- }+ \*io\_get\_tag\_slot(ctx->file\_data, slot\_index) = 0;+ io\_fixed\_file\_set(file\_slot, file);+ io\_file\_bitmap\_set(&ctx->file\_table, slot\_index);+ return 0; err: if (needs\_switch) io\_rsrc\_node\_switch(ctx, ctx->file\_data);diff --git a/io\_uring/io\_uring.c b/io\_uring/io\_uring.cindex cf7dd62da0e371..415248c1f82c6f 100644--- a/[io\_uring/io\_uring.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/io_uring.c?id=28fe81bcd3ea932e280f04e087ff0c75a4995a46)+++ b/[io\_uring/io\_uring.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/io_uring.c?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b)@@ -60,7 +60,6 @@ #include <linux/net.h> #include <net/sock.h> #include <net/af\_unix.h>-#include <net/scm.h> #include <linux/anon\_inodes.h> #include <linux/sched/mm.h> #include <linux/uaccess.h>@@ -2628,12 +2627,6 @@ static \_\_cold void io\_ring\_ctx\_free(struct io\_ring\_ctx \*ctx) WARN\_ON\_ONCE(!list\_empty(&ctx->rsrc\_ref\_list)); WARN\_ON\_ONCE(!llist\_empty(&ctx->rsrc\_put\_llist)); -#if defined(CONFIG\_UNIX)- if (ctx->ring\_sock) {- ctx->ring\_sock->file = NULL; /\* so that iput() is called \*/- sock\_release(ctx->ring\_sock);- }-#endif WARN\_ON\_ONCE(!list\_empty(&ctx->ltimeout\_list));  if (ctx->mm\_account) {@@ -3438,32 +3431,12 @@ static int io\_uring\_install\_fd(struct io\_ring\_ctx \*ctx, struct file \*file) /\* \* Allocate an anonymous fd, this is what constitutes the application \* visible backing of an io\_uring instance. The application mmaps this- \* fd to gain access to the SQ/CQ ring details. If UNIX sockets are enabled,- \* we have to tie this fd to a socket for file garbage collection purposes.+ \* fd to gain access to the SQ/CQ ring details. \*/ static struct file \*io\_uring\_get\_file(struct io\_ring\_ctx \*ctx) {- struct file \*file;-#if defined(CONFIG\_UNIX)- int ret;-- ret = sock\_create\_kern(&init\_net, PF\_UNIX, SOCK\_RAW, IPPROTO\_IP,- &ctx->ring\_sock);- if (ret)- return ERR\_PTR(ret);-#endif-- file = anon\_inode\_getfile\_secure("[io\_uring]", &io\_uring\_fops, ctx,+ return anon\_inode\_getfile\_secure("[io\_uring]", &io\_uring\_fops, ctx, O\_RDWR | O\_CLOEXEC, NULL);-#if defined(CONFIG\_UNIX)- if (IS\_ERR(file)) {- sock\_release(ctx->ring\_sock);- ctx->ring\_sock = NULL;- } else {- ctx->ring\_sock->file = file;- }-#endif- return file; }  static \_\_cold int io\_uring\_create(unsigned entries, struct io\_uring\_params \*p,diff --git a/io\_uring/rsrc.c b/io\_uring/rsrc.cindex 7ada0339b38705..ac658cfa89c63c 100644--- a/[io\_uring/rsrc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/rsrc.c?id=28fe81bcd3ea932e280f04e087ff0c75a4995a46)+++ b/[io\_uring/rsrc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/rsrc.c?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b)@@ -494,11 +494,6 @@ static int \_\_io\_sqe\_files\_update(struct io\_ring\_ctx \*ctx, err = -EBADF; break; }- err = io\_scm\_file\_account(ctx, file);- if (err) {- fput(file);- break;- } \*io\_get\_tag\_slot(data, i) = tag; io\_fixed\_file\_set(file\_slot, file); io\_file\_bitmap\_set(&ctx->file\_table, i);@@ -762,22 +757,12 @@ void \_\_io\_sqe\_files\_unregister(struct io\_ring\_ctx \*ctx) for (i = 0; i < ctx->nr\_user\_files; i++) { struct file \*file = io\_file\_from\_index(&ctx->file\_table, i); - /\* skip scm accounted files, they'll be freed by ->ring\_sock \*/- if (!file || io\_file\_need\_scm(file))+ if (!file) continue; io\_file\_bitmap\_clear(&ctx->file\_table, i); fput(file); } -#if defined(CONFIG\_UNIX)- if (ctx->ring\_sock) {- struct sock \*sock = ctx->ring\_sock->sk;- struct sk\_buff \*skb;-- while ((skb = skb\_dequeue(&sock->sk\_receive\_queue)) != NULL)- kfree\_skb(skb);- }-#endif io\_free\_file\_tables(&ctx->file\_table); io\_file\_table\_set\_alloc\_range(ctx, 0, 0); io\_rsrc\_data\_free(ctx->file\_data);@@ -805,134 +790,11 @@ int io\_sqe\_files\_unregister(struct io\_ring\_ctx \*ctx) return ret; } -/\*- \* Ensure the UNIX gc is aware of our file set, so we are certain that- \* the io\_uring can be safely unregistered on process exit, even if we have- \* loops in the file referencing. We account only files that can hold other- \* files because otherwise they can't form a loop and so are not interesting- \* for GC.- \*/-int \_\_io\_scm\_file\_account(struct io\_ring\_ctx \*ctx, struct file \*file)-{-#if defined(CONFIG\_UNIX)- struct sock \*sk = ctx->ring\_sock->sk;- struct sk\_buff\_head \*head = &sk->sk\_receive\_queue;- struct scm\_fp\_list \*fpl;- struct sk\_buff \*skb;-- if (likely(!io\_file\_need\_scm(file)))- return 0;-- /\*- \* See if we can merge this file into an existing skb SCM\_RIGHTS- \* file set. If there's no room, fall back to allocating a new skb- \* and filling it in.- \*/- spin\_lock\_irq(&head->lock);- skb = skb\_peek(head);- if (skb && UNIXCB(skb).fp->count < SCM\_MAX\_FD)- \_\_skb\_unlink(skb, head);- else- skb = NULL;- spin\_unlock\_irq(&head->lock);-- if (!skb) {- fpl = kzalloc(sizeof(\*fpl), GFP\_KERNEL);- if (!fpl)- return -ENOMEM;-- skb = alloc\_skb(0, GFP\_KERNEL);- if (!skb) {- kfree(fpl);- return -ENOMEM;- }-- fpl->user = get\_uid(current\_user());- fpl->max = SCM\_MAX\_FD;- fpl->count = 0;-- UNIXCB(skb).fp = fpl;- skb->sk = sk;- skb->scm\_io\_uring = 1;- skb->destructor = unix\_destruct\_scm;- refcount\_add(skb->truesize, &sk->sk\_wmem\_alloc);- }-- fpl = UNIXCB(skb).fp;- fpl->fp[fpl->count++] = get\_file(file);- unix\_inflight(fpl->user, file);- skb\_queue\_head(head, skb);- fput(file);-#endif- return 0;-}- static void io\_rsrc\_file\_put(struct io\_ring\_ctx \*ctx, struct io\_rsrc\_put \*prsrc) { struct file \*file = prsrc->file;-#if defined(CONFIG\_UNIX)- struct sock \*sock = ctx->ring\_sock->sk;- struct sk\_buff\_head list, \*head = &sock->sk\_receive\_queue;- struct sk\_buff \*skb;- int i;-- if (!io\_file\_need\_scm(file)) {- fput(file);- return;- }-- \_\_skb\_queue\_head\_init(&list);-- /\*- \* Find the skb that holds this file in its SCM\_RIGHTS. When found,- \* remove this entry and rearrange the file array.- \*/- skb = skb\_dequeue(head);- while (skb) {- struct scm\_fp\_list \*fp; - fp = UNIXCB(skb).fp;- for (i = 0; i < fp->count; i++) {- int left;-- if (fp->fp[i] != file)- continue;-- unix\_notinflight(fp->user, fp->fp[i]);- left = fp->count - 1 - i;- if (left) {- memmove(&fp->fp[i], &fp->fp[i + 1],- left \* sizeof(struct file \*));- }- fp->count--;- if (!fp->count) {- kfree\_skb(skb);- skb = NULL;- } else {- \_\_skb\_queue\_tail(&list, skb);- }- fput(file);- file = NULL;- break;- }-- if (!file)- break;-- \_\_skb\_queue\_tail(&list, skb);-- skb = skb\_dequeue(head);- }-- if (skb\_peek(&list)) {- spin\_lock\_irq(&head->lock);- while ((skb = \_\_skb\_dequeue(&list)) != NULL)- \_\_skb\_queue\_tail(head, skb);- spin\_unlock\_irq(&head->lock);- }-#else fput(file);-#endif }  int io\_sqe\_files\_register(struct io\_ring\_ctx \*ctx, void \_\_user \*arg,@@ -986,21 +848,12 @@ int io\_sqe\_files\_register(struct io\_ring\_ctx \*ctx, void \_\_user \*arg, goto fail;  /\*- \* Don't allow io\_uring instances to be registered. If UNIX- \* isn't enabled, then this causes a reference cycle and this- \* instance can never get freed. If UNIX is enabled we'll- \* handle it just fine, but there's still no point in allowing- \* a ring fd as it doesn't support regular read/write anyway.+ \* Don't allow io\_uring instances to be registered. \*/ if (io\_is\_uring\_fops(file)) { fput(file); goto fail; }- ret = io\_scm\_file\_account(ctx, file);- if (ret) {- fput(file);- goto fail;- } file\_slot = io\_fixed\_file\_slot(&ctx->file\_table, i); io\_fixed\_file\_set(file\_slot, file); io\_file\_bitmap\_set(&ctx->file\_table, i);diff --git a/io\_uring/rsrc.h b/io\_uring/rsrc.hindex acaf8dad054014..85f145607c6209 100644--- a/[io\_uring/rsrc.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/rsrc.h?id=28fe81bcd3ea932e280f04e087ff0c75a4995a46)+++ b/[io\_uring/rsrc.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/rsrc.h?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b)@@ -77,21 +77,6 @@ int io\_sqe\_files\_unregister(struct io\_ring\_ctx \*ctx); int io\_sqe\_files\_register(struct io\_ring\_ctx \*ctx, void \_\_user \*arg, unsigned nr\_args, u64 \_\_user \*tags); -int \_\_io\_scm\_file\_account(struct io\_ring\_ctx \*ctx, struct file \*file);--static inline bool io\_file\_need\_scm(struct file \*filp)-{- return false;-}--static inline int io\_scm\_file\_account(struct io\_ring\_ctx \*ctx,- struct file \*file)-{- if (likely(!io\_file\_need\_scm(file)))- return 0;- return \_\_io\_scm\_file\_account(ctx, file);-}- int io\_register\_files\_update(struct io\_ring\_ctx \*ctx, void \_\_user \*arg, unsigned nr\_args); int io\_register\_rsrc\_update(struct io\_ring\_ctx \*ctx, void \_\_user \*arg, |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 22:32:38 +0000

