

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=a6771f343af90a25f3a14911634562bb5621df02)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a6771f343af90a25f3a14911634562bb5621df02)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a6771f343af90a25f3a14911634562bb5621df02)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a6771f343af90a25f3a14911634562bb5621df02)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jens Axboe <axboe@kernel.dk> | 2024-03-13 17:59:01 -0600 |
| --- | --- | --- |
| committer | Sasha Levin <sashal@kernel.org> | 2024-03-26 18:21:45 -0400 |
| commit | [a6771f343af90a25f3a14911634562bb5621df02](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a6771f343af90a25f3a14911634562bb5621df02) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=a6771f343af90a25f3a14911634562bb5621df02)) | |
| tree | [e3367530386888618c257fe76f9ddc55f950f9a0](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a6771f343af90a25f3a14911634562bb5621df02) | |
| parent | [875f5fed30a182675f729f35bbd6ad62b52bd1ac](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=875f5fed30a182675f729f35bbd6ad62b52bd1ac) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a6771f343af90a25f3a14911634562bb5621df02&id2=875f5fed30a182675f729f35bbd6ad62b52bd1ac)) | |
| download | [linux-a6771f343af90a25f3a14911634562bb5621df02.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-a6771f343af90a25f3a14911634562bb5621df02.tar.gz) | |

io\_uring: drop any code related to SCM\_RIGHTSCommit 6e5e6d274956305f1fc0340522b38f5f5be74bdb upstream.
This is dead code after we dropped support for passing io\_uring fds
over SCM\_RIGHTS, get rid of it.
Signed-off-by: Jens Axboe <axboe@kernel.dk>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a6771f343af90a25f3a14911634562bb5621df02)

| -rw-r--r-- | [io\_uring/io\_uring.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/io_uring/io_uring.c?id=a6771f343af90a25f3a14911634562bb5621df02) | 211 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 3 insertions, 208 deletions

| diff --git a/io\_uring/io\_uring.c b/io\_uring/io\_uring.cindex a80c808d3a0efc..67a355f27ad805 100644--- a/[io\_uring/io\_uring.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/io_uring.c?id=875f5fed30a182675f729f35bbd6ad62b52bd1ac)+++ b/[io\_uring/io\_uring.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/io_uring.c?id=a6771f343af90a25f3a14911634562bb5621df02)@@ -62,7 +62,6 @@ #include <linux/net.h> #include <net/sock.h> #include <net/af\_unix.h>-#include <net/scm.h> #include <linux/anon\_inodes.h> #include <linux/sched/mm.h> #include <linux/uaccess.h>@@ -440,9 +439,6 @@ struct io\_ring\_ctx {  /\* Keep this last, we don't need it for the fast path \*/ struct {- #if defined(CONFIG\_UNIX)- struct socket \*ring\_sock;- #endif /\* hashed buffered write serialization \*/ struct io\_wq\_hash \*hash\_map; @@ -7976,15 +7972,6 @@ static void io\_free\_file\_tables(struct io\_file\_table \*table)  static void \_\_io\_sqe\_files\_unregister(struct io\_ring\_ctx \*ctx) {-#if defined(CONFIG\_UNIX)- if (ctx->ring\_sock) {- struct sock \*sock = ctx->ring\_sock->sk;- struct sk\_buff \*skb;-- while ((skb = skb\_dequeue(&sock->sk\_receive\_queue)) != NULL)- kfree\_skb(skb);- }-#else int i;  for (i = 0; i < ctx->nr\_user\_files; i++) {@@ -7994,7 +7981,6 @@ static void \_\_io\_sqe\_files\_unregister(struct io\_ring\_ctx \*ctx) if (file) fput(file); }-#endif io\_free\_file\_tables(&ctx->file\_table); io\_rsrc\_data\_free(ctx->file\_data); ctx->file\_data = NULL;@@ -8146,170 +8132,11 @@ static struct io\_sq\_data \*io\_get\_sq\_data(struct io\_uring\_params \*p, return sqd; } -#if defined(CONFIG\_UNIX)-/\*- \* Ensure the UNIX gc is aware of our file set, so we are certain that- \* the io\_uring can be safely unregistered on process exit, even if we have- \* loops in the file referencing.- \*/-static int \_\_io\_sqe\_files\_scm(struct io\_ring\_ctx \*ctx, int nr, int offset)-{- struct sock \*sk = ctx->ring\_sock->sk;- struct scm\_fp\_list \*fpl;- struct sk\_buff \*skb;- int i, nr\_files;-- fpl = kzalloc(sizeof(\*fpl), GFP\_KERNEL);- if (!fpl)- return -ENOMEM;-- skb = alloc\_skb(0, GFP\_KERNEL);- if (!skb) {- kfree(fpl);- return -ENOMEM;- }-- skb->sk = sk;- skb->scm\_io\_uring = 1;-- nr\_files = 0;- fpl->user = get\_uid(current\_user());- for (i = 0; i < nr; i++) {- struct file \*file = io\_file\_from\_index(ctx, i + offset);-- if (!file)- continue;- fpl->fp[nr\_files] = get\_file(file);- unix\_inflight(fpl->user, fpl->fp[nr\_files]);- nr\_files++;- }-- if (nr\_files) {- fpl->max = SCM\_MAX\_FD;- fpl->count = nr\_files;- UNIXCB(skb).fp = fpl;- skb->destructor = unix\_destruct\_scm;- refcount\_add(skb->truesize, &sk->sk\_wmem\_alloc);- skb\_queue\_head(&sk->sk\_receive\_queue, skb);-- for (i = 0; i < nr; i++) {- struct file \*file = io\_file\_from\_index(ctx, i + offset);-- if (file)- fput(file);- }- } else {- kfree\_skb(skb);- free\_uid(fpl->user);- kfree(fpl);- }-- return 0;-}--/\*- \* If UNIX sockets are enabled, fd passing can cause a reference cycle which- \* causes regular reference counting to break down. We rely on the UNIX- \* garbage collection to take care of this problem for us.- \*/-static int io\_sqe\_files\_scm(struct io\_ring\_ctx \*ctx)-{- unsigned left, total;- int ret = 0;-- total = 0;- left = ctx->nr\_user\_files;- while (left) {- unsigned this\_files = min\_t(unsigned, left, SCM\_MAX\_FD);-- ret = \_\_io\_sqe\_files\_scm(ctx, this\_files, total);- if (ret)- break;- left -= this\_files;- total += this\_files;- }-- if (!ret)- return 0;-- while (total < ctx->nr\_user\_files) {- struct file \*file = io\_file\_from\_index(ctx, total);-- if (file)- fput(file);- total++;- }-- return ret;-}-#else-static int io\_sqe\_files\_scm(struct io\_ring\_ctx \*ctx)-{- return 0;-}-#endif- static void io\_rsrc\_file\_put(struct io\_ring\_ctx \*ctx, struct io\_rsrc\_put \*prsrc) { struct file \*file = prsrc->file;-#if defined(CONFIG\_UNIX)- struct sock \*sock = ctx->ring\_sock->sk;- struct sk\_buff\_head list, \*head = &sock->sk\_receive\_queue;- struct sk\_buff \*skb;- int i; - \_\_skb\_queue\_head\_init(&list);-- /\*- \* Find the skb that holds this file in its SCM\_RIGHTS. When found,- \* remove this entry and rearrange the file array.- \*/- skb = skb\_dequeue(head);- while (skb) {- struct scm\_fp\_list \*fp;-- fp = UNIXCB(skb).fp;- for (i = 0; i < fp->count; i++) {- int left;-- if (fp->fp[i] != file)- continue;-- unix\_notinflight(fp->user, fp->fp[i]);- left = fp->count - 1 - i;- if (left) {- memmove(&fp->fp[i], &fp->fp[i + 1],- left \* sizeof(struct file \*));- }- fp->count--;- if (!fp->count) {- kfree\_skb(skb);- skb = NULL;- } else {- \_\_skb\_queue\_tail(&list, skb);- }- fput(file);- file = NULL;- break;- }-- if (!file)- break;-- \_\_skb\_queue\_tail(&list, skb);-- skb = skb\_dequeue(head);- }-- if (skb\_peek(&list)) {- spin\_lock\_irq(&head->lock);- while ((skb = \_\_skb\_dequeue(&list)) != NULL)- \_\_skb\_queue\_tail(head, skb);- spin\_unlock\_irq(&head->lock);- }-#else fput(file);-#endif }  static void \_\_io\_rsrc\_put\_work(struct io\_rsrc\_node \*ref\_node)@@ -8420,12 +8247,6 @@ static int io\_sqe\_files\_register(struct io\_ring\_ctx \*ctx, void \_\_user \*arg, io\_fixed\_file\_set(io\_fixed\_file\_slot(&ctx->file\_table, i), file); } - ret = io\_sqe\_files\_scm(ctx);- if (ret) {- \_\_io\_sqe\_files\_unregister(ctx);- return ret;- }- io\_rsrc\_node\_switch(ctx, NULL); return ret; out\_fput:@@ -9382,12 +9203,6 @@ static void io\_ring\_ctx\_free(struct io\_ring\_ctx \*ctx) WARN\_ON\_ONCE(!list\_empty(&ctx->rsrc\_ref\_list)); WARN\_ON\_ONCE(!llist\_empty(&ctx->rsrc\_put\_llist)); -#if defined(CONFIG\_UNIX)- if (ctx->ring\_sock) {- ctx->ring\_sock->file = NULL; /\* so that iput() is called \*/- sock\_release(ctx->ring\_sock);- }-#endif WARN\_ON\_ONCE(!list\_empty(&ctx->ltimeout\_list));  if (ctx->mm\_account) {@@ -10329,32 +10144,12 @@ static int io\_uring\_install\_fd(struct io\_ring\_ctx \*ctx, struct file \*file) /\* \* Allocate an anonymous fd, this is what constitutes the application \* visible backing of an io\_uring instance. The application mmaps this- \* fd to gain access to the SQ/CQ ring details. If UNIX sockets are enabled,- \* we have to tie this fd to a socket for file garbage collection purposes.+ \* fd to gain access to the SQ/CQ ring details. \*/ static struct file \*io\_uring\_get\_file(struct io\_ring\_ctx \*ctx) {- struct file \*file;-#if defined(CONFIG\_UNIX)- int ret;-- ret = sock\_create\_kern(&init\_net, PF\_UNIX, SOCK\_RAW, IPPROTO\_IP,- &ctx->ring\_sock);- if (ret)- return ERR\_PTR(ret);-#endif-- file = anon\_inode\_getfile("[io\_uring]", &io\_uring\_fops, ctx,- O\_RDWR | O\_CLOEXEC);-#if defined(CONFIG\_UNIX)- if (IS\_ERR(file)) {- sock\_release(ctx->ring\_sock);- ctx->ring\_sock = NULL;- } else {- ctx->ring\_sock->file = file;- }-#endif- return file;+ return anon\_inode\_getfile("[io\_uring]", &io\_uring\_fops, ctx,+ O\_RDWR | O\_CLOEXEC); }  static int io\_uring\_create(unsigned entries, struct io\_uring\_params \*p, |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 22:32:38 +0000

