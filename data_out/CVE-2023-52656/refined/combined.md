=== Content from git.kernel.org_2c544ab9_20250110_223403.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=d909d381c3152393421403be4b6435f17a2378b4)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d909d381c3152393421403be4b6435f17a2378b4)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d909d381c3152393421403be4b6435f17a2378b4)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d909d381c3152393421403be4b6435f17a2378b4)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jens Axboe <axboe@kernel.dk> | 2024-03-13 17:59:01 -0600 |
| --- | --- | --- |
| committer | Sasha Levin <sashal@kernel.org> | 2024-03-26 18:21:11 -0400 |
| commit | [d909d381c3152393421403be4b6435f17a2378b4](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d909d381c3152393421403be4b6435f17a2378b4) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=d909d381c3152393421403be4b6435f17a2378b4)) | |
| tree | [0b9027391635d5685cc555024231577f31875ce6](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d909d381c3152393421403be4b6435f17a2378b4) | |
| parent | [9dd3863e3fcd3cbfa08b6a34eb2cefed407f80f4](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9dd3863e3fcd3cbfa08b6a34eb2cefed407f80f4) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d909d381c3152393421403be4b6435f17a2378b4&id2=9dd3863e3fcd3cbfa08b6a34eb2cefed407f80f4)) | |
| download | [linux-d909d381c3152393421403be4b6435f17a2378b4.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-d909d381c3152393421403be4b6435f17a2378b4.tar.gz) | |

io\_uring: drop any code related to SCM\_RIGHTSCommit 6e5e6d274956305f1fc0340522b38f5f5be74bdb upstream.
This is dead code after we dropped support for passing io\_uring fds
over SCM\_RIGHTS, get rid of it.
Signed-off-by: Jens Axboe <axboe@kernel.dk>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d909d381c3152393421403be4b6435f17a2378b4)

| -rw-r--r-- | [io\_uring/io\_uring.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/io_uring/io_uring.c?id=d909d381c3152393421403be4b6435f17a2378b4) | 211 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 3 insertions, 208 deletions

| diff --git a/io\_uring/io\_uring.c b/io\_uring/io\_uring.cindex 541e6a6985ecc3..386b32e6fd9a8e 100644--- a/[io\_uring/io\_uring.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/io_uring.c?id=9dd3863e3fcd3cbfa08b6a34eb2cefed407f80f4)+++ b/[io\_uring/io\_uring.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/io_uring.c?id=d909d381c3152393421403be4b6435f17a2378b4)@@ -62,7 +62,6 @@ #include <linux/net.h> #include <net/sock.h> #include <net/af\_unix.h>-#include <net/scm.h> #include <linux/anon\_inodes.h> #include <linux/sched/mm.h> #include <linux/uaccess.h>@@ -440,9 +439,6 @@ struct io\_ring\_ctx {  /\* Keep this last, we don't need it for the fast path \*/ struct {- #if defined(CONFIG\_UNIX)- struct socket \*ring\_sock;- #endif /\* hashed buffered write serialization \*/ struct io\_wq\_hash \*hash\_map; @@ -8151,15 +8147,6 @@ static void io\_free\_file\_tables(struct io\_file\_table \*table)  static void \_\_io\_sqe\_files\_unregister(struct io\_ring\_ctx \*ctx) {-#if defined(CONFIG\_UNIX)- if (ctx->ring\_sock) {- struct sock \*sock = ctx->ring\_sock->sk;- struct sk\_buff \*skb;-- while ((skb = skb\_dequeue(&sock->sk\_receive\_queue)) != NULL)- kfree\_skb(skb);- }-#else int i;  for (i = 0; i < ctx->nr\_user\_files; i++) {@@ -8169,7 +8156,6 @@ static void \_\_io\_sqe\_files\_unregister(struct io\_ring\_ctx \*ctx) if (file) fput(file); }-#endif io\_free\_file\_tables(&ctx->file\_table); io\_rsrc\_data\_free(ctx->file\_data); ctx->file\_data = NULL;@@ -8321,170 +8307,11 @@ static struct io\_sq\_data \*io\_get\_sq\_data(struct io\_uring\_params \*p, return sqd; } -#if defined(CONFIG\_UNIX)-/\*- \* Ensure the UNIX gc is aware of our file set, so we are certain that- \* the io\_uring can be safely unregistered on process exit, even if we have- \* loops in the file referencing.- \*/-static int \_\_io\_sqe\_files\_scm(struct io\_ring\_ctx \*ctx, int nr, int offset)-{- struct sock \*sk = ctx->ring\_sock->sk;- struct scm\_fp\_list \*fpl;- struct sk\_buff \*skb;- int i, nr\_files;-- fpl = kzalloc(sizeof(\*fpl), GFP\_KERNEL);- if (!fpl)- return -ENOMEM;-- skb = alloc\_skb(0, GFP\_KERNEL);- if (!skb) {- kfree(fpl);- return -ENOMEM;- }-- skb->sk = sk;- skb->scm\_io\_uring = 1;-- nr\_files = 0;- fpl->user = get\_uid(current\_user());- for (i = 0; i < nr; i++) {- struct file \*file = io\_file\_from\_index(ctx, i + offset);-- if (!file)- continue;- fpl->fp[nr\_files] = get\_file(file);- unix\_inflight(fpl->user, fpl->fp[nr\_files]);- nr\_files++;- }-- if (nr\_files) {- fpl->max = SCM\_MAX\_FD;- fpl->count = nr\_files;- UNIXCB(skb).fp = fpl;- skb->destructor = unix\_destruct\_scm;- refcount\_add(skb->truesize, &sk->sk\_wmem\_alloc);- skb\_queue\_head(&sk->sk\_receive\_queue, skb);-- for (i = 0; i < nr; i++) {- struct file \*file = io\_file\_from\_index(ctx, i + offset);-- if (file)- fput(file);- }- } else {- kfree\_skb(skb);- free\_uid(fpl->user);- kfree(fpl);- }-- return 0;-}--/\*- \* If UNIX sockets are enabled, fd passing can cause a reference cycle which- \* causes regular reference counting to break down. We rely on the UNIX- \* garbage collection to take care of this problem for us.- \*/-static int io\_sqe\_files\_scm(struct io\_ring\_ctx \*ctx)-{- unsigned left, total;- int ret = 0;-- total = 0;- left = ctx->nr\_user\_files;- while (left) {- unsigned this\_files = min\_t(unsigned, left, SCM\_MAX\_FD);-- ret = \_\_io\_sqe\_files\_scm(ctx, this\_files, total);- if (ret)- break;- left -= this\_files;- total += this\_files;- }-- if (!ret)- return 0;-- while (total < ctx->nr\_user\_files) {- struct file \*file = io\_file\_from\_index(ctx, total);-- if (file)- fput(file);- total++;- }-- return ret;-}-#else-static int io\_sqe\_files\_scm(struct io\_ring\_ctx \*ctx)-{- return 0;-}-#endif- static void io\_rsrc\_file\_put(struct io\_ring\_ctx \*ctx, struct io\_rsrc\_put \*prsrc) { struct file \*file = prsrc->file;-#if defined(CONFIG\_UNIX)- struct sock \*sock = ctx->ring\_sock->sk;- struct sk\_buff\_head list, \*head = &sock->sk\_receive\_queue;- struct sk\_buff \*skb;- int i; - \_\_skb\_queue\_head\_init(&list);-- /\*- \* Find the skb that holds this file in its SCM\_RIGHTS. When found,- \* remove this entry and rearrange the file array.- \*/- skb = skb\_dequeue(head);- while (skb) {- struct scm\_fp\_list \*fp;-- fp = UNIXCB(skb).fp;- for (i = 0; i < fp->count; i++) {- int left;-- if (fp->fp[i] != file)- continue;-- unix\_notinflight(fp->user, fp->fp[i]);- left = fp->count - 1 - i;- if (left) {- memmove(&fp->fp[i], &fp->fp[i + 1],- left \* sizeof(struct file \*));- }- fp->count--;- if (!fp->count) {- kfree\_skb(skb);- skb = NULL;- } else {- \_\_skb\_queue\_tail(&list, skb);- }- fput(file);- file = NULL;- break;- }-- if (!file)- break;-- \_\_skb\_queue\_tail(&list, skb);-- skb = skb\_dequeue(head);- }-- if (skb\_peek(&list)) {- spin\_lock\_irq(&head->lock);- while ((skb = \_\_skb\_dequeue(&list)) != NULL)- \_\_skb\_queue\_tail(head, skb);- spin\_unlock\_irq(&head->lock);- }-#else fput(file);-#endif }  static void \_\_io\_rsrc\_put\_work(struct io\_rsrc\_node \*ref\_node)@@ -8595,12 +8422,6 @@ static int io\_sqe\_files\_register(struct io\_ring\_ctx \*ctx, void \_\_user \*arg, io\_fixed\_file\_set(io\_fixed\_file\_slot(&ctx->file\_table, i), file); } - ret = io\_sqe\_files\_scm(ctx);- if (ret) {- \_\_io\_sqe\_files\_unregister(ctx);- return ret;- }- io\_rsrc\_node\_switch(ctx, NULL); return ret; out\_fput:@@ -9557,12 +9378,6 @@ static void io\_ring\_ctx\_free(struct io\_ring\_ctx \*ctx) WARN\_ON\_ONCE(!list\_empty(&ctx->rsrc\_ref\_list)); WARN\_ON\_ONCE(!llist\_empty(&ctx->rsrc\_put\_llist)); -#if defined(CONFIG\_UNIX)- if (ctx->ring\_sock) {- ctx->ring\_sock->file = NULL; /\* so that iput() is called \*/- sock\_release(ctx->ring\_sock);- }-#endif WARN\_ON\_ONCE(!list\_empty(&ctx->ltimeout\_list));  if (ctx->mm\_account) {@@ -10499,32 +10314,12 @@ static int io\_uring\_install\_fd(struct io\_ring\_ctx \*ctx, struct file \*file) /\* \* Allocate an anonymous fd, this is what constitutes the application \* visible backing of an io\_uring instance. The application mmaps this- \* fd to gain access to the SQ/CQ ring details. If UNIX sockets are enabled,- \* we have to tie this fd to a socket for file garbage collection purposes.+ \* fd to gain access to the SQ/CQ ring details. \*/ static struct file \*io\_uring\_get\_file(struct io\_ring\_ctx \*ctx) {- struct file \*file;-#if defined(CONFIG\_UNIX)- int ret;-- ret = sock\_create\_kern(&init\_net, PF\_UNIX, SOCK\_RAW, IPPROTO\_IP,- &ctx->ring\_sock);- if (ret)- return ERR\_PTR(ret);-#endif-- file = anon\_inode\_getfile("[io\_uring]", &io\_uring\_fops, ctx,- O\_RDWR | O\_CLOEXEC);-#if defined(CONFIG\_UNIX)- if (IS\_ERR(file)) {- sock\_release(ctx->ring\_sock);- ctx->ring\_sock = NULL;- } else {- ctx->ring\_sock->file = file;- }-#endif- return file;+ return anon\_inode\_getfile("[io\_uring]", &io\_uring\_fops, ctx,+ O\_RDWR | O\_CLOEXEC); }  static int io\_uring\_create(unsigned entries, struct io\_uring\_params \*p, |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 22:32:40 +0000



=== Content from git.kernel.org_846b9828_20250110_223359.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=6e5e6d274956305f1fc0340522b38f5f5be74bdb)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=6e5e6d274956305f1fc0340522b38f5f5be74bdb)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6e5e6d274956305f1fc0340522b38f5f5be74bdb)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=6e5e6d274956305f1fc0340522b38f5f5be74bdb)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jens Axboe <axboe@kernel.dk> | 2023-12-19 12:36:34 -0700 |
| --- | --- | --- |
| committer | Jens Axboe <axboe@kernel.dk> | 2023-12-19 12:36:34 -0700 |
| commit | [6e5e6d274956305f1fc0340522b38f5f5be74bdb](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6e5e6d274956305f1fc0340522b38f5f5be74bdb) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=6e5e6d274956305f1fc0340522b38f5f5be74bdb)) | |
| tree | [531432a48f4872dcdcc561729f0c1684d5443ae4](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=6e5e6d274956305f1fc0340522b38f5f5be74bdb) | |
| parent | [a4104821ad651d8a0b374f0b2474c345bbb42f82](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a4104821ad651d8a0b374f0b2474c345bbb42f82) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=6e5e6d274956305f1fc0340522b38f5f5be74bdb&id2=a4104821ad651d8a0b374f0b2474c345bbb42f82)) | |
| download | [linux-6e5e6d274956305f1fc0340522b38f5f5be74bdb.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-6e5e6d274956305f1fc0340522b38f5f5be74bdb.tar.gz) | |

io\_uring: drop any code related to SCM\_RIGHTSThis is dead code after we dropped support for passing io\_uring fds
over SCM\_RIGHTS, get rid of it.
Signed-off-by: Jens Axboe <axboe@kernel.dk>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=6e5e6d274956305f1fc0340522b38f5f5be74bdb)

| -rw-r--r-- | [include/linux/io\_uring\_types.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/io_uring_types.h?id=6e5e6d274956305f1fc0340522b38f5f5be74bdb) | 3 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [io\_uring/filetable.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/io_uring/filetable.c?id=6e5e6d274956305f1fc0340522b38f5f5be74bdb) | 11 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [io\_uring/io\_uring.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/io_uring/io_uring.c?id=6e5e6d274956305f1fc0340522b38f5f5be74bdb) | 32 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [io\_uring/rsrc.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/io_uring/rsrc.c?id=6e5e6d274956305f1fc0340522b38f5f5be74bdb) | 169 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [io\_uring/rsrc.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/io_uring/rsrc.h?id=6e5e6d274956305f1fc0340522b38f5f5be74bdb) | 15 | |  |  |  | | --- | --- | --- | |

5 files changed, 10 insertions, 220 deletions

| diff --git a/include/linux/io\_uring\_types.h b/include/linux/io\_uring\_types.hindex bebab36abce895..fc8f2570b92b31 100644--- a/[include/linux/io\_uring\_types.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/io_uring_types.h?id=a4104821ad651d8a0b374f0b2474c345bbb42f82)+++ b/[include/linux/io\_uring\_types.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/io_uring_types.h?id=6e5e6d274956305f1fc0340522b38f5f5be74bdb)@@ -389,9 +389,6 @@ struct io\_ring\_ctx { struct wait\_queue\_head rsrc\_quiesce\_wq; unsigned rsrc\_quiesce; - #if defined(CONFIG\_UNIX)- struct socket \*ring\_sock;- #endif /\* hashed buffered write serialization \*/ struct io\_wq\_hash \*hash\_map; diff --git a/io\_uring/filetable.c b/io\_uring/filetable.cindex e7d749991de426..6e86e6188dbeeb 100644--- a/[io\_uring/filetable.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/filetable.c?id=a4104821ad651d8a0b374f0b2474c345bbb42f82)+++ b/[io\_uring/filetable.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/filetable.c?id=6e5e6d274956305f1fc0340522b38f5f5be74bdb)@@ -87,13 +87,10 @@ static int io\_install\_fixed\_file(struct io\_ring\_ctx \*ctx, struct file \*file, io\_file\_bitmap\_clear(&ctx->file\_table, slot\_index); } - ret = io\_scm\_file\_account(ctx, file);- if (!ret) {- \*io\_get\_tag\_slot(ctx->file\_data, slot\_index) = 0;- io\_fixed\_file\_set(file\_slot, file);- io\_file\_bitmap\_set(&ctx->file\_table, slot\_index);- }- return ret;+ \*io\_get\_tag\_slot(ctx->file\_data, slot\_index) = 0;+ io\_fixed\_file\_set(file\_slot, file);+ io\_file\_bitmap\_set(&ctx->file\_table, slot\_index);+ return 0; }  int \_\_io\_fixed\_fd\_install(struct io\_ring\_ctx \*ctx, struct file \*file,diff --git a/io\_uring/io\_uring.c b/io\_uring/io\_uring.cindex a9acccd45880d6..a9a519fa9926ed 100644--- a/[io\_uring/io\_uring.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/io_uring.c?id=a4104821ad651d8a0b374f0b2474c345bbb42f82)+++ b/[io\_uring/io\_uring.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/io_uring.c?id=6e5e6d274956305f1fc0340522b38f5f5be74bdb)@@ -60,7 +60,6 @@ #include <linux/net.h> #include <net/sock.h> #include <net/af\_unix.h>-#include <net/scm.h> #include <linux/anon\_inodes.h> #include <linux/sched/mm.h> #include <linux/uaccess.h>@@ -2866,13 +2865,6 @@ static \_\_cold void io\_ring\_ctx\_free(struct io\_ring\_ctx \*ctx) io\_rsrc\_node\_destroy(ctx, ctx->rsrc\_node);  WARN\_ON\_ONCE(!list\_empty(&ctx->rsrc\_ref\_list));--#if defined(CONFIG\_UNIX)- if (ctx->ring\_sock) {- ctx->ring\_sock->file = NULL; /\* so that iput() is called \*/- sock\_release(ctx->ring\_sock);- }-#endif WARN\_ON\_ONCE(!list\_empty(&ctx->ltimeout\_list));  io\_alloc\_cache\_free(&ctx->rsrc\_node\_cache, io\_rsrc\_node\_cache\_free);@@ -3781,32 +3773,12 @@ static int io\_uring\_install\_fd(struct file \*file) /\* \* Allocate an anonymous fd, this is what constitutes the application \* visible backing of an io\_uring instance. The application mmaps this- \* fd to gain access to the SQ/CQ ring details. If UNIX sockets are enabled,- \* we have to tie this fd to a socket for file garbage collection purposes.+ \* fd to gain access to the SQ/CQ ring details. \*/ static struct file \*io\_uring\_get\_file(struct io\_ring\_ctx \*ctx) {- struct file \*file;-#if defined(CONFIG\_UNIX)- int ret;-- ret = sock\_create\_kern(&init\_net, PF\_UNIX, SOCK\_RAW, IPPROTO\_IP,- &ctx->ring\_sock);- if (ret)- return ERR\_PTR(ret);-#endif-- file = anon\_inode\_getfile\_secure("[io\_uring]", &io\_uring\_fops, ctx,+ return anon\_inode\_getfile\_secure("[io\_uring]", &io\_uring\_fops, ctx, O\_RDWR | O\_CLOEXEC, NULL);-#if defined(CONFIG\_UNIX)- if (IS\_ERR(file)) {- sock\_release(ctx->ring\_sock);- ctx->ring\_sock = NULL;- } else {- ctx->ring\_sock->file = file;- }-#endif- return file; }  static \_\_cold int io\_uring\_create(unsigned entries, struct io\_uring\_params \*p,diff --git a/io\_uring/rsrc.c b/io\_uring/rsrc.cindex f521c5965a9331..4818b79231ddb0 100644--- a/[io\_uring/rsrc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/rsrc.c?id=a4104821ad651d8a0b374f0b2474c345bbb42f82)+++ b/[io\_uring/rsrc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/rsrc.c?id=6e5e6d274956305f1fc0340522b38f5f5be74bdb)@@ -24,7 +24,6 @@ struct io\_rsrc\_update { };  static void io\_rsrc\_buf\_put(struct io\_ring\_ctx \*ctx, struct io\_rsrc\_put \*prsrc);-static void io\_rsrc\_file\_put(struct io\_ring\_ctx \*ctx, struct io\_rsrc\_put \*prsrc); static int io\_sqe\_buffer\_register(struct io\_ring\_ctx \*ctx, struct iovec \*iov, struct io\_mapped\_ubuf \*\*pimu, struct page \*\*last\_hpage);@@ -157,7 +156,7 @@ static void io\_rsrc\_put\_work(struct io\_rsrc\_node \*node)  switch (node->type) { case IORING\_RSRC\_FILE:- io\_rsrc\_file\_put(node->ctx, prsrc);+ fput(prsrc->file); break; case IORING\_RSRC\_BUFFER: io\_rsrc\_buf\_put(node->ctx, prsrc);@@ -402,23 +401,13 @@ static int \_\_io\_sqe\_files\_update(struct io\_ring\_ctx \*ctx, break; } /\*- \* Don't allow io\_uring instances to be registered. If- \* UNIX isn't enabled, then this causes a reference- \* cycle and this instance can never get freed. If UNIX- \* is enabled we'll handle it just fine, but there's- \* still no point in allowing a ring fd as it doesn't- \* support regular read/write anyway.+ \* Don't allow io\_uring instances to be registered. \*/ if (io\_is\_uring\_fops(file)) { fput(file); err = -EBADF; break; }- err = io\_scm\_file\_account(ctx, file);- if (err) {- fput(file);- break;- } \*io\_get\_tag\_slot(data, i) = tag; io\_fixed\_file\_set(file\_slot, file); io\_file\_bitmap\_set(&ctx->file\_table, i);@@ -675,22 +664,12 @@ void \_\_io\_sqe\_files\_unregister(struct io\_ring\_ctx \*ctx) for (i = 0; i < ctx->nr\_user\_files; i++) { struct file \*file = io\_file\_from\_index(&ctx->file\_table, i); - /\* skip scm accounted files, they'll be freed by ->ring\_sock \*/- if (!file || io\_file\_need\_scm(file))+ if (!file) continue; io\_file\_bitmap\_clear(&ctx->file\_table, i); fput(file); } -#if defined(CONFIG\_UNIX)- if (ctx->ring\_sock) {- struct sock \*sock = ctx->ring\_sock->sk;- struct sk\_buff \*skb;-- while ((skb = skb\_dequeue(&sock->sk\_receive\_queue)) != NULL)- kfree\_skb(skb);- }-#endif io\_free\_file\_tables(&ctx->file\_table); io\_file\_table\_set\_alloc\_range(ctx, 0, 0); io\_rsrc\_data\_free(ctx->file\_data);@@ -718,137 +697,6 @@ int io\_sqe\_files\_unregister(struct io\_ring\_ctx \*ctx) return ret; } -/\*- \* Ensure the UNIX gc is aware of our file set, so we are certain that- \* the io\_uring can be safely unregistered on process exit, even if we have- \* loops in the file referencing. We account only files that can hold other- \* files because otherwise they can't form a loop and so are not interesting- \* for GC.- \*/-int \_\_io\_scm\_file\_account(struct io\_ring\_ctx \*ctx, struct file \*file)-{-#if defined(CONFIG\_UNIX)- struct sock \*sk = ctx->ring\_sock->sk;- struct sk\_buff\_head \*head = &sk->sk\_receive\_queue;- struct scm\_fp\_list \*fpl;- struct sk\_buff \*skb;-- if (likely(!io\_file\_need\_scm(file)))- return 0;-- /\*- \* See if we can merge this file into an existing skb SCM\_RIGHTS- \* file set. If there's no room, fall back to allocating a new skb- \* and filling it in.- \*/- spin\_lock\_irq(&head->lock);- skb = skb\_peek(head);- if (skb && UNIXCB(skb).fp->count < SCM\_MAX\_FD)- \_\_skb\_unlink(skb, head);- else- skb = NULL;- spin\_unlock\_irq(&head->lock);-- if (!skb) {- fpl = kzalloc(sizeof(\*fpl), GFP\_KERNEL);- if (!fpl)- return -ENOMEM;-- skb = alloc\_skb(0, GFP\_KERNEL);- if (!skb) {- kfree(fpl);- return -ENOMEM;- }-- fpl->user = get\_uid(current\_user());- fpl->max = SCM\_MAX\_FD;- fpl->count = 0;-- UNIXCB(skb).fp = fpl;- skb->sk = sk;- skb->destructor = io\_uring\_destruct\_scm;- refcount\_add(skb->truesize, &sk->sk\_wmem\_alloc);- }-- fpl = UNIXCB(skb).fp;- fpl->fp[fpl->count++] = get\_file(file);- unix\_inflight(fpl->user, file);- skb\_queue\_head(head, skb);- fput(file);-#endif- return 0;-}--static \_\_cold void io\_rsrc\_file\_scm\_put(struct io\_ring\_ctx \*ctx, struct file \*file)-{-#if defined(CONFIG\_UNIX)- struct sock \*sock = ctx->ring\_sock->sk;- struct sk\_buff\_head list, \*head = &sock->sk\_receive\_queue;- struct sk\_buff \*skb;- int i;-- \_\_skb\_queue\_head\_init(&list);-- /\*- \* Find the skb that holds this file in its SCM\_RIGHTS. When found,- \* remove this entry and rearrange the file array.- \*/- skb = skb\_dequeue(head);- while (skb) {- struct scm\_fp\_list \*fp;-- fp = UNIXCB(skb).fp;- for (i = 0; i < fp->count; i++) {- int left;-- if (fp->fp[i] != file)- continue;-- unix\_notinflight(fp->user, fp->fp[i]);- left = fp->count - 1 - i;- if (left) {- memmove(&fp->fp[i], &fp->fp[i + 1],- left \* sizeof(struct file \*));- }- fp->count--;- if (!fp->count) {- kfree\_skb(skb);- skb = NULL;- } else {- \_\_skb\_queue\_tail(&list, skb);- }- fput(file);- file = NULL;- break;- }-- if (!file)- break;-- \_\_skb\_queue\_tail(&list, skb);-- skb = skb\_dequeue(head);- }-- if (skb\_peek(&list)) {- spin\_lock\_irq(&head->lock);- while ((skb = \_\_skb\_dequeue(&list)) != NULL)- \_\_skb\_queue\_tail(head, skb);- spin\_unlock\_irq(&head->lock);- }-#endif-}--static void io\_rsrc\_file\_put(struct io\_ring\_ctx \*ctx, struct io\_rsrc\_put \*prsrc)-{- struct file \*file = prsrc->file;-- if (likely(!io\_file\_need\_scm(file)))- fput(file);- else- io\_rsrc\_file\_scm\_put(ctx, file);-}- int io\_sqe\_files\_register(struct io\_ring\_ctx \*ctx, void \_\_user \*arg, unsigned nr\_args, u64 \_\_user \*tags) {@@ -897,21 +745,12 @@ int io\_sqe\_files\_register(struct io\_ring\_ctx \*ctx, void \_\_user \*arg, goto fail;  /\*- \* Don't allow io\_uring instances to be registered. If UNIX- \* isn't enabled, then this causes a reference cycle and this- \* instance can never get freed. If UNIX is enabled we'll- \* handle it just fine, but there's still no point in allowing- \* a ring fd as it doesn't support regular read/write anyway.+ \* Don't allow io\_uring instances to be registered. \*/ if (io\_is\_uring\_fops(file)) { fput(file); goto fail; }- ret = io\_scm\_file\_account(ctx, file);- if (ret) {- fput(file);- goto fail;- } file\_slot = io\_fixed\_file\_slot(&ctx->file\_table, i); io\_fixed\_file\_set(file\_slot, file); io\_file\_bitmap\_set(&ctx->file\_table, i);diff --git a/io\_uring/rsrc.h b/io\_uring/rsrc.hindex 08ac0d8e07ef84..7238b9cfe33b60 100644--- a/[io\_uring/rsrc.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/rsrc.h?id=a4104821ad651d8a0b374f0b2474c345bbb42f82)+++ b/[io\_uring/rsrc.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/rsrc.h?id=6e5e6d274956305f1fc0340522b38f5f5be74bdb)@@ -75,21 +75,6 @@ int io\_sqe\_files\_unregister(struct io\_ring\_ctx \*ctx); int io\_sqe\_files\_register(struct io\_ring\_ctx \*ctx, void \_\_user \*arg, unsigned nr\_args, u64 \_\_user \*tags); -int \_\_io\_scm\_file\_account(struct io\_ring\_ctx \*ctx, struct file \*file);--static inline bool io\_file\_need\_scm(struct file \*filp)-{- return false;-}--static inline int io\_scm\_file\_account(struct io\_ring\_ctx \*ctx,- struct file \*file)-{- if (likely(!io\_file\_need\_scm(file)))- return 0;- return \_\_io\_scm\_file\_account(ctx, file);-}- int io\_register\_files\_update(struct io\_ring\_ctx \*ctx, void \_\_user \*arg, unsigned nr\_args); int io\_register\_rsrc\_update(struct io\_ring\_ctx \*ctx, void \_\_user \*arg, |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 22:32:36 +0000



=== Content from git.kernel.org_41b6223b_20250110_223401.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=a6771f343af90a25f3a14911634562bb5621df02)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a6771f343af90a25f3a14911634562bb5621df02)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a6771f343af90a25f3a14911634562bb5621df02)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a6771f343af90a25f3a14911634562bb5621df02)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jens Axboe <axboe@kernel.dk> | 2024-03-13 17:59:01 -0600 |
| --- | --- | --- |
| committer | Sasha Levin <sashal@kernel.org> | 2024-03-26 18:21:45 -0400 |
| commit | [a6771f343af90a25f3a14911634562bb5621df02](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a6771f343af90a25f3a14911634562bb5621df02) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=a6771f343af90a25f3a14911634562bb5621df02)) | |
| tree | [e3367530386888618c257fe76f9ddc55f950f9a0](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a6771f343af90a25f3a14911634562bb5621df02) | |
| parent | [875f5fed30a182675f729f35bbd6ad62b52bd1ac](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=875f5fed30a182675f729f35bbd6ad62b52bd1ac) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a6771f343af90a25f3a14911634562bb5621df02&id2=875f5fed30a182675f729f35bbd6ad62b52bd1ac)) | |
| download | [linux-a6771f343af90a25f3a14911634562bb5621df02.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-a6771f343af90a25f3a14911634562bb5621df02.tar.gz) | |

io\_uring: drop any code related to SCM\_RIGHTSCommit 6e5e6d274956305f1fc0340522b38f5f5be74bdb upstream.
This is dead code after we dropped support for passing io\_uring fds
over SCM\_RIGHTS, get rid of it.
Signed-off-by: Jens Axboe <axboe@kernel.dk>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a6771f343af90a25f3a14911634562bb5621df02)

| -rw-r--r-- | [io\_uring/io\_uring.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/io_uring/io_uring.c?id=a6771f343af90a25f3a14911634562bb5621df02) | 211 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 3 insertions, 208 deletions

| diff --git a/io\_uring/io\_uring.c b/io\_uring/io\_uring.cindex a80c808d3a0efc..67a355f27ad805 100644--- a/[io\_uring/io\_uring.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/io_uring.c?id=875f5fed30a182675f729f35bbd6ad62b52bd1ac)+++ b/[io\_uring/io\_uring.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/io_uring.c?id=a6771f343af90a25f3a14911634562bb5621df02)@@ -62,7 +62,6 @@ #include <linux/net.h> #include <net/sock.h> #include <net/af\_unix.h>-#include <net/scm.h> #include <linux/anon\_inodes.h> #include <linux/sched/mm.h> #include <linux/uaccess.h>@@ -440,9 +439,6 @@ struct io\_ring\_ctx {  /\* Keep this last, we don't need it for the fast path \*/ struct {- #if defined(CONFIG\_UNIX)- struct socket \*ring\_sock;- #endif /\* hashed buffered write serialization \*/ struct io\_wq\_hash \*hash\_map; @@ -7976,15 +7972,6 @@ static void io\_free\_file\_tables(struct io\_file\_table \*table)  static void \_\_io\_sqe\_files\_unregister(struct io\_ring\_ctx \*ctx) {-#if defined(CONFIG\_UNIX)- if (ctx->ring\_sock) {- struct sock \*sock = ctx->ring\_sock->sk;- struct sk\_buff \*skb;-- while ((skb = skb\_dequeue(&sock->sk\_receive\_queue)) != NULL)- kfree\_skb(skb);- }-#else int i;  for (i = 0; i < ctx->nr\_user\_files; i++) {@@ -7994,7 +7981,6 @@ static void \_\_io\_sqe\_files\_unregister(struct io\_ring\_ctx \*ctx) if (file) fput(file); }-#endif io\_free\_file\_tables(&ctx->file\_table); io\_rsrc\_data\_free(ctx->file\_data); ctx->file\_data = NULL;@@ -8146,170 +8132,11 @@ static struct io\_sq\_data \*io\_get\_sq\_data(struct io\_uring\_params \*p, return sqd; } -#if defined(CONFIG\_UNIX)-/\*- \* Ensure the UNIX gc is aware of our file set, so we are certain that- \* the io\_uring can be safely unregistered on process exit, even if we have- \* loops in the file referencing.- \*/-static int \_\_io\_sqe\_files\_scm(struct io\_ring\_ctx \*ctx, int nr, int offset)-{- struct sock \*sk = ctx->ring\_sock->sk;- struct scm\_fp\_list \*fpl;- struct sk\_buff \*skb;- int i, nr\_files;-- fpl = kzalloc(sizeof(\*fpl), GFP\_KERNEL);- if (!fpl)- return -ENOMEM;-- skb = alloc\_skb(0, GFP\_KERNEL);- if (!skb) {- kfree(fpl);- return -ENOMEM;- }-- skb->sk = sk;- skb->scm\_io\_uring = 1;-- nr\_files = 0;- fpl->user = get\_uid(current\_user());- for (i = 0; i < nr; i++) {- struct file \*file = io\_file\_from\_index(ctx, i + offset);-- if (!file)- continue;- fpl->fp[nr\_files] = get\_file(file);- unix\_inflight(fpl->user, fpl->fp[nr\_files]);- nr\_files++;- }-- if (nr\_files) {- fpl->max = SCM\_MAX\_FD;- fpl->count = nr\_files;- UNIXCB(skb).fp = fpl;- skb->destructor = unix\_destruct\_scm;- refcount\_add(skb->truesize, &sk->sk\_wmem\_alloc);- skb\_queue\_head(&sk->sk\_receive\_queue, skb);-- for (i = 0; i < nr; i++) {- struct file \*file = io\_file\_from\_index(ctx, i + offset);-- if (file)- fput(file);- }- } else {- kfree\_skb(skb);- free\_uid(fpl->user);- kfree(fpl);- }-- return 0;-}--/\*- \* If UNIX sockets are enabled, fd passing can cause a reference cycle which- \* causes regular reference counting to break down. We rely on the UNIX- \* garbage collection to take care of this problem for us.- \*/-static int io\_sqe\_files\_scm(struct io\_ring\_ctx \*ctx)-{- unsigned left, total;- int ret = 0;-- total = 0;- left = ctx->nr\_user\_files;- while (left) {- unsigned this\_files = min\_t(unsigned, left, SCM\_MAX\_FD);-- ret = \_\_io\_sqe\_files\_scm(ctx, this\_files, total);- if (ret)- break;- left -= this\_files;- total += this\_files;- }-- if (!ret)- return 0;-- while (total < ctx->nr\_user\_files) {- struct file \*file = io\_file\_from\_index(ctx, total);-- if (file)- fput(file);- total++;- }-- return ret;-}-#else-static int io\_sqe\_files\_scm(struct io\_ring\_ctx \*ctx)-{- return 0;-}-#endif- static void io\_rsrc\_file\_put(struct io\_ring\_ctx \*ctx, struct io\_rsrc\_put \*prsrc) { struct file \*file = prsrc->file;-#if defined(CONFIG\_UNIX)- struct sock \*sock = ctx->ring\_sock->sk;- struct sk\_buff\_head list, \*head = &sock->sk\_receive\_queue;- struct sk\_buff \*skb;- int i; - \_\_skb\_queue\_head\_init(&list);-- /\*- \* Find the skb that holds this file in its SCM\_RIGHTS. When found,- \* remove this entry and rearrange the file array.- \*/- skb = skb\_dequeue(head);- while (skb) {- struct scm\_fp\_list \*fp;-- fp = UNIXCB(skb).fp;- for (i = 0; i < fp->count; i++) {- int left;-- if (fp->fp[i] != file)- continue;-- unix\_notinflight(fp->user, fp->fp[i]);- left = fp->count - 1 - i;- if (left) {- memmove(&fp->fp[i], &fp->fp[i + 1],- left \* sizeof(struct file \*));- }- fp->count--;- if (!fp->count) {- kfree\_skb(skb);- skb = NULL;- } else {- \_\_skb\_queue\_tail(&list, skb);- }- fput(file);- file = NULL;- break;- }-- if (!file)- break;-- \_\_skb\_queue\_tail(&list, skb);-- skb = skb\_dequeue(head);- }-- if (skb\_peek(&list)) {- spin\_lock\_irq(&head->lock);- while ((skb = \_\_skb\_dequeue(&list)) != NULL)- \_\_skb\_queue\_tail(head, skb);- spin\_unlock\_irq(&head->lock);- }-#else fput(file);-#endif }  static void \_\_io\_rsrc\_put\_work(struct io\_rsrc\_node \*ref\_node)@@ -8420,12 +8247,6 @@ static int io\_sqe\_files\_register(struct io\_ring\_ctx \*ctx, void \_\_user \*arg, io\_fixed\_file\_set(io\_fixed\_file\_slot(&ctx->file\_table, i), file); } - ret = io\_sqe\_files\_scm(ctx);- if (ret) {- \_\_io\_sqe\_files\_unregister(ctx);- return ret;- }- io\_rsrc\_node\_switch(ctx, NULL); return ret; out\_fput:@@ -9382,12 +9203,6 @@ static void io\_ring\_ctx\_free(struct io\_ring\_ctx \*ctx) WARN\_ON\_ONCE(!list\_empty(&ctx->rsrc\_ref\_list)); WARN\_ON\_ONCE(!llist\_empty(&ctx->rsrc\_put\_llist)); -#if defined(CONFIG\_UNIX)- if (ctx->ring\_sock) {- ctx->ring\_sock->file = NULL; /\* so that iput() is called \*/- sock\_release(ctx->ring\_sock);- }-#endif WARN\_ON\_ONCE(!list\_empty(&ctx->ltimeout\_list));  if (ctx->mm\_account) {@@ -10329,32 +10144,12 @@ static int io\_uring\_install\_fd(struct io\_ring\_ctx \*ctx, struct file \*file) /\* \* Allocate an anonymous fd, this is what constitutes the application \* visible backing of an io\_uring instance. The application mmaps this- \* fd to gain access to the SQ/CQ ring details. If UNIX sockets are enabled,- \* we have to tie this fd to a socket for file garbage collection purposes.+ \* fd to gain access to the SQ/CQ ring details. \*/ static struct file \*io\_uring\_get\_file(struct io\_ring\_ctx \*ctx) {- struct file \*file;-#if defined(CONFIG\_UNIX)- int ret;-- ret = sock\_create\_kern(&init\_net, PF\_UNIX, SOCK\_RAW, IPPROTO\_IP,- &ctx->ring\_sock);- if (ret)- return ERR\_PTR(ret);-#endif-- file = anon\_inode\_getfile("[io\_uring]", &io\_uring\_fops, ctx,- O\_RDWR | O\_CLOEXEC);-#if defined(CONFIG\_UNIX)- if (IS\_ERR(file)) {- sock\_release(ctx->ring\_sock);- ctx->ring\_sock = NULL;- } else {- ctx->ring\_sock->file = file;- }-#endif- return file;+ return anon\_inode\_getfile("[io\_uring]", &io\_uring\_fops, ctx,+ O\_RDWR | O\_CLOEXEC); }  static int io\_uring\_create(unsigned entries, struct io\_uring\_params \*p, |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 22:32:38 +0000



=== Content from git.kernel.org_a98e76fa_20250110_223400.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=88c49d9c896143cdc0f77197c4dcf24140375e89)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=88c49d9c896143cdc0f77197c4dcf24140375e89)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=88c49d9c896143cdc0f77197c4dcf24140375e89)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=88c49d9c896143cdc0f77197c4dcf24140375e89)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jens Axboe <axboe@kernel.dk> | 2023-12-19 12:36:34 -0700 |
| --- | --- | --- |
| committer | Sasha Levin <sashal@kernel.org> | 2024-03-26 18:17:49 -0400 |
| commit | [88c49d9c896143cdc0f77197c4dcf24140375e89](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=88c49d9c896143cdc0f77197c4dcf24140375e89) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=88c49d9c896143cdc0f77197c4dcf24140375e89)) | |
| tree | [ece3fbb6256c247625fa69bf4119411167b66c40](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=88c49d9c896143cdc0f77197c4dcf24140375e89) | |
| parent | [f3ee556f307e8310b37458f97a3b38f5ea965e2e](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f3ee556f307e8310b37458f97a3b38f5ea965e2e) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=88c49d9c896143cdc0f77197c4dcf24140375e89&id2=f3ee556f307e8310b37458f97a3b38f5ea965e2e)) | |
| download | [linux-88c49d9c896143cdc0f77197c4dcf24140375e89.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-88c49d9c896143cdc0f77197c4dcf24140375e89.tar.gz) | |

io\_uring: drop any code related to SCM\_RIGHTSCommit 6e5e6d274956305f1fc0340522b38f5f5be74bdb upstream.
This is dead code after we dropped support for passing io\_uring fds
over SCM\_RIGHTS, get rid of it.
Signed-off-by: Jens Axboe <axboe@kernel.dk>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=88c49d9c896143cdc0f77197c4dcf24140375e89)

| -rw-r--r-- | [include/linux/io\_uring\_types.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/io_uring_types.h?id=88c49d9c896143cdc0f77197c4dcf24140375e89) | 3 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [io\_uring/filetable.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/io_uring/filetable.c?id=88c49d9c896143cdc0f77197c4dcf24140375e89) | 11 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [io\_uring/io\_uring.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/io_uring/io_uring.c?id=88c49d9c896143cdc0f77197c4dcf24140375e89) | 32 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [io\_uring/rsrc.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/io_uring/rsrc.c?id=88c49d9c896143cdc0f77197c4dcf24140375e89) | 169 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [io\_uring/rsrc.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/io_uring/rsrc.h?id=88c49d9c896143cdc0f77197c4dcf24140375e89) | 15 | |  |  |  | | --- | --- | --- | |

5 files changed, 10 insertions, 220 deletions

| diff --git a/include/linux/io\_uring\_types.h b/include/linux/io\_uring\_types.hindex 239a4f68801bb5..335eca49dc8b0f 100644--- a/[include/linux/io\_uring\_types.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/io_uring_types.h?id=f3ee556f307e8310b37458f97a3b38f5ea965e2e)+++ b/[include/linux/io\_uring\_types.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/io_uring_types.h?id=88c49d9c896143cdc0f77197c4dcf24140375e89)@@ -358,9 +358,6 @@ struct io\_ring\_ctx { struct wait\_queue\_head rsrc\_quiesce\_wq; unsigned rsrc\_quiesce; - #if defined(CONFIG\_UNIX)- struct socket \*ring\_sock;- #endif /\* hashed buffered write serialization \*/ struct io\_wq\_hash \*hash\_map; diff --git a/io\_uring/filetable.c b/io\_uring/filetable.cindex e7d749991de426..6e86e6188dbeeb 100644--- a/[io\_uring/filetable.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/filetable.c?id=f3ee556f307e8310b37458f97a3b38f5ea965e2e)+++ b/[io\_uring/filetable.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/filetable.c?id=88c49d9c896143cdc0f77197c4dcf24140375e89)@@ -87,13 +87,10 @@ static int io\_install\_fixed\_file(struct io\_ring\_ctx \*ctx, struct file \*file, io\_file\_bitmap\_clear(&ctx->file\_table, slot\_index); } - ret = io\_scm\_file\_account(ctx, file);- if (!ret) {- \*io\_get\_tag\_slot(ctx->file\_data, slot\_index) = 0;- io\_fixed\_file\_set(file\_slot, file);- io\_file\_bitmap\_set(&ctx->file\_table, slot\_index);- }- return ret;+ \*io\_get\_tag\_slot(ctx->file\_data, slot\_index) = 0;+ io\_fixed\_file\_set(file\_slot, file);+ io\_file\_bitmap\_set(&ctx->file\_table, slot\_index);+ return 0; }  int \_\_io\_fixed\_fd\_install(struct io\_ring\_ctx \*ctx, struct file \*file,diff --git a/io\_uring/io\_uring.c b/io\_uring/io\_uring.cindex 06bd8795a87d17..f8d145fb40bbc1 100644--- a/[io\_uring/io\_uring.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/io_uring.c?id=f3ee556f307e8310b37458f97a3b38f5ea965e2e)+++ b/[io\_uring/io\_uring.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/io_uring.c?id=88c49d9c896143cdc0f77197c4dcf24140375e89)@@ -60,7 +60,6 @@ #include <linux/net.h> #include <net/sock.h> #include <net/af\_unix.h>-#include <net/scm.h> #include <linux/anon\_inodes.h> #include <linux/sched/mm.h> #include <linux/uaccess.h>@@ -2939,13 +2938,6 @@ static \_\_cold void io\_ring\_ctx\_free(struct io\_ring\_ctx \*ctx) io\_rsrc\_node\_destroy(ctx, ctx->rsrc\_node);  WARN\_ON\_ONCE(!list\_empty(&ctx->rsrc\_ref\_list));--#if defined(CONFIG\_UNIX)- if (ctx->ring\_sock) {- ctx->ring\_sock->file = NULL; /\* so that iput() is called \*/- sock\_release(ctx->ring\_sock);- }-#endif WARN\_ON\_ONCE(!list\_empty(&ctx->ltimeout\_list));  io\_alloc\_cache\_free(&ctx->rsrc\_node\_cache, io\_rsrc\_node\_cache\_free);@@ -3867,32 +3859,12 @@ static int io\_uring\_install\_fd(struct file \*file) /\* \* Allocate an anonymous fd, this is what constitutes the application \* visible backing of an io\_uring instance. The application mmaps this- \* fd to gain access to the SQ/CQ ring details. If UNIX sockets are enabled,- \* we have to tie this fd to a socket for file garbage collection purposes.+ \* fd to gain access to the SQ/CQ ring details. \*/ static struct file \*io\_uring\_get\_file(struct io\_ring\_ctx \*ctx) {- struct file \*file;-#if defined(CONFIG\_UNIX)- int ret;-- ret = sock\_create\_kern(&init\_net, PF\_UNIX, SOCK\_RAW, IPPROTO\_IP,- &ctx->ring\_sock);- if (ret)- return ERR\_PTR(ret);-#endif-- file = anon\_inode\_getfile\_secure("[io\_uring]", &io\_uring\_fops, ctx,+ return anon\_inode\_getfile\_secure("[io\_uring]", &io\_uring\_fops, ctx, O\_RDWR | O\_CLOEXEC, NULL);-#if defined(CONFIG\_UNIX)- if (IS\_ERR(file)) {- sock\_release(ctx->ring\_sock);- ctx->ring\_sock = NULL;- } else {- ctx->ring\_sock->file = file;- }-#endif- return file; }  static \_\_cold int io\_uring\_create(unsigned entries, struct io\_uring\_params \*p,diff --git a/io\_uring/rsrc.c b/io\_uring/rsrc.cindex f521c5965a9331..4818b79231ddb0 100644--- a/[io\_uring/rsrc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/rsrc.c?id=f3ee556f307e8310b37458f97a3b38f5ea965e2e)+++ b/[io\_uring/rsrc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/rsrc.c?id=88c49d9c896143cdc0f77197c4dcf24140375e89)@@ -24,7 +24,6 @@ struct io\_rsrc\_update { };  static void io\_rsrc\_buf\_put(struct io\_ring\_ctx \*ctx, struct io\_rsrc\_put \*prsrc);-static void io\_rsrc\_file\_put(struct io\_ring\_ctx \*ctx, struct io\_rsrc\_put \*prsrc); static int io\_sqe\_buffer\_register(struct io\_ring\_ctx \*ctx, struct iovec \*iov, struct io\_mapped\_ubuf \*\*pimu, struct page \*\*last\_hpage);@@ -157,7 +156,7 @@ static void io\_rsrc\_put\_work(struct io\_rsrc\_node \*node)  switch (node->type) { case IORING\_RSRC\_FILE:- io\_rsrc\_file\_put(node->ctx, prsrc);+ fput(prsrc->file); break; case IORING\_RSRC\_BUFFER: io\_rsrc\_buf\_put(node->ctx, prsrc);@@ -402,23 +401,13 @@ static int \_\_io\_sqe\_files\_update(struct io\_ring\_ctx \*ctx, break; } /\*- \* Don't allow io\_uring instances to be registered. If- \* UNIX isn't enabled, then this causes a reference- \* cycle and this instance can never get freed. If UNIX- \* is enabled we'll handle it just fine, but there's- \* still no point in allowing a ring fd as it doesn't- \* support regular read/write anyway.+ \* Don't allow io\_uring instances to be registered. \*/ if (io\_is\_uring\_fops(file)) { fput(file); err = -EBADF; break; }- err = io\_scm\_file\_account(ctx, file);- if (err) {- fput(file);- break;- } \*io\_get\_tag\_slot(data, i) = tag; io\_fixed\_file\_set(file\_slot, file); io\_file\_bitmap\_set(&ctx->file\_table, i);@@ -675,22 +664,12 @@ void \_\_io\_sqe\_files\_unregister(struct io\_ring\_ctx \*ctx) for (i = 0; i < ctx->nr\_user\_files; i++) { struct file \*file = io\_file\_from\_index(&ctx->file\_table, i); - /\* skip scm accounted files, they'll be freed by ->ring\_sock \*/- if (!file || io\_file\_need\_scm(file))+ if (!file) continue; io\_file\_bitmap\_clear(&ctx->file\_table, i); fput(file); } -#if defined(CONFIG\_UNIX)- if (ctx->ring\_sock) {- struct sock \*sock = ctx->ring\_sock->sk;- struct sk\_buff \*skb;-- while ((skb = skb\_dequeue(&sock->sk\_receive\_queue)) != NULL)- kfree\_skb(skb);- }-#endif io\_free\_file\_tables(&ctx->file\_table); io\_file\_table\_set\_alloc\_range(ctx, 0, 0); io\_rsrc\_data\_free(ctx->file\_data);@@ -718,137 +697,6 @@ int io\_sqe\_files\_unregister(struct io\_ring\_ctx \*ctx) return ret; } -/\*- \* Ensure the UNIX gc is aware of our file set, so we are certain that- \* the io\_uring can be safely unregistered on process exit, even if we have- \* loops in the file referencing. We account only files that can hold other- \* files because otherwise they can't form a loop and so are not interesting- \* for GC.- \*/-int \_\_io\_scm\_file\_account(struct io\_ring\_ctx \*ctx, struct file \*file)-{-#if defined(CONFIG\_UNIX)- struct sock \*sk = ctx->ring\_sock->sk;- struct sk\_buff\_head \*head = &sk->sk\_receive\_queue;- struct scm\_fp\_list \*fpl;- struct sk\_buff \*skb;-- if (likely(!io\_file\_need\_scm(file)))- return 0;-- /\*- \* See if we can merge this file into an existing skb SCM\_RIGHTS- \* file set. If there's no room, fall back to allocating a new skb- \* and filling it in.- \*/- spin\_lock\_irq(&head->lock);- skb = skb\_peek(head);- if (skb && UNIXCB(skb).fp->count < SCM\_MAX\_FD)- \_\_skb\_unlink(skb, head);- else- skb = NULL;- spin\_unlock\_irq(&head->lock);-- if (!skb) {- fpl = kzalloc(sizeof(\*fpl), GFP\_KERNEL);- if (!fpl)- return -ENOMEM;-- skb = alloc\_skb(0, GFP\_KERNEL);- if (!skb) {- kfree(fpl);- return -ENOMEM;- }-- fpl->user = get\_uid(current\_user());- fpl->max = SCM\_MAX\_FD;- fpl->count = 0;-- UNIXCB(skb).fp = fpl;- skb->sk = sk;- skb->destructor = io\_uring\_destruct\_scm;- refcount\_add(skb->truesize, &sk->sk\_wmem\_alloc);- }-- fpl = UNIXCB(skb).fp;- fpl->fp[fpl->count++] = get\_file(file);- unix\_inflight(fpl->user, file);- skb\_queue\_head(head, skb);- fput(file);-#endif- return 0;-}--static \_\_cold void io\_rsrc\_file\_scm\_put(struct io\_ring\_ctx \*ctx, struct file \*file)-{-#if defined(CONFIG\_UNIX)- struct sock \*sock = ctx->ring\_sock->sk;- struct sk\_buff\_head list, \*head = &sock->sk\_receive\_queue;- struct sk\_buff \*skb;- int i;-- \_\_skb\_queue\_head\_init(&list);-- /\*- \* Find the skb that holds this file in its SCM\_RIGHTS. When found,- \* remove this entry and rearrange the file array.- \*/- skb = skb\_dequeue(head);- while (skb) {- struct scm\_fp\_list \*fp;-- fp = UNIXCB(skb).fp;- for (i = 0; i < fp->count; i++) {- int left;-- if (fp->fp[i] != file)- continue;-- unix\_notinflight(fp->user, fp->fp[i]);- left = fp->count - 1 - i;- if (left) {- memmove(&fp->fp[i], &fp->fp[i + 1],- left \* sizeof(struct file \*));- }- fp->count--;- if (!fp->count) {- kfree\_skb(skb);- skb = NULL;- } else {- \_\_skb\_queue\_tail(&list, skb);- }- fput(file);- file = NULL;- break;- }-- if (!file)- break;-- \_\_skb\_queue\_tail(&list, skb);-- skb = skb\_dequeue(head);- }-- if (skb\_peek(&list)) {- spin\_lock\_irq(&head->lock);- while ((skb = \_\_skb\_dequeue(&list)) != NULL)- \_\_skb\_queue\_tail(head, skb);- spin\_unlock\_irq(&head->lock);- }-#endif-}--static void io\_rsrc\_file\_put(struct io\_ring\_ctx \*ctx, struct io\_rsrc\_put \*prsrc)-{- struct file \*file = prsrc->file;-- if (likely(!io\_file\_need\_scm(file)))- fput(file);- else- io\_rsrc\_file\_scm\_put(ctx, file);-}- int io\_sqe\_files\_register(struct io\_ring\_ctx \*ctx, void \_\_user \*arg, unsigned nr\_args, u64 \_\_user \*tags) {@@ -897,21 +745,12 @@ int io\_sqe\_files\_register(struct io\_ring\_ctx \*ctx, void \_\_user \*arg, goto fail;  /\*- \* Don't allow io\_uring instances to be registered. If UNIX- \* isn't enabled, then this causes a reference cycle and this- \* instance can never get freed. If UNIX is enabled we'll- \* handle it just fine, but there's still no point in allowing- \* a ring fd as it doesn't support regular read/write anyway.+ \* Don't allow io\_uring instances to be registered. \*/ if (io\_is\_uring\_fops(file)) { fput(file); goto fail; }- ret = io\_scm\_file\_account(ctx, file);- if (ret) {- fput(file);- goto fail;- } file\_slot = io\_fixed\_file\_slot(&ctx->file\_table, i); io\_fixed\_file\_set(file\_slot, file); io\_file\_bitmap\_set(&ctx->file\_table, i);diff --git a/io\_uring/rsrc.h b/io\_uring/rsrc.hindex 08ac0d8e07ef84..7238b9cfe33b60 100644--- a/[io\_uring/rsrc.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/rsrc.h?id=f3ee556f307e8310b37458f97a3b38f5ea965e2e)+++ b/[io\_uring/rsrc.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/rsrc.h?id=88c49d9c896143cdc0f77197c4dcf24140375e89)@@ -75,21 +75,6 @@ int io\_sqe\_files\_unregister(struct io\_ring\_ctx \*ctx); int io\_sqe\_files\_register(struct io\_ring\_ctx \*ctx, void \_\_user \*arg, unsigned nr\_args, u64 \_\_user \*tags); -int \_\_io\_scm\_file\_account(struct io\_ring\_ctx \*ctx, struct file \*file);--static inline bool io\_file\_need\_scm(struct file \*filp)-{- return false;-}--static inline int io\_scm\_file\_account(struct io\_ring\_ctx \*ctx,- struct file \*file)-{- if (likely(!io\_file\_need\_scm(file)))- return 0;- return \_\_io\_scm\_file\_account(ctx, file);-}- int io\_register\_files\_update(struct io\_ring\_ctx \*ctx, void \_\_user \*arg, unsigned nr\_args); int io\_register\_rsrc\_update(struct io\_ring\_ctx \*ctx, void \_\_user \*arg, |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 22:32:37 +0000



=== Content from lists.debian.org_2d5de243_20250110_223403.html ===


---

[[Date Prev](msg00016.html)][[Date Next](msg00018.html)]
[[Thread Prev](msg00016.html)][[Thread Next](msg00018.html)]
[[Date Index](maillist.html#00017)]
[[Thread Index](threads.html#00017)]

# [SECURITY] [DLA 3842-1] linux-5.10 security update

---

* *To*: debian-lts-announce@lists.debian.org
* *Subject*: [SECURITY] [DLA 3842-1] linux-5.10 security update
* *From*: Ben Hutchings <benh@debian.org>
* *Date*: Tue, 25 Jun 2024 21:41:47 +0200
* *Message-id*: <[[🔎]](/msgid-search/Znsdeycap_uaG_xM%40decadent.org.uk) [Znsdeycap\_uaG\_xM@decadent.org.uk](msg00017.html)>
* *Mail-followup-to*: debian-lts@lists.debian.org
* *Reply-to*: debian-lts@lists.debian.org

---

```
-------------------------------------------------------------------------
Debian LTS Advisory DLA-3842-1                debian-lts@lists.debian.org
<https://www.debian.org/lts/security/>                        Ben Hutchings
June 25, 2024                                 <https://wiki.debian.org/LTS>
-------------------------------------------------------------------------

Package        : linux-5.10
Version        : 5.10.216-1~deb10u1
CVE ID         : CVE-2022-38096 CVE-2023-6270 CVE-2023-7042 CVE-2023-28746
                 CVE-2023-47233 CVE-2023-52429 CVE-2023-52434 CVE-2023-52435
                 CVE-2023-52447 CVE-2023-52458 CVE-2023-52482 CVE-2023-52486
                 CVE-2023-52488 CVE-2023-52489 CVE-2023-52491 CVE-2023-52492
                 CVE-2023-52493 CVE-2023-52497 CVE-2023-52498 CVE-2023-52583
                 CVE-2023-52587 CVE-2023-52594 CVE-2023-52595 CVE-2023-52597
                 CVE-2023-52598 CVE-2023-52599 CVE-2023-52600 CVE-2023-52601
                 CVE-2023-52602 CVE-2023-52603 CVE-2023-52604 CVE-2023-52606
                 CVE-2023-52607 CVE-2023-52614 CVE-2023-52615 CVE-2023-52616
                 CVE-2023-52617 CVE-2023-52618 CVE-2023-52619 CVE-2023-52620
                 CVE-2023-52622 CVE-2023-52623 CVE-2023-52627 CVE-2023-52635
                 CVE-2023-52637 CVE-2023-52642 CVE-2023-52644 CVE-2023-52650
                 CVE-2023-52656 CVE-2023-52669 CVE-2023-52670 CVE-2023-52672
                 CVE-2023-52699 CVE-2023-52880 CVE-2024-0340 CVE-2024-0565
                 CVE-2024-0607 CVE-2024-0841 CVE-2024-1151 CVE-2024-22099
                 CVE-2024-23849 CVE-2024-23850 CVE-2024-23851 CVE-2024-24857
                 CVE-2024-24858 CVE-2024-24861 CVE-2024-25739 CVE-2024-26581
                 CVE-2024-26593 CVE-2024-26600 CVE-2024-26601 CVE-2024-26602
                 CVE-2024-26606 CVE-2024-26610 CVE-2024-26614 CVE-2024-26615
                 CVE-2024-26622 CVE-2024-26625 CVE-2024-26627 CVE-2024-26635
                 CVE-2024-26636 CVE-2024-26640 CVE-2024-26641 CVE-2024-26642
                 CVE-2024-26643 CVE-2024-26644 CVE-2024-26645 CVE-2024-26651
                 CVE-2024-26654 CVE-2024-26659 CVE-2024-26663 CVE-2024-26664
                 CVE-2024-26665 CVE-2024-26671 CVE-2024-26673 CVE-2024-26675
                 CVE-2024-26679 CVE-2024-26684 CVE-2024-26685 CVE-2024-26687
                 CVE-2024-26688 CVE-2024-26689 CVE-2024-26695 CVE-2024-26696
                 CVE-2024-26697 CVE-2024-26698 CVE-2024-26702 CVE-2024-26704
                 CVE-2024-26707 CVE-2024-26712 CVE-2024-26720 CVE-2024-26722
                 CVE-2024-26727 CVE-2024-26733 CVE-2024-26735 CVE-2024-26736
                 CVE-2024-26743 CVE-2024-26744 CVE-2024-26747 CVE-2024-26748
                 CVE-2024-26749 CVE-2024-26751 CVE-2024-26752 CVE-2024-26753
                 CVE-2024-26754 CVE-2024-26763 CVE-2024-26764 CVE-2024-26766
                 CVE-2024-26771 CVE-2024-26772 CVE-2024-26773 CVE-2024-26776
                 CVE-2024-26777 CVE-2024-26778 CVE-2024-26779 CVE-2024-26781
                 CVE-2024-26782 CVE-2024-26787 CVE-2024-26788 CVE-2024-26790
                 CVE-2024-26791 CVE-2024-26793 CVE-2024-26795 CVE-2024-26801
                 CVE-2024-26804 CVE-2024-26805 CVE-2024-26808 CVE-2024-26809
                 CVE-2024-26810 CVE-2024-26812 CVE-2024-26813 CVE-2024-26814
                 CVE-2024-26816 CVE-2024-26817 CVE-2024-26820 CVE-2024-26825
                 CVE-2024-26833 CVE-2024-26835 CVE-2024-26839 CVE-2024-26840
                 CVE-2024-26843 CVE-2024-26845 CVE-2024-26846 CVE-2024-26848
                 CVE-2024-26851 CVE-2024-26852 CVE-2024-26855 CVE-2024-26857
                 CVE-2024-26859 CVE-2024-26861 CVE-2024-26862 CVE-2024-26863
                 CVE-2024-26870 CVE-2024-26872 CVE-2024-26874 CVE-2024-26875
                 CVE-2024-26877 CVE-2024-26878 CVE-2024-26880 CVE-2024-26882
                 CVE-2024-26883 CVE-2024-26884 CVE-2024-26885 CVE-2024-26889
                 CVE-2024-26891 CVE-2024-26894 CVE-2024-26895 CVE-2024-26897
                 CVE-2024-26898 CVE-2024-26901 CVE-2024-26903 CVE-2024-26906
                 CVE-2024-26907 CVE-2024-26910 CVE-2024-26917 CVE-2024-26922
                 CVE-2024-26923 CVE-2024-26924 CVE-2024-26925 CVE-2024-26926
                 CVE-2024-26931 CVE-2024-26934 CVE-2024-26935 CVE-2024-26937
                 CVE-2024-26950 CVE-2024-26951 CVE-2024-26955 CVE-2024-26956
                 CVE-2024-26957 CVE-2024-26958 CVE-2024-26960 CVE-2024-26961
                 CVE-2024-26965 CVE-2024-26966 CVE-2024-26969 CVE-2024-26970
                 CVE-2024-26973 CVE-2024-26974 CVE-2024-26976 CVE-2024-26978
                 CVE-2024-26981 CVE-2024-26984 CVE-2024-26988 CVE-2024-26993
                 CVE-2024-26994 CVE-2024-26997 CVE-2024-26999 CVE-2024-27000
                 CVE-2024-27001 CVE-2024-27004 CVE-2024-27008 CVE-2024-27013
                 CVE-2024-27020 CVE-2024-27024 CVE-2024-27025 CVE-2024-27028
                 CVE-2024-27030 CVE-2024-27038 CVE-2024-27043 CVE-2024-27044
                 CVE-2024-27045 CVE-2024-27046 CVE-2024-27047 CVE-2024-27051
                 CVE-2024-27052 CVE-2024-27053 CVE-2024-27059 CVE-2024-27065
                 CVE-2024-27073 CVE-2024-27074 CVE-2024-27075 CVE-2024-27076
                 CVE-2024-27077 CVE-2024-27078 CVE-2024-27388 CVE-2024-27395
                 CVE-2024-27396 CVE-2024-27405 CVE-2024-27410 CVE-2024-27412
                 CVE-2024-27413 CVE-2024-27414 CVE-2024-27416 CVE-2024-27417
                 CVE-2024-27419 CVE-2024-27431 CVE-2024-27436 CVE-2024-27437
                 CVE-2024-35785 CVE-2024-35789 CVE-2024-35791 CVE-2024-35796
                 CVE-2024-35805 CVE-2024-35806 CVE-2024-35807 CVE-2024-35809
                 CVE-2024-35811 CVE-2024-35813 CVE-2024-35815 CVE-2024-35819
                 CVE-2024-35821 CVE-2024-35822 CVE-2024-35823 CVE-2024-35825
                 CVE-2024-35828 CVE-2024-35829 CVE-2024-35830 CVE-2024-35833
                 CVE-2024-35835 CVE-2024-35837 CVE-2024-35845 CVE-2024-35847
                 CVE-2024-35849 CVE-2024-35852 CVE-2024-35853 CVE-2024-35854
                 CVE-2024-35855 CVE-2024-35871 CVE-2024-35877 CVE-2024-35879
                 CVE-2024-35884 CVE-2024-35886 CVE-2024-35888 CVE-2024-35893
                 CVE-2024-35895 CVE-2024-35896 CVE-2024-35897 CVE-2024-35898
                 CVE-2024-35899 CVE-2024-35900 CVE-2024-35902 CVE-2024-35905
                 CVE-2024-35910 CVE-2024-35915 CVE-2024-35922 CVE-2024-35925
                 CVE-2024-35930 CVE-2024-35933 CVE-2024-35934 CVE-2024-35935
                 CVE-2024-35936 CVE-2024-35940 CVE-2024-35944 CVE-2024-35950
                 CVE-2024-35955 CVE-2024-35958 CVE-2024-35960 CVE-2024-35962
                 CVE-2024-35967 CVE-2024-35969 CVE-2024-35973 CVE-2024-35976
                 CVE-2024-35978 CVE-2024-35982 CVE-2024-35983 CVE-2024-35984
                 CVE-2024-35988 CVE-2024-35990 CVE-2024-35996 CVE-2024-35997
                 CVE-2024-36004 CVE-2024-36005 CVE-2024-36006 CVE-2024-36007
                 CVE-2024-36008 CVE-2024-36020
Debian Bug     : 1064035

Several vulnerabilities were discovered in the Linux kernel that may
lead to a privilege escalation, denial of service or information
leaks.

For Debian 10 buster, these problems were fixed earlier in version
5.10.216-1~deb10u1.  This update also fixed a regression in kernel
documentation generation, and included many more bug fixes from stable
updates 5.10.210-5.10.216 inclusive.

For the detailed security status of linux-5.10 please refer to
its security tracker page at:
<https://security-tracker.debian.org/tracker/linux-5.10>

Further information about Debian LTS security advisories, how to apply
these updates to your system and frequently asked questions can be
found at: <https://wiki.debian.org/LTS>

```

**Attachment:
[signature.asc](pgpvh8SL4z3oF.pgp)**

*Description:* PGP signature

---



=== Content from git.kernel.org_8f674b7c_20250110_223401.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jens Axboe <axboe@kernel.dk> | 2024-03-13 18:15:05 -0600 |
| --- | --- | --- |
| committer | Sasha Levin <sashal@kernel.org> | 2024-03-26 18:20:22 -0400 |
| commit | [a3812a47a32022ca76bf46ddacdd823dc2aabf8b](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b)) | |
| tree | [b7ebee07de035b1ac9934fd96d01e77dff43e444](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b) | |
| parent | [28fe81bcd3ea932e280f04e087ff0c75a4995a46](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=28fe81bcd3ea932e280f04e087ff0c75a4995a46) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b&id2=28fe81bcd3ea932e280f04e087ff0c75a4995a46)) | |
| download | [linux-a3812a47a32022ca76bf46ddacdd823dc2aabf8b.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-a3812a47a32022ca76bf46ddacdd823dc2aabf8b.tar.gz) | |

io\_uring: drop any code related to SCM\_RIGHTSCommit 6e5e6d274956305f1fc0340522b38f5f5be74bdb upstream.
This is dead code after we dropped support for passing io\_uring fds
over SCM\_RIGHTS, get rid of it.
Signed-off-by: Jens Axboe <axboe@kernel.dk>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b)

| -rw-r--r-- | [include/linux/io\_uring\_types.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/io_uring_types.h?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b) | 3 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [io\_uring/filetable.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/io_uring/filetable.c?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b) | 10 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [io\_uring/io\_uring.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/io_uring/io_uring.c?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b) | 31 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [io\_uring/rsrc.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/io_uring/rsrc.c?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b) | 151 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [io\_uring/rsrc.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/io_uring/rsrc.h?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b) | 15 | |  |  |  | | --- | --- | --- | |

5 files changed, 8 insertions, 202 deletions

| diff --git a/include/linux/io\_uring\_types.h b/include/linux/io\_uring\_types.hindex f5b687a787a34d..37aeea266ebb32 100644--- a/[include/linux/io\_uring\_types.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/io_uring_types.h?id=28fe81bcd3ea932e280f04e087ff0c75a4995a46)+++ b/[include/linux/io\_uring\_types.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/io_uring_types.h?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b)@@ -330,9 +330,6 @@ struct io\_ring\_ctx {  struct list\_head io\_buffers\_pages; - #if defined(CONFIG\_UNIX)- struct socket \*ring\_sock;- #endif /\* hashed buffered write serialization \*/ struct io\_wq\_hash \*hash\_map; diff --git a/io\_uring/filetable.c b/io\_uring/filetable.cindex b80614e7d60511..4660cb89ea9f52 100644--- a/[io\_uring/filetable.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/filetable.c?id=28fe81bcd3ea932e280f04e087ff0c75a4995a46)+++ b/[io\_uring/filetable.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/filetable.c?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b)@@ -95,12 +95,10 @@ static int io\_install\_fixed\_file(struct io\_ring\_ctx \*ctx, struct file \*file, needs\_switch = true; } - ret = io\_scm\_file\_account(ctx, file);- if (!ret) {- \*io\_get\_tag\_slot(ctx->file\_data, slot\_index) = 0;- io\_fixed\_file\_set(file\_slot, file);- io\_file\_bitmap\_set(&ctx->file\_table, slot\_index);- }+ \*io\_get\_tag\_slot(ctx->file\_data, slot\_index) = 0;+ io\_fixed\_file\_set(file\_slot, file);+ io\_file\_bitmap\_set(&ctx->file\_table, slot\_index);+ return 0; err: if (needs\_switch) io\_rsrc\_node\_switch(ctx, ctx->file\_data);diff --git a/io\_uring/io\_uring.c b/io\_uring/io\_uring.cindex cf7dd62da0e371..415248c1f82c6f 100644--- a/[io\_uring/io\_uring.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/io_uring.c?id=28fe81bcd3ea932e280f04e087ff0c75a4995a46)+++ b/[io\_uring/io\_uring.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/io_uring.c?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b)@@ -60,7 +60,6 @@ #include <linux/net.h> #include <net/sock.h> #include <net/af\_unix.h>-#include <net/scm.h> #include <linux/anon\_inodes.h> #include <linux/sched/mm.h> #include <linux/uaccess.h>@@ -2628,12 +2627,6 @@ static \_\_cold void io\_ring\_ctx\_free(struct io\_ring\_ctx \*ctx) WARN\_ON\_ONCE(!list\_empty(&ctx->rsrc\_ref\_list)); WARN\_ON\_ONCE(!llist\_empty(&ctx->rsrc\_put\_llist)); -#if defined(CONFIG\_UNIX)- if (ctx->ring\_sock) {- ctx->ring\_sock->file = NULL; /\* so that iput() is called \*/- sock\_release(ctx->ring\_sock);- }-#endif WARN\_ON\_ONCE(!list\_empty(&ctx->ltimeout\_list));  if (ctx->mm\_account) {@@ -3438,32 +3431,12 @@ static int io\_uring\_install\_fd(struct io\_ring\_ctx \*ctx, struct file \*file) /\* \* Allocate an anonymous fd, this is what constitutes the application \* visible backing of an io\_uring instance. The application mmaps this- \* fd to gain access to the SQ/CQ ring details. If UNIX sockets are enabled,- \* we have to tie this fd to a socket for file garbage collection purposes.+ \* fd to gain access to the SQ/CQ ring details. \*/ static struct file \*io\_uring\_get\_file(struct io\_ring\_ctx \*ctx) {- struct file \*file;-#if defined(CONFIG\_UNIX)- int ret;-- ret = sock\_create\_kern(&init\_net, PF\_UNIX, SOCK\_RAW, IPPROTO\_IP,- &ctx->ring\_sock);- if (ret)- return ERR\_PTR(ret);-#endif-- file = anon\_inode\_getfile\_secure("[io\_uring]", &io\_uring\_fops, ctx,+ return anon\_inode\_getfile\_secure("[io\_uring]", &io\_uring\_fops, ctx, O\_RDWR | O\_CLOEXEC, NULL);-#if defined(CONFIG\_UNIX)- if (IS\_ERR(file)) {- sock\_release(ctx->ring\_sock);- ctx->ring\_sock = NULL;- } else {- ctx->ring\_sock->file = file;- }-#endif- return file; }  static \_\_cold int io\_uring\_create(unsigned entries, struct io\_uring\_params \*p,diff --git a/io\_uring/rsrc.c b/io\_uring/rsrc.cindex 7ada0339b38705..ac658cfa89c63c 100644--- a/[io\_uring/rsrc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/rsrc.c?id=28fe81bcd3ea932e280f04e087ff0c75a4995a46)+++ b/[io\_uring/rsrc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/rsrc.c?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b)@@ -494,11 +494,6 @@ static int \_\_io\_sqe\_files\_update(struct io\_ring\_ctx \*ctx, err = -EBADF; break; }- err = io\_scm\_file\_account(ctx, file);- if (err) {- fput(file);- break;- } \*io\_get\_tag\_slot(data, i) = tag; io\_fixed\_file\_set(file\_slot, file); io\_file\_bitmap\_set(&ctx->file\_table, i);@@ -762,22 +757,12 @@ void \_\_io\_sqe\_files\_unregister(struct io\_ring\_ctx \*ctx) for (i = 0; i < ctx->nr\_user\_files; i++) { struct file \*file = io\_file\_from\_index(&ctx->file\_table, i); - /\* skip scm accounted files, they'll be freed by ->ring\_sock \*/- if (!file || io\_file\_need\_scm(file))+ if (!file) continue; io\_file\_bitmap\_clear(&ctx->file\_table, i); fput(file); } -#if defined(CONFIG\_UNIX)- if (ctx->ring\_sock) {- struct sock \*sock = ctx->ring\_sock->sk;- struct sk\_buff \*skb;-- while ((skb = skb\_dequeue(&sock->sk\_receive\_queue)) != NULL)- kfree\_skb(skb);- }-#endif io\_free\_file\_tables(&ctx->file\_table); io\_file\_table\_set\_alloc\_range(ctx, 0, 0); io\_rsrc\_data\_free(ctx->file\_data);@@ -805,134 +790,11 @@ int io\_sqe\_files\_unregister(struct io\_ring\_ctx \*ctx) return ret; } -/\*- \* Ensure the UNIX gc is aware of our file set, so we are certain that- \* the io\_uring can be safely unregistered on process exit, even if we have- \* loops in the file referencing. We account only files that can hold other- \* files because otherwise they can't form a loop and so are not interesting- \* for GC.- \*/-int \_\_io\_scm\_file\_account(struct io\_ring\_ctx \*ctx, struct file \*file)-{-#if defined(CONFIG\_UNIX)- struct sock \*sk = ctx->ring\_sock->sk;- struct sk\_buff\_head \*head = &sk->sk\_receive\_queue;- struct scm\_fp\_list \*fpl;- struct sk\_buff \*skb;-- if (likely(!io\_file\_need\_scm(file)))- return 0;-- /\*- \* See if we can merge this file into an existing skb SCM\_RIGHTS- \* file set. If there's no room, fall back to allocating a new skb- \* and filling it in.- \*/- spin\_lock\_irq(&head->lock);- skb = skb\_peek(head);- if (skb && UNIXCB(skb).fp->count < SCM\_MAX\_FD)- \_\_skb\_unlink(skb, head);- else- skb = NULL;- spin\_unlock\_irq(&head->lock);-- if (!skb) {- fpl = kzalloc(sizeof(\*fpl), GFP\_KERNEL);- if (!fpl)- return -ENOMEM;-- skb = alloc\_skb(0, GFP\_KERNEL);- if (!skb) {- kfree(fpl);- return -ENOMEM;- }-- fpl->user = get\_uid(current\_user());- fpl->max = SCM\_MAX\_FD;- fpl->count = 0;-- UNIXCB(skb).fp = fpl;- skb->sk = sk;- skb->scm\_io\_uring = 1;- skb->destructor = unix\_destruct\_scm;- refcount\_add(skb->truesize, &sk->sk\_wmem\_alloc);- }-- fpl = UNIXCB(skb).fp;- fpl->fp[fpl->count++] = get\_file(file);- unix\_inflight(fpl->user, file);- skb\_queue\_head(head, skb);- fput(file);-#endif- return 0;-}- static void io\_rsrc\_file\_put(struct io\_ring\_ctx \*ctx, struct io\_rsrc\_put \*prsrc) { struct file \*file = prsrc->file;-#if defined(CONFIG\_UNIX)- struct sock \*sock = ctx->ring\_sock->sk;- struct sk\_buff\_head list, \*head = &sock->sk\_receive\_queue;- struct sk\_buff \*skb;- int i;-- if (!io\_file\_need\_scm(file)) {- fput(file);- return;- }-- \_\_skb\_queue\_head\_init(&list);-- /\*- \* Find the skb that holds this file in its SCM\_RIGHTS. When found,- \* remove this entry and rearrange the file array.- \*/- skb = skb\_dequeue(head);- while (skb) {- struct scm\_fp\_list \*fp; - fp = UNIXCB(skb).fp;- for (i = 0; i < fp->count; i++) {- int left;-- if (fp->fp[i] != file)- continue;-- unix\_notinflight(fp->user, fp->fp[i]);- left = fp->count - 1 - i;- if (left) {- memmove(&fp->fp[i], &fp->fp[i + 1],- left \* sizeof(struct file \*));- }- fp->count--;- if (!fp->count) {- kfree\_skb(skb);- skb = NULL;- } else {- \_\_skb\_queue\_tail(&list, skb);- }- fput(file);- file = NULL;- break;- }-- if (!file)- break;-- \_\_skb\_queue\_tail(&list, skb);-- skb = skb\_dequeue(head);- }-- if (skb\_peek(&list)) {- spin\_lock\_irq(&head->lock);- while ((skb = \_\_skb\_dequeue(&list)) != NULL)- \_\_skb\_queue\_tail(head, skb);- spin\_unlock\_irq(&head->lock);- }-#else fput(file);-#endif }  int io\_sqe\_files\_register(struct io\_ring\_ctx \*ctx, void \_\_user \*arg,@@ -986,21 +848,12 @@ int io\_sqe\_files\_register(struct io\_ring\_ctx \*ctx, void \_\_user \*arg, goto fail;  /\*- \* Don't allow io\_uring instances to be registered. If UNIX- \* isn't enabled, then this causes a reference cycle and this- \* instance can never get freed. If UNIX is enabled we'll- \* handle it just fine, but there's still no point in allowing- \* a ring fd as it doesn't support regular read/write anyway.+ \* Don't allow io\_uring instances to be registered. \*/ if (io\_is\_uring\_fops(file)) { fput(file); goto fail; }- ret = io\_scm\_file\_account(ctx, file);- if (ret) {- fput(file);- goto fail;- } file\_slot = io\_fixed\_file\_slot(&ctx->file\_table, i); io\_fixed\_file\_set(file\_slot, file); io\_file\_bitmap\_set(&ctx->file\_table, i);diff --git a/io\_uring/rsrc.h b/io\_uring/rsrc.hindex acaf8dad054014..85f145607c6209 100644--- a/[io\_uring/rsrc.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/rsrc.h?id=28fe81bcd3ea932e280f04e087ff0c75a4995a46)+++ b/[io\_uring/rsrc.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/io_uring/rsrc.h?id=a3812a47a32022ca76bf46ddacdd823dc2aabf8b)@@ -77,21 +77,6 @@ int io\_sqe\_files\_unregister(struct io\_ring\_ctx \*ctx); int io\_sqe\_files\_register(struct io\_ring\_ctx \*ctx, void \_\_user \*arg, unsigned nr\_args, u64 \_\_user \*tags); -int \_\_io\_scm\_file\_account(struct io\_ring\_ctx \*ctx, struct file \*file);--static inline bool io\_file\_need\_scm(struct file \*filp)-{- return false;-}--static inline int io\_scm\_file\_account(struct io\_ring\_ctx \*ctx,- struct file \*file)-{- if (likely(!io\_file\_need\_scm(file)))- return 0;- return \_\_io\_scm\_file\_account(ctx, file);-}- int io\_register\_files\_update(struct io\_ring\_ctx \*ctx, void \_\_user \*arg, unsigned nr\_args); int io\_register\_rsrc\_update(struct io\_ring\_ctx \*ctx, void \_\_user \*arg, |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 22:32:38 +0000



=== Content from git.kernel.org_d63b3665_20250110_223402.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=cfb24022bb2c31f1f555dc6bc3cc5e2547446fb3)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=cfb24022bb2c31f1f555dc6bc3cc5e2547446fb3)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=cfb24022bb2c31f1f555dc6bc3cc5e2547446fb3)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=cfb24022bb2c31f1f555dc6bc3cc5e2547446fb3)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jens Axboe <axboe@kernel.dk> | 2024-03-13 18:36:18 -0600 |
| --- | --- | --- |
| committer | Sasha Levin <sashal@kernel.org> | 2024-03-26 18:22:12 -0400 |
| commit | [cfb24022bb2c31f1f555dc6bc3cc5e2547446fb3](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=cfb24022bb2c31f1f555dc6bc3cc5e2547446fb3) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=cfb24022bb2c31f1f555dc6bc3cc5e2547446fb3)) | |
| tree | [8479b861a171582ef2673482bdae8a61050208bd](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=cfb24022bb2c31f1f555dc6bc3cc5e2547446fb3) | |
| parent | [2692b8a01667275717b6737a0cbdf938c3018868](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=2692b8a01667275717b6737a0cbdf938c3018868) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=cfb24022bb2c31f1f555dc6bc3cc5e2547446fb3&id2=2692b8a01667275717b6737a0cbdf938c3018868)) | |
| download | [linux-cfb24022bb2c31f1f555dc6bc3cc5e2547446fb3.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-cfb24022bb2c31f1f555dc6bc3cc5e2547446fb3.tar.gz) | |

io\_uring: drop any code related to SCM\_RIGHTSCommit 6e5e6d274956305f1fc0340522b38f5f5be74bdb upstream.
This is dead code after we dropped support for passing io\_uring fds
over SCM\_RIGHTS, get rid of it.
Signed-off-by: Jens Axboe <axboe@kernel.dk>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=cfb24022bb2c31f1f555dc6bc3cc5e2547446fb3)

| -rw-r--r-- | [fs/io\_uring.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/io_uring.c?id=cfb24022bb2c31f1f555dc6bc3cc5e2547446fb3) | 47 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 3 insertions, 44 deletions

| diff --git a/fs/io\_uring.c b/fs/io\_uring.cindex cd1858cc632069..2c793e4ccf096b 100644--- a/[fs/io\_uring.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=2692b8a01667275717b6737a0cbdf938c3018868)+++ b/[fs/io\_uring.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=cfb24022bb2c31f1f555dc6bc3cc5e2547446fb3)@@ -63,7 +63,6 @@ #include <linux/net.h> #include <net/sock.h> #include <net/af\_unix.h>-#include <net/scm.h> #include <linux/anon\_inodes.h> #include <linux/sched/mm.h> #include <linux/uaccess.h>@@ -264,10 +263,6 @@ struct io\_ring\_ctx {  struct async\_list pending\_async[2]; -#if defined(CONFIG\_UNIX)- struct socket \*ring\_sock;-#endif- struct list\_head task\_list; spinlock\_t task\_lock; };@@ -3067,20 +3062,10 @@ static int io\_cqring\_wait(struct io\_ring\_ctx \*ctx, int min\_events,  static void \_\_io\_sqe\_files\_unregister(struct io\_ring\_ctx \*ctx) {-#if defined(CONFIG\_UNIX)- if (ctx->ring\_sock) {- struct sock \*sock = ctx->ring\_sock->sk;- struct sk\_buff \*skb;-- while ((skb = skb\_dequeue(&sock->sk\_receive\_queue)) != NULL)- kfree\_skb(skb);- }-#else int i;  for (i = 0; i < ctx->nr\_user\_files; i++) fput(ctx->user\_files[i]);-#endif }  static int io\_sqe\_files\_unregister(struct io\_ring\_ctx \*ctx)@@ -3575,13 +3560,6 @@ static void io\_ring\_ctx\_free(struct io\_ring\_ctx \*ctx) io\_sqe\_files\_unregister(ctx); io\_eventfd\_unregister(ctx); -#if defined(CONFIG\_UNIX)- if (ctx->ring\_sock) {- ctx->ring\_sock->file = NULL; /\* so that iput() is called \*/- sock\_release(ctx->ring\_sock);- }-#endif- io\_mem\_free(ctx->rings); io\_mem\_free(ctx->sq\_sqes); @@ -3833,45 +3811,26 @@ static int io\_allocate\_scq\_urings(struct io\_ring\_ctx \*ctx, /\* \* Allocate an anonymous fd, this is what constitutes the application \* visible backing of an io\_uring instance. The application mmaps this- \* fd to gain access to the SQ/CQ ring details. If UNIX sockets are enabled,- \* we have to tie this fd to a socket for file garbage collection purposes.+ \* fd to gain access to the SQ/CQ ring details. \*/ static int io\_uring\_get\_fd(struct io\_ring\_ctx \*ctx) { struct file \*file; int ret; -#if defined(CONFIG\_UNIX)- ret = sock\_create\_kern(&init\_net, PF\_UNIX, SOCK\_RAW, IPPROTO\_IP,- &ctx->ring\_sock);- if (ret)- return ret;-#endif- ret = get\_unused\_fd\_flags(O\_RDWR | O\_CLOEXEC); if (ret < 0)- goto err;+ return ret;  file = anon\_inode\_getfile("[io\_uring]", &io\_uring\_fops, ctx, O\_RDWR | O\_CLOEXEC); if (IS\_ERR(file)) { put\_unused\_fd(ret);- ret = PTR\_ERR(file);- goto err;+ return PTR\_ERR(file); } -#if defined(CONFIG\_UNIX)- ctx->ring\_sock->file = file;- ctx->ring\_sock->sk->sk\_user\_data = ctx;-#endif fd\_install(ret, file); return ret;-err:-#if defined(CONFIG\_UNIX)- sock\_release(ctx->ring\_sock);- ctx->ring\_sock = NULL;-#endif- return ret; }  static int io\_uring\_create(unsigned entries, struct io\_uring\_params \*p) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 22:32:39 +0000


