

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=27ca3e20fe80be85a92b10064dfeb56cb2564b1c)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=27ca3e20fe80be85a92b10064dfeb56cb2564b1c)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=27ca3e20fe80be85a92b10064dfeb56cb2564b1c)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=27ca3e20fe80be85a92b10064dfeb56cb2564b1c)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Xu Kuohai <xukuohai@huawei.com> | 2024-07-19 19:00:52 +0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-10-04 16:37:52 +0200 |
| commit | [27ca3e20fe80be85a92b10064dfeb56cb2564b1c](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=27ca3e20fe80be85a92b10064dfeb56cb2564b1c) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=27ca3e20fe80be85a92b10064dfeb56cb2564b1c)) | |
| tree | [a7485645071da387802a0faea7130fb612cba7a5](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=27ca3e20fe80be85a92b10064dfeb56cb2564b1c) | |
| parent | [ffe19d48b0c3230b678a2f66d10233b3699e95b0](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ffe19d48b0c3230b678a2f66d10233b3699e95b0) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=27ca3e20fe80be85a92b10064dfeb56cb2564b1c&id2=ffe19d48b0c3230b678a2f66d10233b3699e95b0)) | |
| download | [linux-27ca3e20fe80be85a92b10064dfeb56cb2564b1c.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-27ca3e20fe80be85a92b10064dfeb56cb2564b1c.tar.gz) | |

bpf, lsm: Add check for BPF LSM return value[ Upstream commit 5d99e198be279045e6ecefe220f5c52f8ce9bfd5 ]
A bpf prog returning a positive number attached to file\_alloc\_security
hook makes kernel panic.
This happens because file system can not filter out the positive number
returned by the LSM prog using IS\_ERR, and misinterprets this positive
number as a file pointer.
Given that hook file\_alloc\_security never returned positive number
before the introduction of BPF LSM, and other BPF LSM hooks may
encounter similar issues, this patch adds LSM return value check
in verifier, to ensure no unexpected value is returned.
Fixes: 520b7aa00d8c ("bpf: lsm: Initialize the BPF LSM hooks")
Reported-by: Xin Liu <liuxin350@huawei.com>
Signed-off-by: Xu Kuohai <xukuohai@huawei.com>
Acked-by: Eduard Zingerman <eddyz87@gmail.com>
Link: [https://lore.kernel.org/r/20240719110059.797546-3-xukuohai@huaweicloud.com](https://lore.kernel.org/r/20240719110059.797546-3-xukuohai%40huaweicloud.com)
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Signed-off-by: Andrii Nakryiko <andrii@kernel.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=27ca3e20fe80be85a92b10064dfeb56cb2564b1c)

| -rw-r--r-- | [include/linux/bpf.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/bpf.h?id=27ca3e20fe80be85a92b10064dfeb56cb2564b1c) | 1 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/linux/bpf\_lsm.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/bpf_lsm.h?id=27ca3e20fe80be85a92b10064dfeb56cb2564b1c) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/bpf/bpf\_lsm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/bpf/bpf_lsm.c?id=27ca3e20fe80be85a92b10064dfeb56cb2564b1c) | 34 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/bpf/btf.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/bpf/btf.c?id=27ca3e20fe80be85a92b10064dfeb56cb2564b1c) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/bpf/verifier.c?id=27ca3e20fe80be85a92b10064dfeb56cb2564b1c) | 60 | |  |  |  | | --- | --- | --- | |

5 files changed, 97 insertions, 11 deletions

| diff --git a/include/linux/bpf.h b/include/linux/bpf.hindex 3b94ec161e8ccf..71ccd39011ed0f 100644--- a/[include/linux/bpf.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/bpf.h?id=ffe19d48b0c3230b678a2f66d10233b3699e95b0)+++ b/[include/linux/bpf.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/bpf.h?id=27ca3e20fe80be85a92b10064dfeb56cb2564b1c)@@ -927,6 +927,7 @@ struct bpf\_insn\_access\_aux { }; }; struct bpf\_verifier\_log \*log; /\* for verbose logs \*/+ bool is\_retval; /\* is accessing function return value ? \*/ };  static inline voiddiff --git a/include/linux/bpf\_lsm.h b/include/linux/bpf\_lsm.hindex 1de7ece5d36d43..aefcd656425126 100644--- a/[include/linux/bpf\_lsm.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/bpf_lsm.h?id=ffe19d48b0c3230b678a2f66d10233b3699e95b0)+++ b/[include/linux/bpf\_lsm.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/bpf_lsm.h?id=27ca3e20fe80be85a92b10064dfeb56cb2564b1c)@@ -9,6 +9,7 @@  #include <linux/sched.h> #include <linux/bpf.h>+#include <linux/bpf\_verifier.h> #include <linux/lsm\_hooks.h>  #ifdef CONFIG\_BPF\_LSM@@ -45,6 +46,8 @@ void bpf\_inode\_storage\_free(struct inode \*inode);  void bpf\_lsm\_find\_cgroup\_shim(const struct bpf\_prog \*prog, bpf\_func\_t \*bpf\_func); +int bpf\_lsm\_get\_retval\_range(const struct bpf\_prog \*prog,+ struct bpf\_retval\_range \*range); #else /\* !CONFIG\_BPF\_LSM \*/  static inline bool bpf\_lsm\_is\_sleepable\_hook(u32 btf\_id)@@ -78,6 +81,11 @@ static inline void bpf\_lsm\_find\_cgroup\_shim(const struct bpf\_prog \*prog, { } +static inline int bpf\_lsm\_get\_retval\_range(const struct bpf\_prog \*prog,+ struct bpf\_retval\_range \*range)+{+ return -EOPNOTSUPP;+} #endif /\* CONFIG\_BPF\_LSM \*/  #endif /\* \_LINUX\_BPF\_LSM\_H \*/diff --git a/kernel/bpf/bpf\_lsm.c b/kernel/bpf/bpf\_lsm.cindex 08a338e1f23114..701092736826ad 100644--- a/[kernel/bpf/bpf\_lsm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/bpf_lsm.c?id=ffe19d48b0c3230b678a2f66d10233b3699e95b0)+++ b/[kernel/bpf/bpf\_lsm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/bpf_lsm.c?id=27ca3e20fe80be85a92b10064dfeb56cb2564b1c)@@ -11,7 +11,6 @@ #include <linux/lsm\_hooks.h> #include <linux/bpf\_lsm.h> #include <linux/kallsyms.h>-#include <linux/bpf\_verifier.h> #include <net/bpf\_sk\_storage.h> #include <linux/bpf\_local\_storage.h> #include <linux/btf\_ids.h>@@ -390,3 +389,36 @@ const struct bpf\_verifier\_ops lsm\_verifier\_ops = { .get\_func\_proto = bpf\_lsm\_func\_proto, .is\_valid\_access = btf\_ctx\_access, };++/\* hooks return 0 or 1 \*/+BTF\_SET\_START(bool\_lsm\_hooks)+#ifdef CONFIG\_SECURITY\_NETWORK\_XFRM+BTF\_ID(func, bpf\_lsm\_xfrm\_state\_pol\_flow\_match)+#endif+#ifdef CONFIG\_AUDIT+BTF\_ID(func, bpf\_lsm\_audit\_rule\_known)+#endif+BTF\_ID(func, bpf\_lsm\_inode\_xattr\_skipcap)+BTF\_SET\_END(bool\_lsm\_hooks)++int bpf\_lsm\_get\_retval\_range(const struct bpf\_prog \*prog,+ struct bpf\_retval\_range \*retval\_range)+{+ /\* no return value range for void hooks \*/+ if (!prog->aux->attach\_func\_proto->type)+ return -EINVAL;++ if (btf\_id\_set\_contains(&bool\_lsm\_hooks, prog->aux->attach\_btf\_id)) {+ retval\_range->minval = 0;+ retval\_range->maxval = 1;+ } else {+ /\* All other available LSM hooks, except task\_prctl, return 0+ \* on success and negative error code on failure.+ \* To keep things simple, we only allow bpf progs to return 0+ \* or negative errno for task\_prctl too.+ \*/+ retval\_range->minval = -MAX\_ERRNO;+ retval\_range->maxval = 0;+ }+ return 0;+}diff --git a/kernel/bpf/btf.c b/kernel/bpf/btf.cindex a4e4f8d43ecf04..249c94c9961505 100644--- a/[kernel/bpf/btf.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/btf.c?id=ffe19d48b0c3230b678a2f66d10233b3699e95b0)+++ b/[kernel/bpf/btf.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/btf.c?id=27ca3e20fe80be85a92b10064dfeb56cb2564b1c)@@ -6418,8 +6418,11 @@ bool btf\_ctx\_access(int off, int size, enum bpf\_access\_type type,  if (arg == nr\_args) { switch (prog->expected\_attach\_type) {- case BPF\_LSM\_CGROUP: case BPF\_LSM\_MAC:+ /\* mark we are accessing the return value \*/+ info->is\_retval = true;+ fallthrough;+ case BPF\_LSM\_CGROUP: case BPF\_TRACE\_FEXIT: /\* When LSM programs are attached to void LSM hooks \* they use FEXIT trampolines and when attached todiff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.cindex d8520095ca030e..665bd75193b039 100644--- a/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/verifier.c?id=ffe19d48b0c3230b678a2f66d10233b3699e95b0)+++ b/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/verifier.c?id=27ca3e20fe80be85a92b10064dfeb56cb2564b1c)@@ -2334,6 +2334,25 @@ static void mark\_reg\_unknown(struct bpf\_verifier\_env \*env, \_\_mark\_reg\_unknown(env, regs + regno); } +static int \_\_mark\_reg\_s32\_range(struct bpf\_verifier\_env \*env,+ struct bpf\_reg\_state \*regs,+ u32 regno,+ s32 s32\_min,+ s32 s32\_max)+{+ struct bpf\_reg\_state \*reg = regs + regno;++ reg->s32\_min\_value = max\_t(s32, reg->s32\_min\_value, s32\_min);+ reg->s32\_max\_value = min\_t(s32, reg->s32\_max\_value, s32\_max);++ reg->smin\_value = max\_t(s64, reg->smin\_value, s32\_min);+ reg->smax\_value = min\_t(s64, reg->smax\_value, s32\_max);++ reg\_bounds\_sync(reg);++ return reg\_bounds\_sanity\_check(env, reg, "s32\_range");+}+ static void \_\_mark\_reg\_not\_init(const struct bpf\_verifier\_env \*env, struct bpf\_reg\_state \*reg) {@@ -5587,11 +5606,12 @@ static int check\_packet\_access(struct bpf\_verifier\_env \*env, u32 regno, int off, /\* check access to 'struct bpf\_context' fields. Supports fixed offsets only \*/ static int check\_ctx\_access(struct bpf\_verifier\_env \*env, int insn\_idx, int off, int size, enum bpf\_access\_type t, enum bpf\_reg\_type \*reg\_type,- struct btf \*\*btf, u32 \*btf\_id)+ struct btf \*\*btf, u32 \*btf\_id, bool \*is\_retval) { struct bpf\_insn\_access\_aux info = { .reg\_type = \*reg\_type, .log = &env->log,+ .is\_retval = false, };  if (env->ops->is\_valid\_access &&@@ -5604,6 +5624,7 @@ static int check\_ctx\_access(struct bpf\_verifier\_env \*env, int insn\_idx, int off, \* type of narrower access. \*/ \*reg\_type = info.reg\_type;+ \*is\_retval = info.is\_retval;  if (base\_type(\*reg\_type) == PTR\_TO\_BTF\_ID) { \*btf = info.btf;@@ -6772,6 +6793,17 @@ static int check\_stack\_access\_within\_bounds( return grow\_stack\_state(env, state, -min\_off /\* size \*/); } +static bool get\_func\_retval\_range(struct bpf\_prog \*prog,+ struct bpf\_retval\_range \*range)+{+ if (prog->type == BPF\_PROG\_TYPE\_LSM &&+ prog->expected\_attach\_type == BPF\_LSM\_MAC &&+ !bpf\_lsm\_get\_retval\_range(prog, range)) {+ return true;+ }+ return false;+}+ /\* check whether memory at (regno + off) is accessible for t = (read | write) \* if t==write, value\_regno is a register which value is stored into memory \* if t==read, value\_regno is a register which will receive the value from memory@@ -6876,6 +6908,8 @@ static int check\_mem\_access(struct bpf\_verifier\_env \*env, int insn\_idx, u32 regn if (!err && value\_regno >= 0 && (t == BPF\_READ || rdonly\_mem)) mark\_reg\_unknown(env, regs, value\_regno); } else if (reg->type == PTR\_TO\_CTX) {+ bool is\_retval = false;+ struct bpf\_retval\_range range; enum bpf\_reg\_type reg\_type = SCALAR\_VALUE; struct btf \*btf = NULL; u32 btf\_id = 0;@@ -6891,7 +6925,7 @@ static int check\_mem\_access(struct bpf\_verifier\_env \*env, int insn\_idx, u32 regn return err;  err = check\_ctx\_access(env, insn\_idx, off, size, t, &reg\_type, &btf,- &btf\_id);+ &btf\_id, &is\_retval); if (err) verbose\_linfo(env, insn\_idx, "; "); if (!err && t == BPF\_READ && value\_regno >= 0) {@@ -6900,7 +6934,14 @@ static int check\_mem\_access(struct bpf\_verifier\_env \*env, int insn\_idx, u32 regn \* case, we know the offset is zero. \*/ if (reg\_type == SCALAR\_VALUE) {- mark\_reg\_unknown(env, regs, value\_regno);+ if (is\_retval && get\_func\_retval\_range(env->prog, &range)) {+ err = \_\_mark\_reg\_s32\_range(env, regs, value\_regno,+ range.minval, range.maxval);+ if (err)+ return err;+ } else {+ mark\_reg\_unknown(env, regs, value\_regno);+ } } else { mark\_reg\_known\_zero(env, regs, value\_regno);@@ -15674,12 +15715,13 @@ static int check\_return\_code(struct bpf\_verifier\_env \*env, int regno, const char  case BPF\_PROG\_TYPE\_LSM: if (env->prog->expected\_attach\_type != BPF\_LSM\_CGROUP) {- /\* Regular BPF\_PROG\_TYPE\_LSM programs can return- \* any value.- \*/- return 0;- }- if (!env->prog->aux->attach\_func\_proto->type) {+ /\* no range found, any return value is allowed \*/+ if (!get\_func\_retval\_range(env->prog, &range))+ return 0;+ /\* no restricted range, any return value is allowed \*/+ if (range.minval == S32\_MIN && range.maxval == S32\_MAX)+ return 0;+ } else if (!env->prog->aux->attach\_func\_proto->type) { /\* Make sure programs that attach to void \* hooks don't try to modify return value. \*/ |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 17:36:53 +0000

