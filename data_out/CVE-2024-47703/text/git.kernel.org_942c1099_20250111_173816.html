

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=5d99e198be279045e6ecefe220f5c52f8ce9bfd5)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=5d99e198be279045e6ecefe220f5c52f8ce9bfd5)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=5d99e198be279045e6ecefe220f5c52f8ce9bfd5)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5d99e198be279045e6ecefe220f5c52f8ce9bfd5)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Xu Kuohai <xukuohai@huawei.com> | 2024-07-19 19:00:52 +0800 |
| --- | --- | --- |
| committer | Andrii Nakryiko <andrii@kernel.org> | 2024-07-29 13:09:22 -0700 |
| commit | [5d99e198be279045e6ecefe220f5c52f8ce9bfd5](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=5d99e198be279045e6ecefe220f5c52f8ce9bfd5) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=5d99e198be279045e6ecefe220f5c52f8ce9bfd5)) | |
| tree | [006d24765b0fd8fdff944e4924a2f75149f78471](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=5d99e198be279045e6ecefe220f5c52f8ce9bfd5) | |
| parent | [21c7063f6d08ab9afa088584939791bee0c177e5](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=21c7063f6d08ab9afa088584939791bee0c177e5) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5d99e198be279045e6ecefe220f5c52f8ce9bfd5&id2=21c7063f6d08ab9afa088584939791bee0c177e5)) | |
| download | [linux-5d99e198be279045e6ecefe220f5c52f8ce9bfd5.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-5d99e198be279045e6ecefe220f5c52f8ce9bfd5.tar.gz) | |

bpf, lsm: Add check for BPF LSM return valueA bpf prog returning a positive number attached to file\_alloc\_security
hook makes kernel panic.
This happens because file system can not filter out the positive number
returned by the LSM prog using IS\_ERR, and misinterprets this positive
number as a file pointer.
Given that hook file\_alloc\_security never returned positive number
before the introduction of BPF LSM, and other BPF LSM hooks may
encounter similar issues, this patch adds LSM return value check
in verifier, to ensure no unexpected value is returned.
Fixes: 520b7aa00d8c ("bpf: lsm: Initialize the BPF LSM hooks")
Reported-by: Xin Liu <liuxin350@huawei.com>
Signed-off-by: Xu Kuohai <xukuohai@huawei.com>
Acked-by: Eduard Zingerman <eddyz87@gmail.com>
Link: [https://lore.kernel.org/r/20240719110059.797546-3-xukuohai@huaweicloud.com](https://lore.kernel.org/r/20240719110059.797546-3-xukuohai%40huaweicloud.com)
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Signed-off-by: Andrii Nakryiko <andrii@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5d99e198be279045e6ecefe220f5c52f8ce9bfd5)

| -rw-r--r-- | [include/linux/bpf.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/bpf.h?id=5d99e198be279045e6ecefe220f5c52f8ce9bfd5) | 1 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/linux/bpf\_lsm.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/bpf_lsm.h?id=5d99e198be279045e6ecefe220f5c52f8ce9bfd5) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/bpf/bpf\_lsm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/bpf/bpf_lsm.c?id=5d99e198be279045e6ecefe220f5c52f8ce9bfd5) | 34 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/bpf/btf.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/bpf/btf.c?id=5d99e198be279045e6ecefe220f5c52f8ce9bfd5) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/bpf/verifier.c?id=5d99e198be279045e6ecefe220f5c52f8ce9bfd5) | 60 | |  |  |  | | --- | --- | --- | |

5 files changed, 97 insertions, 11 deletions

| diff --git a/include/linux/bpf.h b/include/linux/bpf.hindex 4c54864316ee49..5739cc9986f8b7 100644--- a/[include/linux/bpf.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/bpf.h?id=21c7063f6d08ab9afa088584939791bee0c177e5)+++ b/[include/linux/bpf.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/bpf.h?id=5d99e198be279045e6ecefe220f5c52f8ce9bfd5)@@ -927,6 +927,7 @@ struct bpf\_insn\_access\_aux { }; }; struct bpf\_verifier\_log \*log; /\* for verbose logs \*/+ bool is\_retval; /\* is accessing function return value ? \*/ };  static inline voiddiff --git a/include/linux/bpf\_lsm.h b/include/linux/bpf\_lsm.hindex 1de7ece5d36d43..aefcd656425126 100644--- a/[include/linux/bpf\_lsm.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/bpf_lsm.h?id=21c7063f6d08ab9afa088584939791bee0c177e5)+++ b/[include/linux/bpf\_lsm.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/bpf_lsm.h?id=5d99e198be279045e6ecefe220f5c52f8ce9bfd5)@@ -9,6 +9,7 @@  #include <linux/sched.h> #include <linux/bpf.h>+#include <linux/bpf\_verifier.h> #include <linux/lsm\_hooks.h>  #ifdef CONFIG\_BPF\_LSM@@ -45,6 +46,8 @@ void bpf\_inode\_storage\_free(struct inode \*inode);  void bpf\_lsm\_find\_cgroup\_shim(const struct bpf\_prog \*prog, bpf\_func\_t \*bpf\_func); +int bpf\_lsm\_get\_retval\_range(const struct bpf\_prog \*prog,+ struct bpf\_retval\_range \*range); #else /\* !CONFIG\_BPF\_LSM \*/  static inline bool bpf\_lsm\_is\_sleepable\_hook(u32 btf\_id)@@ -78,6 +81,11 @@ static inline void bpf\_lsm\_find\_cgroup\_shim(const struct bpf\_prog \*prog, { } +static inline int bpf\_lsm\_get\_retval\_range(const struct bpf\_prog \*prog,+ struct bpf\_retval\_range \*range)+{+ return -EOPNOTSUPP;+} #endif /\* CONFIG\_BPF\_LSM \*/  #endif /\* \_LINUX\_BPF\_LSM\_H \*/diff --git a/kernel/bpf/bpf\_lsm.c b/kernel/bpf/bpf\_lsm.cindex 1f596ad6257c50..6292ac5f9bd139 100644--- a/[kernel/bpf/bpf\_lsm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/bpf_lsm.c?id=21c7063f6d08ab9afa088584939791bee0c177e5)+++ b/[kernel/bpf/bpf\_lsm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/bpf_lsm.c?id=5d99e198be279045e6ecefe220f5c52f8ce9bfd5)@@ -11,7 +11,6 @@ #include <linux/lsm\_hooks.h> #include <linux/bpf\_lsm.h> #include <linux/kallsyms.h>-#include <linux/bpf\_verifier.h> #include <net/bpf\_sk\_storage.h> #include <linux/bpf\_local\_storage.h> #include <linux/btf\_ids.h>@@ -417,3 +416,36 @@ const struct bpf\_verifier\_ops lsm\_verifier\_ops = { .get\_func\_proto = bpf\_lsm\_func\_proto, .is\_valid\_access = btf\_ctx\_access, };++/\* hooks return 0 or 1 \*/+BTF\_SET\_START(bool\_lsm\_hooks)+#ifdef CONFIG\_SECURITY\_NETWORK\_XFRM+BTF\_ID(func, bpf\_lsm\_xfrm\_state\_pol\_flow\_match)+#endif+#ifdef CONFIG\_AUDIT+BTF\_ID(func, bpf\_lsm\_audit\_rule\_known)+#endif+BTF\_ID(func, bpf\_lsm\_inode\_xattr\_skipcap)+BTF\_SET\_END(bool\_lsm\_hooks)++int bpf\_lsm\_get\_retval\_range(const struct bpf\_prog \*prog,+ struct bpf\_retval\_range \*retval\_range)+{+ /\* no return value range for void hooks \*/+ if (!prog->aux->attach\_func\_proto->type)+ return -EINVAL;++ if (btf\_id\_set\_contains(&bool\_lsm\_hooks, prog->aux->attach\_btf\_id)) {+ retval\_range->minval = 0;+ retval\_range->maxval = 1;+ } else {+ /\* All other available LSM hooks, except task\_prctl, return 0+ \* on success and negative error code on failure.+ \* To keep things simple, we only allow bpf progs to return 0+ \* or negative errno for task\_prctl too.+ \*/+ retval\_range->minval = -MAX\_ERRNO;+ retval\_range->maxval = 0;+ }+ return 0;+}diff --git a/kernel/bpf/btf.c b/kernel/bpf/btf.cindex 520f49f422fee2..95426d5b634e38 100644--- a/[kernel/bpf/btf.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/btf.c?id=21c7063f6d08ab9afa088584939791bee0c177e5)+++ b/[kernel/bpf/btf.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/btf.c?id=5d99e198be279045e6ecefe220f5c52f8ce9bfd5)@@ -6416,8 +6416,11 @@ bool btf\_ctx\_access(int off, int size, enum bpf\_access\_type type,  if (arg == nr\_args) { switch (prog->expected\_attach\_type) {- case BPF\_LSM\_CGROUP: case BPF\_LSM\_MAC:+ /\* mark we are accessing the return value \*/+ info->is\_retval = true;+ fallthrough;+ case BPF\_LSM\_CGROUP: case BPF\_TRACE\_FEXIT: /\* When LSM programs are attached to void LSM hooks \* they use FEXIT trampolines and when attached todiff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.cindex 247a038d3a14ca..8caa7322f031a1 100644--- a/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/verifier.c?id=21c7063f6d08ab9afa088584939791bee0c177e5)+++ b/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/verifier.c?id=5d99e198be279045e6ecefe220f5c52f8ce9bfd5)@@ -2334,6 +2334,25 @@ static void mark\_reg\_unknown(struct bpf\_verifier\_env \*env, \_\_mark\_reg\_unknown(env, regs + regno); } +static int \_\_mark\_reg\_s32\_range(struct bpf\_verifier\_env \*env,+ struct bpf\_reg\_state \*regs,+ u32 regno,+ s32 s32\_min,+ s32 s32\_max)+{+ struct bpf\_reg\_state \*reg = regs + regno;++ reg->s32\_min\_value = max\_t(s32, reg->s32\_min\_value, s32\_min);+ reg->s32\_max\_value = min\_t(s32, reg->s32\_max\_value, s32\_max);++ reg->smin\_value = max\_t(s64, reg->smin\_value, s32\_min);+ reg->smax\_value = min\_t(s64, reg->smax\_value, s32\_max);++ reg\_bounds\_sync(reg);++ return reg\_bounds\_sanity\_check(env, reg, "s32\_range");+}+ static void \_\_mark\_reg\_not\_init(const struct bpf\_verifier\_env \*env, struct bpf\_reg\_state \*reg) {@@ -5607,11 +5626,12 @@ static int check\_packet\_access(struct bpf\_verifier\_env \*env, u32 regno, int off, /\* check access to 'struct bpf\_context' fields. Supports fixed offsets only \*/ static int check\_ctx\_access(struct bpf\_verifier\_env \*env, int insn\_idx, int off, int size, enum bpf\_access\_type t, enum bpf\_reg\_type \*reg\_type,- struct btf \*\*btf, u32 \*btf\_id)+ struct btf \*\*btf, u32 \*btf\_id, bool \*is\_retval) { struct bpf\_insn\_access\_aux info = { .reg\_type = \*reg\_type, .log = &env->log,+ .is\_retval = false, };  if (env->ops->is\_valid\_access &&@@ -5624,6 +5644,7 @@ static int check\_ctx\_access(struct bpf\_verifier\_env \*env, int insn\_idx, int off, \* type of narrower access. \*/ \*reg\_type = info.reg\_type;+ \*is\_retval = info.is\_retval;  if (base\_type(\*reg\_type) == PTR\_TO\_BTF\_ID) { \*btf = info.btf;@@ -6792,6 +6813,17 @@ static int check\_stack\_access\_within\_bounds( return grow\_stack\_state(env, state, -min\_off /\* size \*/); } +static bool get\_func\_retval\_range(struct bpf\_prog \*prog,+ struct bpf\_retval\_range \*range)+{+ if (prog->type == BPF\_PROG\_TYPE\_LSM &&+ prog->expected\_attach\_type == BPF\_LSM\_MAC &&+ !bpf\_lsm\_get\_retval\_range(prog, range)) {+ return true;+ }+ return false;+}+ /\* check whether memory at (regno + off) is accessible for t = (read | write) \* if t==write, value\_regno is a register which value is stored into memory \* if t==read, value\_regno is a register which will receive the value from memory@@ -6896,6 +6928,8 @@ static int check\_mem\_access(struct bpf\_verifier\_env \*env, int insn\_idx, u32 regn if (!err && value\_regno >= 0 && (t == BPF\_READ || rdonly\_mem)) mark\_reg\_unknown(env, regs, value\_regno); } else if (reg->type == PTR\_TO\_CTX) {+ bool is\_retval = false;+ struct bpf\_retval\_range range; enum bpf\_reg\_type reg\_type = SCALAR\_VALUE; struct btf \*btf = NULL; u32 btf\_id = 0;@@ -6911,7 +6945,7 @@ static int check\_mem\_access(struct bpf\_verifier\_env \*env, int insn\_idx, u32 regn return err;  err = check\_ctx\_access(env, insn\_idx, off, size, t, &reg\_type, &btf,- &btf\_id);+ &btf\_id, &is\_retval); if (err) verbose\_linfo(env, insn\_idx, "; "); if (!err && t == BPF\_READ && value\_regno >= 0) {@@ -6920,7 +6954,14 @@ static int check\_mem\_access(struct bpf\_verifier\_env \*env, int insn\_idx, u32 regn \* case, we know the offset is zero. \*/ if (reg\_type == SCALAR\_VALUE) {- mark\_reg\_unknown(env, regs, value\_regno);+ if (is\_retval && get\_func\_retval\_range(env->prog, &range)) {+ err = \_\_mark\_reg\_s32\_range(env, regs, value\_regno,+ range.minval, range.maxval);+ if (err)+ return err;+ } else {+ mark\_reg\_unknown(env, regs, value\_regno);+ } } else { mark\_reg\_known\_zero(env, regs, value\_regno);@@ -15762,12 +15803,13 @@ static int check\_return\_code(struct bpf\_verifier\_env \*env, int regno, const char  case BPF\_PROG\_TYPE\_LSM: if (env->prog->expected\_attach\_type != BPF\_LSM\_CGROUP) {- /\* Regular BPF\_PROG\_TYPE\_LSM programs can return- \* any value.- \*/- return 0;- }- if (!env->prog->aux->attach\_func\_proto->type) {+ /\* no range found, any return value is allowed \*/+ if (!get\_func\_retval\_range(env->prog, &range))+ return 0;+ /\* no restricted range, any return value is allowed \*/+ if (range.minval == S32\_MIN && range.maxval == S32\_MAX)+ return 0;+ } else if (!env->prog->aux->attach\_func\_proto->type) { /\* Make sure programs that attach to void \* hooks don't try to modify return value. \*/ |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 17:36:53 +0000

