

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=83f0440b2f92227fcce9898118ca7fe7e0d64b1f)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=83f0440b2f92227fcce9898118ca7fe7e0d64b1f)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=83f0440b2f92227fcce9898118ca7fe7e0d64b1f)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=83f0440b2f92227fcce9898118ca7fe7e0d64b1f)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Peng Fan <peng.fan@nxp.com> | 2024-08-29 11:29:11 +0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-10-10 12:03:48 +0200 |
| commit | [83f0440b2f92227fcce9898118ca7fe7e0d64b1f](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=83f0440b2f92227fcce9898118ca7fe7e0d64b1f) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=83f0440b2f92227fcce9898118ca7fe7e0d64b1f)) | |
| tree | [0b65c6831fe2732e77834efb33084f1432d8c5b6](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=83f0440b2f92227fcce9898118ca7fe7e0d64b1f) | |
| parent | [a70641d20586925b9a90426b74acf6ef7d515641](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a70641d20586925b9a90426b74acf6ef7d515641) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=83f0440b2f92227fcce9898118ca7fe7e0d64b1f&id2=a70641d20586925b9a90426b74acf6ef7d515641)) | |
| download | [linux-83f0440b2f92227fcce9898118ca7fe7e0d64b1f.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-83f0440b2f92227fcce9898118ca7fe7e0d64b1f.tar.gz) | |

mm, slub: avoid zeroing kmalloc redzonecommit 59090e479ac78ae18facd4c58eb332562a23020e upstream.
Since commit 946fa0dbf2d8 ("mm/slub: extend redzone check to extra
allocated kmalloc space than requested"), setting orig\_size treats
the wasted space (object\_size - orig\_size) as a redzone. However with
init\_on\_free=1 we clear the full object->size, including the redzone.
Additionally we clear the object metadata, including the stored orig\_size,
making it zero, which makes check\_object() treat the whole object as a
redzone.
These issues lead to the following BUG report with "slub\_debug=FUZ
init\_on\_free=1":
[ 0.000000] =============================================================================
[ 0.000000] BUG kmalloc-8 (Not tainted): kmalloc Redzone overwritten
[ 0.000000] -----------------------------------------------------------------------------
[ 0.000000]
[ 0.000000] 0xffff000010032858-0xffff00001003285f @offset=2136. First byte 0x0 instead of 0xcc
[ 0.000000] FIX kmalloc-8: Restoring kmalloc Redzone 0xffff000010032858-0xffff00001003285f=0xcc
[ 0.000000] Slab 0xfffffdffc0400c80 objects=36 used=23 fp=0xffff000010032a18 flags=0x3fffe0000000200(workingset|node=0|zone=0|lastcpupid=0x1ffff)
[ 0.000000] Object 0xffff000010032858 @offset=2136 fp=0xffff0000100328c8
[ 0.000000]
[ 0.000000] Redzone ffff000010032850: cc cc cc cc cc cc cc cc ........
[ 0.000000] Object ffff000010032858: cc cc cc cc cc cc cc cc ........
[ 0.000000] Redzone ffff000010032860: cc cc cc cc cc cc cc cc ........
[ 0.000000] Padding ffff0000100328b4: 00 00 00 00 00 00 00 00 00 00 00 00 ............
[ 0.000000] CPU: 0 UID: 0 PID: 0 Comm: swapper/0 Not tainted 6.11.0-rc3-next-20240814-00004-g61844c55c3f4 #144
[ 0.000000] Hardware name: NXP i.MX95 19X19 board (DT)
[ 0.000000] Call trace:
[ 0.000000] dump\_backtrace+0x90/0xe8
[ 0.000000] show\_stack+0x18/0x24
[ 0.000000] dump\_stack\_lvl+0x74/0x8c
[ 0.000000] dump\_stack+0x18/0x24
[ 0.000000] print\_trailer+0x150/0x218
[ 0.000000] check\_object+0xe4/0x454
[ 0.000000] free\_to\_partial\_list+0x2f8/0x5ec
To address the issue, use orig\_size to clear the used area. And restore
the value of orig\_size after clear the remaining area.
When CONFIG\_SLUB\_DEBUG not defined, (get\_orig\_size()' directly returns
s->object\_size. So when using memset to init the area, the size can simply
be orig\_size, as orig\_size returns object\_size when CONFIG\_SLUB\_DEBUG not
enabled. And orig\_size can never be bigger than object\_size.
Fixes: 946fa0dbf2d8 ("mm/slub: extend redzone check to extra allocated kmalloc space than requested")
Cc: <stable@vger.kernel.org>
Reviewed-by: Feng Tang <feng.tang@intel.com>
Acked-by: David Rientjes <rientjes@google.com>
Signed-off-by: Peng Fan <peng.fan@nxp.com>
Signed-off-by: Vlastimil Babka <vbabka@suse.cz>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=83f0440b2f92227fcce9898118ca7fe7e0d64b1f)

| -rw-r--r-- | [mm/slub.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/mm/slub.c?id=83f0440b2f92227fcce9898118ca7fe7e0d64b1f) | 100 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 53 insertions, 47 deletions

| diff --git a/mm/slub.c b/mm/slub.cindex a77f354f83251e..fede2121ec1f21 100644--- a/[mm/slub.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/slub.c?id=a70641d20586925b9a90426b74acf6ef7d515641)+++ b/[mm/slub.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/slub.c?id=83f0440b2f92227fcce9898118ca7fe7e0d64b1f)@@ -756,6 +756,50 @@ static inline bool slab\_update\_freelist(struct kmem\_cache \*s, struct slab \*slab, return false; } +/\*+ \* kmalloc caches has fixed sizes (mostly power of 2), and kmalloc() API+ \* family will round up the real request size to these fixed ones, so+ \* there could be an extra area than what is requested. Save the original+ \* request size in the meta data area, for better debug and sanity check.+ \*/+static inline void set\_orig\_size(struct kmem\_cache \*s,+ void \*object, unsigned int orig\_size)+{+ void \*p = kasan\_reset\_tag(object);+ unsigned int kasan\_meta\_size;++ if (!slub\_debug\_orig\_size(s))+ return;++ /\*+ \* KASAN can save its free meta data inside of the object at offset 0.+ \* If this meta data size is larger than 'orig\_size', it will overlap+ \* the data redzone in [orig\_size+1, object\_size]. Thus, we adjust+ \* 'orig\_size' to be as at least as big as KASAN's meta data.+ \*/+ kasan\_meta\_size = kasan\_metadata\_size(s, true);+ if (kasan\_meta\_size > orig\_size)+ orig\_size = kasan\_meta\_size;++ p += get\_info\_end(s);+ p += sizeof(struct track) \* 2;++ \*(unsigned int \*)p = orig\_size;+}++static inline unsigned int get\_orig\_size(struct kmem\_cache \*s, void \*object)+{+ void \*p = kasan\_reset\_tag(object);++ if (!slub\_debug\_orig\_size(s))+ return s->object\_size;++ p += get\_info\_end(s);+ p += sizeof(struct track) \* 2;++ return \*(unsigned int \*)p;+}+ #ifdef CONFIG\_SLUB\_DEBUG static unsigned long object\_map[BITS\_TO\_LONGS(MAX\_OBJS\_PER\_PAGE)]; static DEFINE\_SPINLOCK(object\_map\_lock);@@ -985,50 +1029,6 @@ static void print\_slab\_info(const struct slab \*slab) &slab->\_\_page\_flags); } -/\*- \* kmalloc caches has fixed sizes (mostly power of 2), and kmalloc() API- \* family will round up the real request size to these fixed ones, so- \* there could be an extra area than what is requested. Save the original- \* request size in the meta data area, for better debug and sanity check.- \*/-static inline void set\_orig\_size(struct kmem\_cache \*s,- void \*object, unsigned int orig\_size)-{- void \*p = kasan\_reset\_tag(object);- unsigned int kasan\_meta\_size;-- if (!slub\_debug\_orig\_size(s))- return;-- /\*- \* KASAN can save its free meta data inside of the object at offset 0.- \* If this meta data size is larger than 'orig\_size', it will overlap- \* the data redzone in [orig\_size+1, object\_size]. Thus, we adjust- \* 'orig\_size' to be as at least as big as KASAN's meta data.- \*/- kasan\_meta\_size = kasan\_metadata\_size(s, true);- if (kasan\_meta\_size > orig\_size)- orig\_size = kasan\_meta\_size;-- p += get\_info\_end(s);- p += sizeof(struct track) \* 2;-- \*(unsigned int \*)p = orig\_size;-}--static inline unsigned int get\_orig\_size(struct kmem\_cache \*s, void \*object)-{- void \*p = kasan\_reset\_tag(object);-- if (!slub\_debug\_orig\_size(s))- return s->object\_size;-- p += get\_info\_end(s);- p += sizeof(struct track) \* 2;-- return \*(unsigned int \*)p;-}- void skip\_orig\_size\_check(struct kmem\_cache \*s, const void \*object) { set\_orig\_size(s, (void \*)object, s->object\_size);@@ -1894,7 +1894,6 @@ static inline void inc\_slabs\_node(struct kmem\_cache \*s, int node, int objects) {} static inline void dec\_slabs\_node(struct kmem\_cache \*s, int node, int objects) {}- #ifndef CONFIG\_SLUB\_TINY static bool freelist\_corrupted(struct kmem\_cache \*s, struct slab \*slab, void \*\*freelist, void \*nextfree)@@ -2243,14 +2242,21 @@ bool slab\_free\_hook(struct kmem\_cache \*s, void \*x, bool init) \*/ if (unlikely(init)) { int rsize;- unsigned int inuse;+ unsigned int inuse, orig\_size;  inuse = get\_info\_end(s);+ orig\_size = get\_orig\_size(s, x); if (!kasan\_has\_integrated\_init())- memset(kasan\_reset\_tag(x), 0, s->object\_size);+ memset(kasan\_reset\_tag(x), 0, orig\_size); rsize = (s->flags & SLAB\_RED\_ZONE) ? s->red\_left\_pad : 0; memset((char \*)kasan\_reset\_tag(x) + inuse, 0, s->size - inuse - rsize);+ /\*+ \* Restore orig\_size, otherwize kmalloc redzone overwritten+ \* would be reported+ \*/+ set\_orig\_size(s, x, orig\_size);+ } /\* KASAN might put x into memory quarantine, delaying its reuse. \*/ return !kasan\_slab\_free(s, x, init); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 10:54:54 +0000

