

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=a309c7194e8a2f8bd4539b9449917913f6c2cd50)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a309c7194e8a2f8bd4539b9449917913f6c2cd50)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a309c7194e8a2f8bd4539b9449917913f6c2cd50)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a309c7194e8a2f8bd4539b9449917913f6c2cd50)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Zack Rusin <zackr@vmware.com> | 2022-12-07 12:29:07 -0500 |
| --- | --- | --- |
| committer | Zack Rusin <zackr@vmware.com> | 2023-01-09 21:15:36 -0500 |
| commit | [a309c7194e8a2f8bd4539b9449917913f6c2cd50](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a309c7194e8a2f8bd4539b9449917913f6c2cd50) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=a309c7194e8a2f8bd4539b9449917913f6c2cd50)) | |
| tree | [2774c49f4f5f962fd9271533104b293bd1031aad](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a309c7194e8a2f8bd4539b9449917913f6c2cd50) | |
| parent | [52531258318ed59a2dc5a43df2eaf0eb1d65438e](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=52531258318ed59a2dc5a43df2eaf0eb1d65438e) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a309c7194e8a2f8bd4539b9449917913f6c2cd50&id2=52531258318ed59a2dc5a43df2eaf0eb1d65438e)) | |
| download | [linux-a309c7194e8a2f8bd4539b9449917913f6c2cd50.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-a309c7194e8a2f8bd4539b9449917913f6c2cd50.tar.gz) | |

drm/vmwgfx: Remove rcu locks from user resourcesUser resource lookups used rcu to avoid two extra atomics. Unfortunately
the rcu paths were buggy and it was easy to make the driver crash by
submitting command buffers from two different threads. Because the
lookups never show up in performance profiles replace them with a
regular spin lock which fixes the races in accesses to those shared
resources.
Fixes kernel oops'es in IGT's vmwgfx execution\_buffer stress test and
seen crashes with apps using shared resources.
Fixes: e14c02e6b699 ("drm/vmwgfx: Look up objects without taking a reference")
Signed-off-by: Zack Rusin <zackr@vmware.com>
Reviewed-by: Martin Krastev <krastevm@vmware.com>
Reviewed-by: Maaz Mombasawala <mombasawalam@vmware.com>
Link: [https://patchwork.freedesktop.org/patch/msgid/20221207172907.959037-1-zack@kde.org](https://patchwork.freedesktop.org/patch/msgid/20221207172907.959037-1-zack%40kde.org)
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a309c7194e8a2f8bd4539b9449917913f6c2cd50)

| -rw-r--r-- | [drivers/gpu/drm/vmwgfx/ttm\_object.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/gpu/drm/vmwgfx/ttm_object.c?id=a309c7194e8a2f8bd4539b9449917913f6c2cd50) | 41 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/gpu/drm/vmwgfx/ttm\_object.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/gpu/drm/vmwgfx/ttm_object.h?id=a309c7194e8a2f8bd4539b9449917913f6c2cd50) | 14 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/gpu/drm/vmwgfx/vmwgfx\_bo.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/gpu/drm/vmwgfx/vmwgfx_bo.c?id=a309c7194e8a2f8bd4539b9449917913f6c2cd50) | 38 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/gpu/drm/vmwgfx/vmwgfx\_drv.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h?id=a309c7194e8a2f8bd4539b9449917913f6c2cd50) | 18 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/gpu/drm/vmwgfx/vmwgfx\_execbuf.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c?id=a309c7194e8a2f8bd4539b9449917913f6c2cd50) | 176 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/gpu/drm/vmwgfx/vmwgfx\_resource.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c?id=a309c7194e8a2f8bd4539b9449917913f6c2cd50) | 33 | |  |  |  | | --- | --- | --- | |

6 files changed, 87 insertions, 233 deletions

| diff --git a/drivers/gpu/drm/vmwgfx/ttm\_object.c b/drivers/gpu/drm/vmwgfx/ttm\_object.cindex 932b125ebf3d64..ddf8373c1d779c 100644--- a/[drivers/gpu/drm/vmwgfx/ttm\_object.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/gpu/drm/vmwgfx/ttm_object.c?id=52531258318ed59a2dc5a43df2eaf0eb1d65438e)+++ b/[drivers/gpu/drm/vmwgfx/ttm\_object.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/gpu/drm/vmwgfx/ttm_object.c?id=a309c7194e8a2f8bd4539b9449917913f6c2cd50)@@ -254,40 +254,6 @@ void ttm\_base\_object\_unref(struct ttm\_base\_object \*\*p\_base) kref\_put(&base->refcount, ttm\_release\_base); } -/\*\*- \* ttm\_base\_object\_noref\_lookup - look up a base object without reference- \* @tfile: The struct ttm\_object\_file the object is registered with.- \* @key: The object handle.- \*- \* This function looks up a ttm base object and returns a pointer to it- \* without refcounting the pointer. The returned pointer is only valid- \* until ttm\_base\_object\_noref\_release() is called, and the object- \* pointed to by the returned pointer may be doomed. Any persistent usage- \* of the object requires a refcount to be taken using kref\_get\_unless\_zero().- \* Iff this function returns successfully it needs to be paired with- \* ttm\_base\_object\_noref\_release() and no sleeping- or scheduling functions- \* may be called inbetween these function callse.- \*- \* Return: A pointer to the object if successful or NULL otherwise.- \*/-struct ttm\_base\_object \*-ttm\_base\_object\_noref\_lookup(struct ttm\_object\_file \*tfile, uint64\_t key)-{- struct vmwgfx\_hash\_item \*hash;- int ret;-- rcu\_read\_lock();- ret = ttm\_tfile\_find\_ref\_rcu(tfile, key, &hash);- if (ret) {- rcu\_read\_unlock();- return NULL;- }-- \_\_release(RCU);- return hlist\_entry(hash, struct ttm\_ref\_object, hash)->obj;-}-EXPORT\_SYMBOL(ttm\_base\_object\_noref\_lookup);- struct ttm\_base\_object \*ttm\_base\_object\_lookup(struct ttm\_object\_file \*tfile, uint64\_t key) {@@ -295,15 +261,16 @@ struct ttm\_base\_object \*ttm\_base\_object\_lookup(struct ttm\_object\_file \*tfile, struct vmwgfx\_hash\_item \*hash; int ret; - rcu\_read\_lock();- ret = ttm\_tfile\_find\_ref\_rcu(tfile, key, &hash);+ spin\_lock(&tfile->lock);+ ret = ttm\_tfile\_find\_ref(tfile, key, &hash);  if (likely(ret == 0)) { base = hlist\_entry(hash, struct ttm\_ref\_object, hash)->obj; if (!kref\_get\_unless\_zero(&base->refcount)) base = NULL; }- rcu\_read\_unlock();+ spin\_unlock(&tfile->lock);+  return base; }diff --git a/drivers/gpu/drm/vmwgfx/ttm\_object.h b/drivers/gpu/drm/vmwgfx/ttm\_object.hindex f0ebbe340ad698..8098a3846bae3e 100644--- a/[drivers/gpu/drm/vmwgfx/ttm\_object.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/gpu/drm/vmwgfx/ttm_object.h?id=52531258318ed59a2dc5a43df2eaf0eb1d65438e)+++ b/[drivers/gpu/drm/vmwgfx/ttm\_object.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/gpu/drm/vmwgfx/ttm_object.h?id=a309c7194e8a2f8bd4539b9449917913f6c2cd50)@@ -307,18 +307,4 @@ extern int ttm\_prime\_handle\_to\_fd(struct ttm\_object\_file \*tfile, #define ttm\_prime\_object\_kfree(\_\_obj, \_\_prime) \ kfree\_rcu(\_\_obj, \_\_prime.base.rhead) -struct ttm\_base\_object \*-ttm\_base\_object\_noref\_lookup(struct ttm\_object\_file \*tfile, uint64\_t key);--/\*\*- \* ttm\_base\_object\_noref\_release - release a base object pointer looked up- \* without reference- \*- \* Releases a base object pointer looked up with ttm\_base\_object\_noref\_lookup().- \*/-static inline void ttm\_base\_object\_noref\_release(void)-{- \_\_acquire(RCU);- rcu\_read\_unlock();-} #endifdiff --git a/drivers/gpu/drm/vmwgfx/vmwgfx\_bo.c b/drivers/gpu/drm/vmwgfx/vmwgfx\_bo.cindex 321c551784a146..aa1cd5126a321d 100644--- a/[drivers/gpu/drm/vmwgfx/vmwgfx\_bo.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/gpu/drm/vmwgfx/vmwgfx_bo.c?id=52531258318ed59a2dc5a43df2eaf0eb1d65438e)+++ b/[drivers/gpu/drm/vmwgfx/vmwgfx\_bo.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/gpu/drm/vmwgfx/vmwgfx_bo.c?id=a309c7194e8a2f8bd4539b9449917913f6c2cd50)@@ -716,44 +716,6 @@ int vmw\_user\_bo\_lookup(struct drm\_file \*filp, }  /\*\*- \* vmw\_user\_bo\_noref\_lookup - Look up a vmw user buffer object without reference- \* @filp: The TTM object file the handle is registered with.- \* @handle: The user buffer object handle.- \*- \* This function looks up a struct vmw\_bo and returns a pointer to the- \* struct vmw\_buffer\_object it derives from without refcounting the pointer.- \* The returned pointer is only valid until vmw\_user\_bo\_noref\_release() is- \* called, and the object pointed to by the returned pointer may be doomed.- \* Any persistent usage of the object requires a refcount to be taken using- \* ttm\_bo\_reference\_unless\_doomed(). Iff this function returns successfully it- \* needs to be paired with vmw\_user\_bo\_noref\_release() and no sleeping-- \* or scheduling functions may be called in between these function calls.- \*- \* Return: A struct vmw\_buffer\_object pointer if successful or negative- \* error pointer on failure.- \*/-struct vmw\_buffer\_object \*-vmw\_user\_bo\_noref\_lookup(struct drm\_file \*filp, u32 handle)-{- struct vmw\_buffer\_object \*vmw\_bo;- struct ttm\_buffer\_object \*bo;- struct drm\_gem\_object \*gobj = drm\_gem\_object\_lookup(filp, handle);-- if (!gobj) {- DRM\_ERROR("Invalid buffer object handle 0x%08lx.\n",- (unsigned long)handle);- return ERR\_PTR(-ESRCH);- }- vmw\_bo = gem\_to\_vmw\_bo(gobj);- bo = ttm\_bo\_get\_unless\_zero(&vmw\_bo->base);- vmw\_bo = vmw\_buffer\_object(bo);- drm\_gem\_object\_put(gobj);-- return vmw\_bo;-}---/\*\* \* vmw\_bo\_fence\_single - Utility function to fence a single TTM buffer \* object without unreserving it. \*diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx\_drv.h b/drivers/gpu/drm/vmwgfx/vmwgfx\_drv.hindex b062b020b37824..5acbf5849b2703 100644--- a/[drivers/gpu/drm/vmwgfx/vmwgfx\_drv.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h?id=52531258318ed59a2dc5a43df2eaf0eb1d65438e)+++ b/[drivers/gpu/drm/vmwgfx/vmwgfx\_drv.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h?id=a309c7194e8a2f8bd4539b9449917913f6c2cd50)@@ -830,12 +830,7 @@ extern int vmw\_user\_resource\_lookup\_handle( uint32\_t handle, const struct vmw\_user\_resource\_conv \*converter, struct vmw\_resource \*\*p\_res);-extern struct vmw\_resource \*-vmw\_user\_resource\_noref\_lookup\_handle(struct vmw\_private \*dev\_priv,- struct ttm\_object\_file \*tfile,- uint32\_t handle,- const struct vmw\_user\_resource\_conv \*- converter);+ extern int vmw\_stream\_claim\_ioctl(struct drm\_device \*dev, void \*data, struct drm\_file \*file\_priv); extern int vmw\_stream\_unref\_ioctl(struct drm\_device \*dev, void \*data,@@ -875,15 +870,6 @@ static inline bool vmw\_resource\_mob\_attached(const struct vmw\_resource \*res) }  /\*\*- \* vmw\_user\_resource\_noref\_release - release a user resource pointer looked up- \* without reference- \*/-static inline void vmw\_user\_resource\_noref\_release(void)-{- ttm\_base\_object\_noref\_release();-}--/\*\* \* Buffer object helper functions - vmwgfx\_bo.c \*/ extern int vmw\_bo\_pin\_in\_placement(struct vmw\_private \*vmw\_priv,@@ -934,8 +920,6 @@ extern void vmw\_bo\_unmap(struct vmw\_buffer\_object \*vbo); extern void vmw\_bo\_move\_notify(struct ttm\_buffer\_object \*bo, struct ttm\_resource \*mem); extern void vmw\_bo\_swap\_notify(struct ttm\_buffer\_object \*bo);-extern struct vmw\_buffer\_object \*-vmw\_user\_bo\_noref\_lookup(struct drm\_file \*filp, u32 handle);  /\*\* \* vmw\_bo\_adjust\_prio - Adjust the buffer object eviction prioritydiff --git a/drivers/gpu/drm/vmwgfx/vmwgfx\_execbuf.c b/drivers/gpu/drm/vmwgfx/vmwgfx\_execbuf.cindex a5379f6fb5ab18..a44d53e33cdb14 100644--- a/[drivers/gpu/drm/vmwgfx/vmwgfx\_execbuf.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c?id=52531258318ed59a2dc5a43df2eaf0eb1d65438e)+++ b/[drivers/gpu/drm/vmwgfx/vmwgfx\_execbuf.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c?id=a309c7194e8a2f8bd4539b9449917913f6c2cd50)@@ -290,20 +290,26 @@ static void vmw\_execbuf\_rcache\_update(struct vmw\_res\_cache\_entry \*rcache, rcache->valid\_handle = 0; } +enum vmw\_val\_add\_flags {+ vmw\_val\_add\_flag\_none = 0,+ vmw\_val\_add\_flag\_noctx = 1 << 0,+};+ /\*\*- \* vmw\_execbuf\_res\_noref\_val\_add - Add a resource described by an unreferenced- \* rcu-protected pointer to the validation list.+ \* vmw\_execbuf\_res\_val\_add - Add a resource to the validation list. \* \* @sw\_context: Pointer to the software context. \* @res: Unreferenced rcu-protected pointer to the resource. \* @dirty: Whether to change dirty status.+ \* @flags: specifies whether to use the context or not \* \* Returns: 0 on success. Negative error code on failure. Typical error codes \* are %-EINVAL on inconsistency and %-ESRCH if the resource was doomed. \*/-static int vmw\_execbuf\_res\_noref\_val\_add(struct vmw\_sw\_context \*sw\_context,- struct vmw\_resource \*res,- u32 dirty)+static int vmw\_execbuf\_res\_val\_add(struct vmw\_sw\_context \*sw\_context,+ struct vmw\_resource \*res,+ u32 dirty,+ u32 flags) { struct vmw\_private \*dev\_priv = res->dev\_priv; int ret;@@ -318,24 +324,30 @@ static int vmw\_execbuf\_res\_noref\_val\_add(struct vmw\_sw\_context \*sw\_context, if (dirty) vmw\_validation\_res\_set\_dirty(sw\_context->ctx, rcache->private, dirty);- vmw\_user\_resource\_noref\_release(); return 0; } - priv\_size = vmw\_execbuf\_res\_size(dev\_priv, res\_type);- ret = vmw\_validation\_add\_resource(sw\_context->ctx, res, priv\_size,- dirty, (void \*\*)&ctx\_info,- &first\_usage);- vmw\_user\_resource\_noref\_release();- if (ret)- return ret;+ if ((flags & vmw\_val\_add\_flag\_noctx) != 0) {+ ret = vmw\_validation\_add\_resource(sw\_context->ctx, res, 0, dirty,+ (void \*\*)&ctx\_info, NULL);+ if (ret)+ return ret; - if (priv\_size && first\_usage) {- ret = vmw\_cmd\_ctx\_first\_setup(dev\_priv, sw\_context, res,- ctx\_info);- if (ret) {- VMW\_DEBUG\_USER("Failed first usage context setup.\n");+ } else {+ priv\_size = vmw\_execbuf\_res\_size(dev\_priv, res\_type);+ ret = vmw\_validation\_add\_resource(sw\_context->ctx, res, priv\_size,+ dirty, (void \*\*)&ctx\_info,+ &first\_usage);+ if (ret) return ret;++ if (priv\_size && first\_usage) {+ ret = vmw\_cmd\_ctx\_first\_setup(dev\_priv, sw\_context, res,+ ctx\_info);+ if (ret) {+ VMW\_DEBUG\_USER("Failed first usage context setup.\n");+ return ret;+ } } } @@ -344,43 +356,6 @@ static int vmw\_execbuf\_res\_noref\_val\_add(struct vmw\_sw\_context \*sw\_context, }  /\*\*- \* vmw\_execbuf\_res\_noctx\_val\_add - Add a non-context resource to the resource- \* validation list if it's not already on it- \*- \* @sw\_context: Pointer to the software context.- \* @res: Pointer to the resource.- \* @dirty: Whether to change dirty status.- \*- \* Returns: Zero on success. Negative error code on failure.- \*/-static int vmw\_execbuf\_res\_noctx\_val\_add(struct vmw\_sw\_context \*sw\_context,- struct vmw\_resource \*res,- u32 dirty)-{- struct vmw\_res\_cache\_entry \*rcache;- enum vmw\_res\_type res\_type = vmw\_res\_type(res);- void \*ptr;- int ret;-- rcache = &sw\_context->res\_cache[res\_type];- if (likely(rcache->valid && rcache->res == res)) {- if (dirty)- vmw\_validation\_res\_set\_dirty(sw\_context->ctx,- rcache->private, dirty);- return 0;- }-- ret = vmw\_validation\_add\_resource(sw\_context->ctx, res, 0, dirty,- &ptr, NULL);- if (ret)- return ret;-- vmw\_execbuf\_rcache\_update(rcache, res, ptr);-- return 0;-}--/\*\* \* vmw\_view\_res\_val\_add - Add a view and the surface it's pointing to to the \* validation list \*@@ -398,13 +373,13 @@ static int vmw\_view\_res\_val\_add(struct vmw\_sw\_context \*sw\_context, \* First add the resource the view is pointing to, otherwise it may be \* swapped out when the view is validated. \*/- ret = vmw\_execbuf\_res\_noctx\_val\_add(sw\_context, vmw\_view\_srf(view),- vmw\_view\_dirtying(view));+ ret = vmw\_execbuf\_res\_val\_add(sw\_context, vmw\_view\_srf(view),+ vmw\_view\_dirtying(view), vmw\_val\_add\_flag\_noctx); if (ret) return ret; - return vmw\_execbuf\_res\_noctx\_val\_add(sw\_context, view,- VMW\_RES\_DIRTY\_NONE);+ return vmw\_execbuf\_res\_val\_add(sw\_context, view, VMW\_RES\_DIRTY\_NONE,+ vmw\_val\_add\_flag\_noctx); }  /\*\*@@ -475,8 +450,9 @@ static int vmw\_resource\_context\_res\_add(struct vmw\_private \*dev\_priv, if (IS\_ERR(res)) continue; - ret = vmw\_execbuf\_res\_noctx\_val\_add(sw\_context, res,- VMW\_RES\_DIRTY\_SET);+ ret = vmw\_execbuf\_res\_val\_add(sw\_context, res,+ VMW\_RES\_DIRTY\_SET,+ vmw\_val\_add\_flag\_noctx); if (unlikely(ret != 0)) return ret; }@@ -490,9 +466,9 @@ static int vmw\_resource\_context\_res\_add(struct vmw\_private \*dev\_priv, if (vmw\_res\_type(entry->res) == vmw\_res\_view) ret = vmw\_view\_res\_val\_add(sw\_context, entry->res); else- ret = vmw\_execbuf\_res\_noctx\_val\_add- (sw\_context, entry->res,- vmw\_binding\_dirtying(entry->bt));+ ret = vmw\_execbuf\_res\_val\_add(sw\_context, entry->res,+ vmw\_binding\_dirtying(entry->bt),+ vmw\_val\_add\_flag\_noctx); if (unlikely(ret != 0)) break; }@@ -658,7 +634,8 @@ vmw\_cmd\_res\_check(struct vmw\_private \*dev\_priv, { struct vmw\_res\_cache\_entry \*rcache = &sw\_context->res\_cache[res\_type]; struct vmw\_resource \*res;- int ret;+ int ret = 0;+ bool needs\_unref = false;  if (p\_res) \*p\_res = NULL;@@ -683,17 +660,18 @@ vmw\_cmd\_res\_check(struct vmw\_private \*dev\_priv, if (ret) return ret; - res = vmw\_user\_resource\_noref\_lookup\_handle- (dev\_priv, sw\_context->fp->tfile, \*id\_loc, converter);- if (IS\_ERR(res)) {+ ret = vmw\_user\_resource\_lookup\_handle+ (dev\_priv, sw\_context->fp->tfile, \*id\_loc, converter, &res);+ if (ret != 0) { VMW\_DEBUG\_USER("Could not find/use resource 0x%08x.\n", (unsigned int) \*id\_loc);- return PTR\_ERR(res);+ return ret; }+ needs\_unref = true; - ret = vmw\_execbuf\_res\_noref\_val\_add(sw\_context, res, dirty);+ ret = vmw\_execbuf\_res\_val\_add(sw\_context, res, dirty, vmw\_val\_add\_flag\_none); if (unlikely(ret != 0))- return ret;+ goto res\_check\_done;  if (rcache->valid && rcache->res == res) { rcache->valid\_handle = true;@@ -708,7 +686,11 @@ vmw\_cmd\_res\_check(struct vmw\_private \*dev\_priv, if (p\_res) \*p\_res = res; - return 0;+res\_check\_done:+ if (needs\_unref)+ vmw\_resource\_unreference(&res);++ return ret; }  /\*\*@@ -1171,9 +1153,9 @@ static int vmw\_translate\_mob\_ptr(struct vmw\_private \*dev\_priv, int ret;  vmw\_validation\_preload\_bo(sw\_context->ctx);- vmw\_bo = vmw\_user\_bo\_noref\_lookup(sw\_context->filp, handle);- if (IS\_ERR(vmw\_bo)) {- VMW\_DEBUG\_USER("Could not find or use MOB buffer.\n");+ ret = vmw\_user\_bo\_lookup(sw\_context->filp, handle, &vmw\_bo);+ if (ret != 0) {+ drm\_dbg(&dev\_priv->drm, "Could not find or use MOB buffer.\n"); return PTR\_ERR(vmw\_bo); } ret = vmw\_validation\_add\_bo(sw\_context->ctx, vmw\_bo, true, false);@@ -1225,9 +1207,9 @@ static int vmw\_translate\_guest\_ptr(struct vmw\_private \*dev\_priv, int ret;  vmw\_validation\_preload\_bo(sw\_context->ctx);- vmw\_bo = vmw\_user\_bo\_noref\_lookup(sw\_context->filp, handle);- if (IS\_ERR(vmw\_bo)) {- VMW\_DEBUG\_USER("Could not find or use GMR region.\n");+ ret = vmw\_user\_bo\_lookup(sw\_context->filp, handle, &vmw\_bo);+ if (ret != 0) {+ drm\_dbg(&dev\_priv->drm, "Could not find or use GMR region.\n"); return PTR\_ERR(vmw\_bo); } ret = vmw\_validation\_add\_bo(sw\_context->ctx, vmw\_bo, false, false);@@ -2025,8 +2007,9 @@ static int vmw\_cmd\_set\_shader(struct vmw\_private \*dev\_priv, res = vmw\_shader\_lookup(vmw\_context\_res\_man(ctx), cmd->body.shid, cmd->body.type); if (!IS\_ERR(res)) {- ret = vmw\_execbuf\_res\_noctx\_val\_add(sw\_context, res,- VMW\_RES\_DIRTY\_NONE);+ ret = vmw\_execbuf\_res\_val\_add(sw\_context, res,+ VMW\_RES\_DIRTY\_NONE,+ vmw\_val\_add\_flag\_noctx); if (unlikely(ret != 0)) return ret; @@ -2273,8 +2256,9 @@ static int vmw\_cmd\_dx\_set\_shader(struct vmw\_private \*dev\_priv, return PTR\_ERR(res); } - ret = vmw\_execbuf\_res\_noctx\_val\_add(sw\_context, res,- VMW\_RES\_DIRTY\_NONE);+ ret = vmw\_execbuf\_res\_val\_add(sw\_context, res,+ VMW\_RES\_DIRTY\_NONE,+ vmw\_val\_add\_flag\_noctx); if (ret) return ret; }@@ -2777,8 +2761,8 @@ static int vmw\_cmd\_dx\_bind\_shader(struct vmw\_private \*dev\_priv, return PTR\_ERR(res); } - ret = vmw\_execbuf\_res\_noctx\_val\_add(sw\_context, res,- VMW\_RES\_DIRTY\_NONE);+ ret = vmw\_execbuf\_res\_val\_add(sw\_context, res, VMW\_RES\_DIRTY\_NONE,+ vmw\_val\_add\_flag\_noctx); if (ret) { VMW\_DEBUG\_USER("Error creating resource validation node.\n"); return ret;@@ -3098,8 +3082,8 @@ static int vmw\_cmd\_dx\_bind\_streamoutput(struct vmw\_private \*dev\_priv,  vmw\_dx\_streamoutput\_set\_size(res, cmd->body.sizeInBytes); - ret = vmw\_execbuf\_res\_noctx\_val\_add(sw\_context, res,- VMW\_RES\_DIRTY\_NONE);+ ret = vmw\_execbuf\_res\_val\_add(sw\_context, res, VMW\_RES\_DIRTY\_NONE,+ vmw\_val\_add\_flag\_noctx); if (ret) { DRM\_ERROR("Error creating resource validation node.\n"); return ret;@@ -3148,8 +3132,8 @@ static int vmw\_cmd\_dx\_set\_streamoutput(struct vmw\_private \*dev\_priv, return 0; } - ret = vmw\_execbuf\_res\_noctx\_val\_add(sw\_context, res,- VMW\_RES\_DIRTY\_NONE);+ ret = vmw\_execbuf\_res\_val\_add(sw\_context, res, VMW\_RES\_DIRTY\_NONE,+ vmw\_val\_add\_flag\_noctx); if (ret) { DRM\_ERROR("Error creating resource validation node.\n"); return ret;@@ -4066,22 +4050,26 @@ static int vmw\_execbuf\_tie\_context(struct vmw\_private \*dev\_priv, if (ret) return ret; - res = vmw\_user\_resource\_noref\_lookup\_handle+ ret = vmw\_user\_resource\_lookup\_handle (dev\_priv, sw\_context->fp->tfile, handle,- user\_context\_converter);- if (IS\_ERR(res)) {+ user\_context\_converter, &res);+ if (ret != 0) { VMW\_DEBUG\_USER("Could not find or user DX context 0x%08x.\n", (unsigned int) handle);- return PTR\_ERR(res);+ return ret; } - ret = vmw\_execbuf\_res\_noref\_val\_add(sw\_context, res, VMW\_RES\_DIRTY\_SET);- if (unlikely(ret != 0))+ ret = vmw\_execbuf\_res\_val\_add(sw\_context, res, VMW\_RES\_DIRTY\_SET,+ vmw\_val\_add\_flag\_none);+ if (unlikely(ret != 0)) {+ vmw\_resource\_unreference(&res); return ret;+ }  sw\_context->dx\_ctx\_node = vmw\_execbuf\_info\_from\_res(sw\_context, res); sw\_context->man = vmw\_context\_res\_man(res); + vmw\_resource\_unreference(&res); return 0; } diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx\_resource.c b/drivers/gpu/drm/vmwgfx/vmwgfx\_resource.cindex f66caa540e1460..c7d645e5ec7bf8 100644--- a/[drivers/gpu/drm/vmwgfx/vmwgfx\_resource.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c?id=52531258318ed59a2dc5a43df2eaf0eb1d65438e)+++ b/[drivers/gpu/drm/vmwgfx/vmwgfx\_resource.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c?id=a309c7194e8a2f8bd4539b9449917913f6c2cd50)@@ -281,39 +281,6 @@ out\_bad\_resource: return ret; } -/\*\*- \* vmw\_user\_resource\_noref\_lookup\_handle - lookup a struct resource from a- \* TTM user-space handle and perform basic type checks- \*- \* @dev\_priv: Pointer to a device private struct- \* @tfile: Pointer to a struct ttm\_object\_file identifying the caller- \* @handle: The TTM user-space handle- \* @converter: Pointer to an object describing the resource type- \*- \* If the handle can't be found or is associated with an incorrect resource- \* type, -EINVAL will be returned.- \*/-struct vmw\_resource \*-vmw\_user\_resource\_noref\_lookup\_handle(struct vmw\_private \*dev\_priv,- struct ttm\_object\_file \*tfile,- uint32\_t handle,- const struct vmw\_user\_resource\_conv- \*converter)-{- struct ttm\_base\_object \*base;-- base = ttm\_base\_object\_noref\_lookup(tfile, handle);- if (!base)- return ERR\_PTR(-ESRCH);-- if (unlikely(ttm\_base\_object\_type(base) != converter->object\_type)) {- ttm\_base\_object\_noref\_release();- return ERR\_PTR(-EINVAL);- }-- return converter->base\_obj\_to\_res(base);-}- /\* \* Helper function that looks either a surface or bo. \* |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 14:58:57 +0000

