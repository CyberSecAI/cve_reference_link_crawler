```
{
  "vulnerability": {
    "root_cause": "The `req->dst` buffer size was not checked before copying data from `scomp_scratch->dst`, which could lead to a buffer overflow.",
    "weaknesses": [
      "Buffer Overflow"
    ],
    "impact": "A buffer overflow could lead to memory corruption and potentially arbitrary code execution.",
    "attack_vectors": "An attacker can trigger the vulnerability by sending a crafted request to the `scomp_acomp_comp_decomp` function with a `req->dlen` value larger than the allocated `req->dst` buffer.",
    "required_capabilities": "An attacker needs to be able to interact with the kernel's crypto subsystem and send crafted requests to the `scomp_acomp_comp_decomp` function."
  },
    "patches": [
        {
            "commit_id": "744e1885922a9943458954cfea917b31064b4131",
            "description": "The req->dst buffer size should be checked before copying from the scomp_scratch->dst to avoid req->dst buffer overflow problem.",
            "file_changes": {
                "crypto/scompress.c": {
                    "insertions": 6,
                    "deletions": 0
                 }
            },
           "patch_code": "@@ -117,6 +117,7 @@\n static int scomp_acomp_comp_decomp(struct acomp_req *req, int dir)\n {\n \tstruct crypto_scomp *scomp = *tfm_ctx;\n \tvoid **ctx = acomp_request_ctx(req);\n \tstruct scomp_scratch *scratch;\n+\tunsigned int dlen;\n\tint ret;\n \n \tif (!req->src || !req->slen || req->slen > SCOMP_SCRATCH_SIZE)\n@@ -128,6 +129,8 @@\n \tif (!req->dlen || req->dlen > SCOMP_SCRATCH_SIZE)\n \t\treq->dlen = SCOMP_SCRATCH_SIZE;\n \n+\tdlen = req->dlen;\n+\tscratch = raw_cpu_ptr(&scomp_scratch);\n \tspin_lock(&scratch->lock);\n \n \t*ctx = scratch;\n@@ -145,6 +148,9 @@\n \tret = -ENOMEM;\n \tgoto out;\n }\n+\t} else if (req->dlen > dlen) {\n+\tret = -ENOSPC;\n+\tgoto out;\n+}\n \tscatterwalk_map_and_copy(scratch->dst, req->dst, 0, req->dlen, 1);"
         }
    ]
}
```