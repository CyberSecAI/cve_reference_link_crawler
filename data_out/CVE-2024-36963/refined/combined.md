=== Content from git.kernel.org_b0417d44_20250111_032344.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=5f91fc82794d4a6e41cdcd02d00baa377d94ca78)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=5f91fc82794d4a6e41cdcd02d00baa377d94ca78)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=5f91fc82794d4a6e41cdcd02d00baa377d94ca78)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5f91fc82794d4a6e41cdcd02d00baa377d94ca78)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Steven Rostedt (Google) <rostedt@goodmis.org> | 2024-05-02 16:08:23 -0400 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-05-17 12:02:37 +0200 |
| commit | [5f91fc82794d4a6e41cdcd02d00baa377d94ca78](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=5f91fc82794d4a6e41cdcd02d00baa377d94ca78) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=5f91fc82794d4a6e41cdcd02d00baa377d94ca78)) | |
| tree | [3c3403dbde35300b823579e3375dc29c6977cd67](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=5f91fc82794d4a6e41cdcd02d00baa377d94ca78) | |
| parent | [100117279c1da02a43d76098a4eba52c26079847](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=100117279c1da02a43d76098a4eba52c26079847) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5f91fc82794d4a6e41cdcd02d00baa377d94ca78&id2=100117279c1da02a43d76098a4eba52c26079847)) | |
| download | [linux-5f91fc82794d4a6e41cdcd02d00baa377d94ca78.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-5f91fc82794d4a6e41cdcd02d00baa377d94ca78.tar.gz) | |

tracefs: Reset permissions on remount if permissions are optionscommit baa23a8d4360d981a49913841a726edede5cdd54 upstream.
There's an inconsistency with the way permissions are handled in tracefs.
Because the permissions are generated when accessed, they default to the
root inode's permission if they were never set by the user. If the user
sets the permissions, then a flag is set and the permissions are saved via
the inode (for tracefs files) or an internal attribute field (for
eventfs).
But if a remount happens that specify the permissions, all the files that
were not changed by the user gets updated, but the ones that were are not.
If the user were to remount the file system with a given permission, then
all files and directories within that file system should be updated.
This can cause security issues if a file's permission was updated but the
admin forgot about it. They could incorrectly think that remounting with
permissions set would update all files, but miss some.
For example:
# cd /sys/kernel/tracing
# chgrp 1002 current\_tracer
# ls -l
[..]
-rw-r----- 1 root root 0 May 1 21:25 buffer\_size\_kb
-rw-r----- 1 root root 0 May 1 21:25 buffer\_subbuf\_size\_kb
-r--r----- 1 root root 0 May 1 21:25 buffer\_total\_size\_kb
-rw-r----- 1 root lkp 0 May 1 21:25 current\_tracer
-rw-r----- 1 root root 0 May 1 21:25 dynamic\_events
-r--r----- 1 root root 0 May 1 21:25 dyn\_ftrace\_total\_info
-r--r----- 1 root root 0 May 1 21:25 enabled\_functions
Where current\_tracer now has group "lkp".
# mount -o remount,gid=1001 .
# ls -l
-rw-r----- 1 root tracing 0 May 1 21:25 buffer\_size\_kb
-rw-r----- 1 root tracing 0 May 1 21:25 buffer\_subbuf\_size\_kb
-r--r----- 1 root tracing 0 May 1 21:25 buffer\_total\_size\_kb
-rw-r----- 1 root lkp 0 May 1 21:25 current\_tracer
-rw-r----- 1 root tracing 0 May 1 21:25 dynamic\_events
-r--r----- 1 root tracing 0 May 1 21:25 dyn\_ftrace\_total\_info
-r--r----- 1 root tracing 0 May 1 21:25 enabled\_functions
Everything changed but the "current\_tracer".
Add a new link list that keeps track of all the tracefs\_inodes which has
the permission flags that tell if the file/dir should use the root inode's
permission or not. Then on remount, clear all the flags so that the
default behavior of using the root inode's permission is done for all
files and directories.
Link: [https://lore.kernel.org/linux-trace-kernel/20240502200905.529542160@goodmis.org](https://lore.kernel.org/linux-trace-kernel/20240502200905.529542160%40goodmis.org)
Cc: stable@vger.kernel.org
Cc: Masami Hiramatsu <mhiramat@kernel.org>
Cc: Mark Rutland <mark.rutland@arm.com>
Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Cc: Andrew Morton <akpm@linux-foundation.org>
Fixes: 8186fff7ab649 ("tracefs/eventfs: Use root and instance inodes as default ownership")
Signed-off-by: Steven Rostedt (Google) <rostedt@goodmis.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5f91fc82794d4a6e41cdcd02d00baa377d94ca78)

| -rw-r--r-- | [fs/tracefs/event\_inode.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/tracefs/event_inode.c?id=5f91fc82794d4a6e41cdcd02d00baa377d94ca78) | 29 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/tracefs/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/tracefs/inode.c?id=5f91fc82794d4a6e41cdcd02d00baa377d94ca78) | 65 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/tracefs/internal.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/tracefs/internal.h?id=5f91fc82794d4a6e41cdcd02d00baa377d94ca78) | 7 | |  |  |  | | --- | --- | --- | |

3 files changed, 99 insertions, 2 deletions

| diff --git a/fs/tracefs/event\_inode.c b/fs/tracefs/event\_inode.cindex 110e8a27218900..c5c5d66234aaea 100644--- a/[fs/tracefs/event\_inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/tracefs/event_inode.c?id=100117279c1da02a43d76098a4eba52c26079847)+++ b/[fs/tracefs/event\_inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/tracefs/event_inode.c?id=5f91fc82794d4a6e41cdcd02d00baa377d94ca78)@@ -265,6 +265,35 @@ static const struct file\_operations eventfs\_file\_operations = { .llseek = generic\_file\_llseek, }; +/\*+ \* On a remount of tracefs, if UID or GID options are set, then+ \* the mount point inode permissions should be used.+ \* Reset the saved permission flags appropriately.+ \*/+void eventfs\_remount(struct tracefs\_inode \*ti, bool update\_uid, bool update\_gid)+{+ struct eventfs\_inode \*ei = ti->private;++ if (!ei)+ return;++ if (update\_uid)+ ei->attr.mode &= ~EVENTFS\_SAVE\_UID;++ if (update\_gid)+ ei->attr.mode &= ~EVENTFS\_SAVE\_GID;++ if (!ei->entry\_attrs)+ return;++ for (int i = 0; i < ei->nr\_entries; i++) {+ if (update\_uid)+ ei->entry\_attrs[i].mode &= ~EVENTFS\_SAVE\_UID;+ if (update\_gid)+ ei->entry\_attrs[i].mode &= ~EVENTFS\_SAVE\_GID;+ }+}+ /\* Return the evenfs\_inode of the "events" directory \*/ static struct eventfs\_inode \*eventfs\_find\_events(struct dentry \*dentry) {diff --git a/fs/tracefs/inode.c b/fs/tracefs/inode.cindex 99caf1c3d0c410..12aa5266673bc3 100644--- a/[fs/tracefs/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/tracefs/inode.c?id=100117279c1da02a43d76098a4eba52c26079847)+++ b/[fs/tracefs/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/tracefs/inode.c?id=5f91fc82794d4a6e41cdcd02d00baa377d94ca78)@@ -30,20 +30,47 @@ static struct vfsmount \*tracefs\_mount; static int tracefs\_mount\_count; static bool tracefs\_registered; +/\*+ \* Keep track of all tracefs\_inodes in order to update their+ \* flags if necessary on a remount.+ \*/+static DEFINE\_SPINLOCK(tracefs\_inode\_lock);+static LIST\_HEAD(tracefs\_inodes);+ static struct inode \*tracefs\_alloc\_inode(struct super\_block \*sb) { struct tracefs\_inode \*ti;+ unsigned long flags;  ti = kmem\_cache\_alloc(tracefs\_inode\_cachep, GFP\_KERNEL); if (!ti) return NULL; + spin\_lock\_irqsave(&tracefs\_inode\_lock, flags);+ list\_add\_rcu(&ti->list, &tracefs\_inodes);+ spin\_unlock\_irqrestore(&tracefs\_inode\_lock, flags);+ return &ti->vfs\_inode; } +static void tracefs\_free\_inode\_rcu(struct rcu\_head \*rcu)+{+ struct tracefs\_inode \*ti;++ ti = container\_of(rcu, struct tracefs\_inode, rcu);+ kmem\_cache\_free(tracefs\_inode\_cachep, ti);+}+ static void tracefs\_free\_inode(struct inode \*inode) {- kmem\_cache\_free(tracefs\_inode\_cachep, get\_tracefs(inode));+ struct tracefs\_inode \*ti = get\_tracefs(inode);+ unsigned long flags;++ spin\_lock\_irqsave(&tracefs\_inode\_lock, flags);+ list\_del\_rcu(&ti->list);+ spin\_unlock\_irqrestore(&tracefs\_inode\_lock, flags);++ call\_rcu(&ti->rcu, tracefs\_free\_inode\_rcu); }  static ssize\_t default\_read\_file(struct file \*file, char \_\_user \*buf,@@ -313,6 +340,8 @@ static int tracefs\_apply\_options(struct super\_block \*sb, bool remount) struct tracefs\_fs\_info \*fsi = sb->s\_fs\_info; struct inode \*inode = d\_inode(sb->s\_root); struct tracefs\_mount\_opts \*opts = &fsi->mount\_opts;+ struct tracefs\_inode \*ti;+ bool update\_uid, update\_gid; umode\_t tmp\_mode;  /\*@@ -332,6 +361,25 @@ static int tracefs\_apply\_options(struct super\_block \*sb, bool remount) if (!remount || opts->opts & BIT(Opt\_gid)) inode->i\_gid = opts->gid; + if (remount && (opts->opts & BIT(Opt\_uid) || opts->opts & BIT(Opt\_gid))) {++ update\_uid = opts->opts & BIT(Opt\_uid);+ update\_gid = opts->opts & BIT(Opt\_gid);++ rcu\_read\_lock();+ list\_for\_each\_entry\_rcu(ti, &tracefs\_inodes, list) {+ if (update\_uid)+ ti->flags &= ~TRACEFS\_UID\_PERM\_SET;++ if (update\_gid)+ ti->flags &= ~TRACEFS\_GID\_PERM\_SET;++ if (ti->flags & TRACEFS\_EVENT\_INODE)+ eventfs\_remount(ti, update\_uid, update\_gid);+ }+ rcu\_read\_unlock();+ }+ return 0; } @@ -398,7 +446,22 @@ static int tracefs\_d\_revalidate(struct dentry \*dentry, unsigned int flags) return !(ei && ei->is\_freed); } +static void tracefs\_d\_iput(struct dentry \*dentry, struct inode \*inode)+{+ struct tracefs\_inode \*ti = get\_tracefs(inode);++ /\*+ \* This inode is being freed and cannot be used for+ \* eventfs. Clear the flag so that it doesn't call into+ \* eventfs during the remount flag updates. The eventfs\_inode+ \* gets freed after an RCU cycle, so the content will still+ \* be safe if the iteration is going on now.+ \*/+ ti->flags &= ~TRACEFS\_EVENT\_INODE;+}+ static const struct dentry\_operations tracefs\_dentry\_operations = {+ .d\_iput = tracefs\_d\_iput, .d\_revalidate = tracefs\_d\_revalidate, .d\_release = tracefs\_d\_release, };diff --git a/fs/tracefs/internal.h b/fs/tracefs/internal.hindex beb3dcd0e43420..824cbe83679cc8 100644--- a/[fs/tracefs/internal.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/tracefs/internal.h?id=100117279c1da02a43d76098a4eba52c26079847)+++ b/[fs/tracefs/internal.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/tracefs/internal.h?id=5f91fc82794d4a6e41cdcd02d00baa377d94ca78)@@ -11,8 +11,12 @@ enum { };  struct tracefs\_inode {- struct inode vfs\_inode;+ union {+ struct inode vfs\_inode;+ struct rcu\_head rcu;+ }; /\* The below gets initialized with memset\_after(ti, 0, vfs\_inode) \*/+ struct list\_head list; unsigned long flags; void \*private; };@@ -75,6 +79,7 @@ struct dentry \*tracefs\_end\_creating(struct dentry \*dentry); struct dentry \*tracefs\_failed\_creating(struct dentry \*dentry); struct inode \*tracefs\_get\_inode(struct super\_block \*sb); +void eventfs\_remount(struct tracefs\_inode \*ti, bool update\_uid, bool update\_gid); void eventfs\_d\_release(struct dentry \*dentry);  #endif /\* \_TRACEFS\_INTERNAL\_H \*/ |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 03:22:22 +0000



=== Content from git.kernel.org_a3454cc4_20250111_032344.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=414fb08628143203d29ccd0264b5a83fb9523c03)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=414fb08628143203d29ccd0264b5a83fb9523c03)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=414fb08628143203d29ccd0264b5a83fb9523c03)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=414fb08628143203d29ccd0264b5a83fb9523c03)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Steven Rostedt (Google) <rostedt@goodmis.org> | 2024-05-02 16:08:23 -0400 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-05-17 12:15:10 +0200 |
| commit | [414fb08628143203d29ccd0264b5a83fb9523c03](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=414fb08628143203d29ccd0264b5a83fb9523c03) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=414fb08628143203d29ccd0264b5a83fb9523c03)) | |
| tree | [ccd0fc9f639d7cd76c45eea46671b214272ba360](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=414fb08628143203d29ccd0264b5a83fb9523c03) | |
| parent | [209e25da5f66b4f08a3ac0aa738a27265519a97a](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=209e25da5f66b4f08a3ac0aa738a27265519a97a) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=414fb08628143203d29ccd0264b5a83fb9523c03&id2=209e25da5f66b4f08a3ac0aa738a27265519a97a)) | |
| download | [linux-414fb08628143203d29ccd0264b5a83fb9523c03.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-414fb08628143203d29ccd0264b5a83fb9523c03.tar.gz) | |

tracefs: Reset permissions on remount if permissions are optionscommit baa23a8d4360d981a49913841a726edede5cdd54 upstream.
There's an inconsistency with the way permissions are handled in tracefs.
Because the permissions are generated when accessed, they default to the
root inode's permission if they were never set by the user. If the user
sets the permissions, then a flag is set and the permissions are saved via
the inode (for tracefs files) or an internal attribute field (for
eventfs).
But if a remount happens that specify the permissions, all the files that
were not changed by the user gets updated, but the ones that were are not.
If the user were to remount the file system with a given permission, then
all files and directories within that file system should be updated.
This can cause security issues if a file's permission was updated but the
admin forgot about it. They could incorrectly think that remounting with
permissions set would update all files, but miss some.
For example:
# cd /sys/kernel/tracing
# chgrp 1002 current\_tracer
# ls -l
[..]
-rw-r----- 1 root root 0 May 1 21:25 buffer\_size\_kb
-rw-r----- 1 root root 0 May 1 21:25 buffer\_subbuf\_size\_kb
-r--r----- 1 root root 0 May 1 21:25 buffer\_total\_size\_kb
-rw-r----- 1 root lkp 0 May 1 21:25 current\_tracer
-rw-r----- 1 root root 0 May 1 21:25 dynamic\_events
-r--r----- 1 root root 0 May 1 21:25 dyn\_ftrace\_total\_info
-r--r----- 1 root root 0 May 1 21:25 enabled\_functions
Where current\_tracer now has group "lkp".
# mount -o remount,gid=1001 .
# ls -l
-rw-r----- 1 root tracing 0 May 1 21:25 buffer\_size\_kb
-rw-r----- 1 root tracing 0 May 1 21:25 buffer\_subbuf\_size\_kb
-r--r----- 1 root tracing 0 May 1 21:25 buffer\_total\_size\_kb
-rw-r----- 1 root lkp 0 May 1 21:25 current\_tracer
-rw-r----- 1 root tracing 0 May 1 21:25 dynamic\_events
-r--r----- 1 root tracing 0 May 1 21:25 dyn\_ftrace\_total\_info
-r--r----- 1 root tracing 0 May 1 21:25 enabled\_functions
Everything changed but the "current\_tracer".
Add a new link list that keeps track of all the tracefs\_inodes which has
the permission flags that tell if the file/dir should use the root inode's
permission or not. Then on remount, clear all the flags so that the
default behavior of using the root inode's permission is done for all
files and directories.
Link: [https://lore.kernel.org/linux-trace-kernel/20240502200905.529542160@goodmis.org](https://lore.kernel.org/linux-trace-kernel/20240502200905.529542160%40goodmis.org)
Cc: stable@vger.kernel.org
Cc: Masami Hiramatsu <mhiramat@kernel.org>
Cc: Mark Rutland <mark.rutland@arm.com>
Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Cc: Andrew Morton <akpm@linux-foundation.org>
Fixes: 8186fff7ab649 ("tracefs/eventfs: Use root and instance inodes as default ownership")
Signed-off-by: Steven Rostedt (Google) <rostedt@goodmis.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=414fb08628143203d29ccd0264b5a83fb9523c03)

| -rw-r--r-- | [fs/tracefs/event\_inode.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/tracefs/event_inode.c?id=414fb08628143203d29ccd0264b5a83fb9523c03) | 29 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/tracefs/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/tracefs/inode.c?id=414fb08628143203d29ccd0264b5a83fb9523c03) | 65 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/tracefs/internal.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/tracefs/internal.h?id=414fb08628143203d29ccd0264b5a83fb9523c03) | 7 | |  |  |  | | --- | --- | --- | |

3 files changed, 99 insertions, 2 deletions

| diff --git a/fs/tracefs/event\_inode.c b/fs/tracefs/event\_inode.cindex 110e8a27218900..c5c5d66234aaea 100644--- a/[fs/tracefs/event\_inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/tracefs/event_inode.c?id=209e25da5f66b4f08a3ac0aa738a27265519a97a)+++ b/[fs/tracefs/event\_inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/tracefs/event_inode.c?id=414fb08628143203d29ccd0264b5a83fb9523c03)@@ -265,6 +265,35 @@ static const struct file\_operations eventfs\_file\_operations = { .llseek = generic\_file\_llseek, }; +/\*+ \* On a remount of tracefs, if UID or GID options are set, then+ \* the mount point inode permissions should be used.+ \* Reset the saved permission flags appropriately.+ \*/+void eventfs\_remount(struct tracefs\_inode \*ti, bool update\_uid, bool update\_gid)+{+ struct eventfs\_inode \*ei = ti->private;++ if (!ei)+ return;++ if (update\_uid)+ ei->attr.mode &= ~EVENTFS\_SAVE\_UID;++ if (update\_gid)+ ei->attr.mode &= ~EVENTFS\_SAVE\_GID;++ if (!ei->entry\_attrs)+ return;++ for (int i = 0; i < ei->nr\_entries; i++) {+ if (update\_uid)+ ei->entry\_attrs[i].mode &= ~EVENTFS\_SAVE\_UID;+ if (update\_gid)+ ei->entry\_attrs[i].mode &= ~EVENTFS\_SAVE\_GID;+ }+}+ /\* Return the evenfs\_inode of the "events" directory \*/ static struct eventfs\_inode \*eventfs\_find\_events(struct dentry \*dentry) {diff --git a/fs/tracefs/inode.c b/fs/tracefs/inode.cindex d65ffad4c327ca..12b58e6713e8e2 100644--- a/[fs/tracefs/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/tracefs/inode.c?id=209e25da5f66b4f08a3ac0aa738a27265519a97a)+++ b/[fs/tracefs/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/tracefs/inode.c?id=414fb08628143203d29ccd0264b5a83fb9523c03)@@ -30,20 +30,47 @@ static struct vfsmount \*tracefs\_mount; static int tracefs\_mount\_count; static bool tracefs\_registered; +/\*+ \* Keep track of all tracefs\_inodes in order to update their+ \* flags if necessary on a remount.+ \*/+static DEFINE\_SPINLOCK(tracefs\_inode\_lock);+static LIST\_HEAD(tracefs\_inodes);+ static struct inode \*tracefs\_alloc\_inode(struct super\_block \*sb) { struct tracefs\_inode \*ti;+ unsigned long flags;  ti = kmem\_cache\_alloc(tracefs\_inode\_cachep, GFP\_KERNEL); if (!ti) return NULL; + spin\_lock\_irqsave(&tracefs\_inode\_lock, flags);+ list\_add\_rcu(&ti->list, &tracefs\_inodes);+ spin\_unlock\_irqrestore(&tracefs\_inode\_lock, flags);+ return &ti->vfs\_inode; } +static void tracefs\_free\_inode\_rcu(struct rcu\_head \*rcu)+{+ struct tracefs\_inode \*ti;++ ti = container\_of(rcu, struct tracefs\_inode, rcu);+ kmem\_cache\_free(tracefs\_inode\_cachep, ti);+}+ static void tracefs\_free\_inode(struct inode \*inode) {- kmem\_cache\_free(tracefs\_inode\_cachep, get\_tracefs(inode));+ struct tracefs\_inode \*ti = get\_tracefs(inode);+ unsigned long flags;++ spin\_lock\_irqsave(&tracefs\_inode\_lock, flags);+ list\_del\_rcu(&ti->list);+ spin\_unlock\_irqrestore(&tracefs\_inode\_lock, flags);++ call\_rcu(&ti->rcu, tracefs\_free\_inode\_rcu); }  static ssize\_t default\_read\_file(struct file \*file, char \_\_user \*buf,@@ -313,6 +340,8 @@ static int tracefs\_apply\_options(struct super\_block \*sb, bool remount) struct tracefs\_fs\_info \*fsi = sb->s\_fs\_info; struct inode \*inode = d\_inode(sb->s\_root); struct tracefs\_mount\_opts \*opts = &fsi->mount\_opts;+ struct tracefs\_inode \*ti;+ bool update\_uid, update\_gid; umode\_t tmp\_mode;  /\*@@ -332,6 +361,25 @@ static int tracefs\_apply\_options(struct super\_block \*sb, bool remount) if (!remount || opts->opts & BIT(Opt\_gid)) inode->i\_gid = opts->gid; + if (remount && (opts->opts & BIT(Opt\_uid) || opts->opts & BIT(Opt\_gid))) {++ update\_uid = opts->opts & BIT(Opt\_uid);+ update\_gid = opts->opts & BIT(Opt\_gid);++ rcu\_read\_lock();+ list\_for\_each\_entry\_rcu(ti, &tracefs\_inodes, list) {+ if (update\_uid)+ ti->flags &= ~TRACEFS\_UID\_PERM\_SET;++ if (update\_gid)+ ti->flags &= ~TRACEFS\_GID\_PERM\_SET;++ if (ti->flags & TRACEFS\_EVENT\_INODE)+ eventfs\_remount(ti, update\_uid, update\_gid);+ }+ rcu\_read\_unlock();+ }+ return 0; } @@ -398,7 +446,22 @@ static int tracefs\_d\_revalidate(struct dentry \*dentry, unsigned int flags) return !(ei && ei->is\_freed); } +static void tracefs\_d\_iput(struct dentry \*dentry, struct inode \*inode)+{+ struct tracefs\_inode \*ti = get\_tracefs(inode);++ /\*+ \* This inode is being freed and cannot be used for+ \* eventfs. Clear the flag so that it doesn't call into+ \* eventfs during the remount flag updates. The eventfs\_inode+ \* gets freed after an RCU cycle, so the content will still+ \* be safe if the iteration is going on now.+ \*/+ ti->flags &= ~TRACEFS\_EVENT\_INODE;+}+ static const struct dentry\_operations tracefs\_dentry\_operations = {+ .d\_iput = tracefs\_d\_iput, .d\_revalidate = tracefs\_d\_revalidate, .d\_release = tracefs\_d\_release, };diff --git a/fs/tracefs/internal.h b/fs/tracefs/internal.hindex beb3dcd0e43420..824cbe83679cc8 100644--- a/[fs/tracefs/internal.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/tracefs/internal.h?id=209e25da5f66b4f08a3ac0aa738a27265519a97a)+++ b/[fs/tracefs/internal.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/tracefs/internal.h?id=414fb08628143203d29ccd0264b5a83fb9523c03)@@ -11,8 +11,12 @@ enum { };  struct tracefs\_inode {- struct inode vfs\_inode;+ union {+ struct inode vfs\_inode;+ struct rcu\_head rcu;+ }; /\* The below gets initialized with memset\_after(ti, 0, vfs\_inode) \*/+ struct list\_head list; unsigned long flags; void \*private; };@@ -75,6 +79,7 @@ struct dentry \*tracefs\_end\_creating(struct dentry \*dentry); struct dentry \*tracefs\_failed\_creating(struct dentry \*dentry); struct inode \*tracefs\_get\_inode(struct super\_block \*sb); +void eventfs\_remount(struct tracefs\_inode \*ti, bool update\_uid, bool update\_gid); void eventfs\_d\_release(struct dentry \*dentry);  #endif /\* \_TRACEFS\_INTERNAL\_H \*/ |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 03:22:21 +0000



=== Content from git.kernel.org_babcf7fb_20250111_032345.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=baa23a8d4360d981a49913841a726edede5cdd54)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=baa23a8d4360d981a49913841a726edede5cdd54)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=baa23a8d4360d981a49913841a726edede5cdd54)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=baa23a8d4360d981a49913841a726edede5cdd54)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Steven Rostedt (Google) <rostedt@goodmis.org> | 2024-05-02 16:08:23 -0400 |
| --- | --- | --- |
| committer | Steven Rostedt (Google) <rostedt@goodmis.org> | 2024-05-04 04:25:37 -0400 |
| commit | [baa23a8d4360d981a49913841a726edede5cdd54](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=baa23a8d4360d981a49913841a726edede5cdd54) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=baa23a8d4360d981a49913841a726edede5cdd54)) | |
| tree | [e1916f0ac4d9801f269ef1ddcc48cc824a358908](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=baa23a8d4360d981a49913841a726edede5cdd54) | |
| parent | [ee4e0379475e4fe723986ae96293e465014fa8d9](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ee4e0379475e4fe723986ae96293e465014fa8d9) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=baa23a8d4360d981a49913841a726edede5cdd54&id2=ee4e0379475e4fe723986ae96293e465014fa8d9)) | |
| download | [linux-baa23a8d4360d981a49913841a726edede5cdd54.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-baa23a8d4360d981a49913841a726edede5cdd54.tar.gz) | |

tracefs: Reset permissions on remount if permissions are optionsThere's an inconsistency with the way permissions are handled in tracefs.
Because the permissions are generated when accessed, they default to the
root inode's permission if they were never set by the user. If the user
sets the permissions, then a flag is set and the permissions are saved via
the inode (for tracefs files) or an internal attribute field (for
eventfs).
But if a remount happens that specify the permissions, all the files that
were not changed by the user gets updated, but the ones that were are not.
If the user were to remount the file system with a given permission, then
all files and directories within that file system should be updated.
This can cause security issues if a file's permission was updated but the
admin forgot about it. They could incorrectly think that remounting with
permissions set would update all files, but miss some.
For example:
# cd /sys/kernel/tracing
# chgrp 1002 current\_tracer
# ls -l
[..]
-rw-r----- 1 root root 0 May 1 21:25 buffer\_size\_kb
-rw-r----- 1 root root 0 May 1 21:25 buffer\_subbuf\_size\_kb
-r--r----- 1 root root 0 May 1 21:25 buffer\_total\_size\_kb
-rw-r----- 1 root lkp 0 May 1 21:25 current\_tracer
-rw-r----- 1 root root 0 May 1 21:25 dynamic\_events
-r--r----- 1 root root 0 May 1 21:25 dyn\_ftrace\_total\_info
-r--r----- 1 root root 0 May 1 21:25 enabled\_functions
Where current\_tracer now has group "lkp".
# mount -o remount,gid=1001 .
# ls -l
-rw-r----- 1 root tracing 0 May 1 21:25 buffer\_size\_kb
-rw-r----- 1 root tracing 0 May 1 21:25 buffer\_subbuf\_size\_kb
-r--r----- 1 root tracing 0 May 1 21:25 buffer\_total\_size\_kb
-rw-r----- 1 root lkp 0 May 1 21:25 current\_tracer
-rw-r----- 1 root tracing 0 May 1 21:25 dynamic\_events
-r--r----- 1 root tracing 0 May 1 21:25 dyn\_ftrace\_total\_info
-r--r----- 1 root tracing 0 May 1 21:25 enabled\_functions
Everything changed but the "current\_tracer".
Add a new link list that keeps track of all the tracefs\_inodes which has
the permission flags that tell if the file/dir should use the root inode's
permission or not. Then on remount, clear all the flags so that the
default behavior of using the root inode's permission is done for all
files and directories.
Link: [https://lore.kernel.org/linux-trace-kernel/20240502200905.529542160@goodmis.org](https://lore.kernel.org/linux-trace-kernel/20240502200905.529542160%40goodmis.org)
Cc: stable@vger.kernel.org
Cc: Masami Hiramatsu <mhiramat@kernel.org>
Cc: Mark Rutland <mark.rutland@arm.com>
Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Cc: Andrew Morton <akpm@linux-foundation.org>
Fixes: 8186fff7ab649 ("tracefs/eventfs: Use root and instance inodes as default ownership")
Signed-off-by: Steven Rostedt (Google) <rostedt@goodmis.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=baa23a8d4360d981a49913841a726edede5cdd54)

| -rw-r--r-- | [fs/tracefs/event\_inode.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/tracefs/event_inode.c?id=baa23a8d4360d981a49913841a726edede5cdd54) | 29 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/tracefs/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/tracefs/inode.c?id=baa23a8d4360d981a49913841a726edede5cdd54) | 65 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/tracefs/internal.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/tracefs/internal.h?id=baa23a8d4360d981a49913841a726edede5cdd54) | 7 | |  |  |  | | --- | --- | --- | |

3 files changed, 99 insertions, 2 deletions

| diff --git a/fs/tracefs/event\_inode.c b/fs/tracefs/event\_inode.cindex cc8b838bbe6260..15a2a9c3c62b04 100644--- a/[fs/tracefs/event\_inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/tracefs/event_inode.c?id=ee4e0379475e4fe723986ae96293e465014fa8d9)+++ b/[fs/tracefs/event\_inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/tracefs/event_inode.c?id=baa23a8d4360d981a49913841a726edede5cdd54)@@ -308,6 +308,35 @@ static const struct file\_operations eventfs\_file\_operations = { .llseek = generic\_file\_llseek, }; +/\*+ \* On a remount of tracefs, if UID or GID options are set, then+ \* the mount point inode permissions should be used.+ \* Reset the saved permission flags appropriately.+ \*/+void eventfs\_remount(struct tracefs\_inode \*ti, bool update\_uid, bool update\_gid)+{+ struct eventfs\_inode \*ei = ti->private;++ if (!ei)+ return;++ if (update\_uid)+ ei->attr.mode &= ~EVENTFS\_SAVE\_UID;++ if (update\_gid)+ ei->attr.mode &= ~EVENTFS\_SAVE\_GID;++ if (!ei->entry\_attrs)+ return;++ for (int i = 0; i < ei->nr\_entries; i++) {+ if (update\_uid)+ ei->entry\_attrs[i].mode &= ~EVENTFS\_SAVE\_UID;+ if (update\_gid)+ ei->entry\_attrs[i].mode &= ~EVENTFS\_SAVE\_GID;+ }+}+ /\* Return the evenfs\_inode of the "events" directory \*/ static struct eventfs\_inode \*eventfs\_find\_events(struct dentry \*dentry) {diff --git a/fs/tracefs/inode.c b/fs/tracefs/inode.cindex 5545e6bf7d26c4..52aa14bd299469 100644--- a/[fs/tracefs/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/tracefs/inode.c?id=ee4e0379475e4fe723986ae96293e465014fa8d9)+++ b/[fs/tracefs/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/tracefs/inode.c?id=baa23a8d4360d981a49913841a726edede5cdd54)@@ -30,20 +30,47 @@ static struct vfsmount \*tracefs\_mount; static int tracefs\_mount\_count; static bool tracefs\_registered; +/\*+ \* Keep track of all tracefs\_inodes in order to update their+ \* flags if necessary on a remount.+ \*/+static DEFINE\_SPINLOCK(tracefs\_inode\_lock);+static LIST\_HEAD(tracefs\_inodes);+ static struct inode \*tracefs\_alloc\_inode(struct super\_block \*sb) { struct tracefs\_inode \*ti;+ unsigned long flags;  ti = kmem\_cache\_alloc(tracefs\_inode\_cachep, GFP\_KERNEL); if (!ti) return NULL; + spin\_lock\_irqsave(&tracefs\_inode\_lock, flags);+ list\_add\_rcu(&ti->list, &tracefs\_inodes);+ spin\_unlock\_irqrestore(&tracefs\_inode\_lock, flags);+ return &ti->vfs\_inode; } +static void tracefs\_free\_inode\_rcu(struct rcu\_head \*rcu)+{+ struct tracefs\_inode \*ti;++ ti = container\_of(rcu, struct tracefs\_inode, rcu);+ kmem\_cache\_free(tracefs\_inode\_cachep, ti);+}+ static void tracefs\_free\_inode(struct inode \*inode) {- kmem\_cache\_free(tracefs\_inode\_cachep, get\_tracefs(inode));+ struct tracefs\_inode \*ti = get\_tracefs(inode);+ unsigned long flags;++ spin\_lock\_irqsave(&tracefs\_inode\_lock, flags);+ list\_del\_rcu(&ti->list);+ spin\_unlock\_irqrestore(&tracefs\_inode\_lock, flags);++ call\_rcu(&ti->rcu, tracefs\_free\_inode\_rcu); }  static ssize\_t default\_read\_file(struct file \*file, char \_\_user \*buf,@@ -313,6 +340,8 @@ static int tracefs\_apply\_options(struct super\_block \*sb, bool remount) struct tracefs\_fs\_info \*fsi = sb->s\_fs\_info; struct inode \*inode = d\_inode(sb->s\_root); struct tracefs\_mount\_opts \*opts = &fsi->mount\_opts;+ struct tracefs\_inode \*ti;+ bool update\_uid, update\_gid; umode\_t tmp\_mode;  /\*@@ -332,6 +361,25 @@ static int tracefs\_apply\_options(struct super\_block \*sb, bool remount) if (!remount || opts->opts & BIT(Opt\_gid)) inode->i\_gid = opts->gid; + if (remount && (opts->opts & BIT(Opt\_uid) || opts->opts & BIT(Opt\_gid))) {++ update\_uid = opts->opts & BIT(Opt\_uid);+ update\_gid = opts->opts & BIT(Opt\_gid);++ rcu\_read\_lock();+ list\_for\_each\_entry\_rcu(ti, &tracefs\_inodes, list) {+ if (update\_uid)+ ti->flags &= ~TRACEFS\_UID\_PERM\_SET;++ if (update\_gid)+ ti->flags &= ~TRACEFS\_GID\_PERM\_SET;++ if (ti->flags & TRACEFS\_EVENT\_INODE)+ eventfs\_remount(ti, update\_uid, update\_gid);+ }+ rcu\_read\_unlock();+ }+ return 0; } @@ -398,7 +446,22 @@ static int tracefs\_d\_revalidate(struct dentry \*dentry, unsigned int flags) return !(ei && ei->is\_freed); } +static void tracefs\_d\_iput(struct dentry \*dentry, struct inode \*inode)+{+ struct tracefs\_inode \*ti = get\_tracefs(inode);++ /\*+ \* This inode is being freed and cannot be used for+ \* eventfs. Clear the flag so that it doesn't call into+ \* eventfs during the remount flag updates. The eventfs\_inode+ \* gets freed after an RCU cycle, so the content will still+ \* be safe if the iteration is going on now.+ \*/+ ti->flags &= ~TRACEFS\_EVENT\_INODE;+}+ static const struct dentry\_operations tracefs\_dentry\_operations = {+ .d\_iput = tracefs\_d\_iput, .d\_revalidate = tracefs\_d\_revalidate, .d\_release = tracefs\_d\_release, };diff --git a/fs/tracefs/internal.h b/fs/tracefs/internal.hindex 15c26f9aaad4df..29f0c999975b62 100644--- a/[fs/tracefs/internal.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/tracefs/internal.h?id=ee4e0379475e4fe723986ae96293e465014fa8d9)+++ b/[fs/tracefs/internal.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/tracefs/internal.h?id=baa23a8d4360d981a49913841a726edede5cdd54)@@ -11,8 +11,12 @@ enum { };  struct tracefs\_inode {- struct inode vfs\_inode;+ union {+ struct inode vfs\_inode;+ struct rcu\_head rcu;+ }; /\* The below gets initialized with memset\_after(ti, 0, vfs\_inode) \*/+ struct list\_head list; unsigned long flags; void \*private; };@@ -73,6 +77,7 @@ struct dentry \*tracefs\_end\_creating(struct dentry \*dentry); struct dentry \*tracefs\_failed\_creating(struct dentry \*dentry); struct inode \*tracefs\_get\_inode(struct super\_block \*sb); +void eventfs\_remount(struct tracefs\_inode \*ti, bool update\_uid, bool update\_gid); void eventfs\_d\_release(struct dentry \*dentry);  #endif /\* \_TRACEFS\_INTERNAL\_H \*/ |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 03:22:22 +0000


