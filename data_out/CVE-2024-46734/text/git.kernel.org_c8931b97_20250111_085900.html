

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=7b5595f33c3c273613b590892a578d78186bb400)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=7b5595f33c3c273613b590892a578d78186bb400)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7b5595f33c3c273613b590892a578d78186bb400)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7b5595f33c3c273613b590892a578d78186bb400)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Filipe Manana <fdmanana@suse.com> | 2024-08-29 18:25:49 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-09-12 11:11:45 +0200 |
| commit | [7b5595f33c3c273613b590892a578d78186bb400](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7b5595f33c3c273613b590892a578d78186bb400) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=7b5595f33c3c273613b590892a578d78186bb400)) | |
| tree | [8ef9bf8edb9fa8e86ee128b659c4a435ea5d3bbf](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=7b5595f33c3c273613b590892a578d78186bb400) | |
| parent | [8eeda5fb5938a20b8dda767c629e29f867cc061d](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=8eeda5fb5938a20b8dda767c629e29f867cc061d) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7b5595f33c3c273613b590892a578d78186bb400&id2=8eeda5fb5938a20b8dda767c629e29f867cc061d)) | |
| download | [linux-7b5595f33c3c273613b590892a578d78186bb400.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-7b5595f33c3c273613b590892a578d78186bb400.tar.gz) | |

btrfs: fix race between direct IO write and fsync when using same fdcommit cd9253c23aedd61eb5ff11f37a36247cd46faf86 upstream.
If we have 2 threads that are using the same file descriptor and one of
them is doing direct IO writes while the other is doing fsync, we have a
race where we can end up either:
1) Attempt a fsync without holding the inode's lock, triggering an
assertion failures when assertions are enabled;
2) Do an invalid memory access from the fsync task because the file private
points to memory allocated on stack by the direct IO task and it may be
used by the fsync task after the stack was destroyed.
The race happens like this:
1) A user space program opens a file descriptor with O\_DIRECT;
2) The program spawns 2 threads using libpthread for example;
3) One of the threads uses the file descriptor to do direct IO writes,
while the other calls fsync using the same file descriptor.
4) Call task A the thread doing direct IO writes and task B the thread
doing fsyncs;
5) Task A does a direct IO write, and at btrfs\_direct\_write() sets the
file's private to an on stack allocated private with the member
'fsync\_skip\_inode\_lock' set to true;
6) Task B enters btrfs\_sync\_file() and sees that there's a private
structure associated to the file which has 'fsync\_skip\_inode\_lock' set
to true, so it skips locking the inode's VFS lock;
7) Task A completes the direct IO write, and resets the file's private to
NULL since it had no prior private and our private was stack allocated.
Then it unlocks the inode's VFS lock;
8) Task B enters btrfs\_get\_ordered\_extents\_for\_logging(), then the
assertion that checks the inode's VFS lock is held fails, since task B
never locked it and task A has already unlocked it.
The stack trace produced is the following:
assertion failed: inode\_is\_locked(&inode->vfs\_inode), in fs/btrfs/ordered-data.c:983
------------[ cut here ]------------
kernel BUG at fs/btrfs/ordered-data.c:983!
Oops: invalid opcode: 0000 [#1] PREEMPT SMP PTI
CPU: 9 PID: 5072 Comm: worker Tainted: G U OE 6.10.5-1-default #1 openSUSE Tumbleweed 69f48d427608e1c09e60ea24c6c55e2ca1b049e8
Hardware name: Acer Predator PH315-52/Covini\_CFS, BIOS V1.12 07/28/2020
RIP: 0010:btrfs\_get\_ordered\_extents\_for\_logging.cold+0x1f/0x42 [btrfs]
Code: 50 d6 86 c0 e8 (...)
RSP: 0018:ffff9e4a03dcfc78 EFLAGS: 00010246
RAX: 0000000000000054 RBX: ffff9078a9868e98 RCX: 0000000000000000
RDX: 0000000000000000 RSI: ffff907dce4a7800 RDI: ffff907dce4a7800
RBP: ffff907805518800 R08: 0000000000000000 R09: ffff9e4a03dcfb38
R10: ffff9e4a03dcfb30 R11: 0000000000000003 R12: ffff907684ae7800
R13: 0000000000000001 R14: ffff90774646b600 R15: 0000000000000000
FS: 00007f04b96006c0(0000) GS:ffff907dce480000(0000) knlGS:0000000000000000
CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f32acbfc000 CR3: 00000001fd4fa005 CR4: 00000000003726f0
Call Trace:
<TASK>
? \_\_die\_body.cold+0x14/0x24
? die+0x2e/0x50
? do\_trap+0xca/0x110
? do\_error\_trap+0x6a/0x90
? btrfs\_get\_ordered\_extents\_for\_logging.cold+0x1f/0x42 [btrfs bb26272d49b4cdc847cf3f7faadd459b62caee9a]
? exc\_invalid\_op+0x50/0x70
? btrfs\_get\_ordered\_extents\_for\_logging.cold+0x1f/0x42 [btrfs bb26272d49b4cdc847cf3f7faadd459b62caee9a]
? asm\_exc\_invalid\_op+0x1a/0x20
? btrfs\_get\_ordered\_extents\_for\_logging.cold+0x1f/0x42 [btrfs bb26272d49b4cdc847cf3f7faadd459b62caee9a]
? btrfs\_get\_ordered\_extents\_for\_logging.cold+0x1f/0x42 [btrfs bb26272d49b4cdc847cf3f7faadd459b62caee9a]
btrfs\_sync\_file+0x21a/0x4d0 [btrfs bb26272d49b4cdc847cf3f7faadd459b62caee9a]
? \_\_seccomp\_filter+0x31d/0x4f0
\_\_x64\_sys\_fdatasync+0x4f/0x90
do\_syscall\_64+0x82/0x160
? do\_futex+0xcb/0x190
? \_\_x64\_sys\_futex+0x10e/0x1d0
? switch\_fpu\_return+0x4f/0xd0
? syscall\_exit\_to\_user\_mode+0x72/0x220
? do\_syscall\_64+0x8e/0x160
? syscall\_exit\_to\_user\_mode+0x72/0x220
? do\_syscall\_64+0x8e/0x160
? syscall\_exit\_to\_user\_mode+0x72/0x220
? do\_syscall\_64+0x8e/0x160
? syscall\_exit\_to\_user\_mode+0x72/0x220
? do\_syscall\_64+0x8e/0x160
entry\_SYSCALL\_64\_after\_hwframe+0x76/0x7e
Another problem here is if task B grabs the private pointer and then uses
it after task A has finished, since the private was allocated in the stack
of task A, it results in some invalid memory access with a hard to predict
result.
This issue, triggering the assertion, was observed with QEMU workloads by
two users in the Link tags below.
Fix this by not relying on a file's private to pass information to fsync
that it should skip locking the inode and instead pass this information
through a special value stored in current->journal\_info. This is safe
because in the relevant section of the direct IO write path we are not
holding a transaction handle, so current->journal\_info is NULL.
The following C program triggers the issue:
$ cat repro.c
/\* Get the O\_DIRECT definition. \*/
#ifndef \_GNU\_SOURCE
#define \_GNU\_SOURCE
#endif
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdint.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <pthread.h>
static int fd;
static ssize\_t do\_write(int fd, const void \*buf, size\_t count, off\_t offset)
{
while (count > 0) {
ssize\_t ret;
ret = pwrite(fd, buf, count, offset);
if (ret < 0) {
if (errno == EINTR)
continue;
return ret;
}
count -= ret;
buf += ret;
}
return 0;
}
static void \*fsync\_loop(void \*arg)
{
while (1) {
int ret;
ret = fsync(fd);
if (ret != 0) {
perror("Fsync failed");
exit(6);
}
}
}
int main(int argc, char \*argv[])
{
long pagesize;
void \*write\_buf;
pthread\_t fsyncer;
int ret;
if (argc != 2) {
fprintf(stderr, "Use: %s <file path>\n", argv[0]);
return 1;
}
fd = open(argv[1], O\_WRONLY | O\_CREAT | O\_TRUNC | O\_DIRECT, 0666);
if (fd == -1) {
perror("Failed to open/create file");
return 1;
}
pagesize = sysconf(\_SC\_PAGE\_SIZE);
if (pagesize == -1) {
perror("Failed to get page size");
return 2;
}
ret = posix\_memalign(&write\_buf, pagesize, pagesize);
if (ret) {
perror("Failed to allocate buffer");
return 3;
}
ret = pthread\_create(&fsyncer, NULL, fsync\_loop, NULL);
if (ret != 0) {
fprintf(stderr, "Failed to create writer thread: %d\n", ret);
return 4;
}
while (1) {
ret = do\_write(fd, write\_buf, pagesize, 0);
if (ret != 0) {
perror("Write failed");
exit(5);
}
}
return 0;
}
$ mkfs.btrfs -f /dev/sdi
$ mount /dev/sdi /mnt/sdi
$ timeout 10 ./repro /mnt/sdi/foo
Usually the race is triggered within less than 1 second. A test case for
fstests will follow soon.
Reported-by: Paulo Dias <paulo.miguel.dias@gmail.com>
Link: <https://bugzilla.kernel.org/show_bug.cgi?id=219187>
Reported-by: Andreas Jahn <jahn-andi@web.de>
Link: <https://bugzilla.kernel.org/show_bug.cgi?id=219199>
Reported-by: syzbot+4704b3cc972bd76024f1@syzkaller.appspotmail.com
Link: [https://lore.kernel.org/linux-btrfs/00000000000044ff540620d7dee2@google.com/](https://lore.kernel.org/linux-btrfs/00000000000044ff540620d7dee2%40google.com/)
Fixes: 939b656bc8ab ("btrfs: fix corruption after buffer fault in during direct IO append write")
CC: stable@vger.kernel.org # 5.15+
Reviewed-by: Josef Bacik <josef@toxicpanda.com>
Signed-off-by: Filipe Manana <fdmanana@suse.com>
Reviewed-by: David Sterba <dsterba@suse.com>
Signed-off-by: David Sterba <dsterba@suse.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7b5595f33c3c273613b590892a578d78186bb400)

| -rw-r--r-- | [fs/btrfs/ctree.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/ctree.h?id=7b5595f33c3c273613b590892a578d78186bb400) | 1 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/btrfs/file.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/file.c?id=7b5595f33c3c273613b590892a578d78186bb400) | 25 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/transaction.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/transaction.h?id=7b5595f33c3c273613b590892a578d78186bb400) | 6 | |  |  |  | | --- | --- | --- | |

3 files changed, 16 insertions, 16 deletions

| diff --git a/fs/btrfs/ctree.h b/fs/btrfs/ctree.hindex 86c7f8ce1715e7..06333a74d6c4cb 100644--- a/[fs/btrfs/ctree.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/ctree.h?id=8eeda5fb5938a20b8dda767c629e29f867cc061d)+++ b/[fs/btrfs/ctree.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/ctree.h?id=7b5595f33c3c273613b590892a578d78186bb400)@@ -445,7 +445,6 @@ struct btrfs\_file\_private { void \*filldir\_buf; u64 last\_index; struct extent\_state \*llseek\_cached\_state;- bool fsync\_skip\_inode\_lock; };  static inline u32 BTRFS\_LEAF\_DATA\_SIZE(const struct btrfs\_fs\_info \*info)diff --git a/fs/btrfs/file.c b/fs/btrfs/file.cindex 952cf145c6295a..15fd8c00f4c083 100644--- a/[fs/btrfs/file.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/file.c?id=8eeda5fb5938a20b8dda767c629e29f867cc061d)+++ b/[fs/btrfs/file.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/file.c?id=7b5595f33c3c273613b590892a578d78186bb400)@@ -1543,13 +1543,6 @@ again: if (IS\_ERR\_OR\_NULL(dio)) { err = PTR\_ERR\_OR\_ZERO(dio); } else {- struct btrfs\_file\_private stack\_private = { 0 };- struct btrfs\_file\_private \*private;- const bool have\_private = (file->private\_data != NULL);-- if (!have\_private)- file->private\_data = &stack\_private;- /\* \* If we have a synchoronous write, we must make sure the fsync \* triggered by the iomap\_dio\_complete() call below doesn't@@ -1558,13 +1551,10 @@ again: \* partial writes due to the input buffer (or parts of it) not \* being already faulted in. \*/- private = file->private\_data;- private->fsync\_skip\_inode\_lock = true;+ ASSERT(current->journal\_info == NULL);+ current->journal\_info = BTRFS\_TRANS\_DIO\_WRITE\_STUB; err = iomap\_dio\_complete(dio);- private->fsync\_skip\_inode\_lock = false;-- if (!have\_private)- file->private\_data = NULL;+ current->journal\_info = NULL; }  /\* No increment (+=) because iomap returns a cumulative value. \*/@@ -1796,7 +1786,6 @@ static inline bool skip\_inode\_logging(const struct btrfs\_log\_ctx \*ctx) \*/ int btrfs\_sync\_file(struct file \*file, loff\_t start, loff\_t end, int datasync) {- struct btrfs\_file\_private \*private = file->private\_data; struct dentry \*dentry = file\_dentry(file); struct inode \*inode = d\_inode(dentry); struct btrfs\_fs\_info \*fs\_info = btrfs\_sb(inode->i\_sb);@@ -1806,7 +1795,13 @@ int btrfs\_sync\_file(struct file \*file, loff\_t start, loff\_t end, int datasync) int ret = 0, err; u64 len; bool full\_sync;- const bool skip\_ilock = (private ? private->fsync\_skip\_inode\_lock : false);+ bool skip\_ilock = false;++ if (current->journal\_info == BTRFS\_TRANS\_DIO\_WRITE\_STUB) {+ skip\_ilock = true;+ current->journal\_info = NULL;+ lockdep\_assert\_held(&inode->i\_rwsem);+ }  trace\_btrfs\_sync\_file(file, datasync); diff --git a/fs/btrfs/transaction.h b/fs/btrfs/transaction.hindex 238a0ab85df9b8..7623db359881e5 100644--- a/[fs/btrfs/transaction.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/transaction.h?id=8eeda5fb5938a20b8dda767c629e29f867cc061d)+++ b/[fs/btrfs/transaction.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/transaction.h?id=7b5595f33c3c273613b590892a578d78186bb400)@@ -12,6 +12,12 @@ #include "ctree.h" #include "misc.h" +/\*+ \* Signal that a direct IO write is in progress, to avoid deadlock for sync+ \* direct IO writes when fsync is called during the direct IO write path.+ \*/+#define BTRFS\_TRANS\_DIO\_WRITE\_STUB ((void \*) 1)+ /\* Radix-tree tag for roots that are part of the trasaction. \*/ #define BTRFS\_ROOT\_TRANS\_TAG 0 |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 08:57:38 +0000

