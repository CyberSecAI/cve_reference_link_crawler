

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=d4d1e4b1513d975961de7bb4f75e450a92d65ebf)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d4d1e4b1513d975961de7bb4f75e450a92d65ebf)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d4d1e4b1513d975961de7bb4f75e450a92d65ebf)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d4d1e4b1513d975961de7bb4f75e450a92d65ebf)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Gaurav Batra <gbatra@linux.vnet.ibm.com> | 2024-01-25 14:30:17 -0600 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-03-06 14:48:43 +0000 |
| commit | [d4d1e4b1513d975961de7bb4f75e450a92d65ebf](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d4d1e4b1513d975961de7bb4f75e450a92d65ebf) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=d4d1e4b1513d975961de7bb4f75e450a92d65ebf)) | |
| tree | [d091aec23b2b76ce904e69cb4f4712d7a91785a1](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d4d1e4b1513d975961de7bb4f75e450a92d65ebf) | |
| parent | [5e3022ea42e490a36ec6f2cfa6fc603deb0bace4](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=5e3022ea42e490a36ec6f2cfa6fc603deb0bace4) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d4d1e4b1513d975961de7bb4f75e450a92d65ebf&id2=5e3022ea42e490a36ec6f2cfa6fc603deb0bace4)) | |
| download | [linux-d4d1e4b1513d975961de7bb4f75e450a92d65ebf.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-d4d1e4b1513d975961de7bb4f75e450a92d65ebf.tar.gz) | |

powerpc/pseries/iommu: IOMMU table is not initialized for kdump over SR-IOV[ Upstream commit 09a3c1e46142199adcee372a420b024b4fc61051 ]
When kdump kernel tries to copy dump data over SR-IOV, LPAR panics due
to NULL pointer exception:
Kernel attempted to read user page (0) - exploit attempt? (uid: 0)
BUG: Kernel NULL pointer dereference on read at 0x00000000
Faulting instruction address: 0xc000000020847ad4
Oops: Kernel access of bad area, sig: 11 [#1]
LE PAGE\_SIZE=64K MMU=Radix SMP NR\_CPUS=2048 NUMA pSeries
Modules linked in: mlx5\_core(+) vmx\_crypto pseries\_wdt papr\_scm libnvdimm mlxfw tls psample sunrpc fuse overlay squashfs loop
CPU: 12 PID: 315 Comm: systemd-udevd Not tainted 6.4.0-Test102+ #12
Hardware name: IBM,9080-HEX POWER10 (raw) 0x800200 0xf000006 of:IBM,FW1060.00 (NH1060\_008) hv:phyp pSeries
NIP: c000000020847ad4 LR: c00000002083b2dc CTR: 00000000006cd18c
REGS: c000000029162ca0 TRAP: 0300 Not tainted (6.4.0-Test102+)
MSR: 800000000280b033 <SF,VEC,VSX,EE,FP,ME,IR,DR,RI,LE> CR: 48288244 XER: 00000008
CFAR: c00000002083b2d8 DAR: 0000000000000000 DSISR: 40000000 IRQMASK: 1
...
NIP \_find\_next\_zero\_bit+0x24/0x110
LR bitmap\_find\_next\_zero\_area\_off+0x5c/0xe0
Call Trace:
dev\_printk\_emit+0x38/0x48 (unreliable)
iommu\_area\_alloc+0xc4/0x180
iommu\_range\_alloc+0x1e8/0x580
iommu\_alloc+0x60/0x130
iommu\_alloc\_coherent+0x158/0x2b0
dma\_iommu\_alloc\_coherent+0x3c/0x50
dma\_alloc\_attrs+0x170/0x1f0
mlx5\_cmd\_init+0xc0/0x760 [mlx5\_core]
mlx5\_function\_setup+0xf0/0x510 [mlx5\_core]
mlx5\_init\_one+0x84/0x210 [mlx5\_core]
probe\_one+0x118/0x2c0 [mlx5\_core]
local\_pci\_probe+0x68/0x110
pci\_call\_probe+0x68/0x200
pci\_device\_probe+0xbc/0x1a0
really\_probe+0x104/0x540
\_\_driver\_probe\_device+0xb4/0x230
driver\_probe\_device+0x54/0x130
\_\_driver\_attach+0x158/0x2b0
bus\_for\_each\_dev+0xa8/0x130
driver\_attach+0x34/0x50
bus\_add\_driver+0x16c/0x300
driver\_register+0xa4/0x1b0
\_\_pci\_register\_driver+0x68/0x80
mlx5\_init+0xb8/0x100 [mlx5\_core]
do\_one\_initcall+0x60/0x300
do\_init\_module+0x7c/0x2b0
At the time of LPAR dump, before kexec hands over control to kdump
kernel, DDWs (Dynamic DMA Windows) are scanned and added to the FDT.
For the SR-IOV case, default DMA window "ibm,dma-window" is removed from
the FDT and DDW added, for the device.
Now, kexec hands over control to the kdump kernel.
When the kdump kernel initializes, PCI busses are scanned and IOMMU
group/tables created, in pci\_dma\_bus\_setup\_pSeriesLP(). For the SR-IOV
case, there is no "ibm,dma-window". The original commit: b1fc44eaa9ba,
fixes the path where memory is pre-mapped (direct mapped) to the DDW.
When TCEs are direct mapped, there is no need to initialize IOMMU
tables.
iommu\_table\_setparms\_lpar() only considers "ibm,dma-window" property
when initiallizing IOMMU table. In the scenario where TCEs are
dynamically allocated for SR-IOV, newly created IOMMU table is not
initialized. Later, when the device driver tries to enter TCEs for the
SR-IOV device, NULL pointer execption is thrown from iommu\_area\_alloc().
The fix is to initialize the IOMMU table with DDW property stored in the
FDT. There are 2 points to remember:
1. For the dedicated adapter, kdump kernel would encounter both
default and DDW in FDT. In this case, DDW property is used to
initialize the IOMMU table.
2. A DDW could be direct or dynamic mapped. kdump kernel would
initialize IOMMU table and mark the existing DDW as
"dynamic". This works fine since, at the time of table
initialization, iommu\_table\_clear() makes some space in the
DDW, for some predefined number of TCEs which are needed for
kdump to succeed.
Fixes: b1fc44eaa9ba ("pseries/iommu/ddw: Fix kdump to work in absence of ibm,dma-window")
Signed-off-by: Gaurav Batra <gbatra@linux.vnet.ibm.com>
Reviewed-by: Brian King <brking@linux.vnet.ibm.com>
Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: [https://msgid.link/20240125203017.61014-1-gbatra@linux.ibm.com](https://msgid.link/20240125203017.61014-1-gbatra%40linux.ibm.com)
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d4d1e4b1513d975961de7bb4f75e450a92d65ebf)

| -rw-r--r-- | [arch/powerpc/platforms/pseries/iommu.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/powerpc/platforms/pseries/iommu.c?id=d4d1e4b1513d975961de7bb4f75e450a92d65ebf) | 156 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 105 insertions, 51 deletions

| diff --git a/arch/powerpc/platforms/pseries/iommu.c b/arch/powerpc/platforms/pseries/iommu.cindex 496e16c588aaa8..e8c4129697b142 100644--- a/[arch/powerpc/platforms/pseries/iommu.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/powerpc/platforms/pseries/iommu.c?id=5e3022ea42e490a36ec6f2cfa6fc603deb0bace4)+++ b/[arch/powerpc/platforms/pseries/iommu.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/powerpc/platforms/pseries/iommu.c?id=d4d1e4b1513d975961de7bb4f75e450a92d65ebf)@@ -574,29 +574,6 @@ static void iommu\_table\_setparms(struct pci\_controller \*phb,  struct iommu\_table\_ops iommu\_table\_lpar\_multi\_ops; -/\*- \* iommu\_table\_setparms\_lpar- \*- \* Function: On pSeries LPAR systems, return TCE table info, given a pci bus.- \*/-static void iommu\_table\_setparms\_lpar(struct pci\_controller \*phb,- struct device\_node \*dn,- struct iommu\_table \*tbl,- struct iommu\_table\_group \*table\_group,- const \_\_be32 \*dma\_window)-{- unsigned long offset, size, liobn;-- of\_parse\_dma\_window(dn, dma\_window, &liobn, &offset, &size);-- iommu\_table\_setparms\_common(tbl, phb->bus->number, liobn, offset, size, IOMMU\_PAGE\_SHIFT\_4K, NULL,- &iommu\_table\_lpar\_multi\_ops);--- table\_group->tce32\_start = offset;- table\_group->tce32\_size = size;-}- struct iommu\_table\_ops iommu\_table\_pseries\_ops = { .set = tce\_build\_pSeries, .clear = tce\_free\_pSeries,@@ -724,26 +701,71 @@ struct iommu\_table\_ops iommu\_table\_lpar\_multi\_ops = { \* dynamic 64bit DMA window, walking up the device tree. \*/ static struct device\_node \*pci\_dma\_find(struct device\_node \*dn,- const \_\_be32 \*\*dma\_window)+ struct dynamic\_dma\_window\_prop \*prop) {- const \_\_be32 \*dw = NULL;+ const \_\_be32 \*default\_prop = NULL;+ const \_\_be32 \*ddw\_prop = NULL;+ struct device\_node \*rdn = NULL;+ bool default\_win = false, ddw\_win = false;  for ( ; dn && PCI\_DN(dn); dn = dn->parent) {- dw = of\_get\_property(dn, "ibm,dma-window", NULL);- if (dw) {- if (dma\_window)- \*dma\_window = dw;- return dn;+ default\_prop = of\_get\_property(dn, "ibm,dma-window", NULL);+ if (default\_prop) {+ rdn = dn;+ default\_win = true;+ }+ ddw\_prop = of\_get\_property(dn, DIRECT64\_PROPNAME, NULL);+ if (ddw\_prop) {+ rdn = dn;+ ddw\_win = true;+ break;+ }+ ddw\_prop = of\_get\_property(dn, DMA64\_PROPNAME, NULL);+ if (ddw\_prop) {+ rdn = dn;+ ddw\_win = true;+ break; }- dw = of\_get\_property(dn, DIRECT64\_PROPNAME, NULL);- if (dw)- return dn;- dw = of\_get\_property(dn, DMA64\_PROPNAME, NULL);- if (dw)- return dn;++ /\* At least found default window, which is the case for normal boot \*/+ if (default\_win)+ break; } - return NULL;+ /\* For PCI devices there will always be a DMA window, either on the device+ \* or parent bus+ \*/+ WARN\_ON(!(default\_win | ddw\_win));++ /\* caller doesn't want to get DMA window property \*/+ if (!prop)+ return rdn;++ /\* parse DMA window property. During normal system boot, only default+ \* DMA window is passed in OF. But, for kdump, a dedicated adapter might+ \* have both default and DDW in FDT. In this scenario, DDW takes precedence+ \* over default window.+ \*/+ if (ddw\_win) {+ struct dynamic\_dma\_window\_prop \*p;++ p = (struct dynamic\_dma\_window\_prop \*)ddw\_prop;+ prop->liobn = p->liobn;+ prop->dma\_base = p->dma\_base;+ prop->tce\_shift = p->tce\_shift;+ prop->window\_shift = p->window\_shift;+ } else if (default\_win) {+ unsigned long offset, size, liobn;++ of\_parse\_dma\_window(rdn, default\_prop, &liobn, &offset, &size);++ prop->liobn = cpu\_to\_be32((u32)liobn);+ prop->dma\_base = cpu\_to\_be64(offset);+ prop->tce\_shift = cpu\_to\_be32(IOMMU\_PAGE\_SHIFT\_4K);+ prop->window\_shift = cpu\_to\_be32(order\_base\_2(size));+ }++ return rdn; }  static void pci\_dma\_bus\_setup\_pSeriesLP(struct pci\_bus \*bus)@@ -751,17 +773,20 @@ static void pci\_dma\_bus\_setup\_pSeriesLP(struct pci\_bus \*bus) struct iommu\_table \*tbl; struct device\_node \*dn, \*pdn; struct pci\_dn \*ppci;- const \_\_be32 \*dma\_window = NULL;+ struct dynamic\_dma\_window\_prop prop;  dn = pci\_bus\_to\_OF\_node(bus);  pr\_debug("pci\_dma\_bus\_setup\_pSeriesLP: setting up bus %pOF\n", dn); - pdn = pci\_dma\_find(dn, &dma\_window);+ pdn = pci\_dma\_find(dn, &prop); - if (dma\_window == NULL)- pr\_debug(" no ibm,dma-window property !\n");+ /\* In PPC architecture, there will always be DMA window on bus or one of the+ \* parent bus. During reboot, there will be ibm,dma-window property to+ \* define DMA window. For kdump, there will at least be default window or DDW+ \* or both.+ \*/  ppci = PCI\_DN(pdn); @@ -771,13 +796,24 @@ static void pci\_dma\_bus\_setup\_pSeriesLP(struct pci\_bus \*bus) if (!ppci->table\_group) { ppci->table\_group = iommu\_pseries\_alloc\_group(ppci->phb->node); tbl = ppci->table\_group->tables[0];- if (dma\_window) {- iommu\_table\_setparms\_lpar(ppci->phb, pdn, tbl,- ppci->table\_group, dma\_window); - if (!iommu\_init\_table(tbl, ppci->phb->node, 0, 0))- panic("Failed to initialize iommu table");- }+ iommu\_table\_setparms\_common(tbl, ppci->phb->bus->number,+ be32\_to\_cpu(prop.liobn),+ be64\_to\_cpu(prop.dma\_base),+ 1ULL << be32\_to\_cpu(prop.window\_shift),+ be32\_to\_cpu(prop.tce\_shift), NULL,+ &iommu\_table\_lpar\_multi\_ops);++ /\* Only for normal boot with default window. Doesn't matter even+ \* if we set these with DDW which is 64bit during kdump, since+ \* these will not be used during kdump.+ \*/+ ppci->table\_group->tce32\_start = be64\_to\_cpu(prop.dma\_base);+ ppci->table\_group->tce32\_size = 1 << be32\_to\_cpu(prop.window\_shift);++ if (!iommu\_init\_table(tbl, ppci->phb->node, 0, 0))+ panic("Failed to initialize iommu table");+ iommu\_register\_group(ppci->table\_group, pci\_domain\_nr(bus), 0); pr\_debug(" created table: %p\n", ppci->table\_group);@@ -968,6 +1004,12 @@ static void find\_existing\_ddw\_windows\_named(const char \*name) continue; } + /\* If at the time of system initialization, there are DDWs in OF,+ \* it means this is during kexec. DDW could be direct or dynamic.+ \* We will just mark DDWs as "dynamic" since this is kdump path,+ \* no need to worry about perforance. ddw\_list\_new\_entry() will+ \* set window->direct = false.+ \*/ window = ddw\_list\_new\_entry(pdn, dma64); if (!window) { of\_node\_put(pdn);@@ -1524,8 +1566,8 @@ static void pci\_dma\_dev\_setup\_pSeriesLP(struct pci\_dev \*dev) { struct device\_node \*pdn, \*dn; struct iommu\_table \*tbl;- const \_\_be32 \*dma\_window = NULL; struct pci\_dn \*pci;+ struct dynamic\_dma\_window\_prop prop;  pr\_debug("pci\_dma\_dev\_setup\_pSeriesLP: %s\n", pci\_name(dev)); @@ -1538,7 +1580,7 @@ static void pci\_dma\_dev\_setup\_pSeriesLP(struct pci\_dev \*dev) dn = pci\_device\_to\_OF\_node(dev); pr\_debug(" node is %pOF\n", dn); - pdn = pci\_dma\_find(dn, &dma\_window);+ pdn = pci\_dma\_find(dn, &prop); if (!pdn || !PCI\_DN(pdn)) { printk(KERN\_WARNING "pci\_dma\_dev\_setup\_pSeriesLP: " "no DMA window found for pci dev=%s dn=%pOF\n",@@ -1551,8 +1593,20 @@ static void pci\_dma\_dev\_setup\_pSeriesLP(struct pci\_dev \*dev) if (!pci->table\_group) { pci->table\_group = iommu\_pseries\_alloc\_group(pci->phb->node); tbl = pci->table\_group->tables[0];- iommu\_table\_setparms\_lpar(pci->phb, pdn, tbl,- pci->table\_group, dma\_window);++ iommu\_table\_setparms\_common(tbl, pci->phb->bus->number,+ be32\_to\_cpu(prop.liobn),+ be64\_to\_cpu(prop.dma\_base),+ 1ULL << be32\_to\_cpu(prop.window\_shift),+ be32\_to\_cpu(prop.tce\_shift), NULL,+ &iommu\_table\_lpar\_multi\_ops);++ /\* Only for normal boot with default window. Doesn't matter even+ \* if we set these with DDW which is 64bit during kdump, since+ \* these will not be used during kdump.+ \*/+ pci->table\_group->tce32\_start = be64\_to\_cpu(prop.dma\_base);+ pci->table\_group->tce32\_size = 1 << be32\_to\_cpu(prop.window\_shift);  iommu\_init\_table(tbl, pci->phb->node, 0, 0); iommu\_register\_group(pci->table\_group, |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 13:31:56 +0000

