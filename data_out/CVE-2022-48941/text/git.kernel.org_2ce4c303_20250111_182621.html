

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=2a3e61de89bab6696aa28b70030eb119968c5586)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=2a3e61de89bab6696aa28b70030eb119968c5586)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=2a3e61de89bab6696aa28b70030eb119968c5586)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=2a3e61de89bab6696aa28b70030eb119968c5586)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jacob Keller <jacob.e.keller@intel.com> | 2022-02-07 10:23:29 -0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2022-03-02 11:50:58 +0100 |
| commit | [2a3e61de89bab6696aa28b70030eb119968c5586](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=2a3e61de89bab6696aa28b70030eb119968c5586) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=2a3e61de89bab6696aa28b70030eb119968c5586)) | |
| tree | [ca4be2a0c3b7ee6f3d75af320b3021722fd2ef96](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=2a3e61de89bab6696aa28b70030eb119968c5586) | |
| parent | [77126296daac6b5ac4062149a99b12bc47123e29](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=77126296daac6b5ac4062149a99b12bc47123e29) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=2a3e61de89bab6696aa28b70030eb119968c5586&id2=77126296daac6b5ac4062149a99b12bc47123e29)) | |
| download | [linux-2a3e61de89bab6696aa28b70030eb119968c5586.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-2a3e61de89bab6696aa28b70030eb119968c5586.tar.gz) | |

ice: fix concurrent reset and removal of VFscommit fadead80fe4c033b5e514fcbadd20b55c4494112 upstream.
Commit c503e63200c6 ("ice: Stop processing VF messages during teardown")
introduced a driver state flag, ICE\_VF\_DEINIT\_IN\_PROGRESS, which is
intended to prevent some issues with concurrently handling messages from
VFs while tearing down the VFs.
This change was motivated by crashes caused while tearing down and
bringing up VFs in rapid succession.
It turns out that the fix actually introduces issues with the VF driver
caused because the PF no longer responds to any messages sent by the VF
during its .remove routine. This results in the VF potentially removing
its DMA memory before the PF has shut down the device queues.
Additionally, the fix doesn't actually resolve concurrency issues within
the ice driver. It is possible for a VF to initiate a reset just prior
to the ice driver removing VFs. This can result in the remove task
concurrently operating while the VF is being reset. This results in
similar memory corruption and panics purportedly fixed by that commit.
Fix this concurrency at its root by protecting both the reset and
removal flows using the existing VF cfg\_lock. This ensures that we
cannot remove the VF while any outstanding critical tasks such as a
virtchnl message or a reset are occurring.
This locking change also fixes the root cause originally fixed by commit
c503e63200c6 ("ice: Stop processing VF messages during teardown"), so we
can simply revert it.
Note that I kept these two changes together because simply reverting the
original commit alone would leave the driver vulnerable to worse race
conditions.
Fixes: c503e63200c6 ("ice: Stop processing VF messages during teardown")
Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
Tested-by: Konrad Jankowski <konrad0.jankowski@intel.com>
Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=2a3e61de89bab6696aa28b70030eb119968c5586)

| -rw-r--r-- | [drivers/net/ethernet/intel/ice/ice.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/intel/ice/ice.h?id=2a3e61de89bab6696aa28b70030eb119968c5586) | 1 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/net/ethernet/intel/ice/ice\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/intel/ice/ice_main.c?id=2a3e61de89bab6696aa28b70030eb119968c5586) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/net/ethernet/intel/ice/ice\_virtchnl\_pf.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c?id=2a3e61de89bab6696aa28b70030eb119968c5586) | 42 | |  |  |  | | --- | --- | --- | |

3 files changed, 27 insertions, 18 deletions

| diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.hindex b3e1fc6a0a8ebf..b067dd9c71e782 100644--- a/[drivers/net/ethernet/intel/ice/ice.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice.h?id=77126296daac6b5ac4062149a99b12bc47123e29)+++ b/[drivers/net/ethernet/intel/ice/ice.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice.h?id=2a3e61de89bab6696aa28b70030eb119968c5586)@@ -280,7 +280,6 @@ enum ice\_pf\_state { ICE\_VFLR\_EVENT\_PENDING, ICE\_FLTR\_OVERFLOW\_PROMISC, ICE\_VF\_DIS,- ICE\_VF\_DEINIT\_IN\_PROGRESS, ICE\_CFG\_BUSY, ICE\_SERVICE\_SCHED, ICE\_SERVICE\_DIS,diff --git a/drivers/net/ethernet/intel/ice/ice\_main.c b/drivers/net/ethernet/intel/ice/ice\_main.cindex 5b4be432b60ce5..8ee778aaa80005 100644--- a/[drivers/net/ethernet/intel/ice/ice\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice_main.c?id=77126296daac6b5ac4062149a99b12bc47123e29)+++ b/[drivers/net/ethernet/intel/ice/ice\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice_main.c?id=2a3e61de89bab6696aa28b70030eb119968c5586)@@ -1772,7 +1772,9 @@ static void ice\_handle\_mdd\_event(struct ice\_pf \*pf) \* reset, so print the event prior to reset. \*/ ice\_print\_vf\_rx\_mdd\_event(vf);+ mutex\_lock(&pf->vf[i].cfg\_lock); ice\_reset\_vf(&pf->vf[i], false);+ mutex\_unlock(&pf->vf[i].cfg\_lock); } } }diff --git a/drivers/net/ethernet/intel/ice/ice\_virtchnl\_pf.c b/drivers/net/ethernet/intel/ice/ice\_virtchnl\_pf.cindex 6427e7ec93de6a..a12cc305c46194 100644--- a/[drivers/net/ethernet/intel/ice/ice\_virtchnl\_pf.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c?id=77126296daac6b5ac4062149a99b12bc47123e29)+++ b/[drivers/net/ethernet/intel/ice/ice\_virtchnl\_pf.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c?id=2a3e61de89bab6696aa28b70030eb119968c5586)@@ -617,8 +617,6 @@ void ice\_free\_vfs(struct ice\_pf \*pf) struct ice\_hw \*hw = &pf->hw; unsigned int tmp, i; - set\_bit(ICE\_VF\_DEINIT\_IN\_PROGRESS, pf->state);- if (!pf->vf) return; @@ -636,22 +634,26 @@ void ice\_free\_vfs(struct ice\_pf \*pf) else dev\_warn(dev, "VFs are assigned - not disabling SR-IOV\n"); - /\* Avoid wait time by stopping all VFs at the same time \*/- ice\_for\_each\_vf(pf, i)- ice\_dis\_vf\_qs(&pf->vf[i]);- tmp = pf->num\_alloc\_vfs; pf->num\_qps\_per\_vf = 0; pf->num\_alloc\_vfs = 0; for (i = 0; i < tmp; i++) {- if (test\_bit(ICE\_VF\_STATE\_INIT, pf->vf[i].vf\_states)) {+ struct ice\_vf \*vf = &pf->vf[i];++ mutex\_lock(&vf->cfg\_lock);++ ice\_dis\_vf\_qs(vf);++ if (test\_bit(ICE\_VF\_STATE\_INIT, vf->vf\_states)) { /\* disable VF qp mappings and set VF disable state \*/- ice\_dis\_vf\_mappings(&pf->vf[i]);- set\_bit(ICE\_VF\_STATE\_DIS, pf->vf[i].vf\_states);- ice\_free\_vf\_res(&pf->vf[i]);+ ice\_dis\_vf\_mappings(vf);+ set\_bit(ICE\_VF\_STATE\_DIS, vf->vf\_states);+ ice\_free\_vf\_res(vf); } - mutex\_destroy(&pf->vf[i].cfg\_lock);+ mutex\_unlock(&vf->cfg\_lock);++ mutex\_destroy(&vf->cfg\_lock); }  if (ice\_sriov\_free\_msix\_res(pf))@@ -687,7 +689,6 @@ void ice\_free\_vfs(struct ice\_pf \*pf) i);  clear\_bit(ICE\_VF\_DIS, pf->state);- clear\_bit(ICE\_VF\_DEINIT\_IN\_PROGRESS, pf->state); clear\_bit(ICE\_FLAG\_SRIOV\_ENA, pf->flags); } @@ -1613,6 +1614,8 @@ bool ice\_reset\_all\_vfs(struct ice\_pf \*pf, bool is\_vflr) ice\_for\_each\_vf(pf, v) { vf = &pf->vf[v]; + mutex\_lock(&vf->cfg\_lock);+ vf->driver\_caps = 0; ice\_vc\_set\_default\_allowlist(vf); @@ -1627,6 +1630,8 @@ bool ice\_reset\_all\_vfs(struct ice\_pf \*pf, bool is\_vflr) ice\_vf\_pre\_vsi\_rebuild(vf); ice\_vf\_rebuild\_vsi(vf); ice\_vf\_post\_vsi\_rebuild(vf);++ mutex\_unlock(&vf->cfg\_lock); }  if (ice\_is\_eswitch\_mode\_switchdev(pf))@@ -1677,6 +1682,8 @@ bool ice\_reset\_vf(struct ice\_vf \*vf, bool is\_vflr) u32 reg; int i; + lockdep\_assert\_held(&vf->cfg\_lock);+ dev = ice\_pf\_to\_dev(pf);  if (test\_bit(ICE\_VF\_RESETS\_DISABLED, pf->state)) {@@ -2176,9 +2183,12 @@ void ice\_process\_vflr\_event(struct ice\_pf \*pf) bit\_idx = (hw->func\_caps.vf\_base\_id + vf\_id) % 32; /\* read GLGEN\_VFLRSTAT register to find out the flr VFs \*/ reg = rd32(hw, GLGEN\_VFLRSTAT(reg\_idx));- if (reg & BIT(bit\_idx))+ if (reg & BIT(bit\_idx)) { /\* GLGEN\_VFLRSTAT bit will be cleared in ice\_reset\_vf \*/+ mutex\_lock(&vf->cfg\_lock); ice\_reset\_vf(vf, true);+ mutex\_unlock(&vf->cfg\_lock);+ } } } @@ -2255,7 +2265,9 @@ ice\_vf\_lan\_overflow\_event(struct ice\_pf \*pf, struct ice\_rq\_event\_info \*event) if (!vf) return; + mutex\_lock(&vf->cfg\_lock); ice\_vc\_reset\_vf(vf);+ mutex\_unlock(&vf->cfg\_lock); }  /\*\*@@ -4651,10 +4663,6 @@ void ice\_vc\_process\_vf\_msg(struct ice\_pf \*pf, struct ice\_rq\_event\_info \*event) struct device \*dev; int err = 0; - /\* if de-init is underway, don't process messages from VF \*/- if (test\_bit(ICE\_VF\_DEINIT\_IN\_PROGRESS, pf->state))- return;- dev = ice\_pf\_to\_dev(pf); if (ice\_validate\_vf\_id(pf, vf\_id)) { err = -EINVAL; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 18:24:59 +0000

