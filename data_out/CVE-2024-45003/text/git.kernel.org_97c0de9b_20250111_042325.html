

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=3525ad25240dfdd8c78f3470911ed10aa727aa72)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=3525ad25240dfdd8c78f3470911ed10aa727aa72)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3525ad25240dfdd8c78f3470911ed10aa727aa72)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3525ad25240dfdd8c78f3470911ed10aa727aa72)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Zhihao Cheng <chengzhihao1@huawei.com> | 2024-08-09 11:16:28 +0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-09-04 13:14:50 +0200 |
| commit | [3525ad25240dfdd8c78f3470911ed10aa727aa72](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3525ad25240dfdd8c78f3470911ed10aa727aa72) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=3525ad25240dfdd8c78f3470911ed10aa727aa72)) | |
| tree | [e645ba4d274339d6f4b10228dde69eed8d0363db](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=3525ad25240dfdd8c78f3470911ed10aa727aa72) | |
| parent | [0f94cd0e022635c0faba036684551a88625e637c](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=0f94cd0e022635c0faba036684551a88625e637c) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3525ad25240dfdd8c78f3470911ed10aa727aa72&id2=0f94cd0e022635c0faba036684551a88625e637c)) | |
| download | [linux-3525ad25240dfdd8c78f3470911ed10aa727aa72.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-3525ad25240dfdd8c78f3470911ed10aa727aa72.tar.gz) | |

vfs: Don't evict inode under the inode lru traversing contextcommit 2a0629834cd82f05d424bbc193374f9a43d1f87d upstream.
The inode reclaiming process(See function prune\_icache\_sb) collects all
reclaimable inodes and mark them with I\_FREEING flag at first, at that
time, other processes will be stuck if they try getting these inodes
(See function find\_inode\_fast), then the reclaiming process destroy the
inodes by function dispose\_list(). Some filesystems(eg. ext4 with
ea\_inode feature, ubifs with xattr) may do inode lookup in the inode
evicting callback function, if the inode lookup is operated under the
inode lru traversing context, deadlock problems may happen.
Case 1: In function ext4\_evict\_inode(), the ea inode lookup could happen
if ea\_inode feature is enabled, the lookup process will be stuck
under the evicting context like this:
1. File A has inode i\_reg and an ea inode i\_ea
2. getfattr(A, xattr\_buf) // i\_ea is added into lru // lru->i\_ea
3. Then, following three processes running like this:
PA PB
echo 2 > /proc/sys/vm/drop\_caches
shrink\_slab
prune\_dcache\_sb
// i\_reg is added into lru, lru->i\_ea->i\_reg
prune\_icache\_sb
list\_lru\_walk\_one
inode\_lru\_isolate
i\_ea->i\_state |= I\_FREEING // set inode state
inode\_lru\_isolate
\_\_iget(i\_reg)
spin\_unlock(&i\_reg->i\_lock)
spin\_unlock(lru\_lock)
rm file A
i\_reg->nlink = 0
iput(i\_reg) // i\_reg->nlink is 0, do evict
ext4\_evict\_inode
ext4\_xattr\_delete\_inode
ext4\_xattr\_inode\_dec\_ref\_all
ext4\_xattr\_inode\_iget
ext4\_iget(i\_ea->i\_ino)
iget\_locked
find\_inode\_fast
\_\_wait\_on\_freeing\_inode(i\_ea) ----→ AA deadlock
dispose\_list // cannot be executed by prune\_icache\_sb
wake\_up\_bit(&i\_ea->i\_state)
Case 2: In deleted inode writing function ubifs\_jnl\_write\_inode(), file
deleting process holds BASEHD's wbuf->io\_mutex while getting the
xattr inode, which could race with inode reclaiming process(The
reclaiming process could try locking BASEHD's wbuf->io\_mutex in
inode evicting function), then an ABBA deadlock problem would
happen as following:
1. File A has inode ia and a xattr(with inode ixa), regular file B has
inode ib and a xattr.
2. getfattr(A, xattr\_buf) // ixa is added into lru // lru->ixa
3. Then, following three processes running like this:
PA PB PC
echo 2 > /proc/sys/vm/drop\_caches
shrink\_slab
prune\_dcache\_sb
// ib and ia are added into lru, lru->ixa->ib->ia
prune\_icache\_sb
list\_lru\_walk\_one
inode\_lru\_isolate
ixa->i\_state |= I\_FREEING // set inode state
inode\_lru\_isolate
\_\_iget(ib)
spin\_unlock(&ib->i\_lock)
spin\_unlock(lru\_lock)
rm file B
ib->nlink = 0
rm file A
iput(ia)
ubifs\_evict\_inode(ia)
ubifs\_jnl\_delete\_inode(ia)
ubifs\_jnl\_write\_inode(ia)
make\_reservation(BASEHD) // Lock wbuf->io\_mutex
ubifs\_iget(ixa->i\_ino)
iget\_locked
find\_inode\_fast
\_\_wait\_on\_freeing\_inode(ixa)
| iput(ib) // ib->nlink is 0, do evict
| ubifs\_evict\_inode
| ubifs\_jnl\_delete\_inode(ib)
↓ ubifs\_jnl\_write\_inode
ABBA deadlock ←-----make\_reservation(BASEHD)
dispose\_list // cannot be executed by prune\_icache\_sb
wake\_up\_bit(&ixa->i\_state)
Fix the possible deadlock by using new inode state flag I\_LRU\_ISOLATING
to pin the inode in memory while inode\_lru\_isolate() reclaims its pages
instead of using ordinary inode reference. This way inode deletion
cannot be triggered from inode\_lru\_isolate() thus avoiding the deadlock.
evict() is made to wait for I\_LRU\_ISOLATING to be cleared before
proceeding with inode cleanup.
Link: [https://lore.kernel.org/all/37c29c42-7685-d1f0-067d-63582ffac405@huaweicloud.com/](https://lore.kernel.org/all/37c29c42-7685-d1f0-067d-63582ffac405%40huaweicloud.com/)
Link: <https://bugzilla.kernel.org/show_bug.cgi?id=219022>
Fixes: e50e5129f384 ("ext4: xattr-in-inode support")
Fixes: 7959cf3a7506 ("ubifs: journal: Handle xattrs like files")
Cc: stable@vger.kernel.org
Signed-off-by: Zhihao Cheng <chengzhihao1@huawei.com>
Link: [https://lore.kernel.org/r/20240809031628.1069873-1-chengzhihao@huaweicloud.com](https://lore.kernel.org/r/20240809031628.1069873-1-chengzhihao%40huaweicloud.com)
Reviewed-by: Jan Kara <jack@suse.cz>
Suggested-by: Jan Kara <jack@suse.cz>
Suggested-by: Mateusz Guzik <mjguzik@gmail.com>
Signed-off-by: Christian Brauner <brauner@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3525ad25240dfdd8c78f3470911ed10aa727aa72)

| -rw-r--r-- | [fs/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/inode.c?id=3525ad25240dfdd8c78f3470911ed10aa727aa72) | 39 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/linux/fs.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/fs.h?id=3525ad25240dfdd8c78f3470911ed10aa727aa72) | 5 | |  |  |  | | --- | --- | --- | |

2 files changed, 42 insertions, 2 deletions

| diff --git a/fs/inode.c b/fs/inode.cindex a6c4c443d45a63..8c850a062300ee 100644--- a/[fs/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/inode.c?id=0f94cd0e022635c0faba036684551a88625e637c)+++ b/[fs/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/inode.c?id=3525ad25240dfdd8c78f3470911ed10aa727aa72)@@ -450,6 +450,39 @@ static void inode\_lru\_list\_del(struct inode \*inode) this\_cpu\_dec(nr\_unused); } +static void inode\_pin\_lru\_isolating(struct inode \*inode)+{+ lockdep\_assert\_held(&inode->i\_lock);+ WARN\_ON(inode->i\_state & (I\_LRU\_ISOLATING | I\_FREEING | I\_WILL\_FREE));+ inode->i\_state |= I\_LRU\_ISOLATING;+}++static void inode\_unpin\_lru\_isolating(struct inode \*inode)+{+ spin\_lock(&inode->i\_lock);+ WARN\_ON(!(inode->i\_state & I\_LRU\_ISOLATING));+ inode->i\_state &= ~I\_LRU\_ISOLATING;+ smp\_mb();+ wake\_up\_bit(&inode->i\_state, \_\_I\_LRU\_ISOLATING);+ spin\_unlock(&inode->i\_lock);+}++static void inode\_wait\_for\_lru\_isolating(struct inode \*inode)+{+ spin\_lock(&inode->i\_lock);+ if (inode->i\_state & I\_LRU\_ISOLATING) {+ DEFINE\_WAIT\_BIT(wq, &inode->i\_state, \_\_I\_LRU\_ISOLATING);+ wait\_queue\_head\_t \*wqh;++ wqh = bit\_waitqueue(&inode->i\_state, \_\_I\_LRU\_ISOLATING);+ spin\_unlock(&inode->i\_lock);+ \_\_wait\_on\_bit(wqh, &wq, bit\_wait, TASK\_UNINTERRUPTIBLE);+ spin\_lock(&inode->i\_lock);+ WARN\_ON(inode->i\_state & I\_LRU\_ISOLATING);+ }+ spin\_unlock(&inode->i\_lock);+}+ /\*\* \* inode\_sb\_list\_add - add inode to the superblock list of inodes \* @inode: inode to add@@ -562,6 +595,8 @@ static void evict(struct inode \*inode)  inode\_sb\_list\_del(inode); + inode\_wait\_for\_lru\_isolating(inode);+ /\* \* Wait for flusher thread to be done with the inode so that filesystem \* does not start destroying it while writeback is still running. Since@@ -761,7 +796,7 @@ static enum lru\_status inode\_lru\_isolate(struct list\_head \*item, }  if (inode\_has\_buffers(inode) || inode->i\_data.nrpages) {- \_\_iget(inode);+ inode\_pin\_lru\_isolating(inode); spin\_unlock(&inode->i\_lock); spin\_unlock(lru\_lock); if (remove\_inode\_buffers(inode)) {@@ -774,7 +809,7 @@ static enum lru\_status inode\_lru\_isolate(struct list\_head \*item, if (current->reclaim\_state) current->reclaim\_state->reclaimed\_slab += reap; }- iput(inode);+ inode\_unpin\_lru\_isolating(inode); spin\_lock(lru\_lock); return LRU\_RETRY; }diff --git a/include/linux/fs.h b/include/linux/fs.hindex 5e122cb506d6ee..d4f5fcc60744dc 100644--- a/[include/linux/fs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fs.h?id=0f94cd0e022635c0faba036684551a88625e637c)+++ b/[include/linux/fs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fs.h?id=3525ad25240dfdd8c78f3470911ed10aa727aa72)@@ -2153,6 +2153,9 @@ static inline void init\_sync\_kiocb(struct kiocb \*kiocb, struct file \*filp) \* Used to detect that mark\_inode\_dirty() should not move \* inode between dirty lists. \*+ \* I\_LRU\_ISOLATING Inode is pinned being isolated from LRU without holding+ \* i\_count.+ \* \* Q: What is the difference between I\_WILL\_FREE and I\_FREEING? \*/ #define I\_DIRTY\_SYNC (1 << 0)@@ -2174,6 +2177,8 @@ static inline void init\_sync\_kiocb(struct kiocb \*kiocb, struct file \*filp) #define I\_OVL\_INUSE (1 << 14) #define I\_CREATING (1 << 15) #define I\_SYNC\_QUEUED (1 << 17)+#define \_\_I\_LRU\_ISOLATING 19+#define I\_LRU\_ISOLATING (1 << \_\_I\_LRU\_ISOLATING)  #define I\_DIRTY\_INODE (I\_DIRTY\_SYNC | I\_DIRTY\_DATASYNC) #define I\_DIRTY (I\_DIRTY\_INODE | I\_DIRTY\_PAGES) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 04:22:02 +0000

