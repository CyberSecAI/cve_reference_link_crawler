

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=d048dced8ea5eac6723ae873a40567e6f101ea42)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d048dced8ea5eac6723ae873a40567e6f101ea42)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d048dced8ea5eac6723ae873a40567e6f101ea42)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d048dced8ea5eac6723ae873a40567e6f101ea42)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Yonghong Song <yonghong.song@linux.dev> | 2023-12-14 12:38:15 -0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-01-25 15:35:26 -0800 |
| commit | [d048dced8ea5eac6723ae873a40567e6f101ea42](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d048dced8ea5eac6723ae873a40567e6f101ea42) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=d048dced8ea5eac6723ae873a40567e6f101ea42)) | |
| tree | [87ee6492a5618236d9926c788834d59ac84fa8a4](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d048dced8ea5eac6723ae873a40567e6f101ea42) | |
| parent | [42357465a069748f5f90259400eb80cc7c3ea08c](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=42357465a069748f5f90259400eb80cc7c3ea08c) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d048dced8ea5eac6723ae873a40567e6f101ea42&id2=42357465a069748f5f90259400eb80cc7c3ea08c)) | |
| download | [linux-d048dced8ea5eac6723ae873a40567e6f101ea42.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-d048dced8ea5eac6723ae873a40567e6f101ea42.tar.gz) | |

bpf: Fix a race condition between btf\_put() and map\_free()[ Upstream commit 59e5791f59dd83e8aa72a4e74217eabb6e8cfd90 ]
When running `./test\_progs -j` in my local vm with latest kernel,
I once hit a kasan error like below:
[ 1887.184724] BUG: KASAN: slab-use-after-free in bpf\_rb\_root\_free+0x1f8/0x2b0
[ 1887.185599] Read of size 4 at addr ffff888106806910 by task kworker/u12:2/2830
[ 1887.186498]
[ 1887.186712] CPU: 3 PID: 2830 Comm: kworker/u12:2 Tainted: G OEL 6.7.0-rc3-00699-g90679706d486-dirty #494
[ 1887.188034] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04/01/2014
[ 1887.189618] Workqueue: events\_unbound bpf\_map\_free\_deferred
[ 1887.190341] Call Trace:
[ 1887.190666] <TASK>
[ 1887.190949] dump\_stack\_lvl+0xac/0xe0
[ 1887.191423] ? nf\_tcp\_handle\_invalid+0x1b0/0x1b0
[ 1887.192019] ? panic+0x3c0/0x3c0
[ 1887.192449] print\_report+0x14f/0x720
[ 1887.192930] ? preempt\_count\_sub+0x1c/0xd0
[ 1887.193459] ? \_\_virt\_addr\_valid+0xac/0x120
[ 1887.194004] ? bpf\_rb\_root\_free+0x1f8/0x2b0
[ 1887.194572] kasan\_report+0xc3/0x100
[ 1887.195085] ? bpf\_rb\_root\_free+0x1f8/0x2b0
[ 1887.195668] bpf\_rb\_root\_free+0x1f8/0x2b0
[ 1887.196183] ? \_\_bpf\_obj\_drop\_impl+0xb0/0xb0
[ 1887.196736] ? preempt\_count\_sub+0x1c/0xd0
[ 1887.197270] ? preempt\_count\_sub+0x1c/0xd0
[ 1887.197802] ? \_raw\_spin\_unlock+0x1f/0x40
[ 1887.198319] bpf\_obj\_free\_fields+0x1d4/0x260
[ 1887.198883] array\_map\_free+0x1a3/0x260
[ 1887.199380] bpf\_map\_free\_deferred+0x7b/0xe0
[ 1887.199943] process\_scheduled\_works+0x3a2/0x6c0
[ 1887.200549] worker\_thread+0x633/0x890
[ 1887.201047] ? \_\_kthread\_parkme+0xd7/0xf0
[ 1887.201574] ? kthread+0x102/0x1d0
[ 1887.202020] kthread+0x1ab/0x1d0
[ 1887.202447] ? pr\_cont\_work+0x270/0x270
[ 1887.202954] ? kthread\_blkcg+0x50/0x50
[ 1887.203444] ret\_from\_fork+0x34/0x50
[ 1887.203914] ? kthread\_blkcg+0x50/0x50
[ 1887.204397] ret\_from\_fork\_asm+0x11/0x20
[ 1887.204913] </TASK>
[ 1887.204913] </TASK>
[ 1887.205209]
[ 1887.205416] Allocated by task 2197:
[ 1887.205881] kasan\_set\_track+0x3f/0x60
[ 1887.206366] \_\_kasan\_kmalloc+0x6e/0x80
[ 1887.206856] \_\_kmalloc+0xac/0x1a0
[ 1887.207293] btf\_parse\_fields+0xa15/0x1480
[ 1887.207836] btf\_parse\_struct\_metas+0x566/0x670
[ 1887.208387] btf\_new\_fd+0x294/0x4d0
[ 1887.208851] \_\_sys\_bpf+0x4ba/0x600
[ 1887.209292] \_\_x64\_sys\_bpf+0x41/0x50
[ 1887.209762] do\_syscall\_64+0x4c/0xf0
[ 1887.210222] entry\_SYSCALL\_64\_after\_hwframe+0x63/0x6b
[ 1887.210868]
[ 1887.211074] Freed by task 36:
[ 1887.211460] kasan\_set\_track+0x3f/0x60
[ 1887.211951] kasan\_save\_free\_info+0x28/0x40
[ 1887.212485] \_\_\_\_kasan\_slab\_free+0x101/0x180
[ 1887.213027] \_\_kmem\_cache\_free+0xe4/0x210
[ 1887.213514] btf\_free+0x5b/0x130
[ 1887.213918] rcu\_core+0x638/0xcc0
[ 1887.214347] \_\_do\_softirq+0x114/0x37e
The error happens at bpf\_rb\_root\_free+0x1f8/0x2b0:
00000000000034c0 <bpf\_rb\_root\_free>:
; {
34c0: f3 0f 1e fa endbr64
34c4: e8 00 00 00 00 callq 0x34c9 <bpf\_rb\_root\_free+0x9>
34c9: 55 pushq %rbp
34ca: 48 89 e5 movq %rsp, %rbp
...
; if (rec && rec->refcount\_off >= 0 &&
36aa: 4d 85 ed testq %r13, %r13
36ad: 74 a9 je 0x3658 <bpf\_rb\_root\_free+0x198>
36af: 49 8d 7d 10 leaq 0x10(%r13), %rdi
36b3: e8 00 00 00 00 callq 0x36b8 <bpf\_rb\_root\_free+0x1f8>
<==== kasan function
36b8: 45 8b 7d 10 movl 0x10(%r13), %r15d
<==== use-after-free load
36bc: 45 85 ff testl %r15d, %r15d
36bf: 78 8c js 0x364d <bpf\_rb\_root\_free+0x18d>
So the problem is at rec->refcount\_off in the above.
I did some source code analysis and find the reason.
CPU A CPU B
bpf\_map\_put:
...
btf\_put with rcu callback
...
bpf\_map\_free\_deferred
with system\_unbound\_wq
... ... ...
... btf\_free\_rcu: ...
... ... bpf\_map\_free\_deferred:
... ...
... ---------> btf\_struct\_metas\_free()
... | race condition ...
... ---------> map->ops->map\_free()
...
... btf->struct\_meta\_tab = NULL
In the above, map\_free() corresponds to array\_map\_free() and eventually
calling bpf\_rb\_root\_free() which calls:
...
\_\_bpf\_obj\_drop\_impl(obj, field->graph\_root.value\_rec, false);
...
Here, 'value\_rec' is assigned in btf\_check\_and\_fixup\_fields() with following code:
meta = btf\_find\_struct\_meta(btf, btf\_id);
if (!meta)
return -EFAULT;
rec->fields[i].graph\_root.value\_rec = meta->record;
So basically, 'value\_rec' is a pointer to the record in struct\_metas\_tab.
And it is possible that that particular record has been freed by
btf\_struct\_metas\_free() and hence we have a kasan error here.
Actually it is very hard to reproduce the failure with current bpf/bpf-next
code, I only got the above error once. To increase reproducibility, I added
a delay in bpf\_map\_free\_deferred() to delay map->ops->map\_free(), which
significantly increased reproducibility.
# diff --git a/kernel/bpf/syscall.c b/kernel/bpf/syscall.c
# index 5e43ddd1b83f..aae5b5213e93 100644
# --- a/kernel/bpf/syscall.c
# +++ b/kernel/bpf/syscall.c
# @@ -695,6 +695,7 @@ static void bpf\_map\_free\_deferred(struct work\_struct \*work)
# struct bpf\_map \*map = container\_of(work, struct bpf\_map, work);
# struct btf\_record \*rec = map->record;
#
# + mdelay(100);
# security\_bpf\_map\_free(map);
# bpf\_map\_release\_memcg(map);
# /\* implementation dependent freeing \*/
Hao also provided test cases ([1]) for easily reproducing the above issue.
There are two ways to fix the issue, the v1 of the patch ([2]) moving
btf\_put() after map\_free callback, and the v5 of the patch ([3]) using
a kptr style fix which tries to get a btf reference during
map\_check\_btf(). Each approach has its pro and cons. The first approach
delays freeing btf while the second approach needs to acquire reference
depending on context which makes logic not very elegant and may
complicate things with future new data structures. Alexei
suggested in [4] going back to v1 which is what this patch
tries to do.
Rerun './test\_progs -j' with the above mdelay() hack for a couple
of times and didn't observe the error for the above rb\_root test cases.
Running Hou's test ([1]) is also successful.
[1] https://lore.kernel.org/bpf/20231207141500.917136-1-houtao@huaweicloud.com/
[2] v1: https://lore.kernel.org/bpf/20231204173946.3066377-1-yonghong.song@linux.dev/
[3] v5: https://lore.kernel.org/bpf/20231208041621.2968241-1-yonghong.song@linux.dev/
[4] v4: https://lore.kernel.org/bpf/CAADnVQJ3FiXUhZJwX\_81sjZvSYYKCFB3BT6P8D59RS2Gu+0Z7g@mail.gmail.com/
Cc: Hou Tao <houtao@huaweicloud.com>
Fixes: 958cf2e273f0 ("bpf: Introduce bpf\_obj\_new")
Signed-off-by: Yonghong Song <yonghong.song@linux.dev>
Link: [https://lore.kernel.org/r/20231214203815.1469107-1-yonghong.song@linux.dev](https://lore.kernel.org/r/20231214203815.1469107-1-yonghong.song%40linux.dev)
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d048dced8ea5eac6723ae873a40567e6f101ea42)

| -rw-r--r-- | [kernel/bpf/syscall.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/bpf/syscall.c?id=d048dced8ea5eac6723ae873a40567e6f101ea42) | 6 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 5 insertions, 1 deletions

| diff --git a/kernel/bpf/syscall.c b/kernel/bpf/syscall.cindex 1625b9d5202c11..3f3bd5518a69a8 100644--- a/[kernel/bpf/syscall.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/syscall.c?id=42357465a069748f5f90259400eb80cc7c3ea08c)+++ b/[kernel/bpf/syscall.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/syscall.c?id=d048dced8ea5eac6723ae873a40567e6f101ea42)@@ -692,6 +692,7 @@ static void bpf\_map\_free\_deferred(struct work\_struct \*work) { struct bpf\_map \*map = container\_of(work, struct bpf\_map, work); struct btf\_record \*rec = map->record;+ struct btf \*btf = map->btf;  security\_bpf\_map\_free(map); bpf\_map\_release\_memcg(map);@@ -707,6 +708,10 @@ static void bpf\_map\_free\_deferred(struct work\_struct \*work) \* template bpf\_map struct used during verification. \*/ btf\_record\_free(rec);+ /\* Delay freeing of btf for maps, as map\_free callback may need+ \* struct\_meta info which will be freed with btf\_put().+ \*/+ btf\_put(btf); }  static void bpf\_map\_put\_uref(struct bpf\_map \*map)@@ -747,7 +752,6 @@ void bpf\_map\_put(struct bpf\_map \*map) if (atomic64\_dec\_and\_test(&map->refcnt)) { /\* bpf\_map\_free\_id() must be called first \*/ bpf\_map\_free\_id(map);- btf\_put(map->btf);  if (READ\_ONCE(map->free\_after\_mult\_rcu\_gp)) call\_rcu\_tasks\_trace(&map->rcu, bpf\_map\_free\_mult\_rcu\_gp); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 20:07:54 +0000

