The provided content describes a vulnerability in the Linux kernel's SLUB allocator, specifically related to the handling of free pointers when `init_on_free` is enabled and objects are freed individually.

**Root cause of vulnerability:**
The vulnerability arises from a change introduced by commit `284f17ac13fe`, which separated single and bulk object freeing into `slab_free()` and `slab_free_bulk()`. This caused `slab_free()` to call `slab_free_hook()` directly, instead of `slab_free_freelist_hook()`. When `init_on_free` is set, `slab_free_hook()` zeroes the object, including the freepointer. If `CONFIG_SLAB_FREELIST_HARDENED` is also set, the freelist consistency checks in the slow path (`do_slab_free()`) would try to decode the zeroed freepointer, leading to a "Freepointer corrupt" detection. This issue does not affect bulk frees, since `slab_free_freelist_hook()` always sets the freepointer using `set_freepointer()`, correctly maintaining the freelist.

**Weaknesses/vulnerabilities present:**
- Incorrect handling of the freepointer during single object frees when `init_on_free` and `CONFIG_SLAB_FREELIST_HARDENED` are enabled.
- Zeroing of the freepointer by `slab_free_hook()` leading to corruption when freelist consistency checks are performed.

**Impact of exploitation:**
- Kernel panic or "Freepointer corrupt" error. The provided dmesg log shows an example of the error.
-  Inconsistency within the SLUB allocator.
- The vulnerability can lead to denial of service.
- Potential for memory corruption due to the inconsistent state of the freelist.

**Attack vectors:**
- Triggering a single object free while the mentioned conditions are met (i.e., `init_on_free` and `CONFIG_SLAB_FREELIST_HARDENED` are enabled and `slub_debug=F`).

**Required attacker capabilities/position:**
- The attacker needs to be able to trigger a single object free.
- The vulnerability requires specific kernel configuration settings to be enabled: `init_on_free=1`, `CONFIG_SLAB_FREELIST_HARDENED=y`, and `slub_debug=F`.

**Additional details:**
- The patch addresses this issue by avoiding zeroing the freepointer if it is stored outside of the object during single frees when `init_on_free` is set,
- The fix involves checking if the freepointer is located outside of the object and adjusting the memset call in `slab_free_hook` and `maybe_wipe_obj_freeptr` accordingly.
- The dmesg sample log provided demonstrates how the vulnerability manifests itself with a "Freepointer corrupt" BUG report and related memory layout information.