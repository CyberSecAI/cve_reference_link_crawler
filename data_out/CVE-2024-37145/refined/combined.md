=== Content from securitylab.github.com_d647bab5_20250111_153243.html ===

[skip to content](#content)

 /
[Security Lab](/ "Security Lab")
[Research](https://github.blog/tag/github-security-lab/ "Research")
[Advisories](/advisories/ "Advisories")
[CodeQL Wall of Fame](/codeql-wall-of-fame/ "CodeQL Wall of Fame")
Resources

[Events](/events/ "Events")

[Get Involved](/get-involved/)

* Resources
* [Open Source Community](/open-source "Home")
* [Enterprise](/enterprise "Home")

 /
[Security Lab](/ "Security Lab")

[Research](https://github.blog/tag/github-security-lab/ "Research")
[Advisories](/advisories/ "Advisories")
[CodeQL Wall of Fame](/codeql-wall-of-fame/ "CodeQL Wall of Fame")
Resources

[Open Source Community](/open-source "Open Source Community")
[Enterprise](/enterprise "Enterprise")

[Events](/events/ "Events")
[Get Involved](/get-involved/ "Events")

June 28, 2024
# GHSL-2023-232\_GHSL-2023-234: Path injection, Cross-Site Scripting (XSS) and CORS misconfiguration in Flowise - CVE-2024-36420, CVE-2024-36421, CVE-2024-36422, CVE-2024-36423, CVE-2024-37145, CVE-2024-37146

[![Author avatar](https://avatars.githubusercontent.com/u/11400619)
Kevin Stubbings](https://github.com/Kwstubbs)

## Coordinated Disclosure Timeline

* 2023-11-27: Vulnerability Report Submitted Via Private Vulnerability Reporting and  [Open Issue](https://github.com/FlowiseAI/Flowise/issues/1290)
* 2023-12-05: Maintainer acknowledges receipt of reports, but states they have a lack of resources to fix issues. Disclosure deadline extended an extra 90 days in order to help maintaners.
* 2024-05-22: Maintainers informed that advisories are planned to be released soon in accordance with our policy. Messages receive no response.
* 2024-06-03: Decision to release advisory due to lack of response from maintainers.
* 2024-06-27: Maintainers informed that advisories will be released on June 28, 2024.

## Summary

Flowise is vulnerable to path injection, cross site scripting and CORS misconfiguration vulnerabilities, that may compromise the confidentiality of the information on the host server. In the worst case, it may allow attackers to read files from the Flowise server and read/modify user secrets.

## Project

Flowise

## Tested Version

[v1.4.3](https://github.com/FlowiseAI/Flowise/releases/tag/flowise%401.4.3)

## Details

### Issue 1: Path Injection at [`/api/v1/openai-assistants-file`](https://github.com/FlowiseAI/Flowise/blob/e93ce07851cdc0fcde12374f301b8070f2043687/packages/server/src/index.ts#L982) (`GHSL-2023-232`)

The [`/api/v1/openai-assistants-file`](https://github.com/FlowiseAI/Flowise/blob/e93ce07851cdc0fcde12374f301b8070f2043687/packages/server/src/index.ts#L982) endpoint in index.ts is vulnerable to arbitrary file read due to lack of sanitization of the fileName body parameter.

```
this.app.post('/api/v1/openai-assistants-file', async (req: Request, res: Response) => {
            const filePath = path.join(getUserHome(), '.flowise', 'openai-assistant', req.body.fileName)
            res.setHeader('Content-Disposition', 'attachment; filename=' + path.basename(filePath))
            const fileStream = fs.createReadStream(filePath)
            fileStream.pipe(res)

```

This vulnerability was found with the help of [CodeQL](https://codeql.github.com/codeql-query-help/javascript/js-path-injection/).

#### Impact

This issue may lead to `Arbitrary File Read`

### Issue 2: Reflected XSS in packages/server/src/index.ts (`GHSL-2023-245`-`GHSL-2023-248`)

Reflected XSS vulnerabilities occur in many of the API endpoints. If the default configuration is used (unauthenticated), an attacker may be able to craft a specially crafted URL that injects Javascript into the user sessions, allowing the attacker to steal information, create false popups, or even redirect the user to other websites without interaction.

```
this.app.get('/api/v1/flow-config/:id', async (req: Request, res: Response) => {
            const chatflow = await this.AppDataSource.getRepository(ChatFlow).findOneBy({
                id: req.params.id
            })
            if (!chatflow) return res.status(404).send(`Chatflow ${req.params.id} not found`)
            const flowData = chatflow.flowData
            const parsedFlowData: IReactFlowObject = JSON.parse(flowData)
            const nodes = parsedFlowData.nodes
            const availableConfigs = findAvailableConfigs(nodes, this.nodesPool.componentCredentials)
            return res.json(availableConfigs)
        })

```

If the chatflow ID is not found, its value is reflected in the 404 page, which has type text/html. This allows an attacker to attach arbitrary scripts to the page, allowing an attacker to steal sensitive information. This XSS may be chained with the path injection to allow an attacker without direct access to Flowise to read arbitrary files from the Flowise server.

This vulnerability is found in many endpoints in index.ts, including:

[`api/v1/chatflows/id`](https://github.com/FlowiseAI/Flowise/blob/flowise-ui%401.4.0/packages/server/src/index.ts#L312-L312)(`GHSL-2023-245`)

[`/api/v1/public-chatflows/id`](https://github.com/FlowiseAI/Flowise/blob/flowise-ui%401.4.0/packages/server/src/index.ts#L322-L322)(`GHSL-2023-246`)

[`/api/v1/chatflows-streaming/id`](https://github.com/FlowiseAI/Flowise/blob/flowise-ui%401.4.0/packages/server/src/index.ts#L375-L375)(`GHSL-2023-247`)

[`/api/v1/credentials/id`](https://github.com/FlowiseAI/Flowise/blob/flowise-ui%401.4.0/packages/server/src/index.ts#L545-L545)(`GHSL-2023-248`)

I have linked the GET handler for each endpoint which is immediately exploitable, but their POST, PUT, DELETE counterparts may be exploitable in the future. It is recommended that you remove all cases where
data provided from the `req` parameter is passed to the `res` without sanitization.
Example:

```
res.status(404).send(`Chatflow ${req.params.id} not found`)

```

These vulnerabilities were found with the help of [CodeQL](https://codeql.github.com/codeql-query-help/javascript/js-reflected-xss)

#### Impact

This issue may lead to `Information Disclosure`

### Issue 3: Cors Misconfiguration in [`packages/server/src/index.ts`](https://github.com/FlowiseAI/Flowise/blob/e93ce07851cdc0fcde12374f301b8070f2043687/packages/server/src/index.ts#L122) (`GHSL-2023-234`)

A CORS misconfiguration sets the Access-Control-Allow-Origin header to all, allowing arbitrary origins to connect to the website. In the default configuration (unauthenticated), arbitrary origins may be able to make requests to Flowise, stealing information from the user.

```
// Allow access from *
        this.app.use(cors())

```

This CORS misconfiguration may be chained with the path injection to allow an attacker attackers without access to Flowise to read arbitrary files from the Flowise server.

#### Impact

This issue may lead to `Information Disclosure`

## Credit

These issues were discovered and reported by GHSL team member [@Kwstubbs (Kevin Stubbings)](https://github.com/Kwstubbs).

## Contact

You can contact the GHSL team at `securitylab@github.com`, please include a reference to `GHSL-2023-232`,`GHSL-2023-234`, `GHSL-2023-245`-`GHSL-2023-248` in any communication regarding these issues.

## CVE

* CVE-2024-36420
* CVE-2024-36421
* CVE-2024-36422
* CVE-2024-36423
* CVE-2024-37145
* CVE-2024-37146

## Product

* [Features](https://github.com/features)
* [Security](https://github.com/security)
* [Team](https://github.com/team)
* [Enterprise](https://github.com/enterprise)
* [Customer stories](https://github.com/customer-stories?type=enterprise)
* [The ReadME Project](https://github.com/readme)
* [Pricing](https://github.com/pricing)
* [Resources](https://resources.github.com)
* [Roadmap](https://github.com/github/roadmap)
* [Compare GitHub](https://resources.github.com/devops/tools/compare/)

## Platform

* [Developer API](https://developer.github.com)
* [Partners](http://partner.github.com/)
* [Atom](https://atom.io)
* [Electron](http://electron.atom.io/)
* [GitHub Desktop](https://desktop.github.com/)

## Support

* [Docs](https://docs.github.com)
* [Community Forum](https://github.community)
* [Professional Services](https://services.github.com/)
* [GitHub Skills](https://skills.github.com/)
* [Status](https://githubstatus.com/)
* [Contact GitHub](https://support.github.com)

## Company

* [About](https://github.com/about)
* [Blog](https://github.blog)
* [Careers](https://github.com/about/careers)
* [Press](https://github.com/about/press)
* [Inclusion](https://github.com/about/careers)
* [Social Impact](https://github.com/about/press)
* [Shop](https://shop.github.com)

* GitHub Inc. Â©
  2024
* [Terms](https://docs.github.com/en/github/site-policy/github-terms-of-service)
* [Privacy](https://docs.github.com/en/github/site-policy/github-privacy-statement)
* Sitemap
* [What is Git?](https://github.com/git-guides)
* Manage Cookies
* Do not share my personal information



=== Content from github.com_6f99a5c8_20250111_153243.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FFlowiseAI%2FFlowise%2Fblob%2Fflowise-ui%25401.4.0%2Fpackages%2Fserver%2Fsrc%2Findex.ts)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FFlowiseAI%2FFlowise%2Fblob%2Fflowise-ui%25401.4.0%2Fpackages%2Fserver%2Fsrc%2Findex.ts)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=FlowiseAI%2FFlowise)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[FlowiseAI](/FlowiseAI)
/
**[Flowise](/FlowiseAI/Flowise)**
Public

* [Notifications](/login?return_to=%2FFlowiseAI%2FFlowise) You must be signed in to change notification settings
* [Fork
  17.4k](/login?return_to=%2FFlowiseAI%2FFlowise)
* [Star
   33.6k](/login?return_to=%2FFlowiseAI%2FFlowise)

* [Code](/FlowiseAI/Flowise/tree/flowise-ui%401.4.0)
* [Issues
  416](/FlowiseAI/Flowise/issues)
* [Pull requests
  37](/FlowiseAI/Flowise/pulls)
* [Discussions](/FlowiseAI/Flowise/discussions)
* [Actions](/FlowiseAI/Flowise/actions)
* [Projects
  0](/FlowiseAI/Flowise/projects)
* [Security](/FlowiseAI/Flowise/security)
* [Insights](/FlowiseAI/Flowise/pulse)

Additional navigation options

* [Code](/FlowiseAI/Flowise/tree/flowise-ui%401.4.0)
* [Issues](/FlowiseAI/Flowise/issues)
* [Pull requests](/FlowiseAI/Flowise/pulls)
* [Discussions](/FlowiseAI/Flowise/discussions)
* [Actions](/FlowiseAI/Flowise/actions)
* [Projects](/FlowiseAI/Flowise/projects)
* [Security](/FlowiseAI/Flowise/security)
* [Insights](/FlowiseAI/Flowise/pulse)

## Files

Â flowise-ui@1.4.0
## Breadcrumbs

1. [Flowise](/FlowiseAI/Flowise/tree/flowise-ui%401.4.0)
2. /[packages](/FlowiseAI/Flowise/tree/flowise-ui%401.4.0/packages)
3. /[server](/FlowiseAI/Flowise/tree/flowise-ui%401.4.0/packages/server)
4. /[src](/FlowiseAI/Flowise/tree/flowise-ui%401.4.0/packages/server/src)
/
# index.ts

Copy path Blame  Blame
## Latest commit

## History

[History](/FlowiseAI/Flowise/commits/flowise-ui%401.4.0/packages/server/src/index.ts)1547 lines (1315 loc) Â· 64.1 KBÂ flowise-ui@1.4.0
## Breadcrumbs

1. [Flowise](/FlowiseAI/Flowise/tree/flowise-ui%401.4.0)
2. /[packages](/FlowiseAI/Flowise/tree/flowise-ui%401.4.0/packages)
3. /[server](/FlowiseAI/Flowise/tree/flowise-ui%401.4.0/packages/server)
4. /[src](/FlowiseAI/Flowise/tree/flowise-ui%401.4.0/packages/server/src)
/
# index.ts

Top
## File metadata and controls

* Code
* Blame

1547 lines (1315 loc) Â· 64.1 KB[Raw](https://github.com/FlowiseAI/Flowise/raw/refs/tags/flowise-ui%401.4.0/packages/server/src/index.ts)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000import express, { NextFunction, Request, Response } from 'express'import multer from 'multer'import path from 'path'import cors from 'cors'import http from 'http'import \* as fs from 'fs'import basicAuth from 'express-basic-auth'import { Server } from 'socket.io'import logger from './utils/logger'import { expressRequestLogger } from './utils/logger'import { v4 as uuidv4 } from 'uuid'import OpenAI from 'openai'import { Between, IsNull, FindOptionsWhere } from 'typeorm'import { IChatFlow, IncomingInput, IReactFlowNode, IReactFlowObject, INodeData, IDatabaseExport, ICredentialReturnResponse, chatType, IChatMessage, IReactFlowEdge} from './Interface'import { getNodeModulesPackagePath, getStartingNodes, buildLangchain, getEndingNode, constructGraphs, resolveVariables, isStartNodeDependOnInput, getAPIKeys, addAPIKey, updateAPIKey, deleteAPIKey, compareKeys, mapMimeTypeToInputField, findAvailableConfigs, isSameOverrideConfig, replaceAllAPIKeys, isFlowValidForStream, databaseEntities, getApiKey, transformToCredentialEntity, decryptCredentialData, clearAllSessionMemory, replaceInputsWithConfig, getEncryptionKey, checkMemorySessionId, clearSessionMemoryFromViewMessageDialog, getUserHome} from './utils'import { cloneDeep, omit } from 'lodash'import { getDataSource } from './DataSource'import { NodesPool } from './NodesPool'import { ChatFlow } from './database/entities/ChatFlow'import { ChatMessage } from './database/entities/ChatMessage'import { Credential } from './database/entities/Credential'import { Tool } from './database/entities/Tool'import { Assistant } from './database/entities/Assistant'import { ChatflowPool } from './ChatflowPool'import { CachePool } from './CachePool'import { ICommonObject, INodeOptionsValue } from 'flowise-components'import { createRateLimiter, getRateLimiter, initializeRateLimiter } from './utils/rateLimit'
export class App { app: express.Application nodesPool: NodesPool chatflowPool: ChatflowPool cachePool: CachePool AppDataSource = getDataSource()
 constructor() { this.app = express() }
 async initDatabase() { // Initialize database this.AppDataSource.initialize() .then(async () => { logger.info('ðŸ“¦ [server]: Data Source has been initialized!')
 // Run Migrations Scripts await this.AppDataSource.runMigrations({ transaction: 'each' })
 // Initialize nodes pool this.nodesPool = new NodesPool() await this.nodesPool.initialize()
 // Initialize chatflow pool this.chatflowPool = new ChatflowPool()
 // Initialize API keys await getAPIKeys()
 // Initialize encryption key await getEncryptionKey()
 // Initialize Rate Limit const AllChatFlow: IChatFlow[] = await getAllChatFlow() await initializeRateLimiter(AllChatFlow)
 // Initialize cache pool this.cachePool = new CachePool() }) .catch((err) => { logger.error('âŒ [server]: Error during Data Source initialization:', err) }) }
 async config(socketIO?: Server) { // Limit is needed to allow sending/receiving base64 encoded string this.app.use(express.json({ limit: '50mb' })) this.app.use(express.urlencoded({ limit: '50mb', extended: true }))
 if (process.env.NUMBER\_OF\_PROXIES && parseInt(process.env.NUMBER\_OF\_PROXIES) > 0) this.app.set('trust proxy', parseInt(process.env.NUMBER\_OF\_PROXIES))
 // Allow access from \* this.app.use(cors())
 // Add the expressRequestLogger middleware to log all requests this.app.use(expressRequestLogger)
 if (process.env.FLOWISE\_USERNAME && process.env.FLOWISE\_PASSWORD) { const username = process.env.FLOWISE\_USERNAME const password = process.env.FLOWISE\_PASSWORD const basicAuthMiddleware = basicAuth({ users: { [username]: password } }) const whitelistURLs = [ '/api/v1/verify/apikey/', '/api/v1/chatflows/apikey/', '/api/v1/public-chatflows', '/api/v1/prediction/', '/api/v1/node-icon/', '/api/v1/components-credentials-icon/', '/api/v1/chatflows-streaming', '/api/v1/ip' ] this.app.use((req, res, next) => { if (req.url.includes('/api/v1/')) { whitelistURLs.some((url) => req.url.includes(url)) ? next() : basicAuthMiddleware(req, res, next) } else next() }) }
 const upload = multer({ dest: `${path.join(\_\_dirname, '..', 'uploads')}/` })
 // ---------------------------------------- // Configure number of proxies in Host Environment // ---------------------------------------- this.app.get('/api/v1/ip', (request, response) => { response.send({ ip: request.ip, msg: 'See the returned IP address in the response. If it matches your current IP address ( which you can get by going to http://ip.nfriedly.com/ or https://api.ipify.org/ ), then the number of proxies is correct and the rate limiter should now work correctly. If not, increase the number of proxies by 1 until the IP address matches your own. Visit https://docs.flowiseai.com/deployment#rate-limit-setup-guide for more information.' }) })
 // ---------------------------------------- // Components // ----------------------------------------
 // Get all component nodes this.app.get('/api/v1/nodes', (req: Request, res: Response) => { const returnData = [] for (const nodeName in this.nodesPool.componentNodes) { const clonedNode = cloneDeep(this.nodesPool.componentNodes[nodeName]) returnData.push(clonedNode) } return res.json(returnData) })
 // Get all component credentials this.app.get('/api/v1/components-credentials', async (req: Request, res: Response) => { const returnData = [] for (const credName in this.nodesPool.componentCredentials) { const clonedCred = cloneDeep(this.nodesPool.componentCredentials[credName]) returnData.push(clonedCred) } return res.json(returnData) })
 // Get specific component node via name this.app.get('/api/v1/nodes/:name', (req: Request, res: Response) => { if (Object.prototype.hasOwnProperty.call(this.nodesPool.componentNodes, req.params.name)) { return res.json(this.nodesPool.componentNodes[req.params.name]) } else { throw new Error(`Node ${req.params.name} not found`) } })
 // Get component credential via name this.app.get('/api/v1/components-credentials/:name', (req: Request, res: Response) => { if (!req.params.name.includes('&')) { if (Object.prototype.hasOwnProperty.call(this.nodesPool.componentCredentials, req.params.name)) { return res.json(this.nodesPool.componentCredentials[req.params.name]) } else { throw new Error(`Credential ${req.params.name} not found`) } } else { const returnResponse = [] for (const name of req.params.name.split('&')) { if (Object.prototype.hasOwnProperty.call(this.nodesPool.componentCredentials, name)) { returnResponse.push(this.nodesPool.componentCredentials[name]) } else { throw new Error(`Credential ${name} not found`) } } return res.json(returnResponse) } })
 // Returns specific component node icon via name this.app.get('/api/v1/node-icon/:name', (req: Request, res: Response) => { if (Object.prototype.hasOwnProperty.call(this.nodesPool.componentNodes, req.params.name)) { const nodeInstance = this.nodesPool.componentNodes[req.params.name] if (nodeInstance.icon === undefined) { throw new Error(`Node ${req.params.name} icon not found`) }
 if (nodeInstance.icon.endsWith('.svg') || nodeInstance.icon.endsWith('.png') || nodeInstance.icon.endsWith('.jpg')) { const filepath = nodeInstance.icon res.sendFile(filepath) } else { throw new Error(`Node ${req.params.name} icon is missing icon`) } } else { throw new Error(`Node ${req.params.name} not found`) } })
 // Returns specific component credential icon via name this.app.get('/api/v1/components-credentials-icon/:name', (req: Request, res: Response) => { if (Object.prototype.hasOwnProperty.call(this.nodesPool.componentCredentials, req.params.name)) { const credInstance = this.nodesPool.componentCredentials[req.params.name] if (credInstance.icon === undefined) { throw new Error(`Credential ${req.params.name} icon not found`) }
 if (credInstance.icon.endsWith('.svg') || credInstance.icon.endsWith('.png') || credInstance.icon.endsWith('.jpg')) { const filepath = credInstance.icon res.sendFile(filepath) } else { throw new Error(`Credential ${req.params.name} icon is missing icon`) } } else { throw new Error(`Credential ${req.params.name} not found`) } })
 // load async options this.app.post('/api/v1/node-load-method/:name', async (req: Request, res: Response) => { const nodeData: INodeData = req.body if (Object.prototype.hasOwnProperty.call(this.nodesPool.componentNodes, req.params.name)) { try { const nodeInstance = this.nodesPool.componentNodes[req.params.name] const methodName = nodeData.loadMethod || ''
 const returnOptions: INodeOptionsValue[] = await nodeInstance.loadMethods![methodName]!.call(nodeInstance, nodeData, { appDataSource: this.AppDataSource, databaseEntities: databaseEntities })
 return res.json(returnOptions) } catch (error) { return res.json([]) } } else { res.status(404).send(`Node ${req.params.name} not found`) return } })
 // ---------------------------------------- // Chatflows // ----------------------------------------
 // Get all chatflows this.app.get('/api/v1/chatflows', async (req: Request, res: Response) => { const chatflows: IChatFlow[] = await getAllChatFlow() return res.json(chatflows) })
 // Get specific chatflow via api key this.app.get('/api/v1/chatflows/apikey/:apiKey', async (req: Request, res: Response) => { try { const apiKey = await getApiKey(req.params.apiKey) if (!apiKey) return res.status(401).send('Unauthorized') const chatflows = await this.AppDataSource.getRepository(ChatFlow) .createQueryBuilder('cf') .where('cf.apikeyid = :apikeyid', { apikeyid: apiKey.id }) .orWhere('cf.apikeyid IS NULL') .orWhere('cf.apikeyid = ""') .orderBy('cf.name', 'ASC') .getMany() if (chatflows.length >= 1) return res.status(200).send(chatflows) return res.status(404).send('Chatflow not found') } catch (err: any) { return res.status(500).send(err?.message) } })
 // Get specific chatflow via id this.app.get('/api/v1/chatflows/:id', async (req: Request, res: Response) => { const chatflow = await this.AppDataSource.getRepository(ChatFlow).findOneBy({ id: req.params.id }) if (chatflow) return res.json(chatflow) return res.status(404).send(`Chatflow ${req.params.id} not found`) })
 // Get specific chatflow via id (PUBLIC endpoint, used when sharing chatbot link) this.app.get('/api/v1/public-chatflows/:id', async (req: Request, res: Response) => { const chatflow = await this.AppDataSource.getRepository(ChatFlow).findOneBy({ id: req.params.id }) if (chatflow && chatflow.isPublic) return res.json(chatflow) else if (chatflow && !chatflow.isPublic) return res.status(401).send(`Unauthorized`) return res.status(404).send(`Chatflow ${req.params.id} not found`) })
 // Save chatflow this.app.post('/api/v1/chatflows', async (req: Request, res: Response) => { const body = req.body const newChatFlow = new ChatFlow() Object.assign(newChatFlow, body)
 const chatflow = this.AppDataSource.getRepository(ChatFlow).create(newChatFlow) const results = await this.AppDataSource.getRepository(ChatFlow).save(chatflow)
 return res.json(results) })
 // Update chatflow this.app.put('/api/v1/chatflows/:id', async (req: Request, res: Response) => { const chatflow = await this.AppDataSource.getRepository(ChatFlow).findOneBy({ id: req.params.id })
 if (!chatflow) { res.status(404).send(`Chatflow ${req.params.id} not found`) return }
 const body = req.body const updateChatFlow = new ChatFlow() Object.assign(updateChatFlow, body)
 updateChatFlow.id = chatflow.id createRateLimiter(updateChatFlow)
 this.AppDataSource.getRepository(ChatFlow).merge(chatflow, updateChatFlow) const result = await this.AppDataSource.getRepository(ChatFlow).save(chatflow)
 // Update chatflowpool inSync to false, to build Langchain again because data has been changed this.chatflowPool.updateInSync(chatflow.id, false)
 return res.json(result) })
 // Delete chatflow via id this.app.delete('/api/v1/chatflows/:id', async (req: Request, res: Response) => { const results = await this.AppDataSource.getRepository(ChatFlow).delete({ id: req.params.id }) return res.json(results) })
 // Check if chatflow valid for streaming this.app.get('/api/v1/chatflows-streaming/:id', async (req: Request, res: Response) => { const chatflow = await this.AppDataSource.getRepository(ChatFlow).findOneBy({ id: req.params.id }) if (!chatflow) return res.status(404).send(`Chatflow ${req.params.id} not found`)
 /\*\*\* Get Ending Node with Directed Graph \*\*\*/ const flowData = chatflow.flowData const parsedFlowData: IReactFlowObject = JSON.parse(flowData) const nodes = parsedFlowData.nodes const edges = parsedFlowData.edges const { graph, nodeDependencies } = constructGraphs(nodes, edges)
 const endingNodeId = getEndingNode(nodeDependencies, graph) if (!endingNodeId) return res.status(500).send(`Ending node ${endingNodeId} not found`)
 const endingNodeData = nodes.find((nd) => nd.id === endingNodeId)?.data if (!endingNodeData) return res.status(500).send(`Ending node ${endingNodeId} data not found`)
 if (endingNodeData && endingNodeData.category !== 'Chains' && endingNodeData.category !== 'Agents') { return res.status(500).send(`Ending node must be either a Chain or Agent`) }
 const obj = { isStreaming: isFlowValidForStream(nodes, endingNodeData) } return res.json(obj) })
 // ---------------------------------------- // ChatMessage // ----------------------------------------
 // Get all chatmessages from chatflowid this.app.get('/api/v1/chatmessage/:id', async (req: Request, res: Response) => { const sortOrder = req.query?.order as string | undefined const chatId = req.query?.chatId as string | undefined const memoryType = req.query?.memoryType as string | undefined const sessionId = req.query?.sessionId as string | undefined const startDate = req.query?.startDate as string | undefined const endDate = req.query?.endDate as string | undefined let chatTypeFilter = req.query?.chatType as chatType | undefined
 if (chatTypeFilter) { try { const chatTypeFilterArray = JSON.parse(chatTypeFilter) if (chatTypeFilterArray.includes(chatType.EXTERNAL) && chatTypeFilterArray.includes(chatType.INTERNAL)) { chatTypeFilter = undefined } else if (chatTypeFilterArray.includes(chatType.EXTERNAL)) { chatTypeFilter = chatType.EXTERNAL } else if (chatTypeFilterArray.includes(chatType.INTERNAL)) { chatTypeFilter = chatType.INTERNAL } } catch (e) { return res.status(500).send(e) } }
 const chatmessages = await this.getChatMessage( req.params.id, chatTypeFilter, sortOrder, chatId, memoryType, sessionId, startDate, endDate ) return res.json(chatmessages) })
 // Get internal chatmessages from chatflowid this.app.get('/api/v1/internal-chatmessage/:id', async (req: Request, res: Response) => { const chatmessages = await this.getChatMessage(req.params.id, chatType.INTERNAL) return res.json(chatmessages) })
 // Add chatmessages for chatflowid this.app.post('/api/v1/chatmessage/:id', async (req: Request, res: Response) => { const body = req.body const results = await this.addChatMessage(body) return res.json(results) })
 // Delete all chatmessages from chatId this.app.delete('/api/v1/chatmessage/:id', async (req: Request, res: Response) => { const chatflowid = req.params.id const chatflow = await this.AppDataSource.getRepository(ChatFlow).findOneBy({ id: chatflowid }) if (!chatflow) { res.status(404).send(`Chatflow ${chatflowid} not found`) return } const chatId = (req.query?.chatId as string) ?? (await getChatId(chatflowid)) const memoryType = req.query?.memoryType as string | undefined const sessionId = req.query?.sessionId as string | undefined const chatType = req.query?.chatType as string | undefined const isClearFromViewMessageDialog = req.query?.isClearFromViewMessageDialog as string | undefined
 const flowData = chatflow.flowData const parsedFlowData: IReactFlowObject = JSON.parse(flowData) const nodes = parsedFlowData.nodes
 if (isClearFromViewMessageDialog) { await clearSessionMemoryFromViewMessageDialog( nodes, this.nodesPool.componentNodes, chatId, this.AppDataSource, sessionId, memoryType ) } else { await clearAllSessionMemory(nodes, this.nodesPool.componentNodes, chatId, this.AppDataSource, sessionId) }
 const deleteOptions: FindOptionsWhere<ChatMessage> = { chatflowid, chatId } if (memoryType) deleteOptions.memoryType = memoryType if (sessionId) deleteOptions.sessionId = sessionId if (chatType) deleteOptions.chatType = chatType
 const results = await this.AppDataSource.getRepository(ChatMessage).delete(deleteOptions) return res.json(results) })
 // ---------------------------------------- // Credentials // ----------------------------------------
 // Create new credential this.app.post('/api/v1/credentials', async (req: Request, res: Response) => { const body = req.body const newCredential = await transformToCredentialEntity(body) const credential = this.AppDataSource.getRepository(Credential).create(newCredential) const results = await this.AppDataSource.getRepository(Credential).save(credential) return res.json(results) })
 // Get all credentials this.app.get('/api/v1/credentials', async (req: Request, res: Response) => { if (req.query.credentialName) { let returnCredentials = [] if (Array.isArray(req.query.credentialName)) { for (let i = 0; i < req.query.credentialName.length; i += 1) { const name = req.query.credentialName[i] as string const credentials = await this.AppDataSource.getRepository(Credential).findBy({ credentialName: name }) returnCredentials.push(...credentials) } } else { const credentials = await this.AppDataSource.getRepository(Credential).findBy({ credentialName: req.query.credentialName as string }) returnCredentials = [...credentials] } return res.json(returnCredentials) } else { const credentials = await this.AppDataSource.getRepository(Credential).find() const returnCredentials = [] for (const credential of credentials) { returnCredentials.push(omit(credential, ['encryptedData'])) } return res.json(returnCredentials) } })
 // Get specific credential this.app.get('/api/v1/credentials/:id', async (req: Request, res: Response) => { const credential = await this.AppDataSource.getRepository(Credential).findOneBy({ id: req.params.id })
 if (!credential) return res.status(404).send(`Credential ${req.params.id} not found`)
 // Decrpyt credentialData const decryptedCredentialData = await decryptCredentialData( credential.encryptedData, credential.credentialName, this.nodesPool.componentCredentials ) const returnCredential: ICredentialReturnResponse = { ...credential, plainDataObj: decryptedCredentialData } return res.json(omit(returnCredential, ['encryptedData'])) })
 // Update credential this.app.put('/api/v1/credentials/:id', async (req: Request, res: Response) => { const credential = await this.AppDataSource.getRepository(Credential).findOneBy({ id: req.params.id })
 if (!credential) return res.status(404).send(`Credential ${req.params.id} not found`)
 const body = req.body const updateCredential = await transformToCredentialEntity(body) this.AppDataSource.getRepository(Credential).merge(credential, updateCredential) const result = await this.AppDataSource.getRepository(Credential).save(credential)
 return res.json(result) })
 // Delete all chatmessages from chatflowid this.app.delete('/api/v1/credentials/:id', async (req: Request, res: Response) => { const results = await this.AppDataSource.getRepository(Credential).delete({ id: req.params.id }) return res.json(results) })
 // ---------------------------------------- // Tools // ----------------------------------------
 // Get all tools this.app.get('/api/v1/tools', async (req: Request, res: Response) => { const tools = await this.AppDataSource.getRepository(Tool).find() return res.json(tools) })
 // Get specific tool this.app.get('/api/v1/tools/:id', async (req: Request, res: Response) => { const tool = await this.AppDataSource.getRepository(Tool).findOneBy({ id: req.params.id }) return res.json(tool) })
 // Add tool this.app.post('/api/v1/tools', async (req: Request, res: Response) => { const body = req.body const newTool = new Tool() Object.assign(newTool, body)
 const tool = this.AppDataSource.getRepository(Tool).create(newTool) const results = await this.AppDataSource.getRepository(Tool).save(tool)
 return res.json(results) })
 // Update tool this.app.put('/api/v1/tools/:id', async (req: Request, res: Response) => { const tool = await this.AppDataSource.getRepository(Tool).findOneBy({ id: req.params.id })
 if (!tool) { res.status(404).send(`Tool ${req.params.id} not found`) return }
 const body = req.body const updateTool = new Tool() Object.assign(updateTool, body)
 this.AppDataSource.getRepository(Tool).merge(tool, updateTool) const result = await this.AppDataSource.getRepository(Tool).save(tool)
 return res.json(result) })
 // Delete tool this.app.delete('/api/v1/tools/:id', async (req: Request, res: Response) => { const results = await this.AppDataSource.getRepository(Tool).delete({ id: req.params.id }) return res.json(results) })
 // ---------------------------------------- // Assistant // ----------------------------------------
 // Get all assistants this.app.get('/api/v1/assistants', async (req: Request, res: Response) => { const assistants = await this.AppDataSource.getRepository(Assistant).find() return res.json(assistants) })
 // Get specific assistant this.app.get('/api/v1/assistants/:id', async (req: Request, res: Response) => { const assistant = await this.AppDataSource.getRepository(Assistant).findOneBy({ id: req.params.id }) return res.json(assistant) })
 // Get assistant object this.app.get('/api/v1/openai-assistants/:id', async (req: Request, res: Response) => { const credentialId = req.query.credential as string const credential = await this.AppDataSource.getRepository(Credential).findOneBy({ id: credentialId })
 if (!credential) return res.status(404).send(`Credential ${credentialId} not found`)
 // Decrpyt credentialData const decryptedCredentialData = await decryptCredentialData(credential.encryptedData) const openAIApiKey = decryptedCredentialData['openAIApiKey'] if (!openAIApiKey) return res.status(404).send(`OpenAI ApiKey not found`)
 const openai = new OpenAI({ apiKey: openAIApiKey }) const retrievedAssistant = await openai.beta.assistants.retrieve(req.params.id)
 if (retrievedAssistant.file\_ids && retrievedAssistant.file\_ids.length) { const files = [] for (const file\_id of retrievedAssistant.file\_ids) { const file = await openai.files.retrieve(file\_id) files.push(file) } ;(retrievedAssistant as any).files = files }
 return res.json(retrievedAssistant) })
 // List available assistants this.app.get('/api/v1/openai-assistants', async (req: Request, res: Response) => { const credentialId = req.query.credential as string const credential = await this.AppDataSource.getRepository(Credential).findOneBy({ id: credentialId })
 if (!credential) return res.status(404).send(`Credential ${credentialId} not found`)
 // Decrpyt credentialData const decryptedCredentialData = await decryptCredentialData(credential.encryptedData) const openAIApiKey = decryptedCredentialData['openAIApiKey'] if (!openAIApiKey) return res.status(404).send(`OpenAI ApiKey not found`)
 const openai = new OpenAI({ apiKey: openAIApiKey }) const retrievedAssistants = await openai.beta.assistants.list()
 return res.json(retrievedAssistants.data) })
 // Add assistant this.app.post('/api/v1/assistants', async (req: Request, res: Response) => { const body = req.body
 if (!body.details) return res.status(500).send(`Invalid request body`)
 const assistantDetails = JSON.parse(body.details)
 try { const credential = await this.AppDataSource.getRepository(Credential).findOneBy({ id: body.credential })
 if (!credential) return res.status(404).send(`Credential ${body.credential} not found`)
 // Decrpyt credentialData const decryptedCredentialData = await decryptCredentialData(credential.encryptedData) const openAIApiKey = decryptedCredentialData['openAIApiKey'] if (!openAIApiKey) return res.status(404).send(`OpenAI ApiKey not found`)
 const openai = new OpenAI({ apiKey: openAIApiKey })
 let tools = [] if (assistantDetails.tools) { for (const tool of assistantDetails.tools ?? []) { tools.push({ type: tool }) } }
 if (assistantDetails.uploadFiles) { // Base64 strings let files: string[] = [] const fileBase64 = assistantDetails.uploadFiles if (fileBase64.startsWith('[') && fileBase64.endsWith(']')) { files = JSON.parse(fileBase64) } else { files = [fileBase64] }
 const uploadedFiles = [] for (const file of files) { const splitDataURI = file.split(',') const filename = splitDataURI.pop()?.split(':')[1] ?? '' const bf = Buffer.from(splitDataURI.pop() || '', 'base64') const filePath = path.join(getUserHome(), '.flowise', 'openai-assistant', filename) if (!fs.existsSync(filePath)) fs.writeFileSync(filePath, bf)
 const createdFile = await openai.files.create({ file: fs.createReadStream(filePath), purpose: 'assistants' }) uploadedFiles.push(createdFile)
 fs.unlinkSync(filePath) } assistantDetails.files = [...assistantDetails.files, ...uploadedFiles] }
 if (!assistantDetails.id) { const newAssistant = await openai.beta.assistants.create({ name: assistantDetails.name, description: assistantDetails.description, instructions: assistantDetails.instructions, model: assistantDetails.model, tools, file\_ids: (assistantDetails.files ?? []).map((file: OpenAI.Files.FileObject) => file.id) }) assistantDetails.id = newAssistant.id } else { await openai.beta.assistants.update(assistantDetails.id, { name: assistantDetails.name, description: assistantDetails.description, instructions: assistantDetails.instructions, model: assistantDetails.model, tools, file\_ids: (assistantDetails.files ?? []).map((file: OpenAI.Files.FileObject) => file.id) }) }
 const newAssistantDetails = { ...assistantDetails } if (newAssistantDetails.uploadFiles) delete newAssistantDetails.uploadFiles
 body.details = JSON.stringify(newAssistantDetails) } catch (error) { return res.status(500).send(`Error creating new assistant: ${error}`) }
 const newAssistant = new Assistant() Object.assign(newAssistant, body)
 const assistant = this.AppDataSource.getRepository(Assistant).create(newAssistant) const results = await this.AppDataSource.getRepository(Assistant).save(assistant)
 return res.json(results) })
 // Update assistant this.app.put('/api/v1/assistants/:id', async (req: Request, res: Response) => { const assistant = await this.AppDataSource.getRepository(Assistant).findOneBy({ id: req.params.id })
 if (!assistant) { res.status(404).send(`Assistant ${req.params.id} not found`) return }
 try { const openAIAssistantId = JSON.parse(assistant.details)?.id
 const body = req.body const assistantDetails = JSON.parse(body.details)
 const credential = await this.AppDataSource.getRepository(Credential).findOneBy({ id: body.credential })
 if (!credential) return res.status(404).send(`Credential ${body.credential} not found`)
 // Decrpyt credentialData const decryptedCredentialData = await decryptCredentialData(credential.encryptedData) const openAIApiKey = decryptedCredentialData['openAIApiKey'] if (!openAIApiKey) return res.status(404).send(`OpenAI ApiKey not found`)
 const openai = new OpenAI({ apiKey: openAIApiKey })
 let tools = [] if (assistantDetails.tools) { for (const tool of assistantDetails.tools ?? []) { tools.push({ type: tool }) } }
 if (assistantDetails.uploadFiles) { // Base64 strings let files: string[] = [] const fileBase64 = assistantDetails.uploadFiles if (fileBase64.startsWith('[') && fileBase64.endsWith(']')) { files = JSON.parse(fileBase64) } else { files = [fileBase64] }
 const uploadedFiles = [] for (const file of files) { const splitDataURI = file.split(',') const filename = splitDataURI.pop()?.split(':')[1] ?? '' const bf = Buffer.from(splitDataURI.pop() || '', 'base64') const filePath = path.join(getUserHome(), '.flowise', 'openai-assistant', filename) if (!fs.existsSync(filePath)) fs.writeFileSync(filePath, bf)
 const createdFile = await openai.files.create({ file: fs.createReadStream(filePath), purpose: 'assistants' }) uploadedFiles.push(createdFile)
 fs.unlinkSync(filePath) } assistantDetails.files = [...assistantDetails.files, ...uploadedFiles] }
 await openai.beta.assistants.update(openAIAssistantId, { name: assistantDetails.name, description: assistantDetails.description, instructions: assistantDetails.instructions, model: assistantDetails.model, tools, file\_ids: (assistantDetails.files ?? []).map((file: OpenAI.Files.FileObject) => file.id) })
 const newAssistantDetails = { ...assistantDetails, id: openAIAssistantId } if (newAssistantDetails.uploadFiles) delete newAssistantDetails.uploadFiles
 const updateAssistant = new Assistant() body.details = JSON.stringify(newAssistantDetails) Object.assign(updateAssistant, body)
 this.AppDataSource.getRepository(Assistant).merge(assistant, updateAssistant) const result = await this.AppDataSource.getRepository(Assistant).save(assistant)
 return res.json(result) } catch (error) { return res.status(500).send(`Error updating assistant: ${error}`) } })
 // Delete assistant this.app.delete('/api/v1/assistants/:id', async (req: Request, res: Response) => { const assistant = await this.AppDataSource.getRepository(Assistant).findOneBy({ id: req.params.id })
 if (!assistant) { res.status(404).send(`Assistant ${req.params.id} not found`) return }
 try { const assistantDetails = JSON.parse(assistant.details)
 const credential = await this.AppDataSource.getRepository(Credential).findOneBy({ id: assistant.credential })
 if (!credential) return res.status(404).send(`Credential ${assistant.credential} not found`)
 // Decrpyt credentialData const decryptedCredentialData = await decryptCredentialData(credential.encryptedData) const openAIApiKey = decryptedCredentialData['openAIApiKey'] if (!openAIApiKey) return res.status(404).send(`OpenAI ApiKey not found`)
 const openai = new OpenAI({ apiKey: openAIApiKey })
 const results = await this.AppDataSource.getRepository(Assistant).delete({ id: req.params.id })
 await openai.beta.assistants.del(assistantDetails.id)
 return res.json(results) } catch (error: any) { if (error.status === 404 && error.type === 'invalid\_request\_error') return res.send('OK') return res.status(500).send(`Error deleting assistant: ${error}`) } })
 // ---------------------------------------- // Configuration // ----------------------------------------
 this.app.get('/api/v1/flow-config/:id', async (req: Request, res: Response) => { const chatflow = await this.AppDataSource.getRepository(ChatFlow).findOneBy({ id: req.params.id }) if (!chatflow) return res.status(404).send(`Chatflow ${req.params.id} not found`) const flowData = chatflow.flowData const parsedFlowData: IReactFlowObject = JSON.parse(flowData) const nodes = parsedFlowData.nodes const availableConfigs = findAvailableConfigs(nodes, this.nodesPool.componentCredentials) return res.json(availableConfigs) })
 this.app.post('/api/v1/node-config', async (req: Request, res: Response) => { const nodes = [{ data: req.body }] as IReactFlowNode[] const availableConfigs = findAvailableConfigs(nodes, this.nodesPool.componentCredentials) return res.json(availableConfigs) })
 this.app.get('/api/v1/version', async (req: Request, res: Response) => { const getPackageJsonPath = (): string => { const checkPaths = [ path.join(\_\_dirname, '..', 'package.json'), path.join(\_\_dirname, '..', '..', 'package.json'), path.join(\_\_dirname, '..', '..', '..', 'package.json'), path.join(\_\_dirname, '..', '..', '..', '..', 'package.json'), path.join(\_\_dirname, '..', '..', '..', '..', '..', 'package.json') ] for (const checkPath of checkPaths) { if (fs.existsSync(checkPath)) { return checkPath } } return '' }
 const packagejsonPath = getPackageJsonPath() if (!packagejsonPath) return res.status(404).send('Version not found') try { const content = await fs.promises.readFile(packagejsonPath, 'utf8') const parsedContent = JSON.parse(content) return res.json({ version: parsedContent.version }) } catch (error) { return res.status(500).send(`Version not found: ${error}`) } })
 // ---------------------------------------- // Export Load Chatflow & ChatMessage & Apikeys // ----------------------------------------
 this.app.get('/api/v1/database/export', async (req: Request, res: Response) => { const chatmessages = await this.AppDataSource.getRepository(ChatMessage).find() const chatflows = await this.AppDataSource.getRepository(ChatFlow).find() const apikeys = await getAPIKeys() const result: IDatabaseExport = { chatmessages, chatflows,[View remainder of file in raw view](https://github.com/FlowiseAI/Flowise/raw/refs/tags/flowise-ui%401.4.0/packages/server/src/index.ts)

## Footer

Â© 2025 GitHub,Â Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You canâ€™t perform that action at this time.


