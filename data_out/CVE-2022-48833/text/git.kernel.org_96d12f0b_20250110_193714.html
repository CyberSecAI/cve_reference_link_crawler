

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=44557a8f539a822c91238c1f95a95f98a5093d82)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=44557a8f539a822c91238c1f95a95f98a5093d82)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=44557a8f539a822c91238c1f95a95f98a5093d82)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=44557a8f539a822c91238c1f95a95f98a5093d82)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Filipe Manana <fdmanana@suse.com> | 2022-01-18 13:39:34 +0000 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2022-03-23 09:18:50 +0100 |
| commit | [44557a8f539a822c91238c1f95a95f98a5093d82](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=44557a8f539a822c91238c1f95a95f98a5093d82) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=44557a8f539a822c91238c1f95a95f98a5093d82)) | |
| tree | [2a948d590b56e8706766d65996605afdd98c40af](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=44557a8f539a822c91238c1f95a95f98a5093d82) | |
| parent | [b8c56b04ea24b1971abbd70ee769b9c1310bff3d](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b8c56b04ea24b1971abbd70ee769b9c1310bff3d) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=44557a8f539a822c91238c1f95a95f98a5093d82&id2=b8c56b04ea24b1971abbd70ee769b9c1310bff3d)) | |
| download | [linux-44557a8f539a822c91238c1f95a95f98a5093d82.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-44557a8f539a822c91238c1f95a95f98a5093d82.tar.gz) | |

btrfs: skip reserved bytes warning on unmount after log cleanup failurecommit 40cdc509877bacb438213b83c7541c5e24a1d9ec upstream.
After the recent changes made by commit c2e39305299f01 ("btrfs: clear
extent buffer uptodate when we fail to write it") and its followup fix,
commit 651740a5024117 ("btrfs: check WRITE\_ERR when trying to read an
extent buffer"), we can now end up not cleaning up space reservations of
log tree extent buffers after a transaction abort happens, as well as not
cleaning up still dirty extent buffers.
This happens because if writeback for a log tree extent buffer failed,
then we have cleared the bit EXTENT\_BUFFER\_UPTODATE from the extent buffer
and we have also set the bit EXTENT\_BUFFER\_WRITE\_ERR on it. Later on,
when trying to free the log tree with free\_log\_tree(), which iterates
over the tree, we can end up getting an -EIO error when trying to read
a node or a leaf, since read\_extent\_buffer\_pages() returns -EIO if an
extent buffer does not have EXTENT\_BUFFER\_UPTODATE set and has the
EXTENT\_BUFFER\_WRITE\_ERR bit set. Getting that -EIO means that we return
immediately as we can not iterate over the entire tree.
In that case we never update the reserved space for an extent buffer in
the respective block group and space\_info object.
When this happens we get the following traces when unmounting the fs:
[174957.284509] BTRFS: error (device dm-0) in cleanup\_transaction:1913: errno=-5 IO failure
[174957.286497] BTRFS: error (device dm-0) in free\_log\_tree:3420: errno=-5 IO failure
[174957.399379] ------------[ cut here ]------------
[174957.402497] WARNING: CPU: 2 PID: 3206883 at fs/btrfs/block-group.c:127 btrfs\_put\_block\_group+0x77/0xb0 [btrfs]
[174957.407523] Modules linked in: btrfs overlay dm\_zero (...)
[174957.424917] CPU: 2 PID: 3206883 Comm: umount Tainted: G W 5.16.0-rc5-btrfs-next-109 #1
[174957.426689] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04/01/2014
[174957.428716] RIP: 0010:btrfs\_put\_block\_group+0x77/0xb0 [btrfs]
[174957.429717] Code: 21 48 8b bd (...)
[174957.432867] RSP: 0018:ffffb70d41cffdd0 EFLAGS: 00010206
[174957.433632] RAX: 0000000000000001 RBX: ffff8b09c3848000 RCX: ffff8b0758edd1c8
[174957.434689] RDX: 0000000000000001 RSI: ffffffffc0b467e7 RDI: ffff8b0758edd000
[174957.436068] RBP: ffff8b0758edd000 R08: 0000000000000000 R09: 0000000000000000
[174957.437114] R10: 0000000000000246 R11: 0000000000000000 R12: ffff8b09c3848148
[174957.438140] R13: ffff8b09c3848198 R14: ffff8b0758edd188 R15: dead000000000100
[174957.439317] FS: 00007f328fb82800(0000) GS:ffff8b0a2d200000(0000) knlGS:0000000000000000
[174957.440402] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[174957.441164] CR2: 00007fff13563e98 CR3: 0000000404f4e005 CR4: 0000000000370ee0
[174957.442117] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[174957.443076] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
[174957.443948] Call Trace:
[174957.444264] <TASK>
[174957.444538] btrfs\_free\_block\_groups+0x255/0x3c0 [btrfs]
[174957.445238] close\_ctree+0x301/0x357 [btrfs]
[174957.445803] ? call\_rcu+0x16c/0x290
[174957.446250] generic\_shutdown\_super+0x74/0x120
[174957.446832] kill\_anon\_super+0x14/0x30
[174957.447305] btrfs\_kill\_super+0x12/0x20 [btrfs]
[174957.447890] deactivate\_locked\_super+0x31/0xa0
[174957.448440] cleanup\_mnt+0x147/0x1c0
[174957.448888] task\_work\_run+0x5c/0xa0
[174957.449336] exit\_to\_user\_mode\_prepare+0x1e5/0x1f0
[174957.449934] syscall\_exit\_to\_user\_mode+0x16/0x40
[174957.450512] do\_syscall\_64+0x48/0xc0
[174957.450980] entry\_SYSCALL\_64\_after\_hwframe+0x44/0xae
[174957.451605] RIP: 0033:0x7f328fdc4a97
[174957.452059] Code: 03 0c 00 f7 (...)
[174957.454320] RSP: 002b:00007fff13564ec8 EFLAGS: 00000246 ORIG\_RAX: 00000000000000a6
[174957.455262] RAX: 0000000000000000 RBX: 00007f328feea264 RCX: 00007f328fdc4a97
[174957.456131] RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000560b8ae51dd0
[174957.457118] RBP: 0000560b8ae51ba0 R08: 0000000000000000 R09: 00007fff13563c40
[174957.458005] R10: 00007f328fe49fc0 R11: 0000000000000246 R12: 0000000000000000
[174957.459113] R13: 0000560b8ae51dd0 R14: 0000560b8ae51cb0 R15: 0000000000000000
[174957.460193] </TASK>
[174957.460534] irq event stamp: 0
[174957.461003] hardirqs last enabled at (0): [<0000000000000000>] 0x0
[174957.461947] hardirqs last disabled at (0): [<ffffffffb0e94214>] copy\_process+0x934/0x2040
[174957.463147] softirqs last enabled at (0): [<ffffffffb0e94214>] copy\_process+0x934/0x2040
[174957.465116] softirqs last disabled at (0): [<0000000000000000>] 0x0
[174957.466323] ---[ end trace bc7ee0c490bce3af ]---
[174957.467282] ------------[ cut here ]------------
[174957.468184] WARNING: CPU: 2 PID: 3206883 at fs/btrfs/block-group.c:3976 btrfs\_free\_block\_groups+0x330/0x3c0 [btrfs]
[174957.470066] Modules linked in: btrfs overlay dm\_zero (...)
[174957.483137] CPU: 2 PID: 3206883 Comm: umount Tainted: G W 5.16.0-rc5-btrfs-next-109 #1
[174957.484691] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04/01/2014
[174957.486853] RIP: 0010:btrfs\_free\_block\_groups+0x330/0x3c0 [btrfs]
[174957.488050] Code: 00 00 00 ad de (...)
[174957.491479] RSP: 0018:ffffb70d41cffde0 EFLAGS: 00010206
[174957.492520] RAX: ffff8b08d79310b0 RBX: ffff8b09c3848000 RCX: 0000000000000000
[174957.493868] RDX: 0000000000000001 RSI: fffff443055ee600 RDI: ffffffffb1131846
[174957.495183] RBP: ffff8b08d79310b0 R08: 0000000000000000 R09: 0000000000000000
[174957.496580] R10: 0000000000000001 R11: 0000000000000000 R12: ffff8b08d7931000
[174957.498027] R13: ffff8b09c38492b0 R14: dead000000000122 R15: dead000000000100
[174957.499438] FS: 00007f328fb82800(0000) GS:ffff8b0a2d200000(0000) knlGS:0000000000000000
[174957.500990] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[174957.502117] CR2: 00007fff13563e98 CR3: 0000000404f4e005 CR4: 0000000000370ee0
[174957.503513] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[174957.504864] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
[174957.506167] Call Trace:
[174957.506654] <TASK>
[174957.507047] close\_ctree+0x301/0x357 [btrfs]
[174957.507867] ? call\_rcu+0x16c/0x290
[174957.508567] generic\_shutdown\_super+0x74/0x120
[174957.509447] kill\_anon\_super+0x14/0x30
[174957.510194] btrfs\_kill\_super+0x12/0x20 [btrfs]
[174957.511123] deactivate\_locked\_super+0x31/0xa0
[174957.511976] cleanup\_mnt+0x147/0x1c0
[174957.512610] task\_work\_run+0x5c/0xa0
[174957.513309] exit\_to\_user\_mode\_prepare+0x1e5/0x1f0
[174957.514231] syscall\_exit\_to\_user\_mode+0x16/0x40
[174957.515069] do\_syscall\_64+0x48/0xc0
[174957.515718] entry\_SYSCALL\_64\_after\_hwframe+0x44/0xae
[174957.516688] RIP: 0033:0x7f328fdc4a97
[174957.517413] Code: 03 0c 00 f7 d8 (...)
[174957.521052] RSP: 002b:00007fff13564ec8 EFLAGS: 00000246 ORIG\_RAX: 00000000000000a6
[174957.522514] RAX: 0000000000000000 RBX: 00007f328feea264 RCX: 00007f328fdc4a97
[174957.523950] RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000560b8ae51dd0
[174957.525375] RBP: 0000560b8ae51ba0 R08: 0000000000000000 R09: 00007fff13563c40
[174957.526763] R10: 00007f328fe49fc0 R11: 0000000000000246 R12: 0000000000000000
[174957.528058] R13: 0000560b8ae51dd0 R14: 0000560b8ae51cb0 R15: 0000000000000000
[174957.529404] </TASK>
[174957.529843] irq event stamp: 0
[174957.530256] hardirqs last enabled at (0): [<0000000000000000>] 0x0
[174957.531061] hardirqs last disabled at (0): [<ffffffffb0e94214>] copy\_process+0x934/0x2040
[174957.532075] softirqs last enabled at (0): [<ffffffffb0e94214>] copy\_process+0x934/0x2040
[174957.533083] softirqs last disabled at (0): [<0000000000000000>] 0x0
[174957.533865] ---[ end trace bc7ee0c490bce3b0 ]---
[174957.534452] BTRFS info (device dm-0): space\_info 4 has 1070841856 free, is not full
[174957.535404] BTRFS info (device dm-0): space\_info total=1073741824, used=2785280, pinned=0, reserved=49152, may\_use=0, readonly=65536 zone\_unusable=0
[174957.537029] BTRFS info (device dm-0): global\_block\_rsv: size 0 reserved 0
[174957.537859] BTRFS info (device dm-0): trans\_block\_rsv: size 0 reserved 0
[174957.538697] BTRFS info (device dm-0): chunk\_block\_rsv: size 0 reserved 0
[174957.539552] BTRFS info (device dm-0): delayed\_block\_rsv: size 0 reserved 0
[174957.540403] BTRFS info (device dm-0): delayed\_refs\_rsv: size 0 reserved 0
This also means that in case we have log tree extent buffers that are
still dirty, we can end up not cleaning them up in case we find an
extent buffer with EXTENT\_BUFFER\_WRITE\_ERR set on it, as in that case
we have no way for iterating over the rest of the tree.
This issue is very often triggered with test cases generic/475 and
generic/648 from fstests.
The issue could almost be fixed by iterating over the io tree attached to
each log root which keeps tracks of the range of allocated extent buffers,
log\_root->dirty\_log\_pages, however that does not work and has some
inconveniences:
1) After we sync the log, we clear the range of the extent buffers from
the io tree, so we can't find them after writeback. We could keep the
ranges in the io tree, with a separate bit to signal they represent
extent buffers already written, but that means we need to hold into
more memory until the transaction commits.
How much more memory is used depends a lot on whether we are able to
allocate contiguous extent buffers on disk (and how often) for a log
tree - if we are able to, then a single extent state record can
represent multiple extent buffers, otherwise we need multiple extent
state record structures to track each extent buffer.
In fact, my earlier approach did that:
https://lore.kernel.org/linux-btrfs/3aae7c6728257c7ce2279d6660ee2797e5e34bbd.1641300250.git.fdmanana@suse.com/
However that can cause a very significant negative impact on
performance, not only due to the extra memory usage but also because
we get a larger and deeper dirty\_log\_pages io tree.
We got a report that, on beefy machines at least, we can get such
performance drop with fsmark for example:
https://lore.kernel.org/linux-btrfs/20220117082426.GE32491@xsang-OptiPlex-9020/
2) We would be doing it only to deal with an unexpected and exceptional
case, which is basically failure to read an extent buffer from disk
due to IO failures. On a healthy system we don't expect transaction
aborts to happen after all;
3) Instead of relying on iterating the log tree or tracking the ranges
of extent buffers in the dirty\_log\_pages io tree, using the radix
tree that tracks extent buffers (fs\_info->buffer\_radix) to find all
log tree extent buffers is not reliable either, because after writeback
of an extent buffer it can be evicted from memory by the release page
callback of the btree inode (btree\_releasepage()).
Since there's no way to be able to properly cleanup a log tree without
being able to read its extent buffers from disk and without using more
memory to track the logical ranges of the allocated extent buffers do
the following:
1) When we fail to cleanup a log tree, setup a flag that indicates that
failure;
2) Trigger writeback of all log tree extent buffers that are still dirty,
and wait for the writeback to complete. This is just to cleanup their
state, page states, page leaks, etc;
3) When unmounting the fs, ignore if the number of bytes reserved in a
block group and in a space\_info is not 0 if, and only if, we failed to
cleanup a log tree. Also ignore only for metadata block groups and the
metadata space\_info object.
This is far from a perfect solution, but it serves to silence test
failures such as those from generic/475 and generic/648. However having
a non-zero value for the reserved bytes counters on unmount after a
transaction abort, is not such a terrible thing and it's completely
harmless, it does not affect the filesystem integrity in any way.
Signed-off-by: Filipe Manana <fdmanana@suse.com>
Signed-off-by: David Sterba <dsterba@suse.com>
Signed-off-by: Anand Jain <anand.jain@oracle.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=44557a8f539a822c91238c1f95a95f98a5093d82)

| -rw-r--r-- | [fs/btrfs/block-group.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/block-group.c?id=44557a8f539a822c91238c1f95a95f98a5093d82) | 26 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/btrfs/ctree.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/ctree.h?id=44557a8f539a822c91238c1f95a95f98a5093d82) | 7 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/tree-log.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/tree-log.c?id=44557a8f539a822c91238c1f95a95f98a5093d82) | 23 | |  |  |  | | --- | --- | --- | |

3 files changed, 54 insertions, 2 deletions

| diff --git a/fs/btrfs/block-group.c b/fs/btrfs/block-group.cindex c4c8db2ffa8437..05c606fb39685c 100644--- a/[fs/btrfs/block-group.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/block-group.c?id=b8c56b04ea24b1971abbd70ee769b9c1310bff3d)+++ b/[fs/btrfs/block-group.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/block-group.c?id=44557a8f539a822c91238c1f95a95f98a5093d82)@@ -124,7 +124,16 @@ void btrfs\_put\_block\_group(struct btrfs\_block\_group \*cache) { if (refcount\_dec\_and\_test(&cache->refs)) { WARN\_ON(cache->pinned > 0);- WARN\_ON(cache->reserved > 0);+ /\*+ \* If there was a failure to cleanup a log tree, very likely due+ \* to an IO failure on a writeback attempt of one or more of its+ \* extent buffers, we could not do proper (and cheap) unaccounting+ \* of their reserved space, so don't warn on reserved > 0 in that+ \* case.+ \*/+ if (!(cache->flags & BTRFS\_BLOCK\_GROUP\_METADATA) ||+ !BTRFS\_FS\_LOG\_CLEANUP\_ERROR(cache->fs\_info))+ WARN\_ON(cache->reserved > 0);  /\* \* A block\_group shouldn't be on the discard\_list anymore.@@ -3987,9 +3996,22 @@ int btrfs\_free\_block\_groups(struct btrfs\_fs\_info \*info) \* important and indicates a real bug if this happens. \*/ if (WARN\_ON(space\_info->bytes\_pinned > 0 ||- space\_info->bytes\_reserved > 0 || space\_info->bytes\_may\_use > 0)) btrfs\_dump\_space\_info(info, space\_info, 0, 0);++ /\*+ \* If there was a failure to cleanup a log tree, very likely due+ \* to an IO failure on a writeback attempt of one or more of its+ \* extent buffers, we could not do proper (and cheap) unaccounting+ \* of their reserved space, so don't warn on bytes\_reserved > 0 in+ \* that case.+ \*/+ if (!(space\_info->flags & BTRFS\_BLOCK\_GROUP\_METADATA) ||+ !BTRFS\_FS\_LOG\_CLEANUP\_ERROR(info)) {+ if (WARN\_ON(space\_info->bytes\_reserved > 0))+ btrfs\_dump\_space\_info(info, space\_info, 0, 0);+ }+ WARN\_ON(space\_info->reclaim\_size > 0); list\_del(&space\_info->list); btrfs\_sysfs\_remove\_space\_info(space\_info);diff --git a/fs/btrfs/ctree.h b/fs/btrfs/ctree.hindex b18939863c29c7..cd8e0f9ae82ca7 100644--- a/[fs/btrfs/ctree.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/ctree.h?id=b8c56b04ea24b1971abbd70ee769b9c1310bff3d)+++ b/[fs/btrfs/ctree.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/ctree.h?id=44557a8f539a822c91238c1f95a95f98a5093d82)@@ -143,6 +143,9 @@ enum { BTRFS\_FS\_STATE\_DEV\_REPLACING, /\* The btrfs\_fs\_info created for self-tests \*/ BTRFS\_FS\_STATE\_DUMMY\_FS\_INFO,++ /\* Indicates there was an error cleaning up a log tree. \*/+ BTRFS\_FS\_STATE\_LOG\_CLEANUP\_ERROR, };  #define BTRFS\_BACKREF\_REV\_MAX 256@@ -3585,6 +3588,10 @@ static inline void btrfs\_print\_v0\_err(struct btrfs\_fs\_info \*fs\_info) "Unsupported V0 extent filesystem detected. Aborting. Please re-create your filesystem with a newer kernel"); } +#define BTRFS\_FS\_LOG\_CLEANUP\_ERROR(fs\_info) \+ (unlikely(test\_bit(BTRFS\_FS\_STATE\_LOG\_CLEANUP\_ERROR, \+ &(fs\_info)->fs\_state)))+ \_\_printf(5, 6) \_\_cold void \_\_btrfs\_handle\_fs\_error(struct btrfs\_fs\_info \*fs\_info, const char \*function,diff --git a/fs/btrfs/tree-log.c b/fs/btrfs/tree-log.cindex f5371c4653cd67..90d5aa11e4178d 100644--- a/[fs/btrfs/tree-log.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/tree-log.c?id=b8c56b04ea24b1971abbd70ee769b9c1310bff3d)+++ b/[fs/btrfs/tree-log.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/tree-log.c?id=44557a8f539a822c91238c1f95a95f98a5093d82)@@ -3449,6 +3449,29 @@ static void free\_log\_tree(struct btrfs\_trans\_handle \*trans, if (log->node) { ret = walk\_log\_tree(trans, log, &wc); if (ret) {+ /\*+ \* We weren't able to traverse the entire log tree, the+ \* typical scenario is getting an -EIO when reading an+ \* extent buffer of the tree, due to a previous writeback+ \* failure of it.+ \*/+ set\_bit(BTRFS\_FS\_STATE\_LOG\_CLEANUP\_ERROR,+ &log->fs\_info->fs\_state);++ /\*+ \* Some extent buffers of the log tree may still be dirty+ \* and not yet written back to storage, because we may+ \* have updates to a log tree without syncing a log tree,+ \* such as during rename and link operations. So flush+ \* them out and wait for their writeback to complete, so+ \* that we properly cleanup their state and pages.+ \*/+ btrfs\_write\_marked\_extents(log->fs\_info,+ &log->dirty\_log\_pages,+ EXTENT\_DIRTY | EXTENT\_NEW);+ btrfs\_wait\_tree\_log\_extents(log,+ EXTENT\_DIRTY | EXTENT\_NEW);+ if (trans) btrfs\_abort\_transaction(trans, ret); else |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 19:35:51 +0000

