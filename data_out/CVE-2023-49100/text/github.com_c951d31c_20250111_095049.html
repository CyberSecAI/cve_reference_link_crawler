
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARM-software%2Farm-trusted-firmware%2Fblob%2Fa05414bedc9b1cc35cf0795ce641b6b4db5bc97e%2Fservices%2Fstd_svc%2Fsdei%2Fsdei_main.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARM-software%2Farm-trusted-firmware%2Fblob%2Fa05414bedc9b1cc35cf0795ce641b6b4db5bc97e%2Fservices%2Fstd_svc%2Fsdei%2Fsdei_main.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=ARM-software%2Farm-trusted-firmware)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[ARM-software](/ARM-software)
/
**[arm-trusted-firmware](/ARM-software/arm-trusted-firmware)**
Public

* [Notifications](/login?return_to=%2FARM-software%2Farm-trusted-firmware) You must be signed in to change notification settings
* [Fork
  1.4k](/login?return_to=%2FARM-software%2Farm-trusted-firmware)
* [Star
   2k](/login?return_to=%2FARM-software%2Farm-trusted-firmware)

* [Code](/ARM-software/arm-trusted-firmware)
* [Pull requests
  12](/ARM-software/arm-trusted-firmware/pulls)
* [Actions](/ARM-software/arm-trusted-firmware/actions)
* [Projects
  0](/ARM-software/arm-trusted-firmware/projects)
* [Wiki](/ARM-software/arm-trusted-firmware/wiki)
* [Security](/ARM-software/arm-trusted-firmware/security)
* [Insights](/ARM-software/arm-trusted-firmware/pulse)

Additional navigation options

* [Code](/ARM-software/arm-trusted-firmware)
* [Pull requests](/ARM-software/arm-trusted-firmware/pulls)
* [Actions](/ARM-software/arm-trusted-firmware/actions)
* [Projects](/ARM-software/arm-trusted-firmware/projects)
* [Wiki](/ARM-software/arm-trusted-firmware/wiki)
* [Security](/ARM-software/arm-trusted-firmware/security)
* [Insights](/ARM-software/arm-trusted-firmware/pulse)

## Files

 a05414b
## Breadcrumbs

1. [arm-trusted-firmware](/ARM-software/arm-trusted-firmware/tree/a05414bedc9b1cc35cf0795ce641b6b4db5bc97e)
2. /[services](/ARM-software/arm-trusted-firmware/tree/a05414bedc9b1cc35cf0795ce641b6b4db5bc97e/services)
3. /[std\_svc](/ARM-software/arm-trusted-firmware/tree/a05414bedc9b1cc35cf0795ce641b6b4db5bc97e/services/std_svc)
4. /[sdei](/ARM-software/arm-trusted-firmware/tree/a05414bedc9b1cc35cf0795ce641b6b4db5bc97e/services/std_svc/sdei)
/
# sdei\_main.c

Copy path Blame  Blame
## Latest commit

## History

[History](/ARM-software/arm-trusted-firmware/commits/a05414bedc9b1cc35cf0795ce641b6b4db5bc97e/services/std_svc/sdei/sdei_main.c)1114 lines (906 loc) · 25.9 KB a05414b
## Breadcrumbs

1. [arm-trusted-firmware](/ARM-software/arm-trusted-firmware/tree/a05414bedc9b1cc35cf0795ce641b6b4db5bc97e)
2. /[services](/ARM-software/arm-trusted-firmware/tree/a05414bedc9b1cc35cf0795ce641b6b4db5bc97e/services)
3. /[std\_svc](/ARM-software/arm-trusted-firmware/tree/a05414bedc9b1cc35cf0795ce641b6b4db5bc97e/services/std_svc)
4. /[sdei](/ARM-software/arm-trusted-firmware/tree/a05414bedc9b1cc35cf0795ce641b6b4db5bc97e/services/std_svc/sdei)
/
# sdei\_main.c

Top
## File metadata and controls

* Code
* Blame

1114 lines (906 loc) · 25.9 KB[Raw](https://github.com/ARM-software/arm-trusted-firmware/raw/a05414bedc9b1cc35cf0795ce641b6b4db5bc97e/services/std_svc/sdei/sdei_main.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\* \* Copyright (c) 2017-2020, ARM Limited and Contributors. All rights reserved. \* \* SPDX-License-Identifier: BSD-3-Clause \*/
#include <arch\_helpers.h>#include <assert.h>#include <inttypes.h>#include <stddef.h>#include <stdint.h>#include <string.h>
#include <bl31/bl31.h>#include <bl31/ehf.h>#include <bl31/interrupt\_mgmt.h>#include <common/bl\_common.h>#include <common/debug.h>#include <common/runtime\_svc.h>#include <context.h>#include <lib/cassert.h>#include <lib/el3\_runtime/pubsub.h>#include <lib/utils.h>#include <plat/common/platform.h>#include <services/sdei.h>
#include "sdei\_private.h"
#define MAJOR\_VERSION 1ULL#define MINOR\_VERSION 0ULL#define VENDOR\_VERSION 0ULL
#define MAKE\_SDEI\_VERSION(\_major, \_minor, \_vendor) \ ((((\_major)) << 48ULL) | (((\_minor)) << 32ULL) | (\_vendor))
#define LOWEST\_INTR\_PRIORITY 0xff
#define is\_valid\_affinity(\_mpidr) (plat\_core\_pos\_by\_mpidr(\_mpidr) >= 0)
CASSERT(PLAT\_SDEI\_CRITICAL\_PRI < PLAT\_SDEI\_NORMAL\_PRI, sdei\_critical\_must\_have\_higher\_priority);
static unsigned int num\_dyn\_priv\_slots, num\_dyn\_shrd\_slots;
/\* Initialise SDEI map entries \*/static void init\_map(sdei\_ev\_map\_t \*map){ map->reg\_count = 0;}
/\* Convert mapping to SDEI class \*/static sdei\_class\_t map\_to\_class(sdei\_ev\_map\_t \*map){ return is\_event\_critical(map) ? SDEI\_CRITICAL : SDEI\_NORMAL;}
/\* Clear SDEI event entries except state \*/static void clear\_event\_entries(sdei\_entry\_t \*se){ se->ep = 0; se->arg = 0; se->affinity = 0; se->reg\_flags = 0;}
/\* Perform CPU-specific state initialisation \*/static void \*sdei\_cpu\_on\_init(const void \*arg){ unsigned int i; sdei\_ev\_map\_t \*map; sdei\_entry\_t \*se;
 /\* Initialize private mappings on this CPU \*/ for\_each\_private\_map(i, map) { se = get\_event\_entry(map); clear\_event\_entries(se); se->state = 0; }
 SDEI\_LOG("Private events initialized on %lx\n", read\_mpidr\_el1());
 /\* All PEs start with SDEI events masked \*/ (void) sdei\_pe\_mask();
 return NULL;}
/\* CPU initialisation after wakeup from suspend \*/static void \*sdei\_cpu\_wakeup\_init(const void \*arg){ SDEI\_LOG("Events masked on %lx\n", read\_mpidr\_el1());
 /\* All PEs wake up with SDEI events masked \*/ sdei\_pe\_mask();
 return 0;}
/\* Initialise an SDEI class \*/static void sdei\_class\_init(sdei\_class\_t class){ unsigned int i; bool zero\_found \_\_unused = false; int ev\_num\_so\_far \_\_unused; sdei\_ev\_map\_t \*map;
 /\* Sanity check and configuration of shared events \*/ ev\_num\_so\_far = -1; for\_each\_shared\_map(i, map) {#if ENABLE\_ASSERTIONS /\* Ensure mappings are sorted \*/ assert((ev\_num\_so\_far < 0) || (map->ev\_num > ev\_num\_so\_far));
 ev\_num\_so\_far = map->ev\_num;
 /\* Event 0 must not be shared \*/ assert(map->ev\_num != SDEI\_EVENT\_0);
 /\* Check for valid event \*/ assert(map->ev\_num >= 0);
 /\* Make sure it's a shared event \*/ assert(is\_event\_shared(map));
 /\* No shared mapping should have signalable property \*/ assert(!is\_event\_signalable(map));
 /\* Shared mappings can't be explicit \*/ assert(!is\_map\_explicit(map));#endif
 /\* Skip initializing the wrong priority \*/ if (map\_to\_class(map) != class) continue;
 /\* Platform events are always bound, so set the bound flag \*/ if (is\_map\_dynamic(map)) { assert(map->intr == SDEI\_DYN\_IRQ); assert(is\_event\_normal(map)); num\_dyn\_shrd\_slots++; } else { /\* Shared mappings must be bound to shared interrupt \*/ assert(plat\_ic\_is\_spi(map->intr) != 0); set\_map\_bound(map); }
 init\_map(map); }
 /\* Sanity check and configuration of private events for this CPU \*/ ev\_num\_so\_far = -1; for\_each\_private\_map(i, map) {#if ENABLE\_ASSERTIONS /\* Ensure mappings are sorted \*/ assert((ev\_num\_so\_far < 0) || (map->ev\_num > ev\_num\_so\_far));
 ev\_num\_so\_far = map->ev\_num;
 if (map->ev\_num == SDEI\_EVENT\_0) { zero\_found = true;
 /\* Event 0 must be a Secure SGI \*/ assert(is\_secure\_sgi(map->intr));
 /\* \* Event 0 can have only have signalable flag (apart \* from being private \*/ assert(map->map\_flags == (SDEI\_MAPF\_SIGNALABLE | SDEI\_MAPF\_PRIVATE)); } else { /\* No other mapping should have signalable property \*/ assert(!is\_event\_signalable(map)); }
 /\* Check for valid event \*/ assert(map->ev\_num >= 0);
 /\* Make sure it's a private event \*/ assert(is\_event\_private(map));
 /\* \* Other than priority, explicit events can only have explicit \* and private flags set. \*/ if (is\_map\_explicit(map)) { assert((map->map\_flags | SDEI\_MAPF\_CRITICAL) == (SDEI\_MAPF\_EXPLICIT | SDEI\_MAPF\_PRIVATE | SDEI\_MAPF\_CRITICAL)); }#endif
 /\* Skip initializing the wrong priority \*/ if (map\_to\_class(map) != class) continue;
 /\* Platform events are always bound, so set the bound flag \*/ if (map->ev\_num != SDEI\_EVENT\_0) { if (is\_map\_dynamic(map)) { assert(map->intr == SDEI\_DYN\_IRQ); assert(is\_event\_normal(map)); num\_dyn\_priv\_slots++; } else if (is\_map\_explicit(map)) { /\* \* Explicit mappings don't have a backing \* SDEI interrupt, but verify that anyway. \*/ assert(map->intr == SDEI\_DYN\_IRQ); } else { /\* \* Private mappings must be bound to private \* interrupt. \*/ assert(plat\_ic\_is\_ppi((unsigned) map->intr) != 0); set\_map\_bound(map); } }
 init\_map(map); }
 /\* Ensure event 0 is in the mapping \*/ assert(zero\_found);
 (void) sdei\_cpu\_on\_init(NULL);}
/\* SDEI dispatcher initialisation \*/void sdei\_init(void){ plat\_sdei\_setup(); sdei\_class\_init(SDEI\_CRITICAL); sdei\_class\_init(SDEI\_NORMAL);
 /\* Register priority level handlers \*/ ehf\_register\_priority\_handler(PLAT\_SDEI\_CRITICAL\_PRI, sdei\_intr\_handler); ehf\_register\_priority\_handler(PLAT\_SDEI\_NORMAL\_PRI, sdei\_intr\_handler);}
/\* Populate SDEI event entry \*/static void set\_sdei\_entry(sdei\_entry\_t \*se, uint64\_t ep, uint64\_t arg, unsigned int flags, uint64\_t affinity){ assert(se != NULL);
 se->ep = ep; se->arg = arg; se->affinity = (affinity & MPIDR\_AFFINITY\_MASK); se->reg\_flags = flags;}
static uint64\_t sdei\_version(void){ return MAKE\_SDEI\_VERSION(MAJOR\_VERSION, MINOR\_VERSION, VENDOR\_VERSION);}
/\* Validate flags and MPIDR values for REGISTER and ROUTING\_SET calls \*/static int validate\_flags(uint64\_t flags, uint64\_t mpidr){ /\* Validate flags \*/ switch (flags) { case SDEI\_REGF\_RM\_PE: if (!is\_valid\_affinity(mpidr)) return SDEI\_EINVAL; break; case SDEI\_REGF\_RM\_ANY: break; default: /\* Unknown flags \*/ return SDEI\_EINVAL; }
 return 0;}
/\* Set routing of an SDEI event \*/static int sdei\_event\_routing\_set(int ev\_num, uint64\_t flags, uint64\_t mpidr){ int ret; unsigned int routing; sdei\_ev\_map\_t \*map; sdei\_entry\_t \*se;
 ret = validate\_flags(flags, mpidr); if (ret != 0) return ret;
 /\* Check if valid event number \*/ map = find\_event\_map(ev\_num); if (map == NULL) return SDEI\_EINVAL;
 /\* The event must not be private \*/ if (is\_event\_private(map)) return SDEI\_EINVAL;
 se = get\_event\_entry(map);
 sdei\_map\_lock(map);
 if (!is\_map\_bound(map) || is\_event\_private(map)) { ret = SDEI\_EINVAL; goto finish; }
 if (!can\_sdei\_state\_trans(se, DO\_ROUTING)) { ret = SDEI\_EDENY; goto finish; }
 /\* Choose appropriate routing \*/ routing = (unsigned int) ((flags == SDEI\_REGF\_RM\_ANY) ? INTR\_ROUTING\_MODE\_ANY : INTR\_ROUTING\_MODE\_PE);
 /\* Update event registration flag \*/ se->reg\_flags = (unsigned int) flags; if (flags == SDEI\_REGF\_RM\_PE) { se->affinity = (mpidr & MPIDR\_AFFINITY\_MASK); }
 /\* \* ROUTING\_SET is permissible only when event composite state is \* 'registered, disabled, and not running'. This means that the \* interrupt is currently disabled, and not active. \*/ plat\_ic\_set\_spi\_routing(map->intr, routing, (u\_register\_t) mpidr);
finish: sdei\_map\_unlock(map);
 return ret;}
/\* Register handler and argument for an SDEI event \*/static int64\_t sdei\_event\_register(int ev\_num, uint64\_t ep, uint64\_t arg, uint64\_t flags, uint64\_t mpidr){ int ret; unsigned int routing; sdei\_entry\_t \*se; sdei\_ev\_map\_t \*map; sdei\_state\_t backup\_state;
 if ((ep == 0U) || (plat\_sdei\_validate\_entry\_point( ep, sdei\_client\_el()) != 0)) { return SDEI\_EINVAL; }
 ret = validate\_flags(flags, mpidr); if (ret != 0) return ret;
 /\* Check if valid event number \*/ map = find\_event\_map(ev\_num); if (map == NULL) return SDEI\_EINVAL;
 /\* Private events always target the PE \*/ if (is\_event\_private(map)) { /\* \* SDEI internally handles private events in the same manner \* as public events with routing mode=RM\_PE, since the routing \* mode flag and affinity fields are not used when registering \* a private event, set them here. \*/ flags = SDEI\_REGF\_RM\_PE; /\* \* Kernel may pass 0 as mpidr, as we set flags to \* SDEI\_REGF\_RM\_PE, so set mpidr also. \*/ mpidr = read\_mpidr\_el1(); }
 se = get\_event\_entry(map);
 /\* \* Even though register operation is per-event (additionally for private \* events, registration is required individually), it has to be \* serialised with respect to bind/release, which are global operations. \* So we hold the lock throughout, unconditionally. \*/ sdei\_map\_lock(map);
 backup\_state = se->state; if (!can\_sdei\_state\_trans(se, DO\_REGISTER)) goto fallback;
 /\* \* When registering for dynamic events, make sure it's been bound \* already. This has to be the case as, without binding, the client \* can't know about the event number to register for. \*/ if (is\_map\_dynamic(map) && !is\_map\_bound(map)) goto fallback;
 if (is\_event\_private(map)) { /\* Multiple calls to register are possible for private events \*/ assert(map->reg\_count >= 0); } else { /\* Only single call to register is possible for shared events \*/ assert(map->reg\_count == 0); }
 if (is\_map\_bound(map)) { /\* Meanwhile, did any PE ACK the interrupt? \*/ if (plat\_ic\_get\_interrupt\_active(map->intr) != 0U) goto fallback;
 /\* The interrupt must currently owned by Non-secure \*/ if (plat\_ic\_get\_interrupt\_type(map->intr) != INTR\_TYPE\_NS) goto fallback;
 /\* \* Disable forwarding of new interrupt triggers to CPU \* interface. \*/ plat\_ic\_disable\_interrupt(map->intr);
 /\* \* Any events that are triggered after register and before \* enable should remain pending. Clear any previous interrupt \* triggers which are pending (except for SGIs). This has no \* affect on level-triggered interrupts. \*/ if (ev\_num != SDEI\_EVENT\_0) plat\_ic\_clear\_interrupt\_pending(map->intr);
 /\* Map interrupt to EL3 and program the correct priority \*/ plat\_ic\_set\_interrupt\_type(map->intr, INTR\_TYPE\_EL3);
 /\* Program the appropriate interrupt priority \*/ plat\_ic\_set\_interrupt\_priority(map->intr, sdei\_event\_priority(map));
 /\* \* Set the routing mode for shared event as requested. We \* already ensure that shared events get bound to SPIs. \*/ if (is\_event\_shared(map)) { routing = (unsigned int) ((flags == SDEI\_REGF\_RM\_ANY) ? INTR\_ROUTING\_MODE\_ANY : INTR\_ROUTING\_MODE\_PE); plat\_ic\_set\_spi\_routing(map->intr, routing, (u\_register\_t) mpidr); } }
 /\* Populate event entries \*/ set\_sdei\_entry(se, ep, arg, (unsigned int) flags, mpidr);
 /\* Increment register count \*/ map->reg\_count++;
 sdei\_map\_unlock(map);
 return 0;
fallback: /\* Reinstate previous state \*/ se->state = backup\_state;
 sdei\_map\_unlock(map);
 return SDEI\_EDENY;}
/\* Enable SDEI event \*/static int64\_t sdei\_event\_enable(int ev\_num){ sdei\_ev\_map\_t \*map; sdei\_entry\_t \*se; int ret; bool before, after;
 /\* Check if valid event number \*/ map = find\_event\_map(ev\_num); if (map == NULL) return SDEI\_EINVAL;
 se = get\_event\_entry(map); ret = SDEI\_EDENY;
 if (is\_event\_shared(map)) sdei\_map\_lock(map);
 before = GET\_EV\_STATE(se, ENABLED); if (!can\_sdei\_state\_trans(se, DO\_ENABLE)) goto finish; after = GET\_EV\_STATE(se, ENABLED);
 /\* \* Enable interrupt for bound events only if there's a change in enabled \* state. \*/ if (is\_map\_bound(map) && (!before && after)) plat\_ic\_enable\_interrupt(map->intr);
 ret = 0;
finish: if (is\_event\_shared(map)) sdei\_map\_unlock(map);
 return ret;}
/\* Disable SDEI event \*/static int sdei\_event\_disable(int ev\_num){ sdei\_ev\_map\_t \*map; sdei\_entry\_t \*se; int ret; bool before, after;
 /\* Check if valid event number \*/ map = find\_event\_map(ev\_num); if (map == NULL) return SDEI\_EINVAL;
 se = get\_event\_entry(map); ret = SDEI\_EDENY;
 if (is\_event\_shared(map)) sdei\_map\_lock(map);
 before = GET\_EV\_STATE(se, ENABLED); if (!can\_sdei\_state\_trans(se, DO\_DISABLE)) goto finish; after = GET\_EV\_STATE(se, ENABLED);
 /\* \* Disable interrupt for bound events only if there's a change in \* enabled state. \*/ if (is\_map\_bound(map) && (before && !after)) plat\_ic\_disable\_interrupt(map->intr);
 ret = 0;
finish: if (is\_event\_shared(map)) sdei\_map\_unlock(map);
 return ret;}
/\* Query SDEI event information \*/static int64\_t sdei\_event\_get\_info(int ev\_num, int info){ sdei\_entry\_t \*se; sdei\_ev\_map\_t \*map;
 uint64\_t flags; bool registered; uint64\_t affinity;
 /\* Check if valid event number \*/ map = find\_event\_map(ev\_num); if (map == NULL) return SDEI\_EINVAL;
 se = get\_event\_entry(map);
 if (is\_event\_shared(map)) sdei\_map\_lock(map);
 /\* Sample state under lock \*/ registered = GET\_EV\_STATE(se, REGISTERED); flags = se->reg\_flags; affinity = se->affinity;
 if (is\_event\_shared(map)) sdei\_map\_unlock(map);
 switch (info) { case SDEI\_INFO\_EV\_TYPE: return is\_event\_shared(map);
 case SDEI\_INFO\_EV\_NOT\_SIGNALED: return !is\_event\_signalable(map);
 case SDEI\_INFO\_EV\_PRIORITY: return is\_event\_critical(map);
 case SDEI\_INFO\_EV\_ROUTING\_MODE: if (!is\_event\_shared(map)) return SDEI\_EINVAL; if (!registered) return SDEI\_EDENY; return (flags == SDEI\_REGF\_RM\_PE);
 case SDEI\_INFO\_EV\_ROUTING\_AFF: if (!is\_event\_shared(map)) return SDEI\_EINVAL; if (!registered) return SDEI\_EDENY; if (flags != SDEI\_REGF\_RM\_PE) return SDEI\_EINVAL; return affinity;
 default: return SDEI\_EINVAL; }}
/\* Unregister an SDEI event \*/static int sdei\_event\_unregister(int ev\_num){ int ret = 0; sdei\_entry\_t \*se; sdei\_ev\_map\_t \*map;
 /\* Check if valid event number \*/ map = find\_event\_map(ev\_num); if (map == NULL) return SDEI\_EINVAL;
 se = get\_event\_entry(map);
 /\* \* Even though unregister operation is per-event (additionally for \* private events, unregistration is required individually), it has to \* be serialised with respect to bind/release, which are global \* operations. So we hold the lock throughout, unconditionally. \*/ sdei\_map\_lock(map);
 if (!can\_sdei\_state\_trans(se, DO\_UNREGISTER)) { /\* \* Even if the call is invalid, and the handler is running (for \* example, having unregistered from a running handler earlier), \* return pending error code; otherwise, return deny. \*/ ret = GET\_EV\_STATE(se, RUNNING) ? SDEI\_EPEND : SDEI\_EDENY;
 goto finish; }
 map->reg\_count--; if (is\_event\_private(map)) { /\* Multiple calls to register are possible for private events \*/ assert(map->reg\_count >= 0); } else { /\* Only single call to register is possible for shared events \*/ assert(map->reg\_count == 0); }
 if (is\_map\_bound(map)) { plat\_ic\_disable\_interrupt(map->intr);
 /\* \* Clear pending interrupt. Skip for SGIs as they may not be \* cleared on interrupt controllers. \*/ if (ev\_num != SDEI\_EVENT\_0) plat\_ic\_clear\_interrupt\_pending(map->intr);
 assert(plat\_ic\_get\_interrupt\_type(map->intr) == INTR\_TYPE\_EL3); plat\_ic\_set\_interrupt\_type(map->intr, INTR\_TYPE\_NS); plat\_ic\_set\_interrupt\_priority(map->intr, LOWEST\_INTR\_PRIORITY); }
 clear\_event\_entries(se);
 /\* \* If the handler is running at the time of unregister, return the \* pending error code. \*/ if (GET\_EV\_STATE(se, RUNNING)) ret = SDEI\_EPEND;
finish: sdei\_map\_unlock(map);
 return ret;}
/\* Query status of an SDEI event \*/static int sdei\_event\_status(int ev\_num){ sdei\_ev\_map\_t \*map; sdei\_entry\_t \*se; sdei\_state\_t state;
 /\* Check if valid event number \*/ map = find\_event\_map(ev\_num); if (map == NULL) return SDEI\_EINVAL;
 se = get\_event\_entry(map);
 if (is\_event\_shared(map)) sdei\_map\_lock(map);
 /\* State value directly maps to the expected return format \*/ state = se->state;
 if (is\_event\_shared(map)) sdei\_map\_unlock(map);
 return (int) state;}
/\* Bind an SDEI event to an interrupt \*/static int sdei\_interrupt\_bind(unsigned int intr\_num){ sdei\_ev\_map\_t \*map; bool retry = true, shared\_mapping;
 /\* SGIs are not allowed to be bound \*/ if (plat\_ic\_is\_sgi(intr\_num) != 0) return SDEI\_EINVAL;
 shared\_mapping = (plat\_ic\_is\_spi(intr\_num) != 0); do { /\* \* Bail out if there is already an event for this interrupt, \* either platform-defined or dynamic. \*/ map = find\_event\_map\_by\_intr(intr\_num, shared\_mapping); if (map != NULL) { if (is\_map\_dynamic(map)) { if (is\_map\_bound(map)) { /\* \* Dynamic event, already bound. Return \* event number. \*/ return map->ev\_num; } } else { /\* Binding non-dynamic event \*/ return SDEI\_EINVAL; } }
 /\* \* The interrupt is not bound yet. Try to find a free slot to \* bind it. Free dynamic mappings have their interrupt set as \* SDEI\_DYN\_IRQ. \*/ map = find\_event\_map\_by\_intr(SDEI\_DYN\_IRQ, shared\_mapping); if (map == NULL) return SDEI\_ENOMEM;
 /\* The returned mapping must be dynamic \*/ assert(is\_map\_dynamic(map));
 /\* \* We cannot assert for bound maps here, as we might be racing \* with another bind. \*/
 /\* The requested interrupt must already belong to NS \*/ if (plat\_ic\_get\_interrupt\_type(intr\_num) != INTR\_TYPE\_NS) return SDEI\_EDENY;
 /\* \* Interrupt programming and ownership transfer are deferred \* until register. \*/
 sdei\_map\_lock(map); if (!is\_map\_bound(map)) { map->intr = intr\_num; set\_map\_bound(map); retry = false; } sdei\_map\_unlock(map); } while (retry);
 return map->ev\_num;}
/\* Release a bound SDEI event previously to an interrupt \*/static int sdei\_interrupt\_release(int ev\_num){ int ret = 0; sdei\_ev\_map\_t \*map; sdei\_entry\_t \*se;
 /\* Check if valid event number \*/ map = find\_event\_map(ev\_num); if (map == NULL) return SDEI\_EINVAL;
 if (!is\_map\_dynamic(map)) return SDEI\_EINVAL;
 se = get\_event\_entry(map);
 sdei\_map\_lock(map);
 /\* Event must have been unregistered before release \*/ if (map->reg\_count != 0) { ret = SDEI\_EDENY; goto finish; }
 /\* \* Interrupt release never causes the state to change. We only check \* whether it's permissible or not. \*/ if (!can\_sdei\_state\_trans(se, DO\_RELEASE)) { ret = SDEI\_EDENY; goto finish; }
 if (is\_map\_bound(map)) { /\* \* Deny release if the interrupt is active, which means it's \* probably being acknowledged and handled elsewhere. \*/ if (plat\_ic\_get\_interrupt\_active(map->intr) != 0U) { ret = SDEI\_EDENY; goto finish; }
 /\* \* Interrupt programming and ownership transfer are already done \* during unregister. \*/
 map->intr = SDEI\_DYN\_IRQ; clr\_map\_bound(map); } else { SDEI\_LOG("Error release bound:%d cnt:%d\n", is\_map\_bound(map), map->reg\_count); ret = SDEI\_EINVAL; }
finish: sdei\_map\_unlock(map);
 return ret;}
/\* Perform reset of private SDEI events \*/static int sdei\_private\_reset(void){ sdei\_ev\_map\_t \*map; int ret = 0, final\_ret = 0; unsigned int i;
 /\* Unregister all private events \*/ for\_each\_private\_map(i, map) { /\* \* The unregister can fail if the event is not registered, which \* is allowed, and a deny will be returned. But if the event is \* running or unregister pending, the call fails. \*/ ret = sdei\_event\_unregister(map->ev\_num); if ((ret == SDEI\_EPEND) && (final\_ret == 0)) final\_ret = SDEI\_EDENY; }
 return final\_ret;}
/\* Perform reset of shared SDEI events \*/static int sdei\_shared\_reset(void){ const sdei\_mapping\_t \*mapping; sdei\_ev\_map\_t \*map; int ret = 0, final\_ret = 0; unsigned int i, j;
 /\* Unregister all shared events \*/ for\_each\_shared\_map(i, map) { /\* \* The unregister can fail if the event is not registered, which \* is allowed, and a deny will be returned. But if the event is \* running or unregister pending, the call fails. \*/ ret = sdei\_event\_unregister(map->ev\_num); if ((ret == SDEI\_EPEND) && (final\_ret == 0)) final\_ret = SDEI\_EDENY; }
 if (final\_ret != 0) return final\_ret;
 /\* \* Loop through both private and shared mappings, and release all \* bindings. \*/ for\_each\_mapping\_type(i, mapping) { iterate\_mapping(mapping, j, map) { /\* \* Release bindings for mappings that are dynamic and \* bound. \*/ if (is\_map\_dynamic(map) && is\_map\_bound(map)) { /\* \* Any failure to release would mean there is at \* least a PE registered for the event. \*/ ret = sdei\_interrupt\_release(map->ev\_num); if ((ret != 0) && (final\_ret == 0)) final\_ret = ret; } } }
 return final\_ret;}
/\* Send a signal to another SDEI client PE \*/static int sdei\_signal(int ev\_num, uint64\_t target\_pe){ sdei\_ev\_map\_t \*map;
 /\* Only event 0 can be signalled \*/ if (ev\_num != SDEI\_EVENT\_0) return SDEI\_EINVAL;
 /\* Find mapping for event 0 \*/ map = find\_event\_map(SDEI\_EVENT\_0); if (map == NULL) return SDEI\_EINVAL;
 /\* The event must be signalable \*/ if (!is\_event\_signalable(map)) return SDEI\_EINVAL;
 /\* Validate target \*/ if (plat\_core\_pos\_by\_mpidr(target\_pe) < 0) return SDEI\_EINVAL;
 /\* Raise SGI. Platform will validate target\_pe \*/ plat\_ic\_raise\_el3\_sgi((int) map->intr, (u\_register\_t) target\_pe);
 return 0;}
/\* Query SDEI dispatcher features \*/static uint64\_t sdei\_features(unsigned int feature){ if (feature == SDEI\_FEATURE\_BIND\_SLOTS) { return FEATURE\_BIND\_SLOTS(num\_dyn\_priv\_slots, num\_dyn\_shrd\_slots); }
 return (uint64\_t) SDEI\_EINVAL;}
/\* SDEI top level handler for servicing SMCs \*/uint64\_t sdei\_smc\_handler(uint32\_t smc\_fid, uint64\_t x1, uint64\_t x2, uint64\_t x3, uint64\_t x4, void \*cookie, void \*handle, uint64\_t flags){
 uint64\_t x5; unsigned int ss = (unsigned int) get\_interrupt\_src\_ss(flags); int64\_t ret; bool resume = false; cpu\_context\_t \*ctx = handle; int ev\_num = (int) x1;
 if (ss != NON\_SECURE) SMC\_RET1(ctx, SMC\_UNK);
 /\* Verify the caller EL \*/ if (GET\_EL(read\_spsr\_el3()) != sdei\_client\_el()) SMC\_RET1(ctx, SMC\_UNK);
 switch (smc\_fid) { case SDEI\_VERSION: SDEI\_LOG("> VER\n"); ret = (int64\_t) sdei\_version(); SDEI\_LOG("< VER:%" PRIx64 "\n", ret); SMC\_RET1(ctx, ret);
 case SDEI\_EVENT\_REGISTER: x5 = SMC\_GET\_GP(ctx, CTX\_GPREG\_X5); SDEI\_LOG("> REG(n:%d e:%" PRIx64 " a:%" PRIx64 " f:%x m:%" PRIx64 "\n", ev\_num, x2, x3, (int) x4, x5); ret = sdei\_event\_register(ev\_num, x2, x3, x4, x5); SDEI\_LOG("< REG:%" PRId64 "\n", ret); SMC\_RET1(ctx, ret);
 case SDEI\_EVENT\_ENABLE: SDEI\_LOG("> ENABLE(n:%d)\n", (int) x1); ret = sdei\_event\_enable(ev\_num); SDEI\_LOG("< ENABLE:%" PRId64 "\n", ret); SMC\_RET1(ctx, ret);
 case SDEI\_EVENT\_DISABLE: SDEI\_LOG("> DISABLE(n:0x%x)\n", ev\_num); ret = sdei\_event\_disable(ev\_num); SDEI\_LOG("< DISABLE:%" PRId64 "\n", ret); SMC\_RET1(ctx, ret);
[View remainder of file in raw view](https://github.com/ARM-software/arm-trusted-firmware/raw/a05414bedc9b1cc35cf0795ce641b6b4db5bc97e/services/std_svc/sdei/sdei_main.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

