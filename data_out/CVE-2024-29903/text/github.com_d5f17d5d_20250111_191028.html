
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fsigstore%2Fcosign%2Fblob%2F14795db16417579fac0c00c11e166868d7976b61%2Fpkg%2Fcosign%2Fverify.go)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fsigstore%2Fcosign%2Fblob%2F14795db16417579fac0c00c11e166868d7976b61%2Fpkg%2Fcosign%2Fverify.go)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=sigstore%2Fcosign)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[sigstore](/sigstore)
/
**[cosign](/sigstore/cosign)**
Public

* [Notifications](/login?return_to=%2Fsigstore%2Fcosign) You must be signed in to change notification settings
* [Fork
  552](/login?return_to=%2Fsigstore%2Fcosign)
* [Star
   4.6k](/login?return_to=%2Fsigstore%2Fcosign)

* [Code](/sigstore/cosign)
* [Issues
  233](/sigstore/cosign/issues)
* [Pull requests
  16](/sigstore/cosign/pulls)
* [Discussions](/sigstore/cosign/discussions)
* [Actions](/sigstore/cosign/actions)
* [Projects
  0](/sigstore/cosign/projects)
* [Security](/sigstore/cosign/security)
* [Insights](/sigstore/cosign/pulse)

Additional navigation options

* [Code](/sigstore/cosign)
* [Issues](/sigstore/cosign/issues)
* [Pull requests](/sigstore/cosign/pulls)
* [Discussions](/sigstore/cosign/discussions)
* [Actions](/sigstore/cosign/actions)
* [Projects](/sigstore/cosign/projects)
* [Security](/sigstore/cosign/security)
* [Insights](/sigstore/cosign/pulse)

## Files

 14795db
## Breadcrumbs

1. [cosign](/sigstore/cosign/tree/14795db16417579fac0c00c11e166868d7976b61)
2. /[pkg](/sigstore/cosign/tree/14795db16417579fac0c00c11e166868d7976b61/pkg)
3. /[cosign](/sigstore/cosign/tree/14795db16417579fac0c00c11e166868d7976b61/pkg/cosign)
/
# verify.go

Copy path Blame  Blame
## Latest commit

## History

[History](/sigstore/cosign/commits/14795db16417579fac0c00c11e166868d7976b61/pkg/cosign/verify.go)1402 lines (1254 loc) · 44.3 KB 14795db
## Breadcrumbs

1. [cosign](/sigstore/cosign/tree/14795db16417579fac0c00c11e166868d7976b61)
2. /[pkg](/sigstore/cosign/tree/14795db16417579fac0c00c11e166868d7976b61/pkg)
3. /[cosign](/sigstore/cosign/tree/14795db16417579fac0c00c11e166868d7976b61/pkg/cosign)
/
# verify.go

Top
## File metadata and controls

* Code
* Blame

1402 lines (1254 loc) · 44.3 KB[Raw](https://github.com/sigstore/cosign/raw/14795db16417579fac0c00c11e166868d7976b61/pkg/cosign/verify.go)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000// Copyright 2021 The Sigstore Authors.//// Licensed under the Apache License, Version 2.0 (the "License");// you may not use this file except in compliance with the License.// You may obtain a copy of the License at//// http://www.apache.org/licenses/LICENSE-2.0//// Unless required by applicable law or agreed to in writing, software// distributed under the License is distributed on an "AS IS" BASIS,// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.// See the License for the specific language governing permissions and// limitations under the License.
package cosign
import ( "bytes" "context" "crypto" "crypto/ecdsa" "crypto/sha256" "crypto/x509" "encoding/asn1" "encoding/base64" "encoding/hex" "encoding/json" "encoding/pem" "fmt" "net/http" "os" "regexp" "strings" "time"
 "github.com/pkg/errors"
 "github.com/digitorus/timestamp" "github.com/go-openapi/runtime" "github.com/nozzle/throttler"
 "github.com/sigstore/cosign/v2/internal/pkg/cosign" "github.com/sigstore/cosign/v2/pkg/blob" cbundle "github.com/sigstore/cosign/v2/pkg/cosign/bundle" "github.com/sigstore/cosign/v2/pkg/oci/static" "github.com/sigstore/cosign/v2/pkg/types"
 "github.com/cyberphone/json-canonicalization/go/src/webpki.org/jsoncanonicalizer" "github.com/google/go-containerregistry/pkg/name" v1 "github.com/google/go-containerregistry/pkg/v1" "github.com/google/go-containerregistry/pkg/v1/remote/transport"
 ssldsse "github.com/secure-systems-lab/go-securesystemslib/dsse" ociexperimental "github.com/sigstore/cosign/v2/internal/pkg/oci/remote" "github.com/sigstore/cosign/v2/internal/ui" "github.com/sigstore/cosign/v2/pkg/oci" "github.com/sigstore/cosign/v2/pkg/oci/layout" ociremote "github.com/sigstore/cosign/v2/pkg/oci/remote" "github.com/sigstore/rekor/pkg/generated/client" "github.com/sigstore/rekor/pkg/generated/models" rekor\_types "github.com/sigstore/rekor/pkg/types" dsse\_v001 "github.com/sigstore/rekor/pkg/types/dsse/v0.0.1" hashedrekord\_v001 "github.com/sigstore/rekor/pkg/types/hashedrekord/v0.0.1" intoto\_v001 "github.com/sigstore/rekor/pkg/types/intoto/v0.0.1" intoto\_v002 "github.com/sigstore/rekor/pkg/types/intoto/v0.0.2" rekord\_v001 "github.com/sigstore/rekor/pkg/types/rekord/v0.0.1" "github.com/sigstore/sigstore/pkg/cryptoutils" "github.com/sigstore/sigstore/pkg/signature" "github.com/sigstore/sigstore/pkg/signature/dsse" "github.com/sigstore/sigstore/pkg/signature/options" "github.com/sigstore/sigstore/pkg/tuf" tsaverification "github.com/sigstore/timestamp-authority/pkg/verification")
// Identity specifies an issuer/subject to verify a signature against.// Both IssuerRegExp/SubjectRegExp support regexp while Issuer/Subject are for// strict matching.type Identity struct { Issuer string Subject string IssuerRegExp string SubjectRegExp string}
// CheckOpts are the options for checking signatures.type CheckOpts struct { // RegistryClientOpts are the options for interacting with the container registry. RegistryClientOpts []ociremote.Option
 // Annotations optionally specifies image signature annotations to verify. Annotations map[string]interface{}
 // ClaimVerifier, if provided, verifies claims present in the oci.Signature. ClaimVerifier func(sig oci.Signature, imageDigest v1.Hash, annotations map[string]interface{}) error
 // RekorClient, if set, is used to make online tlog calls use to verify signatures and public keys. RekorClient \*client.Rekor // RekorPubKeys, if set, is used to validate signatures on log entries from // Rekor. It is a map from LogID to crypto.PublicKey. LogID is // derived from the PublicKey (see RFC 6962 S3.2). // Note that even though the type is of crypto.PublicKey, Rekor only allows // for ecdsa.PublicKey: https://github.com/sigstore/cosign/issues/2540 RekorPubKeys \*TrustedTransparencyLogPubKeys
 // SigVerifier is used to verify signatures. SigVerifier signature.Verifier // PKOpts are the options provided to `SigVerifier.PublicKey()`. PKOpts []signature.PublicKeyOption
 // RootCerts are the root CA certs used to verify a signature's chained certificate. RootCerts \*x509.CertPool // IntermediateCerts are the optional intermediate CA certs used to verify a certificate chain. IntermediateCerts \*x509.CertPool
 // CertGithubWorkflowTrigger is the GitHub Workflow Trigger name expected for a certificate to be valid. The empty string means any certificate can be valid. CertGithubWorkflowTrigger string // CertGithubWorkflowSha is the GitHub Workflow SHA expected for a certificate to be valid. The empty string means any certificate can be valid. CertGithubWorkflowSha string // CertGithubWorkflowName is the GitHub Workflow Name expected for a certificate to be valid. The empty string means any certificate can be valid. CertGithubWorkflowName string // CertGithubWorkflowRepository is the GitHub Workflow Repository expected for a certificate to be valid. The empty string means any certificate can be valid. CertGithubWorkflowRepository string // CertGithubWorkflowRef is the GitHub Workflow Ref expected for a certificate to be valid. The empty string means any certificate can be valid. CertGithubWorkflowRef string
 // IgnoreSCT requires that a certificate contain an embedded SCT during verification. An SCT is proof of inclusion in a // certificate transparency log. IgnoreSCT bool // Detached SCT. Optional, as the SCT is usually embedded in the certificate. SCT []byte // CTLogPubKeys, if set, is used to validate SCTs against those keys. // It is a map from log id to LogIDMetadata. It is a map from LogID to crypto.PublicKey. LogID is derived from the PublicKey (see RFC 6962 S3.2). CTLogPubKeys \*TrustedTransparencyLogPubKeys
 // SignatureRef is the reference to the signature file. PayloadRef should always be specified as well (though it’s possible for a \_some\_ signatures to be verified without it, with a warning). SignatureRef string // PayloadRef is a reference to the payload file. Applicable only if SignatureRef is set. PayloadRef string
 // Identities is an array of Identity (Subject, Issuer) matchers that have // to be met for the signature to ve valid. Identities []Identity
 // Force offline verification of the signature Offline bool
 // Set of flags to verify an RFC3161 timestamp used for trusted timestamping // TSACertificate is the certificate used to sign the timestamp. Optional, if provided in the timestamp TSACertificate \*x509.Certificate // TSARootCertificates are the set of roots to verify the TSA certificate TSARootCertificates []\*x509.Certificate // TSAIntermediateCertificates are the set of intermediates for chain building TSAIntermediateCertificates []\*x509.Certificate
 // IgnoreTlog skip tlog verification IgnoreTlog bool
 // The amount of maximum workers for parallel executions. // Defaults to 10. MaxWorkers int
 // Should the experimental OCI 1.1 behaviour be enabled or not. // Defaults to false. ExperimentalOCI11 bool}
// This is a substitutable signature verification function that can be used for verifying// attestations of blobs.type signatureVerificationFn func( ctx context.Context, verifier signature.Verifier, sig payloader) error
// For unit testingtype payloader interface { // no-op for attestations Base64Signature() (string, error) Payload() ([]byte, error)}
func verifyOCIAttestation(ctx context.Context, verifier signature.Verifier, att payloader) error { payload, err := att.Payload() if err != nil { return err }
 env := ssldsse.Envelope{} if err := json.Unmarshal(payload, &env); err != nil { return err }
 if env.PayloadType != types.IntotoPayloadType { return &VerificationFailure{ fmt.Errorf("invalid payloadType %s on envelope. Expected %s", env.PayloadType, types.IntotoPayloadType), } } dssev, err := ssldsse.NewEnvelopeVerifier(&dsse.VerifierAdapter{SignatureVerifier: verifier}) if err != nil { return err } \_, err = dssev.Verify(ctx, &env) return err}
func verifyOCISignature(ctx context.Context, verifier signature.Verifier, sig payloader) error { b64sig, err := sig.Base64Signature() if err != nil { return err } signature, err := base64.StdEncoding.DecodeString(b64sig) if err != nil { return err } payload, err := sig.Payload() if err != nil { return err } return verifier.VerifySignature(bytes.NewReader(signature), bytes.NewReader(payload), options.WithContext(ctx))}
// ValidateAndUnpackCert creates a Verifier from a certificate. Veries that the certificate// chains up to a trusted root. Optionally verifies the subject and issuer of the certificate.func ValidateAndUnpackCert(cert \*x509.Certificate, co \*CheckOpts) (signature.Verifier, error) { verifier, err := signature.LoadVerifier(cert.PublicKey, crypto.SHA256) if err != nil { return nil, fmt.Errorf("invalid certificate found on signature: %w", err) }
 // Handle certificates where the Subject Alternative Name is not set to a supported // GeneralName (RFC 5280 4.2.1.6). Go only supports DNS, IP addresses, email addresses, // or URIs as SANs. Fulcio can issue a certificate with an OtherName GeneralName, so // remove the unhandled critical SAN extension before verifying. if len(cert.UnhandledCriticalExtensions) > 0 { var unhandledExts []asn1.ObjectIdentifier for \_, oid := range cert.UnhandledCriticalExtensions { if !oid.Equal(cryptoutils.SANOID) { unhandledExts = append(unhandledExts, oid) } } cert.UnhandledCriticalExtensions = unhandledExts }
 // Now verify the cert, then the signature. chains, err := TrustedCert(cert, co.RootCerts, co.IntermediateCerts) if err != nil { return nil, err }
 err = CheckCertificatePolicy(cert, co) if err != nil { return nil, err }
 // If IgnoreSCT is set, skip the SCT check if co.IgnoreSCT { return verifier, nil } contains, err := ContainsSCT(cert.Raw) if err != nil { return nil, err } if !contains && len(co.SCT) == 0 { return nil, &VerificationFailure{ fmt.Errorf("certificate does not include required embedded SCT and no detached SCT was set"), } } // handle if chains has more than one chain - grab first and print message if len(chains) > 1 { fmt.Fprintf(os.Stderr, "\*\*Info\*\* Multiple valid certificate chains found. Selecting the first to verify the SCT.\n") } if contains { if err := VerifyEmbeddedSCT(context.Background(), chains[0], co.CTLogPubKeys); err != nil { return nil, err } } else { chain := chains[0] if len(chain) < 2 { return nil, errors.New("certificate chain must contain at least a certificate and its issuer") } certPEM, err := cryptoutils.MarshalCertificateToPEM(chain[0]) if err != nil { return nil, err } chainPEM, err := cryptoutils.MarshalCertificatesToPEM(chain[1:]) if err != nil { return nil, err } if err := VerifySCT(context.Background(), certPEM, chainPEM, co.SCT, co.CTLogPubKeys); err != nil { return nil, err } }
 return verifier, nil}
// CheckCertificatePolicy checks that the certificate subject and issuer match// the expected values.func CheckCertificatePolicy(cert \*x509.Certificate, co \*CheckOpts) error { ce := CertExtensions{Cert: cert}
 if err := validateCertExtensions(ce, co); err != nil { return err } oidcIssuer := ce.GetIssuer() sans := cryptoutils.GetSubjectAlternateNames(cert) // If there are identities given, go through them and if one of them // matches, call that good, otherwise, return an error. if len(co.Identities) > 0 { for \_, identity := range co.Identities { issuerMatches := false switch { // Check the issuer first case identity.IssuerRegExp != "": if regex, err := regexp.Compile(identity.IssuerRegExp); err != nil { return fmt.Errorf("malformed issuer in identity: %s : %w", identity.IssuerRegExp, err) } else if regex.MatchString(oidcIssuer) { issuerMatches = true } case identity.Issuer != "": if identity.Issuer == oidcIssuer { issuerMatches = true } default: // No issuer constraint on this identity, so checks out issuerMatches = true }
 // Then the subject subjectMatches := false switch { case identity.SubjectRegExp != "": regex, err := regexp.Compile(identity.SubjectRegExp) if err != nil { return fmt.Errorf("malformed subject in identity: %s : %w", identity.SubjectRegExp, err) } for \_, san := range sans { if regex.MatchString(san) { subjectMatches = true break } } case identity.Subject != "": for \_, san := range sans { if san == identity.Subject { subjectMatches = true break } } default: // No subject constraint on this identity, so checks out subjectMatches = true } if subjectMatches && issuerMatches { // If both issuer / subject match, return verified return nil } } return &VerificationFailure{ fmt.Errorf("none of the expected identities matched what was in the certificate, got subjects [%s] with issuer %s", strings.Join(sans, ", "), oidcIssuer), } } return nil}
func validateCertExtensions(ce CertExtensions, co \*CheckOpts) error { if co.CertGithubWorkflowTrigger != "" { if ce.GetCertExtensionGithubWorkflowTrigger() != co.CertGithubWorkflowTrigger { return &VerificationFailure{ fmt.Errorf("expected GitHub Workflow Trigger not found in certificate"), } } }
 if co.CertGithubWorkflowSha != "" { if ce.GetExtensionGithubWorkflowSha() != co.CertGithubWorkflowSha { return &VerificationFailure{ fmt.Errorf("expected GitHub Workflow SHA not found in certificate"), } } }
 if co.CertGithubWorkflowName != "" { if ce.GetCertExtensionGithubWorkflowName() != co.CertGithubWorkflowName { return &VerificationFailure{ fmt.Errorf("expected GitHub Workflow Name not found in certificate"), } } }
 if co.CertGithubWorkflowRepository != "" { if ce.GetCertExtensionGithubWorkflowRepository() != co.CertGithubWorkflowRepository { return &VerificationFailure{ fmt.Errorf("expected GitHub Workflow Repository not found in certificate"), } } }
 if co.CertGithubWorkflowRef != "" { if ce.GetCertExtensionGithubWorkflowRef() != co.CertGithubWorkflowRef { return &VerificationFailure{ fmt.Errorf("expected GitHub Workflow Ref not found in certificate"), } } } return nil}
// ValidateAndUnpackCertWithChain creates a Verifier from a certificate. Verifies that the certificate// chains up to the provided root. Chain should start with the parent of the certificate and end with the root.// Optionally verifies the subject and issuer of the certificate.func ValidateAndUnpackCertWithChain(cert \*x509.Certificate, chain []\*x509.Certificate, co \*CheckOpts) (signature.Verifier, error) { if len(chain) == 0 { return nil, errors.New("no chain provided to validate certificate") } rootPool := x509.NewCertPool() rootPool.AddCert(chain[len(chain)-1]) co.RootCerts = rootPool
 subPool := x509.NewCertPool() for \_, c := range chain[:len(chain)-1] { subPool.AddCert(c) } co.IntermediateCerts = subPool
 return ValidateAndUnpackCert(cert, co)}
func tlogValidateEntry(ctx context.Context, client \*client.Rekor, rekorPubKeys \*TrustedTransparencyLogPubKeys, sig oci.Signature, pem []byte) (\*models.LogEntryAnon, error) { b64sig, err := sig.Base64Signature() if err != nil { return nil, err } payload, err := sig.Payload() if err != nil { return nil, err } tlogEntries, err := FindTlogEntry(ctx, client, b64sig, payload, pem) if err != nil { return nil, err } if len(tlogEntries) == 0 { return nil, fmt.Errorf("no valid tlog entries found with proposed entry") } // Always return the earliest integrated entry. That // always suffices for verification of signature time. var earliestLogEntry models.LogEntryAnon var earliestLogEntryTime \*time.Time entryVerificationErrs := make([]string, 0) for \_, e := range tlogEntries { entry := e if err := VerifyTLogEntryOffline(ctx, &entry, rekorPubKeys); err != nil { entryVerificationErrs = append(entryVerificationErrs, err.Error()) continue } entryTime := time.Unix(\*entry.IntegratedTime, 0) if earliestLogEntryTime == nil || entryTime.Before(\*earliestLogEntryTime) { earliestLogEntryTime = &entryTime earliestLogEntry = entry } } if earliestLogEntryTime == nil { return nil, fmt.Errorf("no valid tlog entries found %s", strings.Join(entryVerificationErrs, ", ")) } return &earliestLogEntry, nil}
type fakeOCISignatures struct { oci.Signatures signatures []oci.Signature}
func (fos \*fakeOCISignatures) Get() ([]oci.Signature, error) { return fos.signatures, nil}
// VerifyImageSignatures does all the main cosign checks in a loop, returning the verified signatures.// If there were no valid signatures, we return an error.// Note that if co.ExperimentlOCI11 is set, we will attempt to verify// signatures using the experimental OCI 1.1 behavior.func VerifyImageSignatures(ctx context.Context, signedImgRef name.Reference, co \*CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) { // Try first using OCI 1.1 behavior if experimental flag is set. if co.ExperimentalOCI11 { verified, bundleVerified, err := verifyImageSignaturesExperimentalOCI(ctx, signedImgRef, co) if err == nil { return verified, bundleVerified, nil } }
 // Enforce this up front. if co.RootCerts == nil && co.SigVerifier == nil { return nil, false, errors.New("one of verifier or root certs is required") }
 // This is a carefully optimized sequence for fetching the signatures of the // entity that minimizes registry requests when supplied with a digest input digest, err := ociremote.ResolveDigest(signedImgRef, co.RegistryClientOpts...) if err != nil { if terr := (&transport.Error{}); errors.As(err, &terr) && terr.StatusCode == http.StatusNotFound { return nil, false, &ErrImageTagNotFound{ fmt.Errorf("image tag not found: %w", err), } } return nil, false, err } h, err := v1.NewHash(digest.Identifier()) if err != nil { return nil, false, err }
 var sigs oci.Signatures sigRef := co.SignatureRef if sigRef == "" { st, err := ociremote.SignatureTag(digest, co.RegistryClientOpts...) if err != nil { return nil, false, err } sigs, err = ociremote.Signatures(st, co.RegistryClientOpts...) if err != nil { return nil, false, err } } else { sigs, err = loadSignatureFromFile(ctx, sigRef, signedImgRef, co) if err != nil { return nil, false, err } }
 return verifySignatures(ctx, sigs, h, co)}
// VerifyLocalImageSignatures verifies signatures from a saved, local image, without any network calls, returning the verified signatures.// If there were no valid signatures, we return an error.func VerifyLocalImageSignatures(ctx context.Context, path string, co \*CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) { // Enforce this up front. if co.RootCerts == nil && co.SigVerifier == nil { return nil, false, errors.New("one of verifier or root certs is required") }
 se, err := layout.SignedImageIndex(path) if err != nil { return nil, false, err }
 var h v1.Hash // Verify either an image index or image. ii, err := se.SignedImageIndex(v1.Hash{}) if err != nil { return nil, false, err } i, err := se.SignedImage(v1.Hash{}) if err != nil { return nil, false, err } switch { case ii != nil: h, err = ii.Digest() if err != nil { return nil, false, err } case i != nil: h, err = i.Digest() if err != nil { return nil, false, err } default: return nil, false, errors.New("must verify either an image index or image") }
 sigs, err := se.Signatures() if err != nil { return nil, false, err } if sigs == nil { return nil, false, fmt.Errorf("no signatures associated with the image saved in %s", path) }
 return verifySignatures(ctx, sigs, h, co)}
func verifySignatures(ctx context.Context, sigs oci.Signatures, h v1.Hash, co \*CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) { sl, err := sigs.Get() if err != nil { return nil, false, err }
 if len(sl) == 0 { return nil, false, &ErrNoMatchingSignatures{ errors.New("no matching signatures"), } }
 signatures := make([]oci.Signature, len(sl)) bundlesVerified := make([]bool, len(sl))
 workers := co.MaxWorkers if co.MaxWorkers == 0 { workers = cosign.DefaultMaxWorkers } t := throttler.New(workers, len(sl)) for i, sig := range sl { go func(sig oci.Signature, index int) { sig, err := static.Copy(sig) if err != nil { t.Done(err) return }
 verified, err := VerifyImageSignature(ctx, sig, h, co) bundlesVerified[index] = verified if err != nil { t.Done(err) return } signatures[index] = sig
 t.Done(nil) }(sig, i)
 // wait till workers are available t.Throttle() }
 for \_, s := range signatures { if s != nil { checkedSignatures = append(checkedSignatures, s) } }
 for \_, verified := range bundlesVerified { bundleVerified = bundleVerified || verified }
 if len(checkedSignatures) == 0 { var combinedErrors []string for \_, err := range t.Errs() { combinedErrors = append(combinedErrors, err.Error()) } // TODO: ErrNoMatchingSignatures.Unwrap should return []error, // or we should replace "...%s" strings.Join with "...%w", errors.Join. return nil, false, &ErrNoMatchingSignatures{ fmt.Errorf("no matching signatures: %s", strings.Join(combinedErrors, "\n ")), } }
 return checkedSignatures, bundleVerified, nil}
// verifyInternal holds the main verification flow for signatures and attestations.// 1. Verifies the signature using the provided verifier.// 2. Checks for transparency log entry presence:// a. Verifies the Rekor entry in the bundle, if provided. This works offline OR// b. If we don't have a Rekor entry retrieved via cert, do an online lookup (assuming// we are in experimental mode).// 3. If a certificate is provided, check it's expiration using the transparency log timestamp.func verifyInternal(ctx context.Context, sig oci.Signature, h v1.Hash, verifyFn signatureVerificationFn, co \*CheckOpts) ( bundleVerified bool, err error) { var acceptableRFC3161Time, acceptableRekorBundleTime \*time.Time // Timestamps for the signature we accept, or nil if not applicable.
 acceptableRFC3161Timestamp, err := VerifyRFC3161Timestamp(sig, co) if err != nil { return false, fmt.Errorf("unable to verify RFC3161 timestamp bundle: %w", err) } if acceptableRFC3161Timestamp != nil { acceptableRFC3161Time = &acceptableRFC3161Timestamp.Time }
 if !co.IgnoreTlog { bundleVerified, err = VerifyBundle(sig, co) if err != nil { return false, fmt.Errorf("error verifying bundle: %w", err) }
 if bundleVerified { // Update with the verified bundle's integrated time. t, err := getBundleIntegratedTime(sig) if err != nil { return false, fmt.Errorf("error getting bundle integrated time: %w", err) } acceptableRekorBundleTime = &t } else { // If the --offline flag was specified, fail here. bundleVerified returns false with // no error when there was no bundle provided. if co.Offline { return false, fmt.Errorf("offline verification failed") }
 // no Rekor client provided for an online lookup if co.RekorClient == nil { return false, fmt.Errorf("rekor client not provided for online verification") }
 pemBytes, err := keyBytes(sig, co) if err != nil { return false, err }
 e, err := tlogValidateEntry(ctx, co.RekorClient, co.RekorPubKeys, sig, pemBytes) if err != nil { return false, err } t := time.Unix(\*e.IntegratedTime, 0) acceptableRekorBundleTime = &t } }
 verifier := co.SigVerifier if verifier == nil { // If we don't have a public key to check against, we can try a root cert. cert, err := sig.Cert() if err != nil { return false, err } if cert == nil { return false, &ErrNoCertificateFoundOnSignature{ fmt.Errorf("no certificate found on signature"), } } // Create a certificate pool for intermediate CA certificates, excluding the root chain, err := sig.Chain() if err != nil { return false, err } // If there is no chain annotation present, we preserve the pools set in the CheckOpts. if len(chain) > 0 { if len(chain) == 1 { co.IntermediateCerts = nil } else if co.IntermediateCerts == nil { // If the intermediate certs have not been loaded in by TUF pool := x509.NewCertPool() for \_, cert := range chain[:len(chain)-1] { pool.AddCert(cert) } co.IntermediateCerts = pool } } verifier, err = ValidateAndUnpackCert(cert, co) if err != nil { return false, err } }
 // 1. Perform cryptographic verification of the signature using the certificate's public key. if err := verifyFn(ctx, verifier, sig); err != nil { return false, err }
 // We can't check annotations without claims, both require unmarshalling the payload. if co.ClaimVerifier != nil { if err := co.ClaimVerifier(sig, h, co.Annotations); err != nil { return false, err } }
 // 2. if a certificate was used, verify the certificate expiration against a time cert, err := sig.Cert() if err != nil { return false, err } if cert != nil { // use the provided Rekor bundle or RFC3161 timestamp to check certificate expiration expirationChecked := false
 if acceptableRFC3161Time != nil { // Verify the cert against the timestamp time. if err := CheckExpiry(cert, \*acceptableRFC3161Time); err != nil { return false, fmt.Errorf("checking expiry on certificate with timestamp: %w", err) } expirationChecked = true }
 if acceptableRekorBundleTime != nil { if err := CheckExpiry(cert, \*acceptableRekorBundleTime); err != nil { return false, fmt.Errorf("checking expiry on certificate with bundle: %w", err) } expirationChecked = true }
 // if no timestamp has been provided, use the current time if !expirationChecked { if err := CheckExpiry(cert, time.Now()); err != nil { // If certificate is expired and not signed timestamp was provided then error the following message. Otherwise throw an expiration error. if co.IgnoreTlog && acceptableRFC3161Time == nil { return false, &VerificationFailure{ fmt.Errorf("expected a signed timestamp to verify an expired certificate"), } } return false, fmt.Errorf("checking expiry on certificate with bundle: %w", err) } } }
 return bundleVerified, nil}
func keyBytes(sig oci.Signature, co \*CheckOpts) ([]byte, error) { cert, err := sig.Cert() if err != nil { return nil, err } // We have a public key. if co.SigVerifier != nil { pub, err := co.SigVerifier.PublicKey(co.PKOpts...) if err != nil { return nil, err } return cryptoutils.MarshalPublicKeyToPEM(pub) } return cryptoutils.MarshalCertificateToPEM(cert)}
// VerifyBlobSignature verifies a blob signature.func VerifyBlobSignature(ctx context.Context, sig oci.Signature, co \*CheckOpts) (bundleVerified bool, err error) { // The hash of the artifact is unused. return verifyInternal(ctx, sig, v1.Hash{}, verifyOCISignature, co)}
// VerifyImageSignature verifies a signaturefunc VerifyImageSignature(ctx context.Context, sig oci.Signature, h v1.Hash, co \*CheckOpts) (bundleVerified bool, err error) { return verifyInternal(ctx, sig, h, verifyOCISignature, co)}
func loadSignatureFromFile(ctx context.Context, sigRef string, signedImgRef name.Reference, co \*CheckOpts) (oci.Signatures, error) { var b64sig string targetSig, err := blob.LoadFileOrURL(sigRef) if err != nil { if !os.IsNotExist(err) { return nil, err } targetSig = []byte(sigRef) }
 \_, err = base64.StdEncoding.DecodeString(string(targetSig))
 if err == nil { b64sig = string(targetSig) } else { b64sig = base64.StdEncoding.EncodeToString(targetSig) }
 var payload []byte if co.PayloadRef != "" { payload, err = blob.LoadFileOrURL(co.PayloadRef) if err != nil { return nil, err } } else { digest, err := ociremote.ResolveDigest(signedImgRef, co.RegistryClientOpts...) if err != nil { return nil, err } payload, err = ObsoletePayload(ctx, digest) if err != nil { return nil, err } }
 sig, err := static.NewSignature(payload, b64sig) if err != nil { return nil, err } return &fakeOCISignatures{ signatures: []oci.Signature{sig}, }, nil}
// VerifyImageAttestations does all the main cosign checks in a loop, returning the verified attestations.// If there were no valid attestations, we return an error.func VerifyImageAttestations(ctx context.Context, signedImgRef name.Reference, co \*CheckOpts) (checkedAttestations []oci.Signature, bundleVerified bool, err error) { // Enforce this up front. if co.RootCerts == nil && co.SigVerifier == nil { return nil, false, errors.New("one of verifier or root certs is required") }
 // This is a carefully optimized sequence for fetching the attestations of // the entity that minimizes registry requests when supplied with a digest // input. digest, err := ociremote.ResolveDigest(signedImgRef, co.RegistryClientOpts...) if err != nil { return nil, false, err } h, err := v1.NewHash(digest.Identifier()) if err != nil { return nil, false, err } st, err := ociremote.AttestationTag(digest, co.RegistryClientOpts...) if err != nil { return nil, false, err } atts, err := ociremote.Signatures(st, co.RegistryClientOpts...) if err != nil { return nil, false, err }
 return VerifyImageAttestation(ctx, atts, h, co)}
// VerifyLocalImageAttestations verifies attestations from a saved, local image, without any network calls,// returning the verified attestations.// If there were no valid signatures, we return an error.func VerifyLocalImageAttestations(ctx context.Context, path string, co \*CheckOpts) (checkedAttestations []oci.Signature, bundleVerified bool, err error) { // Enforce this up front. if co.RootCerts == nil && co.SigVerifier == nil { return nil, false, errors.New("one of verifier or root certs is required") }
 se, err := layout.SignedImageIndex(path) if err != nil { return nil, false, err }
 var h v1.Hash // Verify either an image index or image. ii, err := se.SignedImageIndex(v1.Hash{}) if err != nil { return nil, false, err } i, err := se.SignedImage(v1.Hash{}) if err != nil { return nil, false, err } switch { case ii != nil: h, err = ii.Digest() if err != nil { return nil, false, err } case i != nil: h, err = i.Digest() if err != nil { return nil, false, err } default: return nil, false, errors.New("must verify either an image index or image") }
 atts, err := se.Attestations() if err != nil { return nil, false, err } return VerifyImageAttestation(ctx, atts, h, co)}
func VerifyBlobAttestation(ctx context.Context, att oci.Signature, h v1.Hash, co \*CheckOpts) ( bool, error) { return verifyInternal(ctx, att, h, verifyOCIAttestation, co)}
func VerifyImageAttestation(ctx context.Context, atts oci.Signatures, h v1.Hash, co \*CheckOpts) (checkedAttestations []oci.Signature, bundleVerified bool, err error) { sl, err := atts.Get() if err != nil { return nil, false, err }
 attestations := make([]oci.Signature, len(sl)) bundlesVerified := make([]bool, len(sl))
 workers := co.MaxWorkers if co.MaxWorkers == 0 { workers = cosign.DefaultMaxWorkers } t := throttler.New(workers, len(sl)) for i, att := range sl { go func(att oci.Signature, index int) { att, err := static.Copy(att) if err != nil { t.Done(err) return } if err := func(att oci.Signature) error { verified, err := verifyInternal(ctx, att, h, verifyOCIAttestation, co) bundlesVerified[index] = verified return err }(att); err != nil { t.Done(err) return }
 attestations[index] = att t.Done(nil) }(att, i)
 // wait till workers are available t.Throttle() }
 for \_, a := range attestations { if a != nil { checkedAttestations = append(checkedAttestations, a) } }
 for \_, verified := range bundlesVerified { bundleVerified = bundleVerified || verified }
 if len(checkedAttestations) == 0 { var combinedErrors []string for \_, err := range t.Errs() { combinedErrors = append(combinedErrors, err.Error()) }[View remainder of file in raw view](https://github.com/sigstore/cosign/raw/14795db16417579fac0c00c11e166868d7976b61/pkg/cosign/verify.go)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

