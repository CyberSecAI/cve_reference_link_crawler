<!DOCTYPE html>
<html lang='en'>
<head>
<title>btrfs: fix race when detecting delalloc ranges during fiemap - kernel/git/stable/linux.git - Linux kernel stable tree</title>
<meta name='generator' content='cgit 1.2.3-korg'/>
<meta name='robots' content='noindex, nofollow'/>
<link rel='stylesheet' type='text/css' href='/cgit-data/cgit.css'/>
<script type='text/javascript' src='/cgit-data/cgit.js'></script>
<link rel='shortcut icon' href='/favicon.ico'/>
<link rel='alternate' title='Atom feed' href='https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/atom/?h=master' type='application/atom+xml'/>
<link rel='vcs-git' href='git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git' title='kernel/git/stable/linux.git Git repository'/>
<link rel='vcs-git' href='https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git' title='kernel/git/stable/linux.git Git repository'/>
<link rel='vcs-git' href='https://kernel.googlesource.com/pub/scm/linux/kernel/git/stable/linux.git' title='kernel/git/stable/linux.git Git repository'/>
</head>
<body>
<div id='cgit'><table id='header'>
<tr>
<td class='logo' rowspan='2'><a href='/'><img src='/cgit-data/cgit.png' alt='cgit logo'/></a></td>
<td class='main'><a href='/'>index</a> : <a href='/pub/scm/linux/kernel/git/stable/linux.git/'>kernel/git/stable/linux.git</a></td><td class='form'><form method='get'>
<input type='hidden' name='id' value='49d640d2946c35a17b051d54171a032dd95b0f50'/><select name='h' onchange='this.form.submit();'>
<option value='linux-2.6.11.y'>linux-2.6.11.y</option>
<option value='linux-2.6.12.y'>linux-2.6.12.y</option>
<option value='linux-2.6.13.y'>linux-2.6.13.y</option>
<option value='linux-2.6.14.y'>linux-2.6.14.y</option>
<option value='linux-2.6.15.y'>linux-2.6.15.y</option>
<option value='linux-2.6.16.y'>linux-2.6.16.y</option>
<option value='linux-2.6.17.y'>linux-2.6.17.y</option>
<option value='linux-2.6.18.y'>linux-2.6.18.y</option>
<option value='linux-2.6.19.y'>linux-2.6.19.y</option>
<option value='linux-2.6.20.y'>linux-2.6.20.y</option>
<option value='linux-2.6.21.y'>linux-2.6.21.y</option>
<option value='linux-2.6.22.y'>linux-2.6.22.y</option>
<option value='linux-2.6.23.y'>linux-2.6.23.y</option>
<option value='linux-2.6.24.y'>linux-2.6.24.y</option>
<option value='linux-2.6.25.y'>linux-2.6.25.y</option>
<option value='linux-2.6.26.y'>linux-2.6.26.y</option>
<option value='linux-2.6.27.y'>linux-2.6.27.y</option>
<option value='linux-2.6.28.y'>linux-2.6.28.y</option>
<option value='linux-2.6.29.y'>linux-2.6.29.y</option>
<option value='linux-2.6.30.y'>linux-2.6.30.y</option>
<option value='linux-2.6.31.y'>linux-2.6.31.y</option>
<option value='linux-2.6.32.y'>linux-2.6.32.y</option>
<option value='linux-2.6.33.y'>linux-2.6.33.y</option>
<option value='linux-2.6.34.y'>linux-2.6.34.y</option>
<option value='linux-2.6.35.y'>linux-2.6.35.y</option>
<option value='linux-2.6.36.y'>linux-2.6.36.y</option>
<option value='linux-2.6.37.y'>linux-2.6.37.y</option>
<option value='linux-2.6.38.y'>linux-2.6.38.y</option>
<option value='linux-2.6.39.y'>linux-2.6.39.y</option>
<option value='linux-3.0.y'>linux-3.0.y</option>
<option value='linux-3.1.y'>linux-3.1.y</option>
<option value='linux-3.10.y'>linux-3.10.y</option>
<option value='linux-3.11.y'>linux-3.11.y</option>
<option value='linux-3.12.y'>linux-3.12.y</option>
<option value='linux-3.13.y'>linux-3.13.y</option>
<option value='linux-3.14.y'>linux-3.14.y</option>
<option value='linux-3.15.y'>linux-3.15.y</option>
<option value='linux-3.16.y'>linux-3.16.y</option>
<option value='linux-3.17.y'>linux-3.17.y</option>
<option value='linux-3.18.y'>linux-3.18.y</option>
<option value='linux-3.19.y'>linux-3.19.y</option>
<option value='linux-3.2.y'>linux-3.2.y</option>
<option value='linux-3.3.y'>linux-3.3.y</option>
<option value='linux-3.4.y'>linux-3.4.y</option>
<option value='linux-3.5.y'>linux-3.5.y</option>
<option value='linux-3.6.y'>linux-3.6.y</option>
<option value='linux-3.7.y'>linux-3.7.y</option>
<option value='linux-3.8.y'>linux-3.8.y</option>
<option value='linux-3.9.y'>linux-3.9.y</option>
<option value='linux-4.0.y'>linux-4.0.y</option>
<option value='linux-4.1.y'>linux-4.1.y</option>
<option value='linux-4.10.y'>linux-4.10.y</option>
<option value='linux-4.11.y'>linux-4.11.y</option>
<option value='linux-4.12.y'>linux-4.12.y</option>
<option value='linux-4.13.y'>linux-4.13.y</option>
<option value='linux-4.14.y'>linux-4.14.y</option>
<option value='linux-4.15.y'>linux-4.15.y</option>
<option value='linux-4.16.y'>linux-4.16.y</option>
<option value='linux-4.17.y'>linux-4.17.y</option>
<option value='linux-4.18.y'>linux-4.18.y</option>
<option value='linux-4.19.y'>linux-4.19.y</option>
<option value='linux-4.2.y'>linux-4.2.y</option>
<option value='linux-4.20.y'>linux-4.20.y</option>
<option value='linux-4.3.y'>linux-4.3.y</option>
<option value='linux-4.4.y'>linux-4.4.y</option>
<option value='linux-4.5.y'>linux-4.5.y</option>
<option value='linux-4.6.y'>linux-4.6.y</option>
<option value='linux-4.7.y'>linux-4.7.y</option>
<option value='linux-4.8.y'>linux-4.8.y</option>
<option value='linux-4.9.y'>linux-4.9.y</option>
<option value='linux-5.0.y'>linux-5.0.y</option>
<option value='linux-5.1.y'>linux-5.1.y</option>
<option value='linux-5.10.y'>linux-5.10.y</option>
<option value='linux-5.11.y'>linux-5.11.y</option>
<option value='linux-5.12.y'>linux-5.12.y</option>
<option value='linux-5.13.y'>linux-5.13.y</option>
<option value='linux-5.14.y'>linux-5.14.y</option>
<option value='linux-5.15.y'>linux-5.15.y</option>
<option value='linux-5.16.y'>linux-5.16.y</option>
<option value='linux-5.17.y'>linux-5.17.y</option>
<option value='linux-5.18.y'>linux-5.18.y</option>
<option value='linux-5.19.y'>linux-5.19.y</option>
<option value='linux-5.2.y'>linux-5.2.y</option>
<option value='linux-5.3.y'>linux-5.3.y</option>
<option value='linux-5.4.y'>linux-5.4.y</option>
<option value='linux-5.5.y'>linux-5.5.y</option>
<option value='linux-5.6.y'>linux-5.6.y</option>
<option value='linux-5.7.y'>linux-5.7.y</option>
<option value='linux-5.8.y'>linux-5.8.y</option>
<option value='linux-5.9.y'>linux-5.9.y</option>
<option value='linux-6.0.y'>linux-6.0.y</option>
<option value='linux-6.1.y'>linux-6.1.y</option>
<option value='linux-6.10.y'>linux-6.10.y</option>
<option value='linux-6.11.y'>linux-6.11.y</option>
<option value='linux-6.12.y'>linux-6.12.y</option>
<option value='linux-6.2.y'>linux-6.2.y</option>
<option value='linux-6.3.y'>linux-6.3.y</option>
<option value='linux-6.4.y'>linux-6.4.y</option>
<option value='linux-6.5.y'>linux-6.5.y</option>
<option value='linux-6.6.y'>linux-6.6.y</option>
<option value='linux-6.7.y'>linux-6.7.y</option>
<option value='linux-6.8.y'>linux-6.8.y</option>
<option value='linux-6.9.y'>linux-6.9.y</option>
<option value='linux-rolling-lts'>linux-rolling-lts</option>
<option value='linux-rolling-stable'>linux-rolling-stable</option>
<option value='master' selected='selected'>master</option>
</select> <input type='submit' value='switch'/></form></td></tr>
<tr><td class='sub'>Linux kernel stable tree</td><td class='sub right'>Stable Group</td></tr></table>
<table class='tabs'><tr><td>
<a href='/pub/scm/linux/kernel/git/stable/linux.git/about/'>about</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/'>summary</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=49d640d2946c35a17b051d54171a032dd95b0f50'>refs</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/log/'>log</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=49d640d2946c35a17b051d54171a032dd95b0f50'>tree</a><a class='active' href='/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=49d640d2946c35a17b051d54171a032dd95b0f50'>commit</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=49d640d2946c35a17b051d54171a032dd95b0f50'>diff</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/stats/'>stats</a></td><td class='form'><form class='right' method='get' action='/pub/scm/linux/kernel/git/stable/linux.git/log/'>
<input type='hidden' name='id' value='49d640d2946c35a17b051d54171a032dd95b0f50'/><select name='qt'>
<option value='grep'>log msg</option>
<option value='author'>author</option>
<option value='committer'>committer</option>
<option value='range'>range</option>
</select>
<input class='txt' type='search' size='10' name='q' value=''/>
<input type='submit' value='search'/>
</form>
</td></tr></table>
<div class='content'><div class='cgit-panel'><b>diff options</b><form method='get'><input type='hidden' name='id' value='49d640d2946c35a17b051d54171a032dd95b0f50'/><table><tr><td colspan='2'/></tr><tr><td class='label'>context:</td><td class='ctrl'><select name='context' onchange='this.form.submit();'><option value='1'>1</option><option value='2'>2</option><option value='3' selected='selected'>3</option><option value='4'>4</option><option value='5'>5</option><option value='6'>6</option><option value='7'>7</option><option value='8'>8</option><option value='9'>9</option><option value='10'>10</option><option value='15'>15</option><option value='20'>20</option><option value='25'>25</option><option value='30'>30</option><option value='35'>35</option><option value='40'>40</option></select></td></tr><tr><td class='label'>space:</td><td class='ctrl'><select name='ignorews' onchange='this.form.submit();'><option value='0' selected='selected'>include</option><option value='1'>ignore</option></select></td></tr><tr><td class='label'>mode:</td><td class='ctrl'><select name='dt' onchange='this.form.submit();'><option value='0' selected='selected'>unified</option><option value='1'>ssdiff</option><option value='2'>stat only</option></select></td></tr><tr><td/><td class='ctrl'><noscript><input type='submit' value='reload'/></noscript></td></tr></table></form></div><table summary='commit info' class='commit-info'>
<tr><th>author</th><td>Filipe Manana &lt;fdmanana@suse.com&gt;</td><td class='right'>2024-02-28 11:37:56 +0000</td></tr>
<tr><th>committer</th><td>Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;</td><td class='right'>2024-04-10 16:35:46 +0200</td></tr>
<tr><th>commit</th><td colspan='2' class='oid'><a href='/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=49d640d2946c35a17b051d54171a032dd95b0f50'>49d640d2946c35a17b051d54171a032dd95b0f50</a> (<a href='/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=49d640d2946c35a17b051d54171a032dd95b0f50'>patch</a>)</td></tr>
<tr><th>tree</th><td colspan='2' class='oid'><a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=49d640d2946c35a17b051d54171a032dd95b0f50'>8be53873c87d97ccfeba59e644eaaa7ff879cf58</a></td></tr>
<tr><th>parent</th><td colspan='2' class='oid'><a href='/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=8cc484e85e0c6bf72ec7c3c8c697865355873cfb'>8cc484e85e0c6bf72ec7c3c8c697865355873cfb</a> (<a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=49d640d2946c35a17b051d54171a032dd95b0f50&amp;id2=8cc484e85e0c6bf72ec7c3c8c697865355873cfb'>diff</a>)</td></tr><tr><th>download</th><td colspan='2' class='oid'><a href='/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-49d640d2946c35a17b051d54171a032dd95b0f50.tar.gz'>linux-49d640d2946c35a17b051d54171a032dd95b0f50.tar.gz</a><br/></td></tr></table>
<div class='commit-subject'>btrfs: fix race when detecting delalloc ranges during fiemap</div><div class='commit-msg'>[ Upstream commit 978b63f7464abcfd364a6c95f734282c50f3decf ]

For fiemap we recently stopped locking the target extent range for the
whole duration of the fiemap call, in order to avoid a deadlock in a
scenario where the fiemap buffer happens to be a memory mapped range of
the same file. This use case is very unlikely to be useful in practice but
it may be triggered by fuzz testing (syzbot, etc).

This however introduced a race that makes us miss delalloc ranges for
file regions that are currently holes, so the caller of fiemap will not
be aware that there's data for some file regions. This can be quite
serious for some use cases - for example in coreutils versions before 9.0,
the cp program used fiemap to detect holes and data in the source file,
copying only regions with data (extents or delalloc) from the source file
to the destination file in order to preserve holes (see the documentation
for its --sparse command line option). This means that if cp was used
with a source file that had delalloc in a hole, the destination file could
end up without that data, which is effectively a data loss issue, if it
happened to hit the race described below.

The race happens like this:

1) Fiemap is called, without the FIEMAP_FLAG_SYNC flag, for a file that
   has delalloc in the file range [64M, 65M[, which is currently a hole;

2) Fiemap locks the inode in shared mode, then starts iterating the
   inode's subvolume tree searching for file extent items, without having
   the whole fiemap target range locked in the inode's io tree - the
   change introduced recently by commit b0ad381fa769 ("btrfs: fix
   deadlock with fiemap and extent locking"). It only locks ranges in
   the io tree when it finds a hole or prealloc extent since that
   commit;

3) Note that fiemap clones each leaf before using it, and this is to
   avoid deadlocks when locking a file range in the inode's io tree and
   the fiemap buffer is memory mapped to some file, because writing
   to the page with btrfs_page_mkwrite() will wait on any ordered extent
   for the page's range and the ordered extent needs to lock the range
   and may need to modify the same leaf, therefore leading to a deadlock
   on the leaf;

4) While iterating the file extent items in the cloned leaf before
   finding the hole in the range [64M, 65M[, the delalloc in that range
   is flushed and its ordered extent completes - meaning the corresponding
   file extent item is in the inode's subvolume tree, but not present in
   the cloned leaf that fiemap is iterating over;

5) When fiemap finds the hole in the [64M, 65M[ range by seeing the gap in
   the cloned leaf (or a file extent item with disk_bytenr == 0 in case
   the NO_HOLES feature is not enabled), it will lock that file range in
   the inode's io tree and then search for delalloc by checking for the
   EXTENT_DELALLOC bit in the io tree for that range and ordered extents
   (with btrfs_find_delalloc_in_range()). But it finds nothing since the
   delalloc in that range was already flushed and the ordered extent
   completed and is gone - as a result fiemap will not report that there's
   delalloc or an extent for the range [64M, 65M[, so user space will be
   mislead into thinking that there's a hole in that range.

This could actually be sporadically triggered with test case generic/094
from fstests, which reports a missing extent/delalloc range like this:

#  generic/094 2s ... - output mismatch (see /home/fdmanana/git/hub/xfstests/results//generic/094.out.bad)
#      --- tests/generic/094.out	2020-06-10 19:29:03.830519425 +0100
#      +++ /home/fdmanana/git/hub/xfstests/results//generic/094.out.bad	2024-02-28 11:00:00.381071525 +0000
#      @@ -1,3 +1,9 @@
#       QA output created by 094
#       fiemap run with sync
#       fiemap run without sync
#      +ERROR: couldn't find extent at 7
#      +map is 'HHDDHPPDPHPH'
#      +logical: [       5..       6] phys:   301517..  301518 flags: 0x800 tot: 2
#      +logical: [       8..       8] phys:   301520..  301520 flags: 0x800 tot: 1
#      ...
#      (Run 'diff -u /home/fdmanana/git/hub/xfstests/tests/generic/094.out /home/fdmanana/git/hub/xfstests/results//generic/094.out.bad'  to see the entire diff)

So in order to fix this, while still avoiding deadlocks in the case where
the fiemap buffer is memory mapped to the same file, change fiemap to work
like the following:

1) Always lock the whole range in the inode's io tree before starting to
   iterate the inode's subvolume tree searching for file extent items,
   just like we did before commit b0ad381fa769 ("btrfs: fix deadlock with
   fiemap and extent locking");

2) Now instead of writing to the fiemap buffer every time we have an extent
   to report, write instead to a temporary buffer (1 page), and when that
   buffer becomes full, stop iterating the file extent items, unlock the
   range in the io tree, release the search path, submit all the entries
   kept in that buffer to the fiemap buffer, and then resume the search
   for file extent items after locking again the remainder of the range in
   the io tree.

   The buffer having a size of a page, allows for 146 entries in a system
   with 4K pages. This is a large enough value to have a good performance
   by avoiding too many restarts of the search for file extent items.
   In other words this preserves the huge performance gains made in the
   last two years to fiemap, while avoiding the deadlocks in case the
   fiemap buffer is memory mapped to the same file (useless in practice,
   but possible and exercised by fuzz testing and syzbot).

Fixes: b0ad381fa769 ("btrfs: fix deadlock with fiemap and extent locking")
Reviewed-by: Josef Bacik &lt;josef@toxicpanda.com&gt;
Signed-off-by: Filipe Manana &lt;fdmanana@suse.com&gt;
Signed-off-by: David Sterba &lt;dsterba@suse.com&gt;
Signed-off-by: Sasha Levin &lt;sashal@kernel.org&gt;
</div><div class='diffstat-header'><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=49d640d2946c35a17b051d54171a032dd95b0f50'>Diffstat</a></div><table summary='diffstat' class='diffstat'><tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/extent_io.c?id=49d640d2946c35a17b051d54171a032dd95b0f50'>fs/btrfs/extent_io.c</a></td><td class='right'>221</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 72.4%;'/><td class='rem' style='width: 27.6%;'/><td class='none' style='width: 0.0%;'/></tr></table></td></tr>
</table><div class='diffstat-summary'>1 files changed, 160 insertions, 61 deletions</div><table summary='diff' class='diff'><tr><td><div class='head'>diff --git a/fs/btrfs/extent_io.c b/fs/btrfs/extent_io.c<br/>index 45d427c3033d7f..5acb2cb79d4bfe 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/extent_io.c?id=8cc484e85e0c6bf72ec7c3c8c697865355873cfb'>fs/btrfs/extent_io.c</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/extent_io.c?id=49d640d2946c35a17b051d54171a032dd95b0f50'>fs/btrfs/extent_io.c</a></div><div class='hunk'>@@ -2410,12 +2410,65 @@ next:</div><div class='ctx'> 	return try_release_extent_state(tree, page, mask);</div><div class='ctx'> }</div><div class='ctx'> </div><div class='add'>+struct btrfs_fiemap_entry {</div><div class='add'>+	u64 offset;</div><div class='add'>+	u64 phys;</div><div class='add'>+	u64 len;</div><div class='add'>+	u32 flags;</div><div class='add'>+};</div><div class='add'>+</div><div class='ctx'> /*</div><div class='del'>- * To cache previous fiemap extent</div><div class='add'>+ * Indicate the caller of emit_fiemap_extent() that it needs to unlock the file</div><div class='add'>+ * range from the inode's io tree, unlock the subvolume tree search path, flush</div><div class='add'>+ * the fiemap cache and relock the file range and research the subvolume tree.</div><div class='add'>+ * The value here is something negative that can't be confused with a valid</div><div class='add'>+ * errno value and different from 1 because that's also a return value from</div><div class='add'>+ * fiemap_fill_next_extent() and also it's often used to mean some btree search</div><div class='add'>+ * did not find a key, so make it some distinct negative value.</div><div class='add'>+ */</div><div class='add'>+#define BTRFS_FIEMAP_FLUSH_CACHE (-(MAX_ERRNO + 1))</div><div class='add'>+</div><div class='add'>+/*</div><div class='add'>+ * Used to:</div><div class='add'>+ *</div><div class='add'>+ * - Cache the next entry to be emitted to the fiemap buffer, so that we can</div><div class='add'>+ *   merge extents that are contiguous and can be grouped as a single one;</div><div class='ctx'>  *</div><div class='del'>- * Will be used for merging fiemap extent</div><div class='add'>+ * - Store extents ready to be written to the fiemap buffer in an intermediary</div><div class='add'>+ *   buffer. This intermediary buffer is to ensure that in case the fiemap</div><div class='add'>+ *   buffer is memory mapped to the fiemap target file, we don't deadlock</div><div class='add'>+ *   during btrfs_page_mkwrite(). This is because during fiemap we are locking</div><div class='add'>+ *   an extent range in order to prevent races with delalloc flushing and</div><div class='add'>+ *   ordered extent completion, which is needed in order to reliably detect</div><div class='add'>+ *   delalloc in holes and prealloc extents. And this can lead to a deadlock</div><div class='add'>+ *   if the fiemap buffer is memory mapped to the file we are running fiemap</div><div class='add'>+ *   against (a silly, useless in practice scenario, but possible) because</div><div class='add'>+ *   btrfs_page_mkwrite() will try to lock the same extent range.</div><div class='ctx'>  */</div><div class='ctx'> struct fiemap_cache {</div><div class='add'>+	/* An array of ready fiemap entries. */</div><div class='add'>+	struct btrfs_fiemap_entry *entries;</div><div class='add'>+	/* Number of entries in the entries array. */</div><div class='add'>+	int entries_size;</div><div class='add'>+	/* Index of the next entry in the entries array to write to. */</div><div class='add'>+	int entries_pos;</div><div class='add'>+	/*</div><div class='add'>+	 * Once the entries array is full, this indicates what's the offset for</div><div class='add'>+	 * the next file extent item we must search for in the inode's subvolume</div><div class='add'>+	 * tree after unlocking the extent range in the inode's io tree and</div><div class='add'>+	 * releasing the search path.</div><div class='add'>+	 */</div><div class='add'>+	u64 next_search_offset;</div><div class='add'>+	/*</div><div class='add'>+	 * This matches struct fiemap_extent_info::fi_mapped_extents, we use it</div><div class='add'>+	 * to count ourselves emitted extents and stop instead of relying on</div><div class='add'>+	 * fiemap_fill_next_extent() because we buffer ready fiemap entries at</div><div class='add'>+	 * the @entries array, and we want to stop as soon as we hit the max</div><div class='add'>+	 * amount of extents to map, not just to save time but also to make the</div><div class='add'>+	 * logic at extent_fiemap() simpler.</div><div class='add'>+	 */</div><div class='add'>+	unsigned int extents_mapped;</div><div class='add'>+	/* Fields for the cached extent (unsubmitted, not ready, extent). */</div><div class='ctx'> 	u64 offset;</div><div class='ctx'> 	u64 phys;</div><div class='ctx'> 	u64 len;</div><div class='hunk'>@@ -2423,6 +2476,28 @@ struct fiemap_cache {</div><div class='ctx'> 	bool cached;</div><div class='ctx'> };</div><div class='ctx'> </div><div class='add'>+static int flush_fiemap_cache(struct fiemap_extent_info *fieinfo,</div><div class='add'>+			      struct fiemap_cache *cache)</div><div class='add'>+{</div><div class='add'>+	for (int i = 0; i &lt; cache-&gt;entries_pos; i++) {</div><div class='add'>+		struct btrfs_fiemap_entry *entry = &amp;cache-&gt;entries[i];</div><div class='add'>+		int ret;</div><div class='add'>+</div><div class='add'>+		ret = fiemap_fill_next_extent(fieinfo, entry-&gt;offset,</div><div class='add'>+					      entry-&gt;phys, entry-&gt;len,</div><div class='add'>+					      entry-&gt;flags);</div><div class='add'>+		/*</div><div class='add'>+		 * Ignore 1 (reached max entries) because we keep track of that</div><div class='add'>+		 * ourselves in emit_fiemap_extent().</div><div class='add'>+		 */</div><div class='add'>+		if (ret &lt; 0)</div><div class='add'>+			return ret;</div><div class='add'>+	}</div><div class='add'>+	cache-&gt;entries_pos = 0;</div><div class='add'>+</div><div class='add'>+	return 0;</div><div class='add'>+}</div><div class='add'>+</div><div class='ctx'> /*</div><div class='ctx'>  * Helper to submit fiemap extent.</div><div class='ctx'>  *</div><div class='hunk'>@@ -2437,8 +2512,8 @@ static int emit_fiemap_extent(struct fiemap_extent_info *fieinfo,</div><div class='ctx'> 				struct fiemap_cache *cache,</div><div class='ctx'> 				u64 offset, u64 phys, u64 len, u32 flags)</div><div class='ctx'> {</div><div class='add'>+	struct btrfs_fiemap_entry *entry;</div><div class='ctx'> 	u64 cache_end;</div><div class='del'>-	int ret = 0;</div><div class='ctx'> </div><div class='ctx'> 	/* Set at the end of extent_fiemap(). */</div><div class='ctx'> 	ASSERT((flags &amp; FIEMAP_EXTENT_LAST) == 0);</div><div class='hunk'>@@ -2451,7 +2526,9 @@ static int emit_fiemap_extent(struct fiemap_extent_info *fieinfo,</div><div class='ctx'> 	 * find an extent that starts at an offset behind the end offset of the</div><div class='ctx'> 	 * previous extent we processed. This happens if fiemap is called</div><div class='ctx'> 	 * without FIEMAP_FLAG_SYNC and there are ordered extents completing</div><div class='del'>-	 * while we call btrfs_next_leaf() (through fiemap_next_leaf_item()).</div><div class='add'>+	 * after we had to unlock the file range, release the search path, emit</div><div class='add'>+	 * the fiemap extents stored in the buffer (cache-&gt;entries array) and</div><div class='add'>+	 * the lock the remainder of the range and re-search the btree.</div><div class='ctx'> 	 *</div><div class='ctx'> 	 * For example we are in leaf X processing its last item, which is the</div><div class='ctx'> 	 * file extent item for file range [512K, 1M[, and after</div><div class='hunk'>@@ -2564,11 +2641,35 @@ static int emit_fiemap_extent(struct fiemap_extent_info *fieinfo,</div><div class='ctx'> </div><div class='ctx'> emit:</div><div class='ctx'> 	/* Not mergeable, need to submit cached one */</div><div class='del'>-	ret = fiemap_fill_next_extent(fieinfo, cache-&gt;offset, cache-&gt;phys,</div><div class='del'>-				      cache-&gt;len, cache-&gt;flags);</div><div class='del'>-	cache-&gt;cached = false;</div><div class='del'>-	if (ret)</div><div class='del'>-		return ret;</div><div class='add'>+</div><div class='add'>+	if (cache-&gt;entries_pos == cache-&gt;entries_size) {</div><div class='add'>+		/*</div><div class='add'>+		 * We will need to research for the end offset of the last</div><div class='add'>+		 * stored extent and not from the current offset, because after</div><div class='add'>+		 * unlocking the range and releasing the path, if there's a hole</div><div class='add'>+		 * between that end offset and this current offset, a new extent</div><div class='add'>+		 * may have been inserted due to a new write, so we don't want</div><div class='add'>+		 * to miss it.</div><div class='add'>+		 */</div><div class='add'>+		entry = &amp;cache-&gt;entries[cache-&gt;entries_size - 1];</div><div class='add'>+		cache-&gt;next_search_offset = entry-&gt;offset + entry-&gt;len;</div><div class='add'>+		cache-&gt;cached = false;</div><div class='add'>+</div><div class='add'>+		return BTRFS_FIEMAP_FLUSH_CACHE;</div><div class='add'>+	}</div><div class='add'>+</div><div class='add'>+	entry = &amp;cache-&gt;entries[cache-&gt;entries_pos];</div><div class='add'>+	entry-&gt;offset = cache-&gt;offset;</div><div class='add'>+	entry-&gt;phys = cache-&gt;phys;</div><div class='add'>+	entry-&gt;len = cache-&gt;len;</div><div class='add'>+	entry-&gt;flags = cache-&gt;flags;</div><div class='add'>+	cache-&gt;entries_pos++;</div><div class='add'>+	cache-&gt;extents_mapped++;</div><div class='add'>+</div><div class='add'>+	if (cache-&gt;extents_mapped == fieinfo-&gt;fi_extents_max) {</div><div class='add'>+		cache-&gt;cached = false;</div><div class='add'>+		return 1;</div><div class='add'>+	}</div><div class='ctx'> assign:</div><div class='ctx'> 	cache-&gt;cached = true;</div><div class='ctx'> 	cache-&gt;offset = offset;</div><div class='hunk'>@@ -2694,8 +2795,8 @@ static int fiemap_search_slot(struct btrfs_inode *inode, struct btrfs_path *path</div><div class='ctx'> 	 * neighbour leaf).</div><div class='ctx'> 	 * We also need the private clone because holding a read lock on an</div><div class='ctx'> 	 * extent buffer of the subvolume's b+tree will make lockdep unhappy</div><div class='del'>-	 * when we call fiemap_fill_next_extent(), because that may cause a page</div><div class='del'>-	 * fault when filling the user space buffer with fiemap data.</div><div class='add'>+	 * when we check if extents are shared, as backref walking may need to</div><div class='add'>+	 * lock the same leaf we are processing.</div><div class='ctx'> 	 */</div><div class='ctx'> 	clone = btrfs_clone_extent_buffer(path-&gt;nodes[0]);</div><div class='ctx'> 	if (!clone)</div><div class='hunk'>@@ -2735,34 +2836,16 @@ static int fiemap_process_hole(struct btrfs_inode *inode,</div><div class='ctx'> 	 * it beyond i_size.</div><div class='ctx'> 	 */</div><div class='ctx'> 	while (cur_offset &lt; end &amp;&amp; cur_offset &lt; i_size) {</div><div class='del'>-		struct extent_state *cached_state = NULL;</div><div class='ctx'> 		u64 delalloc_start;</div><div class='ctx'> 		u64 delalloc_end;</div><div class='ctx'> 		u64 prealloc_start;</div><div class='del'>-		u64 lockstart;</div><div class='del'>-		u64 lockend;</div><div class='ctx'> 		u64 prealloc_len = 0;</div><div class='ctx'> 		bool delalloc;</div><div class='ctx'> </div><div class='del'>-		lockstart = round_down(cur_offset, inode-&gt;root-&gt;fs_info-&gt;sectorsize);</div><div class='del'>-		lockend = round_up(end, inode-&gt;root-&gt;fs_info-&gt;sectorsize);</div><div class='del'>-</div><div class='del'>-		/*</div><div class='del'>-		 * We are only locking for the delalloc range because that's the</div><div class='del'>-		 * only thing that can change here.  With fiemap we have a lock</div><div class='del'>-		 * on the inode, so no buffered or direct writes can happen.</div><div class='del'>-		 *</div><div class='del'>-		 * However mmaps and normal page writeback will cause this to</div><div class='del'>-		 * change arbitrarily.  We have to lock the extent lock here to</div><div class='del'>-		 * make sure that nobody messes with the tree while we're doing</div><div class='del'>-		 * btrfs_find_delalloc_in_range.</div><div class='del'>-		 */</div><div class='del'>-		lock_extent(&amp;inode-&gt;io_tree, lockstart, lockend, &amp;cached_state);</div><div class='ctx'> 		delalloc = btrfs_find_delalloc_in_range(inode, cur_offset, end,</div><div class='ctx'> 							delalloc_cached_state,</div><div class='ctx'> 							&amp;delalloc_start,</div><div class='ctx'> 							&amp;delalloc_end);</div><div class='del'>-		unlock_extent(&amp;inode-&gt;io_tree, lockstart, lockend, &amp;cached_state);</div><div class='ctx'> 		if (!delalloc)</div><div class='ctx'> 			break;</div><div class='ctx'> </div><div class='hunk'>@@ -2930,6 +3013,7 @@ int extent_fiemap(struct btrfs_inode *inode, struct fiemap_extent_info *fieinfo,</div><div class='ctx'> 		  u64 start, u64 len)</div><div class='ctx'> {</div><div class='ctx'> 	const u64 ino = btrfs_ino(inode);</div><div class='add'>+	struct extent_state *cached_state = NULL;</div><div class='ctx'> 	struct extent_state *delalloc_cached_state = NULL;</div><div class='ctx'> 	struct btrfs_path *path;</div><div class='ctx'> 	struct fiemap_cache cache = { 0 };</div><div class='hunk'>@@ -2942,26 +3026,33 @@ int extent_fiemap(struct btrfs_inode *inode, struct fiemap_extent_info *fieinfo,</div><div class='ctx'> 	bool stopped = false;</div><div class='ctx'> 	int ret;</div><div class='ctx'> </div><div class='add'>+	cache.entries_size = PAGE_SIZE / sizeof(struct btrfs_fiemap_entry);</div><div class='add'>+	cache.entries = kmalloc_array(cache.entries_size,</div><div class='add'>+				      sizeof(struct btrfs_fiemap_entry),</div><div class='add'>+				      GFP_KERNEL);</div><div class='ctx'> 	backref_ctx = btrfs_alloc_backref_share_check_ctx();</div><div class='ctx'> 	path = btrfs_alloc_path();</div><div class='del'>-	if (!backref_ctx || !path) {</div><div class='add'>+	if (!cache.entries || !backref_ctx || !path) {</div><div class='ctx'> 		ret = -ENOMEM;</div><div class='ctx'> 		goto out;</div><div class='ctx'> 	}</div><div class='ctx'> </div><div class='add'>+restart:</div><div class='ctx'> 	range_start = round_down(start, sectorsize);</div><div class='ctx'> 	range_end = round_up(start + len, sectorsize);</div><div class='ctx'> 	prev_extent_end = range_start;</div><div class='ctx'> </div><div class='add'>+	lock_extent(&amp;inode-&gt;io_tree, range_start, range_end, &amp;cached_state);</div><div class='add'>+</div><div class='ctx'> 	ret = fiemap_find_last_extent_offset(inode, path, &amp;last_extent_end);</div><div class='ctx'> 	if (ret &lt; 0)</div><div class='del'>-		goto out;</div><div class='add'>+		goto out_unlock;</div><div class='ctx'> 	btrfs_release_path(path);</div><div class='ctx'> </div><div class='ctx'> 	path-&gt;reada = READA_FORWARD;</div><div class='ctx'> 	ret = fiemap_search_slot(inode, path, range_start);</div><div class='ctx'> 	if (ret &lt; 0) {</div><div class='del'>-		goto out;</div><div class='add'>+		goto out_unlock;</div><div class='ctx'> 	} else if (ret &gt; 0) {</div><div class='ctx'> 		/*</div><div class='ctx'> 		 * No file extent item found, but we may have delalloc between</div><div class='hunk'>@@ -3008,7 +3099,7 @@ int extent_fiemap(struct btrfs_inode *inode, struct fiemap_extent_info *fieinfo,</div><div class='ctx'> 						  backref_ctx, 0, 0, 0,</div><div class='ctx'> 						  prev_extent_end, hole_end);</div><div class='ctx'> 			if (ret &lt; 0) {</div><div class='del'>-				goto out;</div><div class='add'>+				goto out_unlock;</div><div class='ctx'> 			} else if (ret &gt; 0) {</div><div class='ctx'> 				/* fiemap_fill_next_extent() told us to stop. */</div><div class='ctx'> 				stopped = true;</div><div class='hunk'>@@ -3064,7 +3155,7 @@ int extent_fiemap(struct btrfs_inode *inode, struct fiemap_extent_info *fieinfo,</div><div class='ctx'> 								  extent_gen,</div><div class='ctx'> 								  backref_ctx);</div><div class='ctx'> 				if (ret &lt; 0)</div><div class='del'>-					goto out;</div><div class='add'>+					goto out_unlock;</div><div class='ctx'> 				else if (ret &gt; 0)</div><div class='ctx'> 					flags |= FIEMAP_EXTENT_SHARED;</div><div class='ctx'> 			}</div><div class='hunk'>@@ -3075,9 +3166,9 @@ int extent_fiemap(struct btrfs_inode *inode, struct fiemap_extent_info *fieinfo,</div><div class='ctx'> 		}</div><div class='ctx'> </div><div class='ctx'> 		if (ret &lt; 0) {</div><div class='del'>-			goto out;</div><div class='add'>+			goto out_unlock;</div><div class='ctx'> 		} else if (ret &gt; 0) {</div><div class='del'>-			/* fiemap_fill_next_extent() told us to stop. */</div><div class='add'>+			/* emit_fiemap_extent() told us to stop. */</div><div class='ctx'> 			stopped = true;</div><div class='ctx'> 			break;</div><div class='ctx'> 		}</div><div class='hunk'>@@ -3086,12 +3177,12 @@ int extent_fiemap(struct btrfs_inode *inode, struct fiemap_extent_info *fieinfo,</div><div class='ctx'> next_item:</div><div class='ctx'> 		if (fatal_signal_pending(current)) {</div><div class='ctx'> 			ret = -EINTR;</div><div class='del'>-			goto out;</div><div class='add'>+			goto out_unlock;</div><div class='ctx'> 		}</div><div class='ctx'> </div><div class='ctx'> 		ret = fiemap_next_leaf_item(inode, path);</div><div class='ctx'> 		if (ret &lt; 0) {</div><div class='del'>-			goto out;</div><div class='add'>+			goto out_unlock;</div><div class='ctx'> 		} else if (ret &gt; 0) {</div><div class='ctx'> 			/* No more file extent items for this inode. */</div><div class='ctx'> 			break;</div><div class='hunk'>@@ -3100,22 +3191,12 @@ next_item:</div><div class='ctx'> 	}</div><div class='ctx'> </div><div class='ctx'> check_eof_delalloc:</div><div class='del'>-	/*</div><div class='del'>-	 * Release (and free) the path before emitting any final entries to</div><div class='del'>-	 * fiemap_fill_next_extent() to keep lockdep happy. This is because</div><div class='del'>-	 * once we find no more file extent items exist, we may have a</div><div class='del'>-	 * non-cloned leaf, and fiemap_fill_next_extent() can trigger page</div><div class='del'>-	 * faults when copying data to the user space buffer.</div><div class='del'>-	 */</div><div class='del'>-	btrfs_free_path(path);</div><div class='del'>-	path = NULL;</div><div class='del'>-</div><div class='ctx'> 	if (!stopped &amp;&amp; prev_extent_end &lt; range_end) {</div><div class='ctx'> 		ret = fiemap_process_hole(inode, fieinfo, &amp;cache,</div><div class='ctx'> 					  &amp;delalloc_cached_state, backref_ctx,</div><div class='ctx'> 					  0, 0, 0, prev_extent_end, range_end - 1);</div><div class='ctx'> 		if (ret &lt; 0)</div><div class='del'>-			goto out;</div><div class='add'>+			goto out_unlock;</div><div class='ctx'> 		prev_extent_end = range_end;</div><div class='ctx'> 	}</div><div class='ctx'> </div><div class='hunk'>@@ -3123,28 +3204,16 @@ check_eof_delalloc:</div><div class='ctx'> 		const u64 i_size = i_size_read(&amp;inode-&gt;vfs_inode);</div><div class='ctx'> </div><div class='ctx'> 		if (prev_extent_end &lt; i_size) {</div><div class='del'>-			struct extent_state *cached_state = NULL;</div><div class='ctx'> 			u64 delalloc_start;</div><div class='ctx'> 			u64 delalloc_end;</div><div class='del'>-			u64 lockstart;</div><div class='del'>-			u64 lockend;</div><div class='ctx'> 			bool delalloc;</div><div class='ctx'> </div><div class='del'>-			lockstart = round_down(prev_extent_end, sectorsize);</div><div class='del'>-			lockend = round_up(i_size, sectorsize);</div><div class='del'>-</div><div class='del'>-			/*</div><div class='del'>-			 * See the comment in fiemap_process_hole as to why</div><div class='del'>-			 * we're doing the locking here.</div><div class='del'>-			 */</div><div class='del'>-			lock_extent(&amp;inode-&gt;io_tree, lockstart, lockend, &amp;cached_state);</div><div class='ctx'> 			delalloc = btrfs_find_delalloc_in_range(inode,</div><div class='ctx'> 								prev_extent_end,</div><div class='ctx'> 								i_size - 1,</div><div class='ctx'> 								&amp;delalloc_cached_state,</div><div class='ctx'> 								&amp;delalloc_start,</div><div class='ctx'> 								&amp;delalloc_end);</div><div class='del'>-			unlock_extent(&amp;inode-&gt;io_tree, lockstart, lockend, &amp;cached_state);</div><div class='ctx'> 			if (!delalloc)</div><div class='ctx'> 				cache.flags |= FIEMAP_EXTENT_LAST;</div><div class='ctx'> 		} else {</div><div class='hunk'>@@ -3152,9 +3221,39 @@ check_eof_delalloc:</div><div class='ctx'> 		}</div><div class='ctx'> 	}</div><div class='ctx'> </div><div class='add'>+out_unlock:</div><div class='add'>+	unlock_extent(&amp;inode-&gt;io_tree, range_start, range_end, &amp;cached_state);</div><div class='add'>+</div><div class='add'>+	if (ret == BTRFS_FIEMAP_FLUSH_CACHE) {</div><div class='add'>+		btrfs_release_path(path);</div><div class='add'>+		ret = flush_fiemap_cache(fieinfo, &amp;cache);</div><div class='add'>+		if (ret)</div><div class='add'>+			goto out;</div><div class='add'>+		len -= cache.next_search_offset - start;</div><div class='add'>+		start = cache.next_search_offset;</div><div class='add'>+		goto restart;</div><div class='add'>+	} else if (ret &lt; 0) {</div><div class='add'>+		goto out;</div><div class='add'>+	}</div><div class='add'>+</div><div class='add'>+	/*</div><div class='add'>+	 * Must free the path before emitting to the fiemap buffer because we</div><div class='add'>+	 * may have a non-cloned leaf and if the fiemap buffer is memory mapped</div><div class='add'>+	 * to a file, a write into it (through btrfs_page_mkwrite()) may trigger</div><div class='add'>+	 * waiting for an ordered extent that in order to complete needs to</div><div class='add'>+	 * modify that leaf, therefore leading to a deadlock.</div><div class='add'>+	 */</div><div class='add'>+	btrfs_free_path(path);</div><div class='add'>+	path = NULL;</div><div class='add'>+</div><div class='add'>+	ret = flush_fiemap_cache(fieinfo, &amp;cache);</div><div class='add'>+	if (ret)</div><div class='add'>+		goto out;</div><div class='add'>+</div><div class='ctx'> 	ret = emit_last_fiemap_cache(fieinfo, &amp;cache);</div><div class='ctx'> out:</div><div class='ctx'> 	free_extent_state(delalloc_cached_state);</div><div class='add'>+	kfree(cache.entries);</div><div class='ctx'> 	btrfs_free_backref_share_ctx(backref_ctx);</div><div class='ctx'> 	btrfs_free_path(path);</div><div class='ctx'> 	return ret;</div></td></tr></table></div> <!-- class=content -->
<div class='footer'>generated by <a href='https://git.zx2c4.com/cgit/about/'>cgit 1.2.3-korg</a> (<a href='https://git-scm.com/'>git 2.43.0</a>) at 2025-01-11 17:09:16 +0000</div>
</div> <!-- id=cgit -->
</body>
</html>
