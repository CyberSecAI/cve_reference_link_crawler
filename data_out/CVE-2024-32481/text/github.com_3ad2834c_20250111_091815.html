
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fblob%2F9136169468f317a53b4e7448389aa315f90b95ba%2Fvyper%2Fcodegen%2Fstmt.py)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fblob%2F9136169468f317a53b4e7448389aa315f90b95ba%2Fvyper%2Fcodegen%2Fstmt.py)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=vyperlang%2Fvyper)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[vyperlang](/vyperlang)
/
**[vyper](/vyperlang/vyper)**
Public

* [Notifications](/login?return_to=%2Fvyperlang%2Fvyper) You must be signed in to change notification settings
* [Fork
  815](/login?return_to=%2Fvyperlang%2Fvyper)
* [Star
   4.9k](/login?return_to=%2Fvyperlang%2Fvyper)

* [Code](/vyperlang/vyper)
* [Issues
  413](/vyperlang/vyper/issues)
* [Pull requests
  84](/vyperlang/vyper/pulls)
* [Discussions](/vyperlang/vyper/discussions)
* [Actions](/vyperlang/vyper/actions)
* [Projects
  0](/vyperlang/vyper/projects)
* [Wiki](/vyperlang/vyper/wiki)
* [Security](/vyperlang/vyper/security)
* [Insights](/vyperlang/vyper/pulse)

Additional navigation options

* [Code](/vyperlang/vyper)
* [Issues](/vyperlang/vyper/issues)
* [Pull requests](/vyperlang/vyper/pulls)
* [Discussions](/vyperlang/vyper/discussions)
* [Actions](/vyperlang/vyper/actions)
* [Projects](/vyperlang/vyper/projects)
* [Wiki](/vyperlang/vyper/wiki)
* [Security](/vyperlang/vyper/security)
* [Insights](/vyperlang/vyper/pulse)

## Files

 9136169
## Breadcrumbs

1. [vyper](/vyperlang/vyper/tree/9136169468f317a53b4e7448389aa315f90b95ba)
2. /[vyper](/vyperlang/vyper/tree/9136169468f317a53b4e7448389aa315f90b95ba/vyper)
3. /[codegen](/vyperlang/vyper/tree/9136169468f317a53b4e7448389aa315f90b95ba/vyper/codegen)
/
# stmt.py

Copy path Blame  Blame
## Latest commit

## History

[History](/vyperlang/vyper/commits/9136169468f317a53b4e7448389aa315f90b95ba/vyper/codegen/stmt.py)455 lines (372 loc) · 16.5 KB 9136169
## Breadcrumbs

1. [vyper](/vyperlang/vyper/tree/9136169468f317a53b4e7448389aa315f90b95ba)
2. /[vyper](/vyperlang/vyper/tree/9136169468f317a53b4e7448389aa315f90b95ba/vyper)
3. /[codegen](/vyperlang/vyper/tree/9136169468f317a53b4e7448389aa315f90b95ba/vyper/codegen)
/
# stmt.py

Top
## File metadata and controls

* Code
* Blame

455 lines (372 loc) · 16.5 KB[Raw](https://github.com/vyperlang/vyper/raw/9136169468f317a53b4e7448389aa315f90b95ba/vyper/codegen/stmt.py)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455import vyper.codegen.events as eventsimport vyper.utils as utilfrom vyper import ast as vy\_astfrom vyper.builtins.functions import STMT\_DISPATCH\_TABLEfrom vyper.codegen import external\_call, self\_callfrom vyper.codegen.context import Constancy, Contextfrom vyper.codegen.core import ( LOAD, STORE, IRnode, append\_dyn\_array, check\_assign, clamp, dummy\_node\_for\_type, get\_dyn\_array\_count, get\_element\_ptr, getpos, is\_return\_from\_function, make\_byte\_array\_copier, make\_setter, pop\_dyn\_array, zero\_pad,)from vyper.codegen.expr import Exprfrom vyper.codegen.return\_ import make\_return\_stmtfrom vyper.evm.address\_space import MEMORY, STORAGEfrom vyper.exceptions import CompilerPanic, StructureException, TypeCheckFailurefrom vyper.semantics.types import DArrayT, MemberFunctionTfrom vyper.semantics.types.shortcuts import INT256\_T, UINT256\_T
class Stmt: def \_\_init\_\_(self, node: vy\_ast.VyperNode, context: Context) -> None: self.stmt = node self.context = context fn = getattr(self, f"parse\_{type(node).\_\_name\_\_}", None) if fn is None: raise TypeCheckFailure(f"Invalid statement node: {type(node).\_\_name\_\_}")
 with context.internal\_memory\_scope(): self.ir\_node = fn()
 if self.ir\_node is None: raise TypeCheckFailure("Statement node did not produce IR")
 self.ir\_node.annotation = self.stmt.get("node\_source\_code") self.ir\_node.source\_pos = getpos(self.stmt)
 def parse\_Expr(self): # TODO: follow analysis modules and dispatch down to expr.py return Stmt(self.stmt.value, self.context).ir\_node
 def parse\_Pass(self): return IRnode.from\_list("pass")
 def parse\_Name(self): if self.stmt.id == "vdb": return IRnode("debugger") else: raise StructureException(f"Unsupported statement type: {type(self.stmt)}", self.stmt)
 def parse\_AnnAssign(self): ltyp = self.stmt.target.\_metadata["type"] varname = self.stmt.target.id alloced = self.context.new\_variable(varname, ltyp)
 assert self.stmt.value is not None rhs = Expr(self.stmt.value, self.context).ir\_node
 lhs = IRnode.from\_list(alloced, typ=ltyp, location=MEMORY)
 return make\_setter(lhs, rhs)
 def parse\_Assign(self): # Assignment (e.g. x[4] = y) src = Expr(self.stmt.value, self.context).ir\_node dst = self.\_get\_target(self.stmt.target)
 ret = ["seq"] overlap = len(dst.referenced\_variables & src.referenced\_variables) > 0 if overlap and not dst.typ.\_is\_prim\_word: # there is overlap between the lhs and rhs, and the type is # complex - i.e., it spans multiple words. for safety, we # copy to a temporary buffer before copying to the destination. tmp = self.context.new\_internal\_variable(src.typ) tmp = IRnode.from\_list(tmp, typ=src.typ, location=MEMORY) ret.append(make\_setter(tmp, src)) src = tmp
 ret.append(make\_setter(dst, src)) return IRnode.from\_list(ret)
 def parse\_If(self): if self.stmt.orelse: with self.context.block\_scope(): add\_on = [parse\_body(self.stmt.orelse, self.context)] else: add\_on = []
 with self.context.block\_scope(): test\_expr = Expr.parse\_value\_expr(self.stmt.test, self.context) body = ["if", test\_expr, parse\_body(self.stmt.body, self.context)] + add\_on ir\_node = IRnode.from\_list(body) return ir\_node
 def parse\_Log(self): event = self.stmt.\_metadata["type"]
 args = [Expr(arg, self.context).ir\_node for arg in self.stmt.value.args]
 topic\_ir = [] data\_ir = [] for arg, is\_indexed in zip(args, event.indexed): if is\_indexed: topic\_ir.append(arg) else: data\_ir.append(arg)
 return events.ir\_node\_for\_log(self.stmt, event, topic\_ir, data\_ir, self.context)
 def parse\_Call(self): # TODO use expr.func.type.is\_internal once type annotations # are consistently available. is\_self\_function = ( (isinstance(self.stmt.func, vy\_ast.Attribute)) and isinstance(self.stmt.func.value, vy\_ast.Name) and self.stmt.func.value.id == "self" )
 if isinstance(self.stmt.func, vy\_ast.Name): funcname = self.stmt.func.id return STMT\_DISPATCH\_TABLE[funcname].build\_IR(self.stmt, self.context)
 elif isinstance(self.stmt.func, vy\_ast.Attribute) and self.stmt.func.attr in ( "append", "pop", ): func\_type = self.stmt.func.\_metadata["type"] if isinstance(func\_type, MemberFunctionT): darray = Expr(self.stmt.func.value, self.context).ir\_node args = [Expr(x, self.context).ir\_node for x in self.stmt.args] if self.stmt.func.attr == "append": # sanity checks assert len(args) == 1 arg = args[0] assert isinstance(darray.typ, DArrayT) check\_assign( dummy\_node\_for\_type(darray.typ.value\_type), dummy\_node\_for\_type(arg.typ) )
 return append\_dyn\_array(darray, arg) else: assert len(args) == 0 return pop\_dyn\_array(darray, return\_popped\_item=False)
 if is\_self\_function: return self\_call.ir\_for\_self\_call(self.stmt, self.context) else: return external\_call.ir\_for\_external\_call(self.stmt, self.context)
 def \_assert\_reason(self, test\_expr, msg): # from parse\_Raise: None passed as the assert condition is\_raise = test\_expr is None
 if isinstance(msg, vy\_ast.Name) and msg.id == "UNREACHABLE": if is\_raise: return IRnode.from\_list(["invalid"], error\_msg="raise unreachable") else: return IRnode.from\_list( ["assert\_unreachable", test\_expr], error\_msg="assert unreachable" )
 # set constant so that revert reason str is well behaved try: tmp = self.context.constancy self.context.constancy = Constancy.Constant msg\_ir = Expr(msg, self.context).ir\_node finally: self.context.constancy = tmp
 # TODO this is probably useful in codegen.core # compare with eval\_seq. def \_get\_last(ir): if len(ir.args) == 0: return ir.value return \_get\_last(ir.args[-1])
 # TODO maybe use ensure\_in\_memory if msg\_ir.location != MEMORY: buf = self.context.new\_internal\_variable(msg\_ir.typ) instantiate\_msg = make\_byte\_array\_copier(buf, msg\_ir) else: buf = \_get\_last(msg\_ir) if not isinstance(buf, int): raise CompilerPanic(f"invalid bytestring {buf}\n{self}") instantiate\_msg = msg\_ir
 # offset of bytes in (bytes,) method\_id = util.method\_id\_int("Error(string)")
 # abi encode method\_id + bytestring assert buf >= 36, "invalid buffer" # we don't mind overwriting other memory because we are # getting out of here anyway. \_runtime\_length = ["mload", buf] revert\_seq = [ "seq", instantiate\_msg, zero\_pad(buf), ["mstore", buf - 64, method\_id], ["mstore", buf - 32, 0x20], ["revert", buf - 36, ["add", 4 + 32 + 32, ["ceil32", \_runtime\_length]]], ] if is\_raise: ir\_node = revert\_seq else: ir\_node = ["if", ["iszero", test\_expr], revert\_seq] return IRnode.from\_list(ir\_node, error\_msg="user revert with reason")
 def parse\_Assert(self): test\_expr = Expr.parse\_value\_expr(self.stmt.test, self.context)
 if self.stmt.msg: return self.\_assert\_reason(test\_expr, self.stmt.msg) else: return IRnode.from\_list(["assert", test\_expr], error\_msg="user assert")
 def parse\_Raise(self): if self.stmt.exc: return self.\_assert\_reason(None, self.stmt.exc) else: return IRnode.from\_list(["revert", 0, 0], error\_msg="user raise")
 def \_check\_valid\_range\_constant(self, arg\_ast\_node): with self.context.range\_scope(): arg\_expr = Expr.parse\_value\_expr(arg\_ast\_node, self.context) return arg\_expr
 def \_get\_range\_const\_value(self, arg\_ast\_node): arg\_expr = self.\_check\_valid\_range\_constant(arg\_ast\_node) return arg\_expr.value
 def parse\_For(self): with self.context.block\_scope(): if self.stmt.get("iter.func.id") == "range": return self.\_parse\_For\_range() else: return self.\_parse\_For\_list()
 def \_parse\_For\_range(self): # TODO make sure type always gets annotated if "type" in self.stmt.target.\_metadata: iter\_typ = self.stmt.target.\_metadata["type"] else: iter\_typ = INT256\_T
 # Get arg0 arg0 = self.stmt.iter.args[0] num\_of\_args = len(self.stmt.iter.args)
 kwargs = { s.arg: Expr.parse\_value\_expr(s.value, self.context) for s in self.stmt.iter.keywords or [] }
 # Type 1 for, e.g. for i in range(10): ... if num\_of\_args == 1: n = Expr.parse\_value\_expr(arg0, self.context) start = IRnode.from\_list(0, typ=iter\_typ) rounds = n rounds\_bound = kwargs.get("bound", rounds)
 # Type 2 for, e.g. for i in range(100, 110): ... elif self.\_check\_valid\_range\_constant(self.stmt.iter.args[1]).is\_literal: arg0\_val = self.\_get\_range\_const\_value(arg0) arg1\_val = self.\_get\_range\_const\_value(self.stmt.iter.args[1]) start = IRnode.from\_list(arg0\_val, typ=iter\_typ) rounds = IRnode.from\_list(arg1\_val - arg0\_val, typ=iter\_typ) rounds\_bound = rounds
 # Type 3 for, e.g. for i in range(x, x + 10): ... else: arg1 = self.stmt.iter.args[1] rounds = self.\_get\_range\_const\_value(arg1.right) start = Expr.parse\_value\_expr(arg0, self.context) \_, hi = start.typ.int\_bounds start = clamp("le", start, hi + 1 - rounds) rounds\_bound = rounds
 bound = rounds\_bound if isinstance(rounds\_bound, int) else rounds\_bound.value if bound < 1: return
 varname = self.stmt.target.id i = IRnode.from\_list(self.context.fresh\_varname("range\_ix"), typ=UINT256\_T) iptr = self.context.new\_variable(varname, iter\_typ)
 self.context.forvars[varname] = True
 loop\_body = ["seq"] # store the current value of i so it is accessible to userland loop\_body.append(["mstore", iptr, i]) loop\_body.append(parse\_body(self.stmt.body, self.context))
 # NOTE: codegen for `repeat` inserts an assertion that # (gt rounds\_bound rounds). note this also covers the case where # rounds < 0. # if we ever want to remove that, we need to manually add the assertion # where it makes sense. ir\_node = IRnode.from\_list( ["repeat", i, start, rounds, rounds\_bound, loop\_body], error\_msg="range() bounds check" ) del self.context.forvars[varname]
 return ir\_node
 def \_parse\_For\_list(self): with self.context.range\_scope(): iter\_list = Expr(self.stmt.iter, self.context).ir\_node
 target\_type = self.stmt.target.\_metadata["type"] assert target\_type == iter\_list.typ.value\_type
 # user-supplied name for loop variable varname = self.stmt.target.id loop\_var = IRnode.from\_list( self.context.new\_variable(varname, target\_type), typ=target\_type, location=MEMORY )
 i = IRnode.from\_list(self.context.fresh\_varname("for\_list\_ix"), typ=UINT256\_T)
 self.context.forvars[varname] = True
 ret = ["seq"]
 # list literal, force it to memory first if isinstance(self.stmt.iter, vy\_ast.List): tmp\_list = IRnode.from\_list( self.context.new\_internal\_variable(iter\_list.typ), typ=iter\_list.typ, location=MEMORY, ) ret.append(make\_setter(tmp\_list, iter\_list)) iter\_list = tmp\_list
 # set up the loop variable e = get\_element\_ptr(iter\_list, i, array\_bounds\_check=False) body = ["seq", make\_setter(loop\_var, e), parse\_body(self.stmt.body, self.context)]
 repeat\_bound = iter\_list.typ.count if isinstance(iter\_list.typ, DArrayT): array\_len = get\_dyn\_array\_count(iter\_list) else: array\_len = repeat\_bound
 ret.append(["repeat", i, 0, array\_len, repeat\_bound, body])
 del self.context.forvars[varname] return IRnode.from\_list(ret)
 def parse\_AugAssign(self): target = self.\_get\_target(self.stmt.target)
 sub = Expr.parse\_value\_expr(self.stmt.value, self.context) if not target.typ.\_is\_prim\_word: # because of this check, we do not need to check for # make\_setter references lhs<->rhs as in parse\_Assign - # single word load/stores are atomic. return
 with target.cache\_when\_complex("\_loc") as (b, target): rhs = Expr.parse\_value\_expr( vy\_ast.BinOp( left=IRnode.from\_list(LOAD(target), typ=target.typ), right=sub, op=self.stmt.op, lineno=self.stmt.lineno, col\_offset=self.stmt.col\_offset, end\_lineno=self.stmt.end\_lineno, end\_col\_offset=self.stmt.end\_col\_offset, node\_source\_code=self.stmt.get("node\_source\_code"), ), self.context, ) return b.resolve(STORE(target, rhs))
 def parse\_Continue(self): return IRnode.from\_list("continue")
 def parse\_Break(self): return IRnode.from\_list("break")
 def parse\_Return(self): ir\_val = None if self.stmt.value is not None: ir\_val = Expr(self.stmt.value, self.context).ir\_node return make\_return\_stmt(ir\_val, self.stmt, self.context)
 def \_get\_target(self, target): \_dbg\_expr = target
 if isinstance(target, vy\_ast.Name) and target.id in self.context.forvars: raise TypeCheckFailure(f"Failed constancy check\n{\_dbg\_expr}")
 if isinstance(target, vy\_ast.Tuple): target = Expr(target, self.context).ir\_node for node in target.args: if (node.location == STORAGE and self.context.is\_constant()) or not node.mutable: raise TypeCheckFailure(f"Failed constancy check\n{\_dbg\_expr}") return target
 target = Expr.parse\_pointer\_expr(target, self.context) if (target.location == STORAGE and self.context.is\_constant()) or not target.mutable: raise TypeCheckFailure(f"Failed constancy check\n{\_dbg\_expr}") return target
# Parse a statement (usually one line of code but not always)def parse\_stmt(stmt, context): return Stmt(stmt, context).ir\_node
# check if a function body is "terminated"# a function is terminated if it ends with a return stmt, OR,# it ends with an if/else and both branches are terminated.# (if not, we need to insert a terminator so that the IR is well-formed)def \_is\_terminated(code): last\_stmt = code[-1]
 if is\_return\_from\_function(last\_stmt): return True
 if isinstance(last\_stmt, vy\_ast.If): if last\_stmt.orelse: return \_is\_terminated(last\_stmt.body) and \_is\_terminated(last\_stmt.orelse) return False
# codegen a list of statementsdef parse\_body(code, context, ensure\_terminated=False): if not isinstance(code, list): return parse\_stmt(code, context)
 ir\_node = ["seq"] for stmt in code: ir = parse\_stmt(stmt, context) ir\_node.append(ir)
 # force using the return routine / exit\_to cleanup for end of function if ensure\_terminated and context.return\_type is None and not \_is\_terminated(code): ir\_node.append(parse\_stmt(vy\_ast.Return(value=None), context))
 # force zerovalent, even last statement ir\_node.append("pass") # CMC 2022-01-16 is this necessary? return IRnode.from\_list(ir\_node)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

