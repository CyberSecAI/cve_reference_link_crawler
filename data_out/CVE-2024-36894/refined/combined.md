=== Content from git.kernel.org_c69c0bea_20250111_192211.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=f71a53148ce34898fef099b75386a3a9f4449311)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f71a53148ce34898fef099b75386a3a9f4449311)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f71a53148ce34898fef099b75386a3a9f4449311)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f71a53148ce34898fef099b75386a3a9f4449311)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Wesley Cheng <quic\_wcheng@quicinc.com> | 2024-04-08 18:40:59 -0700 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-07-05 09:00:21 +0200 |
| commit | [f71a53148ce34898fef099b75386a3a9f4449311](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f71a53148ce34898fef099b75386a3a9f4449311) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=f71a53148ce34898fef099b75386a3a9f4449311)) | |
| tree | [622e644a27d3b4afd3a8ba2ad596d48f962b4be6](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f71a53148ce34898fef099b75386a3a9f4449311) | |
| parent | [9c2d206ddc697595ceb0e8e356c64f9e845a0c2f](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9c2d206ddc697595ceb0e8e356c64f9e845a0c2f) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f71a53148ce34898fef099b75386a3a9f4449311&id2=9c2d206ddc697595ceb0e8e356c64f9e845a0c2f)) | |
| download | [linux-f71a53148ce34898fef099b75386a3a9f4449311.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-f71a53148ce34898fef099b75386a3a9f4449311.tar.gz) | |

usb: gadget: f\_fs: Fix race between aio\_cancel() and AIO request complete[ Upstream commit 24729b307eefcd7c476065cd7351c1a018082c19 ]
FFS based applications can utilize the aio\_cancel() callback to dequeue
pending USB requests submitted to the UDC. There is a scenario where the
FFS application issues an AIO cancel call, while the UDC is handling a
soft disconnect. For a DWC3 based implementation, the callstack looks
like the following:
DWC3 Gadget FFS Application
dwc3\_gadget\_soft\_disconnect() ...
--> dwc3\_stop\_active\_transfers()
--> dwc3\_gadget\_giveback(-ESHUTDOWN)
--> ffs\_epfile\_async\_io\_complete() ffs\_aio\_cancel()
--> usb\_ep\_free\_request() --> usb\_ep\_dequeue()
There is currently no locking implemented between the AIO completion
handler and AIO cancel, so the issue occurs if the completion routine is
running in parallel to an AIO cancel call coming from the FFS application.
As the completion call frees the USB request (io\_data->req) the FFS
application is also referencing it for the usb\_ep\_dequeue() call. This can
lead to accessing a stale/hanging pointer.
commit b566d38857fc ("usb: gadget: f\_fs: use io\_data->status consistently")
relocated the usb\_ep\_free\_request() into ffs\_epfile\_async\_io\_complete().
However, in order to properly implement locking to mitigate this issue, the
spinlock can't be added to ffs\_epfile\_async\_io\_complete(), as
usb\_ep\_dequeue() (if successfully dequeuing a USB request) will call the
function driver's completion handler in the same context. Hence, leading
into a deadlock.
Fix this issue by moving the usb\_ep\_free\_request() back to
ffs\_user\_copy\_worker(), and ensuring that it explicitly sets io\_data->req
to NULL after freeing it within the ffs->eps\_lock. This resolves the race
condition above, as the ffs\_aio\_cancel() routine will not continue
attempting to dequeue a request that has already been freed, or the
ffs\_user\_copy\_work() not freeing the USB request until the AIO cancel is
done referencing it.
This fix depends on
commit b566d38857fc ("usb: gadget: f\_fs: use io\_data->status
consistently")
Fixes: 2e4c7553cd6f ("usb: gadget: f\_fs: add aio support")
Cc: stable <stable@kernel.org> # b566d38857fc ("usb: gadget: f\_fs: use io\_data->status consistently")
Signed-off-by: Wesley Cheng <quic\_wcheng@quicinc.com>
Link: [https://lore.kernel.org/r/20240409014059.6740-1-quic\_wcheng@quicinc.com](https://lore.kernel.org/r/20240409014059.6740-1-quic_wcheng%40quicinc.com)
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f71a53148ce34898fef099b75386a3a9f4449311)

| -rw-r--r-- | [drivers/usb/gadget/function/f\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/usb/gadget/function/f_fs.c?id=f71a53148ce34898fef099b75386a3a9f4449311) | 4 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 4 insertions, 0 deletions

| diff --git a/drivers/usb/gadget/function/f\_fs.c b/drivers/usb/gadget/function/f\_fs.cindex 7294586b08dc09..0d8dae1797a97b 100644--- a/[drivers/usb/gadget/function/f\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/gadget/function/f_fs.c?id=9c2d206ddc697595ceb0e8e356c64f9e845a0c2f)+++ b/[drivers/usb/gadget/function/f\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/gadget/function/f_fs.c?id=f71a53148ce34898fef099b75386a3a9f4449311)@@ -761,6 +761,7 @@ static void ffs\_user\_copy\_worker(struct work\_struct \*work) int ret = io\_data->req->status ? io\_data->req->status : io\_data->req->actual; bool kiocb\_has\_eventfd = io\_data->kiocb->ki\_flags & IOCB\_EVENTFD;+ unsigned long flags;  if (io\_data->read && ret > 0) { mm\_segment\_t oldfs = get\_fs();@@ -777,7 +778,10 @@ static void ffs\_user\_copy\_worker(struct work\_struct \*work) if (io\_data->ffs->ffs\_eventfd && !kiocb\_has\_eventfd) eventfd\_signal(io\_data->ffs->ffs\_eventfd, 1); + spin\_lock\_irqsave(&io\_data->ffs->eps\_lock, flags); usb\_ep\_free\_request(io\_data->ep, io\_data->req);+ io\_data->req = NULL;+ spin\_unlock\_irqrestore(&io\_data->ffs->eps\_lock, flags);  if (io\_data->read) kfree(io\_data->to\_free); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 19:20:48 +0000



=== Content from git.kernel.org_08fb9e81_20250111_192208.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=73c05ad46bb4fbbdb346004651576d1c8dbcffbb)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=73c05ad46bb4fbbdb346004651576d1c8dbcffbb)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=73c05ad46bb4fbbdb346004651576d1c8dbcffbb)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=73c05ad46bb4fbbdb346004651576d1c8dbcffbb)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Wesley Cheng <quic\_wcheng@quicinc.com> | 2024-04-08 18:40:59 -0700 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-05-17 12:02:28 +0200 |
| commit | [73c05ad46bb4fbbdb346004651576d1c8dbcffbb](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=73c05ad46bb4fbbdb346004651576d1c8dbcffbb) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=73c05ad46bb4fbbdb346004651576d1c8dbcffbb)) | |
| tree | [4b6c2dc3256b242c128f7a17bb8f357140e3cced](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=73c05ad46bb4fbbdb346004651576d1c8dbcffbb) | |
| parent | [7a54e5052bde582fd0e7677334fe7a5be92e242c](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7a54e5052bde582fd0e7677334fe7a5be92e242c) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=73c05ad46bb4fbbdb346004651576d1c8dbcffbb&id2=7a54e5052bde582fd0e7677334fe7a5be92e242c)) | |
| download | [linux-73c05ad46bb4fbbdb346004651576d1c8dbcffbb.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-73c05ad46bb4fbbdb346004651576d1c8dbcffbb.tar.gz) | |

usb: gadget: f\_fs: Fix race between aio\_cancel() and AIO request completecommit 24729b307eefcd7c476065cd7351c1a018082c19 upstream.
FFS based applications can utilize the aio\_cancel() callback to dequeue
pending USB requests submitted to the UDC. There is a scenario where the
FFS application issues an AIO cancel call, while the UDC is handling a
soft disconnect. For a DWC3 based implementation, the callstack looks
like the following:
DWC3 Gadget FFS Application
dwc3\_gadget\_soft\_disconnect() ...
--> dwc3\_stop\_active\_transfers()
--> dwc3\_gadget\_giveback(-ESHUTDOWN)
--> ffs\_epfile\_async\_io\_complete() ffs\_aio\_cancel()
--> usb\_ep\_free\_request() --> usb\_ep\_dequeue()
There is currently no locking implemented between the AIO completion
handler and AIO cancel, so the issue occurs if the completion routine is
running in parallel to an AIO cancel call coming from the FFS application.
As the completion call frees the USB request (io\_data->req) the FFS
application is also referencing it for the usb\_ep\_dequeue() call. This can
lead to accessing a stale/hanging pointer.
commit b566d38857fc ("usb: gadget: f\_fs: use io\_data->status consistently")
relocated the usb\_ep\_free\_request() into ffs\_epfile\_async\_io\_complete().
However, in order to properly implement locking to mitigate this issue, the
spinlock can't be added to ffs\_epfile\_async\_io\_complete(), as
usb\_ep\_dequeue() (if successfully dequeuing a USB request) will call the
function driver's completion handler in the same context. Hence, leading
into a deadlock.
Fix this issue by moving the usb\_ep\_free\_request() back to
ffs\_user\_copy\_worker(), and ensuring that it explicitly sets io\_data->req
to NULL after freeing it within the ffs->eps\_lock. This resolves the race
condition above, as the ffs\_aio\_cancel() routine will not continue
attempting to dequeue a request that has already been freed, or the
ffs\_user\_copy\_work() not freeing the USB request until the AIO cancel is
done referencing it.
This fix depends on
commit b566d38857fc ("usb: gadget: f\_fs: use io\_data->status
consistently")
Fixes: 2e4c7553cd6f ("usb: gadget: f\_fs: add aio support")
Cc: stable <stable@kernel.org> # b566d38857fc ("usb: gadget: f\_fs: use io\_data->status consistently")
Signed-off-by: Wesley Cheng <quic\_wcheng@quicinc.com>
Link: [https://lore.kernel.org/r/20240409014059.6740-1-quic\_wcheng@quicinc.com](https://lore.kernel.org/r/20240409014059.6740-1-quic_wcheng%40quicinc.com)
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=73c05ad46bb4fbbdb346004651576d1c8dbcffbb)

| -rw-r--r-- | [drivers/usb/gadget/function/f\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/usb/gadget/function/f_fs.c?id=73c05ad46bb4fbbdb346004651576d1c8dbcffbb) | 7 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 6 insertions, 1 deletions

| diff --git a/drivers/usb/gadget/function/f\_fs.c b/drivers/usb/gadget/function/f\_fs.cindex 6e9ef35a43a7ba..4cfd0f14c57366 100644--- a/[drivers/usb/gadget/function/f\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/gadget/function/f_fs.c?id=7a54e5052bde582fd0e7677334fe7a5be92e242c)+++ b/[drivers/usb/gadget/function/f\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/gadget/function/f_fs.c?id=73c05ad46bb4fbbdb346004651576d1c8dbcffbb)@@ -821,6 +821,7 @@ static void ffs\_user\_copy\_worker(struct work\_struct \*work) work); int ret = io\_data->status; bool kiocb\_has\_eventfd = io\_data->kiocb->ki\_flags & IOCB\_EVENTFD;+ unsigned long flags;  if (io\_data->read && ret > 0) { kthread\_use\_mm(io\_data->mm);@@ -833,6 +834,11 @@ static void ffs\_user\_copy\_worker(struct work\_struct \*work) if (io\_data->ffs->ffs\_eventfd && !kiocb\_has\_eventfd) eventfd\_signal(io\_data->ffs->ffs\_eventfd, 1); + spin\_lock\_irqsave(&io\_data->ffs->eps\_lock, flags);+ usb\_ep\_free\_request(io\_data->ep, io\_data->req);+ io\_data->req = NULL;+ spin\_unlock\_irqrestore(&io\_data->ffs->eps\_lock, flags);+ if (io\_data->read) kfree(io\_data->to\_free); ffs\_free\_buffer(io\_data);@@ -846,7 +852,6 @@ static void ffs\_epfile\_async\_io\_complete(struct usb\_ep \*\_ep, struct ffs\_data \*ffs = io\_data->ffs;  io\_data->status = req->status ? req->status : req->actual;- usb\_ep\_free\_request(\_ep, req);  INIT\_WORK(&io\_data->work, ffs\_user\_copy\_worker); queue\_work(ffs->io\_completion\_wq, &io\_data->work); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 19:20:45 +0000



=== Content from git.kernel.org_f2bca10f_20250111_192208.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=3613e5023f09b3308545e9d1acda86017ebd418a)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=3613e5023f09b3308545e9d1acda86017ebd418a)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3613e5023f09b3308545e9d1acda86017ebd418a)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3613e5023f09b3308545e9d1acda86017ebd418a)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Wesley Cheng <quic\_wcheng@quicinc.com> | 2024-04-08 18:40:59 -0700 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-07-05 09:14:09 +0200 |
| commit | [3613e5023f09b3308545e9d1acda86017ebd418a](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3613e5023f09b3308545e9d1acda86017ebd418a) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=3613e5023f09b3308545e9d1acda86017ebd418a)) | |
| tree | [c68c57c0d2e47e64a0715b9d21fe939bf5086a1c](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=3613e5023f09b3308545e9d1acda86017ebd418a) | |
| parent | [3ec6464f050d6f512abca42baad1146539b907fb](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3ec6464f050d6f512abca42baad1146539b907fb) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3613e5023f09b3308545e9d1acda86017ebd418a&id2=3ec6464f050d6f512abca42baad1146539b907fb)) | |
| download | [linux-3613e5023f09b3308545e9d1acda86017ebd418a.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-3613e5023f09b3308545e9d1acda86017ebd418a.tar.gz) | |

usb: gadget: f\_fs: Fix race between aio\_cancel() and AIO request complete[ Upstream commit 24729b307eefcd7c476065cd7351c1a018082c19 ]
FFS based applications can utilize the aio\_cancel() callback to dequeue
pending USB requests submitted to the UDC. There is a scenario where the
FFS application issues an AIO cancel call, while the UDC is handling a
soft disconnect. For a DWC3 based implementation, the callstack looks
like the following:
DWC3 Gadget FFS Application
dwc3\_gadget\_soft\_disconnect() ...
--> dwc3\_stop\_active\_transfers()
--> dwc3\_gadget\_giveback(-ESHUTDOWN)
--> ffs\_epfile\_async\_io\_complete() ffs\_aio\_cancel()
--> usb\_ep\_free\_request() --> usb\_ep\_dequeue()
There is currently no locking implemented between the AIO completion
handler and AIO cancel, so the issue occurs if the completion routine is
running in parallel to an AIO cancel call coming from the FFS application.
As the completion call frees the USB request (io\_data->req) the FFS
application is also referencing it for the usb\_ep\_dequeue() call. This can
lead to accessing a stale/hanging pointer.
commit b566d38857fc ("usb: gadget: f\_fs: use io\_data->status consistently")
relocated the usb\_ep\_free\_request() into ffs\_epfile\_async\_io\_complete().
However, in order to properly implement locking to mitigate this issue, the
spinlock can't be added to ffs\_epfile\_async\_io\_complete(), as
usb\_ep\_dequeue() (if successfully dequeuing a USB request) will call the
function driver's completion handler in the same context. Hence, leading
into a deadlock.
Fix this issue by moving the usb\_ep\_free\_request() back to
ffs\_user\_copy\_worker(), and ensuring that it explicitly sets io\_data->req
to NULL after freeing it within the ffs->eps\_lock. This resolves the race
condition above, as the ffs\_aio\_cancel() routine will not continue
attempting to dequeue a request that has already been freed, or the
ffs\_user\_copy\_work() not freeing the USB request until the AIO cancel is
done referencing it.
This fix depends on
commit b566d38857fc ("usb: gadget: f\_fs: use io\_data->status
consistently")
Fixes: 2e4c7553cd6f ("usb: gadget: f\_fs: add aio support")
Cc: stable <stable@kernel.org> # b566d38857fc ("usb: gadget: f\_fs: use io\_data->status consistently")
Signed-off-by: Wesley Cheng <quic\_wcheng@quicinc.com>
Link: [https://lore.kernel.org/r/20240409014059.6740-1-quic\_wcheng@quicinc.com](https://lore.kernel.org/r/20240409014059.6740-1-quic_wcheng%40quicinc.com)
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3613e5023f09b3308545e9d1acda86017ebd418a)

| -rw-r--r-- | [drivers/usb/gadget/function/f\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/usb/gadget/function/f_fs.c?id=3613e5023f09b3308545e9d1acda86017ebd418a) | 7 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 6 insertions, 1 deletions

| diff --git a/drivers/usb/gadget/function/f\_fs.c b/drivers/usb/gadget/function/f\_fs.cindex 37d18e27ddc645..ad858044e0bfd1 100644--- a/[drivers/usb/gadget/function/f\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/gadget/function/f_fs.c?id=3ec6464f050d6f512abca42baad1146539b907fb)+++ b/[drivers/usb/gadget/function/f\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/gadget/function/f_fs.c?id=3613e5023f09b3308545e9d1acda86017ebd418a)@@ -832,6 +832,7 @@ static void ffs\_user\_copy\_worker(struct work\_struct \*work) work); int ret = io\_data->status; bool kiocb\_has\_eventfd = io\_data->kiocb->ki\_flags & IOCB\_EVENTFD;+ unsigned long flags;  if (io\_data->read && ret > 0) { kthread\_use\_mm(io\_data->mm);@@ -844,6 +845,11 @@ static void ffs\_user\_copy\_worker(struct work\_struct \*work) if (io\_data->ffs->ffs\_eventfd && !kiocb\_has\_eventfd) eventfd\_signal(io\_data->ffs->ffs\_eventfd, 1); + spin\_lock\_irqsave(&io\_data->ffs->eps\_lock, flags);+ usb\_ep\_free\_request(io\_data->ep, io\_data->req);+ io\_data->req = NULL;+ spin\_unlock\_irqrestore(&io\_data->ffs->eps\_lock, flags);+ if (io\_data->read) kfree(io\_data->to\_free); ffs\_free\_buffer(io\_data);@@ -859,7 +865,6 @@ static void ffs\_epfile\_async\_io\_complete(struct usb\_ep \*\_ep, ENTER();  io\_data->status = req->status ? req->status : req->actual;- usb\_ep\_free\_request(\_ep, req);  INIT\_WORK(&io\_data->work, ffs\_user\_copy\_worker); queue\_work(ffs->io\_completion\_wq, &io\_data->work); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 19:20:45 +0000



=== Content from git.kernel.org_5e6d216f_20250111_192207.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=24729b307eefcd7c476065cd7351c1a018082c19)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=24729b307eefcd7c476065cd7351c1a018082c19)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=24729b307eefcd7c476065cd7351c1a018082c19)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=24729b307eefcd7c476065cd7351c1a018082c19)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Wesley Cheng <quic\_wcheng@quicinc.com> | 2024-04-08 18:40:59 -0700 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-04-23 16:10:55 -0700 |
| commit | [24729b307eefcd7c476065cd7351c1a018082c19](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=24729b307eefcd7c476065cd7351c1a018082c19) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=24729b307eefcd7c476065cd7351c1a018082c19)) | |
| tree | [07a2f2a8ad6d954eb3c48d4aac61a9bedd7dfb49](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=24729b307eefcd7c476065cd7351c1a018082c19) | |
| parent | [ed30a4a51bb196781c8058073ea720133a65596f](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ed30a4a51bb196781c8058073ea720133a65596f) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=24729b307eefcd7c476065cd7351c1a018082c19&id2=ed30a4a51bb196781c8058073ea720133a65596f)) | |
| download | [linux-24729b307eefcd7c476065cd7351c1a018082c19.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-24729b307eefcd7c476065cd7351c1a018082c19.tar.gz) | |

usb: gadget: f\_fs: Fix race between aio\_cancel() and AIO request completeFFS based applications can utilize the aio\_cancel() callback to dequeue
pending USB requests submitted to the UDC. There is a scenario where the
FFS application issues an AIO cancel call, while the UDC is handling a
soft disconnect. For a DWC3 based implementation, the callstack looks
like the following:
DWC3 Gadget FFS Application
dwc3\_gadget\_soft\_disconnect() ...
--> dwc3\_stop\_active\_transfers()
--> dwc3\_gadget\_giveback(-ESHUTDOWN)
--> ffs\_epfile\_async\_io\_complete() ffs\_aio\_cancel()
--> usb\_ep\_free\_request() --> usb\_ep\_dequeue()
There is currently no locking implemented between the AIO completion
handler and AIO cancel, so the issue occurs if the completion routine is
running in parallel to an AIO cancel call coming from the FFS application.
As the completion call frees the USB request (io\_data->req) the FFS
application is also referencing it for the usb\_ep\_dequeue() call. This can
lead to accessing a stale/hanging pointer.
commit b566d38857fc ("usb: gadget: f\_fs: use io\_data->status consistently")
relocated the usb\_ep\_free\_request() into ffs\_epfile\_async\_io\_complete().
However, in order to properly implement locking to mitigate this issue, the
spinlock can't be added to ffs\_epfile\_async\_io\_complete(), as
usb\_ep\_dequeue() (if successfully dequeuing a USB request) will call the
function driver's completion handler in the same context. Hence, leading
into a deadlock.
Fix this issue by moving the usb\_ep\_free\_request() back to
ffs\_user\_copy\_worker(), and ensuring that it explicitly sets io\_data->req
to NULL after freeing it within the ffs->eps\_lock. This resolves the race
condition above, as the ffs\_aio\_cancel() routine will not continue
attempting to dequeue a request that has already been freed, or the
ffs\_user\_copy\_work() not freeing the USB request until the AIO cancel is
done referencing it.
This fix depends on
commit b566d38857fc ("usb: gadget: f\_fs: use io\_data->status
consistently")
Fixes: 2e4c7553cd6f ("usb: gadget: f\_fs: add aio support")
Cc: stable <stable@kernel.org> # b566d38857fc ("usb: gadget: f\_fs: use io\_data->status consistently")
Signed-off-by: Wesley Cheng <quic\_wcheng@quicinc.com>
Link: [https://lore.kernel.org/r/20240409014059.6740-1-quic\_wcheng@quicinc.com](https://lore.kernel.org/r/20240409014059.6740-1-quic_wcheng%40quicinc.com)
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=24729b307eefcd7c476065cd7351c1a018082c19)

| -rw-r--r-- | [drivers/usb/gadget/function/f\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/usb/gadget/function/f_fs.c?id=24729b307eefcd7c476065cd7351c1a018082c19) | 7 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 6 insertions, 1 deletions

| diff --git a/drivers/usb/gadget/function/f\_fs.c b/drivers/usb/gadget/function/f\_fs.cindex f855f1fc8e5e14..aa80c2a6b8e070 100644--- a/[drivers/usb/gadget/function/f\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/gadget/function/f_fs.c?id=ed30a4a51bb196781c8058073ea720133a65596f)+++ b/[drivers/usb/gadget/function/f\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/gadget/function/f_fs.c?id=24729b307eefcd7c476065cd7351c1a018082c19)@@ -852,6 +852,7 @@ static void ffs\_user\_copy\_worker(struct work\_struct \*work) work); int ret = io\_data->status; bool kiocb\_has\_eventfd = io\_data->kiocb->ki\_flags & IOCB\_EVENTFD;+ unsigned long flags;  if (io\_data->read && ret > 0) { kthread\_use\_mm(io\_data->mm);@@ -864,6 +865,11 @@ static void ffs\_user\_copy\_worker(struct work\_struct \*work) if (io\_data->ffs->ffs\_eventfd && !kiocb\_has\_eventfd) eventfd\_signal(io\_data->ffs->ffs\_eventfd); + spin\_lock\_irqsave(&io\_data->ffs->eps\_lock, flags);+ usb\_ep\_free\_request(io\_data->ep, io\_data->req);+ io\_data->req = NULL;+ spin\_unlock\_irqrestore(&io\_data->ffs->eps\_lock, flags);+ if (io\_data->read) kfree(io\_data->to\_free); ffs\_free\_buffer(io\_data);@@ -877,7 +883,6 @@ static void ffs\_epfile\_async\_io\_complete(struct usb\_ep \*\_ep, struct ffs\_data \*ffs = io\_data->ffs;  io\_data->status = req->status ? req->status : req->actual;- usb\_ep\_free\_request(\_ep, req);  INIT\_WORK(&io\_data->work, ffs\_user\_copy\_worker); queue\_work(ffs->io\_completion\_wq, &io\_data->work); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 19:20:44 +0000



=== Content from git.kernel.org_5115f3ff_20250111_192210.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=e500b1c4e29ad0bd1c1332a1eaea2913627a92dd)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=e500b1c4e29ad0bd1c1332a1eaea2913627a92dd)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e500b1c4e29ad0bd1c1332a1eaea2913627a92dd)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e500b1c4e29ad0bd1c1332a1eaea2913627a92dd)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Wesley Cheng <quic\_wcheng@quicinc.com> | 2024-04-08 18:40:59 -0700 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-07-05 09:12:24 +0200 |
| commit | [e500b1c4e29ad0bd1c1332a1eaea2913627a92dd](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e500b1c4e29ad0bd1c1332a1eaea2913627a92dd) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=e500b1c4e29ad0bd1c1332a1eaea2913627a92dd)) | |
| tree | [7ec799fc62aef80301d67f08f379ddcf89608e78](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=e500b1c4e29ad0bd1c1332a1eaea2913627a92dd) | |
| parent | [c693698787660c97950bc1f93a8dd19d8307153d](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=c693698787660c97950bc1f93a8dd19d8307153d) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e500b1c4e29ad0bd1c1332a1eaea2913627a92dd&id2=c693698787660c97950bc1f93a8dd19d8307153d)) | |
| download | [linux-e500b1c4e29ad0bd1c1332a1eaea2913627a92dd.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-e500b1c4e29ad0bd1c1332a1eaea2913627a92dd.tar.gz) | |

usb: gadget: f\_fs: Fix race between aio\_cancel() and AIO request complete[ Upstream commit 24729b307eefcd7c476065cd7351c1a018082c19 ]
FFS based applications can utilize the aio\_cancel() callback to dequeue
pending USB requests submitted to the UDC. There is a scenario where the
FFS application issues an AIO cancel call, while the UDC is handling a
soft disconnect. For a DWC3 based implementation, the callstack looks
like the following:
DWC3 Gadget FFS Application
dwc3\_gadget\_soft\_disconnect() ...
--> dwc3\_stop\_active\_transfers()
--> dwc3\_gadget\_giveback(-ESHUTDOWN)
--> ffs\_epfile\_async\_io\_complete() ffs\_aio\_cancel()
--> usb\_ep\_free\_request() --> usb\_ep\_dequeue()
There is currently no locking implemented between the AIO completion
handler and AIO cancel, so the issue occurs if the completion routine is
running in parallel to an AIO cancel call coming from the FFS application.
As the completion call frees the USB request (io\_data->req) the FFS
application is also referencing it for the usb\_ep\_dequeue() call. This can
lead to accessing a stale/hanging pointer.
commit b566d38857fc ("usb: gadget: f\_fs: use io\_data->status consistently")
relocated the usb\_ep\_free\_request() into ffs\_epfile\_async\_io\_complete().
However, in order to properly implement locking to mitigate this issue, the
spinlock can't be added to ffs\_epfile\_async\_io\_complete(), as
usb\_ep\_dequeue() (if successfully dequeuing a USB request) will call the
function driver's completion handler in the same context. Hence, leading
into a deadlock.
Fix this issue by moving the usb\_ep\_free\_request() back to
ffs\_user\_copy\_worker(), and ensuring that it explicitly sets io\_data->req
to NULL after freeing it within the ffs->eps\_lock. This resolves the race
condition above, as the ffs\_aio\_cancel() routine will not continue
attempting to dequeue a request that has already been freed, or the
ffs\_user\_copy\_work() not freeing the USB request until the AIO cancel is
done referencing it.
This fix depends on
commit b566d38857fc ("usb: gadget: f\_fs: use io\_data->status
consistently")
Fixes: 2e4c7553cd6f ("usb: gadget: f\_fs: add aio support")
Cc: stable <stable@kernel.org> # b566d38857fc ("usb: gadget: f\_fs: use io\_data->status consistently")
Signed-off-by: Wesley Cheng <quic\_wcheng@quicinc.com>
Link: [https://lore.kernel.org/r/20240409014059.6740-1-quic\_wcheng@quicinc.com](https://lore.kernel.org/r/20240409014059.6740-1-quic_wcheng%40quicinc.com)
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e500b1c4e29ad0bd1c1332a1eaea2913627a92dd)

| -rw-r--r-- | [drivers/usb/gadget/function/f\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/usb/gadget/function/f_fs.c?id=e500b1c4e29ad0bd1c1332a1eaea2913627a92dd) | 4 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 4 insertions, 0 deletions

| diff --git a/drivers/usb/gadget/function/f\_fs.c b/drivers/usb/gadget/function/f\_fs.cindex ad7df99f09a4cd..592c79a04d64d7 100644--- a/[drivers/usb/gadget/function/f\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/gadget/function/f_fs.c?id=c693698787660c97950bc1f93a8dd19d8307153d)+++ b/[drivers/usb/gadget/function/f\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/gadget/function/f_fs.c?id=e500b1c4e29ad0bd1c1332a1eaea2913627a92dd)@@ -827,6 +827,7 @@ static void ffs\_user\_copy\_worker(struct work\_struct \*work) int ret = io\_data->req->status ? io\_data->req->status : io\_data->req->actual; bool kiocb\_has\_eventfd = io\_data->kiocb->ki\_flags & IOCB\_EVENTFD;+ unsigned long flags;  if (io\_data->read && ret > 0) { kthread\_use\_mm(io\_data->mm);@@ -839,7 +840,10 @@ static void ffs\_user\_copy\_worker(struct work\_struct \*work) if (io\_data->ffs->ffs\_eventfd && !kiocb\_has\_eventfd) eventfd\_signal(io\_data->ffs->ffs\_eventfd, 1); + spin\_lock\_irqsave(&io\_data->ffs->eps\_lock, flags); usb\_ep\_free\_request(io\_data->ep, io\_data->req);+ io\_data->req = NULL;+ spin\_unlock\_irqrestore(&io\_data->ffs->eps\_lock, flags);  if (io\_data->read) kfree(io\_data->to\_free); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 19:20:47 +0000



=== Content from git.kernel.org_3cd9f3ba_20250111_192210.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=d7461830823242702f5d84084bcccb25159003f4)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d7461830823242702f5d84084bcccb25159003f4)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d7461830823242702f5d84084bcccb25159003f4)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d7461830823242702f5d84084bcccb25159003f4)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Wesley Cheng <quic\_wcheng@quicinc.com> | 2024-04-08 18:40:59 -0700 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-05-17 12:14:59 +0200 |
| commit | [d7461830823242702f5d84084bcccb25159003f4](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d7461830823242702f5d84084bcccb25159003f4) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=d7461830823242702f5d84084bcccb25159003f4)) | |
| tree | [b6ef1a6bbb9dea1d130276c474d645956392a92b](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d7461830823242702f5d84084bcccb25159003f4) | |
| parent | [a422089ce42ced73713e5032aad29a9a7cbe9528](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a422089ce42ced73713e5032aad29a9a7cbe9528) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d7461830823242702f5d84084bcccb25159003f4&id2=a422089ce42ced73713e5032aad29a9a7cbe9528)) | |
| download | [linux-d7461830823242702f5d84084bcccb25159003f4.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-d7461830823242702f5d84084bcccb25159003f4.tar.gz) | |

usb: gadget: f\_fs: Fix race between aio\_cancel() and AIO request completecommit 24729b307eefcd7c476065cd7351c1a018082c19 upstream.
FFS based applications can utilize the aio\_cancel() callback to dequeue
pending USB requests submitted to the UDC. There is a scenario where the
FFS application issues an AIO cancel call, while the UDC is handling a
soft disconnect. For a DWC3 based implementation, the callstack looks
like the following:
DWC3 Gadget FFS Application
dwc3\_gadget\_soft\_disconnect() ...
--> dwc3\_stop\_active\_transfers()
--> dwc3\_gadget\_giveback(-ESHUTDOWN)
--> ffs\_epfile\_async\_io\_complete() ffs\_aio\_cancel()
--> usb\_ep\_free\_request() --> usb\_ep\_dequeue()
There is currently no locking implemented between the AIO completion
handler and AIO cancel, so the issue occurs if the completion routine is
running in parallel to an AIO cancel call coming from the FFS application.
As the completion call frees the USB request (io\_data->req) the FFS
application is also referencing it for the usb\_ep\_dequeue() call. This can
lead to accessing a stale/hanging pointer.
commit b566d38857fc ("usb: gadget: f\_fs: use io\_data->status consistently")
relocated the usb\_ep\_free\_request() into ffs\_epfile\_async\_io\_complete().
However, in order to properly implement locking to mitigate this issue, the
spinlock can't be added to ffs\_epfile\_async\_io\_complete(), as
usb\_ep\_dequeue() (if successfully dequeuing a USB request) will call the
function driver's completion handler in the same context. Hence, leading
into a deadlock.
Fix this issue by moving the usb\_ep\_free\_request() back to
ffs\_user\_copy\_worker(), and ensuring that it explicitly sets io\_data->req
to NULL after freeing it within the ffs->eps\_lock. This resolves the race
condition above, as the ffs\_aio\_cancel() routine will not continue
attempting to dequeue a request that has already been freed, or the
ffs\_user\_copy\_work() not freeing the USB request until the AIO cancel is
done referencing it.
This fix depends on
commit b566d38857fc ("usb: gadget: f\_fs: use io\_data->status
consistently")
Fixes: 2e4c7553cd6f ("usb: gadget: f\_fs: add aio support")
Cc: stable <stable@kernel.org> # b566d38857fc ("usb: gadget: f\_fs: use io\_data->status consistently")
Signed-off-by: Wesley Cheng <quic\_wcheng@quicinc.com>
Link: [https://lore.kernel.org/r/20240409014059.6740-1-quic\_wcheng@quicinc.com](https://lore.kernel.org/r/20240409014059.6740-1-quic_wcheng%40quicinc.com)
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d7461830823242702f5d84084bcccb25159003f4)

| -rw-r--r-- | [drivers/usb/gadget/function/f\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/usb/gadget/function/f_fs.c?id=d7461830823242702f5d84084bcccb25159003f4) | 7 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 6 insertions, 1 deletions

| diff --git a/drivers/usb/gadget/function/f\_fs.c b/drivers/usb/gadget/function/f\_fs.cindex 6bff6cb9378916..b2c5186adb7a58 100644--- a/[drivers/usb/gadget/function/f\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/gadget/function/f_fs.c?id=a422089ce42ced73713e5032aad29a9a7cbe9528)+++ b/[drivers/usb/gadget/function/f\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/gadget/function/f_fs.c?id=d7461830823242702f5d84084bcccb25159003f4)@@ -821,6 +821,7 @@ static void ffs\_user\_copy\_worker(struct work\_struct \*work) work); int ret = io\_data->status; bool kiocb\_has\_eventfd = io\_data->kiocb->ki\_flags & IOCB\_EVENTFD;+ unsigned long flags;  if (io\_data->read && ret > 0) { kthread\_use\_mm(io\_data->mm);@@ -833,6 +834,11 @@ static void ffs\_user\_copy\_worker(struct work\_struct \*work) if (io\_data->ffs->ffs\_eventfd && !kiocb\_has\_eventfd) eventfd\_signal(io\_data->ffs->ffs\_eventfd); + spin\_lock\_irqsave(&io\_data->ffs->eps\_lock, flags);+ usb\_ep\_free\_request(io\_data->ep, io\_data->req);+ io\_data->req = NULL;+ spin\_unlock\_irqrestore(&io\_data->ffs->eps\_lock, flags);+ if (io\_data->read) kfree(io\_data->to\_free); ffs\_free\_buffer(io\_data);@@ -846,7 +852,6 @@ static void ffs\_epfile\_async\_io\_complete(struct usb\_ep \*\_ep, struct ffs\_data \*ffs = io\_data->ffs;  io\_data->status = req->status ? req->status : req->actual;- usb\_ep\_free\_request(\_ep, req);  INIT\_WORK(&io\_data->work, ffs\_user\_copy\_worker); queue\_work(ffs->io\_completion\_wq, &io\_data->work); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 19:20:47 +0000



=== Content from git.kernel.org_7f8238e0_20250111_192209.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=a0fdccb1c9e027e3195f947f61aa87d6d0d2ea14)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a0fdccb1c9e027e3195f947f61aa87d6d0d2ea14)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a0fdccb1c9e027e3195f947f61aa87d6d0d2ea14)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a0fdccb1c9e027e3195f947f61aa87d6d0d2ea14)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Wesley Cheng <quic\_wcheng@quicinc.com> | 2024-04-08 18:40:59 -0700 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-06-21 14:35:38 +0200 |
| commit | [a0fdccb1c9e027e3195f947f61aa87d6d0d2ea14](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a0fdccb1c9e027e3195f947f61aa87d6d0d2ea14) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=a0fdccb1c9e027e3195f947f61aa87d6d0d2ea14)) | |
| tree | [2681d37a6d6d4089635957f3334236c4c986d491](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a0fdccb1c9e027e3195f947f61aa87d6d0d2ea14) | |
| parent | [b55bc525215d54678bca65414ee2de4e6faa5146](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b55bc525215d54678bca65414ee2de4e6faa5146) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a0fdccb1c9e027e3195f947f61aa87d6d0d2ea14&id2=b55bc525215d54678bca65414ee2de4e6faa5146)) | |
| download | [linux-a0fdccb1c9e027e3195f947f61aa87d6d0d2ea14.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-a0fdccb1c9e027e3195f947f61aa87d6d0d2ea14.tar.gz) | |

usb: gadget: f\_fs: Fix race between aio\_cancel() and AIO request complete[ Upstream commit 24729b307eefcd7c476065cd7351c1a018082c19 ]
FFS based applications can utilize the aio\_cancel() callback to dequeue
pending USB requests submitted to the UDC. There is a scenario where the
FFS application issues an AIO cancel call, while the UDC is handling a
soft disconnect. For a DWC3 based implementation, the callstack looks
like the following:
DWC3 Gadget FFS Application
dwc3\_gadget\_soft\_disconnect() ...
--> dwc3\_stop\_active\_transfers()
--> dwc3\_gadget\_giveback(-ESHUTDOWN)
--> ffs\_epfile\_async\_io\_complete() ffs\_aio\_cancel()
--> usb\_ep\_free\_request() --> usb\_ep\_dequeue()
There is currently no locking implemented between the AIO completion
handler and AIO cancel, so the issue occurs if the completion routine is
running in parallel to an AIO cancel call coming from the FFS application.
As the completion call frees the USB request (io\_data->req) the FFS
application is also referencing it for the usb\_ep\_dequeue() call. This can
lead to accessing a stale/hanging pointer.
commit b566d38857fc ("usb: gadget: f\_fs: use io\_data->status consistently")
relocated the usb\_ep\_free\_request() into ffs\_epfile\_async\_io\_complete().
However, in order to properly implement locking to mitigate this issue, the
spinlock can't be added to ffs\_epfile\_async\_io\_complete(), as
usb\_ep\_dequeue() (if successfully dequeuing a USB request) will call the
function driver's completion handler in the same context. Hence, leading
into a deadlock.
Fix this issue by moving the usb\_ep\_free\_request() back to
ffs\_user\_copy\_worker(), and ensuring that it explicitly sets io\_data->req
to NULL after freeing it within the ffs->eps\_lock. This resolves the race
condition above, as the ffs\_aio\_cancel() routine will not continue
attempting to dequeue a request that has already been freed, or the
ffs\_user\_copy\_work() not freeing the USB request until the AIO cancel is
done referencing it.
This fix depends on
commit b566d38857fc ("usb: gadget: f\_fs: use io\_data->status
consistently")
Fixes: 2e4c7553cd6f ("usb: gadget: f\_fs: add aio support")
Cc: stable <stable@kernel.org> # b566d38857fc ("usb: gadget: f\_fs: use io\_data->status consistently")
Signed-off-by: Wesley Cheng <quic\_wcheng@quicinc.com>
Link: [https://lore.kernel.org/r/20240409014059.6740-1-quic\_wcheng@quicinc.com](https://lore.kernel.org/r/20240409014059.6740-1-quic_wcheng%40quicinc.com)
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a0fdccb1c9e027e3195f947f61aa87d6d0d2ea14)

| -rw-r--r-- | [drivers/usb/gadget/function/f\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/usb/gadget/function/f_fs.c?id=a0fdccb1c9e027e3195f947f61aa87d6d0d2ea14) | 7 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 6 insertions, 1 deletions

| diff --git a/drivers/usb/gadget/function/f\_fs.c b/drivers/usb/gadget/function/f\_fs.cindex d32e1ece3e0a16..698bf24ba44c74 100644--- a/[drivers/usb/gadget/function/f\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/gadget/function/f_fs.c?id=b55bc525215d54678bca65414ee2de4e6faa5146)+++ b/[drivers/usb/gadget/function/f\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/gadget/function/f_fs.c?id=a0fdccb1c9e027e3195f947f61aa87d6d0d2ea14)@@ -832,6 +832,7 @@ static void ffs\_user\_copy\_worker(struct work\_struct \*work) work); int ret = io\_data->status; bool kiocb\_has\_eventfd = io\_data->kiocb->ki\_flags & IOCB\_EVENTFD;+ unsigned long flags;  if (io\_data->read && ret > 0) { kthread\_use\_mm(io\_data->mm);@@ -844,6 +845,11 @@ static void ffs\_user\_copy\_worker(struct work\_struct \*work) if (io\_data->ffs->ffs\_eventfd && !kiocb\_has\_eventfd) eventfd\_signal(io\_data->ffs->ffs\_eventfd, 1); + spin\_lock\_irqsave(&io\_data->ffs->eps\_lock, flags);+ usb\_ep\_free\_request(io\_data->ep, io\_data->req);+ io\_data->req = NULL;+ spin\_unlock\_irqrestore(&io\_data->ffs->eps\_lock, flags);+ if (io\_data->read) kfree(io\_data->to\_free); ffs\_free\_buffer(io\_data);@@ -859,7 +865,6 @@ static void ffs\_epfile\_async\_io\_complete(struct usb\_ep \*\_ep, ENTER();  io\_data->status = req->status ? req->status : req->actual;- usb\_ep\_free\_request(\_ep, req);  INIT\_WORK(&io\_data->work, ffs\_user\_copy\_worker); queue\_work(ffs->io\_completion\_wq, &io\_data->work); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 19:20:46 +0000



=== Content from git.kernel.org_2ab48e0a_20250111_192209.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=9e72ef59cbe61cd1243857a6418ca92104275867)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=9e72ef59cbe61cd1243857a6418ca92104275867)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9e72ef59cbe61cd1243857a6418ca92104275867)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9e72ef59cbe61cd1243857a6418ca92104275867)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Wesley Cheng <quic\_wcheng@quicinc.com> | 2024-04-08 18:40:59 -0700 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-07-05 09:08:13 +0200 |
| commit | [9e72ef59cbe61cd1243857a6418ca92104275867](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9e72ef59cbe61cd1243857a6418ca92104275867) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=9e72ef59cbe61cd1243857a6418ca92104275867)) | |
| tree | [b5a03b8e99b806e99ec1516b3cb9daf7bbfe8b74](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=9e72ef59cbe61cd1243857a6418ca92104275867) | |
| parent | [c90af1cced2f669a7b2304584be4ada495eaa0e5](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=c90af1cced2f669a7b2304584be4ada495eaa0e5) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9e72ef59cbe61cd1243857a6418ca92104275867&id2=c90af1cced2f669a7b2304584be4ada495eaa0e5)) | |
| download | [linux-9e72ef59cbe61cd1243857a6418ca92104275867.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-9e72ef59cbe61cd1243857a6418ca92104275867.tar.gz) | |

usb: gadget: f\_fs: Fix race between aio\_cancel() and AIO request complete[ Upstream commit 24729b307eefcd7c476065cd7351c1a018082c19 ]
FFS based applications can utilize the aio\_cancel() callback to dequeue
pending USB requests submitted to the UDC. There is a scenario where the
FFS application issues an AIO cancel call, while the UDC is handling a
soft disconnect. For a DWC3 based implementation, the callstack looks
like the following:
DWC3 Gadget FFS Application
dwc3\_gadget\_soft\_disconnect() ...
--> dwc3\_stop\_active\_transfers()
--> dwc3\_gadget\_giveback(-ESHUTDOWN)
--> ffs\_epfile\_async\_io\_complete() ffs\_aio\_cancel()
--> usb\_ep\_free\_request() --> usb\_ep\_dequeue()
There is currently no locking implemented between the AIO completion
handler and AIO cancel, so the issue occurs if the completion routine is
running in parallel to an AIO cancel call coming from the FFS application.
As the completion call frees the USB request (io\_data->req) the FFS
application is also referencing it for the usb\_ep\_dequeue() call. This can
lead to accessing a stale/hanging pointer.
commit b566d38857fc ("usb: gadget: f\_fs: use io\_data->status consistently")
relocated the usb\_ep\_free\_request() into ffs\_epfile\_async\_io\_complete().
However, in order to properly implement locking to mitigate this issue, the
spinlock can't be added to ffs\_epfile\_async\_io\_complete(), as
usb\_ep\_dequeue() (if successfully dequeuing a USB request) will call the
function driver's completion handler in the same context. Hence, leading
into a deadlock.
Fix this issue by moving the usb\_ep\_free\_request() back to
ffs\_user\_copy\_worker(), and ensuring that it explicitly sets io\_data->req
to NULL after freeing it within the ffs->eps\_lock. This resolves the race
condition above, as the ffs\_aio\_cancel() routine will not continue
attempting to dequeue a request that has already been freed, or the
ffs\_user\_copy\_work() not freeing the USB request until the AIO cancel is
done referencing it.
This fix depends on
commit b566d38857fc ("usb: gadget: f\_fs: use io\_data->status
consistently")
Fixes: 2e4c7553cd6f ("usb: gadget: f\_fs: add aio support")
Cc: stable <stable@kernel.org> # b566d38857fc ("usb: gadget: f\_fs: use io\_data->status consistently")
Signed-off-by: Wesley Cheng <quic\_wcheng@quicinc.com>
Link: [https://lore.kernel.org/r/20240409014059.6740-1-quic\_wcheng@quicinc.com](https://lore.kernel.org/r/20240409014059.6740-1-quic_wcheng%40quicinc.com)
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9e72ef59cbe61cd1243857a6418ca92104275867)

| -rw-r--r-- | [drivers/usb/gadget/function/f\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/usb/gadget/function/f_fs.c?id=9e72ef59cbe61cd1243857a6418ca92104275867) | 4 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 4 insertions, 0 deletions

| diff --git a/drivers/usb/gadget/function/f\_fs.c b/drivers/usb/gadget/function/f\_fs.cindex 1cf4f4bee019b1..53658162b14890 100644--- a/[drivers/usb/gadget/function/f\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/gadget/function/f_fs.c?id=c90af1cced2f669a7b2304584be4ada495eaa0e5)+++ b/[drivers/usb/gadget/function/f\_fs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/gadget/function/f_fs.c?id=9e72ef59cbe61cd1243857a6418ca92104275867)@@ -827,6 +827,7 @@ static void ffs\_user\_copy\_worker(struct work\_struct \*work) int ret = io\_data->req->status ? io\_data->req->status : io\_data->req->actual; bool kiocb\_has\_eventfd = io\_data->kiocb->ki\_flags & IOCB\_EVENTFD;+ unsigned long flags;  if (io\_data->read && ret > 0) { mm\_segment\_t oldfs = get\_fs();@@ -843,7 +844,10 @@ static void ffs\_user\_copy\_worker(struct work\_struct \*work) if (io\_data->ffs->ffs\_eventfd && !kiocb\_has\_eventfd) eventfd\_signal(io\_data->ffs->ffs\_eventfd, 1); + spin\_lock\_irqsave(&io\_data->ffs->eps\_lock, flags); usb\_ep\_free\_request(io\_data->ep, io\_data->req);+ io\_data->req = NULL;+ spin\_unlock\_irqrestore(&io\_data->ffs->eps\_lock, flags);  if (io\_data->read) kfree(io\_data->to\_free); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 19:20:46 +0000


