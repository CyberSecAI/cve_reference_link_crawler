
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fhaproxy%2Fhaproxy%2Fissues%2F2237)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fhaproxy%2Fhaproxy%2Fissues%2F2237)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fissues_fragments%2Fissue_layout&source=header-repo&source_repo=haproxy%2Fhaproxy)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[haproxy](/haproxy)
/
**[haproxy](/haproxy/haproxy)**
Public

* [Notifications](/login?return_to=%2Fhaproxy%2Fhaproxy) You must be signed in to change notification settings
* [Fork
  809](/login?return_to=%2Fhaproxy%2Fhaproxy)
* [Star
   5.1k](/login?return_to=%2Fhaproxy%2Fhaproxy)

* [Code](/haproxy/haproxy)
* [Issues
  283](/haproxy/haproxy/issues)
* [Pull requests
  0](/haproxy/haproxy/pulls)
* [Actions](/haproxy/haproxy/actions)
* [Projects
  0](/haproxy/haproxy/projects)
* [Wiki](/haproxy/haproxy/wiki)
* [Security](/haproxy/haproxy/security)
* [Insights](/haproxy/haproxy/pulse)

Additional navigation options

* [Code](/haproxy/haproxy)
* [Issues](/haproxy/haproxy/issues)
* [Pull requests](/haproxy/haproxy/pulls)
* [Actions](/haproxy/haproxy/actions)
* [Projects](/haproxy/haproxy/projects)
* [Wiki](/haproxy/haproxy/wiki)
* [Security](/haproxy/haproxy/security)
* [Insights](/haproxy/haproxy/pulse)

New issue

**Have a question about this project?** Sign up for a free GitHub account to open an issue and contact its maintainers and the community.

 [Sign up for GitHub](/signup?return_to=%2Fhaproxy%2Fhaproxy%2Fissues%2Fnew%2Fchoose)

By clicking “Sign up for GitHub”, you agree to our [terms of service](https://docs.github.com/terms) and
[privacy statement](https://docs.github.com/privacy). We’ll occasionally send you account related emails.

Already on GitHub?
[Sign in](/login?return_to=%2Fhaproxy%2Fhaproxy%2Fissues%2Fnew%2Fchoose)
to your account

[Jump to bottom](#issue-comment-box)

# HAProxy forwards malformed empty Content-Length headers, in violation of RFC 9110 #2237

Closed

[kenballus](/kenballus) opened this issue
Aug 2, 2023
· 22 comments

Closed

# [HAProxy forwards malformed empty Content-Length headers, in violation of RFC 9110](#top) #2237

[kenballus](/kenballus) opened this issue
Aug 2, 2023
· 22 comments

Labels
[status: fixed](/haproxy/haproxy/labels/status%3A%20fixed)
This issue is a now-fixed bug.
[subsystem: http](/haproxy/haproxy/labels/subsystem%3A%20http)
This issue is within the HTTP subsystem.
[type: bug](/haproxy/haproxy/labels/type%3A%20bug)
This issue describes a bug.

## Comments

[![@kenballus](https://avatars.githubusercontent.com/u/49924171?s=80&u=e5fdbc516bb1f36efc22782d270108d10a2b8c6c&v=4)](/kenballus)

Copy link

### **[kenballus](/kenballus)** commented [Aug 2, 2023](#issue-1833468115) • edited Loading

| Detailed Description of the Problem RFC 9110 defines the following ABNF rule for the acceptable values in a `Content-Length` header:  ``` Content-Length = 1*DIGIT  ```  (i.e. 1 or more ASCII digits, so empty values are invalid)  A few paragraphs later, it says this:  Likewise, a sender MUST NOT forward a message with a Content-Length header field value that does not match the ABNF above, with one exception: a recipient of a Content-Length header field value consisting of the same decimal value repeated as a comma-separated list (e.g, "Content-Length: 42, 42") MAY either reject the message as invalid or replace that invalid field value with a single instance of the decimal value, since this likely indicates that a duplicate was generated or combined by an upstream message processor.  Thus, HAProxy is obligated to reject (or at least, not forward) requests that do not match that ABNF rule.  However, HAProxy currently forwards empty `Content-Length` headers as-is, which is a violation of the RFC. Expected Behavior HAProxy should reject requests with empty `Content-Length` headers. Steps to Reproduce the Behavior  1. Build and start HAProxy master. I am using the config below (with the placeholder filled in), but any config should do. 2. Send it the following request:  ``` GET / HTTP/1.1\r\n host: whatever\r\n content-length: \r\n \r\n  ```  3. Observe that it forwards that request verbatim to your backend, without correcting or rejecting the invalid CL header.  Do you have any idea what may have caused this? *No response* Do you have an idea how to solve the issue? Reject empty CL headers. What is your configuration? ``` global     maxconn 4096  defaults     mode http     option http-keep-alive     timeout client 1s     timeout connect 1s     timeout server 1s     timeout http-request 1s     http-reuse always  frontend the_frontend     bind 0.0.0.0:80     default_backend the_backend  backend the_backend    server server1 PROXY_BACKEND_PLACEHOLDER:80 ``` Output of `haproxy -vv` ``` HAProxy version 2.9-dev2-ef2b15-31 2023/08/02 - https://haproxy.org/ Status: development branch - not safe for use in production. Known bugs: https://github.com/haproxy/haproxy/issues?q=is:issue+is:open Running on: Linux 6.4.3-arch1-2 #1 SMP PREEMPT_DYNAMIC Sat, 15 Jul 2023 19:25:49 +0000 x86_64 Build options :   TARGET  = linux-musl   CPU     = generic   CC      = cc   CFLAGS  = -O2 -g -Wall -Wextra -Wundef -Wdeclaration-after-statement -Wfatal-errors -Wtype-limits -Wshift-negative-value -Wshift-overflow=2 -Wduplicated-cond -Wnull-dereference -fwrapv -Wno-address-of-packed-member -Wno-unused-label -Wno-sign-compare -Wno-unused-parameter -Wno-clobbered -Wno-missing-field-initializers -Wno-cast-function-type -Wno-string-plus-int -Wno-atomic-alignment   OPTIONS = USE_OPENSSL=1 USE_ZLIB=1 USE_PCRE=1   DEBUG   = -DDEBUG_STRICT -DDEBUG_MEMORY_POOLS  Feature list : -51DEGREES +ACCEPT4 -BACKTRACE -CLOSEFROM +CPU_AFFINITY +CRYPT_H -DEVICEATLAS +DL -ENGINE +EPOLL -EVPORTS +GETADDRINFO -KQUEUE -LIBATOMIC +LIBCRYPT +LINUX_SPLICE +LINUX_TPROXY -LUA -MATH -MEMORY_PROFILING +NETFILTER +NS -OBSOLETE_LINKER +OPENSSL -OPENSSL_WOLFSSL -OT +PCRE -PCRE2 -PCRE2_JIT -PCRE_JIT +POLL +PRCTL -PROCCTL -PROMEX -PTHREAD_EMULATION -QUIC -QUIC_OPENSSL_COMPAT +RT +SHM_OPEN -SLZ +SSL -STATIC_PCRE -STATIC_PCRE2 -SYSTEMD +TFO +THREAD +THREAD_DUMP +TPROXY -WURFL +ZLIB  Default settings :   bufsize = 16384, maxrewrite = 1024, maxpollevents = 200  Built with multi-threading support (MAX_TGROUPS=16, MAX_THREADS=256, default=32). Built with OpenSSL version : OpenSSL 3.1.1 30 May 2023 Running on OpenSSL version : OpenSSL 3.1.1 30 May 2023 OpenSSL library supports TLS extensions : yes OpenSSL library supports SNI : yes OpenSSL library supports : TLSv1.0 TLSv1.1 TLSv1.2 TLSv1.3 OpenSSL providers loaded : default Built with network namespace support. Built with zlib version : 1.2.13 Running on zlib version : 1.2.13 Compression algorithms supported : identity("identity"), deflate("deflate"), raw-deflate("deflate"), gzip("gzip") Built with transparent proxy support using: IP_TRANSPARENT IPV6_TRANSPARENT IP_FREEBIND Built with PCRE version : 8.45 2021-06-15 Running on PCRE version : 8.45 2021-06-15 PCRE library supports JIT : no (USE_PCRE_JIT not set) Encrypted password support via crypt(3): yes Built with gcc compiler version 12.2.1 20220924  Available polling systems :       epoll : pref=300,  test result OK        poll : pref=200,  test result OK      select : pref=150,  test result OK Total: 3 (3 usable), will use epoll.  Available multiplexer protocols : (protocols marked as <default> cannot be specified using 'proto' keyword)          h2 : mode=HTTP  side=FE|BE  mux=H2    flags=HTX|HOL_RISK|NO_UPG        fcgi : mode=HTTP  side=BE     mux=FCGI  flags=HTX|HOL_RISK|NO_UPG   <default> : mode=HTTP  side=FE|BE  mux=H1    flags=HTX          h1 : mode=HTTP  side=FE|BE  mux=H1    flags=HTX|NO_UPG   <default> : mode=TCP   side=FE|BE  mux=PASS  flags=        none : mode=TCP   side=FE|BE  mux=PASS  flags=NO_UPG  Available services : none  Available filters : 	[BWLIM] bwlim-in 	[BWLIM] bwlim-out 	[CACHE] cache 	[COMP] compression 	[FCGI] fcgi-app 	[SPOE] spoe 	[TRACE] trace  ``` Last Outputs and Backtraces *No response* Additional Information *No response* |
| --- |
| The text was updated successfully, but these errors were encountered: |

 🚀
1
 johnnyjeannatasha reacted with rocket emoji

All reactions

* 🚀
  1 reaction

[![@kenballus](https://avatars.githubusercontent.com/u/49924171?s=40&u=e5fdbc516bb1f36efc22782d270108d10a2b8c6c&v=4)](/kenballus)
[kenballus](/kenballus)
added
[status: needs-triage](/haproxy/haproxy/labels/status%3A%20needs-triage)
This issue needs to be triaged.
[type: bug](/haproxy/haproxy/labels/type%3A%20bug)
This issue describes a bug.
labels
[Aug 2, 2023](#event-9989918072)

[![@Tristan971](https://avatars.githubusercontent.com/u/875533?s=80&u=3145ba1c02e0b53bc5e23f9f4d777271f39b21fb&v=4)](/Tristan971)

Copy link

Member

### **[Tristan971](/Tristan971)** commented [Aug 9, 2023](#issuecomment-1670504851)

| [@kenballus](https://github.com/kenballus) and it didn’t occur to you that this isn’t the right place for this comment? |
| --- |

All reactions

Sorry, something went wrong.

[![@kenballus](https://avatars.githubusercontent.com/u/49924171?s=80&u=e5fdbc516bb1f36efc22782d270108d10a2b8c6c&v=4)](/kenballus)

Copy link

Author

### **[kenballus](/kenballus)** commented [Aug 9, 2023](#issuecomment-1670507954) • edited Loading

| [@kenballus](https://github.com/kenballus) and it didn’t occur to you that this isn’t the right place for this comment?  Sorry; that was a real lapse of judgement. I deleted the comment, and will let the appropriate people know through the official channels. |
| --- |

All reactions

Sorry, something went wrong.

[![@Tristan971](https://avatars.githubusercontent.com/u/875533?s=80&u=3145ba1c02e0b53bc5e23f9f4d777271f39b21fb&v=4)](/Tristan971)

Copy link

Member

### **[Tristan971](/Tristan971)** commented [Aug 9, 2023](#issuecomment-1670509807)

| Thanks.  fyi pinged [@wtarreau](https://github.com/wtarreau) about it, though still do send your example to the security address so they can see for themselves. Maybe the example you have is the most one can do with it, or maybe there’s much more to it (in which case it does indeed warrant attention promptly) |
| --- |

All reactions

Sorry, something went wrong.

[![@wtarreau](https://avatars.githubusercontent.com/u/8141789?s=80&u=e9359a488ad99600a4b9393a83c0f736c29ba401&v=4)](/wtarreau)

Copy link

Member

### **[wtarreau](/wtarreau)** commented [Aug 9, 2023](#issuecomment-1670560009)

| Ben already contacted me. I'll have a look, thanks! |
| --- |

All reactions

Sorry, something went wrong.

[haproxy-mirror](/haproxy-mirror)
pushed a commit
that referenced
this issue
[Aug 9, 2023](#ref-commit-6492f1f)
[![@wtarreau](https://avatars.githubusercontent.com/u/8141789?s=40&u=e9359a488ad99600a4b9393a83c0f736c29ba401&v=4)](/wtarreau)

`[BUG/MAJOR: http: reject any empty content-length header value](/haproxy/haproxy/commit/6492f1f29d738457ea9f382aca54537f35f9d856 "BUG/MAJOR: http: reject any empty content-length header value

The content-length header parser has its dedicated function, in order
to take extreme care about invalid, unparsable, or conflicting values.
But there's a corner case in it, by which it stops comparing values
when reaching the end of the header. This has for a side effect that
an empty value or a value that ends with a comma does not deserve
further analysis, and it acts as if the header was absent.

While this is not necessarily a problem for the value ending with a
comma as it will be cause a header folding and will disappear, it is a
problem for the first isolated empty header because this one will not
be recontructed when next ones are seen, and will be passed as-is to the
backend server. A vulnerable HTTP/1 server hosted behind haproxy that
would just use this first value as \"0\" and ignore the valid one would
then not be protected by haproxy and could be attacked this way, taking
the payload for an extra request.

In field the risk depends on the server. Most commonly used servers
already have safe content-length parsers, but users relying on haproxy
to protect a known-vulnerable server might be at risk (and the risk of
a bug even in a reputable server should never be dismissed).

A configuration-based work-around consists in adding the following rule
in the frontend, to explicitly reject requests featuring an empty
content-length header that would have not be folded into an existing
one:

    http-request deny if { hdr_len(content-length) 0 }

The real fix consists in adjusting the parser so that it always expects a
value at the beginning of the header or after a comma. It will now reject
requests and responses having empty values anywhere in the C-L header.

This needs to be backported to all supported versions. Note that the
modification was made to functions h1_parse_cont_len_header() and
http_parse_cont_len_header(). Prior to 2.8 the latter was in
h2_parse_cont_len_header(). One day the two should be refused but the
former is also used by Lua.

The HTTP messaging reg-tests were completed to test these cases.

Thanks to Ben Kallus of Dartmouth College and Narf Industries for
reporting this! (this is in GH #2237).")`
…

`[6492f1f](/haproxy/haproxy/commit/6492f1f29d738457ea9f382aca54537f35f9d856)`

```
The content-length header parser has its dedicated function, in order
to take extreme care about invalid, unparsable, or conflicting values.
But there's a corner case in it, by which it stops comparing values
when reaching the end of the header. This has for a side effect that
an empty value or a value that ends with a comma does not deserve
further analysis, and it acts as if the header was absent.

While this is not necessarily a problem for the value ending with a
comma as it will be cause a header folding and will disappear, it is a
problem for the first isolated empty header because this one will not
be recontructed when next ones are seen, and will be passed as-is to the
backend server. A vulnerable HTTP/1 server hosted behind haproxy that
would just use this first value as "0" and ignore the valid one would
then not be protected by haproxy and could be attacked this way, taking
the payload for an extra request.

In field the risk depends on the server. Most commonly used servers
already have safe content-length parsers, but users relying on haproxy
to protect a known-vulnerable server might be at risk (and the risk of
a bug even in a reputable server should never be dismissed).

A configuration-based work-around consists in adding the following rule
in the frontend, to explicitly reject requests featuring an empty
content-length header that would have not be folded into an existing
one:

    http-request deny if { hdr_len(content-length) 0 }

The real fix consists in adjusting the parser so that it always expects a
value at the beginning of the header or after a comma. It will now reject
requests and responses having empty values anywhere in the C-L header.

This needs to be backported to all supported versions. Note that the
modification was made to functions h1_parse_cont_len_header() and
http_parse_cont_len_header(). Prior to 2.8 the latter was in
h2_parse_cont_len_header(). One day the two should be refused but the
former is also used by Lua.

The HTTP messaging reg-tests were completed to test these cases.

Thanks to Ben Kallus of Dartmouth College and Narf Industries for
reporting this! (this is in GH [#2237](https://github.com/haproxy/haproxy/issues/2237)).
```

[![@wtarreau](https://avatars.githubusercontent.com/u/8141789?s=80&u=e9359a488ad99600a4b9393a83c0f736c29ba401&v=4)](/wtarreau)

Copy link

Member

### **[wtarreau](/wtarreau)** commented [Aug 9, 2023](#issuecomment-1670818301)

| Now fixed for h1/h2/h3 and with extra regtests (commit [6492f1f](https://github.com/haproxy/haproxy/commit/6492f1f29d738457ea9f382aca54537f35f9d856)). We wanted to produce maintenance releases this end of week, so this will come with them as well. Thanks Ben! |
| --- |

All reactions

Sorry, something went wrong.

[FireBurn](/FireBurn)
pushed a commit
to FireBurn/haproxy
that referenced
this issue
[Aug 10, 2023](#ref-commit-65921ee)
[![@wtarreau](https://avatars.githubusercontent.com/u/8141789?s=40&u=e9359a488ad99600a4b9393a83c0f736c29ba401&v=4)](/wtarreau) [![@a-denoyelle](https://avatars.githubusercontent.com/u/54402659?s=40&v=4)](/a-denoyelle)

`[BUG/MAJOR: http: reject any empty content-length header value](/FireBurn/haproxy/commit/65921ee12d88e9fb1fa9f6cd8198fd64b3a3f37f "BUG/MAJOR: http: reject any empty content-length header value

The content-length header parser has its dedicated function, in order
to take extreme care about invalid, unparsable, or conflicting values.
But there's a corner case in it, by which it stops comparing values
when reaching the end of the header. This has for a side effect that
an empty value or a value that ends with a comma does not deserve
further analysis, and it acts as if the header was absent.

While this is not necessarily a problem for the value ending with a
comma as it will be cause a header folding and will disappear, it is a
problem for the first isolated empty header because this one will not
be recontructed when next ones are seen, and will be passed as-is to the
backend server. A vulnerable HTTP/1 server hosted behind haproxy that
would just use this first value as \"0\" and ignore the valid one would
then not be protected by haproxy and could be attacked this way, taking
the payload for an extra request.

In field the risk depends on the server. Most commonly used servers
already have safe content-length parsers, but users relying on haproxy
to protect a known-vulnerable server might be at risk (and the risk of
a bug even in a reputable server should never be dismissed).

A configuration-based work-around consists in adding the following rule
in the frontend, to explicitly reject requests featuring an empty
content-length header that would have not be folded into an existing
one:

    http-request deny if { hdr_len(content-length) 0 }

The real fix consists in adjusting the parser so that it always expects a
value at the beginning of the header or after a comma. It will now reject
requests and responses having empty values anywhere in the C-L header.

This needs to be backported to all supported versions. Note that the
modification was made to functions h1_parse_cont_len_header() and
http_parse_cont_len_header(). Prior to 2.8 the latter was in
h2_parse_cont_len_header(). One day the two should be refused but the
former is also used by Lua.

The HTTP messaging reg-tests were completed to test these cases.

Thanks to Ben Kallus of Dartmouth College and Narf Industries for
reporting this! (this is in GH #2237).

(cherry picked from commit 6492f1f29d738457ea9f382aca54537f35f9d856)
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>
(cherry picked from commit a32f99f6f991d123ea3e307bf8aa63220836d365)
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>")`
…

`[65921ee](/FireBurn/haproxy/commit/65921ee12d88e9fb1fa9f6cd8198fd64b3a3f37f)`

```
The content-length header parser has its dedicated function, in order
to take extreme care about invalid, unparsable, or conflicting values.
But there's a corner case in it, by which it stops comparing values
when reaching the end of the header. This has for a side effect that
an empty value or a value that ends with a comma does not deserve
further analysis, and it acts as if the header was absent.

While this is not necessarily a problem for the value ending with a
comma as it will be cause a header folding and will disappear, it is a
problem for the first isolated empty header because this one will not
be recontructed when next ones are seen, and will be passed as-is to the
backend server. A vulnerable HTTP/1 server hosted behind haproxy that
would just use this first value as "0" and ignore the valid one would
then not be protected by haproxy and could be attacked this way, taking
the payload for an extra request.

In field the risk depends on the server. Most commonly used servers
already have safe content-length parsers, but users relying on haproxy
to protect a known-vulnerable server might be at risk (and the risk of
a bug even in a reputable server should never be dismissed).

A configuration-based work-around consists in adding the following rule
in the frontend, to explicitly reject requests featuring an empty
content-length header that would have not be folded into an existing
one:

    http-request deny if { hdr_len(content-length) 0 }

The real fix consists in adjusting the parser so that it always expects a
value at the beginning of the header or after a comma. It will now reject
requests and responses having empty values anywhere in the C-L header.

This needs to be backported to all supported versions. Note that the
modification was made to functions h1_parse_cont_len_header() and
http_parse_cont_len_header(). Prior to 2.8 the latter was in
h2_parse_cont_len_header(). One day the two should be refused but the
former is also used by Lua.

The HTTP messaging reg-tests were completed to test these cases.

Thanks to Ben Kallus of Dartmouth College and Narf Industries for
reporting this! (this is in GH [haproxy#2237](https://github.com/haproxy/haproxy/issues/2237)).

(cherry picked from commit [6492f1f](https://github.com/FireBurn/haproxy/commit/6492f1f29d738457ea9f382aca54537f35f9d856))
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>
(cherry picked from commit [a32f99f](https://github.com/FireBurn/haproxy/commit/a32f99f6f991d123ea3e307bf8aa63220836d365))
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>
```

[FireBurn](/FireBurn)
pushed a commit
to FireBurn/haproxy
that referenced
this issue
[Aug 10, 2023](#ref-commit-a32f99f)
[![@wtarreau](https://avatars.githubusercontent.com/u/8141789?s=40&u=e9359a488ad99600a4b9393a83c0f736c29ba401&v=4)](/wtarreau) [![@a-denoyelle](https://avatars.githubusercontent.com/u/54402659?s=40&v=4)](/a-denoyelle)

`[BUG/MAJOR: http: reject any empty content-length header value](/FireBurn/haproxy/commit/a32f99f6f991d123ea3e307bf8aa63220836d365 "BUG/MAJOR: http: reject any empty content-length header value

The content-length header parser has its dedicated function, in order
to take extreme care about invalid, unparsable, or conflicting values.
But there's a corner case in it, by which it stops comparing values
when reaching the end of the header. This has for a side effect that
an empty value or a value that ends with a comma does not deserve
further analysis, and it acts as if the header was absent.

While this is not necessarily a problem for the value ending with a
comma as it will be cause a header folding and will disappear, it is a
problem for the first isolated empty header because this one will not
be recontructed when next ones are seen, and will be passed as-is to the
backend server. A vulnerable HTTP/1 server hosted behind haproxy that
would just use this first value as \"0\" and ignore the valid one would
then not be protected by haproxy and could be attacked this way, taking
the payload for an extra request.

In field the risk depends on the server. Most commonly used servers
already have safe content-length parsers, but users relying on haproxy
to protect a known-vulnerable server might be at risk (and the risk of
a bug even in a reputable server should never be dismissed).

A configuration-based work-around consists in adding the following rule
in the frontend, to explicitly reject requests featuring an empty
content-length header that would have not be folded into an existing
one:

    http-request deny if { hdr_len(content-length) 0 }

The real fix consists in adjusting the parser so that it always expects a
value at the beginning of the header or after a comma. It will now reject
requests and responses having empty values anywhere in the C-L header.

This needs to be backported to all supported versions. Note that the
modification was made to functions h1_parse_cont_len_header() and
http_parse_cont_len_header(). Prior to 2.8 the latter was in
h2_parse_cont_len_header(). One day the two should be refused but the
former is also used by Lua.

The HTTP messaging reg-tests were completed to test these cases.

Thanks to Ben Kallus of Dartmouth College and Narf Industries for
reporting this! (this is in GH #2237).

(cherry picked from commit 6492f1f29d738457ea9f382aca54537f35f9d856)
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>")`
…

`[a32f99f](/FireBurn/haproxy/commit/a32f99f6f991d123ea3e307bf8aa63220836d365)`

```
The content-length header parser has its dedicated function, in order
to take extreme care about invalid, unparsable, or conflicting values.
But there's a corner case in it, by which it stops comparing values
when reaching the end of the header. This has for a side effect that
an empty value or a value that ends with a comma does not deserve
further analysis, and it acts as if the header was absent.

While this is not necessarily a problem for the value ending with a
comma as it will be cause a header folding and will disappear, it is a
problem for the first isolated empty header because this one will not
be recontructed when next ones are seen, and will be passed as-is to the
backend server. A vulnerable HTTP/1 server hosted behind haproxy that
would just use this first value as "0" and ignore the valid one would
then not be protected by haproxy and could be attacked this way, taking
the payload for an extra request.

In field the risk depends on the server. Most commonly used servers
already have safe content-length parsers, but users relying on haproxy
to protect a known-vulnerable server might be at risk (and the risk of
a bug even in a reputable server should never be dismissed).

A configuration-based work-around consists in adding the following rule
in the frontend, to explicitly reject requests featuring an empty
content-length header that would have not be folded into an existing
one:

    http-request deny if { hdr_len(content-length) 0 }

The real fix consists in adjusting the parser so that it always expects a
value at the beginning of the header or after a comma. It will now reject
requests and responses having empty values anywhere in the C-L header.

This needs to be backported to all supported versions. Note that the
modification was made to functions h1_parse_cont_len_header() and
http_parse_cont_len_header(). Prior to 2.8 the latter was in
h2_parse_cont_len_header(). One day the two should be refused but the
former is also used by Lua.

The HTTP messaging reg-tests were completed to test these cases.

Thanks to Ben Kallus of Dartmouth College and Narf Industries for
reporting this! (this is in GH [haproxy#2237](https://github.com/haproxy/haproxy/issues/2237)).

(cherry picked from commit [6492f1f](https://github.com/FireBurn/haproxy/commit/6492f1f29d738457ea9f382aca54537f35f9d856))
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>
```

[FireBurn](/FireBurn)
pushed a commit
to FireBurn/haproxy
that referenced
this issue
[Aug 10, 2023](#ref-commit-d17c500)
[![@wtarreau](https://avatars.githubusercontent.com/u/8141789?s=40&u=e9359a488ad99600a4b9393a83c0f736c29ba401&v=4)](/wtarreau) [![@a-denoyelle](https://avatars.githubusercontent.com/u/54402659?s=40&v=4)](/a-denoyelle)

`[BUG/MAJOR: http: reject any empty content-length header value](/FireBurn/haproxy/commit/d17c50010d591d1c070e1cb0567a06032d8869e9 "BUG/MAJOR: http: reject any empty content-length header value

The content-length header parser has its dedicated function, in order
to take extreme care about invalid, unparsable, or conflicting values.
But there's a corner case in it, by which it stops comparing values
when reaching the end of the header. This has for a side effect that
an empty value or a value that ends with a comma does not deserve
further analysis, and it acts as if the header was absent.

While this is not necessarily a problem for the value ending with a
comma as it will be cause a header folding and will disappear, it is a
problem for the first isolated empty header because this one will not
be recontructed when next ones are seen, and will be passed as-is to the
backend server. A vulnerable HTTP/1 server hosted behind haproxy that
would just use this first value as \"0\" and ignore the valid one would
then not be protected by haproxy and could be attacked this way, taking
the payload for an extra request.

In field the risk depends on the server. Most commonly used servers
already have safe content-length parsers, but users relying on haproxy
to protect a known-vulnerable server might be at risk (and the risk of
a bug even in a reputable server should never be dismissed).

A configuration-based work-around consists in adding the following rule
in the frontend, to explicitly reject requests featuring an empty
content-length header that would have not be folded into an existing
one:

    http-request deny if { hdr_len(content-length) 0 }

The real fix consists in adjusting the parser so that it always expects a
value at the beginning of the header or after a comma. It will now reject
requests and responses having empty values anywhere in the C-L header.

This needs to be backported to all supported versions. Note that the
modification was made to functions h1_parse_cont_len_header() and
http_parse_cont_len_header(). Prior to 2.8 the latter was in
h2_parse_cont_len_header(). One day the two should be refused but the
former is also used by Lua.

The HTTP messaging reg-tests were completed to test these cases.

Thanks to Ben Kallus of Dartmouth College and Narf Industries for
reporting this! (this is in GH #2237).

(cherry picked from commit 6492f1f29d738457ea9f382aca54537f35f9d856)
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>
(cherry picked from commit a32f99f6f991d123ea3e307bf8aa63220836d365)
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>
(cherry picked from commit 65921ee12d88e9fb1fa9f6cd8198fd64b3a3f37f)
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>")`
…

`[d17c500](/FireBurn/haproxy/commit/d17c50010d591d1c070e1cb0567a06032d8869e9)`

```
The content-length header parser has its dedicated function, in order
to take extreme care about invalid, unparsable, or conflicting values.
But there's a corner case in it, by which it stops comparing values
when reaching the end of the header. This has for a side effect that
an empty value or a value that ends with a comma does not deserve
further analysis, and it acts as if the header was absent.

While this is not necessarily a problem for the value ending with a
comma as it will be cause a header folding and will disappear, it is a
problem for the first isolated empty header because this one will not
be recontructed when next ones are seen, and will be passed as-is to the
backend server. A vulnerable HTTP/1 server hosted behind haproxy that
would just use this first value as "0" and ignore the valid one would
then not be protected by haproxy and could be attacked this way, taking
the payload for an extra request.

In field the risk depends on the server. Most commonly used servers
already have safe content-length parsers, but users relying on haproxy
to protect a known-vulnerable server might be at risk (and the risk of
a bug even in a reputable server should never be dismissed).

A configuration-based work-around consists in adding the following rule
in the frontend, to explicitly reject requests featuring an empty
content-length header that would have not be folded into an existing
one:

    http-request deny if { hdr_len(content-length) 0 }

The real fix consists in adjusting the parser so that it always expects a
value at the beginning of the header or after a comma. It will now reject
requests and responses having empty values anywhere in the C-L header.

This needs to be backported to all supported versions. Note that the
modification was made to functions h1_parse_cont_len_header() and
http_parse_cont_len_header(). Prior to 2.8 the latter was in
h2_parse_cont_len_header(). One day the two should be refused but the
former is also used by Lua.

The HTTP messaging reg-tests were completed to test these cases.

Thanks to Ben Kallus of Dartmouth College and Narf Industries for
reporting this! (this is in GH [haproxy#2237](https://github.com/haproxy/haproxy/issues/2237)).

(cherry picked from commit [6492f1f](https://github.com/FireBurn/haproxy/commit/6492f1f29d738457ea9f382aca54537f35f9d856))
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>
(cherry picked from commit [a32f99f](https://github.com/FireBurn/haproxy/commit/a32f99f6f991d123ea3e307bf8aa63220836d365))
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>
(cherry picked from commit [65921ee](https://github.com/FireBurn/haproxy/commit/65921ee12d88e9fb1fa9f6cd8198fd64b3a3f37f))
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>
```

[![@rfrohl](https://avatars.githubusercontent.com/u/1474150?s=80&u=76b9f7025ea6e851f5857d243560a53c1a610ee5&v=4)](/rfrohl)

Copy link

### **[rfrohl](/rfrohl)** commented [Aug 10, 2023](#issuecomment-1673956824)

| This issue got [CVE-2023-40225](https://github.com/advisories/GHSA-xgq7-jp95-v2qv "CVE-2023-40225") assigned. |
| --- |

All reactions

Sorry, something went wrong.

[![@wtarreau](https://avatars.githubusercontent.com/u/8141789?s=80&u=e9359a488ad99600a4b9393a83c0f736c29ba401&v=4)](/wtarreau)

Copy link

Member

### **[wtarreau](/wtarreau)** commented [Aug 11, 2023](#issuecomment-1674218975)

| Thank you Robert! |
| --- |

All reactions

Sorry, something went wrong.

[![@wtarreau](https://avatars.githubusercontent.com/u/8141789?s=40&u=e9359a488ad99600a4b9393a83c0f736c29ba401&v=4)](/wtarreau)
[wtarreau](/wtarreau)
added
[subsystem: http](/haproxy/haproxy/labels/subsystem%3A%20http)
This issue is within the HTTP subsystem.
[status: fixed](/haproxy/haproxy/labels/status%3A%20fixed)
This issue is a now-fixed bug.
[2.0](/haproxy/haproxy/labels/2.0)
This issue affects the HAProxy 2.0 stable branch.
[2.2](/haproxy/haproxy/labels/2.2)
This issue affects the HAProxy 2.2 stable branch.
[2.4](/haproxy/haproxy/labels/2.4)
This issue affects the HAProxy 2.4 stable branch.
and removed
[status: needs-triage](/haproxy/haproxy/labels/status%3A%20needs-triage)
This issue needs to be triaged.
labels
[Aug 11, 2023](#event-10065901889)

[![@robert-scheck](https://avatars.githubusercontent.com/u/10982488?s=80&v=4)](/robert-scheck)

Copy link

### **[robert-scheck](/robert-scheck)** commented [Aug 12, 2023](#issuecomment-1676113850) • edited Loading

| I know that HAProxy 1.8 is unmaintained, but could you still comment whether the CVE is applicable for it, please? |
| --- |

All reactions

Sorry, something went wrong.

[![@kenballus](https://avatars.githubusercontent.com/u/49924171?s=80&u=e5fdbc516bb1f36efc22782d270108d10a2b8c6c&v=4)](/kenballus)

Copy link

Author

### **[kenballus](/kenballus)** commented [Aug 13, 2023](#issuecomment-1676158191)

| I have tested it on haproxy 1.3, and that is also vulnerable. This suggests that 1.8 very likely is too. |
| --- |

All reactions

Sorry, something went wrong.

[![@wtarreau](https://avatars.githubusercontent.com/u/8141789?s=80&u=e9359a488ad99600a4b9393a83c0f736c29ba401&v=4)](/wtarreau)

Copy link

Member

### **[wtarreau](/wtarreau)** commented [Aug 13, 2023](#issuecomment-1676218252)

| I think it is as well. And in fact older versions work more like a pipe in that they will not transform contents. For example 1.3 will simply pass whatever it receives, a bit like a router... Once we're done with the backport in 2.0 I think the patch will be usable in 1.8 if you really need it.  However, please be aware that it is a problem if a server behind is itself vulnerable to multiple different content-length headers. I don't know which ones are vulnerable to this, but I think that if you're using a serious server like Apache or Nginx behind haproxy you should be safe (Ben might be able to confirm).  As a general rule, you should keep in mind that you shouldn't rely on unmaintained software to secure sensitive components. That can probably be OK if your haproxy doesn't have filtering rules or if the server behind is just a static server, though. |
| --- |

All reactions

Sorry, something went wrong.

[![@kenballus](https://avatars.githubusercontent.com/u/49924171?s=80&u=e5fdbc516bb1f36efc22782d270108d10a2b8c6c&v=4)](/kenballus)

Copy link

Author

### **[kenballus](/kenballus)** commented [Aug 13, 2023](#issuecomment-1676223644)

| Current versions of nginx and apache are not vulnerable to this. Some smaller web servers (think Python/Ruby ecosystems) are vulnerable. You should test whether your backend server(s) accept requests with 2 content-length headers, of which the first is empty. If it just rejects such requests, then you're probably okay. |
| --- |

 👍
2
 wtarreau and lukastribus reacted with thumbs up emoji

All reactions

* 👍
  2 reactions

Sorry, something went wrong.

[FireBurn](/FireBurn)
pushed a commit
to FireBurn/haproxy
that referenced
this issue
[Aug 15, 2023](#ref-commit-ba9afd2)
[![@wtarreau](https://avatars.githubusercontent.com/u/8141789?s=40&u=e9359a488ad99600a4b9393a83c0f736c29ba401&v=4)](/wtarreau)

`[BUG/MAJOR: http: reject any empty content-length header value](/FireBurn/haproxy/commit/ba9afd2774c03e434165475b537d0462801f49bb "BUG/MAJOR: http: reject any empty content-length header value

The content-length header parser has its dedicated function, in order
to take extreme care about invalid, unparsable, or conflicting values.
But there's a corner case in it, by which it stops comparing values
when reaching the end of the header. This has for a side effect that
an empty value or a value that ends with a comma does not deserve
further analysis, and it acts as if the header was absent.

While this is not necessarily a problem for the value ending with a
comma as it will be cause a header folding and will disappear, it is a
problem for the first isolated empty header because this one will not
be recontructed when next ones are seen, and will be passed as-is to the
backend server. A vulnerable HTTP/1 server hosted behind haproxy that
would just use this first value as \"0\" and ignore the valid one would
then not be protected by haproxy and could be attacked this way, taking
the payload for an extra request.

In field the risk depends on the server. Most commonly used servers
already have safe content-length parsers, but users relying on haproxy
to protect a known-vulnerable server might be at risk (and the risk of
a bug even in a reputable server should never be dismissed).

A configuration-based work-around consists in adding the following rule
in the frontend, to explicitly reject requests featuring an empty
content-length header that would have not be folded into an existing
one:

    http-request deny if { hdr_len(content-length) 0 }

The real fix consists in adjusting the parser so that it always expects a
value at the beginning of the header or after a comma. It will now reject
requests and responses having empty values anywhere in the C-L header.

This needs to be backported to all supported versions. Note that the
modification was made to functions h1_parse_cont_len_header() and
http_parse_cont_len_header(). Prior to 2.8 the latter was in
h2_parse_cont_len_header(). One day the two should be refused but the
former is also used by Lua.

The HTTP messaging reg-tests were completed to test these cases.

Thanks to Ben Kallus of Dartmouth College and Narf Industries for
reporting this! (this is in GH #2237).

(cherry picked from commit 6492f1f29d738457ea9f382aca54537f35f9d856)
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>
(cherry picked from commit a32f99f6f991d123ea3e307bf8aa63220836d365)
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>
(cherry picked from commit 65921ee12d88e9fb1fa9f6cd8198fd64b3a3f37f)
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>
(cherry picked from commit d17c50010d591d1c070e1cb0567a06032d8869e9)
[wt: applied to h2_parse_cont_len_header() in src/h2.c instead]
Signed-off-by: Willy Tarreau <w@1wt.eu>")`
…

`[ba9afd2](/FireBurn/haproxy/commit/ba9afd2774c03e434165475b537d0462801f49bb)`

```
The content-length header parser has its dedicated function, in order
to take extreme care about invalid, unparsable, or conflicting values.
But there's a corner case in it, by which it stops comparing values
when reaching the end of the header. This has for a side effect that
an empty value or a value that ends with a comma does not deserve
further analysis, and it acts as if the header was absent.

While this is not necessarily a problem for the value ending with a
comma as it will be cause a header folding and will disappear, it is a
problem for the first isolated empty header because this one will not
be recontructed when next ones are seen, and will be passed as-is to the
backend server. A vulnerable HTTP/1 server hosted behind haproxy that
would just use this first value as "0" and ignore the valid one would
then not be protected by haproxy and could be attacked this way, taking
the payload for an extra request.

In field the risk depends on the server. Most commonly used servers
already have safe content-length parsers, but users relying on haproxy
to protect a known-vulnerable server might be at risk (and the risk of
a bug even in a reputable server should never be dismissed).

A configuration-based work-around consists in adding the following rule
in the frontend, to explicitly reject requests featuring an empty
content-length header that would have not be folded into an existing
one:

    http-request deny if { hdr_len(content-length) 0 }

The real fix consists in adjusting the parser so that it always expects a
value at the beginning of the header or after a comma. It will now reject
requests and responses having empty values anywhere in the C-L header.

This needs to be backported to all supported versions. Note that the
modification was made to functions h1_parse_cont_len_header() and
http_parse_cont_len_header(). Prior to 2.8 the latter was in
h2_parse_cont_len_header(). One day the two should be refused but the
former is also used by Lua.

The HTTP messaging reg-tests were completed to test these cases.

Thanks to Ben Kallus of Dartmouth College and Narf Industries for
reporting this! (this is in GH [haproxy#2237](https://github.com/haproxy/haproxy/issues/2237)).

(cherry picked from commit [6492f1f](https://github.com/FireBurn/haproxy/commit/6492f1f29d738457ea9f382aca54537f35f9d856))
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>
(cherry picked from commit [a32f99f](https://github.com/FireBurn/haproxy/commit/a32f99f6f991d123ea3e307bf8aa63220836d365))
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>
(cherry picked from commit [65921ee](https://github.com/FireBurn/haproxy/commit/65921ee12d88e9fb1fa9f6cd8198fd64b3a3f37f))
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>
(cherry picked from commit [d17c500](https://github.com/FireBurn/haproxy/commit/d17c50010d591d1c070e1cb0567a06032d8869e9))
[wt: applied to h2_parse_cont_len_header() in src/h2.c instead]
Signed-off-by: Willy Tarreau <w@1wt.eu>
```

[![@firexinghe](https://avatars.githubusercontent.com/u/80017732?s=80&v=4)](/firexinghe)

Copy link

Contributor

### **[firexinghe](/firexinghe)** commented [Aug 15, 2023](#issuecomment-1678504543) • edited Loading

| [@wtarreau](https://github.com/wtarreau) Hello, is [2273176](https://github.com/haproxy/haproxy/commit/22731762d9fe2c98d9e6c3942b1568266b23c69f) also a fix patch for [CVE-2023-40225](https://github.com/advisories/GHSA-xgq7-jp95-v2qv "CVE-2023-40225")? |
| --- |

All reactions

Sorry, something went wrong.

[![@wtarreau](https://avatars.githubusercontent.com/u/8141789?s=80&u=e9359a488ad99600a4b9393a83c0f736c29ba401&v=4)](/wtarreau)

Copy link

Member

### **[wtarreau](/wtarreau)** commented [Aug 15, 2023](#issuecomment-1678594656)

| No, it's not, even though it was reported by the same person. It's a preventive hardening measure to protect certain poorly written servers against incorrect parsing of leading zeroes. Both of us are aware of the fact that some old non-compliant servers used to suffer from this problem and the protection was easy and inexpensive to add, so it was worth adding it. |
| --- |

All reactions

Sorry, something went wrong.

[![@rodrigoffzz](https://avatars.githubusercontent.com/u/6108573?s=80&v=4)](/rodrigoffzz)

Copy link

### **[rodrigoffzz](/rodrigoffzz)** commented [Aug 15, 2023](#issuecomment-1678807176)

| I think it is as well. And in fact older versions work more like a pipe in that they will not transform contents. For example 1.3 will simply pass whatever it receives, a bit like a router... Once we're done with the backport in 2.0 I think the patch will be usable in 1.8 if you really need it.  Hi, I'm working on a downstream backport for Ubuntu and I noticed that the patch for 2.4 is cleanly applicable for 2.0 (with only one change in a comment line), if that is a correct understanding, do you think you could, please, give an idea on what would be the fix for 1.8, where `*_parse_cont_len_header` methods did not exist yet, if feasible?  Going a bit further in the past, before 1.8, where even `*_headers_to_hdr_list` did not exist yet, I couldn't find where we could place a possible fix. As already stated, older versions are routing whatever it receives, so it would probably don't get a proper fix for this kind of issue since it was not checking it at all... do you think this is a valid statement?  thank you very much ! |
| --- |

All reactions

Sorry, something went wrong.

[![@wtarreau](https://avatars.githubusercontent.com/u/8141789?s=80&u=e9359a488ad99600a4b9393a83c0f736c29ba401&v=4)](/wtarreau)

Copy link

Member

### **[wtarreau](/wtarreau)** commented [Aug 15, 2023](#issuecomment-1678887873)

| Note, for 2.0 there are two HTTP stacks, the legacy and the HTX one. It was a transition version. The part from 2.4 that applies well to 2.0 is only for HTX, we still need to do the backport for the legacy one. I tend to think that once we have a complete one for 2.0 it will be OK to backport it as-is to 1.8.  Once I'm done with the backports, I'll have a look at 1.8. |
| --- |

 👍
1
 rodrigoffzz reacted with thumbs up emoji

All reactions

* 👍
  1 reaction

Sorry, something went wrong.

[![@git001](https://avatars.githubusercontent.com/u/1579468?s=80&u=4ae64f080e61abd9a2add2bcb8a7397f37302a74&v=4)](/git001)

Copy link

Contributor

### **[git001](/git001)** commented [Aug 15, 2023](#issuecomment-1678982279)

| I know that HAProxy 1.8 is unmaintained, but could you still comment whether the CVE is applicable for it, please?  Isn't that the perfect reason to update to a more recent and maintained version? |
| --- |

All reactions

Sorry, something went wrong.

[![@git001](https://avatars.githubusercontent.com/u/1579468?s=80&u=4ae64f080e61abd9a2add2bcb8a7397f37302a74&v=4)](/git001)

Copy link

Contributor

### **[git001](/git001)** commented [Aug 15, 2023](#issuecomment-1678985033)

| Note, for 2.0 there are two HTTP stacks, the legacy and the HTX one. It was a transition version. The part from 2.4 that applies well to 2.0 is only for HTX, we still need to do the backport for the legacy one. I tend to think that once we have a complete one for 2.0 it will be OK to backport it as-is to 1.8.  Once I'm done with the backports, I'll have a look at 1.8.  But isn't 1.8 EOL? Just for my curiosity why invest some time to backport and release an new version for a EOL version? |
| --- |

All reactions

Sorry, something went wrong.

[![@wtarreau](https://avatars.githubusercontent.com/u/8141789?s=80&u=e9359a488ad99600a4b9393a83c0f736c29ba401&v=4)](/wtarreau)

Copy link

Member

### **[wtarreau](/wtarreau)** commented [Aug 15, 2023](#issuecomment-1679009633)

| Yes it's dead. But you know how it is, Aleks. First, there are LTS distros which ship with it and will need the fix. Second, users never upgrade in emergency, that's the best way to face an error due to a rushed upgrade when they would otherwise not have been vulnerable :-) I'll have a look in best effort mode, that's fine. It shouldn't be different from the 2.0 fix anyway. |
| --- |

 ❤️
2
 rodrigoffzz and lukastribus reacted with heart emoji
 👀
1
 git001 reacted with eyes emoji

All reactions

* ❤️
  2 reactions
* 👀
  1 reaction

Sorry, something went wrong.

[![@wtarreau](https://avatars.githubusercontent.com/u/8141789?s=80&u=e9359a488ad99600a4b9393a83c0f736c29ba401&v=4)](/wtarreau)

Copy link

Member

### **[wtarreau](/wtarreau)** commented [Aug 16, 2023](#issuecomment-1680754847)

| [@rodrigoffzz](https://github.com/rodrigoffzz) the great news is that the problem only affects HTX mode, thus 1.9+. The legacy mode in 2.0 and before has the correct check for empty value which immediately returns a 400 bad request. This check was introduced from the beginning when we started to support keep-alive, in 1.4-dev5 with commit [32b47f4](https://github.com/haproxy/haproxy/commit/32b47f42a0d131d3889c9292a2bb06388a752969), which explains why [@kenballus](https://github.com/kenballus) found 1.3 to be affected. In fact 1.3 doesn't support keep-alive so it will pass anything as-is and will not even parse content-length. In that sense it's not affected since the right way to use it is http-close (good old times where keep-alive didn't exist :-)).  So you're fine with 1.8. However, there is still the fact that we'll pass leading zeroes as-is. This could only be addressed in 2.0+ (with HTX), it's really not feasible in older versions due to the way values are indexed (spaces are already skipped in the index). Regardless, as Ben indicated it's not a bug and what we pass is perfectly valid, it's just that we know some rare poor-quality servers can be fooled while we could have had the opportunity to clean what we pass to them. Knowing that from 2.0 and above (hence all supported versions) we can pass them something clean is already OK IMHO. |
| --- |

 👍
2
 kenballus and lukastribus reacted with thumbs up emoji
 ❤️
1
 rodrigoffzz reacted with heart emoji

All reactions

* 👍
  2 reactions
* ❤️
  1 reaction

Sorry, something went wrong.

[![@rodrigoffzz](https://avatars.githubusercontent.com/u/6108573?s=80&v=4)](/rodrigoffzz)

Copy link

### **[rodrigoffzz](/rodrigoffzz)** commented [Aug 16, 2023](#issuecomment-1681270783)

| [@rodrigoffzz](https://github.com/rodrigoffzz) the great news is that the problem only affects HTX mode, thus 1.9+. The legacy mode in 2.0 and before has the correct check for empty value which immediately returns a 400 bad request. This check was introduced from the beginning when we started to support keep-alive, in 1.4-dev5 with commit [32b47f4](https://github.com/haproxy/haproxy/commit/32b47f42a0d131d3889c9292a2bb06388a752969), which explains why [@kenballus](https://github.com/kenballus) found 1.3 to be affected. In fact 1.3 doesn't support keep-alive so it will pass anything as-is and will not even parse content-length. In that sense it's not affected since the right way to use it is http-close (good old times where keep-alive didn't exist :-)).  thank you very much for getting back with that many details, it is indeed good news :)  So you're fine with 1.8. However, there is still the fact that we'll pass leading zeroes as-is. This could only be addressed in 2.0+ (with HTX), it's really not feasible in older versions due to the way values are indexed (spaces are already skipped in the index). Regardless, as Ben indicated it's not a bug and what we pass is perfectly valid, it's just that we know some rare poor-quality servers can be fooled while we could have had the opportunity to clean what we pass to them. Knowing that from 2.0 and above (hence all supported versions) we can pass them something clean is already OK IMHO.  got it, it does make sense.  thanks again! |
| --- |

All reactions

Sorry, something went wrong.

[![@kenballus](https://avatars.githubusercontent.com/u/49924171?s=80&u=e5fdbc516bb1f36efc22782d270108d10a2b8c6c&v=4)](/kenballus)

Copy link

Author

### **[kenballus](/kenballus)** commented [Aug 16, 2023](#issuecomment-1681291586)

| So you're fine with 1.8. However, there is still the fact that we'll pass leading zeroes as-is. This could only be addressed in 2.0+ (with HTX), it's really not feasible in older versions due to the way values are indexed (spaces are already skipped in the index). Regardless, as Ben indicated it's not a bug and what we pass is perfectly valid,  Agreed.  ...it's just that we know some rare poor-quality servers can be fooled while we could have had the opportunity to clean what we pass to them.  This isn't as rare as you might think. If you're worried about this bug, you should check whether your server times out when you send it the following request:  ``` GET / HTTP/1.1\r\n Host: whatever\r\n Content-Length: 010\r\n \r\n 01234567  ```  If it times out, then your server is unaffected. If it doesn't time out, then you should consider updating. |
| --- |

 👍
2
 wtarreau and Tristan971 reacted with thumbs up emoji

All reactions

* 👍
  2 reactions

Sorry, something went wrong.

[![@wtarreau](https://avatars.githubusercontent.com/u/8141789?s=80&u=e9359a488ad99600a4b9393a83c0f736c29ba401&v=4)](/wtarreau)

Copy link

Member

### **[wtarreau](/wtarreau)** commented [Aug 16, 2023](#issuecomment-1681314188)

| This is an excellent idea indeed! Thanks! |
| --- |

All reactions

Sorry, something went wrong.

[FireBurn](/FireBurn)
pushed a commit
to FireBurn/haproxy
that referenced
this issue
[Aug 17, 2023](#ref-commit-4b40011)
[![@wtarreau](https://avatars.githubusercontent.com/u/8141789?s=40&u=e9359a488ad99600a4b9393a83c0f736c29ba401&v=4)](/wtarreau)

`[BUG/MAJOR: http: reject any empty content-length header value](/FireBurn/haproxy/commit/4b400110a58da1aa58d58d6371875a3a64c0cff6 "BUG/MAJOR: http: reject any empty content-length header value

The content-length header parser has its dedicated function, in order
to take extreme care about invalid, unparsable, or conflicting values.
But there's a corner case in it, by which it stops comparing values
when reaching the end of the header. This has for a side effect that
an empty value or a value that ends with a comma does not deserve
further analysis, and it acts as if the header was absent.

While this is not necessarily a problem for the value ending with a
comma as it will be cause a header folding and will disappear, it is a
problem for the first isolated empty header because this one will not
be recontructed when next ones are seen, and will be passed as-is to the
backend server. A vulnerable HTTP/1 server hosted behind haproxy that
would just use this first value as \"0\" and ignore the valid one would
then not be protected by haproxy and could be attacked this way, taking
the payload for an extra request.

In field the risk depends on the server. Most commonly used servers
already have safe content-length parsers, but users relying on haproxy
to protect a known-vulnerable server might be at risk (and the risk of
a bug even in a reputable server should never be dismissed).

A configuration-based work-around consists in adding the following rule
in the frontend, to explicitly reject requests featuring an empty
content-length header that would have not be folded into an existing
one:

    http-request deny if { hdr_len(content-length) 0 }

The real fix consists in adjusting the parser so that it always expects a
value at the beginning of the header or after a comma. It will now reject
requests and responses having empty values anywhere in the C-L header.

This needs to be backported to all supported versions. Note that the
modification was made to functions h1_parse_cont_len_header() and
http_parse_cont_len_header(). Prior to 2.8 the latter was in
h2_parse_cont_len_header(). One day the two should be refused but the
former is also used by Lua.

The HTTP messaging reg-tests were completed to test these cases.

Thanks to Ben Kallus of Dartmouth College and Narf Industries for
reporting this! (this is in GH #2237).

(cherry picked from commit 6492f1f29d738457ea9f382aca54537f35f9d856)
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>
(cherry picked from commit a32f99f6f991d123ea3e307bf8aa63220836d365)
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>
(cherry picked from commit 65921ee12d88e9fb1fa9f6cd8198fd64b3a3f37f)
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>
(cherry picked from commit d17c50010d591d1c070e1cb0567a06032d8869e9)
[wt: applied to h2_parse_cont_len_header() in src/h2.c instead]
Signed-off-by: Willy Tarreau <w@1wt.eu>
(cherry picked from commit ba9afd2774c03e434165475b537d0462801f49bb)
Signed-off-by: Willy Tarreau <w@1wt.eu>
(cherry picked from commit e8ba5e106444fc78558f4ff26e9ce946f89216f4)
[wt: legacy not affected, http_wait_for_request() tests for empty
 value (cf. proto_http.c:1099)]
Signed-off-by: Willy Tarreau <w@1wt.eu>")`
…

`[4b40011](/FireBurn/haproxy/commit/4b400110a58da1aa58d58d6371875a3a64c0cff6)`

```
The content-length header parser has its dedicated function, in order
to take extreme care about invalid, unparsable, or conflicting values.
But there's a corner case in it, by which it stops comparing values
when reaching the end of the header. This has for a side effect that
an empty value or a value that ends with a comma does not deserve
further analysis, and it acts as if the header was absent.

While this is not necessarily a problem for the value ending with a
comma as it will be cause a header folding and will disappear, it is a
problem for the first isolated empty header because this one will not
be recontructed when next ones are seen, and will be passed as-is to the
backend server. A vulnerable HTTP/1 server hosted behind haproxy that
would just use this first value as "0" and ignore the valid one would
then not be protected by haproxy and could be attacked this way, taking
the payload for an extra request.

In field the risk depends on the server. Most commonly used servers
already have safe content-length parsers, but users relying on haproxy
to protect a known-vulnerable server might be at risk (and the risk of
a bug even in a reputable server should never be dismissed).

A configuration-based work-around consists in adding the following rule
in the frontend, to explicitly reject requests featuring an empty
content-length header that would have not be folded into an existing
one:

    http-request deny if { hdr_len(content-length) 0 }

The real fix consists in adjusting the parser so that it always expects a
value at the beginning of the header or after a comma. It will now reject
requests and responses having empty values anywhere in the C-L header.

This needs to be backported to all supported versions. Note that the
modification was made to functions h1_parse_cont_len_header() and
http_parse_cont_len_header(). Prior to 2.8 the latter was in
h2_parse_cont_len_header(). One day the two should be refused but the
former is also used by Lua.

The HTTP messaging reg-tests were completed to test these cases.

Thanks to Ben Kallus of Dartmouth College and Narf Industries for
reporting this! (this is in GH [haproxy#2237](https://github.com/haproxy/haproxy/issues/2237)).

(cherry picked from commit [6492f1f](https://github.com/FireBurn/haproxy/commit/6492f1f29d738457ea9f382aca54537f35f9d856))
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>
(cherry picked from commit [a32f99f](https://github.com/FireBurn/haproxy/commit/a32f99f6f991d123ea3e307bf8aa63220836d365))
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>
(cherry picked from commit [65921ee](https://github.com/FireBurn/haproxy/commit/65921ee12d88e9fb1fa9f6cd8198fd64b3a3f37f))
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>
(cherry picked from commit [d17c500](https://github.com/FireBurn/haproxy/commit/d17c50010d591d1c070e1cb0567a06032d8869e9))
[wt: applied to h2_parse_cont_len_header() in src/h2.c instead]
Signed-off-by: Willy Tarreau <w@1wt.eu>
(cherry picked from commit [ba9afd2](https://github.com/FireBurn/haproxy/commit/ba9afd2774c03e434165475b537d0462801f49bb))
Signed-off-by: Willy Tarreau <w@1wt.eu>
(cherry picked from commit [e8ba5e1](https://github.com/FireBurn/haproxy/commit/e8ba5e106444fc78558f4ff26e9ce946f89216f4))
[wt: legacy not affected, http_wait_for_request() tests for empty
 value (cf. proto_http.c:1099)]
Signed-off-by: Willy Tarreau <w@1wt.eu>
```

[FireBurn](/FireBurn)
pushed a commit
to FireBurn/haproxy
that referenced
this issue
[Aug 17, 2023](#ref-commit-e8ba5e1)
[![@wtarreau](https://avatars.githubusercontent.com/u/8141789?s=40&u=e9359a488ad99600a4b9393a83c0f736c29ba401&v=4)](/wtarreau)

`[BUG/MAJOR: http: reject any empty content-length header value](/FireBurn/haproxy/commit/e8ba5e106444fc78558f4ff26e9ce946f89216f4 "BUG/MAJOR: http: reject any empty content-length header value

The content-length header parser has its dedicated function, in order
to take extreme care about invalid, unparsable, or conflicting values.
But there's a corner case in it, by which it stops comparing values
when reaching the end of the header. This has for a side effect that
an empty value or a value that ends with a comma does not deserve
further analysis, and it acts as if the header was absent.

While this is not necessarily a problem for the value ending with a
comma as it will be cause a header folding and will disappear, it is a
problem for the first isolated empty header because this one will not
be recontructed when next ones are seen, and will be passed as-is to the
backend server. A vulnerable HTTP/1 server hosted behind haproxy that
would just use this first value as \"0\" and ignore the valid one would
then not be protected by haproxy and could be attacked this way, taking
the payload for an extra request.

In field the risk depends on the server. Most commonly used servers
already have safe content-length parsers, but users relying on haproxy
to protect a known-vulnerable server might be at risk (and the risk of
a bug even in a reputable server should never be dismissed).

A configuration-based work-around consists in adding the following rule
in the frontend, to explicitly reject requests featuring an empty
content-length header that would have not be folded into an existing
one:

    http-request deny if { hdr_len(content-length) 0 }

The real fix consists in adjusting the parser so that it always expects a
value at the beginning of the header or after a comma. It will now reject
requests and responses having empty values anywhere in the C-L header.

This needs to be backported to all supported versions. Note that the
modification was made to functions h1_parse_cont_len_header() and
http_parse_cont_len_header(). Prior to 2.8 the latter was in
h2_parse_cont_len_header(). One day the two should be refused but the
former is also used by Lua.

The HTTP messaging reg-tests were completed to test these cases.

Thanks to Ben Kallus of Dartmouth College and Narf Industries for
reporting this! (this is in GH #2237).

(cherry picked from commit 6492f1f29d738457ea9f382aca54537f35f9d856)
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>
(cherry picked from commit a32f99f6f991d123ea3e307bf8aa63220836d365)
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>
(cherry picked from commit 65921ee12d88e9fb1fa9f6cd8198fd64b3a3f37f)
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>
(cherry picked from commit d17c50010d591d1c070e1cb0567a06032d8869e9)
[wt: applied to h2_parse_cont_len_header() in src/h2.c instead]
Signed-off-by: Willy Tarreau <w@1wt.eu>
(cherry picked from commit ba9afd2774c03e434165475b537d0462801f49bb)
Signed-off-by: Willy Tarreau <w@1wt.eu>")`
…

`[e8ba5e1](/FireBurn/haproxy/commit/e8ba5e106444fc78558f4ff26e9ce946f89216f4)`

```
The content-length header parser has its dedicated function, in order
to take extreme care about invalid, unparsable, or conflicting values.
But there's a corner case in it, by which it stops comparing values
when reaching the end of the header. This has for a side effect that
an empty value or a value that ends with a comma does not deserve
further analysis, and it acts as if the header was absent.

While this is not necessarily a problem for the value ending with a
comma as it will be cause a header folding and will disappear, it is a
problem for the first isolated empty header because this one will not
be recontructed when next ones are seen, and will be passed as-is to the
backend server. A vulnerable HTTP/1 server hosted behind haproxy that
would just use this first value as "0" and ignore the valid one would
then not be protected by haproxy and could be attacked this way, taking
the payload for an extra request.

In field the risk depends on the server. Most commonly used servers
already have safe content-length parsers, but users relying on haproxy
to protect a known-vulnerable server might be at risk (and the risk of
a bug even in a reputable server should never be dismissed).

A configuration-based work-around consists in adding the following rule
in the frontend, to explicitly reject requests featuring an empty
content-length header that would have not be folded into an existing
one:

    http-request deny if { hdr_len(content-length) 0 }

The real fix consists in adjusting the parser so that it always expects a
value at the beginning of the header or after a comma. It will now reject
requests and responses having empty values anywhere in the C-L header.

This needs to be backported to all supported versions. Note that the
modification was made to functions h1_parse_cont_len_header() and
http_parse_cont_len_header(). Prior to 2.8 the latter was in
h2_parse_cont_len_header(). One day the two should be refused but the
former is also used by Lua.

The HTTP messaging reg-tests were completed to test these cases.

Thanks to Ben Kallus of Dartmouth College and Narf Industries for
reporting this! (this is in GH [haproxy#2237](https://github.com/haproxy/haproxy/issues/2237)).

(cherry picked from commit [6492f1f](https://github.com/FireBurn/haproxy/commit/6492f1f29d738457ea9f382aca54537f35f9d856))
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>
(cherry picked from commit [a32f99f](https://github.com/FireBurn/haproxy/commit/a32f99f6f991d123ea3e307bf8aa63220836d365))
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>
(cherry picked from commit [65921ee](https://github.com/FireBurn/haproxy/commit/65921ee12d88e9fb1fa9f6cd8198fd64b3a3f37f))
Signed-off-by: Amaury Denoyelle <adenoyelle@haproxy.com>
(cherry picked from commit [d17c500](https://github.com/FireBurn/haproxy/commit/d17c50010d591d1c070e1cb0567a06032d8869e9))
[wt: applied to h2_parse_cont_len_header() in src/h2.c instead]
Signed-off-by: Willy Tarreau <w@1wt.eu>
(cherry picked from commit [ba9afd2](https://github.com/FireBurn/haproxy/commit/ba9afd2774c03e434165475b537d0462801f49bb))
Signed-off-by: Willy Tarreau <w@1wt.eu>
```

[![@pdeslaur](https://avatars.githubusercontent.com/u/1692704?s=40&v=4)](/pdeslaur)
[pdeslaur](/pdeslaur)
mentioned this issue
[Aug 22, 2023](#ref-pullrequest-1861835827)

[haproxy: Advisory for CVE-2023-40225
wolfi-dev/advisories#189](/wolfi-dev/advisories/pull/189)
 Merged

[![@capflam](https://avatars.githubusercontent.com/u/159766?s=40&v=4)](/capflam)
[capflam](/capflam)
removed
[2.0](/haproxy/haproxy/labels/2.0)
This issue affects the HAProxy 2.0 stable branch.
[2.2](/haproxy/haproxy/labels/2.2)
This issue affects the HAProxy 2.2 stable branch.
[2.4](/haproxy/haproxy/labels/2.4)
This issue affects the HAProxy 2.4 stable branch.
labels
[Aug 28, 2023](#event-10208503658)

[![@capflam](https://avatars.githubusercontent.com/u/159766?s=40&v=4)](/capflam)
[capflam](/capflam)
closed this as [completed](/haproxy/haproxy/issues?q=is%3Aissue+is%3Aclosed+archived%3Afalse+reason%3Acompleted)
[Aug 28, 2023](#event-10208504624)

[Sign up for free](/join?source=comment-repo)
**to join this conversation on GitHub**.
Already have an account?
[Sign in to comment](/login?return_to=https%3A%2F%2Fgithub.com%2Fhaproxy%2Fhaproxy%2Fissues%2F2237)

Assignees

No one assigned

Labels

[status: fixed](/haproxy/haproxy/labels/status%3A%20fixed)
This issue is a now-fixed bug.
[subsystem: http](/haproxy/haproxy/labels/subsystem%3A%20http)
This issue is within the HTTP subsystem.
[type: bug](/haproxy/haproxy/labels/type%3A%20bug)
This issue describes a bug.

Projects

None yet

Milestone

No milestone

Development

No branches or pull requests

9 participants

[![@capflam](https://avatars.githubusercontent.com/u/159766?s=52&v=4)](/capflam) [![@Tristan971](https://avatars.githubusercontent.com/u/875533?s=52&v=4)](/Tristan971) [![@rfrohl](https://avatars.githubusercontent.com/u/1474150?s=52&v=4)](/rfrohl) [![@git001](https://avatars.githubusercontent.com/u/1579468?s=52&v=4)](/git001) [![@rodrigoffzz](https://avatars.githubusercontent.com/u/6108573?s=52&v=4)](/rodrigoffzz) [![@wtarreau](https://avatars.githubusercontent.com/u/8141789?s=52&v=4)](/wtarreau) [![@robert-scheck](https://avatars.githubusercontent.com/u/10982488?s=52&v=4)](/robert-scheck) [![@kenballus](https://avatars.githubusercontent.com/u/49924171?s=52&v=4)](/kenballus) [![@firexinghe](https://avatars.githubusercontent.com/u/80017732?s=52&v=4)](/firexinghe)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

