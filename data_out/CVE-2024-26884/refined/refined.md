```
{
  "cveId": "CVE-2024-26884",
  "related": true,
  "content": "The hashtab code relies on roundup_pow_of_two() to compute the number of hash buckets, and contains an overflow check by checking if the resulting value is 0. However, on 32-bit arches, the roundup code itself can overflow by doing a 32-bit left-shift of an unsigned long value, which is undefined behaviour, so it is not guaranteed to truncate neatly. This was triggered by syzbot on the DEVMAP_HASH type, which contains the same check, copied from the hashtab code. So apply the same fix to hashtab, by moving the overflow check to before the roundup.\n",
  "vulnerability": {
    "rootCause": "The `roundup_pow_of_two()` function, used to calculate the number of hash buckets in the BPF hashtab implementation, can overflow on 32-bit architectures due to a left-shift operation on an unsigned long value. This leads to undefined behavior and unreliable truncation, which can bypass the overflow check.",
    "weaknesses": [
      "Integer Overflow",
      "Undefined Behavior"
    ],
    "impact": "If the overflow check is bypassed, it can lead to various issues depending on how the resulting value is used later. While not explicitly stated, this can cause memory corruption or other errors due to the incorrect size calculation, leading to a denial-of-service or potentially other exploits.",
    "attackVectors": "An attacker could craft a BPF program that requests a hashmap allocation with a `max_entries` value that triggers the overflow in the `roundup_pow_of_two()` function during the hash bucket calculation.",
    "requiredCapabilities": "An attacker needs the capability to load and execute BPF programs, as the vulnerability exists in the kernel's BPF hashtable implementation. This could be achieved through a local user with the ability to create such BPF programs or an exploit in a kernel service that accepts such programs."
  }
}
```