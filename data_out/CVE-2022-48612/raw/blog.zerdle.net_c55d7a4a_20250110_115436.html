<!doctype html><html lang=en><head><title>How I Found A Vulnerability in The ClassLink OneClick Extension (CVE-2022-48612) | James Connolly's Blog</title><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=noodp name=robots><link href=https://blog.zerdle.net/style.css rel=stylesheet><link href=https://blog.zerdle.net/color/red.css rel=stylesheet><link href=https://blog.zerdle.net/color/background_dark.css rel=stylesheet><link href=https://blog.zerdle.net/font-hack-subset.css rel=stylesheet><meta name=description><meta property=og:description><meta content="How I Found A Vulnerability in The ClassLink OneClick Extension (CVE-2022-48612) | James Connolly's Blog" property=og:title><meta content=article property=og:type><meta content=https://blog.zerdle.net/classlink/ property=og:url><meta content=summary_large_image name=twitter:card><meta name=twitter:description><meta content="How I Found A Vulnerability in The ClassLink OneClick Extension (CVE-2022-48612) | James Connolly's Blog" name=twitter:title><meta content=blog.zerdle.net property=twitter:domain><meta content=https://blog.zerdle.net/classlink/ property=twitter:url><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a href=https://blog.zerdle.net style=text-decoration:none> <div class=logo>James Connolly's Blog</div> </a></div></div></header><div class=content><div class=post><h1 class=post-title><a href=https://blog.zerdle.net/classlink/>How I Found A Vulnerability in The ClassLink OneClick Extension (CVE-2022-48612)</a></h1><div class=post-meta-inline><span class=post-date> 2022-12-16 </span></div><div class=post-content><p>This is the story of how I found a universal cross-site scripting vector in a browser extension used by over 10 million users.</p><span id=continue-reading></span><h1 id=introduction>Introduction</h1><p>I could immediately tell I would find something as soon as my school rolled out the extension, and once I saw the permissions it requested, I knew I would find something <em>extra</em> spicy.<figure class=center><img alt="ClassLink OneClick Extension permissions" decoding=async loading=lazy src=/classlink/permissions.jpg><figcaption class=center><p>the inability to disable the extension and high privileges were motivating factors in this research</p></figcaption></figure><h1 id=what-is-this-extension>What Is This Extension?</h1><p>This extension is designed to work in tandem with ClassLink LaunchPad which enables a student to select and automatically sign into educational websites. School IT staff load their students' credentials into LaunchPad's admin console; later, when a student clicks a website on LaunchPad, it sends their credentials to the extension which signs them in.<h1 id=suspicious-function>Suspicious Function</h1><p>While Scrolling through a pretty-printed version of <code>injected.js</code>, part of the code immediately attracted my attention.<p><img alt="suspicious code section" src=/classlink/sus.jpg><h2 id=confusion>Confusion</h2><p>Why would this extension need to inject scripts into the DOM? It turns out that this is actually the primary pattern behind the whole extension. There is a bit of JavaScript for each website they integrate with that is responsible for logging a user in. ClassLink LaunchPad connects to over 6,000 websites, so I can understand why the flexibility of running unique JavaScript for each site becomes appealing.<h2 id=how-can-we-exploit-this>How Can We Exploit This?</h2><p>It would be possible to exploit the <code>e</code> function if we can control <code>appResponse.pre_auth_script</code> and the window location. This would enable an attacker to inject any script into any page, in other words, universal cross-site scripting.<h1 id=backtracking>Backtracking</h1><p>Following the code backwards, I found that the <code>e</code> function is called from an event listener.<p><img alt="message listener which calls suspicious code" src=/classlink/handle-sso.jpg><p>At first this looks trivially exploitable by sending a <code>handle-sso</code> message from a webpage. Unfortunately for an attacker, <code>chrome.runtime.onMessage</code> has protections against this. Here is a section from <a href=https://developer.chrome.com/docs/extensions/mv2/messaging/>Message Passing (Chrome Developers)</a>.<p><img alt="article section from Chrome Developers" src=/classlink/messages_from_webpages.jpg><p>In order to send a message to this listener, the extension would need to have an attacker-controlled domain in their <code>manifest.json</code>, which effectively closes off this route of exploitation.<h2 id=sending-handle-sso>Sending "handle-sso"</h2><p>Because <code>externally_connectable</code> is not in <code>manifest.json</code>, we know that <code>handle-sso</code> messages can be only be sent from <code>background.js</code>. Searching for <code>handle-sso</code> in <code>background.js</code> yields this event listener:<p><img alt='sending "handle-sso" message when a new tab is opened' src=/classlink/send-handle-sso.jpg><p>A <code>handle-sso</code> message is sent when a new tab is opened, but the listener is created only after <code>background.js</code> receives an <code>initiate-sso</code> message. This message is sent by the following function in <code>injected.js</code>:<p><img alt='function that sends "initiate-sso" message' src=/classlink/send-initiate-sso.jpg><p>This <code>s</code> function takes in a parameter that's passed into the <code>initiate-sso</code> message, so calling <code>s</code> with user-controlled data is equivalent to universal cross-site scripting.<p><code>s</code> is called here, but it's behind a regex that validates if the URL is controlled by ClassLink. However, this is not the only place that calls <code>s</code>â¦<p><img alt='regex check before "initiate-sso" send function' src=/classlink/regex_guard.jpg><h1 id=the-fundamental-flaw>The Fundamental Flaw</h1><p>The <code>s</code> function is also called here:<p><img alt="duplicated from previous code but without the regex check" src=/classlink/clickhandle.jpg><p>For whatever reason, there existed a mostly copied and pasted version of the previous code snippet which omits the regex check. This code registers click handler, but only for elements with two magic classes: <code>bg-info</code> and <code>js-uc</code>.<p>The failure to run the regex in this case is the root cause of this vulnerability. Putting carefully crafted data into the head of the document will allow us to control the parameters of <code>s</code> and, by proxy, get universal cross-site scripting.<h1 id=creating-a-proof-of-concept>Creating a Proof of Concept</h1><p>Here is the code for a proof of concept:<pre class=language-html data-lang=html style=background:#2b303b;color:#c0c5ce><code class=language-html data-lang=html><span><</span><span style=color:#bf616a>html</span><span>>
</span><span>	<</span><span style=color:#bf616a>head</span><span>>
</span><span>		<</span><span style=color:#bf616a>title</span><span>>ClassLink OneClick UXSS&LT/</span><span style=color:#bf616a>title</span><span>>
</span><span>		<</span><span style=color:#bf616a>script</span><span>>
</span><span>			</span><span style=color:#65737e>//appResponse: JSON.parse('{"userauth": [""], "pre_auth_script": "alert(window.location)"}'),
</span><span>			</span><span style=color:#65737e>//gwstokenMd5:{}
</span><span>
</span><span>			</span><span style=color:#96b5b4>setTimeout</span><span>(</span><span style=color:#b48ead>function</span><span>() {
</span><span>				</span><span style=color:#b48ead>const </span><span style=color:#bf616a>button </span><span>= document.</span><span style=color:#bf616a>getElementById</span><span>("</span><span style=color:#a3be8c>button</span><span>");
</span><span>
</span><span>				</span><span style=color:#bf616a>button</span><span>.</span><span style=color:#bf616a>click</span><span>();
</span><span>				window.location.href = "</span><span style=color:#a3be8c>https://example.com</span><span>";
</span><span>			}, </span><span style=color:#d08770>200</span><span>);
</span><span>		&LT/</span><span style=color:#bf616a>script</span><span>>
</span><span>	&LT/</span><span style=color:#bf616a>head</span><span>>
</span><span>	<</span><span style=color:#bf616a>body</span><span>>
</span><span>		<</span><span style=color:#bf616a>button </span><span style=color:#8fa1b3>id</span><span>="</span><span style=color:#a3be8c>button</span><span>" </span><span style=color:#d08770>class</span><span>="</span><span style=color:#a3be8c>bg-info js-uc</span><span>" </span><span style=color:#d08770>data-index</span><span>="</span><span style=color:#a3be8c>0</span><span>">button of doom&LT/</span><span style=color:#bf616a>button</span><span>>
</span><span>	&LT/</span><span style=color:#bf616a>body</span><span>>
</span><span>&LT/</span><span style=color:#bf616a>html</span><span>>
</span></code></pre><p>In the body, there's a button with the two magic classes the click handler checks. The button also has <code>data-index="0"</code> and <code>appResponse</code> has <code>userauth</code> set as <code>[""]</code> to prevent an out of bounds array index. The <code>pre_auth_script</code> property of <code>appResponse</code> functions as the payload.<h1 id=reporting>Reporting</h1><p>I was initially frustrated by the lack of official avenue to report vulnerabilities. I reported this vulnerability through the help desk, which made me a bit anxious me due to the possibility that details of my report could be intercepted by a third party. I advise that ClassLink adopts RFC 9116 (security.txt) to make it more clear to researchers where and how they should report vulnerabilities in the future.<h2 id=timeline>Timeline</h2><ul><li>September 15th, 2022: vulnerability reported to ClassLink.<li>September 19th, 2022: I received an acknowledgement from ClassLink.<li>October 25th, 2022: I inquired about the status of a fix.<li>November 8th, 2022: I received notice that a patch would roll out on December 1st.<li>December 1st, 2022: The vulnerability was patched.</ul><h1 id=acknowledging-previous-research>Acknowledging Previous Research</h1><p>I stumbled upon <a href=https://seclists.org/fulldisclosure/2018/Jun/20>research</a> done in 2018 that was published on the Full Disclosure mailing list. They made eerily similar findings to me. The research from 2018 exploits the same function which injects scripts into the DOM, but with a different way of triggering it. I assume this research is responsible for the implementation of the URL regex check mentioned earlier in the article.<h1 id=analysis-of-the-patch>Analysis of The Patch</h1><p>The patch adds the regex guard to the <code>s</code> function. I tested my proof of concept code against the latest version and confirmed that it is sufficient to prevent exploitation.<p><img alt='patched function that sends "initiate-sso" function' src=/classlink/patched_send-initiate-sso.jpg></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Thanks for reading! Read other posts?</span><hr></div><div class=pagination__buttons><span class="button next"> <a href=https://blog.zerdle.net/buckeye2023_area51/> <span class=button__text>BuckeyeCTF 2023 web/area51 Writeup</span>Â  <span class=button__icon>â</span> </a> </span></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>Â© 2024 Powered by <a href=https://www.getzola.org/>Zola</a></span><span class=copyright-theme> <span class=copyright-theme-sep>:: </span> Theme: <a href=https://github.com/pawroman/zola-theme-terminimal/>Terminimal</a> by pawroman </span></div></div></footer></div>