Based on the provided information, this content relates to **CVE-2021-47617**.

**Root cause of vulnerability:**
The root cause of the vulnerability is an infinite loop in the PCIe hotplug interrupt handler (`pciehp_isr()`) when a power fault is detected. The "Power Fault Detected" bit in the Slot Status register is sticky and can only be cleared after turning off power to the slot. The hardirq handler clears the PFD bit until the `power_fault_detected` flag is set, which happens in the IRQ thread `pciehp_ist()`. However, the IRQ thread cannot learn about the event and the hardirq handler gets stuck in an infinite loop.

**Weaknesses/vulnerabilities present:**
-   **Infinite Loop:** The primary vulnerability is the potential for an infinite loop within the interrupt handler.
-   **Sticky Status Bit Handling:** The logic incorrectly handled the sticky nature of the "Power Fault Detected" bit in the PCI slot status register.
-   **Race Condition**: The race condition introduced by commit 8edf5332c393 caused the issue to reappear.

**Impact of exploitation:**
-   **System Unresponsiveness:** The infinite loop in the interrupt handler can lead to system unresponsiveness or a hang.
-   **Denial of Service (DoS):**  The system becomes unusable due to the loop preventing the processing of other tasks or interrupts.

**Attack vectors:**
-   **Power Fault:** The vulnerability is triggered when a power fault is detected on a hot-plug PCI slot. This can occur due to hardware malfunctions or potentially via external manipulation of the power supply.

**Required attacker capabilities/position:**
-   The attacker needs to be able to cause a power fault condition on a hot-pluggable PCIe slot. This may require some level of access to the physical hardware or manipulation of the power supply.

**Additional Notes:**
- The fix involves setting the `power_fault_detected` flag in the hardirq handler itself, which allows the IRQ thread to properly handle the event.
- The issue was inadvertently reintroduced after being fixed in 2009, due to a separate change in 2020.
- The fix is present in multiple kernel versions.