
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fdani-garcia%2Fvaultwarden%2Fblob%2F1.30.3%2Fsrc%2Fapi%2Fcore%2Femergency_access.rs)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fdani-garcia%2Fvaultwarden%2Fblob%2F1.30.3%2Fsrc%2Fapi%2Fcore%2Femergency_access.rs)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=dani-garcia%2Fvaultwarden)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[dani-garcia](/dani-garcia)
/
**[vaultwarden](/dani-garcia/vaultwarden)**
Public

* [Notifications](/login?return_to=%2Fdani-garcia%2Fvaultwarden) You must be signed in to change notification settings
* [Fork
  2k](/login?return_to=%2Fdani-garcia%2Fvaultwarden)
* [Star
   40.7k](/login?return_to=%2Fdani-garcia%2Fvaultwarden)

* [Code](/dani-garcia/vaultwarden/tree/1.30.3)
* [Issues
  8](/dani-garcia/vaultwarden/issues)
* [Pull requests
  7](/dani-garcia/vaultwarden/pulls)
* [Discussions](/dani-garcia/vaultwarden/discussions)
* [Actions](/dani-garcia/vaultwarden/actions)
* [Wiki](/dani-garcia/vaultwarden/wiki)
* [Security](/dani-garcia/vaultwarden/security)
* [Insights](/dani-garcia/vaultwarden/pulse)

Additional navigation options

* [Code](/dani-garcia/vaultwarden/tree/1.30.3)
* [Issues](/dani-garcia/vaultwarden/issues)
* [Pull requests](/dani-garcia/vaultwarden/pulls)
* [Discussions](/dani-garcia/vaultwarden/discussions)
* [Actions](/dani-garcia/vaultwarden/actions)
* [Wiki](/dani-garcia/vaultwarden/wiki)
* [Security](/dani-garcia/vaultwarden/security)
* [Insights](/dani-garcia/vaultwarden/pulse)

## Files

 1.30.3
## Breadcrumbs

1. [vaultwarden](/dani-garcia/vaultwarden/tree/1.30.3)
2. /[src](/dani-garcia/vaultwarden/tree/1.30.3/src)
3. /[api](/dani-garcia/vaultwarden/tree/1.30.3/src/api)
4. /[core](/dani-garcia/vaultwarden/tree/1.30.3/src/api/core)
/
# emergency\_access.rs

Copy path Blame  Blame
## Latest commit

## History

[History](/dani-garcia/vaultwarden/commits/1.30.3/src/api/core/emergency_access.rs)864 lines (720 loc) · 29.2 KB 1.30.3
## Breadcrumbs

1. [vaultwarden](/dani-garcia/vaultwarden/tree/1.30.3)
2. /[src](/dani-garcia/vaultwarden/tree/1.30.3/src)
3. /[api](/dani-garcia/vaultwarden/tree/1.30.3/src/api)
4. /[core](/dani-garcia/vaultwarden/tree/1.30.3/src/api/core)
/
# emergency\_access.rs

Top
## File metadata and controls

* Code
* Blame

864 lines (720 loc) · 29.2 KB[Raw](https://github.com/dani-garcia/vaultwarden/raw/refs/tags/1.30.3/src/api/core/emergency_access.rs)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864use chrono::{Duration, Utc};use rocket::{serde::json::Json, Route};use serde\_json::Value;
use crate::{ api::{ core::{CipherSyncData, CipherSyncType}, EmptyResult, JsonResult, JsonUpcase, }, auth::{decode\_emergency\_access\_invite, Headers}, db::{models::\*, DbConn, DbPool}, mail, util::NumberOrString, CONFIG,};
pub fn routes() -> Vec<Route> { routes![ get\_contacts, get\_grantees, get\_emergency\_access, put\_emergency\_access, post\_emergency\_access, delete\_emergency\_access, post\_delete\_emergency\_access, send\_invite, resend\_invite, accept\_invite, confirm\_emergency\_access, initiate\_emergency\_access, approve\_emergency\_access, reject\_emergency\_access, takeover\_emergency\_access, password\_emergency\_access, view\_emergency\_access, policies\_emergency\_access, ]}
// region get
#[get("/emergency-access/trusted")]async fn get\_contacts(headers: Headers, mut conn: DbConn) -> Json<Value> { if !CONFIG.emergency\_access\_allowed() { return Json(json!({ "Data": [{ "Id": "", "Status": 2, "Type": 0, "WaitTimeDays": 0, "GranteeId": "", "Email": "", "Name": "NOTE: Emergency Access is disabled!", "Object": "emergencyAccessGranteeDetails",
 }], "Object": "list", "ContinuationToken": null })); } let emergency\_access\_list = EmergencyAccess::find\_all\_by\_grantor\_uuid(&headers.user.uuid, &mut conn).await; let mut emergency\_access\_list\_json = Vec::with\_capacity(emergency\_access\_list.len()); for ea in emergency\_access\_list { emergency\_access\_list\_json.push(ea.to\_json\_grantee\_details(&mut conn).await); }
 Json(json!({ "Data": emergency\_access\_list\_json, "Object": "list", "ContinuationToken": null }))}
#[get("/emergency-access/granted")]async fn get\_grantees(headers: Headers, mut conn: DbConn) -> Json<Value> { let emergency\_access\_list = if CONFIG.emergency\_access\_allowed() { EmergencyAccess::find\_all\_by\_grantee\_uuid(&headers.user.uuid, &mut conn).await } else { Vec::new() }; let mut emergency\_access\_list\_json = Vec::with\_capacity(emergency\_access\_list.len()); for ea in emergency\_access\_list { emergency\_access\_list\_json.push(ea.to\_json\_grantor\_details(&mut conn).await); }
 Json(json!({ "Data": emergency\_access\_list\_json, "Object": "list", "ContinuationToken": null }))}
#[get("/emergency-access/<emer\_id>")]async fn get\_emergency\_access(emer\_id: &str, mut conn: DbConn) -> JsonResult { check\_emergency\_access\_enabled()?;
 match EmergencyAccess::find\_by\_uuid(emer\_id, &mut conn).await { Some(emergency\_access) => Ok(Json(emergency\_access.to\_json\_grantee\_details(&mut conn).await)), None => err!("Emergency access not valid."), }}
// endregion
// region put/post
#[derive(Deserialize)]#[allow(non\_snake\_case)]struct EmergencyAccessUpdateData { Type: NumberOrString, WaitTimeDays: i32, KeyEncrypted: Option<String>,}
#[put("/emergency-access/<emer\_id>", data = "<data>")]async fn put\_emergency\_access(emer\_id: &str, data: JsonUpcase<EmergencyAccessUpdateData>, conn: DbConn) -> JsonResult { post\_emergency\_access(emer\_id, data, conn).await}
#[post("/emergency-access/<emer\_id>", data = "<data>")]async fn post\_emergency\_access( emer\_id: &str, data: JsonUpcase<EmergencyAccessUpdateData>, mut conn: DbConn,) -> JsonResult { check\_emergency\_access\_enabled()?;
 let data: EmergencyAccessUpdateData = data.into\_inner().data;
 let mut emergency\_access = match EmergencyAccess::find\_by\_uuid(emer\_id, &mut conn).await { Some(emergency\_access) => emergency\_access, None => err!("Emergency access not valid."), };
 let new\_type = match EmergencyAccessType::from\_str(&data.Type.into\_string()) { Some(new\_type) => new\_type as i32, None => err!("Invalid emergency access type."), };
 emergency\_access.atype = new\_type; emergency\_access.wait\_time\_days = data.WaitTimeDays; if data.KeyEncrypted.is\_some() { emergency\_access.key\_encrypted = data.KeyEncrypted; }
 emergency\_access.save(&mut conn).await?; Ok(Json(emergency\_access.to\_json()))}
// endregion
// region delete
#[delete("/emergency-access/<emer\_id>")]async fn delete\_emergency\_access(emer\_id: &str, headers: Headers, mut conn: DbConn) -> EmptyResult { check\_emergency\_access\_enabled()?;
 let grantor\_user = headers.user;
 let emergency\_access = match EmergencyAccess::find\_by\_uuid(emer\_id, &mut conn).await { Some(emer) => { if emer.grantor\_uuid != grantor\_user.uuid && emer.grantee\_uuid != Some(grantor\_user.uuid) { err!("Emergency access not valid.") } emer } None => err!("Emergency access not valid."), }; emergency\_access.delete(&mut conn).await?; Ok(())}
#[post("/emergency-access/<emer\_id>/delete")]async fn post\_delete\_emergency\_access(emer\_id: &str, headers: Headers, conn: DbConn) -> EmptyResult { delete\_emergency\_access(emer\_id, headers, conn).await}
// endregion
// region invite
#[derive(Deserialize)]#[allow(non\_snake\_case)]struct EmergencyAccessInviteData { Email: String, Type: NumberOrString, WaitTimeDays: i32,}
#[post("/emergency-access/invite", data = "<data>")]async fn send\_invite(data: JsonUpcase<EmergencyAccessInviteData>, headers: Headers, mut conn: DbConn) -> EmptyResult { check\_emergency\_access\_enabled()?;
 let data: EmergencyAccessInviteData = data.into\_inner().data; let email = data.Email.to\_lowercase(); let wait\_time\_days = data.WaitTimeDays;
 let emergency\_access\_status = EmergencyAccessStatus::Invited as i32;
 let new\_type = match EmergencyAccessType::from\_str(&data.Type.into\_string()) { Some(new\_type) => new\_type as i32, None => err!("Invalid emergency access type."), };
 let grantor\_user = headers.user;
 // avoid setting yourself as emergency contact if email == grantor\_user.email { err!("You can not set yourself as an emergency contact.") }
 let grantee\_user = match User::find\_by\_mail(&email, &mut conn).await { None => { if !CONFIG.invitations\_allowed() { err!(format!("Grantee user does not exist: {}", &email)) }
 if !CONFIG.is\_email\_domain\_allowed(&email) { err!("Email domain not eligible for invitations") }
 if !CONFIG.mail\_enabled() { let invitation = Invitation::new(&email); invitation.save(&mut conn).await?; }
 let mut user = User::new(email.clone()); user.save(&mut conn).await?; user } Some(user) => user, };
 if EmergencyAccess::find\_by\_grantor\_uuid\_and\_grantee\_uuid\_or\_email( &grantor\_user.uuid, &grantee\_user.uuid, &grantee\_user.email, &mut conn, ) .await .is\_some() { err!(format!("Grantee user already invited: {}", &grantee\_user.email)) }
 let mut new\_emergency\_access = EmergencyAccess::new(grantor\_user.uuid, grantee\_user.email, emergency\_access\_status, new\_type, wait\_time\_days); new\_emergency\_access.save(&mut conn).await?;
 if CONFIG.mail\_enabled() { mail::send\_emergency\_access\_invite( &new\_emergency\_access.email.expect("Grantee email does not exists"), &grantee\_user.uuid, &new\_emergency\_access.uuid, &grantor\_user.name, &grantor\_user.email, ) .await?; } else { // Automatically mark user as accepted if no email invites match User::find\_by\_mail(&email, &mut conn).await { Some(user) => match accept\_invite\_process(&user.uuid, &mut new\_emergency\_access, &email, &mut conn).await { Ok(v) => v, Err(e) => err!(e.to\_string()), }, None => err!("Grantee user not found."), } }
 Ok(())}
#[post("/emergency-access/<emer\_id>/reinvite")]async fn resend\_invite(emer\_id: &str, headers: Headers, mut conn: DbConn) -> EmptyResult { check\_emergency\_access\_enabled()?;
 let mut emergency\_access = match EmergencyAccess::find\_by\_uuid(emer\_id, &mut conn).await { Some(emer) => emer, None => err!("Emergency access not valid."), };
 if emergency\_access.grantor\_uuid != headers.user.uuid { err!("Emergency access not valid."); }
 if emergency\_access.status != EmergencyAccessStatus::Invited as i32 { err!("The grantee user is already accepted or confirmed to the organization"); }
 let email = match emergency\_access.email.clone() { Some(email) => email, None => err!("Email not valid."), };
 let grantee\_user = match User::find\_by\_mail(&email, &mut conn).await { Some(user) => user, None => err!("Grantee user not found."), };
 let grantor\_user = headers.user;
 if CONFIG.mail\_enabled() { mail::send\_emergency\_access\_invite( &email, &grantor\_user.uuid, &emergency\_access.uuid, &grantor\_user.name, &grantor\_user.email, ) .await?; } else { if Invitation::find\_by\_mail(&email, &mut conn).await.is\_none() { let invitation = Invitation::new(&email); invitation.save(&mut conn).await?; }
 // Automatically mark user as accepted if no email invites match accept\_invite\_process(&grantee\_user.uuid, &mut emergency\_access, &email, &mut conn).await { Ok(v) => v, Err(e) => err!(e.to\_string()), } }
 Ok(())}
#[derive(Deserialize)]#[allow(non\_snake\_case)]struct AcceptData { Token: String,}
#[post("/emergency-access/<emer\_id>/accept", data = "<data>")]async fn accept\_invite(emer\_id: &str, data: JsonUpcase<AcceptData>, headers: Headers, mut conn: DbConn) -> EmptyResult { check\_emergency\_access\_enabled()?;
 let data: AcceptData = data.into\_inner().data; let token = &data.Token; let claims = decode\_emergency\_access\_invite(token)?;
 // This can happen if the user who received the invite used a different email to signup. // Since we do not know if this is intended, we error out here and do nothing with the invite. if claims.email != headers.user.email { err!("Claim email does not match current users email") }
 let grantee\_user = match User::find\_by\_mail(&claims.email, &mut conn).await { Some(user) => { Invitation::take(&claims.email, &mut conn).await; user } None => err!("Invited user not found"), };
 let mut emergency\_access = match EmergencyAccess::find\_by\_uuid(emer\_id, &mut conn).await { Some(emer) => emer, None => err!("Emergency access not valid."), };
 // get grantor user to send Accepted email let grantor\_user = match User::find\_by\_uuid(&emergency\_access.grantor\_uuid, &mut conn).await { Some(user) => user, None => err!("Grantor user not found."), };
 if emer\_id == claims.emer\_id && grantor\_user.name == claims.grantor\_name && grantor\_user.email == claims.grantor\_email { match accept\_invite\_process(&grantee\_user.uuid, &mut emergency\_access, &grantee\_user.email, &mut conn).await { Ok(v) => v, Err(e) => err!(e.to\_string()), }
 if CONFIG.mail\_enabled() { mail::send\_emergency\_access\_invite\_accepted(&grantor\_user.email, &grantee\_user.email).await?; }
 Ok(()) } else { err!("Emergency access invitation error.") }}
async fn accept\_invite\_process( grantee\_uuid: &str, emergency\_access: &mut EmergencyAccess, grantee\_email: &str, conn: &mut DbConn,) -> EmptyResult { if emergency\_access.email.is\_none() || emergency\_access.email.as\_ref().unwrap() != grantee\_email { err!("User email does not match invite."); }
 if emergency\_access.status == EmergencyAccessStatus::Accepted as i32 { err!("Emergency contact already accepted."); }
 emergency\_access.status = EmergencyAccessStatus::Accepted as i32; emergency\_access.grantee\_uuid = Some(String::from(grantee\_uuid)); emergency\_access.email = None; emergency\_access.save(conn).await}
#[derive(Deserialize)]#[allow(non\_snake\_case)]struct ConfirmData { Key: String,}
#[post("/emergency-access/<emer\_id>/confirm", data = "<data>")]async fn confirm\_emergency\_access( emer\_id: &str, data: JsonUpcase<ConfirmData>, headers: Headers, mut conn: DbConn,) -> JsonResult { check\_emergency\_access\_enabled()?;
 let confirming\_user = headers.user; let data: ConfirmData = data.into\_inner().data; let key = data.Key;
 let mut emergency\_access = match EmergencyAccess::find\_by\_uuid(emer\_id, &mut conn).await { Some(emer) => emer, None => err!("Emergency access not valid."), };
 if emergency\_access.status != EmergencyAccessStatus::Accepted as i32 || emergency\_access.grantor\_uuid != confirming\_user.uuid { err!("Emergency access not valid.") }
 let grantor\_user = match User::find\_by\_uuid(&confirming\_user.uuid, &mut conn).await { Some(user) => user, None => err!("Grantor user not found."), };
 if let Some(grantee\_uuid) = emergency\_access.grantee\_uuid.as\_ref() { let grantee\_user = match User::find\_by\_uuid(grantee\_uuid, &mut conn).await { Some(user) => user, None => err!("Grantee user not found."), };
 emergency\_access.status = EmergencyAccessStatus::Confirmed as i32; emergency\_access.key\_encrypted = Some(key); emergency\_access.email = None;
 emergency\_access.save(&mut conn).await?;
 if CONFIG.mail\_enabled() { mail::send\_emergency\_access\_invite\_confirmed(&grantee\_user.email, &grantor\_user.name).await?; } Ok(Json(emergency\_access.to\_json())) } else { err!("Grantee user not found.") }}
// endregion
// region access emergency access
#[post("/emergency-access/<emer\_id>/initiate")]async fn initiate\_emergency\_access(emer\_id: &str, headers: Headers, mut conn: DbConn) -> JsonResult { check\_emergency\_access\_enabled()?;
 let initiating\_user = headers.user; let mut emergency\_access = match EmergencyAccess::find\_by\_uuid(emer\_id, &mut conn).await { Some(emer) => emer, None => err!("Emergency access not valid."), };
 if emergency\_access.status != EmergencyAccessStatus::Confirmed as i32 || emergency\_access.grantee\_uuid != Some(initiating\_user.uuid) { err!("Emergency access not valid.") }
 let grantor\_user = match User::find\_by\_uuid(&emergency\_access.grantor\_uuid, &mut conn).await { Some(user) => user, None => err!("Grantor user not found."), };
 let now = Utc::now().naive\_utc(); emergency\_access.status = EmergencyAccessStatus::RecoveryInitiated as i32; emergency\_access.updated\_at = now; emergency\_access.recovery\_initiated\_at = Some(now); emergency\_access.last\_notification\_at = Some(now); emergency\_access.save(&mut conn).await?;
 if CONFIG.mail\_enabled() { mail::send\_emergency\_access\_recovery\_initiated( &grantor\_user.email, &initiating\_user.name, emergency\_access.get\_type\_as\_str(), &emergency\_access.wait\_time\_days, ) .await?; } Ok(Json(emergency\_access.to\_json()))}
#[post("/emergency-access/<emer\_id>/approve")]async fn approve\_emergency\_access(emer\_id: &str, headers: Headers, mut conn: DbConn) -> JsonResult { check\_emergency\_access\_enabled()?;
 let mut emergency\_access = match EmergencyAccess::find\_by\_uuid(emer\_id, &mut conn).await { Some(emer) => emer, None => err!("Emergency access not valid."), };
 if emergency\_access.status != EmergencyAccessStatus::RecoveryInitiated as i32 || emergency\_access.grantor\_uuid != headers.user.uuid { err!("Emergency access not valid.") }
 let grantor\_user = match User::find\_by\_uuid(&headers.user.uuid, &mut conn).await { Some(user) => user, None => err!("Grantor user not found."), };
 if let Some(grantee\_uuid) = emergency\_access.grantee\_uuid.as\_ref() { let grantee\_user = match User::find\_by\_uuid(grantee\_uuid, &mut conn).await { Some(user) => user, None => err!("Grantee user not found."), };
 emergency\_access.status = EmergencyAccessStatus::RecoveryApproved as i32; emergency\_access.save(&mut conn).await?;
 if CONFIG.mail\_enabled() { mail::send\_emergency\_access\_recovery\_approved(&grantee\_user.email, &grantor\_user.name).await?; } Ok(Json(emergency\_access.to\_json())) } else { err!("Grantee user not found.") }}
#[post("/emergency-access/<emer\_id>/reject")]async fn reject\_emergency\_access(emer\_id: &str, headers: Headers, mut conn: DbConn) -> JsonResult { check\_emergency\_access\_enabled()?;
 let mut emergency\_access = match EmergencyAccess::find\_by\_uuid(emer\_id, &mut conn).await { Some(emer) => emer, None => err!("Emergency access not valid."), };
 if (emergency\_access.status != EmergencyAccessStatus::RecoveryInitiated as i32 && emergency\_access.status != EmergencyAccessStatus::RecoveryApproved as i32) || emergency\_access.grantor\_uuid != headers.user.uuid { err!("Emergency access not valid.") }
 let grantor\_user = match User::find\_by\_uuid(&headers.user.uuid, &mut conn).await { Some(user) => user, None => err!("Grantor user not found."), };
 if let Some(grantee\_uuid) = emergency\_access.grantee\_uuid.as\_ref() { let grantee\_user = match User::find\_by\_uuid(grantee\_uuid, &mut conn).await { Some(user) => user, None => err!("Grantee user not found."), };
 emergency\_access.status = EmergencyAccessStatus::Confirmed as i32; emergency\_access.save(&mut conn).await?;
 if CONFIG.mail\_enabled() { mail::send\_emergency\_access\_recovery\_rejected(&grantee\_user.email, &grantor\_user.name).await?; } Ok(Json(emergency\_access.to\_json())) } else { err!("Grantee user not found.") }}
// endregion
// region action
#[post("/emergency-access/<emer\_id>/view")]async fn view\_emergency\_access(emer\_id: &str, headers: Headers, mut conn: DbConn) -> JsonResult { check\_emergency\_access\_enabled()?;
 let emergency\_access = match EmergencyAccess::find\_by\_uuid(emer\_id, &mut conn).await { Some(emer) => emer, None => err!("Emergency access not valid."), };
 if !is\_valid\_request(&emergency\_access, &headers.user.uuid, EmergencyAccessType::View) { err!("Emergency access not valid.") }
 let ciphers = Cipher::find\_owned\_by\_user(&emergency\_access.grantor\_uuid, &mut conn).await; let cipher\_sync\_data = CipherSyncData::new(&emergency\_access.grantor\_uuid, CipherSyncType::User, &mut conn).await;
 let mut ciphers\_json = Vec::with\_capacity(ciphers.len()); for c in ciphers { ciphers\_json.push( c.to\_json( &headers.host, &emergency\_access.grantor\_uuid, Some(&cipher\_sync\_data), CipherSyncType::User, &mut conn, ) .await, ); }
 Ok(Json(json!({ "Ciphers": ciphers\_json, "KeyEncrypted": &emergency\_access.key\_encrypted, "Object": "emergencyAccessView", })))}
#[post("/emergency-access/<emer\_id>/takeover")]async fn takeover\_emergency\_access(emer\_id: &str, headers: Headers, mut conn: DbConn) -> JsonResult { check\_emergency\_access\_enabled()?;
 let requesting\_user = headers.user; let emergency\_access = match EmergencyAccess::find\_by\_uuid(emer\_id, &mut conn).await { Some(emer) => emer, None => err!("Emergency access not valid."), };
 if !is\_valid\_request(&emergency\_access, &requesting\_user.uuid, EmergencyAccessType::Takeover) { err!("Emergency access not valid.") }
 let grantor\_user = match User::find\_by\_uuid(&emergency\_access.grantor\_uuid, &mut conn).await { Some(user) => user, None => err!("Grantor user not found."), };
 let result = json!({ "Kdf": grantor\_user.client\_kdf\_type, "KdfIterations": grantor\_user.client\_kdf\_iter, "KdfMemory": grantor\_user.client\_kdf\_memory, "KdfParallelism": grantor\_user.client\_kdf\_parallelism, "KeyEncrypted": &emergency\_access.key\_encrypted, "Object": "emergencyAccessTakeover", });
 Ok(Json(result))}
#[derive(Deserialize)]#[allow(non\_snake\_case)]struct EmergencyAccessPasswordData { NewMasterPasswordHash: String, Key: String,}
#[post("/emergency-access/<emer\_id>/password", data = "<data>")]async fn password\_emergency\_access( emer\_id: &str, data: JsonUpcase<EmergencyAccessPasswordData>, headers: Headers, mut conn: DbConn,) -> EmptyResult { check\_emergency\_access\_enabled()?;
 let data: EmergencyAccessPasswordData = data.into\_inner().data; let new\_master\_password\_hash = &data.NewMasterPasswordHash; //let key = &data.Key;
 let requesting\_user = headers.user; let emergency\_access = match EmergencyAccess::find\_by\_uuid(emer\_id, &mut conn).await { Some(emer) => emer, None => err!("Emergency access not valid."), };
 if !is\_valid\_request(&emergency\_access, &requesting\_user.uuid, EmergencyAccessType::Takeover) { err!("Emergency access not valid.") }
 let mut grantor\_user = match User::find\_by\_uuid(&emergency\_access.grantor\_uuid, &mut conn).await { Some(user) => user, None => err!("Grantor user not found."), };
 // change grantor\_user password grantor\_user.set\_password(new\_master\_password\_hash, Some(data.Key), true, None); grantor\_user.save(&mut conn).await?;
 // Disable TwoFactor providers since they will otherwise block logins TwoFactor::delete\_all\_by\_user(&grantor\_user.uuid, &mut conn).await?;
 // Remove grantor from all organisations unless Owner for user\_org in UserOrganization::find\_any\_state\_by\_user(&grantor\_user.uuid, &mut conn).await { if user\_org.atype != UserOrgType::Owner as i32 { user\_org.delete(&mut conn).await?; } } Ok(())}
// endregion
#[get("/emergency-access/<emer\_id>/policies")]async fn policies\_emergency\_access(emer\_id: &str, headers: Headers, mut conn: DbConn) -> JsonResult { let requesting\_user = headers.user; let emergency\_access = match EmergencyAccess::find\_by\_uuid(emer\_id, &mut conn).await { Some(emer) => emer, None => err!("Emergency access not valid."), };
 if !is\_valid\_request(&emergency\_access, &requesting\_user.uuid, EmergencyAccessType::Takeover) { err!("Emergency access not valid.") }
 let grantor\_user = match User::find\_by\_uuid(&emergency\_access.grantor\_uuid, &mut conn).await { Some(user) => user, None => err!("Grantor user not found."), };
 let policies = OrgPolicy::find\_confirmed\_by\_user(&grantor\_user.uuid, &mut conn); let policies\_json: Vec<Value> = policies.await.iter().map(OrgPolicy::to\_json).collect();
 Ok(Json(json!({ "Data": policies\_json, "Object": "list", "ContinuationToken": null })))}
fn is\_valid\_request( emergency\_access: &EmergencyAccess, requesting\_user\_uuid: &str, requested\_access\_type: EmergencyAccessType,) -> bool { emergency\_access.grantee\_uuid.is\_some() && emergency\_access.grantee\_uuid.as\_ref().unwrap() == requesting\_user\_uuid && emergency\_access.status == EmergencyAccessStatus::RecoveryApproved as i32 && emergency\_access.atype == requested\_access\_type as i32}
fn check\_emergency\_access\_enabled() -> EmptyResult { if !CONFIG.emergency\_access\_allowed() { err!("Emergency access is not enabled.") } Ok(())}
pub async fn emergency\_request\_timeout\_job(pool: DbPool) { debug!("Start emergency\_request\_timeout\_job"); if !CONFIG.emergency\_access\_allowed() { return; }
 if let Ok(mut conn) = pool.get().await { let emergency\_access\_list = EmergencyAccess::find\_all\_recoveries\_initiated(&mut conn).await;
 if emergency\_access\_list.is\_empty() { debug!("No emergency request timeout to approve"); }
 let now = Utc::now().naive\_utc(); for mut emer in emergency\_access\_list { // The find\_all\_recoveries\_initiated already checks if the recovery\_initiated\_at is not null (None) let recovery\_allowed\_at = emer.recovery\_initiated\_at.unwrap() + Duration::days(i64::from(emer.wait\_time\_days)); if recovery\_allowed\_at.le(&now) { // Only update the access status // Updating the whole record could cause issues when the emergency\_notification\_reminder\_job is also active emer.update\_access\_status\_and\_save(EmergencyAccessStatus::RecoveryApproved as i32, &now, &mut conn) .await .expect("Unable to update emergency access status");
 if CONFIG.mail\_enabled() { // get grantor user to send Accepted email let grantor\_user = User::find\_by\_uuid(&emer.grantor\_uuid, &mut conn).await.expect("Grantor user not found");
 // get grantee user to send Accepted email let grantee\_user = User::find\_by\_uuid(&emer.grantee\_uuid.clone().expect("Grantee user invalid"), &mut conn) .await .expect("Grantee user not found");
 mail::send\_emergency\_access\_recovery\_timed\_out( &grantor\_user.email, &grantee\_user.name, emer.get\_type\_as\_str(), ) .await .expect("Error on sending email");
 mail::send\_emergency\_access\_recovery\_approved(&grantee\_user.email, &grantor\_user.name) .await .expect("Error on sending email"); } } } } else { error!("Failed to get DB connection while searching emergency request timed out") }}
pub async fn emergency\_notification\_reminder\_job(pool: DbPool) { debug!("Start emergency\_notification\_reminder\_job"); if !CONFIG.emergency\_access\_allowed() { return; }
 if let Ok(mut conn) = pool.get().await { let emergency\_access\_list = EmergencyAccess::find\_all\_recoveries\_initiated(&mut conn).await;
 if emergency\_access\_list.is\_empty() { debug!("No emergency request reminder notification to send"); }
 let now = Utc::now().naive\_utc(); for mut emer in emergency\_access\_list { // The find\_all\_recoveries\_initiated already checks if the recovery\_initiated\_at is not null (None) // Calculate the day before the recovery will become active let final\_recovery\_reminder\_at = emer.recovery\_initiated\_at.unwrap() + Duration::days(i64::from(emer.wait\_time\_days - 1)); // Calculate if a day has passed since the previous notification, else no notification has been sent before let next\_recovery\_reminder\_at = if let Some(last\_notification\_at) = emer.last\_notification\_at { last\_notification\_at + Duration::days(1) } else { now }; if final\_recovery\_reminder\_at.le(&now) && next\_recovery\_reminder\_at.le(&now) { // Only update the last notification date // Updating the whole record could cause issues when the emergency\_request\_timeout\_job is also active emer.update\_last\_notification\_date\_and\_save(&now, &mut conn) .await .expect("Unable to update emergency access notification date");
 if CONFIG.mail\_enabled() { // get grantor user to send Accepted email let grantor\_user = User::find\_by\_uuid(&emer.grantor\_uuid, &mut conn).await.expect("Grantor user not found");
 // get grantee user to send Accepted email let grantee\_user = User::find\_by\_uuid(&emer.grantee\_uuid.clone().expect("Grantee user invalid"), &mut conn) .await .expect("Grantee user not found");
 mail::send\_emergency\_access\_recovery\_reminder( &grantor\_user.email, &grantee\_user.name, emer.get\_type\_as\_str(), "1", // This notification is only triggered one day before the activation ) .await .expect("Error on sending email"); } } } } else { error!("Failed to get DB connection while searching emergency notification reminder") }}

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

