

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=e9dac92f4482a382e8c0fe1bc243da5fc3526b0c)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=e9dac92f4482a382e8c0fe1bc243da5fc3526b0c)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e9dac92f4482a382e8c0fe1bc243da5fc3526b0c)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e9dac92f4482a382e8c0fe1bc243da5fc3526b0c)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Namjae Jeon <linkinjeon@kernel.org> | 2024-09-03 20:28:08 +0900 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-10-10 12:03:38 +0200 |
| commit | [e9dac92f4482a382e8c0fe1bc243da5fc3526b0c](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e9dac92f4482a382e8c0fe1bc243da5fc3526b0c) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=e9dac92f4482a382e8c0fe1bc243da5fc3526b0c)) | |
| tree | [6b749d41d234aa4574fbc7bca1a1b5c73042556e](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=e9dac92f4482a382e8c0fe1bc243da5fc3526b0c) | |
| parent | [466726271fb01ffbb4e838e123a9811c5a53e34f](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=466726271fb01ffbb4e838e123a9811c5a53e34f) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e9dac92f4482a382e8c0fe1bc243da5fc3526b0c&id2=466726271fb01ffbb4e838e123a9811c5a53e34f)) | |
| download | [linux-e9dac92f4482a382e8c0fe1bc243da5fc3526b0c.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-e9dac92f4482a382e8c0fe1bc243da5fc3526b0c.tar.gz) | |

ksmbd: add refcnt to ksmbd\_conn struct[ Upstream commit ee426bfb9d09b29987369b897fe9b6485ac2be27 ]
When sending an oplock break request, opinfo->conn is used,
But freed ->conn can be used on multichannel.
This patch add a reference count to the ksmbd\_conn struct
so that it can be freed when it is no longer used.
Signed-off-by: Namjae Jeon <linkinjeon@kernel.org>
Signed-off-by: Steve French <stfrench@microsoft.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e9dac92f4482a382e8c0fe1bc243da5fc3526b0c)

| -rw-r--r-- | [fs/smb/server/connection.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/server/connection.c?id=e9dac92f4482a382e8c0fe1bc243da5fc3526b0c) | 4 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/smb/server/connection.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/server/connection.h?id=e9dac92f4482a382e8c0fe1bc243da5fc3526b0c) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/server/oplock.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/server/oplock.c?id=e9dac92f4482a382e8c0fe1bc243da5fc3526b0c) | 55 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/server/vfs\_cache.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/server/vfs_cache.c?id=e9dac92f4482a382e8c0fe1bc243da5fc3526b0c) | 3 | |  |  |  | | --- | --- | --- | |

4 files changed, 23 insertions, 40 deletions

| diff --git a/fs/smb/server/connection.c b/fs/smb/server/connection.cindex 7889df8112b4ee..cac80e7bfefc74 100644--- a/[fs/smb/server/connection.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/server/connection.c?id=466726271fb01ffbb4e838e123a9811c5a53e34f)+++ b/[fs/smb/server/connection.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/server/connection.c?id=e9dac92f4482a382e8c0fe1bc243da5fc3526b0c)@@ -39,7 +39,8 @@ void ksmbd\_conn\_free(struct ksmbd\_conn \*conn) xa\_destroy(&conn->sessions); kvfree(conn->request\_buf); kfree(conn->preauth\_info);- kfree(conn);+ if (atomic\_dec\_and\_test(&conn->refcnt))+ kfree(conn); }  /\*\*@@ -68,6 +69,7 @@ struct ksmbd\_conn \*ksmbd\_conn\_alloc(void) conn->um = NULL; atomic\_set(&conn->req\_running, 0); atomic\_set(&conn->r\_count, 0);+ atomic\_set(&conn->refcnt, 1); conn->total\_credits = 1; conn->outstanding\_credits = 0; diff --git a/fs/smb/server/connection.h b/fs/smb/server/connection.hindex 5b947175c048eb..b379ae4fdcdffa 100644--- a/[fs/smb/server/connection.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/server/connection.h?id=466726271fb01ffbb4e838e123a9811c5a53e34f)+++ b/[fs/smb/server/connection.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/server/connection.h?id=e9dac92f4482a382e8c0fe1bc243da5fc3526b0c)@@ -106,6 +106,7 @@ struct ksmbd\_conn { bool signing\_negotiated; \_\_le16 signing\_algorithm; bool binding;+ atomic\_t refcnt; };  struct ksmbd\_conn\_ops {diff --git a/fs/smb/server/oplock.c b/fs/smb/server/oplock.cindex e546ffa57b55ab..8ee86478287f93 100644--- a/[fs/smb/server/oplock.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/server/oplock.c?id=466726271fb01ffbb4e838e123a9811c5a53e34f)+++ b/[fs/smb/server/oplock.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/server/oplock.c?id=e9dac92f4482a382e8c0fe1bc243da5fc3526b0c)@@ -51,6 +51,7 @@ static struct oplock\_info \*alloc\_opinfo(struct ksmbd\_work \*work, init\_waitqueue\_head(&opinfo->oplock\_brk); atomic\_set(&opinfo->refcount, 1); atomic\_set(&opinfo->breaking\_cnt, 0);+ atomic\_inc(&opinfo->conn->refcnt);  return opinfo; }@@ -124,6 +125,8 @@ static void free\_opinfo(struct oplock\_info \*opinfo) { if (opinfo->is\_lease) free\_lease(opinfo);+ if (opinfo->conn && atomic\_dec\_and\_test(&opinfo->conn->refcnt))+ kfree(opinfo->conn); kfree(opinfo); } @@ -163,9 +166,7 @@ static struct oplock\_info \*opinfo\_get\_list(struct ksmbd\_inode \*ci) !atomic\_inc\_not\_zero(&opinfo->refcount)) opinfo = NULL; else {- atomic\_inc(&opinfo->conn->r\_count); if (ksmbd\_conn\_releasing(opinfo->conn)) {- atomic\_dec(&opinfo->conn->r\_count); atomic\_dec(&opinfo->refcount); opinfo = NULL; }@@ -177,26 +178,11 @@ static struct oplock\_info \*opinfo\_get\_list(struct ksmbd\_inode \*ci) return opinfo; } -static void opinfo\_conn\_put(struct oplock\_info \*opinfo)+void opinfo\_put(struct oplock\_info \*opinfo) {- struct ksmbd\_conn \*conn;- if (!opinfo) return; - conn = opinfo->conn;- /\*- \* Checking waitqueue to dropping pending requests on- \* disconnection. waitqueue\_active is safe because it- \* uses atomic operation for condition.- \*/- if (!atomic\_dec\_return(&conn->r\_count) && waitqueue\_active(&conn->r\_count\_q))- wake\_up(&conn->r\_count\_q);- opinfo\_put(opinfo);-}--void opinfo\_put(struct oplock\_info \*opinfo)-{ if (!atomic\_dec\_and\_test(&opinfo->refcount)) return; @@ -1127,14 +1113,11 @@ void smb\_send\_parent\_lease\_break\_noti(struct ksmbd\_file \*fp, if (!atomic\_inc\_not\_zero(&opinfo->refcount)) continue; - atomic\_inc(&opinfo->conn->r\_count);- if (ksmbd\_conn\_releasing(opinfo->conn)) {- atomic\_dec(&opinfo->conn->r\_count);+ if (ksmbd\_conn\_releasing(opinfo->conn)) continue;- }  oplock\_break(opinfo, SMB2\_OPLOCK\_LEVEL\_NONE);- opinfo\_conn\_put(opinfo);+ opinfo\_put(opinfo); } } up\_read(&p\_ci->m\_lock);@@ -1167,13 +1150,10 @@ void smb\_lazy\_parent\_lease\_break\_close(struct ksmbd\_file \*fp) if (!atomic\_inc\_not\_zero(&opinfo->refcount)) continue; - atomic\_inc(&opinfo->conn->r\_count);- if (ksmbd\_conn\_releasing(opinfo->conn)) {- atomic\_dec(&opinfo->conn->r\_count);+ if (ksmbd\_conn\_releasing(opinfo->conn)) continue;- } oplock\_break(opinfo, SMB2\_OPLOCK\_LEVEL\_NONE);- opinfo\_conn\_put(opinfo);+ opinfo\_put(opinfo); } } up\_read(&p\_ci->m\_lock);@@ -1252,7 +1232,7 @@ int smb\_grant\_oplock(struct ksmbd\_work \*work, int req\_op\_level, u64 pid, prev\_opinfo = opinfo\_get\_list(ci); if (!prev\_opinfo || (prev\_opinfo->level == SMB2\_OPLOCK\_LEVEL\_NONE && lctx)) {- opinfo\_conn\_put(prev\_opinfo);+ opinfo\_put(prev\_opinfo); goto set\_lev; } prev\_op\_has\_lease = prev\_opinfo->is\_lease;@@ -1262,19 +1242,19 @@ int smb\_grant\_oplock(struct ksmbd\_work \*work, int req\_op\_level, u64 pid, if (share\_ret < 0 && prev\_opinfo->level == SMB2\_OPLOCK\_LEVEL\_EXCLUSIVE) { err = share\_ret;- opinfo\_conn\_put(prev\_opinfo);+ opinfo\_put(prev\_opinfo); goto err\_out; }  if (prev\_opinfo->level != SMB2\_OPLOCK\_LEVEL\_BATCH && prev\_opinfo->level != SMB2\_OPLOCK\_LEVEL\_EXCLUSIVE) {- opinfo\_conn\_put(prev\_opinfo);+ opinfo\_put(prev\_opinfo); goto op\_break\_not\_needed; }  list\_add(&work->interim\_entry, &prev\_opinfo->interim\_list); err = oplock\_break(prev\_opinfo, SMB2\_OPLOCK\_LEVEL\_II);- opinfo\_conn\_put(prev\_opinfo);+ opinfo\_put(prev\_opinfo); if (err == -ENOENT) goto set\_lev; /\* Check all oplock was freed by close \*/@@ -1337,14 +1317,14 @@ static void smb\_break\_all\_write\_oplock(struct ksmbd\_work \*work, return; if (brk\_opinfo->level != SMB2\_OPLOCK\_LEVEL\_BATCH && brk\_opinfo->level != SMB2\_OPLOCK\_LEVEL\_EXCLUSIVE) {- opinfo\_conn\_put(brk\_opinfo);+ opinfo\_put(brk\_opinfo); return; }  brk\_opinfo->open\_trunc = is\_trunc; list\_add(&work->interim\_entry, &brk\_opinfo->interim\_list); oplock\_break(brk\_opinfo, SMB2\_OPLOCK\_LEVEL\_II);- opinfo\_conn\_put(brk\_opinfo);+ opinfo\_put(brk\_opinfo); }  /\*\*@@ -1376,11 +1356,8 @@ void smb\_break\_all\_levII\_oplock(struct ksmbd\_work \*work, struct ksmbd\_file \*fp, if (!atomic\_inc\_not\_zero(&brk\_op->refcount)) continue; - atomic\_inc(&brk\_op->conn->r\_count);- if (ksmbd\_conn\_releasing(brk\_op->conn)) {- atomic\_dec(&brk\_op->conn->r\_count);+ if (ksmbd\_conn\_releasing(brk\_op->conn)) continue;- }  rcu\_read\_unlock(); if (brk\_op->is\_lease && (brk\_op->o\_lease->state &@@ -1411,7 +1388,7 @@ void smb\_break\_all\_levII\_oplock(struct ksmbd\_work \*work, struct ksmbd\_file \*fp, brk\_op->open\_trunc = is\_trunc; oplock\_break(brk\_op, SMB2\_OPLOCK\_LEVEL\_NONE); next:- opinfo\_conn\_put(brk\_op);+ opinfo\_put(brk\_op); rcu\_read\_lock(); } rcu\_read\_unlock();diff --git a/fs/smb/server/vfs\_cache.c b/fs/smb/server/vfs\_cache.cindex 4d4ee696e37cdf..a19f4e563c7e54 100644--- a/[fs/smb/server/vfs\_cache.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/server/vfs_cache.c?id=466726271fb01ffbb4e838e123a9811c5a53e34f)+++ b/[fs/smb/server/vfs\_cache.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/server/vfs_cache.c?id=e9dac92f4482a382e8c0fe1bc243da5fc3526b0c)@@ -863,6 +863,8 @@ static bool session\_fd\_check(struct ksmbd\_tree\_connect \*tcon, list\_for\_each\_entry\_rcu(op, &ci->m\_op\_list, op\_entry) { if (op->conn != conn) continue;+ if (op->conn && atomic\_dec\_and\_test(&op->conn->refcnt))+ kfree(op->conn); op->conn = NULL; } up\_write(&ci->m\_lock);@@ -965,6 +967,7 @@ int ksmbd\_reopen\_durable\_fd(struct ksmbd\_work \*work, struct ksmbd\_file \*fp) if (op->conn) continue; op->conn = fp->conn;+ atomic\_inc(&op->conn->refcnt); } up\_write(&ci->m\_lock); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 20:30:53 +0000

