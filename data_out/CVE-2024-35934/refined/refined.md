```
{
  "cve": "CVE-2024-35934",
  "description": "The provided information describes a patch that aims to reduce rtnl (routing netlink) pressure within the Linux kernel's SMC (Shared Memory Communications) subsystem, specifically in the `smc_pnet_create_pnetids_list()` function. This function is called during net namespace creation, and the patch avoids acquiring the rtnl lock if no network devices are present, which prevents potential deadlocks. The provided information does not indicate any exploitable vulnerability.",
  "affected_versions": [
     "linux kernel versions prior to the fix"
   ],
  "fixes": [
    {
      "commit": "d7ee3bf0caf599c14db0bf4af7aacd6206ef8a23",
      "description": "This patch introduces a check within `smc_pnet_create_pnetids_list` to return early, without acquiring `rtnl_lock`, if the network namespace (`net`) does not have any network devices (`net->dev_base_head` is empty). This prevents unnecessary locking and reduces contention on `rtnl_mutex`.",
      "file": "net/smc/smc_pnet.c",
        "lines": [
           "@@ -802,6 +802,16 @@ static void smc\_pnet\_create\_pnetids\_list(struct net *net)",
           "+        /* Newly created netns do not have devices.",
           "+         * Do not even acquire rtnl.",
           "+         */",
           "+        if (list_empty(&net->dev_base_head))",
           "+                return;",
           "+",
           "@@ -809,7 +819,7 @@ static void smc_pnet_create_pnetids_list(struct net *net)"
        ]
     },
    {
      "commit": "00af2aa93b76b1bade471ad0d0525d4d29ca5cc0",
      "description": "This patch is identical to the patch d7ee3bf0caf599c14db0bf4af7aacd6206ef8a23, and fixes the same issue.",
      "file": "net/smc/smc_pnet.c",
        "lines":[
           "@@ -806,6 +806,16 @@ static void smc\_pnet\_create\_pnetids\_list(struct net *net)",
           "+        /* Newly created netns do not have devices.",
           "+         * Do not even acquire rtnl.",
           "+         */",
           "+        if (list_empty(&net->dev_base_head))",
           "+                return;",
           "+",
           "@@ -813,7 +823,7 @@ static void smc_pnet_create_pnetids_list(struct net *net)"
        ]
    },
    {
      "commit": "bc4d1ebca11b4f194e262326bd45938e857c59d2",
      "description": "This patch is identical to the patch d7ee3bf0caf599c14db0bf4af7aacd6206ef8a23, and fixes the same issue.",
      "file": "net/smc/smc_pnet.c",
      "lines":[
           "@@ -797,6 +797,16 @@ static void smc\_pnet\_create\_pnetids\_list(struct net *net)",
           "+        /* Newly created netns do not have devices.",
           "+         * Do not even acquire rtnl.",
           "+         */",
           "+        if (list_empty(&net->dev_base_head))",
           "+                return;",
           "+",
           "@@ -804,7 +814,7 @@ static void smc_pnet_create_pnetids_list(struct net *net)"
        ]
    },
    {
      "commit": "a2e6bffc0388526ed10406040279a693d62b36ec",
      "description":"This patch is identical to the patch d7ee3bf0caf599c14db0bf4af7aacd6206ef8a23, and fixes the same issue.",
      "file": "net/smc/smc_pnet.c",
      "lines":[
         "@@ -806,6 +806,16 @@ static void smc\_pnet\_create\_pnetids\_list(struct net *net)",
         "+        /* Newly created netns do not have devices.",
         "+         * Do not even acquire rtnl.",
         "+         */",
         "+        if (list_empty(&net->dev_base_head))",
         "+                return;",
         "+",
         "@@ -813,7 +823,7 @@ static void smc_pnet_create_pnetids_list(struct net *net)"
      ]
    },
     {
      "commit": "6e920422e7104928f760fc0e12b6d65ab097a2e7",
       "description": "This patch is identical to the patch d7ee3bf0caf599c14db0bf4af7aacd6206ef8a23, and fixes the same issue.",
       "file": "net/smc/smc_pnet.c",
       "lines":[
           "@@ -806,6 +806,16 @@ static void smc\_pnet\_create\_pnetids\_list(struct net *net)",
           "+        /* Newly created netns do not have devices.",
           "+         * Do not even acquire rtnl.",
           "+         */",
           "+        if (list_empty(&net->dev_base_head))",
           "+                return;",
           "+",
           "@@ -813,7 +823,7 @@ static void smc_pnet_create_pnetids_list(struct net *net)"
       ]
    },
     {
        "commit": "b9117dc783c0ab0a3866812f70e07bf2ea071ac4",
        "description": "This patch is identical to the patch d7ee3bf0caf599c14db0bf4af7aacd6206ef8a23, and fixes the same issue.",
        "file": "net/smc/smc_pnet.c",
        "lines":[
           "@@ -796,6 +796,16 @@ static void smc\_pnet\_create\_pnetids\_list(struct net *net)",
           "+        /* Newly created netns do not have devices.",
           "+         * Do not even acquire rtnl.",
           "+         */",
           "+        if (list_empty(&net->dev_base_head))",
           "+                return;",
           "+",
           "@@ -803,7 +813,7 @@ static void smc_pnet_create_pnetids_list(struct net *net)"
        ]
    }
  ],
  "vulnerability": {
    "root_cause": "The `smc_pnet_create_pnetids_list()` function in the Linux kernel's SMC subsystem acquires the `rtnl_mutex` during net namespace creation, even when there are no network devices present in the namespace. This unnecessary locking contributes to contention and deadlocks under high rtnl pressure, as reported by syzbot.",
    "weaknesses": [
      "Unnecessary locking",
      "High contention on `rtnl_mutex`"
    ],
    "impact": "Denial of service due to deadlocks in the networking stack. While not directly exploitable for privilege escalation or information leaks, the contention issues can result in a system freeze or hang, requiring a system reboot.",
    "attack_vectors": [
      "Creating multiple network namespaces rapidly and concurrently."
    ],
    "required_capabilities": "The attacker must be able to trigger the creation of network namespaces, which can typically be done by a privileged user with `CAP_SYS_ADMIN` capability. While not a privilege escalation vulnerability, the contention issues can result in a system freeze or hang which is a form of denial of service."
  }
}
```