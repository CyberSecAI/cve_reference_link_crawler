

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=edd783162bf2385b43de6764f2d4c6e9f4f6be27)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=edd783162bf2385b43de6764f2d4c6e9f4f6be27)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=edd783162bf2385b43de6764f2d4c6e9f4f6be27)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=edd783162bf2385b43de6764f2d4c6e9f4f6be27)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Mike Christie <michael.christie@oracle.com> | 2021-11-05 17:10:48 -0500 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2021-11-26 10:47:19 +0100 |
| commit | [edd783162bf2385b43de6764f2d4c6e9f4f6be27](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=edd783162bf2385b43de6764f2d4c6e9f4f6be27) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=edd783162bf2385b43de6764f2d4c6e9f4f6be27)) | |
| tree | [d1a8edf0161e1a9a1935af965f41257305ea2fc5](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=edd783162bf2385b43de6764f2d4c6e9f4f6be27) | |
| parent | [446882f216ac1b3b53846e2754fb20700b5fbfef](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=446882f216ac1b3b53846e2754fb20700b5fbfef) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=edd783162bf2385b43de6764f2d4c6e9f4f6be27&id2=446882f216ac1b3b53846e2754fb20700b5fbfef)) | |
| download | [linux-edd783162bf2385b43de6764f2d4c6e9f4f6be27.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-edd783162bf2385b43de6764f2d4c6e9f4f6be27.tar.gz) | |

scsi: core: sysfs: Fix hang when device state is set via sysfs[ Upstream commit 4edd8cd4e86dd3047e5294bbefcc0a08f66a430f ]
This fixes a regression added with:
commit f0f82e2476f6 ("scsi: core: Fix capacity set to zero after
offlinining device")
The problem is that after iSCSI recovery, iscsid will call into the kernel
to set the dev's state to running, and with that patch we now call
scsi\_rescan\_device() with the state\_mutex held. If the SCSI error handler
thread is just starting to test the device in scsi\_send\_eh\_cmnd() then it's
going to try to grab the state\_mutex.
We are then stuck, because when scsi\_rescan\_device() tries to send its I/O
scsi\_queue\_rq() calls -> scsi\_host\_queue\_ready() -> scsi\_host\_in\_recovery()
which will return true (the host state is still in recovery) and I/O will
just be requeued. scsi\_send\_eh\_cmnd() will then never be able to grab the
state\_mutex to finish error handling.
To prevent the deadlock move the rescan-related code to after we drop the
state\_mutex.
This also adds a check for if we are already in the running state. This
prevents extra scans and helps the iscsid case where if the transport class
has already onlined the device during its recovery process then we don't
need userspace to do it again plus possibly block that daemon.
Link: [https://lore.kernel.org/r/20211105221048.6541-3-michael.christie@oracle.com](https://lore.kernel.org/r/20211105221048.6541-3-michael.christie%40oracle.com)
Fixes: f0f82e2476f6 ("scsi: core: Fix capacity set to zero after offlinining device")
Cc: Bart Van Assche <bvanassche@acm.org>
Cc: lijinlin <lijinlin3@huawei.com>
Cc: Wu Bo <wubo40@huawei.com>
Reviewed-by: Lee Duncan <lduncan@suse.com>
Reviewed-by: Wu Bo <wubo40@huawei.com>
Signed-off-by: Mike Christie <michael.christie@oracle.com>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=edd783162bf2385b43de6764f2d4c6e9f4f6be27)

| -rw-r--r-- | [drivers/scsi/scsi\_sysfs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/scsi/scsi_sysfs.c?id=edd783162bf2385b43de6764f2d4c6e9f4f6be27) | 30 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 19 insertions, 11 deletions

| diff --git a/drivers/scsi/scsi\_sysfs.c b/drivers/scsi/scsi\_sysfs.cindex 12064ce76777dc..16432d42a50aac 100644--- a/[drivers/scsi/scsi\_sysfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/scsi/scsi_sysfs.c?id=446882f216ac1b3b53846e2754fb20700b5fbfef)+++ b/[drivers/scsi/scsi\_sysfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/scsi/scsi_sysfs.c?id=edd783162bf2385b43de6764f2d4c6e9f4f6be27)@@ -776,6 +776,7 @@ store\_state\_field(struct device \*dev, struct device\_attribute \*attr, int i, ret; struct scsi\_device \*sdev = to\_scsi\_device(dev); enum scsi\_device\_state state = 0;+ bool rescan\_dev = false;  for (i = 0; i < ARRAY\_SIZE(sdev\_states); i++) { const int len = strlen(sdev\_states[i].name);@@ -794,20 +795,27 @@ store\_state\_field(struct device \*dev, struct device\_attribute \*attr, }  mutex\_lock(&sdev->state\_mutex);- ret = scsi\_device\_set\_state(sdev, state);- /\*- \* If the device state changes to SDEV\_RUNNING, we need to- \* run the queue to avoid I/O hang, and rescan the device- \* to revalidate it. Running the queue first is necessary- \* because another thread may be waiting inside- \* blk\_mq\_freeze\_queue\_wait() and because that call may be- \* waiting for pending I/O to finish.- \*/- if (ret == 0 && state == SDEV\_RUNNING) {+ if (sdev->sdev\_state == SDEV\_RUNNING && state == SDEV\_RUNNING) {+ ret = count;+ } else {+ ret = scsi\_device\_set\_state(sdev, state);+ if (ret == 0 && state == SDEV\_RUNNING)+ rescan\_dev = true;+ }+ mutex\_unlock(&sdev->state\_mutex);++ if (rescan\_dev) {+ /\*+ \* If the device state changes to SDEV\_RUNNING, we need to+ \* run the queue to avoid I/O hang, and rescan the device+ \* to revalidate it. Running the queue first is necessary+ \* because another thread may be waiting inside+ \* blk\_mq\_freeze\_queue\_wait() and because that call may be+ \* waiting for pending I/O to finish.+ \*/ blk\_mq\_run\_hw\_queues(sdev->request\_queue, true); scsi\_rescan\_device(dev); }- mutex\_unlock(&sdev->state\_mutex);  return ret == 0 ? count : -EINVAL; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 04:26:00 +0000

