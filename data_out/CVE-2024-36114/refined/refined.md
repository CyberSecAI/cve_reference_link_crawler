Based on the provided information, here's an analysis of CVE-2024-36114:

**Summary:**
The vulnerability lies in the lack of proper bounds checking within the decompressor implementations of the Airlift aircompressor library (LZ4, LZO, Snappy, and Zstandard). This can lead to out-of-bounds memory access, potentially causing JVM crashes and information leaks.

**Root Cause of Vulnerability:**
The root cause is the use of `sun.misc.Unsafe` for memory access, which bypasses standard Java bounds checking. The decompressors did not perform sufficient checks to ensure that memory accesses were within the bounds of the allocated buffers when handling crafted or corrupted input.

**Weaknesses/Vulnerabilities Present:**
- Out-of-bounds read: Decompressors could attempt to read data beyond the allocated input buffer, triggered by negative or excessively large lengths calculated during decompression.
- Out-of-bounds write: Decompressors could attempt to write decompressed data beyond the allocated output buffer, when processing crafted input that produces a length that exceeds buffer size.

**Impact of Exploitation:**
- Denial of Service (DoS): Malicious input can crash the JVM, causing a denial-of-service attack.
- Information Leak: Out-of-bounds memory access could lead to the exposure of sensitive data from other parts of the Java process's memory.

**Attack Vectors:**
- Maliciously crafted compressed data: An attacker can provide specially crafted compressed data as input to the affected decompressors.

**Required Attacker Capabilities/Position:**
- The attacker needs to be able to supply compressed data to a system using a vulnerable version of the `aircompressor` library. This could be through any interface where decompression is performed, such as network requests or file processing.

**Technical Details:**

*   **LZ4:**
    *   The `literalLength` and `matchLength` could overflow, becoming negative, which would then be used to access memory out of bounds. The fix adds checks to throw MalformedInputException when length is negative
*   **LZO:**
    *   The `literalLength` and `matchLength` could overflow, becoming negative. The fix adds checks to throw MalformedInputException when length is negative
*   **Snappy:**
    *   The `literalLength` and match offset could overflow, becoming negative. The fix adds a check to throw MalformedInputException when the length is negative, and a check for negative compressed length.
*   **Zstandard:**
     *   The issue was with the huffman decoding, where start values could cause out-of-bounds reads. The fix adds a check to verify that start values are valid.

The vulnerability was fixed by adding checks before memory access to ensure computed lengths and offsets are within bounds, and that no negative values are used in the memory access.