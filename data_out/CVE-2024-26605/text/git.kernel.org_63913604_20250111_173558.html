

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=b0f4478838be1f1d330061201898fef65bf8fd7c)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=b0f4478838be1f1d330061201898fef65bf8fd7c)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b0f4478838be1f1d330061201898fef65bf8fd7c)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b0f4478838be1f1d330061201898fef65bf8fd7c)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Johan Hovold <johan+linaro@kernel.org> | 2024-01-30 11:02:43 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-04-27 17:11:44 +0200 |
| commit | [b0f4478838be1f1d330061201898fef65bf8fd7c](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b0f4478838be1f1d330061201898fef65bf8fd7c) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=b0f4478838be1f1d330061201898fef65bf8fd7c)) | |
| tree | [d63a08ee4744ed74a5331b3cd8624fcaf9fd6fa8](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=b0f4478838be1f1d330061201898fef65bf8fd7c) | |
| parent | [3b629239773b02169659ea47e0ad1acfa662de67](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3b629239773b02169659ea47e0ad1acfa662de67) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b0f4478838be1f1d330061201898fef65bf8fd7c&id2=3b629239773b02169659ea47e0ad1acfa662de67)) | |
| download | [linux-b0f4478838be1f1d330061201898fef65bf8fd7c.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-b0f4478838be1f1d330061201898fef65bf8fd7c.tar.gz) | |

PCI/ASPM: Fix deadlock when enabling ASPMcommit 1e560864159d002b453da42bd2c13a1805515a20 upstream.
A last minute revert in 6.7-final introduced a potential deadlock when
enabling ASPM during probe of Qualcomm PCIe controllers as reported by
lockdep:
============================================
WARNING: possible recursive locking detected
6.7.0 #40 Not tainted
--------------------------------------------
kworker/u16:5/90 is trying to acquire lock:
ffffacfa78ced000 (pci\_bus\_sem){++++}-{3:3}, at: pcie\_aspm\_pm\_state\_change+0x58/0xdc
but task is already holding lock:
ffffacfa78ced000 (pci\_bus\_sem){++++}-{3:3}, at: pci\_walk\_bus+0x34/0xbc
other info that might help us debug this:
Possible unsafe locking scenario:
CPU0
----
lock(pci\_bus\_sem);
lock(pci\_bus\_sem);
\*\*\* DEADLOCK \*\*\*
Call trace:
print\_deadlock\_bug+0x25c/0x348
\_\_lock\_acquire+0x10a4/0x2064
lock\_acquire+0x1e8/0x318
down\_read+0x60/0x184
pcie\_aspm\_pm\_state\_change+0x58/0xdc
pci\_set\_full\_power\_state+0xa8/0x114
pci\_set\_power\_state+0xc4/0x120
qcom\_pcie\_enable\_aspm+0x1c/0x3c [pcie\_qcom]
pci\_walk\_bus+0x64/0xbc
qcom\_pcie\_host\_post\_init\_2\_7\_0+0x28/0x34 [pcie\_qcom]
The deadlock can easily be reproduced on machines like the Lenovo ThinkPad
X13s by adding a delay to increase the race window during asynchronous
probe where another thread can take a write lock.
Add a new pci\_set\_power\_state\_locked() and associated helper functions that
can be called with the PCI bus semaphore held to avoid taking the read lock
twice.
Link: [https://lore.kernel.org/r/ZZu0qx2cmn7IwTyQ@hovoldconsulting.com](https://lore.kernel.org/r/ZZu0qx2cmn7IwTyQ%40hovoldconsulting.com)
Link: [https://lore.kernel.org/r/20240130100243.11011-1-johan+linaro@kernel.org](https://lore.kernel.org/r/20240130100243.11011-1-johan%2Blinaro%40kernel.org)
Fixes: f93e71aea6c6 ("Revert "PCI/ASPM: Remove pcie\_aspm\_pm\_state\_change()"")
Signed-off-by: Johan Hovold <johan+linaro@kernel.org>
Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
Cc: <stable@vger.kernel.org> # 6.7
[bhelgaas: backported to v6.6.y, which contains 8cc22ba3f77c ("Revert
"PCI/ASPM: Remove pcie\_aspm\_pm\_state\_change()""), a backport of
f93e71aea6c6. This omits the drivers/pci/controller/dwc/pcie-qcom.c hunk
that updates qcom\_pcie\_enable\_aspm(), which was added by 9f4f3dfad8cf
("PCI: qcom: Enable ASPM for platforms supporting 1.9.0 ops"), which is not
present in v6.6.28.]
Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b0f4478838be1f1d330061201898fef65bf8fd7c)

| -rw-r--r-- | [drivers/pci/bus.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/pci/bus.c?id=b0f4478838be1f1d330061201898fef65bf8fd7c) | 49 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/pci/pci.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/pci/pci.c?id=b0f4478838be1f1d330061201898fef65bf8fd7c) | 78 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/pci/pci.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/pci/pci.h?id=b0f4478838be1f1d330061201898fef65bf8fd7c) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/pci/pcie/aspm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/pci/pcie/aspm.c?id=b0f4478838be1f1d330061201898fef65bf8fd7c) | 13 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/pci.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/pci.h?id=b0f4478838be1f1d330061201898fef65bf8fd7c) | 5 | |  |  |  | | --- | --- | --- | |

5 files changed, 100 insertions, 49 deletions

| diff --git a/drivers/pci/bus.c b/drivers/pci/bus.cindex 9c2137dae429aa..826b5016a10102 100644--- a/[drivers/pci/bus.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/pci/bus.c?id=3b629239773b02169659ea47e0ad1acfa662de67)+++ b/[drivers/pci/bus.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/pci/bus.c?id=b0f4478838be1f1d330061201898fef65bf8fd7c)@@ -386,21 +386,8 @@ void pci\_bus\_add\_devices(const struct pci\_bus \*bus) } EXPORT\_SYMBOL(pci\_bus\_add\_devices); -/\*\* pci\_walk\_bus - walk devices on/under bus, calling callback.- \* @top bus whose devices should be walked- \* @cb callback to be called for each device found- \* @userdata arbitrary pointer to be passed to callback.- \*- \* Walk the given bus, including any bridged devices- \* on buses under this bus. Call the provided callback- \* on each device found.- \*- \* We check the return of @cb each time. If it returns anything- \* other than 0, we break out.- \*- \*/-void pci\_walk\_bus(struct pci\_bus \*top, int (\*cb)(struct pci\_dev \*, void \*),- void \*userdata)+static void \_\_pci\_walk\_bus(struct pci\_bus \*top, int (\*cb)(struct pci\_dev \*, void \*),+ void \*userdata, bool locked) { struct pci\_dev \*dev; struct pci\_bus \*bus;@@ -408,7 +395,8 @@ void pci\_walk\_bus(struct pci\_bus \*top, int (\*cb)(struct pci\_dev \*, void \*), int retval;  bus = top;- down\_read(&pci\_bus\_sem);+ if (!locked)+ down\_read(&pci\_bus\_sem); next = top->devices.next; for (;;) { if (next == &bus->devices) {@@ -431,10 +419,37 @@ void pci\_walk\_bus(struct pci\_bus \*top, int (\*cb)(struct pci\_dev \*, void \*), if (retval) break; }- up\_read(&pci\_bus\_sem);+ if (!locked)+ up\_read(&pci\_bus\_sem);+}++/\*\*+ \* pci\_walk\_bus - walk devices on/under bus, calling callback.+ \* @top: bus whose devices should be walked+ \* @cb: callback to be called for each device found+ \* @userdata: arbitrary pointer to be passed to callback+ \*+ \* Walk the given bus, including any bridged devices+ \* on buses under this bus. Call the provided callback+ \* on each device found.+ \*+ \* We check the return of @cb each time. If it returns anything+ \* other than 0, we break out.+ \*/+void pci\_walk\_bus(struct pci\_bus \*top, int (\*cb)(struct pci\_dev \*, void \*), void \*userdata)+{+ \_\_pci\_walk\_bus(top, cb, userdata, false); } EXPORT\_SYMBOL\_GPL(pci\_walk\_bus); +void pci\_walk\_bus\_locked(struct pci\_bus \*top, int (\*cb)(struct pci\_dev \*, void \*), void \*userdata)+{+ lockdep\_assert\_held(&pci\_bus\_sem);++ \_\_pci\_walk\_bus(top, cb, userdata, true);+}+EXPORT\_SYMBOL\_GPL(pci\_walk\_bus\_locked);+ struct pci\_bus \*pci\_bus\_get(struct pci\_bus \*bus) { if (bus)diff --git a/drivers/pci/pci.c b/drivers/pci/pci.cindex 06fc6f532d6c4a..dddd30deea32bf 100644--- a/[drivers/pci/pci.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/pci/pci.c?id=3b629239773b02169659ea47e0ad1acfa662de67)+++ b/[drivers/pci/pci.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/pci/pci.c?id=b0f4478838be1f1d330061201898fef65bf8fd7c)@@ -1291,6 +1291,7 @@ end: /\*\* \* pci\_set\_full\_power\_state - Put a PCI device into D0 and update its state \* @dev: PCI device to power up+ \* @locked: whether pci\_bus\_sem is held \* \* Call pci\_power\_up() to put @dev into D0, read from its PCI\_PM\_CTRL register \* to confirm the state change, restore its BARs if they might be lost and@@ -1300,7 +1301,7 @@ end: \* to D0, it is more efficient to use pci\_power\_up() directly instead of this \* function. \*/-static int pci\_set\_full\_power\_state(struct pci\_dev \*dev)+static int pci\_set\_full\_power\_state(struct pci\_dev \*dev, bool locked) { u16 pmcsr; int ret;@@ -1336,7 +1337,7 @@ static int pci\_set\_full\_power\_state(struct pci\_dev \*dev) }  if (dev->bus->self)- pcie\_aspm\_pm\_state\_change(dev->bus->self);+ pcie\_aspm\_pm\_state\_change(dev->bus->self, locked);  return 0; }@@ -1365,10 +1366,22 @@ void pci\_bus\_set\_current\_state(struct pci\_bus \*bus, pci\_power\_t state) pci\_walk\_bus(bus, \_\_pci\_dev\_set\_current\_state, &state); } +static void \_\_pci\_bus\_set\_current\_state(struct pci\_bus \*bus, pci\_power\_t state, bool locked)+{+ if (!bus)+ return;++ if (locked)+ pci\_walk\_bus\_locked(bus, \_\_pci\_dev\_set\_current\_state, &state);+ else+ pci\_walk\_bus(bus, \_\_pci\_dev\_set\_current\_state, &state);+}+ /\*\* \* pci\_set\_low\_power\_state - Put a PCI device into a low-power state. \* @dev: PCI device to handle. \* @state: PCI power state (D1, D2, D3hot) to put the device into.+ \* @locked: whether pci\_bus\_sem is held \* \* Use the device's PCI\_PM\_CTRL register to put it into a low-power state. \*@@ -1379,7 +1392,7 @@ void pci\_bus\_set\_current\_state(struct pci\_bus \*bus, pci\_power\_t state) \* 0 if device already is in the requested state. \* 0 if device's power state has been successfully changed. \*/-static int pci\_set\_low\_power\_state(struct pci\_dev \*dev, pci\_power\_t state)+static int pci\_set\_low\_power\_state(struct pci\_dev \*dev, pci\_power\_t state, bool locked) { u16 pmcsr; @@ -1433,29 +1446,12 @@ static int pci\_set\_low\_power\_state(struct pci\_dev \*dev, pci\_power\_t state) pci\_power\_name(state));  if (dev->bus->self)- pcie\_aspm\_pm\_state\_change(dev->bus->self);+ pcie\_aspm\_pm\_state\_change(dev->bus->self, locked);  return 0; } -/\*\*- \* pci\_set\_power\_state - Set the power state of a PCI device- \* @dev: PCI device to handle.- \* @state: PCI power state (D0, D1, D2, D3hot) to put the device into.- \*- \* Transition a device to a new power state, using the platform firmware and/or- \* the device's PCI PM registers.- \*- \* RETURN VALUE:- \* -EINVAL if the requested state is invalid.- \* -EIO if device does not support PCI PM or its PM capabilities register has a- \* wrong version, or device doesn't support the requested state.- \* 0 if the transition is to D1 or D2 but D1 and D2 are not supported.- \* 0 if device already is in the requested state.- \* 0 if the transition is to D3 but D3 is not supported.- \* 0 if device's power state has been successfully changed.- \*/-int pci\_set\_power\_state(struct pci\_dev \*dev, pci\_power\_t state)+static int \_\_pci\_set\_power\_state(struct pci\_dev \*dev, pci\_power\_t state, bool locked) { int error; @@ -1479,7 +1475,7 @@ int pci\_set\_power\_state(struct pci\_dev \*dev, pci\_power\_t state) return 0;  if (state == PCI\_D0)- return pci\_set\_full\_power\_state(dev);+ return pci\_set\_full\_power\_state(dev, locked);  /\* \* This device is quirked not to be put into D3, so don't put it in@@ -1493,16 +1489,16 @@ int pci\_set\_power\_state(struct pci\_dev \*dev, pci\_power\_t state) \* To put the device in D3cold, put it into D3hot in the native \* way, then put it into D3cold using platform ops. \*/- error = pci\_set\_low\_power\_state(dev, PCI\_D3hot);+ error = pci\_set\_low\_power\_state(dev, PCI\_D3hot, locked);  if (pci\_platform\_power\_transition(dev, PCI\_D3cold)) return error;  /\* Powering off a bridge may power off the whole hierarchy \*/ if (dev->current\_state == PCI\_D3cold)- pci\_bus\_set\_current\_state(dev->subordinate, PCI\_D3cold);+ \_\_pci\_bus\_set\_current\_state(dev->subordinate, PCI\_D3cold, locked); } else {- error = pci\_set\_low\_power\_state(dev, state);+ error = pci\_set\_low\_power\_state(dev, state, locked);  if (pci\_platform\_power\_transition(dev, state)) return error;@@ -1510,8 +1506,38 @@ int pci\_set\_power\_state(struct pci\_dev \*dev, pci\_power\_t state)  return 0; }++/\*\*+ \* pci\_set\_power\_state - Set the power state of a PCI device+ \* @dev: PCI device to handle.+ \* @state: PCI power state (D0, D1, D2, D3hot) to put the device into.+ \*+ \* Transition a device to a new power state, using the platform firmware and/or+ \* the device's PCI PM registers.+ \*+ \* RETURN VALUE:+ \* -EINVAL if the requested state is invalid.+ \* -EIO if device does not support PCI PM or its PM capabilities register has a+ \* wrong version, or device doesn't support the requested state.+ \* 0 if the transition is to D1 or D2 but D1 and D2 are not supported.+ \* 0 if device already is in the requested state.+ \* 0 if the transition is to D3 but D3 is not supported.+ \* 0 if device's power state has been successfully changed.+ \*/+int pci\_set\_power\_state(struct pci\_dev \*dev, pci\_power\_t state)+{+ return \_\_pci\_set\_power\_state(dev, state, false);+} EXPORT\_SYMBOL(pci\_set\_power\_state); +int pci\_set\_power\_state\_locked(struct pci\_dev \*dev, pci\_power\_t state)+{+ lockdep\_assert\_held(&pci\_bus\_sem);++ return \_\_pci\_set\_power\_state(dev, state, true);+}+EXPORT\_SYMBOL(pci\_set\_power\_state\_locked);+ #define PCI\_EXP\_SAVE\_REGS 7  static struct pci\_cap\_saved\_state \*\_pci\_find\_saved\_cap(struct pci\_dev \*pci\_dev,diff --git a/drivers/pci/pci.h b/drivers/pci/pci.hindex 1b4f9418297242..2cc032e8cbb926 100644--- a/[drivers/pci/pci.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/pci/pci.h?id=3b629239773b02169659ea47e0ad1acfa662de67)+++ b/[drivers/pci/pci.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/pci/pci.h?id=b0f4478838be1f1d330061201898fef65bf8fd7c)@@ -561,12 +561,12 @@ int pcie\_retrain\_link(struct pci\_dev \*pdev, bool use\_lt); #ifdef CONFIG\_PCIEASPM void pcie\_aspm\_init\_link\_state(struct pci\_dev \*pdev); void pcie\_aspm\_exit\_link\_state(struct pci\_dev \*pdev);-void pcie\_aspm\_pm\_state\_change(struct pci\_dev \*pdev);+void pcie\_aspm\_pm\_state\_change(struct pci\_dev \*pdev, bool locked); void pcie\_aspm\_powersave\_config\_link(struct pci\_dev \*pdev); #else static inline void pcie\_aspm\_init\_link\_state(struct pci\_dev \*pdev) { } static inline void pcie\_aspm\_exit\_link\_state(struct pci\_dev \*pdev) { }-static inline void pcie\_aspm\_pm\_state\_change(struct pci\_dev \*pdev) { }+static inline void pcie\_aspm\_pm\_state\_change(struct pci\_dev \*pdev, bool locked) { } static inline void pcie\_aspm\_powersave\_config\_link(struct pci\_dev \*pdev) { } #endif diff --git a/drivers/pci/pcie/aspm.c b/drivers/pci/pcie/aspm.cindex 19a673aa08eb27..0aef6dc055b922 100644--- a/[drivers/pci/pcie/aspm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/pci/pcie/aspm.c?id=3b629239773b02169659ea47e0ad1acfa662de67)+++ b/[drivers/pci/pcie/aspm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/pci/pcie/aspm.c?id=b0f4478838be1f1d330061201898fef65bf8fd7c)@@ -1001,8 +1001,11 @@ void pcie\_aspm\_exit\_link\_state(struct pci\_dev \*pdev) up\_read(&pci\_bus\_sem); } -/\* @pdev: the root port or switch downstream port \*/-void pcie\_aspm\_pm\_state\_change(struct pci\_dev \*pdev)+/\*+ \* @pdev: the root port or switch downstream port+ \* @locked: whether pci\_bus\_sem is held+ \*/+void pcie\_aspm\_pm\_state\_change(struct pci\_dev \*pdev, bool locked) { struct pcie\_link\_state \*link = pdev->link\_state; @@ -1012,12 +1015,14 @@ void pcie\_aspm\_pm\_state\_change(struct pci\_dev \*pdev) \* Devices changed PM state, we should recheck if latency \* meets all functions' requirement \*/- down\_read(&pci\_bus\_sem);+ if (!locked)+ down\_read(&pci\_bus\_sem); mutex\_lock(&aspm\_lock); pcie\_update\_aspm\_capable(link->root); pcie\_config\_aspm\_path(link); mutex\_unlock(&aspm\_lock);- up\_read(&pci\_bus\_sem);+ if (!locked)+ up\_read(&pci\_bus\_sem); }  void pcie\_aspm\_powersave\_config\_link(struct pci\_dev \*pdev)diff --git a/include/linux/pci.h b/include/linux/pci.hindex b548d5646a86db..ee89a69817aaf7 100644--- a/[include/linux/pci.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/pci.h?id=3b629239773b02169659ea47e0ad1acfa662de67)+++ b/[include/linux/pci.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/pci.h?id=b0f4478838be1f1d330061201898fef65bf8fd7c)@@ -1391,6 +1391,7 @@ int pci\_load\_and\_free\_saved\_state(struct pci\_dev \*dev, struct pci\_saved\_state \*\*state); int pci\_platform\_power\_transition(struct pci\_dev \*dev, pci\_power\_t state); int pci\_set\_power\_state(struct pci\_dev \*dev, pci\_power\_t state);+int pci\_set\_power\_state\_locked(struct pci\_dev \*dev, pci\_power\_t state); pci\_power\_t pci\_choose\_state(struct pci\_dev \*dev, pm\_message\_t state); bool pci\_pme\_capable(struct pci\_dev \*dev, pci\_power\_t state); void pci\_pme\_active(struct pci\_dev \*dev, bool enable);@@ -1594,6 +1595,8 @@ int pci\_scan\_bridge(struct pci\_bus \*bus, struct pci\_dev \*dev, int max,  void pci\_walk\_bus(struct pci\_bus \*top, int (\*cb)(struct pci\_dev \*, void \*), void \*userdata);+void pci\_walk\_bus\_locked(struct pci\_bus \*top, int (\*cb)(struct pci\_dev \*, void \*),+ void \*userdata); int pci\_cfg\_space\_size(struct pci\_dev \*dev); unsigned char pci\_bus\_max\_busnr(struct pci\_bus \*bus); void pci\_setup\_bridge(struct pci\_bus \*bus);@@ -1990,6 +1993,8 @@ static inline int pci\_save\_state(struct pci\_dev \*dev) { return 0; } static inline void pci\_restore\_state(struct pci\_dev \*dev) { } static inline int pci\_set\_power\_state(struct pci\_dev \*dev, pci\_power\_t state) { return 0; }+static inline int pci\_set\_power\_state\_locked(struct pci\_dev \*dev, pci\_power\_t state)+{ return 0; } static inline int pci\_wake\_from\_d3(struct pci\_dev \*dev, bool enable) { return 0; } static inline pci\_power\_t pci\_choose\_state(struct pci\_dev \*dev, |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 17:34:35 +0000

