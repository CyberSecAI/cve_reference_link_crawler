

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=d5347827d0b4b2250cbce6eccaa1c81dc78d8651)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d5347827d0b4b2250cbce6eccaa1c81dc78d8651)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d5347827d0b4b2250cbce6eccaa1c81dc78d8651)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d5347827d0b4b2250cbce6eccaa1c81dc78d8651)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Filipe Manana <fdmanana@suse.com> | 2021-04-22 12:08:05 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2021-05-19 10:29:50 +0200 |
| commit | [d5347827d0b4b2250cbce6eccaa1c81dc78d8651](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d5347827d0b4b2250cbce6eccaa1c81dc78d8651) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=d5347827d0b4b2250cbce6eccaa1c81dc78d8651)) | |
| tree | [da8250f6ff2b1d0c7b9915755e2881564c4579e1](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d5347827d0b4b2250cbce6eccaa1c81dc78d8651) | |
| parent | [637d15e2998a421fcc0db4829db5a6e47b070401](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=637d15e2998a421fcc0db4829db5a6e47b070401) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d5347827d0b4b2250cbce6eccaa1c81dc78d8651&id2=637d15e2998a421fcc0db4829db5a6e47b070401)) | |
| download | [linux-d5347827d0b4b2250cbce6eccaa1c81dc78d8651.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-d5347827d0b4b2250cbce6eccaa1c81dc78d8651.tar.gz) | |

btrfs: fix deadlock when cloning inline extents and using qgroupscommit f9baa501b4fd6962257853d46ddffbc21f27e344 upstream.
There are a few exceptional cases where cloning an inline extent needs to
copy the inline extent data into a page of the destination inode.
When this happens, we end up starting a transaction while having a dirty
page for the destination inode and while having the range locked in the
destination's inode iotree too. Because when reserving metadata space
for a transaction we may need to flush existing delalloc in case there is
not enough free space, we have a mechanism in place to prevent a deadlock,
which was introduced in commit 3d45f221ce627d ("btrfs: fix deadlock when
cloning inline extent and low on free metadata space").
However when using qgroups, a transaction also reserves metadata qgroup
space, which can also result in flushing delalloc in case there is not
enough available space at the moment. When this happens we deadlock, since
flushing delalloc requires locking the file range in the inode's iotree
and the range was already locked at the very beginning of the clone
operation, before attempting to start the transaction.
When this issue happens, stack traces like the following are reported:
[72747.556262] task:kworker/u81:9 state:D stack: 0 pid: 225 ppid: 2 flags:0x00004000
[72747.556268] Workqueue: writeback wb\_workfn (flush-btrfs-1142)
[72747.556271] Call Trace:
[72747.556273] \_\_schedule+0x296/0x760
[72747.556277] schedule+0x3c/0xa0
[72747.556279] io\_schedule+0x12/0x40
[72747.556284] \_\_lock\_page+0x13c/0x280
[72747.556287] ? generic\_file\_readonly\_mmap+0x70/0x70
[72747.556325] extent\_write\_cache\_pages+0x22a/0x440 [btrfs]
[72747.556331] ? \_\_set\_page\_dirty\_nobuffers+0xe7/0x160
[72747.556358] ? set\_extent\_buffer\_dirty+0x5e/0x80 [btrfs]
[72747.556362] ? update\_group\_capacity+0x25/0x210
[72747.556366] ? cpumask\_next\_and+0x1a/0x20
[72747.556391] extent\_writepages+0x44/0xa0 [btrfs]
[72747.556394] do\_writepages+0x41/0xd0
[72747.556398] \_\_writeback\_single\_inode+0x39/0x2a0
[72747.556403] writeback\_sb\_inodes+0x1ea/0x440
[72747.556407] \_\_writeback\_inodes\_wb+0x5f/0xc0
[72747.556410] wb\_writeback+0x235/0x2b0
[72747.556414] ? get\_nr\_inodes+0x35/0x50
[72747.556417] wb\_workfn+0x354/0x490
[72747.556420] ? newidle\_balance+0x2c5/0x3e0
[72747.556424] process\_one\_work+0x1aa/0x340
[72747.556426] worker\_thread+0x30/0x390
[72747.556429] ? create\_worker+0x1a0/0x1a0
[72747.556432] kthread+0x116/0x130
[72747.556435] ? kthread\_park+0x80/0x80
[72747.556438] ret\_from\_fork+0x1f/0x30
[72747.566958] Workqueue: btrfs-flush\_delalloc btrfs\_work\_helper [btrfs]
[72747.566961] Call Trace:
[72747.566964] \_\_schedule+0x296/0x760
[72747.566968] ? finish\_wait+0x80/0x80
[72747.566970] schedule+0x3c/0xa0
[72747.566995] wait\_extent\_bit.constprop.68+0x13b/0x1c0 [btrfs]
[72747.566999] ? finish\_wait+0x80/0x80
[72747.567024] lock\_extent\_bits+0x37/0x90 [btrfs]
[72747.567047] btrfs\_invalidatepage+0x299/0x2c0 [btrfs]
[72747.567051] ? find\_get\_pages\_range\_tag+0x2cd/0x380
[72747.567076] \_\_extent\_writepage+0x203/0x320 [btrfs]
[72747.567102] extent\_write\_cache\_pages+0x2bb/0x440 [btrfs]
[72747.567106] ? update\_load\_avg+0x7e/0x5f0
[72747.567109] ? enqueue\_entity+0xf4/0x6f0
[72747.567134] extent\_writepages+0x44/0xa0 [btrfs]
[72747.567137] ? enqueue\_task\_fair+0x93/0x6f0
[72747.567140] do\_writepages+0x41/0xd0
[72747.567144] \_\_filemap\_fdatawrite\_range+0xc7/0x100
[72747.567167] btrfs\_run\_delalloc\_work+0x17/0x40 [btrfs]
[72747.567195] btrfs\_work\_helper+0xc2/0x300 [btrfs]
[72747.567200] process\_one\_work+0x1aa/0x340
[72747.567202] worker\_thread+0x30/0x390
[72747.567205] ? create\_worker+0x1a0/0x1a0
[72747.567208] kthread+0x116/0x130
[72747.567211] ? kthread\_park+0x80/0x80
[72747.567214] ret\_from\_fork+0x1f/0x30
[72747.569686] task:fsstress state:D stack: 0 pid:841421 ppid:841417 flags:0x00000000
[72747.569689] Call Trace:
[72747.569691] \_\_schedule+0x296/0x760
[72747.569694] schedule+0x3c/0xa0
[72747.569721] try\_flush\_qgroup+0x95/0x140 [btrfs]
[72747.569725] ? finish\_wait+0x80/0x80
[72747.569753] btrfs\_qgroup\_reserve\_data+0x34/0x50 [btrfs]
[72747.569781] btrfs\_check\_data\_free\_space+0x5f/0xa0 [btrfs]
[72747.569804] btrfs\_buffered\_write+0x1f7/0x7f0 [btrfs]
[72747.569810] ? path\_lookupat.isra.48+0x97/0x140
[72747.569833] btrfs\_file\_write\_iter+0x81/0x410 [btrfs]
[72747.569836] ? \_\_kmalloc+0x16a/0x2c0
[72747.569839] do\_iter\_readv\_writev+0x160/0x1c0
[72747.569843] do\_iter\_write+0x80/0x1b0
[72747.569847] vfs\_writev+0x84/0x140
[72747.569869] ? btrfs\_file\_llseek+0x38/0x270 [btrfs]
[72747.569873] do\_writev+0x65/0x100
[72747.569876] do\_syscall\_64+0x33/0x40
[72747.569879] entry\_SYSCALL\_64\_after\_hwframe+0x44/0xa9
[72747.569899] task:fsstress state:D stack: 0 pid:841424 ppid:841417 flags:0x00004000
[72747.569903] Call Trace:
[72747.569906] \_\_schedule+0x296/0x760
[72747.569909] schedule+0x3c/0xa0
[72747.569936] try\_flush\_qgroup+0x95/0x140 [btrfs]
[72747.569940] ? finish\_wait+0x80/0x80
[72747.569967] \_\_btrfs\_qgroup\_reserve\_meta+0x36/0x50 [btrfs]
[72747.569989] start\_transaction+0x279/0x580 [btrfs]
[72747.570014] clone\_copy\_inline\_extent+0x332/0x490 [btrfs]
[72747.570041] btrfs\_clone+0x5b7/0x7a0 [btrfs]
[72747.570068] ? lock\_extent\_bits+0x64/0x90 [btrfs]
[72747.570095] btrfs\_clone\_files+0xfc/0x150 [btrfs]
[72747.570122] btrfs\_remap\_file\_range+0x3d8/0x4a0 [btrfs]
[72747.570126] do\_clone\_file\_range+0xed/0x200
[72747.570131] vfs\_clone\_file\_range+0x37/0x110
[72747.570134] ioctl\_file\_clone+0x7d/0xb0
[72747.570137] do\_vfs\_ioctl+0x138/0x630
[72747.570140] \_\_x64\_sys\_ioctl+0x62/0xc0
[72747.570143] do\_syscall\_64+0x33/0x40
[72747.570146] entry\_SYSCALL\_64\_after\_hwframe+0x44/0xa9
So fix this by skipping the flush of delalloc for an inode that is
flagged with BTRFS\_INODE\_NO\_DELALLOC\_FLUSH, meaning it is currently under
such a special case of cloning an inline extent, when flushing delalloc
during qgroup metadata reservation.
The special cases for cloning inline extents were added in kernel 5.7 by
by commit 05a5a7621ce66c ("Btrfs: implement full reflink support for
inline extents"), while having qgroup metadata space reservation flushing
delalloc when low on space was added in kernel 5.9 by commit
c53e9653605dbf ("btrfs: qgroup: try to flush qgroup space when we get
-EDQUOT"). So use a "Fixes:" tag for the later commit to ease stable
kernel backports.
Reported-by: Wang Yugui <wangyugui@e16-tech.com>
Link: [https://lore.kernel.org/linux-btrfs/20210421083137.31E3.409509F4@e16-tech.com/](https://lore.kernel.org/linux-btrfs/20210421083137.31E3.409509F4%40e16-tech.com/)
Fixes: c53e9653605dbf ("btrfs: qgroup: try to flush qgroup space when we get -EDQUOT")
CC: stable@vger.kernel.org # 5.9+
Reviewed-by: Qu Wenruo <wqu@suse.com>
Signed-off-by: Filipe Manana <fdmanana@suse.com>
Reviewed-by: David Sterba <dsterba@suse.com>
Signed-off-by: David Sterba <dsterba@suse.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d5347827d0b4b2250cbce6eccaa1c81dc78d8651)

| -rw-r--r-- | [fs/btrfs/ctree.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/ctree.h?id=d5347827d0b4b2250cbce6eccaa1c81dc78d8651) | 2 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/btrfs/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/inode.c?id=d5347827d0b4b2250cbce6eccaa1c81dc78d8651) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/ioctl.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/ioctl.c?id=d5347827d0b4b2250cbce6eccaa1c81dc78d8651) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/qgroup.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/qgroup.c?id=d5347827d0b4b2250cbce6eccaa1c81dc78d8651) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/send.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/send.c?id=d5347827d0b4b2250cbce6eccaa1c81dc78d8651) | 4 | |  |  |  | | --- | --- | --- | |

5 files changed, 7 insertions, 7 deletions

| diff --git a/fs/btrfs/ctree.h b/fs/btrfs/ctree.hindex 0c8c55a41d7b22..c6e0f7a647cca7 100644--- a/[fs/btrfs/ctree.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/ctree.h?id=637d15e2998a421fcc0db4829db5a6e47b070401)+++ b/[fs/btrfs/ctree.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/ctree.h?id=d5347827d0b4b2250cbce6eccaa1c81dc78d8651)@@ -3104,7 +3104,7 @@ int btrfs\_truncate\_inode\_items(struct btrfs\_trans\_handle \*trans, struct btrfs\_inode \*inode, u64 new\_size, u32 min\_type); -int btrfs\_start\_delalloc\_snapshot(struct btrfs\_root \*root);+int btrfs\_start\_delalloc\_snapshot(struct btrfs\_root \*root, bool in\_reclaim\_context); int btrfs\_start\_delalloc\_roots(struct btrfs\_fs\_info \*fs\_info, u64 nr, bool in\_reclaim\_context); int btrfs\_set\_extent\_delalloc(struct btrfs\_inode \*inode, u64 start, u64 end,diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.cindex fe723eadced798..c4c26724a00c25 100644--- a/[fs/btrfs/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/inode.c?id=637d15e2998a421fcc0db4829db5a6e47b070401)+++ b/[fs/btrfs/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/inode.c?id=d5347827d0b4b2250cbce6eccaa1c81dc78d8651)@@ -9475,7 +9475,7 @@ out: return ret; } -int btrfs\_start\_delalloc\_snapshot(struct btrfs\_root \*root)+int btrfs\_start\_delalloc\_snapshot(struct btrfs\_root \*root, bool in\_reclaim\_context) { struct writeback\_control wbc = { .nr\_to\_write = LONG\_MAX,@@ -9488,7 +9488,7 @@ int btrfs\_start\_delalloc\_snapshot(struct btrfs\_root \*root) if (test\_bit(BTRFS\_FS\_STATE\_ERROR, &fs\_info->fs\_state)) return -EROFS; - return start\_delalloc\_inodes(root, &wbc, true, false);+ return start\_delalloc\_inodes(root, &wbc, true, in\_reclaim\_context); }  int btrfs\_start\_delalloc\_roots(struct btrfs\_fs\_info \*fs\_info, u64 nr,diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.cindex d06ad9a9abb335..1285837c27462f 100644--- a/[fs/btrfs/ioctl.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/ioctl.c?id=637d15e2998a421fcc0db4829db5a6e47b070401)+++ b/[fs/btrfs/ioctl.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/ioctl.c?id=d5347827d0b4b2250cbce6eccaa1c81dc78d8651)@@ -1042,7 +1042,7 @@ static noinline int btrfs\_mksnapshot(const struct path \*parent, \*/ btrfs\_drew\_read\_lock(&root->snapshot\_lock); - ret = btrfs\_start\_delalloc\_snapshot(root);+ ret = btrfs\_start\_delalloc\_snapshot(root, false); if (ret) goto out; diff --git a/fs/btrfs/qgroup.c b/fs/btrfs/qgroup.cindex f0b9ef13153adb..2991287a71a875 100644--- a/[fs/btrfs/qgroup.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/qgroup.c?id=637d15e2998a421fcc0db4829db5a6e47b070401)+++ b/[fs/btrfs/qgroup.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/qgroup.c?id=d5347827d0b4b2250cbce6eccaa1c81dc78d8651)@@ -3579,7 +3579,7 @@ static int try\_flush\_qgroup(struct btrfs\_root \*root) return 0; } - ret = btrfs\_start\_delalloc\_snapshot(root);+ ret = btrfs\_start\_delalloc\_snapshot(root, true); if (ret < 0) goto out; btrfs\_wait\_ordered\_extents(root, U64\_MAX, 0, (u64)-1);diff --git a/fs/btrfs/send.c b/fs/btrfs/send.cindex 78a35374d49291..e405d68fe1e30f 100644--- a/[fs/btrfs/send.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/send.c?id=637d15e2998a421fcc0db4829db5a6e47b070401)+++ b/[fs/btrfs/send.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/send.c?id=d5347827d0b4b2250cbce6eccaa1c81dc78d8651)@@ -7159,7 +7159,7 @@ static int flush\_delalloc\_roots(struct send\_ctx \*sctx) int i;  if (root) {- ret = btrfs\_start\_delalloc\_snapshot(root);+ ret = btrfs\_start\_delalloc\_snapshot(root, false); if (ret) return ret; btrfs\_wait\_ordered\_extents(root, U64\_MAX, 0, U64\_MAX);@@ -7167,7 +7167,7 @@ static int flush\_delalloc\_roots(struct send\_ctx \*sctx)  for (i = 0; i < sctx->clone\_roots\_cnt; i++) { root = sctx->clone\_roots[i].root;- ret = btrfs\_start\_delalloc\_snapshot(root);+ ret = btrfs\_start\_delalloc\_snapshot(root, false); if (ret) return ret; btrfs\_wait\_ordered\_extents(root, U64\_MAX, 0, U64\_MAX); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 22:46:09 +0000

