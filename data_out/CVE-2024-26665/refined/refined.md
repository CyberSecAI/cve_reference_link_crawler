The provided content relates to CVE-2024-26665.

**Root cause of vulnerability:**
The vulnerability stems from an out-of-bounds access when building IPv6 Path Maximum Transmission Unit (PMTU) error messages within the Linux kernel's tunneling implementation. The issue arises when the ICMPv6 error message is constructed from a non-linear sk\_buff (socket buffer).

**Weaknesses/vulnerabilities present:**
- Out-of-bounds read: The `csum_partial` function attempts to calculate a checksum on a potentially non-contiguous memory region (non-linear skb).
- Incorrect checksum calculation: The use of `csum_partial` on a non-linear skb leads to a read out of the bounds of the buffer, resulting in an incorrect checksum.

**Impact of exploitation:**
- Kernel crash: The out-of-bounds read can lead to a kernel crash, resulting in a denial of service (DoS).
- Potential information leakage: Though not explicitly stated, an out-of-bounds read could potentially leak kernel memory.

**Attack vectors:**
- Triggering a PMTU discovery event that results in an ICMPv6 error being generated.
- Sending a packet through a tunnel, where the packet's size causes the PMTU to be exceeded, triggering the ICMPv6 error.
- Exploitation would involve sending packets through the tunnel that trigger the vulnerability

**Required attacker capabilities/position:**
- The attacker must be able to send network packets that traverse a tunnel within the vulnerable system.
- The attacker needs to be able to induce a PMTU discovery event.
- The attacker needs to be able to cause a path MTU to be discovered that is smaller than the size of the packets being sent, such that an ICMPv6 PMTU error is triggered and a non-linear skb is used to build the error message.

**Technical Details:**

The issue lies in `net/ipv4/ip_tunnel_core.c` within the function `iptunnel_pmtud_build_icmpv6`. The original code used `csum_partial(icmp6h, len, 0)` to calculate the checksum of the ICMPv6 header. However, `csum_partial` is not designed to handle non-linear sk\_buffs, leading to the out-of-bounds read. The fix replaces `csum_partial` with `skb_checksum(skb, skb_transport_offset(skb), len, 0)`, which can correctly handle non-linear sk\_buffs.

The fix for this issue is described as: "Use skb\_checksum instead of csum\_partial who cannot deal with non-linear SKBs."