
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FOP-TEE%2Foptee_os%2Fblob%2Fc2d449482de098f1c894b94f338440e5a327813d%2Fcore%2Ftee%2Fentry_std.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FOP-TEE%2Foptee_os%2Fblob%2Fc2d449482de098f1c894b94f338440e5a327813d%2Fcore%2Ftee%2Fentry_std.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=OP-TEE%2Foptee_os)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[OP-TEE](/OP-TEE)
/
**[optee\_os](/OP-TEE/optee_os)**
Public

* [Notifications](/login?return_to=%2FOP-TEE%2Foptee_os) You must be signed in to change notification settings
* [Fork
  1.1k](/login?return_to=%2FOP-TEE%2Foptee_os)
* [Star
   1.6k](/login?return_to=%2FOP-TEE%2Foptee_os)

* [Code](/OP-TEE/optee_os)
* [Issues
  27](/OP-TEE/optee_os/issues)
* [Pull requests
  24](/OP-TEE/optee_os/pulls)
* [Actions](/OP-TEE/optee_os/actions)
* [Projects
  0](/OP-TEE/optee_os/projects)
* [Wiki](/OP-TEE/optee_os/wiki)
* [Security](/OP-TEE/optee_os/security)
* [Insights](/OP-TEE/optee_os/pulse)

Additional navigation options

* [Code](/OP-TEE/optee_os)
* [Issues](/OP-TEE/optee_os/issues)
* [Pull requests](/OP-TEE/optee_os/pulls)
* [Actions](/OP-TEE/optee_os/actions)
* [Projects](/OP-TEE/optee_os/projects)
* [Wiki](/OP-TEE/optee_os/wiki)
* [Security](/OP-TEE/optee_os/security)
* [Insights](/OP-TEE/optee_os/pulse)

## Files

 c2d4494
## Breadcrumbs

1. [optee\_os](/OP-TEE/optee_os/tree/c2d449482de098f1c894b94f338440e5a327813d)
2. /[core](/OP-TEE/optee_os/tree/c2d449482de098f1c894b94f338440e5a327813d/core)
3. /[tee](/OP-TEE/optee_os/tree/c2d449482de098f1c894b94f338440e5a327813d/core/tee)
/
# entry\_std.c

 Blame  Blame
## Latest commit

## History

[History](/OP-TEE/optee_os/commits/c2d449482de098f1c894b94f338440e5a327813d/core/tee/entry_std.c)609 lines (521 loc) · 14.8 KB c2d4494
## Breadcrumbs

1. [optee\_os](/OP-TEE/optee_os/tree/c2d449482de098f1c894b94f338440e5a327813d)
2. /[core](/OP-TEE/optee_os/tree/c2d449482de098f1c894b94f338440e5a327813d/core)
3. /[tee](/OP-TEE/optee_os/tree/c2d449482de098f1c894b94f338440e5a327813d/core/tee)
/
# entry\_std.c

Top
## File metadata and controls

* Code
* Blame

609 lines (521 loc) · 14.8 KB[Raw](https://github.com/OP-TEE/optee_os/raw/c2d449482de098f1c894b94f338440e5a327813d/core/tee/entry_std.c)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609// SPDX-License-Identifier: BSD-2-Clause/\* \* Copyright (c) 2015-2016, Linaro Limited \* Copyright (c) 2014, STMicroelectronics International N.V. \*/
#include <assert.h>#include <bench.h>#include <compiler.h>#include <initcall.h>#include <io.h>#include <kernel/linker.h>#include <kernel/msg\_param.h>#include <kernel/notif.h>#include <kernel/panic.h>#include <kernel/tee\_misc.h>#include <mm/core\_memprot.h>#include <mm/core\_mmu.h>#include <mm/mobj.h>#include <optee\_msg.h>#include <sm/optee\_smc.h>#include <string.h>#include <tee/entry\_std.h>#include <tee/tee\_cryp\_utl.h>#include <tee/uuid.h>#include <util.h>
#define SHM\_CACHE\_ATTRS \ (uint32\_t)(core\_mmu\_is\_shm\_cached() ? OPTEE\_SMC\_SHM\_CACHED : 0)
/\* Sessions opened from normal world \*/static struct tee\_ta\_session\_head tee\_open\_sessions =TAILQ\_HEAD\_INITIALIZER(tee\_open\_sessions);
#ifdef CFG\_CORE\_RESERVED\_SHMstatic struct mobj \*shm\_mobj;#endif#ifdef CFG\_SECURE\_DATA\_PATHstatic struct mobj \*\*sdp\_mem\_mobjs;#endif
static unsigned int session\_pnum;
static bool \_\_maybe\_unused param\_mem\_from\_mobj(struct param\_mem \*mem, struct mobj \*mobj, const paddr\_t pa, const size\_t sz){ paddr\_t b;
 if (mobj\_get\_pa(mobj, 0, 0, &b) != TEE\_SUCCESS) panic("mobj\_get\_pa failed");
 if (!core\_is\_buffer\_inside(pa, MAX(sz, 1UL), b, mobj->size)) return false;
 mem->mobj = mobj\_get(mobj); mem->offs = pa - b; mem->size = sz; return true;}
#ifdef CFG\_CORE\_FFAstatic TEE\_Result set\_fmem\_param(const struct optee\_msg\_param\_fmem \*fmem, struct param\_mem \*mem){ size\_t req\_size = 0; uint64\_t global\_id = READ\_ONCE(fmem->global\_id); size\_t sz = READ\_ONCE(fmem->size);
 if (global\_id == OPTEE\_MSG\_FMEM\_INVALID\_GLOBAL\_ID && !sz) { mem->mobj = NULL; mem->offs = 0; mem->size = 0; return TEE\_SUCCESS; } mem->mobj = mobj\_ffa\_get\_by\_cookie(global\_id, READ\_ONCE(fmem->internal\_offs)); if (!mem->mobj) return TEE\_ERROR\_BAD\_PARAMETERS;
 mem->offs = reg\_pair\_to\_64(READ\_ONCE(fmem->offs\_high), READ\_ONCE(fmem->offs\_low)); mem->size = sz;
 /\* \* Check that the supplied offset and size is covered by the \* previously verified MOBJ. \*/ if (ADD\_OVERFLOW(mem->offs, mem->size, &req\_size) || mem->mobj->size < req\_size) return TEE\_ERROR\_SECURITY;
 return TEE\_SUCCESS;}#else /\*!CFG\_CORE\_FFA\*//\* fill 'struct param\_mem' structure if buffer matches a valid memory object \*/static TEE\_Result set\_tmem\_param(const struct optee\_msg\_param\_tmem \*tmem, uint32\_t attr, struct param\_mem \*mem){ struct mobj \_\_maybe\_unused \*\*mobj; paddr\_t pa = READ\_ONCE(tmem->buf\_ptr); size\_t sz = READ\_ONCE(tmem->size);
 /\* \* Handle NULL memory reference \*/ if (!pa) { mem->mobj = NULL; mem->offs = 0; mem->size = 0; return TEE\_SUCCESS; }
 /\* Handle non-contiguous reference from a shared memory area \*/ if (attr & OPTEE\_MSG\_ATTR\_NONCONTIG) { uint64\_t shm\_ref = READ\_ONCE(tmem->shm\_ref);
 mem->mobj = msg\_param\_mobj\_from\_noncontig(pa, sz, shm\_ref, false); if (!mem->mobj) return TEE\_ERROR\_BAD\_PARAMETERS; mem->offs = 0; mem->size = sz; return TEE\_SUCCESS; }
#ifdef CFG\_CORE\_RESERVED\_SHM /\* Handle memory reference in the contiguous shared memory \*/ if (param\_mem\_from\_mobj(mem, shm\_mobj, pa, sz)) return TEE\_SUCCESS;#endif
#ifdef CFG\_SECURE\_DATA\_PATH /\* Handle memory reference to Secure Data Path memory areas \*/ for (mobj = sdp\_mem\_mobjs; \*mobj; mobj++) if (param\_mem\_from\_mobj(mem, \*mobj, pa, sz)) return TEE\_SUCCESS;#endif
 return TEE\_ERROR\_BAD\_PARAMETERS;}
#ifdef CFG\_CORE\_DYN\_SHMstatic TEE\_Result set\_rmem\_param(const struct optee\_msg\_param\_rmem \*rmem, struct param\_mem \*mem){ size\_t req\_size = 0; uint64\_t shm\_ref = READ\_ONCE(rmem->shm\_ref); size\_t sz = READ\_ONCE(rmem->size);
 mem->mobj = mobj\_reg\_shm\_get\_by\_cookie(shm\_ref); if (!mem->mobj) return TEE\_ERROR\_BAD\_PARAMETERS;
 mem->offs = READ\_ONCE(rmem->offs); mem->size = sz;
 /\* \* Check that the supplied offset and size is covered by the \* previously verified MOBJ. \*/ if (ADD\_OVERFLOW(mem->offs, mem->size, &req\_size) || mem->mobj->size < req\_size) return TEE\_ERROR\_SECURITY;
 return TEE\_SUCCESS;}#endif /\*CFG\_CORE\_DYN\_SHM\*/#endif /\*!CFG\_CORE\_FFA\*/
static TEE\_Result copy\_in\_params(const struct optee\_msg\_param \*params, uint32\_t num\_params, struct tee\_ta\_param \*ta\_param, uint64\_t \*saved\_attr){ TEE\_Result res; size\_t n; uint8\_t pt[TEE\_NUM\_PARAMS] = { 0 };
 if (num\_params > TEE\_NUM\_PARAMS) return TEE\_ERROR\_BAD\_PARAMETERS;
 memset(ta\_param, 0, sizeof(\*ta\_param));
 for (n = 0; n < num\_params; n++) { uint32\_t attr;
 saved\_attr[n] = READ\_ONCE(params[n].attr);
 if (saved\_attr[n] & OPTEE\_MSG\_ATTR\_META) return TEE\_ERROR\_BAD\_PARAMETERS;
 attr = saved\_attr[n] & OPTEE\_MSG\_ATTR\_TYPE\_MASK; switch (attr) { case OPTEE\_MSG\_ATTR\_TYPE\_NONE: pt[n] = TEE\_PARAM\_TYPE\_NONE; break; case OPTEE\_MSG\_ATTR\_TYPE\_VALUE\_INPUT: case OPTEE\_MSG\_ATTR\_TYPE\_VALUE\_OUTPUT: case OPTEE\_MSG\_ATTR\_TYPE\_VALUE\_INOUT: pt[n] = TEE\_PARAM\_TYPE\_VALUE\_INPUT + attr - OPTEE\_MSG\_ATTR\_TYPE\_VALUE\_INPUT; ta\_param->u[n].val.a = READ\_ONCE(params[n].u.value.a); ta\_param->u[n].val.b = READ\_ONCE(params[n].u.value.b); break;#ifdef CFG\_CORE\_FFA case OPTEE\_MSG\_ATTR\_TYPE\_FMEM\_INPUT: case OPTEE\_MSG\_ATTR\_TYPE\_FMEM\_OUTPUT: case OPTEE\_MSG\_ATTR\_TYPE\_FMEM\_INOUT: res = set\_fmem\_param(&params[n].u.fmem, &ta\_param->u[n].mem); if (res) return res; pt[n] = TEE\_PARAM\_TYPE\_MEMREF\_INPUT + attr - OPTEE\_MSG\_ATTR\_TYPE\_FMEM\_INPUT; break;#else /\*!CFG\_CORE\_FFA\*/ case OPTEE\_MSG\_ATTR\_TYPE\_TMEM\_INPUT: case OPTEE\_MSG\_ATTR\_TYPE\_TMEM\_OUTPUT: case OPTEE\_MSG\_ATTR\_TYPE\_TMEM\_INOUT: res = set\_tmem\_param(&params[n].u.tmem, saved\_attr[n], &ta\_param->u[n].mem); if (res) return res; pt[n] = TEE\_PARAM\_TYPE\_MEMREF\_INPUT + attr - OPTEE\_MSG\_ATTR\_TYPE\_TMEM\_INPUT; break;#ifdef CFG\_CORE\_DYN\_SHM case OPTEE\_MSG\_ATTR\_TYPE\_RMEM\_INPUT: case OPTEE\_MSG\_ATTR\_TYPE\_RMEM\_OUTPUT: case OPTEE\_MSG\_ATTR\_TYPE\_RMEM\_INOUT: res = set\_rmem\_param(&params[n].u.rmem, &ta\_param->u[n].mem); if (res) return res; pt[n] = TEE\_PARAM\_TYPE\_MEMREF\_INPUT + attr - OPTEE\_MSG\_ATTR\_TYPE\_RMEM\_INPUT; break;#endif /\*CFG\_CORE\_DYN\_SHM\*/#endif /\*!CFG\_CORE\_FFA\*/ default: return TEE\_ERROR\_BAD\_PARAMETERS; } }
 ta\_param->types = TEE\_PARAM\_TYPES(pt[0], pt[1], pt[2], pt[3]);
 return TEE\_SUCCESS;}
static void cleanup\_shm\_refs(const uint64\_t \*saved\_attr, struct tee\_ta\_param \*param, uint32\_t num\_params){ size\_t n;
 for (n = 0; n < num\_params; n++) { switch (saved\_attr[n]) { case OPTEE\_MSG\_ATTR\_TYPE\_TMEM\_INPUT: case OPTEE\_MSG\_ATTR\_TYPE\_TMEM\_OUTPUT: case OPTEE\_MSG\_ATTR\_TYPE\_TMEM\_INOUT:#ifdef CFG\_CORE\_DYN\_SHM case OPTEE\_MSG\_ATTR\_TYPE\_RMEM\_INPUT: case OPTEE\_MSG\_ATTR\_TYPE\_RMEM\_OUTPUT: case OPTEE\_MSG\_ATTR\_TYPE\_RMEM\_INOUT:#endif mobj\_put(param->u[n].mem.mobj); break; default: break; } }}
static void copy\_out\_param(struct tee\_ta\_param \*ta\_param, uint32\_t num\_params, struct optee\_msg\_param \*params, uint64\_t \*saved\_attr){ size\_t n;
 for (n = 0; n < num\_params; n++) { switch (TEE\_PARAM\_TYPE\_GET(ta\_param->types, n)) { case TEE\_PARAM\_TYPE\_MEMREF\_OUTPUT: case TEE\_PARAM\_TYPE\_MEMREF\_INOUT: switch (saved\_attr[n] & OPTEE\_MSG\_ATTR\_TYPE\_MASK) { case OPTEE\_MSG\_ATTR\_TYPE\_TMEM\_OUTPUT: case OPTEE\_MSG\_ATTR\_TYPE\_TMEM\_INOUT: params[n].u.tmem.size = ta\_param->u[n].mem.size; break; case OPTEE\_MSG\_ATTR\_TYPE\_RMEM\_OUTPUT: case OPTEE\_MSG\_ATTR\_TYPE\_RMEM\_INOUT: params[n].u.rmem.size = ta\_param->u[n].mem.size; break; default: break; } break; case TEE\_PARAM\_TYPE\_VALUE\_OUTPUT: case TEE\_PARAM\_TYPE\_VALUE\_INOUT: params[n].u.value.a = ta\_param->u[n].val.a; params[n].u.value.b = ta\_param->u[n].val.b; break; default: break; } }}
/\* \* Extracts mandatory parameter for open session. \* \* Returns \* false : mandatory parameter wasn't found or malformatted \* true : paramater found and OK \*/static TEE\_Result get\_open\_session\_meta(size\_t num\_params, struct optee\_msg\_param \*params, size\_t \*num\_meta, TEE\_UUID \*uuid, TEE\_Identity \*clnt\_id){ const uint32\_t req\_attr = OPTEE\_MSG\_ATTR\_META | OPTEE\_MSG\_ATTR\_TYPE\_VALUE\_INPUT;
 if (num\_params < 2) return TEE\_ERROR\_BAD\_PARAMETERS;
 if (params[0].attr != req\_attr || params[1].attr != req\_attr) return TEE\_ERROR\_BAD\_PARAMETERS;
 tee\_uuid\_from\_octets(uuid, (void \*)&params[0].u.value); clnt\_id->login = params[1].u.value.c; switch (clnt\_id->login) { case TEE\_LOGIN\_PUBLIC: case TEE\_LOGIN\_REE\_KERNEL: memset(&clnt\_id->uuid, 0, sizeof(clnt\_id->uuid)); break; case TEE\_LOGIN\_USER: case TEE\_LOGIN\_GROUP: case TEE\_LOGIN\_APPLICATION: case TEE\_LOGIN\_APPLICATION\_USER: case TEE\_LOGIN\_APPLICATION\_GROUP: tee\_uuid\_from\_octets(&clnt\_id->uuid, (void \*)&params[1].u.value); break; default: return TEE\_ERROR\_BAD\_PARAMETERS; }
 \*num\_meta = 2; return TEE\_SUCCESS;}
static void entry\_open\_session(struct optee\_msg\_arg \*arg, uint32\_t num\_params){ TEE\_Result res; TEE\_ErrorOrigin err\_orig = TEE\_ORIGIN\_TEE; struct tee\_ta\_session \*s = NULL; TEE\_Identity clnt\_id; TEE\_UUID uuid; struct tee\_ta\_param param; size\_t num\_meta; uint64\_t saved\_attr[TEE\_NUM\_PARAMS] = { 0 };
 res = get\_open\_session\_meta(num\_params, arg->params, &num\_meta, &uuid, &clnt\_id); if (res != TEE\_SUCCESS) goto out;
 res = copy\_in\_params(arg->params + num\_meta, num\_params - num\_meta, &param, saved\_attr); if (res != TEE\_SUCCESS) goto cleanup\_shm\_refs;
 res = tee\_ta\_open\_session(&err\_orig, &s, &tee\_open\_sessions, &uuid, &clnt\_id, TEE\_TIMEOUT\_INFINITE, &param); if (res != TEE\_SUCCESS) s = NULL; copy\_out\_param(&param, num\_params - num\_meta, arg->params + num\_meta, saved\_attr);
 /\* \* The occurrence of open/close session command is usually \* un-predictable, using this property to increase randomness \* of prng \*/ plat\_prng\_add\_jitter\_entropy(CRYPTO\_RNG\_SRC\_JITTER\_SESSION, &session\_pnum);
cleanup\_shm\_refs: cleanup\_shm\_refs(saved\_attr, &param, num\_params - num\_meta);
out: if (s) arg->session = s->id; else arg->session = 0; arg->ret = res; arg->ret\_origin = err\_orig;}
static void entry\_close\_session(struct optee\_msg\_arg \*arg, uint32\_t num\_params){ TEE\_Result res; struct tee\_ta\_session \*s;
 if (num\_params) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 plat\_prng\_add\_jitter\_entropy(CRYPTO\_RNG\_SRC\_JITTER\_SESSION, &session\_pnum);
 s = tee\_ta\_find\_session(arg->session, &tee\_open\_sessions); res = tee\_ta\_close\_session(s, &tee\_open\_sessions, NSAPP\_IDENTITY);out: arg->ret = res; arg->ret\_origin = TEE\_ORIGIN\_TEE;}
static void entry\_invoke\_command(struct optee\_msg\_arg \*arg, uint32\_t num\_params){ TEE\_Result res; TEE\_ErrorOrigin err\_orig = TEE\_ORIGIN\_TEE; struct tee\_ta\_session \*s; struct tee\_ta\_param param = { 0 }; uint64\_t saved\_attr[TEE\_NUM\_PARAMS] = { 0 };
 bm\_timestamp();
 res = copy\_in\_params(arg->params, num\_params, &param, saved\_attr); if (res != TEE\_SUCCESS) goto out;
 s = tee\_ta\_get\_session(arg->session, true, &tee\_open\_sessions); if (!s) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 res = tee\_ta\_invoke\_command(&err\_orig, s, NSAPP\_IDENTITY, TEE\_TIMEOUT\_INFINITE, arg->func, &param);
 bm\_timestamp();
 tee\_ta\_put\_session(s);
 copy\_out\_param(&param, num\_params, arg->params, saved\_attr);
out: cleanup\_shm\_refs(saved\_attr, &param, num\_params);
 arg->ret = res; arg->ret\_origin = err\_orig;}
static void entry\_cancel(struct optee\_msg\_arg \*arg, uint32\_t num\_params){ TEE\_Result res; TEE\_ErrorOrigin err\_orig = TEE\_ORIGIN\_TEE; struct tee\_ta\_session \*s;
 if (num\_params) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 s = tee\_ta\_get\_session(arg->session, false, &tee\_open\_sessions); if (!s) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 res = tee\_ta\_cancel\_command(&err\_orig, s, NSAPP\_IDENTITY); tee\_ta\_put\_session(s);
out: arg->ret = res; arg->ret\_origin = err\_orig;}
#ifndef CFG\_CORE\_FFA#ifdef CFG\_CORE\_DYN\_SHMstatic void register\_shm(struct optee\_msg\_arg \*arg, uint32\_t num\_params){ struct optee\_msg\_param\_tmem \*tmem = NULL; struct mobj \*mobj = NULL;
 arg->ret = TEE\_ERROR\_BAD\_PARAMETERS;
 if (num\_params != 1 || (arg->params[0].attr != (OPTEE\_MSG\_ATTR\_TYPE\_TMEM\_OUTPUT | OPTEE\_MSG\_ATTR\_NONCONTIG))) return;
 tmem = &arg->params[0].u.tmem; mobj = msg\_param\_mobj\_from\_noncontig(tmem->buf\_ptr, tmem->size, tmem->shm\_ref, false);
 if (!mobj) return;
 mobj\_reg\_shm\_unguard(mobj); arg->ret = TEE\_SUCCESS;}
static void unregister\_shm(struct optee\_msg\_arg \*arg, uint32\_t num\_params){ if (num\_params == 1) { uint64\_t cookie = arg->params[0].u.rmem.shm\_ref; TEE\_Result res = mobj\_reg\_shm\_release\_by\_cookie(cookie);
 if (res) EMSG("Can't find mapping with given cookie"); arg->ret = res; } else { arg->ret = TEE\_ERROR\_BAD\_PARAMETERS; arg->ret\_origin = TEE\_ORIGIN\_TEE; }}#endif /\*CFG\_CORE\_DYN\_SHM\*/#endif
void nsec\_sessions\_list\_head(struct tee\_ta\_session\_head \*\*open\_sessions){ \*open\_sessions = &tee\_open\_sessions;}
/\* Note: this function is weak to let platforms add special handling \*/uint32\_t \_\_weak tee\_entry\_std(struct optee\_msg\_arg \*arg, uint32\_t num\_params){ return \_\_tee\_entry\_std(arg, num\_params);}
/\* \* If tee\_entry\_std() is overridden, it's still supposed to call this \* function. \*/uint32\_t \_\_tee\_entry\_std(struct optee\_msg\_arg \*arg, uint32\_t num\_params){ uint32\_t rv = OPTEE\_SMC\_RETURN\_OK;
 /\* Enable foreign interrupts for STD calls \*/ thread\_set\_foreign\_intr(true); switch (arg->cmd) { case OPTEE\_MSG\_CMD\_OPEN\_SESSION: entry\_open\_session(arg, num\_params); break; case OPTEE\_MSG\_CMD\_CLOSE\_SESSION: entry\_close\_session(arg, num\_params); break; case OPTEE\_MSG\_CMD\_INVOKE\_COMMAND: entry\_invoke\_command(arg, num\_params); break; case OPTEE\_MSG\_CMD\_CANCEL: entry\_cancel(arg, num\_params); break;#ifndef CFG\_CORE\_FFA#ifdef CFG\_CORE\_DYN\_SHM case OPTEE\_MSG\_CMD\_REGISTER\_SHM: register\_shm(arg, num\_params); break; case OPTEE\_MSG\_CMD\_UNREGISTER\_SHM: unregister\_shm(arg, num\_params); break;#endif#endif
 case OPTEE\_MSG\_CMD\_DO\_BOTTOM\_HALF: if (IS\_ENABLED(CFG\_CORE\_ASYNC\_NOTIF)) notif\_deliver\_event(NOTIF\_EVENT\_DO\_BOTTOM\_HALF); else goto err; break; case OPTEE\_MSG\_CMD\_STOP\_ASYNC\_NOTIF: if (IS\_ENABLED(CFG\_CORE\_ASYNC\_NOTIF)) notif\_deliver\_event(NOTIF\_EVENT\_STOPPED); else goto err; break;
 default:err: EMSG("Unknown cmd 0x%x", arg->cmd); rv = OPTEE\_SMC\_RETURN\_EBADCMD; }
 return rv;}
static TEE\_Result default\_mobj\_init(void){#ifdef CFG\_CORE\_RESERVED\_SHM shm\_mobj = mobj\_phys\_alloc(default\_nsec\_shm\_paddr, default\_nsec\_shm\_size, SHM\_CACHE\_ATTRS, CORE\_MEM\_NSEC\_SHM); if (!shm\_mobj) panic("Failed to register shared memory");#endif
#ifdef CFG\_SECURE\_DATA\_PATH sdp\_mem\_mobjs = core\_sdp\_mem\_create\_mobjs(); if (!sdp\_mem\_mobjs) panic("Failed to register SDP memory");#endif
 return TEE\_SUCCESS;}
driver\_init\_late(default\_mobj\_init);

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

