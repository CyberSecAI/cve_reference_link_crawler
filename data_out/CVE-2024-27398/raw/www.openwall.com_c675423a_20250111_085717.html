<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>oss-security - Re: Linux: Race can lead to UAF in net/bluetooth/sco.c: sco_sock_connect()</title>

<link href="/style.css" type="text/css" rel="stylesheet">
<style type="text/css">
.calendar { text-align: center; }
.ccell { background: #ccc; width: 5ex; padding: 2px; }

.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>
</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">


<table bgcolor="#ffffff" width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>

<td>
<a href="/"><img class="logo" src="/logo.png" border="0" width="182" height="80" alt="Openwall"></a>
<td width="100%">
<div class="nav">
<ul>
<li><a href="/">Products</a>
<ul>
<li><a href="/Owl/">Openwall GNU/*/Linux &nbsp; <i>server OS</i></a>
<li><a href="/lkrg/">Linux Kernel Runtime Guard</a>
<li><a href="/john/">John the Ripper &nbsp; <i>password cracker</i></a>
<ul>
<li><a href="/john/">Free &amp; Open Source for any platform</a>
<li><a href="/john/cloud/">in the cloud</a>
<li><a href="/john/pro/linux/">Pro for Linux</a>
<li><a href="/john/pro/macosx/">Pro for macOS</a>
</ul>
<li><a href="/wordlists/">Wordlists &nbsp; <i>for password cracking</i></a>
<li><a href="/passwdqc/">passwdqc &nbsp; <i>policy enforcement</i></a>
<ul>
<li><a href="/passwdqc/">Free &amp; Open Source for Unix</a>
<li><a href="/passwdqc/windows/">Pro for Windows (Active Directory)</a>
</ul>
<li><a href="/yescrypt/">yescrypt &nbsp; <i>KDF &amp; password hashing</i></a>
<li><a href="/yespower/">yespower &nbsp; <i>Proof-of-Work (PoW)</i></a>
<li><a href="/crypt/">crypt_blowfish &nbsp; <i>password hashing</i></a>
<li><a href="/phpass/">phpass &nbsp; <i>ditto in PHP</i></a>
<li><a href="/tcb/">tcb &nbsp; <i>better password shadowing</i></a>
<li><a href="/pam/">Pluggable Authentication Modules</a>
<li><a href="/scanlogd/">scanlogd &nbsp; <i>port scan detector</i></a>
<li><a href="/popa3d/">popa3d &nbsp; <i>tiny POP3 daemon</i></a>
<li><a href="/blists/">blists &nbsp; <i>web interface to mailing lists</i></a>
<li><a href="/msulogin/">msulogin &nbsp; <i>single user mode login</i></a>
<li><a href="/php_mt_seed/">php_mt_seed &nbsp; <i>mt_rand() cracker</i></a>
</ul>
<li><a href="/services/">Services</a>
<li id="narrow-li-1"><a>Publications</a>
<ul>
<li><a href="/articles/">Articles</a>
<li><a href="/presentations/">Presentations</a>
</ul>
<li><a>Resources</a>
<ul>
<li><a href="/lists/">Mailing lists</a>
<li><a href="https://openwall.info/wiki/">Community wiki</a>
<li><a href="https://github.com/openwall">Source code repositories (GitHub)</a>
<li><a href="https://cvsweb.openwall.com">Source code repositories (CVSweb)</a>
<li><a href="/mirrors/">File archive &amp; mirrors</a>
<li><a href="/signatures/">How to verify digital signatures</a>
<li><a href="/ove/">OVE IDs</a>
</ul>
<li id="last-li"><a href="/news">What's new</a>
</ul>
</div>


</table>


<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">
<a href="https://twitter.com/openwall">
Follow @Openwall on Twitter for new release announcements and other news</a>

</TABLE>
</TABLE>

<a href="1">[&lt;prev]</a> <a href="3">[next&gt;]</a> <a href="1">[&lt;thread-prev]</a> <a href="3">[thread-next&gt;]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;CAH_BBqfhd=4MP8XRWTvfcqFkQtZzwCOtqACtio0tGLKBp+vE0Q&#64;mail.gmail.com&gt;
Date: Sat, 30 Nov 2024 13:18:18 +0800
From: tianshu qiu &lt;jimuchutianshu97&#64;...il.com&gt;
To: Luiz Augusto von Dentz &lt;luiz.dentz&#64;...il.com&gt;
Cc: Solar Designer &lt;solar&#64;...nwall.com&gt;, oss-security&#64;...ts.openwall.com, 
	Marcel Holtmann &lt;marcel&#64;...tmann.org&gt;, Johan Hedberg &lt;johan.hedberg&#64;...il.com&gt;
Subject: Re: Linux: Race can lead to UAF in net/bluetooth/sco.c: sco_sock_connect()

I emailed to security&#64;...nel.org, but no reply received.

This email is a correction to my previous email. The previous mail points
out that sco_sock_timeout deferences the freed "sk" and thus triggers the
UAF.
When using PoC to verify vulnerabilities, the timer function
sco_stock_timeout will be canceled. Because the remote bluetooth address
used by
connect is an invalid value, the asynchronous HCI event processing thread
will cancel the registered sco_stock_timeout timer function.
So in actual exploitation environments, sco_sock_timeout will not be
executed.

==============================================================================
sco_sock_timeout Register Thread
 sco_sock_timeout Cancelled Thread

# sco_sock_connect
#     sco_connect
#          sco_sock_set_timer
 #hci_rx_work

       #     hci_event_packet

       #         hci_event_func

       #             hci_conn_complete_evt

       #                 hci_sco_setup

       #                     hci_connect_cfm

       #                         sco_connect_cfm

       #                             sco_conn_del

       #                                 sco_sock_clear_timer

       #                                     cancel_delayed_work
==============================================================================

The bug was introduced on Apr 11, 2023:
<a href="https://github.com/torvalds/linux/commit/9a8ec9e8ebb5a7c0cfbce2d6b4a6b67b2b78e8f3" rel="nofollow">https://github.com/torvalds/linux/commit/9a8ec9e8ebb5a7c0cfbce2d6b4a6b67b2b78e8f3</a>
The latest affected version is Linux-6.11.5
Effect: Control flow hijacking, local privilege escalation

=*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*=   BUG
DETAILS=*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*=*=

I found the bug when looking for unlocked access to "struct sock" objects
in the "net" directory. I think that "struct sock" is shared among multiple
threads.
Access to struct sock object, especially reading and writing sk-&gt;sk_state,
should call lock_sock(sk) in advance to lock, and call release_sock(sk) to
unlock after the last access to "struct sock" object, so as to prevent race
between threads.

=*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*=

static int sco_sock_connect(struct socket *sock, struct sockaddr *addr, int
alen, int flags)
{
            struct sockaddr_sco *sa = (struct sockaddr_sco *) addr;
            struct sock *sk = sock-&gt;sk;
            int err;

            BT_DBG("sk %p", sk);

            if (alen &lt; sizeof(struct sockaddr_sco) ||
                    addr-&gt;sa_family != AF_BLUETOOTH)
                        return -EINVAL;

            if (sk-&gt;sk_state != BT_OPEN &amp;&amp; sk-&gt;sk_state != BT_BOUND)
                        return -EBADFD;

            if (sk-&gt;sk_type != SOCK_SEQPACKET)
                        err = -EINVAL;

            lock_sock(sk);                                       //first
lock-release pair
            /* Set destination address and psm */
            bacpy(&amp;sco_pi(sk)-&gt;dst, &amp;sa-&gt;sco_bdaddr);
            release_sock(sk);                                 // first
lock-release pair

            err = sco_connect(sk);
            if (err)
                        return err;

            lock_sock(sk);                                     //second
lock-release pair

            err = bt_sock_wait_state(sk, BT_CONNECTED,
            sock_sndtimeo(sk, flags &amp; O_NONBLOCK));

            release_sock(sk);                                 //second
lock-release pair
            return err;
}

static int sco_connect(struct sock *sk)
{
            struct sco_conn *conn;
            struct hci_conn *hcon;
            struct hci_dev  *hdev;

            ......

            hdev = hci_get_route(&amp;sco_pi(sk)-&gt;dst, &amp;sco_pi(sk)-&gt;src,
BDADDR_BREDR);
            if (!hdev)
                        return -EHOSTUNREACH;

            hci_dev_lock(hdev);

            ......

            hcon = hci_connect_sco(hdev, type, &amp;sco_pi(sk)-&gt;dst,
                  sco_pi(sk)-&gt;setting, &amp;sco_pi(sk)-&gt;codec);

            ......

            lock_sock(sk);
   // third lock-release pair

            err = sco_chan_add(conn, sk, NULL);
            if (err) {
                        release_sock(sk);
                        goto unlock;
            }

            /* Update source addr of the socket */
            bacpy(&amp;sco_pi(sk)-&gt;src, &amp;hcon-&gt;src);

            if (hcon-&gt;state == BT_CONNECTED) {
                        sco_sock_clear_timer(sk);
                        sk-&gt;sk_state = BT_CONNECTED;
            } else {
                        sk-&gt;sk_state = BT_CONNECT;
                        sco_sock_set_timer(sk, sk-&gt;sk_sndtimeo);
            }

            release_sock(sk);
 // third lock-release pair

            ......
}

=*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*=

To avoid possible circular locking, the commit that introduced the bug
splits the "lock-release" pair which protects the whole sco_sock_connect to
three parts.
The "if" branch for determining sk -&gt;sk_state in sco_sock_connect is
exposed outside the lock_sock(sk) protection, which can lead to race
condition if two threads
execute "connect" system calls simultaneously.
This will lead to dangling "struct sco_conn" object in the function
sco_chan_add, the calling procedure is:
sco_sock_connect -&gt; sco_connect -&gt; sco_chan_add -&gt; __sco_chan_add.

The "struct hcon" associated to this dangling "struct sco_conn" object
still exists and keep alive in the link list managed by "struct hdev", even
if the "struct sock"
object was freed by the system call "close".

=============================================================================================================================================================================
                     main thread
                          thread 1

        thread 2

# fd = socket(AF_BLUETOOTH,
 SOCK_SEQPACKET | SOCK_NONBLOCK ,
 BTPROTO_SCO)

                      # sco_sock_connect
                                                                        #
sco_sock_connect

                      #     sco_connect

#     sco_connect

                     #         hci_connect_sco
                                                                        #
       hci_connect_sco

                     #             hci_connect_acl
                                                                         #
           hci_connect_acl

                     #                 hci_acl_create_connection
                                                                  #
         hci_acl_create_connection

                     #                     hci_send_cmd(hdev,
HCI_OP_CREATE_CONN, sizeof(cp), &amp;cp);           #
 hci_send_cmd(hdev, HCI_OP_CREATE_CONN, sizeof(cp), &amp;cp);

                     # hci_conn_complete_evt （Asynchronous HCI events）

# close(fd)
# struct sock is freed




        # hci_conn_complete_evt （Asynchronous HCI events）



        # ..........



        #         sco_conn_del


   Deference freed "struct sock".   -----------------&gt;        #
    sock_hold(sk)
=============================================================================================================================================================================

The following two commits attempts to fix the UAF caused by this race
condition bug, but did not fundamentally solve the problem:
<a href="https://github.com/torvalds/linux/commit/1bf4470a3939c678fb822073e9ea77a0560bc6bb" rel="nofollow">https://github.com/torvalds/linux/commit/1bf4470a3939c678fb822073e9ea77a0560bc6bb</a>
<a href="https://github.com/torvalds/linux/commit/483bc08181827fc475643272ffb69c533007e546" rel="nofollow">https://github.com/torvalds/linux/commit/483bc08181827fc475643272ffb69c533007e546</a>

=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*=*=*=*=*=*=*=*DMESG
LOG=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*=*=*=*
[ 70.379666] BUG: KASAN: slab-use-after-free in sco_conn_del+0xa6/0x220
[ 70.379717] Write of size 4 at addr ffff888114fa0080 by task
kworker/u521:2/1177

[ 70.379738] CPU: 4 UID: 0 PID: 1177 Comm: kworker/u521:2 Not tainted
6.11.5 #1
[ 70.379752] Hardware name: VMware, Inc. VMware Virtual Platform/440BX
Desktop Reference Platform, BIOS 6.00 11/12/2020
[ 70.379762] Workqueue: hci0 hci_rx_work
[ 70.379779] Call Trace:
[ 70.379813] &lt;TASK&gt;
[ 70.379825] dump_stack_lvl+0x76/0xa0
[ 70.379841] print_report+0xd1/0x670
[ 70.379854] ? __pfx__raw_spin_lock_irqsave+0x10/0x10
[ 70.379867] ? kasan_complete_mode_report_info+0x6a/0x200
[ 70.379882] kasan_report+0xd6/0x120
[ 70.379892] ? sco_conn_del+0xa6/0x220
[ 70.379905] ? sco_conn_del+0xa6/0x220
[ 70.379919] kasan_check_range+0x11c/0x200
[ 70.379932] __kasan_check_write+0x14/0x30
[ 70.379944] sco_conn_del+0xa6/0x220
[ 70.379957] sco_connect_cfm+0x21c/0xb40
[ 70.379970] ? __kasan_check_write+0x14/0x30
[ 70.379982] ? __pfx_sco_connect_cfm+0x10/0x10
[ 70.379995] ? __pfx_mutex_lock+0x10/0x10
[ 70.380009] hci_sco_setup+0x3a1/0x580
[ 70.380021] ? __pfx_hci_sco_setup+0x10/0x10
[ 70.380032] ? __pfx_mutex_lock+0x10/0x10
[ 70.380045] hci_conn_complete_evt+0x9b3/0x1620
[ 70.380060] ? __pfx_hci_conn_complete_evt+0x10/0x10
[ 70.380073] ? __kasan_check_write+0x14/0x30
[ 70.380085] ? mutex_unlock+0x80/0xe0
[ 70.380096] ? __pfx_mutex_unlock+0x10/0x10
[ 70.380109] hci_event_packet+0x820/0x1090
[ 70.380119] ? __pfx_hci_conn_complete_evt+0x10/0x10
[ 70.380131] ? __pfx_hci_event_packet+0x10/0x10
[ 70.380144] ? __pfx__raw_spin_lock_irqsave+0x10/0x10
[ 70.380155] ? __pfx_hci_cmd_sync_complete+0x10/0x10
[ 70.380167] ? __kasan_check_read+0x11/0x20
[ 70.380181] hci_rx_work+0x317/0xdd0
[ 70.380191] ? __pfx___schedule+0x10/0x10
[ 70.380200] ? pwq_dec_nr_in_flight+0x220/0xb70
[ 70.380214] process_one_work+0x626/0xf80
[ 70.380224] ? __kasan_check_write+0x14/0x30
[ 70.380239] worker_thread+0x87a/0x1550
[ 70.380275] ? __pfx__raw_spin_lock_irqsave+0x10/0x10
[ 70.380289] ? __pfx_worker_thread+0x10/0x10
[ 70.380319] kthread+0x2b3/0x390
[ 70.380326] ? __pfx_kthread+0x10/0x10
[ 70.380333] ret_from_fork+0x44/0x90
[ 70.380366] ? __pfx_kthread+0x10/0x10
[ 70.380373] ret_from_fork_asm+0x1a/0x30
[ 70.380397] &lt;/TASK&gt;

[ 70.380404] Allocated by task 3445:
[ 70.380409] kasan_save_stack+0x39/0x70
[ 70.380416] kasan_save_track+0x14/0x40
[ 70.380420] kasan_save_alloc_info+0x37/0x60
[ 70.380427] __kasan_kmalloc+0xc3/0xd0
[ 70.380432] __kmalloc_noprof+0x1fa/0x4d0
[ 70.380456] sk_prot_alloc+0x16d/0x220
[ 70.380462] sk_alloc+0x35/0x750
[ 70.380468] bt_sock_alloc+0x2f/0x360
[ 70.380473] sco_sock_create+0xc6/0x390
[ 70.380479] bt_sock_create+0x152/0x320
[ 70.380483] __sock_create+0x212/0x550
[ 70.380489] __sys_socket+0x138/0x210
[ 70.380494] __x64_sys_socket+0x72/0xc0
[ 70.380499] x64_sys_call+0xd6f/0x25f0
[ 70.380505] do_syscall_64+0x7e/0x170
[ 70.380511] entry_SYSCALL_64_after_hwframe+0x76/0x7e

[ 70.380541] Freed by task 3445:
[ 70.380548] kasan_save_stack+0x39/0x70
[ 70.380553] kasan_save_track+0x14/0x40
[ 70.380558] kasan_save_free_info+0x3b/0x60
[ 70.380564] poison_slab_object+0x111/0x180
[ 70.380569] __kasan_slab_free+0x33/0x60
[ 70.380574] kfree+0xe4/0x390
[ 70.380579] __sk_destruct+0x44f/0x630
[ 70.380585] sk_destruct+0xaa/0xd0
[ 70.380591] __sk_free+0xa5/0x300
[ 70.380596] sk_free+0x50/0x80
[ 70.380602] sco_sock_kill+0x12e/0x160
[ 70.380608] sco_sock_release+0x134/0x290
[ 70.380615] __sock_release+0xac/0x270
[ 70.380622] sock_close+0x15/0x30
[ 70.380626] __fput+0x368/0xae0
[ 70.380631] __fput_sync+0x3a/0x50
[ 70.380636] __x64_sys_close+0x7d/0xe0
[ 70.380643] x64_sys_call+0x1a13/0x25f0
[ 70.380648] do_syscall_64+0x7e/0x170
[ 70.380653] entry_SYSCALL_64_after_hwframe+0x76/0x7e

[ 70.380663] The buggy address belongs to the object at ffff888114fa0000
which belongs to the cache kmalloc-rnd-03-1k of size 1024
[ 70.380671] The buggy address is located 128 bytes inside of freed
1024-byte region [ffff888114fa0000, ffff888114fa0400)

[ 70.380682] The buggy address belongs to the physical page:
[ 70.380687] page: refcount:1 mapcount:0 mapping:0000000000000000
index:0xffff888114fa1800 pfn:0x114fa0
[ 70.380693] head: order:3 mapcount:0 entire_mapcount:0 nr_pages_mapped:0
pincount:0
[ 70.380698] flags: 0x17ffffc0000040(head|node=0|zone=2|lastcpupid=0x1fffff)
[ 70.380705] page_type: 0xfdffffff(slab)
[ 70.380712] raw: 0017ffffc0000040 ffff88810004e000 dead000000000122
0000000000000000
[ 70.380718] raw: ffff888114fa1800 000000008010000c 00000001fdffffff
0000000000000000
[ 70.380723] head: 0017ffffc0000040 ffff88810004e000 dead000000000122
0000000000000000
[ 70.380728] head: ffff888114fa1800 000000008010000c 00000001fdffffff
0000000000000000
[ 70.380732] head: 0017ffffc0000003 ffffea000453e801 ffffffffffffffff
0000000000000000
[ 70.380737] head: 0000000000000008 0000000000000000 00000000ffffffff
0000000000000000
[ 70.380740] page dumped because: kasan: bad access detected

[ 70.380747] Memory state around the buggy address:
[ 70.380752] ffff888114f9ff80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
fc
[ 70.380757] ffff888114fa0000: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb
fb
[ 70.380762] &gt;ffff888114fa0080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb
fb fb
[ 70.380766] ^
[ 70.380771] ffff888114fa0100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
fb
[ 70.380775] ffff888114fa0180: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
fb
[ 70.380780]
==================================================================
[ 70.380912] Disabling lock debugging due to kernel taint
[ 70.380919] ------------[ cut here ]------------
[ 70.380922] refcount_t: addition on 0; use-after-free.
[ 70.381012] WARNING: CPU: 4 PID: 1177 at lib/refcount.c:25
refcount_warn_saturate+0x171/0x1a0
[ 70.381028] Modules linked in: isofs snd_seq_dummy snd_hrtimer
intel_rapl_msr intel_rapl_common intel_uncore_frequency_common
intel_pmc_core qrtr intel_vsec pmt_telemetry pmt_class snd_ens1371
crct10dif_pclmul snd_ac97_codec polyval_clmulni polyval_generic
ghash_clmulni_intel gameport sha256_ssse3 sha1_ssse3 vmw_balloon
aesni_intel ac97_bus crypto_simd uvcvideo cryptd rapl snd_pcm
videobuf2_vmalloc uvc videobuf2_memops videobuf2_v4l2 videodev snd_seq_midi
videobuf2_common btusb snd_seq_midi_event mc btmtk
snd_rawmidi snd_seq snd_seq_device snd_timer snd i2c_piix4 i2c_smbus
soundcore input_leds joydev serio_raw mac_hid vsock_loopback
vmw_vsock_virtio_transport_common vmw_vsock_vmci_transport vsock vmw_vmci
binfmt_misc sch_fq_codel ramoops reed_solomon vmwgfx
drm_ttm_helper ttm msr parport_pc ppdev lp parport efi_pstore nfnetlink
dmi_sysfs ip_tables x_tables autofs4 hid_generic mptspi
crc32_pclmul mptscsih usbhid psmouse mptbase ahci e1000 libahci pata_acpi
scsi_transport_spi floppy
[ 70.381275] CPU: 4 UID: 0 PID: 1177 Comm: kworker/u521:2 Tainted: G B
6.11.5 #1
[ 70.381286] Tainted: [B]=BAD_PAGE
[ 70.381289] Hardware name: VMware, Inc. VMware Virtual Platform/440BX
Desktop Reference Platform, BIOS 6.00 11/12/2020
[ 70.381294] Workqueue: hci0 hci_rx_work
[ 70.381303] RIP: 0010:refcount_warn_saturate+0x171/0x1a0
[ 70.381310] Code: 1d 51 48 e6 03 80 fb 01 0f 87 4a 29 e7 01 83 e3 01 0f 85
4f ff ff ff 48 c7 c7 80 8b aa 84 c6 05 31 48 e6 03 01 e8 7f 34
bb fe &lt;0f&gt; 0b e9 35 ff ff ff 48 89 df e8 40 36 58 ff e9 bc fe ff ff 48 c7
[ 70.381316] RSP: 0018:ffff888104f8f918 EFLAGS: 00010246
[ 70.381323] RAX: 0000000000000000 RBX: 0000000000000000 RCX:
0000000000000000
[ 70.381327] RDX: 0000000000000000 RSI: 0000000000000000 RDI:
0000000000000000
[ 70.381331] RBP: ffff888104f8f928 R08: 0000000000000000 R09:
0000000000000000
[ 70.381335] R10: 0000000000000000 R11: 0000000000000000 R12:
0000000000000002
[ 70.381339] R13: ffff88810b440000 R14: ffff88810b440d00 R15:
ffff88810447c408
[ 70.381344] FS: 0000000000000000(0000) GS:ffff8881f3400000(0000)
knlGS:0000000000000000
[ 70.381349] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[ 70.381354] CR2: 000077a4df9333b4 CR3: 000000011c5da004 CR4:
00000000003706f0
[ 70.381359] DR0: 0000000000000000 DR1: 0000000000000000 DR2:
0000000000000000
[ 70.381362] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7:
0000000000000400
[ 70.381367] Call Trace:
[ 70.381370] &lt;TASK&gt;
[ 70.381375] ? show_regs+0x6c/0x80
[ 70.381403] ? __warn+0xcc/0x270
[ 70.381427] ? __pfx_vprintk_emit+0x10/0x10
[ 70.381435] ? refcount_warn_saturate+0x171/0x1a0
[ 70.381441] ? report_bug+0x288/0x2f0
[ 70.381449] ? handle_bug+0x9f/0xd0
[ 70.381456] ? exc_invalid_op+0x18/0x50
[ 70.381463] ? asm_exc_invalid_op+0x1b/0x20
[ 70.381474] ? refcount_warn_saturate+0x171/0x1a0
[ 70.381480] ? refcount_warn_saturate+0x171/0x1a0
[ 70.381486] sco_conn_del+0x1ef/0x220
[ 70.381495] sco_connect_cfm+0x21c/0xb40
[ 70.381503] ? __kasan_check_write+0x14/0x30
[ 70.381512] ? __pfx_sco_connect_cfm+0x10/0x10
[ 70.381519] ? __pfx_mutex_lock+0x10/0x10
[ 70.381528] hci_sco_setup+0x3a1/0x580
[ 70.381535] ? __pfx_hci_sco_setup+0x10/0x10
[ 70.381541] ? __pfx_mutex_lock+0x10/0x10
[ 70.381623] hci_conn_complete_evt+0x9b3/0x1620
[ 70.381636] ? __pfx_hci_conn_complete_evt+0x10/0x10
[ 70.381643] ? __kasan_check_write+0x14/0x30
[ 70.381651] ? mutex_unlock+0x80/0xe0
[ 70.381657] ? __pfx_mutex_unlock+0x10/0x10
[ 70.381665] hci_event_packet+0x820/0x1090
[ 70.381671] ? __pfx_hci_conn_complete_evt+0x10/0x10
[ 70.381679] ? __pfx_hci_event_packet+0x10/0x10
[ 70.381686] ? __pfx__raw_spin_lock_irqsave+0x10/0x10
[ 70.381693] ? __pfx_hci_cmd_sync_complete+0x10/0x10
[ 70.381700] ? __kasan_check_read+0x11/0x20
[ 70.381708] hci_rx_work+0x317/0xdd0
[ 70.381714] ? __pfx___schedule+0x10/0x10
[ 70.381720] ? pwq_dec_nr_in_flight+0x220/0xb70
[ 70.381727] process_one_work+0x626/0xf80
[ 70.381733] ? __kasan_check_write+0x14/0x30
[ 70.381743] worker_thread+0x87a/0x1550
[ 70.381749] ? __pfx__raw_spin_lock_irqsave+0x10/0x10
[ 70.381758] ? __pfx_worker_thread+0x10/0x10
[ 70.381764] kthread+0x2b3/0x390
[ 70.381770] ? __pfx_kthread+0x10/0x10
[ 70.381777] ret_from_fork+0x44/0x90
[ 70.381783] ? __pfx_kthread+0x10/0x10
[ 70.381789] ret_from_fork_asm+0x1a/0x30
[ 70.381799] &lt;/TASK&gt;
[ 70.381803] ---[ end trace 0000000000000000 ]---
[ 70.381811] ------------[ cut here ]------------
[ 70.381814] refcount_t: underflow; use-after-free.
[ 70.381868] WARNING: CPU: 4 PID: 1177 at lib/refcount.c:28
refcount_warn_saturate+0x13e/0x1a0
[ 70.381880] Modules linked in: isofs snd_seq_dummy snd_hrtimer
intel_rapl_msr intel_rapl_common intel_uncore_frequency_common
intel_pmc_core qrtr intel_vsec pmt_telemetry pmt_class snd_ens1371
crct10dif_pclmul snd_ac97_codec polyval_clmulni polyval_generic
ghash_clmulni_intel gameport sha256_ssse3 sha1_ssse3 vmw_balloon
aesni_intel ac97_bus crypto_simd uvcvideo cryptd rapl snd_pcm
videobuf2_vmalloc uvc videobuf2_memops videobuf2_v4l2 videodev snd_seq_midi
videobuf2_common btusb snd_seq_midi_event mc btmtk
snd_rawmidi snd_seq snd_seq_device snd_timer snd i2c_piix4 i2c_smbus
soundcore input_leds joydev serio_raw mac_hid vsock_loopback
vmw_vsock_virtio_transport_common vmw_vsock_vmci_transport vsock vmw_vmci
binfmt_misc sch_fq_codel ramoops reed_solomon vmwgfx
drm_ttm_helper ttm msr parport_pc ppdev lp parport efi_pstore nfnetlink
dmi_sysfs ip_tables x_tables autofs4 hid_generic mptspi
crc32_pclmul mptscsih usbhid psmouse mptbase ahci e1000 libahci pata_acpi
scsi_transport_spi floppy
[ 70.382063] CPU: 4 UID: 0 PID: 1177 Comm: kworker/u521:2 Tainted: G B W
6.11.5 #1
[ 70.382073] Tainted: [B]=BAD_PAGE, [W]=WARN
[ 70.382076] Hardware name: VMware, Inc. VMware Virtual Platform/440BX
Desktop Reference Platform, BIOS 6.00 11/12/2020
[ 70.382081] Workqueue: hci0 hci_rx_work
[ 70.382089] RIP: 0010:refcount_warn_saturate+0x13e/0x1a0
[ 70.382095] Code: eb 97 0f b6 1d 7f 48 e6 03 80 fb 01 0f 87 8d 29 e7 01 83
e3 01 75 82 48 c7 c7 e0 8b aa 84 c6 05 63 48 e6 03 01 e8 b2 34
bb fe &lt;0f&gt; 0b e9 68 ff ff ff 0f b6 1d 51 48 e6 03 80 fb 01 0f 87 4a 29 e7
[ 70.382101] RSP: 0018:ffff888104f8f918 EFLAGS: 00010246
[ 70.382107] RAX: 0000000000000000 RBX: 0000000000000000 RCX:
0000000000000000
[ 70.382111] RDX: 0000000000000000 RSI: 0000000000000000 RDI:
0000000000000000
[ 70.382115] RBP: ffff888104f8f928 R08: 0000000000000000 R09:
0000000000000000
[ 70.382119] R10: 0000000000000000 R11: 0000000000000000 R12:
0000000000000003
[ 70.382123] R13: ffff88810b440000 R14: ffff88810b440d00 R15:
ffff88810447c408
[ 70.382128] FS: 0000000000000000(0000) GS:ffff8881f3400000(0000)
knlGS:0000000000000000
[ 70.382133] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[ 70.382138] CR2: 000077a4df9333b4 CR3: 000000011c5da004 CR4:
00000000003706f0
[ 70.382142] DR0: 0000000000000000 DR1: 0000000000000000 DR2:
0000000000000000
[ 70.382146] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7:
0000000000000400
[ 70.382150] Call Trace:
[ 70.382154] &lt;TASK&gt;
[ 70.382158] ? show_regs+0x6c/0x80
[ 70.382166] ? __warn+0xcc/0x270
[ 70.382172] ? __pfx_vprintk_emit+0x10/0x10
[ 70.382179] ? refcount_warn_saturate+0x13e/0x1a0
[ 70.382185] ? report_bug+0x288/0x2f0
[ 70.382192] ? handle_bug+0x9f/0xd0
[ 70.382199] ? exc_invalid_op+0x18/0x50
[ 70.382206] ? asm_exc_invalid_op+0x1b/0x20
[ 70.382216] ? refcount_warn_saturate+0x13e/0x1a0
[ 70.382222] ? refcount_warn_saturate+0x13e/0x1a0
[ 70.382228] sco_conn_del+0x1dc/0x220
[ 70.382237] sco_connect_cfm+0x21c/0xb40
[ 70.382245] ? __kasan_check_write+0x14/0x30
[ 70.382253] ? __pfx_sco_connect_cfm+0x10/0x10
[ 70.382260] ? __pfx_mutex_lock+0x10/0x10
[ 70.382268] hci_sco_setup+0x3a1/0x580
[ 70.382275] ? __pfx_hci_sco_setup+0x10/0x10
[ 70.382281] ? __pfx_mutex_lock+0x10/0x10
[ 70.382289] hci_conn_complete_evt+0x9b3/0x1620
[ 70.382299] ? __pfx_hci_conn_complete_evt+0x10/0x10
[ 70.382306] ? __kasan_check_write+0x14/0x30
[ 70.382313] ? mutex_unlock+0x80/0xe0
[ 70.382320] ? __pfx_mutex_unlock+0x10/0x10
[ 70.382327] hci_event_packet+0x820/0x1090
[ 70.382333] ? __pfx_hci_conn_complete_evt+0x10/0x10
[ 70.382341] ? __pfx_hci_event_packet+0x10/0x10
[ 70.382348] ? __pfx__raw_spin_lock_irqsave+0x10/0x10
[ 70.382355] ? __pfx_hci_cmd_sync_complete+0x10/0x10
[ 70.382362] ? __kasan_check_read+0x11/0x20
[ 70.382370] hci_rx_work+0x317/0xdd0
[ 70.382376] ? __pfx___schedule+0x10/0x10
[ 70.382382] ? pwq_dec_nr_in_flight+0x220/0xb70
[ 70.382389] process_one_work+0x626/0xf80
[ 70.382395] ? __kasan_check_write+0x14/0x30
[ 70.382405] worker_thread+0x87a/0x1550
[ 70.382411] ? __pfx__raw_spin_lock_irqsave+0x10/0x10
[ 70.382419] ? __pfx_worker_thread+0x10/0x10
[ 70.382425] kthread+0x2b3/0x390
[ 70.382431] ? __pfx_kthread+0x10/0x10
[ 70.382437] ret_from_fork+0x44/0x90
[ 70.382444] ? __pfx_kthread+0x10/0x10
[ 70.382450] ret_from_fork_asm+0x1a/0x30
[ 70.382460] &lt;/TASK&gt;
[ 70.382463] ---[ end trace 0000000000000000 ]---

=*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*=Environment
=*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*=

linux-6.11.5
ubuntu 24.04

=*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*=

It is easy to hijack control flow by modifying PoC, which leads to local
privilege escalation !

On Sat, Nov 30, 2024 at 10:41 AM Luiz Augusto von Dentz &lt;
luiz.dentz&#64;...il.com&gt; wrote:

&gt; Hi,
&gt;
&gt; On Thu, Nov 28, 2024 at 11:41 PM Solar Designer &lt;solar&#64;...nwall.com&gt;
&gt; wrote:
&gt; &gt;
&gt; &gt; Hi,
&gt; &gt;
&gt; &gt; Upon expiration of the maximum of 14 days embargo, I am forwarding a
&gt; &gt; vulnerability report (and a couple of replies) that was erroneously
&gt; &gt; sent to the linux-distros list and then was not fully handled.  We
&gt; &gt; require information actionable for the distros within the maximum of 14
&gt; &gt; days, which generally means that the upstream should be contacted first
&gt; &gt; and should have a fix ready for the distros to include (or at least
&gt; &gt; should expect that by the proposed public disclosure date).  The
&gt; &gt; specific wording we use is:
&gt; &gt;
&gt; &gt; "For Linux kernel issues, you must notify the kernel security team first,
&gt; &gt; wait for the fix, and only then notify linux-distros or oss-security
&gt; &gt; (depending on whether the information is still private or already
&gt; &gt; public, as well as on issue severity)."
&gt; &gt;
&gt; &gt; While we assume good faith even if the report is misaddressed (which we
&gt; &gt; understand does happen as instructions are naturally more complicated
&gt; &gt; than we'd have liked), unfortunately this time the reporter also did not
&gt; &gt; reply to any of linux-distros' members questions, most notably "have you
&gt; &gt; contacted either security&#64;...nel.org or the bluetooth maintainers about
&gt; &gt; this issue?"  Ideally, someone from linux-distros should have taken over
&gt; &gt; and handled this fully - including asking s@k.o and the maintainers
&gt; &gt; directly - but unfortunately this also did not happen this time.
&gt; &gt;
&gt; &gt; As you can see from the messages below, the issue may be the same as
&gt; &gt; CVE-2024-27398 fixed by commit 483bc08181827fc475643272ffb69c533007e546
&gt; &gt; ("Bluetooth: Fix use-after-free bugs caused by sco_sock_timeout").  The
&gt; &gt; report claims that the "race condition bug has not been solved yet" by
&gt; &gt; this commit, but then the only testing appears to have been on a kernel
&gt; &gt; pre-dating this commit.
&gt; &gt;
&gt; &gt; I'm also attaching here some of the files from the reporter's referenced
&gt; &gt; GitHub repo.  The main claimed PoC is a 9 MB file Linux-6.8.0-PoC.webm,
&gt; &gt; not attached here, but I do attach the proposed patch, test.c "test case
&gt; &gt; after patch" (as the commit message said), and most-relevant files from
&gt; &gt; inside PoC.zip.  I preserved the filenames, but edited the Makefile and
&gt; &gt; #include directives to avoid dependency on otherwise-unused files.  Both
&gt; &gt; programs (test.c and poc.c) build for me on Rocky Linux 9.5 with
&gt; &gt; bluez-libs-devel and fuse-devel installed.  I did not try running them.
&gt; &gt;
&gt; &gt; On a related note, my searching Linux kernel mailing lists for related
&gt; &gt; keywords finds other issues also in Bluetooth and even specifically in
&gt; &gt; SCO triggered by syzbot and with recent proposed patches:
&gt; &gt;
&gt; &gt; 2024-11-25 13:16 [syzbot] [bluetooth?] KASAN: slab-use-after-free Read
&gt; in sco_sock_connect syzbot
&gt; &gt; 2024-11-25 23:58 ` [PATCH] Bluetooth: SCO: remove the redundant
&gt; sco_conn_put Edward Adam Davis
&gt;
&gt; Well, I guess we are still expecting this to be handled via
&gt; security&#64;...nel.org? And while there are some changes to SCO related
&gt; to sco_conn lifetime, and the patches mentioned above do not affect
&gt; the sco_connect to be invoked while helding sock_hold (proposed fix),
&gt; that said first we probably need to confirm the problem is still
&gt; reproducible upstream, if that is still reproducible I suspect we can
&gt; apply a similar fix that was done for ISO sockets since it is quite
&gt; similar to SCO sockets:
&gt;
&gt; d40ae85ee62e ("Bluetooth: ISO: fix iso_conn related locking and
&gt; validity issues")
&gt;
&gt; &gt; Alexander
&gt; &gt;
&gt; &gt; From: tianshu qiu &lt;jimuchutianshu97&#64;...il.com&gt;
&gt; &gt; To: linux-distros
&gt; &gt; Subject: [vs-plain] Race condition vulnerability that can lead to UAF in
&gt; net/bluetooth/sco.c:sco_sock_connect
&gt; &gt; Date: Thu, 14 Nov 2024 18:35:24 +0800
&gt; &gt;
&gt; &gt; On Thu, Nov 14, 2024 at 06:35:24PM +0800, tianshu qiu wrote:
&gt; &gt; &gt; The bug was introduced on Apr 11, 2023:
&gt; &gt; &gt;
&gt; <a href="https://github.com/torvalds/linux/commit/9a8ec9e8ebb5a7c0cfbce2d6b4a6b67b2b78e8f3" rel="nofollow">https://github.com/torvalds/linux/commit/9a8ec9e8ebb5a7c0cfbce2d6b4a6b67b2b78e8f3</a>
&gt; &gt; &gt;
&gt; &gt; &gt; =*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*= BUG DETAILS
&gt; &gt; &gt; =*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*=
&gt; &gt; &gt;
&gt; &gt; &gt; I found the bug when looking for unlocked access to ???struct sock???
&gt; &gt; &gt; objects in the ???net??? directory. I think that "struct sock" is
&gt; shared
&gt; &gt; &gt; among multiple threads.
&gt; &gt; &gt; Access to struct sock object, especially reading and writing sk
&gt; &gt; &gt; -&gt;sk_state, should call lock_sock(sk) in advance to lock, and call
&gt; &gt; &gt; release_sock(sk) to
&gt; &gt; &gt; unlock after the last access to ???struct sock??? object, so as to
&gt; prevent
&gt; &gt; &gt; race between threads.
&gt; &gt; &gt;
&gt; &gt; &gt;
&gt; =*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*=
&gt; &gt; &gt;
&gt; &gt; &gt; static int sco_sock_connect(struct socket *sock, struct sockaddr
&gt; &gt; &gt; *addr, int alen, int flags)
&gt; &gt; &gt; {
&gt; &gt; &gt;         struct sockaddr_sco *sa = (struct sockaddr_sco *) addr;
&gt; &gt; &gt;         struct sock *sk = sock-&gt;sk;
&gt; &gt; &gt;         int err;
&gt; &gt; &gt;
&gt; &gt; &gt;         BT_DBG("sk %p", sk);
&gt; &gt; &gt;
&gt; &gt; &gt;         if (alen &lt; sizeof(struct sockaddr_sco) ||
&gt; &gt; &gt;         addr-&gt;sa_family != AF_BLUETOOTH)
&gt; &gt; &gt;         return -EINVAL;
&gt; &gt; &gt;
&gt; &gt; &gt;         if (sk-&gt;sk_state != BT_OPEN &amp;&amp; sk-&gt;sk_state != BT_BOUND)
&gt; &gt; &gt;                 return -EBADFD;
&gt; &gt; &gt;
&gt; &gt; &gt;         if (sk-&gt;sk_type != SOCK_SEQPACKET)
&gt; &gt; &gt;                 err = -EINVAL;
&gt; &gt; &gt;
&gt; &gt; &gt;         lock_sock(sk);
&gt; &gt; &gt;               // first lock-release pair
&gt; &gt; &gt;         /* Set destination address and psm */
&gt; &gt; &gt;         bacpy(&amp;sco_pi(sk)-&gt;dst, &amp;sa-&gt;sco_bdaddr);
&gt; &gt; &gt;         release_sock(sk);
&gt; &gt; &gt;            // first lock-release pair
&gt; &gt; &gt;
&gt; &gt; &gt;         err = sco_connect(sk);
&gt; &gt; &gt;         if (err)
&gt; &gt; &gt;                 return err;
&gt; &gt; &gt;
&gt; &gt; &gt;         lock_sock(sk);
&gt; &gt; &gt;                  // second lock-release pair
&gt; &gt; &gt;
&gt; &gt; &gt;         err = bt_sock_wait_state(sk, BT_CONNECTED,
&gt; &gt; &gt;         sock_sndtimeo(sk, flags &amp; O_NONBLOCK));
&gt; &gt; &gt;
&gt; &gt; &gt;         release_sock(sk);
&gt; &gt; &gt;              // second lock-release pair
&gt; &gt; &gt;         return err;
&gt; &gt; &gt; }
&gt; &gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt; static int sco_connect(struct sock *sk)
&gt; &gt; &gt; {
&gt; &gt; &gt;         struct sco_conn *conn;
&gt; &gt; &gt;         struct hci_conn *hcon;
&gt; &gt; &gt;         struct hci_dev  *hdev;
&gt; &gt; &gt;
&gt; &gt; &gt;         ??????
&gt; &gt; &gt;
&gt; &gt; &gt;         hdev = hci_get_route(&amp;sco_pi(sk)-&gt;dst, &amp;sco_pi(sk)-&gt;src,
&gt; BDADDR_BREDR);
&gt; &gt; &gt;         if (!hdev)
&gt; &gt; &gt;                 return -EHOSTUNREACH;
&gt; &gt; &gt;
&gt; &gt; &gt;         hci_dev_lock(hdev);
&gt; &gt; &gt;
&gt; &gt; &gt;         ??????
&gt; &gt; &gt;
&gt; &gt; &gt;         hcon = hci_connect_sco(hdev, type, &amp;sco_pi(sk)-&gt;dst,
&gt; &gt; &gt;         sco_pi(sk)-&gt;setting, &amp;sco_pi(sk)-&gt;codec);
&gt; &gt; &gt;
&gt; &gt; &gt;         ??????
&gt; &gt; &gt;
&gt; &gt; &gt;         lock_sock(sk);
&gt; &gt; &gt;                  // third lock-release pair
&gt; &gt; &gt;
&gt; &gt; &gt;         err = sco_chan_add(conn, sk, NULL);
&gt; &gt; &gt;         if (err) {
&gt; &gt; &gt;                 release_sock(sk);
&gt; &gt; &gt;                 goto unlock;
&gt; &gt; &gt;         }
&gt; &gt; &gt;
&gt; &gt; &gt;         /* Update source addr of the socket */
&gt; &gt; &gt;         bacpy(&amp;sco_pi(sk)-&gt;src, &amp;hcon-&gt;src);
&gt; &gt; &gt;
&gt; &gt; &gt;         if (hcon-&gt;state == BT_CONNECTED) {
&gt; &gt; &gt;                 sco_sock_clear_timer(sk);
&gt; &gt; &gt;                 sk-&gt;sk_state = BT_CONNECTED;
&gt; &gt; &gt;         } else {
&gt; &gt; &gt;                 sk-&gt;sk_state = BT_CONNECT;
&gt; &gt; &gt;                 sco_sock_set_timer(sk, sk-&gt;sk_sndtimeo);
&gt; &gt; &gt;         }
&gt; &gt; &gt;
&gt; &gt; &gt;         release_sock(sk);
&gt; &gt; &gt;              // third lock-release pair
&gt; &gt; &gt;
&gt; &gt; &gt;         ......
&gt; &gt; &gt;
&gt; &gt; &gt; }
&gt; &gt; &gt;
&gt; &gt; &gt;
&gt; =*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*=
&gt; &gt; &gt;
&gt; &gt; &gt; To avoid possible circular locking, the commit that introduced the bug
&gt; &gt; &gt; splits the "lock-release" pair which protects the whole
&gt; &gt; &gt; sco_sock_connect to three parts.
&gt; &gt; &gt;
&gt; &gt; &gt; The "if" branch for determining sk -&gt;sk_state in sco_sock_connect is
&gt; &gt; &gt; exposed outside the lock_sock(sk) protection, which can lead to race
&gt; &gt; &gt; condition if two threads
&gt; &gt; &gt; execute ???connect??? system calls simultaneously.
&gt; &gt; &gt; This will lead to dangling ???struct sco_conn??? object in the function
&gt; &gt; &gt; sco_chan_add, the calling procedure is:
&gt; &gt; &gt; sco_sock_connect -&gt; sco_connect -&gt; sco_chan_add -&gt; __sco_chan_add.
&gt; &gt; &gt;
&gt; &gt; &gt; The timer associated to this dangling ???struct sco_conn??? object is
&gt; &gt; &gt; still work, even if the "struct sock" object was freed by the system
&gt; &gt; &gt; call "close", which will cause
&gt; &gt; &gt; UAF when timeout is reached.
&gt; &gt; &gt;
&gt; &gt; &gt; Although the following two commits attempt to solve the UAF issue in
&gt; &gt; &gt; sco_sock_timeout, race condition bug has not been solved yet:
&gt; &gt; &gt;
&gt; &gt; &gt;
&gt; <a href="https://github.com/torvalds/linux/commit/1bf4470a3939c678fb822073e9ea77a0560bc6bb" rel="nofollow">https://github.com/torvalds/linux/commit/1bf4470a3939c678fb822073e9ea77a0560bc6bb</a>
&gt; &gt; &gt;
&gt; <a href="https://github.com/torvalds/linux/commit/483bc08181827fc475643272ffb69c533007e546" rel="nofollow">https://github.com/torvalds/linux/commit/483bc08181827fc475643272ffb69c533007e546</a>
&gt; &gt; &gt;
&gt; &gt; &gt; This is a serious vulnerability that can cause local privilege
&gt; &gt; &gt; escalation. I hope this vulnerability can be patched and assigned a
&gt; &gt; &gt; CVE number.
&gt; &gt; &gt;
&gt; &gt; &gt; =*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*=
&gt; &gt; &gt; DMESG LOG
&gt; =*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*=
&gt; &gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt; [ 1084.906919] BUG: KASAN: slab-use-after-free in
&gt; sco_conn_del+0xa6/0x220
&gt; &gt; &gt; [ 1084.906940] Write of size 4 at addr ffff888122c06880 by task
&gt; &gt; &gt; kworker/u265:0/162
&gt; &gt; &gt;
&gt; &gt; &gt; [ 1084.906955] CPU: 0 PID: 162 Comm: kworker/u265:0 Not tainted 6.8.0
&gt; #4
&gt; &gt; &gt; [ 1084.906966] Hardware name: VMware, Inc. VMware Virtual
&gt; &gt; &gt; Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020
&gt; &gt; &gt; [ 1084.906974] Workqueue: hci0 hci_rx_work
&gt; &gt; &gt; [ 1084.906991] Call Trace:
&gt; &gt; &gt; [ 1084.906996]  &lt;TASK&gt;
&gt; &gt; &gt; [ 1084.907004]  dump_stack_lvl+0x48/0x70
&gt; &gt; &gt; [ 1084.907018]  print_report+0xd2/0x670
&gt; &gt; &gt; [ 1084.907028]  ? __pfx__raw_spin_lock_irqsave+0x10/0x10
&gt; &gt; &gt; [ 1084.907039]  ? kasan_complete_mode_report_info+0x8a/0x230
&gt; &gt; &gt; [ 1084.907052]  kasan_report+0xd7/0x120
&gt; &gt; &gt; [ 1084.907060]  ? sco_conn_del+0xa6/0x220
&gt; &gt; &gt; [ 1084.907070]  ? sco_conn_del+0xa6/0x220
&gt; &gt; &gt; [ 1084.907082]  kasan_check_range+0x11c/0x200
&gt; &gt; &gt; [ 1084.907092]  __kasan_check_write+0x14/0x30
&gt; &gt; &gt; [ 1084.907103]  sco_conn_del+0xa6/0x220
&gt; &gt; &gt; [ 1084.907114]  sco_connect_cfm+0x1d4/0xac0
&gt; &gt; &gt; [ 1084.907125]  ? __pfx_sco_connect_cfm+0x10/0x10
&gt; &gt; &gt; [ 1084.907135]  ? __pfx_mutex_lock+0x10/0x10
&gt; &gt; &gt; [ 1084.907147]  hci_sco_setup+0x397/0x570
&gt; &gt; &gt; [ 1084.907157]  ? __pfx_hci_sco_setup+0x10/0x10
&gt; &gt; &gt; [ 1084.907165]  ? __pfx_mutex_lock+0x10/0x10
&gt; &gt; &gt; [ 1084.907176]  hci_conn_complete_evt+0x957/0x1150
&gt; &gt; &gt; [ 1084.907186]  ? kasan_save_track+0x14/0x40
&gt; &gt; &gt; [ 1084.907196]  ? __pfx_hci_conn_complete_evt+0x10/0x10
&gt; &gt; &gt; [ 1084.907205]  ? __kasan_check_write+0x14/0x30
&gt; &gt; &gt; [ 1084.907216]  ? mutex_unlock+0x81/0xe0
&gt; &gt; &gt; [ 1084.907224]  ? __pfx_mutex_unlock+0x10/0x10
&gt; &gt; &gt; [ 1084.907235]  hci_event_packet+0x818/0x1080
&gt; &gt; &gt; [ 1084.907246]  ? __pfx_hci_conn_complete_evt+0x10/0x10
&gt; &gt; &gt; [ 1084.907256]  ? __pfx_hci_event_packet+0x10/0x10
&gt; &gt; &gt; [ 1084.907266]  ? __pfx__raw_spin_lock_irqsave+0x10/0x10
&gt; &gt; &gt; [ 1084.907275]  ? __pfx_hci_cmd_sync_complete+0x10/0x10
&gt; &gt; &gt; [ 1084.907286]  ? __kasan_check_read+0x11/0x20
&gt; &gt; &gt; [ 1084.907297]  hci_rx_work+0x312/0xd60
&gt; &gt; &gt; [ 1084.907308]  ? __pfx__raw_spin_lock_irq+0x10/0x10
&gt; &gt; &gt; [ 1084.907318]  process_one_work+0x577/0xd30
&gt; &gt; &gt; [ 1084.907371]  ? _raw_spin_lock_irq+0x8b/0x100
&gt; &gt; &gt; [ 1084.907384]  worker_thread+0x879/0x15a0
&gt; &gt; &gt; [ 1084.907392]  ? __pfx__raw_spin_lock_irqsave+0x10/0x10
&gt; &gt; &gt; [ 1084.907403]  ? __pfx_worker_thread+0x10/0x10
&gt; &gt; &gt; [ 1084.907411]  kthread+0x2b7/0x390
&gt; &gt; &gt; [ 1084.907421]  ? __pfx_kthread+0x10/0x10
&gt; &gt; &gt; [ 1084.907431]  ret_from_fork+0x44/0x90
&gt; &gt; &gt; [ 1084.907442]  ? __pfx_kthread+0x10/0x10
&gt; &gt; &gt; [ 1084.907451]  ret_from_fork_asm+0x1b/0x30
&gt; &gt; &gt; [ 1084.907497]  &lt;/TASK&gt;
&gt; &gt; &gt;
&gt; &gt; &gt; [ 1084.907506] Allocated by task 3974:
&gt; &gt; &gt; [ 1084.907513]  kasan_save_stack+0x39/0x70
&gt; &gt; &gt; [ 1084.907522]  kasan_save_track+0x14/0x40
&gt; &gt; &gt; [ 1084.907527]  kasan_save_alloc_info+0x37/0x60
&gt; &gt; &gt; [ 1084.907537]  __kasan_kmalloc+0xc3/0xd0
&gt; &gt; &gt; [ 1084.907543]  __kmalloc+0x21f/0x530
&gt; &gt; &gt; [ 1084.907551]  sk_prot_alloc+0x16d/0x220
&gt; &gt; &gt; [ 1084.907560]  sk_alloc+0x35/0x750
&gt; &gt; &gt; [ 1084.907568]  bt_sock_alloc+0x2f/0x360
&gt; &gt; &gt; [ 1084.907576]  sco_sock_create+0xc6/0x390
&gt; &gt; &gt; [ 1084.907617]  bt_sock_create+0x152/0x320
&gt; &gt; &gt; [ 1084.907629]  __sock_create+0x212/0x500
&gt; &gt; &gt; [ 1084.907636]  __sys_socket+0x139/0x210
&gt; &gt; &gt; [ 1084.907670]  __x64_sys_socket+0x72/0xc0
&gt; &gt; &gt; [ 1084.907677]  do_syscall_64+0x82/0x180
&gt; &gt; &gt; [ 1084.907684]  entry_SYSCALL_64_after_hwframe+0x6e/0x76
&gt; &gt; &gt;
&gt; &gt; &gt; [ 1084.907750] Freed by task 3974:
&gt; &gt; &gt; [ 1084.907755]  kasan_save_stack+0x39/0x70
&gt; &gt; &gt; [ 1084.907760]  kasan_save_track+0x14/0x40
&gt; &gt; &gt; [ 1084.907764]  kasan_save_free_info+0x3b/0x60
&gt; &gt; &gt; [ 1084.907769]  poison_slab_object+0x10a/0x180
&gt; &gt; &gt; [ 1084.907773]  __kasan_slab_free+0x33/0x60
&gt; &gt; &gt; [ 1084.907777]  kfree+0xda/0x2f0
&gt; &gt; &gt; [ 1084.907782]  __sk_destruct+0x44e/0x640
&gt; &gt; &gt; [ 1084.907787]  sk_destruct+0xaa/0xd0
&gt; &gt; &gt; [ 1084.907792]  __sk_free+0xa5/0x300
&gt; &gt; &gt; [ 1084.907797]  sk_free+0x50/0x80
&gt; &gt; &gt; [ 1084.907802]  sco_sock_kill+0x12e/0x160
&gt; &gt; &gt; [ 1084.907808]  sco_sock_release+0x134/0x290
&gt; &gt; &gt; [ 1084.907813]  __sock_release+0xac/0x270
&gt; &gt; &gt; [ 1084.907817]  sock_close+0x15/0x30
&gt; &gt; &gt; [ 1084.907821]  __fput+0x205/0xa90
&gt; &gt; &gt; [ 1084.907825]  __fput_sync+0x3a/0x50
&gt; &gt; &gt; [ 1084.907829]  __x64_sys_close+0x7e/0xe0
&gt; &gt; &gt; [ 1084.907835]  do_syscall_64+0x82/0x180
&gt; &gt; &gt; [ 1084.907839]  entry_SYSCALL_64_after_hwframe+0x6e/0x76
&gt; &gt; &gt;
&gt; &gt; &gt; [ 1084.907847] The buggy address belongs to the object at
&gt; ffff888122c06800
&gt; &gt; &gt;          which belongs to the cache kmalloc-rnd-04-1k of size 1024
&gt; &gt; &gt; [ 1084.907852] The buggy address is located 128 bytes inside of
&gt; &gt; &gt;          freed 1024-byte region [ffff888122c06800, ffff888122c06c00)
&gt; &gt; &gt;
&gt; &gt; &gt; [ 1084.907861] The buggy address belongs to the physical page:
&gt; &gt; &gt; [ 1084.907865] page:00000000dd0be509 refcount:1 mapcount:0
&gt; &gt; &gt; mapping:0000000000000000 index:0x0 pfn:0x122c00
&gt; &gt; &gt; [ 1084.907871] head:00000000dd0be509 order:3 entire_mapcount:0
&gt; &gt; &gt; nr_pages_mapped:0 pincount:0
&gt; &gt; &gt; [ 1084.907876] flags:
&gt; &gt; &gt; 0x17ffffc0000840(slab|head|node=0|zone=2|lastcpupid=0x1fffff)
&gt; &gt; &gt; [ 1084.907882] page_type: 0xffffffff()
&gt; &gt; &gt; [ 1084.907887] raw: 0017ffffc0000840 ffff88810004f040 dead000000000122
&gt; &gt; &gt; 0000000000000000
&gt; &gt; &gt; [ 1084.907892] raw: 0000000000000000 0000000080100010 00000001ffffffff
&gt; &gt; &gt; 0000000000000000
&gt; &gt; &gt; [ 1084.907895] page dumped because: kasan: bad access detected
&gt; &gt; &gt;
&gt; &gt; &gt; [ 1084.907900] Memory state around the buggy address:
&gt; &gt; &gt; [ 1084.907904]  ffff888122c06780: fc fc fc fc fc fc fc fc fc fc fc fc
&gt; &gt; &gt; fc fc fc fc
&gt; &gt; &gt; [ 1084.907908]  ffff888122c06800: fa fb fb fb fb fb fb fb fb fb fb fb
&gt; &gt; &gt; fb fb fb fb
&gt; &gt; &gt; [ 1084.907913] &gt;ffff888122c06880: fb fb fb fb fb fb fb fb fb fb fb fb
&gt; &gt; &gt; fb fb fb fb
&gt; &gt; &gt; [ 1084.907916]                    ^
&gt; &gt; &gt; [ 1084.907920]  ffff888122c06900: fb fb fb fb fb fb fb fb fb fb fb fb
&gt; &gt; &gt; fb fb fb fb
&gt; &gt; &gt; [ 1084.907923]  ffff888122c06980: fb fb fb fb fb fb fb fb fb fb fb fb
&gt; &gt; &gt; fb fb fb fb
&gt; &gt; &gt; [ 1084.907927]
&gt; ==================================================================
&gt; &gt; &gt; [ 1084.908048] Disabling lock debugging due to kernel taint
&gt; &gt; &gt; [ 1084.908054] ------------[ cut here ]------------
&gt; &gt; &gt; [ 1084.908057] refcount_t: addition on 0; use-after-free.
&gt; &gt; &gt; [ 1084.908141] WARNING: CPU: 0 PID: 162 at lib/refcount.c:25
&gt; &gt; &gt; refcount_warn_saturate+0x171/0x1a0
&gt; &gt; &gt; [ 1084.908174] Modules linked in: isofs snd_seq_dummy snd_hrtimer qrtr
&gt; &gt; &gt; intel_rapl_msr intel_rapl_common intel_uncore_frequency_common
&gt; &gt; &gt; intel_pmc_core intel_vsec pmt_telemetry pmt_class crct10dif_pclmul
&gt; &gt; &gt; polyval_clmulni snd_ens1371 polyval_generic snd_ac97_codec
&gt; &gt; &gt; ghash_clmulni_intel gameport sha256_ssse3 ac97_bus vmw_balloon
&gt; &gt; &gt; sha1_ssse3 snd_pcm aesni_intel uvcvideo crypto_simd snd_seq_midi
&gt; &gt; &gt; cryptd rapl snd_seq_midi_event videobuf2_vmalloc uvc snd_rawmidi
&gt; &gt; &gt; videobuf2_memops videobuf2_v4l2 snd_seq snd_seq_device videodev
&gt; &gt; &gt; snd_timer videobuf2_common snd mc btusb btmtk soundcore i2c_piix4
&gt; &gt; &gt; input_leds joydev mac_hid serio_raw vsock_loopback binfmt_misc
&gt; &gt; &gt; vmw_vsock_virtio_transport_common vmw_vsock_vmci_transport vsock
&gt; &gt; &gt; vmw_vmci sch_fq_codel ramoops reed_solomon vmwgfx drm_ttm_helper ttm
&gt; &gt; &gt; msr parport_pc ppdev lp parport efi_pstore nfnetlink dmi_sysfs
&gt; &gt; &gt; ip_tables x_tables autofs4 hid_generic crc32_pclmul usbhid psmouse
&gt; &gt; &gt; mptspi mptscsih e1000 ahci mptbase libahci scsi_transport_spi
&gt; &gt; &gt; pata_acpi floppy
&gt; &gt; &gt; [ 1084.908607] CPU: 0 PID: 162 Comm: kworker/u265:0 Tainted: G    B
&gt; &gt; &gt;           6.8.0 #4
&gt; &gt; &gt; [ 1084.908614] Hardware name: VMware, Inc. VMware Virtual
&gt; &gt; &gt; Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020
&gt; &gt; &gt; [ 1084.908618] Workqueue: hci0 hci_rx_work
&gt; &gt; &gt; [ 1084.908627] RIP: 0010:refcount_warn_saturate+0x171/0x1a0
&gt; &gt; &gt; [ 1084.908634] Code: 1d 81 1a eb 03 80 fb 01 0f 87 13 6f df 01 83 e3
&gt; &gt; &gt; 01 0f 85 4f ff ff ff 48 c7 c7 40 1c aa 84 c6 05 61 1a eb 03 01 e8 ef
&gt; &gt; &gt; de c3 fe &lt;0f&gt; 0b e9 35 ff ff ff 48 89 df e8 f0 99 59 ff e9 bc fe ff ff
&gt; &gt; &gt; 48 c7
&gt; &gt; &gt; [ 1084.908639] RSP: 0018:ffff888134717940 EFLAGS: 00010246
&gt; &gt; &gt; [ 1084.908644] RAX: 0000000000000000 RBX: 0000000000000000 RCX:
&gt; 0000000000000000
&gt; &gt; &gt; [ 1084.908648] RDX: 0000000000000000 RSI: 0000000000000000 RDI:
&gt; 0000000000000000
&gt; &gt; &gt; [ 1084.908651] RBP: ffff888134717950 R08: 0000000000000000 R09:
&gt; 0000000000000000
&gt; &gt; &gt; [ 1084.908654] R10: 0000000000000000 R11: 0000000000000000 R12:
&gt; 0000000000000002
&gt; &gt; &gt; [ 1084.908657] R13: ffff888104589000 R14: ffff888104589780 R15:
&gt; ffff88810033dc08
&gt; &gt; &gt; [ 1084.908661] FS:  0000000000000000(0000) GS:ffff8881f3200000(0000)
&gt; &gt; &gt; knlGS:0000000000000000
&gt; &gt; &gt; [ 1084.908665] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
&gt; &gt; &gt; [ 1084.908669] CR2: 000062bcbcecc5a0 CR3: 000000011de7a002 CR4:
&gt; 00000000003706f0
&gt; &gt; &gt; [ 1084.908673] Call Trace:
&gt; &gt; &gt; [ 1084.908692]  &lt;TASK&gt;
&gt; &gt; &gt; [ 1084.908695]  ? show_regs+0x6d/0x80
&gt; &gt; &gt; [ 1084.908702]  ? __warn+0xcd/0x270
&gt; &gt; &gt; [ 1084.908706]  ? refcount_warn_saturate+0x171/0x1a0
&gt; &gt; &gt; [ 1084.908710]  ? report_bug+0x288/0x310
&gt; &gt; &gt; [ 1084.908715]  ? vprintk_default+0x1d/0x30
&gt; &gt; &gt; [ 1084.908720]  ? handle_bug+0x9f/0xd0
&gt; &gt; &gt; [ 1084.908724]  ? exc_invalid_op+0x18/0x50
&gt; &gt; &gt; [ 1084.908728]  ? asm_exc_invalid_op+0x1b/0x20
&gt; &gt; &gt; [ 1084.908736]  ? refcount_warn_saturate+0x171/0x1a0
&gt; &gt; &gt; [ 1084.908741]  sco_conn_del+0x1ef/0x220
&gt; &gt; &gt; [ 1084.908746]  sco_connect_cfm+0x1d4/0xac0
&gt; &gt; &gt; [ 1084.908751]  ? __pfx_sco_connect_cfm+0x10/0x10
&gt; &gt; &gt; [ 1084.908756]  ? __pfx_mutex_lock+0x10/0x10
&gt; &gt; &gt; [ 1084.908762]  hci_sco_setup+0x397/0x570
&gt; &gt; &gt; [ 1084.908766]  ? __pfx_hci_sco_setup+0x10/0x10
&gt; &gt; &gt; [ 1084.908769]  ? __pfx_mutex_lock+0x10/0x10
&gt; &gt; &gt; [ 1084.908774]  hci_conn_complete_evt+0x957/0x1150
&gt; &gt; &gt; [ 1084.908779]  ? kasan_save_track+0x14/0x40
&gt; &gt; &gt; [ 1084.908784]  ? __pfx_hci_conn_complete_evt+0x10/0x10
&gt; &gt; &gt; [ 1084.908788]  ? __kasan_check_write+0x14/0x30
&gt; &gt; &gt; [ 1084.908793]  ? mutex_unlock+0x81/0xe0
&gt; &gt; &gt; [ 1084.908797]  ? __pfx_mutex_unlock+0x10/0x10
&gt; &gt; &gt; [ 1084.908802]  hci_event_packet+0x818/0x1080
&gt; &gt; &gt; [ 1084.908807]  ? __pfx_hci_conn_complete_evt+0x10/0x10
&gt; &gt; &gt; [ 1084.908812]  ? __pfx_hci_event_packet+0x10/0x10
&gt; &gt; &gt; [ 1084.908816]  ? __pfx__raw_spin_lock_irqsave+0x10/0x10
&gt; &gt; &gt; [ 1084.908820]  ? __pfx_hci_cmd_sync_complete+0x10/0x10
&gt; &gt; &gt; [ 1084.908825]  ? __kasan_check_read+0x11/0x20
&gt; &gt; &gt; [ 1084.908831]  hci_rx_work+0x312/0xd60
&gt; &gt; &gt; [ 1084.908836]  ? __pfx__raw_spin_lock_irq+0x10/0x10
&gt; &gt; &gt; [ 1084.908841]  process_one_work+0x577/0xd30
&gt; &gt; &gt; [ 1084.908844]  ? _raw_spin_lock_irq+0x8b/0x100
&gt; &gt; &gt; [ 1084.908850]  worker_thread+0x879/0x15a0
&gt; &gt; &gt; [ 1084.908853]  ? __pfx__raw_spin_lock_irqsave+0x10/0x10
&gt; &gt; &gt; [ 1084.908859]  ? __pfx_worker_thread+0x10/0x10
&gt; &gt; &gt; [ 1084.908862]  kthread+0x2b7/0x390
&gt; &gt; &gt; [ 1084.908867]  ? __pfx_kthread+0x10/0x10
&gt; &gt; &gt; [ 1084.908871]  ret_from_fork+0x44/0x90
&gt; &gt; &gt; [ 1084.908876]  ? __pfx_kthread+0x10/0x10
&gt; &gt; &gt; [ 1084.908880]  ret_from_fork_asm+0x1b/0x30
&gt; &gt; &gt; [ 1084.908886]  &lt;/TASK&gt;
&gt; &gt; &gt; [ 1084.908888] ---[ end trace 0000000000000000 ]---
&gt; &gt; &gt; [ 1084.908894] ------------[ cut here ]------------
&gt; &gt; &gt; [ 1084.908896] refcount_t: underflow; use-after-free.
&gt; &gt; &gt; [ 1084.908937] WARNING: CPU: 0 PID: 162 at lib/refcount.c:28
&gt; &gt; &gt; refcount_warn_saturate+0x13e/0x1a0
&gt; &gt; &gt; [ 1084.908946] Modules linked in: isofs snd_seq_dummy snd_hrtimer qrtr
&gt; &gt; &gt; intel_rapl_msr intel_rapl_common intel_uncore_frequency_common
&gt; &gt; &gt; intel_pmc_core intel_vsec pmt_telemetry pmt_class crct10dif_pclmul
&gt; &gt; &gt; polyval_clmulni snd_ens1371 polyval_generic snd_ac97_codec
&gt; &gt; &gt; ghash_clmulni_intel gameport sha256_ssse3 ac97_bus vmw_balloon
&gt; &gt; &gt; sha1_ssse3 snd_pcm aesni_intel uvcvideo crypto_simd snd_seq_midi
&gt; &gt; &gt; cryptd rapl snd_seq_midi_event videobuf2_vmalloc uvc snd_rawmidi
&gt; &gt; &gt; videobuf2_memops videobuf2_v4l2 snd_seq snd_seq_device videodev
&gt; &gt; &gt; snd_timer videobuf2_common snd mc btusb btmtk soundcore i2c_piix4
&gt; &gt; &gt; input_leds joydev mac_hid serio_raw vsock_loopback binfmt_misc
&gt; &gt; &gt; vmw_vsock_virtio_transport_common vmw_vsock_vmci_transport vsock
&gt; &gt; &gt; vmw_vmci sch_fq_codel ramoops reed_solomon vmwgfx drm_ttm_helper ttm
&gt; &gt; &gt; msr parport_pc ppdev lp parport efi_pstore nfnetlink dmi_sysfs
&gt; &gt; &gt; ip_tables x_tables autofs4 hid_generic crc32_pclmul usbhid psmouse
&gt; &gt; &gt; mptspi mptscsih e1000 ahci mptbase libahci scsi_transport_spi
&gt; &gt; &gt; pata_acpi floppy
&gt; &gt; &gt; [ 1084.909076] CPU: 0 PID: 162 Comm: kworker/u265:0 Tainted: G    B
&gt; &gt; &gt; W          6.8.0 #4
&gt; &gt; &gt; [ 1084.909081] Hardware name: VMware, Inc. VMware Virtual
&gt; &gt; &gt; Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020
&gt; &gt; &gt; [ 1084.909084] Workqueue: hci0 hci_rx_work
&gt; &gt; &gt; [ 1084.909090] RIP: 0010:refcount_warn_saturate+0x13e/0x1a0
&gt; &gt; &gt; [ 1084.909094] Code: eb 97 0f b6 1d af 1a eb 03 80 fb 01 0f 87 56 6f
&gt; &gt; &gt; df 01 83 e3 01 75 82 48 c7 c7 a0 1c aa 84 c6 05 93 1a eb 03 01 e8 22
&gt; &gt; &gt; df c3 fe &lt;0f&gt; 0b e9 68 ff ff ff 0f b6 1d 81 1a eb 03 80 fb 01 0f 87 13
&gt; &gt; &gt; 6f df
&gt; &gt; &gt; [ 1084.909097] RSP: 0018:ffff888134717940 EFLAGS: 00010246
&gt; &gt; &gt; [ 1084.909101] RAX: 0000000000000000 RBX: 0000000000000000 RCX:
&gt; 0000000000000000
&gt; &gt; &gt; [ 1084.909103] RDX: 0000000000000000 RSI: 0000000000000000 RDI:
&gt; 0000000000000000
&gt; &gt; &gt; [ 1084.909106] RBP: ffff888134717950 R08: 0000000000000000 R09:
&gt; 0000000000000000
&gt; &gt; &gt; [ 1084.909108] R10: 0000000000000000 R11: 0000000000000000 R12:
&gt; 0000000000000003
&gt; &gt; &gt; [ 1084.909110] R13: ffff888104589000 R14: ffff888104589780 R15:
&gt; ffff88810033dc08
&gt; &gt; &gt; [ 1084.909113] FS:  0000000000000000(0000) GS:ffff8881f3200000(0000)
&gt; &gt; &gt; knlGS:0000000000000000
&gt; &gt; &gt; [ 1084.909116] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
&gt; &gt; &gt; [ 1084.909119] CR2: 000062bcbcecc5a0 CR3: 000000011de7a002 CR4:
&gt; 00000000003706f0
&gt; &gt; &gt; [ 1084.909122] Call Trace:
&gt; &gt; &gt; [ 1084.909124]  &lt;TASK&gt;
&gt; &gt; &gt; [ 1084.909127]  ? show_regs+0x6d/0x80
&gt; &gt; &gt; [ 1084.909132]  ? __warn+0xcd/0x270
&gt; &gt; &gt; [ 1084.909137]  ? refcount_warn_saturate+0x13e/0x1a0
&gt; &gt; &gt; [ 1084.909141]  ? report_bug+0x288/0x310
&gt; &gt; &gt; [ 1084.909145]  ? vprintk_default+0x1d/0x30
&gt; &gt; &gt; [ 1084.909149]  ? handle_bug+0x9f/0xd0
&gt; &gt; &gt; [ 1084.909153]  ? exc_invalid_op+0x18/0x50
&gt; &gt; &gt; [ 1084.909158]  ? asm_exc_invalid_op+0x1b/0x20
&gt; &gt; &gt; [ 1084.909164]  ? refcount_warn_saturate+0x13e/0x1a0
&gt; &gt; &gt; [ 1084.909168]  sco_conn_del+0x1dc/0x220
&gt; &gt; &gt; [ 1084.909174]  sco_connect_cfm+0x1d4/0xac0
&gt; &gt; &gt; [ 1084.909179]  ? __pfx_sco_connect_cfm+0x10/0x10
&gt; &gt; &gt; [ 1084.909184]  ? __pfx_mutex_lock+0x10/0x10
&gt; &gt; &gt; [ 1084.909189]  hci_sco_setup+0x397/0x570
&gt; &gt; &gt; [ 1084.909193]  ? __pfx_hci_sco_setup+0x10/0x10
&gt; &gt; &gt; [ 1084.909196]  ? __pfx_mutex_lock+0x10/0x10
&gt; &gt; &gt; [ 1084.909202]  hci_conn_complete_evt+0x957/0x1150
&gt; &gt; &gt; [ 1084.909206]  ? kasan_save_track+0x14/0x40
&gt; &gt; &gt; [ 1084.909211]  ? __pfx_hci_conn_complete_evt+0x10/0x10
&gt; &gt; &gt; [ 1084.909215]  ? __kasan_check_write+0x14/0x30
&gt; &gt; &gt; [ 1084.909220]  ? mutex_unlock+0x81/0xe0
&gt; &gt; &gt; [ 1084.909224]  ? __pfx_mutex_unlock+0x10/0x10
&gt; &gt; &gt; [ 1084.909228]  hci_event_packet+0x818/0x1080
&gt; &gt; &gt; [ 1084.909256]  ? __pfx_hci_conn_complete_evt+0x10/0x10
&gt; &gt; &gt; [ 1084.909261]  ? __pfx_hci_event_packet+0x10/0x10
&gt; &gt; &gt; [ 1084.909267]  ? __pfx__raw_spin_lock_irqsave+0x10/0x10
&gt; &gt; &gt; [ 1084.909272]  ? __pfx_hci_cmd_sync_complete+0x10/0x10
&gt; &gt; &gt; [ 1084.909278]  ? __kasan_check_read+0x11/0x20
&gt; &gt; &gt; [ 1084.909285]  hci_rx_work+0x312/0xd60
&gt; &gt; &gt; [ 1084.909291]  ? __pfx__raw_spin_lock_irq+0x10/0x10
&gt; &gt; &gt; [ 1084.909297]  process_one_work+0x577/0xd30
&gt; &gt; &gt; [ 1084.909301]  ? _raw_spin_lock_irq+0x8b/0x100
&gt; &gt; &gt; [ 1084.909308]  worker_thread+0x879/0x15a0
&gt; &gt; &gt; [ 1084.909312]  ? __pfx__raw_spin_lock_irqsave+0x10/0x10
&gt; &gt; &gt; [ 1084.909319]  ? __pfx_worker_thread+0x10/0x10
&gt; &gt; &gt; [ 1084.909323]  kthread+0x2b7/0x390
&gt; &gt; &gt; [ 1084.909328]  ? __pfx_kthread+0x10/0x10
&gt; &gt; &gt; [ 1084.909350]  ret_from_fork+0x44/0x90
&gt; &gt; &gt; [ 1084.909354]  ? __pfx_kthread+0x10/0x10
&gt; &gt; &gt; [ 1084.909359]  ret_from_fork_asm+0x1b/0x30
&gt; &gt; &gt; [ 1084.909364]  &lt;/TASK&gt;
&gt; &gt; &gt; [ 1084.909366] ---[ end trace 0000000000000000 ]---
&gt; &gt; &gt;
&gt; &gt; &gt; =*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*=
&gt; &gt; &gt; Environment
&gt; =*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*=
&gt; &gt; &gt;
&gt; &gt; &gt; linux-6.8.0
&gt; &gt; &gt; ubuntu 24.04
&gt; &gt; &gt; .config:
&gt; <a href="https://github.com/qiutianshu/sco-race-condition/blob/main/config" rel="nofollow">https://github.com/qiutianshu/sco-race-condition/blob/main/config</a>
&gt; &gt; &gt;
&gt; &gt; &gt; =*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*=
&gt; &gt; &gt; Proof of Concept
&gt; &gt; &gt; =*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*=
&gt; &gt; &gt;
&gt; &gt; &gt;
&gt; <a href="https://github.com/qiutianshu/sco-race-condition/blob/main/Linux-6.8.0-PoC.webm" rel="nofollow">https://github.com/qiutianshu/sco-race-condition/blob/main/Linux-6.8.0-PoC.webm</a>
&gt; &gt; &gt;
&gt; &gt; &gt; =*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*=
&gt; &gt; &gt; PATCH
&gt; =*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*==*=*=*=*=*=*=*=*=
&gt; &gt; &gt;
&gt; &gt; &gt; My patch removes the three "lock-release" pairs in the original
&gt; &gt; &gt; sco_sock_connect, and use a single "lock-release" pair to protect the
&gt; &gt; &gt; whole connect procedure.
&gt; &gt; &gt; Circular locking have not been observed after patching:
&gt; &gt; &gt; <a href="https://github.com/qiutianshu/sco-race-condition/blob/main/test.c" rel="nofollow">https://github.com/qiutianshu/sco-race-condition/blob/main/test.c</a>
&gt; &gt; &gt;
&gt; &gt; &gt; Patch:
&gt; &gt; &gt; <a href="https://github.com/qiutianshu/sco-race-condition/blob/main/diff.txt" rel="nofollow">https://github.com/qiutianshu/sco-race-condition/blob/main/diff.txt</a>
&gt; &gt;
&gt; &gt; The replies originally included some quoting of the message above, which
&gt; &gt; I excluded from the copies below.
&gt; &gt;
&gt; &gt; On Thu, Nov 14, 2024 at 07:51:20PM +0100, Vegard Nossum wrote:
&gt; &gt; &gt; Hi tianshu,
&gt; &gt; &gt;
&gt; &gt; &gt; Thank you for the report.
&gt; &gt; &gt;
&gt; &gt; &gt; At a glance, 483bc08181827fc475643272ffb69c533007e546 looks like it was
&gt; &gt; &gt; only committed in 6.9 yet your crash/kernel messages indicate you are
&gt; &gt; &gt; testing against 6.8.0 -- are you sure this wasn't fixed already? Could
&gt; &gt; &gt; you verify with a more recent kernel?
&gt; &gt; &gt;
&gt; &gt; &gt; Secondly, have you contacted either security&#64;...nel.org or the
&gt; bluetooth
&gt; &gt; &gt; maintainers about this issue? The maintainers would be:
&gt; &gt; &gt;
&gt; &gt; &gt; BLUETOOTH SUBSYSTEM
&gt; &gt; &gt; M:      Marcel Holtmann &lt;marcel&#64;...tmann.org&gt;
&gt; &gt; &gt; M:      Johan Hedberg &lt;johan.hedberg&#64;...il.com&gt;
&gt; &gt; &gt; M:      Luiz Augusto von Dentz &lt;luiz.dentz&#64;...il.com&gt;
&gt; &gt; &gt;
&gt; &gt; &gt; Please see the kernel documentation on reporting security issues:
&gt; &gt; &gt;
&gt; &gt; &gt; <a href="https://docs.kernel.org/process/security-bugs.html" rel="nofollow">https://docs.kernel.org/process/security-bugs.html</a>
&gt; &gt; &gt;
&gt; &gt; &gt; For CVE assignments, you need to contact the CVE assignment team:
&gt; &gt; &gt;
&gt; &gt; &gt; <a href="https://docs.kernel.org/process/cve.html" rel="nofollow">https://docs.kernel.org/process/cve.html</a>
&gt; &gt; &gt;
&gt; &gt; &gt; However, be aware that CVE-2024-27398 was already assigned to the issue
&gt; &gt; &gt; fixed by commit 483bc08181827fc475643272ffb69c533007e546 ("Bluetooth:
&gt; &gt; &gt; Fix use-after-free bugs caused by sco_sock_timeout") -- which, if it's
&gt; &gt; &gt; the same issue, would also be the same CVE.
&gt; &gt; &gt;
&gt; &gt; &gt; I admit I haven't looked very closely at the code yet, I will try to
&gt; &gt; &gt; take a better look tomorrow. (Anybody else on the list is obviously
&gt; &gt; &gt; welcome to look as well.)
&gt; &gt; &gt;
&gt; &gt; &gt; Finally, I will point out that we usually require reporters to set an
&gt; &gt; &gt; embargo end-date according to the linux-distros list policy (usually 7
&gt; &gt; &gt; days, no more than 14 days), after which your report must also be made
&gt; &gt; &gt; public by posting it to oss-security; see:
&gt; &gt; &gt;
&gt; &gt; &gt;
&gt; <a href="https://oss-security.openwall.org/wiki/mailing-lists/distros#list-policy-and-instructions-for-reporters">https://oss-security.openwall.org/wiki/mailing-lists/distros#list-policy-and-instructions-for-reporters</a>
&gt; &gt; &gt;
&gt; &gt; &gt; Thanks,
&gt; &gt; &gt;
&gt; &gt; &gt; Vegard
&gt; &gt;
&gt; &gt; On Mon, Nov 18, 2024 at 09:33:27PM +0100, Salvatore Bonaccorso wrote:
&gt; &gt; &gt; Hi,
&gt; &gt; &gt;
&gt; &gt; &gt; Question back on your report: have you reached out first to the kernel
&gt; &gt; &gt; security team?
&gt; &gt; &gt;
&gt; &gt; &gt; Cf.
&gt; <a href="https://oss-security.openwall.org/wiki/mailing-lists/distros#list-policy-and-instructions-for-reporters">https://oss-security.openwall.org/wiki/mailing-lists/distros#list-policy-and-instructions-for-reporters</a>
&gt; &gt; &gt;
&gt; &gt; &gt; | Please consider notifying upstream projects/developers of the
&gt; affected
&gt; &gt; &gt; | software, other affected distro vendors, and/or affected Open Source
&gt; &gt; &gt; | projects before notifying one of these mailing lists in order to
&gt; &gt; &gt; | readily have fixes for the distributions to apply and to ensure that
&gt; &gt; &gt; | these other parties are OK with the maximum embargo period that would
&gt; &gt; &gt; | apply (if not, you may delay your notification to the mailing list).
&gt; &gt; &gt; | For Linux kernel issues, you must notify the kernel security team
&gt; &gt; &gt; | first, wait for the fix, and only then notify linux-distros or
&gt; &gt; &gt; | oss-security (depending on whether the information is still private
&gt; or
&gt; &gt; &gt; | already public, as well as on issue severity).
&gt; &gt; &gt;
&gt; &gt; &gt; Regards,
&gt; &gt; &gt; Salvatore
&gt;
&gt;
&gt;
&gt; --
&gt; Luiz Augusto von Dentz
&gt;

</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>
Please check out the
<a href="https://oss-security.openwall.org/wiki/">
Open Source Software Security Wiki</a>, which is counterpart to this
<a href="https://oss-security.openwall.org/wiki/mailing-lists/oss-security">mailing list</a>.
<p>
Confused about <a href="/lists/">mailing lists</a> and their use?
<a href="https://en.wikipedia.org/wiki/Electronic_mailing_list">Read about mailing lists on Wikipedia</a>
and check out these
<a href="https://www.complang.tuwien.ac.at/anton/mail-news-errors.html">guidelines on proper formatting of your messages</a>.
<p>

</body>
</html>
