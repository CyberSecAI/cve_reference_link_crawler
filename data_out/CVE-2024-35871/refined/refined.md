```
{
  "vulnerability": {
    "root_cause": "The kernel was leaking the kernel global pointer (gp) register value to user space.",
    "weaknesses": [
      "Information exposure through registers",
      "Insufficient sanitization of register values during process creation."
    ],
    "impact": "The kernel gp register, which is a pointer to a kernel memory region containing global variables, can be observed by user space. This information leak could potentially be used to bypass kernel address space layout randomization (KASLR) and aid in other exploits.",
    "attack_vectors": [
      "Starting user processes directly from kernel, e.g. init.",
      "Attaching to a user_mode_helper thread using ptrace before the exec call.",
      "Using PERF_SAMPLE_REGS_USER to access register data.",
      "Tracing infrastructure that provides access to user registers."
     ],
    "required_capabilities": "Ability to create new processes or use ptrace or perf features"
  },
  "technical_details": {
      "details": "The `copy_thread` function in `arch/riscv/kernel/process.c`, when creating a kernel thread or a user mode helper thread, incorrectly set the `childregs->gp` register with the kernel's global pointer value. This value was then accessible in the user context during syscall execution and in user mode helper threads, before the exec completes. The vulnerability could be exploited using different methods such as `kernel_execve`, `ptrace(PTRACE_GETREGSET)`, `/proc/*/task/*/syscall`, `PERF_SAMPLE_REGS_USER` and tracing infrastructure.",
       "affected_code": "arch/riscv/kernel/process.c",
       "fixed_code_change": "The fix removes the line `childregs->gp = gp_in_global;` to prevent leaking kernel gp value."
  }
}
```