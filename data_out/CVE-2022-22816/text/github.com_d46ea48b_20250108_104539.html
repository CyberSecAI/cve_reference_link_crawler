
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fpython-pillow%2FPillow%2Fblob%2Fc5d9223a8b5e9295d15b5a9b1ef1dae44c8499f3%2Fsrc%2Fpath.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fpython-pillow%2FPillow%2Fblob%2Fc5d9223a8b5e9295d15b5a9b1ef1dae44c8499f3%2Fsrc%2Fpath.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=python-pillow%2FPillow)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[python-pillow](/python-pillow)
/
**[Pillow](/python-pillow/Pillow)**
Public

* [Notifications](/login?return_to=%2Fpython-pillow%2FPillow) You must be signed in to change notification settings
* [Fork
  2.2k](/login?return_to=%2Fpython-pillow%2FPillow)
* [Star
   12.5k](/login?return_to=%2Fpython-pillow%2FPillow)

* [Code](/python-pillow/Pillow)
* [Issues
  73](/python-pillow/Pillow/issues)
* [Pull requests
  61](/python-pillow/Pillow/pulls)
* [Discussions](/python-pillow/Pillow/discussions)
* [Actions](/python-pillow/Pillow/actions)
* [Projects
  1](/python-pillow/Pillow/projects)
* [Wiki](/python-pillow/Pillow/wiki)
* [Security](/python-pillow/Pillow/security)
* [Insights](/python-pillow/Pillow/pulse)

Additional navigation options

* [Code](/python-pillow/Pillow)
* [Issues](/python-pillow/Pillow/issues)
* [Pull requests](/python-pillow/Pillow/pulls)
* [Discussions](/python-pillow/Pillow/discussions)
* [Actions](/python-pillow/Pillow/actions)
* [Projects](/python-pillow/Pillow/projects)
* [Wiki](/python-pillow/Pillow/wiki)
* [Security](/python-pillow/Pillow/security)
* [Insights](/python-pillow/Pillow/pulse)

## Files

 c5d9223
## Breadcrumbs

1. [Pillow](/python-pillow/Pillow/tree/c5d9223a8b5e9295d15b5a9b1ef1dae44c8499f3)
2. /[src](/python-pillow/Pillow/tree/c5d9223a8b5e9295d15b5a9b1ef1dae44c8499f3/src)
/
# path.c

 Blame  Blame
## Latest commit

## History

[History](/python-pillow/Pillow/commits/c5d9223a8b5e9295d15b5a9b1ef1dae44c8499f3/src/path.c)622 lines (539 loc) · 16.8 KB c5d9223
## Breadcrumbs

1. [Pillow](/python-pillow/Pillow/tree/c5d9223a8b5e9295d15b5a9b1ef1dae44c8499f3)
2. /[src](/python-pillow/Pillow/tree/c5d9223a8b5e9295d15b5a9b1ef1dae44c8499f3/src)
/
# path.c

Top
## File metadata and controls

* Code
* Blame

622 lines (539 loc) · 16.8 KB[Raw](https://github.com/python-pillow/Pillow/raw/c5d9223a8b5e9295d15b5a9b1ef1dae44c8499f3/src/path.c)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622/\* \* The Python Imaging Library. \* \* 2D path utilities \* \* history: \* 1996-11-04 fl Added to PIL (incomplete) \* 1996-11-05 fl Added sequence semantics \* 1997-02-28 fl Fixed getbbox \* 1997-06-12 fl Added id attribute \* 1997-06-14 fl Added slicing and setitem \* 1998-12-29 fl Improved sequence handling (from Richard Jones) \* 1999-01-10 fl Fixed IndexError test for 1.5 (from Fred Drake) \* 2000-10-12 fl Added special cases for tuples and lists \* 2002-10-27 fl Added clipping boilerplate \* 2004-09-19 fl Added tolist(flat) variant \* 2005-05-06 fl Added buffer interface support to path constructor \* \* notes: \* FIXME: fill in remaining slots in the sequence api \* \* Copyright (c) 1997-2005 by Secret Labs AB \* Copyright (c) 1997-2005 by Fredrik Lundh \* \* See the README file for information on usage and redistribution. \*/
#include "Python.h"#include "libImaging/Imaging.h"
#include <math.h>
/\* compatibility wrappers (defined in \_imaging.c) \*/extern intPyImaging\_CheckBuffer(PyObject \*buffer);extern intPyImaging\_GetBuffer(PyObject \*buffer, Py\_buffer \*view);
/\* -------------------------------------------------------------------- \*//\* Class \*//\* -------------------------------------------------------------------- \*/
typedef struct { PyObject\_HEAD Py\_ssize\_t count; double \*xy; int index; /\* temporary use, e.g. in decimate \*/} PyPathObject;
static PyTypeObject PyPathType;
static double \*alloc\_array(Py\_ssize\_t count) { double \*xy; if (count < 0) { return ImagingError\_MemoryError(); } if ((unsigned long long)count > (SIZE\_MAX / (2 \* sizeof(double))) - 1) { return ImagingError\_MemoryError(); } xy = malloc(2 \* count \* sizeof(double) + 1); if (!xy) { ImagingError\_MemoryError(); } return xy;}
static PyPathObject \*path\_new(Py\_ssize\_t count, double \*xy, int duplicate) { PyPathObject \*path;
 if (duplicate) { /\* duplicate path \*/ double \*p = alloc\_array(count); if (!p) { return NULL; } memcpy(p, xy, count \* 2 \* sizeof(double)); xy = p; }
 if (PyType\_Ready(&PyPathType) < 0) { free(xy); return NULL; }
 path = PyObject\_New(PyPathObject, &PyPathType); if (path == NULL) { free(xy); return NULL; }
 path->count = count; path->xy = xy;
 return path;}
static voidpath\_dealloc(PyPathObject \*path) { free(path->xy); PyObject\_Del(path);}
/\* -------------------------------------------------------------------- \*//\* Helpers \*//\* -------------------------------------------------------------------- \*/
#define PyPath\_Check(op) (Py\_TYPE(op) == &PyPathType)
Py\_ssize\_tPyPath\_Flatten(PyObject \*data, double \*\*pxy) { Py\_ssize\_t i, j, n; double \*xy;
 if (PyPath\_Check(data)) { /\* This was another path object. \*/ PyPathObject \*path = (PyPathObject \*)data; xy = alloc\_array(path->count); if (!xy) { return -1; } memcpy(xy, path->xy, 2 \* path->count \* sizeof(double)); \*pxy = xy; return path->count; }
 if (PyImaging\_CheckBuffer(data)) { /\* Assume the buffer contains floats \*/ Py\_buffer buffer; if (PyImaging\_GetBuffer(data, &buffer) == 0) { float \*ptr = (float \*)buffer.buf; n = buffer.len / (2 \* sizeof(float)); xy = alloc\_array(n); if (!xy) { return -1; } for (i = 0; i < n + n; i++) { xy[i] = ptr[i]; } \*pxy = xy; PyBuffer\_Release(&buffer); return n; } PyErr\_Clear(); }
 if (!PySequence\_Check(data)) { PyErr\_SetString(PyExc\_TypeError, "argument must be sequence"); return -1; }
 j = 0; n = PyObject\_Length(data); /\* Just in case \_\_len\_\_ breaks (or doesn't exist) \*/ if (PyErr\_Occurred()) { return -1; }
 /\* Allocate for worst case \*/ xy = alloc\_array(n); if (!xy) { return -1; }
 /\* Copy table to path array \*/ if (PyList\_Check(data)) { for (i = 0; i < n; i++) { double x, y; PyObject \*op = PyList\_GET\_ITEM(data, i); if (PyFloat\_Check(op)) { xy[j++] = PyFloat\_AS\_DOUBLE(op); } else if (PyLong\_Check(op)) { xy[j++] = (float)PyLong\_AS\_LONG(op); } else if (PyNumber\_Check(op)) { xy[j++] = PyFloat\_AsDouble(op); } else if (PyArg\_ParseTuple(op, "dd", &x, &y)) { xy[j++] = x; xy[j++] = y; } else { free(xy); return -1; } } } else if (PyTuple\_Check(data)) { for (i = 0; i < n; i++) { double x, y; PyObject \*op = PyTuple\_GET\_ITEM(data, i); if (PyFloat\_Check(op)) { xy[j++] = PyFloat\_AS\_DOUBLE(op); } else if (PyLong\_Check(op)) { xy[j++] = (float)PyLong\_AS\_LONG(op); } else if (PyNumber\_Check(op)) { xy[j++] = PyFloat\_AsDouble(op); } else if (PyArg\_ParseTuple(op, "dd", &x, &y)) { xy[j++] = x; xy[j++] = y; } else { free(xy); return -1; } } } else { for (i = 0; i < n; i++) { double x, y; PyObject \*op = PySequence\_GetItem(data, i); if (!op) { /\* treat IndexError as end of sequence \*/ if (PyErr\_Occurred() && PyErr\_ExceptionMatches(PyExc\_IndexError)) { PyErr\_Clear(); break; } else { free(xy); return -1; } } if (PyFloat\_Check(op)) { xy[j++] = PyFloat\_AS\_DOUBLE(op); } else if (PyLong\_Check(op)) { xy[j++] = (float)PyLong\_AS\_LONG(op); } else if (PyNumber\_Check(op)) { xy[j++] = PyFloat\_AsDouble(op); } else if (PyArg\_ParseTuple(op, "dd", &x, &y)) { xy[j++] = x; xy[j++] = y; } else { Py\_DECREF(op); free(xy); return -1; } Py\_DECREF(op); } }
 if (j & 1) { PyErr\_SetString(PyExc\_ValueError, "wrong number of coordinates"); free(xy); return -1; }
 \*pxy = xy; return j / 2;}
/\* -------------------------------------------------------------------- \*//\* Factories \*//\* -------------------------------------------------------------------- \*/
PyObject \*PyPath\_Create(PyObject \*self, PyObject \*args) { PyObject \*data; Py\_ssize\_t count; double \*xy;
 if (PyArg\_ParseTuple(args, "n:Path", &count)) { /\* number of vertices \*/ xy = alloc\_array(count); if (!xy) { return NULL; }
 } else { /\* sequence or other path \*/ PyErr\_Clear(); if (!PyArg\_ParseTuple(args, "O", &data)) { return NULL; }
 count = PyPath\_Flatten(data, &xy); if (count < 0) { return NULL; } }
 return (PyObject \*)path\_new(count, xy, 0);}
/\* -------------------------------------------------------------------- \*//\* Methods \*//\* -------------------------------------------------------------------- \*/
static PyObject \*path\_compact(PyPathObject \*self, PyObject \*args) { /\* Simple-minded method to shorten path. A point is removed if the city block distance to the previous point is less than the given distance \*/ Py\_ssize\_t i, j; double \*xy;
 double cityblock = 2.0;
 if (!PyArg\_ParseTuple(args, "|d:compact", &cityblock)) { return NULL; }
 xy = self->xy;
 /\* remove bogus vertices \*/ for (i = j = 1; i < self->count; i++) { if (fabs(xy[j + j - 2] - xy[i + i]) + fabs(xy[j + j - 1] - xy[i + i + 1]) >= cityblock) { xy[j + j] = xy[i + i]; xy[j + j + 1] = xy[i + i + 1]; j++; } }
 i = self->count - j; self->count = j;
 /\* shrink coordinate array \*/ /\* malloc check ok, self->count is smaller than it was before \*/ self->xy = realloc(self->xy, 2 \* self->count \* sizeof(double));
 return Py\_BuildValue("i", i); /\* number of removed vertices \*/}
static PyObject \*path\_getbbox(PyPathObject \*self, PyObject \*args) { /\* Find bounding box \*/ Py\_ssize\_t i; double \*xy; double x0, y0, x1, y1;
 if (!PyArg\_ParseTuple(args, ":getbbox")) { return NULL; }
 xy = self->xy;
 x0 = x1 = xy[0]; y0 = y1 = xy[1];
 for (i = 1; i < self->count; i++) { if (xy[i + i] < x0) { x0 = xy[i + i]; } if (xy[i + i] > x1) { x1 = xy[i + i]; } if (xy[i + i + 1] < y0) { y0 = xy[i + i + 1]; } if (xy[i + i + 1] > y1) { y1 = xy[i + i + 1]; } }
 return Py\_BuildValue("dddd", x0, y0, x1, y1);}
static PyObject \*path\_getitem(PyPathObject \*self, Py\_ssize\_t i) { if (i < 0) { i = self->count + i; } if (i < 0 || i >= self->count) { PyErr\_SetString(PyExc\_IndexError, "path index out of range"); return NULL; }
 return Py\_BuildValue("dd", self->xy[i + i], self->xy[i + i + 1]);}
static PyObject \*path\_getslice(PyPathObject \*self, Py\_ssize\_t ilow, Py\_ssize\_t ihigh) { /\* adjust arguments \*/ if (ilow < 0) { ilow = 0; } else if (ilow >= self->count) { ilow = self->count; } if (ihigh < 0) { ihigh = 0; } if (ihigh < ilow) { ihigh = ilow; } else if (ihigh > self->count) { ihigh = self->count; }
 return (PyObject \*)path\_new(ihigh - ilow, self->xy + ilow \* 2, 1);}
static Py\_ssize\_tpath\_len(PyPathObject \*self) { return self->count;}
static PyObject \*path\_map(PyPathObject \*self, PyObject \*args) { /\* Map coordinate set through function \*/ Py\_ssize\_t i; double \*xy; PyObject \*function;
 if (!PyArg\_ParseTuple(args, "O:map", &function)) { return NULL; }
 xy = self->xy;
 /\* apply function to coordinate set \*/ for (i = 0; i < self->count; i++) { double x = xy[i + i]; double y = xy[i + i + 1]; PyObject \*item = PyObject\_CallFunction(function, "dd", x, y); if (!item || !PyArg\_ParseTuple(item, "dd", &x, &y)) { Py\_XDECREF(item); return NULL; } xy[i + i] = x; xy[i + i + 1] = y; Py\_DECREF(item); }
 Py\_INCREF(Py\_None); return Py\_None;}
static intpath\_setitem(PyPathObject \*self, Py\_ssize\_t i, PyObject \*op) { double \*xy;
 if (i < 0 || i >= self->count) { PyErr\_SetString(PyExc\_IndexError, "path assignment index out of range"); return -1; }
 if (op == NULL) { PyErr\_SetString(PyExc\_TypeError, "cannot delete from path"); return -1; }
 xy = &self->xy[i + i];
 if (!PyArg\_ParseTuple(op, "dd", &xy[0], &xy[1])) { return -1; }
 return 0;}
static PyObject \*path\_tolist(PyPathObject \*self, PyObject \*args) { PyObject \*list; Py\_ssize\_t i;
 int flat = 0; if (!PyArg\_ParseTuple(args, "|i:tolist", &flat)) { return NULL; }
 if (flat) { list = PyList\_New(self->count \* 2); for (i = 0; i < self->count \* 2; i++) { PyObject \*item; item = PyFloat\_FromDouble(self->xy[i]); if (!item) { goto error; } PyList\_SetItem(list, i, item); } } else { list = PyList\_New(self->count); for (i = 0; i < self->count; i++) { PyObject \*item; item = Py\_BuildValue("dd", self->xy[i + i], self->xy[i + i + 1]); if (!item) { goto error; } PyList\_SetItem(list, i, item); } }
 return list;
error: Py\_DECREF(list); return NULL;}
static PyObject \*path\_transform(PyPathObject \*self, PyObject \*args) { /\* Apply affine transform to coordinate set \*/ Py\_ssize\_t i; double \*xy; double a, b, c, d, e, f;
 double wrap = 0.0;
 if (!PyArg\_ParseTuple( args, "(dddddd)|d:transform", &a, &b, &c, &d, &e, &f, &wrap)) { return NULL; }
 xy = self->xy;
 /\* transform the coordinate set \*/ if (b == 0.0 && d == 0.0) { /\* scaling \*/ for (i = 0; i < self->count; i++) { xy[i + i] = a \* xy[i + i] + c; xy[i + i + 1] = e \* xy[i + i + 1] + f; } } else { /\* affine transform \*/ for (i = 0; i < self->count; i++) { double x = xy[i + i]; double y = xy[i + i + 1]; xy[i + i] = a \* x + b \* y + c; xy[i + i + 1] = d \* x + e \* y + f; } }
 /\* special treatment of geographical map data \*/ if (wrap != 0.0) { for (i = 0; i < self->count; i++) { xy[i + i] = fmod(xy[i + i], wrap); } }
 Py\_INCREF(Py\_None); return Py\_None;}
static struct PyMethodDef methods[] = { {"getbbox", (PyCFunction)path\_getbbox, METH\_VARARGS}, {"tolist", (PyCFunction)path\_tolist, METH\_VARARGS}, {"compact", (PyCFunction)path\_compact, METH\_VARARGS}, {"map", (PyCFunction)path\_map, METH\_VARARGS}, {"transform", (PyCFunction)path\_transform, METH\_VARARGS}, {NULL, NULL} /\* sentinel \*/};
static PyObject \*path\_getattr\_id(PyPathObject \*self, void \*closure) { return Py\_BuildValue("n", (Py\_ssize\_t)self->xy);}
static struct PyGetSetDef getsetters[] = {{"id", (getter)path\_getattr\_id}, {NULL}};
static PyObject \*path\_subscript(PyPathObject \*self, PyObject \*item) { if (PyIndex\_Check(item)) { Py\_ssize\_t i; i = PyNumber\_AsSsize\_t(item, PyExc\_IndexError); if (i == -1 && PyErr\_Occurred()) { return NULL; } return path\_getitem(self, i); } if (PySlice\_Check(item)) { int len = 4; Py\_ssize\_t start, stop, step, slicelength;
 if (PySlice\_GetIndicesEx(item, len, &start, &stop, &step, &slicelength) < 0) { return NULL; }
 if (slicelength <= 0) { double \*xy = alloc\_array(0); return (PyObject \*)path\_new(0, xy, 0); } else if (step == 1) { return path\_getslice(self, start, stop); } else { PyErr\_SetString(PyExc\_TypeError, "slice steps not supported"); return NULL; } } else { PyErr\_Format( PyExc\_TypeError, "Path indices must be integers, not %.200s", Py\_TYPE(item)->tp\_name); return NULL; }}
static PySequenceMethods path\_as\_sequence = { (lenfunc)path\_len, /\*sq\_length\*/ (binaryfunc)0, /\*sq\_concat\*/ (ssizeargfunc)0, /\*sq\_repeat\*/ (ssizeargfunc)path\_getitem, /\*sq\_item\*/ (ssizessizeargfunc)path\_getslice, /\*sq\_slice\*/ (ssizeobjargproc)path\_setitem, /\*sq\_ass\_item\*/ (ssizessizeobjargproc)0, /\*sq\_ass\_slice\*/};
static PyMappingMethods path\_as\_mapping = { (lenfunc)path\_len, (binaryfunc)path\_subscript, NULL};
static PyTypeObject PyPathType = { PyVarObject\_HEAD\_INIT(NULL, 0) "Path", /\*tp\_name\*/ sizeof(PyPathObject), /\*tp\_size\*/ 0, /\*tp\_itemsize\*/ /\* methods \*/ (destructor)path\_dealloc, /\*tp\_dealloc\*/ 0, /\*tp\_print\*/ 0, /\*tp\_getattr\*/ 0, /\*tp\_setattr\*/ 0, /\*tp\_compare\*/ 0, /\*tp\_repr\*/ 0, /\*tp\_as\_number \*/ &path\_as\_sequence, /\*tp\_as\_sequence \*/ &path\_as\_mapping, /\*tp\_as\_mapping \*/ 0, /\*tp\_hash\*/ 0, /\*tp\_call\*/ 0, /\*tp\_str\*/ 0, /\*tp\_getattro\*/ 0, /\*tp\_setattro\*/ 0, /\*tp\_as\_buffer\*/ Py\_TPFLAGS\_DEFAULT, /\*tp\_flags\*/ 0, /\*tp\_doc\*/ 0, /\*tp\_traverse\*/ 0, /\*tp\_clear\*/ 0, /\*tp\_richcompare\*/ 0, /\*tp\_weaklistoffset\*/ 0, /\*tp\_iter\*/ 0, /\*tp\_iternext\*/ methods, /\*tp\_methods\*/ 0, /\*tp\_members\*/ getsetters, /\*tp\_getset\*/};

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

