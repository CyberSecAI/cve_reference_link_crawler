The provided content is related to CVE-2021-47582.

**Root cause of vulnerability:**
The `USBDEVFS_CONTROL` and `USBDEVFS_BULK` ioctls in the Linux kernel's USB subsystem use `usb_start_wait_urb()`, which involves an uninterruptible wait with a user-specified timeout. If the timeout is large and the USB device doesn't respond promptly, the kernel can get stuck in an uninterruptible sleep, leading to "Task X blocked for more than N seconds" messages and potential system instability.

**Weaknesses/vulnerabilities present:**
- Uninterruptible wait in `usb_start_wait_urb()`.
- Use of `GFP_NOIO` for memory allocation within the interrupt context

**Impact of exploitation:**
- Kernel-level denial of service, where a process can become stuck indefinitely, and in some cases potentially lead to a hung system.

**Attack vectors:**
- By making use of the `USBDEVFS_CONTROL` and `USBDEVFS_BULK` ioctls with a large timeout and interacting with an unresponsive USB device.

**Required attacker capabilities/position:**
- The attacker must have the ability to interact with a USB device through the `USBDEVFS_CONTROL` and `USBDEVFS_BULK` ioctls.
- The attacker has to be able to control the timeout value for the usb request
- The target USB device must be unresponsive to trigger the issue

**Mitigation:**
The patch replaces the usage of `usb_control_msg()` and `usb_bulk_msg()` with custom code that uses a killable wait (`wait_for_completion_killable_timeout`) and `GFP_KERNEL` for memory allocation. This ensures that the wait is interruptible and that memory allocation won't stall the system