

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=403716741c6c2c510dce44e88f085a740f535de6)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=403716741c6c2c510dce44e88f085a740f535de6)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=403716741c6c2c510dce44e88f085a740f535de6)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=403716741c6c2c510dce44e88f085a740f535de6)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Alan Stern <stern@rowland.harvard.edu> | 2021-09-03 13:53:12 -0400 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2021-12-22 09:32:50 +0100 |
| commit | [403716741c6c2c510dce44e88f085a740f535de6](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=403716741c6c2c510dce44e88f085a740f535de6) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=403716741c6c2c510dce44e88f085a740f535de6)) | |
| tree | [16c3cc68f3c049315ef1881c2305b3d2176283ea](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=403716741c6c2c510dce44e88f085a740f535de6) | |
| parent | [303644fe7e0c30df6925ede3dd35b3a5b2c454b8](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=303644fe7e0c30df6925ede3dd35b3a5b2c454b8) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=403716741c6c2c510dce44e88f085a740f535de6&id2=303644fe7e0c30df6925ede3dd35b3a5b2c454b8)) | |
| download | [linux-403716741c6c2c510dce44e88f085a740f535de6.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-403716741c6c2c510dce44e88f085a740f535de6.tar.gz) | |

USB: core: Make do\_proc\_control() and do\_proc\_bulk() killablecommit ae8709b296d80c7f45aa1f35c0e7659ad69edce1 upstream.
The USBDEVFS\_CONTROL and USBDEVFS\_BULK ioctls invoke
usb\_start\_wait\_urb(), which contains an uninterruptible wait with a
user-specified timeout value. If timeout value is very large and the
device being accessed does not respond in a reasonable amount of time,
the kernel will complain about "Task X blocked for more than N
seconds", as found in testing by syzbot:
INFO: task syz-executor.0:8700 blocked for more than 143 seconds.
Not tainted 5.14.0-rc7-syzkaller #0
"echo 0 > /proc/sys/kernel/hung\_task\_timeout\_secs" disables this message.
task:syz-executor.0 state:D stack:23192 pid: 8700 ppid: 8455 flags:0x00004004
Call Trace:
context\_switch kernel/sched/core.c:4681 [inline]
\_\_schedule+0xc07/0x11f0 kernel/sched/core.c:5938
schedule+0x14b/0x210 kernel/sched/core.c:6017
schedule\_timeout+0x98/0x2f0 kernel/time/timer.c:1857
do\_wait\_for\_common+0x2da/0x480 kernel/sched/completion.c:85
\_\_wait\_for\_common kernel/sched/completion.c:106 [inline]
wait\_for\_common kernel/sched/completion.c:117 [inline]
wait\_for\_completion\_timeout+0x46/0x60 kernel/sched/completion.c:157
usb\_start\_wait\_urb+0x167/0x550 drivers/usb/core/message.c:63
do\_proc\_bulk+0x978/0x1080 drivers/usb/core/devio.c:1236
proc\_bulk drivers/usb/core/devio.c:1273 [inline]
usbdev\_do\_ioctl drivers/usb/core/devio.c:2547 [inline]
usbdev\_ioctl+0x3441/0x6b10 drivers/usb/core/devio.c:2713
...
To fix this problem, this patch replaces usbfs's calls to
usb\_control\_msg() and usb\_bulk\_msg() with special-purpose code that
does essentially the same thing (as recommended in the comment for
usb\_start\_wait\_urb()), except that it always uses a killable wait and
it uses GFP\_KERNEL rather than GFP\_NOIO.
Reported-and-tested-by: syzbot+ada0f7d3d9fd2016d927@syzkaller.appspotmail.com
Suggested-by: Oliver Neukum <oneukum@suse.com>
Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
Link: [https://lore.kernel.org/r/20210903175312.GA468440@rowland.harvard.edu](https://lore.kernel.org/r/20210903175312.GA468440%40rowland.harvard.edu)
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=403716741c6c2c510dce44e88f085a740f535de6)

| -rw-r--r-- | [drivers/usb/core/devio.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/usb/core/devio.c?id=403716741c6c2c510dce44e88f085a740f535de6) | 144 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 111 insertions, 33 deletions

| diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.cindex 9618ba622a2d06..fa66e6e5879285 100644--- a/[drivers/usb/core/devio.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/core/devio.c?id=303644fe7e0c30df6925ede3dd35b3a5b2c454b8)+++ b/[drivers/usb/core/devio.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/core/devio.c?id=403716741c6c2c510dce44e88f085a740f535de6)@@ -32,6 +32,7 @@ #include <linux/usb.h> #include <linux/usbdevice\_fs.h> #include <linux/usb/hcd.h> /\* for usbcore internals \*/+#include <linux/usb/quirks.h> #include <linux/cdev.h> #include <linux/notifier.h> #include <linux/security.h>@@ -1102,14 +1103,55 @@ static int usbdev\_release(struct inode \*inode, struct file \*file) return 0; } +static void usbfs\_blocking\_completion(struct urb \*urb)+{+ complete((struct completion \*) urb->context);+}++/\*+ \* Much like usb\_start\_wait\_urb, but returns status separately from+ \* actual\_length and uses a killable wait.+ \*/+static int usbfs\_start\_wait\_urb(struct urb \*urb, int timeout,+ unsigned int \*actlen)+{+ DECLARE\_COMPLETION\_ONSTACK(ctx);+ unsigned long expire;+ int rc;++ urb->context = &ctx;+ urb->complete = usbfs\_blocking\_completion;+ \*actlen = 0;+ rc = usb\_submit\_urb(urb, GFP\_KERNEL);+ if (unlikely(rc))+ return rc;++ expire = (timeout ? msecs\_to\_jiffies(timeout) : MAX\_SCHEDULE\_TIMEOUT);+ rc = wait\_for\_completion\_killable\_timeout(&ctx, expire);+ if (rc <= 0) {+ usb\_kill\_urb(urb);+ \*actlen = urb->actual\_length;+ if (urb->status != -ENOENT)+ ; /\* Completed before it was killed \*/+ else if (rc < 0)+ return -EINTR;+ else+ return -ETIMEDOUT;+ }+ \*actlen = urb->actual\_length;+ return urb->status;+}+ static int do\_proc\_control(struct usb\_dev\_state \*ps, struct usbdevfs\_ctrltransfer \*ctrl) { struct usb\_device \*dev = ps->dev; unsigned int tmo; unsigned char \*tbuf;- unsigned wLength;+ unsigned int wLength, actlen; int i, pipe, ret;+ struct urb \*urb = NULL;+ struct usb\_ctrlrequest \*dr = NULL;  ret = check\_ctrlrecip(ps, ctrl->bRequestType, ctrl->bRequest, ctrl->wIndex);@@ -1122,51 +1164,63 @@ static int do\_proc\_control(struct usb\_dev\_state \*ps, sizeof(struct usb\_ctrlrequest)); if (ret) return ret;++ ret = -ENOMEM; tbuf = (unsigned char \*)\_\_get\_free\_page(GFP\_KERNEL);- if (!tbuf) {- ret = -ENOMEM;+ if (!tbuf) goto done;- }+ urb = usb\_alloc\_urb(0, GFP\_NOIO);+ if (!urb)+ goto done;+ dr = kmalloc(sizeof(struct usb\_ctrlrequest), GFP\_NOIO);+ if (!dr)+ goto done;++ dr->bRequestType = ctrl->bRequestType;+ dr->bRequest = ctrl->bRequest;+ dr->wValue = cpu\_to\_le16(ctrl->wValue);+ dr->wIndex = cpu\_to\_le16(ctrl->wIndex);+ dr->wLength = cpu\_to\_le16(ctrl->wLength);+ tmo = ctrl->timeout; snoop(&dev->dev, "control urb: bRequestType=%02x " "bRequest=%02x wValue=%04x " "wIndex=%04x wLength=%04x\n", ctrl->bRequestType, ctrl->bRequest, ctrl->wValue, ctrl->wIndex, ctrl->wLength);- if ((ctrl->bRequestType & USB\_DIR\_IN) && ctrl->wLength) {++ if ((ctrl->bRequestType & USB\_DIR\_IN) && wLength) { pipe = usb\_rcvctrlpipe(dev, 0);- snoop\_urb(dev, NULL, pipe, ctrl->wLength, tmo, SUBMIT, NULL, 0);+ usb\_fill\_control\_urb(urb, dev, pipe, (unsigned char \*) dr, tbuf,+ wLength, NULL, NULL);+ snoop\_urb(dev, NULL, pipe, wLength, tmo, SUBMIT, NULL, 0);  usb\_unlock\_device(dev);- i = usb\_control\_msg(dev, pipe, ctrl->bRequest,- ctrl->bRequestType, ctrl->wValue, ctrl->wIndex,- tbuf, ctrl->wLength, tmo);+ i = usbfs\_start\_wait\_urb(urb, tmo, &actlen); usb\_lock\_device(dev);- snoop\_urb(dev, NULL, pipe, max(i, 0), min(i, 0), COMPLETE,- tbuf, max(i, 0));- if ((i > 0) && ctrl->wLength) {- if (copy\_to\_user(ctrl->data, tbuf, i)) {+ snoop\_urb(dev, NULL, pipe, actlen, i, COMPLETE, tbuf, actlen);+ if (!i && actlen) {+ if (copy\_to\_user(ctrl->data, tbuf, actlen)) { ret = -EFAULT;- goto done;+ goto recv\_fault; } } } else {- if (ctrl->wLength) {- if (copy\_from\_user(tbuf, ctrl->data, ctrl->wLength)) {+ if (wLength) {+ if (copy\_from\_user(tbuf, ctrl->data, wLength)) { ret = -EFAULT; goto done; } } pipe = usb\_sndctrlpipe(dev, 0);- snoop\_urb(dev, NULL, pipe, ctrl->wLength, tmo, SUBMIT,- tbuf, ctrl->wLength);+ usb\_fill\_control\_urb(urb, dev, pipe, (unsigned char \*) dr, tbuf,+ wLength, NULL, NULL);+ snoop\_urb(dev, NULL, pipe, wLength, tmo, SUBMIT, tbuf, wLength);  usb\_unlock\_device(dev);- i = usb\_control\_msg(dev, pipe, ctrl->bRequest,- ctrl->bRequestType, ctrl->wValue, ctrl->wIndex,- tbuf, ctrl->wLength, tmo);+ i = usbfs\_start\_wait\_urb(urb, tmo, &actlen); usb\_lock\_device(dev);- snoop\_urb(dev, NULL, pipe, max(i, 0), min(i, 0), COMPLETE, NULL, 0);+ snoop\_urb(dev, NULL, pipe, actlen, i, COMPLETE, NULL, 0); } if (i < 0 && i != -EPIPE) { dev\_printk(KERN\_DEBUG, &dev->dev, "usbfs: USBDEVFS\_CONTROL "@@ -1174,8 +1228,15 @@ static int do\_proc\_control(struct usb\_dev\_state \*ps, current->comm, ctrl->bRequestType, ctrl->bRequest, ctrl->wLength, i); }- ret = i;+ ret = (i < 0 ? i : actlen);++ recv\_fault:+ /\* Linger a bit, prior to the next control message. \*/+ if (dev->quirks & USB\_QUIRK\_DELAY\_CTRL\_MSG)+ msleep(200); done:+ kfree(dr);+ usb\_free\_urb(urb); free\_page((unsigned long) tbuf); usbfs\_decrease\_memory\_usage(PAGE\_SIZE + sizeof(struct urb) + sizeof(struct usb\_ctrlrequest));@@ -1195,10 +1256,11 @@ static int do\_proc\_bulk(struct usb\_dev\_state \*ps, struct usbdevfs\_bulktransfer \*bulk) { struct usb\_device \*dev = ps->dev;- unsigned int tmo, len1, pipe;- int len2;+ unsigned int tmo, len1, len2, pipe; unsigned char \*tbuf; int i, ret;+ struct urb \*urb = NULL;+ struct usb\_host\_endpoint \*ep;  ret = findintfep(ps->dev, bulk->ep); if (ret < 0)@@ -1206,14 +1268,17 @@ static int do\_proc\_bulk(struct usb\_dev\_state \*ps, ret = checkintf(ps, ret); if (ret) return ret;++ len1 = bulk->len;+ if (len1 < 0 || len1 >= (INT\_MAX - sizeof(struct urb)))+ return -EINVAL;+ if (bulk->ep & USB\_DIR\_IN) pipe = usb\_rcvbulkpipe(dev, bulk->ep & 0x7f); else pipe = usb\_sndbulkpipe(dev, bulk->ep & 0x7f);- if (!usb\_maxpacket(dev, pipe, !(bulk->ep & USB\_DIR\_IN)))- return -EINVAL;- len1 = bulk->len;- if (len1 >= (INT\_MAX - sizeof(struct urb)))+ ep = usb\_pipe\_endpoint(dev, pipe);+ if (!ep || !usb\_endpoint\_maxp(&ep->desc)) return -EINVAL; ret = usbfs\_increase\_memory\_usage(len1 + sizeof(struct urb)); if (ret)@@ -1223,17 +1288,29 @@ static int do\_proc\_bulk(struct usb\_dev\_state \*ps, \* len1 can be almost arbitrarily large. Don't WARN if it's \* too big, just fail the request. \*/+ ret = -ENOMEM; tbuf = kmalloc(len1, GFP\_KERNEL | \_\_GFP\_NOWARN);- if (!tbuf) {- ret = -ENOMEM;+ if (!tbuf)+ goto done;+ urb = usb\_alloc\_urb(0, GFP\_KERNEL);+ if (!urb) goto done;++ if ((ep->desc.bmAttributes & USB\_ENDPOINT\_XFERTYPE\_MASK) ==+ USB\_ENDPOINT\_XFER\_INT) {+ pipe = (pipe & ~(3 << 30)) | (PIPE\_INTERRUPT << 30);+ usb\_fill\_int\_urb(urb, dev, pipe, tbuf, len1,+ NULL, NULL, ep->desc.bInterval);+ } else {+ usb\_fill\_bulk\_urb(urb, dev, pipe, tbuf, len1, NULL, NULL); }+ tmo = bulk->timeout; if (bulk->ep & 0x80) { snoop\_urb(dev, NULL, pipe, len1, tmo, SUBMIT, NULL, 0);  usb\_unlock\_device(dev);- i = usb\_bulk\_msg(dev, pipe, tbuf, len1, &len2, tmo);+ i = usbfs\_start\_wait\_urb(urb, tmo, &len2); usb\_lock\_device(dev); snoop\_urb(dev, NULL, pipe, len2, i, COMPLETE, tbuf, len2); @@ -1253,12 +1330,13 @@ static int do\_proc\_bulk(struct usb\_dev\_state \*ps, snoop\_urb(dev, NULL, pipe, len1, tmo, SUBMIT, tbuf, len1);  usb\_unlock\_device(dev);- i = usb\_bulk\_msg(dev, pipe, tbuf, len1, &len2, tmo);+ i = usbfs\_start\_wait\_urb(urb, tmo, &len2); usb\_lock\_device(dev); snoop\_urb(dev, NULL, pipe, len2, i, COMPLETE, NULL, 0); } ret = (i < 0 ? i : len2); done:+ usb\_free\_urb(urb); kfree(tbuf); usbfs\_decrease\_memory\_usage(len1 + sizeof(struct urb)); return ret; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 21:20:13 +0000

