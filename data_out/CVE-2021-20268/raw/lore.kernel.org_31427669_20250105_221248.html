<html><head><title>[PATCH] bpf: Fix integer overflow in argument calculation for bpf_map_area_alloc</title><link
rel=alternate
title="Atom feed"
href="../../new.atom"
type="application/atom+xml"/><style>pre{white-space:pre-wrap}*{font-size:100%;font-family:monospace}</style><link
type=text/css
rel=stylesheet
href=../../216light.css?66c655cb
media=screen,print /><link
type=text/css
rel=stylesheet
media="screen and (prefers-color-scheme:dark)"
href=../../216dark.css?66c655cb /></head><body><form
action="../../"><pre><a
href="../../?t=20210517162756"><b>bpf.vger.kernel.org archive mirror</b></a>
<input
name=q
type=text /><input
type=submit
value=search /> <a
href="../../_/text/help/">help</a> / <a
href="../../_/text/color/">color</a> / <a
id=mirror
href="../../_/text/mirror/">mirror</a> / <a
href="../../new.atom">Atom feed</a></pre></form><pre><a
href=#e8929643e99bea9c18ed490a7bc2591145eac6444
id=m8929643e99bea9c18ed490a7bc2591145eac6444>*</a> <b>[PATCH] bpf: Fix integer overflow in argument calculation for bpf_map_area_alloc</b>
<b>@ 2021-01-26  8:26 Bui Quang Minh</b>
  2021-01-26  9:36 ` <a
href="#m2600e88728f9fea79ae6afb7bdfed1411be56870">Lorenz Bauer</a>
  <a
href=#r8929643e99bea9c18ed490a7bc2591145eac6444>0 siblings, 1 reply; 6+ messages in thread</a>
From: Bui Quang Minh @ 2021-01-26  8:26 UTC (<a
href="../../20210126082606.3183-1-minhquangbui99@gmail.com/">permalink</a> / <a
href="../../20210126082606.3183-1-minhquangbui99@gmail.com/raw">raw</a>)
  To: ast, daniel, davem, kuba, hawk, john.fastabend, andrii, kafai,
	songliubraving, yhs, kpsingh, jakub, lmb
  Cc: <a
href="../../../netdev/?t=20210126163919">netdev</a>, <a
href="../../../bpf/?t=20210126163919">bpf</a>, <a
href="../../../lkml/?t=20210126163919">linux-kernel</a>, minhquangbui99

In 32-bit architecture, the result of sizeof() is a 32-bit integer so
the expression becomes the multiplication between 2 32-bit integer which
can potentially leads to integer overflow. As a result,
bpf_map_area_alloc() allocates less memory than needed.

Fix this by casting 1 operand to u64.

Signed-off-by: Bui Quang Minh &lt;minhquangbui99@gmail.com&gt;
---
 <a
id=iZ2e.:..:20210126082606.3183-1-minhquangbui99::40gmail.com:1kernel:bpf:devmap.c
href=#Z2e.:..:20210126082606.3183-1-minhquangbui99::40gmail.com:1kernel:bpf:devmap.c>kernel/bpf/devmap.c</a> | 4 ++--
 <a
id=iZ2e.:..:20210126082606.3183-1-minhquangbui99::40gmail.com:1net:core:sock_map.c
href=#Z2e.:..:20210126082606.3183-1-minhquangbui99::40gmail.com:1net:core:sock_map.c>net/core/sock_map.c</a> | 2 +-
 2 files <a href="#e8929643e99bea9c18ed490a7bc2591145eac6444">changed</a>, 3 insertions(+), 3 deletions(-)

<span
class="head"><a
href=#iZ2e.:..:20210126082606.3183-1-minhquangbui99::40gmail.com:1kernel:bpf:devmap.c
id=Z2e.:..:20210126082606.3183-1-minhquangbui99::40gmail.com:1kernel:bpf:devmap.c>diff</a> --git a/kernel/bpf/devmap.c b/kernel/bpf/devmap.c
index f6e9c68afdd4..e849c3e8a49f 100644
--- a/kernel/bpf/devmap.c
+++ b/kernel/bpf/devmap.c
</span><span
class="hunk">@@ -92,7 +92,7 @@ static struct hlist_head *dev_map_create_hash(unsigned int entries,
</span> 	int i;
 	struct hlist_head *hash;
 
<span
class="del">-	hash = bpf_map_area_alloc(entries * sizeof(*hash), numa_node);
</span><span
class="add">+	hash = bpf_map_area_alloc((u64) entries * sizeof(*hash), numa_node);
</span> 	if (hash != NULL)
 		for (i = 0; i &lt; entries; i++)
 			INIT_HLIST_HEAD(&#38;hash[i]);
<span
class="hunk">@@ -143,7 +143,7 @@ static int dev_map_init_map(struct bpf_dtab *dtab, union bpf_attr *attr)
</span> 
 		spin_lock_init(&#38;dtab-&gt;index_lock);
 	} else {
<span
class="del">-		dtab-&gt;netdev_map = bpf_map_area_alloc(dtab-&gt;map.max_entries *
</span><span
class="add">+		dtab-&gt;netdev_map = bpf_map_area_alloc((u64) dtab-&gt;map.max_entries *
</span> 						      sizeof(struct bpf_dtab_netdev *),
 						      dtab-&gt;map.numa_node);
 		if (!dtab-&gt;netdev_map)
<span
class="head"><a
href=#iZ2e.:..:20210126082606.3183-1-minhquangbui99::40gmail.com:1net:core:sock_map.c
id=Z2e.:..:20210126082606.3183-1-minhquangbui99::40gmail.com:1net:core:sock_map.c>diff</a> --git a/net/core/sock_map.c b/net/core/sock_map.c
index 64b5ec14ff50..7a42016a981d 100644
--- a/net/core/sock_map.c
+++ b/net/core/sock_map.c
</span><span
class="hunk">@@ -44,7 +44,7 @@ static struct bpf_map *sock_map_alloc(union bpf_attr *attr)
</span> 	bpf_map_init_from_attr(&#38;stab-&gt;map, attr);
 	raw_spin_lock_init(&#38;stab-&gt;lock);
 
<span
class="del">-	stab-&gt;sks = bpf_map_area_alloc(stab-&gt;map.max_entries *
</span><span
class="add">+	stab-&gt;sks = bpf_map_area_alloc((u64) stab-&gt;map.max_entries *
</span> 				       sizeof(struct sock *),
 				       stab-&gt;map.numa_node);
 	if (!stab-&gt;sks) {
-- 
2.17.1


<a
href=#m8929643e99bea9c18ed490a7bc2591145eac6444
id=e8929643e99bea9c18ed490a7bc2591145eac6444>^</a> <a
href="../../20210126082606.3183-1-minhquangbui99@gmail.com/">permalink</a> <a
href="../../20210126082606.3183-1-minhquangbui99@gmail.com/raw">raw</a> <a
href="../../20210126082606.3183-1-minhquangbui99@gmail.com/#R">reply</a> <a
href="../../20210126082606.3183-1-minhquangbui99@gmail.com/#related">related</a>	[<a
href="../../20210126082606.3183-1-minhquangbui99@gmail.com/T/#u"><b>flat</b></a>|<a
href="../../20210126082606.3183-1-minhquangbui99@gmail.com/t/#u">nested</a>] <a
href=#r8929643e99bea9c18ed490a7bc2591145eac6444>6+ messages in thread</a></pre><hr><pre><a
href=#e2600e88728f9fea79ae6afb7bdfed1411be56870
id=m2600e88728f9fea79ae6afb7bdfed1411be56870>*</a> <u
id=u><b>Re: [PATCH] bpf: Fix integer overflow in argument calculation for bpf_map_area_alloc</b></u>
  2021-01-26  8:26 <a
href="#m8929643e99bea9c18ed490a7bc2591145eac6444">[PATCH] bpf: Fix integer overflow in argument calculation for bpf_map_area_alloc</a> Bui Quang Minh
<b>@ 2021-01-26  9:36 ` Lorenz Bauer</b>
  2021-01-27  4:23   ` <a
href="#mb8348d16dd76a73108dbb2eb84aed227d86613ef">Bui Quang Minh</a>
  <a
href=#r2600e88728f9fea79ae6afb7bdfed1411be56870>0 siblings, 1 reply; 6+ messages in thread</a>
From: Lorenz Bauer @ 2021-01-26  9:36 UTC (<a
href="../../CACAyw99bEYWJCSGqfLiJ9Jp5YE1ZsZSiJxb4RFUTwbofipf0dA@mail.gmail.com/">permalink</a> / <a
href="../../CACAyw99bEYWJCSGqfLiJ9Jp5YE1ZsZSiJxb4RFUTwbofipf0dA@mail.gmail.com/raw">raw</a>)
  To: Bui Quang Minh
  Cc: Alexei Starovoitov, Daniel Borkmann, David S . Miller,
	Jakub Kicinski, hawk, John Fastabend, Andrii Nakryiko, Martin Lau,
	Song Liu, Yonghong Song, kpsingh, Jakub Sitnicki, <a
href="../../../netdev/?t=20210126145256">Networking</a>, <a
href="../../../bpf/?t=20210126145256">bpf</a>,
	<a
href="../../../lkml/?t=20210126145256">LKML</a>

On Tue, 26 Jan 2021 at 08:26, Bui Quang Minh &lt;minhquangbui99@gmail.com&gt; wrote:
<span
class="q">&gt;
&gt; In 32-bit architecture, the result of sizeof() is a 32-bit integer so
&gt; the expression becomes the multiplication between 2 32-bit integer which
&gt; can potentially leads to integer overflow. As a result,
&gt; bpf_map_area_alloc() allocates less memory than needed.
&gt;
&gt; Fix this by casting 1 operand to u64.
</span>
Some quick thoughts:
* Should this have a Fixes tag?
* Seems like there are quite a few similar calls scattered around
(cpumap, etc.). Did you audit these as well?
* I&#39;d prefer a calloc style version of bpf_map_area_alloc although
that might conflict with Fixes tag.

Lorenz

-- 
Lorenz Bauer  |  Systems Engineer
6th Floor, County Hall/The Riverside Building, SE1 7PB, UK

www.cloudflare.com

<a
href=#m2600e88728f9fea79ae6afb7bdfed1411be56870
id=e2600e88728f9fea79ae6afb7bdfed1411be56870>^</a> <a
href="../../CACAyw99bEYWJCSGqfLiJ9Jp5YE1ZsZSiJxb4RFUTwbofipf0dA@mail.gmail.com/">permalink</a> <a
href="../../CACAyw99bEYWJCSGqfLiJ9Jp5YE1ZsZSiJxb4RFUTwbofipf0dA@mail.gmail.com/raw">raw</a> <a
href="../../CACAyw99bEYWJCSGqfLiJ9Jp5YE1ZsZSiJxb4RFUTwbofipf0dA@mail.gmail.com/#R">reply</a>	[<a
href="../../CACAyw99bEYWJCSGqfLiJ9Jp5YE1ZsZSiJxb4RFUTwbofipf0dA@mail.gmail.com/T/#u"><b>flat</b></a>|<a
href="../../CACAyw99bEYWJCSGqfLiJ9Jp5YE1ZsZSiJxb4RFUTwbofipf0dA@mail.gmail.com/t/#u">nested</a>] <a
href=#r2600e88728f9fea79ae6afb7bdfed1411be56870>6+ messages in thread</a></pre><hr><pre><a
href=#eb8348d16dd76a73108dbb2eb84aed227d86613ef
id=mb8348d16dd76a73108dbb2eb84aed227d86613ef>*</a> <b>Re: [PATCH] bpf: Fix integer overflow in argument calculation for bpf_map_area_alloc</b>
  2021-01-26  9:36 ` <a
href="#m2600e88728f9fea79ae6afb7bdfed1411be56870">Lorenz Bauer</a>
<b>@ 2021-01-27  4:23   ` Bui Quang Minh</b>
  2021-01-27  5:09     ` <a
href="#mee48b3d547541f5e505f3eeb4d482090006b84f4">Bui Quang Minh</a>
  2021-01-28  0:41     ` <a
href="#m3aeaaee6369efd8401f187e268d25de4cb9c2b01">Daniel Borkmann</a>
  <a
href=#rb8348d16dd76a73108dbb2eb84aed227d86613ef>0 siblings, 2 replies; 6+ messages in thread</a>
From: Bui Quang Minh @ 2021-01-27  4:23 UTC (<a
href="../../20210127042341.GA4948@ubuntu/">permalink</a> / <a
href="../../20210127042341.GA4948@ubuntu/raw">raw</a>)
  To: Lorenz Bauer
  Cc: Alexei Starovoitov, Daniel Borkmann, David S . Miller,
	Jakub Kicinski, hawk, John Fastabend, Andrii Nakryiko, Martin Lau,
	Song Liu, Yonghong Song, kpsingh, Jakub Sitnicki, <a
href="../../../netdev/?t=20210127054759">Networking</a>, <a
href="../../../bpf/?t=20210127054759">bpf</a>,
	<a
href="../../../lkml/?t=20210127054759">LKML</a>

On Tue, Jan 26, 2021 at 09:36:57AM +0000, Lorenz Bauer wrote:
<span
class="q">&gt; On Tue, 26 Jan 2021 at 08:26, Bui Quang Minh &lt;minhquangbui99@gmail.com&gt; wrote:
&gt; &gt;
&gt; &gt; In 32-bit architecture, the result of sizeof() is a 32-bit integer so
&gt; &gt; the expression becomes the multiplication between 2 32-bit integer which
&gt; &gt; can potentially leads to integer overflow. As a result,
&gt; &gt; bpf_map_area_alloc() allocates less memory than needed.
&gt; &gt;
&gt; &gt; Fix this by casting 1 operand to u64.
&gt; 
&gt; Some quick thoughts:
&gt; * Should this have a Fixes tag?
</span>
Ok, I will add Fixes tag in later version patch.

<span
class="q">&gt; * Seems like there are quite a few similar calls scattered around
&gt; (cpumap, etc.). Did you audit these as well?
</span>
I spotted another bug after re-auditting. In hashtab, there ares 2 places using
the same calls

	static struct bpf_map *htab_map_alloc(union bpf_attr *attr)
	{
		/* ... snip ... */
		if (htab-&gt;n_buckets == 0 ||
		    htab-&gt;n_buckets &gt; U32_MAX / sizeof(struct bucket))
			goto free_htab;

		htab-&gt;buckets = bpf_map_area_alloc(htab-&gt;n_buckets *
						   sizeof(struct bucket),
						   htab-&gt;map.numa_node);
	}

This is safe because of the above check.

	static int prealloc_init(struct bpf_htab *htab)
	{
		u32 num_entries = htab-&gt;map.max_entries;
		htab-&gt;elems = bpf_map_area_alloc(htab-&gt;elem_size * num_entries,
						 htab-&gt;map.numa_node);
	}

This is not safe since there is no limit check in elem_size.

In cpumap,

	static struct bpf_map *cpu_map_alloc(union bpf_attr *attr)
	{
		cmap-&gt;cpu_map = bpf_map_area_alloc(cmap-&gt;map.max_entries *
						   sizeof(struct bpf_cpu_map_entry *),
						   cmap-&gt;map.numa_node);
	}

I think this is safe because max_entries is not permitted to be larger than NR_CPUS.

In stackmap, there is a place that I&#39;m not very sure about

	static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)
	{
		u32 elem_size = sizeof(struct stack_map_bucket) + smap-&gt;map.value_size;
		smap-&gt;elems = bpf_map_area_alloc(elem_size * smap-&gt;map.max_entries,
						 smap-&gt;map.numa_node);
	}

This is called after another bpf_map_area_alloc in stack_map_alloc(). In the first
bpf_map_area_alloc() the argument is calculated in an u64 variable; so if in the second
one, there is an integer overflow then the first one must be called with size &gt; 4GB. I 
think the first one will probably fail (I am not sure about the actual limit of vmalloc()),
so the second one might not be called.

Overall, I think it is error prone in this pattern, maybe we should use typecasting in all
similar calls or make a comment why we don&#39;t use typecasting. As I see typecasting is not so
expensive and we can typecast the sizeof() operand so this change only affect 32-bit
architecture.

<span
class="q">&gt; * I&#39;d prefer a calloc style version of bpf_map_area_alloc although
&gt; that might conflict with Fixes tag.
</span>
Yes, I think the calloc style will prevent this kind of integer overflow bug.

Thank you,
Quang Minh.


<a
href=#mb8348d16dd76a73108dbb2eb84aed227d86613ef
id=eb8348d16dd76a73108dbb2eb84aed227d86613ef>^</a> <a
href="../../20210127042341.GA4948@ubuntu/">permalink</a> <a
href="../../20210127042341.GA4948@ubuntu/raw">raw</a> <a
href="../../20210127042341.GA4948@ubuntu/#R">reply</a>	[<a
href="../../20210127042341.GA4948@ubuntu/T/#u"><b>flat</b></a>|<a
href="../../20210127042341.GA4948@ubuntu/t/#u">nested</a>] <a
href=#rb8348d16dd76a73108dbb2eb84aed227d86613ef>6+ messages in thread</a></pre><hr><pre><a
href=#eee48b3d547541f5e505f3eeb4d482090006b84f4
id=mee48b3d547541f5e505f3eeb4d482090006b84f4>*</a> <b>Re: [PATCH] bpf: Fix integer overflow in argument calculation for bpf_map_area_alloc</b>
  2021-01-27  4:23   ` <a
href="#mb8348d16dd76a73108dbb2eb84aed227d86613ef">Bui Quang Minh</a>
<b>@ 2021-01-27  5:09     ` Bui Quang Minh</b>
  2021-01-28  0:41     ` <a
href="#m3aeaaee6369efd8401f187e268d25de4cb9c2b01">Daniel Borkmann</a>
  <a
href=#ree48b3d547541f5e505f3eeb4d482090006b84f4>1 sibling, 0 replies; 6+ messages in thread</a>
From: Bui Quang Minh @ 2021-01-27  5:09 UTC (<a
href="../../20210127050937.GA5418@ubuntu/">permalink</a> / <a
href="../../20210127050937.GA5418@ubuntu/raw">raw</a>)
  To: Lorenz Bauer
  Cc: Alexei Starovoitov, Daniel Borkmann, David S . Miller,
	Jakub Kicinski, hawk, John Fastabend, Andrii Nakryiko, Martin Lau,
	Song Liu, Yonghong Song, kpsingh, Jakub Sitnicki, <a
href="../../../netdev/?t=20210127054805">Networking</a>, <a
href="../../../bpf/?t=20210127054805">bpf</a>,
	<a
href="../../../lkml/?t=20210127054805">LKML</a>

On Wed, Jan 27, 2021 at 11:23:41AM +0700, Bui Quang Minh wrote:
<span
class="q">&gt; &gt; * Seems like there are quite a few similar calls scattered around
&gt; &gt; (cpumap, etc.). Did you audit these as well?
&gt; 
&gt; I spotted another bug after re-auditting. In hashtab, there ares 2 places using
&gt; the same calls
&gt; 
&gt; 	static struct bpf_map *htab_map_alloc(union bpf_attr *attr)
&gt; 	{
&gt; 		/* ... snip ... */
&gt; 		if (htab-&gt;n_buckets == 0 ||
&gt; 		    htab-&gt;n_buckets &gt; U32_MAX / sizeof(struct bucket))
&gt; 			goto free_htab;
&gt; 
&gt; 		htab-&gt;buckets = bpf_map_area_alloc(htab-&gt;n_buckets *
&gt; 						   sizeof(struct bucket),
&gt; 						   htab-&gt;map.numa_node);
&gt; 	}
&gt; 
&gt; This is safe because of the above check.
&gt; 
&gt; 	static int prealloc_init(struct bpf_htab *htab)
&gt; 	{
&gt; 		u32 num_entries = htab-&gt;map.max_entries;
&gt; 		htab-&gt;elems = bpf_map_area_alloc(htab-&gt;elem_size * num_entries,
&gt; 						 htab-&gt;map.numa_node);
&gt; 	}
&gt; 
&gt; This is not safe since there is no limit check in elem_size.
</span>
So sorry but I rechecked and saw this bug in hashtab has been fixed with commit
e1868b9e36d0ca

Thank you,
Quang Minh.

<a
href=#mee48b3d547541f5e505f3eeb4d482090006b84f4
id=eee48b3d547541f5e505f3eeb4d482090006b84f4>^</a> <a
href="../../20210127050937.GA5418@ubuntu/">permalink</a> <a
href="../../20210127050937.GA5418@ubuntu/raw">raw</a> <a
href="../../20210127050937.GA5418@ubuntu/#R">reply</a>	[<a
href="../../20210127050937.GA5418@ubuntu/T/#u"><b>flat</b></a>|<a
href="../../20210127050937.GA5418@ubuntu/t/#u">nested</a>] <a
href=#ree48b3d547541f5e505f3eeb4d482090006b84f4>6+ messages in thread</a></pre><hr><pre><a
href=#e3aeaaee6369efd8401f187e268d25de4cb9c2b01
id=m3aeaaee6369efd8401f187e268d25de4cb9c2b01>*</a> <b>Re: [PATCH] bpf: Fix integer overflow in argument calculation for bpf_map_area_alloc</b>
  2021-01-27  4:23   ` <a
href="#mb8348d16dd76a73108dbb2eb84aed227d86613ef">Bui Quang Minh</a>
  2021-01-27  5:09     ` <a
href="#mee48b3d547541f5e505f3eeb4d482090006b84f4">Bui Quang Minh</a>
<b>@ 2021-01-28  0:41     ` Daniel Borkmann</b>
  2021-05-17 15:10       ` <a
href="#ma3352959e39c5db0c88efde596a0a2945b67a122">Bui Quang Minh</a>
  <a
href=#r3aeaaee6369efd8401f187e268d25de4cb9c2b01>1 sibling, 1 reply; 6+ messages in thread</a>
From: Daniel Borkmann @ 2021-01-28  0:41 UTC (<a
href="../../f4d20d92-2370-a8d3-d56c-408819a5f7f4@iogearbox.net/">permalink</a> / <a
href="../../f4d20d92-2370-a8d3-d56c-408819a5f7f4@iogearbox.net/raw">raw</a>)
  To: Bui Quang Minh, Lorenz Bauer
  Cc: Alexei Starovoitov, David S . Miller, Jakub Kicinski, hawk,
	John Fastabend, Andrii Nakryiko, Martin Lau, Song Liu,
	Yonghong Song, kpsingh, Jakub Sitnicki, <a
href="../../../netdev/?t=20210128004257">Networking</a>, <a
href="../../../bpf/?t=20210128004257">bpf</a>, <a
href="../../../lkml/?t=20210128004257">LKML</a>

On 1/27/21 5:23 AM, Bui Quang Minh wrote:
<span
class="q">&gt; On Tue, Jan 26, 2021 at 09:36:57AM +0000, Lorenz Bauer wrote:
&gt;&gt; On Tue, 26 Jan 2021 at 08:26, Bui Quang Minh &lt;minhquangbui99@gmail.com&gt; wrote:
&gt;&gt;&gt;
&gt;&gt;&gt; In 32-bit architecture, the result of sizeof() is a 32-bit integer so
&gt;&gt;&gt; the expression becomes the multiplication between 2 32-bit integer which
&gt;&gt;&gt; can potentially leads to integer overflow. As a result,
&gt;&gt;&gt; bpf_map_area_alloc() allocates less memory than needed.
&gt;&gt;&gt;
&gt;&gt;&gt; Fix this by casting 1 operand to u64.
&gt;&gt;
&gt;&gt; Some quick thoughts:
&gt;&gt; * Should this have a Fixes tag?
&gt; 
&gt; Ok, I will add Fixes tag in later version patch.
&gt; 
&gt;&gt; * Seems like there are quite a few similar calls scattered around
&gt;&gt; (cpumap, etc.). Did you audit these as well?
&gt; 
</span>[...]
<span
class="q">&gt; In cpumap,
&gt; 
&gt; 	static struct bpf_map *cpu_map_alloc(union bpf_attr *attr)
&gt; 	{
&gt; 		cmap-&gt;cpu_map = bpf_map_area_alloc(cmap-&gt;map.max_entries *
&gt; 						   sizeof(struct bpf_cpu_map_entry *),
&gt; 						   cmap-&gt;map.numa_node);
&gt; 	}
&gt; 
&gt; I think this is safe because max_entries is not permitted to be larger than NR_CPUS.
</span>
Yes.

<span
class="q">&gt; In stackmap, there is a place that I&#39;m not very sure about
&gt; 
&gt; 	static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)
&gt; 	{
&gt; 		u32 elem_size = sizeof(struct stack_map_bucket) + smap-&gt;map.value_size;
&gt; 		smap-&gt;elems = bpf_map_area_alloc(elem_size * smap-&gt;map.max_entries,
&gt; 						 smap-&gt;map.numa_node);
&gt; 	}
&gt; 
&gt; This is called after another bpf_map_area_alloc in stack_map_alloc(). In the first
&gt; bpf_map_area_alloc() the argument is calculated in an u64 variable; so if in the second
&gt; one, there is an integer overflow then the first one must be called with size &gt; 4GB. I
&gt; think the first one will probably fail (I am not sure about the actual limit of vmalloc()),
&gt; so the second one might not be called.
</span>
I would sanity check this as well. Looks like k*alloc()/v*alloc() call sites typically
use array_size() which returns SIZE_MAX on overflow, 610b15c50e86 (&#34;overflow.h: Add
allocation size calculation helpers&#34;).

Thanks,
Daniel

<a
href=#m3aeaaee6369efd8401f187e268d25de4cb9c2b01
id=e3aeaaee6369efd8401f187e268d25de4cb9c2b01>^</a> <a
href="../../f4d20d92-2370-a8d3-d56c-408819a5f7f4@iogearbox.net/">permalink</a> <a
href="../../f4d20d92-2370-a8d3-d56c-408819a5f7f4@iogearbox.net/raw">raw</a> <a
href="../../f4d20d92-2370-a8d3-d56c-408819a5f7f4@iogearbox.net/#R">reply</a>	[<a
href="../../f4d20d92-2370-a8d3-d56c-408819a5f7f4@iogearbox.net/T/#u"><b>flat</b></a>|<a
href="../../f4d20d92-2370-a8d3-d56c-408819a5f7f4@iogearbox.net/t/#u">nested</a>] <a
href=#r3aeaaee6369efd8401f187e268d25de4cb9c2b01>6+ messages in thread</a></pre><hr><pre><a
href=#ea3352959e39c5db0c88efde596a0a2945b67a122
id=ma3352959e39c5db0c88efde596a0a2945b67a122>*</a> <b>Re: [PATCH] bpf: Fix integer overflow in argument calculation for bpf_map_area_alloc</b>
  2021-01-28  0:41     ` <a
href="#m3aeaaee6369efd8401f187e268d25de4cb9c2b01">Daniel Borkmann</a>
<b>@ 2021-05-17 15:10       ` Bui Quang Minh</b>
  <a
href=#ra3352959e39c5db0c88efde596a0a2945b67a122>0 siblings, 0 replies; 6+ messages in thread</a>
From: Bui Quang Minh @ 2021-05-17 15:10 UTC (<a
href="../../728b238e-a481-eb50-98e9-b0f430ab01e7@gmail.com/">permalink</a> / <a
href="../../728b238e-a481-eb50-98e9-b0f430ab01e7@gmail.com/raw">raw</a>)
  To: Daniel Borkmann, Lorenz Bauer
  Cc: Alexei Starovoitov, David S . Miller, Jakub Kicinski, hawk,
	John Fastabend, Andrii Nakryiko, Martin Lau, Song Liu,
	Yonghong Song, kpsingh, Jakub Sitnicki, <a
href="../../../netdev/?t=20210517162756">Networking</a>, <a
href="../../../bpf/?t=20210517162756">bpf</a>, <a
href="../../../lkml/?t=20210517162756">LKML</a>

On 1/28/21 7:41 AM, Daniel Borkmann wrote:
<span
class="q">&gt; On 1/27/21 5:23 AM, Bui Quang Minh wrote:
&gt;&gt; On Tue, Jan 26, 2021 at 09:36:57AM +0000, Lorenz Bauer wrote:
&gt;&gt;&gt; On Tue, 26 Jan 2021 at 08:26, Bui Quang Minh 
&gt;&gt;&gt; &lt;minhquangbui99@gmail.com&gt; wrote:
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; In 32-bit architecture, the result of sizeof() is a 32-bit integer so
&gt;&gt;&gt;&gt; the expression becomes the multiplication between 2 32-bit integer 
&gt;&gt;&gt;&gt; which
&gt;&gt;&gt;&gt; can potentially leads to integer overflow. As a result,
&gt;&gt;&gt;&gt; bpf_map_area_alloc() allocates less memory than needed.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; Fix this by casting 1 operand to u64.
&gt;&gt;&gt;
&gt;&gt;&gt; Some quick thoughts:
&gt;&gt;&gt; * Should this have a Fixes tag?
&gt;&gt;
&gt;&gt; Ok, I will add Fixes tag in later version patch.
&gt;&gt;
&gt;&gt;&gt; * Seems like there are quite a few similar calls scattered around
&gt;&gt;&gt; (cpumap, etc.). Did you audit these as well?
&gt;&gt;
&gt; [...]
&gt;&gt; In cpumap,
&gt;&gt;
&gt;&gt; &#160;&#160;&#160;&#160;static struct bpf_map *cpu_map_alloc(union bpf_attr *attr)
&gt;&gt; &#160;&#160;&#160;&#160;{
&gt;&gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160; cmap-&gt;cpu_map = bpf_map_area_alloc(cmap-&gt;map.max_entries *
&gt;&gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; sizeof(struct bpf_cpu_map_entry *),
&gt;&gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cmap-&gt;map.numa_node);
&gt;&gt; &#160;&#160;&#160;&#160;}
&gt;&gt;
&gt;&gt; I think this is safe because max_entries is not permitted to be larger 
&gt;&gt; than NR_CPUS.
&gt; 
&gt; Yes.
&gt; 
&gt;&gt; In stackmap, there is a place that I&#39;m not very sure about
&gt;&gt;
&gt;&gt; &#160;&#160;&#160;&#160;static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)
&gt;&gt; &#160;&#160;&#160;&#160;{
&gt;&gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160; u32 elem_size = sizeof(struct stack_map_bucket) + 
&gt;&gt; smap-&gt;map.value_size;
&gt;&gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160; smap-&gt;elems = bpf_map_area_alloc(elem_size * 
&gt;&gt; smap-&gt;map.max_entries,
&gt;&gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; smap-&gt;map.numa_node);
&gt;&gt; &#160;&#160;&#160;&#160;}
&gt;&gt;
&gt;&gt; This is called after another bpf_map_area_alloc in stack_map_alloc(). 
&gt;&gt; In the first
&gt;&gt; bpf_map_area_alloc() the argument is calculated in an u64 variable; so 
&gt;&gt; if in the second
&gt;&gt; one, there is an integer overflow then the first one must be called 
&gt;&gt; with size &gt; 4GB. I
&gt;&gt; think the first one will probably fail (I am not sure about the actual 
&gt;&gt; limit of vmalloc()),
&gt;&gt; so the second one might not be called.
&gt; 
&gt; I would sanity check this as well. Looks like k*alloc()/v*alloc() call 
&gt; sites typically
&gt; use array_size() which returns SIZE_MAX on overflow, 610b15c50e86 
&gt; (&#34;overflow.h: Add
&gt; allocation size calculation helpers&#34;).
</span>
Hi,

I almost forget about this patch, I have checked the bpf_map_area_alloc 
in in stackmap.c and I can see that integer overflow cannot happen in 
this stackmap.c case.

In stack_map_alloc(),

	u64 cost;
	...
	cost = n_buckets * sizeof(struct stack_map_bucket *) + sizeof(*smap);
	cost += n_buckets * (value_size + sizeof(struct stack_map_bucket));
	smap = bpf_map_area_alloc(cost, bpf_map_attr_numa_node(attr)); (1)
	...
	prealloc_elems_and_freelist(smap);

In prealloc_elems_and_freelist(),

	u32 elem_size = sizeof(struct stack_map_bucket) + smap-&gt;map.value_size;
	smap-&gt;elems = bpf_map_area_alloc(elem_size * smap-&gt;map.max_entries, 
smap-&gt;map.numa_node); (2)

Argument calculation at (1) is safe. Argument calculation at (2) can 
potentially result in an integer overflow in 32-bit architecture. 
However, if the integer overflow happens, it means argument at (1) must 
be 2**32, which cannot pass the SIZE_MAX check in __bpf_map_area_alloc()

In __bpf_map_area_alloc()

	if (size &gt;= SIZE_MAX)
		return NULL;

So I think the original patch has fixed instances of this bug pattern.

Thank you,
Quang Minh.

<a
href=#ma3352959e39c5db0c88efde596a0a2945b67a122
id=ea3352959e39c5db0c88efde596a0a2945b67a122>^</a> <a
href="../../728b238e-a481-eb50-98e9-b0f430ab01e7@gmail.com/">permalink</a> <a
href="../../728b238e-a481-eb50-98e9-b0f430ab01e7@gmail.com/raw">raw</a> <a
href="../../728b238e-a481-eb50-98e9-b0f430ab01e7@gmail.com/#R">reply</a>	[<a
href="../../728b238e-a481-eb50-98e9-b0f430ab01e7@gmail.com/T/#u"><b>flat</b></a>|<a
href="../../728b238e-a481-eb50-98e9-b0f430ab01e7@gmail.com/t/#u">nested</a>] <a
href=#ra3352959e39c5db0c88efde596a0a2945b67a122>6+ messages in thread</a></pre><hr><pre>end of thread, other threads:[<a
href="../../?t=20210517162756">~2021-05-17 16:27 UTC</a> | <a
href="../../">newest</a>]

<b
id=t>Thread overview:</b> 6+ messages (download: <a
href="../t.mbox.gz">mbox.gz</a> follow: <a
href="../t.atom">Atom feed</a>
-- links below jump to the message on this page --
2021-01-26  8:26 <a
href="#m8929643e99bea9c18ed490a7bc2591145eac6444"
id=r8929643e99bea9c18ed490a7bc2591145eac6444>[PATCH] bpf: Fix integer overflow in argument calculation for bpf_map_area_alloc</a> Bui Quang Minh
2021-01-26  9:36 ` <a
href="#m2600e88728f9fea79ae6afb7bdfed1411be56870"
id=r2600e88728f9fea79ae6afb7bdfed1411be56870>Lorenz Bauer</a>
2021-01-27  4:23   ` <a
href="#mb8348d16dd76a73108dbb2eb84aed227d86613ef"
id=rb8348d16dd76a73108dbb2eb84aed227d86613ef>Bui Quang Minh</a>
2021-01-27  5:09     ` <a
href="#mee48b3d547541f5e505f3eeb4d482090006b84f4"
id=ree48b3d547541f5e505f3eeb4d482090006b84f4>Bui Quang Minh</a>
2021-01-28  0:41     ` <a
href="#m3aeaaee6369efd8401f187e268d25de4cb9c2b01"
id=r3aeaaee6369efd8401f187e268d25de4cb9c2b01>Daniel Borkmann</a>
2021-05-17 15:10       ` <a
href="#ma3352959e39c5db0c88efde596a0a2945b67a122"
id=ra3352959e39c5db0c88efde596a0a2945b67a122>Bui Quang Minh</a>
</pre><hr><pre>This is a public inbox, see <a
href="../../_/text/mirror/">mirroring instructions</a>
for how to clone and mirror all data and code used for this inbox;
as well as URLs for NNTP newsgroup(s).</pre></body></html>