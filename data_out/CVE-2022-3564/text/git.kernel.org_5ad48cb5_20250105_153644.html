

| [cgit logo](/) | [index](/) : [kernel/git/bluetooth/bluetooth-next.git](/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/) | bluetooth-next for-upstream master |
| --- | --- | --- |
| Bluetooth kernel development tree | Bluetooth group |

| [about](/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/about/)[summary](/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/)[refs](/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/refs/?id=89f9f3cb86b1c63badaf392a83dd661d56cc50b1)[log](/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/log/)[tree](/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/tree/?id=89f9f3cb86b1c63badaf392a83dd661d56cc50b1)[commit](/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/commit/?id=89f9f3cb86b1c63badaf392a83dd661d56cc50b1)[diff](/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/diff/?id=89f9f3cb86b1c63badaf392a83dd661d56cc50b1)[stats](/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Maxim Mikityanskiy <maxtram95@gmail.com> | 2022-10-05 00:27:18 +0300 |
| --- | --- | --- |
| committer | Luiz Augusto von Dentz <luiz.von.dentz@intel.com> | 2022-10-04 16:24:09 -0700 |
| commit | [89f9f3cb86b1c63badaf392a83dd661d56cc50b1](/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/commit/?id=89f9f3cb86b1c63badaf392a83dd661d56cc50b1) ([patch](/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/patch/?id=89f9f3cb86b1c63badaf392a83dd661d56cc50b1)) | |
| tree | [3562082d15568eb809cdf4996c65ead0ce020db1](/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/tree/?id=89f9f3cb86b1c63badaf392a83dd661d56cc50b1) | |
| parent | [681bf011b9b5989c6e9db6beb64494918aab9a43](/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/commit/?id=681bf011b9b5989c6e9db6beb64494918aab9a43) ([diff](/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/diff/?id=89f9f3cb86b1c63badaf392a83dd661d56cc50b1&id2=681bf011b9b5989c6e9db6beb64494918aab9a43)) | |
| download | [bluetooth-next-89f9f3cb86b1c63badaf392a83dd661d56cc50b1.tar.gz](/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/snapshot/bluetooth-next-89f9f3cb86b1c63badaf392a83dd661d56cc50b1.tar.gz) | |

Bluetooth: L2CAP: Fix use-after-free caused by l2cap\_reassemble\_sduFix the race condition between the following two flows that run in
parallel:
1. l2cap\_reassemble\_sdu -> chan->ops->recv (l2cap\_sock\_recv\_cb) ->
\_\_sock\_queue\_rcv\_skb.
2. bt\_sock\_recvmsg -> skb\_recv\_datagram, skb\_free\_datagram.
An SKB can be queued by the first flow and immediately dequeued and
freed by the second flow, therefore the callers of l2cap\_reassemble\_sdu
can't use the SKB after that function returns. However, some places
continue accessing struct l2cap\_ctrl that resides in the SKB's CB for a
short time after l2cap\_reassemble\_sdu returns, leading to a
use-after-free condition (the stack trace is below, line numbers for
kernel 5.19.8).
Fix it by keeping a local copy of struct l2cap\_ctrl.
BUG: KASAN: use-after-free in l2cap\_rx\_state\_recv (net/bluetooth/l2cap\_core.c:6906) bluetooth
Read of size 1 at addr ffff88812025f2f0 by task kworker/u17:3/43169
Workqueue: hci0 hci\_rx\_work [bluetooth]
Call Trace:
<TASK>
dump\_stack\_lvl (lib/dump\_stack.c:107 (discriminator 4))
print\_report.cold (mm/kasan/report.c:314 mm/kasan/report.c:429)
? l2cap\_rx\_state\_recv (net/bluetooth/l2cap\_core.c:6906) bluetooth
kasan\_report (mm/kasan/report.c:162 mm/kasan/report.c:493)
? l2cap\_rx\_state\_recv (net/bluetooth/l2cap\_core.c:6906) bluetooth
l2cap\_rx\_state\_recv (net/bluetooth/l2cap\_core.c:6906) bluetooth
l2cap\_rx (net/bluetooth/l2cap\_core.c:7236 net/bluetooth/l2cap\_core.c:7271) bluetooth
ret\_from\_fork (arch/x86/entry/entry\_64.S:306)
</TASK>
Allocated by task 43169:
kasan\_save\_stack (mm/kasan/common.c:39)
\_\_kasan\_slab\_alloc (mm/kasan/common.c:45 mm/kasan/common.c:436 mm/kasan/common.c:469)
kmem\_cache\_alloc\_node (mm/slab.h:750 mm/slub.c:3243 mm/slub.c:3293)
\_\_alloc\_skb (net/core/skbuff.c:414)
l2cap\_recv\_frag (./include/net/bluetooth/bluetooth.h:425 net/bluetooth/l2cap\_core.c:8329) bluetooth
l2cap\_recv\_acldata (net/bluetooth/l2cap\_core.c:8442) bluetooth
hci\_rx\_work (net/bluetooth/hci\_core.c:3642 net/bluetooth/hci\_core.c:3832) bluetooth
process\_one\_work (kernel/workqueue.c:2289)
worker\_thread (./include/linux/list.h:292 kernel/workqueue.c:2437)
kthread (kernel/kthread.c:376)
ret\_from\_fork (arch/x86/entry/entry\_64.S:306)
Freed by task 27920:
kasan\_save\_stack (mm/kasan/common.c:39)
kasan\_set\_track (mm/kasan/common.c:45)
kasan\_set\_free\_info (mm/kasan/generic.c:372)
\_\_\_\_kasan\_slab\_free (mm/kasan/common.c:368 mm/kasan/common.c:328)
slab\_free\_freelist\_hook (mm/slub.c:1780)
kmem\_cache\_free (mm/slub.c:3536 mm/slub.c:3553)
skb\_free\_datagram (./include/net/sock.h:1578 ./include/net/sock.h:1639 net/core/datagram.c:323)
bt\_sock\_recvmsg (net/bluetooth/af\_bluetooth.c:295) bluetooth
l2cap\_sock\_recvmsg (net/bluetooth/l2cap\_sock.c:1212) bluetooth
sock\_read\_iter (net/socket.c:1087)
new\_sync\_read (./include/linux/fs.h:2052 fs/read\_write.c:401)
vfs\_read (fs/read\_write.c:482)
ksys\_read (fs/read\_write.c:620)
do\_syscall\_64 (arch/x86/entry/common.c:50 arch/x86/entry/common.c:80)
entry\_SYSCALL\_64\_after\_hwframe (arch/x86/entry/entry\_64.S:120)
Link: [https://lore.kernel.org/linux-bluetooth/CAKErNvoqga1WcmoR3-0875esY6TVWFQDandbVZncSiuGPBQXLA@mail.gmail.com/T/#u](https://lore.kernel.org/linux-bluetooth/CAKErNvoqga1WcmoR3-0875esY6TVWFQDandbVZncSiuGPBQXLA%40mail.gmail.com/T/#u)
Fixes: d2a7ac5d5d3a ("Bluetooth: Add the ERTM receive state machine")
Fixes: 4b51dae96731 ("Bluetooth: Add streaming mode receive and incoming packet classifier")
Signed-off-by: Maxim Mikityanskiy <maxtram95@gmail.com>
Signed-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
[Diffstat](/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/diff/?id=89f9f3cb86b1c63badaf392a83dd661d56cc50b1)

| -rw-r--r-- | [net/bluetooth/l2cap\_core.c](/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/diff/net/bluetooth/l2cap_core.c?id=89f9f3cb86b1c63badaf392a83dd661d56cc50b1) | 48 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 41 insertions, 7 deletions

| diff --git a/net/bluetooth/l2cap\_core.c b/net/bluetooth/l2cap\_core.cindex 1f34b82ca0ec93..2283871d3f0131 100644--- a/[net/bluetooth/l2cap\_core.c](/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/tree/net/bluetooth/l2cap_core.c?id=681bf011b9b5989c6e9db6beb64494918aab9a43)+++ b/[net/bluetooth/l2cap\_core.c](/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/tree/net/bluetooth/l2cap_core.c?id=89f9f3cb86b1c63badaf392a83dd661d56cc50b1)@@ -6885,6 +6885,7 @@ static int l2cap\_rx\_state\_recv(struct l2cap\_chan \*chan, struct l2cap\_ctrl \*control, struct sk\_buff \*skb, u8 event) {+ struct l2cap\_ctrl local\_control; int err = 0; bool skb\_in\_use = false; @@ -6909,15 +6910,32 @@ static int l2cap\_rx\_state\_recv(struct l2cap\_chan \*chan, chan->buffer\_seq = chan->expected\_tx\_seq; skb\_in\_use = true; + /\* l2cap\_reassemble\_sdu may free skb, hence invalidate+ \* control, so make a copy in advance to use it after+ \* l2cap\_reassemble\_sdu returns and to avoid the race+ \* condition, for example:+ \*+ \* The current thread calls:+ \* l2cap\_reassemble\_sdu+ \* chan->ops->recv == l2cap\_sock\_recv\_cb+ \* \_\_sock\_queue\_rcv\_skb+ \* Another thread calls:+ \* bt\_sock\_recvmsg+ \* skb\_recv\_datagram+ \* skb\_free\_datagram+ \* Then the current thread tries to access control, but+ \* it was freed by skb\_free\_datagram.+ \*/+ local\_control = \*control; err = l2cap\_reassemble\_sdu(chan, skb, control); if (err) break; - if (control->final) {+ if (local\_control.final) { if (!test\_and\_clear\_bit(CONN\_REJ\_ACT, &chan->conn\_state)) {- control->final = 0;- l2cap\_retransmit\_all(chan, control);+ local\_control.final = 0;+ l2cap\_retransmit\_all(chan, &local\_control); l2cap\_ertm\_send(chan); } }@@ -7297,11 +7315,27 @@ static int l2cap\_rx(struct l2cap\_chan \*chan, struct l2cap\_ctrl \*control, static int l2cap\_stream\_rx(struct l2cap\_chan \*chan, struct l2cap\_ctrl \*control, struct sk\_buff \*skb) {+ /\* l2cap\_reassemble\_sdu may free skb, hence invalidate control, so store+ \* the txseq field in advance to use it after l2cap\_reassemble\_sdu+ \* returns and to avoid the race condition, for example:+ \*+ \* The current thread calls:+ \* l2cap\_reassemble\_sdu+ \* chan->ops->recv == l2cap\_sock\_recv\_cb+ \* \_\_sock\_queue\_rcv\_skb+ \* Another thread calls:+ \* bt\_sock\_recvmsg+ \* skb\_recv\_datagram+ \* skb\_free\_datagram+ \* Then the current thread tries to access control, but it was freed by+ \* skb\_free\_datagram.+ \*/+ u16 txseq = control->txseq;+ BT\_DBG("chan %p, control %p, skb %p, state %d", chan, control, skb, chan->rx\_state); - if (l2cap\_classify\_txseq(chan, control->txseq) ==- L2CAP\_TXSEQ\_EXPECTED) {+ if (l2cap\_classify\_txseq(chan, txseq) == L2CAP\_TXSEQ\_EXPECTED) { l2cap\_pass\_to\_tx(chan, control);  BT\_DBG("buffer\_seq %u->%u", chan->buffer\_seq,@@ -7324,8 +7358,8 @@ static int l2cap\_stream\_rx(struct l2cap\_chan \*chan, struct l2cap\_ctrl \*control, } } - chan->last\_acked\_seq = control->txseq;- chan->expected\_tx\_seq = \_\_next\_seq(chan, control->txseq);+ chan->last\_acked\_seq = txseq;+ chan->expected\_tx\_seq = \_\_next\_seq(chan, txseq);  return 0; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-05 15:35:21 +0000

