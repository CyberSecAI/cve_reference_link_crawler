=== Content from github.com_64225e13_20250110_170531.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FNixOS%2Fofborg%2Fissues%2F68)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FNixOS%2Fofborg%2Fissues%2F68)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fissues_fragments%2Fissue_layout&source=header-repo&source_repo=NixOS%2Fofborg)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[NixOS](/NixOS)
/
**[ofborg](/NixOS/ofborg)**
Public

* [Notifications](/login?return_to=%2FNixOS%2Fofborg) You must be signed in to change notification settings
* [Fork
  164](/login?return_to=%2FNixOS%2Fofborg)
* [Star
   256](/login?return_to=%2FNixOS%2Fofborg)

* [Code](/NixOS/ofborg)
* [Issues
  130](/NixOS/ofborg/issues)
* [Pull requests
  19](/NixOS/ofborg/pulls)
* [Actions](/NixOS/ofborg/actions)
* [Projects
  0](/NixOS/ofborg/projects)
* [Wiki](/NixOS/ofborg/wiki)
* [Security](/NixOS/ofborg/security)
* [Insights](/NixOS/ofborg/pulse)

Additional navigation options

* [Code](/NixOS/ofborg)
* [Issues](/NixOS/ofborg/issues)
* [Pull requests](/NixOS/ofborg/pulls)
* [Actions](/NixOS/ofborg/actions)
* [Projects](/NixOS/ofborg/projects)
* [Wiki](/NixOS/ofborg/wiki)
* [Security](/NixOS/ofborg/security)
* [Insights](/NixOS/ofborg/pulse)

New issue

**Have a question about this project?** Sign up for a free GitHub account to open an issue and contact its maintainers and the community.

 [Sign up for GitHub](/signup?return_to=%2FNixOS%2Fofborg%2Fissues%2Fnew%2Fchoose)

By clicking ‚ÄúSign up for GitHub‚Äù, you agree to our [terms of service](https://docs.github.com/terms) and
[privacy statement](https://docs.github.com/privacy). We‚Äôll occasionally send you account related emails.

Already on GitHub?
[Sign in](/login?return_to=%2FNixOS%2Fofborg%2Fissues%2Fnew%2Fchoose)
to your account

[Jump to bottom](#issue-comment-box)

# Provide a binary cache for builds #68

Open

[Mic92](/Mic92) opened this issue
Feb 8, 2018
¬∑ 20 comments

Open

# [Provide a binary cache for builds](#top) #68

[Mic92](/Mic92) opened this issue
Feb 8, 2018
¬∑ 20 comments

## Comments

[![@Mic92](https://avatars.githubusercontent.com/u/96200?s=80&u=9ed15c85825694d00e996d605d728179b830c4fa&v=4)](/Mic92)

Copy link

Member

### **[Mic92](/Mic92)** commented [Feb 8, 2018](#issue-295665843) ‚Ä¢ edited Loading

| It would be pretty cool, if the builds of ofborg would also be downloadable. Then maintainers could get quite a lot more pull requests tested in shorter time.  If there would be a url where a expression with expression tarball could be downloaded, then one could do something like (it should be also possible to provide an actual tarball url for github pull requests)  ``` $ nix-shell 'https://gist.github.com/Mic92/93f65c4d42ac72c8d64397258cada90c/archive/0159f2d6894ea2928e0b05d6ee46349be81681d6.tar.gz' --command 'studio-link' ``` |
| --- |
| The text was updated successfully, but these errors were encountered: |

 üëç
7
 onny, yajo, doronbehar, dixslyf, tobiasBora, Aleksanaa, and hraban reacted with thumbs up emoji

All reactions

* üëç
  7 reactions

[![@Mic92](https://avatars.githubusercontent.com/u/96200?s=40&u=9ed15c85825694d00e996d605d728179b830c4fa&v=4)](/Mic92)
[Mic92](/Mic92)
changed the title
~~Provide a binary cache with builds~~
Provide a binary cache for builds
[Feb 8, 2018](#event-1465490735)

[![@7c6f434c](https://avatars.githubusercontent.com/u/1891350?s=80&v=4)](/7c6f434c)

Copy link

Member

### **[7c6f434c](/7c6f434c)** commented [Feb 8, 2018](#issuecomment-364252619)

| Wouldn't it make builders a more attractive compromise target? Asking as an operator of a part-time build machine, which I don't take good care of. |
| --- |

 üëç
2
 LnL7 and grahamc reacted with thumbs up emoji

All reactions

* üëç
  2 reactions

Sorry, something went wrong.

[![@grahamc](https://avatars.githubusercontent.com/u/76716?s=80&v=4)](/grahamc)

Copy link

Member

### **[grahamc](/grahamc)** commented [Feb 8, 2018](#issuecomment-364260014)

| [@7c6f434c](https://github.com/7c6f434c) If this was turned on per-builder, would it make all builders an attractive target? ie: if only the AWS machines were able to produce binaries, would you be uncomfortable running your own? |
| --- |

All reactions

Sorry, something went wrong.

[![@7c6f434c](https://avatars.githubusercontent.com/u/1891350?s=80&v=4)](/7c6f434c)

Copy link

Member

### **[7c6f434c](/7c6f434c)** commented [Feb 8, 2018](#issuecomment-364264127) via email

| Well, my builder is behind a relatively stupid NAT with now ports forwarded, although who knows‚Ä¶ In any case, I don't care as much about having to wipe the builder, as about not making a promise that I keep an eye on it. That is definitely solved by per-builder approach. If we have good enough reproducibility, maybe cross-checking that two builders have obtained the same hash independently before signing with the key of a second, more limited cache (which shares bulk storage but has different metadata) could also be a good idea? That last part could eventually be done even for things I just happen to have built: if I have a log and a build and confirm that the build is local (the log requirement is useful, because it is easy to forget using binary cache, but not so easy to forget manually putting a log into /nix/var/log, why would anyone do it anyway), I run some ofborg command and if the same hash has already been declared, I am allowed to upload. Of course, 1 and 2 are not the only numbers of independent replications that can be tracked‚Ä¶ |
| --- |

All reactions

Sorry, something went wrong.

[![@domenkozar](https://avatars.githubusercontent.com/u/126339?s=80&u=7229d6348ca93e59129e118db025fb1ab111df84&v=4)](/domenkozar)

Copy link

Member

### **[domenkozar](/domenkozar)** commented [Jul 22, 2018](#issuecomment-406858065)

| It seems best to have all builders under one owner (or a few for redundancy) and then use something like <https://cachix.org/> to provide a binary cache. In the future, hydra might even reuse that if hydra owners == ofborg build owners. |
| --- |

All reactions

Sorry, something went wrong.

[![@ncfavier](https://avatars.githubusercontent.com/u/4323933?s=80&u=ccc7a35e006af892ee83016bf36a9bfcfbb50966&v=4)](/ncfavier)

Copy link

Member

### **[ncfavier](/ncfavier)** commented [Aug 3, 2021](#issuecomment-891870214)

| This would be great. |
| --- |

All reactions

Sorry, something went wrong.

[![@Mic92](https://avatars.githubusercontent.com/u/96200?s=80&u=9ed15c85825694d00e996d605d728179b830c4fa&v=4)](/Mic92)

Copy link

Member

Author

### **[Mic92](/Mic92)** commented [Aug 3, 2021](#issuecomment-891960404) ‚Ä¢ edited Loading

| All builders are trusted now afaik. I asked to help [@grahamc](https://github.com/grahamc) setting up cachix but got no response so far. |
| --- |

All reactions

Sorry, something went wrong.

[![@ncfavier](https://avatars.githubusercontent.com/u/4323933?s=80&u=ccc7a35e006af892ee83016bf36a9bfcfbb50966&v=4)](/ncfavier)

Copy link

Member

### **[ncfavier](/ncfavier)** commented [Aug 3, 2021](#issuecomment-891961891)

| Does this actually require modifying ofborg or could we just set up a cachix action somewhere? |
| --- |

All reactions

Sorry, something went wrong.

[![@Mic92](https://avatars.githubusercontent.com/u/96200?s=80&u=9ed15c85825694d00e996d605d728179b830c4fa&v=4)](/Mic92)

Copy link

Member

Author

### **[Mic92](/Mic92)** commented [Aug 3, 2021](#issuecomment-891966927)

| Only deploying this service on the builder is required: <https://github.com/nix-community/infra/blob/b9fc8d54383fd05391fa4470720f06d6bbb32e82/roles/nix-community-cache.nix#L7> |
| --- |

All reactions

Sorry, something went wrong.

[![@domenkozar](https://avatars.githubusercontent.com/u/126339?s=80&u=7229d6348ca93e59129e118db025fb1ab111df84&v=4)](/domenkozar)

Copy link

Member

### **[domenkozar](/domenkozar)** commented [Nov 15, 2021](#issuecomment-969139599)

| I'm happy to sponsor the cache for ofborg (thought I mentioned this earlier here, but I didn't). |
| --- |

All reactions

Sorry, something went wrong.

[![@euank](https://avatars.githubusercontent.com/u/2147649?s=40&v=4)](/euank)
[euank](/euank)
mentioned this issue
[Apr 10, 2023](#ref-pullrequest-1660616776)

[k3s\_1\_24: 1.24.10+k3s1 -> 1.24.12+k3s1
NixOS/nixpkgs#225562](/NixOS/nixpkgs/pull/225562)
 Closed

12 tasks

[![@wegank](https://avatars.githubusercontent.com/u/9713184?s=40&v=4)](/wegank)
[wegank](/wegank)
mentioned this issue
[Apr 19, 2023](#ref-pullrequest-1659560847)

[qtcreator-qt6: 9.0.2 -> 10.0.0
NixOS/nixpkgs#225306](/NixOS/nixpkgs/pull/225306)
 Merged

12 tasks

[![@doronbehar](https://avatars.githubusercontent.com/u/10998835?s=40&u=e8a1743c4630ec4686f6d2dfaf82d80cf4a04e2c&v=4)](/doronbehar)
[doronbehar](/doronbehar)
mentioned this issue
[Dec 24, 2023](#ref-issue-2054936710)

[libreoffice: offline help doesn't get added.
NixOS/nixpkgs#276400](/NixOS/nixpkgs/issues/276400)

Closed

[![@tobiasBora](https://avatars.githubusercontent.com/u/2164118?s=80&v=4)](/tobiasBora)

Copy link

### **[tobiasBora](/tobiasBora)** commented [Apr 29, 2024](#issuecomment-2082789441)

| That would be great, but note that one should first solve [NixOS/nix#969](https://github.com/NixOS/nix/issues/969) otherwise this raises an important security issue, basically allowing any attacker (=person making the PR) to execute arbitrary code on the machine of the reviewer. The issue right now is that the cache is shared between all PR on Ofborg (which makes sense), but combined with [NixOS/nix#969](https://github.com/NixOS/nix/issues/969) this can be quite dangerous as it is possible to send a malicious (not reviewed) PR containing a malicious code inserted in any program with some hash `malicioushash`, and then send in a reviewed PR the right PR, except that the hash is `malicioushash` instead of the valid hash. This way, the reviewer will run the malicious binary, even if the PR actually seems points to a valid source. |
| --- |

 üëç
1
 hraban reacted with thumbs up emoji

All reactions

* üëç
  1 reaction

Sorry, something went wrong.

[![@doronbehar](https://avatars.githubusercontent.com/u/10998835?s=80&u=e8a1743c4630ec4686f6d2dfaf82d80cf4a04e2c&v=4)](/doronbehar)

Copy link

Contributor

### **[doronbehar](/doronbehar)** commented [Apr 29, 2024](#issuecomment-2083256467)

| [@tobiasBora](https://github.com/tobiasBora) could you layout a way how #969 could be abused for such an attack? I'm not sure I understand... |
| --- |

All reactions

Sorry, something went wrong.

[![@tobiasBora](https://avatars.githubusercontent.com/u/2164118?s=80&v=4)](/tobiasBora)

Copy link

### **[tobiasBora](/tobiasBora)** commented [Apr 29, 2024](#issuecomment-2083351493) ‚Ä¢ edited Loading

| [@doronbehar](https://github.com/doronbehar) Sure, I even made a small example ^^   1. First, the attacker creates a clone of the source of the program, say that is officially located in `http://foo.com/example.com/` (this is the URL I used in my tests, it does not exists so if Ofborg does not complain, it means that it used the attacker URL), and adds some malicious code inside (say, that executes `rm -rf $HOME` when starting), say that the malicious URL is at `http://example.com/` (this is what I used in my example, this one exists). 2. Then the attacker creates a dummy PR like I did here <https://github.com/NixOS/nixpkgs/pull/307709/files>. The exact content of the PR does not really matter, nobody will even need to review it, so the attacker can write a big *Work in progress* at the beginning to be sure nobody will check the content. What matters is that it should download the malicious code with something like `fetchurl` (the hash used here is `sha256-6o+sfGX7WJsNU1YPUlH3T56bJDR43Laz6nm142RJyNk=` in my test) , and Ofborg should also test it (like it did automatically in my case). This step has basically one goal : pollute the cache of Ofborg with the malicious code. 3. Then, the attacker creates another PR like I did here <https://github.com/NixOS/nixpkgs/pull/307725/files> This PR is supposed to contain exactly the code for an honest PR, except that the hash used is not the true hash coming from the upstream project, but the hash used in step 2, `sha256-6o+sfGX7WJsNU1YPUlH3T56bJDR43Laz6nm142RJyNk=` in my example. As you can see, Ofborg will pass all tests (even if the "official URL" does not even exist), meaning that it used the cache from the first PR.   As of today, if a reviewer tries to review this last PR, they will get an error since the hash does not match the one obtained from the official URL. But if Ofborg & reviewers share the same cache (or even worse, if Hydra and Ofborg share the same cache, this would allow the attack to be executed on any user of the program and not just the reviewer), then the reviewer will basically download the version built by Ofborg, i.e. the malicious one. Just trying to run the program (which is expected from most reviewers) will execute the `rm -rf $HOME` (or maybe something more subtle like installing a keylogger)‚Ä¶ not something I'd love to have, especially from an innocent looking PR.  I just sent an email to the security team with other potential attacks related to #969 that can already be executed now (but in a slightly more convoluted manner), let's see what they say. |
| --- |

All reactions

Sorry, something went wrong.

[![@tobiasBora](https://avatars.githubusercontent.com/u/2164118?s=40&v=4)](/tobiasBora)
[tobiasBora](/tobiasBora)
mentioned this issue
[Apr 29, 2024](#ref-issue-165212248)

[re-fetch source when url changes
NixOS/nix#969](/NixOS/nix/issues/969)

Open

[![@Mic92](https://avatars.githubusercontent.com/u/96200?s=80&u=9ed15c85825694d00e996d605d728179b830c4fa&v=4)](/Mic92)

Copy link

Member

Author

### **[Mic92](/Mic92)** commented [Apr 30, 2024](#issuecomment-2084757766)

| We have the same issue by the way in nixpkgs if the attacker controls any package source in nixpkgs and creates a malicious release that contains the source of both the actual package and the package of a second package that has been modified in a malicious way. |
| --- |

All reactions

Sorry, something went wrong.

[![@Mic92](https://avatars.githubusercontent.com/u/96200?s=80&u=9ed15c85825694d00e996d605d728179b830c4fa&v=4)](/Mic92)

Copy link

Member

Author

### **[Mic92](/Mic92)** commented [Apr 30, 2024](#issuecomment-2084760078)

| So what I think we need is some CI check that will try to download any fixed output derivation that is new and verify it gets the same hash. |
| --- |

All reactions

Sorry, something went wrong.

[![@tobiasBora](https://avatars.githubusercontent.com/u/2164118?s=80&v=4)](/tobiasBora)

Copy link

### **[tobiasBora](/tobiasBora)** commented [Apr 30, 2024](#issuecomment-2084779081)

| We have the same issue by the way in nixpkgs if the attacker controls any package source in nixpkgs and creates a malicious release that contains the source of both the actual package and the package of a second package that has been modified in a malicious way.  Yes exactly, that was basically part of what I wrote in the email to the security maintainers ^^ (with some other attacks, e.g. relying on obfuscated automatically generated files)  So what I think we need is some CI check that will try to download any fixed output derivation that is new and verify it gets the same hash.  Why should this be a CI check? The attacks would still be possible if I just use a fork of nixpkgs without going through CI‚Ä¶ and maybe the reviewers would not wait for the CI to finish before testing the PR themself. Can't we directly modify nix's way of handling fix-output derivation, by basically re-running them whenever an unseen derivation is seen? (seems quite straightforward no?) |
| --- |

All reactions

Sorry, something went wrong.

[![@doronbehar](https://avatars.githubusercontent.com/u/10998835?s=80&u=e8a1743c4630ec4686f6d2dfaf82d80cf4a04e2c&v=4)](/doronbehar)

Copy link

Contributor

### **[doronbehar](/doronbehar)** commented [Apr 30, 2024](#issuecomment-2085157162)

| Can't we directly modify nix's way of handling fix-output derivation, by basically re-running them whenever an unseen derivation is seen? (seems quite straightforward no?)  Sounds not to hard to me too, but the question is, what would you consider an "unseen derivation"? Would you simply make Nix evaluation reevaluate all FODs that are not found in the local cache? Would you consider Hydra's cache safe? |
| --- |

All reactions

Sorry, something went wrong.

[![@Mic92](https://avatars.githubusercontent.com/u/96200?s=80&u=9ed15c85825694d00e996d605d728179b830c4fa&v=4)](/Mic92)

Copy link

Member

Author

### **[Mic92](/Mic92)** commented [Apr 30, 2024](#issuecomment-2085219162)

| Why should this be a CI check? The attacks would still be possible if I just use a fork of nixpkgs without going through CI‚Ä¶ and maybe the reviewers would not wait for the CI to finish before testing the PR themself. Can't we directly modify nix's way of handling fix-output derivation, by basically re-running them whenever an unseen derivation is seen? (seems quite straightforward no?)  I mean I am talking about how to protect cache.nixos.org against cache poisoning at least. |
| --- |

All reactions

Sorry, something went wrong.

[![@Mic92](https://avatars.githubusercontent.com/u/96200?s=80&u=9ed15c85825694d00e996d605d728179b830c4fa&v=4)](/Mic92)

Copy link

Member

Author

### **[Mic92](/Mic92)** commented [Apr 30, 2024](#issuecomment-2085222996)

| Can't we directly modify nix's way of handling fix-output derivation, by basically re-running them whenever an unseen derivation is seen? (seems quite straightforward no?)  Sounds not to hard to me too, but the question is, what would you consider an "unseen derivation"? Would you simply make Nix evaluation reevaluate all FODs that are not found in the local cache? Would you consider Hydra's cache safe?  We only use the cache if we have verified that that a given `<url>` produces a given `<hash>` and is not part of cache.nixos.org. |
| --- |

All reactions

Sorry, something went wrong.

[![@tobiasBora](https://avatars.githubusercontent.com/u/2164118?s=80&v=4)](/tobiasBora)

Copy link

### **[tobiasBora](/tobiasBora)** commented [Apr 30, 2024](#issuecomment-2085327052)

| We only use the cache if we have verified that that a given produces a given and is not part of cache.nixos.org.  That would indeed be the safest option, but I'm thinking that it might be quite inefficient, as it means that we need to download the source of all the transitive dependencies before even considering downloading something from `cache.nixos.org`‚Ä¶ One can maybe add an option `--paranoid` for this behavior, and we can maybe enabled for `cache.nixos.org` (this should anyway not add too much overhead since it already have downloaded anything basically), but this seems quite hard to enforce on the end user‚Ä¶ I'm trying to see if we can imagine a solution that is both safe & with a minimal overhead.  Would you simply make Nix evaluation reevaluate all FODs that are not found in the local cache? Would you consider Hydra's cache safe?  That's a good question. So I think we **should** trust caches like `cache.nixos.org` (at least once they implement a fix for this issue, since anyway malicious caches could do anything), but I don't think that the current information that is shared by caches is enough. Indeed, for now, the cache says something like "I have a derivation whose hash is `foohash` but I don't know how it was generated"‚Ä¶ which is exactly the same information as what NixOs already tells you, which is, as we saw before, not secure.  So, in my opinion, I think that both users & cache should keep a table `derivation path -> hash`, and caches should share this table with users. This way, when a user wants to install a program:   1. first, whenever it finds a FOD (dependency, source‚Ä¶), it will check in its local table if `derivation -> hash` is present. If it is present, but not correct, abort. If it is present and correct, goto step 4 2. If it is not present, check on the cache if `derivation -> hash` is present. Again, check correctness if present and goto step 4 3. If it is still not present, execute the FOD locally, and check if the hash is correct, otherwise abort. 4. Once all dependencies have been checked, the rest is as usual: compute as usual the final hash of the program, and ask to the binary cache if is it present. If so, download it, otherwise build it.   Note that one may make this algorithm more efficient (so far it uses many rounds of communication with the server which is not great) by sending a single message to the server with the list of all FOD that could not be checked locally, with their expected hash. If the server sees a single hash mismatch, it aborts, and otherwise sends back the list of FOD that could not be checked.  Hope it make sense! |
| --- |

 üëç
1
 doronbehar reacted with thumbs up emoji

All reactions

* üëç
  1 reaction

Sorry, something went wrong.

[![@risicle](https://avatars.githubusercontent.com/u/807447?s=40&v=4)](/risicle)
[risicle](/risicle)
mentioned this issue
[May 6, 2024](#ref-pullrequest-2196489189)

[[RFC 0171] Default name of fetchFromGithub FOD to include revision
NixOS/rfcs#171](/NixOS/rfcs/pull/171)
 Closed

[![@risicle](https://avatars.githubusercontent.com/u/807447?s=80&v=4)](/risicle)

Copy link

Contributor

### **[risicle](/risicle)** commented [May 6, 2024](#issuecomment-2095640872)

| So what I think we need is some CI check that will try to download any fixed output derivation that is new and verify it gets the same hash.  I am currently working on such a thing. |
| --- |

All reactions

Sorry, something went wrong.

[![@risicle](https://avatars.githubusercontent.com/u/807447?s=40&v=4)](/risicle)
[risicle](/risicle)
mentioned this issue
[May 20, 2024](#ref-pullrequest-2306864690)

[add force-build-new-FODs.sh maintainer script
NixOS/nixpkgs#313248](/NixOS/nixpkgs/pull/313248)
 Open

13 tasks

[Sign up for free](/join?source=comment-repo)
**to join this conversation on GitHub**.
Already have an account?
[Sign in to comment](/login?return_to=https%3A%2F%2Fgithub.com%2FNixOS%2Fofborg%2Fissues%2F68)

Assignees

No one assigned

Labels

None yet

Projects

None yet

Milestone

No milestone

Development

No branches or pull requests

8 participants

[![@grahamc](https://avatars.githubusercontent.com/u/76716?s=52&v=4)](/grahamc) [![@Mic92](https://avatars.githubusercontent.com/u/96200?s=52&v=4)](/Mic92) [![@domenkozar](https://avatars.githubusercontent.com/u/126339?s=52&v=4)](/domenkozar) [![@risicle](https://avatars.githubusercontent.com/u/807447?s=52&v=4)](/risicle) [![@7c6f434c](https://avatars.githubusercontent.com/u/1891350?s=52&v=4)](/7c6f434c) [![@tobiasBora](https://avatars.githubusercontent.com/u/2164118?s=52&v=4)](/tobiasBora) [![@ncfavier](https://avatars.githubusercontent.com/u/4323933?s=52&v=4)](/ncfavier) [![@doronbehar](https://avatars.githubusercontent.com/u/10998835?s=52&v=4)](/doronbehar)

## Footer

¬© 2025 GitHub,¬†Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can‚Äôt perform that action at this time.



=== Content from discourse.nixos.org_2386e2ec_20250110_170528.html ===


![NixOS Discourse](data:image/svg;base64...)
Loading

[NixOS Discourse](/)

# [Nixpkgs supply chain security project](/t/nixpkgs-supply-chain-security-project/34345)

[Announcements](/c/announcements/8)

[fricklerhandwerk](https://discourse.nixos.org/u/fricklerhandwerk)

October 19, 2023, 11:57am

1

Hi everyone,

a couple of months ago, back in June 2023, multiple groups of Nix ecosystem contributors [prepared project proposals](https://discourse.nixos.org/t/german-federal-funding-for-foss-development/29036/4) for the [Sovereign Tech Fund ‚ÄúContribute Back Challenges‚Äù](https://sovereigntechfund.de/en/challenges/).

Today I‚Äôm glad to announce that the Nix ecosystem supply chain security project will be [supported by the Sovereign Tech Fund](https://mastodon.social/%40sovtechfund/111261407556029020) with an investment of 226 000 Euro!

The focus of this project is on reducing our reliance on foreign binaries to compile Nixpkgs from scratch, ensuring we are are indeed running the code we compiled by leveraging existing security components in NixOS, and putting in place mechanisms that allow us to deliver the most up-to-date, secure software whenever it is available in a way that can be sustained given our maintainer capacities.

Specifically, **by the end of the year** this will provide the Nix community with three major improvements to the ecosystem‚Äôs security story:

1. A state-of-the-art vulnerability tracker for Nixpkgs
2. TPM2-based UEFI Secure Boot for NixOS
3. A full-source bootstrap chain for the Standard Environment (`stdenv`) in Nixpkgs

Check the [submitted project description](https://github.com/nix-community/projects/blob/274c6d15708b8f0f6e0b3f9782e3959e076ff792/proposals/nixpkgs-security.md) for details on the planned deliverables.

All of these three capabilities combined in one software distribution will be quite a unique feature in the open source world.

Nix is not only particularly suitable to support that with declarative, immutable configurations making highly intricate setups tractable.

The Nix ecosystem also needs them very much due to its immense size, growing popularity, and the resulting attack surface.

I‚Äôm quite excited about this happening, and proud to be part of it.

This effort will, with time, greatly improve the security situation for most Nix and NixOS users by default.

And it will also very likely further boost adoption of Nix and NixOS in security-sensitive software development communities.

It‚Äôs already an amazing showcase of community collaboration, and a perfect opportunity to show yet another time what‚Äôs possible with Nix.

[@raitobezarius](/u/raitobezarius) will work on the boot chain security part, together with [@nikstur](/u/nikstur) and [@lheckemann](/u/lheckemann). [@raitobezarius](/u/raitobezarius) is a [Nixpkgs security contributor](https://github.com/NixOS/nixpkgs/pulls?q=is%3Apr+author%3ARaitoBezarius+label%3A%221.severity%3A+security%22+is%3Aclosed) and [reviewer of security fixes](https://github.com/NixOS/nixpkgs/pulls?q=is%3Apr+reviewed-by%3ARaitoBezarius+label%3A%221.severity%3A+security%22+is%3Aclosed+), the and was release manager for NixOS 23.05. [@nikstur](/u/nikstur) is one of the maintainers of [lanzaboote](https://github.com/nix-community/lanzaboote), and [@lheckemann](/u/lheckemann) is a prolific long-term contributor to Nixpkgs and NixOS, having managed the releases of NixOS 19.03 and 19.09 as well as being a member of the security team and the RFC Steering Committee.

[@thubrecht](/u/thubrecht) will set up the web service for the vulnerability tracker and collaborate with the Nixpkgs security team to address their requirements.

The bootstrapping work is led by [@emilytrau](/u/emilytrau), who kickstarted the [minimal bootstrap project](https://github.com/NixOS/nixpkgs/pull/232329) and is involved in the community that delivered the [Guix full-source bootstrap](https://guix.gnu.org/blog/2023/the-full-source-bootstrap-building-from-source-all-the-way-down/).

I will support the team with administrative tasks, external communication, and documentation reviews.

Thank you very much to everyone who made this possible!

Special thanks to the NixOS Foundation board ([@edolstra](/u/edolstra), [@domenkozar](/u/domenkozar), [@thufschmitt](/u/thufschmitt), [@ron](/u/ron), [@zimbatm](/u/zimbatm)) for both financial and moral support with the application process.

Extra special thanks to [@proofconstruction](/u/proofconstruction) for sitting through the arduous last checks of the project descriptions.

The Sovereign Tech Fund (STF) invests in many other open source projects you may be interested in. Check out their [announcements for this year‚Äôs funding round](https://mastodon.social/%40sovtechfund). STF supports the development, improvement, and maintenance of open digital infrastructure in the public interest. Its goal to strengthen the open source ecosystem sustainably, focusing on security, resilience, technological diversity, and the people behind the code. STF is funded by the German Federal Ministry of Economics and Climate Action (BMWK) and hosted at and supported by the German Federal Agency for Disruptive Innovation GmbH (SPRIND).

Stay tuned for updates, and get in touch if you have any questions.

94 Likes

[Nixpkgs supply chain security -- phase 2 proposals (STF)](https://discourse.nixos.org/t/nixpkgs-supply-chain-security-phase-2-proposals-stf/35757)

[Boot Time Integrity Checks for the Nix Store](https://discourse.nixos.org/t/boot-time-integrity-checks-for-the-nix-store/36793)

[NixOS Reproducible Builds: minimal installation ISO successfully independently rebuilt](https://discourse.nixos.org/t/nixos-reproducible-builds-minimal-installation-iso-successfully-independently-rebuilt/34756/3)

[2024-06-14 Documentation team meeting notes #132](https://discourse.nixos.org/t/2024-06-14-documentation-team-meeting-notes-132/47182)

[2023-12-15 meeting notes on accounting](https://discourse.nixos.org/t/2023-12-15-meeting-notes-on-accounting/36907)

[Scanning NIX packages with Sonatype (Nexus IQ) CLM scan tool](https://discourse.nixos.org/t/scanning-nix-packages-with-sonatype-nexus-iq-clm-scan-tool/35583/12)

[NixOS Reproducible Builds: minimal installation ISO successfully independently rebuilt](https://discourse.nixos.org/t/nixos-reproducible-builds-minimal-installation-iso-successfully-independently-rebuilt/34756)

[iFreilicht](https://discourse.nixos.org/u/iFreilicht)

October 19, 2023, 5:07pm

2

Those are great news! All of those things are sorely needed to make Nix and NixOS a solid choice for businesses and private users alike.

So cool to see that capable contributors will get paid to do good work, I hope that helps with their general workload as well.

The STF announced it would take longer to review the applications, but I didn‚Äôt expect them to take two months longer than initially planned.

2 Likes

[Quagmire](https://discourse.nixos.org/u/Quagmire)

October 20, 2023, 2:04pm

3

This is really fantastic; thanks to all of those who are helping to achieve these goals, it‚Äôs much appreciated.

1 Like

[Mindavi](https://discourse.nixos.org/u/Mindavi)

October 20, 2023, 2:43pm

4

I am looking forward to the minimal bootstrap efforts to hopefully one day get rid of the bootstrap archives (at least for the common platforms)! It seems there are still some challenges to overcome there. Is there an issue tracking this, maybe?

The vulnerability tracking sounds interesting, I‚Äôd like to see how that turns out.

2 Likes

[emilytrau](https://discourse.nixos.org/u/emilytrau)

October 22, 2023, 9:45am

5

Thanks for the support! Progress on minimal-bootstrap is being tracked in this PR [stdenv: begin work on 256b bootstrap i.e. Trusting Trust by emilytrau ¬∑ Pull Request #227914 ¬∑ NixOS/nixpkgs ¬∑ GitHub](https://github.com/NixOS/nixpkgs/pull/227914)

14 Likes

[ron](https://discourse.nixos.org/u/ron)

October 22, 2023, 3:59pm

6

Just a huge THANK YOU shout out to the folks who did all the incredible work that made this happen! <3

4 Likes

[fricklerhandwerk](https://discourse.nixos.org/u/fricklerhandwerk)

November 5, 2023, 11:02pm

7

Here‚Äôs the tracking issue for NixOS boot security: [Tracking issue: Boot security in NixOS ¬∑ Issue #265640 ¬∑ NixOS/nixpkgs ¬∑ GitHub](https://github.com/NixOS/nixpkgs/issues/265640)

3 Likes

[fricklerhandwerk](https://discourse.nixos.org/u/fricklerhandwerk)

November 22, 2023, 7:30am

8

About a month left to land the promised deliverables. Here‚Äôs a status report.

> tl;dr We‚Äôre on track.

Since the initial announcement, the working group has grown as the specification became more refined, with every milestone having at least one individual responsible.

## NixOS Boot Security

* [@lheckemann](/u/lheckemann) got an ISO to build that can be booted with Secure Boot enabled via [shim](https://github.com/RaitoBezarius/nixos-shim/). It currently works by signing the kernel directly. It doesn‚Äôt verify the initramfs or store image, so the next step is to build a Unified Kernel Image to get the initrd verified, and do a checksum of the store image to get all the desired security properties. This is not ideal, especially performance-wise, but will unblock kicking off the [shim-review](https://github.com/rhboot/shim-review) process to obtain a signature that allows booting on machines that only ship with Microsoft keys.
  + [@mschwaig](/u/mschwaig) generously helped out
* [@ElvishJerricco](/u/elvishjerricco) explored multiple options to verify the store closure
  + The most secure and attainable solution for now is using `nix-store --verify` on regular systems, despite a significant performance penalty, and `dm-crypt` on appliances.
  + At the end of the year there will be a an outline for what an optimal solution would loook like: something very much along the lines of APFS Signed System Volume, with ZFS being closest to being able to implement it, despite being far from ideal in many other respects.
* [@nikstur](/u/nikstur) opened a tracking issue: [Perlless Activation - Tracking Issue ¬∑ Issue #267982 ¬∑ NixOS/nixpkgs ¬∑ GitHub](https://github.com/NixOS/nixpkgs/issues/267982)
  + Booting NixOS without running the Perl interpreter is almost done
  + At the end of the year we‚Äôll have a clear implementation strategy to also get rid of Bash in a possible next round of work
* [@RaitoBezarius](/u/raitobezarius)
  + Added [PE write support in Goblin](https://github.com/m4b/goblin/pull/361)
  + Got an even fancier [PE assembling solution](https://github.com/m4b/goblin/pull/381), which aims to replace `objcopy` or systemd‚Äôs `ukify` in the future
  + Added [Signing support for PE via Goblin](https://github.com/RaitoBezarius/goblin-signing/blob/c12b400a228b94c3853c7e91e3c1681f03939514/tests/test_snakeoil_sign.rs)
  + [Verifying PE certificates](https://github.com/RaitoBezarius/goblin-signing/blob/c12b400a228b94c3853c7e91e3c1681f03939514/examples/verify_binary.rs) in a **basic** way, with a UEFI example using your own `db` variable, which should work with Lanzaboote!
    - X.509 resolution chain is not implemented yet, so you cannot have a chain of verification from an organizational certificate authority to your ‚Äúmachine‚Äù certificate.
  + [Writing cursed PKCS#11 code](https://github.com/RaitoBezarius/goblin-signing/blob/c12b400a228b94c3853c7e91e3c1681f03939514/examples/sign_binary.rs) in to enable users to test the creation of a simple certificate authority, then build a certificate for a specific machine or group of machines (a ‚Äúsub CA‚Äù) and use it to sign your binaries, all of that from your PKCS#11 hardware security token (that is, a (Nitro|Yubi|expensive)HSM, a smartcard key, a SoftHSM2, a TPM2, maybe your phone, and much more)
  + Used it to [assemble companion files according to the BLS specification and systemd semantics](https://github.com/nix-community/lanzaboote/blob/a60c471decc591ed75edfed2d9e4da568597978c/rust/uefi/linux-bootloader/src/companions.rs) inside of lanzastub. This involved some contributions and discussions with `uefi-rs` people.
  + Wrote the [`pio` (for pico I/O) dedicated to write CPIO archives](https://github.com/nix-community/lanzaboote/blob/a60c471decc591ed75edfed2d9e4da568597978c/rust/uefi/pio/tests/read_write.rs) in a `no_std` context, albeit with `alloc`
* [@Dmills27](/u/dmills27) started working on documenting the complete setup for end users

## Vulnerability tracker

* Due to a constellation of unfortunate situations, we had to quickly re-plan some milestones. Special thanks to Ryan Trinkle and Ali Abrar from [Obsidian Systems](https://obsidian.systems/) for jumping in to support us with developer time and project management expertise on short notice, with [@cidkid](/u/cidkid) being part of the group now.
* Progress is tracked here: [Issues ¬∑ Nix-Security-WG/nix-security-tracker ¬∑ GitHub](https://github.com/Tom-Hubrecht/nix-security-tracker/issues/)
* [@thubrecht](/u/thubrecht) implemented the web service infrastructure and CVE ingestion, and is working on providing APIs to implement clients against
* [@raboof](/u/raboof) and [@cidkid](/u/cidkid), after an extensive survey of prior art, are developing [a tool](https://github.com/Nix-Security-WG/nix-security-tracker/tree/local-security-scanner) to match local store path closures and metadata against advisories, which will use the web APIs to improve accuracy.
* [@mightyiam](/u/mightyiam), [@jfly](/u/jfly), and @modprog work on extending and integrating `label-tracker`, a tool to track PRs/issues in nixpkgs according to their tags, generously supported with input from [@pennae](/u/pennae)

## Nixpkgs full-source bootstrap chain

* [@emilytrau](/u/emilytrau) is tracking progress with PRs referencing [stdenv: begin work on 256b bootstrap i.e. Trusting Trust by emilytrau ¬∑ Pull Request #227914 ¬∑ NixOS/nixpkgs ¬∑ GitHub](https://github.com/NixOS/nixpkgs/pull/227914)
  + Implementation is in the home stretch, with GCC 8 compiling with musl, bootstrapped off the latest `stag0-posix` release 1.6.0
  + There was lots of volunteer support in the form of reviews, thanks [@picnoir](/u/picnoir), [@artturin](/u/artturin), [@Ericson2314](/u/ericson2314) and everyone else involved!
* [@alejandrosame](/u/alejandrosame) is writing in-code and maintainer-oriented documentation, since a major contribution to security by this sub-project is being able to understanding how and why things work

## Phase 2

Overall, the project is on a path to fulfill the envisioned requirements in terms of security, but due to time limits has to strike many compromises between implementation complexity and performance. One important byproduct are findings that inform possible next implementation steps.

The second application phase is coming up, where we can continue to build upon what‚Äôs currently being done and incorporate those findings. We invite everyone available to work on security in the first quarter of 2024 to [participate in planning](https://discourse.nixos.org/t/nixpkgs-supply-chain-security-phase-2-proposals-stf/35757). The deadline to hand in a proposal to the STF is Wednesday 2023-12-13.

19 Likes

[fricklerhandwerk](https://discourse.nixos.org/u/fricklerhandwerk)

December 13, 2023, 12:42pm

9

Hi everyone, we just submitted the phase 1 report to the Sovereign Tech Fund. It‚Äôs also [published on our projects repository](https://github.com/nix-community/projects/pull/9) and includes the proposal for phase 2.

tl;dr Phase 1:

> NixOS now has all pieces of the puzzle to offer security features superior to most other Linux distributions and at least en par with commercial offers, while preserving the ease and freedom of customisation NixOS has always been known for. Completing this project will shift our concern from purely remediation to prevention of security incidents.

tl;dr Phase 2:

> Primarily we would like to finish and round off the projects started in Round 1 to make them more immediately useful, and as an addition close a major gap in the software distribution lifecycle in the Nix ecosystem.

Great many thanks to everyone who‚Äôs working on the project to make it a success ‚Äì still in progress until end of the year ‚Äì or helped writing the report or the proposal (in ASCIIbetical order):

[@DMills27](/u/dmills27)

[@ElvishJerricco](/u/elvishjerricco)

[@Ericson2314](/u/ericson2314)

[@JulienMalka](/u/julienmalka)

[@Mic92](/u/mic92)

[@RaitoBezarius](/u/raitobezarius)

[@alejandrosame](/u/alejandrosame)

[@cidkid](/u/cidkid)

[@emilytrau](/u/emilytrau)

[@jeremiahs](/u/jeremiahs)

[@jfly](/u/jfly)

[@lassulus](/u/lassulus)

[@lheckemann](/u/lheckemann)

[@lilyinstarlight](/u/lilyinstarlight)

[@mightyiam](/u/mightyiam)

@modprog

[@nikstur](/u/nikstur)

[@raboof](/u/raboof)

[@t184256](/u/t184256)

[@thubrecht](/u/thubrecht)

18 Likes

[mightyiam](https://discourse.nixos.org/u/mightyiam)

December 15, 2023, 6:28am

10

You guys are heroes.

[fricklerhandwerk](https://discourse.nixos.org/u/fricklerhandwerk)

February 7, 2024, 4:03pm

11

Hi everyone, unfortunately our phase 2 proposal was declined. But we can still apply for [general funding](https://www.sovereigntechfund.de/programs/applications).

Regarding the status of the project:

* The boot security work is fully implemented, but some PRs still need to be merged.
* The bootstrapping code is in place, but the 32-bit `stdenv` is not switched over. This may still require some discussion among maintainers.
* The vulnerability tracker front end work got stuck end of December 2023 for health reasons. Honestly, we were just overworked. The heavy lifting on the back-end is done due to a heroic effort by [@raitobezarius](/u/raitobezarius), which means that we now have a very faithful, continuously updated database representation of Nixpkgs. [@raitobezarius](/u/raitobezarius) and me will continue making the front-end usable in the coming weeks and months, as time allows. [@mightyiam](/u/mightyiam) and [@jfly](/u/jfly) continue refining the `label-tracker` part of the back-end, which also still needs to be integrated.

6 Likes

[imincik](https://discourse.nixos.org/u/imincik)

February 7, 2024, 6:26pm

12

Thank you for information. Are you able to share more details about the reason why it was decided? We could learn from it for the future projects.

1 Like

[fricklerhandwerk](https://discourse.nixos.org/u/fricklerhandwerk)

February 7, 2024, 6:34pm

13

![](https://discourse.nixos.org/letter_avatar_proxy/v4/letter/i/6de8d8/48.png) imincik:
> Are you able to share more details about the reason why it was decided?

No reason was given.

[tobiasBora](https://discourse.nixos.org/u/tobiasBora)

February 7, 2024, 6:40pm

14

This is really cool! Just, out of curiosity, is there any plan (maybe for another funding?) to absorb some concepts from [Qubes](http://www.qubes-os.org/), that provides unseen guarantees in term of security, by providing a way to isolate all processes in separated VM? I would love to be able to specify in my `configuration.nix` something like:

```
isolatedVMs = {
  vm_browser = {
    color = "red";
    home_folder = "/home/me/foldervms_browser";
    config = {
      environment.systemPackages = with pkgs; [
        firefox
      ];
    }
  };
  vm_email = {
    color = "green";
    home_folder = "/home/me/foldervms_email";
    config = {
      environment.systemPackages = with pkgs; [
        thunderbird
      ];
    }
  };
}

```

I guess it is not an easy task, but would be really awesome.

I‚Äôm aware of <https://spectrum-os.org/> but I would prefer to have it as a light layer on top of NixOs to jail some specific processes rather than using a whole different OS.

2 Likes

[RaitoBezarius](https://discourse.nixos.org/u/RaitoBezarius)

February 7, 2024, 7:34pm

15

I don‚Äôt think it makes that much sense to pursue this sort of lightweight sandboxing, Spectrum is doing a great job here and I don‚Äôt believe it makes a lot of sense to divide efforts.

If anything, if I was given the option, I would prefer to offer a funding to Spectrum.

And plenty OOT projects exist: [GitHub - jollheef/appvm: Nix-based app VMs](https://github.com/jollheef/appvm).

3 Likes

[fricklerhandwerk](https://discourse.nixos.org/u/fricklerhandwerk)

April 28, 2024, 10:44pm

17

Another update on project status:

We did not manage to make any progress on the [security tracker](https://github.com/Nix-Security-WG/nix-security-tracker) due to other priorities. Concretely, since the last update I only had [a minimal amount of time for work](https://discourse.nixos.org/t/taking-a-break-in-2024q1/36913) that I used to write the documentation team report that is about to be published, and prepared [Summer of Nix](https://github.com/ngi-nix/summer-of-nix) to make sure it‚Äôs on schedule.

[@mightyiam](/u/mightyiam) reported a release of [`pr-tracker`](https://github.com/molybdenumsoftware/pr-tracker), which still needs to be reviewed before it can be integrated. That would also require building views to implement the interaction where pull requests are mapped to security issues.

Last week I met [@alejandrosame](/u/alejandrosame) and [@RaitoBezarius](/u/raitobezarius) to plan the next steps. The goal is to make the security tracker useful for the security team‚Äôs day-to-day tasks, taking it on carefully since we‚Äôre not in any particular rush at the moment. In the coming weeks, [@alejandrosame](/u/alejandrosame) will develop the required views, for now still without styling. [@RaitoBezarius](/u/raitobezarius) will guide the process, checking in regularly to make code reviews and try out the intermediate results. I will step back from the project to focus on other responsibilities, but will probably help out as a volunteer here and there.

Specifically, the agreed-upon roadmap is:

* Have GitHub login and the record linkage workflow by 2024-05-31
* Ramp up CSS development in 2024-06
* Prepare for hand-off to security team on 2024-08-01
  + Prepare org-level documentation in the Nix ecosystem
  + Take care of follow-up funding

10 Likes

[raboof](https://discourse.nixos.org/u/raboof)

May 19, 2024, 3:39pm

18

Despite not getting the funding, [@JulienMalka](/u/julienmalka) and I have proceeded with the [hash collection subproject](https://github.com/JulienMalka/lila) in our free time. It is early days but getting into a fairly good shape: the basic features work and it can generate basic reports like <https://reproducibility.nixos.social/reports/minimal-iso-runtime> . There‚Äôs still some [notable features missing](https://github.com/JulienMalka/lila/issues) but I think it‚Äôs ready for some wider feedback and contributions - feel free to get in touch!

![](https://discourse.nixos.org/user_avatar/discourse.nixos.org/fricklerhandwerk/48/2029_2.png) fricklerhandwerk:
> I will step back from the project to focus on other responsibilities, but will probably help out as a volunteer here and there.

Thanks a lot for your great work here!

9 Likes

[tobiasBora](https://discourse.nixos.org/u/tobiasBora)

May 20, 2024, 2:26pm

19

Speaking of security, I wanted to raise some attention regarding this CVE I just reported <https://nvd.nist.gov/vuln/detail/CVE-2024-36050> following my first report here [re-fetch source when url changes ¬∑ Issue #969 ¬∑ NixOS/nix ¬∑ GitHub](https://github.com/NixOS/nix/issues/969#issuecomment-2083382876) (cf the follow up discussion for details) and to the security team. As of today it is not clear if Nix already got impacted by it or not, but in any case it is, IMHO, quite important to address it in a timely manner.

1 Like

[tomberek](https://discourse.nixos.org/u/tomberek)

June 12, 2024, 8:56pm

20

What is remaining for the Vulnerability tracker project? Due to upcoming possible grants, it would be good for this effort to come to a conclusion.

Is it front-end work, do we need additional people? Are there blockers that others can help with/

1 Like

[sambacha](https://discourse.nixos.org/u/sambacha)

June 13, 2024, 5:52am

21

The security tracker seems like it could achieve its objectives by just leveraging the GitHub dependency submission endpoint:

![](https://docs.github.com/assets/cb-345/images/site/favicon.png)
[GitHub Docs](https://docs.github.com/en/rest/dependency-graph/dependency-submission?apiVersion=2022-11-28)

![](https://github.githubassets.com/images/modules/open_graph/github-logo.png)
### [REST API endpoints for dependency submission - GitHub Docs](https://docs.github.com/en/rest/dependency-graph/dependency-submission?apiVersion=2022-11-28)

Use the REST API to submit dependencies.

![](https://docs.github.com/assets/cb-345/images/site/favicon.png)
[GitHub Docs](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/using-the-dependency-submission-api)

![](https://github.githubassets.com/images/modules/open_graph/github-logo.png)
### [Using the dependency submission API - GitHub Docs](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/using-the-dependency-submission-api)

You can use the dependency submission API to submit dependencies for projects, such as the dependencies resolved when a project is built or compiled.

1 Like

**[next page ‚Üí](/t/nixpkgs-supply-chain-security-project/34345?page=2)**

* [Home](/)
* [Categories](/categories)
* [Guidelines](/guidelines)
* [Terms of Service](/tos)
* [Privacy Policy](/privacy)

Powered by [Discourse](https://www.discourse.org), best viewed with JavaScript enabled



=== Content from github.com_d1f92ebb_20250110_170530.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FNixOS%2Fnix%2Fissues%2F969)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FNixOS%2Fnix%2Fissues%2F969)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fissues_fragments%2Fissue_layout&source=header-repo&source_repo=NixOS%2Fnix)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[NixOS](/NixOS)
/
**[nix](/NixOS/nix)**
Public

* [Notifications](/login?return_to=%2FNixOS%2Fnix) You must be signed in to change notification settings
* [Fork
  1.6k](/login?return_to=%2FNixOS%2Fnix)
* [Star
   13.3k](/login?return_to=%2FNixOS%2Fnix)

* [Code](/NixOS/nix)
* [Issues
  3.1k](/NixOS/nix/issues)
* [Pull requests
  406](/NixOS/nix/pulls)
* [Actions](/NixOS/nix/actions)
* [Projects
  2](/NixOS/nix/projects)
* [Security](/NixOS/nix/security)
* [Insights](/NixOS/nix/pulse)

Additional navigation options

* [Code](/NixOS/nix)
* [Issues](/NixOS/nix/issues)
* [Pull requests](/NixOS/nix/pulls)
* [Actions](/NixOS/nix/actions)
* [Projects](/NixOS/nix/projects)
* [Security](/NixOS/nix/security)
* [Insights](/NixOS/nix/pulse)

New issue

**Have a question about this project?** Sign up for a free GitHub account to open an issue and contact its maintainers and the community.

 [Sign up for GitHub](/signup?return_to=%2FNixOS%2Fnix%2Fissues%2Fnew%2Fchoose)

By clicking ‚ÄúSign up for GitHub‚Äù, you agree to our [terms of service](https://docs.github.com/terms) and
[privacy statement](https://docs.github.com/privacy). We‚Äôll occasionally send you account related emails.

Already on GitHub?
[Sign in](/login?return_to=%2FNixOS%2Fnix%2Fissues%2Fnew%2Fchoose)
to your account

[Jump to bottom](#issue-comment-box)

# re-fetch source when url changes #969

Open

[magnetophon](/magnetophon) opened this issue
Jul 13, 2016
¬∑ 22 comments

Open

# [re-fetch source when url changes](#top) #969

[magnetophon](/magnetophon) opened this issue
Jul 13, 2016
¬∑ 22 comments

Assignees
[![@copumpkin](https://avatars.githubusercontent.com/u/2623?s=40&v=4)](/copumpkin)

Labels
[UX](/NixOS/nix/labels/UX)
The way in which users interact with Nix. Higher level than UI.

## Comments

[![@magnetophon](https://avatars.githubusercontent.com/u/7645711?s=80&u=f323cc7946d4cc96687ff0ea30d2572630cc7413&v=4)](/magnetophon)

Copy link

Member

### **[magnetophon](/magnetophon)** commented [Jul 13, 2016](#issue-165212248)

| Currently the source is only re-fetched when the hash changes. When you use `nix-env -i` to find the new hash, but forget to make a change to the hash, you are stuck with the wrong source.  To add injure to insult: the source is then not re-fetched when you change the hash: you first have to garbage-collect the old source. |
| --- |
| The text was updated successfully, but these errors were encountered: |

All reactions

[![@domenkozar](https://avatars.githubusercontent.com/u/126339?s=80&u=7229d6348ca93e59129e118db025fb1ab111df84&v=4)](/domenkozar)

Copy link

Member

### **[domenkozar](/domenkozar)** commented [Jul 13, 2016](#issuecomment-232332031)

| In fixed-output derivations, the hash is content addressed. We could get URL to be part of the hash, but then mirror/url change would trigger a rebuild, which is very unfortunate.  I propose you change the workflow how you change sources, but I realize that's poor UX. |
| --- |

 üëç
2
 AleXoundOS and CyberShadow reacted with thumbs up emoji

All reactions

* üëç
  2 reactions

Sorry, something went wrong.

[![@copumpkin](https://avatars.githubusercontent.com/u/2623?s=80&v=4)](/copumpkin)

Copy link

Member

### **[copumpkin](/copumpkin)** commented [Jul 13, 2016](#issuecomment-232333974)

| I want to better understand the "stuck with the wrong source" thing you mention because I haven't experienced it, but otherwise I'm basically with [@domenkozar](https://github.com/domenkozar) on this. I don't like the usability aspects either, but I don't know how to retain the nice content-centric properties without something like this.  One option, possibly more work than someone's willing to put into solving this, is for Nix to maintain a local cache of fixed-output derivation output hashes and the regular-derivation-style input hash that led to that output hash. This could be stored as a very simple "output-hash -> regular-derivation-hash" KV mapping. Then it could simply warn you that it's seeing the same output hash coming from a different derivation, which isn't necessarily an error but might be interesting to the user. |
| --- |

All reactions

Sorry, something went wrong.

[![@magnetophon](https://avatars.githubusercontent.com/u/7645711?s=80&u=f323cc7946d4cc96687ff0ea30d2572630cc7413&v=4)](/magnetophon)

Copy link

Member

Author

### **[magnetophon](/magnetophon)** commented [Jul 13, 2016](#issuecomment-232336201)

| [@domenkozar](https://github.com/domenkozar): Could you expand on "I propose you change the workflow how you change sources, but I realize that's poor UX."?  [@copumpkin](https://github.com/copumpkin): What I mean is: nix wil write the old source in the store, under the new name.  It won't re-fetch it if you just change the hash; you have to remove the "old source under the new name" first.  @ the both of you: it seems this issue is not as easy to fix as I hoped. Feel free to close it if you want. |
| --- |

All reactions

Sorry, something went wrong.

[![@copumpkin](https://avatars.githubusercontent.com/u/2623?s=80&v=4)](/copumpkin)

Copy link

Member

### **[copumpkin](/copumpkin)** commented [Jul 13, 2016](#issuecomment-232339080)

| What I mean is: nix wil write the old source in the store, under the new name. It won't re-fetch it if you just change the hash; you have to remove the "old source under the new name" first.  I'm confused. The way Nix thinks about fixed-output derivations is as follows:   1. The content + the derivation name (which in some cases isn't provided by the user) are the only things that identify the data in the store. 2. The other stuff like the URL for `fetchurl` or the git repo specs for `fetchgit`, and basically all the scripts that call `git` or `curl` or whatever are "hints" for how to produce the content in (1). If the content already exists, the scripts won't be run. If the content doesn't exist, and the script produces data with a different hash, Nix will complain that the hash doesn't match and quit.   So here are the scenarios I can think of:   1. Content not in store, and you change the hash without changing e.g., the url for `fetchurl`: Nix will fetch the original URL, check it against the new hash you changed, and complain that the hashes don't match. 2. Content not in store, and you leave the original hash alone: Nix will fetch the original URL, check against the correct hash, and add the result to the store because they match. 3. Content in store, and you change the hash without changing the URL: Nix will fetch the original URL, check it against the new hash, and complain that the hashes don't match. 4. Content in store, and you change the hash and change the URL: Nix will fetch new URL, check against new hash, and accept the new content.   It sounds like you're saying (3) is leaving junk in the store that's identified with the new hash but contains the old data, but that doesn't fit with my understanding of how things work. What am I missing? |
| --- |

All reactions

Sorry, something went wrong.

[![@magnetophon](https://avatars.githubusercontent.com/u/7645711?s=80&u=f323cc7946d4cc96687ff0ea30d2572630cc7413&v=4)](/magnetophon)

Copy link

Member

Author

### **[magnetophon](/magnetophon)** commented [Jul 13, 2016](#issuecomment-232343131)

| [@copumpkin](https://github.com/copumpkin): I'm talking about when you change the version (or name in general) of the pkg and the url, but not the hash. afaik in that case it doesn't matter if the content is already in the store, it'll be stored under the new name.  Sorry for the confusion, hope I'm clear now. |
| --- |

All reactions

Sorry, something went wrong.

[![@veprbl](https://avatars.githubusercontent.com/u/245573?s=80&v=4)](/veprbl)

Copy link

Member

### **[veprbl](/veprbl)** commented [Jul 17, 2016](#issuecomment-233194147)

| I see the opposite in my tests:  ``` Welcome to Nix version 1.11.2. Type :? for help.  nix-repl> let  pkgs = import <nixpkgs> {}; in pkgs.fetchurl { url = "http://example.com/test.tar.gz"; sha256 = "0biw882fp1lmgs6kpxznp1v6758r7dg9x8iv5a06k0b82bcdsc53"; } ¬´derivation /blah/nix/store/9hj80g8r12q74wk6k0wq8zfi1bf6glgn-test.tar.gz.drv¬ª  nix-repl> let  pkgs = import <nixpkgs> {}; in pkgs.fetchurl { url = "http://example.org/test.tar.gz"; sha256 = "0biw882fp1lmgs6kpxznp1v6758r7dg9x8iv5a06k0b82bcdsc53"; } ¬´derivation /blah/nix/store/6zh44fbv7agc7n7il0wprzg6hv1khwha-test.tar.gz.drv¬ª  nix-repl> let  pkgs = import <nixpkgs> {}; in pkgs.stdenv.mkDerivation { name = "test"; src = pkgs.fetchurl { url = "http://example.com/test.tar.gz"; sha256 = "0biw882fp1lmgs6kpxznp1v6758r7dg9x8iv5a06k0b82bcdsc53"; }; } ¬´derivation /blah/nix/store/zbajq1zcsz90z8dnnfxfi5d1a36kk17l-test.drv¬ª  nix-repl> let  pkgs = import <nixpkgs> {}; in pkgs.stdenv.mkDerivation { name = "test"; src = pkgs.fetchurl { url = "http://example.org/test.tar.gz"; sha256 = "0biw882fp1lmgs6kpxznp1v6758r7dg9x8iv5a06k0b82bcdsc53"; }; } ¬´derivation /blah/nix/store/dvhk6cw4am7r9rgyjb1q7rwqdww6cns7-test.drv¬ª  ```  I would think that nix shouldn't care about url change as long as the hash stays the same. But in reality the change of the url gives me both redownload and (massive) rebuild. |
| --- |

All reactions

Sorry, something went wrong.

[![@domenkozar](https://avatars.githubusercontent.com/u/126339?s=80&u=7229d6348ca93e59129e118db025fb1ab111df84&v=4)](/domenkozar)

Copy link

Member

### **[domenkozar](/domenkozar)** commented [Jul 21, 2016](#issuecomment-234238939)

| [@veprbl](https://github.com/veprbl) we're talking about the realized derivation hash, not the derivation hash itself. |
| --- |

 üëç
1
 veprbl reacted with thumbs up emoji
 üòÑ
1
 veprbl reacted with laugh emoji

All reactions

* üëç
  1 reaction
* üòÑ
  1 reaction

Sorry, something went wrong.

[![@changlinli](https://avatars.githubusercontent.com/u/1762540?s=40&v=4)](/changlinli)
[changlinli](/changlinli)
mentioned this issue
[May 13, 2017](#ref-issue-228455595)

[fetchgit no longer complains when rev/hash don't match
NixOS/nixpkgs#25755](/NixOS/nixpkgs/issues/25755)

Open

[![@freeman42x](https://avatars.githubusercontent.com/u/1758708?s=80&u=4e9b9549f5cfe8b5cbb34033d5172f8324aa67a5&v=4)](/freeman42x)

Copy link

### **[freeman42x](/freeman42x)** commented [Feb 3, 2018](#issuecomment-362786187)

| [@magnetophon](https://github.com/magnetophon)  I was getting:  ``` nix-store --delete /nix/store/sfzwi15fsd9wf7qv2rvxwpwr8wk9nkka-AntTweakBar-1.16 error: cannot delete path ‚Äò/nix/store/sfzwi15fsd9wf7qv2rvxwpwr8wk9nkka-AntTweakBar-1.16‚Äô since it is still alive  ```  I run:  ``` nix-store -q --roots /nix/store/sfzwi15fsd9wf7qv2rvxwpwr8wk9nkka-AntTweakBar-1.16  ```  And deleted the results folder mentioned by previous command.  After that nix-build picked up the hanged URL. |
| --- |

All reactions

Sorry, something went wrong.

[![@freeman42x](https://avatars.githubusercontent.com/u/1758708?s=40&u=4e9b9549f5cfe8b5cbb34033d5172f8324aa67a5&v=4)](/freeman42x)
[freeman42x](/freeman42x)
mentioned this issue
[Feb 3, 2018](#ref-pullrequest-294052787)

[AntTweakBar: init at 1.16
NixOS/nixpkgs#34540](/NixOS/nixpkgs/pull/34540)
 Merged

2 tasks

[![@shlevy](https://avatars.githubusercontent.com/u/487050?s=40&u=82c0990bc0a459f23d124535b084eda3114d1c9c&v=4)](/shlevy)
[shlevy](/shlevy)
added
the
[backlog](/NixOS/nix/labels/backlog)
label
[Apr 1, 2018](#event-1551126894)

[![@shlevy](https://avatars.githubusercontent.com/u/487050?s=40&u=82c0990bc0a459f23d124535b084eda3114d1c9c&v=4)](/shlevy)
[shlevy](/shlevy)
assigned [copumpkin](/copumpkin)
[Apr 1, 2018](#event-1551127011)

[![@danieldk](https://avatars.githubusercontent.com/u/49398?s=40&v=4)](/danieldk)
[danieldk](/danieldk)
mentioned this issue
[May 19, 2019](#ref-issue-445763973)

[fetchFromGitHub allows hash and content specified to diverge
NixOS/nixpkgs#61690](/NixOS/nixpkgs/issues/61690)

Closed

[![@domenkozar](https://avatars.githubusercontent.com/u/126339?s=40&u=7229d6348ca93e59129e118db025fb1ab111df84&v=4)](/domenkozar)
[domenkozar](/domenkozar)
removed
the
[backlog](/NixOS/nix/labels/backlog)
label
[Apr 30, 2020](#event-3288512853)

[![@Ma27](https://avatars.githubusercontent.com/u/6025220?s=40&v=4)](/Ma27)
[Ma27](/Ma27)
mentioned this issue
[Jul 20, 2020](#ref-issue-661527673)

[fetchurl: output not reproducible
NixOS/nixpkgs#93518](/NixOS/nixpkgs/issues/93518)

Closed

[![@stale](https://avatars.githubusercontent.com/in/1724?s=80&v=4)](/apps/stale)

Copy link

### **[stale](/apps/stale) bot** commented [Feb 15, 2021](#issuecomment-779396831)

| I marked this as stale due to inactivity. ‚Üí [More info](https://github.com/NixOS/nix/blob/master/.github/STALE-BOT.md) |
| --- |

All reactions

Sorry, something went wrong.

[![@stale](https://avatars.githubusercontent.com/in/1724?s=40&v=4)](/apps/stale)
[stale](/apps/stale)
bot
added
the
[stale](/NixOS/nix/labels/stale)
label
[Feb 15, 2021](#event-4333069081)

[![@baracoder](https://avatars.githubusercontent.com/u/127523?s=40&v=4)](/baracoder)
[baracoder](/baracoder)
mentioned this issue
[Jun 23, 2021](#ref-pullrequest-927447680)

[nvidia\_x11\_beta: 465.31 -> 470.42.01
NixOS/nixpkgs#127812](/NixOS/nixpkgs/pull/127812)
 Merged

11 tasks

[![@fricklerhandwerk](https://avatars.githubusercontent.com/u/6599296?s=40&v=4)](/fricklerhandwerk)
[fricklerhandwerk](/fricklerhandwerk)
added
[UX](/NixOS/nix/labels/UX)
The way in which users interact with Nix. Higher level than UI.
[cli](/NixOS/nix/labels/cli)
The old and/or new command line interface
and removed
[cli](/NixOS/nix/labels/cli)
The old and/or new command line interface
labels
[Sep 12, 2022](#event-7366193940)

[![@7c6f434c](https://avatars.githubusercontent.com/u/1891350?s=40&v=4)](/7c6f434c)
[7c6f434c](/7c6f434c)
mentioned this issue
[Mar 8, 2023](#ref-issue-1614506012)

[Bypass store object reuse when FODs change source description
#7999](/NixOS/nix/issues/7999)

Open

[![@hab25](https://avatars.githubusercontent.com/u/31970961?s=80&v=4)](/hab25)

Copy link

### **[hab25](/hab25)** commented [Dec 22, 2023](#issuecomment-1868004444)

| I marked this as stale due to inactivity. ‚Üí [More info](https://github.com/NixOS/nix/blob/master/.github/STALE-BOT.md)  To remove the stale label, just leave a new comment. |
| --- |

All reactions

Sorry, something went wrong.

[![@stale](https://avatars.githubusercontent.com/in/1724?s=40&v=4)](/apps/stale)
[stale](/apps/stale)
bot
removed
the
[stale](/NixOS/nix/labels/stale)
label
[Dec 22, 2023](#event-11328956645)

[![@tobiasBora](https://avatars.githubusercontent.com/u/2164118?s=80&v=4)](/tobiasBora)

Copy link

### **[tobiasBora](/tobiasBora)** commented [Feb 12, 2024](#issuecomment-1938388202) ‚Ä¢ edited Loading

| I was thinking, would it make sense to add an option like `--force-redownload` that would try to redownload the source of the currently built package, and double check if the hash corresponds? It could help people to quickly check if the hash in a derivation is correct. (**EDIT**: actually, I think the current behavior brings some security issues, let me test it first) |
| --- |

All reactions

Sorry, something went wrong.

[![@lolbinarycat](https://avatars.githubusercontent.com/u/19915050?s=80&v=4)](/lolbinarycat)

Copy link

### **[lolbinarycat](/lolbinarycat)** commented [Mar 7, 2024](#issuecomment-1982322361)

| One option, possibly more work than someone's willing to put into solving this, is for Nix to maintain a local cache of fixed-output derivation output hashes and the regular-derivation-style input hash that led to that output hash.  doesn't nix already track this for garbage collection purposes? `nix-store -q --deriver` and `nix-store -q --valid-derivers` should give you enough information to triangulate this. |
| --- |

All reactions

Sorry, something went wrong.

[![@lolbinarycat](https://avatars.githubusercontent.com/u/19915050?s=40&v=4)](/lolbinarycat)
[lolbinarycat](/lolbinarycat)
mentioned this issue
[Mar 8, 2024](#ref-issue-2168638123)

[Automatic `finalAttrs` pattern migration
NixOS/nixpkgs#293452](/NixOS/nixpkgs/issues/293452)

Open

[![@tobiasBora](https://avatars.githubusercontent.com/u/2164118?s=40&v=4)](/tobiasBora)
[tobiasBora](/tobiasBora)
mentioned this issue
[Apr 29, 2024](#ref-issue-295665843)

[Provide a binary cache for builds
NixOS/ofborg#68](/NixOS/ofborg/issues/68)

Open

[![@tobiasBora](https://avatars.githubusercontent.com/u/2164118?s=80&v=4)](/tobiasBora)

Copy link

### **[tobiasBora](/tobiasBora)** commented [Apr 29, 2024](#issuecomment-2083382876) ‚Ä¢ edited Loading

| I can confirm that this bug can lead to some security issues, described in an email sent to the security team (I'll likely create a public issue soonish). Other potential attacks (if other functionalities like cache sharing between Ofborg and reviewers/hydra is implemented) are described in [NixOS/ofborg#68 (comment)](https://github.com/NixOS/ofborg/issues/68#issuecomment-2083351493)  What I propose to solve this is to keep on each nix installation a map `URL -> hash` (or rather, as suggested by Linus in a private email, a map `derivation -> hash` since fixed-output derivations might be much more general than downloading a file). For any fixed-output derivation, if `hash` is already present on the system, it should first check if the url/derivation is also contained in the database with the appropriate hash. If not, it should re-execute the derivation, check if the hash is correct, and if so continue from the cached value.  EDIT: See my proposition here [NixOS/ofborg#68 (comment)](https://github.com/NixOS/ofborg/issues/68#issuecomment-2085327052) for a more robust version |
| --- |

All reactions

Sorry, something went wrong.

[![@oxij](https://avatars.githubusercontent.com/u/391919?s=40&v=4)](/oxij)
[oxij](/oxij)
mentioned this issue
[May 6, 2024](#ref-pullrequest-2196489189)

[[RFC 0171] Default name of fetchFromGithub FOD to include revision
NixOS/rfcs#171](/NixOS/rfcs/pull/171)
 Closed

[![@oxij](https://avatars.githubusercontent.com/u/391919?s=80&v=4)](/oxij)

Copy link

Member

### **[oxij](/oxij)** commented [May 6, 2024](#issuecomment-2096302974) via email

| [@tobiasBora](https://github.com/tobiasBora) After [@risicle](https://github.com/risicle) pointed me your way in [NixOS/rfcs#171 (comment)](https://github.com/NixOS/rfcs/pull/171#issuecomment-2095639253), and after reading your comments in [NixOS/ofborg#68](https://github.com/NixOS/ofborg/issues/68) I came up with a very simple currently undetectable way to poison Hydra's cache in [NixOS/rfcs#171 (comment)](https://github.com/NixOS/rfcs/pull/171#issuecomment-2096283938):  But now thinking about this, I have an IMHO much simpler and thus scarier attack that \_will\_ work against Hydra: - Malice makes an evil PR with a package update that changes the source's revision to a new version but points the hash to a hash of an older version of the same package, a version which has a well-known CVE. - A very paranoid Nixpkgs maintainer Alice (who does not use any build caches) looks at it, it looks fine, so she builds it, and it works fine, since Alice has the older version of the source in `/nix/store`, and so she merges it. - All tools that track unfixed CVEs in Nixpkgs only look at package versions, so those will be fooled too. - Malice can now exploit the CVE. So, this is actually a critical bug. Merging [NixOS/nixpkgs#49862](https://github.com/NixOS/nixpkgs/pull/49862), setting `nameSourcesPrettily = true` or `nameSourcesPrettily = "full"` by default, and banning of customly-named source derivations is a workaround that will work in the meantime. |
| --- |

 üëç
1
 lolbinarycat reacted with thumbs up emoji

All reactions

* üëç
  1 reaction

Sorry, something went wrong.

[![@tobiasBora](https://avatars.githubusercontent.com/u/2164118?s=80&v=4)](/tobiasBora)

Copy link

### **[tobiasBora](/tobiasBora)** commented [May 6, 2024](#issuecomment-2096337596) ‚Ä¢ edited Loading

| Yes, I actually realized exactly this morning this issue with `fetchzip` and transmitted a MWE to the security team showing that one can use the code of any package controlled by an adversary to inject code into any another package, exploiting the fact that fetchzip removes the package name & version in the attribute name, making the attack trivial to carry: the difference between a malicious & honest derivation is juts one hash.  As a result, I submitted a CVE online.  Patching fetchzip as discussed in [NixOS/rfcs#171](https://github.com/NixOS/rfcs/pull/171) is only a first step but does not stop the slightly more involved cache poisoning attacks. The only robust fix I can think of is what I am proposing in [NixOS/ofborg#68 (comment)](https://github.com/NixOS/ofborg/issues/68#issuecomment-2085327052)  Merging [NixOS/nixpkgs#49862](https://github.com/NixOS/nixpkgs/pull/49862), setting `nameSourcesPrettily = true` or `nameSourcesPrettily = "full"` by default, and banning of customly-named source derivations is a workaround that will work in the meantime.  That might be a first quick mitigation (actually not needed if we implement [NixOS/ofborg#68 (comment)](https://github.com/NixOS/ofborg/issues/68#issuecomment-2085327052)), but not something sufficient. Nobody would realize if a derivation is misnamed, for instance in a long "automatically generating" file. |
| --- |

All reactions

Sorry, something went wrong.

[![@oxij](https://avatars.githubusercontent.com/u/391919?s=80&v=4)](/oxij)

Copy link

Member

### **[oxij](/oxij)** commented [May 6, 2024](#issuecomment-2096916208) via email

| The only robust fix I can think of is what I am proposing in [NixOS/ofborg#68 (comment)](https://github.com/NixOS/ofborg/issues/68#issuecomment-2085327052)  While your algorithm will work if you trust Hydra to do the right thing and check all fixed-output outputs, the problem is that ATM Hydra won't do it because Nix does not do it. I.e. you are trying to prevent poisoning of your local `/nix/store` with an unrelated output substituted from a binary cache, but, as I pointed out above, the attacker can trivially poison your (and Hydra's) `/nix/store` directly too by reusing old hashes.  Merging [NixOS/nixpkgs#49862](https://github.com/NixOS/nixpkgs/pull/49862), setting `nameSourcesPrettily = true` or `nameSourcesPrettily = "full"` by default is one work-around for this. As hinted in [NixOS/rfcs#171 (comment)](https://github.com/NixOS/rfcs/pull/171#issuecomment-2082993487), making `nix-store -r --check` semantics slightly more convenient: - for a normal derivation, when the `outPath` is valid it should build the derivation again and check the result matches the previously known output exactly (as it does now), - for a normal derivations, when the `outPath` is not valid, it should just build the derivation twice and compare the results (the current semantics of failing in this case is surprising and inconvenient), - for a fixed-output, regardless of `outPath` validity, it should always do the build and then check the hash, and then making OfBorg always run `nix-store -r --check` for all affected fixed-output derivations, thus limiting the set of attackers who could poison caches and `/nix/store`s to those who have direct commit access to Nixpkgs, is another work-around for this. But the actual solution is to never reuse outputs between derivations without checking them first, i.e. Nix should remember a mapping of `outPath -> set<drvPath>` for each valid `outPath` in `/nix/store` (ATM Nix only stores one `drvPath` for each valid `outPath`, aka `nix-store -q --deriver`) and `nix-store -r` should force re-build (i.e. `--check`) each given derivation even if the corresponding `outPath` already exists and is valid in `/nix/store` in cases when that `outPath` does not have that `drvPath` in its `set<drvPath>` yet. In other words, `/nix/store` path validity should be changed from being a flag ("is valid") to a predicate ("is valid as an output for this `drvPath`). Similarly, substitutors should provide their `set<drvPath>` for each requested `outPath` to the client Nix'es (somehow) and a client Nix should check those before accepting a substitution. Obviously, without any optimizations that would be incredibly inconvenient, as, among other things, not only changes to URLs and changes between `fetch\*` functions would always cause a rebuild, but also any unrelated changes to `stdenv.mkDerivation` would cause all derivations using any of the `fetch\*` functions to be rebuilt too. One possible way to minimize rebuilds in this case is to implement a tiny `mkDerivationLite` variant of `stdenv.mkDerivationLite` and use that in all `fetch\*` functions. Sure, updating `curl` or `git` will still cause a lot of rebuilds, but for the paranoid this could be a good thing: after all, what if the attacker poisoned one of those somehow. Another way to reduce rebuilds with `drvPath`-predicated-validity is to add a new `outputPathToken` parameter to `derivation` which would declare to Nix that the `outPath` of this derivation is valid for any other derivation that maps to the same `outPath` and uses the same `outputPathToken`, i.e. it would declare an equivalence class of valid `drvPath`s for each `outPath` (i.e., in the above, `set<drvPath>` becomes `set<drvPath or outputPathToken>`). Then, - the current minimal-rebuilds behavior can be archived by always setting `outputPathToken` to some constant, - keeping `outputPathToken` always unset will get you the most paranoid behavior at the cost of most rebuilds, - precise control of what should or should not be rebuilt on changes to fixed-output derivations can be archived by setting `outputPathToken` to different things in different `fetch\*` derivations, e.g. - set `outputPathToken` to the `"fetchurl " + concatSepBy " " (sort urls)` in `fetchurl` so that changes to URLs would cause rebuilds, - set it to `"fetchgit " + url + " rev " + rev` in `fetchgit` so that changes to URLs and revisions would also cause rebuilds, - etc. `nix.conf` could then provide an option to ignore all `outputPathToken` options, for the most paranoid. |
| --- |

All reactions

Sorry, something went wrong.

[![@tobiasBora](https://avatars.githubusercontent.com/u/2164118?s=80&v=4)](/tobiasBora)

Copy link

### **[tobiasBora](/tobiasBora)** commented [May 7, 2024](#issuecomment-2097670970) ‚Ä¢ edited Loading

| I've to admit I don't yet fully grasp all your proposition, but here are a few comments after a first reading:  While your algorithm will work if you trust Hydra to do the right thing and check all fixed-output outputs, the problem is that ATM Hydra won't do it because Nix does not do it.  Well, I precisely want nix to implement it. All other solutions would either not work or require the user to do massive downloads (if the data don't exist, you have no other way than regenerating it yourself) to check all FOD, which can lead to many issues. Not only the user would need to download the (transitive) sources of all packages they want to install, even if they only care about the final binary, by if the source is not available anymore at its current location then the user would not even be able to install the binary (and the security team mentioned me that they don't want to go this path as it used to be this way and created many issues).  I.e. you are trying to prevent poisoning of your local `/nix/store` with an unrelated output substituted from a binary cache, but, as I pointed out above, the attacker can trivially poison your (and Hydra's) `/nix/store` directly too by reusing old hashes.  If one changes nix the way I propose, I don't see how anyone could poison Hydra's cache (of course if we trust Hydra itself‚Ä¶ but one anyway already needs to trust Hydra for many other reasons). The new `derivation -> hash` map is precisely used to say "Hydra checked that this FOD `derivation` evaluates to `hash`", i.e. "no poisoning has been done on this derivation". In particular, old hashes would NOT be part of this trusted map until Hydra checks that they are indeed correct.  setting `nameSourcesPrettily = true` or `nameSourcesPrettily = "full"` by default is one work-around for this.  I don't see it as a true work-around. This makes a very particular attack (downgrading) harder, but there are many other ways to pollute a cache, for instance by adding (e.g. a few months in advance to be sure it is in Hydra' cache) a malicious dependency in some automatically generated files with the name & version of the program to attack.  Nix should remember a mapping of `outPath -> set<drvPath>` for each valid `outPath` in `/nix/store`  I think this is more or less what I proposed, just the maps is in the other way around as I was proposing instead `drvPath -> outPath` & I also propose to let cache.nixos.org/‚Ä¶ share this map.  One possible way to minimize rebuilds [‚Ä¶]  What do you call a rebuild here? Is it in the sense that:   * the FOD output should be re-checked by Hydra, to complete the map `drvPath -> outPath` (which indeed should be done by hydra if the `fetch*` function change, and I guess having a lite version of `mkDerivation` makes sense if these often change) * the FOD output should be re-checked by the end user: this should NOT be the case, at least if hydra already did it before and if we implement the sharing of `drvPath -> outPath` I was proposing above * the whole world should be rebuilt: this should NOT be the case, once the user is assured that the hash is correct they can use the old derivation as before. |
| --- |

All reactions

Sorry, something went wrong.

[![@oxij](https://avatars.githubusercontent.com/u/391919?s=80&v=4)](/oxij)

Copy link

Member

### **[oxij](/oxij)** commented [May 7, 2024](#issuecomment-2097907708) via email

| (of course if we trust Hydra itself‚Ä¶ but one anyway already needs to trust Hydra for many other reasons) What reasons? If I'm not using the Hydra binary cache and I'm not using the default bootstrap tarballs what is there to trust? Tarballs downloaded from Hydra tarball cache get hashed and checked against hashes in their derivations locally, as they should.  I don't see it as a true work-around. This makes a very particular attack (downgrading) harder, but there are many other ways to pollute a cache, for instance by adding (e.g. a few months in advance to be sure it is in Hydra' cache) a malicious dependency in some automatically generated files with the name & version of the program to attack. Putting the whole revision or hash into the source derivation name and banning of customly-named `fetch\*` derivations will make that attack impossible. But even without the first part (and with `<hash>-<name>-<version or short revision>-source` scheme), sure, in theory, the attacker could still poison it by pre-`fetch\*`ing an evil source in an autogenerated files with the same derivation name if the attacker manages guess a version number (or the prefix of the revision) with a CVE they could attack in advance. So... almost never. And then, users like me, that do not build anything from those huge autogenerated files and are not using Hydra binary cache will catch those mis-hashes immediately. I'm running with [NixOS/nixpkgs#49862](https://github.com/NixOS/nixpkgs/pull/49862) and `nameSourcesPrettily = "full"` enabled since 2018 (essentially, implementation details changed over time, but the behavior did not). Do I use a small subset of Nixpkgs? Yes. Do source URLs still fail to fetch sometimes? Yes. But usually things are pretty easy to fix, and older source versions usually can be found on archive servers without changes to any hashes. But now, remembering the uncountable number of times I had to fix fixed-output hashes locally to make my systems build I'm feeling kind of paranoid. Were all those outputs mis-hashed in honest error or were some of them attempts to poison something? Some of those mis-hashes persisted for months in `master` while I was too annoyed with the PR process, thinking them honest errors that would be fixed eventually by people with direct commit access. Was something poisoned already?  ... implementation ... I think this is more or less what I proposed, just the maps is in the other way around as I was proposing instead `drvPath -> outPath` & I also propose to let cache.nixos.org/‚Ä¶ share this map. Yes, algorithmically, we are proposing the same thing, but I'm essentially proposing we reuse the existing Nix derivers mechanism for this and while you are talking about how to make Hydra publish its derivers and make Nix use them, I'm pointing out that Hydra publishing its derivers is not enough: if Hydra does not have the output in its cache yet, then the user will have to `--fallback` build locally, meaning local Nix will have to do the check too, which means checking that the source derivation is in checked derivers set of that output, which would frequently fail, which would mean frequent mass rebuilds, and so I'm proposing a way to minimize those, and `outputPathToken` is a clever and simple solution, IMHO. Precise formats of `outputPathToken` for different `fetch\*`ers and their security implications could and should be discussed. > One possible way to minimize rebuilds [‚Ä¶] What do you call a rebuild here? Is it in the sense that: - the FOD output should be re-checked by Hydra, to complete the map `drvPath -> outPath` (which indeed should be done by hydra if the `fetch\*` function change, and I guess having a lite version of `mkDerivation` makes sense if these often change) I.e., in the terminology I use in my proposal, you are stating that Nix should ask its substitutors for their derivers set for the `outPath` it tries to substitute and then check that source derivation is in that set. To which I agree.  - the FOD output should be re-checked by the end user: this should NOT be the case, at least if hydra already did it before and if we implement the sharing of `drvPath -> outPath` I was proposing above Sure, if substitutors are enabled, then Nix should only do "member in a set" check, not a full derivation rebuild (i.e. `nix-store -r --check`, which is what I call a "rebuild", because `nix build --rebuild` does it).  - the whole world should be rebuilt: this should NOT be the case, once the user is assured that the hash is correct they can use the old derivation as before. But if the user does not use Hydra, and `curl` changed, and the user is feeling sufficiently paranoid, I would think having a way to re-check everything would be a good thing. |
| --- |

All reactions

Sorry, something went wrong.

[![@ShamrockLee](https://avatars.githubusercontent.com/u/44064051?s=40&v=4)](/ShamrockLee)
[ShamrockLee](/ShamrockLee)
mentioned this issue
[May 9, 2024](#ref-pullrequest-2286298723)

[singularity: 4.1.2 -> 4.1.3
NixOS/nixpkgs#310186](/NixOS/nixpkgs/pull/310186)
 Merged

13 tasks

[![@tobiasBora](https://avatars.githubusercontent.com/u/2164118?s=80&v=4)](/tobiasBora)

Copy link

### **[tobiasBora](/tobiasBora)** commented [May 10, 2024](#issuecomment-2104999916) ‚Ä¢ edited Loading

| What reasons?  Anyone relying on `cache.nixos.org` (which is likely 99% of users) need to trust Hydra, as if it can always inject malicious code inside the final binary‚Ä¶ Like Debian users need to trust Debian maintainers. And I don't see how checking the hash can help here, programs are not FOD and their hash may vary across builds in general, so until we have succinct verifiable honest proof of compilation (which, let's be honest, is never going to happen) or at least 100% reproducible builds, we need to trust hydra.  Anyway, the attack I describe would also apply to people NOT using hydra, so building everything from source will not help since it will pick the wrong source.  If the attacker manages guess a version number (or the prefix of the revision) with a CVE they could attack in advance. So... almost never.  I think you misunderstand the attack I have in mind. What I describe allows any adversary to inject arbitrarily malicious code (irrespective of the fact of whether the actual program will have a CVE or not) in a future release of any program, assuming they can simply guess the name of the release‚Ä¶ which is trivial (these usually simply increase one by one and are often pre-released in an alpha form like `3.42-alpha`.  But now, remembering the uncountable number of times I had to fix fixed-output hashes locally  Is it really an experience we want for nix end users?  Was something poisoned already?  Hard to say. I tried to do a quick check in Nixpkgs by looking at duplicated hashes (but it is possible to apply a different attack so that this does not appear that clearly). The number of duplicated hashes is quite large so I used a script to help me to discard the good looking ones, but most of them seem quite honest. Only two physics programs (in pkgs/by-name) were sharing the same hash while having very different names‚Ä¶ but I had no time to investigate further.  which would mean frequent mass rebuilds  I don't see why we would get more rebuilds than now. If a program is in the cache, Hydra already downloaded its source, so the user can rely on Hydra's map. If Hydra has not built the package yet‚Ä¶ anyway the user needs to rebuild everything. And if the package is a "legacy package" in the sense that it was built by Hydra before we even started to add this option, what I propose (maybe what you propose as well, not sure to understand all details) allows the user to only download & check the source while using the binary compiled by Hydra (which saves most of the time-consuming part).  Precise formats of `outputPathToken` for different `fetch*`ers and their security implications could and should be discussed.  I'm not sure to understand all details of your proposition here (maybe because I lack some knowledge of nix's internals) but I think I get the big picture. I think creating equivalent classes of derivations (which, I think, could be a nice concept in general in nix) could be a nice way to limit rebuilds in case of curl updates‚Ä¶ but your implementation with `outputPathToken` raises a number of questions, including in term of security:   * how can we enforce that a FOD cannot change their own `outputPathToken`? If any derivation & fetcher can set this option (as it is the case for now as I understand it), this provides basically no additional security as the attacker could always submit an obfuscated FOD that sets `outputPathTokens` to the one used in `fetchgit`/‚Ä¶ So for this to work `outputPathToken` must be added by a new mechanism in nix, and not via the usual derivation. * the `outputPathToken` should be an indication of the fetcher, but nix should provide command line options to follow or not these recommendations from the fetcher (either in a more or less paranoid way) * if my understanding is correct, `outputPathToken` alone is not sufficient as it does not assert that the hash is correct. Notably, if I try to execute a derivation, and realize that the provided hash is not correct, one MUST REMOVE this derivation from `/nix/store`, otherwise we will have no way of knowing if a derivation really evaluates to a given hash.   So based on the first point, since it seems hard to only allow specify fetchers to create a given `outputPathToken` (unless you know some special tricks?), and since anyway a new nix concept must be introduced, we can maybe deal with this by creating a new kind of derivation that specifies **what** must be downloaded and not **how** to obtain it as it is the case for now. For instance, one could create a derivation like:  ``` Derive([   "kind": "fetchurl",   "url": "myurl",   "out": "/nix/store/foo.tar.xz",   "sha256", "somehash" ])  ```  and nix should automatically understand that when receiving this derivation, it should download the url, using any CURL version they want as soon as the hash matches at the end. If we don't want to hardcode all of them in nix itself (let's try to **keep nix small**), we can let nix take as input a special nix file `trusted-fetchers.nix` containing all the "trusted fetchers". This could be a map like `kind -> fetcher`, such that when nix encounters a custom derivation they are not able to evaluate, nix would resort instead to using the fetcher in the map. This means that we only need to check `trusted-fetchers.nix` instead of nixpkgs in its totality.  More specifically, `fetcher` could be a function taking as input the above derivation, and outputting a bit Ok/Not ok (and possibly an error message) and a folder, such that the folder is kept in `out` by nix iff the bit is true (this bit would be intuitively like "I checked that the hash is correct").  This idea of equivalence of fetchers can certainly be used to also solve other issues with non-deterministic processes. For instance, for now we have no solutions to avoid hash shift with `leaveDotGit = true;`: [NixOS/nixpkgs#8567](https://github.com/NixOS/nixpkgs/issues/8567) and certainly many other package-manager things. One option here would be to create a derivation:  ``` Derive([   "kind": "fetchgit",   "url": "git repo",   "leaveDotGit": true,   "out": "/nix/store/foo.tar.xz",   "sha256", "somehash" ])  ```  where the hash only corresponds to the "stable" part of the package, i.e. what is outside `.git`. The fetcher would then run `git clone` to clone the package, compute the hash of the "valid" part, and output "OK" if this hash is valid.  But if the user does not use Hydra, and `curl` changed, and the user is feeling sufficiently paranoid, I would think having a way to re-check everything would be a good thing.  Well, checking the source, I agree it's nice to have‚Ä¶ but no need to recompile programs. |
| --- |

All reactions

Sorry, something went wrong.

[![@tobiasBora](https://avatars.githubusercontent.com/u/2164118?s=40&v=4)](/tobiasBora)
[tobiasBora](/tobiasBora)
mentioned this issue
[May 10, 2024](#ref-issue-91945224)

[`fetchgit` with `leaveDotGit = true` is still not completely deterministic
NixOS/nixpkgs#8567](/NixOS/nixpkgs/issues/8567)

Open

[![@oxij](https://avatars.githubusercontent.com/u/391919?s=80&v=4)](/oxij)

Copy link

Member

### **[oxij](/oxij)** commented [May 15, 2024](#issuecomment-2112108340) via email

| Well, checking the source, I agree it's nice to have‚Ä¶ but no need to recompile programs. Most of my mentions of "rebuild" above imply the context of "rebuild the source (`<name>.src`) derivation". Package derivations (`<name>`) should not be rebuilt, of course. > What reasons? Anyone relying on `cache.nixos.org` (which is likely 99% of users) need to trust Hydra... ... Anyway, the attack I describe would also apply to people NOT using hydra, so building everything from source will not help since it will pick the wrong source. My point exactly. Some users have personal and/or shared build machines, and `/nix/store`s on those can be poisoned too. So the solution can not be "check derivers on Hydra and/or other configured binary caches", it has to be a general thing. > If the attacker manages guess a version number (or the prefix of the revision) with a CVE they could attack in advance. So... almost never. I think you misunderstand the attack I have in mind. ... I'm referencing the exploit described in [#969 (comment)](https://github.com/NixOS/nix/issues/969#issuecomment-2096302974) there. > But now, remembering the uncountable number of times I had to fix fixed-output hashes locally Is it really an experience we want for nix end users? Well, those hashes are factually wrong, either in honest error, on in malice. That's just the reality of the situation. If Hydra or OfBorg verified them all, then those packages would have been fixed in `master` instead of in my local branches. > which would mean frequent mass rebuilds I don't see why we would get more rebuilds than now. In the context I discuss there, say `curl` changes, now all `<name>.src` derivations that use `fetchurl` have to be rebuilt. > Precise formats of `outputPathToken` for different `fetch\*`ers and their security implications could and should be discussed. ... trusted fetchers ... Hmm, that's a good point. Specifically, yes, `outputPathToken`s is probably not a good solution when the attacker can also modify the `fetch\*` derivations themselves, so it would at the very least still leave OfBorg vulnerable.  ``` Derive([("out", "/nix/store/foo.tar.xz", "sha256", "somehash")], [ "kind": "fetchurl", "url": "myurl", ]) ``` Making full-featured `curl` into a Nix builtin is a possibility (as opposed to `fetchurlBoot` that exists now), but what about derivations fetched with `curl` and then unpacked with `zip` (like `fetchFromGitHub`)? Should `zip` be a builtin too? What about those fetched with `git`? Even if it's just `curl` and `zip`, you'd have also make Nix depend on SSL CA's to verify HTTPS certs, otherwise the hashes could be poisoned on your developer machine by MITMing your Nix HTTP traffic, and ca-certs derivation is also non-trivial. Also, at the moment Nix built with all the optional things disabled is pretty small and can be used for minimal self-bootstrap, requiring all those things will make things harder. So: Is it possible to do? Yes. Is it a desirable solution? Probably not. > Was something poisoned already? Hard to say. I tried to do a quick check in Nixpkgs by looking at duplicated hashes (but it is possible to apply a different attack so that this does not appear that clearly). The number of duplicated hashes is quite large so I used a script to help me to discard the good looking ones, but most of them seem quite honest. Only two physics programs (in pkgs/by-name) were sharing the same hash while having very different names‚Ä¶ but I had no time to investigate further. How are you doing this, exactly? Are you parsing Nix files by hand? `nix-env -f ./default.nix -qa --argstr system "x86\_64-linux" --attr-path --drv-path --out-path` gives the output that has the right data (after all, we need to check that different `--attr-path`s don't reuse or downgrade `--out-path`s), but it only evaluates package derivations, not source derivations. If it did, running that on successive revisions of Nixpkgs, parsing the outputs, building a DB from the results, and then printing `--out-path` reuses and downgrades would be a good first step. (Expensive to do, though. Especially since I don't have enough memory to evaluate all of Nixpkgs in a single run of `nix-env -qa` already, and evaluating a subset is kinda useless, given that any of the autogenerated package sets can be poisoned.) I guess, the simplest way to do this, cheaper than doing `nix-env -qaP` followed by `nix-instantiate -A` on all `--attr-path`s, and then `nix-store -q --requisites`, followed by parsing the `.drv` files manually (which would be crazy expensive to do and will also torture your SSD) would be implementing `nix-env -q --all` option so that `nix-env -f ./default.nix -q --all --argstr system "x86\_64-linux" --attr-path --drv-path --out-path` would print that data for \_all\_ `derivation`s Nix encounters while doing evaluations, not only the ones `--available` from the current Nix expression. My ability to patch Nix sources is fairly superficial ATM and I don't really care for this much, given that [NixOS/nixpkgs#49862](https://github.com/NixOS/nixpkgs/pull/49862) with a small custom-name-warning change on top basically solves the problem for me (given that I don't use Hydra). But it would be nice if someone could implement that `nix-env -q --all` and then possibly somebody else would share all those evaluations on a bunch of revisions of `master`, so that we could check if Hydra and all users using it were PWNed yet. |
| --- |

All reactions

Sorry, something went wrong.

[![@nixos-discourse](https://avatars.githubusercontent.com/u/45043797?s=80&u=2946682fe7c78ac6f742cd670dd17a36444dca27&v=4)](/nixos-discourse)

Copy link

### **[nixos-discourse](/nixos-discourse)** commented [May 20, 2024](#issuecomment-2120573438)

| This issue has been mentioned on **NixOS Discourse**. There might be relevant details there:  <https://discourse.nixos.org/t/nixpkgs-supply-chain-security-project/34345/19> |
| --- |

All reactions

Sorry, something went wrong.

[![@risicle](https://avatars.githubusercontent.com/u/807447?s=40&v=4)](/risicle)
[risicle](/risicle)
mentioned this issue
[May 20, 2024](#ref-pullrequest-2306864690)

[add force-build-new-FODs.sh maintainer script
NixOS/nixpkgs#313248](/NixOS/nixpkgs/pull/313248)
 Open

13 tasks

[![@tobiasBora](https://avatars.githubusercontent.com/u/2164118?s=80&v=4)](/tobiasBora)

Copy link

### **[tobiasBora](/tobiasBora)** commented [May 21, 2024](#issuecomment-2122093466) ‚Ä¢ edited Loading

| I'm not sure why my last answer has not been posted. In the meantime the CVE got published at <https://nvd.nist.gov/vuln/detail/CVE-2024-36050>  Package derivations (`<name>`) should not be rebuilt, of course.  Good, just wanted to be sure we are on the same basis.  So the solution can not be "check derivers on Hydra and/or other configured binary caches", it has to be a general thing.  Definitely agree. My point was just to try to reduce the amount of downloaded materials from the user perspective using the cache **when available**, otherwise users (especially those with little bandwith) would suffer a lot, and if the source is changed they would get 404 error even if it is still cached.  I'm referencing the exploit described in [#969 (comment)](https://github.com/NixOS/nix/issues/969#issuecomment-2096302974) there.  I show here a much more generic attack <https://github.com/leo-colisson/CVE_NixOs_cache_spoil/> with some variants using `fetchurl` instead of `fetchzip` etc. For instance, this:  ``` { pkgs ? import <nixpkgs> {} }: pkgs.callPackage ({stdenv, fetchzip}:   let iconpackage = stdenv.mkDerivation rec {         pname = "iconpackage";         version = "42.0";         src = fetchzip {           url = "http://localhost:8042/iconpackage-${version}.tar.gz"; # <-- this is controlled by the adversary           sha256 = "sha256-kACAk1+Se9vaJN8FkqLRJsOI7szD9zw015nCxxT54bs=";         };         buildPhase = ":";         installPhase = ''           mkdir -p $out/share/icons/hicolor/64x64/apps/           mv myicon.png $out/share/icons/hicolor/64x64/apps/         '';            };       honestpackage = stdenv.mkDerivation rec {         pname = "honestpackage";         version = "1.0";         src = fetchzip {           url = "http://localhost:8042/honestpackage-${version}.tar.gz"; # <-- this is NOT controlled by the adversary           sha256 = "sha256-kACAk1+Se9vaJN8FkqLRJsOI7szD9zw015nCxxT54bs=";         };         buildInputs = [ iconpackage ];         buildPhase = ":";         installPhase = ''           mkdir -p $out/bin           mv honestpackage.sh $out/bin         '';       };   in honestpackage ) {}  ```  Would result in:  ``` $ nix-build $ ./result/bin/honestpackage I am malicious >:-|  ```  In the context I discuss there, say `curl` changes, now all `<name>.src` derivations that use `fetchurl` have to be rebuilt.  Yeah I see now, hence my proposition to have trusted fetchers.  Specifically, yes, `outputPathToken`s is probably not a good solution when the attacker can also modify the `fetch*` derivations themselve  Well, they can always do that, for instance by implementing their own FOD derivation, without even relying on a pre-existing `fetch*` at all.  Making full-featured `curl` into a Nix builtin is a possibility (as opposed to `fetchurlBoot` that exists now), but what about derivations fetched with `curl` and then unpacked with `zip` [‚Ä¶] Is it possible to do? Yes. Is it a desirable solution? Probably not.  That's precisely why I **don't** want to include this in Nix directly, but provide to nix a `trusted-fetcher.nix` file via a command line like `$ nix --trusted-fetchers trusted-fetchers.nix` or simply by picking this file automatically by default. One needs to think carefully about this file, but after a quick thought, it could look like:  ``` {pkgs, ...}: {   "fetchurl" = {     args = [ "url" ];     script = "       ${pkgs.curl}/bin/curl "$url" -O $tmpOut       ${pkgs.sha256sum}/bin/sha256sum $tmpOut > $tmpOutSha     ";   }; }  ```  This way, when a user calls `fetchurl { url = "https://foo.com"; hash = "somehash"; }` it would create a derivation like:  ``` Derivation({   "trustedFetcher": "fetchurl",   "url": "https://foo.com",   "hash": "somehash" })  ```  (see that it is agnostic of `curl`'s version), and to execute it, nix would pick the appropriate fetcher in `trusted-fetchers.nix` (unless it is already present in the cache), run the corresponding script, and compare at the end the content of `$tmpOutSha` with the hash in the derivation. If they match, the it derives from the `hash` of the derivation the final `$out` and copies `$tmpOut` to this path.  How are you doing this, exactly? Are you parsing Nix files by hand?  Right now this is made in a very dirty way, via a simple grep (install `ripgrep`):  ``` import subprocess import os import re  for line in os.popen("rg -o 'hash = \".*\"' --no-filename | sort | uniq -c | sort -hr | rg -v \"1 hash\" | rg -o '\".*\"'").readlines():     print(f"==={line}")     output = os.popen(f"rg -F '{line.strip()}' -C 5").read()     res = re.findall(r'owner ?= ?"[^"]*"', output)     if res and len(res) - len(set(res)) > 0:         print("The owner appears twice, sounds good enough here")         continue     res = re.findall(r'url ?= ?"[^"]*"', output)     if res and len(res) - len(set(res)) > 0:         print("The url appears twice, sounds good enough here")         continue     print(output)     print("===================================================================\n\n\n")  ```  You can see that the number of duplicated hashes is quite large (155), so I try to discard some of them automatically, for instance if I see the same url twice around the good lines, but this is very dirty, and I don't consider this as any good security measure. Even with this sorting there is quite a lot of entries to manually read, so it would be better to actually extract all such `fetch*`, and try to run them (without using the local cache of course, not sure how to do) and see if the hash is actually correct‚Ä¶ |
| --- |

All reactions

Sorry, something went wrong.

[Sign up for free](/join?source=comment-repo)
**to join this conversation on GitHub**.
Already have an account?
[Sign in to comment](/login?return_to=https%3A%2F%2Fgithub.com%2FNixOS%2Fnix%2Fissues%2F969)

Assignees

[![@copumpkin](https://avatars.githubusercontent.com/u/2623?s=40&v=4)](/copumpkin) [copumpkin](/copumpkin)

Labels

[UX](/NixOS/nix/labels/UX)
The way in which users interact with Nix. Higher level than UI.

Projects

None yet

Milestone

No milestone

Development

No branches or pull requests

12 participants

[![@copumpkin](https://avatars.githubusercontent.com/u/2623?s=52&v=4)](/copumpkin) [![@domenkozar](https://avatars.githubusercontent.com/u/126339?s=52&v=4)](/domenkozar) [![@veprbl](https://avatars.githubusercontent.com/u/245573?s=52&v=4)](/veprbl) [![@oxij](https://avatars.githubusercontent.com/u/391919?s=52&v=4)](/oxij) [![@shlevy](https://avatars.githubusercontent.com/u/487050?s=52&v=4)](/shlevy) [![@freeman42x](https://avatars.githubusercontent.com/u/1758708?s=52&v=4)](/freeman42x) [![@tobiasBora](https://avatars.githubusercontent.com/u/2164118?s=52&v=4)](/tobiasBora) [![@fricklerhandwerk](https://avatars.githubusercontent.com/u/6599296?s=52&v=4)](/fricklerhandwerk) [![@magnetophon](https://avatars.githubusercontent.com/u/7645711?s=52&v=4)](/magnetophon) [![@lolbinarycat](https://avatars.githubusercontent.com/u/19915050?s=52&v=4)](/lolbinarycat) [![@hab25](https://avatars.githubusercontent.com/u/31970961?s=52&v=4)](/hab25) [![@nixos-discourse](https://avatars.githubusercontent.com/u/45043797?s=52&v=4)](/nixos-discourse)

## Footer

¬© 2025 GitHub,¬†Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can‚Äôt perform that action at this time.


