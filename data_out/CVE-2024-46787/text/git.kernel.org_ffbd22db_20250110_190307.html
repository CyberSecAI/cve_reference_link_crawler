

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=98cc18b1b71e23fe81a5194ed432b20c2d81a01a)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=98cc18b1b71e23fe81a5194ed432b20c2d81a01a)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=98cc18b1b71e23fe81a5194ed432b20c2d81a01a)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=98cc18b1b71e23fe81a5194ed432b20c2d81a01a)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jann Horn <jannh@google.com> | 2024-08-13 22:25:21 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-09-12 11:12:47 +0200 |
| commit | [98cc18b1b71e23fe81a5194ed432b20c2d81a01a](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=98cc18b1b71e23fe81a5194ed432b20c2d81a01a) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=98cc18b1b71e23fe81a5194ed432b20c2d81a01a)) | |
| tree | [ed592d7740ea824464a2407d9ce811c05892acc8](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=98cc18b1b71e23fe81a5194ed432b20c2d81a01a) | |
| parent | [db978287e908d48b209e374b00d847b2d785e0a9](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=db978287e908d48b209e374b00d847b2d785e0a9) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=98cc18b1b71e23fe81a5194ed432b20c2d81a01a&id2=db978287e908d48b209e374b00d847b2d785e0a9)) | |
| download | [linux-98cc18b1b71e23fe81a5194ed432b20c2d81a01a.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-98cc18b1b71e23fe81a5194ed432b20c2d81a01a.tar.gz) | |

userfaultfd: fix checks for huge PMDscommit 71c186efc1b2cf1aeabfeff3b9bd5ac4c5ac14d8 upstream.
Patch series "userfaultfd: fix races around pmd\_trans\_huge() check", v2.
The pmd\_trans\_huge() code in mfill\_atomic() is wrong in three different
ways depending on kernel version:
1. The pmd\_trans\_huge() check is racy and can lead to a BUG\_ON() (if you hit
the right two race windows) - I've tested this in a kernel build with
some extra mdelay() calls. See the commit message for a description
of the race scenario.
On older kernels (before 6.5), I think the same bug can even
theoretically lead to accessing transhuge page contents as a page table
if you hit the right 5 narrow race windows (I haven't tested this case).
2. As pointed out by Qi Zheng, pmd\_trans\_huge() is not sufficient for
detecting PMDs that don't point to page tables.
On older kernels (before 6.5), you'd just have to win a single fairly
wide race to hit this.
I've tested this on 6.1 stable by racing migration (with a mdelay()
patched into try\_to\_migrate()) against UFFDIO\_ZEROPAGE - on my x86
VM, that causes a kernel oops in ptlock\_ptr().
3. On newer kernels (>=6.5), for shmem mappings, khugepaged is allowed
to yank page tables out from under us (though I haven't tested that),
so I think the BUG\_ON() checks in mfill\_atomic() are just wrong.
I decided to write two separate fixes for these (one fix for bugs 1+2, one
fix for bug 3), so that the first fix can be backported to kernels
affected by bugs 1+2.
This patch (of 2):
This fixes two issues.
I discovered that the following race can occur:
mfill\_atomic other thread
============ ============
<zap PMD>
pmdp\_get\_lockless() [reads none pmd]
<bail if trans\_huge>
<if none:>
<pagefault creates transhuge zeropage>
\_\_pte\_alloc [no-op]
<zap PMD>
<bail if pmd\_trans\_huge(\*dst\_pmd)>
BUG\_ON(pmd\_none(\*dst\_pmd))
I have experimentally verified this in a kernel with extra mdelay() calls;
the BUG\_ON(pmd\_none(\*dst\_pmd)) triggers.
On kernels newer than commit 0d940a9b270b ("mm/pgtable: allow
pte\_offset\_map[\_lock]() to fail"), this can't lead to anything worse than
a BUG\_ON(), since the page table access helpers are actually designed to
deal with page tables concurrently disappearing; but on older kernels
(<=6.4), I think we could probably theoretically race past the two
BUG\_ON() checks and end up treating a hugepage as a page table.
The second issue is that, as Qi Zheng pointed out, there are other types
of huge PMDs that pmd\_trans\_huge() can't catch: devmap PMDs and swap PMDs
(in particular, migration PMDs).
On <=6.4, this is worse than the first issue: If mfill\_atomic() runs on a
PMD that contains a migration entry (which just requires winning a single,
fairly wide race), it will pass the PMD to pte\_offset\_map\_lock(), which
assumes that the PMD points to a page table.
Breakage follows: First, the kernel tries to take the PTE lock (which will
crash or maybe worse if there is no "struct page" for the address bits in
the migration entry PMD - I think at least on X86 there usually is no
corresponding "struct page" thanks to the PTE inversion mitigation, amd64
looks different).
If that didn't crash, the kernel would next try to write a PTE into what
it wrongly thinks is a page table.
As part of fixing these issues, get rid of the check for pmd\_trans\_huge()
before \_\_pte\_alloc() - that's redundant, we're going to have to check for
that after the \_\_pte\_alloc() anyway.
Backport note: pmdp\_get\_lockless() is pmd\_read\_atomic() in older kernels.
Link: [https://lkml.kernel.org/r/20240813-uffd-thp-flip-fix-v2-0-5efa61078a41@google.com](https://lkml.kernel.org/r/20240813-uffd-thp-flip-fix-v2-0-5efa61078a41%40google.com)
Link: [https://lkml.kernel.org/r/20240813-uffd-thp-flip-fix-v2-1-5efa61078a41@google.com](https://lkml.kernel.org/r/20240813-uffd-thp-flip-fix-v2-1-5efa61078a41%40google.com)
Fixes: c1a4de99fada ("userfaultfd: mcopy\_atomic|mfill\_zeropage: UFFDIO\_COPY|UFFDIO\_ZEROPAGE preparation")
Signed-off-by: Jann Horn <jannh@google.com>
Acked-by: David Hildenbrand <david@redhat.com>
Cc: Andrea Arcangeli <aarcange@redhat.com>
Cc: Hugh Dickins <hughd@google.com>
Cc: Jann Horn <jannh@google.com>
Cc: Pavel Emelyanov <xemul@virtuozzo.com>
Cc: Qi Zheng <zhengqi.arch@bytedance.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=98cc18b1b71e23fe81a5194ed432b20c2d81a01a)

| -rw-r--r-- | [mm/userfaultfd.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/mm/userfaultfd.c?id=98cc18b1b71e23fe81a5194ed432b20c2d81a01a) | 22 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 12 insertions, 10 deletions

| diff --git a/mm/userfaultfd.c b/mm/userfaultfd.cindex 335de81ae5d415..75f47706882fb1 100644--- a/[mm/userfaultfd.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/userfaultfd.c?id=db978287e908d48b209e374b00d847b2d785e0a9)+++ b/[mm/userfaultfd.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/userfaultfd.c?id=98cc18b1b71e23fe81a5194ed432b20c2d81a01a)@@ -787,21 +787,23 @@ retry: }  dst\_pmdval = pmdp\_get\_lockless(dst\_pmd);- /\*- \* If the dst\_pmd is mapped as THP don't- \* override it and just be strict.- \*/- if (unlikely(pmd\_trans\_huge(dst\_pmdval))) {- err = -EEXIST;- break;- } if (unlikely(pmd\_none(dst\_pmdval)) && unlikely(\_\_pte\_alloc(dst\_mm, dst\_pmd))) { err = -ENOMEM; break; }- /\* If an huge pmd materialized from under us fail \*/- if (unlikely(pmd\_trans\_huge(\*dst\_pmd))) {+ dst\_pmdval = pmdp\_get\_lockless(dst\_pmd);+ /\*+ \* If the dst\_pmd is THP don't override it and just be strict.+ \* (This includes the case where the PMD used to be THP and+ \* changed back to none after \_\_pte\_alloc().)+ \*/+ if (unlikely(!pmd\_present(dst\_pmdval) || pmd\_trans\_huge(dst\_pmdval) ||+ pmd\_devmap(dst\_pmdval))) {+ err = -EEXIST;+ break;+ }+ if (unlikely(pmd\_bad(dst\_pmdval))) { err = -EFAULT; break; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 19:01:44 +0000

