```
{
  "vulnerability": {
    "root_cause": "The TCP option parser in synproxy (synproxy_parse_options) could read one byte out of bounds.",
    "weaknesses": [
      "Out-of-bounds read"
    ],
    "impact": "Reading out of bounds memory.",
    "attack_vectors": "A crafted TCP packet with specific option lengths can trigger the out-of-bounds read.",
    "required_capabilities": "Attacker needs to be able to send network packets to the vulnerable system."
  },
   "commits": [
    {
      "commit_id": "f648089337cb8ed40b2bb96e244f72b9d97dc96b",
      "commit_message": "netfilter: synproxy: Fix out of bounds when parsing TCP options",
      "commit_details": "The TCP option parser in synproxy (synproxy_parse_options) could read one byte out of bounds. When the length is 1, the execution flow gets into the loop, reads one byte of the opcode, and if the opcode is neither TCPOPT_EOL nor TCPOPT_NOP, it reads one more byte, which exceeds the length of 1.\nThis fix is inspired by commit 9609dad263f8 (\"ipv4: tcp_input: fix stack out of bounds when parsing TCP options.\").\nv2 changes:\nAdded an early return when length < 0 to avoid calling skb_header_pointer with negative length."
    },
    {
      "commit_id": "5fc177ab759418c9537433e63301096e733fb915",
      "commit_message": "netfilter: synproxy: Fix out of bounds when parsing TCP options",
       "commit_details": "The TCP option parser in synproxy (synproxy_parse_options) could read one byte out of bounds. When the length is 1, the execution flow gets into the loop, reads one byte of the opcode, and if the opcode is neither TCPOPT_EOL nor TCPOPT_NOP, it reads one more byte, which exceeds the length of 1.\nThis fix is inspired by commit 9609dad263f8 (\"ipv4: tcp_input: fix stack out of bounds when parsing TCP options.\").\nv2 changes:\nAdded an early return when length < 0 to avoid calling skb_header_pointer with negative length."
    },
     {
      "commit_id": "576c1526b4d83c44ad7b673cb841f36cbc6cb6c4",
      "commit_message": "netfilter: synproxy: Fix out of bounds when parsing TCP options",
       "commit_details": "The TCP option parser in synproxy (synproxy_parse_options) could read one byte out of bounds. When the length is 1, the execution flow gets into the loop, reads one byte of the opcode, and if the opcode is neither TCPOPT_EOL nor TCPOPT_NOP, it reads one more byte, which exceeds the length of 1.\nThis fix is inspired by commit 9609dad263f8 (\"ipv4: tcp_input: fix stack out of bounds when parsing TCP options.\").\nv2 changes:\nAdded an early return when length < 0 to avoid calling skb_header_pointer with negative length."
    },
    {
      "commit_id": "7d9a9a1a88a3da574e019b4de756bc73337b3b0b",
      "commit_message": "netfilter: synproxy: Fix out of bounds when parsing TCP options",
       "commit_details":"The TCP option parser in synproxy (synproxy_parse_options) could read one byte out of bounds. When the length is 1, the execution flow gets into the loop, reads one byte of the opcode, and if the opcode is neither TCPOPT_EOL nor TCPOPT_NOP, it reads one more byte, which exceeds the length of 1.\nThis fix is inspired by commit 9609dad263f8 (\"ipv4: tcp_input: fix stack out of bounds when parsing TCP options.\").\nv2 changes:\nAdded an early return when length < 0 to avoid calling skb_header_pointer with negative length."
    },
    {
      "commit_id":"e1eb98cfeafdd85537e7e3cefe93ca9bfbcc3ea8",
       "commit_message": "netfilter: synproxy: Fix out of bounds when parsing TCP options",
      "commit_details": "The TCP option parser in synproxy (synproxy_parse_options) could read one byte out of bounds. When the length is 1, the execution flow gets into the loop, reads one byte of the opcode, and if the opcode is neither TCPOPT_EOL nor TCPOPT_NOP, it reads one more byte, which exceeds the length of 1.\nThis fix is inspired by commit 9609dad263f8 (\"ipv4: tcp_input: fix stack out of bounds when parsing TCP options.\").\nv2 changes:\nAdded an early return when length < 0 to avoid calling skb_header_pointer with negative length."
    },
    {
      "commit_id": "674b5f0c6a4fc5d3abce877048290cea6091fcb1",
      "commit_message": "netfilter: synproxy: Fix out of bounds when parsing TCP options",
       "commit_details":"The TCP option parser in synproxy (synproxy_parse_options) could read one byte out of bounds. When the length is 1, the execution flow gets into the loop, reads one byte of the opcode, and if the opcode is neither TCPOPT_EOL nor TCPOPT_NOP, it reads one more byte, which exceeds the length of 1.\nThis fix is inspired by commit 9609dad263f8 (\"ipv4: tcp_input: fix stack out of bounds when parsing TCP options.\").\nv2 changes:\nAdded an early return when length < 0 to avoid calling skb_header_pointer with negative length."
    },
     {
      "commit_id": "9cdf299ba4e153b5e56187648420de22c6216f02",
      "commit_message": "netfilter: synproxy: Fix out of bounds when parsing TCP options",
       "commit_details":"The TCP option parser in synproxy (synproxy_parse_options) could read one byte out of bounds. When the length is 1, the execution flow gets into the loop, reads one byte of the opcode, and if the opcode is neither TCPOPT_EOL nor TCPOPT_NOP, it reads one more byte, which exceeds the length of 1.\nThis fix is inspired by commit 9609dad263f8 (\"ipv4: tcp_input: fix stack out of bounds when parsing TCP options.\").\nv2 changes:\nAdded an early return when length < 0 to avoid calling skb_header_pointer with negative length."
    },
     {
       "commit_id": "6defc77d48eff74075b80ad5925061b2fc010d98",
      "commit_message": "netfilter: synproxy: Fix out of bounds when parsing TCP options",
       "commit_details": "The TCP option parser in synproxy (synproxy_parse_options) could read one byte out of bounds. When the length is 1, the execution flow gets into the loop, reads one byte of the opcode, and if the opcode is neither TCPOPT_EOL nor TCPOPT_NOP, it reads one more byte, which exceeds the length of 1.\nThis fix is inspired by commit 9609dad263f8 (\"ipv4: tcp_input: fix stack out of bounds when parsing TCP options.\").\nv2 changes:\nAdded an early return when length < 0 to avoid calling skb_header_pointer with negative length."
    }
  ]
}
```