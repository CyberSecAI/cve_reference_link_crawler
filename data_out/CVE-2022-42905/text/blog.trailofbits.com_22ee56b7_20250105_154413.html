
# [Trail of Bits Blog](https://blog.trailofbits.com/ "Trail of Bits Blog")

##

# Menu

[Skip to content](#content "Skip to content")

* [Home](https://blog.trailofbits.com/)

# Keeping the wolves out of wolfSSL

* Post
* [January 12, 2023](https://blog.trailofbits.com/2023/01/12/wolfssl-vulnerabilities-tlspuffin-fuzzing-ssh/ "8:00 am")
* [Leave a comment](https://blog.trailofbits.com/2023/01/12/wolfssl-vulnerabilities-tlspuffin-fuzzing-ssh/#respond)

***By Max Ammann***

Trail of Bits is publicly disclosing four vulnerabilities that affect wolfSSL: [CVE-2022-38152](https://www.cve.org/CVERecord?id=CVE-2022-38152), [CVE-2022-38153](https://www.cve.org/CVERecord?id=CVE-2022-38153), [CVE-2022-39173](https://www.cve.org/CVERecord?id=CVE-2022-39173), and [CVE-2022-42905](https://www.cve.org/CVERecord?id=CVE-2022-42905). The four issues, which have CVSS scores ranging from medium to critical, can all result in a denial of service (DoS). These vulnerabilities have been discovered automatically using the novel protocol fuzzer [tlspuffin](https://github.com/tlspuffin/tlspuffin). This blog post will explore these vulnerabilities, then provide an in-depth overview of the fuzzer.

tlspuffin is a fuzzer inspired by formal protocol verification. Initially developed as part of my internship at [LORIA, INRIA, France](https://www.loria.fr/en/), it is especially targeted against cryptographic protocols like TLS or SSH.

During my internship at Trail of Bits, we pushed protocol fuzzing even further by supporting a new protocol (SSH), adding more fuzzing targets, and (re)discovering vulnerabilities. This work represents a milestone in the development of the first [Dolev-Yao model](https://en.wikipedia.org/wiki/Dolev%E2%80%93Yao_model)-guided fuzzer. By supporting an additional protocol, we proved that our fuzzing approach is agnostic with respect to the protocol. Going forward, we aim to support other protocols such as QUIC, OpenVPN, and WireGuard.

## Targeting wolfSSL

During my internship at Trail of Bits, we added several versions of wolfSSL as fuzzing targets. The wolfSSL library was an ideal choice because it was affected by two authentication vulnerabilities that were discovered in early 2022 ([CVE-2022-25640](https://www.cve.org/CVERecord?id=CVE-2022-25640) and [CVE-2022-25638](https://www.cve.org/CVERecord?id=CVE-2022-25638)). That meant we could verify that tlspuffin works by using it to rediscover the known vulnerabilities.

As tlspuffin is written in Rust, we first had to write bindings to wolfSSL. While the bindings were being implemented, several bugs were discovered in the OpenSSL compatibility layer that have also been reported to the wolfSSL team. With the bindings ready, we were ready to let the fuzzer do its job: discovering weird states within wolfSSL.

## Discovered Vulnerabilities

During my internship, I discovered several vulnerabilities in wolfSSL, which can result in a denial of service (DoS).

* **DOSC:** [CVE-2022-38153](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-38153) allows MitM actors or malicious servers to perform a DoS attack against TLS 1.2 clients by intercepting and modifying a TLS packet. This vulnerability affects wolfSSL 5.3.0.
* **DOSS:** [CVE-2022-38152](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-38152) is a DoS vulnerability against wolfSSL servers that use the `wolfSSL_clear` function instead of the sequence `wolfSSL_free; wolfSSL_new`. Resuming a session causes the server to crash with a NULL-pointer dereference. This vulnerability affects wolfSSL 5.3.0 to 5.4.0.
* **BUF:** [CVE-2022-39173](https://www.cve.org/CVERecord?id=CVE-2022-39173) is caused by a buffer overflow and causes a DoS of wolfSSL servers. It is caused by pretending to resume a session, and sending duplicate cipher suites in the Client Hello. It might allow an attacker to gain RCE on certain architectures or targets; however, this has not yet been confirmed. Versions of wolfSSL before 5.5.1 are affected.
* **HEAP:** [CVE-2022-42905](https://www.cve.org/CVERecord?id=CVE-2022-42905) is caused by a buffer overread while parsing TLS record headers. Versions of wolfSSL before 5.5.2 are affected.

### “A few CVEs for wolfSSL, one giant leap for tlspuffin.”

The vulnerabilities mark a milestone for the fuzzer: They are the first vulnerabilities found using this tool that have a far-reaching impact. We can also confidently say that this vulnerability would not have been easy to find with classical bit-level fuzzers. It’s especially intriguing that on average, the fuzzer took less than one hour to discover a vulnerability and crash.

While preparing the fuzzing setup for wolfSSL, we also discovered a severe memory leak that was caused by misuse of the wolfSSL API. This issue was reported to the wolfSSL team, [changed their documentation](https://github.com/wolfSSL/wolfssl/pull/5483) to help users avoid the leak. Additionally, several other code-quality issues have been reported to wolfSSL, and their team fixed all of our findings within one week of disclosure. If a “best coordinated disclosure” award existed, the wolfSSL team would definitely win it.

The following sections will focus on two of the vulnerabilities because of their higher impact and expressive attack traces.

### **DOSC:** Denial of service against clients

In wolfSSL 5.3.0, MiTM attackers or malicious servers can crash TLS clients. The bug lives in the `AddSessionToCache` function, which is called when the client receives a new session ticket from the server.

Let’s assume that each bucket of the session cache of wolfSSL contains at least one entry. As soon as a new session ticket arrives, the client will reuse a previously stored cache entry to try to cache it in the session cache. Additionally, because the new session ticket is quite large at 700 bytes, it will be allocated on the heap using `XMALLOC`.

In the following example, `SESSION_TICKET_LEN` is 256:

```
if (ticLen > SESSION_TICKET_LEN) {
    ticBuff = (byte*)XMALLOC(ticLen, NULL,
            DYNAMIC_TYPE_SESSION_TICK);
    …
}

```

[ssl.c:13442](https://github.com/wolfSSL/wolfssl/blob/e722c15be860794179082a05d09e6a90dc77ccf0/src/ssl.c)

This allocation leads to the initialization of `cacheTicBuff`, as `ticBuff` is already initialized, `cacheSession->ticketLenAlloc` is 0, and `ticLen` is 700:

```
if (ticBuff != NULL && cacheSession->ticketLenAlloc < ticLen) {
    cacheTicBuff = cacheSession->ticket;
    …
}

```

[ssl.c:13500](https://github.com/wolfSSL/wolfssl/blob/e722c15be860794179082a05d09e6a90dc77ccf0/src/ssl.c)

The `cacheTicBuff` is set to the ticket of a previous session, `cacheSession->ticket`. The memory to which `cacheTicBuff` points is not allocated on the heap; in fact, `cacheTicBuff` points to `cacheSession->_staticTicket`. This is problematic because the `cacheTicBuff` is later freed if it is not null.

```
if (cacheTicBuff != NULL)
     XFREE(cacheTicBuff, NULL, DYNAMIC_TYPE_SESSION_TICK);

```

[ssl.c:13557](https://github.com/wolfSSL/wolfssl/blob/e722c15be860794179082a05d09e6a90dc77ccf0/src/ssl.c)

The process terminates by executing the `XFREE` function, as the passed pointer is not allocated on the heap.

Note that the ticket length in itself is not the cause of the crash. This vulnerability is quite different to [Heartbleed](https://heartbleed.com/), the buffer over-read vulnerability discovered in OpenSSL. With wolfSSL, a crash is caused not by overflowing buffers but by a logical bug.

### Finding weird states

The fuzzer discovered the vulnerability in about one hour. The fuzzer modified the `NewSessionTicket` (`new_message_ticket`) message by replacing an actual ticket with a large array of 700 bytes (`large_bytes_vec`). This mutation of an otherwise-sane trace leads to a call of `XFREE` on a non-allocated value. This eventually leads to a crash of the client that receives such a large ticket.

[![](https://blog.trailofbits.com/wp-content/uploads/2023/01/Screenshot-2023-01-09-at-2.15.34-PM-1024x520.png)](https://blog.trailofbits.com/wp-content/uploads/2023/01/Screenshot-2023-01-09-at-2.15.34-PM.png)

Visualized exploit for DOSC ([CVE-2022-38153](https://www.cve.org/CVERecord?id=CVE-2022-38153)). Each box represents a TLS message. Each message is composed of different fields like a protocol version or a vector of cipher suites. The visualization was generated using the tlspuffin fuzzer and mirrors the structure of the DY attacker traces which will be introduced in the next section.

A single execution of the above trace is not enough to reach the vulnerable code. As the bug resides in the session cache of wolfSSL, we need to let the client cache fill up in order to trigger the crash. Empirically, we discovered that about 30 prior connections are needed to reliably crash them. The reason for the random behavior is that the cache consists of multiple rows or buckets; the default compilation configuration of wolfSSL contains 11 buckets. Based on the hash of the TLS session ID, sessions are stored in one of these buckets. The DoS is triggered only if the current bucket already contains a previous session.

Reproducing this vulnerability is difficult, as a prepared state is required to reach the behavior. In general, a global state such as the wolfSSL cache makes fuzzing more difficult to apply. Ideally, one might assume that each execution of a program yields the same outputs given the identical inputs. Reproduction and debugging become more challenging if this assumption is violated because the program uses a global state; this represents a general challenge when fuzzing unknown targets.

Fortunately, tlspuffin allows researchers to recreate a program state that is similar to the one that was present when the fuzzer observed a crash. We were able to re-execute all the traces that the fuzzer rated as interesting, which allowed us to observe the crash of wolfSSL in a more controlled environment and to debug wolfSSL using GDB. After analyzing the call stack that led to the invalid free, it was clear that the bug was related to the session cache.

The root cause for **DOSC** lies in the usage of a shared global state. It was very surprising to find that wolfSSL shares the state between multiple invocations of the library. Conceptually, the lifetime of the session cache should be bound to the TLS context, which already serves as a container for TLS session. Each SSL session shares the state with the TLS context. The addition of maintaining a global mutable state increases complexity throughout a codebase. Therefore, it should be used only when absolutely necessary.

## **BUF:** Buffer overflow on servers

In versions of wolfSSL before 5.5.1, malicious clients can cause a buffer overflow during a resumed TLS 1.3 handshake. If an attacker resumes or pretends to resume a previous TLS session by sending a maliciously crafted Client Hello followed by another maliciously crafted Client Hello, then a buffer overflow is possible. A minimum of two Client Hellos must be sent: one that pretends to resume a previous session, and a second as a response to a Hello Retry Request message.

The malicious Client Hellos contain a list of supported cipher suites, which contain at least `⌊sqrt(150)⌋ + 1 = 13` duplicates and fewer than 150 ciphers in total. The buffer overflow occurs in the second invocation `RefineSuites` function during a handshake.

```

/* Refine list of supported cipher suites to those common to server and
client.
*
* ssl         SSL/TLS object.
* peerSuites  The peer's advertised list of supported cipher suites.
*/
static void RefineSuites(WOLFSSL* ssl, Suites* peerSuites)
{
    byte   suites[WOLFSSL_MAX_SUITE_SZ];
    word16 suiteSz = 0;
    word16 i, j;

  XMEMSET(suites, 0, WOLFSSL_MAX_SUITE_SZ);

  for (i = 0; i < ssl->suites->suiteSz; i += 2) {
      for (j = 0; j < peerSuites->suiteSz; j += 2) {
          if (ssl->suites->suites[i+0] == peerSuites->suites[j+0] &&
              ssl->suites->suites[i+1] == peerSuites->suites[j+1]) {
              suites[suiteSz++] = peerSuites->suites[j+0];
              suites[suiteSz++] = peerSuites->suites[j+1];
          }
      }
  }

  ssl->suites->suiteSz = suiteSz;
  XMEMCPY(ssl->suites->suites, &suites, sizeof(suites));
#ifdef WOLFSSL_DEBUG_TLS
[...]
#endif
}
```

[tls13.c:4355](https://raw.githubusercontent.com/wolfSSL/wolfssl/v5.4.0-stable/src/ssl.c)

The `RefineSuites` function expects a `struct WOLFSSL` that contains a list of acceptable ciphers suites at `ssl->suites`, as well as an array of peer cipher suites. Both inputs are bounded by `WOLFSSL_MAX_SUITE_SZ`, which is equal to 150 cipher suites or 300 bytes.

Let us assume that `ssl->suites` consists of a single cipher suite like `TLS_AES_256_GCM_SHA384` and that the user-controllable `peerSuites` list contains the same cipher repeated 13 times. The `RefineSuites` function will iterate for each suite in `ssl->suites` over `peerSuites` and append the suite to the `suites` array if it is a match. The suites array has a maximum length of `WOLFSSL_MAX_SUITE_SZ` suites.

With the just-mentioned input, the length of `suites` equals now 13. The suites array is now copied to the struct `WOLFSSL` in the last line of the listing above. Therefore, the `ssl->suites` array now contains 13 `TLS_AES_256_GCM_SHA384` cipher suites.

During a presumably resumed TLS handshake, the `RefineSuites` function is called again if a Hello Retry Request is triggered by the client. The `struct WOLFSSL` is not reset in between and keeps the previous suites of 13 cipher suites. Because the TLS peer controls the `peerSuites` array, we assume that it again contains 13 duplicate cipher suites.

The `RefineSuites` function will iterate for each element in `ssl->suites` over `peerSuites` and append the suite to suites if it is a match. Because the `ssl->suites`

array contains already `13 TLS_AES_256_GCM_SHA384` cipher suites, in total 13 x 13 = 169 cipher suites are written to suites. The 169 cipher suites exceed the allocated maximum allowed `WOLFSSL_MAX_SUITE_SZ` cipher suites. The `suites` buffer overflows on the stack.

So far, we have been unable to exploit this bug and, for example, gain remote code execution because the set of bytes that can overflow the suites buffer is small. Only valid cipher suite values can overflow the buffer.

Because of space constraints, we are not providing a detailed review of the mutations that are required in order to mutate a sane trace to an attack trace, as we did with **DOSC**.

To understand how we found these vulnerabilities, it is worth examining how tlspuffin was developed.

## Next Generation Protocol Fuzzing

History has proven that the implementation of cryptographic protocols is prone to errors. It’s easy to introduce logical flaws when translating specifications like RFC or scientific articles to actual program code. In 2017, researchers discovered that the well-known WPA2 protocol suffered severe flaws ([KRACK](https://www.krackattacks.com/)). Vulnerabilities like [FREAK](https://freakattack.com/), or authentication vulnerabilities like the wolfSSL bugs found in early 2022 ([CVE-2022-25640](https://www.cve.org/CVERecord?id=CVE-2022-25640) and [CVE-2022-25638](https://www.cve.org/CVERecord?id=CVE-2022-25638)), support this idea.

It is challenging to fuzz implementations of cryptographic protocols. Unlike traditional fuzzing of file formats, cryptographic protocols require a specific flow of cryptographic and mutually dependent messages to reach deep protocol states.

Additionally, detecting logical bugs is a challenge on its own. The AddressSanitizer enables security researchers to reliably find memory-related issues. For logical bugs like authentication bypasses or loss of confidentiality no automated detectors exist.

These challenges are why I and Inria set out to design tlspuffin. The fuzzer is guided by the so-called Dolev-Yao model, which has been used in formal protocol verification since the 1980s.

## The Dolev-Yao Model

Formal methods have become an essential tool in the security analysis of cryptographic protocols. Modern tools like [ProVerif](https://bblanche.gitlabpages.inria.fr/proverif/) or [Tamarin](https://tamarin-prover.github.io/) feature a fully automated framework to model and verify security protocols. The [ProVerif manual](https://bblanche.gitlabpages.inria.fr/proverif/manual.pdf) and [DEEPSEC paper](https://ieeexplore.ieee.org/document/8418623) provide a good introduction to protocol verification. The underlying theory of these tools uses a symbolic model—the Dolev-Yao model—that originates from the work of [Dolev and Yao](https://doi.org/10.1109/TIT.1983.1056650).

With Dolev-Yao models, attackers have full control over the messages being sent within the communication network. Messages are modeled symbolically using a term algebra, which consists of a set of function symbols and variables. This means that messages can be represented by applying functions over variables and other functions.

An adversary can eavesdrop on, inject, or manipulate messages; the Dolev-Yao model is meant to simulate real-world attacks on these protocols, such as Man-in-the-Middle (MitM)-style attacks. The cryptographic primitives are modeled through abstracted semantics because the Dolev-Yao model focuses on finding logical protocol flaws and is not concerned with correctness of cryptographic primitives. Because the primitives are described through an abstract semantic, there is no real implementation of, for example, RSA or AES defined in the Dolev-Yao model.

It was already possible to find attacks in the cryptographic protocols using this model. The TLS specification has already undergone various analyses by these tools in [2006](https://doi.org/10.1145/1455770.1455828) and [2017](https://doi.org/10.1109/SP.2017.26), which led to fixes in RFC drafts. But in order to fuzz implementations of protocols, instead of verifying their specification, we need to do things slightly differently. We chose to replace the abstract semantics with a more concrete one which includes implementations of primitives.

The tlspuffin fuzzer was designed based on the Dolev-Yao model and guided by the symbolic formal model, which means that it can execute any protocol flow that is representable in the Dolev-Yao model. It can also generate previously unseen protocol executions. The following section explains the notion of Dolev-Yao traces, which are loosely based on the Dolev-Yao model.

## Dolev-Yao Traces

Dolev-Yao traces build on top of the Dolev-Yao model and also use a term algebra to represent messages symbolically. Just like in the Dolev-Yao model, the cryptographic primitives are treated as black boxes. This allows the fuzzer to focus on logical bugs, instead of testing cryptographic primitives for their correctness.

Let’s start with an example of the infamous Needham-Schröder protocol. If you aren’t familiar, Needham-Schröder is an authentication protocol that allows two parties to establish a shared secret through a trusted server; however, its asymmetric version is infamous for being susceptible to an MitM attack.

The protocol allows Alice and Bob to create a shared secret through a trusted third-party server. The protocol works by requesting a shared secret from the server that is encrypted once for Bob and once for Alice. Alice can request a fresh secret from the server and will receive an encrypted message that contains the shared secret and a further encrypted message addressed to Bob. Alice will forward the message to Bob. Bob can now decrypt the message and also has access to the shared secret.

The flaw in the protocol allows an imposter to impersonate Alice by first initiating a connection with Alice and then forwarding the received data to Bob. (For a deeper understanding of the protocol, we suggest reading its [Wikipedia article](https://en.wikipedia.org/wiki/Needham%E2%80%93Schroeder_protocol#The_public-key_protocol).)

In the below Dolev-Yao trace T, we model one specific execution of the Needham-Schröder protocol between the two agents with the names a and b. Each agent has an underlying implementation. The trace consists of a concatenation of steps that are delimited by a dot. There are two kinds of steps: input and output. Output steps are denoted by a bar above the agent name.

[![](https://blog.trailofbits.com/wp-content/uploads/2023/01/Screenshot-2023-01-09-at-2.51.04-PM-1024x383.png)](https://blog.trailofbits.com/wp-content/uploads/2023/01/Screenshot-2023-01-09-at-2.51.04-PM.png)

Dolev-Yao attack trace for the Needham-Schröder protocol

Let’s now describe the semantics of trace `T`. (A deep understanding of the steps of this protocol is not needed. This example should just give you a feeling about the expressiveness of the Dolev-Yao model and what a Dolev-Yao trace is.)

In the first step, we send the term `pk(sk_E)` to agent `a`. Agent `a` will serialize the term and provide it to its underlying implementation of Needham-Schröder.

Next, we let the agent a output a bitstring and bind it to `h_1`. By following the steps in the Dolev-Yao trace, we can observe that we now send the term `aenc(adec(h_1, sk_E), pk(sk_B))` to agent `b`.

Next, we let agent `b`’s underlying implementation output a bitstring and bind it to `h_2`. The next two steps forward the message `h_2` to agent a and bind its new output to `h_3`. Finally, we repeat the third and fourth step for a different input, namely `h_3`, and send the term `h_3` to agent `a`.

Such traces allow us to model arbitrary execution flows of cryptographic protocols. The trace above models an MitM attack, originally discovered by Gavin Lowe. A fixed version of the protocol is known as the Needham-Schroeder-Lowe protocol.

### TLS 1.3 Handshake Protocol

Before providing an example for a modern cryptographic protocol, I quickly want to explain the different phases of a TLS handshake.

[![](https://blog.trailofbits.com/wp-content/uploads/2023/01/Screenshot-2023-01-09-at-2.56.40-PM-735x1024.png)](https://blog.trailofbits.com/wp-content/uploads/2023/01/Screenshot-2023-01-09-at-2.56.40-PM.png)

Overview of the phases of a TLS handshake

1. **Key exchange**: Establish shared keys and select the cryptographic methods and parameters. Both messages in this phase are not encrypted.- **Server parameters**: Exchange further parameters that are no longer sent in plaintext.- **Server authentication**: Authenticate the server by confirming keys and handshake integrity.- **Client authentication**: Optionally, authenticate the client by confirming keys and handshake integrity.

Just like in the Needham-Schröder example, each message of the TLS handshake can be represented by a symbolic term. For example, the first Client Hello message can be represented as the term `fn_client_hello(fn_key_share, fn_signature_algorithm, psk)`. In this example, `fn_key_share`, `fn_signature_algorithm`, and `psk` are constants.

For a more in-depth review of the handshake message, [Section 2 of RFC 8446](https://datatracker.ietf.org/doc/html/rfc8446#section-2) explains each message in more detail.

## Fuzzing Dolev-Yao Traces

The tlspuffin fuzzer implements Dolev-Yao traces and allows their execution in concrete fuzzing targets like OpenSSL, wolfSSL, and libssh.

[![](https://blog.trailofbits.com/wp-content/uploads/2023/01/Screenshot-2023-01-09-at-3.02.50-PM-1024x733.png)](https://blog.trailofbits.com/wp-content/uploads/2023/01/Screenshot-2023-01-09-at-3.02.50-PM.png)

Structure of tlspuffin. It follows the best-practices defined by [LibAFL](https://github.com/AFLplusplus/LibAFL).

The design of tlspuffin is based on the evolutionary fuzzer [LibAFL](https://github.com/AFLplusplus/LibAFL). The fuzzer uses several concepts, which are illustrated in the following sections. We will follow traces on their journey from being picked from a **seed corpus** until they are **mutated, executed, observed**, and eventually become an attack trace.

### Seed Corpus

Initially, the seed corpus contains some handcrafted traces that represent some common attack scenarios (e.g., client/server is the attacker or the MitM is the attacker).

### Scheduler and Mutational Stage

The scheduler picks seeds based on a heuristic; for example, the scheduler might prefer shorter and more minimal traces. After that, the picked traces are mutated. This means that messages are skipped or repeated or their contents are changed. Because we are using a Dolev-Yao model to represent messages, we can change fields of messages by swapping sub terms or changing function symbols.

### Executor, Feedback, and Objectives

After the traces have been mutated, they are sent to the executor. The executor is responsible for executing the traces in actual implementations such as OpenSSL or wolfSSL, where they are executed in either the same process or a fork for each input. The executor is also responsible for collecting observations about the execution. An observation is classified as feedback if it contains information about newly discovered code edges in terms of coverage. For example, if the trace made the fuzzing target crash or an authentication bypass was witnessed, the trace is classified as an objective. The observation is then either added to the seed corpus or the objective corpus based on how it was classified.

Finally, we can repeat the process and start picking new traces from the seed corpus. This algorithm is quite common in fuzzing and is closely related to the approach of the classical [AFL](https://lcamtuf.coredump.cx/afl/) fuzzer. (For a more in-depth explanation of this particular algorithm, refer to the preprint [LibAFL: A Framework to Build Modular and Reusable Fuzzers](https://www.s3.eurecom.fr/docs/ccs22_fioraldi.pdf).)

## Internship Highlights

During my internship, we added several new features to tlspuffin that extended the tool in several dimensions, which are:

* Protocol implementations,* Cryptographic protocols,* Detection of security violations, and* Reproducibility of vulnerabilities.

### Toward more Fuzzing Targets

Before my internship at Trail of Bits, tlspuffin already supported fuzzing several versions of OpenSSL (including the version 1.0.1, which is vulnerable to Heartbleed) and LibreSSL. We designed an interface that added the capability to fuzz arbitrary protocol libraries. By implementing the interface for wolfSSL, we were able to add support for fuzzing wolfSSL 4.3.0 to 5.4.0, even though wolfSSL is not ABI compatible with OpenSSL or LibreSSL. Because the interface is written in Rust, implementing it for wolfSSL required us to create Rust bindings. The great thing about this is that the wolfSSL bindings could be reused outside of tlspuffin for embedded software projects. We released open-source wolfSSL bindings on [GitHub](https://github.com/trailofbits/rust-wolfssl).

This represents a milestone in library support. Previously, the tlspuffin was bound to the OpenSSL API, which is supported only by LibreSSL and OpenSSL. With this interface, it will be possible to support arbitrary future fuzzing targets.

### Toward more Protocols

Although tlspuffin was specifically designed for the TLS protocol, it has the capability to support other formats. In fact, any protocol that is formalized in the Dolev-Yao model should also be fuzzable with tlspuffin. We added support for SSH, which required us to abstract over certain protocol primitives such as messages, message parsing, the term algebra, and knowledge queries. The same abstraction we choose for TLS also, for the most part, works for SSH. However, the SSH protocol required a few adjustments because of a stateful serialization of protocol packets.

In order to test the SSH abstractions, we added support for fuzzing libssh (not to be confused with libssh2). As with wolfSSL, one of our first tasks was to create Rust bindings, which we plan to release separately as open-source software in the future.

### Toward a better Security Violation Oracle

Detecting security violations other than segmentation faults, buffer overflows, or use-after-free is essential for protocol fuzzers. In the world of fuzzers, an oracle decides whether a specific execution of the program under test reached some objective.

When using sanitizers like AddressSanitizer, buffer overflows or over-reads can make the program crash. In traditional fuzzing, the oracle decides whether the classical objective “program crashed” is fulfilled. This allows oracles to detect not only program crashes caused by segmentation faults, but also memory-related issues.

Many security issues like authentication bypasses or protocol downgrades in TLS libraries do not make themselves obvious by crashing. To address this, tlspuffin features a more sophisticated oracle that can detect protocol-specific problems. This allowed tlspuffin to rediscover not just vulnerabilities like [Heartbleed](https://heartbleed.com/) or [CVE-2021-3449](https://www.cve.org/CVERecord?id=CVE-2021-3449), but also logical vulnerabilities like [FREAK](https://www.cve.org/CVERecord?id=CVE-2015-0204). During my internship, we extended the capabilities of the security violation oracle to include authentication checks, which led us to rediscover two authentication bugs in wolfSSL ([CVE-2022-25640](https://www.cve.org/CVERecord?id=CVE-2022-25640) and [CVE-2022-25638](https://www.cve.org/CVERecord?id=CVE-2022-25638)). This indicates that tlspuffin automatically discovered these vulnerabilities without human interaction.

### Toward better Reproducibility

If the fuzzer discovers an alleged attack trace, then we as security researchers have to validate the finding. A good way to verify results is to execute them against an actual target like a TLS server or client over TCP. By using default settings, we can ensure that the setup of the fuzzing target is not causing false positives.

During the internship, we worked on a feature that allows users to execute a Dolev-Yao trace against clients or servers over TCP, which allows us to test attack traces against targets in isolation. One of these targets could be an OpenSSL server that is reachable over TCP. Every OpenSSL installation comes with such a server, which can be started using `openssl s_server -key key.pem -cert cert.pem`. A similar test server exists for wolfSSL. We can now execute traces through tlspuffin and see if the server crashes, misbehaves, or simply errors.

As described above, this enabled us to verify [CVE-2022-38153](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-38153) and to determine that a crash happens only when using a specific setup of the wolfSSL library.

## Conclusion

### Considerations for implementation

Despite this work, Dolev-Yao model-guided fuzzing also has drawbacks. Significant effort is required to integrate new fuzzing targets or protocols. Adding support for SSH took roughly five to six weeks, and adding a new fuzzing target took between one and two weeks. Finally, the fuzzer needed to be tested, bugs in the test harness needed to be resolved, and the fuzzer needed to be run for a reasonable length of time; in our case, finding bugs took another week. Note that letting a single instance of the fuzzer run for a long time might not be the best approach. Restarting the fuzzer every few days is a good approach to avoid that the fuzzer gets stuck in a “local minima” with respect to coverage.

Therefore, the overall process of applying Dolev-Yao model-guided fuzzing to an arbitrary cryptographic protocol and arbitrary implementation takes a few months. Based on these estimates, the fuzzing technique is best suited for ubiquitous protocols with multiple implementations like TLS or SSH, where the benefits outweigh the effort.

We noticed that protocol-specific features can increase the complexity of integration. For example, TLS uses transcripts, which can significantly increase the size of protocol messages. We applied a workaround for large transcripts in tlspuffin. In the case of SSH, we observed that message encoding and decoding is stateful, which means that messages are encoded differently based on the protocol state (a different MAC algorithm is used based on negotiated parameters).

On the contrary, testing existing or future TLS or SSH implementations through Dolev-Yao model-guided fuzzing is very promising. Investing a couple of weeks seems reasonable given that once a library is integrated into tlspuffin, it can be fuzzed continuously over many versions.

### Usage in test-suites

Developers can also use tlspuffin for writing test suites. It is possible to run traces against libraries, which test for the absence of specific authentication bugs. This allows for the implementation of regression tests to ensure that previous bugs do not occur again. In other words, tlspuffin can be used for the same tasks for which [TLS-Attacker](https://github.com/tls-attacker/TLS-Attacker) is currently used.

### Summary

To summarize, Dolev-Yao model-guided fuzzing is a novel and promising technique to fuzz test cryptographic protocols. It has proved its feasibility by rediscovering already-known authentication vulnerabilities and finding new DoS attacks in wolfSSL.

tlspuffin is a good fit for high-impact and widely used protocols like TLS or SSH. Integrating a new protocol into tlspuffin takes significant effort and requires an in-depth understanding of the protocol. In traditional fuzzing, domain-specific knowledge is sometimes relatively unimportant because simple fuzzers in a standard configuration can yield strong results. This advantage is lost if tlspuffin is used for protocols that are not yet supported.

Despite this, tlspuffin shines when it is used on an already-supported protocol. The internet heavily depends on the TLS and SSH protocols, and security issues affecting them have far-reaching implications. If TLS or SSH breaks, then the internet breaks. Luckily, this has not happened yet due to the great work of security researchers around the world. Let’s keep it that way by verifying, testing, and fuzzing cryptographic protocols!

I would like to wholeheartedly thank my mentor, Opal Wright. She supported me throughout my internship and motivated me by giving me plenty of praise for my work. I’d also like to give a great thanks to the entire cryptography team, who provided me with valuable feedback. Last but not least, I would like to thank my friends at INRIA for hosting me last year for my master thesis, which led to the development of tlspuffin. Without their mentorship and fundamental research, this work would not have been possible.

## Coordinated disclosure timeline

As part of the disclosure process, we reported four vulnerabilities in total to WolfSSL. The timeline of disclosure and remediation is provided below:

* August 12, 2022: Contacted wolfSSL support to set up a secure channel.* August 12, 2022: Reported CVE-2022-38152 and CVE-2022-38153 to wolfSSL.

### For CVE-2022-38152:

* August 12, 2022: wolfSSL maintainers confirmed and fixed the vulnerability.

### For CVE-2022-38153:

* August 16, 2022: wolfSSL maintainers confirmed the vulnerability.* August 17, 2022: wolfSSL maintainers fixed the vulnerability.

* August 30, 2022: wolfSSL released a fixed version, 5.5.0.* September 12, 2022: Reported CVE-2022-39173 to wolfSSL.

### For CVE-2022-39173:

* September 12, 2022: wolfSSL maintainers confirmed and fixed the vulnerability.* September 28, 2022: wolfSSL released a fixed version, 5.5.1.* October 09, 2022: Reported CVE-2022-42905 to wolfSSL.

### For CVE-2022-42905:

* October 10, 2022: wolfSSL maintainers confirmed and fixed the vulnerability.* October 28, 2022: wolfSSL released a fixed version, 5.5.2.

We would like to thank the team at wolfSSL for working swiftly with us to address these issues; they fixed one of the vulnerabilities on the same day it was submitted to them. The people involved at INRIA and Trail of Bits even got some swag delivered in appreciation of the disclosure.

[![](https://blog.trailofbits.com/wp-content/uploads/2023/01/Screenshot-2023-01-09-at-4.28.35-PM.png)](https://blog.trailofbits.com/wp-content/uploads/2023/01/Screenshot-2023-01-09-at-4.28.35-PM.png)

### Share this:

* [Twitter](https://blog.trailofbits.com/2023/01/12/wolfssl-vulnerabilities-tlspuffin-fuzzing-ssh/?share=twitter "Click to share on Twitter")
* [LinkedIn](https://blog.trailofbits.com/2023/01/12/wolfssl-vulnerabilities-tlspuffin-fuzzing-ssh/?share=linkedin "Click to share on LinkedIn")
* [Reddit](https://blog.trailofbits.com/2023/01/12/wolfssl-vulnerabilities-tlspuffin-fuzzing-ssh/?share=reddit "Click to share on Reddit")
* [Telegram](https://blog.trailofbits.com/2023/01/12/wolfssl-vulnerabilities-tlspuffin-fuzzing-ssh/?share=telegram "Click to share on Telegram")
* [Facebook](https://blog.trailofbits.com/2023/01/12/wolfssl-vulnerabilities-tlspuffin-fuzzing-ssh/?share=facebook "Click to share on Facebook")
* [Pocket](https://blog.trailofbits.com/2023/01/12/wolfssl-vulnerabilities-tlspuffin-fuzzing-ssh/?share=pocket "Click to share on Pocket")
* Email
* [Print](https://blog.trailofbits.com/2023/01/12/wolfssl-vulnerabilities-tlspuffin-fuzzing-ssh/#print "Click to print")
### Like this:

Like Loading...
### *Related*

By Trail of Bits

Posted in [Cryptography](https://blog.trailofbits.com/category/cryptography/), [Fuzzing](https://blog.trailofbits.com/category/fuzzing/), [Internship Projects](https://blog.trailofbits.com/category/internship-projects/), [Vulnerability Disclosure](https://blog.trailofbits.com/category/vulnerability-disclosure/)

# Post navigation

[← Another prolific year of open-source contributions](https://blog.trailofbits.com/2023/01/10/open-source-contributions-2022/) [Announcing a stable release of sigstore-python →](https://blog.trailofbits.com/2023/01/13/sigstore-python/)

### Leave a Reply[Cancel reply](/2023/01/12/wolfssl-vulnerabilities-tlspuffin-fuzzing-ssh/#respond)

Search

# About Us

Since 2012, Trail of Bits has helped secure some of the world’s most targeted organizations and products. We combine high-­end security research with a real­ world attacker mentality to reduce risk and fortify code.

Read more at [www.trailofbits.com](https://www.trailofbits.com)

# Subscribe via RSS

[![RSS feed](https://blog.trailofbits.com/wp-content/plugins/jetpack/images/rss/red-small.png) RSS - Posts](https://blog.trailofbits.com/feed/ "Subscribe to posts")

# Recent Posts

* [Auditing the Ruby ecosystem’s central package repository](https://blog.trailofbits.com/2024/12/11/auditing-the-ruby-ecosystems-central-package-repository/)
* [35 more Semgrep rules: infrastructure, supply chain, and Ruby](https://blog.trailofbits.com/2024/12/09/35-more-semgrep-rules-infrastructure-supply-chain-and-ruby/)
* [Evaluating Solidity support in AI coding assistants](https://blog.trailofbits.com/2024/11/19/evaluating-solidity-support-in-ai-coding-assistants/)
* [Attestations: A new generation of signatures on PyPI](https://blog.trailofbits.com/2024/11/14/attestations-a-new-generation-of-signatures-on-pypi/)
* [Killing Filecoin nodes](https://blog.trailofbits.com/2024/11/13/killing-filecoin-nodes/)
* [Fuzzing between the lines in popular barcode software](https://blog.trailofbits.com/2024/10/31/fuzzing-between-the-lines-in-popular-barcode-software/)
* [A deep dive into Linux’s new mseal syscall](https://blog.trailofbits.com/2024/10/25/a-deep-dive-into-linuxs-new-mseal-syscall/)
* [Auditing Gradio 5, Hugging Face’s ML GUI framework](https://blog.trailofbits.com/2024/10/10/auditing-gradio-5-hugging-faces-ml-gui-framework/)
* [Securing the software supply chain with the SLSA framework](https://blog.trailofbits.com/2024/10/01/securing-the-software-supply-chain-with-the-slsa-framework/)
* [A few notes on AWS Nitro Enclaves: Attack surface](https://blog.trailofbits.com/2024/09/24/notes-on-aws-nitro-enclaves-attack-surface/)
* [Announcing the Trail of Bits and Semgrep partnership](https://blog.trailofbits.com/2024/09/19/announcing-the-trail-of-bits-and-semgrep-partnership/)
* [Inside DEF CON: Michael Brown on how AI/ML is revolutionizing cybersecurity](https://blog.trailofbits.com/2024/09/17/inside-def-con-michael-brown-on-how-ai-ml-is-revolutionizing-cybersecurity/)
* [Friends don’t let friends reuse nonces](https://blog.trailofbits.com/2024/09/13/friends-dont-let-friends-reuse-nonces/)
* [Sanitize your C++ containers: ASan annotations step-by-step](https://blog.trailofbits.com/2024/09/10/sanitize-your-c-containers-asan-annotations-step-by-step/)
* [“Unstripping” binaries: Restoring debugging information in GDB with Pwndbg](https://blog.trailofbits.com/2024/09/06/unstripping-binaries-restoring-debugging-information-in-gdb-with-pwndbg/)
# Yearly Archive

* [2023](https://blog.trailofbits.com/2023)
* [2022](https://blog.trailofbits.com/2022)
* [2021](https://blog.trailofbits.com/2021)
* [2020](https://blog.trailofbits.com/2020)
* [2019](https://blog.trailofbits.com/2019)
* [2018](https://blog.trailofbits.com/2018)
* [2017](https://blog.trailofbits.com/2017)
* [2016](https://blog.trailofbits.com/2016)
* [2015](https://blog.trailofbits.com/2015)
* [2014](https://blog.trailofbits.com/2014)
* [2013](https://blog.trailofbits.com/2013)
* [2012](https://blog.trailofbits.com/2012)

# Categories

* [AIxCC](https://blog.trailofbits.com/category/aixcc/) (6)
* [Apple](https://blog.trailofbits.com/category/apple/) (13)
* [Application Security](https://blog.trailofbits.com/category/application-security/) (15)
* [Artificial Intelligence](https://blog.trailofbits.com/category/artificial-intelligence/) (1)
* [Attacks](https://blog.trailofbits.com/category/attacks/) (13)
* [Audits](https://blog.trailofbits.com/category/audits/) (11)
* [Authentication](https://blog.trailofbits.com/category/authentication/) (6)
* [Binary Ninja](https://blog.trailofbits.com/category/binary-ninja/) (15)
* [Blockchain](https://blog.trailofbits.com/category/blockchain/) (69)
* [C/C++](https://blog.trailofbits.com/category/c-c/) (1)
* [Capture the Flag](https://blog.trailofbits.com/category/capture-the-flag/) (11)
* [Careers](https://blog.trailofbits.com/category/careers/) (2)
* [CodeQL](https://blog.trailofbits.com/category/codeql/) (6)
* [Compilers](https://blog.trailofbits.com/category/compilers/) (30)
* [Conferences](https://blog.trailofbits.com/category/conferences/) (33)
* [Confidential Computing](https://blog.trailofbits.com/category/confidential-computing/) (1)
* [Containers](https://blog.trailofbits.com/category/containers/) (3)
* [Cryptography](https://blog.trailofbits.com/category/cryptography/) (68)
* [Crytic](https://blog.trailofbits.com/category/crytic/) (4)
* [Cyber Grand Challenge](https://blog.trailofbits.com/category/cyber-grand-challenge/) (8)
* [DARPA](https://blog.trailofbits.com/category/darpa/) (25)
* [Design Review](https://blog.trailofbits.com/category/design-review/) (1)
* [Dynamic Analysis](https://blog.trailofbits.com/category/dynamic-analysis/) (14)
* [eBPF](https://blog.trailofbits.com/category/ebpf/) (6)
* [Echidna](https://blog.trailofbits.com/category/echidna/) (1)
* [Ecosystem Security](https://blog.trailofbits.com/category/ecosystem-security/) (5)
* [Education](https://blog.trailofbits.com/category/education/) (17)
* [Empire Hacking](https://blog.trailofbits.com/category/empire-hacking/) (7)
* [Engineering Practice](https://blog.trailofbits.com/category/engineering-practice/) (16)
* [Events](https://blog.trailofbits.com/category/events/) (8)
* [Exploits](https://blog.trailofbits.com/category/exploits/) (30)
* [Fuzzing](https://blog.trailofbits.com/category/fuzzing/) (45)
* [Go](https://blog.trailofbits.com/category/go/) (8)
* [Guides](https://blog.trailofbits.com/category/guides/) (15)
* [Internship Projects](https://blog.trailofbits.com/category/internship-projects/) (38)
* [Invariant Development](https://blog.trailofbits.com/category/invariant-development/) (1)
* [iVerify](https://blog.trailofbits.com/category/iverify/) (5)
* [Kubernetes](https://blog.trailofbits.com/category/kubernetes/) (3)
* [Linux](https://blog.trailofbits.com/category/linux/) (8)
* [LLVM](https://blog.trailofbits.com/category/llvm/) (4)
* [Machine Learning](https://blog.trailofbits.com/category/machine-learning/) (27)
* [Malware](https://blog.trailofbits.com/category/malware/) (7)
* [Manticore](https://blog.trailofbits.com/category/manticore/) (17)
* [McSema](https://blog.trailofbits.com/category/mcsema/) (11)
* [Memory Safety](https://blog.trailofbits.com/category/memory-safety/) (2)
* [Meta](https://blog.trailofbits.com/category/meta/) (12)
* [Mitigations](https://blog.trailofbits.com/category/mitigations/) (11)
* [MLIR](https://blog.trailofbits.com/category/mlir/) (2)
* [Open Source](https://blog.trailofbits.com/category/open-source/) (14)
* [osquery](https://blog.trailofbits.com/category/osquery/) (23)
* [Paper Review](https://blog.trailofbits.com/category/paper-review/) (11)
* [People](https://blog.trailofbits.com/category/people/) (6)
* [Podcast](https://blog.trailofbits.com/category/podcast/) (1)
* [Policy](https://blog.trailofbits.com/category/policy/) (11)
* [Press Release](https://blog.trailofbits.com/category/press-release/) (30)
* [Privacy](https://blog.trailofbits.com/category/privacy/) (9)
* [Products](https://blog.trailofbits.com/category/products/) (8)
* [Program Analysis](https://blog.trailofbits.com/category/program-analysis/) (18)
* [Recruitment](https://blog.trailofbits.com/category/recruitment/) (1)
* [Remote Work](https://blog.trailofbits.com/category/remote-work/) (1)
* [Research Practice](https://blog.trailofbits.com/category/research-practice/) (30)
* [Reversing](https://blog.trailofbits.com/category/reversing/) (16)
* [Rust](https://blog.trailofbits.com/category/rust/) (7)
* [SafeDocs](https://blog.trailofbits.com/category/safedocs/) (1)
* [Semgrep](https://blog.trailofbits.com/category/semgrep/) (9)
* [Sinter](https://blog.trailofbits.com/category/sinter/) (1)
* [Slither](https://blog.trailofbits.com/category/slither/) (4)
* [Sponsorships](https://blog.trailofbits.com/category/sponsorships/) (12)
* [Static Analysis](https://blog.trailofbits.com/category/static-analysis/) (34)
* [Supply Chain](https://blog.trailofbits.com/category/supply-chain/) (3)
* [Symbolic Execution](https://blog.trailofbits.com/category/symbolic-execution/) (18)
* [Testing Handbook](https://blog.trailofbits.com/category/testing-handbook/) (5)
* [Threshold Signatures](https://blog.trailofbits.com/category/threshold-signatures/) (1)
* [Tool Release](https://blog.trailofbits.com/category/tool-release/) (5)
* [Training](https://blog.trailofbits.com/category/training/) (3)
* [Uncategorized](https://blog.trailofbits.com/category/uncategorized/) (33)
* [VAST](https://blog.trailofbits.com/category/vast/) (2)
* [Vulnerability Disclosure](https://blog.trailofbits.com/category/vulnerability-disclosure/) (20)
* [Windows](https://blog.trailofbits.com/category/windows/) (3)
* [Working at Trail of Bits](https://blog.trailofbits.com/category/working-at-trail-of-bits/) (2)
* [Year in Review](https://blog.trailofbits.com/category/year-in-review/) (6)
* [Zero Knowledge](https://blog.trailofbits.com/category/zero-knowledge/) (11)
[My Tweets](https://twitter.com/trailofbits)

## Discover more from Trail of Bits Blog

Subscribe now to keep reading and get access to the full archive.

Type your email…

Subscribe

Continue reading

##

##

Loading Comments...

Write a Comment...

Email (Required)

Name (Required)

Website

###

%d

