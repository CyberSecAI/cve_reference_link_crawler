=== Content from git.kernel.org_b760339c_20250111_193057.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=5939feb63ea1f011027576c64b68b681cbad31ca)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=5939feb63ea1f011027576c64b68b681cbad31ca)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=5939feb63ea1f011027576c64b68b681cbad31ca)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5939feb63ea1f011027576c64b68b681cbad31ca)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Brett Creeley <brett.creeley@amd.com> | 2024-01-29 15:40:33 -0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-02-05 20:17:10 +0000 |
| commit | [5939feb63ea1f011027576c64b68b681cbad31ca](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=5939feb63ea1f011027576c64b68b681cbad31ca) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=5939feb63ea1f011027576c64b68b681cbad31ca)) | |
| tree | [3298e158e10cf71084158df9b872d645df4461a2](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=5939feb63ea1f011027576c64b68b681cbad31ca) | |
| parent | [c1f105c92919741ada726f3efd1d31fa0499bf44](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=c1f105c92919741ada726f3efd1d31fa0499bf44) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5939feb63ea1f011027576c64b68b681cbad31ca&id2=c1f105c92919741ada726f3efd1d31fa0499bf44)) | |
| download | [linux-5939feb63ea1f011027576c64b68b681cbad31ca.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-5939feb63ea1f011027576c64b68b681cbad31ca.tar.gz) | |

pds\_core: Prevent race issues involving the adminq[ Upstream commit 7e82a8745b951b1e794cc780d46f3fbee5e93447 ]
There are multiple paths that can result in using the pdsc's
adminq.
[1] pdsc\_adminq\_isr and the resulting work from queue\_work(),
i.e. pdsc\_work\_thread()->pdsc\_process\_adminq()
[2] pdsc\_adminq\_post()
When the device goes through reset via PCIe reset and/or
a fw\_down/fw\_up cycle due to bad PCIe state or bad device
state the adminq is destroyed and recreated.
A NULL pointer dereference can happen if [1] or [2] happens
after the adminq is already destroyed.
In order to fix this, add some further state checks and
implement reference counting for adminq uses. Reference
counting was used because multiple threads can attempt to
access the adminq at the same time via [1] or [2]. Additionally,
multiple clients (i.e. pds-vfio-pci) can be using [2]
at the same time.
The adminq\_refcnt is initialized to 1 when the adminq has been
allocated and is ready to use. Users/clients of the adminq
(i.e. [1] and [2]) will increment the refcnt when they are using
the adminq. When the driver goes into a fw\_down cycle it will
set the PDSC\_S\_FW\_DEAD bit and then wait for the adminq\_refcnt
to hit 1. Setting the PDSC\_S\_FW\_DEAD before waiting will prevent
any further adminq\_refcnt increments. Waiting for the
adminq\_refcnt to hit 1 allows for any current users of the adminq
to finish before the driver frees the adminq. Once the
adminq\_refcnt hits 1 the driver clears the refcnt to signify that
the adminq is deleted and cannot be used. On the fw\_up cycle the
driver will once again initialize the adminq\_refcnt to 1 allowing
the adminq to be used again.
Fixes: 01ba61b55b20 ("pds\_core: Add adminq processing and commands")
Signed-off-by: Brett Creeley <brett.creeley@amd.com>
Reviewed-by: Shannon Nelson <shannon.nelson@amd.com>
Reviewed-by: Przemek Kitszel <przemyslaw.kitszel@intel.com>
Link: [https://lore.kernel.org/r/20240129234035.69802-5-brett.creeley@amd.com](https://lore.kernel.org/r/20240129234035.69802-5-brett.creeley%40amd.com)
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5939feb63ea1f011027576c64b68b681cbad31ca)

| -rw-r--r-- | [drivers/net/ethernet/amd/pds\_core/adminq.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/amd/pds_core/adminq.c?id=5939feb63ea1f011027576c64b68b681cbad31ca) | 31 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/net/ethernet/amd/pds\_core/core.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/amd/pds_core/core.c?id=5939feb63ea1f011027576c64b68b681cbad31ca) | 21 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/net/ethernet/amd/pds\_core/core.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/amd/pds_core/core.h?id=5939feb63ea1f011027576c64b68b681cbad31ca) | 1 | |  |  |  | | --- | --- | --- | |

3 files changed, 47 insertions, 6 deletions

| diff --git a/drivers/net/ethernet/amd/pds\_core/adminq.c b/drivers/net/ethernet/amd/pds\_core/adminq.cindex 68be5ea251fc10..5edff33d56f360 100644--- a/[drivers/net/ethernet/amd/pds\_core/adminq.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/amd/pds_core/adminq.c?id=c1f105c92919741ada726f3efd1d31fa0499bf44)+++ b/[drivers/net/ethernet/amd/pds\_core/adminq.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/amd/pds_core/adminq.c?id=5939feb63ea1f011027576c64b68b681cbad31ca)@@ -63,6 +63,15 @@ static int pdsc\_process\_notifyq(struct pdsc\_qcq \*qcq) return nq\_work; } +static bool pdsc\_adminq\_inc\_if\_up(struct pdsc \*pdsc)+{+ if (pdsc->state & BIT\_ULL(PDSC\_S\_STOPPING\_DRIVER) ||+ pdsc->state & BIT\_ULL(PDSC\_S\_FW\_DEAD))+ return false;++ return refcount\_inc\_not\_zero(&pdsc->adminq\_refcnt);+}+ void pdsc\_process\_adminq(struct pdsc\_qcq \*qcq) { union pds\_core\_adminq\_comp \*comp;@@ -75,9 +84,9 @@ void pdsc\_process\_adminq(struct pdsc\_qcq \*qcq) int aq\_work = 0; int credits; - /\* Don't process AdminQ when shutting down \*/- if (pdsc->state & BIT\_ULL(PDSC\_S\_STOPPING\_DRIVER)) {- dev\_err(pdsc->dev, "%s: called while PDSC\_S\_STOPPING\_DRIVER\n",+ /\* Don't process AdminQ when it's not up \*/+ if (!pdsc\_adminq\_inc\_if\_up(pdsc)) {+ dev\_err(pdsc->dev, "%s: called while adminq is unavailable\n", \_\_func\_\_); return; }@@ -124,6 +133,7 @@ credits: pds\_core\_intr\_credits(&pdsc->intr\_ctrl[qcq->intx], credits, PDS\_CORE\_INTR\_CRED\_REARM);+ refcount\_dec(&pdsc->adminq\_refcnt); }  void pdsc\_work\_thread(struct work\_struct \*work)@@ -138,9 +148,9 @@ irqreturn\_t pdsc\_adminq\_isr(int irq, void \*data) struct pdsc \*pdsc = data; struct pdsc\_qcq \*qcq; - /\* Don't process AdminQ when shutting down \*/- if (pdsc->state & BIT\_ULL(PDSC\_S\_STOPPING\_DRIVER)) {- dev\_err(pdsc->dev, "%s: called while PDSC\_S\_STOPPING\_DRIVER\n",+ /\* Don't process AdminQ when it's not up \*/+ if (!pdsc\_adminq\_inc\_if\_up(pdsc)) {+ dev\_err(pdsc->dev, "%s: called while adminq is unavailable\n", \_\_func\_\_); return IRQ\_HANDLED; }@@ -148,6 +158,7 @@ irqreturn\_t pdsc\_adminq\_isr(int irq, void \*data) qcq = &pdsc->adminqcq; queue\_work(pdsc->wq, &qcq->work); pds\_core\_intr\_mask(&pdsc->intr\_ctrl[qcq->intx], PDS\_CORE\_INTR\_MASK\_CLEAR);+ refcount\_dec(&pdsc->adminq\_refcnt);  return IRQ\_HANDLED; }@@ -231,6 +242,12 @@ int pdsc\_adminq\_post(struct pdsc \*pdsc, int err = 0; int index; + if (!pdsc\_adminq\_inc\_if\_up(pdsc)) {+ dev\_dbg(pdsc->dev, "%s: preventing adminq cmd %u\n",+ \_\_func\_\_, cmd->opcode);+ return -ENXIO;+ }+ wc.qcq = &pdsc->adminqcq; index = \_\_pdsc\_adminq\_post(pdsc, &pdsc->adminqcq, cmd, comp, &wc); if (index < 0) {@@ -286,6 +303,8 @@ err\_out: queue\_work(pdsc->wq, &pdsc->health\_work); } + refcount\_dec(&pdsc->adminq\_refcnt);+ return err; } EXPORT\_SYMBOL\_GPL(pdsc\_adminq\_post);diff --git a/drivers/net/ethernet/amd/pds\_core/core.c b/drivers/net/ethernet/amd/pds\_core/core.cindex 0356e56a6e99e0..f44333bd1256ec 100644--- a/[drivers/net/ethernet/amd/pds\_core/core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/amd/pds_core/core.c?id=c1f105c92919741ada726f3efd1d31fa0499bf44)+++ b/[drivers/net/ethernet/amd/pds\_core/core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/amd/pds_core/core.c?id=5939feb63ea1f011027576c64b68b681cbad31ca)@@ -450,6 +450,7 @@ int pdsc\_setup(struct pdsc \*pdsc, bool init) pdsc\_debugfs\_add\_viftype(pdsc); } + refcount\_set(&pdsc->adminq\_refcnt, 1); clear\_bit(PDSC\_S\_FW\_DEAD, &pdsc->state); return 0; @@ -514,6 +515,24 @@ void pdsc\_stop(struct pdsc \*pdsc) PDS\_CORE\_INTR\_MASK\_SET); } +static void pdsc\_adminq\_wait\_and\_dec\_once\_unused(struct pdsc \*pdsc)+{+ /\* The driver initializes the adminq\_refcnt to 1 when the adminq is+ \* allocated and ready for use. Other users/requesters will increment+ \* the refcnt while in use. If the refcnt is down to 1 then the adminq+ \* is not in use and the refcnt can be cleared and adminq freed. Before+ \* calling this function the driver will set PDSC\_S\_FW\_DEAD, which+ \* prevent subsequent attempts to use the adminq and increment the+ \* refcnt to fail. This guarantees that this function will eventually+ \* exit.+ \*/+ while (!refcount\_dec\_if\_one(&pdsc->adminq\_refcnt)) {+ dev\_dbg\_ratelimited(pdsc->dev, "%s: adminq in use\n",+ \_\_func\_\_);+ cpu\_relax();+ }+}+ void pdsc\_fw\_down(struct pdsc \*pdsc) { union pds\_core\_notifyq\_comp reset\_event = {@@ -529,6 +548,8 @@ void pdsc\_fw\_down(struct pdsc \*pdsc) if (pdsc->pdev->is\_virtfn) return; + pdsc\_adminq\_wait\_and\_dec\_once\_unused(pdsc);+ /\* Notify clients of fw\_down \*/ if (pdsc->fw\_reporter) devlink\_health\_report(pdsc->fw\_reporter, "FW down reported", pdsc);diff --git a/drivers/net/ethernet/amd/pds\_core/core.h b/drivers/net/ethernet/amd/pds\_core/core.hindex e35d3e7006bfc1..cbd5716f46e69e 100644--- a/[drivers/net/ethernet/amd/pds\_core/core.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/amd/pds_core/core.h?id=c1f105c92919741ada726f3efd1d31fa0499bf44)+++ b/[drivers/net/ethernet/amd/pds\_core/core.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/amd/pds_core/core.h?id=5939feb63ea1f011027576c64b68b681cbad31ca)@@ -184,6 +184,7 @@ struct pdsc { struct mutex devcmd\_lock; /\* lock for dev\_cmd operations \*/ struct mutex config\_lock; /\* lock for configuration operations \*/ spinlock\_t adminq\_lock; /\* lock for adminq operations \*/+ refcount\_t adminq\_refcnt; struct pds\_core\_dev\_info\_regs \_\_iomem \*info\_regs; struct pds\_core\_dev\_cmd\_regs \_\_iomem \*cmd\_regs; struct pds\_core\_intr \_\_iomem \*intr\_ctrl; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 19:29:34 +0000



=== Content from git.kernel.org_eb254043_20250111_193058.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=7e82a8745b951b1e794cc780d46f3fbee5e93447)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=7e82a8745b951b1e794cc780d46f3fbee5e93447)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7e82a8745b951b1e794cc780d46f3fbee5e93447)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7e82a8745b951b1e794cc780d46f3fbee5e93447)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Brett Creeley <brett.creeley@amd.com> | 2024-01-29 15:40:33 -0800 |
| --- | --- | --- |
| committer | Jakub Kicinski <kuba@kernel.org> | 2024-01-31 18:26:59 -0800 |
| commit | [7e82a8745b951b1e794cc780d46f3fbee5e93447](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7e82a8745b951b1e794cc780d46f3fbee5e93447) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=7e82a8745b951b1e794cc780d46f3fbee5e93447)) | |
| tree | [1cc9ad756363508d011296f838171514f0e69385](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=7e82a8745b951b1e794cc780d46f3fbee5e93447) | |
| parent | [951705151e50f9022bc96ec8b3fd5697380b1df6](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=951705151e50f9022bc96ec8b3fd5697380b1df6) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7e82a8745b951b1e794cc780d46f3fbee5e93447&id2=951705151e50f9022bc96ec8b3fd5697380b1df6)) | |
| download | [linux-7e82a8745b951b1e794cc780d46f3fbee5e93447.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-7e82a8745b951b1e794cc780d46f3fbee5e93447.tar.gz) | |

pds\_core: Prevent race issues involving the adminqThere are multiple paths that can result in using the pdsc's
adminq.
[1] pdsc\_adminq\_isr and the resulting work from queue\_work(),
i.e. pdsc\_work\_thread()->pdsc\_process\_adminq()
[2] pdsc\_adminq\_post()
When the device goes through reset via PCIe reset and/or
a fw\_down/fw\_up cycle due to bad PCIe state or bad device
state the adminq is destroyed and recreated.
A NULL pointer dereference can happen if [1] or [2] happens
after the adminq is already destroyed.
In order to fix this, add some further state checks and
implement reference counting for adminq uses. Reference
counting was used because multiple threads can attempt to
access the adminq at the same time via [1] or [2]. Additionally,
multiple clients (i.e. pds-vfio-pci) can be using [2]
at the same time.
The adminq\_refcnt is initialized to 1 when the adminq has been
allocated and is ready to use. Users/clients of the adminq
(i.e. [1] and [2]) will increment the refcnt when they are using
the adminq. When the driver goes into a fw\_down cycle it will
set the PDSC\_S\_FW\_DEAD bit and then wait for the adminq\_refcnt
to hit 1. Setting the PDSC\_S\_FW\_DEAD before waiting will prevent
any further adminq\_refcnt increments. Waiting for the
adminq\_refcnt to hit 1 allows for any current users of the adminq
to finish before the driver frees the adminq. Once the
adminq\_refcnt hits 1 the driver clears the refcnt to signify that
the adminq is deleted and cannot be used. On the fw\_up cycle the
driver will once again initialize the adminq\_refcnt to 1 allowing
the adminq to be used again.
Fixes: 01ba61b55b20 ("pds\_core: Add adminq processing and commands")
Signed-off-by: Brett Creeley <brett.creeley@amd.com>
Reviewed-by: Shannon Nelson <shannon.nelson@amd.com>
Reviewed-by: Przemek Kitszel <przemyslaw.kitszel@intel.com>
Link: [https://lore.kernel.org/r/20240129234035.69802-5-brett.creeley@amd.com](https://lore.kernel.org/r/20240129234035.69802-5-brett.creeley%40amd.com)
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7e82a8745b951b1e794cc780d46f3fbee5e93447)

| -rw-r--r-- | [drivers/net/ethernet/amd/pds\_core/adminq.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/amd/pds_core/adminq.c?id=7e82a8745b951b1e794cc780d46f3fbee5e93447) | 31 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/net/ethernet/amd/pds\_core/core.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/amd/pds_core/core.c?id=7e82a8745b951b1e794cc780d46f3fbee5e93447) | 21 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/net/ethernet/amd/pds\_core/core.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/amd/pds_core/core.h?id=7e82a8745b951b1e794cc780d46f3fbee5e93447) | 1 | |  |  |  | | --- | --- | --- | |

3 files changed, 47 insertions, 6 deletions

| diff --git a/drivers/net/ethernet/amd/pds\_core/adminq.c b/drivers/net/ethernet/amd/pds\_core/adminq.cindex 68be5ea251fc10..5edff33d56f360 100644--- a/[drivers/net/ethernet/amd/pds\_core/adminq.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/amd/pds_core/adminq.c?id=951705151e50f9022bc96ec8b3fd5697380b1df6)+++ b/[drivers/net/ethernet/amd/pds\_core/adminq.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/amd/pds_core/adminq.c?id=7e82a8745b951b1e794cc780d46f3fbee5e93447)@@ -63,6 +63,15 @@ static int pdsc\_process\_notifyq(struct pdsc\_qcq \*qcq) return nq\_work; } +static bool pdsc\_adminq\_inc\_if\_up(struct pdsc \*pdsc)+{+ if (pdsc->state & BIT\_ULL(PDSC\_S\_STOPPING\_DRIVER) ||+ pdsc->state & BIT\_ULL(PDSC\_S\_FW\_DEAD))+ return false;++ return refcount\_inc\_not\_zero(&pdsc->adminq\_refcnt);+}+ void pdsc\_process\_adminq(struct pdsc\_qcq \*qcq) { union pds\_core\_adminq\_comp \*comp;@@ -75,9 +84,9 @@ void pdsc\_process\_adminq(struct pdsc\_qcq \*qcq) int aq\_work = 0; int credits; - /\* Don't process AdminQ when shutting down \*/- if (pdsc->state & BIT\_ULL(PDSC\_S\_STOPPING\_DRIVER)) {- dev\_err(pdsc->dev, "%s: called while PDSC\_S\_STOPPING\_DRIVER\n",+ /\* Don't process AdminQ when it's not up \*/+ if (!pdsc\_adminq\_inc\_if\_up(pdsc)) {+ dev\_err(pdsc->dev, "%s: called while adminq is unavailable\n", \_\_func\_\_); return; }@@ -124,6 +133,7 @@ credits: pds\_core\_intr\_credits(&pdsc->intr\_ctrl[qcq->intx], credits, PDS\_CORE\_INTR\_CRED\_REARM);+ refcount\_dec(&pdsc->adminq\_refcnt); }  void pdsc\_work\_thread(struct work\_struct \*work)@@ -138,9 +148,9 @@ irqreturn\_t pdsc\_adminq\_isr(int irq, void \*data) struct pdsc \*pdsc = data; struct pdsc\_qcq \*qcq; - /\* Don't process AdminQ when shutting down \*/- if (pdsc->state & BIT\_ULL(PDSC\_S\_STOPPING\_DRIVER)) {- dev\_err(pdsc->dev, "%s: called while PDSC\_S\_STOPPING\_DRIVER\n",+ /\* Don't process AdminQ when it's not up \*/+ if (!pdsc\_adminq\_inc\_if\_up(pdsc)) {+ dev\_err(pdsc->dev, "%s: called while adminq is unavailable\n", \_\_func\_\_); return IRQ\_HANDLED; }@@ -148,6 +158,7 @@ irqreturn\_t pdsc\_adminq\_isr(int irq, void \*data) qcq = &pdsc->adminqcq; queue\_work(pdsc->wq, &qcq->work); pds\_core\_intr\_mask(&pdsc->intr\_ctrl[qcq->intx], PDS\_CORE\_INTR\_MASK\_CLEAR);+ refcount\_dec(&pdsc->adminq\_refcnt);  return IRQ\_HANDLED; }@@ -231,6 +242,12 @@ int pdsc\_adminq\_post(struct pdsc \*pdsc, int err = 0; int index; + if (!pdsc\_adminq\_inc\_if\_up(pdsc)) {+ dev\_dbg(pdsc->dev, "%s: preventing adminq cmd %u\n",+ \_\_func\_\_, cmd->opcode);+ return -ENXIO;+ }+ wc.qcq = &pdsc->adminqcq; index = \_\_pdsc\_adminq\_post(pdsc, &pdsc->adminqcq, cmd, comp, &wc); if (index < 0) {@@ -286,6 +303,8 @@ err\_out: queue\_work(pdsc->wq, &pdsc->health\_work); } + refcount\_dec(&pdsc->adminq\_refcnt);+ return err; } EXPORT\_SYMBOL\_GPL(pdsc\_adminq\_post);diff --git a/drivers/net/ethernet/amd/pds\_core/core.c b/drivers/net/ethernet/amd/pds\_core/core.cindex 0356e56a6e99e0..f44333bd1256ec 100644--- a/[drivers/net/ethernet/amd/pds\_core/core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/amd/pds_core/core.c?id=951705151e50f9022bc96ec8b3fd5697380b1df6)+++ b/[drivers/net/ethernet/amd/pds\_core/core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/amd/pds_core/core.c?id=7e82a8745b951b1e794cc780d46f3fbee5e93447)@@ -450,6 +450,7 @@ int pdsc\_setup(struct pdsc \*pdsc, bool init) pdsc\_debugfs\_add\_viftype(pdsc); } + refcount\_set(&pdsc->adminq\_refcnt, 1); clear\_bit(PDSC\_S\_FW\_DEAD, &pdsc->state); return 0; @@ -514,6 +515,24 @@ void pdsc\_stop(struct pdsc \*pdsc) PDS\_CORE\_INTR\_MASK\_SET); } +static void pdsc\_adminq\_wait\_and\_dec\_once\_unused(struct pdsc \*pdsc)+{+ /\* The driver initializes the adminq\_refcnt to 1 when the adminq is+ \* allocated and ready for use. Other users/requesters will increment+ \* the refcnt while in use. If the refcnt is down to 1 then the adminq+ \* is not in use and the refcnt can be cleared and adminq freed. Before+ \* calling this function the driver will set PDSC\_S\_FW\_DEAD, which+ \* prevent subsequent attempts to use the adminq and increment the+ \* refcnt to fail. This guarantees that this function will eventually+ \* exit.+ \*/+ while (!refcount\_dec\_if\_one(&pdsc->adminq\_refcnt)) {+ dev\_dbg\_ratelimited(pdsc->dev, "%s: adminq in use\n",+ \_\_func\_\_);+ cpu\_relax();+ }+}+ void pdsc\_fw\_down(struct pdsc \*pdsc) { union pds\_core\_notifyq\_comp reset\_event = {@@ -529,6 +548,8 @@ void pdsc\_fw\_down(struct pdsc \*pdsc) if (pdsc->pdev->is\_virtfn) return; + pdsc\_adminq\_wait\_and\_dec\_once\_unused(pdsc);+ /\* Notify clients of fw\_down \*/ if (pdsc->fw\_reporter) devlink\_health\_report(pdsc->fw\_reporter, "FW down reported", pdsc);diff --git a/drivers/net/ethernet/amd/pds\_core/core.h b/drivers/net/ethernet/amd/pds\_core/core.hindex e35d3e7006bfc1..cbd5716f46e69e 100644--- a/[drivers/net/ethernet/amd/pds\_core/core.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/amd/pds_core/core.h?id=951705151e50f9022bc96ec8b3fd5697380b1df6)+++ b/[drivers/net/ethernet/amd/pds\_core/core.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/amd/pds_core/core.h?id=7e82a8745b951b1e794cc780d46f3fbee5e93447)@@ -184,6 +184,7 @@ struct pdsc { struct mutex devcmd\_lock; /\* lock for dev\_cmd operations \*/ struct mutex config\_lock; /\* lock for configuration operations \*/ spinlock\_t adminq\_lock; /\* lock for adminq operations \*/+ refcount\_t adminq\_refcnt; struct pds\_core\_dev\_info\_regs \_\_iomem \*info\_regs; struct pds\_core\_dev\_cmd\_regs \_\_iomem \*cmd\_regs; struct pds\_core\_intr \_\_iomem \*intr\_ctrl; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 19:29:35 +0000



=== Content from git.kernel.org_099e8903_20250111_193056.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=22cd6046eb2148b18990257505834dd45c672a1b)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=22cd6046eb2148b18990257505834dd45c672a1b)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=22cd6046eb2148b18990257505834dd45c672a1b)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=22cd6046eb2148b18990257505834dd45c672a1b)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Brett Creeley <brett.creeley@amd.com> | 2024-01-29 15:40:33 -0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-02-05 20:14:37 +0000 |
| commit | [22cd6046eb2148b18990257505834dd45c672a1b](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=22cd6046eb2148b18990257505834dd45c672a1b) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=22cd6046eb2148b18990257505834dd45c672a1b)) | |
| tree | [ab18d21bdb9c9bcab21153caf2e7e45000ac2d9c](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=22cd6046eb2148b18990257505834dd45c672a1b) | |
| parent | [699f5416c33e515424982eacbe5a8567c5f64f04](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=699f5416c33e515424982eacbe5a8567c5f64f04) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=22cd6046eb2148b18990257505834dd45c672a1b&id2=699f5416c33e515424982eacbe5a8567c5f64f04)) | |
| download | [linux-22cd6046eb2148b18990257505834dd45c672a1b.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-22cd6046eb2148b18990257505834dd45c672a1b.tar.gz) | |

pds\_core: Prevent race issues involving the adminq[ Upstream commit 7e82a8745b951b1e794cc780d46f3fbee5e93447 ]
There are multiple paths that can result in using the pdsc's
adminq.
[1] pdsc\_adminq\_isr and the resulting work from queue\_work(),
i.e. pdsc\_work\_thread()->pdsc\_process\_adminq()
[2] pdsc\_adminq\_post()
When the device goes through reset via PCIe reset and/or
a fw\_down/fw\_up cycle due to bad PCIe state or bad device
state the adminq is destroyed and recreated.
A NULL pointer dereference can happen if [1] or [2] happens
after the adminq is already destroyed.
In order to fix this, add some further state checks and
implement reference counting for adminq uses. Reference
counting was used because multiple threads can attempt to
access the adminq at the same time via [1] or [2]. Additionally,
multiple clients (i.e. pds-vfio-pci) can be using [2]
at the same time.
The adminq\_refcnt is initialized to 1 when the adminq has been
allocated and is ready to use. Users/clients of the adminq
(i.e. [1] and [2]) will increment the refcnt when they are using
the adminq. When the driver goes into a fw\_down cycle it will
set the PDSC\_S\_FW\_DEAD bit and then wait for the adminq\_refcnt
to hit 1. Setting the PDSC\_S\_FW\_DEAD before waiting will prevent
any further adminq\_refcnt increments. Waiting for the
adminq\_refcnt to hit 1 allows for any current users of the adminq
to finish before the driver frees the adminq. Once the
adminq\_refcnt hits 1 the driver clears the refcnt to signify that
the adminq is deleted and cannot be used. On the fw\_up cycle the
driver will once again initialize the adminq\_refcnt to 1 allowing
the adminq to be used again.
Fixes: 01ba61b55b20 ("pds\_core: Add adminq processing and commands")
Signed-off-by: Brett Creeley <brett.creeley@amd.com>
Reviewed-by: Shannon Nelson <shannon.nelson@amd.com>
Reviewed-by: Przemek Kitszel <przemyslaw.kitszel@intel.com>
Link: [https://lore.kernel.org/r/20240129234035.69802-5-brett.creeley@amd.com](https://lore.kernel.org/r/20240129234035.69802-5-brett.creeley%40amd.com)
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=22cd6046eb2148b18990257505834dd45c672a1b)

| -rw-r--r-- | [drivers/net/ethernet/amd/pds\_core/adminq.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/amd/pds_core/adminq.c?id=22cd6046eb2148b18990257505834dd45c672a1b) | 31 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/net/ethernet/amd/pds\_core/core.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/amd/pds_core/core.c?id=22cd6046eb2148b18990257505834dd45c672a1b) | 21 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/net/ethernet/amd/pds\_core/core.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/amd/pds_core/core.h?id=22cd6046eb2148b18990257505834dd45c672a1b) | 1 | |  |  |  | | --- | --- | --- | |

3 files changed, 47 insertions, 6 deletions

| diff --git a/drivers/net/ethernet/amd/pds\_core/adminq.c b/drivers/net/ethernet/amd/pds\_core/adminq.cindex 68be5ea251fc10..5edff33d56f360 100644--- a/[drivers/net/ethernet/amd/pds\_core/adminq.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/amd/pds_core/adminq.c?id=699f5416c33e515424982eacbe5a8567c5f64f04)+++ b/[drivers/net/ethernet/amd/pds\_core/adminq.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/amd/pds_core/adminq.c?id=22cd6046eb2148b18990257505834dd45c672a1b)@@ -63,6 +63,15 @@ static int pdsc\_process\_notifyq(struct pdsc\_qcq \*qcq) return nq\_work; } +static bool pdsc\_adminq\_inc\_if\_up(struct pdsc \*pdsc)+{+ if (pdsc->state & BIT\_ULL(PDSC\_S\_STOPPING\_DRIVER) ||+ pdsc->state & BIT\_ULL(PDSC\_S\_FW\_DEAD))+ return false;++ return refcount\_inc\_not\_zero(&pdsc->adminq\_refcnt);+}+ void pdsc\_process\_adminq(struct pdsc\_qcq \*qcq) { union pds\_core\_adminq\_comp \*comp;@@ -75,9 +84,9 @@ void pdsc\_process\_adminq(struct pdsc\_qcq \*qcq) int aq\_work = 0; int credits; - /\* Don't process AdminQ when shutting down \*/- if (pdsc->state & BIT\_ULL(PDSC\_S\_STOPPING\_DRIVER)) {- dev\_err(pdsc->dev, "%s: called while PDSC\_S\_STOPPING\_DRIVER\n",+ /\* Don't process AdminQ when it's not up \*/+ if (!pdsc\_adminq\_inc\_if\_up(pdsc)) {+ dev\_err(pdsc->dev, "%s: called while adminq is unavailable\n", \_\_func\_\_); return; }@@ -124,6 +133,7 @@ credits: pds\_core\_intr\_credits(&pdsc->intr\_ctrl[qcq->intx], credits, PDS\_CORE\_INTR\_CRED\_REARM);+ refcount\_dec(&pdsc->adminq\_refcnt); }  void pdsc\_work\_thread(struct work\_struct \*work)@@ -138,9 +148,9 @@ irqreturn\_t pdsc\_adminq\_isr(int irq, void \*data) struct pdsc \*pdsc = data; struct pdsc\_qcq \*qcq; - /\* Don't process AdminQ when shutting down \*/- if (pdsc->state & BIT\_ULL(PDSC\_S\_STOPPING\_DRIVER)) {- dev\_err(pdsc->dev, "%s: called while PDSC\_S\_STOPPING\_DRIVER\n",+ /\* Don't process AdminQ when it's not up \*/+ if (!pdsc\_adminq\_inc\_if\_up(pdsc)) {+ dev\_err(pdsc->dev, "%s: called while adminq is unavailable\n", \_\_func\_\_); return IRQ\_HANDLED; }@@ -148,6 +158,7 @@ irqreturn\_t pdsc\_adminq\_isr(int irq, void \*data) qcq = &pdsc->adminqcq; queue\_work(pdsc->wq, &qcq->work); pds\_core\_intr\_mask(&pdsc->intr\_ctrl[qcq->intx], PDS\_CORE\_INTR\_MASK\_CLEAR);+ refcount\_dec(&pdsc->adminq\_refcnt);  return IRQ\_HANDLED; }@@ -231,6 +242,12 @@ int pdsc\_adminq\_post(struct pdsc \*pdsc, int err = 0; int index; + if (!pdsc\_adminq\_inc\_if\_up(pdsc)) {+ dev\_dbg(pdsc->dev, "%s: preventing adminq cmd %u\n",+ \_\_func\_\_, cmd->opcode);+ return -ENXIO;+ }+ wc.qcq = &pdsc->adminqcq; index = \_\_pdsc\_adminq\_post(pdsc, &pdsc->adminqcq, cmd, comp, &wc); if (index < 0) {@@ -286,6 +303,8 @@ err\_out: queue\_work(pdsc->wq, &pdsc->health\_work); } + refcount\_dec(&pdsc->adminq\_refcnt);+ return err; } EXPORT\_SYMBOL\_GPL(pdsc\_adminq\_post);diff --git a/drivers/net/ethernet/amd/pds\_core/core.c b/drivers/net/ethernet/amd/pds\_core/core.cindex cc5e3d1fe6522f..e1f554f2532940 100644--- a/[drivers/net/ethernet/amd/pds\_core/core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/amd/pds_core/core.c?id=699f5416c33e515424982eacbe5a8567c5f64f04)+++ b/[drivers/net/ethernet/amd/pds\_core/core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/amd/pds_core/core.c?id=22cd6046eb2148b18990257505834dd45c672a1b)@@ -452,6 +452,7 @@ int pdsc\_setup(struct pdsc \*pdsc, bool init) if (init) pdsc\_debugfs\_add\_viftype(pdsc); + refcount\_set(&pdsc->adminq\_refcnt, 1); clear\_bit(PDSC\_S\_FW\_DEAD, &pdsc->state); return 0; @@ -514,6 +515,24 @@ void pdsc\_stop(struct pdsc \*pdsc) PDS\_CORE\_INTR\_MASK\_SET); } +static void pdsc\_adminq\_wait\_and\_dec\_once\_unused(struct pdsc \*pdsc)+{+ /\* The driver initializes the adminq\_refcnt to 1 when the adminq is+ \* allocated and ready for use. Other users/requesters will increment+ \* the refcnt while in use. If the refcnt is down to 1 then the adminq+ \* is not in use and the refcnt can be cleared and adminq freed. Before+ \* calling this function the driver will set PDSC\_S\_FW\_DEAD, which+ \* prevent subsequent attempts to use the adminq and increment the+ \* refcnt to fail. This guarantees that this function will eventually+ \* exit.+ \*/+ while (!refcount\_dec\_if\_one(&pdsc->adminq\_refcnt)) {+ dev\_dbg\_ratelimited(pdsc->dev, "%s: adminq in use\n",+ \_\_func\_\_);+ cpu\_relax();+ }+}+ void pdsc\_fw\_down(struct pdsc \*pdsc) { union pds\_core\_notifyq\_comp reset\_event = {@@ -529,6 +548,8 @@ void pdsc\_fw\_down(struct pdsc \*pdsc) if (pdsc->pdev->is\_virtfn) return; + pdsc\_adminq\_wait\_and\_dec\_once\_unused(pdsc);+ /\* Notify clients of fw\_down \*/ if (pdsc->fw\_reporter) devlink\_health\_report(pdsc->fw\_reporter, "FW down reported", pdsc);diff --git a/drivers/net/ethernet/amd/pds\_core/core.h b/drivers/net/ethernet/amd/pds\_core/core.hindex 860bce1731c702..d6d19f72df00cd 100644--- a/[drivers/net/ethernet/amd/pds\_core/core.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/amd/pds_core/core.h?id=699f5416c33e515424982eacbe5a8567c5f64f04)+++ b/[drivers/net/ethernet/amd/pds\_core/core.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/amd/pds_core/core.h?id=22cd6046eb2148b18990257505834dd45c672a1b)@@ -184,6 +184,7 @@ struct pdsc { struct mutex devcmd\_lock; /\* lock for dev\_cmd operations \*/ struct mutex config\_lock; /\* lock for configuration operations \*/ spinlock\_t adminq\_lock; /\* lock for adminq operations \*/+ refcount\_t adminq\_refcnt; struct pds\_core\_dev\_info\_regs \_\_iomem \*info\_regs; struct pds\_core\_dev\_cmd\_regs \_\_iomem \*cmd\_regs; struct pds\_core\_intr \_\_iomem \*intr\_ctrl; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 19:29:34 +0000


