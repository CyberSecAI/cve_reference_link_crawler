<html><head><title>[PATCH 1/3] netfilter: nf_tables: do not allow SET_ID to refer to another table</title><link
rel=alternate
title="Atom feed"
href="../../new.atom"
type="application/atom+xml"/><style>pre{white-space:pre-wrap}*{font-size:100%;font-family:monospace}</style><link
type=text/css
rel=stylesheet
href=../../216light.css?66c655cb
media=screen,print /><link
type=text/css
rel=stylesheet
media="screen and (prefers-color-scheme:dark)"
href=../../216dark.css?66c655cb /></head><body><form
action="../../"><pre><a
href="../../?t=20220809173931"><b>netfilter-devel.vger.kernel.org archive mirror</b></a>
<input
name=q
type=text /><input
type=submit
value=search /> <a
href="../../_/text/help/">help</a> / <a
href="../../_/text/color/">color</a> / <a
id=mirror
href="../../_/text/mirror/">mirror</a> / <a
href="../../new.atom">Atom feed</a></pre></form><pre><a
href=#e28987dc4a804be08efaaaf3cb13c5a168d755a35
id=m28987dc4a804be08efaaaf3cb13c5a168d755a35>*</a> <u
id=u><b>[PATCH 1/3] netfilter: nf_tables: do not allow SET_ID to refer to another table</b></u>
<b>@ 2022-08-09 17:01 Thadeu Lima de Souza Cascardo</b>
  2022-08-09 17:01 ` <a
href="#mff760809e54644eeebc632cbb53a438c95ba6933">[PATCH 2/3] netfilter: nf_tables: do not allow CHAIN_ID</a> &#34; Thadeu Lima de Souza Cascardo
  2022-08-09 17:01 ` <a
href="#mc8a8e3638d61175b2ae75c64db9b3a7271f63d42">[PATCH 3/3] netfilter: nf_tables: do not allow RULE_ID to refer to another chain</a> Thadeu Lima de Souza Cascardo
  <a
href=#r28987dc4a804be08efaaaf3cb13c5a168d755a35>0 siblings, 2 replies; 4+ messages in thread</a>
From: Thadeu Lima de Souza Cascardo @ 2022-08-09 17:01 UTC (<a
href="../../20220809170148.164591-1-cascardo@canonical.com/">permalink</a> / <a
href="../../20220809170148.164591-1-cascardo@canonical.com/raw">raw</a>)
  To: <a
href="../../../netfilter-devel/?t=20220809170335">netfilter-devel</a>; <b>+Cc:</b> pablo, kadlec, fw, Thadeu Lima de Souza Cascardo, <a
href="../../../stable/?t=20220809170335">stable</a>

When doing lookups for sets on the same batch by using its ID, a set from a
different table can be used.

Then, when the table is removed, a reference to the set may be kept after
the set is freed, leading to a potential use-after-free.

When looking for sets by ID, use the table that was used for the lookup by
name, and only return sets belonging to that same table.

This fixes CVE-2022-2586, also reported as ZDI-CAN-17470.

Reported-by: Team Orca of Sea Security (@seasecresponse)
Fixes: 958bee14d071 (&#34;netfilter: nf_tables: use new transaction infrastructure to handle sets&#34;)
Signed-off-by: Thadeu Lima de Souza Cascardo &lt;cascardo@canonical.com&gt;
Cc: &lt;stable@vger.kernel.org&gt;
---
 <a
id=iZ2e.:..:20220809170148.164591-1-cascardo::40canonical.com:1net:netfilter:nf_tables_api.c
href=#Z2e.:..:20220809170148.164591-1-cascardo::40canonical.com:1net:netfilter:nf_tables_api.c>net/netfilter/nf_tables_api.c</a> | 4 +++-
 1 file <a href="#e28987dc4a804be08efaaaf3cb13c5a168d755a35">changed</a>, 3 insertions(+), 1 deletion(-)

<span
class="head"><a
href=#iZ2e.:..:20220809170148.164591-1-cascardo::40canonical.com:1net:netfilter:nf_tables_api.c
id=Z2e.:..:20220809170148.164591-1-cascardo::40canonical.com:1net:netfilter:nf_tables_api.c>diff</a> --git a/net/netfilter/nf_tables_api.c b/net/netfilter/nf_tables_api.c
index 9f976b11d896..86fae065f1d2 100644
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
</span><span
class="hunk">@@ -3842,6 +3842,7 @@ static struct nft_set *nft_set_lookup_byhandle(const struct nft_table *table,
</span> }
 
 static struct nft_set *nft_set_lookup_byid(const struct net *net,
<span
class="add">+					   const struct nft_table *table,
</span> 					   const struct nlattr *nla, u8 genmask)
 {
 	struct nftables_pernet *nft_net = nft_pernet(net);
<span
class="hunk">@@ -3853,6 +3854,7 @@ static struct nft_set *nft_set_lookup_byid(const struct net *net,
</span> 			struct nft_set *set = nft_trans_set(trans);
 
 			if (id == nft_trans_set_id(trans) &#38;&#38;
<span
class="add">+			    set-&gt;table == table &#38;&#38;
</span> 			    nft_active_genmask(set, genmask))
 				return set;
 		}
<span
class="hunk">@@ -3873,7 +3875,7 @@ struct nft_set *nft_set_lookup_global(const struct net *net,
</span> 		if (!nla_set_id)
 			return set;
 
<span
class="del">-		set = nft_set_lookup_byid(net, nla_set_id, genmask);
</span><span
class="add">+		set = nft_set_lookup_byid(net, table, nla_set_id, genmask);
</span> 	}
 	return set;
 }
-- 
2.34.1


<a
href=#m28987dc4a804be08efaaaf3cb13c5a168d755a35
id=e28987dc4a804be08efaaaf3cb13c5a168d755a35>^</a> <a
href="../../20220809170148.164591-1-cascardo@canonical.com/">permalink</a> <a
href="../../20220809170148.164591-1-cascardo@canonical.com/raw">raw</a> <a
href="../../20220809170148.164591-1-cascardo@canonical.com/#R">reply</a> <a
href="../../20220809170148.164591-1-cascardo@canonical.com/#related">related</a>	[<a
href="../../20220809170148.164591-1-cascardo@canonical.com/T/#u"><b>flat</b></a>|<a
href="../../20220809170148.164591-1-cascardo@canonical.com/t/#u">nested</a>] <a
href=#r28987dc4a804be08efaaaf3cb13c5a168d755a35>4+ messages in thread</a></pre><hr><pre><a
href=#eff760809e54644eeebc632cbb53a438c95ba6933
id=mff760809e54644eeebc632cbb53a438c95ba6933>*</a> <b>[PATCH 2/3] netfilter: nf_tables: do not allow CHAIN_ID to refer to another table</b>
  2022-08-09 17:01 <a
href="#m28987dc4a804be08efaaaf3cb13c5a168d755a35">[PATCH 1/3] netfilter: nf_tables: do not allow SET_ID to refer to another table</a> Thadeu Lima de Souza Cascardo
<b>@ 2022-08-09 17:01 ` Thadeu Lima de Souza Cascardo</b>
  2022-08-09 17:01 ` <a
href="#mc8a8e3638d61175b2ae75c64db9b3a7271f63d42">[PATCH 3/3] netfilter: nf_tables: do not allow RULE_ID to refer to another chain</a> Thadeu Lima de Souza Cascardo
  <a
href=#rff760809e54644eeebc632cbb53a438c95ba6933>1 sibling, 0 replies; 4+ messages in thread</a>
From: Thadeu Lima de Souza Cascardo @ 2022-08-09 17:01 UTC (<a
href="../../20220809170148.164591-2-cascardo@canonical.com/">permalink</a> / <a
href="../../20220809170148.164591-2-cascardo@canonical.com/raw">raw</a>)
  To: <a
href="../../../netfilter-devel/?t=20220809170427">netfilter-devel</a>; <b>+Cc:</b> pablo, kadlec, fw, Thadeu Lima de Souza Cascardo, <a
href="../../../stable/?t=20220809170427">stable</a>

When doing lookups for chains on the same batch by using its ID, a chain
from a different table can be used. If a rule is added to a table but
refers to a chain in a different table, it will be linked to the chain in
table2, but would have expressions referring to objects in table1.

Then, when table1 is removed, the rule will not be removed as its linked to
a chain in table2. When expressions in the rule are processed or removed,
that will lead to a use-after-free.

When looking for chains by ID, use the table that was used for the lookup
by name, and only return chains belonging to that same table.

Fixes: 837830a4b439 (&#34;netfilter: nf_tables: add NFTA_RULE_CHAIN_ID attribute&#34;)
Signed-off-by: Thadeu Lima de Souza Cascardo &lt;cascardo@canonical.com&gt;
Cc: &lt;stable@vger.kernel.org&gt;
---
 <a
id=iZ2e.:..:20220809170148.164591-2-cascardo::40canonical.com:1net:netfilter:nf_tables_api.c
href=#Z2e.:..:20220809170148.164591-2-cascardo::40canonical.com:1net:netfilter:nf_tables_api.c>net/netfilter/nf_tables_api.c</a> | 6 ++++--
 1 file <a href="#eff760809e54644eeebc632cbb53a438c95ba6933">changed</a>, 4 insertions(+), 2 deletions(-)

<span
class="head"><a
href=#iZ2e.:..:20220809170148.164591-2-cascardo::40canonical.com:1net:netfilter:nf_tables_api.c
id=Z2e.:..:20220809170148.164591-2-cascardo::40canonical.com:1net:netfilter:nf_tables_api.c>diff</a> --git a/net/netfilter/nf_tables_api.c b/net/netfilter/nf_tables_api.c
index 86fae065f1d2..ae59784db9aa 100644
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
</span><span
class="hunk">@@ -2472,6 +2472,7 @@ static int nf_tables_updchain(struct nft_ctx *ctx, u8 genmask, u8 policy,
</span> }
 
 static struct nft_chain *nft_chain_lookup_byid(const struct net *net,
<span
class="add">+					       const struct nft_table *table,
</span> 					       const struct nlattr *nla)
 {
 	struct nftables_pernet *nft_net = nft_pernet(net);
<span
class="hunk">@@ -2482,6 +2483,7 @@ static struct nft_chain *nft_chain_lookup_byid(const struct net *net,
</span> 		struct nft_chain *chain = trans-&gt;ctx.chain;
 
 		if (trans-&gt;msg_type == NFT_MSG_NEWCHAIN &#38;&#38;
<span
class="add">+		    chain-&gt;table == table &#38;&#38;
</span> 		    id == nft_trans_chain_id(trans))
 			return chain;
 	}
<span
class="hunk">@@ -3417,7 +3419,7 @@ static int nf_tables_newrule(struct sk_buff *skb, const struct nfnl_info *info,
</span> 			return -EOPNOTSUPP;
 
 	} else if (nla[NFTA_RULE_CHAIN_ID]) {
<span
class="del">-		chain = nft_chain_lookup_byid(net, nla[NFTA_RULE_CHAIN_ID]);
</span><span
class="add">+		chain = nft_chain_lookup_byid(net, table, nla[NFTA_RULE_CHAIN_ID]);
</span> 		if (IS_ERR(chain)) {
 			NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN_ID]);
 			return PTR_ERR(chain);
<span
class="hunk">@@ -9607,7 +9609,7 @@ static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,
</span> 						 tb[NFTA_VERDICT_CHAIN],
 						 genmask);
 		} else if (tb[NFTA_VERDICT_CHAIN_ID]) {
<span
class="del">-			chain = nft_chain_lookup_byid(ctx-&gt;net,
</span><span
class="add">+			chain = nft_chain_lookup_byid(ctx-&gt;net, ctx-&gt;table,
</span> 						      tb[NFTA_VERDICT_CHAIN_ID]);
 			if (IS_ERR(chain))
 				return PTR_ERR(chain);
-- 
2.34.1


<a
href=#mff760809e54644eeebc632cbb53a438c95ba6933
id=eff760809e54644eeebc632cbb53a438c95ba6933>^</a> <a
href="../../20220809170148.164591-2-cascardo@canonical.com/">permalink</a> <a
href="../../20220809170148.164591-2-cascardo@canonical.com/raw">raw</a> <a
href="../../20220809170148.164591-2-cascardo@canonical.com/#R">reply</a> <a
href="../../20220809170148.164591-2-cascardo@canonical.com/#related">related</a>	[<a
href="../../20220809170148.164591-2-cascardo@canonical.com/T/#u"><b>flat</b></a>|<a
href="../../20220809170148.164591-2-cascardo@canonical.com/t/#u">nested</a>] <a
href=#rff760809e54644eeebc632cbb53a438c95ba6933>4+ messages in thread</a></pre><hr><pre><a
href=#ec8a8e3638d61175b2ae75c64db9b3a7271f63d42
id=mc8a8e3638d61175b2ae75c64db9b3a7271f63d42>*</a> <b>[PATCH 3/3] netfilter: nf_tables: do not allow RULE_ID to refer to another chain</b>
  2022-08-09 17:01 <a
href="#m28987dc4a804be08efaaaf3cb13c5a168d755a35">[PATCH 1/3] netfilter: nf_tables: do not allow SET_ID to refer to another table</a> Thadeu Lima de Souza Cascardo
  2022-08-09 17:01 ` <a
href="#mff760809e54644eeebc632cbb53a438c95ba6933">[PATCH 2/3] netfilter: nf_tables: do not allow CHAIN_ID</a> &#34; Thadeu Lima de Souza Cascardo
<b>@ 2022-08-09 17:01 ` Thadeu Lima de Souza Cascardo</b>
  2022-08-09 17:39   ` <a
href="#m23e2cee6b4cb236e0c7d7f6d06a6fb214a3ad39d">Pablo Neira Ayuso</a>
  <a
href=#rc8a8e3638d61175b2ae75c64db9b3a7271f63d42>1 sibling, 1 reply; 4+ messages in thread</a>
From: Thadeu Lima de Souza Cascardo @ 2022-08-09 17:01 UTC (<a
href="../../20220809170148.164591-3-cascardo@canonical.com/">permalink</a> / <a
href="../../20220809170148.164591-3-cascardo@canonical.com/raw">raw</a>)
  To: <a
href="../../../netfilter-devel/?t=20220809170429">netfilter-devel</a>; <b>+Cc:</b> pablo, kadlec, fw, Thadeu Lima de Souza Cascardo, <a
href="../../../stable/?t=20220809170429">stable</a>

When doing lookups for rules on the same batch by using its ID, a rule from
a different chain can be used. If a rule is added to a chain but tries to
be positioned next to a rule from a different chain, it will be linked to
chain2, but the use counter on chain1 would be the one to be incremented.

When looking for rules by ID, use the chain that was used for the lookup by
name. The chain used in the context copied to the transaction needs to
match that same chain. That way, struct nft_rule does not need to get
enlarged with another member.

Fixes: 1a94e38d254b (&#34;netfilter: nf_tables: add NFTA_RULE_ID attribute&#34;)
Fixes: 75dd48e2e420 (&#34;netfilter: nf_tables: Support RULE_ID reference in new rule&#34;)
Signed-off-by: Thadeu Lima de Souza Cascardo &lt;cascardo@canonical.com&gt;
Cc: &lt;stable@vger.kernel.org&gt;
---
 <a
id=iZ2e.:..:20220809170148.164591-3-cascardo::40canonical.com:1net:netfilter:nf_tables_api.c
href=#Z2e.:..:20220809170148.164591-3-cascardo::40canonical.com:1net:netfilter:nf_tables_api.c>net/netfilter/nf_tables_api.c</a> | 7 +++++--
 1 file <a href="#ec8a8e3638d61175b2ae75c64db9b3a7271f63d42">changed</a>, 5 insertions(+), 2 deletions(-)

<span
class="head"><a
href=#iZ2e.:..:20220809170148.164591-3-cascardo::40canonical.com:1net:netfilter:nf_tables_api.c
id=Z2e.:..:20220809170148.164591-3-cascardo::40canonical.com:1net:netfilter:nf_tables_api.c>diff</a> --git a/net/netfilter/nf_tables_api.c b/net/netfilter/nf_tables_api.c
index ae59784db9aa..d98c153a80e9 100644
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
</span><span
class="hunk">@@ -3373,6 +3373,7 @@ static int nft_table_validate(struct net *net, const struct nft_table *table)
</span> }
 
 static struct nft_rule *nft_rule_lookup_byid(const struct net *net,
<span
class="add">+					     const struct nft_chain *chain,
</span> 					     const struct nlattr *nla);
 
 #define NFT_RULE_MAXEXPRS	128
<span
class="hunk">@@ -3461,7 +3462,7 @@ static int nf_tables_newrule(struct sk_buff *skb, const struct nfnl_info *info,
</span> 				return PTR_ERR(old_rule);
 			}
 		} else if (nla[NFTA_RULE_POSITION_ID]) {
<span
class="del">-			old_rule = nft_rule_lookup_byid(net, nla[NFTA_RULE_POSITION_ID]);
</span><span
class="add">+			old_rule = nft_rule_lookup_byid(net, chain, nla[NFTA_RULE_POSITION_ID]);
</span> 			if (IS_ERR(old_rule)) {
 				NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_POSITION_ID]);
 				return PTR_ERR(old_rule);
<span
class="hunk">@@ -3606,6 +3607,7 @@ static int nf_tables_newrule(struct sk_buff *skb, const struct nfnl_info *info,
</span> }
 
 static struct nft_rule *nft_rule_lookup_byid(const struct net *net,
<span
class="add">+					     const struct nft_chain *chain,
</span> 					     const struct nlattr *nla)
 {
 	struct nftables_pernet *nft_net = nft_pernet(net);
<span
class="hunk">@@ -3616,6 +3618,7 @@ static struct nft_rule *nft_rule_lookup_byid(const struct net *net,
</span> 		struct nft_rule *rule = nft_trans_rule(trans);
 
 		if (trans-&gt;msg_type == NFT_MSG_NEWRULE &#38;&#38;
<span
class="add">+		    trans-&gt;ctx.chain == chain &#38;&#38;
</span> 		    id == nft_trans_rule_id(trans))
 			return rule;
 	}
<span
class="hunk">@@ -3665,7 +3668,7 @@ static int nf_tables_delrule(struct sk_buff *skb, const struct nfnl_info *info,
</span> 
 			err = nft_delrule(&#38;ctx, rule);
 		} else if (nla[NFTA_RULE_ID]) {
<span
class="del">-			rule = nft_rule_lookup_byid(net, nla[NFTA_RULE_ID]);
</span><span
class="add">+			rule = nft_rule_lookup_byid(net, chain, nla[NFTA_RULE_ID]);
</span> 			if (IS_ERR(rule)) {
 				NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_ID]);
 				return PTR_ERR(rule);
-- 
2.34.1


<a
href=#mc8a8e3638d61175b2ae75c64db9b3a7271f63d42
id=ec8a8e3638d61175b2ae75c64db9b3a7271f63d42>^</a> <a
href="../../20220809170148.164591-3-cascardo@canonical.com/">permalink</a> <a
href="../../20220809170148.164591-3-cascardo@canonical.com/raw">raw</a> <a
href="../../20220809170148.164591-3-cascardo@canonical.com/#R">reply</a> <a
href="../../20220809170148.164591-3-cascardo@canonical.com/#related">related</a>	[<a
href="../../20220809170148.164591-3-cascardo@canonical.com/T/#u"><b>flat</b></a>|<a
href="../../20220809170148.164591-3-cascardo@canonical.com/t/#u">nested</a>] <a
href=#rc8a8e3638d61175b2ae75c64db9b3a7271f63d42>4+ messages in thread</a></pre><hr><pre><a
href=#e23e2cee6b4cb236e0c7d7f6d06a6fb214a3ad39d
id=m23e2cee6b4cb236e0c7d7f6d06a6fb214a3ad39d>*</a> <b>Re: [PATCH 3/3] netfilter: nf_tables: do not allow RULE_ID to refer to another chain</b>
  2022-08-09 17:01 ` <a
href="#mc8a8e3638d61175b2ae75c64db9b3a7271f63d42">[PATCH 3/3] netfilter: nf_tables: do not allow RULE_ID to refer to another chain</a> Thadeu Lima de Souza Cascardo
<b>@ 2022-08-09 17:39   ` Pablo Neira Ayuso</b>
  <a
href=#r23e2cee6b4cb236e0c7d7f6d06a6fb214a3ad39d>0 siblings, 0 replies; 4+ messages in thread</a>
From: Pablo Neira Ayuso @ 2022-08-09 17:39 UTC (<a
href="../../YvKbzc53xy+0Bh0B@salvia/">permalink</a> / <a
href="../../YvKbzc53xy+0Bh0B@salvia/raw">raw</a>)
  To: Thadeu Lima de Souza Cascardo; <b>+Cc:</b> <a
href="../../../netfilter-devel/?t=20220809173931">netfilter-devel</a>, kadlec, fw, <a
href="../../../stable/?t=20220809173931">stable</a>

On Tue, Aug 09, 2022 at 02:01:48PM -0300, Thadeu Lima de Souza Cascardo wrote:
<span
class="q">&gt; When doing lookups for rules on the same batch by using its ID, a rule from
&gt; a different chain can be used. If a rule is added to a chain but tries to
&gt; be positioned next to a rule from a different chain, it will be linked to
&gt; chain2, but the use counter on chain1 would be the one to be incremented.
&gt; 
&gt; When looking for rules by ID, use the chain that was used for the lookup by
&gt; name. The chain used in the context copied to the transaction needs to
&gt; match that same chain. That way, struct nft_rule does not need to get
&gt; enlarged with another member.
</span>
Series applied, thanks

<a
href=#m23e2cee6b4cb236e0c7d7f6d06a6fb214a3ad39d
id=e23e2cee6b4cb236e0c7d7f6d06a6fb214a3ad39d>^</a> <a
href="../../YvKbzc53xy+0Bh0B@salvia/">permalink</a> <a
href="../../YvKbzc53xy+0Bh0B@salvia/raw">raw</a> <a
href="../../YvKbzc53xy+0Bh0B@salvia/#R">reply</a>	[<a
href="../../YvKbzc53xy+0Bh0B@salvia/T/#u"><b>flat</b></a>|<a
href="../../YvKbzc53xy+0Bh0B@salvia/t/#u">nested</a>] <a
href=#r23e2cee6b4cb236e0c7d7f6d06a6fb214a3ad39d>4+ messages in thread</a></pre><hr><pre>end of thread, other threads:[<a
href="../../?t=20220809173931">~2022-08-09 17:39 UTC</a> | <a
href="../../">newest</a>]

<b
id=t>Thread overview:</b> 4+ messages (download: <a
href="../t.mbox.gz">mbox.gz</a> follow: <a
href="../t.atom">Atom feed</a>
-- links below jump to the message on this page --
2022-08-09 17:01 <a
href="#m28987dc4a804be08efaaaf3cb13c5a168d755a35"
id=r28987dc4a804be08efaaaf3cb13c5a168d755a35>[PATCH 1/3] netfilter: nf_tables: do not allow SET_ID to refer to another table</a> Thadeu Lima de Souza Cascardo
2022-08-09 17:01 ` <a
href="#mff760809e54644eeebc632cbb53a438c95ba6933"
id=rff760809e54644eeebc632cbb53a438c95ba6933>[PATCH 2/3] netfilter: nf_tables: do not allow CHAIN_ID</a> &#34; Thadeu Lima de Souza Cascardo
2022-08-09 17:01 ` <a
href="#mc8a8e3638d61175b2ae75c64db9b3a7271f63d42"
id=rc8a8e3638d61175b2ae75c64db9b3a7271f63d42>[PATCH 3/3] netfilter: nf_tables: do not allow RULE_ID to refer to another chain</a> Thadeu Lima de Souza Cascardo
2022-08-09 17:39   ` <a
href="#m23e2cee6b4cb236e0c7d7f6d06a6fb214a3ad39d"
id=r23e2cee6b4cb236e0c7d7f6d06a6fb214a3ad39d>Pablo Neira Ayuso</a>
</pre><hr><pre>This is a public inbox, see <a
href="../../_/text/mirror/">mirroring instructions</a>
for how to clone and mirror all data and code used for this inbox;
as well as URLs for NNTP newsgroup(s).</pre></body></html>