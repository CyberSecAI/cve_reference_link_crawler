
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fcjlin1%2Flibsvm%2Fblob%2F9a3a9708926dec87d382c43b203f2ca19c2d56a0%2Fsvm.cpp)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fcjlin1%2Flibsvm%2Fblob%2F9a3a9708926dec87d382c43b203f2ca19c2d56a0%2Fsvm.cpp)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=cjlin1%2Flibsvm)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[cjlin1](/cjlin1)
/
**[libsvm](/cjlin1/libsvm)**
Public

* [Notifications](/login?return_to=%2Fcjlin1%2Flibsvm) You must be signed in to change notification settings
* [Fork
  1.6k](/login?return_to=%2Fcjlin1%2Flibsvm)
* [Star
   4.6k](/login?return_to=%2Fcjlin1%2Flibsvm)

* [Code](/cjlin1/libsvm)
* [Issues
  80](/cjlin1/libsvm/issues)
* [Pull requests
  32](/cjlin1/libsvm/pulls)
* [Actions](/cjlin1/libsvm/actions)
* [Projects
  0](/cjlin1/libsvm/projects)
* [Wiki](/cjlin1/libsvm/wiki)
* [Security](/cjlin1/libsvm/security)
* [Insights](/cjlin1/libsvm/pulse)

Additional navigation options

* [Code](/cjlin1/libsvm)
* [Issues](/cjlin1/libsvm/issues)
* [Pull requests](/cjlin1/libsvm/pulls)
* [Actions](/cjlin1/libsvm/actions)
* [Projects](/cjlin1/libsvm/projects)
* [Wiki](/cjlin1/libsvm/wiki)
* [Security](/cjlin1/libsvm/security)
* [Insights](/cjlin1/libsvm/pulse)

## Files

 9a3a970
## Breadcrumbs

1. [libsvm](/cjlin1/libsvm/tree/9a3a9708926dec87d382c43b203f2ca19c2d56a0)
/
# svm.cpp

 Blame  Blame
## Latest commit

## History

[History](/cjlin1/libsvm/commits/9a3a9708926dec87d382c43b203f2ca19c2d56a0/svm.cpp)3182 lines (2834 loc) · 63.6 KB 9a3a970
## Breadcrumbs

1. [libsvm](/cjlin1/libsvm/tree/9a3a9708926dec87d382c43b203f2ca19c2d56a0)
/
# svm.cpp

Top
## File metadata and controls

* Code
* Blame

3182 lines (2834 loc) · 63.6 KB[Raw](https://github.com/cjlin1/libsvm/raw/9a3a9708926dec87d382c43b203f2ca19c2d56a0/svm.cpp)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000#include <math.h>#include <stdio.h>#include <stdlib.h>#include <ctype.h>#include <float.h>#include <string.h>#include <stdarg.h>#include <limits.h>#include <locale.h>#include "svm.h"int libsvm\_version = LIBSVM\_VERSION;typedef float Qfloat;typedef signed char schar;#ifndef mintemplate <class T> static inline T min(T x,T y) { return (x<y)?x:y; }#endif#ifndef maxtemplate <class T> static inline T max(T x,T y) { return (x>y)?x:y; }#endiftemplate <class T> static inline void swap(T& x, T& y) { T t=x; x=y; y=t; }template <class S, class T> static inline void clone(T\*& dst, S\* src, int n){ dst = new T[n]; memcpy((void \*)dst,(void \*)src,sizeof(T)\*n);}static inline double powi(double base, int times){ double tmp = base, ret = 1.0;
 for(int t=times; t>0; t/=2) { if(t%2==1) ret\*=tmp; tmp = tmp \* tmp; } return ret;}#define INF HUGE\_VAL#define TAU 1e-12#define Malloc(type,n) (type \*)malloc((n)\*sizeof(type))
static void print\_string\_stdout(const char \*s){ fputs(s,stdout); fflush(stdout);}static void (\*svm\_print\_string) (const char \*) = &print\_string\_stdout;#if 1static void info(const char \*fmt,...){ char buf[BUFSIZ]; va\_list ap; va\_start(ap,fmt); vsprintf(buf,fmt,ap); va\_end(ap); (\*svm\_print\_string)(buf);}#elsestatic void info(const char \*fmt,...) {}#endif
//// Kernel Cache//// l is the number of total data items// size is the cache size limit in bytes//class Cache{public: Cache(int l,long int size); ~Cache();
 // request data [0,len) // return some position p where [p,len) need to be filled // (p >= len if nothing needs to be filled) int get\_data(const int index, Qfloat \*\*data, int len); void swap\_index(int i, int j);private: int l; long int size; struct head\_t { head\_t \*prev, \*next; // a circular list Qfloat \*data; int len; // data[0,len) is cached in this entry };
 head\_t \*head; head\_t lru\_head; void lru\_delete(head\_t \*h); void lru\_insert(head\_t \*h);};
Cache::Cache(int l\_,long int size\_):l(l\_),size(size\_){ head = (head\_t \*)calloc(l,sizeof(head\_t)); // initialized to 0 size /= sizeof(Qfloat); size -= l \* sizeof(head\_t) / sizeof(Qfloat); size = max(size, 2 \* (long int) l); // cache must be large enough for two columns lru\_head.next = lru\_head.prev = &lru\_head;}
Cache::~Cache(){ for(head\_t \*h = lru\_head.next; h != &lru\_head; h=h->next) free(h->data); free(head);}
void Cache::lru\_delete(head\_t \*h){ // delete from current location h->prev->next = h->next; h->next->prev = h->prev;}
void Cache::lru\_insert(head\_t \*h){ // insert to last position h->next = &lru\_head; h->prev = lru\_head.prev; h->prev->next = h; h->next->prev = h;}
int Cache::get\_data(const int index, Qfloat \*\*data, int len){ head\_t \*h = &head[index]; if(h->len) lru\_delete(h); int more = len - h->len;
 if(more > 0) { // free old space while(size < more) { head\_t \*old = lru\_head.next; lru\_delete(old); free(old->data); size += old->len; old->data = 0; old->len = 0; }
 // allocate new space h->data = (Qfloat \*)realloc(h->data,sizeof(Qfloat)\*len); size -= more; swap(h->len,len); }
 lru\_insert(h); \*data = h->data; return len;}
void Cache::swap\_index(int i, int j){ if(i==j) return;
 if(head[i].len) lru\_delete(&head[i]); if(head[j].len) lru\_delete(&head[j]); swap(head[i].data,head[j].data); swap(head[i].len,head[j].len); if(head[i].len) lru\_insert(&head[i]); if(head[j].len) lru\_insert(&head[j]);
 if(i>j) swap(i,j); for(head\_t \*h = lru\_head.next; h!=&lru\_head; h=h->next) { if(h->len > i) { if(h->len > j) swap(h->data[i],h->data[j]); else { // give up lru\_delete(h); free(h->data); size += h->len; h->data = 0; h->len = 0; } } }}
//// Kernel evaluation//// the static method k\_function is for doing single kernel evaluation// the constructor of Kernel prepares to calculate the l\*l kernel matrix// the member function get\_Q is for getting one column from the Q Matrix//class QMatrix {public: virtual Qfloat \*get\_Q(int column, int len) const = 0; virtual double \*get\_QD() const = 0; virtual void swap\_index(int i, int j) const = 0; virtual ~QMatrix() {}};
class Kernel: public QMatrix {public: Kernel(int l, svm\_node \* const \* x, const svm\_parameter& param); virtual ~Kernel();
 static double k\_function(const svm\_node \*x, const svm\_node \*y, const svm\_parameter& param); virtual Qfloat \*get\_Q(int column, int len) const = 0; virtual double \*get\_QD() const = 0; virtual void swap\_index(int i, int j) const // no so const... { swap(x[i],x[j]); if(x\_square) swap(x\_square[i],x\_square[j]); }protected:
 double (Kernel::\*kernel\_function)(int i, int j) const;
private: const svm\_node \*\*x; double \*x\_square;
 // svm\_parameter const int kernel\_type; const int degree; const double gamma; const double coef0;
 static double dot(const svm\_node \*px, const svm\_node \*py); double kernel\_linear(int i, int j) const { return dot(x[i],x[j]); } double kernel\_poly(int i, int j) const { return powi(gamma\*dot(x[i],x[j])+coef0,degree); } double kernel\_rbf(int i, int j) const { return exp(-gamma\*(x\_square[i]+x\_square[j]-2\*dot(x[i],x[j]))); } double kernel\_sigmoid(int i, int j) const { return tanh(gamma\*dot(x[i],x[j])+coef0); } double kernel\_precomputed(int i, int j) const { return x[i][(int)(x[j][0].value)].value; }};
Kernel::Kernel(int l, svm\_node \* const \* x\_, const svm\_parameter& param):kernel\_type(param.kernel\_type), degree(param.degree), gamma(param.gamma), coef0(param.coef0){ switch(kernel\_type) { case LINEAR: kernel\_function = &Kernel::kernel\_linear; break; case POLY: kernel\_function = &Kernel::kernel\_poly; break; case RBF: kernel\_function = &Kernel::kernel\_rbf; break; case SIGMOID: kernel\_function = &Kernel::kernel\_sigmoid; break; case PRECOMPUTED: kernel\_function = &Kernel::kernel\_precomputed; break; }
 clone(x,x\_,l);
 if(kernel\_type == RBF) { x\_square = new double[l]; for(int i=0;i<l;i++) x\_square[i] = dot(x[i],x[i]); } else x\_square = 0;}
Kernel::~Kernel(){ delete[] x; delete[] x\_square;}
double Kernel::dot(const svm\_node \*px, const svm\_node \*py){ double sum = 0; while(px->index != -1 && py->index != -1) { if(px->index == py->index) { sum += px->value \* py->value; ++px; ++py; } else { if(px->index > py->index) ++py; else ++px; } } return sum;}
double Kernel::k\_function(const svm\_node \*x, const svm\_node \*y, const svm\_parameter& param){ switch(param.kernel\_type) { case LINEAR: return dot(x,y); case POLY: return powi(param.gamma\*dot(x,y)+param.coef0,param.degree); case RBF: { double sum = 0; while(x->index != -1 && y->index !=-1) { if(x->index == y->index) { double d = x->value - y->value; sum += d\*d; ++x; ++y; } else { if(x->index > y->index) { sum += y->value \* y->value; ++y; } else { sum += x->value \* x->value; ++x; } } }
 while(x->index != -1) { sum += x->value \* x->value; ++x; }
 while(y->index != -1) { sum += y->value \* y->value; ++y; }
 return exp(-param.gamma\*sum); } case SIGMOID: return tanh(param.gamma\*dot(x,y)+param.coef0); case PRECOMPUTED: //x: test (validation), y: SV return x[(int)(y->value)].value; default: return 0; // Unreachable }}
// An SMO algorithm in Fan et al., JMLR 6(2005), p. 1889--1918// Solves://// min 0.5(\alpha^T Q \alpha) + p^T \alpha//// y^T \alpha = \delta// y\_i = +1 or -1// 0 <= alpha\_i <= Cp for y\_i = 1// 0 <= alpha\_i <= Cn for y\_i = -1//// Given://// Q, p, y, Cp, Cn, and an initial feasible point \alpha// l is the size of vectors and matrices// eps is the stopping tolerance//// solution will be put in \alpha, objective value will be put in obj//class Solver {public: Solver() {}; virtual ~Solver() {};
 struct SolutionInfo { double obj; double rho; double upper\_bound\_p; double upper\_bound\_n; double r; // for Solver\_NU };
 void Solve(int l, const QMatrix& Q, const double \*p\_, const schar \*y\_, double \*alpha\_, double Cp, double Cn, double eps, SolutionInfo\* si, int shrinking);protected: int active\_size; schar \*y; double \*G; // gradient of objective function enum { LOWER\_BOUND, UPPER\_BOUND, FREE }; char \*alpha\_status; // LOWER\_BOUND, UPPER\_BOUND, FREE double \*alpha; const QMatrix \*Q; const double \*QD; double eps; double Cp,Cn; double \*p; int \*active\_set; double \*G\_bar; // gradient, if we treat free variables as 0 int l; bool unshrink; // XXX
 double get\_C(int i) { return (y[i] > 0)? Cp : Cn; } void update\_alpha\_status(int i) { if(alpha[i] >= get\_C(i)) alpha\_status[i] = UPPER\_BOUND; else if(alpha[i] <= 0) alpha\_status[i] = LOWER\_BOUND; else alpha\_status[i] = FREE; } bool is\_upper\_bound(int i) { return alpha\_status[i] == UPPER\_BOUND; } bool is\_lower\_bound(int i) { return alpha\_status[i] == LOWER\_BOUND; } bool is\_free(int i) { return alpha\_status[i] == FREE; } void swap\_index(int i, int j); void reconstruct\_gradient(); virtual int select\_working\_set(int &i, int &j); virtual double calculate\_rho(); virtual void do\_shrinking();private: bool be\_shrunk(int i, double Gmax1, double Gmax2);};
void Solver::swap\_index(int i, int j){ Q->swap\_index(i,j); swap(y[i],y[j]); swap(G[i],G[j]); swap(alpha\_status[i],alpha\_status[j]); swap(alpha[i],alpha[j]); swap(p[i],p[j]); swap(active\_set[i],active\_set[j]); swap(G\_bar[i],G\_bar[j]);}
void Solver::reconstruct\_gradient(){ // reconstruct inactive elements of G from G\_bar and free variables
 if(active\_size == l) return;
 int i,j; int nr\_free = 0;
 for(j=active\_size;j<l;j++) G[j] = G\_bar[j] + p[j];
 for(j=0;j<active\_size;j++) if(is\_free(j)) nr\_free++;
 if(2\*nr\_free < active\_size) info("\nWARNING: using -h 0 may be faster\n");
 if (nr\_free\*l > 2\*active\_size\*(l-active\_size)) { for(i=active\_size;i<l;i++) { const Qfloat \*Q\_i = Q->get\_Q(i,active\_size); for(j=0;j<active\_size;j++) if(is\_free(j)) G[i] += alpha[j] \* Q\_i[j]; } } else { for(i=0;i<active\_size;i++) if(is\_free(i)) { const Qfloat \*Q\_i = Q->get\_Q(i,l); double alpha\_i = alpha[i]; for(j=active\_size;j<l;j++) G[j] += alpha\_i \* Q\_i[j]; } }}
void Solver::Solve(int l, const QMatrix& Q, const double \*p\_, const schar \*y\_, double \*alpha\_, double Cp, double Cn, double eps, SolutionInfo\* si, int shrinking){ this->l = l; this->Q = &Q; QD=Q.get\_QD(); clone(p, p\_,l); clone(y, y\_,l); clone(alpha,alpha\_,l); this->Cp = Cp; this->Cn = Cn; this->eps = eps; unshrink = false;
 // initialize alpha\_status { alpha\_status = new char[l]; for(int i=0;i<l;i++) update\_alpha\_status(i); }
 // initialize active set (for shrinking) { active\_set = new int[l]; for(int i=0;i<l;i++) active\_set[i] = i; active\_size = l; }
 // initialize gradient { G = new double[l]; G\_bar = new double[l]; int i; for(i=0;i<l;i++) { G[i] = p[i]; G\_bar[i] = 0; } for(i=0;i<l;i++) if(!is\_lower\_bound(i)) { const Qfloat \*Q\_i = Q.get\_Q(i,l); double alpha\_i = alpha[i]; int j; for(j=0;j<l;j++) G[j] += alpha\_i\*Q\_i[j]; if(is\_upper\_bound(i)) for(j=0;j<l;j++) G\_bar[j] += get\_C(i) \* Q\_i[j]; } }
 // optimization step
 int iter = 0; int max\_iter = max(10000000, l>INT\_MAX/100 ? INT\_MAX : 100\*l); int counter = min(l,1000)+1;
 while(iter < max\_iter) { // show progress and do shrinking
 if(--counter == 0) { counter = min(l,1000); if(shrinking) do\_shrinking(); info("."); }
 int i,j; if(select\_working\_set(i,j)!=0) { // reconstruct the whole gradient reconstruct\_gradient(); // reset active set size and check active\_size = l; info("\*"); if(select\_working\_set(i,j)!=0) break; else counter = 1; // do shrinking next iteration }
 ++iter;
 // update alpha[i] and alpha[j], handle bounds carefully
 const Qfloat \*Q\_i = Q.get\_Q(i,active\_size); const Qfloat \*Q\_j = Q.get\_Q(j,active\_size);
 double C\_i = get\_C(i); double C\_j = get\_C(j);
 double old\_alpha\_i = alpha[i]; double old\_alpha\_j = alpha[j];
 if(y[i]!=y[j]) { double quad\_coef = QD[i]+QD[j]+2\*Q\_i[j]; if (quad\_coef <= 0) quad\_coef = TAU; double delta = (-G[i]-G[j])/quad\_coef; double diff = alpha[i] - alpha[j]; alpha[i] += delta; alpha[j] += delta;
 if(diff > 0) { if(alpha[j] < 0) { alpha[j] = 0; alpha[i] = diff; } } else { if(alpha[i] < 0) { alpha[i] = 0; alpha[j] = -diff; } } if(diff > C\_i - C\_j) { if(alpha[i] > C\_i) { alpha[i] = C\_i; alpha[j] = C\_i - diff; } } else { if(alpha[j] > C\_j) { alpha[j] = C\_j; alpha[i] = C\_j + diff; } } } else { double quad\_coef = QD[i]+QD[j]-2\*Q\_i[j]; if (quad\_coef <= 0) quad\_coef = TAU; double delta = (G[i]-G[j])/quad\_coef; double sum = alpha[i] + alpha[j]; alpha[i] -= delta; alpha[j] += delta;
 if(sum > C\_i) { if(alpha[i] > C\_i) { alpha[i] = C\_i; alpha[j] = sum - C\_i; } } else { if(alpha[j] < 0) { alpha[j] = 0; alpha[i] = sum; } } if(sum > C\_j) { if(alpha[j] > C\_j) { alpha[j] = C\_j; alpha[i] = sum - C\_j; } } else { if(alpha[i] < 0) { alpha[i] = 0; alpha[j] = sum; } } }
 // update G
 double delta\_alpha\_i = alpha[i] - old\_alpha\_i; double delta\_alpha\_j = alpha[j] - old\_alpha\_j;
 for(int k=0;k<active\_size;k++) { G[k] += Q\_i[k]\*delta\_alpha\_i + Q\_j[k]\*delta\_alpha\_j; }
 // update alpha\_status and G\_bar
 { bool ui = is\_upper\_bound(i); bool uj = is\_upper\_bound(j); update\_alpha\_status(i); update\_alpha\_status(j); int k; if(ui != is\_upper\_bound(i)) { Q\_i = Q.get\_Q(i,l); if(ui) for(k=0;k<l;k++) G\_bar[k] -= C\_i \* Q\_i[k]; else for(k=0;k<l;k++) G\_bar[k] += C\_i \* Q\_i[k]; }
 if(uj != is\_upper\_bound(j)) { Q\_j = Q.get\_Q(j,l); if(uj) for(k=0;k<l;k++) G\_bar[k] -= C\_j \* Q\_j[k]; else for(k=0;k<l;k++) G\_bar[k] += C\_j \* Q\_j[k]; } } }
 if(iter >= max\_iter) { if(active\_size < l) { // reconstruct the whole gradient to calculate objective value reconstruct\_gradient(); active\_size = l; info("\*"); } fprintf(stderr,"\nWARNING: reaching max number of iterations\n"); }
 // calculate rho
 si->rho = calculate\_rho();
 // calculate objective value { double v = 0; int i; for(i=0;i<l;i++) v += alpha[i] \* (G[i] + p[i]);
 si->obj = v/2; }
 // put back the solution { for(int i=0;i<l;i++) alpha\_[active\_set[i]] = alpha[i]; }
 // juggle everything back /\*{ for(int i=0;i<l;i++) while(active\_set[i] != i) swap\_index(i,active\_set[i]); // or Q.swap\_index(i,active\_set[i]); }\*/
 si->upper\_bound\_p = Cp; si->upper\_bound\_n = Cn;
 info("\noptimization finished, #iter = %d\n",iter);
 delete[] p; delete[] y; delete[] alpha; delete[] alpha\_status; delete[] active\_set; delete[] G; delete[] G\_bar;}
// return 1 if already optimal, return 0 otherwiseint Solver::select\_working\_set(int &out\_i, int &out\_j){ // return i,j such that // i: maximizes -y\_i \* grad(f)\_i, i in I\_up(\alpha) // j: minimizes the decrease of obj value // (if quadratic coefficeint <= 0, replace it with tau) // -y\_j\*grad(f)\_j < -y\_i\*grad(f)\_i, j in I\_low(\alpha)
 double Gmax = -INF; double Gmax2 = -INF; int Gmax\_idx = -1; int Gmin\_idx = -1; double obj\_diff\_min = INF;
 for(int t=0;t<active\_size;t++) if(y[t]==+1) { if(!is\_upper\_bound(t)) if(-G[t] >= Gmax) { Gmax = -G[t]; Gmax\_idx = t; } } else { if(!is\_lower\_bound(t)) if(G[t] >= Gmax) { Gmax = G[t]; Gmax\_idx = t; } }
 int i = Gmax\_idx; const Qfloat \*Q\_i = NULL; if(i != -1) // NULL Q\_i not accessed: Gmax=-INF if i=-1 Q\_i = Q->get\_Q(i,active\_size);
 for(int j=0;j<active\_size;j++) { if(y[j]==+1) { if (!is\_lower\_bound(j)) { double grad\_diff=Gmax+G[j]; if (G[j] >= Gmax2) Gmax2 = G[j]; if (grad\_diff > 0) { double obj\_diff; double quad\_coef = QD[i]+QD[j]-2.0\*y[i]\*Q\_i[j]; if (quad\_coef > 0) obj\_diff = -(grad\_diff\*grad\_diff)/quad\_coef; else obj\_diff = -(grad\_diff\*grad\_diff)/TAU;
 if (obj\_diff <= obj\_diff\_min) { Gmin\_idx=j; obj\_diff\_min = obj\_diff; } } } } else { if (!is\_upper\_bound(j)) { double grad\_diff= Gmax-G[j]; if (-G[j] >= Gmax2) Gmax2 = -G[j]; if (grad\_diff > 0) { double obj\_diff; double quad\_coef = QD[i]+QD[j]+2.0\*y[i]\*Q\_i[j]; if (quad\_coef > 0) obj\_diff = -(grad\_diff\*grad\_diff)/quad\_coef; else obj\_diff = -(grad\_diff\*grad\_diff)/TAU;
 if (obj\_diff <= obj\_diff\_min) { Gmin\_idx=j; obj\_diff\_min = obj\_diff; } } } } }
 if(Gmax+Gmax2 < eps || Gmin\_idx == -1) return 1;
 out\_i = Gmax\_idx; out\_j = Gmin\_idx; return 0;}
bool Solver::be\_shrunk(int i, double Gmax1, double Gmax2){ if(is\_upper\_bound(i)) { if(y[i]==+1) return(-G[i] > Gmax1); else return(-G[i] > Gmax2); } else if(is\_lower\_bound(i)) { if(y[i]==+1) return(G[i] > Gmax2); else return(G[i] > Gmax1); } else return(false);}
void Solver::do\_shrinking(){ int i; double Gmax1 = -INF; // max { -y\_i \* grad(f)\_i | i in I\_up(\alpha) } double Gmax2 = -INF; // max { y\_i \* grad(f)\_i | i in I\_low(\alpha) }
 // find maximal violating pair first for(i=0;i<active\_size;i++) { if(y[i]==+1) { if(!is\_upper\_bound(i)) { if(-G[i] >= Gmax1) Gmax1 = -G[i]; } if(!is\_lower\_bound(i)) { if(G[i] >= Gmax2) Gmax2 = G[i]; } } else { if(!is\_upper\_bound(i)) { if(-G[i] >= Gmax2) Gmax2 = -G[i]; } if(!is\_lower\_bound(i)) { if(G[i] >= Gmax1) Gmax1 = G[i]; } } }
 if(unshrink == false && Gmax1 + Gmax2 <= eps\*10) { unshrink = true; reconstruct\_gradient(); active\_size = l; info("\*"); }
 for(i=0;i<active\_size;i++) if (be\_shrunk(i, Gmax1, Gmax2)) { active\_size--; while (active\_size > i) { if (!be\_shrunk(active\_size, Gmax1, Gmax2)) { swap\_index(i,active\_size); break; } active\_size--; } }}
double Solver::calculate\_rho(){ double r; int nr\_free = 0; double ub = INF, lb = -INF, sum\_free = 0; for(int i=0;i<active\_size;i++) { double yG = y[i]\*G[i];
 if(is\_upper\_bound(i)) { if(y[i]==-1) ub = min(ub,yG); else lb = max(lb,yG); } else if(is\_lower\_bound(i)) { if(y[i]==+1) ub = min(ub,yG); else lb = max(lb,yG); } else { ++nr\_free; sum\_free += yG; } }
 if(nr\_free>0) r = sum\_free/nr\_free; else r = (ub+lb)/2;
[View remainder of file in raw view](https://github.com/cjlin1/libsvm/raw/9a3a9708926dec87d382c43b203f2ca19c2d56a0/svm.cpp)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

