The provided content contains information about a vulnerability in the Linux kernel related to TCP zerocopy and the misuse of `pfmemalloc` page status.

**Root Cause:**
The vulnerability arises from the incorrect use of `page_is_pfmemalloc()` in the TCP zerocopy paths. This function was being used to check pages coming from user space or other layers, which is inappropriate and could lead to false positives. The `page_is_pfmemalloc()` function checks if a page is allocated by the `pfmemalloc` allocator and should only be used for pages owned by the kernel.

**Weaknesses/Vulnerabilities:**
- **Incorrect pfmemalloc check:** The core issue is that `page_is_pfmemalloc()` was being used on pages not managed by the kernel's `pfmemalloc` allocator.
- **Data race:** The incorrect check led to a data race, detected by the Kernel Concurrency Sanitizer (KCSAN). This data race occurs in `lru_add_fn / tcp_build_frag`.

**Impact of Exploitation:**
- **Data Corruption/Race Condition:** The vulnerability manifested as a data race which can lead to undefined behavior, kernel crashes, and potentially data corruption

**Attack Vectors:**
- The vulnerability is triggered via the TCP zerocopy path.
- A specific sequence of operations involving `sendpage` syscalls, pipes, and file writes can trigger the data race. The provided KCSAN report shows the exploit is triggered by `syz-executor`.
- The vulnerability can be triggered when a page from userspace or another layer is used with TCP zerocopy, leading to the `page_is_pfmemalloc()` function returning an incorrect status.

**Required Attacker Capabilities/Position:**
- Attacker needs the ability to send data using TCP zerocopy.
- Attacker requires the capability to trigger a `sendpage` syscall using a pipe to create the data race.

**Technical Details:**
- The fix replaces calls to `skb_fill_page_desc()` with `skb_fill_page_desc_noacc()` in the zerocopy paths of `net/core/datagram.c` and `net/ipv4/tcp.c`
- A new function `skb_fill_page_desc_noacc` was introduced, which avoids using `page_is_pfmemalloc` when the page is not owned by the kernel.
- The commit also mentions the race is more probable after commit `c07aea3ef4d4` ("mm: add a signature in struct page") because the `page_is_pfmemalloc()` function uses the low order bit of `page->lru.next`, which can change more often.
- The fix includes the prerequisite commit `84ce071e38a6` ("net: introduce `__skb_fill_page_desc_noacc`").