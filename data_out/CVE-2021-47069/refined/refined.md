The provided content relates to CVE-2021-47069.

**Root cause of vulnerability:**
The vulnerability stems from a race condition in the Linux kernel's inter-process communication (IPC) mechanisms, specifically in message queues (mqueue), message passing (msg), and semaphores (sem). The core issue lies in the use of stack-allocated `ext_wait_queue` structures. When `do_mq_timedreceive` is called, a stack-local `ext_wait_queue` address is passed to `wq_sleep` and stored in `info->e_wait_q[RECV].list`. Subsequently, `do_mq_timedsend` retrieves this address to call `__pipelined_op`. The race occurs when `do_mq_timedreceive` returns, rendering the stack address invalid while `do_mq_timedsend` might still use it.

**Weaknesses/vulnerabilities present:**
- **Use-after-free:**  The primary vulnerability is a use-after-free condition. A sender thread (`do_mq_timedsend`) can dereference a pointer to a `struct ext_wait_queue` that was allocated on the stack of a receiver thread (`do_mq_timedreceive`) after the receiver thread has returned, potentially corrupting the memory.
- **Race Condition:** The vulnerability is triggered by a race condition between the receiver thread returning from `do_mq_timedreceive` and the sender thread accessing the stack allocated address.

**Impact of exploitation:**
Exploitation can lead to a kernel crash due to the sender attempting to dereference an invalid memory address. This can manifest as a crash within the `wake_q_add_safe` function, as it receives a bogus address for the receiver's `task_struct`.

**Attack vectors:**
The attack vector involves triggering the vulnerable code paths in message queues, message passing, or semaphores. The specific scenario requires a receiver thread calling `do_mq_timedreceive` (or similar function), sleeping using `wq_sleep`, and a sender thread attempting to send a message using `do_mq_timedsend` or related function.

**Required attacker capabilities/position:**
An attacker needs to be able to trigger the `mq_timedreceive` and `mq_timedsend` (or the corresponding vulnerable operations in msg and sem) syscalls or similar interfaces. The attacker needs to have the ability to execute code that can trigger this race condition. This might involve a local or remote attacker if the relevant syscalls or entrypoints are accessible.