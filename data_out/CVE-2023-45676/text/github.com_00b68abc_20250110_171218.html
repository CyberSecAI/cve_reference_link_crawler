
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fnothings%2Fstb%2Fblob%2F5736b15f7ea0ffb08dd38af21067c314d6a3aae9%2Fstb_vorbis.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fnothings%2Fstb%2Fblob%2F5736b15f7ea0ffb08dd38af21067c314d6a3aae9%2Fstb_vorbis.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=nothings%2Fstb)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[nothings](/nothings)
/
**[stb](/nothings/stb)**
Public

* [Notifications](/login?return_to=%2Fnothings%2Fstb) You must be signed in to change notification settings
* [Fork
  7.7k](/login?return_to=%2Fnothings%2Fstb)
* [Star
   27.5k](/login?return_to=%2Fnothings%2Fstb)

* [Code](/nothings/stb)
* [Issues
  158](/nothings/stb/issues)
* [Pull requests
  131](/nothings/stb/pulls)
* [Discussions](/nothings/stb/discussions)
* [Actions](/nothings/stb/actions)
* [Projects
  0](/nothings/stb/projects)
* [Security](/nothings/stb/security)
* [Insights](/nothings/stb/pulse)

Additional navigation options

* [Code](/nothings/stb)
* [Issues](/nothings/stb/issues)
* [Pull requests](/nothings/stb/pulls)
* [Discussions](/nothings/stb/discussions)
* [Actions](/nothings/stb/actions)
* [Projects](/nothings/stb/projects)
* [Security](/nothings/stb/security)
* [Insights](/nothings/stb/pulse)

## Files

 5736b15
## Breadcrumbs

1. [stb](/nothings/stb/tree/5736b15f7ea0ffb08dd38af21067c314d6a3aae9)
/
# stb\_vorbis.c

Copy path Blame  Blame
## Latest commit

## History

[History](/nothings/stb/commits/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c)5584 lines (4959 loc) · 188 KB 5736b15
## Breadcrumbs

1. [stb](/nothings/stb/tree/5736b15f7ea0ffb08dd38af21067c314d6a3aae9)
/
# stb\_vorbis.c

Top
## File metadata and controls

* Code
* Blame

5584 lines (4959 loc) · 188 KB[Raw](https://github.com/nothings/stb/raw/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000// Ogg Vorbis audio decoder - v1.22 - public domain// http://nothings.org/stb\_vorbis///// Original version written by Sean Barrett in 2007.//// Originally sponsored by RAD Game Tools. Seeking implementation// sponsored by Phillip Bennefall, Marc Andersen, Aaron Baker,// Elias Software, Aras Pranckevicius, and Sean Barrett.//// LICENSE//// See end of file for license information.//// Limitations://// - floor 0 not supported (used in old ogg vorbis files pre-2004)// - lossless sample-truncation at beginning ignored// - cannot concatenate multiple vorbis streams// - sample positions are 32-bit, limiting seekable 192Khz// files to around 6 hours (Ogg supports 64-bit)//// Feature contributors:// Dougall Johnson (sample-exact seeking)//// Bugfix/warning contributors:// Terje Mathisen Niklas Frykholm Andy Hill// Casey Muratori John Bolton Gargaj// Laurent Gomila Marc LeBlanc Ronny Chevalier// Bernhard Wodo Evan Balster github:alxprd// Tom Beaumont Ingo Leitgeb Nicolas Guillemot// Phillip Bennefall Rohit Thiago Goulart// github:manxorist Saga Musix github:infatum// Timur Gagiev Maxwell Koo Peter Waller// github:audinowho Dougall Johnson David Reid// github:Clownacy Pedro J. Estebanez Remi Verschelde// AnthoFoxo github:morlat Gabriel Ravier//// Partial history:// 1.22 - 2021-07-11 - various small fixes// 1.21 - 2021-07-02 - fix bug for files with no comments// 1.20 - 2020-07-11 - several small fixes// 1.19 - 2020-02-05 - warnings// 1.18 - 2020-02-02 - fix seek bugs; parse header comments; misc warnings etc.// 1.17 - 2019-07-08 - fix CVE-2019-13217..CVE-2019-13223 (by ForAllSecure)// 1.16 - 2019-03-04 - fix warnings// 1.15 - 2019-02-07 - explicit failure if Ogg Skeleton data is found// 1.14 - 2018-02-11 - delete bogus dealloca usage// 1.13 - 2018-01-29 - fix truncation of last frame (hopefully)// 1.12 - 2017-11-21 - limit residue begin/end to blocksize/2 to avoid large temp allocs in bad/corrupt files// 1.11 - 2017-07-23 - fix MinGW compilation// 1.10 - 2017-03-03 - more robust seeking; fix negative ilog(); clear error in open\_memory// 1.09 - 2016-04-04 - back out 'truncation of last frame' fix from previous version// 1.08 - 2016-04-02 - warnings; setup memory leaks; truncation of last frame// 1.07 - 2015-01-16 - fixes for crashes on invalid files; warning fixes; const// 1.06 - 2015-08-31 - full, correct support for seeking API (Dougall Johnson)// some crash fixes when out of memory or with corrupt files// fix some inappropriately signed shifts// 1.05 - 2015-04-19 - don't define \_\_forceinline if it's redundant// 1.04 - 2014-08-27 - fix missing const-correct case in API// 1.03 - 2014-08-07 - warning fixes// 1.02 - 2014-07-09 - declare qsort comparison as explicitly \_cdecl in Windows// 1.01 - 2014-06-18 - fix stb\_vorbis\_get\_samples\_float (interleaved was correct)// 1.0 - 2014-05-26 - fix memory leaks; fix warnings; fix bugs in >2-channel;// (API change) report sample rate for decode-full-file funcs//// See end of file for full version history.
////////////////////////////////////////////////////////////////////////////////// HEADER BEGINS HERE//
#ifndef STB\_VORBIS\_INCLUDE\_STB\_VORBIS\_H#define STB\_VORBIS\_INCLUDE\_STB\_VORBIS\_H
#if defined(STB\_VORBIS\_NO\_CRT) && !defined(STB\_VORBIS\_NO\_STDIO)#define STB\_VORBIS\_NO\_STDIO 1#endif
#ifndef STB\_VORBIS\_NO\_STDIO#include <stdio.h>#endif
#ifdef \_\_cplusplusextern "C" {#endif
/////////// THREAD SAFETY
// Individual stb\_vorbis\* handles are not thread-safe; you cannot decode from// them from multiple threads at the same time. However, you can have multiple// stb\_vorbis\* handles and decode from them independently in multiple thrads.
/////////// MEMORY ALLOCATION
// normally stb\_vorbis uses malloc() to allocate memory at startup,// and alloca() to allocate temporary memory during a frame on the// stack. (Memory consumption will depend on the amount of setup// data in the file and how you set the compile flags for speed// vs. size. In my test files the maximal-size usage is ~150KB.)//// You can modify the wrapper functions in the source (setup\_malloc,// setup\_temp\_malloc, temp\_malloc) to change this behavior, or you// can use a simpler allocation model: you pass in a buffer from// which stb\_vorbis will allocate \_all\_ its memory (including the// temp memory). "open" may fail with a VORBIS\_outofmem if you// do not pass in enough data; there is no way to determine how// much you do need except to succeed (at which point you can// query get\_info to find the exact amount required. yes I know// this is lame).//// If you pass in a non-NULL buffer of the type below, allocation// will occur from it as described above. Otherwise just pass NULL// to use malloc()/alloca()
typedef struct{ char \*alloc\_buffer; int alloc\_buffer\_length\_in\_bytes;} stb\_vorbis\_alloc;
/////////// FUNCTIONS USEABLE WITH ALL INPUT MODES
typedef struct stb\_vorbis stb\_vorbis;
typedef struct{ unsigned int sample\_rate; int channels;
 unsigned int setup\_memory\_required; unsigned int setup\_temp\_memory\_required; unsigned int temp\_memory\_required;
 int max\_frame\_size;} stb\_vorbis\_info;
typedef struct{ char \*vendor;
 int comment\_list\_length; char \*\*comment\_list;} stb\_vorbis\_comment;
// get general information about the fileextern stb\_vorbis\_info stb\_vorbis\_get\_info(stb\_vorbis \*f);
// get ogg commentsextern stb\_vorbis\_comment stb\_vorbis\_get\_comment(stb\_vorbis \*f);
// get the last error detected (clears it, too)extern int stb\_vorbis\_get\_error(stb\_vorbis \*f);
// close an ogg vorbis file and free all memory in useextern void stb\_vorbis\_close(stb\_vorbis \*f);
// this function returns the offset (in samples) from the beginning of the// file that will be returned by the next decode, if it is known, or -1// otherwise. after a flush\_pushdata() call, this may take a while before// it becomes valid again.// NOT WORKING YET after a seek with PULLDATA APIextern int stb\_vorbis\_get\_sample\_offset(stb\_vorbis \*f);
// returns the current seek point within the file, or offset from the beginning// of the memory buffer. In pushdata mode it returns 0.extern unsigned int stb\_vorbis\_get\_file\_offset(stb\_vorbis \*f);
/////////// PUSHDATA API
#ifndef STB\_VORBIS\_NO\_PUSHDATA\_API
// this API allows you to get blocks of data from any source and hand// them to stb\_vorbis. you have to buffer them; stb\_vorbis will tell// you how much it used, and you have to give it the rest next time;// and stb\_vorbis may not have enough data to work with and you will// need to give it the same data again PLUS more. Note that the Vorbis// specification does not bound the size of an individual frame.
extern stb\_vorbis \*stb\_vorbis\_open\_pushdata( const unsigned char \* datablock, int datablock\_length\_in\_bytes, int \*datablock\_memory\_consumed\_in\_bytes, int \*error, const stb\_vorbis\_alloc \*alloc\_buffer);// create a vorbis decoder by passing in the initial data block containing// the ogg&vorbis headers (you don't need to do parse them, just provide// the first N bytes of the file--you're told if it's not enough, see below)// on success, returns an stb\_vorbis \*, does not set error, returns the amount of// data parsed/consumed on this call in \*datablock\_memory\_consumed\_in\_bytes;// on failure, returns NULL on error and sets \*error, does not change \*datablock\_memory\_consumed// if returns NULL and \*error is VORBIS\_need\_more\_data, then the input block was// incomplete and you need to pass in a larger block from the start of the file
extern int stb\_vorbis\_decode\_frame\_pushdata( stb\_vorbis \*f, const unsigned char \*datablock, int datablock\_length\_in\_bytes, int \*channels, // place to write number of float \* buffers float \*\*\*output, // place to write float \*\* array of float \* buffers int \*samples // place to write number of output samples );// decode a frame of audio sample data if possible from the passed-in data block//// return value: number of bytes we used from datablock//// possible cases:// 0 bytes used, 0 samples output (need more data)// N bytes used, 0 samples output (resynching the stream, keep going)// N bytes used, M samples output (one frame of data)// note that after opening a file, you will ALWAYS get one N-bytes,0-sample// frame, because Vorbis always "discards" the first frame.//// Note that on resynch, stb\_vorbis will rarely consume all of the buffer,// instead only datablock\_length\_in\_bytes-3 or less. This is because it wants// to avoid missing parts of a page header if they cross a datablock boundary,// without writing state-machiney code to record a partial detection.//// The number of channels returned are stored in \*channels (which can be// NULL--it is always the same as the number of channels reported by// get\_info). \*output will contain an array of float\* buffers, one per// channel. In other words, (\*output)[0][0] contains the first sample from// the first channel, and (\*output)[1][0] contains the first sample from// the second channel.//// \*output points into stb\_vorbis's internal output buffer storage; these// buffers are owned by stb\_vorbis and application code should not free// them or modify their contents. They are transient and will be overwritten// once you ask for more data to get decoded, so be sure to grab any data// you need before then.
extern void stb\_vorbis\_flush\_pushdata(stb\_vorbis \*f);// inform stb\_vorbis that your next datablock will not be contiguous with// previous ones (e.g. you've seeked in the data); future attempts to decode// frames will cause stb\_vorbis to resynchronize (as noted above), and// once it sees a valid Ogg page (typically 4-8KB, as large as 64KB), it// will begin decoding the \_next\_ frame.//// if you want to seek using pushdata, you need to seek in your file, then// call stb\_vorbis\_flush\_pushdata(), then start calling decoding, then once// decoding is returning you data, call stb\_vorbis\_get\_sample\_offset, and// if you don't like the result, seek your file again and repeat.#endif
////////// PULLING INPUT API
#ifndef STB\_VORBIS\_NO\_PULLDATA\_API// This API assumes stb\_vorbis is allowed to pull data from a source--// either a block of memory containing the \_entire\_ vorbis stream, or a// FILE \* that you or it create, or possibly some other reading mechanism// if you go modify the source to replace the FILE \* case with some kind// of callback to your code. (But if you don't support seeking, you may// just want to go ahead and use pushdata.)
#if !defined(STB\_VORBIS\_NO\_STDIO) && !defined(STB\_VORBIS\_NO\_INTEGER\_CONVERSION)extern int stb\_vorbis\_decode\_filename(const char \*filename, int \*channels, int \*sample\_rate, short \*\*output);#endif#if !defined(STB\_VORBIS\_NO\_INTEGER\_CONVERSION)extern int stb\_vorbis\_decode\_memory(const unsigned char \*mem, int len, int \*channels, int \*sample\_rate, short \*\*output);#endif// decode an entire file and output the data interleaved into a malloc()ed// buffer stored in \*output. The return value is the number of samples// decoded, or -1 if the file could not be opened or was not an ogg vorbis file.// When you're done with it, just free() the pointer returned in \*output.
extern stb\_vorbis \* stb\_vorbis\_open\_memory(const unsigned char \*data, int len, int \*error, const stb\_vorbis\_alloc \*alloc\_buffer);// create an ogg vorbis decoder from an ogg vorbis stream in memory (note// this must be the entire stream!). on failure, returns NULL and sets \*error
#ifndef STB\_VORBIS\_NO\_STDIOextern stb\_vorbis \* stb\_vorbis\_open\_filename(const char \*filename, int \*error, const stb\_vorbis\_alloc \*alloc\_buffer);// create an ogg vorbis decoder from a filename via fopen(). on failure,// returns NULL and sets \*error (possibly to VORBIS\_file\_open\_failure).
extern stb\_vorbis \* stb\_vorbis\_open\_file(FILE \*f, int close\_handle\_on\_close, int \*error, const stb\_vorbis\_alloc \*alloc\_buffer);// create an ogg vorbis decoder from an open FILE \*, looking for a stream at// the \_current\_ seek point (ftell). on failure, returns NULL and sets \*error.// note that stb\_vorbis must "own" this stream; if you seek it in between// calls to stb\_vorbis, it will become confused. Moreover, if you attempt to// perform stb\_vorbis\_seek\_\*() operations on this file, it will assume it// owns the \_entire\_ rest of the file after the start point. Use the next// function, stb\_vorbis\_open\_file\_section(), to limit it.
extern stb\_vorbis \* stb\_vorbis\_open\_file\_section(FILE \*f, int close\_handle\_on\_close, int \*error, const stb\_vorbis\_alloc \*alloc\_buffer, unsigned int len);// create an ogg vorbis decoder from an open FILE \*, looking for a stream at// the \_current\_ seek point (ftell); the stream will be of length 'len' bytes.// on failure, returns NULL and sets \*error. note that stb\_vorbis must "own"// this stream; if you seek it in between calls to stb\_vorbis, it will become// confused.#endif
extern int stb\_vorbis\_seek\_frame(stb\_vorbis \*f, unsigned int sample\_number);extern int stb\_vorbis\_seek(stb\_vorbis \*f, unsigned int sample\_number);// these functions seek in the Vorbis file to (approximately) 'sample\_number'.// after calling seek\_frame(), the next call to get\_frame\_\*() will include// the specified sample. after calling stb\_vorbis\_seek(), the next call to// stb\_vorbis\_get\_samples\_\* will start with the specified sample. If you// do not need to seek to EXACTLY the target sample when using get\_samples\_\*,// you can also use seek\_frame().
extern int stb\_vorbis\_seek\_start(stb\_vorbis \*f);// this function is equivalent to stb\_vorbis\_seek(f,0)
extern unsigned int stb\_vorbis\_stream\_length\_in\_samples(stb\_vorbis \*f);extern float stb\_vorbis\_stream\_length\_in\_seconds(stb\_vorbis \*f);// these functions return the total length of the vorbis stream
extern int stb\_vorbis\_get\_frame\_float(stb\_vorbis \*f, int \*channels, float \*\*\*output);// decode the next frame and return the number of samples. the number of// channels returned are stored in \*channels (which can be NULL--it is always// the same as the number of channels reported by get\_info). \*output will// contain an array of float\* buffers, one per channel. These outputs will// be overwritten on the next call to stb\_vorbis\_get\_frame\_\*.//// You generally should not intermix calls to stb\_vorbis\_get\_frame\_\*()// and stb\_vorbis\_get\_samples\_\*(), since the latter calls the former.
#ifndef STB\_VORBIS\_NO\_INTEGER\_CONVERSIONextern int stb\_vorbis\_get\_frame\_short\_interleaved(stb\_vorbis \*f, int num\_c, short \*buffer, int num\_shorts);extern int stb\_vorbis\_get\_frame\_short (stb\_vorbis \*f, int num\_c, short \*\*buffer, int num\_samples);#endif// decode the next frame and return the number of \*samples\* per channel.// Note that for interleaved data, you pass in the number of shorts (the// size of your array), but the return value is the number of samples per// channel, not the total number of samples.//// The data is coerced to the number of channels you request according to the// channel coercion rules (see below). You must pass in the size of your// buffer(s) so that stb\_vorbis will not overwrite the end of the buffer.// The maximum buffer size needed can be gotten from get\_info(); however,// the Vorbis I specification implies an absolute maximum of 4096 samples// per channel.
// Channel coercion rules:// Let M be the number of channels requested, and N the number of channels present,// and Cn be the nth channel; let stereo L be the sum of all L and center channels,// and stereo R be the sum of all R and center channels (channel assignment from the// vorbis spec).// M N output// 1 k sum(Ck) for all k// 2 \* stereo L, stereo R// k l k > l, the first l channels, then 0s// k l k <= l, the first k channels// Note that this is not \_good\_ surround etc. mixing at all! It's just so// you get something useful.
extern int stb\_vorbis\_get\_samples\_float\_interleaved(stb\_vorbis \*f, int channels, float \*buffer, int num\_floats);extern int stb\_vorbis\_get\_samples\_float(stb\_vorbis \*f, int channels, float \*\*buffer, int num\_samples);// gets num\_samples samples, not necessarily on a frame boundary--this requires// buffering so you have to supply the buffers. DOES NOT APPLY THE COERCION RULES.// Returns the number of samples stored per channel; it may be less than requested// at the end of the file. If there are no more samples in the file, returns 0.
#ifndef STB\_VORBIS\_NO\_INTEGER\_CONVERSIONextern int stb\_vorbis\_get\_samples\_short\_interleaved(stb\_vorbis \*f, int channels, short \*buffer, int num\_shorts);extern int stb\_vorbis\_get\_samples\_short(stb\_vorbis \*f, int channels, short \*\*buffer, int num\_samples);#endif// gets num\_samples samples, not necessarily on a frame boundary--this requires// buffering so you have to supply the buffers. Applies the coercion rules above// to produce 'channels' channels. Returns the number of samples stored per channel;// it may be less than requested at the end of the file. If there are no more// samples in the file, returns 0.
#endif
//////// ERROR CODES
enum STBVorbisError{ VORBIS\_\_no\_error,
 VORBIS\_need\_more\_data=1, // not a real error
 VORBIS\_invalid\_api\_mixing, // can't mix API modes VORBIS\_outofmem, // not enough memory VORBIS\_feature\_not\_supported, // uses floor 0 VORBIS\_too\_many\_channels, // STB\_VORBIS\_MAX\_CHANNELS is too small VORBIS\_file\_open\_failure, // fopen() failed VORBIS\_seek\_without\_length, // can't seek in unknown-length file
 VORBIS\_unexpected\_eof=10, // file is truncated? VORBIS\_seek\_invalid, // seek past EOF
 // decoding errors (corrupt/invalid stream) -- you probably // don't care about the exact details of these
 // vorbis errors: VORBIS\_invalid\_setup=20, VORBIS\_invalid\_stream,
 // ogg errors: VORBIS\_missing\_capture\_pattern=30, VORBIS\_invalid\_stream\_structure\_version, VORBIS\_continued\_packet\_flag\_invalid, VORBIS\_incorrect\_stream\_serial\_number, VORBIS\_invalid\_first\_page, VORBIS\_bad\_packet\_type, VORBIS\_cant\_find\_last\_page, VORBIS\_seek\_failed, VORBIS\_ogg\_skeleton\_not\_supported};
#ifdef \_\_cplusplus}#endif
#endif // STB\_VORBIS\_INCLUDE\_STB\_VORBIS\_H//// HEADER ENDS HERE////////////////////////////////////////////////////////////////////////////////
#ifndef STB\_VORBIS\_HEADER\_ONLY
// global configuration settings (e.g. set these in the project/makefile),// or just set them in this file at the top (although ideally the first few// should be visible when the header file is compiled too, although it's not// crucial)
// STB\_VORBIS\_NO\_PUSHDATA\_API// does not compile the code for the various stb\_vorbis\_\*\_pushdata()// functions// #define STB\_VORBIS\_NO\_PUSHDATA\_API
// STB\_VORBIS\_NO\_PULLDATA\_API// does not compile the code for the non-pushdata APIs// #define STB\_VORBIS\_NO\_PULLDATA\_API
// STB\_VORBIS\_NO\_STDIO// does not compile the code for the APIs that use FILE \*s internally// or externally (implied by STB\_VORBIS\_NO\_PULLDATA\_API)// #define STB\_VORBIS\_NO\_STDIO
// STB\_VORBIS\_NO\_INTEGER\_CONVERSION// does not compile the code for converting audio sample data from// float to integer (implied by STB\_VORBIS\_NO\_PULLDATA\_API)// #define STB\_VORBIS\_NO\_INTEGER\_CONVERSION
// STB\_VORBIS\_NO\_FAST\_SCALED\_FLOAT// does not use a fast float-to-int trick to accelerate float-to-int on// most platforms which requires endianness be defined correctly.//#define STB\_VORBIS\_NO\_FAST\_SCALED\_FLOAT
// STB\_VORBIS\_MAX\_CHANNELS [number]// globally define this to the maximum number of channels you need.// The spec does not put a restriction on channels except that// the count is stored in a byte, so 255 is the hard limit.// Reducing this saves about 16 bytes per value, so using 16 saves// (255-16)\*16 or around 4KB. Plus anything other memory usage// I forgot to account for. Can probably go as low as 8 (7.1 audio),// 6 (5.1 audio), or 2 (stereo only).#ifndef STB\_VORBIS\_MAX\_CHANNELS#define STB\_VORBIS\_MAX\_CHANNELS 16 // enough for anyone?#endif
// STB\_VORBIS\_PUSHDATA\_CRC\_COUNT [number]// after a flush\_pushdata(), stb\_vorbis begins scanning for the// next valid page, without backtracking. when it finds something// that looks like a page, it streams through it and verifies its// CRC32. Should that validation fail, it keeps scanning. But it's// possible that \_while\_ streaming through to check the CRC32 of// one candidate page, it sees another candidate page. This #define// determines how many "overlapping" candidate pages it can search// at once. Note that "real" pages are typically ~4KB to ~8KB, whereas// garbage pages could be as big as 64KB, but probably average ~16KB.// So don't hose ourselves by scanning an apparent 64KB page and// missing a ton of real ones in the interim; so minimum of 2#ifndef STB\_VORBIS\_PUSHDATA\_CRC\_COUNT#define STB\_VORBIS\_PUSHDATA\_CRC\_COUNT 4#endif
// STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH [number]// sets the log size of the huffman-acceleration table. Maximum// supported value is 24. with larger numbers, more decodings are O(1),// but the table size is larger so worse cache missing, so you'll have// to probe (and try multiple ogg vorbis files) to find the sweet spot.#ifndef STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH#define STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH 10#endif
// STB\_VORBIS\_FAST\_BINARY\_LENGTH [number]// sets the log size of the binary-search acceleration table. this// is used in similar fashion to the fast-huffman size to set initial// parameters for the binary search
// STB\_VORBIS\_FAST\_HUFFMAN\_INT// The fast huffman tables are much more efficient if they can be// stored as 16-bit results instead of 32-bit results. This restricts// the codebooks to having only 65535 possible outcomes, though.// (At least, accelerated by the huffman table.)#ifndef STB\_VORBIS\_FAST\_HUFFMAN\_INT#define STB\_VORBIS\_FAST\_HUFFMAN\_SHORT#endif
// STB\_VORBIS\_NO\_HUFFMAN\_BINARY\_SEARCH// If the 'fast huffman' search doesn't succeed, then stb\_vorbis falls// back on binary searching for the correct one. This requires storing// extra tables with the huffman codes in sorted order. Defining this// symbol trades off space for speed by forcing a linear search in the// non-fast case, except for "sparse" codebooks.// #define STB\_VORBIS\_NO\_HUFFMAN\_BINARY\_SEARCH
// STB\_VORBIS\_DIVIDES\_IN\_RESIDUE// stb\_vorbis precomputes the result of the scalar residue decoding// that would otherwise require a divide per chunk. you can trade off// space for time by defining this symbol.// #define STB\_VORBIS\_DIVIDES\_IN\_RESIDUE
// STB\_VORBIS\_DIVIDES\_IN\_CODEBOOK// vorbis VQ codebooks can be encoded two ways: with every case explicitly// stored, or with all elements being chosen from a small range of values,// and all values possible in all elements. By default, stb\_vorbis expands// this latter kind out to look like the former kind for ease of decoding,// because otherwise an integer divide-per-vector-element is required to// unpack the index. If you define STB\_VORBIS\_DIVIDES\_IN\_CODEBOOK, you can// trade off storage for speed.//#define STB\_VORBIS\_DIVIDES\_IN\_CODEBOOK
#ifdef STB\_VORBIS\_CODEBOOK\_SHORTS#error "STB\_VORBIS\_CODEBOOK\_SHORTS is no longer supported as it produced incorrect results for some input formats"#endif
// STB\_VORBIS\_DIVIDE\_TABLE// this replaces small integer divides in the floor decode loop with// table lookups. made less than 1% difference, so disabled by default.
// STB\_VORBIS\_NO\_INLINE\_DECODE// disables the inlining of the scalar codebook fast-huffman decode.// might save a little codespace; useful for debugging// #define STB\_VORBIS\_NO\_INLINE\_DECODE
// STB\_VORBIS\_NO\_DEFER\_FLOOR// Normally we only decode the floor without synthesizing the actual// full curve. We can instead synthesize the curve immediately. This// requires more memory and is very likely slower, so I don't think// you'd ever want to do it except for debugging.// #define STB\_VORBIS\_NO\_DEFER\_FLOOR
//////////////////////////////////////////////////////////////////////////////
#ifdef STB\_VORBIS\_NO\_PULLDATA\_API #define STB\_VORBIS\_NO\_INTEGER\_CONVERSION #define STB\_VORBIS\_NO\_STDIO#endif
#if defined(STB\_VORBIS\_NO\_CRT) && !defined(STB\_VORBIS\_NO\_STDIO) #define STB\_VORBIS\_NO\_STDIO 1#endif
#ifndef STB\_VORBIS\_NO\_INTEGER\_CONVERSION#ifndef STB\_VORBIS\_NO\_FAST\_SCALED\_FLOAT
 // only need endianness for fast-float-to-int, which we don't // use for pushdata
 #ifndef STB\_VORBIS\_BIG\_ENDIAN #define STB\_VORBIS\_ENDIAN 0 #else #define STB\_VORBIS\_ENDIAN 1 #endif
#endif#endif
#ifndef STB\_VORBIS\_NO\_STDIO#include <stdio.h>#endif
#ifndef STB\_VORBIS\_NO\_CRT #include <stdlib.h> #include <string.h> #include <assert.h> #include <math.h>
 // find definition of alloca if it's not in stdlib.h: #if defined(\_MSC\_VER) || defined(\_\_MINGW32\_\_) #include <malloc.h> #endif #if defined(\_\_linux\_\_) || defined(\_\_linux) || defined(\_\_sun\_\_) || defined(\_\_EMSCRIPTEN\_\_) || defined(\_\_NEWLIB\_\_) #include <alloca.h> #endif#else // STB\_VORBIS\_NO\_CRT #define NULL 0 #define malloc(s) 0 #define free(s) ((void) 0) #define realloc(s) 0#endif // STB\_VORBIS\_NO\_CRT
#include <limits.h>
#ifdef \_\_MINGW32\_\_ // eff you mingw: // "fixed": // http://sourceforge.net/p/mingw-w64/mailman/message/32882927/ // "no that broke the build, reverted, who cares about C": // http://sourceforge.net/p/mingw-w64/mailman/message/32890381/ #ifdef \_\_forceinline #undef \_\_forceinline #endif #define \_\_forceinline #ifndef alloca #define alloca \_\_builtin\_alloca #endif#elif !defined(\_MSC\_VER) #if \_\_GNUC\_\_ #define \_\_forceinline inline #else #define \_\_forceinline #endif#endif
#if STB\_VORBIS\_MAX\_CHANNELS > 256#error "Value of STB\_VORBIS\_MAX\_CHANNELS outside of allowed range"#endif
#if STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH > 24#error "Value of STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH outside of allowed range"#endif
#if 0#include <crtdbg.h>#define CHECK(f) \_CrtIsValidHeapPointer(f->channel\_buffers[1])#else#define CHECK(f) ((void) 0)#endif
#define MAX\_BLOCKSIZE\_LOG 13 // from specification#define MAX\_BLOCKSIZE (1 << MAX\_BLOCKSIZE\_LOG)
typedef unsigned char uint8;typedef signed char int8;typedef unsigned short uint16;typedef signed short int16;typedef unsigned int uint32;typedef signed int int32;
#ifndef TRUE#define TRUE 1#define FALSE 0#endif
typedef float codetype;
#ifdef \_MSC\_VER#define STBV\_NOTUSED(v) (void)(v)#else#define STBV\_NOTUSED(v) (void)sizeof(v)#endif
// @NOTE//// Some arrays below are tagged "//varies", which means it's actually// a variable-sized piece of data, but rather than malloc I assume it's// small enough it's better to just allocate it all together with the// main thing//// Most of the variables are specified with the smallest size I could pack// them into. It might give better performance to make them all full-sized// integers. It should be safe to freely rearrange the structures or change// the sizes larger--nothing relies on silently truncating etc., nor the// order of variables.
#define FAST\_HUFFMAN\_TABLE\_SIZE (1 << STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH)#define FAST\_HUFFMAN\_TABLE\_MASK (FAST\_HUFFMAN\_TABLE\_SIZE - 1)
typedef struct{ int dimensions, entries; uint8 \*codeword\_lengths; float minimum\_value; float delta\_value; uint8 value\_bits; uint8 lookup\_type; uint8 sequence\_p; uint8 sparse; uint32 lookup\_values; codetype \*multiplicands; uint32 \*codewords; #ifdef STB\_VORBIS\_FAST\_HUFFMAN\_SHORT int16 fast\_huffman[FAST\_HUFFMAN\_TABLE\_SIZE]; #else int32 fast\_huffman[FAST\_HUFFMAN\_TABLE\_SIZE]; #endif uint32 \*sorted\_codewords; int \*sorted\_values; int sorted\_entries;} Codebook;
typedef struct{ uint8 order; uint16 rate; uint16 bark\_map\_size; uint8 amplitude\_bits; uint8 amplitude\_offset; uint8 number\_of\_books; uint8 book\_list[16]; // varies} Floor0;
typedef struct{ uint8 partitions; uint8 partition\_class\_list[32]; // varies uint8 class\_dimensions[16]; // varies uint8 class\_subclasses[16]; // varies uint8 class\_masterbooks[16]; // varies int16 subclass\_books[16][8]; // varies uint16 Xlist[31\*8+2]; // varies uint8 sorted\_order[31\*8+2]; uint8 neighbors[31\*8+2][2]; uint8 floor1\_multiplier; uint8 rangebits; int values;} Floor1;
typedef union{ Floor0 floor0; Floor1 floor1;} Floor;
typedef struct{ uint32 begin, end; uint32 part\_size; uint8 classifications; uint8 classbook; uint8 \*\*classdata; int16 (\*residue\_books)[8];} Residue;
typedef struct{ uint8 magnitude; uint8 angle; uint8 mux;} MappingChannel;
typedef struct{ uint16 coupling\_steps; MappingChannel \*chan; uint8 submaps; uint8 submap\_floor[15]; // varies uint8 submap\_residue[15]; // varies} Mapping;
typedef struct{ uint8 blockflag; uint8 mapping; uint16 windowtype; uint16 transformtype;} Mode;
typedef struct{ uint32 goal\_crc; // expected crc if match int bytes\_left; // bytes left in packet uint32 crc\_so\_far; // running crc int bytes\_done; // bytes processed in \_current\_ chunk uint32 sample\_loc; // granule pos encoded in page} CRCscan;
typedef struct{ uint32 page\_start, page\_end; uint32 last\_decoded\_sample;} ProbedPage;
struct stb\_vorbis{ // user-accessible info unsigned int sample\_rate; int channels;
 unsigned int setup\_memory\_required; unsigned int temp\_memory\_required; unsigned int setup\_temp\_memory\_required;
 char \*vendor; int comment\_list\_length; char \*\*comment\_list;
 // input config#ifndef STB\_VORBIS\_NO\_STDIO FILE \*f; uint32 f\_start; int close\_on\_free;#endif
 uint8 \*stream; uint8 \*stream\_start; uint8 \*stream\_end;
 uint32 stream\_len;
 uint8 push\_mode;
 // the page to seek to when seeking to start, may be zero uint32 first\_audio\_page\_offset;
 // p\_first is the page on which the first audio packet ends // (but not necessarily the page on which it starts) ProbedPage p\_first, p\_last;
 // memory management stb\_vorbis\_alloc alloc; int setup\_offset; int temp\_offset;
 // run-time results int eof; enum STBVorbisError error;
 // user-useful data
 // header info int blocksize[2]; int blocksize\_0, blocksize\_1; int codebook\_count; Codebook \*codebooks; int floor\_count; uint16 floor\_types[64]; // varies Floor \*floor\_config; int residue\_count; uint16 residue\_types[64]; // varies Residue \*residue\_config; int mapping\_count; Mapping \*mapping; int mode\_count; Mode mode\_config[64]; // varies
 uint32 total\_samples;
 // decode buffer float \*channel\_buffers[STB\_VORBIS\_MAX\_CHANNELS]; float \*outputs [STB\_VORBIS\_MAX\_CHANNELS];
 float \*previous\_window[STB\_VORBIS\_MAX\_CHANNELS]; int previous\_length;
 #ifndef STB\_VORBIS\_NO\_DEFER\_FLOOR int16 \*finalY[STB\_VORBIS\_MAX\_CHANNELS]; #else float \*floor\_buffers[STB\_VORBIS\_MAX\_CHANNELS]; #endif
 uint32 current\_loc; // sample location of next frame to decode int current\_loc\_valid;
 // per-blocksize precomputed data
 // twiddle factors float \*A[2],\*B[2],\*C[2]; float \*window[2]; uint16 \*bit\_reverse[2];
 // current page/packet/segment streaming info uint32 serial; // stream serial number for verification int last\_page; int segment\_count; uint8 segments[255]; uint8 page\_flag; uint8 bytes\_in\_seg; uint8 first\_decode; int next\_seg; int last\_seg; // flag that we're on the last segment int last\_seg\_which; // what was the segment number of the last seg? uint32 acc; int valid\_bits; int packet\_bytes; int end\_seg\_with\_known\_loc; uint32 known\_loc\_for\_packet; int discard\_samples\_deferred; uint32 samples\_output;
 // push mode scanning int page\_crc\_tests; // only in push\_mode: number of tests active; -1 if not searching#ifndef STB\_VORBIS\_NO\_PUSHDATA\_API CRCscan scan[STB\_VORBIS\_PUSHDATA\_CRC\_COUNT];#endif
 // sample-access int channel\_buffer\_start; int channel\_buffer\_end;};
#if defined(STB\_VORBIS\_NO\_PUSHDATA\_API) #define IS\_PUSH\_MODE(f) FALSE#elif defined(STB\_VORBIS\_NO\_PULLDATA\_API) #define IS\_PUSH\_MODE(f) TRUE#else #define IS\_PUSH\_MODE(f) ((f)->push\_mode)#endif
typedef struct stb\_vorbis vorb;
static int error(vorb \*f, enum STBVorbisError e){ f->error = e; if (!f->eof && e != VORBIS\_need\_more\_data) { f->error=e; // breakpoint for debugging } return 0;}
// these functions are used for allocating temporary memory// while decoding. if you can afford the stack space, use// alloca(); otherwise, provide a temp buffer and it will// allocate out of those.
#define array\_size\_required(count,size) (count\*(sizeof(void \*)+(size)))
#define temp\_alloc(f,size) (f->alloc.alloc\_buffer ? setup\_temp\_malloc(f,size) : alloca(size))#define temp\_free(f,p) (void)0#define temp\_alloc\_save(f) ((f)->temp\_offset)#define temp\_alloc\_restore(f,p) ((f)->temp\_offset = (p))
#define temp\_block\_array(f,count,size) make\_block\_array(temp\_alloc(f,array\_size\_required(count,size)), count, size)
// given a sufficiently large block of memory, make an array of pointers to subblocks of itstatic void \*make\_block\_array(void \*mem, int count, int size){ int i; void \*\* p = (void \*\*) mem; char \*q = (char \*) (p + count); for (i=0; i < count; ++i) { p[i] = q; q += size; } return p;}
static void \*setup\_malloc(vorb \*f, int sz){ sz = (sz+7) & ~7; // round up to nearest 8 for alignment of future allocs. f->setup\_memory\_required += sz; if (f->alloc.alloc\_buffer) { void \*p = (char \*) f->alloc.alloc\_buffer + f->setup\_offset; if (f->setup\_offset + sz > f->temp\_offset) return NULL; f->setup\_offset += sz; return p; } return sz ? malloc(sz) : NULL;}
static void setup\_free(vorb \*f, void \*p){ if (f->alloc.alloc\_buffer) return; // do nothing; setup mem is a stack free(p);}
static void \*setup\_temp\_malloc(vorb \*f, int sz){ sz = (sz+7) & ~7; // round up to nearest 8 for alignment of future allocs. if (f->alloc.alloc\_buffer) { if (f->temp\_offset - sz < f->setup\_offset) return NULL; f->temp\_offset -= sz; return (char \*) f->alloc.alloc\_buffer + f->temp\_offset; } return malloc(sz);}
static void setup\_temp\_free(vorb \*f, void \*p, int sz){ if (f->alloc.alloc\_buffer) { f->temp\_offset += (sz+7)&~7; return; } free(p);}
#define CRC32\_POLY 0x04c11db7 // from spec
static uint32 crc\_table[256];static void crc32\_init(void){ int i,j; uint32 s; for(i=0; i < 256; i++) { for (s=(uint32) i << 24, j=0; j < 8; ++j) s = (s << 1) ^ (s >= (1U<<31) ? CRC32\_POLY : 0); crc\_table[i] = s; }[View remainder of file in raw view](https://github.com/nothings/stb/raw/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_vorbis.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

