

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=952f048eb901881a7cc6f7c1368b53cd386ead7b)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=952f048eb901881a7cc6f7c1368b53cd386ead7b)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=952f048eb901881a7cc6f7c1368b53cd386ead7b)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=952f048eb901881a7cc6f7c1368b53cd386ead7b)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Qu Wenruo <wqu@suse.com> | 2024-06-06 11:01:51 +0930 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-06-16 13:51:14 +0200 |
| commit | [952f048eb901881a7cc6f7c1368b53cd386ead7b](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=952f048eb901881a7cc6f7c1368b53cd386ead7b) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=952f048eb901881a7cc6f7c1368b53cd386ead7b)) | |
| tree | [4bc6da2b9c3ba95bf77d1116ee25f5fc1e56d66b](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=952f048eb901881a7cc6f7c1368b53cd386ead7b) | |
| parent | [522fb1a22aab83f608fb50b3331d42d3056eef13](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=522fb1a22aab83f608fb50b3331d42d3056eef13) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=952f048eb901881a7cc6f7c1368b53cd386ead7b&id2=522fb1a22aab83f608fb50b3331d42d3056eef13)) | |
| download | [linux-952f048eb901881a7cc6f7c1368b53cd386ead7b.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-952f048eb901881a7cc6f7c1368b53cd386ead7b.tar.gz) | |

btrfs: protect folio::private when attaching extent buffer folioscommit f3a5367c679d31473d3fbb391675055b4792c309 upstream.
[BUG]
Since v6.8 there are rare kernel crashes reported by various people,
the common factor is bad page status error messages like this:
BUG: Bad page state in process kswapd0 pfn:d6e840
page: refcount:0 mapcount:0 mapping:000000007512f4f2 index:0x2796c2c7c
pfn:0xd6e840
aops:btree\_aops ino:1
flags: 0x17ffffe0000008(uptodate|node=0|zone=2|lastcpupid=0x3fffff)
page\_type: 0xffffffff()
raw: 0017ffffe0000008 dead000000000100 dead000000000122 ffff88826d0be4c0
raw: 00000002796c2c7c 0000000000000000 00000000ffffffff 0000000000000000
page dumped because: non-NULL mapping
[CAUSE]
Commit 09e6cef19c9f ("btrfs: refactor alloc\_extent\_buffer() to
allocate-then-attach method") changes the sequence when allocating a new
extent buffer.
Previously we always called grab\_extent\_buffer() under
mapping->i\_private\_lock, to ensure the safety on modification on
folio::private (which is a pointer to extent buffer for regular
sectorsize).
This can lead to the following race:
Thread A is trying to allocate an extent buffer at bytenr X, with 4
4K pages, meanwhile thread B is trying to release the page at X + 4K
(the second page of the extent buffer at X).
Thread A | Thread B
-----------------------------------+-------------------------------------
| btree\_release\_folio()
| | This is for the page at X + 4K,
| | Not page X.
| |
alloc\_extent\_buffer() | |- release\_extent\_buffer()
|- filemap\_add\_folio() for the | | |- atomic\_dec\_and\_test(eb->refs)
| page at bytenr X (the first | | |
| page). | | |
| Which returned -EEXIST. | | |
| | | |
|- filemap\_lock\_folio() | | |
| Returned the first page locked. | | |
| | | |
|- grab\_extent\_buffer() | | |
| |- atomic\_inc\_not\_zero() | | |
| | Returned false | | |
| |- folio\_detach\_private() | | |- folio\_detach\_private() for X
| |- folio\_test\_private() | | |- folio\_test\_private()
| Returned true | | | Returned true
|- folio\_put() | |- folio\_put()
Now there are two puts on the same folio at folio X, leading to refcount
underflow of the folio X, and eventually causing the BUG\_ON() on the
page->mapping.
The condition is not that easy to hit:
- The release must be triggered for the middle page of an eb
If the release is on the same first page of an eb, page lock would kick
in and prevent the race.
- folio\_detach\_private() has a very small race window
It's only between folio\_test\_private() and folio\_clear\_private().
That's exactly when mapping->i\_private\_lock is used to prevent such race,
and commit 09e6cef19c9f ("btrfs: refactor alloc\_extent\_buffer() to
allocate-then-attach method") screwed that up.
At that time, I thought the page lock would kick in as
filemap\_release\_folio() also requires the page to be locked, but forgot
the filemap\_release\_folio() only locks one page, not all pages of an
extent buffer.
[FIX]
Move all the code requiring i\_private\_lock into
attach\_eb\_folio\_to\_filemap(), so that everything is done with proper
lock protection.
Furthermore to prevent future problems, add an extra
lockdep\_assert\_locked() to ensure we're holding the proper lock.
To reproducer that is able to hit the race (takes a few minutes with
instrumented code inserting delays to alloc\_extent\_buffer()):
#!/bin/sh
drop\_caches () {
while(true); do
echo 3 > /proc/sys/vm/drop\_caches
echo 1 > /proc/sys/vm/compact\_memory
done
}
run\_tar () {
while(true); do
for x in `seq 1 80` ; do
tar cf /dev/zero /mnt > /dev/null &
done
wait
done
}
mkfs.btrfs -f -d single -m single /dev/vda
mount -o noatime /dev/vda /mnt
# create 200,000 files, 1K each
./simoop -n 200000 -E -f 1k /mnt
drop\_caches &
(run\_tar)
Reported-by: Linus Torvalds <torvalds@linux-foundation.org>
Link: [https://lore.kernel.org/linux-btrfs/CAHk-=wgt362nGfScVOOii8cgKn2LVVHeOvOA7OBwg1OwbuJQcw@mail.gmail.com/](https://lore.kernel.org/linux-btrfs/CAHk-%3Dwgt362nGfScVOOii8cgKn2LVVHeOvOA7OBwg1OwbuJQcw%40mail.gmail.com/)
Reported-by: Mikhail Gavrilov <mikhail.v.gavrilov@gmail.com>
Link: [https://lore.kernel.org/lkml/CABXGCsPktcHQOvKTbPaTwegMExije=Gpgci5NW=hqORo-s7diA@mail.gmail.com/](https://lore.kernel.org/lkml/CABXGCsPktcHQOvKTbPaTwegMExije%3DGpgci5NW%3DhqORo-s7diA%40mail.gmail.com/)
Reported-by: Toralf FÃ¶rster <toralf.foerster@gmx.de>
Link: [https://lore.kernel.org/linux-btrfs/e8b3311c-9a75-4903-907f-fc0f7a3fe423@gmx.de/](https://lore.kernel.org/linux-btrfs/e8b3311c-9a75-4903-907f-fc0f7a3fe423%40gmx.de/)
Reported-by: syzbot+f80b066392366b4af85e@syzkaller.appspotmail.com
Fixes: 09e6cef19c9f ("btrfs: refactor alloc\_extent\_buffer() to allocate-then-attach method")
CC: stable@vger.kernel.org # 6.8+
CC: Chris Mason <clm@fb.com>
Reviewed-by: Filipe Manana <fdmanana@suse.com>
Reviewed-by: Josef Bacik <josef@toxicpanda.com>
Signed-off-by: Qu Wenruo <wqu@suse.com>
Reviewed-by: David Sterba <dsterba@suse.com>
Signed-off-by: David Sterba <dsterba@suse.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=952f048eb901881a7cc6f7c1368b53cd386ead7b)

| -rw-r--r-- | [fs/btrfs/extent\_io.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/extent_io.c?id=952f048eb901881a7cc6f7c1368b53cd386ead7b) | 60 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 31 insertions, 29 deletions

| diff --git a/fs/btrfs/extent\_io.c b/fs/btrfs/extent\_io.cindex 87f487b1165779..41173701f1befe 100644--- a/[fs/btrfs/extent\_io.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/extent_io.c?id=522fb1a22aab83f608fb50b3331d42d3056eef13)+++ b/[fs/btrfs/extent\_io.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/extent_io.c?id=952f048eb901881a7cc6f7c1368b53cd386ead7b)@@ -3662,6 +3662,8 @@ static struct extent\_buffer \*grab\_extent\_buffer( struct folio \*folio = page\_folio(page); struct extent\_buffer \*exists; + lockdep\_assert\_held(&page->mapping->i\_private\_lock);+ /\* \* For subpage case, we completely rely on radix tree to ensure we \* don't try to insert two ebs for the same bytenr. So here we always@@ -3729,13 +3731,14 @@ static int check\_eb\_alignment(struct btrfs\_fs\_info \*fs\_info, u64 start) \* The caller needs to free the existing folios and retry using the same order. \*/ static int attach\_eb\_folio\_to\_filemap(struct extent\_buffer \*eb, int i,+ struct btrfs\_subpage \*prealloc, struct extent\_buffer \*\*found\_eb\_ret) {  struct btrfs\_fs\_info \*fs\_info = eb->fs\_info; struct address\_space \*mapping = fs\_info->btree\_inode->i\_mapping; const unsigned long index = eb->start >> PAGE\_SHIFT;- struct folio \*existing\_folio;+ struct folio \*existing\_folio = NULL; int ret;  ASSERT(found\_eb\_ret);@@ -3747,12 +3750,14 @@ retry: ret = filemap\_add\_folio(mapping, eb->folios[i], index + i, GFP\_NOFS | \_\_GFP\_NOFAIL); if (!ret)- return 0;+ goto finish;  existing\_folio = filemap\_lock\_folio(mapping, index + i); /\* The page cache only exists for a very short time, just retry. \*/- if (IS\_ERR(existing\_folio))+ if (IS\_ERR(existing\_folio)) {+ existing\_folio = NULL; goto retry;+ }  /\* For now, we should only have single-page folios for btree inode. \*/ ASSERT(folio\_nr\_pages(existing\_folio) == 1);@@ -3763,14 +3768,13 @@ retry: return -EAGAIN; } - if (fs\_info->nodesize < PAGE\_SIZE) {- /\*- \* We're going to reuse the existing page, can drop our page- \* and subpage structure now.- \*/+finish:+ spin\_lock(&mapping->i\_private\_lock);+ if (existing\_folio && fs\_info->nodesize < PAGE\_SIZE) {+ /\* We're going to reuse the existing page, can drop our folio now. \*/ \_\_free\_page(folio\_page(eb->folios[i], 0)); eb->folios[i] = existing\_folio;- } else {+ } else if (existing\_folio) { struct extent\_buffer \*existing\_eb;  existing\_eb = grab\_extent\_buffer(fs\_info,@@ -3778,6 +3782,7 @@ retry: if (existing\_eb) { /\* The extent buffer still exists, we can use it directly. \*/ \*found\_eb\_ret = existing\_eb;+ spin\_unlock(&mapping->i\_private\_lock); folio\_unlock(existing\_folio); folio\_put(existing\_folio); return 1;@@ -3786,6 +3791,22 @@ retry: \_\_free\_page(folio\_page(eb->folios[i], 0)); eb->folios[i] = existing\_folio; }+ eb->folio\_size = folio\_size(eb->folios[i]);+ eb->folio\_shift = folio\_shift(eb->folios[i]);+ /\* Should not fail, as we have preallocated the memory. \*/+ ret = attach\_extent\_buffer\_folio(eb, eb->folios[i], prealloc);+ ASSERT(!ret);+ /\*+ \* To inform we have an extra eb under allocation, so that+ \* detach\_extent\_buffer\_page() won't release the folio private when the+ \* eb hasn't been inserted into radix tree yet.+ \*+ \* The ref will be decreased when the eb releases the page, in+ \* detach\_extent\_buffer\_page(). Thus needs no special handling in the+ \* error path.+ \*/+ btrfs\_folio\_inc\_eb\_refs(fs\_info, eb->folios[i]);+ spin\_unlock(&mapping->i\_private\_lock); return 0; } @@ -3797,7 +3818,6 @@ struct extent\_buffer \*alloc\_extent\_buffer(struct btrfs\_fs\_info \*fs\_info, int attached = 0; struct extent\_buffer \*eb; struct extent\_buffer \*existing\_eb = NULL;- struct address\_space \*mapping = fs\_info->btree\_inode->i\_mapping; struct btrfs\_subpage \*prealloc = NULL; u64 lockdep\_owner = owner\_root; bool page\_contig = true;@@ -3863,7 +3883,7 @@ reallocate: for (int i = 0; i < num\_folios; i++) { struct folio \*folio; - ret = attach\_eb\_folio\_to\_filemap(eb, i, &existing\_eb);+ ret = attach\_eb\_folio\_to\_filemap(eb, i, prealloc, &existing\_eb); if (ret > 0) { ASSERT(existing\_eb); goto out;@@ -3900,24 +3920,6 @@ reallocate: \* and free the allocated page. \*/ folio = eb->folios[i];- eb->folio\_size = folio\_size(folio);- eb->folio\_shift = folio\_shift(folio);- spin\_lock(&mapping->i\_private\_lock);- /\* Should not fail, as we have preallocated the memory \*/- ret = attach\_extent\_buffer\_folio(eb, folio, prealloc);- ASSERT(!ret);- /\*- \* To inform we have extra eb under allocation, so that- \* detach\_extent\_buffer\_page() won't release the folio private- \* when the eb hasn't yet been inserted into radix tree.- \*- \* The ref will be decreased when the eb released the page, in- \* detach\_extent\_buffer\_page().- \* Thus needs no special handling in error path.- \*/- btrfs\_folio\_inc\_eb\_refs(fs\_info, folio);- spin\_unlock(&mapping->i\_private\_lock);- WARN\_ON(btrfs\_folio\_test\_dirty(fs\_info, folio, eb->start, eb->len));  /\* |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 18:29:39 +0000

