

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=1ff2bd566fbcefcb892be85c493bdb92b911c428)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=1ff2bd566fbcefcb892be85c493bdb92b911c428)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=1ff2bd566fbcefcb892be85c493bdb92b911c428)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=1ff2bd566fbcefcb892be85c493bdb92b911c428)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Omar Sandoval <osandov@fb.com> | 2024-05-24 13:58:11 -0700 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-06-16 13:41:42 +0200 |
| commit | [1ff2bd566fbcefcb892be85c493bdb92b911c428](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=1ff2bd566fbcefcb892be85c493bdb92b911c428) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=1ff2bd566fbcefcb892be85c493bdb92b911c428)) | |
| tree | [e29ac72601c8cd9d7e01e08716520485e82a3411](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=1ff2bd566fbcefcb892be85c493bdb92b911c428) | |
| parent | [e601937b5bafc4304e5c1d5779ebb570a8e4af66](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e601937b5bafc4304e5c1d5779ebb570a8e4af66) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=1ff2bd566fbcefcb892be85c493bdb92b911c428&id2=e601937b5bafc4304e5c1d5779ebb570a8e4af66)) | |
| download | [linux-1ff2bd566fbcefcb892be85c493bdb92b911c428.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-1ff2bd566fbcefcb892be85c493bdb92b911c428.tar.gz) | |

btrfs: fix crash on racing fsync and size-extending write into prealloccommit 9d274c19a71b3a276949933859610721a453946b upstream.
We have been seeing crashes on duplicate keys in
btrfs\_set\_item\_key\_safe():
BTRFS critical (device vdb): slot 4 key (450 108 8192) new key (450 108 8192)
------------[ cut here ]------------
kernel BUG at fs/btrfs/ctree.c:2620!
invalid opcode: 0000 [#1] PREEMPT SMP PTI
CPU: 0 PID: 3139 Comm: xfs\_io Kdump: loaded Not tainted 6.9.0 #6
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-2.fc40 04/01/2014
RIP: 0010:btrfs\_set\_item\_key\_safe+0x11f/0x290 [btrfs]
With the following stack trace:
#0 btrfs\_set\_item\_key\_safe (fs/btrfs/ctree.c:2620:4)
#1 btrfs\_drop\_extents (fs/btrfs/file.c:411:4)
#2 log\_one\_extent (fs/btrfs/tree-log.c:4732:9)
#3 btrfs\_log\_changed\_extents (fs/btrfs/tree-log.c:4955:9)
#4 btrfs\_log\_inode (fs/btrfs/tree-log.c:6626:9)
#5 btrfs\_log\_inode\_parent (fs/btrfs/tree-log.c:7070:8)
#6 btrfs\_log\_dentry\_safe (fs/btrfs/tree-log.c:7171:8)
#7 btrfs\_sync\_file (fs/btrfs/file.c:1933:8)
#8 vfs\_fsync\_range (fs/sync.c:188:9)
#9 vfs\_fsync (fs/sync.c:202:9)
#10 do\_fsync (fs/sync.c:212:9)
#11 \_\_do\_sys\_fdatasync (fs/sync.c:225:9)
#12 \_\_se\_sys\_fdatasync (fs/sync.c:223:1)
#13 \_\_x64\_sys\_fdatasync (fs/sync.c:223:1)
#14 do\_syscall\_x64 (arch/x86/entry/common.c:52:14)
#15 do\_syscall\_64 (arch/x86/entry/common.c:83:7)
#16 entry\_SYSCALL\_64+0xaf/0x14c (arch/x86/entry/entry\_64.S:121)
So we're logging a changed extent from fsync, which is splitting an
extent in the log tree. But this split part already exists in the tree,
triggering the BUG().
This is the state of the log tree at the time of the crash, dumped with
drgn (https://github.com/osandov/drgn/blob/main/contrib/btrfs\_tree.py)
to get more details than btrfs\_print\_leaf() gives us:
>>> print\_extent\_buffer(prog.crashed\_thread().stack\_trace()[0]["eb"])
leaf 33439744 level 0 items 72 generation 9 owner 18446744073709551610
leaf 33439744 flags 0x100000000000000
fs uuid e5bd3946-400c-4223-8923-190ef1f18677
chunk uuid d58cb17e-6d02-494a-829a-18b7d8a399da
item 0 key (450 INODE\_ITEM 0) itemoff 16123 itemsize 160
generation 7 transid 9 size 8192 nbytes 8473563889606862198
block group 0 mode 100600 links 1 uid 0 gid 0 rdev 0
sequence 204 flags 0x10(PREALLOC)
atime 1716417703.220000000 (2024-05-22 15:41:43)
ctime 1716417704.983333333 (2024-05-22 15:41:44)
mtime 1716417704.983333333 (2024-05-22 15:41:44)
otime 17592186044416.000000000 (559444-03-08 01:40:16)
item 1 key (450 INODE\_REF 256) itemoff 16110 itemsize 13
index 195 namelen 3 name: 193
item 2 key (450 XATTR\_ITEM 1640047104) itemoff 16073 itemsize 37
location key (0 UNKNOWN.0 0) type XATTR
transid 7 data\_len 1 name\_len 6
name: user.a
data a
item 3 key (450 EXTENT\_DATA 0) itemoff 16020 itemsize 53
generation 9 type 1 (regular)
extent data disk byte 303144960 nr 12288
extent data offset 0 nr 4096 ram 12288
extent compression 0 (none)
item 4 key (450 EXTENT\_DATA 4096) itemoff 15967 itemsize 53
generation 9 type 2 (prealloc)
prealloc data disk byte 303144960 nr 12288
prealloc data offset 4096 nr 8192
item 5 key (450 EXTENT\_DATA 8192) itemoff 15914 itemsize 53
generation 9 type 2 (prealloc)
prealloc data disk byte 303144960 nr 12288
prealloc data offset 8192 nr 4096
...
So the real problem happened earlier: notice that items 4 (4k-12k) and 5
(8k-12k) overlap. Both are prealloc extents. Item 4 straddles i\_size and
item 5 starts at i\_size.
Here is the state of the filesystem tree at the time of the crash:
>>> root = prog.crashed\_thread().stack\_trace()[2]["inode"].root
>>> ret, nodes, slots = btrfs\_search\_slot(root, BtrfsKey(450, 0, 0))
>>> print\_extent\_buffer(nodes[0])
leaf 30425088 level 0 items 184 generation 9 owner 5
leaf 30425088 flags 0x100000000000000
fs uuid e5bd3946-400c-4223-8923-190ef1f18677
chunk uuid d58cb17e-6d02-494a-829a-18b7d8a399da
...
item 179 key (450 INODE\_ITEM 0) itemoff 4907 itemsize 160
generation 7 transid 7 size 4096 nbytes 12288
block group 0 mode 100600 links 1 uid 0 gid 0 rdev 0
sequence 6 flags 0x10(PREALLOC)
atime 1716417703.220000000 (2024-05-22 15:41:43)
ctime 1716417703.220000000 (2024-05-22 15:41:43)
mtime 1716417703.220000000 (2024-05-22 15:41:43)
otime 1716417703.220000000 (2024-05-22 15:41:43)
item 180 key (450 INODE\_REF 256) itemoff 4894 itemsize 13
index 195 namelen 3 name: 193
item 181 key (450 XATTR\_ITEM 1640047104) itemoff 4857 itemsize 37
location key (0 UNKNOWN.0 0) type XATTR
transid 7 data\_len 1 name\_len 6
name: user.a
data a
item 182 key (450 EXTENT\_DATA 0) itemoff 4804 itemsize 53
generation 9 type 1 (regular)
extent data disk byte 303144960 nr 12288
extent data offset 0 nr 8192 ram 12288
extent compression 0 (none)
item 183 key (450 EXTENT\_DATA 8192) itemoff 4751 itemsize 53
generation 9 type 2 (prealloc)
prealloc data disk byte 303144960 nr 12288
prealloc data offset 8192 nr 4096
Item 5 in the log tree corresponds to item 183 in the filesystem tree,
but nothing matches item 4. Furthermore, item 183 is the last item in
the leaf.
btrfs\_log\_prealloc\_extents() is responsible for logging prealloc extents
beyond i\_size. It first truncates any previously logged prealloc extents
that start beyond i\_size. Then, it walks the filesystem tree and copies
the prealloc extent items to the log tree.
If it hits the end of a leaf, then it calls btrfs\_next\_leaf(), which
unlocks the tree and does another search. However, while the filesystem
tree is unlocked, an ordered extent completion may modify the tree. In
particular, it may insert an extent item that overlaps with an extent
item that was already copied to the log tree.
This may manifest in several ways depending on the exact scenario,
including an EEXIST error that is silently translated to a full sync,
overlapping items in the log tree, or this crash. This particular crash
is triggered by the following sequence of events:
- Initially, the file has i\_size=4k, a regular extent from 0-4k, and a
prealloc extent beyond i\_size from 4k-12k. The prealloc extent item is
the last item in its B-tree leaf.
- The file is fsync'd, which copies its inode item and both extent items
to the log tree.
- An xattr is set on the file, which sets the
BTRFS\_INODE\_COPY\_EVERYTHING flag.
- The range 4k-8k in the file is written using direct I/O. i\_size is
extended to 8k, but the ordered extent is still in flight.
- The file is fsync'd. Since BTRFS\_INODE\_COPY\_EVERYTHING is set, this
calls copy\_inode\_items\_to\_log(), which calls
btrfs\_log\_prealloc\_extents().
- btrfs\_log\_prealloc\_extents() finds the 4k-12k prealloc extent in the
filesystem tree. Since it starts before i\_size, it skips it. Since it
is the last item in its B-tree leaf, it calls btrfs\_next\_leaf().
- btrfs\_next\_leaf() unlocks the path.
- The ordered extent completion runs, which converts the 4k-8k part of
the prealloc extent to written and inserts the remaining prealloc part
from 8k-12k.
- btrfs\_next\_leaf() does a search and finds the new prealloc extent
8k-12k.
- btrfs\_log\_prealloc\_extents() copies the 8k-12k prealloc extent into
the log tree. Note that it overlaps with the 4k-12k prealloc extent
that was copied to the log tree by the first fsync.
- fsync calls btrfs\_log\_changed\_extents(), which tries to log the 4k-8k
extent that was written.
- This tries to drop the range 4k-8k in the log tree, which requires
adjusting the start of the 4k-12k prealloc extent in the log tree to
8k.
- btrfs\_set\_item\_key\_safe() sees that there is already an extent
starting at 8k in the log tree and calls BUG().
Fix this by detecting when we're about to insert an overlapping file
extent item in the log tree and truncating the part that would overlap.
CC: stable@vger.kernel.org # 6.1+
Reviewed-by: Filipe Manana <fdmanana@suse.com>
Signed-off-by: Omar Sandoval <osandov@fb.com>
Signed-off-by: David Sterba <dsterba@suse.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=1ff2bd566fbcefcb892be85c493bdb92b911c428)

| -rw-r--r-- | [fs/btrfs/tree-log.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/tree-log.c?id=1ff2bd566fbcefcb892be85c493bdb92b911c428) | 17 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 11 insertions, 6 deletions

| diff --git a/fs/btrfs/tree-log.c b/fs/btrfs/tree-log.cindex 7c33b28c02aebc..b7a5bf88193f93 100644--- a/[fs/btrfs/tree-log.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/tree-log.c?id=e601937b5bafc4304e5c1d5779ebb570a8e4af66)+++ b/[fs/btrfs/tree-log.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/tree-log.c?id=1ff2bd566fbcefcb892be85c493bdb92b911c428)@@ -4845,18 +4845,23 @@ static int btrfs\_log\_prealloc\_extents(struct btrfs\_trans\_handle \*trans, path->slots[0]++; continue; }- if (!dropped\_extents) {- /\*- \* Avoid logging extent items logged in past fsync calls- \* and leading to duplicate keys in the log tree.- \*/+ /\*+ \* Avoid overlapping items in the log tree. The first time we+ \* get here, get rid of everything from a past fsync. After+ \* that, if the current extent starts before the end of the last+ \* extent we copied, truncate the last one. This can happen if+ \* an ordered extent completion modifies the subvolume tree+ \* while btrfs\_next\_leaf() has the tree unlocked.+ \*/+ if (!dropped\_extents || key.offset < truncate\_offset) { ret = truncate\_inode\_items(trans, root->log\_root, inode,- truncate\_offset,+ min(key.offset, truncate\_offset), BTRFS\_EXTENT\_DATA\_KEY); if (ret) goto out; dropped\_extents = true; }+ truncate\_offset = btrfs\_file\_extent\_end(path); if (ins\_nr == 0) start\_slot = slot; ins\_nr++; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 08:41:57 +0000

