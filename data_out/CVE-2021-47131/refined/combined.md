=== Content from git.kernel.org_6d32153e_20250111_164124.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=f1d4184f128dede82a59a841658ed40d4e6d3aa2)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f1d4184f128dede82a59a841658ed40d4e6d3aa2)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f1d4184f128dede82a59a841658ed40d4e6d3aa2)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f1d4184f128dede82a59a841658ed40d4e6d3aa2)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Maxim Mikityanskiy <maximmi@nvidia.com> | 2021-06-01 15:08:00 +0300 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2021-06-10 13:39:18 +0200 |
| commit | [f1d4184f128dede82a59a841658ed40d4e6d3aa2](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f1d4184f128dede82a59a841658ed40d4e6d3aa2) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=f1d4184f128dede82a59a841658ed40d4e6d3aa2)) | |
| tree | [214d6bf0bd443387f97e4633836d089e3c4fc09c](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f1d4184f128dede82a59a841658ed40d4e6d3aa2) | |
| parent | [874ece252ed269f5ac1f55167a3f2735ab0f249f](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=874ece252ed269f5ac1f55167a3f2735ab0f249f) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f1d4184f128dede82a59a841658ed40d4e6d3aa2&id2=874ece252ed269f5ac1f55167a3f2735ab0f249f)) | |
| download | [linux-f1d4184f128dede82a59a841658ed40d4e6d3aa2.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-f1d4184f128dede82a59a841658ed40d4e6d3aa2.tar.gz) | |

net/tls: Fix use-after-free after the TLS device goes down and up[ Upstream commit c55dcdd435aa6c6ad6ccac0a4c636d010ee367a4 ]
When a netdev with active TLS offload goes down, tls\_device\_down is
called to stop the offload and tear down the TLS context. However, the
socket stays alive, and it still points to the TLS context, which is now
deallocated. If a netdev goes up, while the connection is still active,
and the data flow resumes after a number of TCP retransmissions, it will
lead to a use-after-free of the TLS context.
This commit addresses this bug by keeping the context alive until its
normal destruction, and implements the necessary fallbacks, so that the
connection can resume in software (non-offloaded) kTLS mode.
On the TX side tls\_sw\_fallback is used to encrypt all packets. The RX
side already has all the necessary fallbacks, because receiving
non-decrypted packets is supported. The thing needed on the RX side is
to block resync requests, which are normally produced after receiving
non-decrypted packets.
The necessary synchronization is implemented for a graceful teardown:
first the fallbacks are deployed, then the driver resources are released
(it used to be possible to have a tls\_dev\_resync after tls\_dev\_del).
A new flag called TLS\_RX\_DEV\_DEGRADED is added to indicate the fallback
mode. It's used to skip the RX resync logic completely, as it becomes
useless, and some objects may be released (for example, resync\_async,
which is allocated and freed by the driver).
Fixes: e8f69799810c ("net/tls: Add generic NIC offload infrastructure")
Signed-off-by: Maxim Mikityanskiy <maximmi@nvidia.com>
Reviewed-by: Tariq Toukan <tariqt@nvidia.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f1d4184f128dede82a59a841658ed40d4e6d3aa2)

| -rw-r--r-- | [include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/tls.h?id=f1d4184f128dede82a59a841658ed40d4e6d3aa2) | 9 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/tls/tls\_device.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/tls/tls_device.c?id=f1d4184f128dede82a59a841658ed40d4e6d3aa2) | 52 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/tls/tls\_device\_fallback.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/tls/tls_device_fallback.c?id=f1d4184f128dede82a59a841658ed40d4e6d3aa2) | 7 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/tls/tls\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/tls/tls_main.c?id=f1d4184f128dede82a59a841658ed40d4e6d3aa2) | 1 | |  |  |  | | --- | --- | --- | |

4 files changed, 64 insertions, 5 deletions

| diff --git a/include/net/tls.h b/include/net/tls.hindex d32a067055877d..43891b28fc4820 100644--- a/[include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/tls.h?id=874ece252ed269f5ac1f55167a3f2735ab0f249f)+++ b/[include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/tls.h?id=f1d4184f128dede82a59a841658ed40d4e6d3aa2)@@ -193,6 +193,11 @@ struct tls\_offload\_context\_tx { (sizeof(struct tls\_offload\_context\_tx) + TLS\_DRIVER\_STATE\_SIZE\_TX)  enum tls\_context\_flags {+ /\* tls\_device\_down was called after the netdev went down, device state+ \* was released, and kTLS works in software, even though rx\_conf is+ \* still TLS\_HW (needed for transition).+ \*/+ TLS\_RX\_DEV\_DEGRADED = 0, /\* Unlike RX where resync is driven entirely by the core in TX only \* the driver knows when things went out of sync, so we need the flag \* to be atomic.@@ -264,6 +269,7 @@ struct tls\_context {  /\* cache cold stuff \*/ struct proto \*sk\_proto;+ struct sock \*sk;  void (\*sk\_destruct)(struct sock \*sk); @@ -446,6 +452,9 @@ static inline u16 tls\_user\_config(struct tls\_context \*ctx, bool tx) struct sk\_buff \* tls\_validate\_xmit\_skb(struct sock \*sk, struct net\_device \*dev, struct sk\_buff \*skb);+struct sk\_buff \*+tls\_validate\_xmit\_skb\_sw(struct sock \*sk, struct net\_device \*dev,+ struct sk\_buff \*skb);  static inline bool tls\_is\_sk\_tx\_device\_offloaded(struct sock \*sk) {diff --git a/net/tls/tls\_device.c b/net/tls/tls\_device.cindex abc04045577d82..f718c7346088fc 100644--- a/[net/tls/tls\_device.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_device.c?id=874ece252ed269f5ac1f55167a3f2735ab0f249f)+++ b/[net/tls/tls\_device.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_device.c?id=f1d4184f128dede82a59a841658ed40d4e6d3aa2)@@ -50,6 +50,7 @@ static void tls\_device\_gc\_task(struct work\_struct \*work); static DECLARE\_WORK(tls\_device\_gc\_work, tls\_device\_gc\_task); static LIST\_HEAD(tls\_device\_gc\_list); static LIST\_HEAD(tls\_device\_list);+static LIST\_HEAD(tls\_device\_down\_list); static DEFINE\_SPINLOCK(tls\_device\_lock);  static void tls\_device\_free\_ctx(struct tls\_context \*ctx)@@ -759,6 +760,8 @@ void tls\_device\_rx\_resync\_new\_rec(struct sock \*sk, u32 rcd\_len, u32 seq)  if (tls\_ctx->rx\_conf != TLS\_HW) return;+ if (unlikely(test\_bit(TLS\_RX\_DEV\_DEGRADED, &tls\_ctx->flags)))+ return;  prot = &tls\_ctx->prot\_info; rx\_ctx = tls\_offload\_ctx\_rx(tls\_ctx);@@ -961,6 +964,17 @@ int tls\_device\_decrypted(struct sock \*sk, struct tls\_context \*tls\_ctx,  ctx->sw.decrypted |= is\_decrypted; + if (unlikely(test\_bit(TLS\_RX\_DEV\_DEGRADED, &tls\_ctx->flags))) {+ if (likely(is\_encrypted || is\_decrypted))+ return 0;++ /\* After tls\_device\_down disables the offload, the next SKB will+ \* likely have initial fragments decrypted, and final ones not+ \* decrypted. We need to reencrypt that single SKB.+ \*/+ return tls\_device\_reencrypt(sk, skb);+ }+ /\* Return immediately if the record is either entirely plaintext or \* entirely ciphertext. Otherwise handle reencrypt partially decrypted \* record.@@ -1288,6 +1302,26 @@ static int tls\_device\_down(struct net\_device \*netdev) spin\_unlock\_irqrestore(&tls\_device\_lock, flags);  list\_for\_each\_entry\_safe(ctx, tmp, &list, list) {+ /\* Stop offloaded TX and switch to the fallback.+ \* tls\_is\_sk\_tx\_device\_offloaded will return false.+ \*/+ WRITE\_ONCE(ctx->sk->sk\_validate\_xmit\_skb, tls\_validate\_xmit\_skb\_sw);++ /\* Stop the RX and TX resync.+ \* tls\_dev\_resync must not be called after tls\_dev\_del.+ \*/+ WRITE\_ONCE(ctx->netdev, NULL);++ /\* Start skipping the RX resync logic completely. \*/+ set\_bit(TLS\_RX\_DEV\_DEGRADED, &ctx->flags);++ /\* Sync with inflight packets. After this point:+ \* TX: no non-encrypted packets will be passed to the driver.+ \* RX: resync requests from the driver will be ignored.+ \*/+ synchronize\_net();++ /\* Release the offload context on the driver side. \*/ if (ctx->tx\_conf == TLS\_HW) netdev->tlsdev\_ops->tls\_dev\_del(netdev, ctx, TLS\_OFFLOAD\_CTX\_DIR\_TX);@@ -1295,13 +1329,21 @@ static int tls\_device\_down(struct net\_device \*netdev) !test\_bit(TLS\_RX\_DEV\_CLOSED, &ctx->flags)) netdev->tlsdev\_ops->tls\_dev\_del(netdev, ctx, TLS\_OFFLOAD\_CTX\_DIR\_RX);- WRITE\_ONCE(ctx->netdev, NULL);- synchronize\_net();+ dev\_put(netdev);- list\_del\_init(&ctx->list); - if (refcount\_dec\_and\_test(&ctx->refcount))- tls\_device\_free\_ctx(ctx);+ /\* Move the context to a separate list for two reasons:+ \* 1. When the context is deallocated, list\_del is called.+ \* 2. It's no longer an offloaded context, so we don't want to+ \* run offload-specific code on this context.+ \*/+ spin\_lock\_irqsave(&tls\_device\_lock, flags);+ list\_move\_tail(&ctx->list, &tls\_device\_down\_list);+ spin\_unlock\_irqrestore(&tls\_device\_lock, flags);++ /\* Device contexts for RX and TX will be freed in on sk\_destruct+ \* by tls\_device\_free\_ctx. rx\_conf and tx\_conf stay in TLS\_HW.+ \*/ }  up\_write(&device\_offload\_lock);diff --git a/net/tls/tls\_device\_fallback.c b/net/tls/tls\_device\_fallback.cindex 28895333701e40..0d40016bf69e03 100644--- a/[net/tls/tls\_device\_fallback.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_device_fallback.c?id=874ece252ed269f5ac1f55167a3f2735ab0f249f)+++ b/[net/tls/tls\_device\_fallback.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_device_fallback.c?id=f1d4184f128dede82a59a841658ed40d4e6d3aa2)@@ -430,6 +430,13 @@ struct sk\_buff \*tls\_validate\_xmit\_skb(struct sock \*sk, } EXPORT\_SYMBOL\_GPL(tls\_validate\_xmit\_skb); +struct sk\_buff \*tls\_validate\_xmit\_skb\_sw(struct sock \*sk,+ struct net\_device \*dev,+ struct sk\_buff \*skb)+{+ return tls\_sw\_fallback(sk, skb);+}+ struct sk\_buff \*tls\_encrypt\_skb(struct sk\_buff \*skb) { return tls\_sw\_fallback(skb->sk, skb);diff --git a/net/tls/tls\_main.c b/net/tls/tls\_main.cindex 8d93cea99f2cb2..32a51b20509c92 100644--- a/[net/tls/tls\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_main.c?id=874ece252ed269f5ac1f55167a3f2735ab0f249f)+++ b/[net/tls/tls\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_main.c?id=f1d4184f128dede82a59a841658ed40d4e6d3aa2)@@ -633,6 +633,7 @@ struct tls\_context \*tls\_ctx\_create(struct sock \*sk) mutex\_init(&ctx->tx\_lock); rcu\_assign\_pointer(icsk->icsk\_ulp\_data, ctx); ctx->sk\_proto = READ\_ONCE(sk->sk\_prot);+ ctx->sk = sk; return ctx; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 16:40:01 +0000



=== Content from git.kernel.org_36cdfb0f_20250111_164122.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=0f1e6fe66977a864fe850522316f713d7b926fd9)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=0f1e6fe66977a864fe850522316f713d7b926fd9)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=0f1e6fe66977a864fe850522316f713d7b926fd9)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=0f1e6fe66977a864fe850522316f713d7b926fd9)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Maxim Mikityanskiy <maximmi@nvidia.com> | 2021-06-01 15:08:00 +0300 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2021-06-10 13:41:36 +0200 |
| commit | [0f1e6fe66977a864fe850522316f713d7b926fd9](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=0f1e6fe66977a864fe850522316f713d7b926fd9) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=0f1e6fe66977a864fe850522316f713d7b926fd9)) | |
| tree | [9a348be974716453a5e37810d7740e748d795fd9](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=0f1e6fe66977a864fe850522316f713d7b926fd9) | |
| parent | [aada297447114019ab63ee4e7d6c5906f6cfa7e9](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=aada297447114019ab63ee4e7d6c5906f6cfa7e9) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=0f1e6fe66977a864fe850522316f713d7b926fd9&id2=aada297447114019ab63ee4e7d6c5906f6cfa7e9)) | |
| download | [linux-0f1e6fe66977a864fe850522316f713d7b926fd9.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-0f1e6fe66977a864fe850522316f713d7b926fd9.tar.gz) | |

net/tls: Fix use-after-free after the TLS device goes down and up[ Upstream commit c55dcdd435aa6c6ad6ccac0a4c636d010ee367a4 ]
When a netdev with active TLS offload goes down, tls\_device\_down is
called to stop the offload and tear down the TLS context. However, the
socket stays alive, and it still points to the TLS context, which is now
deallocated. If a netdev goes up, while the connection is still active,
and the data flow resumes after a number of TCP retransmissions, it will
lead to a use-after-free of the TLS context.
This commit addresses this bug by keeping the context alive until its
normal destruction, and implements the necessary fallbacks, so that the
connection can resume in software (non-offloaded) kTLS mode.
On the TX side tls\_sw\_fallback is used to encrypt all packets. The RX
side already has all the necessary fallbacks, because receiving
non-decrypted packets is supported. The thing needed on the RX side is
to block resync requests, which are normally produced after receiving
non-decrypted packets.
The necessary synchronization is implemented for a graceful teardown:
first the fallbacks are deployed, then the driver resources are released
(it used to be possible to have a tls\_dev\_resync after tls\_dev\_del).
A new flag called TLS\_RX\_DEV\_DEGRADED is added to indicate the fallback
mode. It's used to skip the RX resync logic completely, as it becomes
useless, and some objects may be released (for example, resync\_async,
which is allocated and freed by the driver).
Fixes: e8f69799810c ("net/tls: Add generic NIC offload infrastructure")
Signed-off-by: Maxim Mikityanskiy <maximmi@nvidia.com>
Reviewed-by: Tariq Toukan <tariqt@nvidia.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=0f1e6fe66977a864fe850522316f713d7b926fd9)

| -rw-r--r-- | [include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/tls.h?id=0f1e6fe66977a864fe850522316f713d7b926fd9) | 9 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/tls/tls\_device.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/tls/tls_device.c?id=0f1e6fe66977a864fe850522316f713d7b926fd9) | 52 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/tls/tls\_device\_fallback.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/tls/tls_device_fallback.c?id=0f1e6fe66977a864fe850522316f713d7b926fd9) | 7 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/tls/tls\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/tls/tls_main.c?id=0f1e6fe66977a864fe850522316f713d7b926fd9) | 1 | |  |  |  | | --- | --- | --- | |

4 files changed, 64 insertions, 5 deletions

| diff --git a/include/net/tls.h b/include/net/tls.hindex 6531ace2a68bd1..8341a8d1e80733 100644--- a/[include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/tls.h?id=aada297447114019ab63ee4e7d6c5906f6cfa7e9)+++ b/[include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/tls.h?id=0f1e6fe66977a864fe850522316f713d7b926fd9)@@ -193,6 +193,11 @@ struct tls\_offload\_context\_tx { (sizeof(struct tls\_offload\_context\_tx) + TLS\_DRIVER\_STATE\_SIZE\_TX)  enum tls\_context\_flags {+ /\* tls\_device\_down was called after the netdev went down, device state+ \* was released, and kTLS works in software, even though rx\_conf is+ \* still TLS\_HW (needed for transition).+ \*/+ TLS\_RX\_DEV\_DEGRADED = 0, /\* Unlike RX where resync is driven entirely by the core in TX only \* the driver knows when things went out of sync, so we need the flag \* to be atomic.@@ -265,6 +270,7 @@ struct tls\_context {  /\* cache cold stuff \*/ struct proto \*sk\_proto;+ struct sock \*sk;  void (\*sk\_destruct)(struct sock \*sk); @@ -447,6 +453,9 @@ static inline u16 tls\_user\_config(struct tls\_context \*ctx, bool tx) struct sk\_buff \* tls\_validate\_xmit\_skb(struct sock \*sk, struct net\_device \*dev, struct sk\_buff \*skb);+struct sk\_buff \*+tls\_validate\_xmit\_skb\_sw(struct sock \*sk, struct net\_device \*dev,+ struct sk\_buff \*skb);  static inline bool tls\_is\_sk\_tx\_device\_offloaded(struct sock \*sk) {diff --git a/net/tls/tls\_device.c b/net/tls/tls\_device.cindex 2602d61a8d28d3..9b1ea17f3b1dc1 100644--- a/[net/tls/tls\_device.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_device.c?id=aada297447114019ab63ee4e7d6c5906f6cfa7e9)+++ b/[net/tls/tls\_device.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_device.c?id=0f1e6fe66977a864fe850522316f713d7b926fd9)@@ -50,6 +50,7 @@ static void tls\_device\_gc\_task(struct work\_struct \*work); static DECLARE\_WORK(tls\_device\_gc\_work, tls\_device\_gc\_task); static LIST\_HEAD(tls\_device\_gc\_list); static LIST\_HEAD(tls\_device\_list);+static LIST\_HEAD(tls\_device\_down\_list); static DEFINE\_SPINLOCK(tls\_device\_lock);  static void tls\_device\_free\_ctx(struct tls\_context \*ctx)@@ -759,6 +760,8 @@ void tls\_device\_rx\_resync\_new\_rec(struct sock \*sk, u32 rcd\_len, u32 seq)  if (tls\_ctx->rx\_conf != TLS\_HW) return;+ if (unlikely(test\_bit(TLS\_RX\_DEV\_DEGRADED, &tls\_ctx->flags)))+ return;  prot = &tls\_ctx->prot\_info; rx\_ctx = tls\_offload\_ctx\_rx(tls\_ctx);@@ -961,6 +964,17 @@ int tls\_device\_decrypted(struct sock \*sk, struct tls\_context \*tls\_ctx,  ctx->sw.decrypted |= is\_decrypted; + if (unlikely(test\_bit(TLS\_RX\_DEV\_DEGRADED, &tls\_ctx->flags))) {+ if (likely(is\_encrypted || is\_decrypted))+ return 0;++ /\* After tls\_device\_down disables the offload, the next SKB will+ \* likely have initial fragments decrypted, and final ones not+ \* decrypted. We need to reencrypt that single SKB.+ \*/+ return tls\_device\_reencrypt(sk, skb);+ }+ /\* Return immediately if the record is either entirely plaintext or \* entirely ciphertext. Otherwise handle reencrypt partially decrypted \* record.@@ -1290,6 +1304,26 @@ static int tls\_device\_down(struct net\_device \*netdev) spin\_unlock\_irqrestore(&tls\_device\_lock, flags);  list\_for\_each\_entry\_safe(ctx, tmp, &list, list) {+ /\* Stop offloaded TX and switch to the fallback.+ \* tls\_is\_sk\_tx\_device\_offloaded will return false.+ \*/+ WRITE\_ONCE(ctx->sk->sk\_validate\_xmit\_skb, tls\_validate\_xmit\_skb\_sw);++ /\* Stop the RX and TX resync.+ \* tls\_dev\_resync must not be called after tls\_dev\_del.+ \*/+ WRITE\_ONCE(ctx->netdev, NULL);++ /\* Start skipping the RX resync logic completely. \*/+ set\_bit(TLS\_RX\_DEV\_DEGRADED, &ctx->flags);++ /\* Sync with inflight packets. After this point:+ \* TX: no non-encrypted packets will be passed to the driver.+ \* RX: resync requests from the driver will be ignored.+ \*/+ synchronize\_net();++ /\* Release the offload context on the driver side. \*/ if (ctx->tx\_conf == TLS\_HW) netdev->tlsdev\_ops->tls\_dev\_del(netdev, ctx, TLS\_OFFLOAD\_CTX\_DIR\_TX);@@ -1297,13 +1331,21 @@ static int tls\_device\_down(struct net\_device \*netdev) !test\_bit(TLS\_RX\_DEV\_CLOSED, &ctx->flags)) netdev->tlsdev\_ops->tls\_dev\_del(netdev, ctx, TLS\_OFFLOAD\_CTX\_DIR\_RX);- WRITE\_ONCE(ctx->netdev, NULL);- synchronize\_net();+ dev\_put(netdev);- list\_del\_init(&ctx->list); - if (refcount\_dec\_and\_test(&ctx->refcount))- tls\_device\_free\_ctx(ctx);+ /\* Move the context to a separate list for two reasons:+ \* 1. When the context is deallocated, list\_del is called.+ \* 2. It's no longer an offloaded context, so we don't want to+ \* run offload-specific code on this context.+ \*/+ spin\_lock\_irqsave(&tls\_device\_lock, flags);+ list\_move\_tail(&ctx->list, &tls\_device\_down\_list);+ spin\_unlock\_irqrestore(&tls\_device\_lock, flags);++ /\* Device contexts for RX and TX will be freed in on sk\_destruct+ \* by tls\_device\_free\_ctx. rx\_conf and tx\_conf stay in TLS\_HW.+ \*/ }  up\_write(&device\_offload\_lock);diff --git a/net/tls/tls\_device\_fallback.c b/net/tls/tls\_device\_fallback.cindex cacf040872c74c..e40bedd112b685 100644--- a/[net/tls/tls\_device\_fallback.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_device_fallback.c?id=aada297447114019ab63ee4e7d6c5906f6cfa7e9)+++ b/[net/tls/tls\_device\_fallback.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_device_fallback.c?id=0f1e6fe66977a864fe850522316f713d7b926fd9)@@ -431,6 +431,13 @@ struct sk\_buff \*tls\_validate\_xmit\_skb(struct sock \*sk, } EXPORT\_SYMBOL\_GPL(tls\_validate\_xmit\_skb); +struct sk\_buff \*tls\_validate\_xmit\_skb\_sw(struct sock \*sk,+ struct net\_device \*dev,+ struct sk\_buff \*skb)+{+ return tls\_sw\_fallback(sk, skb);+}+ struct sk\_buff \*tls\_encrypt\_skb(struct sk\_buff \*skb) { return tls\_sw\_fallback(skb->sk, skb);diff --git a/net/tls/tls\_main.c b/net/tls/tls\_main.cindex 47b7c5334c346f..fde56ff491637b 100644--- a/[net/tls/tls\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_main.c?id=aada297447114019ab63ee4e7d6c5906f6cfa7e9)+++ b/[net/tls/tls\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_main.c?id=0f1e6fe66977a864fe850522316f713d7b926fd9)@@ -636,6 +636,7 @@ struct tls\_context \*tls\_ctx\_create(struct sock \*sk) mutex\_init(&ctx->tx\_lock); rcu\_assign\_pointer(icsk->icsk\_ulp\_data, ctx); ctx->sk\_proto = READ\_ONCE(sk->sk\_prot);+ ctx->sk = sk; return ctx; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 16:39:59 +0000



=== Content from git.kernel.org_39639a45_20250111_164122.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=c55dcdd435aa6c6ad6ccac0a4c636d010ee367a4)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=c55dcdd435aa6c6ad6ccac0a4c636d010ee367a4)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=c55dcdd435aa6c6ad6ccac0a4c636d010ee367a4)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=c55dcdd435aa6c6ad6ccac0a4c636d010ee367a4)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Maxim Mikityanskiy <maximmi@nvidia.com> | 2021-06-01 15:08:00 +0300 |
| --- | --- | --- |
| committer | David S. Miller <davem@davemloft.net> | 2021-06-01 15:58:05 -0700 |
| commit | [c55dcdd435aa6c6ad6ccac0a4c636d010ee367a4](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=c55dcdd435aa6c6ad6ccac0a4c636d010ee367a4) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=c55dcdd435aa6c6ad6ccac0a4c636d010ee367a4)) | |
| tree | [f128e09998bb979a99cc5d8325c31ab3d10eaa74](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=c55dcdd435aa6c6ad6ccac0a4c636d010ee367a4) | |
| parent | [05fc8b6cbd4f979a6f25759c4a17dd5f657f7ecd](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=05fc8b6cbd4f979a6f25759c4a17dd5f657f7ecd) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=c55dcdd435aa6c6ad6ccac0a4c636d010ee367a4&id2=05fc8b6cbd4f979a6f25759c4a17dd5f657f7ecd)) | |
| download | [linux-c55dcdd435aa6c6ad6ccac0a4c636d010ee367a4.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-c55dcdd435aa6c6ad6ccac0a4c636d010ee367a4.tar.gz) | |

net/tls: Fix use-after-free after the TLS device goes down and upWhen a netdev with active TLS offload goes down, tls\_device\_down is
called to stop the offload and tear down the TLS context. However, the
socket stays alive, and it still points to the TLS context, which is now
deallocated. If a netdev goes up, while the connection is still active,
and the data flow resumes after a number of TCP retransmissions, it will
lead to a use-after-free of the TLS context.
This commit addresses this bug by keeping the context alive until its
normal destruction, and implements the necessary fallbacks, so that the
connection can resume in software (non-offloaded) kTLS mode.
On the TX side tls\_sw\_fallback is used to encrypt all packets. The RX
side already has all the necessary fallbacks, because receiving
non-decrypted packets is supported. The thing needed on the RX side is
to block resync requests, which are normally produced after receiving
non-decrypted packets.
The necessary synchronization is implemented for a graceful teardown:
first the fallbacks are deployed, then the driver resources are released
(it used to be possible to have a tls\_dev\_resync after tls\_dev\_del).
A new flag called TLS\_RX\_DEV\_DEGRADED is added to indicate the fallback
mode. It's used to skip the RX resync logic completely, as it becomes
useless, and some objects may be released (for example, resync\_async,
which is allocated and freed by the driver).
Fixes: e8f69799810c ("net/tls: Add generic NIC offload infrastructure")
Signed-off-by: Maxim Mikityanskiy <maximmi@nvidia.com>
Reviewed-by: Tariq Toukan <tariqt@nvidia.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=c55dcdd435aa6c6ad6ccac0a4c636d010ee367a4)

| -rw-r--r-- | [include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/tls.h?id=c55dcdd435aa6c6ad6ccac0a4c636d010ee367a4) | 9 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/tls/tls\_device.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/tls/tls_device.c?id=c55dcdd435aa6c6ad6ccac0a4c636d010ee367a4) | 52 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/tls/tls\_device\_fallback.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/tls/tls_device_fallback.c?id=c55dcdd435aa6c6ad6ccac0a4c636d010ee367a4) | 7 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/tls/tls\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/tls/tls_main.c?id=c55dcdd435aa6c6ad6ccac0a4c636d010ee367a4) | 1 | |  |  |  | | --- | --- | --- | |

4 files changed, 64 insertions, 5 deletions

| diff --git a/include/net/tls.h b/include/net/tls.hindex 6531ace2a68bd1..8341a8d1e80733 100644--- a/[include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/tls.h?id=05fc8b6cbd4f979a6f25759c4a17dd5f657f7ecd)+++ b/[include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/tls.h?id=c55dcdd435aa6c6ad6ccac0a4c636d010ee367a4)@@ -193,6 +193,11 @@ struct tls\_offload\_context\_tx { (sizeof(struct tls\_offload\_context\_tx) + TLS\_DRIVER\_STATE\_SIZE\_TX)  enum tls\_context\_flags {+ /\* tls\_device\_down was called after the netdev went down, device state+ \* was released, and kTLS works in software, even though rx\_conf is+ \* still TLS\_HW (needed for transition).+ \*/+ TLS\_RX\_DEV\_DEGRADED = 0, /\* Unlike RX where resync is driven entirely by the core in TX only \* the driver knows when things went out of sync, so we need the flag \* to be atomic.@@ -265,6 +270,7 @@ struct tls\_context {  /\* cache cold stuff \*/ struct proto \*sk\_proto;+ struct sock \*sk;  void (\*sk\_destruct)(struct sock \*sk); @@ -447,6 +453,9 @@ static inline u16 tls\_user\_config(struct tls\_context \*ctx, bool tx) struct sk\_buff \* tls\_validate\_xmit\_skb(struct sock \*sk, struct net\_device \*dev, struct sk\_buff \*skb);+struct sk\_buff \*+tls\_validate\_xmit\_skb\_sw(struct sock \*sk, struct net\_device \*dev,+ struct sk\_buff \*skb);  static inline bool tls\_is\_sk\_tx\_device\_offloaded(struct sock \*sk) {diff --git a/net/tls/tls\_device.c b/net/tls/tls\_device.cindex 171752cd691024..bd9f1567aa3929 100644--- a/[net/tls/tls\_device.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_device.c?id=05fc8b6cbd4f979a6f25759c4a17dd5f657f7ecd)+++ b/[net/tls/tls\_device.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_device.c?id=c55dcdd435aa6c6ad6ccac0a4c636d010ee367a4)@@ -50,6 +50,7 @@ static void tls\_device\_gc\_task(struct work\_struct \*work); static DECLARE\_WORK(tls\_device\_gc\_work, tls\_device\_gc\_task); static LIST\_HEAD(tls\_device\_gc\_list); static LIST\_HEAD(tls\_device\_list);+static LIST\_HEAD(tls\_device\_down\_list); static DEFINE\_SPINLOCK(tls\_device\_lock);  static void tls\_device\_free\_ctx(struct tls\_context \*ctx)@@ -759,6 +760,8 @@ void tls\_device\_rx\_resync\_new\_rec(struct sock \*sk, u32 rcd\_len, u32 seq)  if (tls\_ctx->rx\_conf != TLS\_HW) return;+ if (unlikely(test\_bit(TLS\_RX\_DEV\_DEGRADED, &tls\_ctx->flags)))+ return;  prot = &tls\_ctx->prot\_info; rx\_ctx = tls\_offload\_ctx\_rx(tls\_ctx);@@ -961,6 +964,17 @@ int tls\_device\_decrypted(struct sock \*sk, struct tls\_context \*tls\_ctx,  ctx->sw.decrypted |= is\_decrypted; + if (unlikely(test\_bit(TLS\_RX\_DEV\_DEGRADED, &tls\_ctx->flags))) {+ if (likely(is\_encrypted || is\_decrypted))+ return 0;++ /\* After tls\_device\_down disables the offload, the next SKB will+ \* likely have initial fragments decrypted, and final ones not+ \* decrypted. We need to reencrypt that single SKB.+ \*/+ return tls\_device\_reencrypt(sk, skb);+ }+ /\* Return immediately if the record is either entirely plaintext or \* entirely ciphertext. Otherwise handle reencrypt partially decrypted \* record.@@ -1290,6 +1304,26 @@ static int tls\_device\_down(struct net\_device \*netdev) spin\_unlock\_irqrestore(&tls\_device\_lock, flags);  list\_for\_each\_entry\_safe(ctx, tmp, &list, list) {+ /\* Stop offloaded TX and switch to the fallback.+ \* tls\_is\_sk\_tx\_device\_offloaded will return false.+ \*/+ WRITE\_ONCE(ctx->sk->sk\_validate\_xmit\_skb, tls\_validate\_xmit\_skb\_sw);++ /\* Stop the RX and TX resync.+ \* tls\_dev\_resync must not be called after tls\_dev\_del.+ \*/+ WRITE\_ONCE(ctx->netdev, NULL);++ /\* Start skipping the RX resync logic completely. \*/+ set\_bit(TLS\_RX\_DEV\_DEGRADED, &ctx->flags);++ /\* Sync with inflight packets. After this point:+ \* TX: no non-encrypted packets will be passed to the driver.+ \* RX: resync requests from the driver will be ignored.+ \*/+ synchronize\_net();++ /\* Release the offload context on the driver side. \*/ if (ctx->tx\_conf == TLS\_HW) netdev->tlsdev\_ops->tls\_dev\_del(netdev, ctx, TLS\_OFFLOAD\_CTX\_DIR\_TX);@@ -1297,13 +1331,21 @@ static int tls\_device\_down(struct net\_device \*netdev) !test\_bit(TLS\_RX\_DEV\_CLOSED, &ctx->flags)) netdev->tlsdev\_ops->tls\_dev\_del(netdev, ctx, TLS\_OFFLOAD\_CTX\_DIR\_RX);- WRITE\_ONCE(ctx->netdev, NULL);- synchronize\_net();+ dev\_put(netdev);- list\_del\_init(&ctx->list); - if (refcount\_dec\_and\_test(&ctx->refcount))- tls\_device\_free\_ctx(ctx);+ /\* Move the context to a separate list for two reasons:+ \* 1. When the context is deallocated, list\_del is called.+ \* 2. It's no longer an offloaded context, so we don't want to+ \* run offload-specific code on this context.+ \*/+ spin\_lock\_irqsave(&tls\_device\_lock, flags);+ list\_move\_tail(&ctx->list, &tls\_device\_down\_list);+ spin\_unlock\_irqrestore(&tls\_device\_lock, flags);++ /\* Device contexts for RX and TX will be freed in on sk\_destruct+ \* by tls\_device\_free\_ctx. rx\_conf and tx\_conf stay in TLS\_HW.+ \*/ }  up\_write(&device\_offload\_lock);diff --git a/net/tls/tls\_device\_fallback.c b/net/tls/tls\_device\_fallback.cindex cacf040872c74c..e40bedd112b685 100644--- a/[net/tls/tls\_device\_fallback.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_device_fallback.c?id=05fc8b6cbd4f979a6f25759c4a17dd5f657f7ecd)+++ b/[net/tls/tls\_device\_fallback.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_device_fallback.c?id=c55dcdd435aa6c6ad6ccac0a4c636d010ee367a4)@@ -431,6 +431,13 @@ struct sk\_buff \*tls\_validate\_xmit\_skb(struct sock \*sk, } EXPORT\_SYMBOL\_GPL(tls\_validate\_xmit\_skb); +struct sk\_buff \*tls\_validate\_xmit\_skb\_sw(struct sock \*sk,+ struct net\_device \*dev,+ struct sk\_buff \*skb)+{+ return tls\_sw\_fallback(sk, skb);+}+ struct sk\_buff \*tls\_encrypt\_skb(struct sk\_buff \*skb) { return tls\_sw\_fallback(skb->sk, skb);diff --git a/net/tls/tls\_main.c b/net/tls/tls\_main.cindex 47b7c5334c346f..fde56ff491637b 100644--- a/[net/tls/tls\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_main.c?id=05fc8b6cbd4f979a6f25759c4a17dd5f657f7ecd)+++ b/[net/tls/tls\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_main.c?id=c55dcdd435aa6c6ad6ccac0a4c636d010ee367a4)@@ -636,6 +636,7 @@ struct tls\_context \*tls\_ctx\_create(struct sock \*sk) mutex\_init(&ctx->tx\_lock); rcu\_assign\_pointer(icsk->icsk\_ulp\_data, ctx); ctx->sk\_proto = READ\_ONCE(sk->sk\_prot);+ ctx->sk = sk; return ctx; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 16:40:00 +0000


