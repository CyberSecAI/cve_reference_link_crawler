
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FNetatalk%2Fnetatalk%2Fblob%2F90d91a9ac9a7d6132ab7620d31c8c23400949206%2Fetc%2Fuams%2Fuams_dhx_pam.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FNetatalk%2Fnetatalk%2Fblob%2F90d91a9ac9a7d6132ab7620d31c8c23400949206%2Fetc%2Fuams%2Fuams_dhx_pam.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=Netatalk%2Fnetatalk)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[Netatalk](/Netatalk)
/
**[netatalk](/Netatalk/netatalk)**
Public

* [Notifications](/login?return_to=%2FNetatalk%2Fnetatalk) You must be signed in to change notification settings
* [Fork
  94](/login?return_to=%2FNetatalk%2Fnetatalk)
* [Star
   377](/login?return_to=%2FNetatalk%2Fnetatalk)

* [Code](/Netatalk/netatalk)
* [Issues
  29](/Netatalk/netatalk/issues)
* [Pull requests
  3](/Netatalk/netatalk/pulls)
* [Discussions](/Netatalk/netatalk/discussions)
* [Actions](/Netatalk/netatalk/actions)
* [Projects
  0](/Netatalk/netatalk/projects)
* [Wiki](/Netatalk/netatalk/wiki)
* [Security](/Netatalk/netatalk/security)
* [Insights](/Netatalk/netatalk/pulse)

Additional navigation options

* [Code](/Netatalk/netatalk)
* [Issues](/Netatalk/netatalk/issues)
* [Pull requests](/Netatalk/netatalk/pulls)
* [Discussions](/Netatalk/netatalk/discussions)
* [Actions](/Netatalk/netatalk/actions)
* [Projects](/Netatalk/netatalk/projects)
* [Wiki](/Netatalk/netatalk/wiki)
* [Security](/Netatalk/netatalk/security)
* [Insights](/Netatalk/netatalk/pulse)

## Files

 90d91a9
## Breadcrumbs

1. [netatalk](/Netatalk/netatalk/tree/90d91a9ac9a7d6132ab7620d31c8c23400949206)
2. /[etc](/Netatalk/netatalk/tree/90d91a9ac9a7d6132ab7620d31c8c23400949206/etc)
3. /[uams](/Netatalk/netatalk/tree/90d91a9ac9a7d6132ab7620d31c8c23400949206/etc/uams)
/
# uams\_dhx\_pam.c

 Blame  Blame
## Latest commit

## History

[History](/Netatalk/netatalk/commits/90d91a9ac9a7d6132ab7620d31c8c23400949206/etc/uams/uams_dhx_pam.c)768 lines (655 loc) · 20.6 KB 90d91a9
## Breadcrumbs

1. [netatalk](/Netatalk/netatalk/tree/90d91a9ac9a7d6132ab7620d31c8c23400949206)
2. /[etc](/Netatalk/netatalk/tree/90d91a9ac9a7d6132ab7620d31c8c23400949206/etc)
3. /[uams](/Netatalk/netatalk/tree/90d91a9ac9a7d6132ab7620d31c8c23400949206/etc/uams)
/
# uams\_dhx\_pam.c

Top
## File metadata and controls

* Code
* Blame

768 lines (655 loc) · 20.6 KB[Raw](https://github.com/Netatalk/netatalk/raw/90d91a9ac9a7d6132ab7620d31c8c23400949206/etc/uams/uams_dhx_pam.c)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768/\* \* \* Copyright (c) 1990,1993 Regents of The University of Michigan. \* Copyright (c) 1999 Adrian Sun (asun@u.washington.edu) \* All Rights Reserved. See COPYRIGHT. \*/
#ifdef HAVE\_CONFIG\_H#include "config.h"#endif /\* HAVE\_CONFIG\_H \*/
#if defined(USE\_PAM) && defined(UAM\_DHX)
#include <arpa/inet.h>#include <errno.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <unistd.h>
#ifdef HAVE\_PAM\_PAM\_APPL\_H#include <pam/pam\_appl.h>#endif
#ifdef HAVE\_SECURITY\_PAM\_APPL\_H#include <security/pam\_appl.h>#endif
#if defined(EMBEDDED\_SSL)#include <wolfssl/openssl/bn.h>#include <wolfssl/openssl/dh.h>#include <wolfssl/openssl/err.h>#include <wolfssl/openssl/ssl.h>#include <atalk/cast.h>#elif defined(OPENSSL\_DHX)#include <openssl/bn.h>#include <openssl/dh.h>#include <openssl/cast.h>#include <openssl/err.h>#include "openssl\_compat.h"#endif /\* EMBEDDED\_SSL \*/
#include <atalk/afp.h>#include <atalk/logger.h>#include <atalk/uam.h>
#define KEYSIZE 16#define PASSWDLEN 64#define CRYPTBUFLEN (KEYSIZE\*2)#define CRYPT2BUFLEN (KEYSIZE + PASSWDLEN)#define CHANGEPWBUFLEN (KEYSIZE + 2\*PASSWDLEN)
/\* hash a number to a 16-bit quantity \*/#define dhxhash(a) ((((unsigned long) (a) >> 8) ^ \ (unsigned long) (a)) & 0xffff)
/\* the secret key \*/static CAST\_KEY castkey;static struct passwd \*dhxpwd;static uint8\_t randbuf[KEYSIZE];
/\* diffie-hellman bits \*/static unsigned char msg2\_iv[] = "CJalbert";static unsigned char msg3\_iv[] = "LWallace";static const uint8\_t p[] = {0xBA, 0x28, 0x73, 0xDF, 0xB0, 0x60, 0x57, 0xD4, 0x3F, 0x20, 0x24, 0x74, 0x4C, 0xEE, 0xE7, 0x5B};static const uint8\_t g = 0x07;
/\* Static variables used to communicate between the conversation function \* and the server\_login function \*/static pam\_handle\_t \*pamh = NULL;static unsigned char \*PAM\_username;static unsigned char \*PAM\_password;
/\* PAM conversation function \* Here we assume (for now, at least) that echo on means login name, and \* echo off means password. \*/static int PAM\_conv (int num\_msg,#if !defined(\_\_svr4\_\_) const struct pam\_message \*\*msg,#else struct pam\_message \*\*msg,#endif struct pam\_response \*\*resp, void \*appdata\_ptr \_U\_) { int count = 0; struct pam\_response \*reply;
#define COPY\_STRING(s) (s) ? strdup(s) : NULL
 errno = 0;
 if (num\_msg < 1) { /\* Log Entry \*/ LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM DHX Conversation Err -- %s", strerror(errno)); /\* Log Entry \*/ return PAM\_CONV\_ERR; }
 reply = (struct pam\_response \*) calloc(num\_msg, sizeof(struct pam\_response));
 if (!reply) { /\* Log Entry \*/ LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM DHX Conversation Err -- %s", strerror(errno)); /\* Log Entry \*/ return PAM\_CONV\_ERR; }
 for (count = 0; count < num\_msg; count++) { char \*string = NULL;
 switch (msg[count]->msg\_style) { case PAM\_PROMPT\_ECHO\_ON: if (!(string = COPY\_STRING((const char \*)PAM\_username))) { /\* Log Entry \*/ LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM: username failure -- %s", strerror(errno)); /\* Log Entry \*/ goto pam\_fail\_conv; } break; case PAM\_PROMPT\_ECHO\_OFF: if (!(string = COPY\_STRING((const char \*)PAM\_password))) { /\* Log Entry \*/ LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM: passwd failure: --: %s", strerror(errno)); /\* Log Entry \*/ goto pam\_fail\_conv; } break; case PAM\_TEXT\_INFO:#ifdef PAM\_BINARY\_PROMPT case PAM\_BINARY\_PROMPT:#endif /\* PAM\_BINARY\_PROMPT \*/ /\* ignore it... \*/ break; case PAM\_ERROR\_MSG: default: /\* Log Entry \*/ LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM: Binary\_Prompt -- %s", strerror(errno)); /\* Log Entry \*/ goto pam\_fail\_conv; }
 if (string) { reply[count].resp\_retcode = 0; reply[count].resp = string; string = NULL; } }
 \*resp = reply; /\* Log Entry \*/ LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM: PAM Success"); /\* Log Entry \*/ return PAM\_SUCCESS;
pam\_fail\_conv: for (count = 0; count < num\_msg; count++) { if (!reply[count].resp) continue; switch (msg[count]->msg\_style) { case PAM\_PROMPT\_ECHO\_OFF: case PAM\_PROMPT\_ECHO\_ON: free(reply[count].resp); break; } } free(reply); /\* Log Entry \*/ LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM DHX Conversation Err -- %s", strerror(errno)); /\* Log Entry \*/ return PAM\_CONV\_ERR;}
static struct pam\_conv PAM\_conversation = { &PAM\_conv, NULL};
static int dhx\_setup(void \*obj, const unsigned char \*ibuf, size\_t ibuflen \_U\_, unsigned char \*rbuf, size\_t \*rbuflen){ uint16\_t sessid; size\_t i; BIGNUM \*bn, \*gbn, \*pbn; const BIGNUM \*pub\_key; DH \*dh;
 /\* get the client's public key \*/ if (!(bn = BN\_bin2bn(ibuf, KEYSIZE, NULL))) { /\* Log Entry \*/ LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM No Public Key -- %s", strerror(errno)); /\* Log Entry \*/ return AFPERR\_PARAM; }
 /\* get our primes \*/ if (!(gbn = BN\_bin2bn(&g, sizeof(g), NULL))) { BN\_clear\_free(bn); /\* Log Entry \*/ LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM No Primes: GBN -- %s", strerror(errno)); /\* Log Entry \*/ return AFPERR\_PARAM; }
 if (!(pbn = BN\_bin2bn(p, sizeof(p), NULL))) { BN\_free(gbn); BN\_clear\_free(bn); /\* Log Entry \*/ LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM No Primes: PBN -- %s", strerror(errno)); /\* Log Entry \*/ return AFPERR\_PARAM; }
 /\* okay, we're ready \*/ if (!(dh = DH\_new())) { BN\_free(pbn); BN\_free(gbn); BN\_clear\_free(bn); /\* Log Entry \*/ LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM DH was equal to DH\_New... Go figure... -- %s", strerror(errno)); /\* Log Entry \*/ return AFPERR\_PARAM; }
 if (!DH\_set0\_pqg(dh, pbn, NULL, gbn)) { BN\_free(pbn); BN\_free(gbn); /\* Log Entry \*/ LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM DH\_set0\_pqg() mysteriously failed -- %s", strerror(errno)); /\* Log Entry \*/ goto pam\_fail; }
 /\* generate key and make sure that we have enough space \*/ if (DH\_generate\_key(dh) == 0) { unsigned long dherror; char errbuf[256];
 ERR\_load\_crypto\_strings(); dherror = ERR\_get\_error(); ERR\_error\_string\_n(dherror, errbuf, 256);
 LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM: Err Generating Key (OpenSSL error code: %u, %s)", dherror, errbuf);
 ERR\_free\_strings(); goto pam\_fail; } DH\_get0\_key(dh, &pub\_key, NULL); if (BN\_num\_bytes(pub\_key) > KEYSIZE) { LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM: Err Generating Key -- Not enough Space? -- %s", strerror(errno)); goto pam\_fail; }
 /\* figure out the key. store the key in rbuf for now. \*/ i = (unsigned long) DH\_compute\_key(rbuf, bn, dh);
 /\* set the key \*/ CAST\_set\_key(&castkey, (int) i, rbuf);
 /\* session id. it's just a hashed version of the object pointer. \*/ sessid = dhxhash(obj); memcpy(rbuf, &sessid, sizeof(sessid)); rbuf += sizeof(sessid); \*rbuflen += sizeof(sessid);
 /\* public key \*/ BN\_bn2bin(pub\_key, rbuf); rbuf += KEYSIZE; \*rbuflen += KEYSIZE;
 /\* buffer to be encrypted \*/ i = sizeof(randbuf); if (uam\_afpserver\_option(obj, UAM\_OPTION\_RANDNUM, (void \*) randbuf, &i) < 0) { \*rbuflen = 0; /\* Log Entry \*/ LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM: Buffer Encryption Err. -- %s", strerror(errno)); /\* Log Entry \*/ goto pam\_fail; } memcpy(rbuf, &randbuf, sizeof(randbuf));
 /\* get the signature. it's always 16 bytes. \*/#if 0 if (uam\_afpserver\_option(obj, UAM\_OPTION\_SIGNATURE, (void \*) &buf, NULL) < 0) { \*rbuflen = 0; /\* Log Entry \*/ LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM: Signature Retieval Failure -- %s", strerror(errno)); /\* Log Entry \*/ goto pam\_fail; } memcpy(rbuf + KEYSIZE, buf, KEYSIZE);#else /\* 0 \*/ memset(rbuf + KEYSIZE, 0, KEYSIZE);#endif /\* 0 \*/
 /\* encrypt using cast \*/ CAST\_cbc\_encrypt(rbuf, rbuf, CRYPTBUFLEN, &castkey, msg2\_iv, CAST\_ENCRYPT); \*rbuflen += CRYPTBUFLEN; BN\_free(bn); DH\_free(dh); return AFPERR\_AUTHCONT;
pam\_fail: BN\_free(bn); DH\_free(dh); /\* Log Entry \*/ LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM: Fail - Cast Encryption -- %s", strerror(errno)); /\* Log Entry \*/ return AFPERR\_PARAM;}
/\* -------------------------------- \*/static int login(void \*obj, unsigned char \*username, int ulen, struct passwd \*\*uam\_pwd \_U\_, const unsigned char \*ibuf, size\_t ibuflen, unsigned char \*rbuf, size\_t \*rbuflen){ if (( dhxpwd = uam\_getname(obj, (char \*)username, ulen)) == NULL ) { LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c: unknown username [%s]", username); return AFPERR\_NOTAUTH; }
 PAM\_username = username; LOG(log\_info, logtype\_uams, "dhx login: %s", username); return dhx\_setup(obj, ibuf, ibuflen, rbuf, rbuflen);}
/\* -------------------------------- \*//\* dhx login: things are done in a slightly bizarre order to avoid \* having to clean things up if there's an error. \*/static int pam\_login(void \*obj, struct passwd \*\*uam\_pwd, unsigned char \*ibuf, size\_t ibuflen, unsigned char \*rbuf, size\_t \*rbuflen){ unsigned char \*username; size\_t len, ulen;
 \*rbuflen = 0;
 /\* grab some of the options \*/ if (uam\_afpserver\_option(obj, UAM\_OPTION\_USERNAME, (void \*) &username, &ulen) < 0) { LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM: uam\_afpserver\_option didn't meet uam\_option\_username -- %s", strerror(errno)); return AFPERR\_PARAM; }
 len = \*ibuf++; if ( len > ulen ) { LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM: Signature Retieval Failure -- %s", strerror(errno)); return AFPERR\_PARAM; }
 memcpy(username, ibuf, len ); ibuf += len; username[ len ] = '\0';
 if ((unsigned long) ibuf & 1) /\* pad to even boundary \*/ ++ibuf;
 return (login(obj, username, ulen, uam\_pwd, ibuf, ibuflen, rbuf, rbuflen));}
/\* ----------------------------- \*/static int pam\_login\_ext(void \*obj, char \*uname, struct passwd \*\*uam\_pwd, const unsigned char \*ibuf, size\_t ibuflen, unsigned char \*rbuf, size\_t \*rbuflen){ unsigned char \*username; int len; size\_t ulen; uint16\_t temp16;
 \*rbuflen = 0;
 /\* grab some of the options \*/ if (uam\_afpserver\_option(obj, UAM\_OPTION\_USERNAME, (void \*) &username, &ulen) < 0) { LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM: uam\_afpserver\_option didn't meet uam\_option\_username -- %s", strerror(errno)); return AFPERR\_PARAM; }
 if (\*uname != 3) return AFPERR\_PARAM; uname++; memcpy(&temp16, uname, sizeof(temp16)); len = ntohs(temp16);
 if ( !len || len > ulen ) { LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM: Signature Retrieval Failure -- %s", strerror(errno)); return AFPERR\_PARAM; } memcpy(username, uname +2, len ); username[ len ] = '\0';
 return (login(obj, username, ulen, uam\_pwd, ibuf, ibuflen, rbuf, rbuflen));}
/\* -------------------------------- \*/
static int pam\_logincont(void \*obj, struct passwd \*\*uam\_pwd, const unsigned char \*ibuf, size\_t ibuflen \_U\_, unsigned char \*rbuf, size\_t \*rbuflen){ const char \*hostname; BIGNUM \*bn1, \*bn2, \*bn3; uint16\_t sessid; int err, PAM\_error;
 \*rbuflen = 0;
 /\* check for session id \*/ memcpy(&sessid, ibuf, sizeof(sessid)); if (sessid != dhxhash(obj)) { /\* Log Entry \*/ LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM Session ID - DHXHash Mismatch -- %s", strerror(errno)); /\* Log Entry \*/ return AFPERR\_PARAM; } ibuf += sizeof(sessid);
 if (uam\_afpserver\_option(obj, UAM\_OPTION\_CLIENTNAME, (void \*) &hostname, NULL) < 0) { LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM: unable to retrieve client hostname"); hostname = NULL; }
 CAST\_cbc\_encrypt(ibuf, rbuf, CRYPT2BUFLEN, &castkey, msg3\_iv, CAST\_DECRYPT); memset(&castkey, 0, sizeof(castkey));
 /\* check to make sure that the random number is the same. we \* get sent back an incremented random number. \*/ if (!(bn1 = BN\_bin2bn(rbuf, KEYSIZE, NULL))) return AFPERR\_PARAM;
 if (!(bn2 = BN\_bin2bn(randbuf, sizeof(randbuf), NULL))) { BN\_free(bn1); return AFPERR\_PARAM; }
 /\* zero out the random number \*/ memset(rbuf, 0, sizeof(randbuf)); memset(randbuf, 0, sizeof(randbuf)); rbuf += KEYSIZE;
 if (!(bn3 = BN\_new())) { BN\_free(bn2); BN\_free(bn1); return AFPERR\_PARAM; }
 BN\_sub(bn3, bn1, bn2); BN\_free(bn2); BN\_free(bn1);
 /\* okay. is it one more? \*/ if (!BN\_is\_one(bn3)) { BN\_free(bn3); return AFPERR\_PARAM; } BN\_free(bn3);
 /\* Set these things up for the conv function \*/ rbuf[PASSWDLEN] = '\0'; PAM\_password = rbuf;
 err = AFPERR\_NOTAUTH; PAM\_error = pam\_start("netatalk", (const char \*)PAM\_username, &PAM\_conversation, &pamh); if (PAM\_error != PAM\_SUCCESS) { /\* Log Entry \*/ LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM: PAM\_Error: %s", pam\_strerror(pamh,PAM\_error)); /\* Log Entry \*/ goto logincont\_err; }
 /\* solaris craps out if PAM\_TTY and PAM\_RHOST aren't set. \*/ pam\_set\_item(pamh, PAM\_TTY, "afpd"); pam\_set\_item(pamh, PAM\_RHOST, hostname); PAM\_error = pam\_authenticate(pamh,0); if (PAM\_error != PAM\_SUCCESS) { if (PAM\_error == PAM\_MAXTRIES) err = AFPERR\_PWDEXPR; /\* Log Entry \*/ LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM: PAM\_Error: %s", pam\_strerror(pamh, PAM\_error)); /\* Log Entry \*/ goto logincont\_err; }
 PAM\_error = pam\_acct\_mgmt(pamh, 0); if (PAM\_error != PAM\_SUCCESS ) { /\* Log Entry \*/ LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM: PAM\_Error: %s", pam\_strerror(pamh, PAM\_error)); /\* Log Entry \*/ if (PAM\_error == PAM\_NEW\_AUTHTOK\_REQD) /\* password expired \*/ err = AFPERR\_PWDEXPR;#ifdef PAM\_AUTHTOKEN\_REQD else if (PAM\_error == PAM\_AUTHTOKEN\_REQD) err = AFPERR\_PWDCHNG;#endif else goto logincont\_err; }
#ifndef PAM\_CRED\_ESTABLISH#define PAM\_CRED\_ESTABLISH PAM\_ESTABLISH\_CRED#endif PAM\_error = pam\_setcred(pamh, PAM\_CRED\_ESTABLISH); if (PAM\_error != PAM\_SUCCESS) { /\* Log Entry \*/ LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM: PAM\_Error: %s", pam\_strerror(pamh, PAM\_error)); /\* Log Entry \*/ goto logincont\_err; }
 PAM\_error = pam\_open\_session(pamh, 0); if (PAM\_error != PAM\_SUCCESS) { /\* Log Entry \*/ LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM: PAM\_Error: %s", pam\_strerror(pamh, PAM\_error)); /\* Log Entry \*/ goto logincont\_err; }
 memset(rbuf, 0, PASSWDLEN); /\* zero out the password \*/ \*uam\_pwd = dhxpwd; /\* Log Entry \*/ LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM: PAM Auth OK!"); /\* Log Entry \*/ if ( err == AFPERR\_PWDEXPR) return err; return AFP\_OK;
logincont\_err: pam\_end(pamh, PAM\_error); pamh = NULL; memset(rbuf, 0, CRYPT2BUFLEN); return err;}
/\* logout \*/static void pam\_logout(void) { pam\_close\_session(pamh, 0); pam\_end(pamh, 0); pamh = NULL;}
/\* change pw for dhx needs a couple passes to get everything all \* right. basically, it's like the login/logincont sequence \*/static int pam\_changepw(void \*obj, unsigned char \*username, const struct passwd \*pwd \_U\_, unsigned char \*ibuf, size\_t ibuflen, unsigned char \*rbuf, size\_t \*rbuflen){ BIGNUM \*bn1, \*bn2, \*bn3;
 char \*hostname; pam\_handle\_t \*lpamh; uid\_t uid; uint16\_t sessid; int PAM\_error;
 if (ibuflen < sizeof(sessid)) { return AFPERR\_PARAM; }
 /\* grab the id \*/ memcpy(&sessid, ibuf, sizeof(sessid)); ibuf += sizeof(sessid);
 if (!sessid) { /\* no sessid -> initialization phase \*/ PAM\_username = username; ibuflen -= sizeof(sessid); return dhx\_setup(obj, ibuf, ibuflen, rbuf, rbuflen); }
 /\* otherwise, it's like logincont but different. \*/
 /\* check out the session id \*/ if (sessid != dhxhash(obj)) { /\* Log Entry \*/ LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM: Session ID not Equal to DHX Hash -- %s", strerror(errno)); /\* Log Entry \*/ return AFPERR\_PARAM; }
 /\* we need this for pam \*/ if (uam\_afpserver\_option(obj, UAM\_OPTION\_HOSTNAME, (void \*) &hostname, NULL) < 0) { /\* Log Entry \*/ LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM: Hostname Null?? -- %s", strerror(errno)); /\* Log Entry \*/ return AFPERR\_MISC; }
 /\* grab the client's nonce, old password, and new password. \*/ CAST\_cbc\_encrypt(ibuf, ibuf, CHANGEPWBUFLEN, &castkey, msg3\_iv, CAST\_DECRYPT); memset(&castkey, 0, sizeof(castkey));
 /\* check to make sure that the random number is the same. we \* get sent back an incremented random number. \*/ if (!(bn1 = BN\_bin2bn(ibuf, KEYSIZE, NULL))) { /\* Log Entry \*/ LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM: Random Number Not the same or not incremented-- %s", strerror(errno)); /\* Log Entry \*/ return AFPERR\_PARAM; }
 if (!(bn2 = BN\_bin2bn(randbuf, sizeof(randbuf), NULL))) { BN\_free(bn1); /\* Log Entry \*/ LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM: Random Number Not the same or not incremented -- %s", strerror(errno)); /\* Log Entry \*/ return AFPERR\_PARAM; }
 /\* zero out the random number \*/ memset(rbuf, 0, sizeof(randbuf)); memset(randbuf, 0, sizeof(randbuf));
 if (!(bn3 = BN\_new())) { BN\_free(bn2); BN\_free(bn1); /\* Log Entry \*/ LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM: Random Number did not Zero -- %s", strerror(errno)); /\* Log Entry \*/ return AFPERR\_PARAM; }
 BN\_sub(bn3, bn1, bn2); BN\_free(bn2); BN\_free(bn1);
 /\* okay. is it one more? \*/#if 0 if (!BN\_is\_one(bn3)) { BN\_free(bn3); /\* Log Entry \*/ LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM: After Random Number not Zero, is it one more? -- %s", strerror(errno)); /\* Log Entry \*/ return AFPERR\_PARAM; }#endif BN\_free(bn3);
 /\* Set these things up for the conv function. the old password \* is at the end. \*/ ibuf += KEYSIZE; ibuf[PASSWDLEN + PASSWDLEN] = '\0'; PAM\_password = ibuf + PASSWDLEN;
 PAM\_error = pam\_start("netatalk", (char \*)username, &PAM\_conversation, &lpamh); if (PAM\_error != PAM\_SUCCESS) { /\* Log Entry \*/ LOG(log\_info, logtype\_uams, "uams\_dhx\_pam.c :PAM: Needless to say, PAM\_error is != to PAM\_SUCCESS -- %s", strerror(errno)); /\* Log Entry \*/ return AFPERR\_PARAM; } pam\_set\_item(lpamh, PAM\_TTY, "afpd"); pam\_set\_item(lpamh, PAM\_RHOST, hostname);
 /\* we might need to do this as root \*/ uid = geteuid(); seteuid(0); PAM\_error = pam\_authenticate(lpamh, 0); if (PAM\_error != PAM\_SUCCESS) { seteuid(uid); pam\_end(lpamh, PAM\_error); return AFPERR\_NOTAUTH; }
 /\* clear out old passwd \*/ memset(ibuf + PASSWDLEN, 0, PASSWDLEN);
 /\* new password \*/ PAM\_password = ibuf; ibuf[PASSWDLEN] = '\0';
 /\* this really does need to be done as root \*/ PAM\_error = pam\_chauthtok(lpamh, 0); seteuid(uid); /\* un-root ourselves. \*/ memset(ibuf, 0, PASSWDLEN); if (PAM\_error != PAM\_SUCCESS) { pam\_end(lpamh, PAM\_error); return AFPERR\_ACCESS; }
 pam\_end(lpamh, 0); return AFP\_OK;}
static int uam\_setup(void \*obj, const char \*path){ if (uam\_register(UAM\_SERVER\_LOGIN\_EXT, path, "DHCAST128", pam\_login, pam\_logincont, pam\_logout, pam\_login\_ext) < 0) return -1;
 if (uam\_register(UAM\_SERVER\_CHANGEPW, path, "DHCAST128", pam\_changepw) < 0) { uam\_unregister(UAM\_SERVER\_LOGIN, "DHCAST128"); return -1; }
 /\*uam\_register(UAM\_SERVER\_PRINTAUTH, path, "DHCAST128", pam\_printer);\*/
 return 0;}
static void uam\_cleanup(void){ uam\_unregister(UAM\_SERVER\_LOGIN, "DHCAST128"); uam\_unregister(UAM\_SERVER\_CHANGEPW, "DHCAST128"); /\*uam\_unregister(UAM\_SERVER\_PRINTAUTH, "DHCAST128"); \*/}
UAM\_MODULE\_EXPORT struct uam\_export uams\_dhx = { UAM\_MODULE\_SERVER, UAM\_MODULE\_VERSION, uam\_setup, uam\_cleanup};
UAM\_MODULE\_EXPORT struct uam\_export uams\_dhx\_pam = { UAM\_MODULE\_SERVER, UAM\_MODULE\_VERSION, uam\_setup, uam\_cleanup};
#endif /\* USE\_PAM && UAM\_DHX \*/

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

