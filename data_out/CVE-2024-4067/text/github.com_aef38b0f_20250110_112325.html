
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fmicromatch%2Fmicromatch%2Fblob%2F2c56a8604b68c1099e7bc0f807ce0865a339747a%2Findex.js)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fmicromatch%2Fmicromatch%2Fblob%2F2c56a8604b68c1099e7bc0f807ce0865a339747a%2Findex.js)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=micromatch%2Fmicromatch)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[micromatch](/micromatch)
/
**[micromatch](/micromatch/micromatch)**
Public

* [Notifications](/login?return_to=%2Fmicromatch%2Fmicromatch) You must be signed in to change notification settings
* [Fork
  168](/login?return_to=%2Fmicromatch%2Fmicromatch)
* [Star
   2.8k](/login?return_to=%2Fmicromatch%2Fmicromatch)

* [Code](/micromatch/micromatch)
* [Issues
  28](/micromatch/micromatch/issues)
* [Pull requests
  6](/micromatch/micromatch/pulls)
* [Actions](/micromatch/micromatch/actions)
* [Security](/micromatch/micromatch/security)
* [Insights](/micromatch/micromatch/pulse)

Additional navigation options

* [Code](/micromatch/micromatch)
* [Issues](/micromatch/micromatch/issues)
* [Pull requests](/micromatch/micromatch/pulls)
* [Actions](/micromatch/micromatch/actions)
* [Security](/micromatch/micromatch/security)
* [Insights](/micromatch/micromatch/pulse)

## Files

 2c56a86
## Breadcrumbs

1. [micromatch](/micromatch/micromatch/tree/2c56a8604b68c1099e7bc0f807ce0865a339747a)
/
# index.js

 Blame  Blame
## Latest commit

## History

[History](/micromatch/micromatch/commits/2c56a8604b68c1099e7bc0f807ce0865a339747a/index.js)467 lines (409 loc) · 13.4 KB 2c56a86
## Breadcrumbs

1. [micromatch](/micromatch/micromatch/tree/2c56a8604b68c1099e7bc0f807ce0865a339747a)
/
# index.js

Top
## File metadata and controls

* Code
* Blame

467 lines (409 loc) · 13.4 KB[Raw](https://github.com/micromatch/micromatch/raw/2c56a8604b68c1099e7bc0f807ce0865a339747a/index.js)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467'use strict';
const util = require('util');const braces = require('braces');const picomatch = require('picomatch');const utils = require('picomatch/lib/utils');const isEmptyString = val => val === '' || val === './';
/\*\* \* Returns an array of strings that match one or more glob patterns. \* \* ```js \* const mm = require('micromatch'); \* // mm(list, patterns[, options]); \* \* console.log(mm(['a.js', 'a.txt'], ['\*.js'])); \* //=> [ 'a.js' ] \* ``` \* @param {String|Array<string>} `list` List of strings to match. \* @param {String|Array<string>} `patterns` One or more glob patterns to use for matching. \* @param {Object} `options` See available [options](#options) \* @return {Array} Returns an array of matches \* @summary false \* @api public \*/
const micromatch = (list, patterns, options) => { patterns = [].concat(patterns); list = [].concat(list);
 let omit = new Set(); let keep = new Set(); let items = new Set(); let negatives = 0;
 let onResult = state => { items.add(state.output); if (options && options.onResult) { options.onResult(state); } };
 for (let i = 0; i < patterns.length; i++) { let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true); let negated = isMatch.state.negated || isMatch.state.negatedExtglob; if (negated) negatives++;
 for (let item of list) { let matched = isMatch(item, true);
 let match = negated ? !matched.isMatch : matched.isMatch; if (!match) continue;
 if (negated) { omit.add(matched.output); } else { omit.delete(matched.output); keep.add(matched.output); } } }
 let result = negatives === patterns.length ? [...items] : [...keep]; let matches = result.filter(item => !omit.has(item));
 if (options && matches.length === 0) { if (options.failglob === true) { throw new Error(`No matches found for "${patterns.join(', ')}"`); }
 if (options.nonull === true || options.nullglob === true) { return options.unescape ? patterns.map(p => p.replace(/\\/g, '')) : patterns; } }
 return matches;};
/\*\* \* Backwards compatibility \*/
micromatch.match = micromatch;
/\*\* \* Returns a matcher function from the given glob `pattern` and `options`. \* The returned function takes a string to match as its only argument and returns \* true if the string is a match. \* \* ```js \* const mm = require('micromatch'); \* // mm.matcher(pattern[, options]); \* \* const isMatch = mm.matcher('\*.!(\*a)'); \* console.log(isMatch('a.a')); //=> false \* console.log(isMatch('a.b')); //=> true \* ``` \* @param {String} `pattern` Glob pattern \* @param {Object} `options` \* @return {Function} Returns a matcher function. \* @api public \*/
micromatch.matcher = (pattern, options) => picomatch(pattern, options);
/\*\* \* Returns true if \*\*any\*\* of the given glob `patterns` match the specified `string`. \* \* ```js \* const mm = require('micromatch'); \* // mm.isMatch(string, patterns[, options]); \* \* console.log(mm.isMatch('a.a', ['b.\*', '\*.a'])); //=> true \* console.log(mm.isMatch('a.a', 'b.\*')); //=> false \* ``` \* @param {String} `str` The string to test. \* @param {String|Array} `patterns` One or more glob patterns to use for matching. \* @param {Object} `[options]` See available [options](#options). \* @return {Boolean} Returns true if any patterns match `str` \* @api public \*/
micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
/\*\* \* Backwards compatibility \*/
micromatch.any = micromatch.isMatch;
/\*\* \* Returns a list of strings that \_\*\*do not match any\*\*\_ of the given `patterns`. \* \* ```js \* const mm = require('micromatch'); \* // mm.not(list, patterns[, options]); \* \* console.log(mm.not(['a.a', 'b.b', 'c.c'], '\*.a')); \* //=> ['b.b', 'c.c'] \* ``` \* @param {Array} `list` Array of strings to match. \* @param {String|Array} `patterns` One or more glob pattern to use for matching. \* @param {Object} `options` See available [options](#options) for changing how matches are performed \* @return {Array} Returns an array of strings that \*\*do not match\*\* the given patterns. \* @api public \*/
micromatch.not = (list, patterns, options = {}) => { patterns = [].concat(patterns).map(String); let result = new Set(); let items = [];
 let onResult = state => { if (options.onResult) options.onResult(state); items.push(state.output); };
 let matches = new Set(micromatch(list, patterns, { ...options, onResult }));
 for (let item of items) { if (!matches.has(item)) { result.add(item); } } return [...result];};
/\*\* \* Returns true if the given `string` contains the given pattern. Similar \* to [.isMatch](#isMatch) but the pattern can match any part of the string. \* \* ```js \* var mm = require('micromatch'); \* // mm.contains(string, pattern[, options]); \* \* console.log(mm.contains('aa/bb/cc', '\*b')); \* //=> true \* console.log(mm.contains('aa/bb/cc', '\*d')); \* //=> false \* ``` \* @param {String} `str` The string to match. \* @param {String|Array} `patterns` Glob pattern to use for matching. \* @param {Object} `options` See available [options](#options) for changing how matches are performed \* @return {Boolean} Returns true if any of the patterns matches any part of `str`. \* @api public \*/
micromatch.contains = (str, pattern, options) => { if (typeof str !== 'string') { throw new TypeError(`Expected a string: "${util.inspect(str)}"`); }
 if (Array.isArray(pattern)) { return pattern.some(p => micromatch.contains(str, p, options)); }
 if (typeof pattern === 'string') { if (isEmptyString(str) || isEmptyString(pattern)) { return false; }
 if (str.includes(pattern) || (str.startsWith('./') && str.slice(2).includes(pattern))) { return true; } }
 return micromatch.isMatch(str, pattern, { ...options, contains: true });};
/\*\* \* Filter the keys of the given object with the given `glob` pattern \* and `options`. Does not attempt to match nested keys. If you need this feature, \* use [glob-object][] instead. \* \* ```js \* const mm = require('micromatch'); \* // mm.matchKeys(object, patterns[, options]); \* \* const obj = { aa: 'a', ab: 'b', ac: 'c' }; \* console.log(mm.matchKeys(obj, '\*b')); \* //=> { ab: 'b' } \* ``` \* @param {Object} `object` The object with keys to filter. \* @param {String|Array} `patterns` One or more glob patterns to use for matching. \* @param {Object} `options` See available [options](#options) for changing how matches are performed \* @return {Object} Returns an object with only keys that match the given patterns. \* @api public \*/
micromatch.matchKeys = (obj, patterns, options) => { if (!utils.isObject(obj)) { throw new TypeError('Expected the first argument to be an object'); } let keys = micromatch(Object.keys(obj), patterns, options); let res = {}; for (let key of keys) res[key] = obj[key]; return res;};
/\*\* \* Returns true if some of the strings in the given `list` match any of the given glob `patterns`. \* \* ```js \* const mm = require('micromatch'); \* // mm.some(list, patterns[, options]); \* \* console.log(mm.some(['foo.js', 'bar.js'], ['\*.js', '!foo.js'])); \* // true \* console.log(mm.some(['foo.js'], ['\*.js', '!foo.js'])); \* // false \* ``` \* @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found. \* @param {String|Array} `patterns` One or more glob patterns to use for matching. \* @param {Object} `options` See available [options](#options) for changing how matches are performed \* @return {Boolean} Returns true if any `patterns` matches any of the strings in `list` \* @api public \*/
micromatch.some = (list, patterns, options) => { let items = [].concat(list);
 for (let pattern of [].concat(patterns)) { let isMatch = picomatch(String(pattern), options); if (items.some(item => isMatch(item))) { return true; } } return false;};
/\*\* \* Returns true if every string in the given `list` matches \* any of the given glob `patterns`. \* \* ```js \* const mm = require('micromatch'); \* // mm.every(list, patterns[, options]); \* \* console.log(mm.every('foo.js', ['foo.js'])); \* // true \* console.log(mm.every(['foo.js', 'bar.js'], ['\*.js'])); \* // true \* console.log(mm.every(['foo.js', 'bar.js'], ['\*.js', '!foo.js'])); \* // false \* console.log(mm.every(['foo.js'], ['\*.js', '!foo.js'])); \* // false \* ``` \* @param {String|Array} `list` The string or array of strings to test. \* @param {String|Array} `patterns` One or more glob patterns to use for matching. \* @param {Object} `options` See available [options](#options) for changing how matches are performed \* @return {Boolean} Returns true if all `patterns` matches all of the strings in `list` \* @api public \*/
micromatch.every = (list, patterns, options) => { let items = [].concat(list);
 for (let pattern of [].concat(patterns)) { let isMatch = picomatch(String(pattern), options); if (!items.every(item => isMatch(item))) { return false; } } return true;};
/\*\* \* Returns true if \*\*all\*\* of the given `patterns` match \* the specified string. \* \* ```js \* const mm = require('micromatch'); \* // mm.all(string, patterns[, options]); \* \* console.log(mm.all('foo.js', ['foo.js'])); \* // true \* \* console.log(mm.all('foo.js', ['\*.js', '!foo.js'])); \* // false \* \* console.log(mm.all('foo.js', ['\*.js', 'foo.js'])); \* // true \* \* console.log(mm.all('foo.js', ['\*.js', 'f\*', '\*o\*', '\*o.js'])); \* // true \* ``` \* @param {String|Array} `str` The string to test. \* @param {String|Array} `patterns` One or more glob patterns to use for matching. \* @param {Object} `options` See available [options](#options) for changing how matches are performed \* @return {Boolean} Returns true if any patterns match `str` \* @api public \*/
micromatch.all = (str, patterns, options) => { if (typeof str !== 'string') { throw new TypeError(`Expected a string: "${util.inspect(str)}"`); }
 return [].concat(patterns).every(p => picomatch(p, options)(str));};
/\*\* \* Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match. \* \* ```js \* const mm = require('micromatch'); \* // mm.capture(pattern, string[, options]); \* \* console.log(mm.capture('test/\*.js', 'test/foo.js')); \* //=> ['foo'] \* console.log(mm.capture('test/\*.js', 'foo/bar.css')); \* //=> null \* ``` \* @param {String} `glob` Glob pattern to use for matching. \* @param {String} `input` String to match \* @param {Object} `options` See available [options](#options) for changing how matches are performed \* @return {Array|null} Returns an array of captures if the input matches the glob pattern, otherwise `null`. \* @api public \*/
micromatch.capture = (glob, input, options) => { let posix = utils.isWindows(options); let regex = picomatch.makeRe(String(glob), { ...options, capture: true }); let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);
 if (match) { return match.slice(1).map(v => v === void 0 ? '' : v); }};
/\*\* \* Create a regular expression from the given glob `pattern`. \* \* ```js \* const mm = require('micromatch'); \* // mm.makeRe(pattern[, options]); \* \* console.log(mm.makeRe('\*.js')); \* //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]\*?\.js)$/ \* ``` \* @param {String} `pattern` A glob pattern to convert to regex. \* @param {Object} `options` \* @return {RegExp} Returns a regex created from the given pattern. \* @api public \*/
micromatch.makeRe = (...args) => picomatch.makeRe(...args);
/\*\* \* Scan a glob pattern to separate the pattern into segments. Used \* by the [split](#split) method. \* \* ```js \* const mm = require('micromatch'); \* const state = mm.scan(pattern[, options]); \* ``` \* @param {String} `pattern` \* @param {Object} `options` \* @return {Object} Returns an object with \* @api public \*/
micromatch.scan = (...args) => picomatch.scan(...args);
/\*\* \* Parse a glob pattern to create the source string for a regular \* expression. \* \* ```js \* const mm = require('micromatch'); \* const state = mm.parse(pattern[, options]); \* ``` \* @param {String} `glob` \* @param {Object} `options` \* @return {Object} Returns an object with useful properties and output to be used as regex source string. \* @api public \*/
micromatch.parse = (patterns, options) => { let res = []; for (let pattern of [].concat(patterns || [])) { for (let str of braces(String(pattern), options)) { res.push(picomatch.parse(str, options)); } } return res;};
/\*\* \* Process the given brace `pattern`. \* \* ```js \* const { braces } = require('micromatch'); \* console.log(braces('foo/{a,b,c}/bar')); \* //=> [ 'foo/(a|b|c)/bar' ] \* \* console.log(braces('foo/{a,b,c}/bar', { expand: true })); \* //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ] \* ``` \* @param {String} `pattern` String with brace pattern to process. \* @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options. \* @return {Array} \* @api public \*/
micromatch.braces = (pattern, options) => { if (typeof pattern !== 'string') throw new TypeError('Expected a string'); if ((options && options.nobrace === true) || !/\{.\*\}/.test(pattern)) { return [pattern]; } return braces(pattern, options);};
/\*\* \* Expand braces \*/
micromatch.braceExpand = (pattern, options) => { if (typeof pattern !== 'string') throw new TypeError('Expected a string'); return micromatch.braces(pattern, { ...options, expand: true });};
/\*\* \* Expose micromatch \*/
module.exports = micromatch;

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

