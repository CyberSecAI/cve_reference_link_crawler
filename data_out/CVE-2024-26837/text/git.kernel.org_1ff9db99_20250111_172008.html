

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=dc489f86257cab5056e747344f17a164f63bff4b)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=dc489f86257cab5056e747344f17a164f63bff4b)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=dc489f86257cab5056e747344f17a164f63bff4b)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=dc489f86257cab5056e747344f17a164f63bff4b)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Tobias Waldekranz <tobias@waldekranz.com> | 2024-02-14 22:40:03 +0100 |
| --- | --- | --- |
| committer | David S. Miller <davem@davemloft.net> | 2024-02-16 09:36:37 +0000 |
| commit | [dc489f86257cab5056e747344f17a164f63bff4b](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=dc489f86257cab5056e747344f17a164f63bff4b) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=dc489f86257cab5056e747344f17a164f63bff4b)) | |
| tree | [1e6299d697fb2a1c2ede6acfa8deb146994738de](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=dc489f86257cab5056e747344f17a164f63bff4b) | |
| parent | [b4ea9b6a18ebf7f9f3a7a60f82e925186978cfcf](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b4ea9b6a18ebf7f9f3a7a60f82e925186978cfcf) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=dc489f86257cab5056e747344f17a164f63bff4b&id2=b4ea9b6a18ebf7f9f3a7a60f82e925186978cfcf)) | |
| download | [linux-dc489f86257cab5056e747344f17a164f63bff4b.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-dc489f86257cab5056e747344f17a164f63bff4b.tar.gz) | |

net: bridge: switchdev: Skip MDB replays of deferred events on offloadBefore this change, generation of the list of MDB events to replay
would race against the creation of new group memberships, either from
the IGMP/MLD snooping logic or from user configuration.
While new memberships are immediately visible to walkers of
br->mdb\_list, the notification of their existence to switchdev event
subscribers is deferred until a later point in time. So if a replay
list was generated during a time that overlapped with such a window,
it would also contain a replay of the not-yet-delivered event.
The driver would thus receive two copies of what the bridge internally
considered to be one single event. On destruction of the bridge, only
a single membership deletion event was therefore sent. As a
consequence of this, drivers which reference count memberships (at
least DSA), would be left with orphan groups in their hardware
database when the bridge was destroyed.
This is only an issue when replaying additions. While deletion events
may still be pending on the deferred queue, they will already have
been removed from br->mdb\_list, so no duplicates can be generated in
that scenario.
To a user this meant that old group memberships, from a bridge in
which a port was previously attached, could be reanimated (in
hardware) when the port joined a new bridge, without the new bridge's
knowledge.
For example, on an mv88e6xxx system, create a snooping bridge and
immediately add a port to it:
root@infix-06-0b-00:~$ ip link add dev br0 up type bridge mcast\_snooping 1 && \
> ip link set dev x3 up master br0
And then destroy the bridge:
root@infix-06-0b-00:~$ ip link del dev br0
root@infix-06-0b-00:~$ mvls atu
ADDRESS FID STATE Q F 0 1 2 3 4 5 6 7 8 9 a
DEV:0 Marvell 88E6393X
33:33:00:00:00:6a 1 static - - 0 . . . . . . . . . .
33:33:ff:87:e4:3f 1 static - - 0 . . . . . . . . . .
ff:ff:ff:ff:ff:ff 1 static - - 0 1 2 3 4 5 6 7 8 9 a
root@infix-06-0b-00:~$
The two IPv6 groups remain in the hardware database because the
port (x3) is notified of the host's membership twice: once via the
original event and once via a replay. Since only a single delete
notification is sent, the count remains at 1 when the bridge is
destroyed.
Then add the same port (or another port belonging to the same hardware
domain) to a new bridge, this time with snooping disabled:
root@infix-06-0b-00:~$ ip link add dev br1 up type bridge mcast\_snooping 0 && \
> ip link set dev x3 up master br1
All multicast, including the two IPv6 groups from br0, should now be
flooded, according to the policy of br1. But instead the old
memberships are still active in the hardware database, causing the
switch to only forward traffic to those groups towards the CPU (port
0).
Eliminate the race in two steps:
1. Grab the write-side lock of the MDB while generating the replay
list.
This prevents new memberships from showing up while we are generating
the replay list. But it leaves the scenario in which a deferred event
was already generated, but not delivered, before we grabbed the
lock. Therefore:
2. Make sure that no deferred version of a replay event is already
enqueued to the switchdev deferred queue, before adding it to the
replay list, when replaying additions.
Fixes: 4f2673b3a2b6 ("net: bridge: add helper to replay port and host-joined mdb entries")
Signed-off-by: Tobias Waldekranz <tobias@waldekranz.com>
Reviewed-by: Vladimir Oltean <olteanv@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=dc489f86257cab5056e747344f17a164f63bff4b)

| -rw-r--r-- | [include/net/switchdev.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/switchdev.h?id=dc489f86257cab5056e747344f17a164f63bff4b) | 3 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/bridge/br\_switchdev.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/bridge/br_switchdev.c?id=dc489f86257cab5056e747344f17a164f63bff4b) | 74 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/switchdev/switchdev.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/switchdev/switchdev.c?id=dc489f86257cab5056e747344f17a164f63bff4b) | 73 | |  |  |  | | --- | --- | --- | |

3 files changed, 122 insertions, 28 deletions

| diff --git a/include/net/switchdev.h b/include/net/switchdev.hindex a43062d4c734bb..8346b0d29542c3 100644--- a/[include/net/switchdev.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/switchdev.h?id=b4ea9b6a18ebf7f9f3a7a60f82e925186978cfcf)+++ b/[include/net/switchdev.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/switchdev.h?id=dc489f86257cab5056e747344f17a164f63bff4b)@@ -308,6 +308,9 @@ void switchdev\_deferred\_process(void); int switchdev\_port\_attr\_set(struct net\_device \*dev, const struct switchdev\_attr \*attr, struct netlink\_ext\_ack \*extack);+bool switchdev\_port\_obj\_act\_is\_deferred(struct net\_device \*dev,+ enum switchdev\_notifier\_type nt,+ const struct switchdev\_obj \*obj); int switchdev\_port\_obj\_add(struct net\_device \*dev, const struct switchdev\_obj \*obj, struct netlink\_ext\_ack \*extack);diff --git a/net/bridge/br\_switchdev.c b/net/bridge/br\_switchdev.cindex ee84e783e1dff5..6a7cb01f121c70 100644--- a/[net/bridge/br\_switchdev.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/bridge/br_switchdev.c?id=b4ea9b6a18ebf7f9f3a7a60f82e925186978cfcf)+++ b/[net/bridge/br\_switchdev.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/bridge/br_switchdev.c?id=dc489f86257cab5056e747344f17a164f63bff4b)@@ -595,21 +595,40 @@ br\_switchdev\_mdb\_replay\_one(struct notifier\_block \*nb, struct net\_device \*dev, }  static int br\_switchdev\_mdb\_queue\_one(struct list\_head \*mdb\_list,+ struct net\_device \*dev,+ unsigned long action, enum switchdev\_obj\_id id, const struct net\_bridge\_mdb\_entry \*mp, struct net\_device \*orig\_dev) {- struct switchdev\_obj\_port\_mdb \*mdb;+ struct switchdev\_obj\_port\_mdb mdb = {+ .obj = {+ .id = id,+ .orig\_dev = orig\_dev,+ },+ };+ struct switchdev\_obj\_port\_mdb \*pmdb; - mdb = kzalloc(sizeof(\*mdb), GFP\_ATOMIC);- if (!mdb)- return -ENOMEM;+ br\_switchdev\_mdb\_populate(&mdb, mp); - mdb->obj.id = id;- mdb->obj.orig\_dev = orig\_dev;- br\_switchdev\_mdb\_populate(mdb, mp);- list\_add\_tail(&mdb->obj.list, mdb\_list);+ if (action == SWITCHDEV\_PORT\_OBJ\_ADD &&+ switchdev\_port\_obj\_act\_is\_deferred(dev, action, &mdb.obj)) {+ /\* This event is already in the deferred queue of+ \* events, so this replay must be elided, lest the+ \* driver receives duplicate events for it. This can+ \* only happen when replaying additions, since+ \* modifications are always immediately visible in+ \* br->mdb\_list, whereas actual event delivery may be+ \* delayed.+ \*/+ return 0;+ }++ pmdb = kmemdup(&mdb, sizeof(mdb), GFP\_ATOMIC);+ if (!pmdb)+ return -ENOMEM; + list\_add\_tail(&pmdb->obj.list, mdb\_list); return 0; } @@ -677,51 +696,50 @@ br\_switchdev\_mdb\_replay(struct net\_device \*br\_dev, struct net\_device \*dev, if (!br\_opt\_get(br, BROPT\_MULTICAST\_ENABLED)) return 0; - /\* We cannot walk over br->mdb\_list protected just by the rtnl\_mutex,- \* because the write-side protection is br->multicast\_lock. But we- \* need to emulate the [ blocking ] calling context of a regular- \* switchdev event, so since both br->multicast\_lock and RCU read side- \* critical sections are atomic, we have no choice but to pick the RCU- \* read side lock, queue up all our events, leave the critical section- \* and notify switchdev from blocking context.+ if (adding)+ action = SWITCHDEV\_PORT\_OBJ\_ADD;+ else+ action = SWITCHDEV\_PORT\_OBJ\_DEL;++ /\* br\_switchdev\_mdb\_queue\_one() will take care to not queue a+ \* replay of an event that is already pending in the switchdev+ \* deferred queue. In order to safely determine that, there+ \* must be no new deferred MDB notifications enqueued for the+ \* duration of the MDB scan. Therefore, grab the write-side+ \* lock to avoid racing with any concurrent IGMP/MLD snooping. \*/- rcu\_read\_lock();+ spin\_lock\_bh(&br->multicast\_lock); - hlist\_for\_each\_entry\_rcu(mp, &br->mdb\_list, mdb\_node) {+ hlist\_for\_each\_entry(mp, &br->mdb\_list, mdb\_node) { struct net\_bridge\_port\_group \_\_rcu \* const \*pp; const struct net\_bridge\_port\_group \*p;  if (mp->host\_joined) {- err = br\_switchdev\_mdb\_queue\_one(&mdb\_list,+ err = br\_switchdev\_mdb\_queue\_one(&mdb\_list, dev, action, SWITCHDEV\_OBJ\_ID\_HOST\_MDB, mp, br\_dev); if (err) {- rcu\_read\_unlock();+ spin\_unlock\_bh(&br->multicast\_lock); goto out\_free\_mdb; } } - for (pp = &mp->ports; (p = rcu\_dereference(\*pp)) != NULL;+ for (pp = &mp->ports; (p = mlock\_dereference(\*pp, br)) != NULL; pp = &p->next) { if (p->key.port->dev != dev) continue; - err = br\_switchdev\_mdb\_queue\_one(&mdb\_list,+ err = br\_switchdev\_mdb\_queue\_one(&mdb\_list, dev, action, SWITCHDEV\_OBJ\_ID\_PORT\_MDB, mp, dev); if (err) {- rcu\_read\_unlock();+ spin\_unlock\_bh(&br->multicast\_lock); goto out\_free\_mdb; } } } - rcu\_read\_unlock();-- if (adding)- action = SWITCHDEV\_PORT\_OBJ\_ADD;- else- action = SWITCHDEV\_PORT\_OBJ\_DEL;+ spin\_unlock\_bh(&br->multicast\_lock);  list\_for\_each\_entry(obj, &mdb\_list, list) { err = br\_switchdev\_mdb\_replay\_one(nb, dev,diff --git a/net/switchdev/switchdev.c b/net/switchdev/switchdev.cindex 5b045284849e03..c9189a970eec31 100644--- a/[net/switchdev/switchdev.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/switchdev/switchdev.c?id=b4ea9b6a18ebf7f9f3a7a60f82e925186978cfcf)+++ b/[net/switchdev/switchdev.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/switchdev/switchdev.c?id=dc489f86257cab5056e747344f17a164f63bff4b)@@ -19,6 +19,35 @@ #include <linux/rtnetlink.h> #include <net/switchdev.h> +static bool switchdev\_obj\_eq(const struct switchdev\_obj \*a,+ const struct switchdev\_obj \*b)+{+ const struct switchdev\_obj\_port\_vlan \*va, \*vb;+ const struct switchdev\_obj\_port\_mdb \*ma, \*mb;++ if (a->id != b->id || a->orig\_dev != b->orig\_dev)+ return false;++ switch (a->id) {+ case SWITCHDEV\_OBJ\_ID\_PORT\_VLAN:+ va = SWITCHDEV\_OBJ\_PORT\_VLAN(a);+ vb = SWITCHDEV\_OBJ\_PORT\_VLAN(b);+ return va->flags == vb->flags &&+ va->vid == vb->vid &&+ va->changed == vb->changed;+ case SWITCHDEV\_OBJ\_ID\_PORT\_MDB:+ case SWITCHDEV\_OBJ\_ID\_HOST\_MDB:+ ma = SWITCHDEV\_OBJ\_PORT\_MDB(a);+ mb = SWITCHDEV\_OBJ\_PORT\_MDB(b);+ return ma->vid == mb->vid &&+ ether\_addr\_equal(ma->addr, mb->addr);+ default:+ break;+ }++ BUG();+}+ static LIST\_HEAD(deferred); static DEFINE\_SPINLOCK(deferred\_lock); @@ -307,6 +336,50 @@ int switchdev\_port\_obj\_del(struct net\_device \*dev, } EXPORT\_SYMBOL\_GPL(switchdev\_port\_obj\_del); +/\*\*+ \* switchdev\_port\_obj\_act\_is\_deferred - Is object action pending?+ \*+ \* @dev: port device+ \* @nt: type of action; add or delete+ \* @obj: object to test+ \*+ \* Returns true if a deferred item is pending, which is+ \* equivalent to the action @nt on an object @obj.+ \*+ \* rtnl\_lock must be held.+ \*/+bool switchdev\_port\_obj\_act\_is\_deferred(struct net\_device \*dev,+ enum switchdev\_notifier\_type nt,+ const struct switchdev\_obj \*obj)+{+ struct switchdev\_deferred\_item \*dfitem;+ bool found = false;++ ASSERT\_RTNL();++ spin\_lock\_bh(&deferred\_lock);++ list\_for\_each\_entry(dfitem, &deferred, list) {+ if (dfitem->dev != dev)+ continue;++ if ((dfitem->func == switchdev\_port\_obj\_add\_deferred &&+ nt == SWITCHDEV\_PORT\_OBJ\_ADD) ||+ (dfitem->func == switchdev\_port\_obj\_del\_deferred &&+ nt == SWITCHDEV\_PORT\_OBJ\_DEL)) {+ if (switchdev\_obj\_eq((const void \*)dfitem->data, obj)) {+ found = true;+ break;+ }+ }+ }++ spin\_unlock\_bh(&deferred\_lock);++ return found;+}+EXPORT\_SYMBOL\_GPL(switchdev\_port\_obj\_act\_is\_deferred);+ static ATOMIC\_NOTIFIER\_HEAD(switchdev\_notif\_chain); static BLOCKING\_NOTIFIER\_HEAD(switchdev\_blocking\_notif\_chain); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 17:18:45 +0000

