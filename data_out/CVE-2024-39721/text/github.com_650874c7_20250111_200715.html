
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Follama%2Follama%2Fblob%2Fadeb40eaf29039b8964425f69a9315f9f1694ba8%2Fserver%2Froutes.go)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Follama%2Follama%2Fblob%2Fadeb40eaf29039b8964425f69a9315f9f1694ba8%2Fserver%2Froutes.go)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=ollama%2Follama)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[ollama](/ollama)
/
**[ollama](/ollama/ollama)**
Public

* [Notifications](/login?return_to=%2Follama%2Follama) You must be signed in to change notification settings
* [Fork
  8.6k](/login?return_to=%2Follama%2Follama)
* [Star
   107k](/login?return_to=%2Follama%2Follama)

* [Code](/ollama/ollama)
* [Issues
  1.1k](/ollama/ollama/issues)
* [Pull requests
  183](/ollama/ollama/pulls)
* [Actions](/ollama/ollama/actions)
* [Security](/ollama/ollama/security)
* [Insights](/ollama/ollama/pulse)

Additional navigation options

* [Code](/ollama/ollama)
* [Issues](/ollama/ollama/issues)
* [Pull requests](/ollama/ollama/pulls)
* [Actions](/ollama/ollama/actions)
* [Security](/ollama/ollama/security)
* [Insights](/ollama/ollama/pulse)

## Files

 adeb40e
## Breadcrumbs

1. [ollama](/ollama/ollama/tree/adeb40eaf29039b8964425f69a9315f9f1694ba8)
2. /[server](/ollama/ollama/tree/adeb40eaf29039b8964425f69a9315f9f1694ba8/server)
/
# routes.go

Copy path Blame  Blame
## Latest commit

## History

[History](/ollama/ollama/commits/adeb40eaf29039b8964425f69a9315f9f1694ba8/server/routes.go)1322 lines (1120 loc) · 31.6 KB adeb40e
## Breadcrumbs

1. [ollama](/ollama/ollama/tree/adeb40eaf29039b8964425f69a9315f9f1694ba8)
2. /[server](/ollama/ollama/tree/adeb40eaf29039b8964425f69a9315f9f1694ba8/server)
/
# routes.go

Top
## File metadata and controls

* Code
* Blame

1322 lines (1120 loc) · 31.6 KB[Raw](https://github.com/ollama/ollama/raw/adeb40eaf29039b8964425f69a9315f9f1694ba8/server/routes.go)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000package server
import ( "cmp" "context" "encoding/json" "errors" "fmt" "io" "io/fs" "log/slog" "math" "net" "net/http" "net/netip" "os" "os/signal" "path/filepath" "strconv" "strings" "syscall" "time"
 "github.com/gin-contrib/cors" "github.com/gin-gonic/gin" "golang.org/x/exp/slices"
 "github.com/ollama/ollama/api" "github.com/ollama/ollama/gpu" "github.com/ollama/ollama/llm" "github.com/ollama/ollama/openai" "github.com/ollama/ollama/server/envconfig" "github.com/ollama/ollama/types/model" "github.com/ollama/ollama/version")
var mode string = gin.DebugMode
type Server struct { addr net.Addr sched \*Scheduler}
func init() { switch mode { case gin.DebugMode: case gin.ReleaseMode: case gin.TestMode: default: mode = gin.DebugMode }
 gin.SetMode(mode)}
var defaultSessionDuration = 5 \* time.Minute
func modelOptions(model \*Model, requestOpts map[string]interface{}) (api.Options, error) { opts := api.DefaultOptions() if err := opts.FromMap(model.Options); err != nil { return api.Options{}, err }
 if err := opts.FromMap(requestOpts); err != nil { return api.Options{}, err }
 return opts, nil}
func isSupportedImageType(image []byte) bool { contentType := http.DetectContentType(image) allowedTypes := []string{"image/jpeg", "image/jpg", "image/png"} return slices.Contains(allowedTypes, contentType)}
func (s \*Server) GenerateHandler(c \*gin.Context) {
 checkpointStart := time.Now() var req api.GenerateRequest err := c.ShouldBindJSON(&req)
 switch { case errors.Is(err, io.EOF): c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "missing request body"}) return case err != nil: c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 // validate the request switch { case req.Model == "": c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "model is required"}) return case len(req.Format) > 0 && req.Format != "json": c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "format must be json"}) return case req.Raw && (req.Template != "" || req.System != "" || len(req.Context) > 0): c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "raw mode does not support template, system, or context"}) return }
 for \_, img := range req.Images { if !isSupportedImageType(img) { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "unsupported image format"}) return } }
 model, err := GetModel(req.Model) if err != nil { var pErr \*fs.PathError if errors.As(err, &pErr) { c.JSON(http.StatusNotFound, gin.H{"error": fmt.Sprintf("model '%s' not found, try pulling it first", req.Model)}) return } c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 if model.IsEmbedding() { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "embedding models do not support generate"}) return }
 opts, err := modelOptions(model, req.Options) if err != nil { if errors.Is(err, api.ErrInvalidOpts) { c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return } c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 var sessionDuration time.Duration if req.KeepAlive == nil { sessionDuration = getDefaultSessionDuration() } else { sessionDuration = req.KeepAlive.Duration }
 rCh, eCh := s.sched.GetRunner(c.Request.Context(), model, opts, sessionDuration) var runner \*runnerRef select { case runner = <-rCh: case err = <-eCh: handleErrorResponse(c, err) return }
 // an empty request loads the model // note: for a short while template was used in lieu // of `raw` mode so we need to check for it too if req.Prompt == "" && req.Template == "" && req.System == "" { c.JSON(http.StatusOK, api.GenerateResponse{ CreatedAt: time.Now().UTC(), Model: req.Model, Done: true, }) return }
 checkpointLoaded := time.Now()
 var prompt string switch { case req.Raw: prompt = req.Prompt case req.Prompt != "": if req.Template == "" { req.Template = model.Template }
 if req.System == "" { req.System = model.System }
 slog.Debug("generate handler", "prompt", req.Prompt) slog.Debug("generate handler", "template", req.Template) slog.Debug("generate handler", "system", req.System)
 var sb strings.Builder for i := range req.Images { fmt.Fprintf(&sb, "[img-%d] ", i) }
 sb.WriteString(req.Prompt)
 p, err := Prompt(req.Template, req.System, sb.String(), "", true) if err != nil { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 sb.Reset() if req.Context != nil { prev, err := runner.llama.Detokenize(c.Request.Context(), req.Context) if err != nil { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 sb.WriteString(prev) }
 sb.WriteString(p)
 prompt = sb.String() }
 slog.Debug("generate handler", "prompt", prompt)
 ch := make(chan any) var generated strings.Builder go func() { defer close(ch)
 fn := func(r llm.CompletionResponse) { // Build up the full response if \_, err := generated.WriteString(r.Content); err != nil { ch <- gin.H{"error": err.Error()} return }
 resp := api.GenerateResponse{ Model: req.Model, CreatedAt: time.Now().UTC(), Done: r.Done, Response: r.Content, Metrics: api.Metrics{ PromptEvalCount: r.PromptEvalCount, PromptEvalDuration: r.PromptEvalDuration, EvalCount: r.EvalCount, EvalDuration: r.EvalDuration, }, }
 if r.Done { resp.TotalDuration = time.Since(checkpointStart) resp.LoadDuration = checkpointLoaded.Sub(checkpointStart)
 if !req.Raw { p, err := Prompt(req.Template, req.System, req.Prompt, generated.String(), false) if err != nil { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 // TODO (jmorganca): encode() should not strip special tokens tokens, err := runner.llama.Tokenize(c.Request.Context(), p) if err != nil { ch <- gin.H{"error": err.Error()} return }
 resp.Context = append(req.Context, tokens...) } }
 ch <- resp }
 var images []llm.ImageData for i := range req.Images { images = append(images, llm.ImageData{ ID: i, Data: req.Images[i], }) }
 // Start prediction req := llm.CompletionRequest{ Prompt: prompt, Format: req.Format, Images: images, Options: opts, } if err := runner.llama.Completion(c.Request.Context(), req, fn); err != nil { ch <- gin.H{"error": err.Error()} } }()
 if req.Stream != nil && !\*req.Stream { // Accumulate responses into the final response var final api.GenerateResponse var sb strings.Builder for resp := range ch { switch r := resp.(type) { case api.GenerateResponse: sb.WriteString(r.Response) final = r case gin.H: if errorMsg, ok := r["error"].(string); ok { c.JSON(http.StatusInternalServerError, gin.H{"error": errorMsg}) return } else { c.JSON(http.StatusInternalServerError, gin.H{"error": "unexpected error format in response"}) return } default: c.JSON(http.StatusInternalServerError, gin.H{"error": "unexpected error"}) return } }
 final.Response = sb.String() c.JSON(http.StatusOK, final) return }
 streamResponse(c, ch)}
func getDefaultSessionDuration() time.Duration { if t, exists := os.LookupEnv("OLLAMA\_KEEP\_ALIVE"); exists { v, err := strconv.Atoi(t) if err != nil { d, err := time.ParseDuration(t) if err != nil { return defaultSessionDuration }
 if d < 0 { return time.Duration(math.MaxInt64) }
 return d }
 d := time.Duration(v) \* time.Second if d < 0 { return time.Duration(math.MaxInt64) } return d }
 return defaultSessionDuration}
func (s \*Server) EmbeddingsHandler(c \*gin.Context) { var req api.EmbeddingRequest err := c.ShouldBindJSON(&req) switch { case errors.Is(err, io.EOF): c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "missing request body"}) return case err != nil: c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 if req.Model == "" { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "model is required"}) return }
 model, err := GetModel(req.Model) if err != nil { var pErr \*fs.PathError if errors.As(err, &pErr) { c.JSON(http.StatusNotFound, gin.H{"error": fmt.Sprintf("model '%s' not found, try pulling it first", req.Model)}) return } c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 opts, err := modelOptions(model, req.Options) if err != nil { if errors.Is(err, api.ErrInvalidOpts) { c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return } c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 var sessionDuration time.Duration if req.KeepAlive == nil { sessionDuration = getDefaultSessionDuration() } else { sessionDuration = req.KeepAlive.Duration }
 rCh, eCh := s.sched.GetRunner(c.Request.Context(), model, opts, sessionDuration) var runner \*runnerRef select { case runner = <-rCh: case err = <-eCh: handleErrorResponse(c, err) return }
 // an empty request loads the model if req.Prompt == "" { c.JSON(http.StatusOK, api.EmbeddingResponse{Embedding: []float64{}}) return }
 embedding, err := runner.llama.Embedding(c.Request.Context(), req.Prompt) if err != nil { slog.Info(fmt.Sprintf("embedding generation failed: %v", err)) c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to generate embedding"}) return }
 resp := api.EmbeddingResponse{ Embedding: embedding, } c.JSON(http.StatusOK, resp)}
func (s \*Server) PullModelHandler(c \*gin.Context) { var req api.PullRequest err := c.ShouldBindJSON(&req) switch { case errors.Is(err, io.EOF): c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "missing request body"}) return case err != nil: c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 var model string if req.Model != "" { model = req.Model } else if req.Name != "" { model = req.Name } else { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "model is required"}) return }
 ch := make(chan any) go func() { defer close(ch) fn := func(r api.ProgressResponse) { ch <- r }
 regOpts := &registryOptions{ Insecure: req.Insecure, }
 ctx, cancel := context.WithCancel(c.Request.Context()) defer cancel()
 if err := PullModel(ctx, model, regOpts, fn); err != nil { ch <- gin.H{"error": err.Error()} } }()
 if req.Stream != nil && !\*req.Stream { waitForStream(c, ch) return }
 streamResponse(c, ch)}
func (s \*Server) PushModelHandler(c \*gin.Context) { var req api.PushRequest err := c.ShouldBindJSON(&req) switch { case errors.Is(err, io.EOF): c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "missing request body"}) return case err != nil: c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 var model string if req.Model != "" { model = req.Model } else if req.Name != "" { model = req.Name } else { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "model is required"}) return }
 ch := make(chan any) go func() { defer close(ch) fn := func(r api.ProgressResponse) { ch <- r }
 regOpts := &registryOptions{ Insecure: req.Insecure, }
 ctx, cancel := context.WithCancel(c.Request.Context()) defer cancel()
 if err := PushModel(ctx, model, regOpts, fn); err != nil { ch <- gin.H{"error": err.Error()} } }()
 if req.Stream != nil && !\*req.Stream { waitForStream(c, ch) return }
 streamResponse(c, ch)}
func (s \*Server) CreateModelHandler(c \*gin.Context) { var req api.CreateRequest if err := c.ShouldBindJSON(&req); errors.Is(err, io.EOF) { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "missing request body"}) return } else if err != nil { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 name := model.ParseName(cmp.Or(req.Model, req.Name)) if !name.IsValid() { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "invalid model name"}) return }
 if req.Path == "" && req.Modelfile == "" { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "path or modelfile are required"}) return }
 var r io.Reader = strings.NewReader(req.Modelfile) if req.Path != "" && req.Modelfile == "" { f, err := os.Open(req.Path) if err != nil { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("error reading modelfile: %s", err)}) return } defer f.Close()
 r = f }
 modelfile, err := model.ParseFile(r) if err != nil { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 ch := make(chan any) go func() { defer close(ch) fn := func(resp api.ProgressResponse) { ch <- resp }
 ctx, cancel := context.WithCancel(c.Request.Context()) defer cancel()
 if err := CreateModel(ctx, name.String(), filepath.Dir(req.Path), req.Quantization, modelfile, fn); err != nil { ch <- gin.H{"error": err.Error()} } }()
 if req.Stream != nil && !\*req.Stream { waitForStream(c, ch) return }
 streamResponse(c, ch)}
func (s \*Server) DeleteModelHandler(c \*gin.Context) { var req api.DeleteRequest err := c.ShouldBindJSON(&req) switch { case errors.Is(err, io.EOF): c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "missing request body"}) return case err != nil: c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 var model string if req.Model != "" { model = req.Model } else if req.Name != "" { model = req.Name } else { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "model is required"}) return }
 if err := DeleteModel(model); err != nil { if os.IsNotExist(err) { c.JSON(http.StatusNotFound, gin.H{"error": fmt.Sprintf("model '%s' not found", model)}) } else { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) } return }
 manifestsPath, err := GetManifestPath() if err != nil { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 if err := PruneDirectory(manifestsPath); err != nil { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 c.JSON(http.StatusOK, nil)}
func (s \*Server) ShowModelHandler(c \*gin.Context) { var req api.ShowRequest err := c.ShouldBindJSON(&req) switch { case errors.Is(err, io.EOF): c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "missing request body"}) return case err != nil: c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 if req.Model != "" { // noop } else if req.Name != "" { req.Model = req.Name } else { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "model is required"}) return }
 resp, err := GetModelInfo(req) if err != nil { if os.IsNotExist(err) { c.JSON(http.StatusNotFound, gin.H{"error": fmt.Sprintf("model '%s' not found", req.Model)}) } else { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) } return }
 c.JSON(http.StatusOK, resp)}
func GetModelInfo(req api.ShowRequest) (\*api.ShowResponse, error) { model, err := GetModel(req.Model) if err != nil { return nil, err }
 modelDetails := api.ModelDetails{ ParentModel: model.ParentModel, Format: model.Config.ModelFormat, Family: model.Config.ModelFamily, Families: model.Config.ModelFamilies, ParameterSize: model.Config.ModelType, QuantizationLevel: model.Config.FileType, }
 if req.System != "" { model.System = req.System }
 if req.Template != "" { model.Template = req.Template }
 msgs := make([]api.Message, 0) for \_, msg := range model.Messages { msgs = append(msgs, api.Message{Role: msg.Role, Content: msg.Content}) }
 resp := &api.ShowResponse{ License: strings.Join(model.License, "\n"), System: model.System, Template: model.Template, Details: modelDetails, Messages: msgs, }
 var params []string cs := 30 for k, v := range model.Options { switch val := v.(type) { case []interface{}: for \_, nv := range val { params = append(params, fmt.Sprintf("%-\*s %#v", cs, k, nv)) } default: params = append(params, fmt.Sprintf("%-\*s %#v", cs, k, v)) } } resp.Parameters = strings.Join(params, "\n")
 for k, v := range req.Options { if \_, ok := req.Options[k]; ok { model.Options[k] = v } }
 var sb strings.Builder fmt.Fprintln(&sb, "# Modelfile generate by \"ollama show\"") fmt.Fprintln(&sb, "# To build a new Modelfile based on this, replace FROM with:") fmt.Fprintf(&sb, "# FROM %s\n\n", model.ShortName) fmt.Fprint(&sb, model.String()) resp.Modelfile = sb.String()
 return resp, nil}
func (s \*Server) ListModelsHandler(c \*gin.Context) { models := make([]api.ModelResponse, 0) manifestsPath, err := GetManifestPath() if err != nil { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 modelResponse := func(modelName string) (api.ModelResponse, error) { model, err := GetModel(modelName) if err != nil { return api.ModelResponse{}, err }
 modelDetails := api.ModelDetails{ Format: model.Config.ModelFormat, Family: model.Config.ModelFamily, Families: model.Config.ModelFamilies, ParameterSize: model.Config.ModelType, QuantizationLevel: model.Config.FileType, }
 return api.ModelResponse{ Model: model.ShortName, Name: model.ShortName, Size: model.Size, Digest: model.Digest, Details: modelDetails, }, nil }
 walkFunc := func(path string, info os.FileInfo, \_ error) error { if !info.IsDir() { path, tag := filepath.Split(path) model := strings.Trim(strings.TrimPrefix(path, manifestsPath), string(os.PathSeparator)) modelPath := strings.Join([]string{model, tag}, ":") canonicalModelPath := strings.ReplaceAll(modelPath, string(os.PathSeparator), "/")
 resp, err := modelResponse(canonicalModelPath) if err != nil { slog.Info(fmt.Sprintf("skipping file: %s", canonicalModelPath)) // nolint: nilerr return nil }
 resp.ModifiedAt = info.ModTime() models = append(models, resp) }
 return nil }
 if err := filepath.Walk(manifestsPath, walkFunc); err != nil { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 c.JSON(http.StatusOK, api.ListResponse{Models: models})}
func (s \*Server) CopyModelHandler(c \*gin.Context) { var r api.CopyRequest if err := c.ShouldBindJSON(&r); errors.Is(err, io.EOF) { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "missing request body"}) return } else if err != nil { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 src := model.ParseName(r.Source) if !src.IsValid() { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("source %q is invalid", r.Source)}) return }
 dst := model.ParseName(r.Destination) if !dst.IsValid() { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("destination %q is invalid", r.Source)}) return }
 if err := CopyModel(src, dst); errors.Is(err, os.ErrNotExist) { c.JSON(http.StatusNotFound, gin.H{"error": fmt.Sprintf("model %q not found", r.Source)}) } else if err != nil { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) }}
func (s \*Server) HeadBlobHandler(c \*gin.Context) { path, err := GetBlobsPath(c.Param("digest")) if err != nil { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 if \_, err := os.Stat(path); err != nil { c.AbortWithStatusJSON(http.StatusNotFound, gin.H{"error": fmt.Sprintf("blob %q not found", c.Param("digest"))}) return }
 c.Status(http.StatusOK)}
func (s \*Server) CreateBlobHandler(c \*gin.Context) { path, err := GetBlobsPath(c.Param("digest")) if err != nil { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 \_, err = os.Stat(path) switch { case errors.Is(err, os.ErrNotExist): // noop case err != nil: c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return default: c.Status(http.StatusOK) return }
 layer, err := NewLayer(c.Request.Body, "") if err != nil { c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 if layer.Digest != c.Param("digest") { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("digest mismatch, expected %q, got %q", c.Param("digest"), layer.Digest)}) return }
 if \_, err := layer.Commit(); err != nil { c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 c.Status(http.StatusCreated)}
func isLocalIP(ip netip.Addr) bool { if interfaces, err := net.Interfaces(); err == nil { for \_, iface := range interfaces { addrs, err := iface.Addrs() if err != nil { continue }
 for \_, a := range addrs { if parsed, \_, err := net.ParseCIDR(a.String()); err == nil { if parsed.String() == ip.String() { return true } } } } }
 return false}
func allowedHost(host string) bool { if host == "" || host == "localhost" { return true }
 if hostname, err := os.Hostname(); err == nil && host == hostname { return true }
 var tlds = []string{ "localhost", "local", "internal", }
 // check if the host is a local TLD for \_, tld := range tlds { if strings.HasSuffix(host, "."+tld) { return true } }
 return false}
func allowedHostsMiddleware(addr net.Addr) gin.HandlerFunc { return func(c \*gin.Context) { if addr == nil { c.Next() return }
 if addr, err := netip.ParseAddrPort(addr.String()); err == nil && !addr.Addr().IsLoopback() { c.Next() return }
 host, \_, err := net.SplitHostPort(c.Request.Host) if err != nil { host = c.Request.Host }
 if addr, err := netip.ParseAddr(host); err == nil { if addr.IsLoopback() || addr.IsPrivate() || addr.IsUnspecified() || isLocalIP(addr) { c.Next() return } }
 if allowedHost(host) { c.Next() return }
 c.AbortWithStatus(http.StatusForbidden) }}
func (s \*Server) GenerateRoutes() http.Handler { config := cors.DefaultConfig() config.AllowWildcard = true config.AllowBrowserExtensions = true config.AllowOrigins = envconfig.AllowOrigins
 r := gin.Default() r.Use( cors.New(config), allowedHostsMiddleware(s.addr), )
 r.POST("/api/pull", s.PullModelHandler) r.POST("/api/generate", s.GenerateHandler) r.POST("/api/chat", s.ChatHandler) r.POST("/api/embeddings", s.EmbeddingsHandler) r.POST("/api/create", s.CreateModelHandler) r.POST("/api/push", s.PushModelHandler) r.POST("/api/copy", s.CopyModelHandler) r.DELETE("/api/delete", s.DeleteModelHandler) r.POST("/api/show", s.ShowModelHandler) r.POST("/api/blobs/:digest", s.CreateBlobHandler) r.HEAD("/api/blobs/:digest", s.HeadBlobHandler)
 // Compatibility endpoints r.POST("/v1/chat/completions", openai.Middleware(), s.ChatHandler)
 for \_, method := range []string{http.MethodGet, http.MethodHead} { r.Handle(method, "/", func(c \*gin.Context) { c.String(http.StatusOK, "Ollama is running") })
 r.Handle(method, "/api/tags", s.ListModelsHandler) r.Handle(method, "/api/version", func(c \*gin.Context) { c.JSON(http.StatusOK, gin.H{"version": version.Version}) }) }
 return r}
func Serve(ln net.Listener) error { level := slog.LevelInfo if envconfig.Debug { level = slog.LevelDebug }
 slog.Info("server config", "env", envconfig.AsMap()) handler := slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{ Level: level, AddSource: true, ReplaceAttr: func(\_ []string, attr slog.Attr) slog.Attr { if attr.Key == slog.SourceKey { source := attr.Value.Any().(\*slog.Source) source.File = filepath.Base(source.File) }
 return attr },[View remainder of file in raw view](https://github.com/ollama/ollama/raw/adeb40eaf29039b8964425f69a9315f9f1694ba8/server/routes.go)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

