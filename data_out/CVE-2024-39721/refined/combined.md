=== Content from github.com_650874c7_20250111_200715.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Follama%2Follama%2Fblob%2Fadeb40eaf29039b8964425f69a9315f9f1694ba8%2Fserver%2Froutes.go)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Follama%2Follama%2Fblob%2Fadeb40eaf29039b8964425f69a9315f9f1694ba8%2Fserver%2Froutes.go)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=ollama%2Follama)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[ollama](/ollama)
/
**[ollama](/ollama/ollama)**
Public

* [Notifications](/login?return_to=%2Follama%2Follama) You must be signed in to change notification settings
* [Fork
  8.6k](/login?return_to=%2Follama%2Follama)
* [Star
   107k](/login?return_to=%2Follama%2Follama)

* [Code](/ollama/ollama)
* [Issues
  1.1k](/ollama/ollama/issues)
* [Pull requests
  183](/ollama/ollama/pulls)
* [Actions](/ollama/ollama/actions)
* [Security](/ollama/ollama/security)
* [Insights](/ollama/ollama/pulse)

Additional navigation options

* [Code](/ollama/ollama)
* [Issues](/ollama/ollama/issues)
* [Pull requests](/ollama/ollama/pulls)
* [Actions](/ollama/ollama/actions)
* [Security](/ollama/ollama/security)
* [Insights](/ollama/ollama/pulse)

## Files

 adeb40e
## Breadcrumbs

1. [ollama](/ollama/ollama/tree/adeb40eaf29039b8964425f69a9315f9f1694ba8)
2. /[server](/ollama/ollama/tree/adeb40eaf29039b8964425f69a9315f9f1694ba8/server)
/
# routes.go

Copy path Blame  Blame
## Latest commit

## History

[History](/ollama/ollama/commits/adeb40eaf29039b8964425f69a9315f9f1694ba8/server/routes.go)1322 lines (1120 loc) · 31.6 KB adeb40e
## Breadcrumbs

1. [ollama](/ollama/ollama/tree/adeb40eaf29039b8964425f69a9315f9f1694ba8)
2. /[server](/ollama/ollama/tree/adeb40eaf29039b8964425f69a9315f9f1694ba8/server)
/
# routes.go

Top
## File metadata and controls

* Code
* Blame

1322 lines (1120 loc) · 31.6 KB[Raw](https://github.com/ollama/ollama/raw/adeb40eaf29039b8964425f69a9315f9f1694ba8/server/routes.go)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000package server
import ( "cmp" "context" "encoding/json" "errors" "fmt" "io" "io/fs" "log/slog" "math" "net" "net/http" "net/netip" "os" "os/signal" "path/filepath" "strconv" "strings" "syscall" "time"
 "github.com/gin-contrib/cors" "github.com/gin-gonic/gin" "golang.org/x/exp/slices"
 "github.com/ollama/ollama/api" "github.com/ollama/ollama/gpu" "github.com/ollama/ollama/llm" "github.com/ollama/ollama/openai" "github.com/ollama/ollama/server/envconfig" "github.com/ollama/ollama/types/model" "github.com/ollama/ollama/version")
var mode string = gin.DebugMode
type Server struct { addr net.Addr sched \*Scheduler}
func init() { switch mode { case gin.DebugMode: case gin.ReleaseMode: case gin.TestMode: default: mode = gin.DebugMode }
 gin.SetMode(mode)}
var defaultSessionDuration = 5 \* time.Minute
func modelOptions(model \*Model, requestOpts map[string]interface{}) (api.Options, error) { opts := api.DefaultOptions() if err := opts.FromMap(model.Options); err != nil { return api.Options{}, err }
 if err := opts.FromMap(requestOpts); err != nil { return api.Options{}, err }
 return opts, nil}
func isSupportedImageType(image []byte) bool { contentType := http.DetectContentType(image) allowedTypes := []string{"image/jpeg", "image/jpg", "image/png"} return slices.Contains(allowedTypes, contentType)}
func (s \*Server) GenerateHandler(c \*gin.Context) {
 checkpointStart := time.Now() var req api.GenerateRequest err := c.ShouldBindJSON(&req)
 switch { case errors.Is(err, io.EOF): c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "missing request body"}) return case err != nil: c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 // validate the request switch { case req.Model == "": c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "model is required"}) return case len(req.Format) > 0 && req.Format != "json": c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "format must be json"}) return case req.Raw && (req.Template != "" || req.System != "" || len(req.Context) > 0): c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "raw mode does not support template, system, or context"}) return }
 for \_, img := range req.Images { if !isSupportedImageType(img) { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "unsupported image format"}) return } }
 model, err := GetModel(req.Model) if err != nil { var pErr \*fs.PathError if errors.As(err, &pErr) { c.JSON(http.StatusNotFound, gin.H{"error": fmt.Sprintf("model '%s' not found, try pulling it first", req.Model)}) return } c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 if model.IsEmbedding() { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "embedding models do not support generate"}) return }
 opts, err := modelOptions(model, req.Options) if err != nil { if errors.Is(err, api.ErrInvalidOpts) { c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return } c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 var sessionDuration time.Duration if req.KeepAlive == nil { sessionDuration = getDefaultSessionDuration() } else { sessionDuration = req.KeepAlive.Duration }
 rCh, eCh := s.sched.GetRunner(c.Request.Context(), model, opts, sessionDuration) var runner \*runnerRef select { case runner = <-rCh: case err = <-eCh: handleErrorResponse(c, err) return }
 // an empty request loads the model // note: for a short while template was used in lieu // of `raw` mode so we need to check for it too if req.Prompt == "" && req.Template == "" && req.System == "" { c.JSON(http.StatusOK, api.GenerateResponse{ CreatedAt: time.Now().UTC(), Model: req.Model, Done: true, }) return }
 checkpointLoaded := time.Now()
 var prompt string switch { case req.Raw: prompt = req.Prompt case req.Prompt != "": if req.Template == "" { req.Template = model.Template }
 if req.System == "" { req.System = model.System }
 slog.Debug("generate handler", "prompt", req.Prompt) slog.Debug("generate handler", "template", req.Template) slog.Debug("generate handler", "system", req.System)
 var sb strings.Builder for i := range req.Images { fmt.Fprintf(&sb, "[img-%d] ", i) }
 sb.WriteString(req.Prompt)
 p, err := Prompt(req.Template, req.System, sb.String(), "", true) if err != nil { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 sb.Reset() if req.Context != nil { prev, err := runner.llama.Detokenize(c.Request.Context(), req.Context) if err != nil { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 sb.WriteString(prev) }
 sb.WriteString(p)
 prompt = sb.String() }
 slog.Debug("generate handler", "prompt", prompt)
 ch := make(chan any) var generated strings.Builder go func() { defer close(ch)
 fn := func(r llm.CompletionResponse) { // Build up the full response if \_, err := generated.WriteString(r.Content); err != nil { ch <- gin.H{"error": err.Error()} return }
 resp := api.GenerateResponse{ Model: req.Model, CreatedAt: time.Now().UTC(), Done: r.Done, Response: r.Content, Metrics: api.Metrics{ PromptEvalCount: r.PromptEvalCount, PromptEvalDuration: r.PromptEvalDuration, EvalCount: r.EvalCount, EvalDuration: r.EvalDuration, }, }
 if r.Done { resp.TotalDuration = time.Since(checkpointStart) resp.LoadDuration = checkpointLoaded.Sub(checkpointStart)
 if !req.Raw { p, err := Prompt(req.Template, req.System, req.Prompt, generated.String(), false) if err != nil { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 // TODO (jmorganca): encode() should not strip special tokens tokens, err := runner.llama.Tokenize(c.Request.Context(), p) if err != nil { ch <- gin.H{"error": err.Error()} return }
 resp.Context = append(req.Context, tokens...) } }
 ch <- resp }
 var images []llm.ImageData for i := range req.Images { images = append(images, llm.ImageData{ ID: i, Data: req.Images[i], }) }
 // Start prediction req := llm.CompletionRequest{ Prompt: prompt, Format: req.Format, Images: images, Options: opts, } if err := runner.llama.Completion(c.Request.Context(), req, fn); err != nil { ch <- gin.H{"error": err.Error()} } }()
 if req.Stream != nil && !\*req.Stream { // Accumulate responses into the final response var final api.GenerateResponse var sb strings.Builder for resp := range ch { switch r := resp.(type) { case api.GenerateResponse: sb.WriteString(r.Response) final = r case gin.H: if errorMsg, ok := r["error"].(string); ok { c.JSON(http.StatusInternalServerError, gin.H{"error": errorMsg}) return } else { c.JSON(http.StatusInternalServerError, gin.H{"error": "unexpected error format in response"}) return } default: c.JSON(http.StatusInternalServerError, gin.H{"error": "unexpected error"}) return } }
 final.Response = sb.String() c.JSON(http.StatusOK, final) return }
 streamResponse(c, ch)}
func getDefaultSessionDuration() time.Duration { if t, exists := os.LookupEnv("OLLAMA\_KEEP\_ALIVE"); exists { v, err := strconv.Atoi(t) if err != nil { d, err := time.ParseDuration(t) if err != nil { return defaultSessionDuration }
 if d < 0 { return time.Duration(math.MaxInt64) }
 return d }
 d := time.Duration(v) \* time.Second if d < 0 { return time.Duration(math.MaxInt64) } return d }
 return defaultSessionDuration}
func (s \*Server) EmbeddingsHandler(c \*gin.Context) { var req api.EmbeddingRequest err := c.ShouldBindJSON(&req) switch { case errors.Is(err, io.EOF): c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "missing request body"}) return case err != nil: c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 if req.Model == "" { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "model is required"}) return }
 model, err := GetModel(req.Model) if err != nil { var pErr \*fs.PathError if errors.As(err, &pErr) { c.JSON(http.StatusNotFound, gin.H{"error": fmt.Sprintf("model '%s' not found, try pulling it first", req.Model)}) return } c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 opts, err := modelOptions(model, req.Options) if err != nil { if errors.Is(err, api.ErrInvalidOpts) { c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return } c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 var sessionDuration time.Duration if req.KeepAlive == nil { sessionDuration = getDefaultSessionDuration() } else { sessionDuration = req.KeepAlive.Duration }
 rCh, eCh := s.sched.GetRunner(c.Request.Context(), model, opts, sessionDuration) var runner \*runnerRef select { case runner = <-rCh: case err = <-eCh: handleErrorResponse(c, err) return }
 // an empty request loads the model if req.Prompt == "" { c.JSON(http.StatusOK, api.EmbeddingResponse{Embedding: []float64{}}) return }
 embedding, err := runner.llama.Embedding(c.Request.Context(), req.Prompt) if err != nil { slog.Info(fmt.Sprintf("embedding generation failed: %v", err)) c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to generate embedding"}) return }
 resp := api.EmbeddingResponse{ Embedding: embedding, } c.JSON(http.StatusOK, resp)}
func (s \*Server) PullModelHandler(c \*gin.Context) { var req api.PullRequest err := c.ShouldBindJSON(&req) switch { case errors.Is(err, io.EOF): c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "missing request body"}) return case err != nil: c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 var model string if req.Model != "" { model = req.Model } else if req.Name != "" { model = req.Name } else { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "model is required"}) return }
 ch := make(chan any) go func() { defer close(ch) fn := func(r api.ProgressResponse) { ch <- r }
 regOpts := &registryOptions{ Insecure: req.Insecure, }
 ctx, cancel := context.WithCancel(c.Request.Context()) defer cancel()
 if err := PullModel(ctx, model, regOpts, fn); err != nil { ch <- gin.H{"error": err.Error()} } }()
 if req.Stream != nil && !\*req.Stream { waitForStream(c, ch) return }
 streamResponse(c, ch)}
func (s \*Server) PushModelHandler(c \*gin.Context) { var req api.PushRequest err := c.ShouldBindJSON(&req) switch { case errors.Is(err, io.EOF): c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "missing request body"}) return case err != nil: c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 var model string if req.Model != "" { model = req.Model } else if req.Name != "" { model = req.Name } else { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "model is required"}) return }
 ch := make(chan any) go func() { defer close(ch) fn := func(r api.ProgressResponse) { ch <- r }
 regOpts := &registryOptions{ Insecure: req.Insecure, }
 ctx, cancel := context.WithCancel(c.Request.Context()) defer cancel()
 if err := PushModel(ctx, model, regOpts, fn); err != nil { ch <- gin.H{"error": err.Error()} } }()
 if req.Stream != nil && !\*req.Stream { waitForStream(c, ch) return }
 streamResponse(c, ch)}
func (s \*Server) CreateModelHandler(c \*gin.Context) { var req api.CreateRequest if err := c.ShouldBindJSON(&req); errors.Is(err, io.EOF) { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "missing request body"}) return } else if err != nil { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 name := model.ParseName(cmp.Or(req.Model, req.Name)) if !name.IsValid() { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "invalid model name"}) return }
 if req.Path == "" && req.Modelfile == "" { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "path or modelfile are required"}) return }
 var r io.Reader = strings.NewReader(req.Modelfile) if req.Path != "" && req.Modelfile == "" { f, err := os.Open(req.Path) if err != nil { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("error reading modelfile: %s", err)}) return } defer f.Close()
 r = f }
 modelfile, err := model.ParseFile(r) if err != nil { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 ch := make(chan any) go func() { defer close(ch) fn := func(resp api.ProgressResponse) { ch <- resp }
 ctx, cancel := context.WithCancel(c.Request.Context()) defer cancel()
 if err := CreateModel(ctx, name.String(), filepath.Dir(req.Path), req.Quantization, modelfile, fn); err != nil { ch <- gin.H{"error": err.Error()} } }()
 if req.Stream != nil && !\*req.Stream { waitForStream(c, ch) return }
 streamResponse(c, ch)}
func (s \*Server) DeleteModelHandler(c \*gin.Context) { var req api.DeleteRequest err := c.ShouldBindJSON(&req) switch { case errors.Is(err, io.EOF): c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "missing request body"}) return case err != nil: c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 var model string if req.Model != "" { model = req.Model } else if req.Name != "" { model = req.Name } else { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "model is required"}) return }
 if err := DeleteModel(model); err != nil { if os.IsNotExist(err) { c.JSON(http.StatusNotFound, gin.H{"error": fmt.Sprintf("model '%s' not found", model)}) } else { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) } return }
 manifestsPath, err := GetManifestPath() if err != nil { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 if err := PruneDirectory(manifestsPath); err != nil { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 c.JSON(http.StatusOK, nil)}
func (s \*Server) ShowModelHandler(c \*gin.Context) { var req api.ShowRequest err := c.ShouldBindJSON(&req) switch { case errors.Is(err, io.EOF): c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "missing request body"}) return case err != nil: c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 if req.Model != "" { // noop } else if req.Name != "" { req.Model = req.Name } else { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "model is required"}) return }
 resp, err := GetModelInfo(req) if err != nil { if os.IsNotExist(err) { c.JSON(http.StatusNotFound, gin.H{"error": fmt.Sprintf("model '%s' not found", req.Model)}) } else { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) } return }
 c.JSON(http.StatusOK, resp)}
func GetModelInfo(req api.ShowRequest) (\*api.ShowResponse, error) { model, err := GetModel(req.Model) if err != nil { return nil, err }
 modelDetails := api.ModelDetails{ ParentModel: model.ParentModel, Format: model.Config.ModelFormat, Family: model.Config.ModelFamily, Families: model.Config.ModelFamilies, ParameterSize: model.Config.ModelType, QuantizationLevel: model.Config.FileType, }
 if req.System != "" { model.System = req.System }
 if req.Template != "" { model.Template = req.Template }
 msgs := make([]api.Message, 0) for \_, msg := range model.Messages { msgs = append(msgs, api.Message{Role: msg.Role, Content: msg.Content}) }
 resp := &api.ShowResponse{ License: strings.Join(model.License, "\n"), System: model.System, Template: model.Template, Details: modelDetails, Messages: msgs, }
 var params []string cs := 30 for k, v := range model.Options { switch val := v.(type) { case []interface{}: for \_, nv := range val { params = append(params, fmt.Sprintf("%-\*s %#v", cs, k, nv)) } default: params = append(params, fmt.Sprintf("%-\*s %#v", cs, k, v)) } } resp.Parameters = strings.Join(params, "\n")
 for k, v := range req.Options { if \_, ok := req.Options[k]; ok { model.Options[k] = v } }
 var sb strings.Builder fmt.Fprintln(&sb, "# Modelfile generate by \"ollama show\"") fmt.Fprintln(&sb, "# To build a new Modelfile based on this, replace FROM with:") fmt.Fprintf(&sb, "# FROM %s\n\n", model.ShortName) fmt.Fprint(&sb, model.String()) resp.Modelfile = sb.String()
 return resp, nil}
func (s \*Server) ListModelsHandler(c \*gin.Context) { models := make([]api.ModelResponse, 0) manifestsPath, err := GetManifestPath() if err != nil { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 modelResponse := func(modelName string) (api.ModelResponse, error) { model, err := GetModel(modelName) if err != nil { return api.ModelResponse{}, err }
 modelDetails := api.ModelDetails{ Format: model.Config.ModelFormat, Family: model.Config.ModelFamily, Families: model.Config.ModelFamilies, ParameterSize: model.Config.ModelType, QuantizationLevel: model.Config.FileType, }
 return api.ModelResponse{ Model: model.ShortName, Name: model.ShortName, Size: model.Size, Digest: model.Digest, Details: modelDetails, }, nil }
 walkFunc := func(path string, info os.FileInfo, \_ error) error { if !info.IsDir() { path, tag := filepath.Split(path) model := strings.Trim(strings.TrimPrefix(path, manifestsPath), string(os.PathSeparator)) modelPath := strings.Join([]string{model, tag}, ":") canonicalModelPath := strings.ReplaceAll(modelPath, string(os.PathSeparator), "/")
 resp, err := modelResponse(canonicalModelPath) if err != nil { slog.Info(fmt.Sprintf("skipping file: %s", canonicalModelPath)) // nolint: nilerr return nil }
 resp.ModifiedAt = info.ModTime() models = append(models, resp) }
 return nil }
 if err := filepath.Walk(manifestsPath, walkFunc); err != nil { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 c.JSON(http.StatusOK, api.ListResponse{Models: models})}
func (s \*Server) CopyModelHandler(c \*gin.Context) { var r api.CopyRequest if err := c.ShouldBindJSON(&r); errors.Is(err, io.EOF) { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "missing request body"}) return } else if err != nil { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 src := model.ParseName(r.Source) if !src.IsValid() { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("source %q is invalid", r.Source)}) return }
 dst := model.ParseName(r.Destination) if !dst.IsValid() { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("destination %q is invalid", r.Source)}) return }
 if err := CopyModel(src, dst); errors.Is(err, os.ErrNotExist) { c.JSON(http.StatusNotFound, gin.H{"error": fmt.Sprintf("model %q not found", r.Source)}) } else if err != nil { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) }}
func (s \*Server) HeadBlobHandler(c \*gin.Context) { path, err := GetBlobsPath(c.Param("digest")) if err != nil { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 if \_, err := os.Stat(path); err != nil { c.AbortWithStatusJSON(http.StatusNotFound, gin.H{"error": fmt.Sprintf("blob %q not found", c.Param("digest"))}) return }
 c.Status(http.StatusOK)}
func (s \*Server) CreateBlobHandler(c \*gin.Context) { path, err := GetBlobsPath(c.Param("digest")) if err != nil { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 \_, err = os.Stat(path) switch { case errors.Is(err, os.ErrNotExist): // noop case err != nil: c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return default: c.Status(http.StatusOK) return }
 layer, err := NewLayer(c.Request.Body, "") if err != nil { c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 if layer.Digest != c.Param("digest") { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("digest mismatch, expected %q, got %q", c.Param("digest"), layer.Digest)}) return }
 if \_, err := layer.Commit(); err != nil { c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 c.Status(http.StatusCreated)}
func isLocalIP(ip netip.Addr) bool { if interfaces, err := net.Interfaces(); err == nil { for \_, iface := range interfaces { addrs, err := iface.Addrs() if err != nil { continue }
 for \_, a := range addrs { if parsed, \_, err := net.ParseCIDR(a.String()); err == nil { if parsed.String() == ip.String() { return true } } } } }
 return false}
func allowedHost(host string) bool { if host == "" || host == "localhost" { return true }
 if hostname, err := os.Hostname(); err == nil && host == hostname { return true }
 var tlds = []string{ "localhost", "local", "internal", }
 // check if the host is a local TLD for \_, tld := range tlds { if strings.HasSuffix(host, "."+tld) { return true } }
 return false}
func allowedHostsMiddleware(addr net.Addr) gin.HandlerFunc { return func(c \*gin.Context) { if addr == nil { c.Next() return }
 if addr, err := netip.ParseAddrPort(addr.String()); err == nil && !addr.Addr().IsLoopback() { c.Next() return }
 host, \_, err := net.SplitHostPort(c.Request.Host) if err != nil { host = c.Request.Host }
 if addr, err := netip.ParseAddr(host); err == nil { if addr.IsLoopback() || addr.IsPrivate() || addr.IsUnspecified() || isLocalIP(addr) { c.Next() return } }
 if allowedHost(host) { c.Next() return }
 c.AbortWithStatus(http.StatusForbidden) }}
func (s \*Server) GenerateRoutes() http.Handler { config := cors.DefaultConfig() config.AllowWildcard = true config.AllowBrowserExtensions = true config.AllowOrigins = envconfig.AllowOrigins
 r := gin.Default() r.Use( cors.New(config), allowedHostsMiddleware(s.addr), )
 r.POST("/api/pull", s.PullModelHandler) r.POST("/api/generate", s.GenerateHandler) r.POST("/api/chat", s.ChatHandler) r.POST("/api/embeddings", s.EmbeddingsHandler) r.POST("/api/create", s.CreateModelHandler) r.POST("/api/push", s.PushModelHandler) r.POST("/api/copy", s.CopyModelHandler) r.DELETE("/api/delete", s.DeleteModelHandler) r.POST("/api/show", s.ShowModelHandler) r.POST("/api/blobs/:digest", s.CreateBlobHandler) r.HEAD("/api/blobs/:digest", s.HeadBlobHandler)
 // Compatibility endpoints r.POST("/v1/chat/completions", openai.Middleware(), s.ChatHandler)
 for \_, method := range []string{http.MethodGet, http.MethodHead} { r.Handle(method, "/", func(c \*gin.Context) { c.String(http.StatusOK, "Ollama is running") })
 r.Handle(method, "/api/tags", s.ListModelsHandler) r.Handle(method, "/api/version", func(c \*gin.Context) { c.JSON(http.StatusOK, gin.H{"version": version.Version}) }) }
 return r}
func Serve(ln net.Listener) error { level := slog.LevelInfo if envconfig.Debug { level = slog.LevelDebug }
 slog.Info("server config", "env", envconfig.AsMap()) handler := slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{ Level: level, AddSource: true, ReplaceAttr: func(\_ []string, attr slog.Attr) slog.Attr { if attr.Key == slog.SourceKey { source := attr.Value.Any().(\*slog.Source) source.File = filepath.Base(source.File) }
 return attr },[View remainder of file in raw view](https://github.com/ollama/ollama/raw/adeb40eaf29039b8964425f69a9315f9f1694ba8/server/routes.go)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_1a3cb599_20250111_200712.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Follama%2Follama%2Fblob%2F9164b0161bcb24e543cba835a8863b80af2c0c21%2Fserver%2Froutes.go)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Follama%2Follama%2Fblob%2F9164b0161bcb24e543cba835a8863b80af2c0c21%2Fserver%2Froutes.go)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=ollama%2Follama)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[ollama](/ollama)
/
**[ollama](/ollama/ollama)**
Public

* [Notifications](/login?return_to=%2Follama%2Follama) You must be signed in to change notification settings
* [Fork
  8.6k](/login?return_to=%2Follama%2Follama)
* [Star
   107k](/login?return_to=%2Follama%2Follama)

* [Code](/ollama/ollama)
* [Issues
  1.1k](/ollama/ollama/issues)
* [Pull requests
  183](/ollama/ollama/pulls)
* [Actions](/ollama/ollama/actions)
* [Security](/ollama/ollama/security)
* [Insights](/ollama/ollama/pulse)

Additional navigation options

* [Code](/ollama/ollama)
* [Issues](/ollama/ollama/issues)
* [Pull requests](/ollama/ollama/pulls)
* [Actions](/ollama/ollama/actions)
* [Security](/ollama/ollama/security)
* [Insights](/ollama/ollama/pulse)

## Files

 9164b01
## Breadcrumbs

1. [ollama](/ollama/ollama/tree/9164b0161bcb24e543cba835a8863b80af2c0c21)
2. /[server](/ollama/ollama/tree/9164b0161bcb24e543cba835a8863b80af2c0c21/server)
/
# routes.go

Copy path Blame  Blame
## Latest commit

## History

[History](/ollama/ollama/commits/9164b0161bcb24e543cba835a8863b80af2c0c21/server/routes.go)1351 lines (1142 loc) · 32.2 KB 9164b01
## Breadcrumbs

1. [ollama](/ollama/ollama/tree/9164b0161bcb24e543cba835a8863b80af2c0c21)
2. /[server](/ollama/ollama/tree/9164b0161bcb24e543cba835a8863b80af2c0c21/server)
/
# routes.go

Top
## File metadata and controls

* Code
* Blame

1351 lines (1142 loc) · 32.2 KB[Raw](https://github.com/ollama/ollama/raw/9164b0161bcb24e543cba835a8863b80af2c0c21/server/routes.go)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000package server
import ( "context" "encoding/json" "errors" "fmt" "io" "io/fs" "log/slog" "math" "net" "net/http" "net/netip" "os" "os/signal" "path/filepath" "strconv" "strings" "syscall" "time"
 "github.com/gin-contrib/cors" "github.com/gin-gonic/gin" "golang.org/x/exp/slices"
 "github.com/ollama/ollama/api" "github.com/ollama/ollama/gpu" "github.com/ollama/ollama/llm" "github.com/ollama/ollama/openai" "github.com/ollama/ollama/parser" "github.com/ollama/ollama/types/model" "github.com/ollama/ollama/version")
var mode string = gin.DebugMode
type Server struct { addr net.Addr sched \*Scheduler}
func init() { switch mode { case gin.DebugMode: case gin.ReleaseMode: case gin.TestMode: default: mode = gin.DebugMode }
 gin.SetMode(mode)}
var defaultSessionDuration = 5 \* time.Minute
func modelOptions(model \*Model, requestOpts map[string]interface{}) (api.Options, error) { opts := api.DefaultOptions() if err := opts.FromMap(model.Options); err != nil { return api.Options{}, err }
 if err := opts.FromMap(requestOpts); err != nil { return api.Options{}, err }
 return opts, nil}
func isSupportedImageType(image []byte) bool { contentType := http.DetectContentType(image) allowedTypes := []string{"image/jpeg", "image/jpg", "image/png"} return slices.Contains(allowedTypes, contentType)}
func (s \*Server) GenerateHandler(c \*gin.Context) {
 checkpointStart := time.Now() var req api.GenerateRequest err := c.ShouldBindJSON(&req)
 switch { case errors.Is(err, io.EOF): c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "missing request body"}) return case err != nil: c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 // validate the request switch { case req.Model == "": c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "model is required"}) return case len(req.Format) > 0 && req.Format != "json": c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "format must be json"}) return case req.Raw && (req.Template != "" || req.System != "" || len(req.Context) > 0): c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "raw mode does not support template, system, or context"}) return }
 for \_, img := range req.Images { if !isSupportedImageType(img) { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "unsupported image format"}) return } }
 model, err := GetModel(req.Model) if err != nil { var pErr \*fs.PathError if errors.As(err, &pErr) { c.JSON(http.StatusNotFound, gin.H{"error": fmt.Sprintf("model '%s' not found, try pulling it first", req.Model)}) return } c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 if model.IsEmbedding() { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "embedding models do not support generate"}) return }
 opts, err := modelOptions(model, req.Options) if err != nil { if errors.Is(err, api.ErrInvalidOpts) { c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return } c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 var sessionDuration time.Duration if req.KeepAlive == nil { sessionDuration = getDefaultSessionDuration() } else { sessionDuration = req.KeepAlive.Duration }
 rCh, eCh := s.sched.GetRunner(c.Request.Context(), model, opts, sessionDuration) var runner \*runnerRef select { case runner = <-rCh: case err = <-eCh: if errors.Is(err, context.Canceled) { c.JSON(499, gin.H{"error": "request canceled"}) return }
 c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 // an empty request loads the model // note: for a short while template was used in lieu // of `raw` mode so we need to check for it too if req.Prompt == "" && req.Template == "" && req.System == "" { c.JSON(http.StatusOK, api.GenerateResponse{ CreatedAt: time.Now().UTC(), Model: req.Model, Done: true, }) return }
 checkpointLoaded := time.Now()
 var prompt string switch { case req.Raw: prompt = req.Prompt case req.Prompt != "": if req.Template == "" { req.Template = model.Template }
 if req.System == "" { req.System = model.System }
 slog.Debug("generate handler", "prompt", req.Prompt) slog.Debug("generate handler", "template", req.Template) slog.Debug("generate handler", "system", req.System)
 var sb strings.Builder for i := range req.Images { fmt.Fprintf(&sb, "[img-%d] ", i) }
 sb.WriteString(req.Prompt)
 p, err := Prompt(req.Template, req.System, sb.String(), "", true) if err != nil { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 sb.Reset() if req.Context != nil { prev, err := runner.llama.Detokenize(c.Request.Context(), req.Context) if err != nil { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 sb.WriteString(prev) }
 sb.WriteString(p)
 prompt = sb.String() }
 slog.Debug("generate handler", "prompt", prompt)
 ch := make(chan any) var generated strings.Builder go func() { defer close(ch)
 fn := func(r llm.CompletionResponse) { // Build up the full response if \_, err := generated.WriteString(r.Content); err != nil { ch <- gin.H{"error": err.Error()} return }
 resp := api.GenerateResponse{ Model: req.Model, CreatedAt: time.Now().UTC(), Done: r.Done, Response: r.Content, Metrics: api.Metrics{ PromptEvalCount: r.PromptEvalCount, PromptEvalDuration: r.PromptEvalDuration, EvalCount: r.EvalCount, EvalDuration: r.EvalDuration, }, }
 if r.Done { resp.TotalDuration = time.Since(checkpointStart) resp.LoadDuration = checkpointLoaded.Sub(checkpointStart)
 if !req.Raw { p, err := Prompt(req.Template, req.System, req.Prompt, generated.String(), false) if err != nil { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 // TODO (jmorganca): encode() should not strip special tokens tokens, err := runner.llama.Tokenize(c.Request.Context(), p) if err != nil { ch <- gin.H{"error": err.Error()} return }
 resp.Context = append(req.Context, tokens...) } }
 ch <- resp }
 var images []llm.ImageData for i := range req.Images { images = append(images, llm.ImageData{ ID: i, Data: req.Images[i], }) }
 // Start prediction req := llm.CompletionRequest{ Prompt: prompt, Format: req.Format, Images: images, Options: opts, } if err := runner.llama.Completion(c.Request.Context(), req, fn); err != nil { ch <- gin.H{"error": err.Error()} } }()
 if req.Stream != nil && !\*req.Stream { // Accumulate responses into the final response var final api.GenerateResponse var sb strings.Builder for resp := range ch { switch r := resp.(type) { case api.GenerateResponse: sb.WriteString(r.Response) final = r case gin.H: if errorMsg, ok := r["error"].(string); ok { c.JSON(http.StatusInternalServerError, gin.H{"error": errorMsg}) return } else { c.JSON(http.StatusInternalServerError, gin.H{"error": "unexpected error format in response"}) return } default: c.JSON(http.StatusInternalServerError, gin.H{"error": "unexpected error"}) return } }
 final.Response = sb.String() c.JSON(http.StatusOK, final) return }
 streamResponse(c, ch)}
func getDefaultSessionDuration() time.Duration { if t, exists := os.LookupEnv("OLLAMA\_KEEP\_ALIVE"); exists { v, err := strconv.Atoi(t) if err != nil { d, err := time.ParseDuration(t) if err != nil { return defaultSessionDuration }
 if d < 0 { return time.Duration(math.MaxInt64) }
 return d }
 d := time.Duration(v) \* time.Second if d < 0 { return time.Duration(math.MaxInt64) } return d }
 return defaultSessionDuration}
func (s \*Server) EmbeddingsHandler(c \*gin.Context) { var req api.EmbeddingRequest err := c.ShouldBindJSON(&req) switch { case errors.Is(err, io.EOF): c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "missing request body"}) return case err != nil: c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 if req.Model == "" { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "model is required"}) return }
 model, err := GetModel(req.Model) if err != nil { var pErr \*fs.PathError if errors.As(err, &pErr) { c.JSON(http.StatusNotFound, gin.H{"error": fmt.Sprintf("model '%s' not found, try pulling it first", req.Model)}) return } c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 opts, err := modelOptions(model, req.Options) if err != nil { if errors.Is(err, api.ErrInvalidOpts) { c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return } c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 var sessionDuration time.Duration if req.KeepAlive == nil { sessionDuration = getDefaultSessionDuration() } else { sessionDuration = req.KeepAlive.Duration }
 rCh, eCh := s.sched.GetRunner(c.Request.Context(), model, opts, sessionDuration) var runner \*runnerRef select { case runner = <-rCh: case err = <-eCh: if errors.Is(err, context.Canceled) { c.JSON(499, gin.H{"error": "request canceled"}) return }
 c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 // an empty request loads the model if req.Prompt == "" { c.JSON(http.StatusOK, api.EmbeddingResponse{Embedding: []float64{}}) return }
 embedding, err := runner.llama.Embedding(c.Request.Context(), req.Prompt) if err != nil { slog.Info(fmt.Sprintf("embedding generation failed: %v", err)) c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to generate embedding"}) return }
 resp := api.EmbeddingResponse{ Embedding: embedding, } c.JSON(http.StatusOK, resp)}
func (s \*Server) PullModelHandler(c \*gin.Context) { var req api.PullRequest err := c.ShouldBindJSON(&req) switch { case errors.Is(err, io.EOF): c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "missing request body"}) return case err != nil: c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 var model string if req.Model != "" { model = req.Model } else if req.Name != "" { model = req.Name } else { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "model is required"}) return }
 ch := make(chan any) go func() { defer close(ch) fn := func(r api.ProgressResponse) { ch <- r }
 regOpts := &registryOptions{ Insecure: req.Insecure, }
 ctx, cancel := context.WithCancel(c.Request.Context()) defer cancel()
 if err := PullModel(ctx, model, regOpts, fn); err != nil { ch <- gin.H{"error": err.Error()} } }()
 if req.Stream != nil && !\*req.Stream { waitForStream(c, ch) return }
 streamResponse(c, ch)}
func (s \*Server) PushModelHandler(c \*gin.Context) { var req api.PushRequest err := c.ShouldBindJSON(&req) switch { case errors.Is(err, io.EOF): c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "missing request body"}) return case err != nil: c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 var model string if req.Model != "" { model = req.Model } else if req.Name != "" { model = req.Name } else { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "model is required"}) return }
 ch := make(chan any) go func() { defer close(ch) fn := func(r api.ProgressResponse) { ch <- r }
 regOpts := &registryOptions{ Insecure: req.Insecure, }
 ctx, cancel := context.WithCancel(c.Request.Context()) defer cancel()
 if err := PushModel(ctx, model, regOpts, fn); err != nil { ch <- gin.H{"error": err.Error()} } }()
 if req.Stream != nil && !\*req.Stream { waitForStream(c, ch) return }
 streamResponse(c, ch)}
func (s \*Server) CreateModelHandler(c \*gin.Context) { var req api.CreateRequest err := c.ShouldBindJSON(&req) switch { case errors.Is(err, io.EOF): c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "missing request body"}) return case err != nil: c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 var model string if req.Model != "" { model = req.Model } else if req.Name != "" { model = req.Name } else { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "model is required"}) return }
 if err := ParseModelPath(model).Validate(); err != nil { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 if req.Path == "" && req.Modelfile == "" { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "path or modelfile are required"}) return }
 var modelfile io.Reader = strings.NewReader(req.Modelfile) if req.Path != "" && req.Modelfile == "" { mf, err := os.Open(req.Path) if err != nil { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("error reading modelfile: %s", err)}) return } defer mf.Close()
 modelfile = mf }
 commands, err := parser.Parse(modelfile) if err != nil { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 ch := make(chan any) go func() { defer close(ch) fn := func(resp api.ProgressResponse) { ch <- resp }
 ctx, cancel := context.WithCancel(c.Request.Context()) defer cancel()
 if err := CreateModel(ctx, model, filepath.Dir(req.Path), req.Quantization, commands, fn); err != nil { ch <- gin.H{"error": err.Error()} } }()
 if req.Stream != nil && !\*req.Stream { waitForStream(c, ch) return }
 streamResponse(c, ch)}
func (s \*Server) DeleteModelHandler(c \*gin.Context) { var req api.DeleteRequest err := c.ShouldBindJSON(&req) switch { case errors.Is(err, io.EOF): c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "missing request body"}) return case err != nil: c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 var model string if req.Model != "" { model = req.Model } else if req.Name != "" { model = req.Name } else { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "model is required"}) return }
 if err := DeleteModel(model); err != nil { if os.IsNotExist(err) { c.JSON(http.StatusNotFound, gin.H{"error": fmt.Sprintf("model '%s' not found", model)}) } else { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) } return }
 manifestsPath, err := GetManifestPath() if err != nil { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 if err := PruneDirectory(manifestsPath); err != nil { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 c.JSON(http.StatusOK, nil)}
func (s \*Server) ShowModelHandler(c \*gin.Context) { var req api.ShowRequest err := c.ShouldBindJSON(&req) switch { case errors.Is(err, io.EOF): c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "missing request body"}) return case err != nil: c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 if req.Model != "" { // noop } else if req.Name != "" { req.Model = req.Name } else { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "model is required"}) return }
 resp, err := GetModelInfo(req) if err != nil { if os.IsNotExist(err) { c.JSON(http.StatusNotFound, gin.H{"error": fmt.Sprintf("model '%s' not found", req.Model)}) } else { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) } return }
 c.JSON(http.StatusOK, resp)}
func GetModelInfo(req api.ShowRequest) (\*api.ShowResponse, error) { model, err := GetModel(req.Model) if err != nil { return nil, err }
 modelDetails := api.ModelDetails{ ParentModel: model.ParentModel, Format: model.Config.ModelFormat, Family: model.Config.ModelFamily, Families: model.Config.ModelFamilies, ParameterSize: model.Config.ModelType, QuantizationLevel: model.Config.FileType, }
 if req.System != "" { model.System = req.System }
 if req.Template != "" { model.Template = req.Template }
 msgs := make([]api.Message, 0) for \_, msg := range model.Messages { msgs = append(msgs, api.Message{Role: msg.Role, Content: msg.Content}) }
 resp := &api.ShowResponse{ License: strings.Join(model.License, "\n"), System: model.System, Template: model.Template, Details: modelDetails, Messages: msgs, }
 var params []string cs := 30 for k, v := range model.Options { switch val := v.(type) { case []interface{}: for \_, nv := range val { params = append(params, fmt.Sprintf("%-\*s %#v", cs, k, nv)) } default: params = append(params, fmt.Sprintf("%-\*s %#v", cs, k, v)) } } resp.Parameters = strings.Join(params, "\n")
 for k, v := range req.Options { if \_, ok := req.Options[k]; ok { model.Options[k] = v } }
 mf, err := ShowModelfile(model) if err != nil { return nil, err }
 resp.Modelfile = mf
 return resp, nil}
func (s \*Server) ListModelsHandler(c \*gin.Context) { models := make([]api.ModelResponse, 0) manifestsPath, err := GetManifestPath() if err != nil { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 modelResponse := func(modelName string) (api.ModelResponse, error) { model, err := GetModel(modelName) if err != nil { return api.ModelResponse{}, err }
 modelDetails := api.ModelDetails{ Format: model.Config.ModelFormat, Family: model.Config.ModelFamily, Families: model.Config.ModelFamilies, ParameterSize: model.Config.ModelType, QuantizationLevel: model.Config.FileType, }
 return api.ModelResponse{ Model: model.ShortName, Name: model.ShortName, Size: model.Size, Digest: model.Digest, Details: modelDetails, }, nil }
 walkFunc := func(path string, info os.FileInfo, \_ error) error { if !info.IsDir() { path, tag := filepath.Split(path) model := strings.Trim(strings.TrimPrefix(path, manifestsPath), string(os.PathSeparator)) modelPath := strings.Join([]string{model, tag}, ":") canonicalModelPath := strings.ReplaceAll(modelPath, string(os.PathSeparator), "/")
 resp, err := modelResponse(canonicalModelPath) if err != nil { slog.Info(fmt.Sprintf("skipping file: %s", canonicalModelPath)) // nolint: nilerr return nil }
 resp.ModifiedAt = info.ModTime() models = append(models, resp) }
 return nil }
 if err := filepath.Walk(manifestsPath, walkFunc); err != nil { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 c.JSON(http.StatusOK, api.ListResponse{Models: models})}
func (s \*Server) CopyModelHandler(c \*gin.Context) { var r api.CopyRequest if err := c.ShouldBindJSON(&r); errors.Is(err, io.EOF) { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "missing request body"}) return } else if err != nil { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 src := model.ParseName(r.Source) if !src.IsValid() { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("source %q is invalid", r.Source)}) return }
 dst := model.ParseName(r.Destination) if !dst.IsValid() { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("destination %q is invalid", r.Source)}) return }
 if err := CopyModel(src, dst); errors.Is(err, os.ErrNotExist) { c.JSON(http.StatusNotFound, gin.H{"error": fmt.Sprintf("model %q not found", r.Source)}) } else if err != nil { c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) }}
func (s \*Server) HeadBlobHandler(c \*gin.Context) { path, err := GetBlobsPath(c.Param("digest")) if err != nil { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 if \_, err := os.Stat(path); err != nil { c.AbortWithStatusJSON(http.StatusNotFound, gin.H{"error": fmt.Sprintf("blob %q not found", c.Param("digest"))}) return }
 c.Status(http.StatusOK)}
func (s \*Server) CreateBlobHandler(c \*gin.Context) { path, err := GetBlobsPath(c.Param("digest")) if err != nil { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": err.Error()}) return }
 \_, err = os.Stat(path) switch { case errors.Is(err, os.ErrNotExist): // noop case err != nil: c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return default: c.Status(http.StatusOK) return }
 layer, err := NewLayer(c.Request.Body, "") if err != nil { c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 if layer.Digest != c.Param("digest") { c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("digest mismatch, expected %q, got %q", c.Param("digest"), layer.Digest)}) return }
 if \_, err := layer.Commit(); err != nil { c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) return }
 c.Status(http.StatusCreated)}
var defaultAllowOrigins = []string{ "localhost", "127.0.0.1", "0.0.0.0",}
func isLocalIP(ip netip.Addr) bool { if interfaces, err := net.Interfaces(); err == nil { for \_, iface := range interfaces { addrs, err := iface.Addrs() if err != nil { continue }
 for \_, a := range addrs { if parsed, \_, err := net.ParseCIDR(a.String()); err == nil { if parsed.String() == ip.String() { return true } } } } }
 return false}
func allowedHost(host string) bool { if host == "" || host == "localhost" { return true }
 if hostname, err := os.Hostname(); err == nil && host == hostname { return true }
 var tlds = []string{ "localhost", "local", "internal", }
 // check if the host is a local TLD for \_, tld := range tlds { if strings.HasSuffix(host, "."+tld) { return true } }
 return false}
func allowedHostsMiddleware(addr net.Addr) gin.HandlerFunc { return func(c \*gin.Context) { if addr == nil { c.Next() return }
 if addr, err := netip.ParseAddrPort(addr.String()); err == nil && !addr.Addr().IsLoopback() { c.Next() return }
 host, \_, err := net.SplitHostPort(c.Request.Host) if err != nil { host = c.Request.Host }
 if addr, err := netip.ParseAddr(host); err == nil { if addr.IsLoopback() || addr.IsPrivate() || addr.IsUnspecified() || isLocalIP(addr) { c.Next() return } }
 if allowedHost(host) { c.Next() return }
 c.AbortWithStatus(http.StatusForbidden) }}
func (s \*Server) GenerateRoutes() http.Handler { config := cors.DefaultConfig() config.AllowWildcard = true config.AllowBrowserExtensions = true
 if allowedOrigins := strings.Trim(os.Getenv("OLLAMA\_ORIGINS"), "\"'"); allowedOrigins != "" { config.AllowOrigins = strings.Split(allowedOrigins, ",") }
 for \_, allowOrigin := range defaultAllowOrigins { config.AllowOrigins = append(config.AllowOrigins, fmt.Sprintf("http://%s", allowOrigin), fmt.Sprintf("https://%s", allowOrigin), fmt.Sprintf("http://%s:\*", allowOrigin), fmt.Sprintf("https://%s:\*", allowOrigin), ) }
 r := gin.Default() r.Use( cors.New(config), allowedHostsMiddleware(s.addr), )
 r.POST("/api/pull", s.PullModelHandler) r.POST("/api/generate", s.GenerateHandler) r.POST("/api/chat", s.ChatHandler) r.POST("/api/embeddings", s.EmbeddingsHandler) r.POST("/api/create", s.CreateModelHandler) r.POST("/api/push", s.PushModelHandler) r.POST("/api/copy", s.CopyModelHandler) r.DELETE("/api/delete", s.DeleteModelHandler) r.POST("/api/show", s.ShowModelHandler)[View remainder of file in raw view](https://github.com/ollama/ollama/raw/9164b0161bcb24e543cba835a8863b80af2c0c21/server/routes.go)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from www.oligo.security_a286c873_20250111_200715.html ===


ProductPRODUCT[Oligo FocusFix only what matters](/product/oligo-focus)[Oligo ADRStop attacks before they impact your business](/product/oligo-adr)SolutionsSolutions[Real-Time Scanning and Monitoring](/solution/vulnerability-scanning)[Real-Time BOM /VEX](/solution/real-time-bom)[Supply Chain Security](/solution/supply-chain-security)[Application Vulnerability Management](/solution/application-security-posture)[Attack Detection and Response](/solution/detection-and-incident-response)[Compliance and Assurance](/solution/compliance)ResourcesResources[Resource Center](/resource-center)[Blog](/resources/blog)[News](/resources/news)[Events](/resources/events)[Webinars & Videos](/resource-center?category=Webinars+%26+Videos)[Whitepapers](/resource-center?category=Whitepapers)CompanyCompany[About us](/company/about)[![](https://cdn.prod.website-files.com/63dbb928e89213590c5bfd53/666580339802ccd65553400e_Group%201000016926.png)Why Oligo](/company/whyoligo)[Careers](/company/careers)[Customers](/resources/case-studies)menuProductPRODUCT[Oligo FocusFix only what matters](/product/oligo-focus)[Oligo ADRStop attach before they impact your business](/product/oligo-adr)SolutionsSolutions[Real-Time Scanning and MonitoringFix only what matters](/solution/vulnerability-scanning)[Real-Time BOM /VEXStop attach before they impact your business](/solution/real-time-bom)[Supply Chain SecurityStop attach before they impact your business](/solution/supply-chain-security)[Application Vulnerability ManagementStop attach before they impact your business](/solution/application-security-posture)[Attack Detection and ResponseStop attach before they impact your business](/solution/detection-and-incident-response)[CompliaCompliance and AssurancenceStop attach before they impact your business](/solution/compliance)ResourcesResources[Resource CenterEngaging discussions on the latest runtime security](/resource-center)[BlogDeep dives into recent trends, updates and insights](/resources/blog)[NewsLatest announcements & security updates](/resources/news)[EventsJoin us at upcoming security events and workshops](/resources/events)[Webinars & VideosSee how businesses enhance their security posture](/resource-center?category=Webinars+%26+Videos)[WhitepapersSee how businesses enhance their security posture](/resource-center?category=Whitepapers)CompanyCompany[About usFix only what matters](/company/about)[Why OligoStop attach before they impact your business](/company/whyoligo)[CareersStop attach before they impact your business](/company/careers)[Customers](/resources/case-studies)[Contact](/contact)[Book a Demo](/demo)ResearchÂ Â Â min read
# More Models, More ProbLLMs

![Avi Lumelsky](https://cdn.prod.website-files.com/63e8dd453f71270c6845992b/65fbd7d106f822c9e08dcb85_Avi-Lumelsky.webp)![]()![]()Avi Lumelsky,,October 30, 2024Copied to Clipboardhttps://www.oligo.security/blog/more-models-more-probllms
### Overview

Â Â Â

[â](#1)

## TL;DR

Oligoâs research team recently uncovered **6 vulnerabilities** in Ollama, one of the leading open-source frameworks for running AI models. Four of the flaws received CVEs and were patched in a recent version, while two were disputed by the applicationâs maintainers, making them [shadow vulnerabilities](https://www.oligo.security/blog/shining-a-light-on-shadow-vulnerabilities).

Collectively, the vulnerabilities could allow an attacker to carry out a wide-range of malicious actions with a single HTTPÂ request, including Denial of Service (DoS) attacks, model poisoning, model theft, and more. With Ollamaâs enterprise use skyrocketing, it is pivotal that development and security teams fully understand the associated risks and urgency to ensure that vulnerable versions of the application arenât being used in their environments.

1. â[Ollama Background](#1)
2. [Our Findings](#2)
3. [CVE-2024-39720 - Out-of-bounds Read leading to Denial of Service (CWE-125)](#4)
4. [CVE-2024-39722 - File existence disclosure (CWE-22)](#5)
5. [CVE-2024-39719 - File existence disclosure (CWE-497)](#6)
6. [CVE-2024-39721 - Infinite Loops and Denial of Service (CWE-400)](#7)
7. [Model Poisoning (CWE-668)](#9)
8. [Model Theft (CWE-285)](#10)
9. [Internet Facing Servers](#11)

## Ollama Background

[Ollama](https://ollama.com/) is an open-source application that allows users to operate large language models (LLMs) locally on personal or corporate hardware. It is one of the most widely-used open-source projects for AI models, with over 93k stars on GitHub. Due to its simplicity, Ollama has quickly risen in popularity for enterprise use, as organizations look to benefit from the productivity gains delivered by LLMs.

When we started our research, Ollama had ~**64K** stars on GitHub. It is mostly used for local inference on CPUs, but it is also used by organizations around the world for cloud deployment of open-source and private models. Ollama is known to be robust, and it supports CPUs (x84, ARM), NVIDIA GPUs and Apple Metal out of the box (thanks to llama.cpp).

![](https://cdn.prod.website-files.com/63e8dd453f71270c6845992b/6722135d5f24ef509ae94eb4_AD_4nXem9X31qCVKlc0nbYydtsXfZjSbZZz6bOau-kmv-WdXqi7VgmKrqZ9eymDaM2yhywkZcMTa0g4v1PiACUiBnAzZAWeYTxWEAJHrEiuRq7XABMkVpc2WuEZHqD86JDv065uUGQRu1ncmZH-tKRLXOyxHDYU4.png)

Now, only 3 months later, Ollama has **94K** stars, a 46% increase!

![](https://cdn.prod.website-files.com/63e8dd453f71270c6845992b/6722135d27a90cb98104afcf_AD_4nXcp1Z8PSw8d-yfNDqGXJxv7kYmFfG8V0lcpoDY6B0USSwtdfsL5A_ArswD9APLUogVgwQPituwm_DwtbNe7hv_xLYeznUw5hPPmh3v22lYIrOAPD6bzjKMHDvmFEUva_egUA82aRL6s6DCcNlisZ1p-Pqo.png)

In the figure above, we compared the stars of [ollama](https://github.com/ollama/ollama), [pytorch](https://github.com/pytorch/pytorch) and [llama.cpp](https://github.com/ggerganov/llama.cpp) (ollamaâs core inference code) through time. Ollama is relatively new, but it has more stars than [pytorch](https://github.com/pytorch/pytorch), and even surpassed [llama.cpp](https://github.com/ggerganov/llama.cpp), the famous LLM inference codebase that Ollama is based on.

## Our Findings

Oligoâs research team recently uncovered **6 vulnerabilities** in the Ollama framework, with four patched in Version 0.1.47, and **two shadow vulnerabilities** that have been disputed by Ollama maintainers:

* **CVE-2024-39722:** Exposes the files that exist on the server on which Ollama is deployed, via path traversal in the API/push route.**Â**
* **CVE-2024-39721:** Allows denial-of-service (DoS) attacks through the CreateModel API route via a single HTTP request.Â
* **CVE-2024-39720:** Enables attackers to crash the application through the CreateModel route, leading to a segmentation fault.
* **CVE-2024-39719:** Provides a primitive for file existence on the server, making it easier for threat actors to further abuse the application.Â **â**
* **Model Poisoning (CWE-668):** A client can pull a model from an unverified HTTP source by using the /api/pull route if it lacks special authorization.**â**
* **Model Theft (CWE-285)**: A client can push a model to an unverified (HTTP) source by using the /api/push route as it lacks any form of authorization.

## **CVEs**

### **1.** [**CVE-2024-39720**](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-39720) **-** Out-of-bounds Read leading to Denial of Service (CWE-125)

URI: /api/create
Method: POST
User Interaction: None **Scope:** Ollama <= 0.1.45 is vulnerable. Fixed in version 0.1.46. **Effect:** Denial of ServiceÂ  **Technical Details:** This vulnerability allows an attacker to use two HTTP requests to upload a malformed GGUF file containing just 4 bytes starting with the GGUF custom magic header. By leveraging a custom Modelfile that includes a FROM statement pointing to the attacker-controlled blob file, the attacker can crash the application through the CreateModel route, leading to a segmentation fault (signal SIGSEGV: segmentation violation).

![](https://cdn.prod.website-files.com/63e8dd453f71270c6845992b/6722135d145c06d73bbf9ad9_AD_4nXc0iN51pvB49thrncC0GML1L2FxN3v7Cns6fxoIAU4EQ92ArM2LdiF0MQ839N-63ZOslLOFIamYiMpg3WdykEpcM-3W9GkxcPHKeOK90O_uT8FOxLZPFmTg9HAoyAjyzxjbBBbg0lMQ12PYGkzom7uwLJXE.png)![](https://cdn.prod.website-files.com/63e8dd453f71270c6845992b/6722135d64044956c8c87391_AD_4nXfk3sjkRSiAkVqMU_-EzoJsHC4Nv5MMyB4Tvovi2kVLnbJEChQKeqADIygkUEyadJobBRv0Y5XtPDFLERX9LX_e3MBwDEjr4MeC2Ug6OE5TjIB-07iKeGpH_yFvHvGgo4ckAPQO9Nqsoit1jDUA5ard6e3B.gif)

**References:**

* [https://github.com/ollama/ollama/server/routes.go:534](https://github.com/ollama/ollama/server/routes.go%3A534)
* [https://github.com/ollama/ollama/server/routes.go:554](https://github.com/ollama/ollama/server/routes.go%3A554)
* [https://github.com/ollama/ollama/server/routes.go:563](https://github.com/ollama/ollama/server/routes.go%3A554)
* <https://github.com/ollama/ollama/compare/v0.1.45...v0.1.46#diff-782c2737eecfa83b7cb46a77c8bdaf40023e7067baccd4f806ac5517b4563131L417>

## 2. [**CVE-2024-39722**](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-39722) - File existence disclosure (CWE-22)

URI: api/push
Method: POST
User Interaction: None
**Scope**: Ollama <= 0.1.45 is vulnerable. Fixed in version 0.1.46.
**Description**: Ollama exposes which files exist on the server on which it is deployed via path traversal in the api/push route.
**Technical Details:** When calling the api/push route with a path parameter that does not exist, it reflects the escaped URI to the attacker, providing a primitive for file existence on the server and user that executes it, making it easier for Threat Actors to abuse the application further.
**Example Payload:** The example payload will expose the server directory structure via the HTTP
response:

`{"error":"stat /root/.ollama/models/manifests/registry.ollama.ai/library/latest:
no such file or directory"}
~/ curl <http://127.0.0.1:11434/api/push> -d '{
Â Â "name": "../../../test../../../:../../../test../../../", "insecure":true, "stream": true
}'

{"status":"retrieving manifest"}
{"status":"couldn't retrieve manifest"}
{"error":"stat /root/.ollama/models/manifests/registry.ollama.ai/library/latest:
no such file or directory"}`

#### **References:**

* <https://github.com/ollama/ollama/compare/v0.1.45...v0.1.46>

### 3. [**CVE-2024-39719**](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-39719) - File existence disclosure (CWE-497)

URI: api/create
Method: POST
User Interaction: None **Scope:** Not fixed, as of version 0.3.14. **Description:** Ollama exposes which files exist on the server on which it is deployed. **Technical Details:** When calling the CreateModel route with a path parameter that does not exist, Ollama reflects the âFile does not existâ error to the attacker, providing a primitive for file existence on the server and making it easier for threat actors to abuse the application further.
The attacker has reflection of the [os.Stat](https://cs.opensource.google/go/go/%2B/refs/tags/go1.23.2%3Asrc/os/stat_unix.go;l=15) command output, and has control of the file path.

`~/ curl "<http://localhost:11434/api/create>" -d '{"name": "file-leak-existence","path": "/tmp/aasd.txt"}'
{"error":"error reading modelfile: open /tmp/aasd.txt: no such file or directory"}%`

**Examples:**
Calling the endpoint with a file that does not exist:

* ~/ curl "http://localhost:11434/api/create" -d '{"name": "file-leak-existence","path": "/tmp/non-existing"}'
  + {"error":"error reading modelfile: open /tmp/non-existing: no such file or directory"}%
* With a file that exists:
  + ~/ curl http://localhost:11434/api/create -d '{"name": "file-leak-existence","path": "/etc/passwd"}'
    - {"error":"command must be one of \"from\", \"license\", \"template\", \"system\", \"adapter\", \"parameter\", or \"message\""}%
* With a directory instead of file path:
  + ~/ curl http://localhost:11434/api/create -d '{"name": "file-leak-existence","path": "/etc"}'
    - {"error":"read /etc: is a directory"}%

#### **References:**

* <https://github.com/ollama/ollama/releases/tag/v0.1.47>
* [https://github.com/ollama/ollama/blob/cb42e607c5cf4d439ad4d5a93ed13c7d6a09fc34/server/images.go#L349](https://github.com/ollama/ollama/releases/tag/v0.1.47)

### 4. [**CVE-2024-39721**](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-39721) - Infinite Loops and Denial of Service(CWE-400)

URI: api/create
Method: POST
User Interaction: None **Scope:** Ollama <= 0.1.33 is vulnerable. **Description:** Versions of Ollama before 1.34 are vulnerable to a denial-of-service (DoS) attack through the CreateModel API route with a single HTTP request. **Technical Details:** The CreateModelHandler function uses [os.Open](https://docs.python.org/3/library/os.html) to read a file until completion. The req.Path parameter is user-controlled and can be set to /dev/random, which is blocking, causing the goroutine to run infinitely (even after the HTTP request is aborted by the client). This leads to extensive resource consumption in a never-ending loop. Calling the api/create endpoint multiple times with these parameters increases CPU usage on the impacted machine to 80-90%, and repetitive calls to this endpoint will rapidly cause denial of service.

### **Example Payload:**

`~/ curl <http://localhost:11434/api/create> -d '{
Â Â "name": "denial-of-service",
Â Â "path": "/dev/random"
}'`
`# OR simply
ollama serve &
curl "<http://localhost:11434/api/create>" -d '{"name": "dos","path": "/dev/random"}'`

**POC code:**
`# Run docker
docker run -p 11434:11434 --name ollama ollama/ollama
# DOS with single client request
curl "<http://localhost:11434/api/create>" -d '{"name": "dos","path": "/dev/random"}'`

#### **References:**

* <https://github.com/ollama/ollama/blob/9164b0161bcb24e543cba835a8863b80af2c0c21/server/routes.go#L557>
* <https://github.com/ollama/ollama/blob/adeb40eaf29039b8964425f69a9315f9f1694ba8/server/routes.go#L536>

### Disputed Vulnerabilities (Shadow Vulnerabilities)

Although we have reported 6 vulnerabilities, the maintainers of Ollama acknowledged only 4 of them while disputing 2. Ollamaâs maintainers disputed 2 of the vulnerabilities:

*â¦ we do recommend folks filter which endpoints are exposed to end-users using a web application, proxy or load balancer â¦*

Meaning that, by default, not all endpoints should be exposed. Thatâs a dangerous assumption. Not everybody is aware of that, or filters http routing to Ollama. Currently, these endpoints are available through the default port of Ollama as part of every deployment, without any separation or documentation to back it up.

### **5. Model Poisoning** (CWE-668)

URI: api/pull
Method: POST
User Interaction: None **Scope:** ollama <= 0.1.34 **Description:** Model Poisoning via the api/pull route from an untrusted source. **Technical Details:** A client can pull a model from an unverified (HTTP) source by using the /api/pull route if it lacks special authorization (vulnerable by default). An attacker can trigger the server to pull a model from the attacker controlled server. It widens the attack surface when working with file uploads, continuous call to this endpoint will download models until the disk is full, potentially leading to denial of service (DOS).

### **Example Payload:**

`curl <http://127.0.0.1:11434/api/pull> -d '{
Â Â "name": "any-name"
}'`

**References:**

* <https://github.com/ollama/ollama/blob/788b092c49d6fa889c911ed1d4eb2d01d944e1c3/llm/ext_server/server.cpp#L2101>

### **6. Model Theft** (CWE-285)

URI: /api/push
Method: POST
User Interaction: None **Scope:** ollama <= 0.1.34 **Description:** Model Theft in the api/push route to an untrusted target. **Technical Details:** A client can push a model to an unverified (HTTP) source by using the /api/push route as it lacks any form of authorization or authentication. This primitive enables attackers to steal every model that is stored on the server (and upload to a third party server) using a single HTTP request. Models are intellectual property, and for AI companies it can be the competitive advantage. Many Ollama users deploy private models that are not on [ollama.com/models](http://ollama.com/models) hub.

### **Example Payload:**

A /api/push HTTP request with insecure=True and attacker-controlled server will push the model to an untrusted, attacker-controlled source.
For comparison, TorchServe and Triton Inference Server both run the management service on a different port. We hope Ollama will do the same eventually - move the management endpoints to a different port. By separating the management routes, users that deploy with default configuration (and are unaware of the unsafe defaults that are not highlighted in the docs) will be less exposed to risks associated with these endpoints. We believe that only inference endpoints should be exposed by default. Many Ollama users are deploying the service as is, using the unsafe defaults.

## Internet Facing Servers

To assess the risk of this vulnerability being exploited in the wild, we tried to estimate how many vulnerable servers are exposed to the internet at the time of writing.
To create a distribution of the deployed versions on the internet, we sent HTTP requests to the public servers via [host:port]/api/version endpoint, which returns the versions of the installed Ollama servers as part of the response.
At the time of writing, there are around **10K unique internet-facing IPs** that run Ollama. 1 of every 4 internet-facing servers is vulnerable to these vulnerabilities uncovered by the Oligo research team.

![](https://cdn.prod.website-files.com/63e8dd453f71270c6845992b/6722135da92418a9c8e3bd16_AD_4nXeOPkYWKcNGR9KL54voMRIfEChr9sDkRqGwOQKPiHx-K_lGtWNAKKDvEijNBnt_TPgNK4UIeZzcxKYAAM4TWMMFvaoFDutasHT1qbViKb4dpnO2Gpqik09ECdzmqCR98XveGRlNvt24YY4_c_c0LY4xgS8.png)

Source: <https://en.fofa.info/result?qbase64=Im9sbGFtYSBpcyBydW5uaW5nIg%3D%3D>

![](https://cdn.prod.website-files.com/63e8dd453f71270c6845992b/6722135dc3e664992bc931c7_AD_4nXedDItoi3uOctlAJw8KZRXp2Ni4djExpgv3a3-pLuZxIAorVRg96917hNhf5WdSIkJenFoQui8YTXvuU4kGhHtDoSANaLwEu7ZzzruRL_F2E7gTF_kcEwq81AhSbAU5SkPOi7NKr03u1pLD5RlVG-9Ot-pu.png)![](https://cdn.prod.website-files.com/63e8dd453f71270c6845992b/6722135dedb15552d1e9232a_AD_4nXc2x9I2t4FMyXF--p7xAp7kzNZowWUjWzETKnJYlgsUouYv8rivy83fy5zFQmGhKzShNdvDA-NyT40w3tdzANmA4AWVw3rH898fq1RBNn9ph8b04k2V8Ner417CYqmJph10QzSudDqC1ADI1LAvGIFEiG69.png)

Censys and Shodan showed fewer results, and most of them were honeypots.

In June 2024, Wiz Research disclosed [Probllama](https://www.wiz.io/blog/probllama-ollama-vulnerability-cve-2024-37032) ([CVE-2024-37032](https://www.cve.org/CVERecord?id=CVE-2024-37032)), a vulnerability that enables remote code execution on the Ollama servers before 1.34.
Exposing Ollama to the internet without authorization is the equivalent to exposing the docker socket to the public internet, because it can upload files and has model pull and push capabilities (that can be abused by attackers).

## IoCs

| Name | Value | Notes |
| --- | --- | --- |
| SHA-256 hash of Modelfile that leads to denial of service; The string âGGUFâ encoded as bytes, followed by EOF. | b83633aa785344791618f2fddf131b010ea04912a60430760b070bad293f65bd | Ollama server containing a blob with this hash, means the vulnerable model was uploaded successfully using the blobs upload endpoint.If this file exists on your server blob files, it means the server is compromised. |

## Special Thanks

We would like to thank Ollamaâs maintainers, who were highly cooperative and fixed our findings quickly. Thank you for the amazing product you have built. We would also like to thank all previous Ollama security researchers for their responsible disclosures and keeping the community secure.

## Responsible Disclosure Timeline

Oligo have identified the CVEs when Ollamaâs latest release was Ollama v0.1.34 (which was released on May 7, 2024).

* May 18, 2024- Initial Report of 6 vulnerabilities
  + Oligo provided a full security report to Ollamaâs maintainers.
  + Ollamaâs maintainers responded with a PGP key.
  + Oligo encrypted the security report to Ollamaâs maintainers.
* May 21, 2024 - Follow Up by Oligo
* May 21, 2024 - Ollama Confirmed 4 out of the 6 vulnerabilities, started to work on a fix.
* Jun 4, 2024 - Follow Up by Oligo
* Jun 9, 2024- Fixed the DOS vulnerabilities in Ollama Server version (Patched in release 0.1.46).
* Jun 26, 2024- Oligo asked MITRE to issue CVEs for the 4 vulnerabilities.
* Jun 28, 2024- MITRE issued CVEs: [CVE-2024-39720](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-39720), [CVE-2024-39721](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-39721), [CVE-2024-39722](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-39722), [CVE-2024-39719](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-39719)
* Aug 16, 2024 End of responsible disclosure (90 days since initial report)
* Oct 30, 2024 Oligo published this advisory.
## Related Posts

[![](https://cdn.prod.website-files.com/63e8dd453f71270c6845992b/66f86067f4ec4031863dd759_open%20graph%20imahe-%20cups%20(2).png)AllResearch
### New Remote Code Execution (RCE) Vulnerabilities in CUPS for Linux: Threats and Mitigations

![](https://cdn.prod.website-files.com/63e8dd453f71270c6845992b/65fbd7d106f822c9e08dcb85_Avi-Lumelsky.webp)![](https://cdn.prod.website-files.com/63e8dd453f71270c6845992b/660c33d252e4d8e5e6c2c245_T031M0HCR88-U05QB8P8EBH-278918b3a1d0-512.webp)![]()Avi Lumelsky,Uri Katz,September 28, 2024](/blog/new-remote-code-execution-vulnerabilities-in-cups-for-linux-threats-and-mitigations)[![](https://cdn.prod.website-files.com/63e8dd453f71270c6845992b/66ec1a3228b93c0a5c225fce_open%20graph%20(3).png)AllResearch
### Shining a Light on Shadow Vulnerabilities

![](https://cdn.prod.website-files.com/63e8dd453f71270c6845992b/65fbd7d106f822c9e08dcb85_Avi-Lumelsky.webp)![](https://cdn.prod.website-files.com/63e8dd453f71270c6845992b/651c02da27d2a4f4f97b5e79_Ellipse%203618.webp)![]()Avi Lumelsky,Gal Elbaz,September 19, 2024](/blog/shining-a-light-on-shadow-vulnerabilities)[![](https://cdn.prod.website-files.com/63e8dd453f71270c6845992b/66c310df32476ae409cf1d48_thumnail.png)AllResearch
### TensorFlow Keras Downgrade Attack: CVE-2024-3660 Bypass

![](https://cdn.prod.website-files.com/63e8dd453f71270c6845992b/65fbd7d106f822c9e08dcb85_Avi-Lumelsky.webp)![]()![]()Avi Lumelsky,,August 20, 2024](/blog/tensorflow-keras-downgrade-attack-cve-2024-3660-bypass)
## Subscribe and get the latest security updates

### Zero in on what's exploitable

Oligo helps organizations focus on true exploitability, streamlining security processes without hindering developerÂ productivity.

[Book a Demo](/demo)COMPANY[Home](/)[About](/company/about)[Contact](/contact)[Customers](/resources/case-studies)[Careers](/company/careers)PRODUCT[Oligo Focus](/product/oligo-focus)[Oligo ADR](/product/oligo-adr)Solutions[Real-Time Scanning and Monitoring](/solution/vulnerability-scanning)[Real-Time BOM/VEX](/solution/real-time-bom)[Supply Chain Security](/solution/supply-chain-security)[Application Vulnerability Management](/solution/application-security-posture)[Attack Detection and Response](/solution/detection-and-incident-response)[Compliance and Assurance](/solution/compliance)RESOURCES[Resource Center](/resource-center)[Blog](/resources/blog)[News](/resources/news)[Events](/resources/events)[Academy](https://www.oligo.security/academy?category=all)[Whitepapers](/resource-center?category=Whitepapers)[Application Detection & Response](https://www.oligo.security/blog/what-is-adr-application-detection-and-response)[Reachability Analysis](https://www.oligo.security/academy/reachability-analysis-5-techniques-and-5-critical-best-practices)Copyright Â© Oligo Security| All Rights Reserved 2024[Terms of use](/legal/terms)[Privacy Policy](/legal/privacy-policy)[Cookie Policy](/legal/cookie-policy)![AICPA SOC](https://cdn.prod.website-files.com/63dbb928e89213590c5bfd53/65fbb973777e6eaf162a04e1_6446265cd141a65d1e78cb03_Oligo-%20SOC%20ii%20type%20ii.webp)![ISO](https://cdn.prod.website-files.com/63dbb928e89213590c5bfd53/65fbb973b9384cf3cc4b8b85_658938677efa8f55635d1b4d_iso_27001_02.webp)


