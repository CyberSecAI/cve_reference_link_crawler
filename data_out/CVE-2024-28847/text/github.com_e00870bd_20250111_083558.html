
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fopen-metadata%2FOpenMetadata%2Fblob%2Fb6b337e09a05101506a5faba4b45d370cc3c9fc8%2Fopenmetadata-service%2Fsrc%2Fmain%2Fjava%2Forg%2Fopenmetadata%2Fservice%2Fjdbi3%2FEntityRepository.java)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fopen-metadata%2FOpenMetadata%2Fblob%2Fb6b337e09a05101506a5faba4b45d370cc3c9fc8%2Fopenmetadata-service%2Fsrc%2Fmain%2Fjava%2Forg%2Fopenmetadata%2Fservice%2Fjdbi3%2FEntityRepository.java)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=open-metadata%2FOpenMetadata)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[open-metadata](/open-metadata)
/
**[OpenMetadata](/open-metadata/OpenMetadata)**
Public

* [Notifications](/login?return_to=%2Fopen-metadata%2FOpenMetadata) You must be signed in to change notification settings
* [Fork
  1.1k](/login?return_to=%2Fopen-metadata%2FOpenMetadata)
* [Star
   5.9k](/login?return_to=%2Fopen-metadata%2FOpenMetadata)

* [Code](/open-metadata/OpenMetadata)
* [Issues
  395](/open-metadata/OpenMetadata/issues)
* [Pull requests
  92](/open-metadata/OpenMetadata/pulls)
* [Discussions](/open-metadata/OpenMetadata/discussions)
* [Actions](/open-metadata/OpenMetadata/actions)
* [Projects
  0](/open-metadata/OpenMetadata/projects)
* [Wiki](/open-metadata/OpenMetadata/wiki)
* [Security](/open-metadata/OpenMetadata/security)
* [Insights](/open-metadata/OpenMetadata/pulse)

Additional navigation options

* [Code](/open-metadata/OpenMetadata)
* [Issues](/open-metadata/OpenMetadata/issues)
* [Pull requests](/open-metadata/OpenMetadata/pulls)
* [Discussions](/open-metadata/OpenMetadata/discussions)
* [Actions](/open-metadata/OpenMetadata/actions)
* [Projects](/open-metadata/OpenMetadata/projects)
* [Wiki](/open-metadata/OpenMetadata/wiki)
* [Security](/open-metadata/OpenMetadata/security)
* [Insights](/open-metadata/OpenMetadata/pulse)

## Files

 b6b337e
## Breadcrumbs

1. [OpenMetadata](/open-metadata/OpenMetadata/tree/b6b337e09a05101506a5faba4b45d370cc3c9fc8)
2. /[openmetadata-service](/open-metadata/OpenMetadata/tree/b6b337e09a05101506a5faba4b45d370cc3c9fc8/openmetadata-service)
3. /[src](/open-metadata/OpenMetadata/tree/b6b337e09a05101506a5faba4b45d370cc3c9fc8/openmetadata-service/src)
4. /[main](/open-metadata/OpenMetadata/tree/b6b337e09a05101506a5faba4b45d370cc3c9fc8/openmetadata-service/src/main)
5. /[java](/open-metadata/OpenMetadata/tree/b6b337e09a05101506a5faba4b45d370cc3c9fc8/openmetadata-service/src/main/java)
6. /[org](/open-metadata/OpenMetadata/tree/b6b337e09a05101506a5faba4b45d370cc3c9fc8/openmetadata-service/src/main/java/org)
7. /[openmetadata](/open-metadata/OpenMetadata/tree/b6b337e09a05101506a5faba4b45d370cc3c9fc8/openmetadata-service/src/main/java/org/openmetadata)
8. /[service](/open-metadata/OpenMetadata/tree/b6b337e09a05101506a5faba4b45d370cc3c9fc8/openmetadata-service/src/main/java/org/openmetadata/service)
9. /[jdbi3](/open-metadata/OpenMetadata/tree/b6b337e09a05101506a5faba4b45d370cc3c9fc8/openmetadata-service/src/main/java/org/openmetadata/service/jdbi3)
/
# EntityRepository.java

Copy path Blame  Blame
## Latest commit

## History

[History](/open-metadata/OpenMetadata/commits/b6b337e09a05101506a5faba4b45d370cc3c9fc8/openmetadata-service/src/main/java/org/openmetadata/service/jdbi3/EntityRepository.java)2651 lines (2366 loc) · 110 KB b6b337e
## Breadcrumbs

1. [OpenMetadata](/open-metadata/OpenMetadata/tree/b6b337e09a05101506a5faba4b45d370cc3c9fc8)
2. /[openmetadata-service](/open-metadata/OpenMetadata/tree/b6b337e09a05101506a5faba4b45d370cc3c9fc8/openmetadata-service)
3. /[src](/open-metadata/OpenMetadata/tree/b6b337e09a05101506a5faba4b45d370cc3c9fc8/openmetadata-service/src)
4. /[main](/open-metadata/OpenMetadata/tree/b6b337e09a05101506a5faba4b45d370cc3c9fc8/openmetadata-service/src/main)
5. /[java](/open-metadata/OpenMetadata/tree/b6b337e09a05101506a5faba4b45d370cc3c9fc8/openmetadata-service/src/main/java)
6. /[org](/open-metadata/OpenMetadata/tree/b6b337e09a05101506a5faba4b45d370cc3c9fc8/openmetadata-service/src/main/java/org)
7. /[openmetadata](/open-metadata/OpenMetadata/tree/b6b337e09a05101506a5faba4b45d370cc3c9fc8/openmetadata-service/src/main/java/org/openmetadata)
8. /[service](/open-metadata/OpenMetadata/tree/b6b337e09a05101506a5faba4b45d370cc3c9fc8/openmetadata-service/src/main/java/org/openmetadata/service)
9. /[jdbi3](/open-metadata/OpenMetadata/tree/b6b337e09a05101506a5faba4b45d370cc3c9fc8/openmetadata-service/src/main/java/org/openmetadata/service/jdbi3)
/
# EntityRepository.java

Top
## File metadata and controls

* Code
* Blame

2651 lines (2366 loc) · 110 KB[Raw](https://github.com/open-metadata/OpenMetadata/raw/b6b337e09a05101506a5faba4b45d370cc3c9fc8/openmetadata-service/src/main/java/org/openmetadata/service/jdbi3/EntityRepository.java)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\* \* Copyright 2021 Collate \* Licensed under the Apache License, Version 2.0 (the "License"); \* you may not use this file except in compliance with the License. \* You may obtain a copy of the License at \* http://www.apache.org/licenses/LICENSE-2.0 \* Unless required by applicable law or agreed to in writing, software \* distributed under the License is distributed on an "AS IS" BASIS, \* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \* See the License for the specific language governing permissions and \* limitations under the License. \*/
package org.openmetadata.service.jdbi3;
import static org.openmetadata.common.utils.CommonUtil.listOrEmpty;import static org.openmetadata.common.utils.CommonUtil.nullOrEmpty;import static org.openmetadata.schema.type.Include.ALL;import static org.openmetadata.schema.type.Include.DELETED;import static org.openmetadata.schema.type.Include.NON\_DELETED;import static org.openmetadata.schema.utils.EntityInterfaceUtil.quoteName;import static org.openmetadata.service.Entity.ADMIN\_USER\_NAME;import static org.openmetadata.service.Entity.DATA\_PRODUCT;import static org.openmetadata.service.Entity.DOMAIN;import static org.openmetadata.service.Entity.FIELD\_CHILDREN;import static org.openmetadata.service.Entity.FIELD\_DATA\_PRODUCTS;import static org.openmetadata.service.Entity.FIELD\_DELETED;import static org.openmetadata.service.Entity.FIELD\_DESCRIPTION;import static org.openmetadata.service.Entity.FIELD\_DISPLAY\_NAME;import static org.openmetadata.service.Entity.FIELD\_DOMAIN;import static org.openmetadata.service.Entity.FIELD\_EXPERTS;import static org.openmetadata.service.Entity.FIELD\_EXTENSION;import static org.openmetadata.service.Entity.FIELD\_FOLLOWERS;import static org.openmetadata.service.Entity.FIELD\_LIFE\_CYCLE;import static org.openmetadata.service.Entity.FIELD\_OWNER;import static org.openmetadata.service.Entity.FIELD\_REVIEWERS;import static org.openmetadata.service.Entity.FIELD\_STYLE;import static org.openmetadata.service.Entity.FIELD\_TAGS;import static org.openmetadata.service.Entity.FIELD\_VOTES;import static org.openmetadata.service.Entity.USER;import static org.openmetadata.service.Entity.getEntityByName;import static org.openmetadata.service.Entity.getEntityFields;import static org.openmetadata.service.exception.CatalogExceptionMessage.csvNotSupported;import static org.openmetadata.service.exception.CatalogExceptionMessage.entityNotFound;import static org.openmetadata.service.util.EntityUtil.compareTagLabel;import static org.openmetadata.service.util.EntityUtil.entityReferenceMatch;import static org.openmetadata.service.util.EntityUtil.fieldAdded;import static org.openmetadata.service.util.EntityUtil.fieldDeleted;import static org.openmetadata.service.util.EntityUtil.fieldUpdated;import static org.openmetadata.service.util.EntityUtil.getColumnField;import static org.openmetadata.service.util.EntityUtil.getEntityReferences;import static org.openmetadata.service.util.EntityUtil.getExtensionField;import static org.openmetadata.service.util.EntityUtil.getId;import static org.openmetadata.service.util.EntityUtil.nextMajorVersion;import static org.openmetadata.service.util.EntityUtil.nextVersion;import static org.openmetadata.service.util.EntityUtil.objectMatch;import static org.openmetadata.service.util.EntityUtil.tagLabelMatch;
import com.fasterxml.jackson.databind.JsonNode;import com.fasterxml.jackson.databind.node.ObjectNode;import com.google.common.annotations.VisibleForTesting;import com.google.common.cache.CacheBuilder;import com.google.common.cache.CacheLoader;import com.google.common.cache.LoadingCache;import com.google.common.util.concurrent.UncheckedExecutionException;import com.networknt.schema.JsonSchema;import com.networknt.schema.ValidationMessage;import java.io.IOException;import java.net.URI;import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Map.Entry;import java.util.Objects;import java.util.Optional;import java.util.Set;import java.util.UUID;import java.util.concurrent.ExecutionException;import java.util.concurrent.TimeUnit;import java.util.function.BiPredicate;import java.util.function.Function;import java.util.stream.Collectors;import javax.json.JsonPatch;import javax.validation.constraints.NotNull;import javax.ws.rs.core.Response.Status;import javax.ws.rs.core.UriInfo;import lombok.Getter;import lombok.NonNull;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.tuple.ImmutablePair;import org.apache.commons.lang3.tuple.Pair;import org.jdbi.v3.sqlobject.transaction.Transaction;import org.openmetadata.common.utils.CommonUtil;import org.openmetadata.schema.CreateEntity;import org.openmetadata.schema.EntityInterface;import org.openmetadata.schema.api.VoteRequest;import org.openmetadata.schema.api.VoteRequest.VoteType;import org.openmetadata.schema.api.feed.ResolveTask;import org.openmetadata.schema.api.teams.CreateTeam;import org.openmetadata.schema.entity.data.Table;import org.openmetadata.schema.entity.teams.Team;import org.openmetadata.schema.entity.teams.User;import org.openmetadata.schema.type.ChangeDescription;import org.openmetadata.schema.type.ChangeEvent;import org.openmetadata.schema.type.Column;import org.openmetadata.schema.type.EntityHistory;import org.openmetadata.schema.type.EntityReference;import org.openmetadata.schema.type.EventType;import org.openmetadata.schema.type.Include;import org.openmetadata.schema.type.LifeCycle;import org.openmetadata.schema.type.ProviderType;import org.openmetadata.schema.type.Relationship;import org.openmetadata.schema.type.TagLabel;import org.openmetadata.schema.type.TaskType;import org.openmetadata.schema.type.ThreadType;import org.openmetadata.schema.type.Votes;import org.openmetadata.schema.type.csv.CsvImportResult;import org.openmetadata.schema.utils.EntityInterfaceUtil;import org.openmetadata.service.Entity;import org.openmetadata.service.OpenMetadataApplicationConfig;import org.openmetadata.service.TypeRegistry;import org.openmetadata.service.exception.CatalogExceptionMessage;import org.openmetadata.service.exception.EntityNotFoundException;import org.openmetadata.service.exception.UnhandledServerException;import org.openmetadata.service.jdbi3.CollectionDAO.EntityRelationshipRecord;import org.openmetadata.service.jdbi3.CollectionDAO.EntityVersionPair;import org.openmetadata.service.jdbi3.CollectionDAO.ExtensionRecord;import org.openmetadata.service.jdbi3.FeedRepository.TaskWorkflow;import org.openmetadata.service.jdbi3.FeedRepository.ThreadContext;import org.openmetadata.service.resources.tags.TagLabelUtil;import org.openmetadata.service.search.SearchRepository;import org.openmetadata.service.util.EntityUtil;import org.openmetadata.service.util.EntityUtil.Fields;import org.openmetadata.service.util.FullyQualifiedName;import org.openmetadata.service.util.JsonUtils;import org.openmetadata.service.util.RestUtil;import org.openmetadata.service.util.RestUtil.DeleteResponse;import org.openmetadata.service.util.RestUtil.PatchResponse;import org.openmetadata.service.util.RestUtil.PutResponse;import org.openmetadata.service.util.ResultList;
/\*\* \* This is the base class used by Entity Resources to perform READ and WRITE operations to the backend database to \* Create, Retrieve, Update, and Delete entities. \* \* <p>An entity has two types of fields - `attributes` and `relationships`. \* \* <ul> \* <li>The `attributes` are the core properties of the entity, example - entity id, name, fullyQualifiedName, columns \* for a table, etc. \* <li>The `relationships` are an associated between two entities, example - table belongs to a database, table has a \* tag, user owns a table, etc. All relationships are captured using {@code EntityReference}. \* </ul> \* \* Entities are stored as JSON documents in the database. Each entity is stored in a separate table and is accessed \* through a <i>Data Access Object</i> or <i>DAO</i> that corresponds to each of the entity. For example, \* <i>table\_entity</i> is the database table used to store JSON docs corresponding to <i>table</i> entity and {@link \* org.openmetadata.service.jdbi3.CollectionDAO.TableDAO} is used as the DAO object to access the table\_entity table. \* All DAO objects for an entity are available in {@code daoCollection}. <br> \* <br> \* Relationships between entity is stored in a separate table that captures the edge - fromEntity, toEntity, and the \* relationship name <i>entity\_relationship</i> table and are supported by {@link \* org.openmetadata.service.jdbi3.CollectionDAO.EntityRelationshipDAO} DAO object. \* \* <p>JSON document of an entity stores only <i>required</i> attributes of an entity. Some attributes such as \* <i>href</i> are not stored and are created on the fly. <br> \* <br> \* Json document of an entity does not store relationships. As an example, JSON document for <i>table</i> entity does \* not store the relationship <i>database</i> which is of type <i>EntityReference</i>. This is always retrieved from the \* relationship table when required to ensure, the data stored is efficiently and consistently, and relationship \* information does not become stale. \*/@Slf4j@Repository()public abstract class EntityRepository<T extends EntityInterface> {
 public static final LoadingCache<Pair<String, String>, EntityInterface> CACHE\_WITH\_NAME = CacheBuilder.newBuilder() .maximumSize(5000) .expireAfterWrite(30, TimeUnit.SECONDS) .recordStats() .build(new EntityLoaderWithName()); public static final LoadingCache<Pair<String, UUID>, EntityInterface> CACHE\_WITH\_ID = CacheBuilder.newBuilder() .maximumSize(5000) .expireAfterWrite(30, TimeUnit.SECONDS) .recordStats() .build(new EntityLoaderWithId()); private final String collectionPath; private final Class<T> entityClass; @Getter protected final String entityType; @Getter protected final EntityDAO<T> dao; @Getter protected final CollectionDAO daoCollection; @Getter protected final SearchRepository searchRepository; @Getter protected final Set<String> allowedFields; public final boolean supportsSoftDelete; @Getter protected final boolean supportsTags; @Getter protected final boolean supportsOwner; @Getter protected final boolean supportsStyle; @Getter protected final boolean supportsLifeCycle; protected final boolean supportsFollower; protected final boolean supportsExtension; protected final boolean supportsVotes; @Getter protected final boolean supportsDomain; protected final boolean supportsDataProducts; @Getter protected final boolean supportsReviewers; @Getter protected final boolean supportsExperts; protected boolean quoteFqn = false; // Entity FQNS not hierarchical such user, teams, services need to be quoted protected boolean renameAllowed = false; // Entity can be renamed
 /\*\* Fields that can be updated during PATCH operation \*/ @Getter private final Fields patchFields;
 /\*\* Fields that can be updated during PUT operation \*/ @Getter protected final Fields putFields;
 protected boolean supportsSearch = false;
 protected EntityRepository( String collectionPath, String entityType, Class<T> entityClass, EntityDAO<T> entityDAO, String patchFields, String putFields) { this.collectionPath = collectionPath; this.entityClass = entityClass; allowedFields = getEntityFields(entityClass); this.dao = entityDAO; this.daoCollection = Entity.getCollectionDAO(); this.searchRepository = Entity.getSearchRepository(); this.entityType = entityType; this.patchFields = getFields(patchFields); this.putFields = getFields(putFields);
 this.supportsTags = allowedFields.contains(FIELD\_TAGS); if (supportsTags) { this.patchFields.addField(allowedFields, FIELD\_TAGS); this.putFields.addField(allowedFields, FIELD\_TAGS); } this.supportsOwner = allowedFields.contains(FIELD\_OWNER); if (supportsOwner) { this.patchFields.addField(allowedFields, FIELD\_OWNER); this.putFields.addField(allowedFields, FIELD\_OWNER); } this.supportsSoftDelete = allowedFields.contains(FIELD\_DELETED); this.supportsFollower = allowedFields.contains(FIELD\_FOLLOWERS); if (supportsFollower) { this.patchFields.addField(allowedFields, FIELD\_FOLLOWERS); this.putFields.addField(allowedFields, FIELD\_FOLLOWERS); } this.supportsExtension = allowedFields.contains(FIELD\_EXTENSION); if (supportsExtension) { this.patchFields.addField(allowedFields, FIELD\_EXTENSION); this.putFields.addField(allowedFields, FIELD\_EXTENSION); } this.supportsVotes = allowedFields.contains(FIELD\_VOTES); if (supportsVotes) { this.patchFields.addField(allowedFields, FIELD\_VOTES); this.putFields.addField(allowedFields, FIELD\_VOTES); } this.supportsDomain = allowedFields.contains(FIELD\_DOMAIN); if (supportsDomain) { this.patchFields.addField(allowedFields, FIELD\_DOMAIN); this.putFields.addField(allowedFields, FIELD\_DOMAIN); } this.supportsReviewers = allowedFields.contains(FIELD\_REVIEWERS); if (supportsReviewers) { this.patchFields.addField(allowedFields, FIELD\_REVIEWERS); this.putFields.addField(allowedFields, FIELD\_REVIEWERS); } this.supportsExperts = allowedFields.contains(FIELD\_EXPERTS); if (supportsExperts) { this.patchFields.addField(allowedFields, FIELD\_EXPERTS); this.putFields.addField(allowedFields, FIELD\_EXPERTS); } this.supportsDataProducts = allowedFields.contains(FIELD\_DATA\_PRODUCTS); if (supportsDataProducts) { this.patchFields.addField(allowedFields, FIELD\_DATA\_PRODUCTS); this.putFields.addField(allowedFields, FIELD\_DATA\_PRODUCTS); } this.supportsStyle = allowedFields.contains(FIELD\_STYLE); if (supportsStyle) { this.patchFields.addField(allowedFields, FIELD\_STYLE); this.putFields.addField(allowedFields, FIELD\_STYLE); } this.supportsLifeCycle = allowedFields.contains(FIELD\_LIFE\_CYCLE); if (supportsLifeCycle) { this.patchFields.addField(allowedFields, FIELD\_LIFE\_CYCLE); this.putFields.addField(allowedFields, FIELD\_LIFE\_CYCLE); } Entity.registerEntity(entityClass, entityType, this); }
 /\*\* \* Set the requested fields in an entity. This is used for requesting specific fields in the object during GET \* operations. It is also used during PUT and PATCH operations to set up fields that can be updated. \*/ public abstract void setFields(T entity, Fields fields);
 /\*\* \* Set the requested fields in an entity. This is used for requesting specific fields in the object during GET \* operations. It is also used during PUT and PATCH operations to set up fields that can be updated. \*/ public abstract void clearFields(T entity, Fields fields);
 /\*\* \* This method is used for validating an entity to be created during POST, PUT, and PATCH operations and prepare the \* entity with all the required attributes and relationships. \* \* <p>The implementation of this method must perform the following: \* \* <ol> \* <li>Prepare the values for attributes that are not required in the request but can be derived on the server side. \* Example - <i>>FullyQualifiedNames</i> of an entity can be derived from the hierarchy that an entity belongs \* to . \* <li>Validate all the attributes of an entity. \* <li>Validate all the relationships of an entity. As an example - during <i>table</i> creation, relationships such \* as <i>Tags</i>, <i>Owner</i>, <i>Database</i>a table belongs to are validated. During validation additional \* information that is not required in the create/update request are set up in the corresponding relationship \* fields. \* </ol> \* \* At the end of this operation, entity is expected to be valid and fully constructed with all the fields that will be \* sent as payload in the POST, PUT, and PATCH operations response. \* \* @see TableRepository#prepare(Table, boolean) for an example implementation \*/ public abstract void prepare(T entity, boolean update);
 /\*\* \* An entity is stored in the backend database as JSON document. The JSON includes some attributes of the entity and \* does not include attributes such as <i>href</i>. The relationship fields of an entity is never stored in the JSON \* document. It is always reconstructed based on relationship edges from the backend database. <br> \* <br> \* As an example, when <i>table</i> entity is stored, the attributes such as <i>href</i> and the relationships such as \* <i>owner</i>, <i>database</i>, and <i>tags</i> are set to null. These attributes are restored back after the JSON \* document is stored to be sent as response. \* \* @see TableRepository#storeEntity(Table, boolean) for an example implementation \*/ public abstract void storeEntity(T entity, boolean update);
 /\*\* \* This method is called to store all the relationships of an entity. It is expected that all relationships are \* already validated and completely setup before this method is called and no validation of relationships is required. \* \* @see TableRepository#storeRelationships(Table) for an example implementation \*/ public abstract void storeRelationships(T entity);
 /\*\* \* This method is called to set inherited fields that an entity inherits from its parent. \* \* @see TableRepository#setInheritedFields(Table, Fields) for an example implementation \*/ @SuppressWarnings("unused") public T setInheritedFields(T entity, Fields fields) { EntityInterface parent = supportsDomain ? getParentEntity(entity, "domain") : null; return parent != null ? inheritDomain(entity, fields, parent) : entity; }
 /\*\* \* PATCH operations can't overwrite certain fields, such as entity ID, fullyQualifiedNames etc. Instead of throwing an \* error, we take lenient approach of ignoring the user error and restore those attributes based on what is already \* stored in the original entity. \*/ public void restorePatchAttributes(T original, T updated) { updated.setId(original.getId()); updated.setName(renameAllowed ? updated.getName() : original.getName()); updated.setFullyQualifiedName(original.getFullyQualifiedName()); updated.setChangeDescription(original.getChangeDescription()); }
 /\*\* Set fullyQualifiedName of an entity \*/ public void setFullyQualifiedName(T entity) { entity.setFullyQualifiedName(quoteName(entity.getName())); }
 /\*\* \* Initialize data from json files if seed data does not exist in corresponding tables. Seed data is stored under \* openmetadata-service/src/main/resources/json/data/{entityType} \* \* <p>This method needs to be explicitly called, typically from initialize method. See {@link \* org.openmetadata.service.resources.teams.RoleResource#initialize(OpenMetadataApplicationConfig)} \*/ public void initSeedDataFromResources() throws IOException { List<T> entities = getEntitiesFromSeedData(); for (T entity : entities) { initializeEntity(entity); } }
 public List<T> getEntitiesFromSeedData() throws IOException { return getEntitiesFromSeedData(String.format(".\*json/data/%s/.\*\\.json$", entityType)); }
 public List<T> getEntitiesFromSeedData(String path) throws IOException { return getEntitiesFromSeedData(entityType, path, entityClass); }
 public static <U> List<U> getEntitiesFromSeedData(String entityType, String path, Class<U> clazz) throws IOException { List<U> entities = new ArrayList<>(); List<String> jsonDataFiles = EntityUtil.getJsonDataResources(path); jsonDataFiles.forEach( jsonDataFile -> { try { String json = CommonUtil.getResourceAsStream(EntityRepository.class.getClassLoader(), jsonDataFile); json = json.replace("<separator>", Entity.SEPARATOR); entities.add(JsonUtils.readValue(json, clazz)); } catch (Exception e) { LOG.warn("Failed to initialize the {} from file {}", entityType, jsonDataFile, e); } }); return entities; }
 /\*\* Initialize a given entity if it does not exist. \*/ @Transaction public void initializeEntity(T entity) { T existingEntity = findByNameOrNull(entity.getFullyQualifiedName(), ALL); if (existingEntity != null) { LOG.info("{} {} is already initialized", entityType, entity.getFullyQualifiedName()); return; }
 LOG.info("{} {} is not initialized", entityType, entity.getFullyQualifiedName()); entity.setUpdatedBy(ADMIN\_USER\_NAME); entity.setUpdatedAt(System.currentTimeMillis()); entity.setId(UUID.randomUUID()); create(null, entity); LOG.info("Created a new {} {}", entityType, entity.getFullyQualifiedName()); }
 public final T copy(T entity, CreateEntity request, String updatedBy) { EntityReference owner = validateOwner(request.getOwner()); EntityReference domain = validateDomain(request.getDomain()); entity.setId(UUID.randomUUID()); entity.setName(request.getName()); entity.setDisplayName(request.getDisplayName()); entity.setDescription(request.getDescription()); entity.setOwner(owner); entity.setDomain(domain); entity.setTags(request.getTags()); entity.setDataProducts(getEntityReferences(Entity.DATA\_PRODUCT, request.getDataProducts())); entity.setLifeCycle(request.getLifeCycle()); entity.setExtension(request.getExtension()); entity.setUpdatedBy(updatedBy); entity.setUpdatedAt(System.currentTimeMillis()); return entity; }
 public EntityUpdater getUpdater(T original, T updated, Operation operation) { return new EntityUpdater(original, updated, operation); }
 public final T get(UriInfo uriInfo, UUID id, Fields fields) { return get(uriInfo, id, fields, NON\_DELETED, false); }
 /\*\* Used for getting an entity with a set of requested fields \*/ public final T get(UriInfo uriInfo, UUID id, Fields fields, Include include, boolean fromCache) { if (!fromCache) { // Clear the cache and always get the entity from the database to ensure read-after-write consistency CACHE\_WITH\_ID.invalidate(new ImmutablePair<>(entityType, id)); } // Find the entity from the cache. Set all the fields that are not already set T entity = find(id, include); setFieldsInternal(entity, fields); setInheritedFields(entity, fields);
 // Clone the entity from the cache and reset all the fields that are not already set // Cloning is necessary to ensure different threads making a call to this method don't // overwrite the fields of the entity being returned T entityClone = JsonUtils.deepCopy(entity, entityClass); clearFieldsInternal(entityClone, fields); return withHref(uriInfo, entityClone); }
 /\*\* getReference is used for getting the entity references from the entity in the cache. \*/ public final EntityReference getReference(UUID id, Include include) throws EntityNotFoundException { return find(id, include).getEntityReference(); }
 /\*\* \* Find method is used for getting an entity only with core fields stored as JSON without any relational fields set \*/ public T find(UUID id, Include include) throws EntityNotFoundException { try { @SuppressWarnings("unchecked") T entity = (T) CACHE\_WITH\_ID.get(new ImmutablePair<>(entityType, id)); if (include == NON\_DELETED && Boolean.TRUE.equals(entity.getDeleted()) || include == DELETED && !Boolean.TRUE.equals(entity.getDeleted())) { throw new EntityNotFoundException(entityNotFound(entityType, id)); } return entity; } catch (ExecutionException | UncheckedExecutionException e) { throw new EntityNotFoundException(entityNotFound(entityType, id)); } }
 public T getByName(UriInfo uriInfo, String fqn, Fields fields) { return getByName(uriInfo, fqn, fields, NON\_DELETED, false); }
 public final T getByName(UriInfo uriInfo, String fqn, Fields fields, Include include, boolean fromCache) { fqn = quoteFqn ? EntityInterfaceUtil.quoteName(fqn) : fqn; if (!fromCache) { // Clear the cache and always get the entity from the database to ensure read-after-write consistency CACHE\_WITH\_NAME.invalidate(new ImmutablePair<>(entityType, fqn)); } // Find the entity from the cache. Set all the fields that are not already set T entity = findByName(fqn, include); setFieldsInternal(entity, fields); setInheritedFields(entity, fields);
 // Clone the entity from the cache and reset all the fields that are not already set // Cloning is necessary to ensure different threads making a call to this method don't // overwrite the fields of the entity being returned T entityClone = JsonUtils.deepCopy(entity, entityClass); clearFieldsInternal(entityClone, fields); return withHref(uriInfo, entityClone); }
 public final EntityReference getReferenceByName(String fqn, Include include) { fqn = quoteFqn ? EntityInterfaceUtil.quoteName(fqn) : fqn; return findByName(fqn, include).getEntityReference(); }
 public T findByNameOrNull(String fqn, Include include) { try { return findByName(fqn, include); } catch (EntityNotFoundException e) { return null; } }
 /\*\* \* Find method is used for getting an entity only with core fields stored as JSON without any relational fields set \*/ public T findByName(String fqn, Include include) { fqn = quoteFqn ? EntityInterfaceUtil.quoteName(fqn) : fqn; try { @SuppressWarnings("unchecked") T entity = (T) CACHE\_WITH\_NAME.get(new ImmutablePair<>(entityType, fqn)); if (include == NON\_DELETED && Boolean.TRUE.equals(entity.getDeleted()) || include == DELETED && !Boolean.TRUE.equals(entity.getDeleted())) { throw new EntityNotFoundException(entityNotFound(entityType, fqn)); } return entity; } catch (ExecutionException | UncheckedExecutionException e) { throw new EntityNotFoundException(entityNotFound(entityType, fqn)); } }
 public final List<T> listAll(Fields fields, ListFilter filter) { // forward scrolling, if after == null then first page is being asked List<String> jsons = dao.listAfter(filter, Integer.MAX\_VALUE, ""); List<T> entities = new ArrayList<>(); for (String json : jsons) { T entity = setFieldsInternal(JsonUtils.readValue(json, entityClass), fields); entity = clearFieldsInternal(entity, fields); entities.add(entity); } return entities; }
 public ResultList<T> listAfter(UriInfo uriInfo, Fields fields, ListFilter filter, int limitParam, String after) { int total = dao.listCount(filter); List<T> entities = new ArrayList<>(); if (limitParam > 0) { // forward scrolling, if after == null then first page is being asked List<String> jsons = dao.listAfter(filter, limitParam + 1, after == null ? "" : RestUtil.decodeCursor(after));
 for (String json : jsons) { T entity = setFieldsInternal(JsonUtils.readValue(json, entityClass), fields); entity = clearFieldsInternal(entity, fields); entities.add(withHref(uriInfo, entity)); }
 String beforeCursor; String afterCursor = null; beforeCursor = after == null ? null : entities.get(0).getName(); if (entities.size() > limitParam) { // If extra result exists, then next page exists - return after cursor entities.remove(limitParam); afterCursor = entities.get(limitParam - 1).getName(); } return getResultList(entities, beforeCursor, afterCursor, total); } else { // limit == 0 , return total count of entity. return getResultList(entities, null, null, total); } }
 public ResultList<T> listAfterWithSkipFailure( UriInfo uriInfo, Fields fields, ListFilter filter, int limitParam, String after) { List<String> errors = new ArrayList<>(); List<T> entities = new ArrayList<>(); int beforeOffset = Integer.parseInt(RestUtil.decodeCursor(after)); int currentOffset = beforeOffset; int total = dao.listCount(filter); if (limitParam > 0) { // forward scrolling, if after == null then first page is being asked List<String> jsons = dao.listAfterWithOffset(limitParam, currentOffset);
 for (String json : jsons) { try { T entity = setFieldsInternal(JsonUtils.readValue(json, entityClass), fields); entity = clearFieldsInternal(entity, fields); entities.add(withHref(uriInfo, entity)); } catch (Exception e) { LOG.error("Failed in Set Fields for Entity with Json : {}", json); errors.add(String.format("Error Message : %s , %n Entity Json : %s", e.getMessage(), json)); } } currentOffset = currentOffset + limitParam; String newAfter = currentOffset > total ? null : String.valueOf(currentOffset); return getResultList(entities, errors, String.valueOf(beforeOffset), newAfter, total); } else { // limit == 0 , return total count of entity. return getResultList(entities, errors, null, null, total); } }
 public ResultList<T> listBefore(UriInfo uriInfo, Fields fields, ListFilter filter, int limitParam, String before) { // Reverse scrolling - Get one extra result used for computing before cursor List<String> jsons = dao.listBefore(filter, limitParam + 1, RestUtil.decodeCursor(before));
 List<T> entities = new ArrayList<>(); for (String json : jsons) { T entity = setFieldsInternal(JsonUtils.readValue(json, entityClass), fields); entity = clearFieldsInternal(entity, fields); entities.add(withHref(uriInfo, entity)); } int total = dao.listCount(filter);
 String beforeCursor = null; String afterCursor; if (entities.size() > limitParam) { // If extra result exists, then previous page exists - return before cursor entities.remove(0); beforeCursor = entities.get(0).getName(); } afterCursor = entities.get(entities.size() - 1).getName(); return getResultList(entities, beforeCursor, afterCursor, total); }
 public T getVersion(UUID id, String version) { Double requestedVersion = Double.parseDouble(version); String extension = EntityUtil.getVersionExtension(entityType, requestedVersion);
 // Get previous version from version history String json = daoCollection.entityExtensionDAO().getExtension(id, extension); if (json != null) { return JsonUtils.readValue(json, entityClass); } // If requested the latest version, return it from current version of the entity T entity = setFieldsInternal(find(id, ALL), putFields); if (entity.getVersion().equals(requestedVersion)) { return entity; } throw EntityNotFoundException.byMessage( CatalogExceptionMessage.entityVersionNotFound(entityType, id, requestedVersion)); }
 public EntityHistory listVersions(UUID id) { T latest = setFieldsInternal(find(id, ALL), putFields); String extensionPrefix = EntityUtil.getVersionExtensionPrefix(entityType); List<ExtensionRecord> records = daoCollection.entityExtensionDAO().getExtensions(id, extensionPrefix); List<EntityVersionPair> oldVersions = new ArrayList<>(); records.forEach(r -> oldVersions.add(new EntityVersionPair(r))); oldVersions.sort(EntityUtil.compareVersion.reversed());
 final List<Object> allVersions = new ArrayList<>(); allVersions.add(JsonUtils.pojoToJson(latest)); oldVersions.forEach(version -> allVersions.add(version.getEntityJson())); return new EntityHistory().withEntityType(entityType).withVersions(allVersions); }
 public final T create(UriInfo uriInfo, T entity) { entity = withHref(uriInfo, createInternal(entity)); return entity; }
 public final T createInternal(T entity) { prepareInternal(entity, false); return createNewEntity(entity); }
 public void prepareInternal(T entity, boolean update) { validateTags(entity); prepare(entity, update); setFullyQualifiedName(entity); validateExtension(entity); // Domain is already validated }
 public void storeRelationshipsInternal(T entity) { storeOwner(entity, entity.getOwner()); applyTags(entity); storeDomain(entity, entity.getDomain()); storeDataProducts(entity, entity.getDataProducts()); storeRelationships(entity); }
 public T setFieldsInternal(T entity, Fields fields) { entity.setOwner(fields.contains(FIELD\_OWNER) ? getOwner(entity) : entity.getOwner()); entity.setTags(fields.contains(FIELD\_TAGS) ? getTags(entity) : entity.getTags()); entity.setExtension(fields.contains(FIELD\_EXTENSION) ? getExtension(entity) : entity.getExtension()); entity.setDomain(fields.contains(FIELD\_DOMAIN) ? getDomain(entity) : entity.getDomain()); entity.setDataProducts(fields.contains(FIELD\_DATA\_PRODUCTS) ? getDataProducts(entity) : entity.getDataProducts()); entity.setFollowers(fields.contains(FIELD\_FOLLOWERS) ? getFollowers(entity) : entity.getFollowers()); entity.setChildren(fields.contains(FIELD\_CHILDREN) ? getChildren(entity) : entity.getChildren()); entity.setExperts(fields.contains(FIELD\_EXPERTS) ? getExperts(entity) : entity.getExperts()); entity.setReviewers(fields.contains(FIELD\_REVIEWERS) ? getReviewers(entity) : entity.getReviewers()); entity.setVotes(fields.contains(FIELD\_VOTES) ? getVotes(entity) : entity.getVotes()); setFields(entity, fields); return entity; }
 public T clearFieldsInternal(T entity, Fields fields) { entity.setOwner(fields.contains(FIELD\_OWNER) ? entity.getOwner() : null); entity.setTags(fields.contains(FIELD\_TAGS) ? entity.getTags() : null); entity.setExtension(fields.contains(FIELD\_EXTENSION) ? entity.getExtension() : null); entity.setDomain(fields.contains(FIELD\_DOMAIN) ? entity.getDomain() : null); entity.setDataProducts(fields.contains(FIELD\_DATA\_PRODUCTS) ? entity.getDataProducts() : null); entity.setFollowers(fields.contains(FIELD\_FOLLOWERS) ? entity.getFollowers() : null); entity.setChildren(fields.contains(FIELD\_CHILDREN) ? entity.getChildren() : null); entity.setExperts(fields.contains(FIELD\_EXPERTS) ? entity.getExperts() : null); entity.setReviewers(fields.contains(FIELD\_REVIEWERS) ? entity.getReviewers() : null); entity.setVotes(fields.contains(FIELD\_VOTES) ? entity.getVotes() : null); clearFields(entity, fields); return entity; }
 @Transaction public final PutResponse<T> createOrUpdate(UriInfo uriInfo, T updated) { T original = findByNameOrNull(updated.getFullyQualifiedName(), ALL); if (original == null) { // If an original entity does not exist then create it, else update return new PutResponse<>(Status.CREATED, withHref(uriInfo, createNewEntity(updated)), RestUtil.ENTITY\_CREATED); } return update(uriInfo, original, updated); }
 @SuppressWarnings("unused") protected void postCreate(T entity) { if (supportsSearch) { searchRepository.createEntity(entity); } }
 @SuppressWarnings("unused") protected void postUpdate(T original, T updated) { if (supportsSearch) { searchRepository.updateEntity(updated); } }
 @Transaction public PutResponse<T> update(UriInfo uriInfo, T original, T updated) { // Get all the fields in the original entity that can be updated during PUT operation setFieldsInternal(original, putFields);
 // If the entity state is soft-deleted, recursively undelete the entity and it's children if (Boolean.TRUE.equals(original.getDeleted())) { restoreEntity(updated.getUpdatedBy(), entityType, original.getId()); }
 // Update the attributes and relationships of an entity EntityUpdater entityUpdater = getUpdater(original, updated, Operation.PUT); entityUpdater.update(); String change = entityUpdater.fieldsChanged() ? RestUtil.ENTITY\_UPDATED : RestUtil.ENTITY\_NO\_CHANGE; setInheritedFields(updated, new Fields(allowedFields)); return new PutResponse<>(Status.OK, withHref(uriInfo, updated), change); }
 @Transaction public final PatchResponse<T> patch(UriInfo uriInfo, UUID id, String user, JsonPatch patch) { // Get all the fields in the original entity that can be updated during PATCH operation T original = setFieldsInternal(find(id, NON\_DELETED), patchFields); setInheritedFields(original, patchFields);
 // Apply JSON patch to the original entity to get the updated entity T updated = JsonUtils.applyPatch(original, patch, entityClass); updated.setUpdatedBy(user); updated.setUpdatedAt(System.currentTimeMillis());
 prepareInternal(updated, true); populateOwner(updated.getOwner()); restorePatchAttributes(original, updated);
 // Update the attributes and relationships of an entity EntityUpdater entityUpdater = getUpdater(original, updated, Operation.PATCH); entityUpdater.update(); String change = RestUtil.ENTITY\_NO\_CHANGE; if (entityUpdater.fieldsChanged()) { change = RestUtil.ENTITY\_UPDATED; setInheritedFields(original, patchFields); // Restore inherited fields after a change } return new PatchResponse<>(Status.OK, withHref(uriInfo, updated), change); }
 @Transaction public PutResponse<T> addFollower(String updatedBy, UUID entityId, UUID userId) { T entity = find(entityId, NON\_DELETED);
 // Validate follower User user = daoCollection.userDAO().findEntityById(userId); if (Boolean.TRUE.equals(user.getDeleted())) { throw new IllegalArgumentException(CatalogExceptionMessage.deletedUser(userId)); }
 // Add relationship addRelationship(userId, entityId, Entity.USER, entityType, Relationship.FOLLOWS);
 ChangeDescription change = new ChangeDescription().withPreviousVersion(entity.getVersion()); fieldAdded(change, FIELD\_FOLLOWERS, List.of(user.getEntityReference()));
 ChangeEvent changeEvent = new ChangeEvent() .withEntity(entity) .withChangeDescription(change) .withEventType(EventType.ENTITY\_UPDATED) .withEntityType(entityType) .withEntityId(entityId) .withEntityFullyQualifiedName(entity.getFullyQualifiedName()) .withUserName(updatedBy) .withTimestamp(System.currentTimeMillis()) .withCurrentVersion(entity.getVersion()) .withPreviousVersion(change.getPreviousVersion()); entity.setChangeDescription(change); postUpdate(entity, entity); return new PutResponse<>(Status.OK, changeEvent, RestUtil.ENTITY\_FIELDS\_CHANGED); }
 @Transaction public PutResponse<T> updateVote(String updatedBy, UUID entityId, VoteRequest request) { T originalEntity = find(entityId, NON\_DELETED);
 // Validate User User user = daoCollection.userDAO().findEntityByName(FullyQualifiedName.quoteName(updatedBy)); UUID userId = user.getId(); if (Boolean.TRUE.equals(user.getDeleted())) { throw new IllegalArgumentException(CatalogExceptionMessage.deletedUser(userId)); }
 ChangeDescription change = new ChangeDescription().withPreviousVersion(originalEntity.getVersion()); fieldUpdated(change, FIELD\_VOTES, null, request.getUpdatedVoteType());
 // Add or Delete relationship if (request.getUpdatedVoteType() == VoteType.UN\_VOTED) { deleteRelationship(userId, Entity.USER, entityId, entityType, Relationship.VOTED); } else { addRelationship( userId, entityId, Entity.USER, entityType, Relationship.VOTED, JsonUtils.pojoToJson(request.getUpdatedVoteType()), false); }
 setFieldsInternal(originalEntity, new Fields(allowedFields, "votes")); ChangeEvent changeEvent = new ChangeEvent() .withEntity(originalEntity) .withChangeDescription(change) .withEventType(EventType.ENTITY\_UPDATED) .withEntityType(entityType) .withEntityId(entityId) .withEntityFullyQualifiedName(originalEntity.getFullyQualifiedName()) .withUserName(updatedBy) .withTimestamp(System.currentTimeMillis()) .withCurrentVersion(originalEntity.getVersion()) .withPreviousVersion(change.getPreviousVersion()); postUpdate(originalEntity, originalEntity); return new PutResponse<>(Status.OK, changeEvent, RestUtil.ENTITY\_FIELDS\_CHANGED); }
 @Transaction public final DeleteResponse<T> delete(String updatedBy, UUID id, boolean recursive, boolean hardDelete) { DeleteResponse<T> response = deleteInternal(updatedBy, id, recursive, hardDelete); postDelete(response.getEntity()); return response; }
 @Transaction public final DeleteResponse<T> deleteByName(String updatedBy, String name, boolean recursive, boolean hardDelete) { name = quoteFqn ? quoteName(name) : name; DeleteResponse<T> response = deleteInternalByName(updatedBy, name, recursive, hardDelete); postDelete(response.getEntity()); return response; }
 protected void preDelete(T entity, String deletedBy) { // Override this method to perform any operation required after deletion. // For example ingestion pipeline deletes a pipeline in AirFlow. }
 protected void postDelete(T entity) {}
 public void deleteFromSearch(T entity, String changeType) { if (supportsSearch) { if (changeType.equals(RestUtil.ENTITY\_SOFT\_DELETED)) { searchRepository.softDeleteOrRestoreEntity(entity, true); } else { searchRepository.deleteEntity(entity); } } }
 public void restoreFromSearch(T entity) { if (supportsSearch) { searchRepository.softDeleteOrRestoreEntity(entity, false); } }
 @Transaction private DeleteResponse<T> delete(String deletedBy, T original, boolean recursive, boolean hardDelete) { checkSystemEntityDeletion(original); preDelete(original, deletedBy); setFieldsInternal(original, putFields); deleteChildren(original.getId(), recursive, hardDelete, deletedBy);
 String changeType; T updated = get(null, original.getId(), putFields, ALL, false); if (supportsSoftDelete && !hardDelete) { updated.setUpdatedBy(deletedBy); updated.setUpdatedAt(System.currentTimeMillis()); updated.setDeleted(true); EntityUpdater updater = getUpdater(original, updated, Operation.SOFT\_DELETE); updater.update(); changeType = RestUtil.ENTITY\_SOFT\_DELETED; } else { cleanup(updated); changeType = RestUtil.ENTITY\_DELETED; } LOG.info("{} deleted {}", hardDelete ? "Hard" : "Soft", updated.getFullyQualifiedName()); return new DeleteResponse<>(updated, changeType); }
 @Transaction public final DeleteResponse<T> deleteInternalByName( String updatedBy, String name, boolean recursive, boolean hardDelete) { // Validate entity T entity = findByName(name, ALL); return delete(updatedBy, entity, recursive, hardDelete); }
 @Transaction public final DeleteResponse<T> deleteInternal(String updatedBy, UUID id, boolean recursive, boolean hardDelete) { // Validate entity T entity = find(id, ALL); return delete(updatedBy, entity, recursive, hardDelete); }
 @Transaction private void deleteChildren(UUID id, boolean recursive, boolean hardDelete, String updatedBy) { // If an entity being deleted contains other \*\*non-deleted\*\* children entities, it can't be deleted List<EntityRelationshipRecord> childrenRecords = daoCollection .relationshipDAO() .findTo(id, entityType, List.of(Relationship.CONTAINS.ordinal(), Relationship.PARENT\_OF.ordinal()));
 if (childrenRecords.isEmpty()) { LOG.info("No children to delete"); return; } // Entity being deleted contains children entities if (!recursive) { throw new IllegalArgumentException(CatalogExceptionMessage.entityIsNotEmpty(entityType)); } // Delete all the contained entities for (EntityRelationshipRecord entityRelationshipRecord : childrenRecords) { LOG.info( "Recursively {} deleting {} {}", hardDelete ? "hard" : "soft", entityRelationshipRecord.getType(), entityRelationshipRecord.getId()); Entity.deleteEntity( updatedBy, entityRelationshipRecord.getType(), entityRelationshipRecord.getId(), true, hardDelete); } }
 @Transaction protected void cleanup(T entityInterface) { UUID id = entityInterface.getId();
 // Delete all the relationships to other entities daoCollection.relationshipDAO().deleteAll(id, entityType);
 // Delete all the field relationships to other entities daoCollection.fieldRelationshipDAO().deleteAllByPrefix(entityInterface.getFullyQualifiedName());
 // Delete all the extensions of entity daoCollection.entityExtensionDAO().deleteAll(id);[View remainder of file in raw view](https://github.com/open-metadata/OpenMetadata/raw/b6b337e09a05101506a5faba4b45d370cc3c9fc8/openmetadata-service/src/main/java/org/openmetadata/service/jdbi3/EntityRepository.java)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

