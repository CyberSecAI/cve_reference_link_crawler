

| [cgit logo](/) | [index](/) : [kernel/git/torvalds/linux.git](/pub/scm/linux/kernel/git/torvalds/linux.git/) | for-next master vsnprintf |
| --- | --- | --- |
| Linux kernel source tree | Linus Torvalds |

| [about](/pub/scm/linux/kernel/git/torvalds/linux.git/about/)[summary](/pub/scm/linux/kernel/git/torvalds/linux.git/)[refs](/pub/scm/linux/kernel/git/torvalds/linux.git/refs/?id=af6d10345ca76670c1b7c37799f0d5576ccef277)[log](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)[tree](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=af6d10345ca76670c1b7c37799f0d5576ccef277)[commit](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=af6d10345ca76670c1b7c37799f0d5576ccef277)[diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=af6d10345ca76670c1b7c37799f0d5576ccef277)[stats](/pub/scm/linux/kernel/git/torvalds/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jon Maxwell <jmaxwell37@gmail.com> | 2023-01-12 12:25:32 +1100 |
| --- | --- | --- |
| committer | Jakub Kicinski <kuba@kernel.org> | 2023-01-13 20:59:14 -0800 |
| commit | [af6d10345ca76670c1b7c37799f0d5576ccef277](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=af6d10345ca76670c1b7c37799f0d5576ccef277) ([patch](/pub/scm/linux/kernel/git/torvalds/linux.git/patch/?id=af6d10345ca76670c1b7c37799f0d5576ccef277)) | |
| tree | [63bbdea43a5d2a8d75db45781f8c7b8004bcefa9](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=af6d10345ca76670c1b7c37799f0d5576ccef277) | |
| parent | [c1917514107982794fd448ee2596878f396ee6a8](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c1917514107982794fd448ee2596878f396ee6a8) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=af6d10345ca76670c1b7c37799f0d5576ccef277&id2=c1917514107982794fd448ee2596878f396ee6a8)) | |
| download | [linux-af6d10345ca76670c1b7c37799f0d5576ccef277.tar.gz](/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-af6d10345ca76670c1b7c37799f0d5576ccef277.tar.gz) | |

ipv6: remove max\_size check inline with ipv4In ip6\_dst\_gc() replace:
if (entries > gc\_thresh)
With:
if (entries > ops->gc\_thresh)
Sending Ipv6 packets in a loop via a raw socket triggers an issue where a
route is cloned by ip6\_rt\_cache\_alloc() for each packet sent. This quickly
consumes the Ipv6 max\_size threshold which defaults to 4096 resulting in
these warnings:
[1] 99.187805] dst\_alloc: 7728 callbacks suppressed
[2] Route cache is full: consider increasing sysctl net.ipv6.route.max\_size.
.
.
[300] Route cache is full: consider increasing sysctl net.ipv6.route.max\_size.
When this happens the packet is dropped and sendto() gets a network is
unreachable error:
remaining pkt 200557 errno 101
remaining pkt 196462 errno 101
.
.
remaining pkt 126821 errno 101
Implement David Aherns suggestion to remove max\_size check seeing that Ipv6
has a GC to manage memory usage. Ipv4 already does not check max\_size.
Here are some memory comparisons for Ipv4 vs Ipv6 with the patch:
Test by running 5 instances of a program that sends UDP packets to a raw
socket 5000000 times. Compare Ipv4 and Ipv6 performance with a similar
program.
Ipv4:
Before test:
MemFree: 29427108 kB
Slab: 237612 kB
ip6\_dst\_cache 1912 2528 256 32 2 : tunables 0 0 0
xfrm\_dst\_cache 0 0 320 25 2 : tunables 0 0 0
ip\_dst\_cache 2881 3990 192 42 2 : tunables 0 0 0
During test:
MemFree: 29417608 kB
Slab: 247712 kB
ip6\_dst\_cache 1912 2528 256 32 2 : tunables 0 0 0
xfrm\_dst\_cache 0 0 320 25 2 : tunables 0 0 0
ip\_dst\_cache 44394 44394 192 42 2 : tunables 0 0 0
After test:
MemFree: 29422308 kB
Slab: 238104 kB
ip6\_dst\_cache 1912 2528 256 32 2 : tunables 0 0 0
xfrm\_dst\_cache 0 0 320 25 2 : tunables 0 0 0
ip\_dst\_cache 3048 4116 192 42 2 : tunables 0 0 0
Ipv6 with patch:
Errno 101 errors are not observed anymore with the patch.
Before test:
MemFree: 29422308 kB
Slab: 238104 kB
ip6\_dst\_cache 1912 2528 256 32 2 : tunables 0 0 0
xfrm\_dst\_cache 0 0 320 25 2 : tunables 0 0 0
ip\_dst\_cache 3048 4116 192 42 2 : tunables 0 0 0
During Test:
MemFree: 29431516 kB
Slab: 240940 kB
ip6\_dst\_cache 11980 12064 256 32 2 : tunables 0 0 0
xfrm\_dst\_cache 0 0 320 25 2 : tunables 0 0 0
ip\_dst\_cache 3048 4116 192 42 2 : tunables 0 0 0
After Test:
MemFree: 29441816 kB
Slab: 238132 kB
ip6\_dst\_cache 1902 2432 256 32 2 : tunables 0 0 0
xfrm\_dst\_cache 0 0 320 25 2 : tunables 0 0 0
ip\_dst\_cache 3048 4116 192 42 2 : tunables 0 0 0
Tested-by: Andrea Mayer <andrea.mayer@uniroma2.it>
Signed-off-by: Jon Maxwell <jmaxwell37@gmail.com>
Reviewed-by: David Ahern <dsahern@kernel.org>
Link: [https://lore.kernel.org/r/20230112012532.311021-1-jmaxwell37@gmail.com](https://lore.kernel.org/r/20230112012532.311021-1-jmaxwell37%40gmail.com)
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=af6d10345ca76670c1b7c37799f0d5576ccef277)

| -rw-r--r-- | [include/net/dst\_ops.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/net/dst_ops.h?id=af6d10345ca76670c1b7c37799f0d5576ccef277) | 2 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/core/dst.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/net/core/dst.c?id=af6d10345ca76670c1b7c37799f0d5576ccef277) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/ipv6/route.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/net/ipv6/route.c?id=af6d10345ca76670c1b7c37799f0d5576ccef277) | 13 | |  |  |  | | --- | --- | --- | |

3 files changed, 8 insertions, 15 deletions

| diff --git a/include/net/dst\_ops.h b/include/net/dst\_ops.hindex 88ff7bb2bb9bd9..632086b2f644a9 100644--- a/[include/net/dst\_ops.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/net/dst_ops.h?id=c1917514107982794fd448ee2596878f396ee6a8)+++ b/[include/net/dst\_ops.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/net/dst_ops.h?id=af6d10345ca76670c1b7c37799f0d5576ccef277)@@ -16,7 +16,7 @@ struct dst\_ops { unsigned short family; unsigned int gc\_thresh; - int (\*gc)(struct dst\_ops \*ops);+ void (\*gc)(struct dst\_ops \*ops); struct dst\_entry \* (\*check)(struct dst\_entry \*, \_\_u32 cookie); unsigned int (\*default\_advmss)(const struct dst\_entry \*); unsigned int (\*mtu)(const struct dst\_entry \*);diff --git a/net/core/dst.c b/net/core/dst.cindex 6d2dd03dafa813..31c08a3386d3d7 100644--- a/[net/core/dst.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/core/dst.c?id=c1917514107982794fd448ee2596878f396ee6a8)+++ b/[net/core/dst.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/core/dst.c?id=af6d10345ca76670c1b7c37799f0d5576ccef277)@@ -82,12 +82,8 @@ void \*dst\_alloc(struct dst\_ops \*ops, struct net\_device \*dev,  if (ops->gc && !(flags & DST\_NOCOUNT) &&- dst\_entries\_get\_fast(ops) > ops->gc\_thresh) {- if (ops->gc(ops)) {- pr\_notice\_ratelimited("Route cache is full: consider increasing sysctl net.ipv6.route.max\_size.\n");- return NULL;- }- }+ dst\_entries\_get\_fast(ops) > ops->gc\_thresh)+ ops->gc(ops);  dst = kmem\_cache\_alloc(ops->kmem\_cachep, GFP\_ATOMIC); if (!dst)diff --git a/net/ipv6/route.c b/net/ipv6/route.cindex e74e0361fd921f..b643dda68d312e 100644--- a/[net/ipv6/route.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/ipv6/route.c?id=c1917514107982794fd448ee2596878f396ee6a8)+++ b/[net/ipv6/route.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/ipv6/route.c?id=af6d10345ca76670c1b7c37799f0d5576ccef277)@@ -91,7 +91,7 @@ static struct dst\_entry \*ip6\_negative\_advice(struct dst\_entry \*); static void ip6\_dst\_destroy(struct dst\_entry \*); static void ip6\_dst\_ifdown(struct dst\_entry \*, struct net\_device \*dev, int how);-static int ip6\_dst\_gc(struct dst\_ops \*ops);+static void ip6\_dst\_gc(struct dst\_ops \*ops);  static int ip6\_pkt\_discard(struct sk\_buff \*skb); static int ip6\_pkt\_discard\_out(struct net \*net, struct sock \*sk, struct sk\_buff \*skb);@@ -3284,11 +3284,10 @@ out: return dst; } -static int ip6\_dst\_gc(struct dst\_ops \*ops)+static void ip6\_dst\_gc(struct dst\_ops \*ops) { struct net \*net = container\_of(ops, struct net, ipv6.ip6\_dst\_ops); int rt\_min\_interval = net->ipv6.sysctl.ip6\_rt\_gc\_min\_interval;- int rt\_max\_size = net->ipv6.sysctl.ip6\_rt\_max\_size; int rt\_elasticity = net->ipv6.sysctl.ip6\_rt\_gc\_elasticity; int rt\_gc\_timeout = net->ipv6.sysctl.ip6\_rt\_gc\_timeout; unsigned long rt\_last\_gc = net->ipv6.ip6\_rt\_last\_gc;@@ -3296,11 +3295,10 @@ static int ip6\_dst\_gc(struct dst\_ops \*ops) int entries;  entries = dst\_entries\_get\_fast(ops);- if (entries > rt\_max\_size)+ if (entries > ops->gc\_thresh) entries = dst\_entries\_get\_slow(ops); - if (time\_after(rt\_last\_gc + rt\_min\_interval, jiffies) &&- entries <= rt\_max\_size)+ if (time\_after(rt\_last\_gc + rt\_min\_interval, jiffies)) goto out;  fib6\_run\_gc(atomic\_inc\_return(&net->ipv6.ip6\_rt\_gc\_expire), net, true);@@ -3310,7 +3308,6 @@ static int ip6\_dst\_gc(struct dst\_ops \*ops) out: val = atomic\_read(&net->ipv6.ip6\_rt\_gc\_expire); atomic\_set(&net->ipv6.ip6\_rt\_gc\_expire, val - (val >> rt\_elasticity));- return entries > rt\_max\_size; }  static int ip6\_nh\_lookup\_table(struct net \*net, struct fib6\_config \*cfg,@@ -6512,7 +6509,7 @@ static int \_\_net\_init ip6\_route\_net\_init(struct net \*net) #endif  net->ipv6.sysctl.flush\_delay = 0;- net->ipv6.sysctl.ip6\_rt\_max\_size = 4096;+ net->ipv6.sysctl.ip6\_rt\_max\_size = INT\_MAX; net->ipv6.sysctl.ip6\_rt\_gc\_min\_interval = HZ / 2; net->ipv6.sysctl.ip6\_rt\_gc\_timeout = 60\*HZ; net->ipv6.sysctl.ip6\_rt\_gc\_interval = 30\*HZ; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 04:42:00 +0000

