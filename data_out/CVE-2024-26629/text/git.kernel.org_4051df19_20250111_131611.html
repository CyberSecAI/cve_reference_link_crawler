

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=b7d2eee1f53899b53f069bba3a59a419fc3d331b)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=b7d2eee1f53899b53f069bba3a59a419fc3d331b)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b7d2eee1f53899b53f069bba3a59a419fc3d331b)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b7d2eee1f53899b53f069bba3a59a419fc3d331b)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | NeilBrown <neilb@suse.de> | 2024-01-22 14:58:16 +1100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-01-31 16:19:06 -0800 |
| commit | [b7d2eee1f53899b53f069bba3a59a419fc3d331b](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b7d2eee1f53899b53f069bba3a59a419fc3d331b) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=b7d2eee1f53899b53f069bba3a59a419fc3d331b)) | |
| tree | [5aa411312004981826b273c45820d23b3f65fc76](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=b7d2eee1f53899b53f069bba3a59a419fc3d331b) | |
| parent | [870171899d75d43e3d14360f3a4850e90a9c289b](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=870171899d75d43e3d14360f3a4850e90a9c289b) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b7d2eee1f53899b53f069bba3a59a419fc3d331b&id2=870171899d75d43e3d14360f3a4850e90a9c289b)) | |
| download | [linux-b7d2eee1f53899b53f069bba3a59a419fc3d331b.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-b7d2eee1f53899b53f069bba3a59a419fc3d331b.tar.gz) | |

nfsd: fix RELEASE\_LOCKOWNERcommit edcf9725150e42beeca42d085149f4c88fa97afd upstream.
The test on so\_count in nfsd4\_release\_lockowner() is nonsense and
harmful. Revert to using check\_for\_locks(), changing that to not sleep.
First: harmful.
As is documented in the kdoc comment for nfsd4\_release\_lockowner(), the
test on so\_count can transiently return a false positive resulting in a
return of NFS4ERR\_LOCKS\_HELD when in fact no locks are held. This is
clearly a protocol violation and with the Linux NFS client it can cause
incorrect behaviour.
If RELEASE\_LOCKOWNER is sent while some other thread is still
processing a LOCK request which failed because, at the time that request
was received, the given owner held a conflicting lock, then the nfsd
thread processing that LOCK request can hold a reference (conflock) to
the lock owner that causes nfsd4\_release\_lockowner() to return an
incorrect error.
The Linux NFS client ignores that NFS4ERR\_LOCKS\_HELD error because it
never sends NFS4\_RELEASE\_LOCKOWNER without first releasing any locks, so
it knows that the error is impossible. It assumes the lock owner was in
fact released so it feels free to use the same lock owner identifier in
some later locking request.
When it does reuse a lock owner identifier for which a previous RELEASE
failed, it will naturally use a lock\_seqid of zero. However the server,
which didn't release the lock owner, will expect a larger lock\_seqid and
so will respond with NFS4ERR\_BAD\_SEQID.
So clearly it is harmful to allow a false positive, which testing
so\_count allows.
The test is nonsense because ... well... it doesn't mean anything.
so\_count is the sum of three different counts.
1/ the set of states listed on so\_stateids
2/ the set of active vfs locks owned by any of those states
3/ various transient counts such as for conflicting locks.
When it is tested against '2' it is clear that one of these is the
transient reference obtained by find\_lockowner\_str\_locked(). It is not
clear what the other one is expected to be.
In practice, the count is often 2 because there is precisely one state
on so\_stateids. If there were more, this would fail.
In my testing I see two circumstances when RELEASE\_LOCKOWNER is called.
In one case, CLOSE is called before RELEASE\_LOCKOWNER. That results in
all the lock states being removed, and so the lockowner being discarded
(it is removed when there are no more references which usually happens
when the lock state is discarded). When nfsd4\_release\_lockowner() finds
that the lock owner doesn't exist, it returns success.
The other case shows an so\_count of '2' and precisely one state listed
in so\_stateid. It appears that the Linux client uses a separate lock
owner for each file resulting in one lock state per lock owner, so this
test on '2' is safe. For another client it might not be safe.
So this patch changes check\_for\_locks() to use the (newish)
find\_any\_file\_locked() so that it doesn't take a reference on the
nfs4\_file and so never calls nfsd\_file\_put(), and so never sleeps. With
this check is it safe to restore the use of check\_for\_locks() rather
than testing so\_count against the mysterious '2'.
Fixes: ce3c4ad7f4ce ("NFSD: Fix possible sleep during nfsd4\_release\_lockowner()")
Signed-off-by: NeilBrown <neilb@suse.de>
Reviewed-by: Jeff Layton <jlayton@kernel.org>
Cc: stable@vger.kernel.org # v6.2+
Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b7d2eee1f53899b53f069bba3a59a419fc3d331b)

| -rw-r--r-- | [fs/nfsd/nfs4state.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/nfsd/nfs4state.c?id=b7d2eee1f53899b53f069bba3a59a419fc3d331b) | 26 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 15 insertions, 11 deletions

| diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.cindex 529b3ed3b3177a..f4cccbf664ceb5 100644--- a/[fs/nfsd/nfs4state.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/nfsd/nfs4state.c?id=870171899d75d43e3d14360f3a4850e90a9c289b)+++ b/[fs/nfsd/nfs4state.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/nfsd/nfs4state.c?id=b7d2eee1f53899b53f069bba3a59a419fc3d331b)@@ -7890,14 +7890,16 @@ check\_for\_locks(struct nfs4\_file \*fp, struct nfs4\_lockowner \*lowner) { struct file\_lock \*fl; int status = false;- struct nfsd\_file \*nf = find\_any\_file(fp);+ struct nfsd\_file \*nf; struct inode \*inode; struct file\_lock\_context \*flctx; + spin\_lock(&fp->fi\_lock);+ nf = find\_any\_file\_locked(fp); if (!nf) { /\* Any valid lock stateid should have some sort of access \*/ WARN\_ON\_ONCE(1);- return status;+ goto out; }  inode = file\_inode(nf->nf\_file);@@ -7913,7 +7915,8 @@ check\_for\_locks(struct nfs4\_file \*fp, struct nfs4\_lockowner \*lowner) } spin\_unlock(&flctx->flc\_lock); }- nfsd\_file\_put(nf);+out:+ spin\_unlock(&fp->fi\_lock); return status; } @@ -7923,10 +7926,8 @@ check\_for\_locks(struct nfs4\_file \*fp, struct nfs4\_lockowner \*lowner) \* @cstate: NFSv4 COMPOUND state \* @u: RELEASE\_LOCKOWNER arguments \*- \* The lockowner's so\_count is bumped when a lock record is added- \* or when copying a conflicting lock. The latter case is brief,- \* but can lead to fleeting false positives when looking for- \* locks-in-use.+ \* Check if theree are any locks still held and if not - free the lockowner+ \* and any lock state that is owned. \* \* Return values: \* %nfs\_ok: lockowner released or not found@@ -7962,10 +7963,13 @@ nfsd4\_release\_lockowner(struct svc\_rqst \*rqstp, spin\_unlock(&clp->cl\_lock); return nfs\_ok; }- if (atomic\_read(&lo->lo\_owner.so\_count) != 2) {- spin\_unlock(&clp->cl\_lock);- nfs4\_put\_stateowner(&lo->lo\_owner);- return nfserr\_locks\_held;++ list\_for\_each\_entry(stp, &lo->lo\_owner.so\_stateids, st\_perstateowner) {+ if (check\_for\_locks(stp->st\_stid.sc\_file, lo)) {+ spin\_unlock(&clp->cl\_lock);+ nfs4\_put\_stateowner(&lo->lo\_owner);+ return nfserr\_locks\_held;+ } } unhash\_lockowner\_locked(lo); while (!list\_empty(&lo->lo\_owner.so\_stateids)) { |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 13:14:48 +0000

