

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=e3dfcab2080dc1f9a4b09cc1327361bc2845bfcd)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=e3dfcab2080dc1f9a4b09cc1327361bc2845bfcd)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e3dfcab2080dc1f9a4b09cc1327361bc2845bfcd)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e3dfcab2080dc1f9a4b09cc1327361bc2845bfcd)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Xiubo Li <xiubli@redhat.com> | 2022-12-21 14:13:51 +0800 |
| --- | --- | --- |
| committer | Ilya Dryomov <idryomov@gmail.com> | 2023-08-24 11:24:36 +0200 |
| commit | [e3dfcab2080dc1f9a4b09cc1327361bc2845bfcd](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e3dfcab2080dc1f9a4b09cc1327361bc2845bfcd) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=e3dfcab2080dc1f9a4b09cc1327361bc2845bfcd)) | |
| tree | [bfc1dd9c3ef8fe62885f96ff1d317984f9fd2d4a](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=e3dfcab2080dc1f9a4b09cc1327361bc2845bfcd) | |
| parent | [230bd8b98ddfae3b7093671d4973236dc724d0bb](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=230bd8b98ddfae3b7093671d4973236dc724d0bb) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e3dfcab2080dc1f9a4b09cc1327361bc2845bfcd&id2=230bd8b98ddfae3b7093671d4973236dc724d0bb)) | |
| download | [linux-e3dfcab2080dc1f9a4b09cc1327361bc2845bfcd.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-e3dfcab2080dc1f9a4b09cc1327361bc2845bfcd.tar.gz) | |

ceph: drop messages from MDS when unmountingWhen unmounting all the dirty buffers will be flushed and after
the last osd request is finished the last reference of the i\_count
will be released. Then it will flush the dirty cap/snap to MDSs,
and the unmounting won't wait the possible acks, which will ihold
the inodes when updating the metadata locally but makes no sense
any more, of this. This will make the evict\_inodes() to skip these
inodes.
If encrypt is enabled the kernel generate a warning when removing
the encrypt keys when the skipped inodes still hold the keyring:
WARNING: CPU: 4 PID: 168846 at fs/crypto/keyring.c:242 fscrypt\_destroy\_keyring+0x7e/0xd0
CPU: 4 PID: 168846 Comm: umount Tainted: G S 6.1.0-rc5-ceph-g72ead199864c #1
Hardware name: Supermicro SYS-5018R-WR/X10SRW-F, BIOS 2.0 12/17/2015
RIP: 0010:fscrypt\_destroy\_keyring+0x7e/0xd0
RSP: 0018:ffffc9000b277e28 EFLAGS: 00010202
RAX: 0000000000000002 RBX: ffff88810d52ac00 RCX: ffff88810b56aa00
RDX: 0000000080000000 RSI: ffffffff822f3a09 RDI: ffff888108f59000
RBP: ffff8881d394fb88 R08: 0000000000000028 R09: 0000000000000000
R10: 0000000000000001 R11: 11ff4fe6834fcd91 R12: ffff8881d394fc40
R13: ffff888108f59000 R14: ffff8881d394f800 R15: 0000000000000000
FS: 00007fd83f6f1080(0000) GS:ffff88885fd00000(0000) knlGS:0000000000000000
CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f918d417000 CR3: 000000017f89a005 CR4: 00000000003706e0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
<TASK>
generic\_shutdown\_super+0x47/0x120
kill\_anon\_super+0x14/0x30
ceph\_kill\_sb+0x36/0x90 [ceph]
deactivate\_locked\_super+0x29/0x60
cleanup\_mnt+0xb8/0x140
task\_work\_run+0x67/0xb0
exit\_to\_user\_mode\_prepare+0x23d/0x240
syscall\_exit\_to\_user\_mode+0x25/0x60
do\_syscall\_64+0x40/0x80
entry\_SYSCALL\_64\_after\_hwframe+0x63/0xcd
RIP: 0033:0x7fd83dc39e9b
Later the kernel will crash when iput() the inodes and dereferencing
the "sb->s\_master\_keys", which has been released by the
generic\_shutdown\_super().
Link: <https://tracker.ceph.com/issues/59162>
Signed-off-by: Xiubo Li <xiubli@redhat.com>
Reviewed-and-tested-by: Lu√≠s Henriques <lhenriques@suse.de>
Reviewed-by: Milind Changire <mchangir@redhat.com>
Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e3dfcab2080dc1f9a4b09cc1327361bc2845bfcd)

| -rw-r--r-- | [fs/ceph/caps.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/ceph/caps.c?id=e3dfcab2080dc1f9a4b09cc1327361bc2845bfcd) | 6 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/ceph/mds\_client.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/ceph/mds_client.c?id=e3dfcab2080dc1f9a4b09cc1327361bc2845bfcd) | 12 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/ceph/mds\_client.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/ceph/mds_client.h?id=e3dfcab2080dc1f9a4b09cc1327361bc2845bfcd) | 11 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/ceph/quota.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/ceph/quota.c?id=e3dfcab2080dc1f9a4b09cc1327361bc2845bfcd) | 14 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/ceph/snap.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/ceph/snap.c?id=e3dfcab2080dc1f9a4b09cc1327361bc2845bfcd) | 10 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/ceph/super.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/ceph/super.c?id=e3dfcab2080dc1f9a4b09cc1327361bc2845bfcd) | 75 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/ceph/super.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/ceph/super.h?id=e3dfcab2080dc1f9a4b09cc1327361bc2845bfcd) | 3 | |  |  |  | | --- | --- | --- | |

7 files changed, 109 insertions, 22 deletions

| diff --git a/fs/ceph/caps.c b/fs/ceph/caps.cindex 5c2b28ac941000..54041d9c1e25bd 100644--- a/[fs/ceph/caps.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/caps.c?id=230bd8b98ddfae3b7093671d4973236dc724d0bb)+++ b/[fs/ceph/caps.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/caps.c?id=e3dfcab2080dc1f9a4b09cc1327361bc2845bfcd)@@ -4247,6 +4247,9 @@ void ceph\_handle\_caps(struct ceph\_mds\_session \*session,  dout("handle\_caps from mds%d\n", session->s\_mds); + if (!ceph\_inc\_mds\_stopping\_blocker(mdsc, session))+ return;+ /\* decode \*/ end = msg->front.iov\_base + msg->front.iov\_len; if (msg->front.iov\_len < sizeof(\*h))@@ -4348,7 +4351,6 @@ void ceph\_handle\_caps(struct ceph\_mds\_session \*session, vino.snap, inode);  mutex\_lock(&session->s\_mutex);- inc\_session\_sequence(session); dout(" mds%d seq %lld cap seq %u\n", session->s\_mds, session->s\_seq, (unsigned)seq); @@ -4457,6 +4459,8 @@ done: done\_unlocked: iput(inode); out:+ ceph\_dec\_mds\_stopping\_blocker(mdsc);+ ceph\_put\_string(extra\_info.pool\_ns);  /\* Defer closing the sessions after s\_mutex lock being released \*/diff --git a/fs/ceph/mds\_client.c b/fs/ceph/mds\_client.cindex c257d75c575799..04a881343e43eb 100644--- a/[fs/ceph/mds\_client.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/mds_client.c?id=230bd8b98ddfae3b7093671d4973236dc724d0bb)+++ b/[fs/ceph/mds\_client.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/mds_client.c?id=e3dfcab2080dc1f9a4b09cc1327361bc2845bfcd)@@ -4889,6 +4889,9 @@ static void handle\_lease(struct ceph\_mds\_client \*mdsc,  dout("handle\_lease from mds%d\n", mds); + if (!ceph\_inc\_mds\_stopping\_blocker(mdsc, session))+ return;+ /\* decode \*/ if (msg->front.iov\_len < sizeof(\*h) + sizeof(u32)) goto bad;@@ -4907,8 +4910,6 @@ static void handle\_lease(struct ceph\_mds\_client \*mdsc, dname.len, dname.name);  mutex\_lock(&session->s\_mutex);- inc\_session\_sequence(session);- if (!inode) { dout("handle\_lease no inode %llx\n", vino.ino); goto release;@@ -4970,9 +4971,13 @@ release: out: mutex\_unlock(&session->s\_mutex); iput(inode);++ ceph\_dec\_mds\_stopping\_blocker(mdsc); return;  bad:+ ceph\_dec\_mds\_stopping\_blocker(mdsc);+ pr\_err("corrupt lease message\n"); ceph\_msg\_dump(msg); }@@ -5168,6 +5173,9 @@ int ceph\_mdsc\_init(struct ceph\_fs\_client \*fsc) }  init\_completion(&mdsc->safe\_umount\_waiters);+ spin\_lock\_init(&mdsc->stopping\_lock);+ atomic\_set(&mdsc->stopping\_blockers, 0);+ init\_completion(&mdsc->stopping\_waiter); init\_waitqueue\_head(&mdsc->session\_close\_wq); INIT\_LIST\_HEAD(&mdsc->waiting\_for\_map); mdsc->quotarealms\_inodes = RB\_ROOT;diff --git a/fs/ceph/mds\_client.h b/fs/ceph/mds\_client.hindex 0477388a0d1c2f..1fa0f78b7b79a7 100644--- a/[fs/ceph/mds\_client.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/mds_client.h?id=230bd8b98ddfae3b7093671d4973236dc724d0bb)+++ b/[fs/ceph/mds\_client.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/mds_client.h?id=e3dfcab2080dc1f9a4b09cc1327361bc2845bfcd)@@ -399,8 +399,9 @@ struct cap\_wait { };  enum {- CEPH\_MDSC\_STOPPING\_BEGIN = 1,- CEPH\_MDSC\_STOPPING\_FLUSHED = 2,+ CEPH\_MDSC\_STOPPING\_BEGIN = 1,+ CEPH\_MDSC\_STOPPING\_FLUSHING = 2,+ CEPH\_MDSC\_STOPPING\_FLUSHED = 3, };  /\*@@ -419,7 +420,11 @@ struct ceph\_mds\_client { struct ceph\_mds\_session \*\*sessions; /\* NULL for mds if no session \*/ atomic\_t num\_sessions; int max\_sessions; /\* len of sessions array \*/- int stopping; /\* true if shutting down \*/++ spinlock\_t stopping\_lock; /\* protect snap\_empty \*/+ int stopping; /\* the stage of shutting down \*/+ atomic\_t stopping\_blockers;+ struct completion stopping\_waiter;  atomic64\_t quotarealms\_count; /\* # realms with quota \*/ /\*diff --git a/fs/ceph/quota.c b/fs/ceph/quota.cindex 64592adfe48fbc..f7fcf7f08ec642 100644--- a/[fs/ceph/quota.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/quota.c?id=230bd8b98ddfae3b7093671d4973236dc724d0bb)+++ b/[fs/ceph/quota.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/quota.c?id=e3dfcab2080dc1f9a4b09cc1327361bc2845bfcd)@@ -47,25 +47,23 @@ void ceph\_handle\_quota(struct ceph\_mds\_client \*mdsc, struct inode \*inode; struct ceph\_inode\_info \*ci; + if (!ceph\_inc\_mds\_stopping\_blocker(mdsc, session))+ return;+ if (msg->front.iov\_len < sizeof(\*h)) { pr\_err("%s corrupt message mds%d len %d\n", \_\_func\_\_, session->s\_mds, (int)msg->front.iov\_len); ceph\_msg\_dump(msg);- return;+ goto out; } - /\* increment msg sequence number \*/- mutex\_lock(&session->s\_mutex);- inc\_session\_sequence(session);- mutex\_unlock(&session->s\_mutex);- /\* lookup inode \*/ vino.ino = le64\_to\_cpu(h->ino); vino.snap = CEPH\_NOSNAP; inode = ceph\_find\_inode(sb, vino); if (!inode) { pr\_warn("Failed to find inode %llu\n", vino.ino);- return;+ goto out; } ci = ceph\_inode(inode); @@ -78,6 +76,8 @@ void ceph\_handle\_quota(struct ceph\_mds\_client \*mdsc, spin\_unlock(&ci->i\_ceph\_lock);  iput(inode);+out:+ ceph\_dec\_mds\_stopping\_blocker(mdsc); }  static struct ceph\_quotarealm\_inode \*diff --git a/fs/ceph/snap.c b/fs/ceph/snap.cindex 343d738448dcd9..7ddc6bad77ef3f 100644--- a/[fs/ceph/snap.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/snap.c?id=230bd8b98ddfae3b7093671d4973236dc724d0bb)+++ b/[fs/ceph/snap.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/snap.c?id=e3dfcab2080dc1f9a4b09cc1327361bc2845bfcd)@@ -1015,6 +1015,9 @@ void ceph\_handle\_snap(struct ceph\_mds\_client \*mdsc, int locked\_rwsem = 0; bool close\_sessions = false; + if (!ceph\_inc\_mds\_stopping\_blocker(mdsc, session))+ return;+ /\* decode \*/ if (msg->front.iov\_len < sizeof(\*h)) goto bad;@@ -1030,10 +1033,6 @@ void ceph\_handle\_snap(struct ceph\_mds\_client \*mdsc, dout("%s from mds%d op %s split %llx tracelen %d\n", \_\_func\_\_, mds, ceph\_snap\_op\_name(op), split, trace\_len); - mutex\_lock(&session->s\_mutex);- inc\_session\_sequence(session);- mutex\_unlock(&session->s\_mutex);- down\_write(&mdsc->snap\_rwsem); locked\_rwsem = 1; @@ -1151,6 +1150,7 @@ skip\_inode: up\_write(&mdsc->snap\_rwsem);  flush\_snaps(mdsc);+ ceph\_dec\_mds\_stopping\_blocker(mdsc); return;  bad:@@ -1160,6 +1160,8 @@ out: if (locked\_rwsem) up\_write(&mdsc->snap\_rwsem); + ceph\_dec\_mds\_stopping\_blocker(mdsc);+ if (close\_sessions) ceph\_mdsc\_close\_sessions(mdsc); return;diff --git a/fs/ceph/super.c b/fs/ceph/super.cindex 75dd1b6b3d0151..1c14d87ed87144 100644--- a/[fs/ceph/super.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/super.c?id=230bd8b98ddfae3b7093671d4973236dc724d0bb)+++ b/[fs/ceph/super.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/super.c?id=e3dfcab2080dc1f9a4b09cc1327361bc2845bfcd)@@ -1462,25 +1462,90 @@ nomem: return -ENOMEM; } +/\*+ \* Return true if it successfully increases the blocker counter,+ \* or false if the mdsc is in stopping and flushed state.+ \*/+static bool \_\_inc\_stopping\_blocker(struct ceph\_mds\_client \*mdsc)+{+ spin\_lock(&mdsc->stopping\_lock);+ if (mdsc->stopping >= CEPH\_MDSC\_STOPPING\_FLUSHING) {+ spin\_unlock(&mdsc->stopping\_lock);+ return false;+ }+ atomic\_inc(&mdsc->stopping\_blockers);+ spin\_unlock(&mdsc->stopping\_lock);+ return true;+}++static void \_\_dec\_stopping\_blocker(struct ceph\_mds\_client \*mdsc)+{+ spin\_lock(&mdsc->stopping\_lock);+ if (!atomic\_dec\_return(&mdsc->stopping\_blockers) &&+ mdsc->stopping >= CEPH\_MDSC\_STOPPING\_FLUSHING)+ complete\_all(&mdsc->stopping\_waiter);+ spin\_unlock(&mdsc->stopping\_lock);+}++/\* For metadata IO requests \*/+bool ceph\_inc\_mds\_stopping\_blocker(struct ceph\_mds\_client \*mdsc,+ struct ceph\_mds\_session \*session)+{+ mutex\_lock(&session->s\_mutex);+ inc\_session\_sequence(session);+ mutex\_unlock(&session->s\_mutex);++ return \_\_inc\_stopping\_blocker(mdsc);+}++void ceph\_dec\_mds\_stopping\_blocker(struct ceph\_mds\_client \*mdsc)+{+ \_\_dec\_stopping\_blocker(mdsc);+}+ static void ceph\_kill\_sb(struct super\_block \*s) { struct ceph\_fs\_client \*fsc = ceph\_sb\_to\_client(s);+ struct ceph\_mds\_client \*mdsc = fsc->mdsc;+ bool wait;  dout("kill\_sb %p\n", s); - ceph\_mdsc\_pre\_umount(fsc->mdsc);+ ceph\_mdsc\_pre\_umount(mdsc); flush\_fs\_workqueues(fsc);  /\* \* Though the kill\_anon\_super() will finally trigger the- \* sync\_filesystem() anyway, we still need to do it here- \* and then bump the stage of shutdown to stop the work- \* queue as earlier as possible.+ \* sync\_filesystem() anyway, we still need to do it here and+ \* then bump the stage of shutdown. This will allow us to+ \* drop any further message, which will increase the inodes'+ \* i\_count reference counters but makes no sense any more,+ \* from MDSs.+ \*+ \* Without this when evicting the inodes it may fail in the+ \* kill\_anon\_super(), which will trigger a warning when+ \* destroying the fscrypt keyring and then possibly trigger+ \* a further crash in ceph module when the iput() tries to+ \* evict the inodes later. \*/ sync\_filesystem(s); - fsc->mdsc->stopping = CEPH\_MDSC\_STOPPING\_FLUSHED;+ spin\_lock(&mdsc->stopping\_lock);+ mdsc->stopping = CEPH\_MDSC\_STOPPING\_FLUSHING;+ wait = !!atomic\_read(&mdsc->stopping\_blockers);+ spin\_unlock(&mdsc->stopping\_lock);++ if (wait && atomic\_read(&mdsc->stopping\_blockers)) {+ long timeleft = wait\_for\_completion\_killable\_timeout(+ &mdsc->stopping\_waiter,+ fsc->client->options->mount\_timeout);+ if (!timeleft) /\* timed out \*/+ pr\_warn("umount timed out, %ld\n", timeleft);+ else if (timeleft < 0) /\* killed \*/+ pr\_warn("umount was killed, %ld\n", timeleft);+ } + mdsc->stopping = CEPH\_MDSC\_STOPPING\_FLUSHED; kill\_anon\_super(s);  fsc->client->extra\_mon\_dispatch = NULL;diff --git a/fs/ceph/super.h b/fs/ceph/super.hindex b5e54c8f010b76..d8eb35d73a231a 100644--- a/[fs/ceph/super.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/super.h?id=230bd8b98ddfae3b7093671d4973236dc724d0bb)+++ b/[fs/ceph/super.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ceph/super.h?id=e3dfcab2080dc1f9a4b09cc1327361bc2845bfcd)@@ -1413,4 +1413,7 @@ extern bool ceph\_quota\_update\_statfs(struct ceph\_fs\_client \*fsc, struct kstatfs \*buf); extern void ceph\_cleanup\_quotarealms\_inodes(struct ceph\_mds\_client \*mdsc); +bool ceph\_inc\_mds\_stopping\_blocker(struct ceph\_mds\_client \*mdsc,+ struct ceph\_mds\_session \*session);+void ceph\_dec\_mds\_stopping\_blocker(struct ceph\_mds\_client \*mdsc); #endif /\* \_FS\_CEPH\_SUPER\_H \*/ |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 03:31:10 +0000

