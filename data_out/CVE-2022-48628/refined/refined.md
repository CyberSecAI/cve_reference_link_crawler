```
{
  "cveId": "CVE-2022-48628",
  "baseScore": "NOINFO",
  "impactScore": "NOINFO",
  "exploitabilityScore": "NOINFO",
  "vulnerability": [
    {
      "Description": "The vulnerability stems from a race condition during the unmounting of a Ceph filesystem. When unmounting, dirty buffers are flushed, and after the last OSD request, the inode's i_count is released, which then triggers flushing dirty cap/snap to MDSs. The unmounting process doesn't wait for possible acks, which leads to the inodes being held while updating metadata locally, but these inodes are skipped during the eviction process. If encryption is enabled, this can result in a warning when removing the encryption keys because the skipped inodes still hold the keyring. Later, a crash can occur when iput() is called on the inodes because sb->s_master_keys was already released by generic_shutdown_super().",
      "Root cause": "Race condition during Ceph filesystem unmount where inodes are skipped during eviction but their metadata is still being updated.",
      "Weaknesses": [
        "Race condition in handling inode metadata during unmount",
        "Improper synchronization of metadata updates and inode eviction",
        "Lack of proper waiting for metadata acknowledgments during unmount",
        "Potential use-after-free on superblock master keys"
      ],
      "Impact": "Kernel warning and potential crash due to use-after-free.",
       "Attack vectors": "Unmounting a Ceph filesystem.",
      "Required capabilities": "Requires the ability to unmount a Ceph filesystem with encrypted data."
    }
  ]
}
```