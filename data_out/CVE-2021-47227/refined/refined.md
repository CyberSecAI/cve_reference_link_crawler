The provided content describes a vulnerability in the Linux kernel's x86 FPU state restoration logic. The vulnerability is related to how the kernel handles user-provided FPU state during signal handling, specifically when using the XSAVE feature in a non-compacted format.

**Root cause of vulnerability:**

The root cause is an insecure copy operation in the `__fpu__restore_sig()` function when restoring FPU state from user space. The non-compacted slow path used `__copy_from_user()` to copy the entire user-provided buffer directly into the kernel's XSAVE buffer. This approach failed to validate the user-provided data, leading to potential corruption if the user supplied malicious data, which could trigger a #GP fault when attempting to restore the state using XRSTOR.

**Weaknesses/vulnerabilities present:**
- **Lack of input validation:** The kernel was not validating the user-provided XSAVE state when using the non-compacted format, allowing for arbitrary data to be copied into the kernel's buffer.
- **Incorrect handling of supervisor states:** Prior to XSAVES support, the kernel could reinitialize the buffer but, with supervisor states that is not longer possible. The buffer clearing code was not handling supervisor states correctly.

**Impact of exploitation:**

- **Kernel crash:** If a user provides corrupted data for the XSAVE state, the `XRSTOR` instruction can trigger a general protection fault (#GP), resulting in a kernel crash.

**Attack vectors:**

- The attacker must send a crafted signal that triggers the vulnerable code path, providing malicious XSAVE state through the signal's context.

**Required attacker capabilities/position:**

- The attacker must be able to execute code that can send signals and control the FPU state data passed to the kernel during the signal handling. This generally requires a local user with the ability to send signals to a process.

**Mitigation:**

The fix replaces the `__copy_from_user()` call and the separate header validation with a call to `copy_user_to_xstate()`, which validates the XSAVE header contents *before* copying the data, preventing the corruption of the kernel's XSAVE buffer.