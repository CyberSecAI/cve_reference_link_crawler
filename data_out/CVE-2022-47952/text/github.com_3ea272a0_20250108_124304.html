
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Flxc%2Flxc%2Fblob%2F0b83d71c2c8f3bac9503f894cd84584f79258bb3%2Fsrc%2Flxc%2Fcmd%2Flxc_user_nic.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Flxc%2Flxc%2Fblob%2F0b83d71c2c8f3bac9503f894cd84584f79258bb3%2Fsrc%2Flxc%2Fcmd%2Flxc_user_nic.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=lxc%2Flxc)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[lxc](/lxc)
/
**[lxc](/lxc/lxc)**
Public

* [Notifications](/login?return_to=%2Flxc%2Flxc) You must be signed in to change notification settings
* [Fork
  1.1k](/login?return_to=%2Flxc%2Flxc)
* [Star
   4.7k](/login?return_to=%2Flxc%2Flxc)

* [Code](/lxc/lxc)
* [Issues
  169](/lxc/lxc/issues)
* [Pull requests
  6](/lxc/lxc/pulls)
* [Actions](/lxc/lxc/actions)
* [Security](/lxc/lxc/security)
* [Insights](/lxc/lxc/pulse)

Additional navigation options

* [Code](/lxc/lxc)
* [Issues](/lxc/lxc/issues)
* [Pull requests](/lxc/lxc/pulls)
* [Actions](/lxc/lxc/actions)
* [Security](/lxc/lxc/security)
* [Insights](/lxc/lxc/pulse)

## Files

 0b83d71
## Breadcrumbs

1. [lxc](/lxc/lxc/tree/0b83d71c2c8f3bac9503f894cd84584f79258bb3)
2. /[src](/lxc/lxc/tree/0b83d71c2c8f3bac9503f894cd84584f79258bb3/src)
3. /[lxc](/lxc/lxc/tree/0b83d71c2c8f3bac9503f894cd84584f79258bb3/src/lxc)
4. /[cmd](/lxc/lxc/tree/0b83d71c2c8f3bac9503f894cd84584f79258bb3/src/lxc/cmd)
/
# lxc\_user\_nic.c

 Blame  Blame
## Latest commit

## History

[History](/lxc/lxc/commits/0b83d71c2c8f3bac9503f894cd84584f79258bb3/src/lxc/cmd/lxc_user_nic.c)1237 lines (1009 loc) · 27.8 KB 0b83d71
## Breadcrumbs

1. [lxc](/lxc/lxc/tree/0b83d71c2c8f3bac9503f894cd84584f79258bb3)
2. /[src](/lxc/lxc/tree/0b83d71c2c8f3bac9503f894cd84584f79258bb3/src)
3. /[lxc](/lxc/lxc/tree/0b83d71c2c8f3bac9503f894cd84584f79258bb3/src/lxc)
4. /[cmd](/lxc/lxc/tree/0b83d71c2c8f3bac9503f894cd84584f79258bb3/src/lxc/cmd)
/
# lxc\_user\_nic.c

Top
## File metadata and controls

* Code
* Blame

1237 lines (1009 loc) · 27.8 KB[Raw](https://github.com/lxc/lxc/raw/0b83d71c2c8f3bac9503f894cd84584f79258bb3/src/lxc/cmd/lxc_user_nic.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\* SPDX-License-Identifier: LGPL-2.1+ \*/
#include "config.h"
#include <arpa/inet.h>#include <ctype.h>#include <errno.h>#include <fcntl.h>#include <grp.h>#include <linux/netlink.h>#include <linux/rtnetlink.h>#include <linux/sockios.h>#include <net/if.h>#include <net/if\_arp.h>#include <netinet/in.h>#include <pwd.h>#include <sched.h>#include <stdbool.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <sys/file.h>#include <sys/ioctl.h>#include <sys/mman.h>#include <sys/param.h>#include <sys/socket.h>#include <sys/stat.h>#include <sys/types.h>#include <unistd.h>
#include "compiler.h"#include "file\_utils.h"#include "log.h"#include "memory\_utils.h"#include "network.h"#include "nl.h"#include "parse.h"#include "process\_utils.h"#include "string\_utils.h"#include "syscall\_wrappers.h"#include "utils.h"
#if !HAVE\_STRLCPY#include "strlcpy.h"#endif
#define usernic\_debug\_stream(stream, format, ...) \ do { \ fprintf(stream, "%s: %d: %s: " format, \_\_FILE\_\_, \_\_LINE\_\_, \ \_\_func\_\_, \_\_VA\_ARGS\_\_); \ } while (false)
#define usernic\_error(format, ...) usernic\_debug\_stream(stderr, format, \_\_VA\_ARGS\_\_)
#define cmd\_error\_errno(\_\_ret\_\_, \_\_errno\_\_, format, ...) \ ({ \ typeof(\_\_ret\_\_) \_\_internal\_ret\_\_ = (\_\_ret\_\_); \ errno = (\_\_errno\_\_); \ CMD\_SYSERROR(format, ##\_\_VA\_ARGS\_\_); \ \_\_internal\_ret\_\_; \ })
\_\_noreturn static void usage(bool fail){ fprintf(stderr, "Description:\n"); fprintf(stderr, " Manage nics in another network namespace\n\n");
 fprintf(stderr, "Usage:\n"); fprintf(stderr, " lxc-user-nic [command]\n\n");
 fprintf(stderr, "Available Commands:\n"); fprintf(stderr, " create {lxcpath} {name} {pid} {type} {bridge} {container nicname}\n"); fprintf(stderr, " delete {lxcpath} {name} {/proc/<pid>/ns/net} {type} {bridge} {container nicname}\n");
 if (fail) \_exit(EXIT\_FAILURE);
 \_exit(EXIT\_SUCCESS);}
static int open\_and\_lock(const char \*path){ \_\_do\_close int fd = -EBADF; int ret; struct flock lk;
 fd = open(path, O\_RDWR | O\_CREAT, S\_IWUSR | S\_IRUSR | O\_CLOEXEC); if (fd < 0) { CMD\_SYSERROR("Failed to open \"%s\"\n", path); return -1; }
 lk.l\_type = F\_WRLCK; lk.l\_whence = SEEK\_SET; lk.l\_start = 0; lk.l\_len = 0;
 ret = fcntl(fd, F\_SETLKW, &lk); if (ret < 0) { CMD\_SYSERROR("Failed to lock \"%s\"\n", path); return -1; }
 return move\_fd(fd);}
static char \*get\_username(void){ \_\_do\_free char \*buf = NULL; struct passwd pwent; struct passwd \*pwentp = NULL; ssize\_t bufsize; int ret;
 bufsize = sysconf(\_SC\_GETPW\_R\_SIZE\_MAX); if (bufsize < 0) bufsize = 1024;
 buf = malloc(bufsize); if (!buf) return NULL;
 ret = getpwuid\_r(getuid(), &pwent, buf, bufsize, &pwentp); if (!pwentp) { if (ret == 0) usernic\_error("%s", "Could not find matched password record\n");
 CMD\_SYSERROR("Failed to get username: %u\n", getuid()); return NULL; }
 return strdup(pwent.pw\_name);}
static char \*\*get\_groupnames(void){ \_\_do\_free char \*buf = NULL; \_\_do\_free gid\_t \*group\_ids = NULL; \_\_do\_free\_string\_list char \*\*groupnames = NULL; int ngroups; int ret, i; struct group grent; struct group \*grentp = NULL; ssize\_t bufsize;
 ngroups = getgroups(0, NULL); if (ngroups < 0) { CMD\_SYSERROR("Failed to get number of groups the user belongs to\n"); return NULL; }
 if (ngroups == 0) return NULL;
 group\_ids = malloc(sizeof(gid\_t) \* ngroups); if (!group\_ids) { CMD\_SYSERROR("Failed to allocate memory while getting groups the user belongs to\n"); return NULL; }
 ret = getgroups(ngroups, group\_ids); if (ret < 0) { CMD\_SYSERROR("Failed to get process groups\n"); return NULL; }
 groupnames = zalloc(sizeof(char \*) \* (ngroups + 1)); if (!groupnames) { CMD\_SYSERROR("Failed to allocate memory while getting group names\n"); return NULL; }
 bufsize = sysconf(\_SC\_GETGR\_R\_SIZE\_MAX); if (bufsize < 0) bufsize = 1024;
 buf = malloc(bufsize); if (!buf) { CMD\_SYSERROR("Failed to allocate memory while getting group names\n"); return NULL; }
 for (i = 0; i < ngroups; i++) { while ((ret = getgrgid\_r(group\_ids[i], &grent, buf, bufsize, &grentp)) == ERANGE) { char \*new\_buf;
 bufsize <<= 1; if (bufsize > MAX\_GRBUF\_SIZE) { usernic\_error("Failed to get group members: %u\n", group\_ids[i]); return NULL; }
 new\_buf = realloc(buf, bufsize); if (!new\_buf) { usernic\_error("Failed to allocate memory while getting group names: %s\n", strerror(errno)); return NULL; } buf = new\_buf; }
 /\* If a group is not found, just ignore it. \*/ if (!grentp) continue;
 groupnames[i] = strdup(grent.gr\_name); if (!groupnames[i]) { usernic\_error("Failed to copy group name \"%s\"", grent.gr\_name); return NULL; } }
 return move\_ptr(groupnames);}
static bool name\_is\_in\_groupnames(char \*name, char \*\*groupnames){ while (groupnames) { if (!strcmp(name, \*groupnames)) return true; groupnames++; }
 return false;}
struct alloted\_s { char \*name; int allowed; struct alloted\_s \*next;};
static struct alloted\_s \*append\_alloted(struct alloted\_s \*\*head, char \*name, int n){ \_\_do\_free struct alloted\_s \*al = NULL; struct alloted\_s \*cur;
 if (!head || !name) { /\* Sanity check. Parameters should not be null. \*/ usernic\_error("%s\n", "Unexpected NULL argument"); return NULL; }
 al = zalloc(sizeof(struct alloted\_s)); if (!al) { CMD\_SYSERROR("Failed to allocate memory\n"); return NULL; }
 al->name = strdup(name); if (!al->name) return NULL;
 al->allowed = n; al->next = NULL;
 if (\*head) { cur = \*head; while (cur->next) cur = cur->next; cur->next = al; } else { \*head = al; }
 return move\_ptr(al);}
static void free\_alloted(struct alloted\_s \*\*head){ struct alloted\_s \*cur;
 if (!head) return;
 cur = \*head; while (cur) { cur = cur->next; free((\*head)->name); free(\*head); \*head = cur; }}
/\* The configuration file consists of lines of the form: \* \* user type bridge count \* or \* @group type bridge count \* \* Return the count entry for the calling user if there is one. Else \* return -1. \*/static int get\_alloted(char \*me, char \*intype, char \*link, struct alloted\_s \*\*alloted){ \_\_do\_free char \*line = NULL; \_\_do\_fclose FILE \*fin = NULL; \_\_do\_free\_string\_list char \*\*groups = NULL; int n, ret; char name[100], type[100], br[100]; int count = 0; size\_t len = 0;
 fin = fopen(LXC\_USERNIC\_CONF, "re"); if (!fin) { CMD\_SYSERROR("Failed to open \"%s\"\n", LXC\_USERNIC\_CONF); return -1; }
 groups = get\_groupnames(); while ((getline(&line, &len, fin)) != -1) { ret = sscanf(line, "%99[^ \t] %99[^ \t] %99[^ \t] %d", name, type, br, &n); if (ret != 4) continue;
 if (is\_empty\_string(name)) continue;
 if (!strequal(name, me)) { if (name[0] != '@') continue;
 if (!name\_is\_in\_groupnames(name + 1, groups)) continue; }
 if (!strequal(type, intype)) continue;
 if (!strequal(link, br)) continue;
 /\* \* Found the user or group with the appropriate settings, \* therefore finish the search. What to do if there are is more \* than one applicable line? Currently this is not specified in \* the docs. \* \* If append\_alloted returns NULL, e.g. due to a malloc error, \* we set count to 0 and break the loop, allowing cleanup and \* then exiting from main(). \*/ if (!append\_alloted(alloted, name, n)) { count = 0; break; }
 count += n; }
 /\* Now return the total number of nics that this user can create. \*/ return count;}
static char \*get\_eol(char \*s, char \*e){ while ((s < e) && \*s && (\*s != '\n')) s++;
 return s;}
static char \*get\_eow(char \*s, char \*e){ while ((s < e) && \*s && !isblank(\*s) && (\*s != '\n')) s++;
 return s;}
static char \*find\_line(char \*buf\_start, char \*buf\_end, char \*name, char \*net\_type, char \*net\_link, char \*net\_dev, bool \*owner, bool \*found, bool \*keep){ char \*end\_of\_line, \*end\_of\_word, \*line;
 while (buf\_start < buf\_end) { size\_t len; char netdev\_name[IFNAMSIZ];
 \*found = false; \*keep = true; \*owner = false;
 end\_of\_line = get\_eol(buf\_start, buf\_end); if (end\_of\_line >= buf\_end) return NULL;
 line = buf\_start; if (\*buf\_start == '#') goto next;
 while ((buf\_start < buf\_end) && isblank(\*buf\_start)) buf\_start++;
 /\* Check whether the line contains the caller's name. \*/ end\_of\_word = get\_eow(buf\_start, buf\_end); /\* corrupt db \*/ if (!end\_of\_word) return NULL;
 if (strncmp(buf\_start, name, strlen(name))) \*found = false; else if (strlen(name) == (size\_t)(end\_of\_word - buf\_start)) \*owner = true;
 buf\_start = end\_of\_word + 1; while ((buf\_start < buf\_end) && isblank(\*buf\_start)) buf\_start++;
 /\* Check whether line is of the right network type. \*/ end\_of\_word = get\_eow(buf\_start, buf\_end); /\* corrupt db \*/ if (!end\_of\_word) return NULL;
 if (strncmp(buf\_start, net\_type, strlen(net\_type))) \*found = false;
 buf\_start = end\_of\_word + 1; while ((buf\_start < buf\_end) && isblank(\*buf\_start)) buf\_start++;
 /\* Check whether line is contains the right link. \*/ end\_of\_word = get\_eow(buf\_start, buf\_end); /\* corrupt db \*/ if (!end\_of\_word) return NULL;
 if (strncmp(buf\_start, net\_link, strlen(net\_link))) \*found = false;
 buf\_start = end\_of\_word + 1; while ((buf\_start < buf\_end) && isblank(\*buf\_start)) buf\_start++;
 /\* Check whether line contains the right network device. \*/ end\_of\_word = get\_eow(buf\_start, buf\_end); /\* corrupt db \*/ if (!end\_of\_word) return NULL;
 len = end\_of\_word - buf\_start; /\* corrupt db \*/ if (len >= IFNAMSIZ) return NULL;
 memcpy(netdev\_name, buf\_start, len); netdev\_name[len] = '\0'; \*keep = lxc\_nic\_exists(netdev\_name);
 if (net\_dev && !strcmp(netdev\_name, net\_dev)) \*found = true;
 return line;
 next: buf\_start = end\_of\_line + 1; }
 return NULL;}
static int instantiate\_veth(char \*veth1, char \*veth2, pid\_t pid, unsigned int mtu){ int ret;
 ret = lxc\_veth\_create(veth1, veth2, pid, mtu, -1, -1); if (ret < 0) { CMD\_SYSERROR("Failed to create %s-%s\n", veth1, veth2); return ret\_errno(-ret); }
 /\* \* Changing the high byte of the mac address to 0xfe, the bridge \* interface will always keep the host's mac address and not take the \* mac address of a container. \*/ ret = setup\_private\_host\_hw\_addr(veth1); if (ret < 0) { CMD\_SYSERROR("Failed to change mac address of host interface %s\n", veth1); return ret\_errno(-ret); }
 return netdev\_set\_flag(veth1, IFF\_UP);}
static int get\_mtu(char \*name){ int idx;
 idx = if\_nametoindex(name); if (idx < 0) return -1;
 return netdev\_get\_mtu(idx);}
static int create\_nic(char \*nic, char \*br, int pid, char \*\*cnic){ unsigned int mtu = 1500; int ret; char veth1buf[IFNAMSIZ], veth2buf[IFNAMSIZ];
 ret = snprintf(veth1buf, IFNAMSIZ, "%s", nic); if (ret < 0 || ret >= IFNAMSIZ) { usernic\_error("%s", "Could not create nic name\n"); return -1; }
 ret = snprintf(veth2buf, IFNAMSIZ, "%sp", veth1buf); if (ret < 0 || ret >= IFNAMSIZ) { usernic\_error("%s\n", "Could not create nic name"); return -1; }
 if (strcmp(br, "none")) mtu = get\_mtu(br); if (!mtu) mtu = 1500;
 /\* create the nics \*/ ret = instantiate\_veth(veth1buf, veth2buf, pid, mtu); if (ret < 0) { usernic\_error("%s", "Error creating veth tunnel\n"); return -1; }
 if (strcmp(br, "none")) { if (mtu > 0) { ret = lxc\_netdev\_set\_mtu(veth1buf, mtu); if (ret < 0) { usernic\_error("Failed to set mtu to %d on %s\n", mtu, veth1buf); goto out\_del; } }
 /\* attach veth1 to bridge \*/ ret = lxc\_bridge\_attach(br, veth1buf); if (ret < 0) { usernic\_error("Error attaching %s to %s\n", veth1buf, br); goto out\_del; } }
 \*cnic = strdup(veth2buf); if (!\*cnic) { usernic\_error("Failed to copy string \"%s\"\n", veth2buf); return -1; }
 return 0;
out\_del: lxc\_netdev\_delete\_by\_name(veth1buf); return -1;}
struct entry\_line { char \*start; int len; bool keep;};
static bool cull\_entries(int fd, char \*name, char \*net\_type, char \*net\_link, char \*net\_dev, bool \*found\_nicname){ \_\_do\_free char \*buf = NULL; \_\_do\_free struct entry\_line \*entry\_lines = NULL; int n = 0; size\_t length = 0; int ret; char \*buf\_end, \*buf\_start; bool found, keep;
 ret = fd\_to\_buf(fd, &buf, &length); if (ret < 0) { CMD\_SYSERROR("Failed to read database file\n"); return false; } if (lseek(fd, 0, SEEK\_SET) < 0) return false;
 if (length == 0) return false;
 buf\_start = buf; buf\_end = buf + length; while ((buf\_start = find\_line(buf\_start, buf\_end, name, net\_type, net\_link, net\_dev, &(bool){true}, &found, &keep))) { struct entry\_line \*newe;
 newe = realloc(entry\_lines, sizeof(\*entry\_lines) \* (n + 1)); if (!newe) return false;
 if (found) \*found\_nicname = true;
 entry\_lines = newe; entry\_lines[n].start = buf\_start; entry\_lines[n].len = get\_eol(buf\_start, buf\_end) - entry\_lines[n].start; entry\_lines[n].keep = keep; n++;
 buf\_start += entry\_lines[n - 1].len + 1; if (buf\_start >= buf\_end) break; }
 buf\_start = buf;
 for (int i = 0; i < n; i++) { if (!entry\_lines[i].keep) continue;
 memcpy(buf\_start, entry\_lines[i].start, entry\_lines[i].len); buf\_start += entry\_lines[i].len; \*buf\_start = '\n'; buf\_start++; }
 return ftruncate(fd, buf\_start - buf) == 0;}
static int count\_entries(char \*buf, off\_t len, char \*name, char \*net\_type, char \*net\_link){ int count = 0; bool owner = false; char \*buf\_end;
 buf\_end = &buf[len]; while ((buf = find\_line(buf, buf\_end, name, net\_type, net\_link, NULL, &owner, &(bool){true}, &(bool){true}))) { if (owner) count++;
 buf = get\_eol(buf, buf\_end) + 1; if (buf >= buf\_end) break; }
 return count;}
/\* The dbfile has lines of the format: user type bridge nicname. \*/static char \*get\_nic\_if\_avail(int fd, struct alloted\_s \*names, int pid, char \*intype, char \*br, int allowed, char \*\*cnic){ \_\_do\_free char \*buf = NULL, \*newline = NULL; size\_t length = 0; int ret; size\_t slen; ssize\_t nbytes; char \*owner; char nicname[IFNAMSIZ]; struct alloted\_s \*n; uid\_t uid;
 for (n = names; n != NULL; n = n->next) cull\_entries(fd, n->name, intype, br, NULL, NULL);
 if (allowed == 0) return NULL;
 owner = names->name;
 ret = fd\_to\_buf(fd, &buf, &length); if (ret < 0) { CMD\_SYSERROR("Failed to read database file\n"); return false; } if (lseek(fd, 0, SEEK\_SET) < 0) return false;
 if (length > 0) { owner = NULL;
 for (n = names; n != NULL; n = n->next) { int count;
 count = count\_entries(buf, length, n->name, intype, br); if (count >= n->allowed) continue;
 owner = n->name; break; } }
 if (!owner) return NULL;
 uid = getuid(); /\* \* For POSIX integer uids the network device name schema is \* vethUID\_XXXX. \* With four random characters passed to \* lxc\_ifname\_alnum\_case\_sensitive() we get 62^4 = 14776336 \* combinations per uid. That's plenty of network devices for now. \*/ if (uid > 0 && uid <= 65536) ret = snprintf(nicname, sizeof(nicname), "veth%d\_XXXX", uid); else ret = snprintf(nicname, sizeof(nicname), "vethXXXXXX"); if (ret < 0 || (size\_t)ret >= sizeof(nicname)) return NULL;
 if (!lxc\_ifname\_alnum\_case\_sensitive(nicname)) return NULL;
 ret = create\_nic(nicname, br, pid, cnic); if (ret < 0) { usernic\_error("%s", "Failed to create new nic\n"); return NULL; }
 /\* strlen(owner) \* + \* " " \* + \* strlen(intype) \* + \* " " \* + \* strlen(br) \* + \* " " \* + \* strlen(nicname) \* + \* \n \* + \* \0 \*/ slen = strlen(owner) + strlen(intype) + strlen(br) + strlen(nicname) + 4; newline = malloc(slen + 1); if (!newline) { CMD\_SYSERROR("Failed allocate memory\n"); return NULL; }
 ret = snprintf(newline, slen + 1, "%s %s %s %s\n", owner, intype, br, nicname); if (ret < 0 || (size\_t)ret >= (slen + 1)) { if (lxc\_netdev\_delete\_by\_name(nicname) != 0) usernic\_error("Error unlinking %s\n", nicname);
 return NULL; }
 nbytes = lxc\_pwrite\_nointr(fd, newline, slen, length); if (nbytes < 0 || (size\_t)nbytes != slen) { CMD\_SYSERROR("Failed to append new entry \"%s\" to database file", newline);
 if (lxc\_netdev\_delete\_by\_name(nicname) != 0) usernic\_error("Error unlinking %s\n", nicname);
 return NULL; }
 ret = ftruncate(fd, length + slen); if (ret < 0) { CMD\_SYSERROR("Failed to truncate file\n");
 if (lxc\_netdev\_delete\_by\_name(nicname) != 0) usernic\_error("Error unlinking %s\n", nicname);
 return NULL; }
 return strdup(nicname);}
static bool create\_db\_dir(char \*fnam){ \_\_do\_free char \*copy = NULL; char \*p; int ret;
 copy = must\_copy\_string(fnam); p = copy; fnam = p; p = p + 1;
again: while (\*p && \*p != '/') p++;
 if (!\*p) return true;
 \*p = '\0';
 ret = mkdir(fnam, 0755); if (ret < 0 && errno != EEXIST) { CMD\_SYSERROR("Failed to create %s\n", fnam); \*p = '/'; return false; }
 \*(p++) = '/';
 goto again;}
static char \*lxc\_secure\_rename\_in\_ns(int pid, char \*oldname, char \*newname, int \*container\_veth\_ifidx){ \_\_do\_close int fd = -EBADF, ofd = -EBADF; int fret = -1; int ifindex, ret; pid\_t pid\_self; uid\_t ruid, suid, euid; char ifname[IFNAMSIZ];
 pid\_self = lxc\_raw\_getpid();
 ofd = lxc\_preserve\_ns(pid\_self, "net"); if (ofd < 0) return cmd\_error\_errno(NULL, errno, "Failed opening network namespace path for %d", pid\_self);
 fd = lxc\_preserve\_ns(pid, "net"); if (fd < 0) return cmd\_error\_errno(NULL, errno, "Failed opening network namespace path for %d", pid);
 ret = getresuid(&ruid, &euid, &suid); if (ret < 0) return cmd\_error\_errno(NULL, errno, "Failed to retrieve real, effective, and saved user IDs\n");
 ret = setns(fd, CLONE\_NEWNET); if (ret < 0) return cmd\_error\_errno(NULL, errno, "Failed to setns() to the network namespace of the container with PID %d\n", pid);
 ret = setresuid(ruid, ruid, 0); if (ret < 0) { CMD\_SYSERROR("Failed to drop privilege by setting effective user id and real user id to %d, and saved user ID to 0\n", ruid); /\* \* It's ok to jump to do\_full\_cleanup here since setresuid() \* will succeed when trying to set real, effective, and saved \* to values they currently have. \*/ goto out\_setns; }
 /\* Check if old interface exists. \*/ ifindex = if\_nametoindex(oldname); if (!ifindex) { CMD\_SYSERROR("Failed to get netdev index\n"); goto out\_setresuid; }
 /\* \* When the IFLA\_IFNAME attribute is passed something like "<prefix>%d" \* netlink will replace the format specifier with an appropriate index. \* So we pass "eth%d". \*/ ret = lxc\_netdev\_rename\_by\_name(oldname, newname ? newname : "eth%d"); if (ret < 0) { CMD\_SYSERROR("Error %d renaming netdev %s to %s in container\n", ret, oldname, newname ? newname : "eth%d"); goto out\_setresuid; }
 /\* Retrieve new name for interface. \*/ if (!if\_indextoname(ifindex, ifname)) { CMD\_SYSERROR("Failed to get new netdev name\n"); goto out\_setresuid; }
 fret = 0;
out\_setresuid: ret = setresuid(ruid, euid, suid); if (ret < 0) return cmd\_error\_errno(NULL, errno, "Failed to restore privilege by setting effective user id to %d, real user id to %d, and saved user ID to %d\n", ruid, euid, suid);
out\_setns: ret = setns(ofd, CLONE\_NEWNET); if (ret < 0) return cmd\_error\_errno(NULL, errno, "Failed to setns() to original network namespace of PID %d\n", ofd);
 if (fret < 0) return NULL;
 \*container\_veth\_ifidx = ifindex; return strdup(ifname);}
/\* If the caller (real uid, not effective uid) may read the /proc/[pid]/ns/net, \* then it is either the caller's netns or one which it created. \*/static bool may\_access\_netns(int pid){ int ret; char s[200]; uid\_t ruid, suid, euid; bool may\_access = false;
 ret = getresuid(&ruid, &euid, &suid); if (ret < 0) { CMD\_SYSERROR("Failed to retrieve real, effective, and saved user IDs\n"); return false; }
 ret = setresuid(ruid, ruid, euid); if (ret < 0) { CMD\_SYSERROR("Failed to drop privilege by setting effective user id and real user id to %d, and saved user ID to %d\n", ruid, euid); return false; }
 ret = snprintf(s, 200, "/proc/%d/ns/net", pid); if (ret < 0 || ret >= 200) return false;
 ret = access(s, R\_OK); may\_access = true; if (ret < 0) { may\_access = false; CMD\_SYSERROR("Uid %d may not access %s\n", (int)ruid, s); }
 ret = setresuid(ruid, euid, suid); if (ret < 0) { CMD\_SYSERROR("Failed to restore user id to %d, real user id to %d, and saved user ID to %d\n", ruid, euid, suid); may\_access = false; }
 return may\_access;}
struct user\_nic\_args { char \*cmd; char \*lxc\_path; char \*lxc\_name; char \*pid; char \*type; char \*link; char \*veth\_name;};
enum lxc\_user\_nic\_command { LXC\_USERNIC\_CREATE = 0, LXC\_USERNIC\_DELETE = 1,};
static bool is\_privileged\_over\_netns(int netns\_fd){ int ofd, ret; pid\_t pid\_self; uid\_t euid, ruid, suid; bool bret = false;
 pid\_self = lxc\_raw\_getpid();
 ofd = lxc\_preserve\_ns(pid\_self, "net"); if (ofd < 0) { usernic\_error("Failed opening network namespace path for %d", pid\_self); return false; }
 ret = getresuid(&ruid, &euid, &suid); if (ret < 0) { CMD\_SYSERROR("Failed to retrieve real, effective, and saved user IDs\n"); goto do\_partial\_cleanup; }
 ret = setns(netns\_fd, CLONE\_NEWNET); if (ret < 0) { CMD\_SYSERROR("Failed to setns() to network namespace\n"); goto do\_partial\_cleanup; }
 ret = setresuid(ruid, ruid, 0); if (ret < 0) { CMD\_SYSERROR("Failed to drop privilege by setting effective user id and real user id to %d, and saved user ID to 0\n", ruid); /\* It's ok to jump to do\_full\_cleanup here since setresuid() \* will succeed when trying to set real, effective, and saved to \* values they currently have. \*/ goto do\_full\_cleanup; }
 /\* Test whether we are privileged over the network namespace. To do this \* we try to delete the loopback interface which is not possible. If we \* are privileged over the network namespace we will get ENOTSUP. If we \* are not privileged over the network namespace we will get EPERM. \*/ ret = lxc\_netdev\_delete\_by\_name("lo"); if (ret == -ENOTSUP) bret = true;
[View remainder of file in raw view](https://github.com/lxc/lxc/raw/0b83d71c2c8f3bac9503f894cd84584f79258bb3/src/lxc/cmd/lxc_user_nic.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

