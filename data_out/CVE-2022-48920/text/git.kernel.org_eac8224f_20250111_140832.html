

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=850a77c999b81dd2724efd2684068d6f90db8c16)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=850a77c999b81dd2724efd2684068d6f90db8c16)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=850a77c999b81dd2724efd2684068d6f90db8c16)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=850a77c999b81dd2724efd2684068d6f90db8c16)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Filipe Manana <fdmanana@suse.com> | 2022-02-02 15:26:09 +0000 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2022-03-08 19:12:29 +0100 |
| commit | [850a77c999b81dd2724efd2684068d6f90db8c16](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=850a77c999b81dd2724efd2684068d6f90db8c16) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=850a77c999b81dd2724efd2684068d6f90db8c16)) | |
| tree | [e29c6be53d53b0bb64a9f253226d53a587d84473](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=850a77c999b81dd2724efd2684068d6f90db8c16) | |
| parent | [6279c5263dedc6af67c194ec8e0f91bc2849cdf8](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6279c5263dedc6af67c194ec8e0f91bc2849cdf8) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=850a77c999b81dd2724efd2684068d6f90db8c16&id2=6279c5263dedc6af67c194ec8e0f91bc2849cdf8)) | |
| download | [linux-850a77c999b81dd2724efd2684068d6f90db8c16.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-850a77c999b81dd2724efd2684068d6f90db8c16.tar.gz) | |

btrfs: get rid of warning on transaction commit when using flushoncommit[ Upstream commit a0f0cf8341e34e5d2265bfd3a7ad68342da1e2aa ]
When using the flushoncommit mount option, during almost every transaction
commit we trigger a warning from \_\_writeback\_inodes\_sb\_nr():
$ cat fs/fs-writeback.c:
(...)
static void \_\_writeback\_inodes\_sb\_nr(struct super\_block \*sb, ...
{
(...)
WARN\_ON(!rwsem\_is\_locked(&sb->s\_umount));
(...)
}
(...)
The trace produced in dmesg looks like the following:
[947.473890] WARNING: CPU: 5 PID: 930 at fs/fs-writeback.c:2610 \_\_writeback\_inodes\_sb\_nr+0x7e/0xb3
[947.481623] Modules linked in: nfsd nls\_cp437 cifs asn1\_decoder cifs\_arc4 fscache cifs\_md4 ipmi\_ssif
[947.489571] CPU: 5 PID: 930 Comm: btrfs-transacti Not tainted 95.16.3-srb-asrock-00001-g36437ad63879 #186
[947.497969] RIP: 0010:\_\_writeback\_inodes\_sb\_nr+0x7e/0xb3
[947.502097] Code: 24 10 4c 89 44 24 18 c6 (...)
[947.519760] RSP: 0018:ffffc90000777e10 EFLAGS: 00010246
[947.523818] RAX: 0000000000000000 RBX: 0000000000963300 RCX: 0000000000000000
[947.529765] RDX: 0000000000000000 RSI: 000000000000fa51 RDI: ffffc90000777e50
[947.535740] RBP: ffff888101628a90 R08: ffff888100955800 R09: ffff888100956000
[947.541701] R10: 0000000000000002 R11: 0000000000000001 R12: ffff888100963488
[947.547645] R13: ffff888100963000 R14: ffff888112fb7200 R15: ffff888100963460
[947.553621] FS: 0000000000000000(0000) GS:ffff88841fd40000(0000) knlGS:0000000000000000
[947.560537] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[947.565122] CR2: 0000000008be50c4 CR3: 000000000220c000 CR4: 00000000001006e0
[947.571072] Call Trace:
[947.572354] <TASK>
[947.573266] btrfs\_commit\_transaction+0x1f1/0x998
[947.576785] ? start\_transaction+0x3ab/0x44e
[947.579867] ? schedule\_timeout+0x8a/0xdd
[947.582716] transaction\_kthread+0xe9/0x156
[947.585721] ? btrfs\_cleanup\_transaction.isra.0+0x407/0x407
[947.590104] kthread+0x131/0x139
[947.592168] ? set\_kthread\_struct+0x32/0x32
[947.595174] ret\_from\_fork+0x22/0x30
[947.597561] </TASK>
[947.598553] ---[ end trace 644721052755541c ]---
This is because we started using writeback\_inodes\_sb() to flush delalloc
when committing a transaction (when using -o flushoncommit), in order to
avoid deadlocks with filesystem freeze operations. This change was made
by commit ce8ea7cc6eb313 ("btrfs: don't call btrfs\_start\_delalloc\_roots
in flushoncommit"). After that change we started producing that warning,
and every now and then a user reports this since the warning happens too
often, it spams dmesg/syslog, and a user is unsure if this reflects any
problem that might compromise the filesystem's reliability.
We can not just lock the sb->s\_umount semaphore before calling
writeback\_inodes\_sb(), because that would at least deadlock with
filesystem freezing, since at fs/super.c:freeze\_super() sync\_filesystem()
is called while we are holding that semaphore in write mode, and that can
trigger a transaction commit, resulting in a deadlock. It would also
trigger the same type of deadlock in the unmount path. Possibly, it could
also introduce some other locking dependencies that lockdep would report.
To fix this call try\_to\_writeback\_inodes\_sb() instead of
writeback\_inodes\_sb(), because that will try to read lock sb->s\_umount
and then will only call writeback\_inodes\_sb() if it was able to lock it.
This is fine because the cases where it can't read lock sb->s\_umount
are during a filesystem unmount or during a filesystem freeze - in those
cases sb->s\_umount is write locked and sync\_filesystem() is called, which
calls writeback\_inodes\_sb(). In other words, in all cases where we can't
take a read lock on sb->s\_umount, writeback is already being triggered
elsewhere.
An alternative would be to call btrfs\_start\_delalloc\_roots() with a
number of pages different from LONG\_MAX, for example matching the number
of delalloc bytes we currently have, in which case we would end up
starting all delalloc with filemap\_fdatawrite\_wbc() and not with an
async flush via filemap\_flush() - that is only possible after the rather
recent commit e076ab2a2ca70a ("btrfs: shrink delalloc pages instead of
full inodes"). However that creates a whole new can of worms due to new
lock dependencies, which lockdep complains, like for example:
[ 8948.247280] ======================================================
[ 8948.247823] WARNING: possible circular locking dependency detected
[ 8948.248353] 5.17.0-rc1-btrfs-next-111 #1 Not tainted
[ 8948.248786] ------------------------------------------------------
[ 8948.249320] kworker/u16:18/933570 is trying to acquire lock:
[ 8948.249812] ffff9b3de1591690 (sb\_internal#2){.+.+}-{0:0}, at: find\_free\_extent+0x141e/0x1590 [btrfs]
[ 8948.250638]
but task is already holding lock:
[ 8948.251140] ffff9b3e09c717d8 (&root->delalloc\_mutex){+.+.}-{3:3}, at: start\_delalloc\_inodes+0x78/0x400 [btrfs]
[ 8948.252018]
which lock already depends on the new lock.
[ 8948.252710]
the existing dependency chain (in reverse order) is:
[ 8948.253343]
-> #2 (&root->delalloc\_mutex){+.+.}-{3:3}:
[ 8948.253950] \_\_mutex\_lock+0x90/0x900
[ 8948.254354] start\_delalloc\_inodes+0x78/0x400 [btrfs]
[ 8948.254859] btrfs\_start\_delalloc\_roots+0x194/0x2a0 [btrfs]
[ 8948.255408] btrfs\_commit\_transaction+0x32f/0xc00 [btrfs]
[ 8948.255942] btrfs\_mksubvol+0x380/0x570 [btrfs]
[ 8948.256406] btrfs\_mksnapshot+0x81/0xb0 [btrfs]
[ 8948.256870] \_\_btrfs\_ioctl\_snap\_create+0x17f/0x190 [btrfs]
[ 8948.257413] btrfs\_ioctl\_snap\_create\_v2+0xbb/0x140 [btrfs]
[ 8948.257961] btrfs\_ioctl+0x1196/0x3630 [btrfs]
[ 8948.258418] \_\_x64\_sys\_ioctl+0x83/0xb0
[ 8948.258793] do\_syscall\_64+0x3b/0xc0
[ 8948.259146] entry\_SYSCALL\_64\_after\_hwframe+0x44/0xae
[ 8948.259709]
-> #1 (&fs\_info->delalloc\_root\_mutex){+.+.}-{3:3}:
[ 8948.260330] \_\_mutex\_lock+0x90/0x900
[ 8948.260692] btrfs\_start\_delalloc\_roots+0x97/0x2a0 [btrfs]
[ 8948.261234] btrfs\_commit\_transaction+0x32f/0xc00 [btrfs]
[ 8948.261766] btrfs\_set\_free\_space\_cache\_v1\_active+0x38/0x60 [btrfs]
[ 8948.262379] btrfs\_start\_pre\_rw\_mount+0x119/0x180 [btrfs]
[ 8948.262909] open\_ctree+0x1511/0x171e [btrfs]
[ 8948.263359] btrfs\_mount\_root.cold+0x12/0xde [btrfs]
[ 8948.263863] legacy\_get\_tree+0x30/0x50
[ 8948.264242] vfs\_get\_tree+0x28/0xc0
[ 8948.264594] vfs\_kern\_mount.part.0+0x71/0xb0
[ 8948.265017] btrfs\_mount+0x11d/0x3a0 [btrfs]
[ 8948.265462] legacy\_get\_tree+0x30/0x50
[ 8948.265851] vfs\_get\_tree+0x28/0xc0
[ 8948.266203] path\_mount+0x2d4/0xbe0
[ 8948.266554] \_\_x64\_sys\_mount+0x103/0x140
[ 8948.266940] do\_syscall\_64+0x3b/0xc0
[ 8948.267300] entry\_SYSCALL\_64\_after\_hwframe+0x44/0xae
[ 8948.267790]
-> #0 (sb\_internal#2){.+.+}-{0:0}:
[ 8948.268322] \_\_lock\_acquire+0x12e8/0x2260
[ 8948.268733] lock\_acquire+0xd7/0x310
[ 8948.269092] start\_transaction+0x44c/0x6e0 [btrfs]
[ 8948.269591] find\_free\_extent+0x141e/0x1590 [btrfs]
[ 8948.270087] btrfs\_reserve\_extent+0x14b/0x280 [btrfs]
[ 8948.270588] cow\_file\_range+0x17e/0x490 [btrfs]
[ 8948.271051] btrfs\_run\_delalloc\_range+0x345/0x7a0 [btrfs]
[ 8948.271586] writepage\_delalloc+0xb5/0x170 [btrfs]
[ 8948.272071] \_\_extent\_writepage+0x156/0x3c0 [btrfs]
[ 8948.272579] extent\_write\_cache\_pages+0x263/0x460 [btrfs]
[ 8948.273113] extent\_writepages+0x76/0x130 [btrfs]
[ 8948.273573] do\_writepages+0xd2/0x1c0
[ 8948.273942] filemap\_fdatawrite\_wbc+0x68/0x90
[ 8948.274371] start\_delalloc\_inodes+0x17f/0x400 [btrfs]
[ 8948.274876] btrfs\_start\_delalloc\_roots+0x194/0x2a0 [btrfs]
[ 8948.275417] flush\_space+0x1f2/0x630 [btrfs]
[ 8948.275863] btrfs\_async\_reclaim\_data\_space+0x108/0x1b0 [btrfs]
[ 8948.276438] process\_one\_work+0x252/0x5a0
[ 8948.276829] worker\_thread+0x55/0x3b0
[ 8948.277189] kthread+0xf2/0x120
[ 8948.277506] ret\_from\_fork+0x22/0x30
[ 8948.277868]
other info that might help us debug this:
[ 8948.278548] Chain exists of:
sb\_internal#2 --> &fs\_info->delalloc\_root\_mutex --> &root->delalloc\_mutex
[ 8948.279601] Possible unsafe locking scenario:
[ 8948.280102] CPU0 CPU1
[ 8948.280508] ---- ----
[ 8948.280915] lock(&root->delalloc\_mutex);
[ 8948.281271] lock(&fs\_info->delalloc\_root\_mutex);
[ 8948.281915] lock(&root->delalloc\_mutex);
[ 8948.282487] lock(sb\_internal#2);
[ 8948.282800]
\*\*\* DEADLOCK \*\*\*
[ 8948.283333] 4 locks held by kworker/u16:18/933570:
[ 8948.283750] #0: ffff9b3dc00a9d48 ((wq\_completion)events\_unbound){+.+.}-{0:0}, at: process\_one\_work+0x1d2/0x5a0
[ 8948.284609] #1: ffffa90349dafe70 ((work\_completion)(&fs\_info->async\_data\_reclaim\_work)){+.+.}-{0:0}, at: process\_one\_work+0x1d2/0x5a0
[ 8948.285637] #2: ffff9b3e14db5040 (&fs\_info->delalloc\_root\_mutex){+.+.}-{3:3}, at: btrfs\_start\_delalloc\_roots+0x97/0x2a0 [btrfs]
[ 8948.286674] #3: ffff9b3e09c717d8 (&root->delalloc\_mutex){+.+.}-{3:3}, at: start\_delalloc\_inodes+0x78/0x400 [btrfs]
[ 8948.287596]
stack backtrace:
[ 8948.287975] CPU: 3 PID: 933570 Comm: kworker/u16:18 Not tainted 5.17.0-rc1-btrfs-next-111 #1
[ 8948.288677] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04/01/2014
[ 8948.289649] Workqueue: events\_unbound btrfs\_async\_reclaim\_data\_space [btrfs]
[ 8948.290298] Call Trace:
[ 8948.290517] <TASK>
[ 8948.290700] dump\_stack\_lvl+0x59/0x73
[ 8948.291026] check\_noncircular+0xf3/0x110
[ 8948.291375] ? start\_transaction+0x228/0x6e0 [btrfs]
[ 8948.291826] \_\_lock\_acquire+0x12e8/0x2260
[ 8948.292241] lock\_acquire+0xd7/0x310
[ 8948.292714] ? find\_free\_extent+0x141e/0x1590 [btrfs]
[ 8948.293241] ? lock\_is\_held\_type+0xea/0x140
[ 8948.293601] start\_transaction+0x44c/0x6e0 [btrfs]
[ 8948.294055] ? find\_free\_extent+0x141e/0x1590 [btrfs]
[ 8948.294518] find\_free\_extent+0x141e/0x1590 [btrfs]
[ 8948.294957] ? \_raw\_spin\_unlock+0x29/0x40
[ 8948.295312] ? btrfs\_get\_alloc\_profile+0x124/0x290 [btrfs]
[ 8948.295813] btrfs\_reserve\_extent+0x14b/0x280 [btrfs]
[ 8948.296270] cow\_file\_range+0x17e/0x490 [btrfs]
[ 8948.296691] btrfs\_run\_delalloc\_range+0x345/0x7a0 [btrfs]
[ 8948.297175] ? find\_lock\_delalloc\_range+0x247/0x270 [btrfs]
[ 8948.297678] writepage\_delalloc+0xb5/0x170 [btrfs]
[ 8948.298123] \_\_extent\_writepage+0x156/0x3c0 [btrfs]
[ 8948.298570] extent\_write\_cache\_pages+0x263/0x460 [btrfs]
[ 8948.299061] extent\_writepages+0x76/0x130 [btrfs]
[ 8948.299495] do\_writepages+0xd2/0x1c0
[ 8948.299817] ? sched\_clock\_cpu+0xd/0x110
[ 8948.300160] ? lock\_release+0x155/0x4a0
[ 8948.300494] filemap\_fdatawrite\_wbc+0x68/0x90
[ 8948.300874] ? do\_raw\_spin\_unlock+0x4b/0xa0
[ 8948.301243] start\_delalloc\_inodes+0x17f/0x400 [btrfs]
[ 8948.301706] ? lock\_release+0x155/0x4a0
[ 8948.302055] btrfs\_start\_delalloc\_roots+0x194/0x2a0 [btrfs]
[ 8948.302564] flush\_space+0x1f2/0x630 [btrfs]
[ 8948.302970] btrfs\_async\_reclaim\_data\_space+0x108/0x1b0 [btrfs]
[ 8948.303510] process\_one\_work+0x252/0x5a0
[ 8948.303860] ? process\_one\_work+0x5a0/0x5a0
[ 8948.304221] worker\_thread+0x55/0x3b0
[ 8948.304543] ? process\_one\_work+0x5a0/0x5a0
[ 8948.304904] kthread+0xf2/0x120
[ 8948.305184] ? kthread\_complete\_and\_exit+0x20/0x20
[ 8948.305598] ret\_from\_fork+0x22/0x30
[ 8948.305921] </TASK>
It all comes from the fact that btrfs\_start\_delalloc\_roots() takes the
delalloc\_root\_mutex, in the transaction commit path we are holding a
read lock on one of the superblock's freeze semaphores (via
sb\_start\_intwrite()), the async reclaim task can also do a call to
btrfs\_start\_delalloc\_roots(), which ends up triggering writeback with
calls to filemap\_fdatawrite\_wbc(), resulting in extent allocation which
in turn can call btrfs\_start\_transaction(), which will result in taking
the freeze semaphore via sb\_start\_intwrite(), forming a nasty dependency
on all those locks which can be taken in different orders by different
code paths.
So just adopt the simple approach of calling try\_to\_writeback\_inodes\_sb()
at btrfs\_start\_delalloc\_flush().
Link: [https://lore.kernel.org/linux-btrfs/20220130005258.GA7465@cuci.nl/](https://lore.kernel.org/linux-btrfs/20220130005258.GA7465%40cuci.nl/)
Link: [https://lore.kernel.org/linux-btrfs/43acc426-d683-d1b6-729d-c6bc4a2fff4d@gmail.com/](https://lore.kernel.org/linux-btrfs/43acc426-d683-d1b6-729d-c6bc4a2fff4d%40gmail.com/)
Link: [https://lore.kernel.org/linux-btrfs/6833930a-08d7-6fbc-0141-eb9cdfd6bb4d@gmail.com/](https://lore.kernel.org/linux-btrfs/6833930a-08d7-6fbc-0141-eb9cdfd6bb4d%40gmail.com/)
Link: [https://lore.kernel.org/linux-btrfs/20190322041731.GF16651@hungrycats.org/](https://lore.kernel.org/linux-btrfs/20190322041731.GF16651%40hungrycats.org/)
Reviewed-by: Omar Sandoval <osandov@fb.com>
Signed-off-by: Filipe Manana <fdmanana@suse.com>
[ add more link reports ]
Signed-off-by: David Sterba <dsterba@suse.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=850a77c999b81dd2724efd2684068d6f90db8c16)

| -rw-r--r-- | [fs/btrfs/transaction.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/transaction.c?id=850a77c999b81dd2724efd2684068d6f90db8c16) | 12 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 10 insertions, 2 deletions

| diff --git a/fs/btrfs/transaction.c b/fs/btrfs/transaction.cindex f1ae5a5b79c685..e3e9c58ea66faa 100644--- a/[fs/btrfs/transaction.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/transaction.c?id=6279c5263dedc6af67c194ec8e0f91bc2849cdf8)+++ b/[fs/btrfs/transaction.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/transaction.c?id=850a77c999b81dd2724efd2684068d6f90db8c16)@@ -2014,16 +2014,24 @@ static void btrfs\_cleanup\_pending\_block\_groups(struct btrfs\_trans\_handle \*trans) static inline int btrfs\_start\_delalloc\_flush(struct btrfs\_fs\_info \*fs\_info) { /\*- \* We use writeback\_inodes\_sb here because if we used+ \* We use try\_to\_writeback\_inodes\_sb() here because if we used \* btrfs\_start\_delalloc\_roots we would deadlock with fs freeze. \* Currently are holding the fs freeze lock, if we do an async flush \* we'll do btrfs\_join\_transaction() and deadlock because we need to \* wait for the fs freeze lock. Using the direct flushing we benefit \* from already being in a transaction and our join\_transaction doesn't \* have to re-take the fs freeze lock.+ \*+ \* Note that try\_to\_writeback\_inodes\_sb() will only trigger writeback+ \* if it can read lock sb->s\_umount. It will always be able to lock it,+ \* except when the filesystem is being unmounted or being frozen, but in+ \* those cases sync\_filesystem() is called, which results in calling+ \* writeback\_inodes\_sb() while holding a write lock on sb->s\_umount.+ \* Note that we don't call writeback\_inodes\_sb() directly, because it+ \* will emit a warning if sb->s\_umount is not locked. \*/ if (btrfs\_test\_opt(fs\_info, FLUSHONCOMMIT))- writeback\_inodes\_sb(fs\_info->sb, WB\_REASON\_SYNC);+ try\_to\_writeback\_inodes\_sb(fs\_info->sb, WB\_REASON\_SYNC); return 0; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 14:07:09 +0000

