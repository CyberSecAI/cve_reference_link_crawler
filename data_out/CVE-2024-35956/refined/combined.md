=== Content from git.kernel.org_c8e83c8d_20250111_054510.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=14431815a4ae4bcd7c7a68b6a64c66c7712d27c9)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=14431815a4ae4bcd7c7a68b6a64c66c7712d27c9)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=14431815a4ae4bcd7c7a68b6a64c66c7712d27c9)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=14431815a4ae4bcd7c7a68b6a64c66c7712d27c9)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Boris Burkov <boris@bur.io> | 2024-03-21 10:02:04 -0700 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-04-17 11:19:33 +0200 |
| commit | [14431815a4ae4bcd7c7a68b6a64c66c7712d27c9](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=14431815a4ae4bcd7c7a68b6a64c66c7712d27c9) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=14431815a4ae4bcd7c7a68b6a64c66c7712d27c9)) | |
| tree | [92791aa2291acd9b3c8f8cc69eb62dd6d8ba584e](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=14431815a4ae4bcd7c7a68b6a64c66c7712d27c9) | |
| parent | [03cca8fe300fa35e9be6457d02d75498c88f1d9c](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=03cca8fe300fa35e9be6457d02d75498c88f1d9c) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=14431815a4ae4bcd7c7a68b6a64c66c7712d27c9&id2=03cca8fe300fa35e9be6457d02d75498c88f1d9c)) | |
| download | [linux-14431815a4ae4bcd7c7a68b6a64c66c7712d27c9.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-14431815a4ae4bcd7c7a68b6a64c66c7712d27c9.tar.gz) | |

btrfs: qgroup: fix qgroup prealloc rsv leak in subvolume operationscommit 74e97958121aa1f5854da6effba70143f051b0cd upstream.
Create subvolume, create snapshot and delete subvolume all use
btrfs\_subvolume\_reserve\_metadata() to reserve metadata for the changes
done to the parent subvolume's fs tree, which cannot be mediated in the
normal way via start\_transaction. When quota groups (squota or qgroups)
are enabled, this reserves qgroup metadata of type PREALLOC. Once the
operation is associated to a transaction, we convert PREALLOC to
PERTRANS, which gets cleared in bulk at the end of the transaction.
However, the error paths of these three operations were not implementing
this lifecycle correctly. They unconditionally converted the PREALLOC to
PERTRANS in a generic cleanup step regardless of errors or whether the
operation was fully associated to a transaction or not. This resulted in
error paths occasionally converting this rsv to PERTRANS without calling
record\_root\_in\_trans successfully, which meant that unless that root got
recorded in the transaction by some other thread, the end of the
transaction would not free that root's PERTRANS, leaking it. Ultimately,
this resulted in hitting a WARN in CONFIG\_BTRFS\_DEBUG builds at unmount
for the leaked reservation.
The fix is to ensure that every qgroup PREALLOC reservation observes the
following properties:
1. any failure before record\_root\_in\_trans is called successfully
results in freeing the PREALLOC reservation.
2. after record\_root\_in\_trans, we convert to PERTRANS, and now the
transaction owns freeing the reservation.
This patch enforces those properties on the three operations. Without
it, generic/269 with squotas enabled at mkfs time would fail in ~5-10
runs on my system. With this patch, it ran successfully 1000 times in a
row.
Fixes: e85fde5162bf ("btrfs: qgroup: fix qgroup meta rsv leak for subvolume operations")
CC: stable@vger.kernel.org # 6.1+
Reviewed-by: Qu Wenruo <wqu@suse.com>
Signed-off-by: Boris Burkov <boris@bur.io>
Signed-off-by: David Sterba <dsterba@suse.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=14431815a4ae4bcd7c7a68b6a64c66c7712d27c9)

| -rw-r--r-- | [fs/btrfs/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/inode.c?id=14431815a4ae4bcd7c7a68b6a64c66c7712d27c9) | 13 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/btrfs/ioctl.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/ioctl.c?id=14431815a4ae4bcd7c7a68b6a64c66c7712d27c9) | 37 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/root-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/root-tree.c?id=14431815a4ae4bcd7c7a68b6a64c66c7712d27c9) | 10 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/root-tree.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/root-tree.h?id=14431815a4ae4bcd7c7a68b6a64c66c7712d27c9) | 2 | |  |  |  | | --- | --- | --- | |

4 files changed, 40 insertions, 22 deletions

| diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.cindex 1ac14223ffb50d..e57d18825a56e6 100644--- a/[fs/btrfs/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/inode.c?id=03cca8fe300fa35e9be6457d02d75498c88f1d9c)+++ b/[fs/btrfs/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/inode.c?id=14431815a4ae4bcd7c7a68b6a64c66c7712d27c9)@@ -4460,6 +4460,7 @@ int btrfs\_delete\_subvolume(struct btrfs\_inode \*dir, struct dentry \*dentry) struct btrfs\_trans\_handle \*trans; struct btrfs\_block\_rsv block\_rsv; u64 root\_flags;+ u64 qgroup\_reserved = 0; int ret;  down\_write(&fs\_info->subvol\_sem);@@ -4504,12 +4505,20 @@ int btrfs\_delete\_subvolume(struct btrfs\_inode \*dir, struct dentry \*dentry) ret = btrfs\_subvolume\_reserve\_metadata(root, &block\_rsv, 5, true); if (ret) goto out\_undead;+ qgroup\_reserved = block\_rsv.qgroup\_rsv\_reserved;  trans = btrfs\_start\_transaction(root, 0); if (IS\_ERR(trans)) { ret = PTR\_ERR(trans); goto out\_release; }+ ret = btrfs\_record\_root\_in\_trans(trans, root);+ if (ret) {+ btrfs\_abort\_transaction(trans, ret);+ goto out\_end\_trans;+ }+ btrfs\_qgroup\_convert\_reserved\_meta(root, qgroup\_reserved);+ qgroup\_reserved = 0; trans->block\_rsv = &block\_rsv; trans->bytes\_reserved = block\_rsv.size; @@ -4568,7 +4577,9 @@ out\_end\_trans: ret = btrfs\_end\_transaction(trans); inode->i\_flags |= S\_DEAD; out\_release:- btrfs\_subvolume\_release\_metadata(root, &block\_rsv);+ btrfs\_block\_rsv\_release(fs\_info, &block\_rsv, (u64)-1, NULL);+ if (qgroup\_reserved)+ btrfs\_qgroup\_free\_meta\_prealloc(root, qgroup\_reserved); out\_undead: if (ret) { spin\_lock(&dest->root\_item\_lock);diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.cindex 839e579268dc15..3f43a08613d8a5 100644--- a/[fs/btrfs/ioctl.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/ioctl.c?id=03cca8fe300fa35e9be6457d02d75498c88f1d9c)+++ b/[fs/btrfs/ioctl.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/ioctl.c?id=14431815a4ae4bcd7c7a68b6a64c66c7712d27c9)@@ -603,6 +603,7 @@ static noinline int create\_subvol(struct mnt\_idmap \*idmap, int ret; dev\_t anon\_dev; u64 objectid;+ u64 qgroup\_reserved = 0;  root\_item = kzalloc(sizeof(\*root\_item), GFP\_KERNEL); if (!root\_item)@@ -640,13 +641,18 @@ static noinline int create\_subvol(struct mnt\_idmap \*idmap, trans\_num\_items, false); if (ret) goto out\_new\_inode\_args;+ qgroup\_reserved = block\_rsv.qgroup\_rsv\_reserved;  trans = btrfs\_start\_transaction(root, 0); if (IS\_ERR(trans)) { ret = PTR\_ERR(trans);- btrfs\_subvolume\_release\_metadata(root, &block\_rsv);- goto out\_new\_inode\_args;+ goto out\_release\_rsv; }+ ret = btrfs\_record\_root\_in\_trans(trans, BTRFS\_I(dir)->root);+ if (ret)+ goto out;+ btrfs\_qgroup\_convert\_reserved\_meta(root, qgroup\_reserved);+ qgroup\_reserved = 0; trans->block\_rsv = &block\_rsv; trans->bytes\_reserved = block\_rsv.size; /\* Tree log can't currently deal with an inode which is a new root. \*/@@ -757,9 +763,11 @@ static noinline int create\_subvol(struct mnt\_idmap \*idmap, out: trans->block\_rsv = NULL; trans->bytes\_reserved = 0;- btrfs\_subvolume\_release\_metadata(root, &block\_rsv);- btrfs\_end\_transaction(trans);+out\_release\_rsv:+ btrfs\_block\_rsv\_release(fs\_info, &block\_rsv, (u64)-1, NULL);+ if (qgroup\_reserved)+ btrfs\_qgroup\_free\_meta\_prealloc(root, qgroup\_reserved); out\_new\_inode\_args: btrfs\_new\_inode\_args\_destroy(&new\_inode\_args); out\_inode:@@ -781,6 +789,8 @@ static int create\_snapshot(struct btrfs\_root \*root, struct inode \*dir, struct btrfs\_pending\_snapshot \*pending\_snapshot; unsigned int trans\_num\_items; struct btrfs\_trans\_handle \*trans;+ struct btrfs\_block\_rsv \*block\_rsv;+ u64 qgroup\_reserved = 0; int ret;  /\* We do not support snapshotting right now. \*/@@ -817,19 +827,19 @@ static int create\_snapshot(struct btrfs\_root \*root, struct inode \*dir, goto free\_pending; } - btrfs\_init\_block\_rsv(&pending\_snapshot->block\_rsv,- BTRFS\_BLOCK\_RSV\_TEMP);+ block\_rsv = &pending\_snapshot->block\_rsv;+ btrfs\_init\_block\_rsv(block\_rsv, BTRFS\_BLOCK\_RSV\_TEMP); /\* \* 1 to add dir item \* 1 to add dir index \* 1 to update parent inode item \*/ trans\_num\_items = create\_subvol\_num\_items(inherit) + 3;- ret = btrfs\_subvolume\_reserve\_metadata(BTRFS\_I(dir)->root,- &pending\_snapshot->block\_rsv,+ ret = btrfs\_subvolume\_reserve\_metadata(BTRFS\_I(dir)->root, block\_rsv, trans\_num\_items, false); if (ret) goto free\_pending;+ qgroup\_reserved = block\_rsv->qgroup\_rsv\_reserved;  pending\_snapshot->dentry = dentry; pending\_snapshot->root = root;@@ -842,6 +852,13 @@ static int create\_snapshot(struct btrfs\_root \*root, struct inode \*dir, ret = PTR\_ERR(trans); goto fail; }+ ret = btrfs\_record\_root\_in\_trans(trans, BTRFS\_I(dir)->root);+ if (ret) {+ btrfs\_end\_transaction(trans);+ goto fail;+ }+ btrfs\_qgroup\_convert\_reserved\_meta(root, qgroup\_reserved);+ qgroup\_reserved = 0;  trans->pending\_snapshot = pending\_snapshot; @@ -871,7 +888,9 @@ fail: if (ret && pending\_snapshot->snap) pending\_snapshot->snap->anon\_dev = 0; btrfs\_put\_root(pending\_snapshot->snap);- btrfs\_subvolume\_release\_metadata(root, &pending\_snapshot->block\_rsv);+ btrfs\_block\_rsv\_release(fs\_info, block\_rsv, (u64)-1, NULL);+ if (qgroup\_reserved)+ btrfs\_qgroup\_free\_meta\_prealloc(root, qgroup\_reserved); free\_pending: if (pending\_snapshot->anon\_dev) free\_anon\_bdev(pending\_snapshot->anon\_dev);diff --git a/fs/btrfs/root-tree.c b/fs/btrfs/root-tree.cindex 5b0f1bccc409cc..aac18f620de4ce 100644--- a/[fs/btrfs/root-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/root-tree.c?id=03cca8fe300fa35e9be6457d02d75498c88f1d9c)+++ b/[fs/btrfs/root-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/root-tree.c?id=14431815a4ae4bcd7c7a68b6a64c66c7712d27c9)@@ -537,13 +537,3 @@ int btrfs\_subvolume\_reserve\_metadata(struct btrfs\_root \*root, } return ret; }--void btrfs\_subvolume\_release\_metadata(struct btrfs\_root \*root,- struct btrfs\_block\_rsv \*rsv)-{- struct btrfs\_fs\_info \*fs\_info = root->fs\_info;- u64 qgroup\_to\_release;-- btrfs\_block\_rsv\_release(fs\_info, rsv, (u64)-1, &qgroup\_to\_release);- btrfs\_qgroup\_convert\_reserved\_meta(root, qgroup\_to\_release);-}diff --git a/fs/btrfs/root-tree.h b/fs/btrfs/root-tree.hindex cbbaca32126e62..cce808b44cc025 100644--- a/[fs/btrfs/root-tree.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/root-tree.h?id=03cca8fe300fa35e9be6457d02d75498c88f1d9c)+++ b/[fs/btrfs/root-tree.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/root-tree.h?id=14431815a4ae4bcd7c7a68b6a64c66c7712d27c9)@@ -6,8 +6,6 @@ int btrfs\_subvolume\_reserve\_metadata(struct btrfs\_root \*root, struct btrfs\_block\_rsv \*rsv, int nitems, bool use\_global\_rsv);-void btrfs\_subvolume\_release\_metadata(struct btrfs\_root \*root,- struct btrfs\_block\_rsv \*rsv); int btrfs\_add\_root\_ref(struct btrfs\_trans\_handle \*trans, u64 root\_id, u64 ref\_id, u64 dirid, u64 sequence, const struct fscrypt\_str \*name); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 05:43:47 +0000



=== Content from git.kernel.org_64800c1a_20250111_054511.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=6c95336f5d8eb9ab79cd7306d71b6d0477363f8c)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=6c95336f5d8eb9ab79cd7306d71b6d0477363f8c)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6c95336f5d8eb9ab79cd7306d71b6d0477363f8c)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=6c95336f5d8eb9ab79cd7306d71b6d0477363f8c)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Boris Burkov <boris@bur.io> | 2024-03-21 10:02:04 -0700 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-04-17 11:23:35 +0200 |
| commit | [6c95336f5d8eb9ab79cd7306d71b6d0477363f8c](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6c95336f5d8eb9ab79cd7306d71b6d0477363f8c) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=6c95336f5d8eb9ab79cd7306d71b6d0477363f8c)) | |
| tree | [84a8c03dd5a272131d8ca49cdab76571de2e1ae0](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=6c95336f5d8eb9ab79cd7306d71b6d0477363f8c) | |
| parent | [6c85b91ee5d0a59eeefc0db0f2b720a0e0369111](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6c85b91ee5d0a59eeefc0db0f2b720a0e0369111) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=6c95336f5d8eb9ab79cd7306d71b6d0477363f8c&id2=6c85b91ee5d0a59eeefc0db0f2b720a0e0369111)) | |
| download | [linux-6c95336f5d8eb9ab79cd7306d71b6d0477363f8c.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-6c95336f5d8eb9ab79cd7306d71b6d0477363f8c.tar.gz) | |

btrfs: qgroup: fix qgroup prealloc rsv leak in subvolume operationscommit 74e97958121aa1f5854da6effba70143f051b0cd upstream.
Create subvolume, create snapshot and delete subvolume all use
btrfs\_subvolume\_reserve\_metadata() to reserve metadata for the changes
done to the parent subvolume's fs tree, which cannot be mediated in the
normal way via start\_transaction. When quota groups (squota or qgroups)
are enabled, this reserves qgroup metadata of type PREALLOC. Once the
operation is associated to a transaction, we convert PREALLOC to
PERTRANS, which gets cleared in bulk at the end of the transaction.
However, the error paths of these three operations were not implementing
this lifecycle correctly. They unconditionally converted the PREALLOC to
PERTRANS in a generic cleanup step regardless of errors or whether the
operation was fully associated to a transaction or not. This resulted in
error paths occasionally converting this rsv to PERTRANS without calling
record\_root\_in\_trans successfully, which meant that unless that root got
recorded in the transaction by some other thread, the end of the
transaction would not free that root's PERTRANS, leaking it. Ultimately,
this resulted in hitting a WARN in CONFIG\_BTRFS\_DEBUG builds at unmount
for the leaked reservation.
The fix is to ensure that every qgroup PREALLOC reservation observes the
following properties:
1. any failure before record\_root\_in\_trans is called successfully
results in freeing the PREALLOC reservation.
2. after record\_root\_in\_trans, we convert to PERTRANS, and now the
transaction owns freeing the reservation.
This patch enforces those properties on the three operations. Without
it, generic/269 with squotas enabled at mkfs time would fail in ~5-10
runs on my system. With this patch, it ran successfully 1000 times in a
row.
Fixes: e85fde5162bf ("btrfs: qgroup: fix qgroup meta rsv leak for subvolume operations")
CC: stable@vger.kernel.org # 6.1+
Reviewed-by: Qu Wenruo <wqu@suse.com>
Signed-off-by: Boris Burkov <boris@bur.io>
Signed-off-by: David Sterba <dsterba@suse.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=6c95336f5d8eb9ab79cd7306d71b6d0477363f8c)

| -rw-r--r-- | [fs/btrfs/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/inode.c?id=6c95336f5d8eb9ab79cd7306d71b6d0477363f8c) | 13 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/btrfs/ioctl.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/ioctl.c?id=6c95336f5d8eb9ab79cd7306d71b6d0477363f8c) | 37 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/root-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/root-tree.c?id=6c95336f5d8eb9ab79cd7306d71b6d0477363f8c) | 10 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/root-tree.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/root-tree.h?id=6c95336f5d8eb9ab79cd7306d71b6d0477363f8c) | 2 | |  |  |  | | --- | --- | --- | |

4 files changed, 40 insertions, 22 deletions

| diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.cindex 5ceb995709b568..6e2715e3f3aa00 100644--- a/[fs/btrfs/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/inode.c?id=6c85b91ee5d0a59eeefc0db0f2b720a0e0369111)+++ b/[fs/btrfs/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/inode.c?id=6c95336f5d8eb9ab79cd7306d71b6d0477363f8c)@@ -4476,6 +4476,7 @@ int btrfs\_delete\_subvolume(struct btrfs\_inode \*dir, struct dentry \*dentry) struct btrfs\_trans\_handle \*trans; struct btrfs\_block\_rsv block\_rsv; u64 root\_flags;+ u64 qgroup\_reserved = 0; int ret;  down\_write(&fs\_info->subvol\_sem);@@ -4520,12 +4521,20 @@ int btrfs\_delete\_subvolume(struct btrfs\_inode \*dir, struct dentry \*dentry) ret = btrfs\_subvolume\_reserve\_metadata(root, &block\_rsv, 5, true); if (ret) goto out\_undead;+ qgroup\_reserved = block\_rsv.qgroup\_rsv\_reserved;  trans = btrfs\_start\_transaction(root, 0); if (IS\_ERR(trans)) { ret = PTR\_ERR(trans); goto out\_release; }+ ret = btrfs\_record\_root\_in\_trans(trans, root);+ if (ret) {+ btrfs\_abort\_transaction(trans, ret);+ goto out\_end\_trans;+ }+ btrfs\_qgroup\_convert\_reserved\_meta(root, qgroup\_reserved);+ qgroup\_reserved = 0; trans->block\_rsv = &block\_rsv; trans->bytes\_reserved = block\_rsv.size; @@ -4584,7 +4593,9 @@ out\_end\_trans: ret = btrfs\_end\_transaction(trans); inode->i\_flags |= S\_DEAD; out\_release:- btrfs\_subvolume\_release\_metadata(root, &block\_rsv);+ btrfs\_block\_rsv\_release(fs\_info, &block\_rsv, (u64)-1, NULL);+ if (qgroup\_reserved)+ btrfs\_qgroup\_free\_meta\_prealloc(root, qgroup\_reserved); out\_undead: if (ret) { spin\_lock(&dest->root\_item\_lock);diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.cindex bd19aed66605a1..6b93fae74403dd 100644--- a/[fs/btrfs/ioctl.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/ioctl.c?id=6c85b91ee5d0a59eeefc0db0f2b720a0e0369111)+++ b/[fs/btrfs/ioctl.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/ioctl.c?id=6c95336f5d8eb9ab79cd7306d71b6d0477363f8c)@@ -603,6 +603,7 @@ static noinline int create\_subvol(struct mnt\_idmap \*idmap, int ret; dev\_t anon\_dev; u64 objectid;+ u64 qgroup\_reserved = 0;  root\_item = kzalloc(sizeof(\*root\_item), GFP\_KERNEL); if (!root\_item)@@ -640,13 +641,18 @@ static noinline int create\_subvol(struct mnt\_idmap \*idmap, trans\_num\_items, false); if (ret) goto out\_new\_inode\_args;+ qgroup\_reserved = block\_rsv.qgroup\_rsv\_reserved;  trans = btrfs\_start\_transaction(root, 0); if (IS\_ERR(trans)) { ret = PTR\_ERR(trans);- btrfs\_subvolume\_release\_metadata(root, &block\_rsv);- goto out\_new\_inode\_args;+ goto out\_release\_rsv; }+ ret = btrfs\_record\_root\_in\_trans(trans, BTRFS\_I(dir)->root);+ if (ret)+ goto out;+ btrfs\_qgroup\_convert\_reserved\_meta(root, qgroup\_reserved);+ qgroup\_reserved = 0; trans->block\_rsv = &block\_rsv; trans->bytes\_reserved = block\_rsv.size; /\* Tree log can't currently deal with an inode which is a new root. \*/@@ -757,9 +763,11 @@ static noinline int create\_subvol(struct mnt\_idmap \*idmap, out: trans->block\_rsv = NULL; trans->bytes\_reserved = 0;- btrfs\_subvolume\_release\_metadata(root, &block\_rsv);- btrfs\_end\_transaction(trans);+out\_release\_rsv:+ btrfs\_block\_rsv\_release(fs\_info, &block\_rsv, (u64)-1, NULL);+ if (qgroup\_reserved)+ btrfs\_qgroup\_free\_meta\_prealloc(root, qgroup\_reserved); out\_new\_inode\_args: btrfs\_new\_inode\_args\_destroy(&new\_inode\_args); out\_inode:@@ -781,6 +789,8 @@ static int create\_snapshot(struct btrfs\_root \*root, struct inode \*dir, struct btrfs\_pending\_snapshot \*pending\_snapshot; unsigned int trans\_num\_items; struct btrfs\_trans\_handle \*trans;+ struct btrfs\_block\_rsv \*block\_rsv;+ u64 qgroup\_reserved = 0; int ret;  /\* We do not support snapshotting right now. \*/@@ -817,19 +827,19 @@ static int create\_snapshot(struct btrfs\_root \*root, struct inode \*dir, goto free\_pending; } - btrfs\_init\_block\_rsv(&pending\_snapshot->block\_rsv,- BTRFS\_BLOCK\_RSV\_TEMP);+ block\_rsv = &pending\_snapshot->block\_rsv;+ btrfs\_init\_block\_rsv(block\_rsv, BTRFS\_BLOCK\_RSV\_TEMP); /\* \* 1 to add dir item \* 1 to add dir index \* 1 to update parent inode item \*/ trans\_num\_items = create\_subvol\_num\_items(inherit) + 3;- ret = btrfs\_subvolume\_reserve\_metadata(BTRFS\_I(dir)->root,- &pending\_snapshot->block\_rsv,+ ret = btrfs\_subvolume\_reserve\_metadata(BTRFS\_I(dir)->root, block\_rsv, trans\_num\_items, false); if (ret) goto free\_pending;+ qgroup\_reserved = block\_rsv->qgroup\_rsv\_reserved;  pending\_snapshot->dentry = dentry; pending\_snapshot->root = root;@@ -842,6 +852,13 @@ static int create\_snapshot(struct btrfs\_root \*root, struct inode \*dir, ret = PTR\_ERR(trans); goto fail; }+ ret = btrfs\_record\_root\_in\_trans(trans, BTRFS\_I(dir)->root);+ if (ret) {+ btrfs\_end\_transaction(trans);+ goto fail;+ }+ btrfs\_qgroup\_convert\_reserved\_meta(root, qgroup\_reserved);+ qgroup\_reserved = 0;  trans->pending\_snapshot = pending\_snapshot; @@ -871,7 +888,9 @@ fail: if (ret && pending\_snapshot->snap) pending\_snapshot->snap->anon\_dev = 0; btrfs\_put\_root(pending\_snapshot->snap);- btrfs\_subvolume\_release\_metadata(root, &pending\_snapshot->block\_rsv);+ btrfs\_block\_rsv\_release(fs\_info, block\_rsv, (u64)-1, NULL);+ if (qgroup\_reserved)+ btrfs\_qgroup\_free\_meta\_prealloc(root, qgroup\_reserved); free\_pending: if (pending\_snapshot->anon\_dev) free\_anon\_bdev(pending\_snapshot->anon\_dev);diff --git a/fs/btrfs/root-tree.c b/fs/btrfs/root-tree.cindex 603ad1459368c3..5260677ad51e2d 100644--- a/[fs/btrfs/root-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/root-tree.c?id=6c85b91ee5d0a59eeefc0db0f2b720a0e0369111)+++ b/[fs/btrfs/root-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/root-tree.c?id=6c95336f5d8eb9ab79cd7306d71b6d0477363f8c)@@ -539,13 +539,3 @@ int btrfs\_subvolume\_reserve\_metadata(struct btrfs\_root \*root, } return ret; }--void btrfs\_subvolume\_release\_metadata(struct btrfs\_root \*root,- struct btrfs\_block\_rsv \*rsv)-{- struct btrfs\_fs\_info \*fs\_info = root->fs\_info;- u64 qgroup\_to\_release;-- btrfs\_block\_rsv\_release(fs\_info, rsv, (u64)-1, &qgroup\_to\_release);- btrfs\_qgroup\_convert\_reserved\_meta(root, qgroup\_to\_release);-}diff --git a/fs/btrfs/root-tree.h b/fs/btrfs/root-tree.hindex 8b2c3859e4647a..de0175cbdb1e50 100644--- a/[fs/btrfs/root-tree.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/root-tree.h?id=6c85b91ee5d0a59eeefc0db0f2b720a0e0369111)+++ b/[fs/btrfs/root-tree.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/root-tree.h?id=6c95336f5d8eb9ab79cd7306d71b6d0477363f8c)@@ -8,8 +8,6 @@ struct fscrypt\_str; int btrfs\_subvolume\_reserve\_metadata(struct btrfs\_root \*root, struct btrfs\_block\_rsv \*rsv, int nitems, bool use\_global\_rsv);-void btrfs\_subvolume\_release\_metadata(struct btrfs\_root \*root,- struct btrfs\_block\_rsv \*rsv); int btrfs\_add\_root\_ref(struct btrfs\_trans\_handle \*trans, u64 root\_id, u64 ref\_id, u64 dirid, u64 sequence, const struct fscrypt\_str \*name); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 05:43:48 +0000



=== Content from git.kernel.org_672855e2_20250111_054512.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=945559be6e282a812dc48f7bcd5adc60901ea4a0)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=945559be6e282a812dc48f7bcd5adc60901ea4a0)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=945559be6e282a812dc48f7bcd5adc60901ea4a0)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=945559be6e282a812dc48f7bcd5adc60901ea4a0)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Boris Burkov <boris@bur.io> | 2024-03-21 10:02:04 -0700 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-12-14 19:53:56 +0100 |
| commit | [945559be6e282a812dc48f7bcd5adc60901ea4a0](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=945559be6e282a812dc48f7bcd5adc60901ea4a0) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=945559be6e282a812dc48f7bcd5adc60901ea4a0)) | |
| tree | [ec02c49e966b1da6f8d3e080a941359ba1f0dc24](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=945559be6e282a812dc48f7bcd5adc60901ea4a0) | |
| parent | [224fd631c41b81697aa622d38615bfbf446b91cf](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=224fd631c41b81697aa622d38615bfbf446b91cf) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=945559be6e282a812dc48f7bcd5adc60901ea4a0&id2=224fd631c41b81697aa622d38615bfbf446b91cf)) | |
| download | [linux-945559be6e282a812dc48f7bcd5adc60901ea4a0.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-945559be6e282a812dc48f7bcd5adc60901ea4a0.tar.gz) | |

btrfs: qgroup: fix qgroup prealloc rsv leak in subvolume operationscommit 74e97958121aa1f5854da6effba70143f051b0cd upstream.
Create subvolume, create snapshot and delete subvolume all use
btrfs\_subvolume\_reserve\_metadata() to reserve metadata for the changes
done to the parent subvolume's fs tree, which cannot be mediated in the
normal way via start\_transaction. When quota groups (squota or qgroups)
are enabled, this reserves qgroup metadata of type PREALLOC. Once the
operation is associated to a transaction, we convert PREALLOC to
PERTRANS, which gets cleared in bulk at the end of the transaction.
However, the error paths of these three operations were not implementing
this lifecycle correctly. They unconditionally converted the PREALLOC to
PERTRANS in a generic cleanup step regardless of errors or whether the
operation was fully associated to a transaction or not. This resulted in
error paths occasionally converting this rsv to PERTRANS without calling
record\_root\_in\_trans successfully, which meant that unless that root got
recorded in the transaction by some other thread, the end of the
transaction would not free that root's PERTRANS, leaking it. Ultimately,
this resulted in hitting a WARN in CONFIG\_BTRFS\_DEBUG builds at unmount
for the leaked reservation.
The fix is to ensure that every qgroup PREALLOC reservation observes the
following properties:
1. any failure before record\_root\_in\_trans is called successfully
results in freeing the PREALLOC reservation.
2. after record\_root\_in\_trans, we convert to PERTRANS, and now the
transaction owns freeing the reservation.
This patch enforces those properties on the three operations. Without
it, generic/269 with squotas enabled at mkfs time would fail in ~5-10
runs on my system. With this patch, it ran successfully 1000 times in a
row.
Fixes: e85fde5162bf ("btrfs: qgroup: fix qgroup meta rsv leak for subvolume operations")
CC: stable@vger.kernel.org # 6.1+
Reviewed-by: Qu Wenruo <wqu@suse.com>
Signed-off-by: Boris Burkov <boris@bur.io>
Signed-off-by: David Sterba <dsterba@suse.com>
[Xiangyu: BP to fix CVE-2024-35956, due to 6.1 btrfs\_subvolume\_release\_metadata()
defined in ctree.h, modified the header file name from root-tree.h to ctree.h]
Signed-off-by: Xiangyu Chen <xiangyu.chen@windriver.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=945559be6e282a812dc48f7bcd5adc60901ea4a0)

| -rw-r--r-- | [fs/btrfs/ctree.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/ctree.h?id=945559be6e282a812dc48f7bcd5adc60901ea4a0) | 2 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/btrfs/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/inode.c?id=945559be6e282a812dc48f7bcd5adc60901ea4a0) | 13 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/ioctl.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/ioctl.c?id=945559be6e282a812dc48f7bcd5adc60901ea4a0) | 36 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/root-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/root-tree.c?id=945559be6e282a812dc48f7bcd5adc60901ea4a0) | 10 | |  |  |  | | --- | --- | --- | |

4 files changed, 40 insertions, 21 deletions

| diff --git a/fs/btrfs/ctree.h b/fs/btrfs/ctree.hindex cca1acf2e03718..cab023927b4341 100644--- a/[fs/btrfs/ctree.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/ctree.h?id=224fd631c41b81697aa622d38615bfbf446b91cf)+++ b/[fs/btrfs/ctree.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/ctree.h?id=945559be6e282a812dc48f7bcd5adc60901ea4a0)@@ -2987,8 +2987,6 @@ enum btrfs\_flush\_state { int btrfs\_subvolume\_reserve\_metadata(struct btrfs\_root \*root, struct btrfs\_block\_rsv \*rsv, int nitems, bool use\_global\_rsv);-void btrfs\_subvolume\_release\_metadata(struct btrfs\_root \*root,- struct btrfs\_block\_rsv \*rsv); void btrfs\_delalloc\_release\_extents(struct btrfs\_inode \*inode, u64 num\_bytes);  int btrfs\_delalloc\_reserve\_metadata(struct btrfs\_inode \*inode, u64 num\_bytes,diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.cindex a79da940f5b24c..8fc8a24a1afe80 100644--- a/[fs/btrfs/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/inode.c?id=224fd631c41b81697aa622d38615bfbf446b91cf)+++ b/[fs/btrfs/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/inode.c?id=945559be6e282a812dc48f7bcd5adc60901ea4a0)@@ -4707,6 +4707,7 @@ int btrfs\_delete\_subvolume(struct inode \*dir, struct dentry \*dentry) struct btrfs\_trans\_handle \*trans; struct btrfs\_block\_rsv block\_rsv; u64 root\_flags;+ u64 qgroup\_reserved = 0; int ret;  down\_write(&fs\_info->subvol\_sem);@@ -4751,12 +4752,20 @@ int btrfs\_delete\_subvolume(struct inode \*dir, struct dentry \*dentry) ret = btrfs\_subvolume\_reserve\_metadata(root, &block\_rsv, 5, true); if (ret) goto out\_undead;+ qgroup\_reserved = block\_rsv.qgroup\_rsv\_reserved;  trans = btrfs\_start\_transaction(root, 0); if (IS\_ERR(trans)) { ret = PTR\_ERR(trans); goto out\_release; }+ ret = btrfs\_record\_root\_in\_trans(trans, root);+ if (ret) {+ btrfs\_abort\_transaction(trans, ret);+ goto out\_end\_trans;+ }+ btrfs\_qgroup\_convert\_reserved\_meta(root, qgroup\_reserved);+ qgroup\_reserved = 0; trans->block\_rsv = &block\_rsv; trans->bytes\_reserved = block\_rsv.size; @@ -4815,7 +4824,9 @@ out\_end\_trans: ret = btrfs\_end\_transaction(trans); inode->i\_flags |= S\_DEAD; out\_release:- btrfs\_subvolume\_release\_metadata(root, &block\_rsv);+ btrfs\_block\_rsv\_release(fs\_info, &block\_rsv, (u64)-1, NULL);+ if (qgroup\_reserved)+ btrfs\_qgroup\_free\_meta\_prealloc(root, qgroup\_reserved); out\_undead: if (ret) { spin\_lock(&dest->root\_item\_lock);diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.cindex 31f7fe31b607a5..a30379936af5a7 100644--- a/[fs/btrfs/ioctl.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/ioctl.c?id=224fd631c41b81697aa622d38615bfbf446b91cf)+++ b/[fs/btrfs/ioctl.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/ioctl.c?id=945559be6e282a812dc48f7bcd5adc60901ea4a0)@@ -592,6 +592,7 @@ static noinline int create\_subvol(struct user\_namespace \*mnt\_userns, int ret; dev\_t anon\_dev; u64 objectid;+ u64 qgroup\_reserved = 0;  root\_item = kzalloc(sizeof(\*root\_item), GFP\_KERNEL); if (!root\_item)@@ -629,13 +630,18 @@ static noinline int create\_subvol(struct user\_namespace \*mnt\_userns, trans\_num\_items, false); if (ret) goto out\_new\_inode\_args;+ qgroup\_reserved = block\_rsv.qgroup\_rsv\_reserved;  trans = btrfs\_start\_transaction(root, 0); if (IS\_ERR(trans)) { ret = PTR\_ERR(trans);- btrfs\_subvolume\_release\_metadata(root, &block\_rsv);- goto out\_new\_inode\_args;+ goto out\_release\_rsv; }+ ret = btrfs\_record\_root\_in\_trans(trans, BTRFS\_I(dir)->root);+ if (ret)+ goto out;+ btrfs\_qgroup\_convert\_reserved\_meta(root, qgroup\_reserved);+ qgroup\_reserved = 0; trans->block\_rsv = &block\_rsv; trans->bytes\_reserved = block\_rsv.size; @@ -744,12 +750,15 @@ static noinline int create\_subvol(struct user\_namespace \*mnt\_userns, out: trans->block\_rsv = NULL; trans->bytes\_reserved = 0;- btrfs\_subvolume\_release\_metadata(root, &block\_rsv);  if (ret) btrfs\_end\_transaction(trans); else ret = btrfs\_commit\_transaction(trans);+out\_release\_rsv:+ btrfs\_block\_rsv\_release(fs\_info, &block\_rsv, (u64)-1, NULL);+ if (qgroup\_reserved)+ btrfs\_qgroup\_free\_meta\_prealloc(root, qgroup\_reserved); out\_new\_inode\_args: btrfs\_new\_inode\_args\_destroy(&new\_inode\_args); out\_inode:@@ -771,6 +780,8 @@ static int create\_snapshot(struct btrfs\_root \*root, struct inode \*dir, struct btrfs\_pending\_snapshot \*pending\_snapshot; unsigned int trans\_num\_items; struct btrfs\_trans\_handle \*trans;+ struct btrfs\_block\_rsv \*block\_rsv;+ u64 qgroup\_reserved = 0; int ret;  /\* We do not support snapshotting right now. \*/@@ -807,19 +818,19 @@ static int create\_snapshot(struct btrfs\_root \*root, struct inode \*dir, goto free\_pending; } - btrfs\_init\_block\_rsv(&pending\_snapshot->block\_rsv,- BTRFS\_BLOCK\_RSV\_TEMP);+ block\_rsv = &pending\_snapshot->block\_rsv;+ btrfs\_init\_block\_rsv(block\_rsv, BTRFS\_BLOCK\_RSV\_TEMP); /\* \* 1 to add dir item \* 1 to add dir index \* 1 to update parent inode item \*/ trans\_num\_items = create\_subvol\_num\_items(inherit) + 3;- ret = btrfs\_subvolume\_reserve\_metadata(BTRFS\_I(dir)->root,- &pending\_snapshot->block\_rsv,+ ret = btrfs\_subvolume\_reserve\_metadata(BTRFS\_I(dir)->root, block\_rsv, trans\_num\_items, false); if (ret) goto free\_pending;+ qgroup\_reserved = block\_rsv->qgroup\_rsv\_reserved;  pending\_snapshot->dentry = dentry; pending\_snapshot->root = root;@@ -832,6 +843,13 @@ static int create\_snapshot(struct btrfs\_root \*root, struct inode \*dir, ret = PTR\_ERR(trans); goto fail; }+ ret = btrfs\_record\_root\_in\_trans(trans, BTRFS\_I(dir)->root);+ if (ret) {+ btrfs\_end\_transaction(trans);+ goto fail;+ }+ btrfs\_qgroup\_convert\_reserved\_meta(root, qgroup\_reserved);+ qgroup\_reserved = 0;  trans->pending\_snapshot = pending\_snapshot; @@ -861,7 +879,9 @@ fail: if (ret && pending\_snapshot->snap) pending\_snapshot->snap->anon\_dev = 0; btrfs\_put\_root(pending\_snapshot->snap);- btrfs\_subvolume\_release\_metadata(root, &pending\_snapshot->block\_rsv);+ btrfs\_block\_rsv\_release(fs\_info, block\_rsv, (u64)-1, NULL);+ if (qgroup\_reserved)+ btrfs\_qgroup\_free\_meta\_prealloc(root, qgroup\_reserved); free\_pending: if (pending\_snapshot->anon\_dev) free\_anon\_bdev(pending\_snapshot->anon\_dev);diff --git a/fs/btrfs/root-tree.c b/fs/btrfs/root-tree.cindex 7d783f09430681..37780ede89bac3 100644--- a/[fs/btrfs/root-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/root-tree.c?id=224fd631c41b81697aa622d38615bfbf446b91cf)+++ b/[fs/btrfs/root-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/root-tree.c?id=945559be6e282a812dc48f7bcd5adc60901ea4a0)@@ -532,13 +532,3 @@ int btrfs\_subvolume\_reserve\_metadata(struct btrfs\_root \*root, } return ret; }--void btrfs\_subvolume\_release\_metadata(struct btrfs\_root \*root,- struct btrfs\_block\_rsv \*rsv)-{- struct btrfs\_fs\_info \*fs\_info = root->fs\_info;- u64 qgroup\_to\_release;-- btrfs\_block\_rsv\_release(fs\_info, rsv, (u64)-1, &qgroup\_to\_release);- btrfs\_qgroup\_convert\_reserved\_meta(root, qgroup\_to\_release);-} |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 05:43:49 +0000



=== Content from git.kernel.org_d7760d2b_20250111_054511.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=74e97958121aa1f5854da6effba70143f051b0cd)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=74e97958121aa1f5854da6effba70143f051b0cd)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=74e97958121aa1f5854da6effba70143f051b0cd)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=74e97958121aa1f5854da6effba70143f051b0cd)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Boris Burkov <boris@bur.io> | 2024-03-21 10:02:04 -0700 |
| --- | --- | --- |
| committer | David Sterba <dsterba@suse.com> | 2024-04-02 19:18:23 +0200 |
| commit | [74e97958121aa1f5854da6effba70143f051b0cd](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=74e97958121aa1f5854da6effba70143f051b0cd) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=74e97958121aa1f5854da6effba70143f051b0cd)) | |
| tree | [990b5c7a33ba8e7dcbe76f02877d8739dd4bc198](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=74e97958121aa1f5854da6effba70143f051b0cd) | |
| parent | [141fb8cd206ace23c02cd2791c6da52c1d77d42a](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=141fb8cd206ace23c02cd2791c6da52c1d77d42a) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=74e97958121aa1f5854da6effba70143f051b0cd&id2=141fb8cd206ace23c02cd2791c6da52c1d77d42a)) | |
| download | [linux-74e97958121aa1f5854da6effba70143f051b0cd.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-74e97958121aa1f5854da6effba70143f051b0cd.tar.gz) | |

btrfs: qgroup: fix qgroup prealloc rsv leak in subvolume operationsCreate subvolume, create snapshot and delete subvolume all use
btrfs\_subvolume\_reserve\_metadata() to reserve metadata for the changes
done to the parent subvolume's fs tree, which cannot be mediated in the
normal way via start\_transaction. When quota groups (squota or qgroups)
are enabled, this reserves qgroup metadata of type PREALLOC. Once the
operation is associated to a transaction, we convert PREALLOC to
PERTRANS, which gets cleared in bulk at the end of the transaction.
However, the error paths of these three operations were not implementing
this lifecycle correctly. They unconditionally converted the PREALLOC to
PERTRANS in a generic cleanup step regardless of errors or whether the
operation was fully associated to a transaction or not. This resulted in
error paths occasionally converting this rsv to PERTRANS without calling
record\_root\_in\_trans successfully, which meant that unless that root got
recorded in the transaction by some other thread, the end of the
transaction would not free that root's PERTRANS, leaking it. Ultimately,
this resulted in hitting a WARN in CONFIG\_BTRFS\_DEBUG builds at unmount
for the leaked reservation.
The fix is to ensure that every qgroup PREALLOC reservation observes the
following properties:
1. any failure before record\_root\_in\_trans is called successfully
results in freeing the PREALLOC reservation.
2. after record\_root\_in\_trans, we convert to PERTRANS, and now the
transaction owns freeing the reservation.
This patch enforces those properties on the three operations. Without
it, generic/269 with squotas enabled at mkfs time would fail in ~5-10
runs on my system. With this patch, it ran successfully 1000 times in a
row.
Fixes: e85fde5162bf ("btrfs: qgroup: fix qgroup meta rsv leak for subvolume operations")
CC: stable@vger.kernel.org # 6.1+
Reviewed-by: Qu Wenruo <wqu@suse.com>
Signed-off-by: Boris Burkov <boris@bur.io>
Signed-off-by: David Sterba <dsterba@suse.com>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=74e97958121aa1f5854da6effba70143f051b0cd)

| -rw-r--r-- | [fs/btrfs/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/inode.c?id=74e97958121aa1f5854da6effba70143f051b0cd) | 13 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/btrfs/ioctl.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/ioctl.c?id=74e97958121aa1f5854da6effba70143f051b0cd) | 37 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/root-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/root-tree.c?id=74e97958121aa1f5854da6effba70143f051b0cd) | 10 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/root-tree.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/root-tree.h?id=74e97958121aa1f5854da6effba70143f051b0cd) | 2 | |  |  |  | | --- | --- | --- | |

4 files changed, 40 insertions, 22 deletions

| diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.cindex 37701531eeb1ba..1f9e74c4161d31 100644--- a/[fs/btrfs/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/inode.c?id=141fb8cd206ace23c02cd2791c6da52c1d77d42a)+++ b/[fs/btrfs/inode.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/inode.c?id=74e97958121aa1f5854da6effba70143f051b0cd)@@ -4503,6 +4503,7 @@ int btrfs\_delete\_subvolume(struct btrfs\_inode \*dir, struct dentry \*dentry) struct btrfs\_trans\_handle \*trans; struct btrfs\_block\_rsv block\_rsv; u64 root\_flags;+ u64 qgroup\_reserved = 0; int ret;  down\_write(&fs\_info->subvol\_sem);@@ -4547,12 +4548,20 @@ int btrfs\_delete\_subvolume(struct btrfs\_inode \*dir, struct dentry \*dentry) ret = btrfs\_subvolume\_reserve\_metadata(root, &block\_rsv, 5, true); if (ret) goto out\_undead;+ qgroup\_reserved = block\_rsv.qgroup\_rsv\_reserved;  trans = btrfs\_start\_transaction(root, 0); if (IS\_ERR(trans)) { ret = PTR\_ERR(trans); goto out\_release; }+ ret = btrfs\_record\_root\_in\_trans(trans, root);+ if (ret) {+ btrfs\_abort\_transaction(trans, ret);+ goto out\_end\_trans;+ }+ btrfs\_qgroup\_convert\_reserved\_meta(root, qgroup\_reserved);+ qgroup\_reserved = 0; trans->block\_rsv = &block\_rsv; trans->bytes\_reserved = block\_rsv.size; @@ -4611,7 +4620,9 @@ out\_end\_trans: ret = btrfs\_end\_transaction(trans); inode->i\_flags |= S\_DEAD; out\_release:- btrfs\_subvolume\_release\_metadata(root, &block\_rsv);+ btrfs\_block\_rsv\_release(fs\_info, &block\_rsv, (u64)-1, NULL);+ if (qgroup\_reserved)+ btrfs\_qgroup\_free\_meta\_prealloc(root, qgroup\_reserved); out\_undead: if (ret) { spin\_lock(&dest->root\_item\_lock);diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.cindex 38459a89b27c4d..5a507237c4fa3a 100644--- a/[fs/btrfs/ioctl.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/ioctl.c?id=141fb8cd206ace23c02cd2791c6da52c1d77d42a)+++ b/[fs/btrfs/ioctl.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/ioctl.c?id=74e97958121aa1f5854da6effba70143f051b0cd)@@ -613,6 +613,7 @@ static noinline int create\_subvol(struct mnt\_idmap \*idmap, int ret; dev\_t anon\_dev; u64 objectid;+ u64 qgroup\_reserved = 0;  root\_item = kzalloc(sizeof(\*root\_item), GFP\_KERNEL); if (!root\_item)@@ -650,13 +651,18 @@ static noinline int create\_subvol(struct mnt\_idmap \*idmap, trans\_num\_items, false); if (ret) goto out\_new\_inode\_args;+ qgroup\_reserved = block\_rsv.qgroup\_rsv\_reserved;  trans = btrfs\_start\_transaction(root, 0); if (IS\_ERR(trans)) { ret = PTR\_ERR(trans);- btrfs\_subvolume\_release\_metadata(root, &block\_rsv);- goto out\_new\_inode\_args;+ goto out\_release\_rsv; }+ ret = btrfs\_record\_root\_in\_trans(trans, BTRFS\_I(dir)->root);+ if (ret)+ goto out;+ btrfs\_qgroup\_convert\_reserved\_meta(root, qgroup\_reserved);+ qgroup\_reserved = 0; trans->block\_rsv = &block\_rsv; trans->bytes\_reserved = block\_rsv.size; /\* Tree log can't currently deal with an inode which is a new root. \*/@@ -767,9 +773,11 @@ static noinline int create\_subvol(struct mnt\_idmap \*idmap, out: trans->block\_rsv = NULL; trans->bytes\_reserved = 0;- btrfs\_subvolume\_release\_metadata(root, &block\_rsv);- btrfs\_end\_transaction(trans);+out\_release\_rsv:+ btrfs\_block\_rsv\_release(fs\_info, &block\_rsv, (u64)-1, NULL);+ if (qgroup\_reserved)+ btrfs\_qgroup\_free\_meta\_prealloc(root, qgroup\_reserved); out\_new\_inode\_args: btrfs\_new\_inode\_args\_destroy(&new\_inode\_args); out\_inode:@@ -791,6 +799,8 @@ static int create\_snapshot(struct btrfs\_root \*root, struct inode \*dir, struct btrfs\_pending\_snapshot \*pending\_snapshot; unsigned int trans\_num\_items; struct btrfs\_trans\_handle \*trans;+ struct btrfs\_block\_rsv \*block\_rsv;+ u64 qgroup\_reserved = 0; int ret;  /\* We do not support snapshotting right now. \*/@@ -827,19 +837,19 @@ static int create\_snapshot(struct btrfs\_root \*root, struct inode \*dir, goto free\_pending; } - btrfs\_init\_block\_rsv(&pending\_snapshot->block\_rsv,- BTRFS\_BLOCK\_RSV\_TEMP);+ block\_rsv = &pending\_snapshot->block\_rsv;+ btrfs\_init\_block\_rsv(block\_rsv, BTRFS\_BLOCK\_RSV\_TEMP); /\* \* 1 to add dir item \* 1 to add dir index \* 1 to update parent inode item \*/ trans\_num\_items = create\_subvol\_num\_items(inherit) + 3;- ret = btrfs\_subvolume\_reserve\_metadata(BTRFS\_I(dir)->root,- &pending\_snapshot->block\_rsv,+ ret = btrfs\_subvolume\_reserve\_metadata(BTRFS\_I(dir)->root, block\_rsv, trans\_num\_items, false); if (ret) goto free\_pending;+ qgroup\_reserved = block\_rsv->qgroup\_rsv\_reserved;  pending\_snapshot->dentry = dentry; pending\_snapshot->root = root;@@ -852,6 +862,13 @@ static int create\_snapshot(struct btrfs\_root \*root, struct inode \*dir, ret = PTR\_ERR(trans); goto fail; }+ ret = btrfs\_record\_root\_in\_trans(trans, BTRFS\_I(dir)->root);+ if (ret) {+ btrfs\_end\_transaction(trans);+ goto fail;+ }+ btrfs\_qgroup\_convert\_reserved\_meta(root, qgroup\_reserved);+ qgroup\_reserved = 0;  trans->pending\_snapshot = pending\_snapshot; @@ -881,7 +898,9 @@ fail: if (ret && pending\_snapshot->snap) pending\_snapshot->snap->anon\_dev = 0; btrfs\_put\_root(pending\_snapshot->snap);- btrfs\_subvolume\_release\_metadata(root, &pending\_snapshot->block\_rsv);+ btrfs\_block\_rsv\_release(fs\_info, block\_rsv, (u64)-1, NULL);+ if (qgroup\_reserved)+ btrfs\_qgroup\_free\_meta\_prealloc(root, qgroup\_reserved); free\_pending: if (pending\_snapshot->anon\_dev) free\_anon\_bdev(pending\_snapshot->anon\_dev);diff --git a/fs/btrfs/root-tree.c b/fs/btrfs/root-tree.cindex 4bb538a372ce56..7007f9e0c97282 100644--- a/[fs/btrfs/root-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/root-tree.c?id=141fb8cd206ace23c02cd2791c6da52c1d77d42a)+++ b/[fs/btrfs/root-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/root-tree.c?id=74e97958121aa1f5854da6effba70143f051b0cd)@@ -548,13 +548,3 @@ int btrfs\_subvolume\_reserve\_metadata(struct btrfs\_root \*root, } return ret; }--void btrfs\_subvolume\_release\_metadata(struct btrfs\_root \*root,- struct btrfs\_block\_rsv \*rsv)-{- struct btrfs\_fs\_info \*fs\_info = root->fs\_info;- u64 qgroup\_to\_release;-- btrfs\_block\_rsv\_release(fs\_info, rsv, (u64)-1, &qgroup\_to\_release);- btrfs\_qgroup\_convert\_reserved\_meta(root, qgroup\_to\_release);-}diff --git a/fs/btrfs/root-tree.h b/fs/btrfs/root-tree.hindex 6f929cf3bd4967..8f5739e732b9b6 100644--- a/[fs/btrfs/root-tree.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/root-tree.h?id=141fb8cd206ace23c02cd2791c6da52c1d77d42a)+++ b/[fs/btrfs/root-tree.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/root-tree.h?id=74e97958121aa1f5854da6effba70143f051b0cd)@@ -18,8 +18,6 @@ struct btrfs\_trans\_handle; int btrfs\_subvolume\_reserve\_metadata(struct btrfs\_root \*root, struct btrfs\_block\_rsv \*rsv, int nitems, bool use\_global\_rsv);-void btrfs\_subvolume\_release\_metadata(struct btrfs\_root \*root,- struct btrfs\_block\_rsv \*rsv); int btrfs\_add\_root\_ref(struct btrfs\_trans\_handle \*trans, u64 root\_id, u64 ref\_id, u64 dirid, u64 sequence, const struct fscrypt\_str \*name); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 05:43:48 +0000


