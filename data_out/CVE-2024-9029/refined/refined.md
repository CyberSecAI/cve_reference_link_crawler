Based on the provided information, here's a breakdown of the vulnerability:

**CVE ID:** CVE-2024-9029

**Root Cause:** The vulnerability stems from a heap buffer overflow in the `tiff_read_iptc_profile` function within the FreeImage library. Specifically, the code does not properly sanitize the size of the IPTC profile data read from a TIFF image.

**Weaknesses/Vulnerabilities:**
- **Heap Buffer Overflow:** The `read_iptc_profile` function reads data from the profile without ensuring the size is within the bounds of allocated memory. This occurs because the size of the profile is not being sanitized, leading to a buffer over-read.
- **Lack of Input Sanitization:** The code does not validate the size of the IPTC profile data before processing, creating the conditions for the overflow.

**Impact of Exploitation:**
- **Denial of Service (DoS):** The heap buffer overflow can cause a crash in the application linked to the FreeImage library. This crash can lead to a denial of service, making the application unavailable.

**Attack Vectors:**
- **Maliciously Crafted TIFF Image:** An attacker can exploit the vulnerability by crafting a TIFF image containing a specially crafted IPTC profile. When the vulnerable application processes this image, it triggers the buffer overflow.

**Required Attacker Capabilities/Position:**
- The attacker needs the ability to provide a crafted TIFF file to a system that uses a vulnerable version of the FreeImage library. This could involve:
    - Submitting the crafted image to a web application which processes images.
    - Sending the crafted image via email where it is processed by a mail client.
    - Providing a file to a user to open using an image viewing application.

**Technical Details:**

- The vulnerability is located in the `read_iptc_profile` function in the `Source/Metadata/IPTC.cpp` file.
- The over-read is triggered on line 74 of the `IPTC.cpp` file, where the code searches for the start of the BIM portion of the binary data without checking the bounds based on the profile size:
  ```cpp
    while(offset < length - 1) {
        if((profile[offset] == 0x1C) && (profile[offset+1] == 0x02))
            break;
        offset++;
    }
  ```
- The crash occurs during a read of size 1 at the address which is outside of the allocated memory, as shown in the AddressSanitizer error report.
- The provided stack trace shows the chain of function calls that lead to the vulnerable code, originating from loading the TIFF image from memory using `FreeImage_LoadFromMemory`.

**Additional Notes:**
- The bug report notes that the issue was found via fuzzing using AFL++ & Sydr.
- The affected library is FreeImage.
- Red Hat Bugzilla bug IDs 2313705, 2313706 and 2313707 are also related to this CVE, related to specific distribution updates.