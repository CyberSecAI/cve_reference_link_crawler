

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=75799e71df1da11394740b43ae5686646179561d)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=75799e71df1da11394740b43ae5686646179561d)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=75799e71df1da11394740b43ae5686646179561d)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=75799e71df1da11394740b43ae5686646179561d)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Xin Long <lucien.xin@gmail.com> | 2021-12-23 13:04:30 -0500 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2022-01-05 12:42:35 +0100 |
| commit | [75799e71df1da11394740b43ae5686646179561d](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=75799e71df1da11394740b43ae5686646179561d) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=75799e71df1da11394740b43ae5686646179561d)) | |
| tree | [e52062e7d9ee317875d39f9a808d0a0953bf86ef](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=75799e71df1da11394740b43ae5686646179561d) | |
| parent | [df06c8dd7aca2078dbbfafd7495da49700ab324f](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=df06c8dd7aca2078dbbfafd7495da49700ab324f) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=75799e71df1da11394740b43ae5686646179561d&id2=df06c8dd7aca2078dbbfafd7495da49700ab324f)) | |
| download | [linux-75799e71df1da11394740b43ae5686646179561d.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-75799e71df1da11394740b43ae5686646179561d.tar.gz) | |

sctp: use call\_rcu to free endpoint[ Upstream commit 5ec7d18d1813a5bead0b495045606c93873aecbb ]
This patch is to delay the endpoint free by calling call\_rcu() to fix
another use-after-free issue in sctp\_sock\_dump():
BUG: KASAN: use-after-free in \_\_lock\_acquire+0x36d9/0x4c20
Call Trace:
\_\_lock\_acquire+0x36d9/0x4c20 kernel/locking/lockdep.c:3218
lock\_acquire+0x1ed/0x520 kernel/locking/lockdep.c:3844
\_\_raw\_spin\_lock\_bh include/linux/spinlock\_api\_smp.h:135 [inline]
\_raw\_spin\_lock\_bh+0x31/0x40 kernel/locking/spinlock.c:168
spin\_lock\_bh include/linux/spinlock.h:334 [inline]
\_\_lock\_sock+0x203/0x350 net/core/sock.c:2253
lock\_sock\_nested+0xfe/0x120 net/core/sock.c:2774
lock\_sock include/net/sock.h:1492 [inline]
sctp\_sock\_dump+0x122/0xb20 net/sctp/diag.c:324
sctp\_for\_each\_transport+0x2b5/0x370 net/sctp/socket.c:5091
sctp\_diag\_dump+0x3ac/0x660 net/sctp/diag.c:527
\_\_inet\_diag\_dump+0xa8/0x140 net/ipv4/inet\_diag.c:1049
inet\_diag\_dump+0x9b/0x110 net/ipv4/inet\_diag.c:1065
netlink\_dump+0x606/0x1080 net/netlink/af\_netlink.c:2244
\_\_netlink\_dump\_start+0x59a/0x7c0 net/netlink/af\_netlink.c:2352
netlink\_dump\_start include/linux/netlink.h:216 [inline]
inet\_diag\_handler\_cmd+0x2ce/0x3f0 net/ipv4/inet\_diag.c:1170
\_\_sock\_diag\_cmd net/core/sock\_diag.c:232 [inline]
sock\_diag\_rcv\_msg+0x31d/0x410 net/core/sock\_diag.c:263
netlink\_rcv\_skb+0x172/0x440 net/netlink/af\_netlink.c:2477
sock\_diag\_rcv+0x2a/0x40 net/core/sock\_diag.c:274
This issue occurs when asoc is peeled off and the old sk is freed after
getting it by asoc->base.sk and before calling lock\_sock(sk).
To prevent the sk free, as a holder of the sk, ep should be alive when
calling lock\_sock(). This patch uses call\_rcu() and moves sock\_put and
ep free into sctp\_endpoint\_destroy\_rcu(), so that it's safe to try to
hold the ep under rcu\_read\_lock in sctp\_transport\_traverse\_process().
If sctp\_endpoint\_hold() returns true, it means this ep is still alive
and we have held it and can continue to dump it; If it returns false,
it means this ep is dead and can be freed after rcu\_read\_unlock, and
we should skip it.
In sctp\_sock\_dump(), after locking the sk, if this ep is different from
tsp->asoc->ep, it means during this dumping, this asoc was peeled off
before calling lock\_sock(), and the sk should be skipped; If this ep is
the same with tsp->asoc->ep, it means no peeloff happens on this asoc,
and due to lock\_sock, no peeloff will happen either until release\_sock.
Note that delaying endpoint free won't delay the port release, as the
port release happens in sctp\_endpoint\_destroy() before calling call\_rcu().
Also, freeing endpoint by call\_rcu() makes it safe to access the sk by
asoc->base.sk in sctp\_assocs\_seq\_show() and sctp\_rcv().
Thanks Jones to bring this issue up.
v1->v2:
- improve the changelog.
- add kfree(ep) into sctp\_endpoint\_destroy\_rcu(), as Jakub noticed.
Reported-by: syzbot+9276d76e83e3bcde6c99@syzkaller.appspotmail.com
Reported-by: Lee Jones <lee.jones@linaro.org>
Fixes: d25adbeb0cdb ("sctp: fix an use-after-free issue in sctp\_sock\_dump")
Signed-off-by: Xin Long <lucien.xin@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=75799e71df1da11394740b43ae5686646179561d)

| -rw-r--r-- | [include/net/sctp/sctp.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/sctp/sctp.h?id=75799e71df1da11394740b43ae5686646179561d) | 6 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/net/sctp/structs.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/sctp/structs.h?id=75799e71df1da11394740b43ae5686646179561d) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sctp/diag.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/sctp/diag.c?id=75799e71df1da11394740b43ae5686646179561d) | 12 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sctp/endpointola.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/sctp/endpointola.c?id=75799e71df1da11394740b43ae5686646179561d) | 23 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sctp/socket.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/sctp/socket.c?id=75799e71df1da11394740b43ae5686646179561d) | 23 | |  |  |  | | --- | --- | --- | |

5 files changed, 41 insertions, 26 deletions

| diff --git a/include/net/sctp/sctp.h b/include/net/sctp/sctp.hindex 189fdb9db16220..d314a180ab93d7 100644--- a/[include/net/sctp/sctp.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/sctp/sctp.h?id=df06c8dd7aca2078dbbfafd7495da49700ab324f)+++ b/[include/net/sctp/sctp.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/sctp/sctp.h?id=75799e71df1da11394740b43ae5686646179561d)@@ -105,6 +105,7 @@ extern struct percpu\_counter sctp\_sockets\_allocated; int sctp\_asconf\_mgmt(struct sctp\_sock \*, struct sctp\_sockaddr\_entry \*); struct sk\_buff \*sctp\_skb\_recv\_datagram(struct sock \*, int, int, int \*); +typedef int (\*sctp\_callback\_t)(struct sctp\_endpoint \*, struct sctp\_transport \*, void \*); void sctp\_transport\_walk\_start(struct rhashtable\_iter \*iter); void sctp\_transport\_walk\_stop(struct rhashtable\_iter \*iter); struct sctp\_transport \*sctp\_transport\_get\_next(struct net \*net,@@ -115,9 +116,8 @@ int sctp\_transport\_lookup\_process(int (\*cb)(struct sctp\_transport \*, void \*), struct net \*net, const union sctp\_addr \*laddr, const union sctp\_addr \*paddr, void \*p);-int sctp\_for\_each\_transport(int (\*cb)(struct sctp\_transport \*, void \*),- int (\*cb\_done)(struct sctp\_transport \*, void \*),- struct net \*net, int \*pos, void \*p);+int sctp\_transport\_traverse\_process(sctp\_callback\_t cb, sctp\_callback\_t cb\_done,+ struct net \*net, int \*pos, void \*p); int sctp\_for\_each\_endpoint(int (\*cb)(struct sctp\_endpoint \*, void \*), void \*p); int sctp\_get\_sctp\_info(struct sock \*sk, struct sctp\_association \*asoc, struct sctp\_info \*info);diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.hindex 651bba654d77db..8d2c3dd9f5953f 100644--- a/[include/net/sctp/structs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/sctp/structs.h?id=df06c8dd7aca2078dbbfafd7495da49700ab324f)+++ b/[include/net/sctp/structs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/sctp/structs.h?id=75799e71df1da11394740b43ae5686646179561d)@@ -1365,6 +1365,7 @@ struct sctp\_endpoint {  u32 secid; u32 peer\_secid;+ struct rcu\_head rcu; };  /\* Recover the outter endpoint structure. \*/@@ -1380,7 +1381,7 @@ static inline struct sctp\_endpoint \*sctp\_ep(struct sctp\_ep\_common \*base) struct sctp\_endpoint \*sctp\_endpoint\_new(struct sock \*, gfp\_t); void sctp\_endpoint\_free(struct sctp\_endpoint \*); void sctp\_endpoint\_put(struct sctp\_endpoint \*);-void sctp\_endpoint\_hold(struct sctp\_endpoint \*);+int sctp\_endpoint\_hold(struct sctp\_endpoint \*ep); void sctp\_endpoint\_add\_asoc(struct sctp\_endpoint \*, struct sctp\_association \*); struct sctp\_association \*sctp\_endpoint\_lookup\_assoc( const struct sctp\_endpoint \*ep,diff --git a/net/sctp/diag.c b/net/sctp/diag.cindex 760b367644c12b..a7d62317150139 100644--- a/[net/sctp/diag.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/diag.c?id=df06c8dd7aca2078dbbfafd7495da49700ab324f)+++ b/[net/sctp/diag.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/diag.c?id=75799e71df1da11394740b43ae5686646179561d)@@ -290,9 +290,8 @@ out: return err; } -static int sctp\_sock\_dump(struct sctp\_transport \*tsp, void \*p)+static int sctp\_sock\_dump(struct sctp\_endpoint \*ep, struct sctp\_transport \*tsp, void \*p) {- struct sctp\_endpoint \*ep = tsp->asoc->ep; struct sctp\_comm\_param \*commp = p; struct sock \*sk = ep->base.sk; struct sk\_buff \*skb = commp->skb;@@ -302,6 +301,8 @@ static int sctp\_sock\_dump(struct sctp\_transport \*tsp, void \*p) int err = 0;  lock\_sock(sk);+ if (ep != tsp->asoc->ep)+ goto release; list\_for\_each\_entry(assoc, &ep->asocs, asocs) { if (cb->args[4] < cb->args[1]) goto next;@@ -344,9 +345,8 @@ release: return err; } -static int sctp\_sock\_filter(struct sctp\_transport \*tsp, void \*p)+static int sctp\_sock\_filter(struct sctp\_endpoint \*ep, struct sctp\_transport \*tsp, void \*p) {- struct sctp\_endpoint \*ep = tsp->asoc->ep; struct sctp\_comm\_param \*commp = p; struct sock \*sk = ep->base.sk; const struct inet\_diag\_req\_v2 \*r = commp->r;@@ -505,8 +505,8 @@ skip: if (!(idiag\_states & ~(TCPF\_LISTEN | TCPF\_CLOSE))) goto done; - sctp\_for\_each\_transport(sctp\_sock\_filter, sctp\_sock\_dump,- net, &pos, &commp);+ sctp\_transport\_traverse\_process(sctp\_sock\_filter, sctp\_sock\_dump,+ net, &pos, &commp); cb->args[2] = pos;  done:diff --git a/net/sctp/endpointola.c b/net/sctp/endpointola.cindex 48c9c2c7602f78..efffde7f2328e4 100644--- a/[net/sctp/endpointola.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/endpointola.c?id=df06c8dd7aca2078dbbfafd7495da49700ab324f)+++ b/[net/sctp/endpointola.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/endpointola.c?id=75799e71df1da11394740b43ae5686646179561d)@@ -184,6 +184,18 @@ void sctp\_endpoint\_free(struct sctp\_endpoint \*ep) }  /\* Final destructor for endpoint. \*/+static void sctp\_endpoint\_destroy\_rcu(struct rcu\_head \*head)+{+ struct sctp\_endpoint \*ep = container\_of(head, struct sctp\_endpoint, rcu);+ struct sock \*sk = ep->base.sk;++ sctp\_sk(sk)->ep = NULL;+ sock\_put(sk);++ kfree(ep);+ SCTP\_DBG\_OBJCNT\_DEC(ep);+}+ static void sctp\_endpoint\_destroy(struct sctp\_endpoint \*ep) { struct sock \*sk;@@ -213,18 +225,13 @@ static void sctp\_endpoint\_destroy(struct sctp\_endpoint \*ep) if (sctp\_sk(sk)->bind\_hash) sctp\_put\_port(sk); - sctp\_sk(sk)->ep = NULL;- /\* Give up our hold on the sock \*/- sock\_put(sk);-- kfree(ep);- SCTP\_DBG\_OBJCNT\_DEC(ep);+ call\_rcu(&ep->rcu, sctp\_endpoint\_destroy\_rcu); }  /\* Hold a reference to an endpoint. \*/-void sctp\_endpoint\_hold(struct sctp\_endpoint \*ep)+int sctp\_endpoint\_hold(struct sctp\_endpoint \*ep) {- refcount\_inc(&ep->base.refcnt);+ return refcount\_inc\_not\_zero(&ep->base.refcnt); }  /\* Release a reference to an endpoint and clean up if there arediff --git a/net/sctp/socket.c b/net/sctp/socket.cindex 6b937bfd475159..d2215d24634e85 100644--- a/[net/sctp/socket.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/socket.c?id=df06c8dd7aca2078dbbfafd7495da49700ab324f)+++ b/[net/sctp/socket.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/socket.c?id=75799e71df1da11394740b43ae5686646179561d)@@ -5338,11 +5338,12 @@ int sctp\_transport\_lookup\_process(int (\*cb)(struct sctp\_transport \*, void \*), } EXPORT\_SYMBOL\_GPL(sctp\_transport\_lookup\_process); -int sctp\_for\_each\_transport(int (\*cb)(struct sctp\_transport \*, void \*),- int (\*cb\_done)(struct sctp\_transport \*, void \*),- struct net \*net, int \*pos, void \*p) {+int sctp\_transport\_traverse\_process(sctp\_callback\_t cb, sctp\_callback\_t cb\_done,+ struct net \*net, int \*pos, void \*p)+{ struct rhashtable\_iter hti; struct sctp\_transport \*tsp;+ struct sctp\_endpoint \*ep; int ret;  again:@@ -5351,26 +5352,32 @@ again:  tsp = sctp\_transport\_get\_idx(net, &hti, \*pos + 1); for (; !IS\_ERR\_OR\_NULL(tsp); tsp = sctp\_transport\_get\_next(net, &hti)) {- ret = cb(tsp, p);- if (ret)- break;+ ep = tsp->asoc->ep;+ if (sctp\_endpoint\_hold(ep)) { /\* asoc can be peeled off \*/+ ret = cb(ep, tsp, p);+ if (ret)+ break;+ sctp\_endpoint\_put(ep);+ } (\*pos)++; sctp\_transport\_put(tsp); } sctp\_transport\_walk\_stop(&hti);  if (ret) {- if (cb\_done && !cb\_done(tsp, p)) {+ if (cb\_done && !cb\_done(ep, tsp, p)) { (\*pos)++;+ sctp\_endpoint\_put(ep); sctp\_transport\_put(tsp); goto again; }+ sctp\_endpoint\_put(ep); sctp\_transport\_put(tsp); }  return ret; }-EXPORT\_SYMBOL\_GPL(sctp\_for\_each\_transport);+EXPORT\_SYMBOL\_GPL(sctp\_transport\_traverse\_process);  /\* 7.2.1 Association Status (SCTP\_STATUS) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 19:13:00 +0000

