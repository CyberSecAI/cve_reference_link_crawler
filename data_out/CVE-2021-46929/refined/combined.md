=== Content from git.kernel.org_276da357_20250110_191422.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=5ec7d18d1813a5bead0b495045606c93873aecbb)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=5ec7d18d1813a5bead0b495045606c93873aecbb)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=5ec7d18d1813a5bead0b495045606c93873aecbb)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5ec7d18d1813a5bead0b495045606c93873aecbb)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Xin Long <lucien.xin@gmail.com> | 2021-12-23 13:04:30 -0500 |
| --- | --- | --- |
| committer | David S. Miller <davem@davemloft.net> | 2021-12-25 17:13:37 +0000 |
| commit | [5ec7d18d1813a5bead0b495045606c93873aecbb](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=5ec7d18d1813a5bead0b495045606c93873aecbb) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=5ec7d18d1813a5bead0b495045606c93873aecbb)) | |
| tree | [d6929bddd265b41fc2e785ae553cd0edf60beb41](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=5ec7d18d1813a5bead0b495045606c93873aecbb) | |
| parent | [b45396afa4177f2b1ddfeff7185da733fade1dc3](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b45396afa4177f2b1ddfeff7185da733fade1dc3) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5ec7d18d1813a5bead0b495045606c93873aecbb&id2=b45396afa4177f2b1ddfeff7185da733fade1dc3)) | |
| download | [linux-5ec7d18d1813a5bead0b495045606c93873aecbb.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-5ec7d18d1813a5bead0b495045606c93873aecbb.tar.gz) | |

sctp: use call\_rcu to free endpointThis patch is to delay the endpoint free by calling call\_rcu() to fix
another use-after-free issue in sctp\_sock\_dump():
BUG: KASAN: use-after-free in \_\_lock\_acquire+0x36d9/0x4c20
Call Trace:
\_\_lock\_acquire+0x36d9/0x4c20 kernel/locking/lockdep.c:3218
lock\_acquire+0x1ed/0x520 kernel/locking/lockdep.c:3844
\_\_raw\_spin\_lock\_bh include/linux/spinlock\_api\_smp.h:135 [inline]
\_raw\_spin\_lock\_bh+0x31/0x40 kernel/locking/spinlock.c:168
spin\_lock\_bh include/linux/spinlock.h:334 [inline]
\_\_lock\_sock+0x203/0x350 net/core/sock.c:2253
lock\_sock\_nested+0xfe/0x120 net/core/sock.c:2774
lock\_sock include/net/sock.h:1492 [inline]
sctp\_sock\_dump+0x122/0xb20 net/sctp/diag.c:324
sctp\_for\_each\_transport+0x2b5/0x370 net/sctp/socket.c:5091
sctp\_diag\_dump+0x3ac/0x660 net/sctp/diag.c:527
\_\_inet\_diag\_dump+0xa8/0x140 net/ipv4/inet\_diag.c:1049
inet\_diag\_dump+0x9b/0x110 net/ipv4/inet\_diag.c:1065
netlink\_dump+0x606/0x1080 net/netlink/af\_netlink.c:2244
\_\_netlink\_dump\_start+0x59a/0x7c0 net/netlink/af\_netlink.c:2352
netlink\_dump\_start include/linux/netlink.h:216 [inline]
inet\_diag\_handler\_cmd+0x2ce/0x3f0 net/ipv4/inet\_diag.c:1170
\_\_sock\_diag\_cmd net/core/sock\_diag.c:232 [inline]
sock\_diag\_rcv\_msg+0x31d/0x410 net/core/sock\_diag.c:263
netlink\_rcv\_skb+0x172/0x440 net/netlink/af\_netlink.c:2477
sock\_diag\_rcv+0x2a/0x40 net/core/sock\_diag.c:274
This issue occurs when asoc is peeled off and the old sk is freed after
getting it by asoc->base.sk and before calling lock\_sock(sk).
To prevent the sk free, as a holder of the sk, ep should be alive when
calling lock\_sock(). This patch uses call\_rcu() and moves sock\_put and
ep free into sctp\_endpoint\_destroy\_rcu(), so that it's safe to try to
hold the ep under rcu\_read\_lock in sctp\_transport\_traverse\_process().
If sctp\_endpoint\_hold() returns true, it means this ep is still alive
and we have held it and can continue to dump it; If it returns false,
it means this ep is dead and can be freed after rcu\_read\_unlock, and
we should skip it.
In sctp\_sock\_dump(), after locking the sk, if this ep is different from
tsp->asoc->ep, it means during this dumping, this asoc was peeled off
before calling lock\_sock(), and the sk should be skipped; If this ep is
the same with tsp->asoc->ep, it means no peeloff happens on this asoc,
and due to lock\_sock, no peeloff will happen either until release\_sock.
Note that delaying endpoint free won't delay the port release, as the
port release happens in sctp\_endpoint\_destroy() before calling call\_rcu().
Also, freeing endpoint by call\_rcu() makes it safe to access the sk by
asoc->base.sk in sctp\_assocs\_seq\_show() and sctp\_rcv().
Thanks Jones to bring this issue up.
v1->v2:
- improve the changelog.
- add kfree(ep) into sctp\_endpoint\_destroy\_rcu(), as Jakub noticed.
Reported-by: syzbot+9276d76e83e3bcde6c99@syzkaller.appspotmail.com
Reported-by: Lee Jones <lee.jones@linaro.org>
Fixes: d25adbeb0cdb ("sctp: fix an use-after-free issue in sctp\_sock\_dump")
Signed-off-by: Xin Long <lucien.xin@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5ec7d18d1813a5bead0b495045606c93873aecbb)

| -rw-r--r-- | [include/net/sctp/sctp.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/sctp/sctp.h?id=5ec7d18d1813a5bead0b495045606c93873aecbb) | 6 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/net/sctp/structs.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/sctp/structs.h?id=5ec7d18d1813a5bead0b495045606c93873aecbb) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sctp/diag.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/sctp/diag.c?id=5ec7d18d1813a5bead0b495045606c93873aecbb) | 12 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sctp/endpointola.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/sctp/endpointola.c?id=5ec7d18d1813a5bead0b495045606c93873aecbb) | 23 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sctp/socket.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/sctp/socket.c?id=5ec7d18d1813a5bead0b495045606c93873aecbb) | 23 | |  |  |  | | --- | --- | --- | |

5 files changed, 41 insertions, 26 deletions

| diff --git a/include/net/sctp/sctp.h b/include/net/sctp/sctp.hindex 189fdb9db16220..d314a180ab93d7 100644--- a/[include/net/sctp/sctp.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/sctp/sctp.h?id=b45396afa4177f2b1ddfeff7185da733fade1dc3)+++ b/[include/net/sctp/sctp.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/sctp/sctp.h?id=5ec7d18d1813a5bead0b495045606c93873aecbb)@@ -105,6 +105,7 @@ extern struct percpu\_counter sctp\_sockets\_allocated; int sctp\_asconf\_mgmt(struct sctp\_sock \*, struct sctp\_sockaddr\_entry \*); struct sk\_buff \*sctp\_skb\_recv\_datagram(struct sock \*, int, int, int \*); +typedef int (\*sctp\_callback\_t)(struct sctp\_endpoint \*, struct sctp\_transport \*, void \*); void sctp\_transport\_walk\_start(struct rhashtable\_iter \*iter); void sctp\_transport\_walk\_stop(struct rhashtable\_iter \*iter); struct sctp\_transport \*sctp\_transport\_get\_next(struct net \*net,@@ -115,9 +116,8 @@ int sctp\_transport\_lookup\_process(int (\*cb)(struct sctp\_transport \*, void \*), struct net \*net, const union sctp\_addr \*laddr, const union sctp\_addr \*paddr, void \*p);-int sctp\_for\_each\_transport(int (\*cb)(struct sctp\_transport \*, void \*),- int (\*cb\_done)(struct sctp\_transport \*, void \*),- struct net \*net, int \*pos, void \*p);+int sctp\_transport\_traverse\_process(sctp\_callback\_t cb, sctp\_callback\_t cb\_done,+ struct net \*net, int \*pos, void \*p); int sctp\_for\_each\_endpoint(int (\*cb)(struct sctp\_endpoint \*, void \*), void \*p); int sctp\_get\_sctp\_info(struct sock \*sk, struct sctp\_association \*asoc, struct sctp\_info \*info);diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.hindex 899c29c326ba13..8dabd8800006a2 100644--- a/[include/net/sctp/structs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/sctp/structs.h?id=b45396afa4177f2b1ddfeff7185da733fade1dc3)+++ b/[include/net/sctp/structs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/sctp/structs.h?id=5ec7d18d1813a5bead0b495045606c93873aecbb)@@ -1355,6 +1355,7 @@ struct sctp\_endpoint { reconf\_enable:1;  \_\_u8 strreset\_enable;+ struct rcu\_head rcu; };  /\* Recover the outter endpoint structure. \*/@@ -1370,7 +1371,7 @@ static inline struct sctp\_endpoint \*sctp\_ep(struct sctp\_ep\_common \*base) struct sctp\_endpoint \*sctp\_endpoint\_new(struct sock \*, gfp\_t); void sctp\_endpoint\_free(struct sctp\_endpoint \*); void sctp\_endpoint\_put(struct sctp\_endpoint \*);-void sctp\_endpoint\_hold(struct sctp\_endpoint \*);+int sctp\_endpoint\_hold(struct sctp\_endpoint \*ep); void sctp\_endpoint\_add\_asoc(struct sctp\_endpoint \*, struct sctp\_association \*); struct sctp\_association \*sctp\_endpoint\_lookup\_assoc( const struct sctp\_endpoint \*ep,diff --git a/net/sctp/diag.c b/net/sctp/diag.cindex 760b367644c12b..a7d62317150139 100644--- a/[net/sctp/diag.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/diag.c?id=b45396afa4177f2b1ddfeff7185da733fade1dc3)+++ b/[net/sctp/diag.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/diag.c?id=5ec7d18d1813a5bead0b495045606c93873aecbb)@@ -290,9 +290,8 @@ out: return err; } -static int sctp\_sock\_dump(struct sctp\_transport \*tsp, void \*p)+static int sctp\_sock\_dump(struct sctp\_endpoint \*ep, struct sctp\_transport \*tsp, void \*p) {- struct sctp\_endpoint \*ep = tsp->asoc->ep; struct sctp\_comm\_param \*commp = p; struct sock \*sk = ep->base.sk; struct sk\_buff \*skb = commp->skb;@@ -302,6 +301,8 @@ static int sctp\_sock\_dump(struct sctp\_transport \*tsp, void \*p) int err = 0;  lock\_sock(sk);+ if (ep != tsp->asoc->ep)+ goto release; list\_for\_each\_entry(assoc, &ep->asocs, asocs) { if (cb->args[4] < cb->args[1]) goto next;@@ -344,9 +345,8 @@ release: return err; } -static int sctp\_sock\_filter(struct sctp\_transport \*tsp, void \*p)+static int sctp\_sock\_filter(struct sctp\_endpoint \*ep, struct sctp\_transport \*tsp, void \*p) {- struct sctp\_endpoint \*ep = tsp->asoc->ep; struct sctp\_comm\_param \*commp = p; struct sock \*sk = ep->base.sk; const struct inet\_diag\_req\_v2 \*r = commp->r;@@ -505,8 +505,8 @@ skip: if (!(idiag\_states & ~(TCPF\_LISTEN | TCPF\_CLOSE))) goto done; - sctp\_for\_each\_transport(sctp\_sock\_filter, sctp\_sock\_dump,- net, &pos, &commp);+ sctp\_transport\_traverse\_process(sctp\_sock\_filter, sctp\_sock\_dump,+ net, &pos, &commp); cb->args[2] = pos;  done:diff --git a/net/sctp/endpointola.c b/net/sctp/endpointola.cindex 48c9c2c7602f78..efffde7f2328e4 100644--- a/[net/sctp/endpointola.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/endpointola.c?id=b45396afa4177f2b1ddfeff7185da733fade1dc3)+++ b/[net/sctp/endpointola.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/endpointola.c?id=5ec7d18d1813a5bead0b495045606c93873aecbb)@@ -184,6 +184,18 @@ void sctp\_endpoint\_free(struct sctp\_endpoint \*ep) }  /\* Final destructor for endpoint. \*/+static void sctp\_endpoint\_destroy\_rcu(struct rcu\_head \*head)+{+ struct sctp\_endpoint \*ep = container\_of(head, struct sctp\_endpoint, rcu);+ struct sock \*sk = ep->base.sk;++ sctp\_sk(sk)->ep = NULL;+ sock\_put(sk);++ kfree(ep);+ SCTP\_DBG\_OBJCNT\_DEC(ep);+}+ static void sctp\_endpoint\_destroy(struct sctp\_endpoint \*ep) { struct sock \*sk;@@ -213,18 +225,13 @@ static void sctp\_endpoint\_destroy(struct sctp\_endpoint \*ep) if (sctp\_sk(sk)->bind\_hash) sctp\_put\_port(sk); - sctp\_sk(sk)->ep = NULL;- /\* Give up our hold on the sock \*/- sock\_put(sk);-- kfree(ep);- SCTP\_DBG\_OBJCNT\_DEC(ep);+ call\_rcu(&ep->rcu, sctp\_endpoint\_destroy\_rcu); }  /\* Hold a reference to an endpoint. \*/-void sctp\_endpoint\_hold(struct sctp\_endpoint \*ep)+int sctp\_endpoint\_hold(struct sctp\_endpoint \*ep) {- refcount\_inc(&ep->base.refcnt);+ return refcount\_inc\_not\_zero(&ep->base.refcnt); }  /\* Release a reference to an endpoint and clean up if there arediff --git a/net/sctp/socket.c b/net/sctp/socket.cindex 33391254fa82b2..ad5028a07b1830 100644--- a/[net/sctp/socket.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/socket.c?id=b45396afa4177f2b1ddfeff7185da733fade1dc3)+++ b/[net/sctp/socket.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/socket.c?id=5ec7d18d1813a5bead0b495045606c93873aecbb)@@ -5338,11 +5338,12 @@ int sctp\_transport\_lookup\_process(int (\*cb)(struct sctp\_transport \*, void \*), } EXPORT\_SYMBOL\_GPL(sctp\_transport\_lookup\_process); -int sctp\_for\_each\_transport(int (\*cb)(struct sctp\_transport \*, void \*),- int (\*cb\_done)(struct sctp\_transport \*, void \*),- struct net \*net, int \*pos, void \*p) {+int sctp\_transport\_traverse\_process(sctp\_callback\_t cb, sctp\_callback\_t cb\_done,+ struct net \*net, int \*pos, void \*p)+{ struct rhashtable\_iter hti; struct sctp\_transport \*tsp;+ struct sctp\_endpoint \*ep; int ret;  again:@@ -5351,26 +5352,32 @@ again:  tsp = sctp\_transport\_get\_idx(net, &hti, \*pos + 1); for (; !IS\_ERR\_OR\_NULL(tsp); tsp = sctp\_transport\_get\_next(net, &hti)) {- ret = cb(tsp, p);- if (ret)- break;+ ep = tsp->asoc->ep;+ if (sctp\_endpoint\_hold(ep)) { /\* asoc can be peeled off \*/+ ret = cb(ep, tsp, p);+ if (ret)+ break;+ sctp\_endpoint\_put(ep);+ } (\*pos)++; sctp\_transport\_put(tsp); } sctp\_transport\_walk\_stop(&hti);  if (ret) {- if (cb\_done && !cb\_done(tsp, p)) {+ if (cb\_done && !cb\_done(ep, tsp, p)) { (\*pos)++;+ sctp\_endpoint\_put(ep); sctp\_transport\_put(tsp); goto again; }+ sctp\_endpoint\_put(ep); sctp\_transport\_put(tsp); }  return ret; }-EXPORT\_SYMBOL\_GPL(sctp\_for\_each\_transport);+EXPORT\_SYMBOL\_GPL(sctp\_transport\_traverse\_process);  /\* 7.2.1 Association Status (SCTP\_STATUS) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 19:12:59 +0000



=== Content from git.kernel.org_609740e8_20250110_191428.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=af6e6e58f7ebf86b4e7201694b1e4f3a62cbc3ec)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=af6e6e58f7ebf86b4e7201694b1e4f3a62cbc3ec)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=af6e6e58f7ebf86b4e7201694b1e4f3a62cbc3ec)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=af6e6e58f7ebf86b4e7201694b1e4f3a62cbc3ec)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Xin Long <lucien.xin@gmail.com> | 2021-12-23 13:04:30 -0500 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2022-01-05 12:34:58 +0100 |
| commit | [af6e6e58f7ebf86b4e7201694b1e4f3a62cbc3ec](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=af6e6e58f7ebf86b4e7201694b1e4f3a62cbc3ec) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=af6e6e58f7ebf86b4e7201694b1e4f3a62cbc3ec)) | |
| tree | [07bbeb78b17c0fefa905d07589c40942ed183bd4](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=af6e6e58f7ebf86b4e7201694b1e4f3a62cbc3ec) | |
| parent | [cd045c467c7614cbe75d5421c79396dd25a5fded](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=cd045c467c7614cbe75d5421c79396dd25a5fded) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=af6e6e58f7ebf86b4e7201694b1e4f3a62cbc3ec&id2=cd045c467c7614cbe75d5421c79396dd25a5fded)) | |
| download | [linux-af6e6e58f7ebf86b4e7201694b1e4f3a62cbc3ec.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-af6e6e58f7ebf86b4e7201694b1e4f3a62cbc3ec.tar.gz) | |

sctp: use call\_rcu to free endpoint[ Upstream commit 5ec7d18d1813a5bead0b495045606c93873aecbb ]
This patch is to delay the endpoint free by calling call\_rcu() to fix
another use-after-free issue in sctp\_sock\_dump():
BUG: KASAN: use-after-free in \_\_lock\_acquire+0x36d9/0x4c20
Call Trace:
\_\_lock\_acquire+0x36d9/0x4c20 kernel/locking/lockdep.c:3218
lock\_acquire+0x1ed/0x520 kernel/locking/lockdep.c:3844
\_\_raw\_spin\_lock\_bh include/linux/spinlock\_api\_smp.h:135 [inline]
\_raw\_spin\_lock\_bh+0x31/0x40 kernel/locking/spinlock.c:168
spin\_lock\_bh include/linux/spinlock.h:334 [inline]
\_\_lock\_sock+0x203/0x350 net/core/sock.c:2253
lock\_sock\_nested+0xfe/0x120 net/core/sock.c:2774
lock\_sock include/net/sock.h:1492 [inline]
sctp\_sock\_dump+0x122/0xb20 net/sctp/diag.c:324
sctp\_for\_each\_transport+0x2b5/0x370 net/sctp/socket.c:5091
sctp\_diag\_dump+0x3ac/0x660 net/sctp/diag.c:527
\_\_inet\_diag\_dump+0xa8/0x140 net/ipv4/inet\_diag.c:1049
inet\_diag\_dump+0x9b/0x110 net/ipv4/inet\_diag.c:1065
netlink\_dump+0x606/0x1080 net/netlink/af\_netlink.c:2244
\_\_netlink\_dump\_start+0x59a/0x7c0 net/netlink/af\_netlink.c:2352
netlink\_dump\_start include/linux/netlink.h:216 [inline]
inet\_diag\_handler\_cmd+0x2ce/0x3f0 net/ipv4/inet\_diag.c:1170
\_\_sock\_diag\_cmd net/core/sock\_diag.c:232 [inline]
sock\_diag\_rcv\_msg+0x31d/0x410 net/core/sock\_diag.c:263
netlink\_rcv\_skb+0x172/0x440 net/netlink/af\_netlink.c:2477
sock\_diag\_rcv+0x2a/0x40 net/core/sock\_diag.c:274
This issue occurs when asoc is peeled off and the old sk is freed after
getting it by asoc->base.sk and before calling lock\_sock(sk).
To prevent the sk free, as a holder of the sk, ep should be alive when
calling lock\_sock(). This patch uses call\_rcu() and moves sock\_put and
ep free into sctp\_endpoint\_destroy\_rcu(), so that it's safe to try to
hold the ep under rcu\_read\_lock in sctp\_transport\_traverse\_process().
If sctp\_endpoint\_hold() returns true, it means this ep is still alive
and we have held it and can continue to dump it; If it returns false,
it means this ep is dead and can be freed after rcu\_read\_unlock, and
we should skip it.
In sctp\_sock\_dump(), after locking the sk, if this ep is different from
tsp->asoc->ep, it means during this dumping, this asoc was peeled off
before calling lock\_sock(), and the sk should be skipped; If this ep is
the same with tsp->asoc->ep, it means no peeloff happens on this asoc,
and due to lock\_sock, no peeloff will happen either until release\_sock.
Note that delaying endpoint free won't delay the port release, as the
port release happens in sctp\_endpoint\_destroy() before calling call\_rcu().
Also, freeing endpoint by call\_rcu() makes it safe to access the sk by
asoc->base.sk in sctp\_assocs\_seq\_show() and sctp\_rcv().
Thanks Jones to bring this issue up.
v1->v2:
- improve the changelog.
- add kfree(ep) into sctp\_endpoint\_destroy\_rcu(), as Jakub noticed.
Reported-by: syzbot+9276d76e83e3bcde6c99@syzkaller.appspotmail.com
Reported-by: Lee Jones <lee.jones@linaro.org>
Fixes: d25adbeb0cdb ("sctp: fix an use-after-free issue in sctp\_sock\_dump")
Signed-off-by: Xin Long <lucien.xin@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=af6e6e58f7ebf86b4e7201694b1e4f3a62cbc3ec)

| -rw-r--r-- | [include/net/sctp/sctp.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/sctp/sctp.h?id=af6e6e58f7ebf86b4e7201694b1e4f3a62cbc3ec) | 6 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/net/sctp/structs.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/sctp/structs.h?id=af6e6e58f7ebf86b4e7201694b1e4f3a62cbc3ec) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sctp/diag.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/sctp/diag.c?id=af6e6e58f7ebf86b4e7201694b1e4f3a62cbc3ec) | 12 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sctp/endpointola.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/sctp/endpointola.c?id=af6e6e58f7ebf86b4e7201694b1e4f3a62cbc3ec) | 23 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sctp/socket.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/sctp/socket.c?id=af6e6e58f7ebf86b4e7201694b1e4f3a62cbc3ec) | 23 | |  |  |  | | --- | --- | --- | |

5 files changed, 41 insertions, 26 deletions

| diff --git a/include/net/sctp/sctp.h b/include/net/sctp/sctp.hindex 2c6570e6fcfec1..903b2ddde1b437 100644--- a/[include/net/sctp/sctp.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/sctp/sctp.h?id=cd045c467c7614cbe75d5421c79396dd25a5fded)+++ b/[include/net/sctp/sctp.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/sctp/sctp.h?id=af6e6e58f7ebf86b4e7201694b1e4f3a62cbc3ec)@@ -118,6 +118,7 @@ extern struct percpu\_counter sctp\_sockets\_allocated; int sctp\_asconf\_mgmt(struct sctp\_sock \*, struct sctp\_sockaddr\_entry \*); struct sk\_buff \*sctp\_skb\_recv\_datagram(struct sock \*, int, int, int \*); +typedef int (\*sctp\_callback\_t)(struct sctp\_endpoint \*, struct sctp\_transport \*, void \*); void sctp\_transport\_walk\_start(struct rhashtable\_iter \*iter); void sctp\_transport\_walk\_stop(struct rhashtable\_iter \*iter); struct sctp\_transport \*sctp\_transport\_get\_next(struct net \*net,@@ -128,9 +129,8 @@ int sctp\_transport\_lookup\_process(int (\*cb)(struct sctp\_transport \*, void \*), struct net \*net, const union sctp\_addr \*laddr, const union sctp\_addr \*paddr, void \*p);-int sctp\_for\_each\_transport(int (\*cb)(struct sctp\_transport \*, void \*),- int (\*cb\_done)(struct sctp\_transport \*, void \*),- struct net \*net, int \*pos, void \*p);+int sctp\_transport\_traverse\_process(sctp\_callback\_t cb, sctp\_callback\_t cb\_done,+ struct net \*net, int \*pos, void \*p); int sctp\_for\_each\_endpoint(int (\*cb)(struct sctp\_endpoint \*, void \*), void \*p); int sctp\_get\_sctp\_info(struct sock \*sk, struct sctp\_association \*asoc, struct sctp\_info \*info);diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.hindex 2882bc7a5b4b8b..18f9924aa25077 100644--- a/[include/net/sctp/structs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/sctp/structs.h?id=cd045c467c7614cbe75d5421c79396dd25a5fded)+++ b/[include/net/sctp/structs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/sctp/structs.h?id=af6e6e58f7ebf86b4e7201694b1e4f3a62cbc3ec)@@ -1348,6 +1348,7 @@ struct sctp\_endpoint {  u32 secid; u32 peer\_secid;+ struct rcu\_head rcu; };  /\* Recover the outter endpoint structure. \*/@@ -1363,7 +1364,7 @@ static inline struct sctp\_endpoint \*sctp\_ep(struct sctp\_ep\_common \*base) struct sctp\_endpoint \*sctp\_endpoint\_new(struct sock \*, gfp\_t); void sctp\_endpoint\_free(struct sctp\_endpoint \*); void sctp\_endpoint\_put(struct sctp\_endpoint \*);-void sctp\_endpoint\_hold(struct sctp\_endpoint \*);+int sctp\_endpoint\_hold(struct sctp\_endpoint \*ep); void sctp\_endpoint\_add\_asoc(struct sctp\_endpoint \*, struct sctp\_association \*); struct sctp\_association \*sctp\_endpoint\_lookup\_assoc( const struct sctp\_endpoint \*ep,diff --git a/net/sctp/diag.c b/net/sctp/diag.cindex 8767405de9fa4d..0a9db0a7f4234a 100644--- a/[net/sctp/diag.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/diag.c?id=cd045c467c7614cbe75d5421c79396dd25a5fded)+++ b/[net/sctp/diag.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/diag.c?id=af6e6e58f7ebf86b4e7201694b1e4f3a62cbc3ec)@@ -307,9 +307,8 @@ out: return err; } -static int sctp\_sock\_dump(struct sctp\_transport \*tsp, void \*p)+static int sctp\_sock\_dump(struct sctp\_endpoint \*ep, struct sctp\_transport \*tsp, void \*p) {- struct sctp\_endpoint \*ep = tsp->asoc->ep; struct sctp\_comm\_param \*commp = p; struct sock \*sk = ep->base.sk; struct sk\_buff \*skb = commp->skb;@@ -319,6 +318,8 @@ static int sctp\_sock\_dump(struct sctp\_transport \*tsp, void \*p) int err = 0;  lock\_sock(sk);+ if (ep != tsp->asoc->ep)+ goto release; list\_for\_each\_entry(assoc, &ep->asocs, asocs) { if (cb->args[4] < cb->args[1]) goto next;@@ -361,9 +362,8 @@ release: return err; } -static int sctp\_sock\_filter(struct sctp\_transport \*tsp, void \*p)+static int sctp\_sock\_filter(struct sctp\_endpoint \*ep, struct sctp\_transport \*tsp, void \*p) {- struct sctp\_endpoint \*ep = tsp->asoc->ep; struct sctp\_comm\_param \*commp = p; struct sock \*sk = ep->base.sk; const struct inet\_diag\_req\_v2 \*r = commp->r;@@ -521,8 +521,8 @@ skip: if (!(idiag\_states & ~(TCPF\_LISTEN | TCPF\_CLOSE))) goto done; - sctp\_for\_each\_transport(sctp\_sock\_filter, sctp\_sock\_dump,- net, &pos, &commp);+ sctp\_transport\_traverse\_process(sctp\_sock\_filter, sctp\_sock\_dump,+ net, &pos, &commp); cb->args[2] = pos;  done:diff --git a/net/sctp/endpointola.c b/net/sctp/endpointola.cindex 8640dedcf64f19..c4068451b9c768 100644--- a/[net/sctp/endpointola.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/endpointola.c?id=cd045c467c7614cbe75d5421c79396dd25a5fded)+++ b/[net/sctp/endpointola.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/endpointola.c?id=af6e6e58f7ebf86b4e7201694b1e4f3a62cbc3ec)@@ -242,6 +242,18 @@ void sctp\_endpoint\_free(struct sctp\_endpoint \*ep) }  /\* Final destructor for endpoint. \*/+static void sctp\_endpoint\_destroy\_rcu(struct rcu\_head \*head)+{+ struct sctp\_endpoint \*ep = container\_of(head, struct sctp\_endpoint, rcu);+ struct sock \*sk = ep->base.sk;++ sctp\_sk(sk)->ep = NULL;+ sock\_put(sk);++ kfree(ep);+ SCTP\_DBG\_OBJCNT\_DEC(ep);+}+ static void sctp\_endpoint\_destroy(struct sctp\_endpoint \*ep) { struct sock \*sk;@@ -275,18 +287,13 @@ static void sctp\_endpoint\_destroy(struct sctp\_endpoint \*ep) if (sctp\_sk(sk)->bind\_hash) sctp\_put\_port(sk); - sctp\_sk(sk)->ep = NULL;- /\* Give up our hold on the sock \*/- sock\_put(sk);-- kfree(ep);- SCTP\_DBG\_OBJCNT\_DEC(ep);+ call\_rcu(&ep->rcu, sctp\_endpoint\_destroy\_rcu); }  /\* Hold a reference to an endpoint. \*/-void sctp\_endpoint\_hold(struct sctp\_endpoint \*ep)+int sctp\_endpoint\_hold(struct sctp\_endpoint \*ep) {- refcount\_inc(&ep->base.refcnt);+ return refcount\_inc\_not\_zero(&ep->base.refcnt); }  /\* Release a reference to an endpoint and clean up if there arediff --git a/net/sctp/socket.c b/net/sctp/socket.cindex 1148f66917079a..d429d592280410 100644--- a/[net/sctp/socket.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/socket.c?id=cd045c467c7614cbe75d5421c79396dd25a5fded)+++ b/[net/sctp/socket.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/socket.c?id=af6e6e58f7ebf86b4e7201694b1e4f3a62cbc3ec)@@ -5056,11 +5056,12 @@ int sctp\_transport\_lookup\_process(int (\*cb)(struct sctp\_transport \*, void \*), } EXPORT\_SYMBOL\_GPL(sctp\_transport\_lookup\_process); -int sctp\_for\_each\_transport(int (\*cb)(struct sctp\_transport \*, void \*),- int (\*cb\_done)(struct sctp\_transport \*, void \*),- struct net \*net, int \*pos, void \*p) {+int sctp\_transport\_traverse\_process(sctp\_callback\_t cb, sctp\_callback\_t cb\_done,+ struct net \*net, int \*pos, void \*p)+{ struct rhashtable\_iter hti; struct sctp\_transport \*tsp;+ struct sctp\_endpoint \*ep; int ret;  again:@@ -5069,26 +5070,32 @@ again:  tsp = sctp\_transport\_get\_idx(net, &hti, \*pos + 1); for (; !IS\_ERR\_OR\_NULL(tsp); tsp = sctp\_transport\_get\_next(net, &hti)) {- ret = cb(tsp, p);- if (ret)- break;+ ep = tsp->asoc->ep;+ if (sctp\_endpoint\_hold(ep)) { /\* asoc can be peeled off \*/+ ret = cb(ep, tsp, p);+ if (ret)+ break;+ sctp\_endpoint\_put(ep);+ } (\*pos)++; sctp\_transport\_put(tsp); } sctp\_transport\_walk\_stop(&hti);  if (ret) {- if (cb\_done && !cb\_done(tsp, p)) {+ if (cb\_done && !cb\_done(ep, tsp, p)) { (\*pos)++;+ sctp\_endpoint\_put(ep); sctp\_transport\_put(tsp); goto again; }+ sctp\_endpoint\_put(ep); sctp\_transport\_put(tsp); }  return ret; }-EXPORT\_SYMBOL\_GPL(sctp\_for\_each\_transport);+EXPORT\_SYMBOL\_GPL(sctp\_transport\_traverse\_process);  /\* 7.2.1 Association Status (SCTP\_STATUS) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 19:13:06 +0000



=== Content from git.kernel.org_8684bd86_20250110_191426.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=831de271452b87657fcf8d715ee20519b79caef5)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=831de271452b87657fcf8d715ee20519b79caef5)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=831de271452b87657fcf8d715ee20519b79caef5)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=831de271452b87657fcf8d715ee20519b79caef5)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Xin Long <lucien.xin@gmail.com> | 2021-12-23 13:04:30 -0500 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2022-01-05 12:37:44 +0100 |
| commit | [831de271452b87657fcf8d715ee20519b79caef5](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=831de271452b87657fcf8d715ee20519b79caef5) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=831de271452b87657fcf8d715ee20519b79caef5)) | |
| tree | [0c369aa62cb1c29a5beccf0ba7e7e1235e77240f](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=831de271452b87657fcf8d715ee20519b79caef5) | |
| parent | [3218d6bd6195ffac3efcbec9967f386886ebbdc7](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3218d6bd6195ffac3efcbec9967f386886ebbdc7) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=831de271452b87657fcf8d715ee20519b79caef5&id2=3218d6bd6195ffac3efcbec9967f386886ebbdc7)) | |
| download | [linux-831de271452b87657fcf8d715ee20519b79caef5.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-831de271452b87657fcf8d715ee20519b79caef5.tar.gz) | |

sctp: use call\_rcu to free endpoint[ Upstream commit 5ec7d18d1813a5bead0b495045606c93873aecbb ]
This patch is to delay the endpoint free by calling call\_rcu() to fix
another use-after-free issue in sctp\_sock\_dump():
BUG: KASAN: use-after-free in \_\_lock\_acquire+0x36d9/0x4c20
Call Trace:
\_\_lock\_acquire+0x36d9/0x4c20 kernel/locking/lockdep.c:3218
lock\_acquire+0x1ed/0x520 kernel/locking/lockdep.c:3844
\_\_raw\_spin\_lock\_bh include/linux/spinlock\_api\_smp.h:135 [inline]
\_raw\_spin\_lock\_bh+0x31/0x40 kernel/locking/spinlock.c:168
spin\_lock\_bh include/linux/spinlock.h:334 [inline]
\_\_lock\_sock+0x203/0x350 net/core/sock.c:2253
lock\_sock\_nested+0xfe/0x120 net/core/sock.c:2774
lock\_sock include/net/sock.h:1492 [inline]
sctp\_sock\_dump+0x122/0xb20 net/sctp/diag.c:324
sctp\_for\_each\_transport+0x2b5/0x370 net/sctp/socket.c:5091
sctp\_diag\_dump+0x3ac/0x660 net/sctp/diag.c:527
\_\_inet\_diag\_dump+0xa8/0x140 net/ipv4/inet\_diag.c:1049
inet\_diag\_dump+0x9b/0x110 net/ipv4/inet\_diag.c:1065
netlink\_dump+0x606/0x1080 net/netlink/af\_netlink.c:2244
\_\_netlink\_dump\_start+0x59a/0x7c0 net/netlink/af\_netlink.c:2352
netlink\_dump\_start include/linux/netlink.h:216 [inline]
inet\_diag\_handler\_cmd+0x2ce/0x3f0 net/ipv4/inet\_diag.c:1170
\_\_sock\_diag\_cmd net/core/sock\_diag.c:232 [inline]
sock\_diag\_rcv\_msg+0x31d/0x410 net/core/sock\_diag.c:263
netlink\_rcv\_skb+0x172/0x440 net/netlink/af\_netlink.c:2477
sock\_diag\_rcv+0x2a/0x40 net/core/sock\_diag.c:274
This issue occurs when asoc is peeled off and the old sk is freed after
getting it by asoc->base.sk and before calling lock\_sock(sk).
To prevent the sk free, as a holder of the sk, ep should be alive when
calling lock\_sock(). This patch uses call\_rcu() and moves sock\_put and
ep free into sctp\_endpoint\_destroy\_rcu(), so that it's safe to try to
hold the ep under rcu\_read\_lock in sctp\_transport\_traverse\_process().
If sctp\_endpoint\_hold() returns true, it means this ep is still alive
and we have held it and can continue to dump it; If it returns false,
it means this ep is dead and can be freed after rcu\_read\_unlock, and
we should skip it.
In sctp\_sock\_dump(), after locking the sk, if this ep is different from
tsp->asoc->ep, it means during this dumping, this asoc was peeled off
before calling lock\_sock(), and the sk should be skipped; If this ep is
the same with tsp->asoc->ep, it means no peeloff happens on this asoc,
and due to lock\_sock, no peeloff will happen either until release\_sock.
Note that delaying endpoint free won't delay the port release, as the
port release happens in sctp\_endpoint\_destroy() before calling call\_rcu().
Also, freeing endpoint by call\_rcu() makes it safe to access the sk by
asoc->base.sk in sctp\_assocs\_seq\_show() and sctp\_rcv().
Thanks Jones to bring this issue up.
v1->v2:
- improve the changelog.
- add kfree(ep) into sctp\_endpoint\_destroy\_rcu(), as Jakub noticed.
Reported-by: syzbot+9276d76e83e3bcde6c99@syzkaller.appspotmail.com
Reported-by: Lee Jones <lee.jones@linaro.org>
Fixes: d25adbeb0cdb ("sctp: fix an use-after-free issue in sctp\_sock\_dump")
Signed-off-by: Xin Long <lucien.xin@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=831de271452b87657fcf8d715ee20519b79caef5)

| -rw-r--r-- | [include/net/sctp/sctp.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/sctp/sctp.h?id=831de271452b87657fcf8d715ee20519b79caef5) | 6 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/net/sctp/structs.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/sctp/structs.h?id=831de271452b87657fcf8d715ee20519b79caef5) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sctp/diag.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/sctp/diag.c?id=831de271452b87657fcf8d715ee20519b79caef5) | 12 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sctp/endpointola.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/sctp/endpointola.c?id=831de271452b87657fcf8d715ee20519b79caef5) | 23 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sctp/socket.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/sctp/socket.c?id=831de271452b87657fcf8d715ee20519b79caef5) | 23 | |  |  |  | | --- | --- | --- | |

5 files changed, 41 insertions, 26 deletions

| diff --git a/include/net/sctp/sctp.h b/include/net/sctp/sctp.hindex 3ab5c6bbb90bd5..35c108a6b8720d 100644--- a/[include/net/sctp/sctp.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/sctp/sctp.h?id=3218d6bd6195ffac3efcbec9967f386886ebbdc7)+++ b/[include/net/sctp/sctp.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/sctp/sctp.h?id=831de271452b87657fcf8d715ee20519b79caef5)@@ -103,6 +103,7 @@ extern struct percpu\_counter sctp\_sockets\_allocated; int sctp\_asconf\_mgmt(struct sctp\_sock \*, struct sctp\_sockaddr\_entry \*); struct sk\_buff \*sctp\_skb\_recv\_datagram(struct sock \*, int, int, int \*); +typedef int (\*sctp\_callback\_t)(struct sctp\_endpoint \*, struct sctp\_transport \*, void \*); void sctp\_transport\_walk\_start(struct rhashtable\_iter \*iter); void sctp\_transport\_walk\_stop(struct rhashtable\_iter \*iter); struct sctp\_transport \*sctp\_transport\_get\_next(struct net \*net,@@ -113,9 +114,8 @@ int sctp\_transport\_lookup\_process(int (\*cb)(struct sctp\_transport \*, void \*), struct net \*net, const union sctp\_addr \*laddr, const union sctp\_addr \*paddr, void \*p);-int sctp\_for\_each\_transport(int (\*cb)(struct sctp\_transport \*, void \*),- int (\*cb\_done)(struct sctp\_transport \*, void \*),- struct net \*net, int \*pos, void \*p);+int sctp\_transport\_traverse\_process(sctp\_callback\_t cb, sctp\_callback\_t cb\_done,+ struct net \*net, int \*pos, void \*p); int sctp\_for\_each\_endpoint(int (\*cb)(struct sctp\_endpoint \*, void \*), void \*p); int sctp\_get\_sctp\_info(struct sock \*sk, struct sctp\_association \*asoc, struct sctp\_info \*info);diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.hindex fd7c3f76040c3a..cb05e503c9cd17 100644--- a/[include/net/sctp/structs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/sctp/structs.h?id=3218d6bd6195ffac3efcbec9967f386886ebbdc7)+++ b/[include/net/sctp/structs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/sctp/structs.h?id=831de271452b87657fcf8d715ee20519b79caef5)@@ -1345,6 +1345,7 @@ struct sctp\_endpoint {  u32 secid; u32 peer\_secid;+ struct rcu\_head rcu; };  /\* Recover the outter endpoint structure. \*/@@ -1360,7 +1361,7 @@ static inline struct sctp\_endpoint \*sctp\_ep(struct sctp\_ep\_common \*base) struct sctp\_endpoint \*sctp\_endpoint\_new(struct sock \*, gfp\_t); void sctp\_endpoint\_free(struct sctp\_endpoint \*); void sctp\_endpoint\_put(struct sctp\_endpoint \*);-void sctp\_endpoint\_hold(struct sctp\_endpoint \*);+int sctp\_endpoint\_hold(struct sctp\_endpoint \*ep); void sctp\_endpoint\_add\_asoc(struct sctp\_endpoint \*, struct sctp\_association \*); struct sctp\_association \*sctp\_endpoint\_lookup\_assoc( const struct sctp\_endpoint \*ep,diff --git a/net/sctp/diag.c b/net/sctp/diag.cindex ba9f64fdfd2387..7921e77fa55a39 100644--- a/[net/sctp/diag.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/diag.c?id=3218d6bd6195ffac3efcbec9967f386886ebbdc7)+++ b/[net/sctp/diag.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/diag.c?id=831de271452b87657fcf8d715ee20519b79caef5)@@ -292,9 +292,8 @@ out: return err; } -static int sctp\_sock\_dump(struct sctp\_transport \*tsp, void \*p)+static int sctp\_sock\_dump(struct sctp\_endpoint \*ep, struct sctp\_transport \*tsp, void \*p) {- struct sctp\_endpoint \*ep = tsp->asoc->ep; struct sctp\_comm\_param \*commp = p; struct sock \*sk = ep->base.sk; struct sk\_buff \*skb = commp->skb;@@ -304,6 +303,8 @@ static int sctp\_sock\_dump(struct sctp\_transport \*tsp, void \*p) int err = 0;  lock\_sock(sk);+ if (ep != tsp->asoc->ep)+ goto release; list\_for\_each\_entry(assoc, &ep->asocs, asocs) { if (cb->args[4] < cb->args[1]) goto next;@@ -346,9 +347,8 @@ release: return err; } -static int sctp\_sock\_filter(struct sctp\_transport \*tsp, void \*p)+static int sctp\_sock\_filter(struct sctp\_endpoint \*ep, struct sctp\_transport \*tsp, void \*p) {- struct sctp\_endpoint \*ep = tsp->asoc->ep; struct sctp\_comm\_param \*commp = p; struct sock \*sk = ep->base.sk; const struct inet\_diag\_req\_v2 \*r = commp->r;@@ -506,8 +506,8 @@ skip: if (!(idiag\_states & ~(TCPF\_LISTEN | TCPF\_CLOSE))) goto done; - sctp\_for\_each\_transport(sctp\_sock\_filter, sctp\_sock\_dump,- net, &pos, &commp);+ sctp\_transport\_traverse\_process(sctp\_sock\_filter, sctp\_sock\_dump,+ net, &pos, &commp); cb->args[2] = pos;  done:diff --git a/net/sctp/endpointola.c b/net/sctp/endpointola.cindex 3067deb0fbec1c..665a22d5c725ba 100644--- a/[net/sctp/endpointola.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/endpointola.c?id=3218d6bd6195ffac3efcbec9967f386886ebbdc7)+++ b/[net/sctp/endpointola.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/endpointola.c?id=831de271452b87657fcf8d715ee20519b79caef5)@@ -184,6 +184,18 @@ void sctp\_endpoint\_free(struct sctp\_endpoint \*ep) }  /\* Final destructor for endpoint. \*/+static void sctp\_endpoint\_destroy\_rcu(struct rcu\_head \*head)+{+ struct sctp\_endpoint \*ep = container\_of(head, struct sctp\_endpoint, rcu);+ struct sock \*sk = ep->base.sk;++ sctp\_sk(sk)->ep = NULL;+ sock\_put(sk);++ kfree(ep);+ SCTP\_DBG\_OBJCNT\_DEC(ep);+}+ static void sctp\_endpoint\_destroy(struct sctp\_endpoint \*ep) { struct sock \*sk;@@ -213,18 +225,13 @@ static void sctp\_endpoint\_destroy(struct sctp\_endpoint \*ep) if (sctp\_sk(sk)->bind\_hash) sctp\_put\_port(sk); - sctp\_sk(sk)->ep = NULL;- /\* Give up our hold on the sock \*/- sock\_put(sk);-- kfree(ep);- SCTP\_DBG\_OBJCNT\_DEC(ep);+ call\_rcu(&ep->rcu, sctp\_endpoint\_destroy\_rcu); }  /\* Hold a reference to an endpoint. \*/-void sctp\_endpoint\_hold(struct sctp\_endpoint \*ep)+int sctp\_endpoint\_hold(struct sctp\_endpoint \*ep) {- refcount\_inc(&ep->base.refcnt);+ return refcount\_inc\_not\_zero(&ep->base.refcnt); }  /\* Release a reference to an endpoint and clean up if there arediff --git a/net/sctp/socket.c b/net/sctp/socket.cindex 2146372adff43f..565aa77fe5cbe5 100644--- a/[net/sctp/socket.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/socket.c?id=3218d6bd6195ffac3efcbec9967f386886ebbdc7)+++ b/[net/sctp/socket.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/socket.c?id=831de271452b87657fcf8d715ee20519b79caef5)@@ -5395,11 +5395,12 @@ int sctp\_transport\_lookup\_process(int (\*cb)(struct sctp\_transport \*, void \*), } EXPORT\_SYMBOL\_GPL(sctp\_transport\_lookup\_process); -int sctp\_for\_each\_transport(int (\*cb)(struct sctp\_transport \*, void \*),- int (\*cb\_done)(struct sctp\_transport \*, void \*),- struct net \*net, int \*pos, void \*p) {+int sctp\_transport\_traverse\_process(sctp\_callback\_t cb, sctp\_callback\_t cb\_done,+ struct net \*net, int \*pos, void \*p)+{ struct rhashtable\_iter hti; struct sctp\_transport \*tsp;+ struct sctp\_endpoint \*ep; int ret;  again:@@ -5408,26 +5409,32 @@ again:  tsp = sctp\_transport\_get\_idx(net, &hti, \*pos + 1); for (; !IS\_ERR\_OR\_NULL(tsp); tsp = sctp\_transport\_get\_next(net, &hti)) {- ret = cb(tsp, p);- if (ret)- break;+ ep = tsp->asoc->ep;+ if (sctp\_endpoint\_hold(ep)) { /\* asoc can be peeled off \*/+ ret = cb(ep, tsp, p);+ if (ret)+ break;+ sctp\_endpoint\_put(ep);+ } (\*pos)++; sctp\_transport\_put(tsp); } sctp\_transport\_walk\_stop(&hti);  if (ret) {- if (cb\_done && !cb\_done(tsp, p)) {+ if (cb\_done && !cb\_done(ep, tsp, p)) { (\*pos)++;+ sctp\_endpoint\_put(ep); sctp\_transport\_put(tsp); goto again; }+ sctp\_endpoint\_put(ep); sctp\_transport\_put(tsp); }  return ret; }-EXPORT\_SYMBOL\_GPL(sctp\_for\_each\_transport);+EXPORT\_SYMBOL\_GPL(sctp\_transport\_traverse\_process);  /\* 7.2.1 Association Status (SCTP\_STATUS) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 19:13:03 +0000



=== Content from git.kernel.org_fa386572_20250110_191427.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=8873140f95d4977bf37e4cf0d5c5e3f6e34cdd3e)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=8873140f95d4977bf37e4cf0d5c5e3f6e34cdd3e)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=8873140f95d4977bf37e4cf0d5c5e3f6e34cdd3e)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=8873140f95d4977bf37e4cf0d5c5e3f6e34cdd3e)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Xin Long <lucien.xin@gmail.com> | 2021-12-23 13:04:30 -0500 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2022-01-05 12:33:49 +0100 |
| commit | [8873140f95d4977bf37e4cf0d5c5e3f6e34cdd3e](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=8873140f95d4977bf37e4cf0d5c5e3f6e34cdd3e) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=8873140f95d4977bf37e4cf0d5c5e3f6e34cdd3e)) | |
| tree | [7175af527144dd5fd9015d0002803453d95882a2](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=8873140f95d4977bf37e4cf0d5c5e3f6e34cdd3e) | |
| parent | [5c2fe20ad37ff56070ae0acb34152333976929b4](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=5c2fe20ad37ff56070ae0acb34152333976929b4) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=8873140f95d4977bf37e4cf0d5c5e3f6e34cdd3e&id2=5c2fe20ad37ff56070ae0acb34152333976929b4)) | |
| download | [linux-8873140f95d4977bf37e4cf0d5c5e3f6e34cdd3e.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-8873140f95d4977bf37e4cf0d5c5e3f6e34cdd3e.tar.gz) | |

sctp: use call\_rcu to free endpointcommit 5ec7d18d1813a5bead0b495045606c93873aecbb upstream.
This patch is to delay the endpoint free by calling call\_rcu() to fix
another use-after-free issue in sctp\_sock\_dump():
BUG: KASAN: use-after-free in \_\_lock\_acquire+0x36d9/0x4c20
Call Trace:
\_\_lock\_acquire+0x36d9/0x4c20 kernel/locking/lockdep.c:3218
lock\_acquire+0x1ed/0x520 kernel/locking/lockdep.c:3844
\_\_raw\_spin\_lock\_bh include/linux/spinlock\_api\_smp.h:135 [inline]
\_raw\_spin\_lock\_bh+0x31/0x40 kernel/locking/spinlock.c:168
spin\_lock\_bh include/linux/spinlock.h:334 [inline]
\_\_lock\_sock+0x203/0x350 net/core/sock.c:2253
lock\_sock\_nested+0xfe/0x120 net/core/sock.c:2774
lock\_sock include/net/sock.h:1492 [inline]
sctp\_sock\_dump+0x122/0xb20 net/sctp/diag.c:324
sctp\_for\_each\_transport+0x2b5/0x370 net/sctp/socket.c:5091
sctp\_diag\_dump+0x3ac/0x660 net/sctp/diag.c:527
\_\_inet\_diag\_dump+0xa8/0x140 net/ipv4/inet\_diag.c:1049
inet\_diag\_dump+0x9b/0x110 net/ipv4/inet\_diag.c:1065
netlink\_dump+0x606/0x1080 net/netlink/af\_netlink.c:2244
\_\_netlink\_dump\_start+0x59a/0x7c0 net/netlink/af\_netlink.c:2352
netlink\_dump\_start include/linux/netlink.h:216 [inline]
inet\_diag\_handler\_cmd+0x2ce/0x3f0 net/ipv4/inet\_diag.c:1170
\_\_sock\_diag\_cmd net/core/sock\_diag.c:232 [inline]
sock\_diag\_rcv\_msg+0x31d/0x410 net/core/sock\_diag.c:263
netlink\_rcv\_skb+0x172/0x440 net/netlink/af\_netlink.c:2477
sock\_diag\_rcv+0x2a/0x40 net/core/sock\_diag.c:274
This issue occurs when asoc is peeled off and the old sk is freed after
getting it by asoc->base.sk and before calling lock\_sock(sk).
To prevent the sk free, as a holder of the sk, ep should be alive when
calling lock\_sock(). This patch uses call\_rcu() and moves sock\_put and
ep free into sctp\_endpoint\_destroy\_rcu(), so that it's safe to try to
hold the ep under rcu\_read\_lock in sctp\_transport\_traverse\_process().
If sctp\_endpoint\_hold() returns true, it means this ep is still alive
and we have held it and can continue to dump it; If it returns false,
it means this ep is dead and can be freed after rcu\_read\_unlock, and
we should skip it.
In sctp\_sock\_dump(), after locking the sk, if this ep is different from
tsp->asoc->ep, it means during this dumping, this asoc was peeled off
before calling lock\_sock(), and the sk should be skipped; If this ep is
the same with tsp->asoc->ep, it means no peeloff happens on this asoc,
and due to lock\_sock, no peeloff will happen either until release\_sock.
Note that delaying endpoint free won't delay the port release, as the
port release happens in sctp\_endpoint\_destroy() before calling call\_rcu().
Also, freeing endpoint by call\_rcu() makes it safe to access the sk by
asoc->base.sk in sctp\_assocs\_seq\_show() and sctp\_rcv().
Thanks Jones to bring this issue up.
v1->v2:
- improve the changelog.
- add kfree(ep) into sctp\_endpoint\_destroy\_rcu(), as Jakub noticed.
Reported-by: syzbot+9276d76e83e3bcde6c99@syzkaller.appspotmail.com
Reported-by: Lee Jones <lee.jones@linaro.org>
Fixes: d25adbeb0cdb ("sctp: fix an use-after-free issue in sctp\_sock\_dump")
Signed-off-by: Xin Long <lucien.xin@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=8873140f95d4977bf37e4cf0d5c5e3f6e34cdd3e)

| -rw-r--r-- | [include/net/sctp/sctp.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/sctp/sctp.h?id=8873140f95d4977bf37e4cf0d5c5e3f6e34cdd3e) | 6 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/net/sctp/structs.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/sctp/structs.h?id=8873140f95d4977bf37e4cf0d5c5e3f6e34cdd3e) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sctp/endpointola.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/sctp/endpointola.c?id=8873140f95d4977bf37e4cf0d5c5e3f6e34cdd3e) | 23 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sctp/sctp\_diag.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/sctp/sctp_diag.c?id=8873140f95d4977bf37e4cf0d5c5e3f6e34cdd3e) | 12 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sctp/socket.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/sctp/socket.c?id=8873140f95d4977bf37e4cf0d5c5e3f6e34cdd3e) | 23 | |  |  |  | | --- | --- | --- | |

5 files changed, 41 insertions, 26 deletions

| diff --git a/include/net/sctp/sctp.h b/include/net/sctp/sctp.hindex c713bd62428f6d..6c20a08a54ae1d 100644--- a/[include/net/sctp/sctp.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/sctp/sctp.h?id=5c2fe20ad37ff56070ae0acb34152333976929b4)+++ b/[include/net/sctp/sctp.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/sctp/sctp.h?id=8873140f95d4977bf37e4cf0d5c5e3f6e34cdd3e)@@ -118,6 +118,7 @@ extern struct percpu\_counter sctp\_sockets\_allocated; int sctp\_asconf\_mgmt(struct sctp\_sock \*, struct sctp\_sockaddr\_entry \*); struct sk\_buff \*sctp\_skb\_recv\_datagram(struct sock \*, int, int, int \*); +typedef int (\*sctp\_callback\_t)(struct sctp\_endpoint \*, struct sctp\_transport \*, void \*); int sctp\_transport\_walk\_start(struct rhashtable\_iter \*iter); void sctp\_transport\_walk\_stop(struct rhashtable\_iter \*iter); struct sctp\_transport \*sctp\_transport\_get\_next(struct net \*net,@@ -128,9 +129,8 @@ int sctp\_transport\_lookup\_process(int (\*cb)(struct sctp\_transport \*, void \*), struct net \*net, const union sctp\_addr \*laddr, const union sctp\_addr \*paddr, void \*p);-int sctp\_for\_each\_transport(int (\*cb)(struct sctp\_transport \*, void \*),- int (\*cb\_done)(struct sctp\_transport \*, void \*),- struct net \*net, int \*pos, void \*p);+int sctp\_transport\_traverse\_process(sctp\_callback\_t cb, sctp\_callback\_t cb\_done,+ struct net \*net, int \*pos, void \*p); int sctp\_for\_each\_endpoint(int (\*cb)(struct sctp\_endpoint \*, void \*), void \*p); int sctp\_get\_sctp\_info(struct sock \*sk, struct sctp\_association \*asoc, struct sctp\_info \*info);diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.hindex 5831a304e61b22..adbd8ad778f41f 100644--- a/[include/net/sctp/structs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/sctp/structs.h?id=5c2fe20ad37ff56070ae0acb34152333976929b4)+++ b/[include/net/sctp/structs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/sctp/structs.h?id=8873140f95d4977bf37e4cf0d5c5e3f6e34cdd3e)@@ -1272,6 +1272,7 @@ struct sctp\_endpoint { reconf\_enable:1;  \_\_u8 strreset\_enable;+ struct rcu\_head rcu; };  /\* Recover the outter endpoint structure. \*/@@ -1287,7 +1288,7 @@ static inline struct sctp\_endpoint \*sctp\_ep(struct sctp\_ep\_common \*base) struct sctp\_endpoint \*sctp\_endpoint\_new(struct sock \*, gfp\_t); void sctp\_endpoint\_free(struct sctp\_endpoint \*); void sctp\_endpoint\_put(struct sctp\_endpoint \*);-void sctp\_endpoint\_hold(struct sctp\_endpoint \*);+int sctp\_endpoint\_hold(struct sctp\_endpoint \*ep); void sctp\_endpoint\_add\_asoc(struct sctp\_endpoint \*, struct sctp\_association \*); struct sctp\_association \*sctp\_endpoint\_lookup\_assoc( const struct sctp\_endpoint \*ep,diff --git a/net/sctp/endpointola.c b/net/sctp/endpointola.cindex c71b4191df1e7d..8d3ee8bb6181da 100644--- a/[net/sctp/endpointola.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/endpointola.c?id=5c2fe20ad37ff56070ae0acb34152333976929b4)+++ b/[net/sctp/endpointola.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/endpointola.c?id=8873140f95d4977bf37e4cf0d5c5e3f6e34cdd3e)@@ -242,6 +242,18 @@ void sctp\_endpoint\_free(struct sctp\_endpoint \*ep) }  /\* Final destructor for endpoint. \*/+static void sctp\_endpoint\_destroy\_rcu(struct rcu\_head \*head)+{+ struct sctp\_endpoint \*ep = container\_of(head, struct sctp\_endpoint, rcu);+ struct sock \*sk = ep->base.sk;++ sctp\_sk(sk)->ep = NULL;+ sock\_put(sk);++ kfree(ep);+ SCTP\_DBG\_OBJCNT\_DEC(ep);+}+ static void sctp\_endpoint\_destroy(struct sctp\_endpoint \*ep) { struct sock \*sk;@@ -275,18 +287,13 @@ static void sctp\_endpoint\_destroy(struct sctp\_endpoint \*ep) if (sctp\_sk(sk)->bind\_hash) sctp\_put\_port(sk); - sctp\_sk(sk)->ep = NULL;- /\* Give up our hold on the sock \*/- sock\_put(sk);-- kfree(ep);- SCTP\_DBG\_OBJCNT\_DEC(ep);+ call\_rcu(&ep->rcu, sctp\_endpoint\_destroy\_rcu); }  /\* Hold a reference to an endpoint. \*/-void sctp\_endpoint\_hold(struct sctp\_endpoint \*ep)+int sctp\_endpoint\_hold(struct sctp\_endpoint \*ep) {- refcount\_inc(&ep->base.refcnt);+ return refcount\_inc\_not\_zero(&ep->base.refcnt); }  /\* Release a reference to an endpoint and clean up if there arediff --git a/net/sctp/sctp\_diag.c b/net/sctp/sctp\_diag.cindex 6a5a3dfa6c8d66..7c7b476bad3109 100644--- a/[net/sctp/sctp\_diag.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/sctp_diag.c?id=5c2fe20ad37ff56070ae0acb34152333976929b4)+++ b/[net/sctp/sctp\_diag.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/sctp_diag.c?id=8873140f95d4977bf37e4cf0d5c5e3f6e34cdd3e)@@ -276,9 +276,8 @@ out: return err; } -static int sctp\_sock\_dump(struct sctp\_transport \*tsp, void \*p)+static int sctp\_sock\_dump(struct sctp\_endpoint \*ep, struct sctp\_transport \*tsp, void \*p) {- struct sctp\_endpoint \*ep = tsp->asoc->ep; struct sctp\_comm\_param \*commp = p; struct sock \*sk = ep->base.sk; struct sk\_buff \*skb = commp->skb;@@ -288,6 +287,8 @@ static int sctp\_sock\_dump(struct sctp\_transport \*tsp, void \*p) int err = 0;  lock\_sock(sk);+ if (ep != tsp->asoc->ep)+ goto release; list\_for\_each\_entry(assoc, &ep->asocs, asocs) { if (cb->args[4] < cb->args[1]) goto next;@@ -330,9 +331,8 @@ release: return err; } -static int sctp\_sock\_filter(struct sctp\_transport \*tsp, void \*p)+static int sctp\_sock\_filter(struct sctp\_endpoint \*ep, struct sctp\_transport \*tsp, void \*p) {- struct sctp\_endpoint \*ep = tsp->asoc->ep; struct sctp\_comm\_param \*commp = p; struct sock \*sk = ep->base.sk; const struct inet\_diag\_req\_v2 \*r = commp->r;@@ -490,8 +490,8 @@ skip: if (!(idiag\_states & ~(TCPF\_LISTEN | TCPF\_CLOSE))) goto done; - sctp\_for\_each\_transport(sctp\_sock\_filter, sctp\_sock\_dump,- net, &pos, &commp);+ sctp\_transport\_traverse\_process(sctp\_sock\_filter, sctp\_sock\_dump,+ net, &pos, &commp); cb->args[2] = pos;  done:diff --git a/net/sctp/socket.c b/net/sctp/socket.cindex 8d64caa72cbaae..fac24f329c1d04 100644--- a/[net/sctp/socket.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/socket.c?id=5c2fe20ad37ff56070ae0acb34152333976929b4)+++ b/[net/sctp/socket.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/socket.c?id=8873140f95d4977bf37e4cf0d5c5e3f6e34cdd3e)@@ -4738,11 +4738,12 @@ int sctp\_transport\_lookup\_process(int (\*cb)(struct sctp\_transport \*, void \*), } EXPORT\_SYMBOL\_GPL(sctp\_transport\_lookup\_process); -int sctp\_for\_each\_transport(int (\*cb)(struct sctp\_transport \*, void \*),- int (\*cb\_done)(struct sctp\_transport \*, void \*),- struct net \*net, int \*pos, void \*p) {+int sctp\_transport\_traverse\_process(sctp\_callback\_t cb, sctp\_callback\_t cb\_done,+ struct net \*net, int \*pos, void \*p)+{ struct rhashtable\_iter hti; struct sctp\_transport \*tsp;+ struct sctp\_endpoint \*ep; int ret;  again:@@ -4752,26 +4753,32 @@ again:  tsp = sctp\_transport\_get\_idx(net, &hti, \*pos + 1); for (; !IS\_ERR\_OR\_NULL(tsp); tsp = sctp\_transport\_get\_next(net, &hti)) {- ret = cb(tsp, p);- if (ret)- break;+ ep = tsp->asoc->ep;+ if (sctp\_endpoint\_hold(ep)) { /\* asoc can be peeled off \*/+ ret = cb(ep, tsp, p);+ if (ret)+ break;+ sctp\_endpoint\_put(ep);+ } (\*pos)++; sctp\_transport\_put(tsp); } sctp\_transport\_walk\_stop(&hti);  if (ret) {- if (cb\_done && !cb\_done(tsp, p)) {+ if (cb\_done && !cb\_done(ep, tsp, p)) { (\*pos)++;+ sctp\_endpoint\_put(ep); sctp\_transport\_put(tsp); goto again; }+ sctp\_endpoint\_put(ep); sctp\_transport\_put(tsp); }  return ret; }-EXPORT\_SYMBOL\_GPL(sctp\_for\_each\_transport);+EXPORT\_SYMBOL\_GPL(sctp\_transport\_traverse\_process);  /\* 7.2.1 Association Status (SCTP\_STATUS) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 19:13:04 +0000



=== Content from git.kernel.org_ca79cd7d_20250110_191423.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=75799e71df1da11394740b43ae5686646179561d)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=75799e71df1da11394740b43ae5686646179561d)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=75799e71df1da11394740b43ae5686646179561d)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=75799e71df1da11394740b43ae5686646179561d)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Xin Long <lucien.xin@gmail.com> | 2021-12-23 13:04:30 -0500 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2022-01-05 12:42:35 +0100 |
| commit | [75799e71df1da11394740b43ae5686646179561d](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=75799e71df1da11394740b43ae5686646179561d) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=75799e71df1da11394740b43ae5686646179561d)) | |
| tree | [e52062e7d9ee317875d39f9a808d0a0953bf86ef](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=75799e71df1da11394740b43ae5686646179561d) | |
| parent | [df06c8dd7aca2078dbbfafd7495da49700ab324f](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=df06c8dd7aca2078dbbfafd7495da49700ab324f) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=75799e71df1da11394740b43ae5686646179561d&id2=df06c8dd7aca2078dbbfafd7495da49700ab324f)) | |
| download | [linux-75799e71df1da11394740b43ae5686646179561d.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-75799e71df1da11394740b43ae5686646179561d.tar.gz) | |

sctp: use call\_rcu to free endpoint[ Upstream commit 5ec7d18d1813a5bead0b495045606c93873aecbb ]
This patch is to delay the endpoint free by calling call\_rcu() to fix
another use-after-free issue in sctp\_sock\_dump():
BUG: KASAN: use-after-free in \_\_lock\_acquire+0x36d9/0x4c20
Call Trace:
\_\_lock\_acquire+0x36d9/0x4c20 kernel/locking/lockdep.c:3218
lock\_acquire+0x1ed/0x520 kernel/locking/lockdep.c:3844
\_\_raw\_spin\_lock\_bh include/linux/spinlock\_api\_smp.h:135 [inline]
\_raw\_spin\_lock\_bh+0x31/0x40 kernel/locking/spinlock.c:168
spin\_lock\_bh include/linux/spinlock.h:334 [inline]
\_\_lock\_sock+0x203/0x350 net/core/sock.c:2253
lock\_sock\_nested+0xfe/0x120 net/core/sock.c:2774
lock\_sock include/net/sock.h:1492 [inline]
sctp\_sock\_dump+0x122/0xb20 net/sctp/diag.c:324
sctp\_for\_each\_transport+0x2b5/0x370 net/sctp/socket.c:5091
sctp\_diag\_dump+0x3ac/0x660 net/sctp/diag.c:527
\_\_inet\_diag\_dump+0xa8/0x140 net/ipv4/inet\_diag.c:1049
inet\_diag\_dump+0x9b/0x110 net/ipv4/inet\_diag.c:1065
netlink\_dump+0x606/0x1080 net/netlink/af\_netlink.c:2244
\_\_netlink\_dump\_start+0x59a/0x7c0 net/netlink/af\_netlink.c:2352
netlink\_dump\_start include/linux/netlink.h:216 [inline]
inet\_diag\_handler\_cmd+0x2ce/0x3f0 net/ipv4/inet\_diag.c:1170
\_\_sock\_diag\_cmd net/core/sock\_diag.c:232 [inline]
sock\_diag\_rcv\_msg+0x31d/0x410 net/core/sock\_diag.c:263
netlink\_rcv\_skb+0x172/0x440 net/netlink/af\_netlink.c:2477
sock\_diag\_rcv+0x2a/0x40 net/core/sock\_diag.c:274
This issue occurs when asoc is peeled off and the old sk is freed after
getting it by asoc->base.sk and before calling lock\_sock(sk).
To prevent the sk free, as a holder of the sk, ep should be alive when
calling lock\_sock(). This patch uses call\_rcu() and moves sock\_put and
ep free into sctp\_endpoint\_destroy\_rcu(), so that it's safe to try to
hold the ep under rcu\_read\_lock in sctp\_transport\_traverse\_process().
If sctp\_endpoint\_hold() returns true, it means this ep is still alive
and we have held it and can continue to dump it; If it returns false,
it means this ep is dead and can be freed after rcu\_read\_unlock, and
we should skip it.
In sctp\_sock\_dump(), after locking the sk, if this ep is different from
tsp->asoc->ep, it means during this dumping, this asoc was peeled off
before calling lock\_sock(), and the sk should be skipped; If this ep is
the same with tsp->asoc->ep, it means no peeloff happens on this asoc,
and due to lock\_sock, no peeloff will happen either until release\_sock.
Note that delaying endpoint free won't delay the port release, as the
port release happens in sctp\_endpoint\_destroy() before calling call\_rcu().
Also, freeing endpoint by call\_rcu() makes it safe to access the sk by
asoc->base.sk in sctp\_assocs\_seq\_show() and sctp\_rcv().
Thanks Jones to bring this issue up.
v1->v2:
- improve the changelog.
- add kfree(ep) into sctp\_endpoint\_destroy\_rcu(), as Jakub noticed.
Reported-by: syzbot+9276d76e83e3bcde6c99@syzkaller.appspotmail.com
Reported-by: Lee Jones <lee.jones@linaro.org>
Fixes: d25adbeb0cdb ("sctp: fix an use-after-free issue in sctp\_sock\_dump")
Signed-off-by: Xin Long <lucien.xin@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=75799e71df1da11394740b43ae5686646179561d)

| -rw-r--r-- | [include/net/sctp/sctp.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/sctp/sctp.h?id=75799e71df1da11394740b43ae5686646179561d) | 6 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/net/sctp/structs.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/sctp/structs.h?id=75799e71df1da11394740b43ae5686646179561d) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sctp/diag.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/sctp/diag.c?id=75799e71df1da11394740b43ae5686646179561d) | 12 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sctp/endpointola.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/sctp/endpointola.c?id=75799e71df1da11394740b43ae5686646179561d) | 23 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sctp/socket.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/sctp/socket.c?id=75799e71df1da11394740b43ae5686646179561d) | 23 | |  |  |  | | --- | --- | --- | |

5 files changed, 41 insertions, 26 deletions

| diff --git a/include/net/sctp/sctp.h b/include/net/sctp/sctp.hindex 189fdb9db16220..d314a180ab93d7 100644--- a/[include/net/sctp/sctp.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/sctp/sctp.h?id=df06c8dd7aca2078dbbfafd7495da49700ab324f)+++ b/[include/net/sctp/sctp.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/sctp/sctp.h?id=75799e71df1da11394740b43ae5686646179561d)@@ -105,6 +105,7 @@ extern struct percpu\_counter sctp\_sockets\_allocated; int sctp\_asconf\_mgmt(struct sctp\_sock \*, struct sctp\_sockaddr\_entry \*); struct sk\_buff \*sctp\_skb\_recv\_datagram(struct sock \*, int, int, int \*); +typedef int (\*sctp\_callback\_t)(struct sctp\_endpoint \*, struct sctp\_transport \*, void \*); void sctp\_transport\_walk\_start(struct rhashtable\_iter \*iter); void sctp\_transport\_walk\_stop(struct rhashtable\_iter \*iter); struct sctp\_transport \*sctp\_transport\_get\_next(struct net \*net,@@ -115,9 +116,8 @@ int sctp\_transport\_lookup\_process(int (\*cb)(struct sctp\_transport \*, void \*), struct net \*net, const union sctp\_addr \*laddr, const union sctp\_addr \*paddr, void \*p);-int sctp\_for\_each\_transport(int (\*cb)(struct sctp\_transport \*, void \*),- int (\*cb\_done)(struct sctp\_transport \*, void \*),- struct net \*net, int \*pos, void \*p);+int sctp\_transport\_traverse\_process(sctp\_callback\_t cb, sctp\_callback\_t cb\_done,+ struct net \*net, int \*pos, void \*p); int sctp\_for\_each\_endpoint(int (\*cb)(struct sctp\_endpoint \*, void \*), void \*p); int sctp\_get\_sctp\_info(struct sock \*sk, struct sctp\_association \*asoc, struct sctp\_info \*info);diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.hindex 651bba654d77db..8d2c3dd9f5953f 100644--- a/[include/net/sctp/structs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/sctp/structs.h?id=df06c8dd7aca2078dbbfafd7495da49700ab324f)+++ b/[include/net/sctp/structs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/sctp/structs.h?id=75799e71df1da11394740b43ae5686646179561d)@@ -1365,6 +1365,7 @@ struct sctp\_endpoint {  u32 secid; u32 peer\_secid;+ struct rcu\_head rcu; };  /\* Recover the outter endpoint structure. \*/@@ -1380,7 +1381,7 @@ static inline struct sctp\_endpoint \*sctp\_ep(struct sctp\_ep\_common \*base) struct sctp\_endpoint \*sctp\_endpoint\_new(struct sock \*, gfp\_t); void sctp\_endpoint\_free(struct sctp\_endpoint \*); void sctp\_endpoint\_put(struct sctp\_endpoint \*);-void sctp\_endpoint\_hold(struct sctp\_endpoint \*);+int sctp\_endpoint\_hold(struct sctp\_endpoint \*ep); void sctp\_endpoint\_add\_asoc(struct sctp\_endpoint \*, struct sctp\_association \*); struct sctp\_association \*sctp\_endpoint\_lookup\_assoc( const struct sctp\_endpoint \*ep,diff --git a/net/sctp/diag.c b/net/sctp/diag.cindex 760b367644c12b..a7d62317150139 100644--- a/[net/sctp/diag.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/diag.c?id=df06c8dd7aca2078dbbfafd7495da49700ab324f)+++ b/[net/sctp/diag.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/diag.c?id=75799e71df1da11394740b43ae5686646179561d)@@ -290,9 +290,8 @@ out: return err; } -static int sctp\_sock\_dump(struct sctp\_transport \*tsp, void \*p)+static int sctp\_sock\_dump(struct sctp\_endpoint \*ep, struct sctp\_transport \*tsp, void \*p) {- struct sctp\_endpoint \*ep = tsp->asoc->ep; struct sctp\_comm\_param \*commp = p; struct sock \*sk = ep->base.sk; struct sk\_buff \*skb = commp->skb;@@ -302,6 +301,8 @@ static int sctp\_sock\_dump(struct sctp\_transport \*tsp, void \*p) int err = 0;  lock\_sock(sk);+ if (ep != tsp->asoc->ep)+ goto release; list\_for\_each\_entry(assoc, &ep->asocs, asocs) { if (cb->args[4] < cb->args[1]) goto next;@@ -344,9 +345,8 @@ release: return err; } -static int sctp\_sock\_filter(struct sctp\_transport \*tsp, void \*p)+static int sctp\_sock\_filter(struct sctp\_endpoint \*ep, struct sctp\_transport \*tsp, void \*p) {- struct sctp\_endpoint \*ep = tsp->asoc->ep; struct sctp\_comm\_param \*commp = p; struct sock \*sk = ep->base.sk; const struct inet\_diag\_req\_v2 \*r = commp->r;@@ -505,8 +505,8 @@ skip: if (!(idiag\_states & ~(TCPF\_LISTEN | TCPF\_CLOSE))) goto done; - sctp\_for\_each\_transport(sctp\_sock\_filter, sctp\_sock\_dump,- net, &pos, &commp);+ sctp\_transport\_traverse\_process(sctp\_sock\_filter, sctp\_sock\_dump,+ net, &pos, &commp); cb->args[2] = pos;  done:diff --git a/net/sctp/endpointola.c b/net/sctp/endpointola.cindex 48c9c2c7602f78..efffde7f2328e4 100644--- a/[net/sctp/endpointola.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/endpointola.c?id=df06c8dd7aca2078dbbfafd7495da49700ab324f)+++ b/[net/sctp/endpointola.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/endpointola.c?id=75799e71df1da11394740b43ae5686646179561d)@@ -184,6 +184,18 @@ void sctp\_endpoint\_free(struct sctp\_endpoint \*ep) }  /\* Final destructor for endpoint. \*/+static void sctp\_endpoint\_destroy\_rcu(struct rcu\_head \*head)+{+ struct sctp\_endpoint \*ep = container\_of(head, struct sctp\_endpoint, rcu);+ struct sock \*sk = ep->base.sk;++ sctp\_sk(sk)->ep = NULL;+ sock\_put(sk);++ kfree(ep);+ SCTP\_DBG\_OBJCNT\_DEC(ep);+}+ static void sctp\_endpoint\_destroy(struct sctp\_endpoint \*ep) { struct sock \*sk;@@ -213,18 +225,13 @@ static void sctp\_endpoint\_destroy(struct sctp\_endpoint \*ep) if (sctp\_sk(sk)->bind\_hash) sctp\_put\_port(sk); - sctp\_sk(sk)->ep = NULL;- /\* Give up our hold on the sock \*/- sock\_put(sk);-- kfree(ep);- SCTP\_DBG\_OBJCNT\_DEC(ep);+ call\_rcu(&ep->rcu, sctp\_endpoint\_destroy\_rcu); }  /\* Hold a reference to an endpoint. \*/-void sctp\_endpoint\_hold(struct sctp\_endpoint \*ep)+int sctp\_endpoint\_hold(struct sctp\_endpoint \*ep) {- refcount\_inc(&ep->base.refcnt);+ return refcount\_inc\_not\_zero(&ep->base.refcnt); }  /\* Release a reference to an endpoint and clean up if there arediff --git a/net/sctp/socket.c b/net/sctp/socket.cindex 6b937bfd475159..d2215d24634e85 100644--- a/[net/sctp/socket.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/socket.c?id=df06c8dd7aca2078dbbfafd7495da49700ab324f)+++ b/[net/sctp/socket.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/socket.c?id=75799e71df1da11394740b43ae5686646179561d)@@ -5338,11 +5338,12 @@ int sctp\_transport\_lookup\_process(int (\*cb)(struct sctp\_transport \*, void \*), } EXPORT\_SYMBOL\_GPL(sctp\_transport\_lookup\_process); -int sctp\_for\_each\_transport(int (\*cb)(struct sctp\_transport \*, void \*),- int (\*cb\_done)(struct sctp\_transport \*, void \*),- struct net \*net, int \*pos, void \*p) {+int sctp\_transport\_traverse\_process(sctp\_callback\_t cb, sctp\_callback\_t cb\_done,+ struct net \*net, int \*pos, void \*p)+{ struct rhashtable\_iter hti; struct sctp\_transport \*tsp;+ struct sctp\_endpoint \*ep; int ret;  again:@@ -5351,26 +5352,32 @@ again:  tsp = sctp\_transport\_get\_idx(net, &hti, \*pos + 1); for (; !IS\_ERR\_OR\_NULL(tsp); tsp = sctp\_transport\_get\_next(net, &hti)) {- ret = cb(tsp, p);- if (ret)- break;+ ep = tsp->asoc->ep;+ if (sctp\_endpoint\_hold(ep)) { /\* asoc can be peeled off \*/+ ret = cb(ep, tsp, p);+ if (ret)+ break;+ sctp\_endpoint\_put(ep);+ } (\*pos)++; sctp\_transport\_put(tsp); } sctp\_transport\_walk\_stop(&hti);  if (ret) {- if (cb\_done && !cb\_done(tsp, p)) {+ if (cb\_done && !cb\_done(ep, tsp, p)) { (\*pos)++;+ sctp\_endpoint\_put(ep); sctp\_transport\_put(tsp); goto again; }+ sctp\_endpoint\_put(ep); sctp\_transport\_put(tsp); }  return ret; }-EXPORT\_SYMBOL\_GPL(sctp\_for\_each\_transport);+EXPORT\_SYMBOL\_GPL(sctp\_transport\_traverse\_process);  /\* 7.2.1 Association Status (SCTP\_STATUS) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 19:13:00 +0000



=== Content from git.kernel.org_a9126b7f_20250110_191424.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=769d14abd35e0e153b5149c3e1e989a9d719e3ff)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=769d14abd35e0e153b5149c3e1e989a9d719e3ff)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=769d14abd35e0e153b5149c3e1e989a9d719e3ff)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=769d14abd35e0e153b5149c3e1e989a9d719e3ff)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Xin Long <lucien.xin@gmail.com> | 2021-12-23 13:04:30 -0500 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2022-01-05 12:40:30 +0100 |
| commit | [769d14abd35e0e153b5149c3e1e989a9d719e3ff](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=769d14abd35e0e153b5149c3e1e989a9d719e3ff) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=769d14abd35e0e153b5149c3e1e989a9d719e3ff)) | |
| tree | [d58db0a22405869f27ab248a334c8b74d61aa971](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=769d14abd35e0e153b5149c3e1e989a9d719e3ff) | |
| parent | [13c1bf43b6744fcf28387cdec6f5b5c24a32f20a](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=13c1bf43b6744fcf28387cdec6f5b5c24a32f20a) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=769d14abd35e0e153b5149c3e1e989a9d719e3ff&id2=13c1bf43b6744fcf28387cdec6f5b5c24a32f20a)) | |
| download | [linux-769d14abd35e0e153b5149c3e1e989a9d719e3ff.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-769d14abd35e0e153b5149c3e1e989a9d719e3ff.tar.gz) | |

sctp: use call\_rcu to free endpoint[ Upstream commit 5ec7d18d1813a5bead0b495045606c93873aecbb ]
This patch is to delay the endpoint free by calling call\_rcu() to fix
another use-after-free issue in sctp\_sock\_dump():
BUG: KASAN: use-after-free in \_\_lock\_acquire+0x36d9/0x4c20
Call Trace:
\_\_lock\_acquire+0x36d9/0x4c20 kernel/locking/lockdep.c:3218
lock\_acquire+0x1ed/0x520 kernel/locking/lockdep.c:3844
\_\_raw\_spin\_lock\_bh include/linux/spinlock\_api\_smp.h:135 [inline]
\_raw\_spin\_lock\_bh+0x31/0x40 kernel/locking/spinlock.c:168
spin\_lock\_bh include/linux/spinlock.h:334 [inline]
\_\_lock\_sock+0x203/0x350 net/core/sock.c:2253
lock\_sock\_nested+0xfe/0x120 net/core/sock.c:2774
lock\_sock include/net/sock.h:1492 [inline]
sctp\_sock\_dump+0x122/0xb20 net/sctp/diag.c:324
sctp\_for\_each\_transport+0x2b5/0x370 net/sctp/socket.c:5091
sctp\_diag\_dump+0x3ac/0x660 net/sctp/diag.c:527
\_\_inet\_diag\_dump+0xa8/0x140 net/ipv4/inet\_diag.c:1049
inet\_diag\_dump+0x9b/0x110 net/ipv4/inet\_diag.c:1065
netlink\_dump+0x606/0x1080 net/netlink/af\_netlink.c:2244
\_\_netlink\_dump\_start+0x59a/0x7c0 net/netlink/af\_netlink.c:2352
netlink\_dump\_start include/linux/netlink.h:216 [inline]
inet\_diag\_handler\_cmd+0x2ce/0x3f0 net/ipv4/inet\_diag.c:1170
\_\_sock\_diag\_cmd net/core/sock\_diag.c:232 [inline]
sock\_diag\_rcv\_msg+0x31d/0x410 net/core/sock\_diag.c:263
netlink\_rcv\_skb+0x172/0x440 net/netlink/af\_netlink.c:2477
sock\_diag\_rcv+0x2a/0x40 net/core/sock\_diag.c:274
This issue occurs when asoc is peeled off and the old sk is freed after
getting it by asoc->base.sk and before calling lock\_sock(sk).
To prevent the sk free, as a holder of the sk, ep should be alive when
calling lock\_sock(). This patch uses call\_rcu() and moves sock\_put and
ep free into sctp\_endpoint\_destroy\_rcu(), so that it's safe to try to
hold the ep under rcu\_read\_lock in sctp\_transport\_traverse\_process().
If sctp\_endpoint\_hold() returns true, it means this ep is still alive
and we have held it and can continue to dump it; If it returns false,
it means this ep is dead and can be freed after rcu\_read\_unlock, and
we should skip it.
In sctp\_sock\_dump(), after locking the sk, if this ep is different from
tsp->asoc->ep, it means during this dumping, this asoc was peeled off
before calling lock\_sock(), and the sk should be skipped; If this ep is
the same with tsp->asoc->ep, it means no peeloff happens on this asoc,
and due to lock\_sock, no peeloff will happen either until release\_sock.
Note that delaying endpoint free won't delay the port release, as the
port release happens in sctp\_endpoint\_destroy() before calling call\_rcu().
Also, freeing endpoint by call\_rcu() makes it safe to access the sk by
asoc->base.sk in sctp\_assocs\_seq\_show() and sctp\_rcv().
Thanks Jones to bring this issue up.
v1->v2:
- improve the changelog.
- add kfree(ep) into sctp\_endpoint\_destroy\_rcu(), as Jakub noticed.
Reported-by: syzbot+9276d76e83e3bcde6c99@syzkaller.appspotmail.com
Reported-by: Lee Jones <lee.jones@linaro.org>
Fixes: d25adbeb0cdb ("sctp: fix an use-after-free issue in sctp\_sock\_dump")
Signed-off-by: Xin Long <lucien.xin@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=769d14abd35e0e153b5149c3e1e989a9d719e3ff)

| -rw-r--r-- | [include/net/sctp/sctp.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/sctp/sctp.h?id=769d14abd35e0e153b5149c3e1e989a9d719e3ff) | 6 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/net/sctp/structs.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/sctp/structs.h?id=769d14abd35e0e153b5149c3e1e989a9d719e3ff) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sctp/diag.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/sctp/diag.c?id=769d14abd35e0e153b5149c3e1e989a9d719e3ff) | 12 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sctp/endpointola.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/sctp/endpointola.c?id=769d14abd35e0e153b5149c3e1e989a9d719e3ff) | 23 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sctp/socket.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/sctp/socket.c?id=769d14abd35e0e153b5149c3e1e989a9d719e3ff) | 23 | |  |  |  | | --- | --- | --- | |

5 files changed, 41 insertions, 26 deletions

| diff --git a/include/net/sctp/sctp.h b/include/net/sctp/sctp.hindex 4fc747b778eb63..33475d061823e8 100644--- a/[include/net/sctp/sctp.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/sctp/sctp.h?id=13c1bf43b6744fcf28387cdec6f5b5c24a32f20a)+++ b/[include/net/sctp/sctp.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/sctp/sctp.h?id=769d14abd35e0e153b5149c3e1e989a9d719e3ff)@@ -103,6 +103,7 @@ extern struct percpu\_counter sctp\_sockets\_allocated; int sctp\_asconf\_mgmt(struct sctp\_sock \*, struct sctp\_sockaddr\_entry \*); struct sk\_buff \*sctp\_skb\_recv\_datagram(struct sock \*, int, int, int \*); +typedef int (\*sctp\_callback\_t)(struct sctp\_endpoint \*, struct sctp\_transport \*, void \*); void sctp\_transport\_walk\_start(struct rhashtable\_iter \*iter); void sctp\_transport\_walk\_stop(struct rhashtable\_iter \*iter); struct sctp\_transport \*sctp\_transport\_get\_next(struct net \*net,@@ -113,9 +114,8 @@ int sctp\_transport\_lookup\_process(int (\*cb)(struct sctp\_transport \*, void \*), struct net \*net, const union sctp\_addr \*laddr, const union sctp\_addr \*paddr, void \*p);-int sctp\_for\_each\_transport(int (\*cb)(struct sctp\_transport \*, void \*),- int (\*cb\_done)(struct sctp\_transport \*, void \*),- struct net \*net, int \*pos, void \*p);+int sctp\_transport\_traverse\_process(sctp\_callback\_t cb, sctp\_callback\_t cb\_done,+ struct net \*net, int \*pos, void \*p); int sctp\_for\_each\_endpoint(int (\*cb)(struct sctp\_endpoint \*, void \*), void \*p); int sctp\_get\_sctp\_info(struct sock \*sk, struct sctp\_association \*asoc, struct sctp\_info \*info);diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.hindex 51d698f2656fc1..be9ff0422c1626 100644--- a/[include/net/sctp/structs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/sctp/structs.h?id=13c1bf43b6744fcf28387cdec6f5b5c24a32f20a)+++ b/[include/net/sctp/structs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/sctp/structs.h?id=769d14abd35e0e153b5149c3e1e989a9d719e3ff)@@ -1339,6 +1339,7 @@ struct sctp\_endpoint {  u32 secid; u32 peer\_secid;+ struct rcu\_head rcu; };  /\* Recover the outter endpoint structure. \*/@@ -1354,7 +1355,7 @@ static inline struct sctp\_endpoint \*sctp\_ep(struct sctp\_ep\_common \*base) struct sctp\_endpoint \*sctp\_endpoint\_new(struct sock \*, gfp\_t); void sctp\_endpoint\_free(struct sctp\_endpoint \*); void sctp\_endpoint\_put(struct sctp\_endpoint \*);-void sctp\_endpoint\_hold(struct sctp\_endpoint \*);+int sctp\_endpoint\_hold(struct sctp\_endpoint \*ep); void sctp\_endpoint\_add\_asoc(struct sctp\_endpoint \*, struct sctp\_association \*); struct sctp\_association \*sctp\_endpoint\_lookup\_assoc( const struct sctp\_endpoint \*ep,diff --git a/net/sctp/diag.c b/net/sctp/diag.cindex 493fc01e5d2b7c..babadd6720a2be 100644--- a/[net/sctp/diag.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/diag.c?id=13c1bf43b6744fcf28387cdec6f5b5c24a32f20a)+++ b/[net/sctp/diag.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/diag.c?id=769d14abd35e0e153b5149c3e1e989a9d719e3ff)@@ -292,9 +292,8 @@ out: return err; } -static int sctp\_sock\_dump(struct sctp\_transport \*tsp, void \*p)+static int sctp\_sock\_dump(struct sctp\_endpoint \*ep, struct sctp\_transport \*tsp, void \*p) {- struct sctp\_endpoint \*ep = tsp->asoc->ep; struct sctp\_comm\_param \*commp = p; struct sock \*sk = ep->base.sk; struct sk\_buff \*skb = commp->skb;@@ -304,6 +303,8 @@ static int sctp\_sock\_dump(struct sctp\_transport \*tsp, void \*p) int err = 0;  lock\_sock(sk);+ if (ep != tsp->asoc->ep)+ goto release; list\_for\_each\_entry(assoc, &ep->asocs, asocs) { if (cb->args[4] < cb->args[1]) goto next;@@ -346,9 +347,8 @@ release: return err; } -static int sctp\_sock\_filter(struct sctp\_transport \*tsp, void \*p)+static int sctp\_sock\_filter(struct sctp\_endpoint \*ep, struct sctp\_transport \*tsp, void \*p) {- struct sctp\_endpoint \*ep = tsp->asoc->ep; struct sctp\_comm\_param \*commp = p; struct sock \*sk = ep->base.sk; const struct inet\_diag\_req\_v2 \*r = commp->r;@@ -507,8 +507,8 @@ skip: if (!(idiag\_states & ~(TCPF\_LISTEN | TCPF\_CLOSE))) goto done; - sctp\_for\_each\_transport(sctp\_sock\_filter, sctp\_sock\_dump,- net, &pos, &commp);+ sctp\_transport\_traverse\_process(sctp\_sock\_filter, sctp\_sock\_dump,+ net, &pos, &commp); cb->args[2] = pos;  done:diff --git a/net/sctp/endpointola.c b/net/sctp/endpointola.cindex 48c9c2c7602f78..efffde7f2328e4 100644--- a/[net/sctp/endpointola.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/endpointola.c?id=13c1bf43b6744fcf28387cdec6f5b5c24a32f20a)+++ b/[net/sctp/endpointola.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/endpointola.c?id=769d14abd35e0e153b5149c3e1e989a9d719e3ff)@@ -184,6 +184,18 @@ void sctp\_endpoint\_free(struct sctp\_endpoint \*ep) }  /\* Final destructor for endpoint. \*/+static void sctp\_endpoint\_destroy\_rcu(struct rcu\_head \*head)+{+ struct sctp\_endpoint \*ep = container\_of(head, struct sctp\_endpoint, rcu);+ struct sock \*sk = ep->base.sk;++ sctp\_sk(sk)->ep = NULL;+ sock\_put(sk);++ kfree(ep);+ SCTP\_DBG\_OBJCNT\_DEC(ep);+}+ static void sctp\_endpoint\_destroy(struct sctp\_endpoint \*ep) { struct sock \*sk;@@ -213,18 +225,13 @@ static void sctp\_endpoint\_destroy(struct sctp\_endpoint \*ep) if (sctp\_sk(sk)->bind\_hash) sctp\_put\_port(sk); - sctp\_sk(sk)->ep = NULL;- /\* Give up our hold on the sock \*/- sock\_put(sk);-- kfree(ep);- SCTP\_DBG\_OBJCNT\_DEC(ep);+ call\_rcu(&ep->rcu, sctp\_endpoint\_destroy\_rcu); }  /\* Hold a reference to an endpoint. \*/-void sctp\_endpoint\_hold(struct sctp\_endpoint \*ep)+int sctp\_endpoint\_hold(struct sctp\_endpoint \*ep) {- refcount\_inc(&ep->base.refcnt);+ return refcount\_inc\_not\_zero(&ep->base.refcnt); }  /\* Release a reference to an endpoint and clean up if there arediff --git a/net/sctp/socket.c b/net/sctp/socket.cindex e872bc50bbe61f..0a9e2c7d8e5f53 100644--- a/[net/sctp/socket.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/socket.c?id=13c1bf43b6744fcf28387cdec6f5b5c24a32f20a)+++ b/[net/sctp/socket.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/socket.c?id=769d14abd35e0e153b5149c3e1e989a9d719e3ff)@@ -5223,11 +5223,12 @@ int sctp\_transport\_lookup\_process(int (\*cb)(struct sctp\_transport \*, void \*), } EXPORT\_SYMBOL\_GPL(sctp\_transport\_lookup\_process); -int sctp\_for\_each\_transport(int (\*cb)(struct sctp\_transport \*, void \*),- int (\*cb\_done)(struct sctp\_transport \*, void \*),- struct net \*net, int \*pos, void \*p) {+int sctp\_transport\_traverse\_process(sctp\_callback\_t cb, sctp\_callback\_t cb\_done,+ struct net \*net, int \*pos, void \*p)+{ struct rhashtable\_iter hti; struct sctp\_transport \*tsp;+ struct sctp\_endpoint \*ep; int ret;  again:@@ -5236,26 +5237,32 @@ again:  tsp = sctp\_transport\_get\_idx(net, &hti, \*pos + 1); for (; !IS\_ERR\_OR\_NULL(tsp); tsp = sctp\_transport\_get\_next(net, &hti)) {- ret = cb(tsp, p);- if (ret)- break;+ ep = tsp->asoc->ep;+ if (sctp\_endpoint\_hold(ep)) { /\* asoc can be peeled off \*/+ ret = cb(ep, tsp, p);+ if (ret)+ break;+ sctp\_endpoint\_put(ep);+ } (\*pos)++; sctp\_transport\_put(tsp); } sctp\_transport\_walk\_stop(&hti);  if (ret) {- if (cb\_done && !cb\_done(tsp, p)) {+ if (cb\_done && !cb\_done(ep, tsp, p)) { (\*pos)++;+ sctp\_endpoint\_put(ep); sctp\_transport\_put(tsp); goto again; }+ sctp\_endpoint\_put(ep); sctp\_transport\_put(tsp); }  return ret; }-EXPORT\_SYMBOL\_GPL(sctp\_for\_each\_transport);+EXPORT\_SYMBOL\_GPL(sctp\_transport\_traverse\_process);  /\* 7.2.1 Association Status (SCTP\_STATUS) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 19:13:02 +0000


