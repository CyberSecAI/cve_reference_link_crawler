=== Content from github.com_57daf5ae_20250110_195451.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FDriverHunter%2FWin-Driver-EXP%2Ftree%2Fmain%2FCVE-2024-33224)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FDriverHunter%2FWin-Driver-EXP%2Ftree%2Fmain%2FCVE-2024-33224)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Ffiles%2Fdisambiguate&source=header-repo&source_repo=DriverHunter%2FWin-Driver-EXP)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[DriverHunter](/DriverHunter)
/
**[Win-Driver-EXP](/DriverHunter/Win-Driver-EXP)**
Public

* [Notifications](/login?return_to=%2FDriverHunter%2FWin-Driver-EXP) You must be signed in to change notification settings
* [Fork
  4](/login?return_to=%2FDriverHunter%2FWin-Driver-EXP)
* [Star
   20](/login?return_to=%2FDriverHunter%2FWin-Driver-EXP)

* [Code](/DriverHunter/Win-Driver-EXP)
* [Issues
  0](/DriverHunter/Win-Driver-EXP/issues)
* [Pull requests
  0](/DriverHunter/Win-Driver-EXP/pulls)
* [Actions](/DriverHunter/Win-Driver-EXP/actions)
* [Projects
  0](/DriverHunter/Win-Driver-EXP/projects)
* [Security](/DriverHunter/Win-Driver-EXP/security)
* [Insights](/DriverHunter/Win-Driver-EXP/pulse)

Additional navigation options

* [Code](/DriverHunter/Win-Driver-EXP)
* [Issues](/DriverHunter/Win-Driver-EXP/issues)
* [Pull requests](/DriverHunter/Win-Driver-EXP/pulls)
* [Actions](/DriverHunter/Win-Driver-EXP/actions)
* [Projects](/DriverHunter/Win-Driver-EXP/projects)
* [Security](/DriverHunter/Win-Driver-EXP/security)
* [Insights](/DriverHunter/Win-Driver-EXP/pulse)

## Files

 main
## Breadcrumbs

1. [Win-Driver-EXP](/DriverHunter/Win-Driver-EXP/tree/main)
/
# CVE-2024-33224

/Copy path
## Directory actions

## More options

## Directory actions

## More options

## Latest commit

## History

[History](/DriverHunter/Win-Driver-EXP/commits/main/CVE-2024-33224) main
## Breadcrumbs

1. [Win-Driver-EXP](/DriverHunter/Win-Driver-EXP/tree/main)
/
# CVE-2024-33224

/Top
## Folders and files

| Name | | Name | Last commit message | Last commit date |
| --- | --- | --- | --- | --- |
| parent directory[..](/DriverHunter/Win-Driver-EXP/tree/main) | | |
| [README.md](/DriverHunter/Win-Driver-EXP/blob/main/CVE-2024-33224/README.md "README.md") | | [README.md](/DriverHunter/Win-Driver-EXP/blob/main/CVE-2024-33224/README.md "README.md") |  |  |
| [rtkio64.sys](/DriverHunter/Win-Driver-EXP/blob/main/CVE-2024-33224/rtkio64.sys "rtkio64.sys") | | [rtkio64.sys](/DriverHunter/Win-Driver-EXP/blob/main/CVE-2024-33224/rtkio64.sys "rtkio64.sys") |  |  |
| View all files | | |

## [README.md](#readme)

# Vulnerable Driver rtkio64.sys in Realtek Semiconductor Corp Realtek lO Driver v1.008.0823.2017

---

rtkio64.sys in Realtek Semiconductor Corp Realtek lO Driver v1.008.0823.2017 exposes functionality that allows low-privileged users to map arbitrary physical memory, read and write i/o port via specially crafted IOCTL requests. This can be exploited for privilege escalation, code execution under high privileges, and information disclosure. These signed drivers can also be used to bypass the Microsoft driver-signing policy to deploy malicious code.

## version

1.008.0823.2017

## Vulnerability causes

rtkio64.sys provides the functionality of mapping physical memory, read/write I/O ports, but it does not restrict the privileges of the caller, resulting in low-privileged users being able to call the driver and execute corresponding functions through DeviceIoControl.

```
__int64 __fastcall sub_134BC(__int64 a1, __int64 a2)
{
  unsigned int v3; // r12d
  unsigned __int16 *v4; // r13
  unsigned int v5; // ebx
  __int64 v6; // r9
  unsigned __int16 v7; // si
  unsigned __int8 v8; // di
  unsigned __int16 v9; // bx
  KAFFINITY ActiveProcessors; // rax
  __int64 v11; // rdx
  __int64 v12; // rbx
  unsigned __int8 v13; // al
  unsigned __int16 v14; // ax
  unsigned __int32 v15; // eax
  unsigned int *v16; // rbx
  _QWORD *v17; // rsi
  struct _MDL *v18; // rsi
  PVOID v19; // rax
  struct _MDL *Mdl; // rax
  unsigned int *PoolWithTag; // rax
  __int64 LowPart_low; // rcx
  __int64 v23; // r9
  unsigned __int16 v24; // ax
  int v25; // eax
  __int64 v26; // rcx
  __int64 v27; // r8
  int v28; // eax
  unsigned int v29; // ebx
  unsigned int v30; // eax
  __int64 v31; // rbx
  unsigned __int8 v32; // al
  char v33; // al
  int v34; // ecx
  int v35; // r8d
  int v36; // edx
  int v37; // ecx
  __int64 v38; // rdx
  int v39; // eax
  unsigned __int16 v40; // r11
  unsigned __int32 v41; // eax
  unsigned __int8 v42; // al
  unsigned __int8 v43; // bl
  unsigned __int16 v44; // dx
  unsigned __int16 v45; // dx
  unsigned __int16 v46; // r11
  unsigned __int32 v47; // eax
  unsigned __int8 v48; // al
  unsigned __int8 v49; // bl
  unsigned __int16 v50; // dx
  unsigned __int16 v51; // ax
  PIRP Irp; // [rsp+20h] [rbp-B8h]
  PIRP Irpa; // [rsp+20h] [rbp-B8h]
  PIRP Irpb; // [rsp+20h] [rbp-B8h]
  PIRP Irpc; // [rsp+20h] [rbp-B8h]
  PIRP Irpd; // [rsp+20h] [rbp-B8h]
  PIRP Irpe; // [rsp+20h] [rbp-B8h]
  PIRP Irpf; // [rsp+20h] [rbp-B8h]
  unsigned __int16 v60; // [rsp+70h] [rbp-68h]
  unsigned __int16 v61; // [rsp+72h] [rbp-66h]
  PVOID v62; // [rsp+78h] [rbp-60h]
  __int16 v63; // [rsp+78h] [rbp-60h]
  PVOID BaseAddress; // [rsp+F0h] [rbp+18h] BYREF
  PHYSICAL_ADDRESS PhysicalAddress; // [rsp+F8h] [rbp+20h] BYREF

  v3 = 0;
  if ( DeviceObject != (PDEVICE_OBJECT)&DeviceObject
    && (BYTE4(DeviceObject->Timer) & 1) != 0
    && BYTE1(DeviceObject->Timer) >= 4u )
  {
    sub_11314(DeviceObject->AttachedDevice, 42i64, &unk_16150);
  }
  *(_DWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0i64;
  PhysicalAddress = *(PHYSICAL_ADDRESS *)(a2 + 184);
  v4 = *(unsigned __int16 **)(a2 + 24);
  v5 = *(_DWORD *)(PhysicalAddress.QuadPart + 16);
  LODWORD(BaseAddress) = *(_DWORD *)(PhysicalAddress.QuadPart + 8);
  sub_110AC(5i64, "inBufLength=%x outBufLength=%x", v5, (unsigned int)BaseAddress);
  if ( !v5 )
  {
    v3 = -1073741811;
    goto LABEL_120;
  }
  sub_110AC(5i64, "IoControlCode = %x", *(unsigned int *)(PhysicalAddress.QuadPart + 24));
  sub_111C8(*(unsigned int *)(PhysicalAddress.QuadPart + 24));
  v6 = *(unsigned int *)(PhysicalAddress.QuadPart + 24);
  if ( (unsigned int)v6 > 0x8000201C )
  {
    switch ( (_DWORD)v6 )
    {
      case 0x80002024:
        sub_110AC(5i64, "!!IOCTL_PHYMEM_GETEEPROM\n");
        sub_110AC(5i64, "IoBase =%x Reg = %x\n", *v4, v4[1]);
        v46 = 6;
        if ( v5 == 6 && (unsigned int)BaseAddress >= 2 )
        {
          *(_QWORD *)(a2 + 56) = 2i64;
          v47 = __indword(*v4 + 68);
          if ( (v47 & 0x40) != 0 )
            v46 = 7;
          v48 = __inbyte(*v4 + 80);
          v49 = v48;
          v50 = *v4 + 80;
          __outbyte(v50, 0x80u);
          __outbyte(v50, 0x84u);
          __outbyte(v50, 0x80u);
          v51 = sub_12040((unsigned int)*v4 + 80, v4[1], v46);
          *v4 = v51;
          __outbyte(v51 + 80, 0x80u);
          __outbyte(v51 + 80, 0x84u);
          __outbyte(v51 + 80, 0x80u);
          __outbyte(*v4 + 80, v49);
        }
        else
        {
          v3 = -1073741811;
        }
        break;
      case 0x80002028:
        sub_110AC(5i64, "!!IOCTL_PHYMEM_SETEEEPROM\n");
        sub_110AC(5i64, "IoBase =%x Reg = %x Value = %x\n", *v4, v4[1], v4[2]);
        v40 = 6;
        if ( v5 == 6 )
        {
          *(_QWORD *)(a2 + 56) = 2i64;
          v41 = __indword(*v4 + 68);
          if ( (v41 & 0x40) != 0 )
            v40 = 7;
          v42 = __inbyte(*v4 + 80);
          v43 = v42;
          v44 = *v4 + 80;
          __outbyte(v44, 0x80u);
          __outbyte(v44, 0x84u);
          __outbyte(v44, 0x80u);
          sub_12320((unsigned int)*v4 + 80, v4[1], v4[2], v40);
          v45 = *v4 + 80;
          __outbyte(v45, 0x80u);
          __outbyte(v45, 0x84u);
          __outbyte(v45, 0x80u);
          __outbyte(v45, v43);
        }
        else
        {
          v3 = -1073741811;
        }
        break;
      case 0x8000202C:
        sub_110AC(5i64, "!!IOCTL_PHYMEM_GETCHANNEL\n");
        sub_110AC(
          5i64,
          "BUS =%x DEV = %x FN = %x PcieBase = %p\n",
          *(unsigned __int8 *)v4,
          *((unsigned __int8 *)v4 + 1),
          *((unsigned __int8 *)v4 + 2),
          *((const void **)v4 + 3));
        LODWORD(Irpe) = *((_DWORD *)v4 + 2);
        sub_110AC(
          5i64,
          "MutexType =%x AddrRegOffset = %x AddrRegValue = %x\n",
          *((unsigned __int8 *)v4 + 3),
          *((unsigned __int8 *)v4 + 4),
          Irpe);
        LODWORD(Irpf) = v4[10];
        sub_110AC(
          5i64,
          "DataRegOffset =%x DataRegValue = %x WaitTime = %x\n",
          *((unsigned __int8 *)v4 + 12),
          *((unsigned int *)v4 + 4),
          Irpf);
        if ( v5 == 40 && (unsigned int)BaseAddress >= 4 )
        {
          v37 = v4[10];
          v38 = *((_QWORD *)v4 + 3);
          LOBYTE(v38) = *((_BYTE *)v4 + 1);
          LOBYTE(v37) = *(_BYTE *)v4;
          v39 = sub_1161C(
                  v37,
                  v38,
                  *((unsigned __int8 *)v4 + 2),
                  v4[16],
                  *((_QWORD *)v4 + 3),
                  v4[10],
                  *((_BYTE *)v4 + 3),
                  0,
                  0,
                  *((_DWORD *)v4 + 2),
                  *((unsigned __int8 *)v4 + 4),
                  *((unsigned __int8 *)v4 + 12));
          if ( v39 == -1 )
          {
            v3 = -1073741823;
          }
          else
          {
            *(_DWORD *)v4 = v39;
            *(_QWORD *)(a2 + 56) = 4i64;
          }
        }
        else
        {
          v3 = -1073741811;
        }
        break;
      case 0x80002030:
        sub_110AC(5i64, "!!IOCTL_PHYMEM_SETCHANNEL\n");
        sub_110AC(
          5i64,
          "BUS =%x DEV = %x FN = %x\n",
          *(unsigned __int8 *)v4,
          *((unsigned __int8 *)v4 + 1),
          *((unsigned __int8 *)v4 + 2));
        LODWORD(Irpc) = *((_DWORD *)v4 + 2);
        sub_110AC(
          5i64,
          "MutexType =%x AddrRegOffset = %x AddrRegValue = %x\n",
          *((unsigned __int8 *)v4 + 3),
          *((unsigned __int8 *)v4 + 4),
          Irpc);
        LODWORD(Irpd) = v4[10];
        sub_110AC(
          5i64,
          "DataRegOffset =%x DataRegValue = %x WaitTime = %x\n",
          *((unsigned __int8 *)v4 + 12),
          *((unsigned int *)v4 + 4),
          Irpd);
        if ( v5 == 40 )
        {
          v35 = *((_DWORD *)v4 + 4);
          v36 = v4[10];
          LOBYTE(v35) = *((_BYTE *)v4 + 2);
          LOBYTE(v36) = *((_BYTE *)v4 + 1);
          LOBYTE(v34) = *(_BYTE *)v4;
          v3 = sub_1187C(
                 v34,
                 v36,
                 v35,
                 v4[16],
                 *((_QWORD *)v4 + 3),
                 v4[10],
                 *((_BYTE *)v4 + 3),
                 0,
                 0,
                 *((_DWORD *)v4 + 2),
                 *((unsigned __int8 *)v4 + 4),
                 *((_DWORD *)v4 + 4),
                 *((unsigned __int8 *)v4 + 12));
        }
        else
        {
          v3 = -1073741811;
        }
        break;
      case 0x80002034:
        sub_110AC(5i64, "!!IOCTL_PHYMEM_INFORM_FP_FW_S3S4S5\n");
        sub_110AC(
          5i64,
          "BUS =%x DEV = %x FN = %x\n",
          *(unsigned __int8 *)v4,
          *((unsigned __int8 *)v4 + 1),
          *((unsigned __int8 *)v4 + 2));
        LODWORD(Irpa) = *((_DWORD *)v4 + 2);
        sub_110AC(
          5i64,
          "MutexType =%x AddrRegOffset = %x AddrRegValue = %x\n",
          *((unsigned __int8 *)v4 + 3),
          *((unsigned __int8 *)v4 + 4),
          Irpa);
        LODWORD(Irpb) = v4[10];
        sub_110AC(
          5i64,
          "DataRegOffset =%x DataRegValue = %x WaitTime = %x\n",
          *((unsigned __int8 *)v4 + 12),
          *((unsigned int *)v4 + 4),
          Irpb);
        sub_110AC(5i64, "PCIEBASE =%p IOBASE = %x \n", *((const void **)v4 + 3), v4[16]);
        byte_17161 = 0;
        word_17164 = 0;
        Src = 0;
        dword_1716C = 0;
        if ( v5 == 40 )
        {
          memmove(&byte_17180, v4, 0x28ui64);
          v32 = sub_11B58(byte_17180, byte_17181, byte_17182, *(__int64 *)&qword_17198, 4u, 1u);
          sub_11CE4(byte_17180, byte_17181, byte_17182, *(__int64 *)&qword_17198, 4u, v32 | 7, 1u);
          v33 = sub_11B58(byte_17180, byte_17181, byte_17182, *(__int64 *)&qword_17198, 0x44u, 1u);
          sub_11CE4(byte_17180, byte_17181, byte_17182, *(__int64 *)&qword_17198, 0x44u, v33 & 0xFC, 1u);
          sub_128E8();
          byte_17160 = 1;
        }
        else
        {
          v3 = -1073741811;
        }
        break;
      default:
        goto LABEL_92;
    }
  }
  else
  {
    switch ( (_DWORD)v6 )
    {
      case 0x8000201C:
        sub_110AC(5i64, "IOCTL_ENUM_RTKNIC\n");
        LOWORD(PhysicalAddress.LowPart) = 0;
        do
        {
          LOBYTE(v24) = 0;
          v61 = 0;
          do
          {
            v60 = (unsigned __int8)v24;
            LOBYTE(v23) = 12;
            LOBYTE(LowPart_low) = v3;
            v25 = sub_143D6(LowPart_low, (unsigned __int8)v24, 0i64, v23);
            if ( v25 == -1 || (v25 & 0x800000) == 0 )
              v63 = 1;
            else
              v63 = 8;
            LOBYTE(v26) = 0;
            LOBYTE(BaseAddress) = 0;
            while ( 1 )
            {
              LOBYTE(v27) = v26;
              LOBYTE(v26) = v3;
              v28 = sub_143D6(v26, v60, v27, 0i64);
              if ( v28 == -2127163156
                || v28 == -2127097620
                || v28 == -2123951892
                || v28 == -2123886356
                || v28 == -2123820820
                || v28 == -2124017428
                || v28 == -2124345108 )
              {
                break;
              }
              LOBYTE(v26) = (_BYTE)BaseAddress + 1;
              LOBYTE(BaseAddress) = v26;
              if ( (unsigned __int8)v26 >= (unsigned __int16)v63 )
              {
                LowPart_low = LOWORD(PhysicalAddress.LowPart);
                goto LABEL_82;
              }
            }
            LOBYTE(v23) = 16;
            LOBYTE(v27) = (_BYTE)BaseAddress;
            LOBYTE(v26) = v3;
            v29 = sub_143D6(v26, v60, v27, v23);
            sub_110AC(5i64, "Hardware ID: 0x%08X\n", v29);
            v30 = LOWORD(PhysicalAddress.LowPart);
            *(_DWORD *)&v4[2 * LOWORD(PhysicalAddress.LowPart) + 2] = v29 - 1;
            sub_110AC(5i64, "cnt=%d\n", v30);
            LOWORD(LowPart_low) = ++LOWORD(PhysicalAddress.LowPart);
LABEL_82:
            v24 = v61 + 1;
            v61 = v24;
          }
          while ( v24 < 0x20u );
          LOWORD(v3) = v3 + 1;
        }
        while ( (unsigned __int16)v3 < 0x100u );
        *(_DWORD *)v4 = (unsigned __int16)LowPart_low;
        *(_QWORD *)(a2 + 56) = 4i64 * ((unsigned __int16)LowPart_low + 1);
        sub_110AC(5i64, "pSysBuf:");
        v31 = 10i64;
        v3 = 0;
        do
        {
          sub_110AC(5i64, (const char *)qword_14DE0, *(unsigned int *)v4);
          v4 += 2;
          --v31;
        }
        while ( v31 );
        sub_110AC(5i64, (const char *)qword_14DF0);
        break;
      case 0x80002000:// map primitive
        sub_110AC(5i64, "!!IOCTL_PHYMEM_MAP\n");
        if ( v5 != 16 || (_DWORD)BaseAddress != 8 )
        {
          v3 = -1073741811;
          break;
        }
        PhysicalAddress.QuadPart = 0i64;
        BaseAddress = 0i64;
        v18 = 0i64;
        v16 = 0i64;
        memmove(&PhysicalAddress, v4, 8ui64);
        v19 = MmMapIoSpace(PhysicalAddress, *((unsigned int *)v4 + 2), MmNonCached);
        v62 = v19;
        if ( v19 )
        {
          Mdl = IoAllocateMdl(v19, *((_DWORD *)v4 + 2), 0, 0, 0i64);
          v18 = Mdl;
          if ( Mdl )
          {
            MmBuildMdlForNonPagedPool(Mdl);
            BaseAddress = MmMapLockedPagesSpecifyCache(v18, 1, MmNonCached, 0i64, 0, 0x10u);
            if ( BaseAddress )
            {
              PoolWithTag = (unsigned int *)ExAllocatePoolWithTag(NonPagedPool, 0x28ui64, 0x6F697452u);
              v16 = PoolWithTag;
              if ( PoolWithTag )
              {
                *((_QWORD *)PoolWithTag + 1) = v18;
                *((_QWORD *)PoolWithTag + 2) = v62;
                *((_QWORD *)PoolWithTag + 3) = BaseAddress;
                PoolWithTag[8] = *((_DWORD *)v4 + 2);
                *(_QWORD *)PoolWithTag = P;
                P = PoolWithTag;
                LODWORD(Irp) = *((_DWORD *)v4 + 2);
                sub_110AC(5i64, "Map physical 0x%p to virtual 0x%p, size %u", *(const void **)v4, BaseAddress, Irp);
                memmove(v4, &BaseAddress, 8ui64);
                *(_QWORD *)(a2 + 56) = 8i64;
              }
              else
              {
                sub_110AC(5i64, "Call to ExAllocatePoolWithTag MAPINFO failed\n");
                v3 = -1073741670;
              }
            }
            else
            {
              sub_110AC(5i64, "Call to MmMapLockedPagesSpecifyCache MAPINFO failed\n");
              v3 = -1073741670;
            }
          }
          else
          {
            v3 = -1073741670;
          }
        }
        else
        {
          v3 = -1073741670;
        }
        if ( v3 )
        {
          if ( BaseAddress )
            MmUnmapLockedPages(BaseAddress, v18);
          if ( v18 )
            IoFreeMdl(v18);
          if ( v62 )
            MmUnmapIoSpace(v62, *((unsigned int *)v4 + 2));
          if ( v16 )
            goto LABEL_63;
        }
        break;
      case 0x80002004:
        sub_110AC(5i64, "!!IOCTL_PHYMEM_UNMAP\n");
        if ( v5 != 16 )
        {
          v3 = -1073741811;
          break;
        }
        v16 = (unsigned int *)P;
        v17 = P;
        if ( P )
        {
          while ( *((_QWORD *)v16 + 3) != *(_QWORD *)v4 )
          {
            v17 = v16;
            v16 = *(unsigned int **)v16;
            if ( !v16 )
              goto LABEL_120;
          }
          if ( v16[8] != *((_DWORD *)v4 + 2) )
          {
            v3 = -1073741811;
            break;
          }
          MmUnmapLockedPages(*((PVOID *)v16 + 3), *((PMDL *)v16 + 1));
          IoFreeMdl(*((PMDL *)v16 + 1));
          MmUnmapIoSpace(*((PVOID *)v16 + 2), v16[8]);
          if ( v16 == P )
            P = *(PVOID *)v16;
          else
            *v17 = *(_QWORD *)v16;
LABEL_63:
          ExFreePoolWithTag(v16, 0);
        }
        break;
      case 0x80002008:// in primitive
        sub_110AC(5i64, "!!IOCTL_PHYMEM_GETPORT\n");
        sub_110AC(5i64, "pPort->dwPort=%x\n", *(unsigned int *)v4);
        if ( v5 == 12 )
        {
          *(_QWORD *)(a2 + 56) = 4i64;
          switch ( *((_DWORD *)v4 + 1) )
          {
            case 1:
              v13 = __inbyte(*(_DWORD *)v4);
              *(_DWORD *)v4 = v13;
              break;
            case 2:
              v14 = __inword(*(_DWORD *)v4);
              *(_DWORD *)v4 = v14;
              break;
            case 4:
              v15 = __indword(*(_DWORD *)v4);
              *(_DWORD *)v4 = v15;
              break;
            default:
              v3 = -1073741811;
              break;
          }
        }
        else
        {
          v3 = -1073741811;
        }
        break;
      case 0x8000200C://out primitive
        sub_110AC(5i64, "!!IOCTL_PHYMEM_SETPORT");
        if ( v5 == 12 )
        {
          *(_QWORD *)(a2 + 56) = 4i64;
          switch ( *((_DWORD *)v4 + 1) )
          {
            case 1:
              __outbyte(*(_DWORD *)v4, *((_BYTE *)v4 + 8));
              break;
            case 2:
              __outword(*(_DWORD *)v4, v4[4]);
              break;
            case 4:
              __outdword(*(_DWORD *)v4, *((_DWORD *)v4 + 2));
              break;
            default:
              v3 = -1073741811;
              break;
          }
        }
        else
        {
          v3 = -1073741811;
        }
        break;
      case 0x80002018:
        *(_QWORD *)(a2 + 56) = 8i64;
        sub_110AC(5i64, "!!IOCTL_PHYMEM_SENDSMI");
        v7 = *v4;
        v8 = *((_BYTE *)v4 + 2);
        v9 = v4[2];
        sub_110AC(5i64, "!!!!!!SmiPort=0x%x SmiCommand=0x%x SmiSubCommand=0x%x!!\n", *v4, v8, v9);
        ActiveProcessors = KeQueryActiveProcessors();
        sub_110AC(5i64, "KeActiveProcessors=0x%zx", ActiveProcessors);
        KeSetSystemAffinityThread(1ui64);
        LOBYTE(v11) = v8;
        v12 = (unsigned __int16)sub_143A0(v7, v11, v9);
        KeSetSystemAffinityThread(1ui64);
        sub_110AC(5i64, "SmiResult=%d\n", (unsigned int)v12);
        *(_QWORD *)v4 = v12;
        break;
      default:
LABEL_92:
        if ( DeviceObject != (PDEVICE_OBJECT)&DeviceObject
          && (BYTE4(DeviceObject->Timer) & 1) != 0
          && BYTE1(DeviceObject->Timer) >= 4u )
        {
          sub_11008(DeviceObject->AttachedDevice, 43i64, &unk_16150, v6);
        }
        v3 = -1073741808;
        break;
    }
  }
LABEL_120:
  *(_DWORD *)(a2 + 48) = v3;
  IofCompleteRequest((PIRP)a2, 0);
  if ( DeviceObject != (PDEVICE_OBJECT)&DeviceObject
    && (BYTE4(DeviceObject->Timer) & 1) != 0
    && BYTE1(DeviceObject->Timer) >= 4u )
  {
    sub_11008(DeviceObject->AttachedDevice, 44i64, &unk_16150, v3);
  }
  return v3;
}
```

### IOCTL 0x80002000

This IOCTL code triggers memory map operation as blow.

```
      case 0x80002000:// map primitive
        sub_110AC(5i64, "!!IOCTL_PHYMEM_MAP\n");
        if ( v5 != 16 || (_DWORD)BaseAddress != 8 )
        {
          v3 = -1073741811;
          break;
        }
        PhysicalAddress.QuadPart = 0i64;
        BaseAddress = 0i64;
        v18 = 0i64;
        v16 = 0i64;
        memmove(&PhysicalAddress, v4, 8ui64);
        v19 = MmMapIoSpace(PhysicalAddress, *((unsigned int *)v4 + 2), MmNonCached);
        v62 = v19;
        if ( v19 )
        {
          Mdl = IoAllocateMdl(v19, *((_DWORD *)v4 + 2), 0, 0, 0i64);
          v18 = Mdl;
          if ( Mdl )
          {
            MmBuildMdlForNonPagedPool(Mdl);
            BaseAddress = MmMapLockedPagesSpecifyCache(v18, 1, MmNonCached, 0i64, 0, 0x10u);
            if ( BaseAddress )
            {
              PoolWithTag = (unsigned int *)ExAllocatePoolWithTag(NonPagedPool, 0x28ui64, 0x6F697452u);
              v16 = PoolWithTag;
              if ( PoolWithTag )
              {
                *((_QWORD *)PoolWithTag + 1) = v18;
                *((_QWORD *)PoolWithTag + 2) = v62;
                *((_QWORD *)PoolWithTag + 3) = BaseAddress;
                PoolWithTag[8] = *((_DWORD *)v4 + 2);
                *(_QWORD *)PoolWithTag = P;
                P = PoolWithTag;
                LODWORD(Irp) = *((_DWORD *)v4 + 2);
                sub_110AC(5i64, "Map physical 0x%p to virtual 0x%p, size %u", *(const void **)v4, BaseAddress, Irp);
                memmove(v4, &BaseAddress, 8ui64);
                *(_QWORD *)(a2 + 56) = 8i64;
              }
              else
              {
                sub_110AC(5i64, "Call to ExAllocatePoolWithTag MAPINFO failed\n");
                v3 = -1073741670;
              }
            }
            else
            {
              sub_110AC(5i64, "Call to MmMapLockedPagesSpecifyCache MAPINFO failed\n");
              v3 = -1073741670;
            }
          }
          else
          {
            v3 = -1073741670;
          }
        }
        else
        {
          v3 = -1073741670;
        }
        if ( v3 )
        {
          if ( BaseAddress )
            MmUnmapLockedPages(BaseAddress, v18);
          if ( v18 )
            IoFreeMdl(v18);
          if ( v62 )
            MmUnmapIoSpace(v62, *((unsigned int *)v4 + 2));
          if ( v16 )
            goto LABEL_63;
        }
        break;
```

### IOCTL 0x8000200C

This IOCTL code triggers port out operation .

```
      case 0x8000200C://out primitive
        sub_110AC(5i64, "!!IOCTL_PHYMEM_SETPORT");
        if ( v5 == 12 )
        {
          *(_QWORD *)(a2 + 56) = 4i64;
          switch ( *((_DWORD *)v4 + 1) )
          {
            case 1:
              __outbyte(*(_DWORD *)v4, *((_BYTE *)v4 + 8));
              break;
            case 2:
              __outword(*(_DWORD *)v4, v4[4]);
              break;
            case 4:
              __outdword(*(_DWORD *)v4, *((_DWORD *)v4 + 2));
              break;
            default:
              v3 = -1073741811;
              break;
          }
        }
        else
        {
          v3 = -1073741811;
        }
        break;
```

### IOCTL 0x8000200C

This IOCTL code triggers port in operation .

```
      case 0x80002008:// in primitive
        sub_110AC(5i64, "!!IOCTL_PHYMEM_GETPORT\n");
        sub_110AC(5i64, "pPort->dwPort=%x\n", *(unsigned int *)v4);
        if ( v5 == 12 )
        {
          *(_QWORD *)(a2 + 56) = 4i64;
          switch ( *((_DWORD *)v4 + 1) )
          {
            case 1:
              v13 = __inbyte(*(_DWORD *)v4);
              *(_DWORD *)v4 = v13;
              break;
            case 2:
              v14 = __inword(*(_DWORD *)v4);
              *(_DWORD *)v4 = v14;
              break;
            case 4:
              v15 = __indword(*(_DWORD *)v4);
              *(_DWORD *)v4 = v15;
              break;
            default:
              v3 = -1073741811;
              break;
          }
        }
        else
        {
          v3 = -1073741811;
        }
        break;
```

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


