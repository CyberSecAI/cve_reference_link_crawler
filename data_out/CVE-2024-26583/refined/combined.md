=== Content from git.kernel.org_f6a530e2_20250111_193104.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=6209319b2efdd8524691187ee99c40637558fa33)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=6209319b2efdd8524691187ee99c40637558fa33)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6209319b2efdd8524691187ee99c40637558fa33)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=6209319b2efdd8524691187ee99c40637558fa33)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jakub Kicinski <kuba@kernel.org> | 2024-02-06 17:18:19 -0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-02-23 09:51:26 +0100 |
| commit | [6209319b2efdd8524691187ee99c40637558fa33](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6209319b2efdd8524691187ee99c40637558fa33) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=6209319b2efdd8524691187ee99c40637558fa33)) | |
| tree | [4e927164684d386ad9e89709eb09b98a10500cb4](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=6209319b2efdd8524691187ee99c40637558fa33) | |
| parent | [51f6ed87ac5f3f493b5e06945727fb0c9441061a](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=51f6ed87ac5f3f493b5e06945727fb0c9441061a) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=6209319b2efdd8524691187ee99c40637558fa33&id2=51f6ed87ac5f3f493b5e06945727fb0c9441061a)) | |
| download | [linux-6209319b2efdd8524691187ee99c40637558fa33.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-6209319b2efdd8524691187ee99c40637558fa33.tar.gz) | |

tls: fix race between async notify and socket close[ Upstream commit aec7961916f3f9e88766e2688992da6980f11b8d ]
The submitting thread (one which called recvmsg/sendmsg)
may exit as soon as the async crypto handler calls complete()
so any code past that point risks touching already freed data.
Try to avoid the locking and extra flags altogether.
Have the main thread hold an extra reference, this way
we can depend solely on the atomic ref counter for
synchronization.
Don't futz with reiniting the completion, either, we are now
tightly controlling when completion fires.
Reported-by: valis <sec@valis.email>
Fixes: 0cada33241d9 ("net/tls: fix race condition causing kernel panic")
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Reviewed-by: Simon Horman <horms@kernel.org>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Reviewed-by: Sabrina Dubroca <sd@queasysnail.net>
Signed-off-by: David S. Miller <davem@davemloft.net>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=6209319b2efdd8524691187ee99c40637558fa33)

| -rw-r--r-- | [include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/tls.h?id=6209319b2efdd8524691187ee99c40637558fa33) | 5 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/tls/tls\_sw.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/tls/tls_sw.c?id=6209319b2efdd8524691187ee99c40637558fa33) | 43 | |  |  |  | | --- | --- | --- | |

2 files changed, 10 insertions, 38 deletions

| diff --git a/include/net/tls.h b/include/net/tls.hindex 962f0c501111ba..340ad43971e471 100644--- a/[include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/tls.h?id=51f6ed87ac5f3f493b5e06945727fb0c9441061a)+++ b/[include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/tls.h?id=6209319b2efdd8524691187ee99c40637558fa33)@@ -97,9 +97,6 @@ struct tls\_sw\_context\_tx { struct tls\_rec \*open\_rec; struct list\_head tx\_list; atomic\_t encrypt\_pending;- /\* protect crypto\_wait with encrypt\_pending \*/- spinlock\_t encrypt\_compl\_lock;- int async\_notify; u8 async\_capable:1;  #define BIT\_TX\_SCHEDULED 0@@ -136,8 +133,6 @@ struct tls\_sw\_context\_rx { struct tls\_strparser strp;  atomic\_t decrypt\_pending;- /\* protect crypto\_wait with decrypt\_pending\*/- spinlock\_t decrypt\_compl\_lock; struct sk\_buff\_head async\_hold; struct wait\_queue\_head wq; };diff --git a/net/tls/tls\_sw.c b/net/tls/tls\_sw.cindex 6a73714f34cc4a..635305bebfef6d 100644--- a/[net/tls/tls\_sw.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_sw.c?id=51f6ed87ac5f3f493b5e06945727fb0c9441061a)+++ b/[net/tls/tls\_sw.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_sw.c?id=6209319b2efdd8524691187ee99c40637558fa33)@@ -224,22 +224,15 @@ static void tls\_decrypt\_done(void \*data, int err)  kfree(aead\_req); - spin\_lock\_bh(&ctx->decrypt\_compl\_lock);- if (!atomic\_dec\_return(&ctx->decrypt\_pending))+ if (atomic\_dec\_and\_test(&ctx->decrypt\_pending)) complete(&ctx->async\_wait.completion);- spin\_unlock\_bh(&ctx->decrypt\_compl\_lock); }  static int tls\_decrypt\_async\_wait(struct tls\_sw\_context\_rx \*ctx) {- int pending;-- spin\_lock\_bh(&ctx->decrypt\_compl\_lock);- reinit\_completion(&ctx->async\_wait.completion);- pending = atomic\_read(&ctx->decrypt\_pending);- spin\_unlock\_bh(&ctx->decrypt\_compl\_lock);- if (pending)+ if (!atomic\_dec\_and\_test(&ctx->decrypt\_pending)) crypto\_wait\_req(-EINPROGRESS, &ctx->async\_wait);+ atomic\_inc(&ctx->decrypt\_pending);  return ctx->async\_wait.err; }@@ -267,6 +260,7 @@ static int tls\_do\_decryption(struct sock \*sk, aead\_request\_set\_callback(aead\_req, CRYPTO\_TFM\_REQ\_MAY\_BACKLOG, tls\_decrypt\_done, aead\_req);+ DEBUG\_NET\_WARN\_ON\_ONCE(atomic\_read(&ctx->decrypt\_pending) < 1); atomic\_inc(&ctx->decrypt\_pending); } else { aead\_request\_set\_callback(aead\_req,@@ -455,7 +449,6 @@ static void tls\_encrypt\_done(void \*data, int err) struct sk\_msg \*msg\_en; bool ready = false; struct sock \*sk;- int pending;  msg\_en = &rec->msg\_encrypted; @@ -494,12 +487,8 @@ static void tls\_encrypt\_done(void \*data, int err) ready = true; } - spin\_lock\_bh(&ctx->encrypt\_compl\_lock);- pending = atomic\_dec\_return(&ctx->encrypt\_pending);-- if (!pending && ctx->async\_notify)+ if (atomic\_dec\_and\_test(&ctx->encrypt\_pending)) complete(&ctx->async\_wait.completion);- spin\_unlock\_bh(&ctx->encrypt\_compl\_lock);  if (!ready) return;@@ -511,22 +500,9 @@ static void tls\_encrypt\_done(void \*data, int err)  static int tls\_encrypt\_async\_wait(struct tls\_sw\_context\_tx \*ctx) {- int pending;-- spin\_lock\_bh(&ctx->encrypt\_compl\_lock);- ctx->async\_notify = true;-- pending = atomic\_read(&ctx->encrypt\_pending);- spin\_unlock\_bh(&ctx->encrypt\_compl\_lock);- if (pending)+ if (!atomic\_dec\_and\_test(&ctx->encrypt\_pending)) crypto\_wait\_req(-EINPROGRESS, &ctx->async\_wait);- else- reinit\_completion(&ctx->async\_wait.completion);-- /\* There can be no concurrent accesses, since we have no- \* pending encrypt operations- \*/- WRITE\_ONCE(ctx->async\_notify, false);+ atomic\_inc(&ctx->encrypt\_pending);  return ctx->async\_wait.err; }@@ -577,6 +553,7 @@ static int tls\_do\_encryption(struct sock \*sk,  /\* Add the record in tx\_list \*/ list\_add\_tail((struct list\_head \*)&rec->list, &ctx->tx\_list);+ DEBUG\_NET\_WARN\_ON\_ONCE(atomic\_read(&ctx->encrypt\_pending) < 1); atomic\_inc(&ctx->encrypt\_pending);  rc = crypto\_aead\_encrypt(aead\_req);@@ -2601,7 +2578,7 @@ static struct tls\_sw\_context\_tx \*init\_ctx\_tx(struct tls\_context \*ctx, struct soc }  crypto\_init\_wait(&sw\_ctx\_tx->async\_wait);- spin\_lock\_init(&sw\_ctx\_tx->encrypt\_compl\_lock);+ atomic\_set(&sw\_ctx\_tx->encrypt\_pending, 1); INIT\_LIST\_HEAD(&sw\_ctx\_tx->tx\_list); INIT\_DELAYED\_WORK(&sw\_ctx\_tx->tx\_work.work, tx\_work\_handler); sw\_ctx\_tx->tx\_work.sk = sk;@@ -2622,7 +2599,7 @@ static struct tls\_sw\_context\_rx \*init\_ctx\_rx(struct tls\_context \*ctx) }  crypto\_init\_wait(&sw\_ctx\_rx->async\_wait);- spin\_lock\_init(&sw\_ctx\_rx->decrypt\_compl\_lock);+ atomic\_set(&sw\_ctx\_rx->decrypt\_pending, 1); init\_waitqueue\_head(&sw\_ctx\_rx->wq); skb\_queue\_head\_init(&sw\_ctx\_rx->rx\_list); skb\_queue\_head\_init(&sw\_ctx\_rx->async\_hold); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 19:29:42 +0000



=== Content from git.kernel.org_1d8d16e6_20250111_193105.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=7a3ca06d04d589deec81f56229a9a9d62352ce01)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=7a3ca06d04d589deec81f56229a9a9d62352ce01)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7a3ca06d04d589deec81f56229a9a9d62352ce01)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7a3ca06d04d589deec81f56229a9a9d62352ce01)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jakub Kicinski <kuba@kernel.org> | 2024-02-06 17:18:19 -0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-02-23 09:12:31 +0100 |
| commit | [7a3ca06d04d589deec81f56229a9a9d62352ce01](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7a3ca06d04d589deec81f56229a9a9d62352ce01) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=7a3ca06d04d589deec81f56229a9a9d62352ce01)) | |
| tree | [d280be4397ab99308a859763a5b57bde213c6eaf](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=7a3ca06d04d589deec81f56229a9a9d62352ce01) | |
| parent | [2c6841c88201e13967583f0f8a9f9b54b9cde404](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=2c6841c88201e13967583f0f8a9f9b54b9cde404) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7a3ca06d04d589deec81f56229a9a9d62352ce01&id2=2c6841c88201e13967583f0f8a9f9b54b9cde404)) | |
| download | [linux-7a3ca06d04d589deec81f56229a9a9d62352ce01.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-7a3ca06d04d589deec81f56229a9a9d62352ce01.tar.gz) | |

tls: fix race between async notify and socket close[ Upstream commit aec7961916f3f9e88766e2688992da6980f11b8d ]
The submitting thread (one which called recvmsg/sendmsg)
may exit as soon as the async crypto handler calls complete()
so any code past that point risks touching already freed data.
Try to avoid the locking and extra flags altogether.
Have the main thread hold an extra reference, this way
we can depend solely on the atomic ref counter for
synchronization.
Don't futz with reiniting the completion, either, we are now
tightly controlling when completion fires.
Reported-by: valis <sec@valis.email>
Fixes: 0cada33241d9 ("net/tls: fix race condition causing kernel panic")
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Reviewed-by: Simon Horman <horms@kernel.org>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Reviewed-by: Sabrina Dubroca <sd@queasysnail.net>
Signed-off-by: David S. Miller <davem@davemloft.net>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7a3ca06d04d589deec81f56229a9a9d62352ce01)

| -rw-r--r-- | [include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/tls.h?id=7a3ca06d04d589deec81f56229a9a9d62352ce01) | 5 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/tls/tls\_sw.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/tls/tls_sw.c?id=7a3ca06d04d589deec81f56229a9a9d62352ce01) | 43 | |  |  |  | | --- | --- | --- | |

2 files changed, 10 insertions, 38 deletions

| diff --git a/include/net/tls.h b/include/net/tls.hindex c36bf4c50027e5..899c863aba02ce 100644--- a/[include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/tls.h?id=2c6841c88201e13967583f0f8a9f9b54b9cde404)+++ b/[include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/tls.h?id=7a3ca06d04d589deec81f56229a9a9d62352ce01)@@ -108,9 +108,6 @@ struct tls\_sw\_context\_tx { struct tls\_rec \*open\_rec; struct list\_head tx\_list; atomic\_t encrypt\_pending;- /\* protect crypto\_wait with encrypt\_pending \*/- spinlock\_t encrypt\_compl\_lock;- int async\_notify; u8 async\_capable:1;  #define BIT\_TX\_SCHEDULED 0@@ -147,8 +144,6 @@ struct tls\_sw\_context\_rx { struct tls\_strparser strp;  atomic\_t decrypt\_pending;- /\* protect crypto\_wait with decrypt\_pending\*/- spinlock\_t decrypt\_compl\_lock; struct sk\_buff\_head async\_hold; struct wait\_queue\_head wq; };diff --git a/net/tls/tls\_sw.c b/net/tls/tls\_sw.cindex b146be099a3fc5..ee11932237c079 100644--- a/[net/tls/tls\_sw.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_sw.c?id=2c6841c88201e13967583f0f8a9f9b54b9cde404)+++ b/[net/tls/tls\_sw.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_sw.c?id=7a3ca06d04d589deec81f56229a9a9d62352ce01)@@ -223,22 +223,15 @@ static void tls\_decrypt\_done(crypto\_completion\_data\_t \*data, int err)  kfree(aead\_req); - spin\_lock\_bh(&ctx->decrypt\_compl\_lock);- if (!atomic\_dec\_return(&ctx->decrypt\_pending))+ if (atomic\_dec\_and\_test(&ctx->decrypt\_pending)) complete(&ctx->async\_wait.completion);- spin\_unlock\_bh(&ctx->decrypt\_compl\_lock); }  static int tls\_decrypt\_async\_wait(struct tls\_sw\_context\_rx \*ctx) {- int pending;-- spin\_lock\_bh(&ctx->decrypt\_compl\_lock);- reinit\_completion(&ctx->async\_wait.completion);- pending = atomic\_read(&ctx->decrypt\_pending);- spin\_unlock\_bh(&ctx->decrypt\_compl\_lock);- if (pending)+ if (!atomic\_dec\_and\_test(&ctx->decrypt\_pending)) crypto\_wait\_req(-EINPROGRESS, &ctx->async\_wait);+ atomic\_inc(&ctx->decrypt\_pending);  return ctx->async\_wait.err; }@@ -266,6 +259,7 @@ static int tls\_do\_decryption(struct sock \*sk, aead\_request\_set\_callback(aead\_req, CRYPTO\_TFM\_REQ\_MAY\_BACKLOG, tls\_decrypt\_done, aead\_req);+ DEBUG\_NET\_WARN\_ON\_ONCE(atomic\_read(&ctx->decrypt\_pending) < 1); atomic\_inc(&ctx->decrypt\_pending); } else { aead\_request\_set\_callback(aead\_req,@@ -455,7 +449,6 @@ static void tls\_encrypt\_done(crypto\_completion\_data\_t \*data, int err) struct tls\_rec \*rec; bool ready = false; struct sock \*sk;- int pending;  rec = container\_of(aead\_req, struct tls\_rec, aead\_req); msg\_en = &rec->msg\_encrypted;@@ -495,12 +488,8 @@ static void tls\_encrypt\_done(crypto\_completion\_data\_t \*data, int err) ready = true; } - spin\_lock\_bh(&ctx->encrypt\_compl\_lock);- pending = atomic\_dec\_return(&ctx->encrypt\_pending);-- if (!pending && ctx->async\_notify)+ if (atomic\_dec\_and\_test(&ctx->encrypt\_pending)) complete(&ctx->async\_wait.completion);- spin\_unlock\_bh(&ctx->encrypt\_compl\_lock);  if (!ready) return;@@ -512,22 +501,9 @@ static void tls\_encrypt\_done(crypto\_completion\_data\_t \*data, int err)  static int tls\_encrypt\_async\_wait(struct tls\_sw\_context\_tx \*ctx) {- int pending;-- spin\_lock\_bh(&ctx->encrypt\_compl\_lock);- ctx->async\_notify = true;-- pending = atomic\_read(&ctx->encrypt\_pending);- spin\_unlock\_bh(&ctx->encrypt\_compl\_lock);- if (pending)+ if (!atomic\_dec\_and\_test(&ctx->encrypt\_pending)) crypto\_wait\_req(-EINPROGRESS, &ctx->async\_wait);- else- reinit\_completion(&ctx->async\_wait.completion);-- /\* There can be no concurrent accesses, since we have no- \* pending encrypt operations- \*/- WRITE\_ONCE(ctx->async\_notify, false);+ atomic\_inc(&ctx->encrypt\_pending);  return ctx->async\_wait.err; }@@ -578,6 +554,7 @@ static int tls\_do\_encryption(struct sock \*sk,  /\* Add the record in tx\_list \*/ list\_add\_tail((struct list\_head \*)&rec->list, &ctx->tx\_list);+ DEBUG\_NET\_WARN\_ON\_ONCE(atomic\_read(&ctx->encrypt\_pending) < 1); atomic\_inc(&ctx->encrypt\_pending);  rc = crypto\_aead\_encrypt(aead\_req);@@ -2594,7 +2571,7 @@ static struct tls\_sw\_context\_tx \*init\_ctx\_tx(struct tls\_context \*ctx, struct soc }  crypto\_init\_wait(&sw\_ctx\_tx->async\_wait);- spin\_lock\_init(&sw\_ctx\_tx->encrypt\_compl\_lock);+ atomic\_set(&sw\_ctx\_tx->encrypt\_pending, 1); INIT\_LIST\_HEAD(&sw\_ctx\_tx->tx\_list); INIT\_DELAYED\_WORK(&sw\_ctx\_tx->tx\_work.work, tx\_work\_handler); sw\_ctx\_tx->tx\_work.sk = sk;@@ -2615,7 +2592,7 @@ static struct tls\_sw\_context\_rx \*init\_ctx\_rx(struct tls\_context \*ctx) }  crypto\_init\_wait(&sw\_ctx\_rx->async\_wait);- spin\_lock\_init(&sw\_ctx\_rx->decrypt\_compl\_lock);+ atomic\_set(&sw\_ctx\_rx->decrypt\_pending, 1); init\_waitqueue\_head(&sw\_ctx\_rx->wq); skb\_queue\_head\_init(&sw\_ctx\_rx->rx\_list); skb\_queue\_head\_init(&sw\_ctx\_rx->async\_hold); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 19:29:42 +0000



=== Content from git.kernel.org_4c02f26c_20250111_193106.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jakub Kicinski <kuba@kernel.org> | 2024-02-06 17:18:19 -0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-05-25 16:20:17 +0200 |
| commit | [f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7)) | |
| tree | [da717d74398ebc8b603c0f2bfcb2995411b69bf4](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7) | |
| parent | [94afddde1e9285c0aa25a8bb1f4734071e56055b](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=94afddde1e9285c0aa25a8bb1f4734071e56055b) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7&id2=94afddde1e9285c0aa25a8bb1f4734071e56055b)) | |
| download | [linux-f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7.tar.gz) | |

tls: fix race between async notify and socket closecommit aec7961916f3f9e88766e2688992da6980f11b8d upstream.
The submitting thread (one which called recvmsg/sendmsg)
may exit as soon as the async crypto handler calls complete()
so any code past that point risks touching already freed data.
Try to avoid the locking and extra flags altogether.
Have the main thread hold an extra reference, this way
we can depend solely on the atomic ref counter for
synchronization.
Don't futz with reiniting the completion, either, we are now
tightly controlling when completion fires.
Reported-by: valis <sec@valis.email>
Fixes: 0cada33241d9 ("net/tls: fix race condition causing kernel panic")
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Reviewed-by: Simon Horman <horms@kernel.org>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Reviewed-by: Sabrina Dubroca <sd@queasysnail.net>
Signed-off-by: David S. Miller <davem@davemloft.net>
[v5.15: fixed contextual conflicts in struct tls\_sw\_context\_rx and func
init\_ctx\_rx; replaced DEBUG\_NET\_WARN\_ON\_ONCE with BUILD\_BUG\_ON\_INVALID
since they're equivalent when DEBUG\_NET is not defined]
Cc: <stable@vger.kernel.org> # 5.15
Signed-off-by: Shaoying Xu <shaoyi@amazon.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7)

| -rw-r--r-- | [include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/tls.h?id=f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7) | 5 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/tls/tls\_sw.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/tls/tls_sw.c?id=f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7) | 43 | |  |  |  | | --- | --- | --- | |

2 files changed, 10 insertions, 38 deletions

| diff --git a/include/net/tls.h b/include/net/tls.hindex dcd6aa08c06788..59ff5c901ab569 100644--- a/[include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/tls.h?id=94afddde1e9285c0aa25a8bb1f4734071e56055b)+++ b/[include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/tls.h?id=f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7)@@ -128,9 +128,6 @@ struct tls\_sw\_context\_tx { struct tls\_rec \*open\_rec; struct list\_head tx\_list; atomic\_t encrypt\_pending;- /\* protect crypto\_wait with encrypt\_pending \*/- spinlock\_t encrypt\_compl\_lock;- int async\_notify; u8 async\_capable:1;  #define BIT\_TX\_SCHEDULED 0@@ -148,8 +145,6 @@ struct tls\_sw\_context\_rx { struct sk\_buff \*recv\_pkt; u8 async\_capable:1; atomic\_t decrypt\_pending;- /\* protect crypto\_wait with decrypt\_pending\*/- spinlock\_t decrypt\_compl\_lock; };  struct tls\_record\_info {diff --git a/net/tls/tls\_sw.c b/net/tls/tls\_sw.cindex 614cb30dae134c..40b96780e13d2a 100644--- a/[net/tls/tls\_sw.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_sw.c?id=94afddde1e9285c0aa25a8bb1f4734071e56055b)+++ b/[net/tls/tls\_sw.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_sw.c?id=f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7)@@ -220,22 +220,15 @@ static void tls\_decrypt\_done(struct crypto\_async\_request \*req, int err)  kfree(aead\_req); - spin\_lock\_bh(&ctx->decrypt\_compl\_lock);- if (!atomic\_dec\_return(&ctx->decrypt\_pending))+ if (atomic\_dec\_and\_test(&ctx->decrypt\_pending)) complete(&ctx->async\_wait.completion);- spin\_unlock\_bh(&ctx->decrypt\_compl\_lock); }  static int tls\_decrypt\_async\_wait(struct tls\_sw\_context\_rx \*ctx) {- int pending;-- spin\_lock\_bh(&ctx->decrypt\_compl\_lock);- reinit\_completion(&ctx->async\_wait.completion);- pending = atomic\_read(&ctx->decrypt\_pending);- spin\_unlock\_bh(&ctx->decrypt\_compl\_lock);- if (pending)+ if (!atomic\_dec\_and\_test(&ctx->decrypt\_pending)) crypto\_wait\_req(-EINPROGRESS, &ctx->async\_wait);+ atomic\_inc(&ctx->decrypt\_pending);  return ctx->async\_wait.err; }@@ -271,6 +264,7 @@ static int tls\_do\_decryption(struct sock \*sk, aead\_request\_set\_callback(aead\_req, CRYPTO\_TFM\_REQ\_MAY\_BACKLOG, tls\_decrypt\_done, skb);+ BUILD\_BUG\_ON\_INVALID(atomic\_read(&ctx->decrypt\_pending) < 1); atomic\_inc(&ctx->decrypt\_pending); } else { aead\_request\_set\_callback(aead\_req,@@ -460,7 +454,6 @@ static void tls\_encrypt\_done(struct crypto\_async\_request \*req, int err) struct sk\_msg \*msg\_en; struct tls\_rec \*rec; bool ready = false;- int pending;  rec = container\_of(aead\_req, struct tls\_rec, aead\_req); msg\_en = &rec->msg\_encrypted;@@ -495,12 +488,8 @@ static void tls\_encrypt\_done(struct crypto\_async\_request \*req, int err) ready = true; } - spin\_lock\_bh(&ctx->encrypt\_compl\_lock);- pending = atomic\_dec\_return(&ctx->encrypt\_pending);-- if (!pending && ctx->async\_notify)+ if (atomic\_dec\_and\_test(&ctx->encrypt\_pending)) complete(&ctx->async\_wait.completion);- spin\_unlock\_bh(&ctx->encrypt\_compl\_lock);  if (!ready) return;@@ -512,22 +501,9 @@ static void tls\_encrypt\_done(struct crypto\_async\_request \*req, int err)  static int tls\_encrypt\_async\_wait(struct tls\_sw\_context\_tx \*ctx) {- int pending;-- spin\_lock\_bh(&ctx->encrypt\_compl\_lock);- ctx->async\_notify = true;-- pending = atomic\_read(&ctx->encrypt\_pending);- spin\_unlock\_bh(&ctx->encrypt\_compl\_lock);- if (pending)+ if (!atomic\_dec\_and\_test(&ctx->encrypt\_pending)) crypto\_wait\_req(-EINPROGRESS, &ctx->async\_wait);- else- reinit\_completion(&ctx->async\_wait.completion);-- /\* There can be no concurrent accesses, since we have no- \* pending encrypt operations- \*/- WRITE\_ONCE(ctx->async\_notify, false);+ atomic\_inc(&ctx->encrypt\_pending);  return ctx->async\_wait.err; }@@ -571,6 +547,7 @@ static int tls\_do\_encryption(struct sock \*sk,  /\* Add the record in tx\_list \*/ list\_add\_tail((struct list\_head \*)&rec->list, &ctx->tx\_list);+ BUILD\_BUG\_ON\_INVALID(atomic\_read(&ctx->encrypt\_pending) < 1); atomic\_inc(&ctx->encrypt\_pending);  rc = crypto\_aead\_encrypt(aead\_req);@@ -2312,7 +2289,7 @@ static struct tls\_sw\_context\_tx \*init\_ctx\_tx(struct tls\_context \*ctx, struct soc }  crypto\_init\_wait(&sw\_ctx\_tx->async\_wait);- spin\_lock\_init(&sw\_ctx\_tx->encrypt\_compl\_lock);+ atomic\_set(&sw\_ctx\_tx->encrypt\_pending, 1); INIT\_LIST\_HEAD(&sw\_ctx\_tx->tx\_list); INIT\_DELAYED\_WORK(&sw\_ctx\_tx->tx\_work.work, tx\_work\_handler); sw\_ctx\_tx->tx\_work.sk = sk;@@ -2333,7 +2310,7 @@ static struct tls\_sw\_context\_rx \*init\_ctx\_rx(struct tls\_context \*ctx) }  crypto\_init\_wait(&sw\_ctx\_rx->async\_wait);- spin\_lock\_init(&sw\_ctx\_rx->decrypt\_compl\_lock);+ atomic\_set(&sw\_ctx\_rx->decrypt\_pending, 1); skb\_queue\_head\_init(&sw\_ctx\_rx->rx\_list);  return sw\_ctx\_rx; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 19:29:44 +0000



=== Content from git.kernel.org_3d2f9214_20250111_193106.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=aec7961916f3f9e88766e2688992da6980f11b8d)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=aec7961916f3f9e88766e2688992da6980f11b8d)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=aec7961916f3f9e88766e2688992da6980f11b8d)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=aec7961916f3f9e88766e2688992da6980f11b8d)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jakub Kicinski <kuba@kernel.org> | 2024-02-06 17:18:19 -0800 |
| --- | --- | --- |
| committer | David S. Miller <davem@davemloft.net> | 2024-02-10 21:38:19 +0000 |
| commit | [aec7961916f3f9e88766e2688992da6980f11b8d](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=aec7961916f3f9e88766e2688992da6980f11b8d) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=aec7961916f3f9e88766e2688992da6980f11b8d)) | |
| tree | [242e2246f9fb2c26a93dcde3bd597bd5f8100fad](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=aec7961916f3f9e88766e2688992da6980f11b8d) | |
| parent | [c57ca512f3b68ddcd62bda9cc24a8f5584ab01b1](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=c57ca512f3b68ddcd62bda9cc24a8f5584ab01b1) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=aec7961916f3f9e88766e2688992da6980f11b8d&id2=c57ca512f3b68ddcd62bda9cc24a8f5584ab01b1)) | |
| download | [linux-aec7961916f3f9e88766e2688992da6980f11b8d.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-aec7961916f3f9e88766e2688992da6980f11b8d.tar.gz) | |

tls: fix race between async notify and socket closeThe submitting thread (one which called recvmsg/sendmsg)
may exit as soon as the async crypto handler calls complete()
so any code past that point risks touching already freed data.
Try to avoid the locking and extra flags altogether.
Have the main thread hold an extra reference, this way
we can depend solely on the atomic ref counter for
synchronization.
Don't futz with reiniting the completion, either, we are now
tightly controlling when completion fires.
Reported-by: valis <sec@valis.email>
Fixes: 0cada33241d9 ("net/tls: fix race condition causing kernel panic")
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Reviewed-by: Simon Horman <horms@kernel.org>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Reviewed-by: Sabrina Dubroca <sd@queasysnail.net>
Signed-off-by: David S. Miller <davem@davemloft.net>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=aec7961916f3f9e88766e2688992da6980f11b8d)

| -rw-r--r-- | [include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/tls.h?id=aec7961916f3f9e88766e2688992da6980f11b8d) | 5 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/tls/tls\_sw.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/tls/tls_sw.c?id=aec7961916f3f9e88766e2688992da6980f11b8d) | 43 | |  |  |  | | --- | --- | --- | |

2 files changed, 10 insertions, 38 deletions

| diff --git a/include/net/tls.h b/include/net/tls.hindex 962f0c501111ba..340ad43971e471 100644--- a/[include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/tls.h?id=c57ca512f3b68ddcd62bda9cc24a8f5584ab01b1)+++ b/[include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/tls.h?id=aec7961916f3f9e88766e2688992da6980f11b8d)@@ -97,9 +97,6 @@ struct tls\_sw\_context\_tx { struct tls\_rec \*open\_rec; struct list\_head tx\_list; atomic\_t encrypt\_pending;- /\* protect crypto\_wait with encrypt\_pending \*/- spinlock\_t encrypt\_compl\_lock;- int async\_notify; u8 async\_capable:1;  #define BIT\_TX\_SCHEDULED 0@@ -136,8 +133,6 @@ struct tls\_sw\_context\_rx { struct tls\_strparser strp;  atomic\_t decrypt\_pending;- /\* protect crypto\_wait with decrypt\_pending\*/- spinlock\_t decrypt\_compl\_lock; struct sk\_buff\_head async\_hold; struct wait\_queue\_head wq; };diff --git a/net/tls/tls\_sw.c b/net/tls/tls\_sw.cindex 6a73714f34cc4a..635305bebfef6d 100644--- a/[net/tls/tls\_sw.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_sw.c?id=c57ca512f3b68ddcd62bda9cc24a8f5584ab01b1)+++ b/[net/tls/tls\_sw.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_sw.c?id=aec7961916f3f9e88766e2688992da6980f11b8d)@@ -224,22 +224,15 @@ static void tls\_decrypt\_done(void \*data, int err)  kfree(aead\_req); - spin\_lock\_bh(&ctx->decrypt\_compl\_lock);- if (!atomic\_dec\_return(&ctx->decrypt\_pending))+ if (atomic\_dec\_and\_test(&ctx->decrypt\_pending)) complete(&ctx->async\_wait.completion);- spin\_unlock\_bh(&ctx->decrypt\_compl\_lock); }  static int tls\_decrypt\_async\_wait(struct tls\_sw\_context\_rx \*ctx) {- int pending;-- spin\_lock\_bh(&ctx->decrypt\_compl\_lock);- reinit\_completion(&ctx->async\_wait.completion);- pending = atomic\_read(&ctx->decrypt\_pending);- spin\_unlock\_bh(&ctx->decrypt\_compl\_lock);- if (pending)+ if (!atomic\_dec\_and\_test(&ctx->decrypt\_pending)) crypto\_wait\_req(-EINPROGRESS, &ctx->async\_wait);+ atomic\_inc(&ctx->decrypt\_pending);  return ctx->async\_wait.err; }@@ -267,6 +260,7 @@ static int tls\_do\_decryption(struct sock \*sk, aead\_request\_set\_callback(aead\_req, CRYPTO\_TFM\_REQ\_MAY\_BACKLOG, tls\_decrypt\_done, aead\_req);+ DEBUG\_NET\_WARN\_ON\_ONCE(atomic\_read(&ctx->decrypt\_pending) < 1); atomic\_inc(&ctx->decrypt\_pending); } else { aead\_request\_set\_callback(aead\_req,@@ -455,7 +449,6 @@ static void tls\_encrypt\_done(void \*data, int err) struct sk\_msg \*msg\_en; bool ready = false; struct sock \*sk;- int pending;  msg\_en = &rec->msg\_encrypted; @@ -494,12 +487,8 @@ static void tls\_encrypt\_done(void \*data, int err) ready = true; } - spin\_lock\_bh(&ctx->encrypt\_compl\_lock);- pending = atomic\_dec\_return(&ctx->encrypt\_pending);-- if (!pending && ctx->async\_notify)+ if (atomic\_dec\_and\_test(&ctx->encrypt\_pending)) complete(&ctx->async\_wait.completion);- spin\_unlock\_bh(&ctx->encrypt\_compl\_lock);  if (!ready) return;@@ -511,22 +500,9 @@ static void tls\_encrypt\_done(void \*data, int err)  static int tls\_encrypt\_async\_wait(struct tls\_sw\_context\_tx \*ctx) {- int pending;-- spin\_lock\_bh(&ctx->encrypt\_compl\_lock);- ctx->async\_notify = true;-- pending = atomic\_read(&ctx->encrypt\_pending);- spin\_unlock\_bh(&ctx->encrypt\_compl\_lock);- if (pending)+ if (!atomic\_dec\_and\_test(&ctx->encrypt\_pending)) crypto\_wait\_req(-EINPROGRESS, &ctx->async\_wait);- else- reinit\_completion(&ctx->async\_wait.completion);-- /\* There can be no concurrent accesses, since we have no- \* pending encrypt operations- \*/- WRITE\_ONCE(ctx->async\_notify, false);+ atomic\_inc(&ctx->encrypt\_pending);  return ctx->async\_wait.err; }@@ -577,6 +553,7 @@ static int tls\_do\_encryption(struct sock \*sk,  /\* Add the record in tx\_list \*/ list\_add\_tail((struct list\_head \*)&rec->list, &ctx->tx\_list);+ DEBUG\_NET\_WARN\_ON\_ONCE(atomic\_read(&ctx->encrypt\_pending) < 1); atomic\_inc(&ctx->encrypt\_pending);  rc = crypto\_aead\_encrypt(aead\_req);@@ -2601,7 +2578,7 @@ static struct tls\_sw\_context\_tx \*init\_ctx\_tx(struct tls\_context \*ctx, struct soc }  crypto\_init\_wait(&sw\_ctx\_tx->async\_wait);- spin\_lock\_init(&sw\_ctx\_tx->encrypt\_compl\_lock);+ atomic\_set(&sw\_ctx\_tx->encrypt\_pending, 1); INIT\_LIST\_HEAD(&sw\_ctx\_tx->tx\_list); INIT\_DELAYED\_WORK(&sw\_ctx\_tx->tx\_work.work, tx\_work\_handler); sw\_ctx\_tx->tx\_work.sk = sk;@@ -2622,7 +2599,7 @@ static struct tls\_sw\_context\_rx \*init\_ctx\_rx(struct tls\_context \*ctx) }  crypto\_init\_wait(&sw\_ctx\_rx->async\_wait);- spin\_lock\_init(&sw\_ctx\_rx->decrypt\_compl\_lock);+ atomic\_set(&sw\_ctx\_rx->decrypt\_pending, 1); init\_waitqueue\_head(&sw\_ctx\_rx->wq); skb\_queue\_head\_init(&sw\_ctx\_rx->rx\_list); skb\_queue\_head\_init(&sw\_ctx\_rx->async\_hold); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 19:29:43 +0000



=== Content from git.kernel.org_fd7ac91e_20250111_193105.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=86dc27ee36f558fe223dbdfbfcb6856247356f4a)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=86dc27ee36f558fe223dbdfbfcb6856247356f4a)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=86dc27ee36f558fe223dbdfbfcb6856247356f4a)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=86dc27ee36f558fe223dbdfbfcb6856247356f4a)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jakub Kicinski <kuba@kernel.org> | 2024-02-06 17:18:19 -0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-02-23 09:24:52 +0100 |
| commit | [86dc27ee36f558fe223dbdfbfcb6856247356f4a](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=86dc27ee36f558fe223dbdfbfcb6856247356f4a) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=86dc27ee36f558fe223dbdfbfcb6856247356f4a)) | |
| tree | [ab22ed67445a9e0a6fc2272735c3c44f177398f2](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=86dc27ee36f558fe223dbdfbfcb6856247356f4a) | |
| parent | [de31df6f87207dc2a5c02185a435471b35b8a49c](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=de31df6f87207dc2a5c02185a435471b35b8a49c) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=86dc27ee36f558fe223dbdfbfcb6856247356f4a&id2=de31df6f87207dc2a5c02185a435471b35b8a49c)) | |
| download | [linux-86dc27ee36f558fe223dbdfbfcb6856247356f4a.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-86dc27ee36f558fe223dbdfbfcb6856247356f4a.tar.gz) | |

tls: fix race between async notify and socket close[ Upstream commit aec7961916f3f9e88766e2688992da6980f11b8d ]
The submitting thread (one which called recvmsg/sendmsg)
may exit as soon as the async crypto handler calls complete()
so any code past that point risks touching already freed data.
Try to avoid the locking and extra flags altogether.
Have the main thread hold an extra reference, this way
we can depend solely on the atomic ref counter for
synchronization.
Don't futz with reiniting the completion, either, we are now
tightly controlling when completion fires.
Reported-by: valis <sec@valis.email>
Fixes: 0cada33241d9 ("net/tls: fix race condition causing kernel panic")
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Reviewed-by: Simon Horman <horms@kernel.org>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Reviewed-by: Sabrina Dubroca <sd@queasysnail.net>
Signed-off-by: David S. Miller <davem@davemloft.net>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=86dc27ee36f558fe223dbdfbfcb6856247356f4a)

| -rw-r--r-- | [include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/tls.h?id=86dc27ee36f558fe223dbdfbfcb6856247356f4a) | 5 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/tls/tls\_sw.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/tls/tls_sw.c?id=86dc27ee36f558fe223dbdfbfcb6856247356f4a) | 43 | |  |  |  | | --- | --- | --- | |

2 files changed, 10 insertions, 38 deletions

| diff --git a/include/net/tls.h b/include/net/tls.hindex a2b44578dcb753..5fdd5dd251df27 100644--- a/[include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/tls.h?id=de31df6f87207dc2a5c02185a435471b35b8a49c)+++ b/[include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/tls.h?id=86dc27ee36f558fe223dbdfbfcb6856247356f4a)@@ -96,9 +96,6 @@ struct tls\_sw\_context\_tx { struct tls\_rec \*open\_rec; struct list\_head tx\_list; atomic\_t encrypt\_pending;- /\* protect crypto\_wait with encrypt\_pending \*/- spinlock\_t encrypt\_compl\_lock;- int async\_notify; u8 async\_capable:1;  #define BIT\_TX\_SCHEDULED 0@@ -135,8 +132,6 @@ struct tls\_sw\_context\_rx { struct tls\_strparser strp;  atomic\_t decrypt\_pending;- /\* protect crypto\_wait with decrypt\_pending\*/- spinlock\_t decrypt\_compl\_lock; struct sk\_buff\_head async\_hold; struct wait\_queue\_head wq; };diff --git a/net/tls/tls\_sw.c b/net/tls/tls\_sw.cindex 12c3635c2b3e5e..650080d5fd7276 100644--- a/[net/tls/tls\_sw.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_sw.c?id=de31df6f87207dc2a5c02185a435471b35b8a49c)+++ b/[net/tls/tls\_sw.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_sw.c?id=86dc27ee36f558fe223dbdfbfcb6856247356f4a)@@ -224,22 +224,15 @@ static void tls\_decrypt\_done(void \*data, int err)  kfree(aead\_req); - spin\_lock\_bh(&ctx->decrypt\_compl\_lock);- if (!atomic\_dec\_return(&ctx->decrypt\_pending))+ if (atomic\_dec\_and\_test(&ctx->decrypt\_pending)) complete(&ctx->async\_wait.completion);- spin\_unlock\_bh(&ctx->decrypt\_compl\_lock); }  static int tls\_decrypt\_async\_wait(struct tls\_sw\_context\_rx \*ctx) {- int pending;-- spin\_lock\_bh(&ctx->decrypt\_compl\_lock);- reinit\_completion(&ctx->async\_wait.completion);- pending = atomic\_read(&ctx->decrypt\_pending);- spin\_unlock\_bh(&ctx->decrypt\_compl\_lock);- if (pending)+ if (!atomic\_dec\_and\_test(&ctx->decrypt\_pending)) crypto\_wait\_req(-EINPROGRESS, &ctx->async\_wait);+ atomic\_inc(&ctx->decrypt\_pending);  return ctx->async\_wait.err; }@@ -267,6 +260,7 @@ static int tls\_do\_decryption(struct sock \*sk, aead\_request\_set\_callback(aead\_req, CRYPTO\_TFM\_REQ\_MAY\_BACKLOG, tls\_decrypt\_done, aead\_req);+ DEBUG\_NET\_WARN\_ON\_ONCE(atomic\_read(&ctx->decrypt\_pending) < 1); atomic\_inc(&ctx->decrypt\_pending); } else { aead\_request\_set\_callback(aead\_req,@@ -455,7 +449,6 @@ static void tls\_encrypt\_done(void \*data, int err) struct sk\_msg \*msg\_en; bool ready = false; struct sock \*sk;- int pending;  msg\_en = &rec->msg\_encrypted; @@ -494,12 +487,8 @@ static void tls\_encrypt\_done(void \*data, int err) ready = true; } - spin\_lock\_bh(&ctx->encrypt\_compl\_lock);- pending = atomic\_dec\_return(&ctx->encrypt\_pending);-- if (!pending && ctx->async\_notify)+ if (atomic\_dec\_and\_test(&ctx->encrypt\_pending)) complete(&ctx->async\_wait.completion);- spin\_unlock\_bh(&ctx->encrypt\_compl\_lock);  if (!ready) return;@@ -511,22 +500,9 @@ static void tls\_encrypt\_done(void \*data, int err)  static int tls\_encrypt\_async\_wait(struct tls\_sw\_context\_tx \*ctx) {- int pending;-- spin\_lock\_bh(&ctx->encrypt\_compl\_lock);- ctx->async\_notify = true;-- pending = atomic\_read(&ctx->encrypt\_pending);- spin\_unlock\_bh(&ctx->encrypt\_compl\_lock);- if (pending)+ if (!atomic\_dec\_and\_test(&ctx->encrypt\_pending)) crypto\_wait\_req(-EINPROGRESS, &ctx->async\_wait);- else- reinit\_completion(&ctx->async\_wait.completion);-- /\* There can be no concurrent accesses, since we have no- \* pending encrypt operations- \*/- WRITE\_ONCE(ctx->async\_notify, false);+ atomic\_inc(&ctx->encrypt\_pending);  return ctx->async\_wait.err; }@@ -577,6 +553,7 @@ static int tls\_do\_encryption(struct sock \*sk,  /\* Add the record in tx\_list \*/ list\_add\_tail((struct list\_head \*)&rec->list, &ctx->tx\_list);+ DEBUG\_NET\_WARN\_ON\_ONCE(atomic\_read(&ctx->encrypt\_pending) < 1); atomic\_inc(&ctx->encrypt\_pending);  rc = crypto\_aead\_encrypt(aead\_req);@@ -2604,7 +2581,7 @@ static struct tls\_sw\_context\_tx \*init\_ctx\_tx(struct tls\_context \*ctx, struct soc }  crypto\_init\_wait(&sw\_ctx\_tx->async\_wait);- spin\_lock\_init(&sw\_ctx\_tx->encrypt\_compl\_lock);+ atomic\_set(&sw\_ctx\_tx->encrypt\_pending, 1); INIT\_LIST\_HEAD(&sw\_ctx\_tx->tx\_list); INIT\_DELAYED\_WORK(&sw\_ctx\_tx->tx\_work.work, tx\_work\_handler); sw\_ctx\_tx->tx\_work.sk = sk;@@ -2625,7 +2602,7 @@ static struct tls\_sw\_context\_rx \*init\_ctx\_rx(struct tls\_context \*ctx) }  crypto\_init\_wait(&sw\_ctx\_rx->async\_wait);- spin\_lock\_init(&sw\_ctx\_rx->decrypt\_compl\_lock);+ atomic\_set(&sw\_ctx\_rx->decrypt\_pending, 1); init\_waitqueue\_head(&sw\_ctx\_rx->wq); skb\_queue\_head\_init(&sw\_ctx\_rx->rx\_list); skb\_queue\_head\_init(&sw\_ctx\_rx->async\_hold); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 19:29:43 +0000


