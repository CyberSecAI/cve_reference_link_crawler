

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=7a3ca06d04d589deec81f56229a9a9d62352ce01)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=7a3ca06d04d589deec81f56229a9a9d62352ce01)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7a3ca06d04d589deec81f56229a9a9d62352ce01)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7a3ca06d04d589deec81f56229a9a9d62352ce01)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jakub Kicinski <kuba@kernel.org> | 2024-02-06 17:18:19 -0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-02-23 09:12:31 +0100 |
| commit | [7a3ca06d04d589deec81f56229a9a9d62352ce01](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7a3ca06d04d589deec81f56229a9a9d62352ce01) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=7a3ca06d04d589deec81f56229a9a9d62352ce01)) | |
| tree | [d280be4397ab99308a859763a5b57bde213c6eaf](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=7a3ca06d04d589deec81f56229a9a9d62352ce01) | |
| parent | [2c6841c88201e13967583f0f8a9f9b54b9cde404](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=2c6841c88201e13967583f0f8a9f9b54b9cde404) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7a3ca06d04d589deec81f56229a9a9d62352ce01&id2=2c6841c88201e13967583f0f8a9f9b54b9cde404)) | |
| download | [linux-7a3ca06d04d589deec81f56229a9a9d62352ce01.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-7a3ca06d04d589deec81f56229a9a9d62352ce01.tar.gz) | |

tls: fix race between async notify and socket close[ Upstream commit aec7961916f3f9e88766e2688992da6980f11b8d ]
The submitting thread (one which called recvmsg/sendmsg)
may exit as soon as the async crypto handler calls complete()
so any code past that point risks touching already freed data.
Try to avoid the locking and extra flags altogether.
Have the main thread hold an extra reference, this way
we can depend solely on the atomic ref counter for
synchronization.
Don't futz with reiniting the completion, either, we are now
tightly controlling when completion fires.
Reported-by: valis <sec@valis.email>
Fixes: 0cada33241d9 ("net/tls: fix race condition causing kernel panic")
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Reviewed-by: Simon Horman <horms@kernel.org>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Reviewed-by: Sabrina Dubroca <sd@queasysnail.net>
Signed-off-by: David S. Miller <davem@davemloft.net>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7a3ca06d04d589deec81f56229a9a9d62352ce01)

| -rw-r--r-- | [include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/tls.h?id=7a3ca06d04d589deec81f56229a9a9d62352ce01) | 5 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/tls/tls\_sw.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/tls/tls_sw.c?id=7a3ca06d04d589deec81f56229a9a9d62352ce01) | 43 | |  |  |  | | --- | --- | --- | |

2 files changed, 10 insertions, 38 deletions

| diff --git a/include/net/tls.h b/include/net/tls.hindex c36bf4c50027e5..899c863aba02ce 100644--- a/[include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/tls.h?id=2c6841c88201e13967583f0f8a9f9b54b9cde404)+++ b/[include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/tls.h?id=7a3ca06d04d589deec81f56229a9a9d62352ce01)@@ -108,9 +108,6 @@ struct tls\_sw\_context\_tx { struct tls\_rec \*open\_rec; struct list\_head tx\_list; atomic\_t encrypt\_pending;- /\* protect crypto\_wait with encrypt\_pending \*/- spinlock\_t encrypt\_compl\_lock;- int async\_notify; u8 async\_capable:1;  #define BIT\_TX\_SCHEDULED 0@@ -147,8 +144,6 @@ struct tls\_sw\_context\_rx { struct tls\_strparser strp;  atomic\_t decrypt\_pending;- /\* protect crypto\_wait with decrypt\_pending\*/- spinlock\_t decrypt\_compl\_lock; struct sk\_buff\_head async\_hold; struct wait\_queue\_head wq; };diff --git a/net/tls/tls\_sw.c b/net/tls/tls\_sw.cindex b146be099a3fc5..ee11932237c079 100644--- a/[net/tls/tls\_sw.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_sw.c?id=2c6841c88201e13967583f0f8a9f9b54b9cde404)+++ b/[net/tls/tls\_sw.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_sw.c?id=7a3ca06d04d589deec81f56229a9a9d62352ce01)@@ -223,22 +223,15 @@ static void tls\_decrypt\_done(crypto\_completion\_data\_t \*data, int err)  kfree(aead\_req); - spin\_lock\_bh(&ctx->decrypt\_compl\_lock);- if (!atomic\_dec\_return(&ctx->decrypt\_pending))+ if (atomic\_dec\_and\_test(&ctx->decrypt\_pending)) complete(&ctx->async\_wait.completion);- spin\_unlock\_bh(&ctx->decrypt\_compl\_lock); }  static int tls\_decrypt\_async\_wait(struct tls\_sw\_context\_rx \*ctx) {- int pending;-- spin\_lock\_bh(&ctx->decrypt\_compl\_lock);- reinit\_completion(&ctx->async\_wait.completion);- pending = atomic\_read(&ctx->decrypt\_pending);- spin\_unlock\_bh(&ctx->decrypt\_compl\_lock);- if (pending)+ if (!atomic\_dec\_and\_test(&ctx->decrypt\_pending)) crypto\_wait\_req(-EINPROGRESS, &ctx->async\_wait);+ atomic\_inc(&ctx->decrypt\_pending);  return ctx->async\_wait.err; }@@ -266,6 +259,7 @@ static int tls\_do\_decryption(struct sock \*sk, aead\_request\_set\_callback(aead\_req, CRYPTO\_TFM\_REQ\_MAY\_BACKLOG, tls\_decrypt\_done, aead\_req);+ DEBUG\_NET\_WARN\_ON\_ONCE(atomic\_read(&ctx->decrypt\_pending) < 1); atomic\_inc(&ctx->decrypt\_pending); } else { aead\_request\_set\_callback(aead\_req,@@ -455,7 +449,6 @@ static void tls\_encrypt\_done(crypto\_completion\_data\_t \*data, int err) struct tls\_rec \*rec; bool ready = false; struct sock \*sk;- int pending;  rec = container\_of(aead\_req, struct tls\_rec, aead\_req); msg\_en = &rec->msg\_encrypted;@@ -495,12 +488,8 @@ static void tls\_encrypt\_done(crypto\_completion\_data\_t \*data, int err) ready = true; } - spin\_lock\_bh(&ctx->encrypt\_compl\_lock);- pending = atomic\_dec\_return(&ctx->encrypt\_pending);-- if (!pending && ctx->async\_notify)+ if (atomic\_dec\_and\_test(&ctx->encrypt\_pending)) complete(&ctx->async\_wait.completion);- spin\_unlock\_bh(&ctx->encrypt\_compl\_lock);  if (!ready) return;@@ -512,22 +501,9 @@ static void tls\_encrypt\_done(crypto\_completion\_data\_t \*data, int err)  static int tls\_encrypt\_async\_wait(struct tls\_sw\_context\_tx \*ctx) {- int pending;-- spin\_lock\_bh(&ctx->encrypt\_compl\_lock);- ctx->async\_notify = true;-- pending = atomic\_read(&ctx->encrypt\_pending);- spin\_unlock\_bh(&ctx->encrypt\_compl\_lock);- if (pending)+ if (!atomic\_dec\_and\_test(&ctx->encrypt\_pending)) crypto\_wait\_req(-EINPROGRESS, &ctx->async\_wait);- else- reinit\_completion(&ctx->async\_wait.completion);-- /\* There can be no concurrent accesses, since we have no- \* pending encrypt operations- \*/- WRITE\_ONCE(ctx->async\_notify, false);+ atomic\_inc(&ctx->encrypt\_pending);  return ctx->async\_wait.err; }@@ -578,6 +554,7 @@ static int tls\_do\_encryption(struct sock \*sk,  /\* Add the record in tx\_list \*/ list\_add\_tail((struct list\_head \*)&rec->list, &ctx->tx\_list);+ DEBUG\_NET\_WARN\_ON\_ONCE(atomic\_read(&ctx->encrypt\_pending) < 1); atomic\_inc(&ctx->encrypt\_pending);  rc = crypto\_aead\_encrypt(aead\_req);@@ -2594,7 +2571,7 @@ static struct tls\_sw\_context\_tx \*init\_ctx\_tx(struct tls\_context \*ctx, struct soc }  crypto\_init\_wait(&sw\_ctx\_tx->async\_wait);- spin\_lock\_init(&sw\_ctx\_tx->encrypt\_compl\_lock);+ atomic\_set(&sw\_ctx\_tx->encrypt\_pending, 1); INIT\_LIST\_HEAD(&sw\_ctx\_tx->tx\_list); INIT\_DELAYED\_WORK(&sw\_ctx\_tx->tx\_work.work, tx\_work\_handler); sw\_ctx\_tx->tx\_work.sk = sk;@@ -2615,7 +2592,7 @@ static struct tls\_sw\_context\_rx \*init\_ctx\_rx(struct tls\_context \*ctx) }  crypto\_init\_wait(&sw\_ctx\_rx->async\_wait);- spin\_lock\_init(&sw\_ctx\_rx->decrypt\_compl\_lock);+ atomic\_set(&sw\_ctx\_rx->decrypt\_pending, 1); init\_waitqueue\_head(&sw\_ctx\_rx->wq); skb\_queue\_head\_init(&sw\_ctx\_rx->rx\_list); skb\_queue\_head\_init(&sw\_ctx\_rx->async\_hold); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 19:29:42 +0000

