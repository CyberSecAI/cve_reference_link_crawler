

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=aec7961916f3f9e88766e2688992da6980f11b8d)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=aec7961916f3f9e88766e2688992da6980f11b8d)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=aec7961916f3f9e88766e2688992da6980f11b8d)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=aec7961916f3f9e88766e2688992da6980f11b8d)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jakub Kicinski <kuba@kernel.org> | 2024-02-06 17:18:19 -0800 |
| --- | --- | --- |
| committer | David S. Miller <davem@davemloft.net> | 2024-02-10 21:38:19 +0000 |
| commit | [aec7961916f3f9e88766e2688992da6980f11b8d](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=aec7961916f3f9e88766e2688992da6980f11b8d) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=aec7961916f3f9e88766e2688992da6980f11b8d)) | |
| tree | [242e2246f9fb2c26a93dcde3bd597bd5f8100fad](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=aec7961916f3f9e88766e2688992da6980f11b8d) | |
| parent | [c57ca512f3b68ddcd62bda9cc24a8f5584ab01b1](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=c57ca512f3b68ddcd62bda9cc24a8f5584ab01b1) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=aec7961916f3f9e88766e2688992da6980f11b8d&id2=c57ca512f3b68ddcd62bda9cc24a8f5584ab01b1)) | |
| download | [linux-aec7961916f3f9e88766e2688992da6980f11b8d.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-aec7961916f3f9e88766e2688992da6980f11b8d.tar.gz) | |

tls: fix race between async notify and socket closeThe submitting thread (one which called recvmsg/sendmsg)
may exit as soon as the async crypto handler calls complete()
so any code past that point risks touching already freed data.
Try to avoid the locking and extra flags altogether.
Have the main thread hold an extra reference, this way
we can depend solely on the atomic ref counter for
synchronization.
Don't futz with reiniting the completion, either, we are now
tightly controlling when completion fires.
Reported-by: valis <sec@valis.email>
Fixes: 0cada33241d9 ("net/tls: fix race condition causing kernel panic")
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Reviewed-by: Simon Horman <horms@kernel.org>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Reviewed-by: Sabrina Dubroca <sd@queasysnail.net>
Signed-off-by: David S. Miller <davem@davemloft.net>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=aec7961916f3f9e88766e2688992da6980f11b8d)

| -rw-r--r-- | [include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/tls.h?id=aec7961916f3f9e88766e2688992da6980f11b8d) | 5 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/tls/tls\_sw.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/tls/tls_sw.c?id=aec7961916f3f9e88766e2688992da6980f11b8d) | 43 | |  |  |  | | --- | --- | --- | |

2 files changed, 10 insertions, 38 deletions

| diff --git a/include/net/tls.h b/include/net/tls.hindex 962f0c501111ba..340ad43971e471 100644--- a/[include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/tls.h?id=c57ca512f3b68ddcd62bda9cc24a8f5584ab01b1)+++ b/[include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/tls.h?id=aec7961916f3f9e88766e2688992da6980f11b8d)@@ -97,9 +97,6 @@ struct tls\_sw\_context\_tx { struct tls\_rec \*open\_rec; struct list\_head tx\_list; atomic\_t encrypt\_pending;- /\* protect crypto\_wait with encrypt\_pending \*/- spinlock\_t encrypt\_compl\_lock;- int async\_notify; u8 async\_capable:1;  #define BIT\_TX\_SCHEDULED 0@@ -136,8 +133,6 @@ struct tls\_sw\_context\_rx { struct tls\_strparser strp;  atomic\_t decrypt\_pending;- /\* protect crypto\_wait with decrypt\_pending\*/- spinlock\_t decrypt\_compl\_lock; struct sk\_buff\_head async\_hold; struct wait\_queue\_head wq; };diff --git a/net/tls/tls\_sw.c b/net/tls/tls\_sw.cindex 6a73714f34cc4a..635305bebfef6d 100644--- a/[net/tls/tls\_sw.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_sw.c?id=c57ca512f3b68ddcd62bda9cc24a8f5584ab01b1)+++ b/[net/tls/tls\_sw.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_sw.c?id=aec7961916f3f9e88766e2688992da6980f11b8d)@@ -224,22 +224,15 @@ static void tls\_decrypt\_done(void \*data, int err)  kfree(aead\_req); - spin\_lock\_bh(&ctx->decrypt\_compl\_lock);- if (!atomic\_dec\_return(&ctx->decrypt\_pending))+ if (atomic\_dec\_and\_test(&ctx->decrypt\_pending)) complete(&ctx->async\_wait.completion);- spin\_unlock\_bh(&ctx->decrypt\_compl\_lock); }  static int tls\_decrypt\_async\_wait(struct tls\_sw\_context\_rx \*ctx) {- int pending;-- spin\_lock\_bh(&ctx->decrypt\_compl\_lock);- reinit\_completion(&ctx->async\_wait.completion);- pending = atomic\_read(&ctx->decrypt\_pending);- spin\_unlock\_bh(&ctx->decrypt\_compl\_lock);- if (pending)+ if (!atomic\_dec\_and\_test(&ctx->decrypt\_pending)) crypto\_wait\_req(-EINPROGRESS, &ctx->async\_wait);+ atomic\_inc(&ctx->decrypt\_pending);  return ctx->async\_wait.err; }@@ -267,6 +260,7 @@ static int tls\_do\_decryption(struct sock \*sk, aead\_request\_set\_callback(aead\_req, CRYPTO\_TFM\_REQ\_MAY\_BACKLOG, tls\_decrypt\_done, aead\_req);+ DEBUG\_NET\_WARN\_ON\_ONCE(atomic\_read(&ctx->decrypt\_pending) < 1); atomic\_inc(&ctx->decrypt\_pending); } else { aead\_request\_set\_callback(aead\_req,@@ -455,7 +449,6 @@ static void tls\_encrypt\_done(void \*data, int err) struct sk\_msg \*msg\_en; bool ready = false; struct sock \*sk;- int pending;  msg\_en = &rec->msg\_encrypted; @@ -494,12 +487,8 @@ static void tls\_encrypt\_done(void \*data, int err) ready = true; } - spin\_lock\_bh(&ctx->encrypt\_compl\_lock);- pending = atomic\_dec\_return(&ctx->encrypt\_pending);-- if (!pending && ctx->async\_notify)+ if (atomic\_dec\_and\_test(&ctx->encrypt\_pending)) complete(&ctx->async\_wait.completion);- spin\_unlock\_bh(&ctx->encrypt\_compl\_lock);  if (!ready) return;@@ -511,22 +500,9 @@ static void tls\_encrypt\_done(void \*data, int err)  static int tls\_encrypt\_async\_wait(struct tls\_sw\_context\_tx \*ctx) {- int pending;-- spin\_lock\_bh(&ctx->encrypt\_compl\_lock);- ctx->async\_notify = true;-- pending = atomic\_read(&ctx->encrypt\_pending);- spin\_unlock\_bh(&ctx->encrypt\_compl\_lock);- if (pending)+ if (!atomic\_dec\_and\_test(&ctx->encrypt\_pending)) crypto\_wait\_req(-EINPROGRESS, &ctx->async\_wait);- else- reinit\_completion(&ctx->async\_wait.completion);-- /\* There can be no concurrent accesses, since we have no- \* pending encrypt operations- \*/- WRITE\_ONCE(ctx->async\_notify, false);+ atomic\_inc(&ctx->encrypt\_pending);  return ctx->async\_wait.err; }@@ -577,6 +553,7 @@ static int tls\_do\_encryption(struct sock \*sk,  /\* Add the record in tx\_list \*/ list\_add\_tail((struct list\_head \*)&rec->list, &ctx->tx\_list);+ DEBUG\_NET\_WARN\_ON\_ONCE(atomic\_read(&ctx->encrypt\_pending) < 1); atomic\_inc(&ctx->encrypt\_pending);  rc = crypto\_aead\_encrypt(aead\_req);@@ -2601,7 +2578,7 @@ static struct tls\_sw\_context\_tx \*init\_ctx\_tx(struct tls\_context \*ctx, struct soc }  crypto\_init\_wait(&sw\_ctx\_tx->async\_wait);- spin\_lock\_init(&sw\_ctx\_tx->encrypt\_compl\_lock);+ atomic\_set(&sw\_ctx\_tx->encrypt\_pending, 1); INIT\_LIST\_HEAD(&sw\_ctx\_tx->tx\_list); INIT\_DELAYED\_WORK(&sw\_ctx\_tx->tx\_work.work, tx\_work\_handler); sw\_ctx\_tx->tx\_work.sk = sk;@@ -2622,7 +2599,7 @@ static struct tls\_sw\_context\_rx \*init\_ctx\_rx(struct tls\_context \*ctx) }  crypto\_init\_wait(&sw\_ctx\_rx->async\_wait);- spin\_lock\_init(&sw\_ctx\_rx->decrypt\_compl\_lock);+ atomic\_set(&sw\_ctx\_rx->decrypt\_pending, 1); init\_waitqueue\_head(&sw\_ctx\_rx->wq); skb\_queue\_head\_init(&sw\_ctx\_rx->rx\_list); skb\_queue\_head\_init(&sw\_ctx\_rx->async\_hold); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 19:29:43 +0000

