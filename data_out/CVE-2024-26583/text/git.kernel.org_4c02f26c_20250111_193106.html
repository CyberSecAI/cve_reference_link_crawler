

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jakub Kicinski <kuba@kernel.org> | 2024-02-06 17:18:19 -0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-05-25 16:20:17 +0200 |
| commit | [f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7)) | |
| tree | [da717d74398ebc8b603c0f2bfcb2995411b69bf4](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7) | |
| parent | [94afddde1e9285c0aa25a8bb1f4734071e56055b](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=94afddde1e9285c0aa25a8bb1f4734071e56055b) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7&id2=94afddde1e9285c0aa25a8bb1f4734071e56055b)) | |
| download | [linux-f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7.tar.gz) | |

tls: fix race between async notify and socket closecommit aec7961916f3f9e88766e2688992da6980f11b8d upstream.
The submitting thread (one which called recvmsg/sendmsg)
may exit as soon as the async crypto handler calls complete()
so any code past that point risks touching already freed data.
Try to avoid the locking and extra flags altogether.
Have the main thread hold an extra reference, this way
we can depend solely on the atomic ref counter for
synchronization.
Don't futz with reiniting the completion, either, we are now
tightly controlling when completion fires.
Reported-by: valis <sec@valis.email>
Fixes: 0cada33241d9 ("net/tls: fix race condition causing kernel panic")
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Reviewed-by: Simon Horman <horms@kernel.org>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Reviewed-by: Sabrina Dubroca <sd@queasysnail.net>
Signed-off-by: David S. Miller <davem@davemloft.net>
[v5.15: fixed contextual conflicts in struct tls\_sw\_context\_rx and func
init\_ctx\_rx; replaced DEBUG\_NET\_WARN\_ON\_ONCE with BUILD\_BUG\_ON\_INVALID
since they're equivalent when DEBUG\_NET is not defined]
Cc: <stable@vger.kernel.org> # 5.15
Signed-off-by: Shaoying Xu <shaoyi@amazon.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7)

| -rw-r--r-- | [include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/tls.h?id=f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7) | 5 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/tls/tls\_sw.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/tls/tls_sw.c?id=f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7) | 43 | |  |  |  | | --- | --- | --- | |

2 files changed, 10 insertions, 38 deletions

| diff --git a/include/net/tls.h b/include/net/tls.hindex dcd6aa08c06788..59ff5c901ab569 100644--- a/[include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/tls.h?id=94afddde1e9285c0aa25a8bb1f4734071e56055b)+++ b/[include/net/tls.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/tls.h?id=f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7)@@ -128,9 +128,6 @@ struct tls\_sw\_context\_tx { struct tls\_rec \*open\_rec; struct list\_head tx\_list; atomic\_t encrypt\_pending;- /\* protect crypto\_wait with encrypt\_pending \*/- spinlock\_t encrypt\_compl\_lock;- int async\_notify; u8 async\_capable:1;  #define BIT\_TX\_SCHEDULED 0@@ -148,8 +145,6 @@ struct tls\_sw\_context\_rx { struct sk\_buff \*recv\_pkt; u8 async\_capable:1; atomic\_t decrypt\_pending;- /\* protect crypto\_wait with decrypt\_pending\*/- spinlock\_t decrypt\_compl\_lock; };  struct tls\_record\_info {diff --git a/net/tls/tls\_sw.c b/net/tls/tls\_sw.cindex 614cb30dae134c..40b96780e13d2a 100644--- a/[net/tls/tls\_sw.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_sw.c?id=94afddde1e9285c0aa25a8bb1f4734071e56055b)+++ b/[net/tls/tls\_sw.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/tls/tls_sw.c?id=f17d21ea73918ace8afb9c2d8e734dbf71c2c9d7)@@ -220,22 +220,15 @@ static void tls\_decrypt\_done(struct crypto\_async\_request \*req, int err)  kfree(aead\_req); - spin\_lock\_bh(&ctx->decrypt\_compl\_lock);- if (!atomic\_dec\_return(&ctx->decrypt\_pending))+ if (atomic\_dec\_and\_test(&ctx->decrypt\_pending)) complete(&ctx->async\_wait.completion);- spin\_unlock\_bh(&ctx->decrypt\_compl\_lock); }  static int tls\_decrypt\_async\_wait(struct tls\_sw\_context\_rx \*ctx) {- int pending;-- spin\_lock\_bh(&ctx->decrypt\_compl\_lock);- reinit\_completion(&ctx->async\_wait.completion);- pending = atomic\_read(&ctx->decrypt\_pending);- spin\_unlock\_bh(&ctx->decrypt\_compl\_lock);- if (pending)+ if (!atomic\_dec\_and\_test(&ctx->decrypt\_pending)) crypto\_wait\_req(-EINPROGRESS, &ctx->async\_wait);+ atomic\_inc(&ctx->decrypt\_pending);  return ctx->async\_wait.err; }@@ -271,6 +264,7 @@ static int tls\_do\_decryption(struct sock \*sk, aead\_request\_set\_callback(aead\_req, CRYPTO\_TFM\_REQ\_MAY\_BACKLOG, tls\_decrypt\_done, skb);+ BUILD\_BUG\_ON\_INVALID(atomic\_read(&ctx->decrypt\_pending) < 1); atomic\_inc(&ctx->decrypt\_pending); } else { aead\_request\_set\_callback(aead\_req,@@ -460,7 +454,6 @@ static void tls\_encrypt\_done(struct crypto\_async\_request \*req, int err) struct sk\_msg \*msg\_en; struct tls\_rec \*rec; bool ready = false;- int pending;  rec = container\_of(aead\_req, struct tls\_rec, aead\_req); msg\_en = &rec->msg\_encrypted;@@ -495,12 +488,8 @@ static void tls\_encrypt\_done(struct crypto\_async\_request \*req, int err) ready = true; } - spin\_lock\_bh(&ctx->encrypt\_compl\_lock);- pending = atomic\_dec\_return(&ctx->encrypt\_pending);-- if (!pending && ctx->async\_notify)+ if (atomic\_dec\_and\_test(&ctx->encrypt\_pending)) complete(&ctx->async\_wait.completion);- spin\_unlock\_bh(&ctx->encrypt\_compl\_lock);  if (!ready) return;@@ -512,22 +501,9 @@ static void tls\_encrypt\_done(struct crypto\_async\_request \*req, int err)  static int tls\_encrypt\_async\_wait(struct tls\_sw\_context\_tx \*ctx) {- int pending;-- spin\_lock\_bh(&ctx->encrypt\_compl\_lock);- ctx->async\_notify = true;-- pending = atomic\_read(&ctx->encrypt\_pending);- spin\_unlock\_bh(&ctx->encrypt\_compl\_lock);- if (pending)+ if (!atomic\_dec\_and\_test(&ctx->encrypt\_pending)) crypto\_wait\_req(-EINPROGRESS, &ctx->async\_wait);- else- reinit\_completion(&ctx->async\_wait.completion);-- /\* There can be no concurrent accesses, since we have no- \* pending encrypt operations- \*/- WRITE\_ONCE(ctx->async\_notify, false);+ atomic\_inc(&ctx->encrypt\_pending);  return ctx->async\_wait.err; }@@ -571,6 +547,7 @@ static int tls\_do\_encryption(struct sock \*sk,  /\* Add the record in tx\_list \*/ list\_add\_tail((struct list\_head \*)&rec->list, &ctx->tx\_list);+ BUILD\_BUG\_ON\_INVALID(atomic\_read(&ctx->encrypt\_pending) < 1); atomic\_inc(&ctx->encrypt\_pending);  rc = crypto\_aead\_encrypt(aead\_req);@@ -2312,7 +2289,7 @@ static struct tls\_sw\_context\_tx \*init\_ctx\_tx(struct tls\_context \*ctx, struct soc }  crypto\_init\_wait(&sw\_ctx\_tx->async\_wait);- spin\_lock\_init(&sw\_ctx\_tx->encrypt\_compl\_lock);+ atomic\_set(&sw\_ctx\_tx->encrypt\_pending, 1); INIT\_LIST\_HEAD(&sw\_ctx\_tx->tx\_list); INIT\_DELAYED\_WORK(&sw\_ctx\_tx->tx\_work.work, tx\_work\_handler); sw\_ctx\_tx->tx\_work.sk = sk;@@ -2333,7 +2310,7 @@ static struct tls\_sw\_context\_rx \*init\_ctx\_rx(struct tls\_context \*ctx) }  crypto\_init\_wait(&sw\_ctx\_rx->async\_wait);- spin\_lock\_init(&sw\_ctx\_rx->decrypt\_compl\_lock);+ atomic\_set(&sw\_ctx\_rx->decrypt\_pending, 1); skb\_queue\_head\_init(&sw\_ctx\_rx->rx\_list);  return sw\_ctx\_rx; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 19:29:44 +0000

