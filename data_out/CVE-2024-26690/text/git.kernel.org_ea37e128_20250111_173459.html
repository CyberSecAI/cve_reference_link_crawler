

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=e6af0f082a4b87b99ad033003be2a904a1791b3f)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=e6af0f082a4b87b99ad033003be2a904a1791b3f)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e6af0f082a4b87b99ad033003be2a904a1791b3f)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e6af0f082a4b87b99ad033003be2a904a1791b3f)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Petr Tesarik <petr@tesarici.cz> | 2024-02-03 20:09:27 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-02-23 09:51:56 +0100 |
| commit | [e6af0f082a4b87b99ad033003be2a904a1791b3f](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e6af0f082a4b87b99ad033003be2a904a1791b3f) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=e6af0f082a4b87b99ad033003be2a904a1791b3f)) | |
| tree | [db657c696948cb3b67fd1bc5728665d837201fd1](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=e6af0f082a4b87b99ad033003be2a904a1791b3f) | |
| parent | [8bfc9c2b1d94ca23ea4397109c1141c11bf5fa4c](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=8bfc9c2b1d94ca23ea4397109c1141c11bf5fa4c) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e6af0f082a4b87b99ad033003be2a904a1791b3f&id2=8bfc9c2b1d94ca23ea4397109c1141c11bf5fa4c)) | |
| download | [linux-e6af0f082a4b87b99ad033003be2a904a1791b3f.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-e6af0f082a4b87b99ad033003be2a904a1791b3f.tar.gz) | |

net: stmmac: protect updates of 64-bit statistics counterscommit 38cc3c6dcc09dc3a1800b5ec22aef643ca11eab8 upstream.
As explained by a comment in <linux/u64\_stats\_sync.h>, write side of struct
u64\_stats\_sync must ensure mutual exclusion, or one seqcount update could
be lost on 32-bit platforms, thus blocking readers forever. Such lockups
have been observed in real world after stmmac\_xmit() on one CPU raced with
stmmac\_napi\_poll\_tx() on another CPU.
To fix the issue without introducing a new lock, split the statics into
three parts:
1. fields updated only under the tx queue lock,
2. fields updated only during NAPI poll,
3. fields updated only from interrupt context,
Updates to fields in the first two groups are already serialized through
other locks. It is sufficient to split the existing struct u64\_stats\_sync
so that each group has its own.
Note that tx\_set\_ic\_bit is updated from both contexts. Split this counter
so that each context gets its own, and calculate their sum to get the total
value in stmmac\_get\_ethtool\_stats().
For the third group, multiple interrupts may be processed by different CPUs
at the same time, but interrupts on the same CPU will not nest. Move fields
from this group to a newly created per-cpu struct stmmac\_pcpu\_stats.
Fixes: 133466c3bbe1 ("net: stmmac: use per-queue 64 bit statistics where necessary")
Link: [https://lore.kernel.org/netdev/Za173PhviYg-1qIn@torres.zugschlus.de/t/](https://lore.kernel.org/netdev/Za173PhviYg-1qIn%40torres.zugschlus.de/t/)
Cc: stable@vger.kernel.org
Signed-off-by: Petr Tesarik <petr@tesarici.cz>
Reviewed-by: Jisheng Zhang <jszhang@kernel.org>
Signed-off-by: David S. Miller <davem@davemloft.net>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e6af0f082a4b87b99ad033003be2a904a1791b3f)

| -rw-r--r-- | [drivers/net/ethernet/stmicro/stmmac/common.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/stmicro/stmmac/common.h?id=e6af0f082a4b87b99ad033003be2a904a1791b3f) | 56 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c?id=e6af0f082a4b87b99ad033003be2a904a1791b3f) | 15 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/net/ethernet/stmicro/stmmac/dwmac4\_lib.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/stmicro/stmmac/dwmac4_lib.c?id=e6af0f082a4b87b99ad033003be2a904a1791b3f) | 15 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/net/ethernet/stmicro/stmmac/dwmac\_lib.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/stmicro/stmmac/dwmac_lib.c?id=e6af0f082a4b87b99ad033003be2a904a1791b3f) | 15 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/net/ethernet/stmicro/stmmac/dwxgmac2\_dma.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/stmicro/stmmac/dwxgmac2_dma.c?id=e6af0f082a4b87b99ad033003be2a904a1791b3f) | 15 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/net/ethernet/stmicro/stmmac/stmmac\_ethtool.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c?id=e6af0f082a4b87b99ad033003be2a904a1791b3f) | 129 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/net/ethernet/stmicro/stmmac/stmmac\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c?id=e6af0f082a4b87b99ad033003be2a904a1791b3f) | 133 | |  |  |  | | --- | --- | --- | |

7 files changed, 221 insertions, 157 deletions

| diff --git a/drivers/net/ethernet/stmicro/stmmac/common.h b/drivers/net/ethernet/stmicro/stmmac/common.hindex 588e44d57f2912..c75c64a9383949 100644--- a/[drivers/net/ethernet/stmicro/stmmac/common.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/stmicro/stmmac/common.h?id=8bfc9c2b1d94ca23ea4397109c1141c11bf5fa4c)+++ b/[drivers/net/ethernet/stmicro/stmmac/common.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/stmicro/stmmac/common.h?id=e6af0f082a4b87b99ad033003be2a904a1791b3f)@@ -59,28 +59,51 @@ #undef FRAME\_FILTER\_DEBUG /\* #define FRAME\_FILTER\_DEBUG \*/ +struct stmmac\_q\_tx\_stats {+ u64\_stats\_t tx\_bytes;+ u64\_stats\_t tx\_set\_ic\_bit;+ u64\_stats\_t tx\_tso\_frames;+ u64\_stats\_t tx\_tso\_nfrags;+};++struct stmmac\_napi\_tx\_stats {+ u64\_stats\_t tx\_packets;+ u64\_stats\_t tx\_pkt\_n;+ u64\_stats\_t poll;+ u64\_stats\_t tx\_clean;+ u64\_stats\_t tx\_set\_ic\_bit;+};+ struct stmmac\_txq\_stats {- u64 tx\_bytes;- u64 tx\_packets;- u64 tx\_pkt\_n;- u64 tx\_normal\_irq\_n;- u64 napi\_poll;- u64 tx\_clean;- u64 tx\_set\_ic\_bit;- u64 tx\_tso\_frames;- u64 tx\_tso\_nfrags;- struct u64\_stats\_sync syncp;+ /\* Updates protected by tx queue lock. \*/+ struct u64\_stats\_sync q\_syncp;+ struct stmmac\_q\_tx\_stats q;++ /\* Updates protected by NAPI poll logic. \*/+ struct u64\_stats\_sync napi\_syncp;+ struct stmmac\_napi\_tx\_stats napi; } \_\_\_\_cacheline\_aligned\_in\_smp; +struct stmmac\_napi\_rx\_stats {+ u64\_stats\_t rx\_bytes;+ u64\_stats\_t rx\_packets;+ u64\_stats\_t rx\_pkt\_n;+ u64\_stats\_t poll;+};+ struct stmmac\_rxq\_stats {- u64 rx\_bytes;- u64 rx\_packets;- u64 rx\_pkt\_n;- u64 rx\_normal\_irq\_n;- u64 napi\_poll;- struct u64\_stats\_sync syncp;+ /\* Updates protected by NAPI poll logic. \*/+ struct u64\_stats\_sync napi\_syncp;+ struct stmmac\_napi\_rx\_stats napi; } \_\_\_\_cacheline\_aligned\_in\_smp; +/\* Updates on each CPU protected by not allowing nested irqs. \*/+struct stmmac\_pcpu\_stats {+ struct u64\_stats\_sync syncp;+ u64\_stats\_t rx\_normal\_irq\_n[MTL\_MAX\_TX\_QUEUES];+ u64\_stats\_t tx\_normal\_irq\_n[MTL\_MAX\_RX\_QUEUES];+};+ /\* Extra statistic and debug information exposed by ethtool \*/ struct stmmac\_extra\_stats { /\* Transmit errors \*/@@ -205,6 +228,7 @@ struct stmmac\_extra\_stats { /\* per queue statistics \*/ struct stmmac\_txq\_stats txq\_stats[MTL\_MAX\_TX\_QUEUES]; struct stmmac\_rxq\_stats rxq\_stats[MTL\_MAX\_RX\_QUEUES];+ struct stmmac\_pcpu\_stats \_\_percpu \*pcpu\_stats; unsigned long rx\_dropped; unsigned long rx\_errors; unsigned long tx\_dropped;diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.cindex 137741b94122e5..b21d99faa2d04c 100644--- a/[drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c?id=8bfc9c2b1d94ca23ea4397109c1141c11bf5fa4c)+++ b/[drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c?id=e6af0f082a4b87b99ad033003be2a904a1791b3f)@@ -441,8 +441,7 @@ static int sun8i\_dwmac\_dma\_interrupt(struct stmmac\_priv \*priv, struct stmmac\_extra\_stats \*x, u32 chan, u32 dir) {- struct stmmac\_rxq\_stats \*rxq\_stats = &priv->xstats.rxq\_stats[chan];- struct stmmac\_txq\_stats \*txq\_stats = &priv->xstats.txq\_stats[chan];+ struct stmmac\_pcpu\_stats \*stats = this\_cpu\_ptr(priv->xstats.pcpu\_stats); int ret = 0; u32 v; @@ -455,9 +454,9 @@ static int sun8i\_dwmac\_dma\_interrupt(struct stmmac\_priv \*priv,  if (v & EMAC\_TX\_INT) { ret |= handle\_tx;- u64\_stats\_update\_begin(&txq\_stats->syncp);- txq\_stats->tx\_normal\_irq\_n++;- u64\_stats\_update\_end(&txq\_stats->syncp);+ u64\_stats\_update\_begin(&stats->syncp);+ u64\_stats\_inc(&stats->tx\_normal\_irq\_n[chan]);+ u64\_stats\_update\_end(&stats->syncp); }  if (v & EMAC\_TX\_DMA\_STOP\_INT)@@ -479,9 +478,9 @@ static int sun8i\_dwmac\_dma\_interrupt(struct stmmac\_priv \*priv,  if (v & EMAC\_RX\_INT) { ret |= handle\_rx;- u64\_stats\_update\_begin(&rxq\_stats->syncp);- rxq\_stats->rx\_normal\_irq\_n++;- u64\_stats\_update\_end(&rxq\_stats->syncp);+ u64\_stats\_update\_begin(&stats->syncp);+ u64\_stats\_inc(&stats->rx\_normal\_irq\_n[chan]);+ u64\_stats\_update\_end(&stats->syncp); }  if (v & EMAC\_RX\_BUF\_UA\_INT)diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac4\_lib.c b/drivers/net/ethernet/stmicro/stmmac/dwmac4\_lib.cindex 9470d3fd2dede2..0d185e54eb7e24 100644--- a/[drivers/net/ethernet/stmicro/stmmac/dwmac4\_lib.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/stmicro/stmmac/dwmac4_lib.c?id=8bfc9c2b1d94ca23ea4397109c1141c11bf5fa4c)+++ b/[drivers/net/ethernet/stmicro/stmmac/dwmac4\_lib.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/stmicro/stmmac/dwmac4_lib.c?id=e6af0f082a4b87b99ad033003be2a904a1791b3f)@@ -171,8 +171,7 @@ int dwmac4\_dma\_interrupt(struct stmmac\_priv \*priv, void \_\_iomem \*ioaddr, const struct dwmac4\_addrs \*dwmac4\_addrs = priv->plat->dwmac4\_addrs; u32 intr\_status = readl(ioaddr + DMA\_CHAN\_STATUS(dwmac4\_addrs, chan)); u32 intr\_en = readl(ioaddr + DMA\_CHAN\_INTR\_ENA(dwmac4\_addrs, chan));- struct stmmac\_rxq\_stats \*rxq\_stats = &priv->xstats.rxq\_stats[chan];- struct stmmac\_txq\_stats \*txq\_stats = &priv->xstats.txq\_stats[chan];+ struct stmmac\_pcpu\_stats \*stats = this\_cpu\_ptr(priv->xstats.pcpu\_stats); int ret = 0;  if (dir == DMA\_DIR\_RX)@@ -201,15 +200,15 @@ int dwmac4\_dma\_interrupt(struct stmmac\_priv \*priv, void \_\_iomem \*ioaddr, } /\* TX/RX NORMAL interrupts \*/ if (likely(intr\_status & DMA\_CHAN\_STATUS\_RI)) {- u64\_stats\_update\_begin(&rxq\_stats->syncp);- rxq\_stats->rx\_normal\_irq\_n++;- u64\_stats\_update\_end(&rxq\_stats->syncp);+ u64\_stats\_update\_begin(&stats->syncp);+ u64\_stats\_inc(&stats->rx\_normal\_irq\_n[chan]);+ u64\_stats\_update\_end(&stats->syncp); ret |= handle\_rx; } if (likely(intr\_status & DMA\_CHAN\_STATUS\_TI)) {- u64\_stats\_update\_begin(&txq\_stats->syncp);- txq\_stats->tx\_normal\_irq\_n++;- u64\_stats\_update\_end(&txq\_stats->syncp);+ u64\_stats\_update\_begin(&stats->syncp);+ u64\_stats\_inc(&stats->tx\_normal\_irq\_n[chan]);+ u64\_stats\_update\_end(&stats->syncp); ret |= handle\_tx; } diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac\_lib.c b/drivers/net/ethernet/stmicro/stmmac/dwmac\_lib.cindex 7907d62d343759..85e18f9a22f920 100644--- a/[drivers/net/ethernet/stmicro/stmmac/dwmac\_lib.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/stmicro/stmmac/dwmac_lib.c?id=8bfc9c2b1d94ca23ea4397109c1141c11bf5fa4c)+++ b/[drivers/net/ethernet/stmicro/stmmac/dwmac\_lib.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/stmicro/stmmac/dwmac_lib.c?id=e6af0f082a4b87b99ad033003be2a904a1791b3f)@@ -162,8 +162,7 @@ static void show\_rx\_process\_state(unsigned int status) int dwmac\_dma\_interrupt(struct stmmac\_priv \*priv, void \_\_iomem \*ioaddr, struct stmmac\_extra\_stats \*x, u32 chan, u32 dir) {- struct stmmac\_rxq\_stats \*rxq\_stats = &priv->xstats.rxq\_stats[chan];- struct stmmac\_txq\_stats \*txq\_stats = &priv->xstats.txq\_stats[chan];+ struct stmmac\_pcpu\_stats \*stats = this\_cpu\_ptr(priv->xstats.pcpu\_stats); int ret = 0; /\* read the status register (CSR5) \*/ u32 intr\_status = readl(ioaddr + DMA\_STATUS);@@ -215,16 +214,16 @@ int dwmac\_dma\_interrupt(struct stmmac\_priv \*priv, void \_\_iomem \*ioaddr, u32 value = readl(ioaddr + DMA\_INTR\_ENA); /\* to schedule NAPI on real RIE event. \*/ if (likely(value & DMA\_INTR\_ENA\_RIE)) {- u64\_stats\_update\_begin(&rxq\_stats->syncp);- rxq\_stats->rx\_normal\_irq\_n++;- u64\_stats\_update\_end(&rxq\_stats->syncp);+ u64\_stats\_update\_begin(&stats->syncp);+ u64\_stats\_inc(&stats->rx\_normal\_irq\_n[chan]);+ u64\_stats\_update\_end(&stats->syncp); ret |= handle\_rx; } } if (likely(intr\_status & DMA\_STATUS\_TI)) {- u64\_stats\_update\_begin(&txq\_stats->syncp);- txq\_stats->tx\_normal\_irq\_n++;- u64\_stats\_update\_end(&txq\_stats->syncp);+ u64\_stats\_update\_begin(&stats->syncp);+ u64\_stats\_inc(&stats->tx\_normal\_irq\_n[chan]);+ u64\_stats\_update\_end(&stats->syncp); ret |= handle\_tx; } if (unlikely(intr\_status & DMA\_STATUS\_ERI))diff --git a/drivers/net/ethernet/stmicro/stmmac/dwxgmac2\_dma.c b/drivers/net/ethernet/stmicro/stmmac/dwxgmac2\_dma.cindex 3cde695fec91bd..dd2ab6185c40e8 100644--- a/[drivers/net/ethernet/stmicro/stmmac/dwxgmac2\_dma.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/stmicro/stmmac/dwxgmac2_dma.c?id=8bfc9c2b1d94ca23ea4397109c1141c11bf5fa4c)+++ b/[drivers/net/ethernet/stmicro/stmmac/dwxgmac2\_dma.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/stmicro/stmmac/dwxgmac2_dma.c?id=e6af0f082a4b87b99ad033003be2a904a1791b3f)@@ -337,8 +337,7 @@ static int dwxgmac2\_dma\_interrupt(struct stmmac\_priv \*priv, struct stmmac\_extra\_stats \*x, u32 chan, u32 dir) {- struct stmmac\_rxq\_stats \*rxq\_stats = &priv->xstats.rxq\_stats[chan];- struct stmmac\_txq\_stats \*txq\_stats = &priv->xstats.txq\_stats[chan];+ struct stmmac\_pcpu\_stats \*stats = this\_cpu\_ptr(priv->xstats.pcpu\_stats); u32 intr\_status = readl(ioaddr + XGMAC\_DMA\_CH\_STATUS(chan)); u32 intr\_en = readl(ioaddr + XGMAC\_DMA\_CH\_INT\_EN(chan)); int ret = 0;@@ -367,15 +366,15 @@ static int dwxgmac2\_dma\_interrupt(struct stmmac\_priv \*priv, /\* TX/RX NORMAL interrupts \*/ if (likely(intr\_status & XGMAC\_NIS)) { if (likely(intr\_status & XGMAC\_RI)) {- u64\_stats\_update\_begin(&rxq\_stats->syncp);- rxq\_stats->rx\_normal\_irq\_n++;- u64\_stats\_update\_end(&rxq\_stats->syncp);+ u64\_stats\_update\_begin(&stats->syncp);+ u64\_stats\_inc(&stats->rx\_normal\_irq\_n[chan]);+ u64\_stats\_update\_end(&stats->syncp); ret |= handle\_rx; } if (likely(intr\_status & (XGMAC\_TI | XGMAC\_TBU))) {- u64\_stats\_update\_begin(&txq\_stats->syncp);- txq\_stats->tx\_normal\_irq\_n++;- u64\_stats\_update\_end(&txq\_stats->syncp);+ u64\_stats\_update\_begin(&stats->syncp);+ u64\_stats\_inc(&stats->tx\_normal\_irq\_n[chan]);+ u64\_stats\_update\_end(&stats->syncp); ret |= handle\_tx; } }diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac\_ethtool.c b/drivers/net/ethernet/stmicro/stmmac/stmmac\_ethtool.cindex 67bc98f9913515..f9c1f3f4a17a5e 100644--- a/[drivers/net/ethernet/stmicro/stmmac/stmmac\_ethtool.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c?id=8bfc9c2b1d94ca23ea4397109c1141c11bf5fa4c)+++ b/[drivers/net/ethernet/stmicro/stmmac/stmmac\_ethtool.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c?id=e6af0f082a4b87b99ad033003be2a904a1791b3f)@@ -539,44 +539,79 @@ stmmac\_set\_pauseparam(struct net\_device \*netdev, } } +static u64 stmmac\_get\_rx\_normal\_irq\_n(struct stmmac\_priv \*priv, int q)+{+ u64 total;+ int cpu;++ total = 0;+ for\_each\_possible\_cpu(cpu) {+ struct stmmac\_pcpu\_stats \*pcpu;+ unsigned int start;+ u64 irq\_n;++ pcpu = per\_cpu\_ptr(priv->xstats.pcpu\_stats, cpu);+ do {+ start = u64\_stats\_fetch\_begin(&pcpu->syncp);+ irq\_n = u64\_stats\_read(&pcpu->rx\_normal\_irq\_n[q]);+ } while (u64\_stats\_fetch\_retry(&pcpu->syncp, start));+ total += irq\_n;+ }+ return total;+}++static u64 stmmac\_get\_tx\_normal\_irq\_n(struct stmmac\_priv \*priv, int q)+{+ u64 total;+ int cpu;++ total = 0;+ for\_each\_possible\_cpu(cpu) {+ struct stmmac\_pcpu\_stats \*pcpu;+ unsigned int start;+ u64 irq\_n;++ pcpu = per\_cpu\_ptr(priv->xstats.pcpu\_stats, cpu);+ do {+ start = u64\_stats\_fetch\_begin(&pcpu->syncp);+ irq\_n = u64\_stats\_read(&pcpu->tx\_normal\_irq\_n[q]);+ } while (u64\_stats\_fetch\_retry(&pcpu->syncp, start));+ total += irq\_n;+ }+ return total;+}+ static void stmmac\_get\_per\_qstats(struct stmmac\_priv \*priv, u64 \*data) { u32 tx\_cnt = priv->plat->tx\_queues\_to\_use; u32 rx\_cnt = priv->plat->rx\_queues\_to\_use; unsigned int start;- int q, stat;- char \*p;+ int q;  for (q = 0; q < tx\_cnt; q++) { struct stmmac\_txq\_stats \*txq\_stats = &priv->xstats.txq\_stats[q];- struct stmmac\_txq\_stats snapshot;+ u64 pkt\_n;  do {- start = u64\_stats\_fetch\_begin(&txq\_stats->syncp);- snapshot = \*txq\_stats;- } while (u64\_stats\_fetch\_retry(&txq\_stats->syncp, start));+ start = u64\_stats\_fetch\_begin(&txq\_stats->napi\_syncp);+ pkt\_n = u64\_stats\_read(&txq\_stats->napi.tx\_pkt\_n);+ } while (u64\_stats\_fetch\_retry(&txq\_stats->napi\_syncp, start)); - p = (char \*)&snapshot + offsetof(struct stmmac\_txq\_stats, tx\_pkt\_n);- for (stat = 0; stat < STMMAC\_TXQ\_STATS; stat++) {- \*data++ = (\*(u64 \*)p);- p += sizeof(u64);- }+ \*data++ = pkt\_n;+ \*data++ = stmmac\_get\_tx\_normal\_irq\_n(priv, q); }  for (q = 0; q < rx\_cnt; q++) { struct stmmac\_rxq\_stats \*rxq\_stats = &priv->xstats.rxq\_stats[q];- struct stmmac\_rxq\_stats snapshot;+ u64 pkt\_n;  do {- start = u64\_stats\_fetch\_begin(&rxq\_stats->syncp);- snapshot = \*rxq\_stats;- } while (u64\_stats\_fetch\_retry(&rxq\_stats->syncp, start));+ start = u64\_stats\_fetch\_begin(&rxq\_stats->napi\_syncp);+ pkt\_n = u64\_stats\_read(&rxq\_stats->napi.rx\_pkt\_n);+ } while (u64\_stats\_fetch\_retry(&rxq\_stats->napi\_syncp, start)); - p = (char \*)&snapshot + offsetof(struct stmmac\_rxq\_stats, rx\_pkt\_n);- for (stat = 0; stat < STMMAC\_RXQ\_STATS; stat++) {- \*data++ = (\*(u64 \*)p);- p += sizeof(u64);- }+ \*data++ = pkt\_n;+ \*data++ = stmmac\_get\_rx\_normal\_irq\_n(priv, q); } } @@ -635,39 +670,49 @@ static void stmmac\_get\_ethtool\_stats(struct net\_device \*dev, pos = j; for (i = 0; i < rx\_queues\_count; i++) { struct stmmac\_rxq\_stats \*rxq\_stats = &priv->xstats.rxq\_stats[i];- struct stmmac\_rxq\_stats snapshot;+ struct stmmac\_napi\_rx\_stats snapshot;+ u64 n\_irq;  j = pos; do {- start = u64\_stats\_fetch\_begin(&rxq\_stats->syncp);- snapshot = \*rxq\_stats;- } while (u64\_stats\_fetch\_retry(&rxq\_stats->syncp, start));-- data[j++] += snapshot.rx\_pkt\_n;- data[j++] += snapshot.rx\_normal\_irq\_n;- normal\_irq\_n += snapshot.rx\_normal\_irq\_n;- napi\_poll += snapshot.napi\_poll;+ start = u64\_stats\_fetch\_begin(&rxq\_stats->napi\_syncp);+ snapshot = rxq\_stats->napi;+ } while (u64\_stats\_fetch\_retry(&rxq\_stats->napi\_syncp, start));++ data[j++] += u64\_stats\_read(&snapshot.rx\_pkt\_n);+ n\_irq = stmmac\_get\_rx\_normal\_irq\_n(priv, i);+ data[j++] += n\_irq;+ normal\_irq\_n += n\_irq;+ napi\_poll += u64\_stats\_read(&snapshot.poll); }  pos = j; for (i = 0; i < tx\_queues\_count; i++) { struct stmmac\_txq\_stats \*txq\_stats = &priv->xstats.txq\_stats[i];- struct stmmac\_txq\_stats snapshot;+ struct stmmac\_napi\_tx\_stats napi\_snapshot;+ struct stmmac\_q\_tx\_stats q\_snapshot;+ u64 n\_irq;  j = pos; do {- start = u64\_stats\_fetch\_begin(&txq\_stats->syncp);- snapshot = \*txq\_stats;- } while (u64\_stats\_fetch\_retry(&txq\_stats->syncp, start));-- data[j++] += snapshot.tx\_pkt\_n;- data[j++] += snapshot.tx\_normal\_irq\_n;- normal\_irq\_n += snapshot.tx\_normal\_irq\_n;- data[j++] += snapshot.tx\_clean;- data[j++] += snapshot.tx\_set\_ic\_bit;- data[j++] += snapshot.tx\_tso\_frames;- data[j++] += snapshot.tx\_tso\_nfrags;- napi\_poll += snapshot.napi\_poll;+ start = u64\_stats\_fetch\_begin(&txq\_stats->q\_syncp);+ q\_snapshot = txq\_stats->q;+ } while (u64\_stats\_fetch\_retry(&txq\_stats->q\_syncp, start));+ do {+ start = u64\_stats\_fetch\_begin(&txq\_stats->napi\_syncp);+ napi\_snapshot = txq\_stats->napi;+ } while (u64\_stats\_fetch\_retry(&txq\_stats->napi\_syncp, start));++ data[j++] += u64\_stats\_read(&napi\_snapshot.tx\_pkt\_n);+ n\_irq = stmmac\_get\_tx\_normal\_irq\_n(priv, i);+ data[j++] += n\_irq;+ normal\_irq\_n += n\_irq;+ data[j++] += u64\_stats\_read(&napi\_snapshot.tx\_clean);+ data[j++] += u64\_stats\_read(&q\_snapshot.tx\_set\_ic\_bit) ++ u64\_stats\_read(&napi\_snapshot.tx\_set\_ic\_bit);+ data[j++] += u64\_stats\_read(&q\_snapshot.tx\_tso\_frames);+ data[j++] += u64\_stats\_read(&q\_snapshot.tx\_tso\_nfrags);+ napi\_poll += u64\_stats\_read(&napi\_snapshot.poll); } normal\_irq\_n += priv->xstats.rx\_early\_irq; data[j++] = normal\_irq\_n;diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac\_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac\_main.cindex 2ad3a83ae7e2b9..ec34768e054da0 100644--- a/[drivers/net/ethernet/stmicro/stmmac/stmmac\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c?id=8bfc9c2b1d94ca23ea4397109c1141c11bf5fa4c)+++ b/[drivers/net/ethernet/stmicro/stmmac/stmmac\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c?id=e6af0f082a4b87b99ad033003be2a904a1791b3f)@@ -2442,7 +2442,6 @@ static bool stmmac\_xdp\_xmit\_zc(struct stmmac\_priv \*priv, u32 queue, u32 budget) struct xdp\_desc xdp\_desc; bool work\_done = true; u32 tx\_set\_ic\_bit = 0;- unsigned long flags;  /\* Avoids TX time-out as we are sharing with slow path \*/ txq\_trans\_cond\_update(nq);@@ -2515,9 +2514,9 @@ static bool stmmac\_xdp\_xmit\_zc(struct stmmac\_priv \*priv, u32 queue, u32 budget) tx\_q->cur\_tx = STMMAC\_GET\_ENTRY(tx\_q->cur\_tx, priv->dma\_conf.dma\_tx\_size); entry = tx\_q->cur\_tx; }- flags = u64\_stats\_update\_begin\_irqsave(&txq\_stats->syncp);- txq\_stats->tx\_set\_ic\_bit += tx\_set\_ic\_bit;- u64\_stats\_update\_end\_irqrestore(&txq\_stats->syncp, flags);+ u64\_stats\_update\_begin(&txq\_stats->napi\_syncp);+ u64\_stats\_add(&txq\_stats->napi.tx\_set\_ic\_bit, tx\_set\_ic\_bit);+ u64\_stats\_update\_end(&txq\_stats->napi\_syncp);  if (tx\_desc) { stmmac\_flush\_tx\_descriptors(priv, queue);@@ -2565,7 +2564,6 @@ static int stmmac\_tx\_clean(struct stmmac\_priv \*priv, int budget, u32 queue, unsigned int bytes\_compl = 0, pkts\_compl = 0; unsigned int entry, xmits = 0, count = 0; u32 tx\_packets = 0, tx\_errors = 0;- unsigned long flags;  \_\_netif\_tx\_lock\_bh(netdev\_get\_tx\_queue(priv->dev, queue)); @@ -2721,11 +2719,11 @@ static int stmmac\_tx\_clean(struct stmmac\_priv \*priv, int budget, u32 queue, if (tx\_q->dirty\_tx != tx\_q->cur\_tx) \*pending\_packets = true; - flags = u64\_stats\_update\_begin\_irqsave(&txq\_stats->syncp);- txq\_stats->tx\_packets += tx\_packets;- txq\_stats->tx\_pkt\_n += tx\_packets;- txq\_stats->tx\_clean++;- u64\_stats\_update\_end\_irqrestore(&txq\_stats->syncp, flags);+ u64\_stats\_update\_begin(&txq\_stats->napi\_syncp);+ u64\_stats\_add(&txq\_stats->napi.tx\_packets, tx\_packets);+ u64\_stats\_add(&txq\_stats->napi.tx\_pkt\_n, tx\_packets);+ u64\_stats\_inc(&txq\_stats->napi.tx\_clean);+ u64\_stats\_update\_end(&txq\_stats->napi\_syncp);  priv->xstats.tx\_errors += tx\_errors; @@ -4150,7 +4148,6 @@ static netdev\_tx\_t stmmac\_tso\_xmit(struct sk\_buff \*skb, struct net\_device \*dev) struct stmmac\_tx\_queue \*tx\_q; bool has\_vlan, set\_ic; u8 proto\_hdr\_len, hdr;- unsigned long flags; u32 pay\_len, mss; dma\_addr\_t des; int i;@@ -4315,13 +4312,13 @@ static netdev\_tx\_t stmmac\_tso\_xmit(struct sk\_buff \*skb, struct net\_device \*dev) netif\_tx\_stop\_queue(netdev\_get\_tx\_queue(priv->dev, queue)); } - flags = u64\_stats\_update\_begin\_irqsave(&txq\_stats->syncp);- txq\_stats->tx\_bytes += skb->len;- txq\_stats->tx\_tso\_frames++;- txq\_stats->tx\_tso\_nfrags += nfrags;+ u64\_stats\_update\_begin(&txq\_stats->q\_syncp);+ u64\_stats\_add(&txq\_stats->q.tx\_bytes, skb->len);+ u64\_stats\_inc(&txq\_stats->q.tx\_tso\_frames);+ u64\_stats\_add(&txq\_stats->q.tx\_tso\_nfrags, nfrags); if (set\_ic)- txq\_stats->tx\_set\_ic\_bit++;- u64\_stats\_update\_end\_irqrestore(&txq\_stats->syncp, flags);+ u64\_stats\_inc(&txq\_stats->q.tx\_set\_ic\_bit);+ u64\_stats\_update\_end(&txq\_stats->q\_syncp);  if (priv->sarc\_type) stmmac\_set\_desc\_sarc(priv, first, priv->sarc\_type);@@ -4420,7 +4417,6 @@ static netdev\_tx\_t stmmac\_xmit(struct sk\_buff \*skb, struct net\_device \*dev) struct stmmac\_tx\_queue \*tx\_q; bool has\_vlan, set\_ic; int entry, first\_tx;- unsigned long flags; dma\_addr\_t des;  tx\_q = &priv->dma\_conf.tx\_queue[queue];@@ -4590,11 +4586,11 @@ static netdev\_tx\_t stmmac\_xmit(struct sk\_buff \*skb, struct net\_device \*dev) netif\_tx\_stop\_queue(netdev\_get\_tx\_queue(priv->dev, queue)); } - flags = u64\_stats\_update\_begin\_irqsave(&txq\_stats->syncp);- txq\_stats->tx\_bytes += skb->len;+ u64\_stats\_update\_begin(&txq\_stats->q\_syncp);+ u64\_stats\_add(&txq\_stats->q.tx\_bytes, skb->len); if (set\_ic)- txq\_stats->tx\_set\_ic\_bit++;- u64\_stats\_update\_end\_irqrestore(&txq\_stats->syncp, flags);+ u64\_stats\_inc(&txq\_stats->q.tx\_set\_ic\_bit);+ u64\_stats\_update\_end(&txq\_stats->q\_syncp);  if (priv->sarc\_type) stmmac\_set\_desc\_sarc(priv, first, priv->sarc\_type);@@ -4858,12 +4854,11 @@ static int stmmac\_xdp\_xmit\_xdpf(struct stmmac\_priv \*priv, int queue, set\_ic = false;  if (set\_ic) {- unsigned long flags; tx\_q->tx\_count\_frames = 0; stmmac\_set\_tx\_ic(priv, tx\_desc);- flags = u64\_stats\_update\_begin\_irqsave(&txq\_stats->syncp);- txq\_stats->tx\_set\_ic\_bit++;- u64\_stats\_update\_end\_irqrestore(&txq\_stats->syncp, flags);+ u64\_stats\_update\_begin(&txq\_stats->q\_syncp);+ u64\_stats\_inc(&txq\_stats->q.tx\_set\_ic\_bit);+ u64\_stats\_update\_end(&txq\_stats->q\_syncp); }  stmmac\_enable\_dma\_transmission(priv, priv->ioaddr);@@ -5013,7 +5008,6 @@ static void stmmac\_dispatch\_skb\_zc(struct stmmac\_priv \*priv, u32 queue, unsigned int len = xdp->data\_end - xdp->data; enum pkt\_hash\_types hash\_type; int coe = priv->hw->rx\_csum;- unsigned long flags; struct sk\_buff \*skb; u32 hash; @@ -5038,10 +5032,10 @@ static void stmmac\_dispatch\_skb\_zc(struct stmmac\_priv \*priv, u32 queue, skb\_record\_rx\_queue(skb, queue); napi\_gro\_receive(&ch->rxtx\_napi, skb); - flags = u64\_stats\_update\_begin\_irqsave(&rxq\_stats->syncp);- rxq\_stats->rx\_pkt\_n++;- rxq\_stats->rx\_bytes += len;- u64\_stats\_update\_end\_irqrestore(&rxq\_stats->syncp, flags);+ u64\_stats\_update\_begin(&rxq\_stats->napi\_syncp);+ u64\_stats\_inc(&rxq\_stats->napi.rx\_pkt\_n);+ u64\_stats\_add(&rxq\_stats->napi.rx\_bytes, len);+ u64\_stats\_update\_end(&rxq\_stats->napi\_syncp); }  static bool stmmac\_rx\_refill\_zc(struct stmmac\_priv \*priv, u32 queue, u32 budget)@@ -5123,7 +5117,6 @@ static int stmmac\_rx\_zc(struct stmmac\_priv \*priv, int limit, u32 queue) unsigned int desc\_size; struct bpf\_prog \*prog; bool failure = false;- unsigned long flags; int xdp\_status = 0; int status = 0; @@ -5278,9 +5271,9 @@ read\_again:  stmmac\_finalize\_xdp\_rx(priv, xdp\_status); - flags = u64\_stats\_update\_begin\_irqsave(&rxq\_stats->syncp);- rxq\_stats->rx\_pkt\_n += count;- u64\_stats\_update\_end\_irqrestore(&rxq\_stats->syncp, flags);+ u64\_stats\_update\_begin(&rxq\_stats->napi\_syncp);+ u64\_stats\_add(&rxq\_stats->napi.rx\_pkt\_n, count);+ u64\_stats\_update\_end(&rxq\_stats->napi\_syncp);  priv->xstats.rx\_dropped += rx\_dropped; priv->xstats.rx\_errors += rx\_errors;@@ -5318,7 +5311,6 @@ static int stmmac\_rx(struct stmmac\_priv \*priv, int limit, u32 queue) unsigned int desc\_size; struct sk\_buff \*skb = NULL; struct stmmac\_xdp\_buff ctx;- unsigned long flags; int xdp\_status = 0; int buf\_sz; @@ -5571,11 +5563,11 @@ drain\_data:  stmmac\_rx\_refill(priv, queue); - flags = u64\_stats\_update\_begin\_irqsave(&rxq\_stats->syncp);- rxq\_stats->rx\_packets += rx\_packets;- rxq\_stats->rx\_bytes += rx\_bytes;- rxq\_stats->rx\_pkt\_n += count;- u64\_stats\_update\_end\_irqrestore(&rxq\_stats->syncp, flags);+ u64\_stats\_update\_begin(&rxq\_stats->napi\_syncp);+ u64\_stats\_add(&rxq\_stats->napi.rx\_packets, rx\_packets);+ u64\_stats\_add(&rxq\_stats->napi.rx\_bytes, rx\_bytes);+ u64\_stats\_add(&rxq\_stats->napi.rx\_pkt\_n, count);+ u64\_stats\_update\_end(&rxq\_stats->napi\_syncp);  priv->xstats.rx\_dropped += rx\_dropped; priv->xstats.rx\_errors += rx\_errors;@@ -5590,13 +5582,12 @@ static int stmmac\_napi\_poll\_rx(struct napi\_struct \*napi, int budget) struct stmmac\_priv \*priv = ch->priv\_data; struct stmmac\_rxq\_stats \*rxq\_stats; u32 chan = ch->index;- unsigned long flags; int work\_done;  rxq\_stats = &priv->xstats.rxq\_stats[chan];- flags = u64\_stats\_update\_begin\_irqsave(&rxq\_stats->syncp);- rxq\_stats->napi\_poll++;- u64\_stats\_update\_end\_irqrestore(&rxq\_stats->syncp, flags);+ u64\_stats\_update\_begin(&rxq\_stats->napi\_syncp);+ u64\_stats\_inc(&rxq\_stats->napi.poll);+ u64\_stats\_update\_end(&rxq\_stats->napi\_syncp);  work\_done = stmmac\_rx(priv, budget, chan); if (work\_done < budget && napi\_complete\_done(napi, work\_done)) {@@ -5618,13 +5609,12 @@ static int stmmac\_napi\_poll\_tx(struct napi\_struct \*napi, int budget) struct stmmac\_txq\_stats \*txq\_stats; bool pending\_packets = false; u32 chan = ch->index;- unsigned long flags; int work\_done;  txq\_stats = &priv->xstats.txq\_stats[chan];- flags = u64\_stats\_update\_begin\_irqsave(&txq\_stats->syncp);- txq\_stats->napi\_poll++;- u64\_stats\_update\_end\_irqrestore(&txq\_stats->syncp, flags);+ u64\_stats\_update\_begin(&txq\_stats->napi\_syncp);+ u64\_stats\_inc(&txq\_stats->napi.poll);+ u64\_stats\_update\_end(&txq\_stats->napi\_syncp);  work\_done = stmmac\_tx\_clean(priv, budget, chan, &pending\_packets); work\_done = min(work\_done, budget);@@ -5654,17 +5644,16 @@ static int stmmac\_napi\_poll\_rxtx(struct napi\_struct \*napi, int budget) struct stmmac\_rxq\_stats \*rxq\_stats; struct stmmac\_txq\_stats \*txq\_stats; u32 chan = ch->index;- unsigned long flags;  rxq\_stats = &priv->xstats.rxq\_stats[chan];- flags = u64\_stats\_update\_begin\_irqsave(&rxq\_stats->syncp);- rxq\_stats->napi\_poll++;- u64\_stats\_update\_end\_irqrestore(&rxq\_stats->syncp, flags);+ u64\_stats\_update\_begin(&rxq\_stats->napi\_syncp);+ u64\_stats\_inc(&rxq\_stats->napi.poll);+ u64\_stats\_update\_end(&rxq\_stats->napi\_syncp);  txq\_stats = &priv->xstats.txq\_stats[chan];- flags = u64\_stats\_update\_begin\_irqsave(&txq\_stats->syncp);- txq\_stats->napi\_poll++;- u64\_stats\_update\_end\_irqrestore(&txq\_stats->syncp, flags);+ u64\_stats\_update\_begin(&txq\_stats->napi\_syncp);+ u64\_stats\_inc(&txq\_stats->napi.poll);+ u64\_stats\_update\_end(&txq\_stats->napi\_syncp);  tx\_done = stmmac\_tx\_clean(priv, budget, chan, &tx\_pending\_packets); tx\_done = min(tx\_done, budget);@@ -6990,10 +6979,13 @@ static void stmmac\_get\_stats64(struct net\_device \*dev, struct rtnl\_link\_stats64 u64 tx\_bytes;  do {- start = u64\_stats\_fetch\_begin(&txq\_stats->syncp);- tx\_packets = txq\_stats->tx\_packets;- tx\_bytes = txq\_stats->tx\_bytes;- } while (u64\_stats\_fetch\_retry(&txq\_stats->syncp, start));+ start = u64\_stats\_fetch\_begin(&txq\_stats->q\_syncp);+ tx\_bytes = u64\_stats\_read(&txq\_stats->q.tx\_bytes);+ } while (u64\_stats\_fetch\_retry(&txq\_stats->q\_syncp, start));+ do {+ start = u64\_stats\_fetch\_begin(&txq\_stats->napi\_syncp);+ tx\_packets = u64\_stats\_read(&txq\_stats->napi.tx\_packets);+ } while (u64\_stats\_fetch\_retry(&txq\_stats->napi\_syncp, start));  stats->tx\_packets += tx\_packets; stats->tx\_bytes += tx\_bytes;@@ -7005,10 +6997,10 @@ static void stmmac\_get\_stats64(struct net\_device \*dev, struct rtnl\_link\_stats64 u64 rx\_bytes;  do {- start = u64\_stats\_fetch\_begin(&rxq\_stats->syncp);- rx\_packets = rxq\_stats->rx\_packets;- rx\_bytes = rxq\_stats->rx\_bytes;- } while (u64\_stats\_fetch\_retry(&rxq\_stats->syncp, start));+ start = u64\_stats\_fetch\_begin(&rxq\_stats->napi\_syncp);+ rx\_packets = u64\_stats\_read(&rxq\_stats->napi.rx\_packets);+ rx\_bytes = u64\_stats\_read(&rxq\_stats->napi.rx\_bytes);+ } while (u64\_stats\_fetch\_retry(&rxq\_stats->napi\_syncp, start));  stats->rx\_packets += rx\_packets; stats->rx\_bytes += rx\_bytes;@@ -7402,9 +7394,16 @@ int stmmac\_dvr\_probe(struct device \*device, priv->dev = ndev;  for (i = 0; i < MTL\_MAX\_RX\_QUEUES; i++)- u64\_stats\_init(&priv->xstats.rxq\_stats[i].syncp);- for (i = 0; i < MTL\_MAX\_TX\_QUEUES; i++)- u64\_stats\_init(&priv->xstats.txq\_stats[i].syncp);+ u64\_stats\_init(&priv->xstats.rxq\_stats[i].napi\_syncp);+ for (i = 0; i < MTL\_MAX\_TX\_QUEUES; i++) {+ u64\_stats\_init(&priv->xstats.txq\_stats[i].q\_syncp);+ u64\_stats\_init(&priv->xstats.txq\_stats[i].napi\_syncp);+ }++ priv->xstats.pcpu\_stats =+ devm\_netdev\_alloc\_pcpu\_stats(device, struct stmmac\_pcpu\_stats);+ if (!priv->xstats.pcpu\_stats)+ return -ENOMEM;  stmmac\_set\_ethtool\_ops(ndev); priv->pause = pause; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 17:33:36 +0000

