
[Docs.rs](/)

* ic-stable-structures-0.6.4
  + ic-stable-structures 0.6.4
  + [Docs.rs crate page](/crate/ic-stable-structures/0.6.4 "See ic-stable-structures in docs.rs")
  + [Apache-2.0](/crate/ic-stable-structures/0.6.4)
  + Links
  + [Homepage](https://docs.rs/ic-stable-structures)
  + [Repository](https://github.com/dfinity/stable-structures)
  + [crates.io](https://crates.io/crates/ic-stable-structures "See ic-stable-structures in crates.io")
  + [Source](/crate/ic-stable-structures/0.6.4/source/ "Browse source of ic-stable-structures-0.6.4")
  + Owners
  + [ielashi](https://crates.io/users/ielashi)
  + [github:dfinity:execution](https://crates.io/teams/github%3Adfinity%3Aexecution)

  + Dependencies
  + - [canbench-rs ^0.1.1
      *normal*
      *optional*](/canbench-rs/%5E0.1.1)
    - [ic\_principal ^0.1.1
      *normal*](/ic_principal/%5E0.1.1)
    - [candid ^0.10.3
      *dev*](/candid/%5E0.10.3)
    - [hex ^0.4.3
      *dev*](/hex/%5E0.4.3)
    - [ic-cdk ^0.12.1
      *dev*](/ic-cdk/%5E0.12.1)
    - [ic-cdk-macros ^0.8.4
      *dev*](/ic-cdk-macros/%5E0.8.4)
    - [maplit ^1.0.2
      *dev*](/maplit/%5E1.0.2)
    - [proptest ^1
      *dev*](/proptest/%5E1)
    - [tempfile ^3.3.0
      *dev*](/tempfile/%5E3.3.0)
    - [test-strategy ^0.3.1
      *dev*](/test-strategy/%5E0.3.1)
  + Versions

  + [**74.67%**
    of the crate is documented](/crate/ic-stable-structures/0.6.4)
* [Go to latest version](/crate/ic-stable-structures/latest/target-redirect/x86_64-unknown-linux-gnu/ic_stable_structures/index.html "You are seeing an outdated version of the ic-stable-structures crate. Click here to go to the latest version.")
* Platform
  + [i686-pc-windows-msvc](/crate/ic-stable-structures/0.6.4/target-redirect/i686-pc-windows-msvc/ic_stable_structures/index.html)
  + [i686-unknown-linux-gnu](/crate/ic-stable-structures/0.6.4/target-redirect/i686-unknown-linux-gnu/ic_stable_structures/index.html)
  + [x86\_64-apple-darwin](/crate/ic-stable-structures/0.6.4/target-redirect/x86_64-apple-darwin/ic_stable_structures/index.html)
  + [x86\_64-pc-windows-msvc](/crate/ic-stable-structures/0.6.4/target-redirect/x86_64-pc-windows-msvc/ic_stable_structures/index.html)
  + [x86\_64-unknown-linux-gnu](/crate/ic-stable-structures/0.6.4/target-redirect/x86_64-unknown-linux-gnu/ic_stable_structures/index.html)
* [Feature flags](/crate/ic-stable-structures/0.6.4/features "Browse available feature flags of ic-stable-structures-0.6.4")

* Rust
  + [About docs.rs](/about)
  + [Privacy policy](https://foundation.rust-lang.org/policies/privacy-policy/#docs.rs)
  + [Rust website](https://www.rust-lang.org/)
  + [The Book](https://doc.rust-lang.org/book/)
  + [Standard Library API Reference](https://doc.rust-lang.org/std/)
  + [Rust by Example](https://doc.rust-lang.org/rust-by-example/)
  + [The Cargo Guide](https://doc.rust-lang.org/cargo/guide/)
  + [Clippy Documentation](https://doc.rust-lang.org/nightly/clippy)

## [ic\_stable\_structures](../ic_stable_structures/index.html)0.6.4

* [All Items](all.html)

* [Re-exports](#reexports)
* [Modules](#modules)
* [Structs](#structs)
* [Constants](#constants)
* [Traits](#traits)
* [Type Aliases](#types)
[?](../help.html "help")[Settings](../settings.html "settings")
# Crate ic\_stable\_structuresCopy item path

[source](../src/ic_stable_structures/lib.rs.html#1-234) · [−]Expand description

[![Crate Info](https://img.shields.io/crates/v/ic-stable-structures.svg)](https://crates.io/crates/ic-stable-structures)
[![Apache-2.0](https://img.shields.io/github/license/dfinity/stable-structures)](https://github.com/dfinity/stable-structures/blob/master/LICENSE)
[![API Docs](https://img.shields.io/badge/docs.rs-ic--stable--structures-blue)](https://docs.rs/ic-stable-structures)
[![Chat on the Forum](https://img.shields.io/badge/help-post%20on%20forum.dfinity.org-blue)](https://forum.dfinity.org/)

## [§](#stable-structures)Stable Structures

A collection of scalable data structures for the [Internet Computer](https://internetcomputer.org) that persist across upgrades.

Stable structures are designed to use stable memory as the backing store, allowing them to grow to gigabytes in size without the need for `pre_upgrade`/`post_upgrade` hooks.

### [§](#background)Background

The conventional approach to canister state persistence is to serialize the entire state to stable memory in the `pre_upgrade` hook and decode it back in the `post_upgrade` hook.
This approach is easy to implement and works well for relatively small datasets.
Unfortunately, it does not scale well and can render a canister non-upgradable.

This library aims to simplify managing data structures directly in stable memory.
For more information about the philosophy behind the library, see [Roman’s tutorial on stable structures](https://mmapped.blog/posts/14-stable-structures.html).

### [§](#available-data-structures)Available Data Structures

* [BTreeMap](btreemap/struct.BTreeMap.html "struct ic_stable_structures::btreemap::BTreeMap"): A Key-Value store
* [Vec](vec/struct.Vec.html "struct ic_stable_structures::vec::Vec"): A growable array
* [Log](log/struct.Log.html "struct ic_stable_structures::log::Log"): An append-only list of variable-size entries
* [Cell](cell/struct.Cell.html "struct ic_stable_structures::cell::Cell"): A serializable value
* [MinHeap](min_heap/struct.MinHeap.html "struct ic_stable_structures::min_heap::MinHeap"): A priority queue.

### [§](#tutorials)Tutorials

[Schema Upgrades](./docs/schema-upgrades.md)

### [§](#how-it-works)How it Works

Stable structures are able to work directly in stable memory because each data structure manages
its own memory.
When initializing a stable structure, a memory is provided that the data structure can use to store its data.

Here’s a basic example:

```
use ic_stable_structures::{BTreeMap, DefaultMemoryImpl};
let mut map: BTreeMap<u64, u64, _> = BTreeMap::init(DefaultMemoryImpl::default());

map.insert(1, 2);
assert_eq!(map.get(&1), Some(2));
```

Memories are abstracted with the [Memory](trait.Memory.html "trait ic_stable_structures::Memory") trait, and stable structures can work with any storage
backend that implements this trait.
This includes stable memory, a vector ([VectorMemory](vec_mem/type.VectorMemory.html "type ic_stable_structures::vec_mem::VectorMemory")), or even a flat file ([FileMemory](file_mem/struct.FileMemory.html "struct ic_stable_structures::file_mem::FileMemory")).

The example above initializes a [BTreeMap](btreemap/struct.BTreeMap.html "struct ic_stable_structures::btreemap::BTreeMap") with a [DefaultMemoryImpl](type.DefaultMemoryImpl.html "type ic_stable_structures::DefaultMemoryImpl"), which maps to stable memory when used in a canister and to a [VectorMemory](vec_mem/type.VectorMemory.html "type ic_stable_structures::vec_mem::VectorMemory") otherwise.

Note that **stable structures cannot share memories.**
Each memory must belong to only one stable structure.
For example, this fails when run in a canister:

```
use ic_stable_structures::{BTreeMap, DefaultMemoryImpl};
let mut map_1: BTreeMap<u64, u64, _> = BTreeMap::init(DefaultMemoryImpl::default());
let mut map_2: BTreeMap<u64, u64, _> = BTreeMap::init(DefaultMemoryImpl::default());

map_1.insert(1, 2);
map_2.insert(1, 3);
assert_eq!(map_1.get(&1), Some(2)); // This assertion fails.
```

It fails because both `map_1` and `map_2` are using the same stable memory under the hood, and so changes in `map_1` end up changing or corrupting `map_2`.

To address this issue, we make use of the [MemoryManager](memory_manager/struct.MemoryManager.html "struct ic_stable_structures::memory_manager::MemoryManager"), which takes a single memory and creates up to 255 virtual memories for our disposal.
Here’s the above failing example, but fixed by using the [MemoryManager](memory_manager/struct.MemoryManager.html "struct ic_stable_structures::memory_manager::MemoryManager"):

```
use ic_stable_structures::{
   memory_manager::{MemoryId, MemoryManager},
   BTreeMap, DefaultMemoryImpl,
};
let mem_mgr = MemoryManager::init(DefaultMemoryImpl::default());
let mut map_1: BTreeMap<u64, u64, _> = BTreeMap::init(mem_mgr.get(MemoryId::new(0)));
let mut map_2: BTreeMap<u64, u64, _> = BTreeMap::init(mem_mgr.get(MemoryId::new(1)));

map_1.insert(1, 2);
map_2.insert(1, 3);
assert_eq!(map_1.get(&1), Some(2)); // Succeeds, as expected.
```
### [§](#example-canister)Example Canister

Here’s a fully working canister example that ties everything together.

Dependencies:

```
[dependencies]
ic-cdk = "0.6.8"
ic-cdk-macros = "0.6.8"
ic-stable-structures = "0.5.6"

```

Code:

```
use ic_stable_structures::memory_manager::{MemoryId, MemoryManager, VirtualMemory};
use ic_stable_structures::{DefaultMemoryImpl, StableBTreeMap};
use std::cell::RefCell;

type Memory = VirtualMemory<DefaultMemoryImpl>;

thread_local! {
    // The memory manager is used for simulating multiple memories. Given a `MemoryId` it can
    // return a memory that can be used by stable structures.
    static MEMORY_MANAGER: RefCell<MemoryManager<DefaultMemoryImpl>> =
        RefCell::new(MemoryManager::init(DefaultMemoryImpl::default()));

    // Initialize a `StableBTreeMap` with `MemoryId(0)`.
    static MAP: RefCell<StableBTreeMap<u128, u128, Memory>> = RefCell::new(
        StableBTreeMap::init(
            MEMORY_MANAGER.with(|m| m.borrow().get(MemoryId::new(0))),
        )
    );
}

// Retrieves the value associated with the given key if it exists.
#[ic_cdk_macros::query]
fn get(key: u128) -> Option<u128> {
    MAP.with(|p| p.borrow().get(&key))
}

// Inserts an entry into the map and returns the previous value of the key if it exists.
#[ic_cdk_macros::update]
fn insert(key: u128, value: u128) -> Option<u128> {
    MAP.with(|p| p.borrow_mut().insert(key, value))
}
```
#### [§](#more-examples)More Examples

* [Basic Example](https://github.com/dfinity/stable-structures/tree/main/examples/src/basic_example) (the one above)
* [Quickstart Example](https://github.com/dfinity/stable-structures/tree/main/examples/src/quick_start): Ideal as a template when developing a new canister
* [Custom Types Example](https://github.com/dfinity/stable-structures/tree/main/examples/src/custom_types_example): Showcases storing your own custom types

### [§](#combined-persistence)Combined Persistence

If your project exclusively relies on stable structures, the memory can expand in size without the requirement of `pre_upgrade`/`post_upgrade` hooks.

However, it’s important to note that if you also intend to perform serialization/deserialization of the heap data, utilizing the memory manager becomes necessary. To effectively combine both approaches, refer to the [Quickstart Example](https://github.com/dfinity/stable-structures/tree/main/examples/src/quick_start) for guidance.

## Re-exports[§](#reexports)

* `pub use cell::[Cell](cell/struct.Cell.html "struct ic_stable_structures::cell::Cell") as StableCell;`
* `pub use cell::[Cell](cell/struct.Cell.html "struct ic_stable_structures::cell::Cell");`
* `pub use log::[Log](log/struct.Log.html "struct ic_stable_structures::log::Log") as StableLog;`
* `pub use log::[Log](log/struct.Log.html "struct ic_stable_structures::log::Log");`
* `pub use min_heap::[MinHeap](min_heap/struct.MinHeap.html "struct ic_stable_structures::min_heap::MinHeap");`
* `pub use min_heap::[MinHeap](min_heap/struct.MinHeap.html "struct ic_stable_structures::min_heap::MinHeap") as StableMinHeap;`
* `pub use vec::[Vec](vec/struct.Vec.html "struct ic_stable_structures::vec::Vec") as StableVec;`
* `pub use vec::[Vec](vec/struct.Vec.html "struct ic_stable_structures::vec::Vec");`
* `pub use btreemap::[BTreeMap](btreemap/struct.BTreeMap.html "struct ic_stable_structures::btreemap::BTreeMap");`
* `pub use btreemap::[BTreeMap](btreemap/struct.BTreeMap.html "struct ic_stable_structures::btreemap::BTreeMap") as StableBTreeMap;`
* `pub use file_mem::[FileMemory](file_mem/struct.FileMemory.html "struct ic_stable_structures::file_mem::FileMemory");`
* `pub use storable::[Storable](storable/trait.Storable.html "trait ic_stable_structures::storable::Storable");`
* `pub use vec_mem::[VectorMemory](vec_mem/type.VectorMemory.html "type ic_stable_structures::vec_mem::VectorMemory");`

## Modules[§](#modules)

* [btreemap](btreemap/index.html "mod ic_stable_structures::btreemap")This module implements a key/value store based on a B-Tree
  in stable memory.
* [cell](cell/index.html "mod ic_stable_structures::cell")A serializable value stored in the stable memory.
* [file\_mem](file_mem/index.html "mod ic_stable_structures::file_mem")
* [log](log/index.html "mod ic_stable_structures::log")An append-only list data structure, also known as log.
* [memory\_manager](memory_manager/index.html "mod ic_stable_structures::memory_manager")A module for simulating multiple memories within a single memory.
* [min\_heap](min_heap/index.html "mod ic_stable_structures::min_heap")
* [reader](reader/index.html "mod ic_stable_structures::reader")
* [storable](storable/index.html "mod ic_stable_structures::storable")
* [vec](vec/index.html "mod ic_stable_structures::vec")This module implements a growable array in stable memory.
* [vec\_mem](vec_mem/index.html "mod ic_stable_structures::vec_mem")
* [writer](writer/index.html "mod ic_stable_structures::writer")

## Structs[§](#structs)

* [GrowFailed](struct.GrowFailed.html "struct ic_stable_structures::GrowFailed")
* [RestrictedMemory](struct.RestrictedMemory.html "struct ic_stable_structures::RestrictedMemory")RestrictedMemory creates a limited view of another memory. This
  allows one to divide the main memory into non-intersecting ranges
  and use different layouts in each region.

## Constants[§](#constants)

* [MAX\_PAGES](constant.MAX_PAGES.html "constant ic_stable_structures::MAX_PAGES")The maximum number of stable memory pages a canister can address.

## Traits[§](#traits)

* [Memory](trait.Memory.html "trait ic_stable_structures::Memory")

## Type Aliases[§](#types)

* [DefaultMemoryImpl](type.DefaultMemoryImpl.html "type ic_stable_structures::DefaultMemoryImpl")
