

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=84a5feebba10354c683983f5f1372a144225e4c2)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=84a5feebba10354c683983f5f1372a144225e4c2)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=84a5feebba10354c683983f5f1372a144225e4c2)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=84a5feebba10354c683983f5f1372a144225e4c2)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Frederic Weisbecker <frederic@kernel.org> | 2024-10-10 18:36:09 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-10-17 15:24:30 +0200 |
| commit | [84a5feebba10354c683983f5f1372a144225e4c2](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=84a5feebba10354c683983f5f1372a144225e4c2) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=84a5feebba10354c683983f5f1372a144225e4c2)) | |
| tree | [21256d7adb99174daa47862669f5a2a807ef9abe](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=84a5feebba10354c683983f5f1372a144225e4c2) | |
| parent | [174caf7a16d69b1cf9740592d99d6fc7f657fff7](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=174caf7a16d69b1cf9740592d99d6fc7f657fff7) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=84a5feebba10354c683983f5f1372a144225e4c2&id2=174caf7a16d69b1cf9740592d99d6fc7f657fff7)) | |
| download | [linux-84a5feebba10354c683983f5f1372a144225e4c2.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-84a5feebba10354c683983f5f1372a144225e4c2.tar.gz) | |

rcu/nocb: Fix rcuog wake-up from offline softirq[ Upstream commit f7345ccc62a4b880cf76458db5f320725f28e400 ]
After a CPU has set itself offline and before it eventually calls
rcutree\_report\_cpu\_dead(), there are still opportunities for callbacks
to be enqueued, for example from a softirq. When that happens on NOCB,
the rcuog wake-up is deferred through an IPI to an online CPU in order
not to call into the scheduler and risk arming the RT-bandwidth after
hrtimers have been migrated out and disabled.
But performing a synchronized IPI from a softirq is buggy as reported in
the following scenario:
WARNING: CPU: 1 PID: 26 at kernel/smp.c:633 smp\_call\_function\_single
Modules linked in: rcutorture torture
CPU: 1 UID: 0 PID: 26 Comm: migration/1 Not tainted 6.11.0-rc1-00012-g9139f93209d1 #1
Stopper: multi\_cpu\_stop+0x0/0x320 <- \_\_stop\_cpus+0xd0/0x120
RIP: 0010:smp\_call\_function\_single
<IRQ>
swake\_up\_one\_online
\_\_call\_rcu\_nocb\_wake
\_\_call\_rcu\_common
? rcu\_torture\_one\_read
call\_timer\_fn
\_\_run\_timers
run\_timer\_softirq
handle\_softirqs
irq\_exit\_rcu
? tick\_handle\_periodic
sysvec\_apic\_timer\_interrupt
</IRQ>
Fix this with forcing deferred rcuog wake up through the NOCB timer when
the CPU is offline. The actual wake up will happen from
rcutree\_report\_cpu\_dead().
Reported-by: kernel test robot <oliver.sang@intel.com>
Closes: https://lore.kernel.org/oe-lkp/202409231644.4c55582d-lkp@intel.com
Fixes: 9139f93209d1 ("rcu/nocb: Fix RT throttling hrtimer armed from offline CPU")
Reviewed-by: "Joel Fernandes (Google)" <joel@joelfernandes.org>
Signed-off-by: Frederic Weisbecker <frederic@kernel.org>
Signed-off-by: Neeraj Upadhyay <neeraj.upadhyay@kernel.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=84a5feebba10354c683983f5f1372a144225e4c2)

| -rw-r--r-- | [kernel/rcu/tree\_nocb.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/rcu/tree_nocb.h?id=84a5feebba10354c683983f5f1372a144225e4c2) | 8 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 7 insertions, 1 deletions

| diff --git a/kernel/rcu/tree\_nocb.h b/kernel/rcu/tree\_nocb.hindex 7a0bce3f784df1..8993b2322be2b0 100644--- a/[kernel/rcu/tree\_nocb.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/rcu/tree_nocb.h?id=174caf7a16d69b1cf9740592d99d6fc7f657fff7)+++ b/[kernel/rcu/tree\_nocb.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/rcu/tree_nocb.h?id=84a5feebba10354c683983f5f1372a144225e4c2)@@ -568,13 +568,19 @@ static void \_\_call\_rcu\_nocb\_wake(struct rcu\_data \*rdp, bool was\_alldone, rcu\_nocb\_unlock(rdp); wake\_nocb\_gp\_defer(rdp, RCU\_NOCB\_WAKE\_LAZY, TPS("WakeLazy"));- } else if (!irqs\_disabled\_flags(flags)) {+ } else if (!irqs\_disabled\_flags(flags) && cpu\_online(rdp->cpu)) { /\* ... if queue was empty ... \*/ rcu\_nocb\_unlock(rdp); wake\_nocb\_gp(rdp, false); trace\_rcu\_nocb\_wake(rcu\_state.name, rdp->cpu, TPS("WakeEmpty")); } else {+ /\*+ \* Don't do the wake-up upfront on fragile paths.+ \* Also offline CPUs can't call swake\_up\_one\_online() from+ \* (soft-)IRQs. Rely on the final deferred wake-up from+ \* rcutree\_report\_cpu\_dead()+ \*/ rcu\_nocb\_unlock(rdp); wake\_nocb\_gp\_defer(rdp, RCU\_NOCB\_WAKE, TPS("WakeEmptyIsDeferred")); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 17:45:56 +0000

