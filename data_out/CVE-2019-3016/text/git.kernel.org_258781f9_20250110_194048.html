

| [cgit logo](/) | [index](/) : [kernel/git/torvalds/linux.git](/pub/scm/linux/kernel/git/torvalds/linux.git/) | for-next master vsnprintf |
| --- | --- | --- |
| Linux kernel source tree | Linus Torvalds |

| [about](/pub/scm/linux/kernel/git/torvalds/linux.git/about/)[summary](/pub/scm/linux/kernel/git/torvalds/linux.git/)[refs](/pub/scm/linux/kernel/git/torvalds/linux.git/refs/?id=917248144db5d7320655dbb41d3af0b8a0f3d589)[log](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)[tree](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=917248144db5d7320655dbb41d3af0b8a0f3d589)[commit](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=917248144db5d7320655dbb41d3af0b8a0f3d589)[diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=917248144db5d7320655dbb41d3af0b8a0f3d589)[stats](/pub/scm/linux/kernel/git/torvalds/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Boris Ostrovsky <boris.ostrovsky@oracle.com> | 2019-12-05 01:30:51 +0000 |
| --- | --- | --- |
| committer | Paolo Bonzini <pbonzini@redhat.com> | 2020-01-30 18:45:55 +0100 |
| commit | [917248144db5d7320655dbb41d3af0b8a0f3d589](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=917248144db5d7320655dbb41d3af0b8a0f3d589) ([patch](/pub/scm/linux/kernel/git/torvalds/linux.git/patch/?id=917248144db5d7320655dbb41d3af0b8a0f3d589)) | |
| tree | [4c865f9aeb61137847ce9d283bc33febded17714](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=917248144db5d7320655dbb41d3af0b8a0f3d589) | |
| parent | [1eff70a9abd46f175defafd29bc17ad456f398a7](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=1eff70a9abd46f175defafd29bc17ad456f398a7) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=917248144db5d7320655dbb41d3af0b8a0f3d589&id2=1eff70a9abd46f175defafd29bc17ad456f398a7)) | |
| download | [linux-917248144db5d7320655dbb41d3af0b8a0f3d589.tar.gz](/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-917248144db5d7320655dbb41d3af0b8a0f3d589.tar.gz) | |

x86/kvm: Cache gfn to pfn translation\_\_kvm\_map\_gfn()'s call to gfn\_to\_pfn\_memslot() is
\* relatively expensive
\* in certain cases (such as when done from atomic context) cannot be called
Stashing gfn-to-pfn mapping should help with both cases.
This is part of CVE-2019-3016.
Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
Reviewed-by: Joao Martins <joao.m.martins@oracle.com>
Cc: stable@vger.kernel.org
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
[Diffstat](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=917248144db5d7320655dbb41d3af0b8a0f3d589)

| -rw-r--r-- | [arch/x86/include/asm/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/include/asm/kvm_host.h?id=917248144db5d7320655dbb41d3af0b8a0f3d589) | 1 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [arch/x86/kvm/x86.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kvm/x86.c?id=917248144db5d7320655dbb41d3af0b8a0f3d589) | 10 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/linux/kvm_host.h?id=917248144db5d7320655dbb41d3af0b8a0f3d589) | 7 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/kvm\_types.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/linux/kvm_types.h?id=917248144db5d7320655dbb41d3af0b8a0f3d589) | 9 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [virt/kvm/kvm\_main.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/virt/kvm/kvm_main.c?id=917248144db5d7320655dbb41d3af0b8a0f3d589) | 98 | |  |  |  | | --- | --- | --- | |

5 files changed, 103 insertions, 22 deletions

| diff --git a/arch/x86/include/asm/kvm\_host.h b/arch/x86/include/asm/kvm\_host.hindex b79cd6aa407563..f48a306e1d665a 100644--- a/[arch/x86/include/asm/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/include/asm/kvm_host.h?id=1eff70a9abd46f175defafd29bc17ad456f398a7)+++ b/[arch/x86/include/asm/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/include/asm/kvm_host.h?id=917248144db5d7320655dbb41d3af0b8a0f3d589)@@ -689,6 +689,7 @@ struct kvm\_vcpu\_arch { u64 last\_steal; struct gfn\_to\_hva\_cache stime; struct kvm\_steal\_time steal;+ struct gfn\_to\_pfn\_cache cache; } st;  u64 tsc\_offset;diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.cindex 8c9369151e9f3f..0795bc876abcca 100644--- a/[arch/x86/kvm/x86.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/x86.c?id=1eff70a9abd46f175defafd29bc17ad456f398a7)+++ b/[arch/x86/kvm/x86.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/x86.c?id=917248144db5d7320655dbb41d3af0b8a0f3d589)@@ -9088,6 +9088,9 @@ static void fx\_init(struct kvm\_vcpu \*vcpu) void kvm\_arch\_vcpu\_free(struct kvm\_vcpu \*vcpu) { void \*wbinvd\_dirty\_mask = vcpu->arch.wbinvd\_dirty\_mask;+ struct gfn\_to\_pfn\_cache \*cache = &vcpu->arch.st.cache;++ kvm\_release\_pfn(cache->pfn, cache->dirty, cache);  kvmclock\_reset(vcpu); @@ -9761,11 +9764,18 @@ out\_free:  void kvm\_arch\_memslots\_updated(struct kvm \*kvm, u64 gen) {+ struct kvm\_vcpu \*vcpu;+ int i;+ /\* \* memslots->generation has been incremented. \* mmio generation may have reached its maximum value. \*/ kvm\_mmu\_invalidate\_mmio\_sptes(kvm, gen);++ /\* Force re-initialization of steal\_time cache \*/+ kvm\_for\_each\_vcpu(i, vcpu, kvm)+ kvm\_vcpu\_kick(vcpu); }  int kvm\_arch\_prepare\_memory\_region(struct kvm \*kvm,diff --git a/include/linux/kvm\_host.h b/include/linux/kvm\_host.hindex 0cb78f55b92c93..71cb9cc105f0a5 100644--- a/[include/linux/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/kvm_host.h?id=1eff70a9abd46f175defafd29bc17ad456f398a7)+++ b/[include/linux/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/kvm_host.h?id=917248144db5d7320655dbb41d3af0b8a0f3d589)@@ -723,6 +723,7 @@ void kvm\_set\_pfn\_dirty(kvm\_pfn\_t pfn); void kvm\_set\_pfn\_accessed(kvm\_pfn\_t pfn); void kvm\_get\_pfn(kvm\_pfn\_t pfn); +void kvm\_release\_pfn(kvm\_pfn\_t pfn, bool dirty, struct gfn\_to\_pfn\_cache \*cache); int kvm\_read\_guest\_page(struct kvm \*kvm, gfn\_t gfn, void \*data, int offset, int len); int kvm\_read\_guest\_atomic(struct kvm \*kvm, gpa\_t gpa, void \*data,@@ -775,10 +776,12 @@ struct kvm\_memory\_slot \*kvm\_vcpu\_gfn\_to\_memslot(struct kvm\_vcpu \*vcpu, gfn\_t gfn kvm\_pfn\_t kvm\_vcpu\_gfn\_to\_pfn\_atomic(struct kvm\_vcpu \*vcpu, gfn\_t gfn); kvm\_pfn\_t kvm\_vcpu\_gfn\_to\_pfn(struct kvm\_vcpu \*vcpu, gfn\_t gfn); int kvm\_vcpu\_map(struct kvm\_vcpu \*vcpu, gpa\_t gpa, struct kvm\_host\_map \*map);-int kvm\_map\_gfn(struct kvm\_vcpu \*vcpu, gfn\_t gfn, struct kvm\_host\_map \*map);+int kvm\_map\_gfn(struct kvm\_vcpu \*vcpu, gfn\_t gfn, struct kvm\_host\_map \*map,+ struct gfn\_to\_pfn\_cache \*cache, bool atomic); struct page \*kvm\_vcpu\_gfn\_to\_page(struct kvm\_vcpu \*vcpu, gfn\_t gfn); void kvm\_vcpu\_unmap(struct kvm\_vcpu \*vcpu, struct kvm\_host\_map \*map, bool dirty);-int kvm\_unmap\_gfn(struct kvm\_vcpu \*vcpu, struct kvm\_host\_map \*map, bool dirty);+int kvm\_unmap\_gfn(struct kvm\_vcpu \*vcpu, struct kvm\_host\_map \*map,+ struct gfn\_to\_pfn\_cache \*cache, bool dirty, bool atomic); unsigned long kvm\_vcpu\_gfn\_to\_hva(struct kvm\_vcpu \*vcpu, gfn\_t gfn); unsigned long kvm\_vcpu\_gfn\_to\_hva\_prot(struct kvm\_vcpu \*vcpu, gfn\_t gfn, bool \*writable); int kvm\_vcpu\_read\_guest\_page(struct kvm\_vcpu \*vcpu, gfn\_t gfn, void \*data, int offset,diff --git a/include/linux/kvm\_types.h b/include/linux/kvm\_types.hindex 1c88e69db3d9dc..68e84cf42a3f94 100644--- a/[include/linux/kvm\_types.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/kvm_types.h?id=1eff70a9abd46f175defafd29bc17ad456f398a7)+++ b/[include/linux/kvm\_types.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/kvm_types.h?id=917248144db5d7320655dbb41d3af0b8a0f3d589)@@ -18,7 +18,7 @@ struct kvm\_memslots;  enum kvm\_mr\_change; -#include <asm/types.h>+#include <linux/types.h>  /\* \* Address types:@@ -51,4 +51,11 @@ struct gfn\_to\_hva\_cache { struct kvm\_memory\_slot \*memslot; }; +struct gfn\_to\_pfn\_cache {+ u64 generation;+ gfn\_t gfn;+ kvm\_pfn\_t pfn;+ bool dirty;+};+ #endif /\* \_\_KVM\_TYPES\_H\_\_ \*/diff --git a/virt/kvm/kvm\_main.c b/virt/kvm/kvm\_main.cindex 9ef58a233a7c38..67eb302a7240ac 100644--- a/[virt/kvm/kvm\_main.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/virt/kvm/kvm_main.c?id=1eff70a9abd46f175defafd29bc17ad456f398a7)+++ b/[virt/kvm/kvm\_main.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/virt/kvm/kvm_main.c?id=917248144db5d7320655dbb41d3af0b8a0f3d589)@@ -1821,27 +1821,72 @@ struct page \*gfn\_to\_page(struct kvm \*kvm, gfn\_t gfn) } EXPORT\_SYMBOL\_GPL(gfn\_to\_page); +void kvm\_release\_pfn(kvm\_pfn\_t pfn, bool dirty, struct gfn\_to\_pfn\_cache \*cache)+{+ if (pfn == 0)+ return;++ if (cache)+ cache->pfn = cache->gfn = 0;++ if (dirty)+ kvm\_release\_pfn\_dirty(pfn);+ else+ kvm\_release\_pfn\_clean(pfn);+}++static void kvm\_cache\_gfn\_to\_pfn(struct kvm\_memory\_slot \*slot, gfn\_t gfn,+ struct gfn\_to\_pfn\_cache \*cache, u64 gen)+{+ kvm\_release\_pfn(cache->pfn, cache->dirty, cache);++ cache->pfn = gfn\_to\_pfn\_memslot(slot, gfn);+ cache->gfn = gfn;+ cache->dirty = false;+ cache->generation = gen;+}+ static int \_\_kvm\_map\_gfn(struct kvm\_memslots \*slots, gfn\_t gfn,- struct kvm\_host\_map \*map)+ struct kvm\_host\_map \*map,+ struct gfn\_to\_pfn\_cache \*cache,+ bool atomic) { kvm\_pfn\_t pfn; void \*hva = NULL; struct page \*page = KVM\_UNMAPPED\_PAGE; struct kvm\_memory\_slot \*slot = \_\_gfn\_to\_memslot(slots, gfn);+ u64 gen = slots->generation;  if (!map) return -EINVAL; - pfn = gfn\_to\_pfn\_memslot(slot, gfn);+ if (cache) {+ if (!cache->pfn || cache->gfn != gfn ||+ cache->generation != gen) {+ if (atomic)+ return -EAGAIN;+ kvm\_cache\_gfn\_to\_pfn(slot, gfn, cache, gen);+ }+ pfn = cache->pfn;+ } else {+ if (atomic)+ return -EAGAIN;+ pfn = gfn\_to\_pfn\_memslot(slot, gfn);+ } if (is\_error\_noslot\_pfn(pfn)) return -EINVAL;  if (pfn\_valid(pfn)) { page = pfn\_to\_page(pfn);- hva = kmap(page);+ if (atomic)+ hva = kmap\_atomic(page);+ else+ hva = kmap(page); #ifdef CONFIG\_HAS\_IOMEM- } else {+ } else if (!atomic) { hva = memremap(pfn\_to\_hpa(pfn), PAGE\_SIZE, MEMREMAP\_WB);+ } else {+ return -EINVAL; #endif } @@ -1856,20 +1901,25 @@ static int \_\_kvm\_map\_gfn(struct kvm\_memslots \*slots, gfn\_t gfn, return 0; } -int kvm\_map\_gfn(struct kvm\_vcpu \*vcpu, gfn\_t gfn, struct kvm\_host\_map \*map)+int kvm\_map\_gfn(struct kvm\_vcpu \*vcpu, gfn\_t gfn, struct kvm\_host\_map \*map,+ struct gfn\_to\_pfn\_cache \*cache, bool atomic) {- return \_\_kvm\_map\_gfn(kvm\_memslots(vcpu->kvm), gfn, map);+ return \_\_kvm\_map\_gfn(kvm\_memslots(vcpu->kvm), gfn, map,+ cache, atomic); } EXPORT\_SYMBOL\_GPL(kvm\_map\_gfn);  int kvm\_vcpu\_map(struct kvm\_vcpu \*vcpu, gfn\_t gfn, struct kvm\_host\_map \*map) {- return \_\_kvm\_map\_gfn(kvm\_vcpu\_memslots(vcpu), gfn, map);+ return \_\_kvm\_map\_gfn(kvm\_vcpu\_memslots(vcpu), gfn, map,+ NULL, false); } EXPORT\_SYMBOL\_GPL(kvm\_vcpu\_map);  static void \_\_kvm\_unmap\_gfn(struct kvm\_memory\_slot \*memslot,- struct kvm\_host\_map \*map, bool dirty)+ struct kvm\_host\_map \*map,+ struct gfn\_to\_pfn\_cache \*cache,+ bool dirty, bool atomic) { if (!map) return;@@ -1877,34 +1927,44 @@ static void \_\_kvm\_unmap\_gfn(struct kvm\_memory\_slot \*memslot, if (!map->hva) return; - if (map->page != KVM\_UNMAPPED\_PAGE)- kunmap(map->page);+ if (map->page != KVM\_UNMAPPED\_PAGE) {+ if (atomic)+ kunmap\_atomic(map->hva);+ else+ kunmap(map->page);+ } #ifdef CONFIG\_HAS\_IOMEM- else+ else if (!atomic) memunmap(map->hva);+ else+ WARN\_ONCE(1, "Unexpected unmapping in atomic context"); #endif - if (dirty) {+ if (dirty) mark\_page\_dirty\_in\_slot(memslot, map->gfn);- kvm\_release\_pfn\_dirty(map->pfn);- } else {- kvm\_release\_pfn\_clean(map->pfn);- }++ if (cache)+ cache->dirty |= dirty;+ else+ kvm\_release\_pfn(map->pfn, dirty, NULL);  map->hva = NULL; map->page = NULL; } -int kvm\_unmap\_gfn(struct kvm\_vcpu \*vcpu, struct kvm\_host\_map \*map, bool dirty)+int kvm\_unmap\_gfn(struct kvm\_vcpu \*vcpu, struct kvm\_host\_map \*map, + struct gfn\_to\_pfn\_cache \*cache, bool dirty, bool atomic) {- \_\_kvm\_unmap\_gfn(gfn\_to\_memslot(vcpu->kvm, map->gfn), map, dirty);+ \_\_kvm\_unmap\_gfn(gfn\_to\_memslot(vcpu->kvm, map->gfn), map,+ cache, dirty, atomic); return 0; } EXPORT\_SYMBOL\_GPL(kvm\_unmap\_gfn);  void kvm\_vcpu\_unmap(struct kvm\_vcpu \*vcpu, struct kvm\_host\_map \*map, bool dirty) {- \_\_kvm\_unmap\_gfn(kvm\_vcpu\_gfn\_to\_memslot(vcpu, map->gfn), map, dirty);+ \_\_kvm\_unmap\_gfn(kvm\_vcpu\_gfn\_to\_memslot(vcpu, map->gfn), map, NULL,+ dirty, false); } EXPORT\_SYMBOL\_GPL(kvm\_vcpu\_unmap); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 19:39:25 +0000

