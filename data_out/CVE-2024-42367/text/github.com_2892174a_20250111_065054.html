
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Faio-libs%2Faiohttp%2Fblob%2Fe0ff5246e1d29b7710ab1a2bbc972b48169f1c05%2Faiohttp%2Fweb_fileresponse.py)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Faio-libs%2Faiohttp%2Fblob%2Fe0ff5246e1d29b7710ab1a2bbc972b48169f1c05%2Faiohttp%2Fweb_fileresponse.py)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=aio-libs%2Faiohttp)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[aio-libs](/aio-libs)
/
**[aiohttp](/aio-libs/aiohttp)**
Public

* [Notifications](/login?return_to=%2Faio-libs%2Faiohttp) You must be signed in to change notification settings
* [Fork
  2k](/login?return_to=%2Faio-libs%2Faiohttp)
* [Star
   15.3k](/login?return_to=%2Faio-libs%2Faiohttp)

* [Code](/aio-libs/aiohttp)
* [Issues
  188](/aio-libs/aiohttp/issues)
* [Pull requests
  60](/aio-libs/aiohttp/pulls)
* [Discussions](/aio-libs/aiohttp/discussions)
* [Actions](/aio-libs/aiohttp/actions)
* [Security](/aio-libs/aiohttp/security)
* [Insights](/aio-libs/aiohttp/pulse)

Additional navigation options

* [Code](/aio-libs/aiohttp)
* [Issues](/aio-libs/aiohttp/issues)
* [Pull requests](/aio-libs/aiohttp/pulls)
* [Discussions](/aio-libs/aiohttp/discussions)
* [Actions](/aio-libs/aiohttp/actions)
* [Security](/aio-libs/aiohttp/security)
* [Insights](/aio-libs/aiohttp/pulse)

## Files

 e0ff524
## Breadcrumbs

1. [aiohttp](/aio-libs/aiohttp/tree/e0ff5246e1d29b7710ab1a2bbc972b48169f1c05)
2. /[aiohttp](/aio-libs/aiohttp/tree/e0ff5246e1d29b7710ab1a2bbc972b48169f1c05/aiohttp)
/
# web\_fileresponse.py

Copy path Blame  Blame
## Latest commit

## History

[History](/aio-libs/aiohttp/commits/e0ff5246e1d29b7710ab1a2bbc972b48169f1c05/aiohttp/web_fileresponse.py)349 lines (291 loc) · 13.1 KB e0ff524
## Breadcrumbs

1. [aiohttp](/aio-libs/aiohttp/tree/e0ff5246e1d29b7710ab1a2bbc972b48169f1c05)
2. /[aiohttp](/aio-libs/aiohttp/tree/e0ff5246e1d29b7710ab1a2bbc972b48169f1c05/aiohttp)
/
# web\_fileresponse.py

Top
## File metadata and controls

* Code
* Blame

349 lines (291 loc) · 13.1 KB[Raw](https://github.com/aio-libs/aiohttp/raw/e0ff5246e1d29b7710ab1a2bbc972b48169f1c05/aiohttp/web_fileresponse.py)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349import asyncioimport osimport pathlibimport sysfrom contextlib import suppressfrom mimetypes import MimeTypesfrom stat import S\_ISREGfrom types import MappingProxyTypefrom typing import ( IO, TYPE\_CHECKING, Any, Awaitable, Callable, Final, Optional, Tuple, cast,)
from . import hdrsfrom .abc import AbstractStreamWriterfrom .helpers import ETAG\_ANY, ETag, must\_be\_empty\_bodyfrom .typedefs import LooseHeaders, PathLikefrom .web\_exceptions import ( HTTPForbidden, HTTPNotFound, HTTPNotModified, HTTPPartialContent, HTTPPreconditionFailed, HTTPRequestRangeNotSatisfiable,)from .web\_response import StreamResponse
\_\_all\_\_ = ("FileResponse",)
if TYPE\_CHECKING: from .web\_request import BaseRequest
\_T\_OnChunkSent = Optional[Callable[[bytes], Awaitable[None]]]
NOSENDFILE: Final[bool] = bool(os.environ.get("AIOHTTP\_NOSENDFILE"))
CONTENT\_TYPES: Final[MimeTypes] = MimeTypes()
if sys.version\_info < (3, 9): CONTENT\_TYPES.encodings\_map[".br"] = "br"
# File extension to IANA encodings map that will be checked in the order defined.ENCODING\_EXTENSIONS = MappingProxyType( {ext: CONTENT\_TYPES.encodings\_map[ext] for ext in (".br", ".gz")})
FALLBACK\_CONTENT\_TYPE = "application/octet-stream"
# Provide additional MIME type/extension pairs to be recognized.# https://en.wikipedia.org/wiki/List\_of\_archive\_formats#Compression\_onlyADDITIONAL\_CONTENT\_TYPES = MappingProxyType( { "application/gzip": ".gz", "application/x-brotli": ".br", "application/x-bzip2": ".bz2", "application/x-compress": ".Z", "application/x-xz": ".xz", })
# Add custom pairs and clear the encodings map so guess\_type ignores them.CONTENT\_TYPES.encodings\_map.clear()for content\_type, extension in ADDITIONAL\_CONTENT\_TYPES.items(): CONTENT\_TYPES.add\_type(content\_type, extension) # type: ignore[attr-defined]
class FileResponse(StreamResponse): """A response object can be used to send files."""
 def \_\_init\_\_( self, path: PathLike, chunk\_size: int = 256 \* 1024, status: int = 200, reason: Optional[str] = None, headers: Optional[LooseHeaders] = None, ) -> None: super().\_\_init\_\_(status=status, reason=reason, headers=headers)
 self.\_path = pathlib.Path(path) self.\_chunk\_size = chunk\_size
 async def \_sendfile\_fallback( self, writer: AbstractStreamWriter, fobj: IO[Any], offset: int, count: int ) -> AbstractStreamWriter: # To keep memory usage low,fobj is transferred in chunks # controlled by the constructor's chunk\_size argument.
 chunk\_size = self.\_chunk\_size loop = asyncio.get\_event\_loop()
 await loop.run\_in\_executor(None, fobj.seek, offset)
 chunk = await loop.run\_in\_executor(None, fobj.read, chunk\_size) while chunk: await writer.write(chunk) count = count - chunk\_size if count <= 0: break chunk = await loop.run\_in\_executor(None, fobj.read, min(chunk\_size, count))
 await writer.drain() return writer
 async def \_sendfile( self, request: "BaseRequest", fobj: IO[Any], offset: int, count: int ) -> AbstractStreamWriter: writer = await super().prepare(request) assert writer is not None
 if NOSENDFILE or self.compression: return await self.\_sendfile\_fallback(writer, fobj, offset, count)
 loop = request.\_loop transport = request.transport assert transport is not None
 try: await loop.sendfile(transport, fobj, offset, count) except NotImplementedError: return await self.\_sendfile\_fallback(writer, fobj, offset, count)
 await super().write\_eof() return writer
 @staticmethod def \_strong\_etag\_match(etag\_value: str, etags: Tuple[ETag, ...]) -> bool: if len(etags) == 1 and etags[0].value == ETAG\_ANY: return True return any(etag.value == etag\_value for etag in etags if not etag.is\_weak)
 async def \_not\_modified( self, request: "BaseRequest", etag\_value: str, last\_modified: float ) -> Optional[AbstractStreamWriter]: self.set\_status(HTTPNotModified.status\_code) self.\_length\_check = False self.etag = etag\_value # type: ignore[assignment] self.last\_modified = last\_modified # type: ignore[assignment] # Delete any Content-Length headers provided by user. HTTP 304 # should always have empty response body return await super().prepare(request)
 async def \_precondition\_failed( self, request: "BaseRequest" ) -> Optional[AbstractStreamWriter]: self.set\_status(HTTPPreconditionFailed.status\_code) self.content\_length = 0 return await super().prepare(request)
 def \_get\_file\_path\_stat\_encoding( self, accept\_encoding: str ) -> Tuple[pathlib.Path, os.stat\_result, Optional[str]]: """Return the file path, stat result, and encoding.
 If an uncompressed file is returned, the encoding is set to :py:data:`None`.
 This method should be called from a thread executor since it calls os.stat which may block. """ file\_path = self.\_path for file\_extension, file\_encoding in ENCODING\_EXTENSIONS.items(): if file\_encoding not in accept\_encoding: continue
 compressed\_path = file\_path.with\_suffix(file\_path.suffix + file\_extension) with suppress(OSError): return compressed\_path, compressed\_path.stat(), file\_encoding
 # Fallback to the uncompressed file return file\_path, file\_path.stat(), None
 async def prepare(self, request: "BaseRequest") -> Optional[AbstractStreamWriter]: loop = asyncio.get\_running\_loop() # Encoding comparisons should be case-insensitive # https://www.rfc-editor.org/rfc/rfc9110#section-8.4.1 accept\_encoding = request.headers.get(hdrs.ACCEPT\_ENCODING, "").lower() try: file\_path, st, file\_encoding = await loop.run\_in\_executor( None, self.\_get\_file\_path\_stat\_encoding, accept\_encoding ) except FileNotFoundError: self.set\_status(HTTPNotFound.status\_code) return await super().prepare(request)
 # Forbid special files like sockets, pipes, devices, etc. if not S\_ISREG(st.st\_mode): self.set\_status(HTTPForbidden.status\_code) return await super().prepare(request)
 etag\_value = f"{st.st\_mtime\_ns:x}-{st.st\_size:x}" last\_modified = st.st\_mtime
 # https://tools.ietf.org/html/rfc7232#section-6 ifmatch = request.if\_match if ifmatch is not None and not self.\_strong\_etag\_match(etag\_value, ifmatch): return await self.\_precondition\_failed(request)
 unmodsince = request.if\_unmodified\_since if ( unmodsince is not None and ifmatch is None and st.st\_mtime > unmodsince.timestamp() ): return await self.\_precondition\_failed(request)
 ifnonematch = request.if\_none\_match if ifnonematch is not None and self.\_strong\_etag\_match(etag\_value, ifnonematch): return await self.\_not\_modified(request, etag\_value, last\_modified)
 modsince = request.if\_modified\_since if ( modsince is not None and ifnonematch is None and st.st\_mtime <= modsince.timestamp() ): return await self.\_not\_modified(request, etag\_value, last\_modified)
 status = self.\_status file\_size = st.st\_size count = file\_size
 start = None
 ifrange = request.if\_range if ifrange is None or st.st\_mtime <= ifrange.timestamp(): # If-Range header check: # condition = cached date >= last modification date # return 206 if True else 200. # if False: # Range header would not be processed, return 200 # if True but Range header missing # return 200 try: rng = request.http\_range start = rng.start end = rng.stop except ValueError: # https://tools.ietf.org/html/rfc7233: # A server generating a 416 (Range Not Satisfiable) response to # a byte-range request SHOULD send a Content-Range header field # with an unsatisfied-range value. # The complete-length in a 416 response indicates the current # length of the selected representation. # # Will do the same below. Many servers ignore this and do not # send a Content-Range header with HTTP 416 self.headers[hdrs.CONTENT\_RANGE] = f"bytes \*/{file\_size}" self.set\_status(HTTPRequestRangeNotSatisfiable.status\_code) return await super().prepare(request)
 # If a range request has been made, convert start, end slice # notation into file pointer offset and count if start is not None or end is not None: if start < 0 and end is None: # return tail of file start += file\_size if start < 0: # if Range:bytes=-1000 in request header but file size # is only 200, there would be trouble without this start = 0 count = file\_size - start else: # rfc7233:If the last-byte-pos value is # absent, or if the value is greater than or equal to # the current length of the representation data, # the byte range is interpreted as the remainder # of the representation (i.e., the server replaces the # value of last-byte-pos with a value that is one less than # the current length of the selected representation). count = ( min(end if end is not None else file\_size, file\_size) - start )
 if start >= file\_size: # HTTP 416 should be returned in this case. # # According to https://tools.ietf.org/html/rfc7233: # If a valid byte-range-set includes at least one # byte-range-spec with a first-byte-pos that is less than # the current length of the representation, or at least one # suffix-byte-range-spec with a non-zero suffix-length, # then the byte-range-set is satisfiable. Otherwise, the # byte-range-set is unsatisfiable. self.headers[hdrs.CONTENT\_RANGE] = f"bytes \*/{file\_size}" self.set\_status(HTTPRequestRangeNotSatisfiable.status\_code) return await super().prepare(request)
 status = HTTPPartialContent.status\_code # Even though you are sending the whole file, you should still # return a HTTP 206 for a Range request. self.set\_status(status)
 # If the Content-Type header is not already set, guess it based on the # extension of the request path. The encoding returned by guess\_type # can be ignored since the map was cleared above. if hdrs.CONTENT\_TYPE not in self.headers: self.content\_type = ( CONTENT\_TYPES.guess\_type(self.\_path)[0] or FALLBACK\_CONTENT\_TYPE )
 if file\_encoding: self.headers[hdrs.CONTENT\_ENCODING] = file\_encoding self.headers[hdrs.VARY] = hdrs.ACCEPT\_ENCODING # Disable compression if we are already sending # a compressed file since we don't want to double # compress. self.\_compression = False
 self.etag = etag\_value # type: ignore[assignment] self.last\_modified = st.st\_mtime # type: ignore[assignment] self.content\_length = count
 self.headers[hdrs.ACCEPT\_RANGES] = "bytes"
 real\_start = cast(int, start)
 if status == HTTPPartialContent.status\_code: self.headers[hdrs.CONTENT\_RANGE] = "bytes {}-{}/{}".format( real\_start, real\_start + count - 1, file\_size )
 # If we are sending 0 bytes calling sendfile() will throw a ValueError if count == 0 or must\_be\_empty\_body(request.method, self.status): return await super().prepare(request)
 try: fobj = await loop.run\_in\_executor(None, file\_path.open, "rb") except PermissionError: self.set\_status(HTTPForbidden.status\_code) return await super().prepare(request)
 if start: # be aware that start could be None or int=0 here. offset = start else: offset = 0
 try: return await self.\_sendfile(request, fobj, offset, count) finally: await asyncio.shield(loop.run\_in\_executor(None, fobj.close))

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

