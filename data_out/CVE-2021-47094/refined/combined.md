=== Content from git.kernel.org_84e5f591_20250111_121824.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=3a0f64de479cae75effb630a2e0a237ca0d0623c)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=3a0f64de479cae75effb630a2e0a237ca0d0623c)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3a0f64de479cae75effb630a2e0a237ca0d0623c)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3a0f64de479cae75effb630a2e0a237ca0d0623c)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Sean Christopherson <seanjc@google.com> | 2021-12-14 03:35:28 +0000 |
| --- | --- | --- |
| committer | Paolo Bonzini <pbonzini@redhat.com> | 2021-12-20 08:06:53 -0500 |
| commit | [3a0f64de479cae75effb630a2e0a237ca0d0623c](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3a0f64de479cae75effb630a2e0a237ca0d0623c) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=3a0f64de479cae75effb630a2e0a237ca0d0623c)) | |
| tree | [718585251c23553135204a33e9b91de054c94441](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=3a0f64de479cae75effb630a2e0a237ca0d0623c) | |
| parent | [9fb12fe5b93b94b9e607509ba461e17f4cc6a264](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9fb12fe5b93b94b9e607509ba461e17f4cc6a264) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3a0f64de479cae75effb630a2e0a237ca0d0623c&id2=9fb12fe5b93b94b9e607509ba461e17f4cc6a264)) | |
| download | [linux-3a0f64de479cae75effb630a2e0a237ca0d0623c.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-3a0f64de479cae75effb630a2e0a237ca0d0623c.tar.gz) | |

KVM: x86/mmu: Don't advance iterator after restart due to yieldingAfter dropping mmu\_lock in the TDP MMU, restart the iterator during
tdp\_iter\_next() and do not advance the iterator. Advancing the iterator
results in skipping the top-level SPTE and all its children, which is
fatal if any of the skipped SPTEs were not visited before yielding.
When zapping all SPTEs, i.e. when min\_level == root\_level, restarting the
iter and then invoking tdp\_iter\_next() is always fatal if the current gfn
has as a valid SPTE, as advancing the iterator results in try\_step\_side()
skipping the current gfn, which wasn't visited before yielding.
Sprinkle WARNs on iter->yielded being true in various helpers that are
often used in conjunction with yielding, and tag the helper with
\_\_must\_check to reduce the probabily of improper usage.
Failing to zap a top-level SPTE manifests in one of two ways. If a valid
SPTE is skipped by both kvm\_tdp\_mmu\_zap\_all() and kvm\_tdp\_mmu\_put\_root(),
the shadow page will be leaked and KVM will WARN accordingly.
WARNING: CPU: 1 PID: 3509 at arch/x86/kvm/mmu/tdp\_mmu.c:46 [kvm]
RIP: 0010:kvm\_mmu\_uninit\_tdp\_mmu+0x3e/0x50 [kvm]
Call Trace:
<TASK>
kvm\_arch\_destroy\_vm+0x130/0x1b0 [kvm]
kvm\_destroy\_vm+0x162/0x2a0 [kvm]
kvm\_vcpu\_release+0x34/0x60 [kvm]
\_\_fput+0x82/0x240
task\_work\_run+0x5c/0x90
do\_exit+0x364/0xa10
? futex\_unqueue+0x38/0x60
do\_group\_exit+0x33/0xa0
get\_signal+0x155/0x850
arch\_do\_signal\_or\_restart+0xed/0x750
exit\_to\_user\_mode\_prepare+0xc5/0x120
syscall\_exit\_to\_user\_mode+0x1d/0x40
do\_syscall\_64+0x48/0xc0
entry\_SYSCALL\_64\_after\_hwframe+0x44/0xae
If kvm\_tdp\_mmu\_zap\_all() skips a gfn/SPTE but that SPTE is then zapped by
kvm\_tdp\_mmu\_put\_root(), KVM triggers a use-after-free in the form of
marking a struct page as dirty/accessed after it has been put back on the
free list. This directly triggers a WARN due to encountering a page with
page\_count() == 0, but it can also lead to data corruption and additional
errors in the kernel.
WARNING: CPU: 7 PID: 1995658 at arch/x86/kvm/../../../virt/kvm/kvm\_main.c:171
RIP: 0010:kvm\_is\_zone\_device\_pfn.part.0+0x9e/0xd0 [kvm]
Call Trace:
<TASK>
kvm\_set\_pfn\_dirty+0x120/0x1d0 [kvm]
\_\_handle\_changed\_spte+0x92e/0xca0 [kvm]
\_\_handle\_changed\_spte+0x63c/0xca0 [kvm]
\_\_handle\_changed\_spte+0x63c/0xca0 [kvm]
\_\_handle\_changed\_spte+0x63c/0xca0 [kvm]
zap\_gfn\_range+0x549/0x620 [kvm]
kvm\_tdp\_mmu\_put\_root+0x1b6/0x270 [kvm]
mmu\_free\_root\_page+0x219/0x2c0 [kvm]
kvm\_mmu\_free\_roots+0x1b4/0x4e0 [kvm]
kvm\_mmu\_unload+0x1c/0xa0 [kvm]
kvm\_arch\_destroy\_vm+0x1f2/0x5c0 [kvm]
kvm\_put\_kvm+0x3b1/0x8b0 [kvm]
kvm\_vcpu\_release+0x4e/0x70 [kvm]
\_\_fput+0x1f7/0x8c0
task\_work\_run+0xf8/0x1a0
do\_exit+0x97b/0x2230
do\_group\_exit+0xda/0x2a0
get\_signal+0x3be/0x1e50
arch\_do\_signal\_or\_restart+0x244/0x17f0
exit\_to\_user\_mode\_prepare+0xcb/0x120
syscall\_exit\_to\_user\_mode+0x1d/0x40
do\_syscall\_64+0x4d/0x90
entry\_SYSCALL\_64\_after\_hwframe+0x44/0xae
Note, the underlying bug existed even before commit 1af4a96025b3 ("KVM:
x86/mmu: Yield in TDU MMU iter even if no SPTES changed") moved calls to
tdp\_mmu\_iter\_cond\_resched() to the beginning of loops, as KVM could still
incorrectly advance past a top-level entry when yielding on a lower-level
entry. But with respect to leaking shadow pages, the bug was introduced
by yielding before processing the current gfn.
Alternatively, tdp\_mmu\_iter\_cond\_resched() could simply fall through, or
callers could jump to their "retry" label. The downside of that approach
is that tdp\_mmu\_iter\_cond\_resched() \_must\_ be called before anything else
in the loop, and there's no easy way to enfornce that requirement.
Ideally, KVM would handling the cond\_resched() fully within the iterator
macro (the code is actually quite clean) and avoid this entire class of
bugs, but that is extremely difficult do while also supporting yielding
after tdp\_mmu\_set\_spte\_atomic() fails. Yielding after failing to set a
SPTE is very desirable as the "owner" of the REMOVED\_SPTE isn't strictly
bounded, e.g. if it's zapping a high-level shadow page, the REMOVED\_SPTE
may block operations on the SPTE for a significant amount of time.
Fixes: faaf05b00aec ("kvm: x86/mmu: Support zapping SPTEs in the TDP MMU")
Fixes: 1af4a96025b3 ("KVM: x86/mmu: Yield in TDU MMU iter even if no SPTES changed")
Reported-by: Ignat Korchagin <ignat@cloudflare.com>
Cc: stable@vger.kernel.org
Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-Id: <20211214033528.123268-1-seanjc@google.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3a0f64de479cae75effb630a2e0a237ca0d0623c)

| -rw-r--r-- | [arch/x86/kvm/mmu/tdp\_iter.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/x86/kvm/mmu/tdp_iter.c?id=3a0f64de479cae75effb630a2e0a237ca0d0623c) | 6 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [arch/x86/kvm/mmu/tdp\_iter.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/x86/kvm/mmu/tdp_iter.h?id=3a0f64de479cae75effb630a2e0a237ca0d0623c) | 6 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/mmu/tdp\_mmu.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/x86/kvm/mmu/tdp_mmu.c?id=3a0f64de479cae75effb630a2e0a237ca0d0623c) | 29 | |  |  |  | | --- | --- | --- | |

3 files changed, 28 insertions, 13 deletions

| diff --git a/arch/x86/kvm/mmu/tdp\_iter.c b/arch/x86/kvm/mmu/tdp\_iter.cindex b3ed302c1a359f..caa96c270b9541 100644--- a/[arch/x86/kvm/mmu/tdp\_iter.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/mmu/tdp_iter.c?id=9fb12fe5b93b94b9e607509ba461e17f4cc6a264)+++ b/[arch/x86/kvm/mmu/tdp\_iter.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/mmu/tdp_iter.c?id=3a0f64de479cae75effb630a2e0a237ca0d0623c)@@ -26,6 +26,7 @@ static gfn\_t round\_gfn\_for\_level(gfn\_t gfn, int level) \*/ void tdp\_iter\_restart(struct tdp\_iter \*iter) {+ iter->yielded = false; iter->yielded\_gfn = iter->next\_last\_level\_gfn; iter->level = iter->root\_level; @@ -160,6 +161,11 @@ static bool try\_step\_up(struct tdp\_iter \*iter) \*/ void tdp\_iter\_next(struct tdp\_iter \*iter) {+ if (iter->yielded) {+ tdp\_iter\_restart(iter);+ return;+ }+ if (try\_step\_down(iter)) return; diff --git a/arch/x86/kvm/mmu/tdp\_iter.h b/arch/x86/kvm/mmu/tdp\_iter.hindex b1748b988d3aef..e19cabbcb65c84 100644--- a/[arch/x86/kvm/mmu/tdp\_iter.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/mmu/tdp_iter.h?id=9fb12fe5b93b94b9e607509ba461e17f4cc6a264)+++ b/[arch/x86/kvm/mmu/tdp\_iter.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/mmu/tdp_iter.h?id=3a0f64de479cae75effb630a2e0a237ca0d0623c)@@ -45,6 +45,12 @@ struct tdp\_iter { \* iterator walks off the end of the paging structure. \*/ bool valid;+ /\*+ \* True if KVM dropped mmu\_lock and yielded in the middle of a walk, in+ \* which case tdp\_iter\_next() needs to restart the walk at the root+ \* level instead of advancing to the next entry.+ \*/+ bool yielded; };  /\*diff --git a/arch/x86/kvm/mmu/tdp\_mmu.c b/arch/x86/kvm/mmu/tdp\_mmu.cindex 1db8496259add5..1beb4ca9056092 100644--- a/[arch/x86/kvm/mmu/tdp\_mmu.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/mmu/tdp_mmu.c?id=9fb12fe5b93b94b9e607509ba461e17f4cc6a264)+++ b/[arch/x86/kvm/mmu/tdp\_mmu.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/mmu/tdp_mmu.c?id=3a0f64de479cae75effb630a2e0a237ca0d0623c)@@ -502,6 +502,8 @@ static inline bool tdp\_mmu\_set\_spte\_atomic(struct kvm \*kvm, struct tdp\_iter \*iter, u64 new\_spte) {+ WARN\_ON\_ONCE(iter->yielded);+ lockdep\_assert\_held\_read(&kvm->mmu\_lock);  /\*@@ -575,6 +577,8 @@ static inline void \_\_tdp\_mmu\_set\_spte(struct kvm \*kvm, struct tdp\_iter \*iter, u64 new\_spte, bool record\_acc\_track, bool record\_dirty\_log) {+ WARN\_ON\_ONCE(iter->yielded);+ lockdep\_assert\_held\_write(&kvm->mmu\_lock);  /\*@@ -640,18 +644,19 @@ static inline void tdp\_mmu\_set\_spte\_no\_dirty\_log(struct kvm \*kvm, \* If this function should yield and flush is set, it will perform a remote \* TLB flush before yielding. \*- \* If this function yields, it will also reset the tdp\_iter's walk over the- \* paging structure and the calling function should skip to the next- \* iteration to allow the iterator to continue its traversal from the- \* paging structure root.+ \* If this function yields, iter->yielded is set and the caller must skip to+ \* the next iteration, where tdp\_iter\_next() will reset the tdp\_iter's walk+ \* over the paging structures to allow the iterator to continue its traversal+ \* from the paging structure root. \*- \* Return true if this function yielded and the iterator's traversal was reset.- \* Return false if a yield was not needed.+ \* Returns true if this function yielded. \*/-static inline bool tdp\_mmu\_iter\_cond\_resched(struct kvm \*kvm,- struct tdp\_iter \*iter, bool flush,- bool shared)+static inline bool \_\_must\_check tdp\_mmu\_iter\_cond\_resched(struct kvm \*kvm,+ struct tdp\_iter \*iter,+ bool flush, bool shared) {+ WARN\_ON(iter->yielded);+ /\* Ensure forward progress has been made before yielding. \*/ if (iter->next\_last\_level\_gfn == iter->yielded\_gfn) return false;@@ -671,12 +676,10 @@ static inline bool tdp\_mmu\_iter\_cond\_resched(struct kvm \*kvm,  WARN\_ON(iter->gfn > iter->next\_last\_level\_gfn); - tdp\_iter\_restart(iter);-- return true;+ iter->yielded = true; } - return false;+ return iter->yielded; }  /\* |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 12:17:01 +0000



=== Content from git.kernel.org_6271dbcf_20250111_121825.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=d884eefd75cc54887bc2e9e724207443525dfb2c)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d884eefd75cc54887bc2e9e724207443525dfb2c)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d884eefd75cc54887bc2e9e724207443525dfb2c)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d884eefd75cc54887bc2e9e724207443525dfb2c)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Sean Christopherson <seanjc@google.com> | 2021-12-14 03:35:28 +0000 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2021-12-29 12:28:55 +0100 |
| commit | [d884eefd75cc54887bc2e9e724207443525dfb2c](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d884eefd75cc54887bc2e9e724207443525dfb2c) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=d884eefd75cc54887bc2e9e724207443525dfb2c)) | |
| tree | [a3064946991b0a3a9e1864ff98c9baabb10961f1](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d884eefd75cc54887bc2e9e724207443525dfb2c) | |
| parent | [5dea76f5da655a5998da9a06e16c2b0e311ebefc](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=5dea76f5da655a5998da9a06e16c2b0e311ebefc) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d884eefd75cc54887bc2e9e724207443525dfb2c&id2=5dea76f5da655a5998da9a06e16c2b0e311ebefc)) | |
| download | [linux-d884eefd75cc54887bc2e9e724207443525dfb2c.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-d884eefd75cc54887bc2e9e724207443525dfb2c.tar.gz) | |

KVM: x86/mmu: Don't advance iterator after restart due to yieldingcommit 3a0f64de479cae75effb630a2e0a237ca0d0623c upstream.
After dropping mmu\_lock in the TDP MMU, restart the iterator during
tdp\_iter\_next() and do not advance the iterator. Advancing the iterator
results in skipping the top-level SPTE and all its children, which is
fatal if any of the skipped SPTEs were not visited before yielding.
When zapping all SPTEs, i.e. when min\_level == root\_level, restarting the
iter and then invoking tdp\_iter\_next() is always fatal if the current gfn
has as a valid SPTE, as advancing the iterator results in try\_step\_side()
skipping the current gfn, which wasn't visited before yielding.
Sprinkle WARNs on iter->yielded being true in various helpers that are
often used in conjunction with yielding, and tag the helper with
\_\_must\_check to reduce the probabily of improper usage.
Failing to zap a top-level SPTE manifests in one of two ways. If a valid
SPTE is skipped by both kvm\_tdp\_mmu\_zap\_all() and kvm\_tdp\_mmu\_put\_root(),
the shadow page will be leaked and KVM will WARN accordingly.
WARNING: CPU: 1 PID: 3509 at arch/x86/kvm/mmu/tdp\_mmu.c:46 [kvm]
RIP: 0010:kvm\_mmu\_uninit\_tdp\_mmu+0x3e/0x50 [kvm]
Call Trace:
<TASK>
kvm\_arch\_destroy\_vm+0x130/0x1b0 [kvm]
kvm\_destroy\_vm+0x162/0x2a0 [kvm]
kvm\_vcpu\_release+0x34/0x60 [kvm]
\_\_fput+0x82/0x240
task\_work\_run+0x5c/0x90
do\_exit+0x364/0xa10
? futex\_unqueue+0x38/0x60
do\_group\_exit+0x33/0xa0
get\_signal+0x155/0x850
arch\_do\_signal\_or\_restart+0xed/0x750
exit\_to\_user\_mode\_prepare+0xc5/0x120
syscall\_exit\_to\_user\_mode+0x1d/0x40
do\_syscall\_64+0x48/0xc0
entry\_SYSCALL\_64\_after\_hwframe+0x44/0xae
If kvm\_tdp\_mmu\_zap\_all() skips a gfn/SPTE but that SPTE is then zapped by
kvm\_tdp\_mmu\_put\_root(), KVM triggers a use-after-free in the form of
marking a struct page as dirty/accessed after it has been put back on the
free list. This directly triggers a WARN due to encountering a page with
page\_count() == 0, but it can also lead to data corruption and additional
errors in the kernel.
WARNING: CPU: 7 PID: 1995658 at arch/x86/kvm/../../../virt/kvm/kvm\_main.c:171
RIP: 0010:kvm\_is\_zone\_device\_pfn.part.0+0x9e/0xd0 [kvm]
Call Trace:
<TASK>
kvm\_set\_pfn\_dirty+0x120/0x1d0 [kvm]
\_\_handle\_changed\_spte+0x92e/0xca0 [kvm]
\_\_handle\_changed\_spte+0x63c/0xca0 [kvm]
\_\_handle\_changed\_spte+0x63c/0xca0 [kvm]
\_\_handle\_changed\_spte+0x63c/0xca0 [kvm]
zap\_gfn\_range+0x549/0x620 [kvm]
kvm\_tdp\_mmu\_put\_root+0x1b6/0x270 [kvm]
mmu\_free\_root\_page+0x219/0x2c0 [kvm]
kvm\_mmu\_free\_roots+0x1b4/0x4e0 [kvm]
kvm\_mmu\_unload+0x1c/0xa0 [kvm]
kvm\_arch\_destroy\_vm+0x1f2/0x5c0 [kvm]
kvm\_put\_kvm+0x3b1/0x8b0 [kvm]
kvm\_vcpu\_release+0x4e/0x70 [kvm]
\_\_fput+0x1f7/0x8c0
task\_work\_run+0xf8/0x1a0
do\_exit+0x97b/0x2230
do\_group\_exit+0xda/0x2a0
get\_signal+0x3be/0x1e50
arch\_do\_signal\_or\_restart+0x244/0x17f0
exit\_to\_user\_mode\_prepare+0xcb/0x120
syscall\_exit\_to\_user\_mode+0x1d/0x40
do\_syscall\_64+0x4d/0x90
entry\_SYSCALL\_64\_after\_hwframe+0x44/0xae
Note, the underlying bug existed even before commit 1af4a96025b3 ("KVM:
x86/mmu: Yield in TDU MMU iter even if no SPTES changed") moved calls to
tdp\_mmu\_iter\_cond\_resched() to the beginning of loops, as KVM could still
incorrectly advance past a top-level entry when yielding on a lower-level
entry. But with respect to leaking shadow pages, the bug was introduced
by yielding before processing the current gfn.
Alternatively, tdp\_mmu\_iter\_cond\_resched() could simply fall through, or
callers could jump to their "retry" label. The downside of that approach
is that tdp\_mmu\_iter\_cond\_resched() \_must\_ be called before anything else
in the loop, and there's no easy way to enfornce that requirement.
Ideally, KVM would handling the cond\_resched() fully within the iterator
macro (the code is actually quite clean) and avoid this entire class of
bugs, but that is extremely difficult do while also supporting yielding
after tdp\_mmu\_set\_spte\_atomic() fails. Yielding after failing to set a
SPTE is very desirable as the "owner" of the REMOVED\_SPTE isn't strictly
bounded, e.g. if it's zapping a high-level shadow page, the REMOVED\_SPTE
may block operations on the SPTE for a significant amount of time.
Fixes: faaf05b00aec ("kvm: x86/mmu: Support zapping SPTEs in the TDP MMU")
Fixes: 1af4a96025b3 ("KVM: x86/mmu: Yield in TDU MMU iter even if no SPTES changed")
Reported-by: Ignat Korchagin <ignat@cloudflare.com>
Cc: stable@vger.kernel.org
Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-Id: <20211214033528.123268-1-seanjc@google.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d884eefd75cc54887bc2e9e724207443525dfb2c)

| -rw-r--r-- | [arch/x86/kvm/mmu/tdp\_iter.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/x86/kvm/mmu/tdp_iter.c?id=d884eefd75cc54887bc2e9e724207443525dfb2c) | 6 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [arch/x86/kvm/mmu/tdp\_iter.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/x86/kvm/mmu/tdp_iter.h?id=d884eefd75cc54887bc2e9e724207443525dfb2c) | 6 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/mmu/tdp\_mmu.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/x86/kvm/mmu/tdp_mmu.c?id=d884eefd75cc54887bc2e9e724207443525dfb2c) | 29 | |  |  |  | | --- | --- | --- | |

3 files changed, 28 insertions, 13 deletions

| diff --git a/arch/x86/kvm/mmu/tdp\_iter.c b/arch/x86/kvm/mmu/tdp\_iter.cindex b3ed302c1a359f..caa96c270b9541 100644--- a/[arch/x86/kvm/mmu/tdp\_iter.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/mmu/tdp_iter.c?id=5dea76f5da655a5998da9a06e16c2b0e311ebefc)+++ b/[arch/x86/kvm/mmu/tdp\_iter.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/mmu/tdp_iter.c?id=d884eefd75cc54887bc2e9e724207443525dfb2c)@@ -26,6 +26,7 @@ static gfn\_t round\_gfn\_for\_level(gfn\_t gfn, int level) \*/ void tdp\_iter\_restart(struct tdp\_iter \*iter) {+ iter->yielded = false; iter->yielded\_gfn = iter->next\_last\_level\_gfn; iter->level = iter->root\_level; @@ -160,6 +161,11 @@ static bool try\_step\_up(struct tdp\_iter \*iter) \*/ void tdp\_iter\_next(struct tdp\_iter \*iter) {+ if (iter->yielded) {+ tdp\_iter\_restart(iter);+ return;+ }+ if (try\_step\_down(iter)) return; diff --git a/arch/x86/kvm/mmu/tdp\_iter.h b/arch/x86/kvm/mmu/tdp\_iter.hindex b1748b988d3aef..e19cabbcb65c84 100644--- a/[arch/x86/kvm/mmu/tdp\_iter.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/mmu/tdp_iter.h?id=5dea76f5da655a5998da9a06e16c2b0e311ebefc)+++ b/[arch/x86/kvm/mmu/tdp\_iter.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/mmu/tdp_iter.h?id=d884eefd75cc54887bc2e9e724207443525dfb2c)@@ -45,6 +45,12 @@ struct tdp\_iter { \* iterator walks off the end of the paging structure. \*/ bool valid;+ /\*+ \* True if KVM dropped mmu\_lock and yielded in the middle of a walk, in+ \* which case tdp\_iter\_next() needs to restart the walk at the root+ \* level instead of advancing to the next entry.+ \*/+ bool yielded; };  /\*diff --git a/arch/x86/kvm/mmu/tdp\_mmu.c b/arch/x86/kvm/mmu/tdp\_mmu.cindex 0e4227b59d7bb6..4954cd01c1f0ea 100644--- a/[arch/x86/kvm/mmu/tdp\_mmu.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/mmu/tdp_mmu.c?id=5dea76f5da655a5998da9a06e16c2b0e311ebefc)+++ b/[arch/x86/kvm/mmu/tdp\_mmu.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/mmu/tdp_mmu.c?id=d884eefd75cc54887bc2e9e724207443525dfb2c)@@ -501,6 +501,8 @@ static inline bool tdp\_mmu\_set\_spte\_atomic\_no\_dirty\_log(struct kvm \*kvm, struct tdp\_iter \*iter, u64 new\_spte) {+ WARN\_ON\_ONCE(iter->yielded);+ lockdep\_assert\_held\_read(&kvm->mmu\_lock);  /\*@@ -611,6 +613,8 @@ static inline void \_\_tdp\_mmu\_set\_spte(struct kvm \*kvm, struct tdp\_iter \*iter, u64 new\_spte, bool record\_acc\_track, bool record\_dirty\_log) {+ WARN\_ON\_ONCE(iter->yielded);+ lockdep\_assert\_held\_write(&kvm->mmu\_lock);  /\*@@ -676,18 +680,19 @@ static inline void tdp\_mmu\_set\_spte\_no\_dirty\_log(struct kvm \*kvm, \* If this function should yield and flush is set, it will perform a remote \* TLB flush before yielding. \*- \* If this function yields, it will also reset the tdp\_iter's walk over the- \* paging structure and the calling function should skip to the next- \* iteration to allow the iterator to continue its traversal from the- \* paging structure root.+ \* If this function yields, iter->yielded is set and the caller must skip to+ \* the next iteration, where tdp\_iter\_next() will reset the tdp\_iter's walk+ \* over the paging structures to allow the iterator to continue its traversal+ \* from the paging structure root. \*- \* Return true if this function yielded and the iterator's traversal was reset.- \* Return false if a yield was not needed.+ \* Returns true if this function yielded. \*/-static inline bool tdp\_mmu\_iter\_cond\_resched(struct kvm \*kvm,- struct tdp\_iter \*iter, bool flush,- bool shared)+static inline bool \_\_must\_check tdp\_mmu\_iter\_cond\_resched(struct kvm \*kvm,+ struct tdp\_iter \*iter,+ bool flush, bool shared) {+ WARN\_ON(iter->yielded);+ /\* Ensure forward progress has been made before yielding. \*/ if (iter->next\_last\_level\_gfn == iter->yielded\_gfn) return false;@@ -707,12 +712,10 @@ static inline bool tdp\_mmu\_iter\_cond\_resched(struct kvm \*kvm,  WARN\_ON(iter->gfn > iter->next\_last\_level\_gfn); - tdp\_iter\_restart(iter);-- return true;+ iter->yielded = true; } - return false;+ return iter->yielded; }  /\* |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 12:17:02 +0000


