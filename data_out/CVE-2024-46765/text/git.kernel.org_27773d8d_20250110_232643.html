

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=2504b8405768a57a71e660dbfd5abd59f679a03f)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=2504b8405768a57a71e660dbfd5abd59f679a03f)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=2504b8405768a57a71e660dbfd5abd59f679a03f)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=2504b8405768a57a71e660dbfd5abd59f679a03f)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Larysa Zaremba <larysa.zaremba@intel.com> | 2024-08-23 11:59:27 +0200 |
| --- | --- | --- |
| committer | Tony Nguyen <anthony.l.nguyen@intel.com> | 2024-09-03 08:57:18 -0700 |
| commit | [2504b8405768a57a71e660dbfd5abd59f679a03f](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=2504b8405768a57a71e660dbfd5abd59f679a03f) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=2504b8405768a57a71e660dbfd5abd59f679a03f)) | |
| tree | [2ffcfb5b9b81a0974eb2621bcad06a0ffb194ed4](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=2504b8405768a57a71e660dbfd5abd59f679a03f) | |
| parent | [2a5dc090b92cfa5270e20056074241c6db5c9cdd](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=2a5dc090b92cfa5270e20056074241c6db5c9cdd) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=2504b8405768a57a71e660dbfd5abd59f679a03f&id2=2a5dc090b92cfa5270e20056074241c6db5c9cdd)) | |
| download | [linux-2504b8405768a57a71e660dbfd5abd59f679a03f.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-2504b8405768a57a71e660dbfd5abd59f679a03f.tar.gz) | |

ice: protect XDP configuration with a mutexThe main threat to data consistency in ice\_xdp() is a possible asynchronous
PF reset. It can be triggered by a user or by TX timeout handler.
XDP setup and PF reset code access the same resources in the following
sections:
\* ice\_vsi\_close() in ice\_prepare\_for\_reset() - already rtnl-locked
\* ice\_vsi\_rebuild() for the PF VSI - not protected
\* ice\_vsi\_open() - already rtnl-locked
With an unfortunate timing, such accesses can result in a crash such as the
one below:
[ +1.999878] ice 0000:b1:00.0: Registered XDP mem model MEM\_TYPE\_XSK\_BUFF\_POOL on Rx ring 14
[ +2.002992] ice 0000:b1:00.0: Registered XDP mem model MEM\_TYPE\_XSK\_BUFF\_POOL on Rx ring 18
[Mar15 18:17] ice 0000:b1:00.0 ens801f0np0: NETDEV WATCHDOG: CPU: 38: transmit queue 14 timed out 80692736 ms
[ +0.000093] ice 0000:b1:00.0 ens801f0np0: tx\_timeout: VSI\_num: 6, Q 14, NTC: 0x0, HW\_HEAD: 0x0, NTU: 0x0, INT: 0x4000001
[ +0.000012] ice 0000:b1:00.0 ens801f0np0: tx\_timeout recovery level 1, txqueue 14
[ +0.394718] ice 0000:b1:00.0: PTP reset successful
[ +0.006184] BUG: kernel NULL pointer dereference, address: 0000000000000098
[ +0.000045] #PF: supervisor read access in kernel mode
[ +0.000023] #PF: error\_code(0x0000) - not-present page
[ +0.000023] PGD 0 P4D 0
[ +0.000018] Oops: 0000 [#1] PREEMPT SMP NOPTI
[ +0.000023] CPU: 38 PID: 7540 Comm: kworker/38:1 Not tainted 6.8.0-rc7 #1
[ +0.000031] Hardware name: Intel Corporation S2600WFT/S2600WFT, BIOS SE5C620.86B.02.01.0014.082620210524 08/26/2021
[ +0.000036] Workqueue: ice ice\_service\_task [ice]
[ +0.000183] RIP: 0010:ice\_clean\_tx\_ring+0xa/0xd0 [ice]
[...]
[ +0.000013] Call Trace:
[ +0.000016] <TASK>
[ +0.000014] ? \_\_die+0x1f/0x70
[ +0.000029] ? page\_fault\_oops+0x171/0x4f0
[ +0.000029] ? schedule+0x3b/0xd0
[ +0.000027] ? exc\_page\_fault+0x7b/0x180
[ +0.000022] ? asm\_exc\_page\_fault+0x22/0x30
[ +0.000031] ? ice\_clean\_tx\_ring+0xa/0xd0 [ice]
[ +0.000194] ice\_free\_tx\_ring+0xe/0x60 [ice]
[ +0.000186] ice\_destroy\_xdp\_rings+0x157/0x310 [ice]
[ +0.000151] ice\_vsi\_decfg+0x53/0xe0 [ice]
[ +0.000180] ice\_vsi\_rebuild+0x239/0x540 [ice]
[ +0.000186] ice\_vsi\_rebuild\_by\_type+0x76/0x180 [ice]
[ +0.000145] ice\_rebuild+0x18c/0x840 [ice]
[ +0.000145] ? delay\_tsc+0x4a/0xc0
[ +0.000022] ? delay\_tsc+0x92/0xc0
[ +0.000020] ice\_do\_reset+0x140/0x180 [ice]
[ +0.000886] ice\_service\_task+0x404/0x1030 [ice]
[ +0.000824] process\_one\_work+0x171/0x340
[ +0.000685] worker\_thread+0x277/0x3a0
[ +0.000675] ? preempt\_count\_add+0x6a/0xa0
[ +0.000677] ? \_raw\_spin\_lock\_irqsave+0x23/0x50
[ +0.000679] ? \_\_pfx\_worker\_thread+0x10/0x10
[ +0.000653] kthread+0xf0/0x120
[ +0.000635] ? \_\_pfx\_kthread+0x10/0x10
[ +0.000616] ret\_from\_fork+0x2d/0x50
[ +0.000612] ? \_\_pfx\_kthread+0x10/0x10
[ +0.000604] ret\_from\_fork\_asm+0x1b/0x30
[ +0.000604] </TASK>
The previous way of handling this through returning -EBUSY is not viable,
particularly when destroying AF\_XDP socket, because the kernel proceeds
with removal anyway.
There is plenty of code between those calls and there is no need to create
a large critical section that covers all of them, same as there is no need
to protect ice\_vsi\_rebuild() with rtnl\_lock().
Add xdp\_state\_lock mutex to protect ice\_vsi\_rebuild() and ice\_xdp().
Leaving unprotected sections in between would result in two states that
have to be considered:
1. when the VSI is closed, but not yet rebuild
2. when VSI is already rebuild, but not yet open
The latter case is actually already handled through !netif\_running() case,
we just need to adjust flag checking a little. The former one is not as
trivial, because between ice\_vsi\_close() and ice\_vsi\_rebuild(), a lot of
hardware interaction happens, this can make adding/deleting rings exit
with an error. Luckily, VSI rebuild is pending and can apply new
configuration for us in a managed fashion.
Therefore, add an additional VSI state flag ICE\_VSI\_REBUILD\_PENDING to
indicate that ice\_xdp() can just hot-swap the program.
Also, as ice\_vsi\_rebuild() flow is touched in this patch, make it more
consistent by deconfiguring VSI when coalesce allocation fails.
Fixes: 2d4238f55697 ("ice: Add support for AF\_XDP")
Fixes: efc2214b6047 ("ice: Add support for XDP")
Reviewed-by: Wojciech Drewek <wojciech.drewek@intel.com>
Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
Tested-by: Chandan Kumar Rout <chandanx.rout@intel.com>
Signed-off-by: Larysa Zaremba <larysa.zaremba@intel.com>
Reviewed-by: Maciej Fijalkowski <maciej.fijalkowski@intel.com>
Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=2504b8405768a57a71e660dbfd5abd59f679a03f)

| -rw-r--r-- | [drivers/net/ethernet/intel/ice/ice.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/intel/ice/ice.h?id=2504b8405768a57a71e660dbfd5abd59f679a03f) | 2 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/net/ethernet/intel/ice/ice\_lib.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/intel/ice/ice_lib.c?id=2504b8405768a57a71e660dbfd5abd59f679a03f) | 34 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/net/ethernet/intel/ice/ice\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/intel/ice/ice_main.c?id=2504b8405768a57a71e660dbfd5abd59f679a03f) | 19 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/net/ethernet/intel/ice/ice\_xsk.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/intel/ice/ice_xsk.c?id=2504b8405768a57a71e660dbfd5abd59f679a03f) | 3 | |  |  |  | | --- | --- | --- | |

4 files changed, 39 insertions, 19 deletions

| diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.hindex caaa10157909ee..ce8b5505b16da8 100644--- a/[drivers/net/ethernet/intel/ice/ice.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice.h?id=2a5dc090b92cfa5270e20056074241c6db5c9cdd)+++ b/[drivers/net/ethernet/intel/ice/ice.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice.h?id=2504b8405768a57a71e660dbfd5abd59f679a03f)@@ -318,6 +318,7 @@ enum ice\_vsi\_state { ICE\_VSI\_UMAC\_FLTR\_CHANGED, ICE\_VSI\_MMAC\_FLTR\_CHANGED, ICE\_VSI\_PROMISC\_CHANGED,+ ICE\_VSI\_REBUILD\_PENDING, ICE\_VSI\_STATE\_NBITS /\* must be last \*/ }; @@ -411,6 +412,7 @@ struct ice\_vsi { struct ice\_tx\_ring \*\*xdp\_rings; /\* XDP ring array \*/ u16 num\_xdp\_txq; /\* Used XDP queues \*/ u8 xdp\_mapping\_mode; /\* ICE\_MAP\_MODE\_[CONTIG|SCATTER] \*/+ struct mutex xdp\_state\_lock;  struct net\_device \*\*target\_netdevs; diff --git a/drivers/net/ethernet/intel/ice/ice\_lib.c b/drivers/net/ethernet/intel/ice/ice\_lib.cindex 6676596df88b0f..c1c1b63d970177 100644--- a/[drivers/net/ethernet/intel/ice/ice\_lib.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice_lib.c?id=2a5dc090b92cfa5270e20056074241c6db5c9cdd)+++ b/[drivers/net/ethernet/intel/ice/ice\_lib.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice_lib.c?id=2504b8405768a57a71e660dbfd5abd59f679a03f)@@ -447,6 +447,7 @@ static void ice\_vsi\_free(struct ice\_vsi \*vsi)  ice\_vsi\_free\_stats(vsi); ice\_vsi\_free\_arrays(vsi);+ mutex\_destroy(&vsi->xdp\_state\_lock); mutex\_unlock(&pf->sw\_mutex); devm\_kfree(dev, vsi); }@@ -626,6 +627,8 @@ static struct ice\_vsi \*ice\_vsi\_alloc(struct ice\_pf \*pf) pf->next\_vsi = ice\_get\_free\_slot(pf->vsi, pf->num\_alloc\_vsi, pf->next\_vsi); + mutex\_init(&vsi->xdp\_state\_lock);+ unlock\_pf: mutex\_unlock(&pf->sw\_mutex); return vsi;@@ -2972,19 +2975,23 @@ int ice\_vsi\_rebuild(struct ice\_vsi \*vsi, u32 vsi\_flags) if (WARN\_ON(vsi->type == ICE\_VSI\_VF && !vsi->vf)) return -EINVAL; + mutex\_lock(&vsi->xdp\_state\_lock);+ ret = ice\_vsi\_realloc\_stat\_arrays(vsi); if (ret)- goto err\_vsi\_cfg;+ goto unlock;  ice\_vsi\_decfg(vsi); ret = ice\_vsi\_cfg\_def(vsi); if (ret)- goto err\_vsi\_cfg;+ goto unlock;  coalesce = kcalloc(vsi->num\_q\_vectors, sizeof(struct ice\_coalesce\_stored), GFP\_KERNEL);- if (!coalesce)- return -ENOMEM;+ if (!coalesce) {+ ret = -ENOMEM;+ goto decfg;+ }  prev\_num\_q\_vectors = ice\_vsi\_rebuild\_get\_coalesce(vsi, coalesce); @@ -2992,22 +2999,23 @@ int ice\_vsi\_rebuild(struct ice\_vsi \*vsi, u32 vsi\_flags) if (ret) { if (vsi\_flags & ICE\_VSI\_FLAG\_INIT) { ret = -EIO;- goto err\_vsi\_cfg\_tc\_lan;+ goto free\_coalesce; } - kfree(coalesce);- return ice\_schedule\_reset(pf, ICE\_RESET\_PFR);+ ret = ice\_schedule\_reset(pf, ICE\_RESET\_PFR);+ goto free\_coalesce; }  ice\_vsi\_rebuild\_set\_coalesce(vsi, coalesce, prev\_num\_q\_vectors);- kfree(coalesce);+ clear\_bit(ICE\_VSI\_REBUILD\_PENDING, vsi->state); - return 0;--err\_vsi\_cfg\_tc\_lan:- ice\_vsi\_decfg(vsi);+free\_coalesce: kfree(coalesce);-err\_vsi\_cfg:+decfg:+ if (ret)+ ice\_vsi\_decfg(vsi);+unlock:+ mutex\_unlock(&vsi->xdp\_state\_lock); return ret; } diff --git a/drivers/net/ethernet/intel/ice/ice\_main.c b/drivers/net/ethernet/intel/ice/ice\_main.cindex 263833346d3a66..4edaddcba3b41f 100644--- a/[drivers/net/ethernet/intel/ice/ice\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice_main.c?id=2a5dc090b92cfa5270e20056074241c6db5c9cdd)+++ b/[drivers/net/ethernet/intel/ice/ice\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice_main.c?id=2504b8405768a57a71e660dbfd5abd59f679a03f)@@ -616,6 +616,7 @@ skip: /\* clear SW filtering DB \*/ ice\_clear\_hw\_tbls(hw); /\* disable the VSIs and their queues that are not already DOWN \*/+ set\_bit(ICE\_VSI\_REBUILD\_PENDING, ice\_get\_main\_vsi(pf)->state); ice\_pf\_dis\_all\_vsi(pf, false);  if (test\_bit(ICE\_FLAG\_PTP\_SUPPORTED, pf->flags))@@ -3016,7 +3017,8 @@ ice\_xdp\_setup\_prog(struct ice\_vsi \*vsi, struct bpf\_prog \*prog, }  /\* hot swap progs and avoid toggling link \*/- if (ice\_is\_xdp\_ena\_vsi(vsi) == !!prog) {+ if (ice\_is\_xdp\_ena\_vsi(vsi) == !!prog ||+ test\_bit(ICE\_VSI\_REBUILD\_PENDING, vsi->state)) { ice\_vsi\_assign\_bpf\_prog(vsi, prog); return 0; }@@ -3088,21 +3090,28 @@ static int ice\_xdp(struct net\_device \*dev, struct netdev\_bpf \*xdp) { struct ice\_netdev\_priv \*np = netdev\_priv(dev); struct ice\_vsi \*vsi = np->vsi;+ int ret;  if (vsi->type != ICE\_VSI\_PF) { NL\_SET\_ERR\_MSG\_MOD(xdp->extack, "XDP can be loaded only on PF VSI"); return -EINVAL; } + mutex\_lock(&vsi->xdp\_state\_lock);+ switch (xdp->command) { case XDP\_SETUP\_PROG:- return ice\_xdp\_setup\_prog(vsi, xdp->prog, xdp->extack);+ ret = ice\_xdp\_setup\_prog(vsi, xdp->prog, xdp->extack);+ break; case XDP\_SETUP\_XSK\_POOL:- return ice\_xsk\_pool\_setup(vsi, xdp->xsk.pool,- xdp->xsk.queue\_id);+ ret = ice\_xsk\_pool\_setup(vsi, xdp->xsk.pool, xdp->xsk.queue\_id);+ break; default:- return -EINVAL;+ ret = -EINVAL; }++ mutex\_unlock(&vsi->xdp\_state\_lock);+ return ret; }  /\*\*diff --git a/drivers/net/ethernet/intel/ice/ice\_xsk.c b/drivers/net/ethernet/intel/ice/ice\_xsk.cindex 240a7bec242be3..a659951fa98729 100644--- a/[drivers/net/ethernet/intel/ice/ice\_xsk.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice_xsk.c?id=2a5dc090b92cfa5270e20056074241c6db5c9cdd)+++ b/[drivers/net/ethernet/intel/ice/ice\_xsk.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice_xsk.c?id=2504b8405768a57a71e660dbfd5abd59f679a03f)@@ -390,7 +390,8 @@ int ice\_xsk\_pool\_setup(struct ice\_vsi \*vsi, struct xsk\_buff\_pool \*pool, u16 qid) goto failure; } - if\_running = netif\_running(vsi->netdev) && ice\_is\_xdp\_ena\_vsi(vsi);+ if\_running = !test\_bit(ICE\_VSI\_DOWN, vsi->state) &&+ ice\_is\_xdp\_ena\_vsi(vsi);  if (if\_running) { struct ice\_rx\_ring \*rx\_ring = vsi->rx\_rings[qid]; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 23:25:21 +0000

