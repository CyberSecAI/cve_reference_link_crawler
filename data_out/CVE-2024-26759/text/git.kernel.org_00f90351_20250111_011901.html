

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=2dedda77d4493f3e92e414b272bfa60f1f51ed95)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=2dedda77d4493f3e92e414b272bfa60f1f51ed95)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=2dedda77d4493f3e92e414b272bfa60f1f51ed95)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=2dedda77d4493f3e92e414b272bfa60f1f51ed95)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Kairui Song <kasong@tencent.com> | 2024-02-07 02:25:59 +0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-03-01 13:26:32 +0100 |
| commit | [2dedda77d4493f3e92e414b272bfa60f1f51ed95](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=2dedda77d4493f3e92e414b272bfa60f1f51ed95) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=2dedda77d4493f3e92e414b272bfa60f1f51ed95)) | |
| tree | [5c169645fbbab374f10c9ac19a3b40bd3ff23aec](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=2dedda77d4493f3e92e414b272bfa60f1f51ed95) | |
| parent | [e3bf0a24e050538d3e4c8d8319b8e04e18188ce7](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e3bf0a24e050538d3e4c8d8319b8e04e18188ce7) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=2dedda77d4493f3e92e414b272bfa60f1f51ed95&id2=e3bf0a24e050538d3e4c8d8319b8e04e18188ce7)) | |
| download | [linux-2dedda77d4493f3e92e414b272bfa60f1f51ed95.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-2dedda77d4493f3e92e414b272bfa60f1f51ed95.tar.gz) | |

mm/swap: fix race when skipping swapcachecommit 13ddaf26be324a7f951891ecd9ccd04466d27458 upstream.
When skipping swapcache for SWP\_SYNCHRONOUS\_IO, if two or more threads
swapin the same entry at the same time, they get different pages (A, B).
Before one thread (T0) finishes the swapin and installs page (A) to the
PTE, another thread (T1) could finish swapin of page (B), swap\_free the
entry, then swap out the possibly modified page reusing the same entry.
It breaks the pte\_same check in (T0) because PTE value is unchanged,
causing ABA problem. Thread (T0) will install a stalled page (A) into the
PTE and cause data corruption.
One possible callstack is like this:
CPU0 CPU1
---- ----
do\_swap\_page() do\_swap\_page() with same entry
<direct swapin path> <direct swapin path>
<alloc page A> <alloc page B>
swap\_read\_folio() <- read to page A swap\_read\_folio() <- read to page B
<slow on later locks or interrupt> <finished swapin first>
... set\_pte\_at()
swap\_free() <- entry is free
<write to page B, now page A stalled>
<swap out page B to same swap entry>
pte\_same() <- Check pass, PTE seems
unchanged, but page A
is stalled!
swap\_free() <- page B content lost!
set\_pte\_at() <- staled page A installed!
And besides, for ZRAM, swap\_free() allows the swap device to discard the
entry content, so even if page (B) is not modified, if swap\_read\_folio()
on CPU0 happens later than swap\_free() on CPU1, it may also cause data
loss.
To fix this, reuse swapcache\_prepare which will pin the swap entry using
the cache flag, and allow only one thread to swap it in, also prevent any
parallel code from putting the entry in the cache. Release the pin after
PT unlocked.
Racers just loop and wait since it's a rare and very short event. A
schedule\_timeout\_uninterruptible(1) call is added to avoid repeated page
faults wasting too much CPU, causing livelock or adding too much noise to
perf statistics. A similar livelock issue was described in commit
029c4628b2eb ("mm: swap: get rid of livelock in swapin readahead")
Reproducer:
This race issue can be triggered easily using a well constructed
reproducer and patched brd (with a delay in read path) [1]:
With latest 6.8 mainline, race caused data loss can be observed easily:
$ gcc -g -lpthread test-thread-swap-race.c && ./a.out
Polulating 32MB of memory region...
Keep swapping out...
Starting round 0...
Spawning 65536 workers...
32746 workers spawned, wait for done...
Round 0: Error on 0x5aa00, expected 32746, got 32743, 3 data loss!
Round 0: Error on 0x395200, expected 32746, got 32743, 3 data loss!
Round 0: Error on 0x3fd000, expected 32746, got 32737, 9 data loss!
Round 0 Failed, 15 data loss!
This reproducer spawns multiple threads sharing the same memory region
using a small swap device. Every two threads updates mapped pages one by
one in opposite direction trying to create a race, with one dedicated
thread keep swapping out the data out using madvise.
The reproducer created a reproduce rate of about once every 5 minutes, so
the race should be totally possible in production.
After this patch, I ran the reproducer for over a few hundred rounds and
no data loss observed.
Performance overhead is minimal, microbenchmark swapin 10G from 32G
zram:
Before: 10934698 us
After: 11157121 us
Cached: 13155355 us (Dropping SWP\_SYNCHRONOUS\_IO flag)
[kasong@tencent.com: v4]
Link: https://lkml.kernel.org/r/20240219082040.7495-1-ryncsn@gmail.com
Link: [https://lkml.kernel.org/r/20240206182559.32264-1-ryncsn@gmail.com](https://lkml.kernel.org/r/20240206182559.32264-1-ryncsn%40gmail.com)
Fixes: 0bcac06f27d7 ("mm, swap: skip swapcache for swapin of synchronous device")
Reported-by: "Huang, Ying" <ying.huang@intel.com>
Closes: https://lore.kernel.org/lkml/87bk92gqpx.fsf\_-\_@yhuang6-desk2.ccr.corp.intel.com/
Link: <https://github.com/ryncsn/emm-test-project/tree/master/swap-stress-race> [1]
Signed-off-by: Kairui Song <kasong@tencent.com>
Reviewed-by: "Huang, Ying" <ying.huang@intel.com>
Acked-by: Yu Zhao <yuzhao@google.com>
Acked-by: David Hildenbrand <david@redhat.com>
Acked-by: Chris Li <chrisl@kernel.org>
Cc: Hugh Dickins <hughd@google.com>
Cc: Johannes Weiner <hannes@cmpxchg.org>
Cc: Matthew Wilcox (Oracle) <willy@infradead.org>
Cc: Michal Hocko <mhocko@suse.com>
Cc: Minchan Kim <minchan@kernel.org>
Cc: Yosry Ahmed <yosryahmed@google.com>
Cc: Yu Zhao <yuzhao@google.com>
Cc: Barry Song <21cnbao@gmail.com>
Cc: SeongJae Park <sj@kernel.org>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=2dedda77d4493f3e92e414b272bfa60f1f51ed95)

| -rw-r--r-- | [include/linux/swap.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/swap.h?id=2dedda77d4493f3e92e414b272bfa60f1f51ed95) | 5 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [mm/memory.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/mm/memory.c?id=2dedda77d4493f3e92e414b272bfa60f1f51ed95) | 20 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [mm/swap.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/mm/swap.h?id=2dedda77d4493f3e92e414b272bfa60f1f51ed95) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [mm/swapfile.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/mm/swapfile.c?id=2dedda77d4493f3e92e414b272bfa60f1f51ed95) | 13 | |  |  |  | | --- | --- | --- | |

4 files changed, 43 insertions, 0 deletions

| diff --git a/include/linux/swap.h b/include/linux/swap.hindex a18cf4b7c724c0..add47f43e568ee 100644--- a/[include/linux/swap.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/swap.h?id=e3bf0a24e050538d3e4c8d8319b8e04e18188ce7)+++ b/[include/linux/swap.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/swap.h?id=2dedda77d4493f3e92e414b272bfa60f1f51ed95)@@ -571,6 +571,11 @@ static inline int swap\_duplicate(swp\_entry\_t swp) return 0; } +static inline int swapcache\_prepare(swp\_entry\_t swp)+{+ return 0;+}+ static inline void swap\_free(swp\_entry\_t swp) { }diff --git a/mm/memory.c b/mm/memory.cindex fc8b264ec0caca..fb83cf56377ab6 100644--- a/[mm/memory.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/memory.c?id=e3bf0a24e050538d3e4c8d8319b8e04e18188ce7)+++ b/[mm/memory.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/memory.c?id=2dedda77d4493f3e92e414b272bfa60f1f51ed95)@@ -3761,6 +3761,7 @@ vm\_fault\_t do\_swap\_page(struct vm\_fault \*vmf) struct page \*page; struct swap\_info\_struct \*si = NULL; rmap\_t rmap\_flags = RMAP\_NONE;+ bool need\_clear\_cache = false; bool exclusive = false; swp\_entry\_t entry; pte\_t pte;@@ -3822,6 +3823,20 @@ vm\_fault\_t do\_swap\_page(struct vm\_fault \*vmf) if (!folio) { if (data\_race(si->flags & SWP\_SYNCHRONOUS\_IO) && \_\_swap\_count(entry) == 1) {+ /\*+ \* Prevent parallel swapin from proceeding with+ \* the cache flag. Otherwise, another thread may+ \* finish swapin first, free the entry, and swapout+ \* reusing the same entry. It's undetectable as+ \* pte\_same() returns true due to entry reuse.+ \*/+ if (swapcache\_prepare(entry)) {+ /\* Relax a bit to prevent rapid repeated page faults \*/+ schedule\_timeout\_uninterruptible(1);+ goto out;+ }+ need\_clear\_cache = true;+ /\* skip swapcache \*/ folio = vma\_alloc\_folio(GFP\_HIGHUSER\_MOVABLE, 0, vma, vmf->address, false);@@ -4073,6 +4088,9 @@ vm\_fault\_t do\_swap\_page(struct vm\_fault \*vmf) unlock: pte\_unmap\_unlock(vmf->pte, vmf->ptl); out:+ /\* Clear the swap cache pin for direct swapin after PTL unlock \*/+ if (need\_clear\_cache)+ swapcache\_clear(si, entry); if (si) put\_swap\_device(si); return ret;@@ -4086,6 +4104,8 @@ out\_release: folio\_unlock(swapcache); folio\_put(swapcache); }+ if (need\_clear\_cache)+ swapcache\_clear(si, entry); if (si) put\_swap\_device(si); return ret;diff --git a/mm/swap.h b/mm/swap.hindex cc08c459c6190c..5eff40ef769349 100644--- a/[mm/swap.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/swap.h?id=e3bf0a24e050538d3e4c8d8319b8e04e18188ce7)+++ b/[mm/swap.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/swap.h?id=2dedda77d4493f3e92e414b272bfa60f1f51ed95)@@ -39,6 +39,7 @@ void \_\_delete\_from\_swap\_cache(struct folio \*folio, void delete\_from\_swap\_cache(struct folio \*folio); void clear\_shadow\_from\_swap\_cache(int type, unsigned long begin, unsigned long end);+void swapcache\_clear(struct swap\_info\_struct \*si, swp\_entry\_t entry); struct folio \*swap\_cache\_get\_folio(swp\_entry\_t entry, struct vm\_area\_struct \*vma, unsigned long addr); struct page \*find\_get\_incore\_page(struct address\_space \*mapping, pgoff\_t index);@@ -98,6 +99,10 @@ static inline int swap\_writepage(struct page \*p, struct writeback\_control \*wbc) return 0; } +static inline void swapcache\_clear(struct swap\_info\_struct \*si, swp\_entry\_t entry)+{+}+ static inline struct folio \*swap\_cache\_get\_folio(swp\_entry\_t entry, struct vm\_area\_struct \*vma, unsigned long addr) {diff --git a/mm/swapfile.c b/mm/swapfile.cindex 71db6d8a1ea30a..cca9fda9d036fe 100644--- a/[mm/swapfile.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/swapfile.c?id=e3bf0a24e050538d3e4c8d8319b8e04e18188ce7)+++ b/[mm/swapfile.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/swapfile.c?id=2dedda77d4493f3e92e414b272bfa60f1f51ed95)@@ -3373,6 +3373,19 @@ int swapcache\_prepare(swp\_entry\_t entry) return \_\_swap\_duplicate(entry, SWAP\_HAS\_CACHE); } +void swapcache\_clear(struct swap\_info\_struct \*si, swp\_entry\_t entry)+{+ struct swap\_cluster\_info \*ci;+ unsigned long offset = swp\_offset(entry);+ unsigned char usage;++ ci = lock\_cluster\_or\_swap\_info(si, offset);+ usage = \_\_swap\_entry\_free\_locked(si, offset, SWAP\_HAS\_CACHE);+ unlock\_cluster\_or\_swap\_info(si, ci);+ if (!usage)+ free\_swap\_slot(entry);+}+ struct swap\_info\_struct \*swp\_swap\_info(swp\_entry\_t entry) { return swap\_type\_to\_swap\_info(swp\_type(entry)); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 01:17:39 +0000

