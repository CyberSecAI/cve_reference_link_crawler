The provided content relates to the following vulnerability:

**Root cause of vulnerability:**
The `virtio-net` driver in the Linux kernel did not validate the used length of received data from a virtio device. This allowed a potentially malicious or untrusted device to provide a length exceeding the allocated buffer size, leading to data corruption or loss.

**Weaknesses/vulnerabilities present:**
- Lack of input validation on the received data length from a virtio device.
- Potential for buffer overflow or out-of-bounds access due to incorrect length handling.

**Impact of exploitation:**
- Data corruption
- Data loss
- Kernel instability (possible crashes if memory corruption is severe enough)

**Attack vectors:**
- A malicious or compromised virtio device could provide a used length greater than the allocated buffer size.

**Required attacker capabilities/position:**
- The attacker must control the virtio device or a virtual machine with direct access to it, allowing them to manipulate the used length parameter.

**Technical Details:**
The fix introduces checks to validate the `len` parameter in both `receive_small` and `receive_mergeable` functions within the `drivers/net/virtio_net.c` file. It checks if the used length exceeds `GOOD_PACKET_LEN` for small packets and `truesize` for mergeable packets. If the length is invalid, an error is logged and the packet is dropped.

The following code changes were made:

```diff
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@ -730,6 +730,12 @@
        len -= vi->hdr_len;
        stats->bytes += len;
 
+       if (unlikely(len > GOOD_PACKET_LEN)) {
+               pr_debug("%s: rx error: len %u exceeds max size %d\n",
+                       dev->name, len, GOOD_PACKET_LEN);
+               dev->stats.rx_length_errors++;
+               goto err_len;
+       }
        rcu_read_lock();
        xdp_prog = rcu_dereference(rq->xdp_prog);
        if (xdp_prog) {
@@ -833,6 +839,7 @@
        }
 err:
 err_xdp:
        rcu_read_unlock();
        stats->xdp_drops++;
+err_len:
        stats->drops++;
        put_page(page);
 xdp_xmit:
@@ -886,6 +893,12 @@
        head_skb = NULL;
        stats->bytes += len - vi->hdr_len;
 
+       if (unlikely(len > truesize)) {
+               pr_debug("%s: rx error: len %u exceeds truesize %lu\n",
+                       dev->name, len, (unsigned long)ctx);
+               dev->stats.rx_length_errors++;
+               goto err_skb;
+       }
        rcu_read_lock();
        xdp_prog = rcu_dereference(rq->xdp_prog);
        if (xdp_prog) {
@@ -1012,13 +1025,6 @@
        }
        rcu_read_unlock();
 
-       if (unlikely(len > truesize)) {
-               pr_debug("%s: rx error: len %u exceeds truesize %lu\n",
-                       dev->name, len, (unsigned long)ctx);
-               dev->stats.rx_length_errors++;
-               goto err_skb;
-       }
-
        head_skb = page_to_skb(vi, rq, page, offset, len, truesize, !xdp_prog, metasize, !!headroom);
        curr_skb = head_skb;
```
The code snippets show the commit messages and diffs which introduce the fix. These confirm the vulnerability and its fix.