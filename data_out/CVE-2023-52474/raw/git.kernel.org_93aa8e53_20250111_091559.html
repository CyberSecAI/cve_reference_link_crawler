<!DOCTYPE html>
<html lang='en'>
<head>
<title>IB/hfi1: Fix bugs with non-PAGE_SIZE-end multi-iovec user SDMA requests - kernel/git/stable/linux.git - Linux kernel stable tree</title>
<meta name='generator' content='cgit 1.2.3-korg'/>
<meta name='robots' content='noindex, nofollow'/>
<link rel='stylesheet' type='text/css' href='/cgit-data/cgit.css'/>
<script type='text/javascript' src='/cgit-data/cgit.js'></script>
<link rel='shortcut icon' href='/favicon.ico'/>
<link rel='alternate' title='Atom feed' href='https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/atom/?h=master' type='application/atom+xml'/>
<link rel='vcs-git' href='git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git' title='kernel/git/stable/linux.git Git repository'/>
<link rel='vcs-git' href='https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git' title='kernel/git/stable/linux.git Git repository'/>
<link rel='vcs-git' href='https://kernel.googlesource.com/pub/scm/linux/kernel/git/stable/linux.git' title='kernel/git/stable/linux.git Git repository'/>
</head>
<body>
<div id='cgit'><table id='header'>
<tr>
<td class='logo' rowspan='2'><a href='/'><img src='/cgit-data/cgit.png' alt='cgit logo'/></a></td>
<td class='main'><a href='/'>index</a> : <a href='/pub/scm/linux/kernel/git/stable/linux.git/'>kernel/git/stable/linux.git</a></td><td class='form'><form method='get'>
<input type='hidden' name='id' value='9c4c6512d7330b743c4ffd18bd999a86ca26db0d'/><select name='h' onchange='this.form.submit();'>
<option value='linux-2.6.11.y'>linux-2.6.11.y</option>
<option value='linux-2.6.12.y'>linux-2.6.12.y</option>
<option value='linux-2.6.13.y'>linux-2.6.13.y</option>
<option value='linux-2.6.14.y'>linux-2.6.14.y</option>
<option value='linux-2.6.15.y'>linux-2.6.15.y</option>
<option value='linux-2.6.16.y'>linux-2.6.16.y</option>
<option value='linux-2.6.17.y'>linux-2.6.17.y</option>
<option value='linux-2.6.18.y'>linux-2.6.18.y</option>
<option value='linux-2.6.19.y'>linux-2.6.19.y</option>
<option value='linux-2.6.20.y'>linux-2.6.20.y</option>
<option value='linux-2.6.21.y'>linux-2.6.21.y</option>
<option value='linux-2.6.22.y'>linux-2.6.22.y</option>
<option value='linux-2.6.23.y'>linux-2.6.23.y</option>
<option value='linux-2.6.24.y'>linux-2.6.24.y</option>
<option value='linux-2.6.25.y'>linux-2.6.25.y</option>
<option value='linux-2.6.26.y'>linux-2.6.26.y</option>
<option value='linux-2.6.27.y'>linux-2.6.27.y</option>
<option value='linux-2.6.28.y'>linux-2.6.28.y</option>
<option value='linux-2.6.29.y'>linux-2.6.29.y</option>
<option value='linux-2.6.30.y'>linux-2.6.30.y</option>
<option value='linux-2.6.31.y'>linux-2.6.31.y</option>
<option value='linux-2.6.32.y'>linux-2.6.32.y</option>
<option value='linux-2.6.33.y'>linux-2.6.33.y</option>
<option value='linux-2.6.34.y'>linux-2.6.34.y</option>
<option value='linux-2.6.35.y'>linux-2.6.35.y</option>
<option value='linux-2.6.36.y'>linux-2.6.36.y</option>
<option value='linux-2.6.37.y'>linux-2.6.37.y</option>
<option value='linux-2.6.38.y'>linux-2.6.38.y</option>
<option value='linux-2.6.39.y'>linux-2.6.39.y</option>
<option value='linux-3.0.y'>linux-3.0.y</option>
<option value='linux-3.1.y'>linux-3.1.y</option>
<option value='linux-3.10.y'>linux-3.10.y</option>
<option value='linux-3.11.y'>linux-3.11.y</option>
<option value='linux-3.12.y'>linux-3.12.y</option>
<option value='linux-3.13.y'>linux-3.13.y</option>
<option value='linux-3.14.y'>linux-3.14.y</option>
<option value='linux-3.15.y'>linux-3.15.y</option>
<option value='linux-3.16.y'>linux-3.16.y</option>
<option value='linux-3.17.y'>linux-3.17.y</option>
<option value='linux-3.18.y'>linux-3.18.y</option>
<option value='linux-3.19.y'>linux-3.19.y</option>
<option value='linux-3.2.y'>linux-3.2.y</option>
<option value='linux-3.3.y'>linux-3.3.y</option>
<option value='linux-3.4.y'>linux-3.4.y</option>
<option value='linux-3.5.y'>linux-3.5.y</option>
<option value='linux-3.6.y'>linux-3.6.y</option>
<option value='linux-3.7.y'>linux-3.7.y</option>
<option value='linux-3.8.y'>linux-3.8.y</option>
<option value='linux-3.9.y'>linux-3.9.y</option>
<option value='linux-4.0.y'>linux-4.0.y</option>
<option value='linux-4.1.y'>linux-4.1.y</option>
<option value='linux-4.10.y'>linux-4.10.y</option>
<option value='linux-4.11.y'>linux-4.11.y</option>
<option value='linux-4.12.y'>linux-4.12.y</option>
<option value='linux-4.13.y'>linux-4.13.y</option>
<option value='linux-4.14.y'>linux-4.14.y</option>
<option value='linux-4.15.y'>linux-4.15.y</option>
<option value='linux-4.16.y'>linux-4.16.y</option>
<option value='linux-4.17.y'>linux-4.17.y</option>
<option value='linux-4.18.y'>linux-4.18.y</option>
<option value='linux-4.19.y'>linux-4.19.y</option>
<option value='linux-4.2.y'>linux-4.2.y</option>
<option value='linux-4.20.y'>linux-4.20.y</option>
<option value='linux-4.3.y'>linux-4.3.y</option>
<option value='linux-4.4.y'>linux-4.4.y</option>
<option value='linux-4.5.y'>linux-4.5.y</option>
<option value='linux-4.6.y'>linux-4.6.y</option>
<option value='linux-4.7.y'>linux-4.7.y</option>
<option value='linux-4.8.y'>linux-4.8.y</option>
<option value='linux-4.9.y'>linux-4.9.y</option>
<option value='linux-5.0.y'>linux-5.0.y</option>
<option value='linux-5.1.y'>linux-5.1.y</option>
<option value='linux-5.10.y'>linux-5.10.y</option>
<option value='linux-5.11.y'>linux-5.11.y</option>
<option value='linux-5.12.y'>linux-5.12.y</option>
<option value='linux-5.13.y'>linux-5.13.y</option>
<option value='linux-5.14.y'>linux-5.14.y</option>
<option value='linux-5.15.y'>linux-5.15.y</option>
<option value='linux-5.16.y'>linux-5.16.y</option>
<option value='linux-5.17.y'>linux-5.17.y</option>
<option value='linux-5.18.y'>linux-5.18.y</option>
<option value='linux-5.19.y'>linux-5.19.y</option>
<option value='linux-5.2.y'>linux-5.2.y</option>
<option value='linux-5.3.y'>linux-5.3.y</option>
<option value='linux-5.4.y'>linux-5.4.y</option>
<option value='linux-5.5.y'>linux-5.5.y</option>
<option value='linux-5.6.y'>linux-5.6.y</option>
<option value='linux-5.7.y'>linux-5.7.y</option>
<option value='linux-5.8.y'>linux-5.8.y</option>
<option value='linux-5.9.y'>linux-5.9.y</option>
<option value='linux-6.0.y'>linux-6.0.y</option>
<option value='linux-6.1.y'>linux-6.1.y</option>
<option value='linux-6.10.y'>linux-6.10.y</option>
<option value='linux-6.11.y'>linux-6.11.y</option>
<option value='linux-6.12.y'>linux-6.12.y</option>
<option value='linux-6.2.y'>linux-6.2.y</option>
<option value='linux-6.3.y'>linux-6.3.y</option>
<option value='linux-6.4.y'>linux-6.4.y</option>
<option value='linux-6.5.y'>linux-6.5.y</option>
<option value='linux-6.6.y'>linux-6.6.y</option>
<option value='linux-6.7.y'>linux-6.7.y</option>
<option value='linux-6.8.y'>linux-6.8.y</option>
<option value='linux-6.9.y'>linux-6.9.y</option>
<option value='linux-rolling-lts'>linux-rolling-lts</option>
<option value='linux-rolling-stable'>linux-rolling-stable</option>
<option value='master' selected='selected'>master</option>
</select> <input type='submit' value='switch'/></form></td></tr>
<tr><td class='sub'>Linux kernel stable tree</td><td class='sub right'>Stable Group</td></tr></table>
<table class='tabs'><tr><td>
<a href='/pub/scm/linux/kernel/git/stable/linux.git/about/'>about</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/'>summary</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>refs</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/log/'>log</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>tree</a><a class='active' href='/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>commit</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>diff</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/stats/'>stats</a></td><td class='form'><form class='right' method='get' action='/pub/scm/linux/kernel/git/stable/linux.git/log/'>
<input type='hidden' name='id' value='9c4c6512d7330b743c4ffd18bd999a86ca26db0d'/><select name='qt'>
<option value='grep'>log msg</option>
<option value='author'>author</option>
<option value='committer'>committer</option>
<option value='range'>range</option>
</select>
<input class='txt' type='search' size='10' name='q' value=''/>
<input type='submit' value='search'/>
</form>
</td></tr></table>
<div class='content'><div class='cgit-panel'><b>diff options</b><form method='get'><input type='hidden' name='id' value='9c4c6512d7330b743c4ffd18bd999a86ca26db0d'/><table><tr><td colspan='2'/></tr><tr><td class='label'>context:</td><td class='ctrl'><select name='context' onchange='this.form.submit();'><option value='1'>1</option><option value='2'>2</option><option value='3' selected='selected'>3</option><option value='4'>4</option><option value='5'>5</option><option value='6'>6</option><option value='7'>7</option><option value='8'>8</option><option value='9'>9</option><option value='10'>10</option><option value='15'>15</option><option value='20'>20</option><option value='25'>25</option><option value='30'>30</option><option value='35'>35</option><option value='40'>40</option></select></td></tr><tr><td class='label'>space:</td><td class='ctrl'><select name='ignorews' onchange='this.form.submit();'><option value='0' selected='selected'>include</option><option value='1'>ignore</option></select></td></tr><tr><td class='label'>mode:</td><td class='ctrl'><select name='dt' onchange='this.form.submit();'><option value='0' selected='selected'>unified</option><option value='1'>ssdiff</option><option value='2'>stat only</option></select></td></tr><tr><td/><td class='ctrl'><noscript><input type='submit' value='reload'/></noscript></td></tr></table></form></div><table summary='commit info' class='commit-info'>
<tr><th>author</th><td>Patrick Kelsey &lt;pat.kelsey@cornelisnetworks.com&gt;</td><td class='right'>2023-04-07 12:52:44 -0400</td></tr>
<tr><th>committer</th><td>Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;</td><td class='right'>2023-05-17 11:48:02 +0200</td></tr>
<tr><th>commit</th><td colspan='2' class='oid'><a href='/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>9c4c6512d7330b743c4ffd18bd999a86ca26db0d</a> (<a href='/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>patch</a>)</td></tr>
<tr><th>tree</th><td colspan='2' class='oid'><a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>e29d1f7cbdee75bb66596620a68436709e62db39</a></td></tr>
<tr><th>parent</th><td colspan='2' class='oid'><a href='/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f84c02597857f6b9db24179f9e3ae65942e993fa'>f84c02597857f6b9db24179f9e3ae65942e993fa</a> (<a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d&amp;id2=f84c02597857f6b9db24179f9e3ae65942e993fa'>diff</a>)</td></tr><tr><th>download</th><td colspan='2' class='oid'><a href='/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-9c4c6512d7330b743c4ffd18bd999a86ca26db0d.tar.gz'>linux-9c4c6512d7330b743c4ffd18bd999a86ca26db0d.tar.gz</a><br/></td></tr></table>
<div class='commit-subject'>IB/hfi1: Fix bugs with non-PAGE_SIZE-end multi-iovec user SDMA requests</div><div class='commit-msg'>[ Upstream commit 00cbce5cbf88459cd1aa1d60d0f1df15477df127 ]

hfi1 user SDMA request processing has two bugs that can cause data
corruption for user SDMA requests that have multiple payload iovecs
where an iovec other than the tail iovec does not run up to the page
boundary for the buffer pointed to by that iovec.a

Here are the specific bugs:
1. user_sdma_txadd() does not use struct user_sdma_iovec-&gt;iov.iov_len.
   Rather, user_sdma_txadd() will add up to PAGE_SIZE bytes from iovec
   to the packet, even if some of those bytes are past
   iovec-&gt;iov.iov_len and are thus not intended to be in the packet.
2. user_sdma_txadd() and user_sdma_send_pkts() fail to advance to the
   next iovec in user_sdma_request-&gt;iovs when the current iovec
   is not PAGE_SIZE and does not contain enough data to complete the
   packet. The transmitted packet will contain the wrong data from the
   iovec pages.

This has not been an issue with SDMA packets from hfi1 Verbs or PSM2
because they only produce iovecs that end short of PAGE_SIZE as the tail
iovec of an SDMA request.

Fixing these bugs exposes other bugs with the SDMA pin cache
(struct mmu_rb_handler) that get in way of supporting user SDMA requests
with multiple payload iovecs whose buffers do not end at PAGE_SIZE. So
this commit fixes those issues as well.

Here are the mmu_rb_handler bugs that non-PAGE_SIZE-end multi-iovec
payload user SDMA requests can hit:
1. Overlapping memory ranges in mmu_rb_handler will result in duplicate
   pinnings.
2. When extending an existing mmu_rb_handler entry (struct mmu_rb_node),
   the mmu_rb code (1) removes the existing entry under a lock, (2)
   releases that lock, pins the new pages, (3) then reacquires the lock
   to insert the extended mmu_rb_node.

   If someone else comes in and inserts an overlapping entry between (2)
   and (3), insert in (3) will fail.

   The failure path code in this case unpins _all_ pages in either the
   original mmu_rb_node or the new mmu_rb_node that was inserted between
   (2) and (3).
3. In hfi1_mmu_rb_remove_unless_exact(), mmu_rb_node-&gt;refcount is
   incremented outside of mmu_rb_handler-&gt;lock. As a result, mmu_rb_node
   could be evicted by another thread that gets mmu_rb_handler-&gt;lock and
   checks mmu_rb_node-&gt;refcount before mmu_rb_node-&gt;refcount is
   incremented.
4. Related to #2 above, SDMA request submission failure path does not
   check mmu_rb_node-&gt;refcount before freeing mmu_rb_node object.

   If there are other SDMA requests in progress whose iovecs have
   pointers to the now-freed mmu_rb_node(s), those pointers to the
   now-freed mmu_rb nodes will be dereferenced when those SDMA requests
   complete.

Fixes: 7be85676f1d1 ("IB/hfi1: Don't remove RB entry when not needed.")
Fixes: 7724105686e7 ("IB/hfi1: add driver files")
Signed-off-by: Brendan Cunningham &lt;bcunningham@cornelisnetworks.com&gt;
Signed-off-by: Patrick Kelsey &lt;pat.kelsey@cornelisnetworks.com&gt;
Signed-off-by: Dennis Dalessandro &lt;dennis.dalessandro@cornelisnetworks.com&gt;
Link: <a href="https://lore.kernel.org/r/168088636445.3027109.10054635277810177889.stgit@252.162.96.66.static.eigbox.net">https://lore.kernel.org/r/168088636445.3027109.10054635277810177889.stgit@252.162.96.66.static.eigbox.net</a>
Signed-off-by: Leon Romanovsky &lt;leon@kernel.org&gt;
Signed-off-by: Sasha Levin &lt;sashal@kernel.org&gt;
</div><div class='diffstat-header'><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>Diffstat</a></div><table summary='diffstat' class='diffstat'><tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/infiniband/hw/hfi1/ipoib_tx.c?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>drivers/infiniband/hw/hfi1/ipoib_tx.c</a></td><td class='right'>1</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.2%;'/><td class='rem' style='width: 0.0%;'/><td class='none' style='width: 99.8%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/infiniband/hw/hfi1/mmu_rb.c?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>drivers/infiniband/hw/hfi1/mmu_rb.c</a></td><td class='right'>66</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 2.3%;'/><td class='rem' style='width: 8.7%;'/><td class='none' style='width: 89.0%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/infiniband/hw/hfi1/mmu_rb.h?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>drivers/infiniband/hw/hfi1/mmu_rb.h</a></td><td class='right'>8</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.5%;'/><td class='rem' style='width: 0.8%;'/><td class='none' style='width: 98.7%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/infiniband/hw/hfi1/sdma.c?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>drivers/infiniband/hw/hfi1/sdma.c</a></td><td class='right'>21</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.7%;'/><td class='rem' style='width: 2.8%;'/><td class='none' style='width: 96.5%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/infiniband/hw/hfi1/sdma.h?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>drivers/infiniband/hw/hfi1/sdma.h</a></td><td class='right'>16</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 1.8%;'/><td class='rem' style='width: 0.8%;'/><td class='none' style='width: 97.3%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/infiniband/hw/hfi1/sdma_txreq.h?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>drivers/infiniband/hw/hfi1/sdma_txreq.h</a></td><td class='right'>1</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.2%;'/><td class='rem' style='width: 0.0%;'/><td class='none' style='width: 99.8%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/infiniband/hw/hfi1/trace_mmu.h?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>drivers/infiniband/hw/hfi1/trace_mmu.h</a></td><td class='right'>4</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.0%;'/><td class='rem' style='width: 0.7%;'/><td class='none' style='width: 99.3%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/infiniband/hw/hfi1/user_sdma.c?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>drivers/infiniband/hw/hfi1/user_sdma.c</a></td><td class='right'>600</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 64.3%;'/><td class='rem' style='width: 35.7%;'/><td class='none' style='width: 0.0%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/infiniband/hw/hfi1/user_sdma.h?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>drivers/infiniband/hw/hfi1/user_sdma.h</a></td><td class='right'>5</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.0%;'/><td class='rem' style='width: 0.8%;'/><td class='none' style='width: 99.2%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/infiniband/hw/hfi1/verbs.c?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>drivers/infiniband/hw/hfi1/verbs.c</a></td><td class='right'>4</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.3%;'/><td class='rem' style='width: 0.3%;'/><td class='none' style='width: 99.3%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/infiniband/hw/hfi1/vnic_sdma.c?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>drivers/infiniband/hw/hfi1/vnic_sdma.c</a></td><td class='right'>1</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.2%;'/><td class='rem' style='width: 0.0%;'/><td class='none' style='width: 99.8%;'/></tr></table></td></tr>
</table><div class='diffstat-summary'>11 files changed, 423 insertions, 304 deletions</div><table summary='diff' class='diff'><tr><td><div class='head'>diff --git a/drivers/infiniband/hw/hfi1/ipoib_tx.c b/drivers/infiniband/hw/hfi1/ipoib_tx.c<br/>index ec187ec7467492..956fc3fd88b993 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/infiniband/hw/hfi1/ipoib_tx.c?id=f84c02597857f6b9db24179f9e3ae65942e993fa'>drivers/infiniband/hw/hfi1/ipoib_tx.c</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/infiniband/hw/hfi1/ipoib_tx.c?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>drivers/infiniband/hw/hfi1/ipoib_tx.c</a></div><div class='hunk'>@@ -251,6 +251,7 @@ static int hfi1_ipoib_build_ulp_payload(struct ipoib_txreq *tx,</div><div class='ctx'> 		const skb_frag_t *frag = &amp;skb_shinfo(skb)-&gt;frags[i];</div><div class='ctx'> </div><div class='ctx'> 		ret = sdma_txadd_page(dd,</div><div class='add'>+				      NULL,</div><div class='ctx'> 				      txreq,</div><div class='ctx'> 				      skb_frag_page(frag),</div><div class='ctx'> 				      frag-&gt;bv_offset,</div><div class='head'>diff --git a/drivers/infiniband/hw/hfi1/mmu_rb.c b/drivers/infiniband/hw/hfi1/mmu_rb.c<br/>index d8b6bf271db8f5..d331184ded3088 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/infiniband/hw/hfi1/mmu_rb.c?id=f84c02597857f6b9db24179f9e3ae65942e993fa'>drivers/infiniband/hw/hfi1/mmu_rb.c</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/infiniband/hw/hfi1/mmu_rb.c?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>drivers/infiniband/hw/hfi1/mmu_rb.c</a></div><div class='hunk'>@@ -167,7 +167,7 @@ int hfi1_mmu_rb_insert(struct mmu_rb_handler *handler,</div><div class='ctx'> 	spin_lock_irqsave(&amp;handler-&gt;lock, flags);</div><div class='ctx'> 	node = __mmu_rb_search(handler, mnode-&gt;addr, mnode-&gt;len);</div><div class='ctx'> 	if (node) {</div><div class='del'>-		ret = -EINVAL;</div><div class='add'>+		ret = -EEXIST;</div><div class='ctx'> 		goto unlock;</div><div class='ctx'> 	}</div><div class='ctx'> 	__mmu_int_rb_insert(mnode, &amp;handler-&gt;root);</div><div class='hunk'>@@ -185,6 +185,19 @@ unlock:</div><div class='ctx'> }</div><div class='ctx'> </div><div class='ctx'> /* Caller must hold handler lock */</div><div class='add'>+struct mmu_rb_node *hfi1_mmu_rb_get_first(struct mmu_rb_handler *handler,</div><div class='add'>+					  unsigned long addr, unsigned long len)</div><div class='add'>+{</div><div class='add'>+	struct mmu_rb_node *node;</div><div class='add'>+</div><div class='add'>+	trace_hfi1_mmu_rb_search(addr, len);</div><div class='add'>+	node = __mmu_int_rb_iter_first(&amp;handler-&gt;root, addr, (addr + len) - 1);</div><div class='add'>+	if (node)</div><div class='add'>+		list_move_tail(&amp;node-&gt;list, &amp;handler-&gt;lru_list);</div><div class='add'>+	return node;</div><div class='add'>+}</div><div class='add'>+</div><div class='add'>+/* Caller must hold handler lock */</div><div class='ctx'> static struct mmu_rb_node *__mmu_rb_search(struct mmu_rb_handler *handler,</div><div class='ctx'> 					   unsigned long addr,</div><div class='ctx'> 					   unsigned long len)</div><div class='hunk'>@@ -208,34 +221,6 @@ static struct mmu_rb_node *__mmu_rb_search(struct mmu_rb_handler *handler,</div><div class='ctx'> 	return node;</div><div class='ctx'> }</div><div class='ctx'> </div><div class='del'>-bool hfi1_mmu_rb_remove_unless_exact(struct mmu_rb_handler *handler,</div><div class='del'>-				     unsigned long addr, unsigned long len,</div><div class='del'>-				     struct mmu_rb_node **rb_node)</div><div class='del'>-{</div><div class='del'>-	struct mmu_rb_node *node;</div><div class='del'>-	unsigned long flags;</div><div class='del'>-	bool ret = false;</div><div class='del'>-</div><div class='del'>-	if (current-&gt;mm != handler-&gt;mn.mm)</div><div class='del'>-		return ret;</div><div class='del'>-</div><div class='del'>-	spin_lock_irqsave(&amp;handler-&gt;lock, flags);</div><div class='del'>-	node = __mmu_rb_search(handler, addr, len);</div><div class='del'>-	if (node) {</div><div class='del'>-		if (node-&gt;addr == addr &amp;&amp; node-&gt;len == len) {</div><div class='del'>-			list_move_tail(&amp;node-&gt;list, &amp;handler-&gt;lru_list);</div><div class='del'>-			goto unlock;</div><div class='del'>-		}</div><div class='del'>-		__mmu_int_rb_remove(node, &amp;handler-&gt;root);</div><div class='del'>-		list_del(&amp;node-&gt;list); /* remove from LRU list */</div><div class='del'>-		ret = true;</div><div class='del'>-	}</div><div class='del'>-unlock:</div><div class='del'>-	spin_unlock_irqrestore(&amp;handler-&gt;lock, flags);</div><div class='del'>-	*rb_node = node;</div><div class='del'>-	return ret;</div><div class='del'>-}</div><div class='del'>-</div><div class='ctx'> void hfi1_mmu_rb_evict(struct mmu_rb_handler *handler, void *evict_arg)</div><div class='ctx'> {</div><div class='ctx'> 	struct mmu_rb_node *rbnode, *ptr;</div><div class='hunk'>@@ -266,29 +251,6 @@ void hfi1_mmu_rb_evict(struct mmu_rb_handler *handler, void *evict_arg)</div><div class='ctx'> 	}</div><div class='ctx'> }</div><div class='ctx'> </div><div class='del'>-/*</div><div class='del'>- * It is up to the caller to ensure that this function does not race with the</div><div class='del'>- * mmu invalidate notifier which may be calling the users remove callback on</div><div class='del'>- * 'node'.</div><div class='del'>- */</div><div class='del'>-void hfi1_mmu_rb_remove(struct mmu_rb_handler *handler,</div><div class='del'>-			struct mmu_rb_node *node)</div><div class='del'>-{</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	if (current-&gt;mm != handler-&gt;mn.mm)</div><div class='del'>-		return;</div><div class='del'>-</div><div class='del'>-	/* Validity of handler and node pointers has been checked by caller. */</div><div class='del'>-	trace_hfi1_mmu_rb_remove(node-&gt;addr, node-&gt;len);</div><div class='del'>-	spin_lock_irqsave(&amp;handler-&gt;lock, flags);</div><div class='del'>-	__mmu_int_rb_remove(node, &amp;handler-&gt;root);</div><div class='del'>-	list_del(&amp;node-&gt;list); /* remove from LRU list */</div><div class='del'>-	spin_unlock_irqrestore(&amp;handler-&gt;lock, flags);</div><div class='del'>-</div><div class='del'>-	handler-&gt;ops-&gt;remove(handler-&gt;ops_arg, node);</div><div class='del'>-}</div><div class='del'>-</div><div class='ctx'> static int mmu_notifier_range_start(struct mmu_notifier *mn,</div><div class='ctx'> 		const struct mmu_notifier_range *range)</div><div class='ctx'> {</div><div class='head'>diff --git a/drivers/infiniband/hw/hfi1/mmu_rb.h b/drivers/infiniband/hw/hfi1/mmu_rb.h<br/>index 423aacc67e9488..0265d81c620615 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/infiniband/hw/hfi1/mmu_rb.h?id=f84c02597857f6b9db24179f9e3ae65942e993fa'>drivers/infiniband/hw/hfi1/mmu_rb.h</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/infiniband/hw/hfi1/mmu_rb.h?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>drivers/infiniband/hw/hfi1/mmu_rb.h</a></div><div class='hunk'>@@ -93,10 +93,8 @@ void hfi1_mmu_rb_unregister(struct mmu_rb_handler *handler);</div><div class='ctx'> int hfi1_mmu_rb_insert(struct mmu_rb_handler *handler,</div><div class='ctx'> 		       struct mmu_rb_node *mnode);</div><div class='ctx'> void hfi1_mmu_rb_evict(struct mmu_rb_handler *handler, void *evict_arg);</div><div class='del'>-void hfi1_mmu_rb_remove(struct mmu_rb_handler *handler,</div><div class='del'>-			struct mmu_rb_node *mnode);</div><div class='del'>-bool hfi1_mmu_rb_remove_unless_exact(struct mmu_rb_handler *handler,</div><div class='del'>-				     unsigned long addr, unsigned long len,</div><div class='del'>-				     struct mmu_rb_node **rb_node);</div><div class='add'>+struct mmu_rb_node *hfi1_mmu_rb_get_first(struct mmu_rb_handler *handler,</div><div class='add'>+					  unsigned long addr,</div><div class='add'>+					  unsigned long len);</div><div class='ctx'> </div><div class='ctx'> #endif /* _HFI1_MMU_RB_H */</div><div class='head'>diff --git a/drivers/infiniband/hw/hfi1/sdma.c b/drivers/infiniband/hw/hfi1/sdma.c<br/>index a044bee257f948..061562627dae4e 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/infiniband/hw/hfi1/sdma.c?id=f84c02597857f6b9db24179f9e3ae65942e993fa'>drivers/infiniband/hw/hfi1/sdma.c</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/infiniband/hw/hfi1/sdma.c?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>drivers/infiniband/hw/hfi1/sdma.c</a></div><div class='hunk'>@@ -1635,22 +1635,7 @@ static inline void sdma_unmap_desc(</div><div class='ctx'> 	struct hfi1_devdata *dd,</div><div class='ctx'> 	struct sdma_desc *descp)</div><div class='ctx'> {</div><div class='del'>-	switch (sdma_mapping_type(descp)) {</div><div class='del'>-	case SDMA_MAP_SINGLE:</div><div class='del'>-		dma_unmap_single(</div><div class='del'>-			&amp;dd-&gt;pcidev-&gt;dev,</div><div class='del'>-			sdma_mapping_addr(descp),</div><div class='del'>-			sdma_mapping_len(descp),</div><div class='del'>-			DMA_TO_DEVICE);</div><div class='del'>-		break;</div><div class='del'>-	case SDMA_MAP_PAGE:</div><div class='del'>-		dma_unmap_page(</div><div class='del'>-			&amp;dd-&gt;pcidev-&gt;dev,</div><div class='del'>-			sdma_mapping_addr(descp),</div><div class='del'>-			sdma_mapping_len(descp),</div><div class='del'>-			DMA_TO_DEVICE);</div><div class='del'>-		break;</div><div class='del'>-	}</div><div class='add'>+	system_descriptor_complete(dd, descp);</div><div class='ctx'> }</div><div class='ctx'> </div><div class='ctx'> /*</div><div class='hunk'>@@ -3170,7 +3155,7 @@ int ext_coal_sdma_tx_descs(struct hfi1_devdata *dd, struct sdma_txreq *tx,</div><div class='ctx'> </div><div class='ctx'> 		/* Add descriptor for coalesce buffer */</div><div class='ctx'> 		tx-&gt;desc_limit = MAX_DESC;</div><div class='del'>-		return _sdma_txadd_daddr(dd, SDMA_MAP_SINGLE, tx,</div><div class='add'>+		return _sdma_txadd_daddr(dd, SDMA_MAP_SINGLE, NULL, tx,</div><div class='ctx'> 					 addr, tx-&gt;tlen);</div><div class='ctx'> 	}</div><div class='ctx'> </div><div class='hunk'>@@ -3210,10 +3195,12 @@ int _pad_sdma_tx_descs(struct hfi1_devdata *dd, struct sdma_txreq *tx)</div><div class='ctx'> 			return rval;</div><div class='ctx'> 		}</div><div class='ctx'> 	}</div><div class='add'>+</div><div class='ctx'> 	/* finish the one just added */</div><div class='ctx'> 	make_tx_sdma_desc(</div><div class='ctx'> 		tx,</div><div class='ctx'> 		SDMA_MAP_NONE,</div><div class='add'>+		NULL,</div><div class='ctx'> 		dd-&gt;sdma_pad_phys,</div><div class='ctx'> 		sizeof(u32) - (tx-&gt;packet_len &amp; (sizeof(u32) - 1)));</div><div class='ctx'> 	_sdma_close_tx(dd, tx);</div><div class='head'>diff --git a/drivers/infiniband/hw/hfi1/sdma.h b/drivers/infiniband/hw/hfi1/sdma.h<br/>index 7a851191f9870f..7d4f316ac6e431 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/infiniband/hw/hfi1/sdma.h?id=f84c02597857f6b9db24179f9e3ae65942e993fa'>drivers/infiniband/hw/hfi1/sdma.h</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/infiniband/hw/hfi1/sdma.h?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>drivers/infiniband/hw/hfi1/sdma.h</a></div><div class='hunk'>@@ -635,6 +635,7 @@ static inline dma_addr_t sdma_mapping_addr(struct sdma_desc *d)</div><div class='ctx'> static inline void make_tx_sdma_desc(</div><div class='ctx'> 	struct sdma_txreq *tx,</div><div class='ctx'> 	int type,</div><div class='add'>+	void *pinning_ctx,</div><div class='ctx'> 	dma_addr_t addr,</div><div class='ctx'> 	size_t len)</div><div class='ctx'> {</div><div class='hunk'>@@ -653,6 +654,7 @@ static inline void make_tx_sdma_desc(</div><div class='ctx'> 				&lt;&lt; SDMA_DESC0_PHY_ADDR_SHIFT) |</div><div class='ctx'> 			(((u64)len &amp; SDMA_DESC0_BYTE_COUNT_MASK)</div><div class='ctx'> 				&lt;&lt; SDMA_DESC0_BYTE_COUNT_SHIFT);</div><div class='add'>+	desc-&gt;pinning_ctx = pinning_ctx;</div><div class='ctx'> }</div><div class='ctx'> </div><div class='ctx'> /* helper to extend txreq */</div><div class='hunk'>@@ -685,6 +687,7 @@ static inline void _sdma_close_tx(struct hfi1_devdata *dd,</div><div class='ctx'> static inline int _sdma_txadd_daddr(</div><div class='ctx'> 	struct hfi1_devdata *dd,</div><div class='ctx'> 	int type,</div><div class='add'>+	void *pinning_ctx,</div><div class='ctx'> 	struct sdma_txreq *tx,</div><div class='ctx'> 	dma_addr_t addr,</div><div class='ctx'> 	u16 len)</div><div class='hunk'>@@ -694,6 +697,7 @@ static inline int _sdma_txadd_daddr(</div><div class='ctx'> 	make_tx_sdma_desc(</div><div class='ctx'> 		tx,</div><div class='ctx'> 		type,</div><div class='add'>+		pinning_ctx,</div><div class='ctx'> 		addr, len);</div><div class='ctx'> 	WARN_ON(len &gt; tx-&gt;tlen);</div><div class='ctx'> 	tx-&gt;tlen -= len;</div><div class='hunk'>@@ -714,6 +718,7 @@ static inline int _sdma_txadd_daddr(</div><div class='ctx'> /**</div><div class='ctx'>  * sdma_txadd_page() - add a page to the sdma_txreq</div><div class='ctx'>  * @dd: the device to use for mapping</div><div class='add'>+ * @pinning_ctx: context to be released at descriptor retirement</div><div class='ctx'>  * @tx: tx request to which the page is added</div><div class='ctx'>  * @page: page to map</div><div class='ctx'>  * @offset: offset within the page</div><div class='hunk'>@@ -729,6 +734,7 @@ static inline int _sdma_txadd_daddr(</div><div class='ctx'>  */</div><div class='ctx'> static inline int sdma_txadd_page(</div><div class='ctx'> 	struct hfi1_devdata *dd,</div><div class='add'>+	void *pinning_ctx,</div><div class='ctx'> 	struct sdma_txreq *tx,</div><div class='ctx'> 	struct page *page,</div><div class='ctx'> 	unsigned long offset,</div><div class='hunk'>@@ -756,8 +762,7 @@ static inline int sdma_txadd_page(</div><div class='ctx'> 		return -ENOSPC;</div><div class='ctx'> 	}</div><div class='ctx'> </div><div class='del'>-	return _sdma_txadd_daddr(</div><div class='del'>-			dd, SDMA_MAP_PAGE, tx, addr, len);</div><div class='add'>+	return _sdma_txadd_daddr(dd, SDMA_MAP_PAGE, pinning_ctx, tx, addr, len);</div><div class='ctx'> }</div><div class='ctx'> </div><div class='ctx'> /**</div><div class='hunk'>@@ -791,7 +796,8 @@ static inline int sdma_txadd_daddr(</div><div class='ctx'> 			return rval;</div><div class='ctx'> 	}</div><div class='ctx'> </div><div class='del'>-	return _sdma_txadd_daddr(dd, SDMA_MAP_NONE, tx, addr, len);</div><div class='add'>+	return _sdma_txadd_daddr(dd, SDMA_MAP_NONE, NULL, tx,</div><div class='add'>+				 addr, len);</div><div class='ctx'> }</div><div class='ctx'> </div><div class='ctx'> /**</div><div class='hunk'>@@ -837,8 +843,7 @@ static inline int sdma_txadd_kvaddr(</div><div class='ctx'> 		return -ENOSPC;</div><div class='ctx'> 	}</div><div class='ctx'> </div><div class='del'>-	return _sdma_txadd_daddr(</div><div class='del'>-			dd, SDMA_MAP_SINGLE, tx, addr, len);</div><div class='add'>+	return _sdma_txadd_daddr(dd, SDMA_MAP_SINGLE, NULL, tx, addr, len);</div><div class='ctx'> }</div><div class='ctx'> </div><div class='ctx'> struct iowait_work;</div><div class='hunk'>@@ -1090,4 +1095,5 @@ extern uint mod_num_sdma;</div><div class='ctx'> </div><div class='ctx'> void sdma_update_lmc(struct hfi1_devdata *dd, u64 mask, u32 lid);</div><div class='ctx'> </div><div class='add'>+void system_descriptor_complete(struct hfi1_devdata *dd, struct sdma_desc *descp);</div><div class='ctx'> #endif</div><div class='head'>diff --git a/drivers/infiniband/hw/hfi1/sdma_txreq.h b/drivers/infiniband/hw/hfi1/sdma_txreq.h<br/>index 514a4784566b2a..4204650cebc298 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/infiniband/hw/hfi1/sdma_txreq.h?id=f84c02597857f6b9db24179f9e3ae65942e993fa'>drivers/infiniband/hw/hfi1/sdma_txreq.h</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/infiniband/hw/hfi1/sdma_txreq.h?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>drivers/infiniband/hw/hfi1/sdma_txreq.h</a></div><div class='hunk'>@@ -61,6 +61,7 @@</div><div class='ctx'> struct sdma_desc {</div><div class='ctx'> 	/* private:  don't use directly */</div><div class='ctx'> 	u64 qw[2];</div><div class='add'>+	void *pinning_ctx;</div><div class='ctx'> };</div><div class='ctx'> </div><div class='ctx'> /**</div><div class='head'>diff --git a/drivers/infiniband/hw/hfi1/trace_mmu.h b/drivers/infiniband/hw/hfi1/trace_mmu.h<br/>index 3b7abbc382c209..c3055cff4d6bb0 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/infiniband/hw/hfi1/trace_mmu.h?id=f84c02597857f6b9db24179f9e3ae65942e993fa'>drivers/infiniband/hw/hfi1/trace_mmu.h</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/infiniband/hw/hfi1/trace_mmu.h?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>drivers/infiniband/hw/hfi1/trace_mmu.h</a></div><div class='hunk'>@@ -78,10 +78,6 @@ DEFINE_EVENT(hfi1_mmu_rb_template, hfi1_mmu_rb_search,</div><div class='ctx'> 	     TP_PROTO(unsigned long addr, unsigned long len),</div><div class='ctx'> 	     TP_ARGS(addr, len));</div><div class='ctx'> </div><div class='del'>-DEFINE_EVENT(hfi1_mmu_rb_template, hfi1_mmu_rb_remove,</div><div class='del'>-	     TP_PROTO(unsigned long addr, unsigned long len),</div><div class='del'>-	     TP_ARGS(addr, len));</div><div class='del'>-</div><div class='ctx'> DEFINE_EVENT(hfi1_mmu_rb_template, hfi1_mmu_mem_invalidate,</div><div class='ctx'> 	     TP_PROTO(unsigned long addr, unsigned long len),</div><div class='ctx'> 	     TP_ARGS(addr, len));</div><div class='head'>diff --git a/drivers/infiniband/hw/hfi1/user_sdma.c b/drivers/infiniband/hw/hfi1/user_sdma.c<br/>index da5b2e37355ab3..1eb5a44a4ae6ad 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/infiniband/hw/hfi1/user_sdma.c?id=f84c02597857f6b9db24179f9e3ae65942e993fa'>drivers/infiniband/hw/hfi1/user_sdma.c</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/infiniband/hw/hfi1/user_sdma.c?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>drivers/infiniband/hw/hfi1/user_sdma.c</a></div><div class='hunk'>@@ -65,7 +65,6 @@</div><div class='ctx'> </div><div class='ctx'> #include "hfi.h"</div><div class='ctx'> #include "sdma.h"</div><div class='del'>-#include "mmu_rb.h"</div><div class='ctx'> #include "user_sdma.h"</div><div class='ctx'> #include "verbs.h"  /* for the headers */</div><div class='ctx'> #include "common.h" /* for struct hfi1_tid_info */</div><div class='hunk'>@@ -80,11 +79,7 @@ static unsigned initial_pkt_count = 8;</div><div class='ctx'> static int user_sdma_send_pkts(struct user_sdma_request *req, u16 maxpkts);</div><div class='ctx'> static void user_sdma_txreq_cb(struct sdma_txreq *txreq, int status);</div><div class='ctx'> static inline void pq_update(struct hfi1_user_sdma_pkt_q *pq);</div><div class='del'>-static void user_sdma_free_request(struct user_sdma_request *req, bool unpin);</div><div class='del'>-static int pin_vector_pages(struct user_sdma_request *req,</div><div class='del'>-			    struct user_sdma_iovec *iovec);</div><div class='del'>-static void unpin_vector_pages(struct mm_struct *mm, struct page **pages,</div><div class='del'>-			       unsigned start, unsigned npages);</div><div class='add'>+static void user_sdma_free_request(struct user_sdma_request *req);</div><div class='ctx'> static int check_header_template(struct user_sdma_request *req,</div><div class='ctx'> 				 struct hfi1_pkt_header *hdr, u32 lrhlen,</div><div class='ctx'> 				 u32 datalen);</div><div class='hunk'>@@ -122,6 +117,11 @@ static struct mmu_rb_ops sdma_rb_ops = {</div><div class='ctx'> 	.invalidate = sdma_rb_invalidate</div><div class='ctx'> };</div><div class='ctx'> </div><div class='add'>+static int add_system_pages_to_sdma_packet(struct user_sdma_request *req,</div><div class='add'>+					   struct user_sdma_txreq *tx,</div><div class='add'>+					   struct user_sdma_iovec *iovec,</div><div class='add'>+					   u32 *pkt_remaining);</div><div class='add'>+</div><div class='ctx'> static int defer_packet_queue(</div><div class='ctx'> 	struct sdma_engine *sde,</div><div class='ctx'> 	struct iowait_work *wait,</div><div class='hunk'>@@ -453,6 +453,7 @@ int hfi1_user_sdma_process_request(struct hfi1_filedata *fd,</div><div class='ctx'> 		ret = -EINVAL;</div><div class='ctx'> 		goto free_req;</div><div class='ctx'> 	}</div><div class='add'>+</div><div class='ctx'> 	/* Copy the header from the user buffer */</div><div class='ctx'> 	ret = copy_from_user(&amp;req-&gt;hdr, iovec[idx].iov_base + sizeof(info),</div><div class='ctx'> 			     sizeof(req-&gt;hdr));</div><div class='hunk'>@@ -527,9 +528,8 @@ int hfi1_user_sdma_process_request(struct hfi1_filedata *fd,</div><div class='ctx'> 		memcpy(&amp;req-&gt;iovs[i].iov,</div><div class='ctx'> 		       iovec + idx++,</div><div class='ctx'> 		       sizeof(req-&gt;iovs[i].iov));</div><div class='del'>-		ret = pin_vector_pages(req, &amp;req-&gt;iovs[i]);</div><div class='del'>-		if (ret) {</div><div class='del'>-			req-&gt;data_iovs = i;</div><div class='add'>+		if (req-&gt;iovs[i].iov.iov_len == 0) {</div><div class='add'>+			ret = -EINVAL;</div><div class='ctx'> 			goto free_req;</div><div class='ctx'> 		}</div><div class='ctx'> 		req-&gt;data_len += req-&gt;iovs[i].iov.iov_len;</div><div class='hunk'>@@ -627,7 +627,7 @@ free_req:</div><div class='ctx'> 		if (req-&gt;seqsubmitted)</div><div class='ctx'> 			wait_event(pq-&gt;busy.wait_dma,</div><div class='ctx'> 				   (req-&gt;seqcomp == req-&gt;seqsubmitted - 1));</div><div class='del'>-		user_sdma_free_request(req, true);</div><div class='add'>+		user_sdma_free_request(req);</div><div class='ctx'> 		pq_update(pq);</div><div class='ctx'> 		set_comp_state(pq, cq, info.comp_idx, ERROR, ret);</div><div class='ctx'> 	}</div><div class='hunk'>@@ -739,48 +739,6 @@ static int user_sdma_txadd_ahg(struct user_sdma_request *req,</div><div class='ctx'> 	return ret;</div><div class='ctx'> }</div><div class='ctx'> </div><div class='del'>-static int user_sdma_txadd(struct user_sdma_request *req,</div><div class='del'>-			   struct user_sdma_txreq *tx,</div><div class='del'>-			   struct user_sdma_iovec *iovec, u32 datalen,</div><div class='del'>-			   u32 *queued_ptr, u32 *data_sent_ptr,</div><div class='del'>-			   u64 *iov_offset_ptr)</div><div class='del'>-{</div><div class='del'>-	int ret;</div><div class='del'>-	unsigned int pageidx, len;</div><div class='del'>-	unsigned long base, offset;</div><div class='del'>-	u64 iov_offset = *iov_offset_ptr;</div><div class='del'>-	u32 queued = *queued_ptr, data_sent = *data_sent_ptr;</div><div class='del'>-	struct hfi1_user_sdma_pkt_q *pq = req-&gt;pq;</div><div class='del'>-</div><div class='del'>-	base = (unsigned long)iovec-&gt;iov.iov_base;</div><div class='del'>-	offset = offset_in_page(base + iovec-&gt;offset + iov_offset);</div><div class='del'>-	pageidx = (((iovec-&gt;offset + iov_offset + base) - (base &amp; PAGE_MASK)) &gt;&gt;</div><div class='del'>-		   PAGE_SHIFT);</div><div class='del'>-	len = offset + req-&gt;info.fragsize &gt; PAGE_SIZE ?</div><div class='del'>-		PAGE_SIZE - offset : req-&gt;info.fragsize;</div><div class='del'>-	len = min((datalen - queued), len);</div><div class='del'>-	ret = sdma_txadd_page(pq-&gt;dd, &amp;tx-&gt;txreq, iovec-&gt;pages[pageidx],</div><div class='del'>-			      offset, len);</div><div class='del'>-	if (ret) {</div><div class='del'>-		SDMA_DBG(req, "SDMA txreq add page failed %d\n", ret);</div><div class='del'>-		return ret;</div><div class='del'>-	}</div><div class='del'>-	iov_offset += len;</div><div class='del'>-	queued += len;</div><div class='del'>-	data_sent += len;</div><div class='del'>-	if (unlikely(queued &lt; datalen &amp;&amp; pageidx == iovec-&gt;npages &amp;&amp;</div><div class='del'>-		     req-&gt;iov_idx &lt; req-&gt;data_iovs - 1)) {</div><div class='del'>-		iovec-&gt;offset += iov_offset;</div><div class='del'>-		iovec = &amp;req-&gt;iovs[++req-&gt;iov_idx];</div><div class='del'>-		iov_offset = 0;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	*queued_ptr = queued;</div><div class='del'>-	*data_sent_ptr = data_sent;</div><div class='del'>-	*iov_offset_ptr = iov_offset;</div><div class='del'>-	return ret;</div><div class='del'>-}</div><div class='del'>-</div><div class='ctx'> static int user_sdma_send_pkts(struct user_sdma_request *req, u16 maxpkts)</div><div class='ctx'> {</div><div class='ctx'> 	int ret = 0;</div><div class='hunk'>@@ -812,8 +770,7 @@ static int user_sdma_send_pkts(struct user_sdma_request *req, u16 maxpkts)</div><div class='ctx'> 		maxpkts = req-&gt;info.npkts - req-&gt;seqnum;</div><div class='ctx'> </div><div class='ctx'> 	while (npkts &lt; maxpkts) {</div><div class='del'>-		u32 datalen = 0, queued = 0, data_sent = 0;</div><div class='del'>-		u64 iov_offset = 0;</div><div class='add'>+		u32 datalen = 0;</div><div class='ctx'> </div><div class='ctx'> 		/*</div><div class='ctx'> 		 * Check whether any of the completions have come back</div><div class='hunk'>@@ -906,27 +863,17 @@ static int user_sdma_send_pkts(struct user_sdma_request *req, u16 maxpkts)</div><div class='ctx'> 				goto free_txreq;</div><div class='ctx'> 		}</div><div class='ctx'> </div><div class='del'>-		/*</div><div class='del'>-		 * If the request contains any data vectors, add up to</div><div class='del'>-		 * fragsize bytes to the descriptor.</div><div class='del'>-		 */</div><div class='del'>-		while (queued &lt; datalen &amp;&amp;</div><div class='del'>-		       (req-&gt;sent + data_sent) &lt; req-&gt;data_len) {</div><div class='del'>-			ret = user_sdma_txadd(req, tx, iovec, datalen,</div><div class='del'>-					      &amp;queued, &amp;data_sent, &amp;iov_offset);</div><div class='del'>-			if (ret)</div><div class='del'>-				goto free_txreq;</div><div class='del'>-		}</div><div class='del'>-		/*</div><div class='del'>-		 * The txreq was submitted successfully so we can update</div><div class='del'>-		 * the counters.</div><div class='del'>-		 */</div><div class='ctx'> 		req-&gt;koffset += datalen;</div><div class='ctx'> 		if (req_opcode(req-&gt;info.ctrl) == EXPECTED)</div><div class='ctx'> 			req-&gt;tidoffset += datalen;</div><div class='del'>-		req-&gt;sent += data_sent;</div><div class='del'>-		if (req-&gt;data_len)</div><div class='del'>-			iovec-&gt;offset += iov_offset;</div><div class='add'>+		req-&gt;sent += datalen;</div><div class='add'>+		while (datalen) {</div><div class='add'>+			ret = add_system_pages_to_sdma_packet(req, tx, iovec,</div><div class='add'>+							      &amp;datalen);</div><div class='add'>+			if (ret)</div><div class='add'>+				goto free_txreq;</div><div class='add'>+			iovec = &amp;req-&gt;iovs[req-&gt;iov_idx];</div><div class='add'>+		}</div><div class='ctx'> 		list_add_tail(&amp;tx-&gt;txreq.list, &amp;req-&gt;txps);</div><div class='ctx'> 		/*</div><div class='ctx'> 		 * It is important to increment this here as it is used to</div><div class='hunk'>@@ -963,133 +910,14 @@ free_tx:</div><div class='ctx'> static u32 sdma_cache_evict(struct hfi1_user_sdma_pkt_q *pq, u32 npages)</div><div class='ctx'> {</div><div class='ctx'> 	struct evict_data evict_data;</div><div class='add'>+	struct mmu_rb_handler *handler = pq-&gt;handler;</div><div class='ctx'> </div><div class='ctx'> 	evict_data.cleared = 0;</div><div class='ctx'> 	evict_data.target = npages;</div><div class='del'>-	hfi1_mmu_rb_evict(pq-&gt;handler, &amp;evict_data);</div><div class='add'>+	hfi1_mmu_rb_evict(handler, &amp;evict_data);</div><div class='ctx'> 	return evict_data.cleared;</div><div class='ctx'> }</div><div class='ctx'> </div><div class='del'>-static int pin_sdma_pages(struct user_sdma_request *req,</div><div class='del'>-			  struct user_sdma_iovec *iovec,</div><div class='del'>-			  struct sdma_mmu_node *node,</div><div class='del'>-			  int npages)</div><div class='del'>-{</div><div class='del'>-	int pinned, cleared;</div><div class='del'>-	struct page **pages;</div><div class='del'>-	struct hfi1_user_sdma_pkt_q *pq = req-&gt;pq;</div><div class='del'>-</div><div class='del'>-	pages = kcalloc(npages, sizeof(*pages), GFP_KERNEL);</div><div class='del'>-	if (!pages)</div><div class='del'>-		return -ENOMEM;</div><div class='del'>-	memcpy(pages, node-&gt;pages, node-&gt;npages * sizeof(*pages));</div><div class='del'>-</div><div class='del'>-	npages -= node-&gt;npages;</div><div class='del'>-retry:</div><div class='del'>-	if (!hfi1_can_pin_pages(pq-&gt;dd, current-&gt;mm,</div><div class='del'>-				atomic_read(&amp;pq-&gt;n_locked), npages)) {</div><div class='del'>-		cleared = sdma_cache_evict(pq, npages);</div><div class='del'>-		if (cleared &gt;= npages)</div><div class='del'>-			goto retry;</div><div class='del'>-	}</div><div class='del'>-	pinned = hfi1_acquire_user_pages(current-&gt;mm,</div><div class='del'>-					 ((unsigned long)iovec-&gt;iov.iov_base +</div><div class='del'>-					 (node-&gt;npages * PAGE_SIZE)), npages, 0,</div><div class='del'>-					 pages + node-&gt;npages);</div><div class='del'>-	if (pinned &lt; 0) {</div><div class='del'>-		kfree(pages);</div><div class='del'>-		return pinned;</div><div class='del'>-	}</div><div class='del'>-	if (pinned != npages) {</div><div class='del'>-		unpin_vector_pages(current-&gt;mm, pages, node-&gt;npages, pinned);</div><div class='del'>-		return -EFAULT;</div><div class='del'>-	}</div><div class='del'>-	kfree(node-&gt;pages);</div><div class='del'>-	node-&gt;rb.len = iovec-&gt;iov.iov_len;</div><div class='del'>-	node-&gt;pages = pages;</div><div class='del'>-	atomic_add(pinned, &amp;pq-&gt;n_locked);</div><div class='del'>-	return pinned;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void unpin_sdma_pages(struct sdma_mmu_node *node)</div><div class='del'>-{</div><div class='del'>-	if (node-&gt;npages) {</div><div class='del'>-		unpin_vector_pages(mm_from_sdma_node(node), node-&gt;pages, 0,</div><div class='del'>-				   node-&gt;npages);</div><div class='del'>-		atomic_sub(node-&gt;npages, &amp;node-&gt;pq-&gt;n_locked);</div><div class='del'>-	}</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int pin_vector_pages(struct user_sdma_request *req,</div><div class='del'>-			    struct user_sdma_iovec *iovec)</div><div class='del'>-{</div><div class='del'>-	int ret = 0, pinned, npages;</div><div class='del'>-	struct hfi1_user_sdma_pkt_q *pq = req-&gt;pq;</div><div class='del'>-	struct sdma_mmu_node *node = NULL;</div><div class='del'>-	struct mmu_rb_node *rb_node;</div><div class='del'>-	struct iovec *iov;</div><div class='del'>-	bool extracted;</div><div class='del'>-</div><div class='del'>-	extracted =</div><div class='del'>-		hfi1_mmu_rb_remove_unless_exact(pq-&gt;handler,</div><div class='del'>-						(unsigned long)</div><div class='del'>-						iovec-&gt;iov.iov_base,</div><div class='del'>-						iovec-&gt;iov.iov_len, &amp;rb_node);</div><div class='del'>-	if (rb_node) {</div><div class='del'>-		node = container_of(rb_node, struct sdma_mmu_node, rb);</div><div class='del'>-		if (!extracted) {</div><div class='del'>-			atomic_inc(&amp;node-&gt;refcount);</div><div class='del'>-			iovec-&gt;pages = node-&gt;pages;</div><div class='del'>-			iovec-&gt;npages = node-&gt;npages;</div><div class='del'>-			iovec-&gt;node = node;</div><div class='del'>-			return 0;</div><div class='del'>-		}</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (!node) {</div><div class='del'>-		node = kzalloc(sizeof(*node), GFP_KERNEL);</div><div class='del'>-		if (!node)</div><div class='del'>-			return -ENOMEM;</div><div class='del'>-</div><div class='del'>-		node-&gt;rb.addr = (unsigned long)iovec-&gt;iov.iov_base;</div><div class='del'>-		node-&gt;pq = pq;</div><div class='del'>-		atomic_set(&amp;node-&gt;refcount, 0);</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	iov = &amp;iovec-&gt;iov;</div><div class='del'>-	npages = num_user_pages((unsigned long)iov-&gt;iov_base, iov-&gt;iov_len);</div><div class='del'>-	if (node-&gt;npages &lt; npages) {</div><div class='del'>-		pinned = pin_sdma_pages(req, iovec, node, npages);</div><div class='del'>-		if (pinned &lt; 0) {</div><div class='del'>-			ret = pinned;</div><div class='del'>-			goto bail;</div><div class='del'>-		}</div><div class='del'>-		node-&gt;npages += pinned;</div><div class='del'>-		npages = node-&gt;npages;</div><div class='del'>-	}</div><div class='del'>-	iovec-&gt;pages = node-&gt;pages;</div><div class='del'>-	iovec-&gt;npages = npages;</div><div class='del'>-	iovec-&gt;node = node;</div><div class='del'>-</div><div class='del'>-	ret = hfi1_mmu_rb_insert(req-&gt;pq-&gt;handler, &amp;node-&gt;rb);</div><div class='del'>-	if (ret) {</div><div class='del'>-		iovec-&gt;node = NULL;</div><div class='del'>-		goto bail;</div><div class='del'>-	}</div><div class='del'>-	return 0;</div><div class='del'>-bail:</div><div class='del'>-	unpin_sdma_pages(node);</div><div class='del'>-	kfree(node);</div><div class='del'>-	return ret;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void unpin_vector_pages(struct mm_struct *mm, struct page **pages,</div><div class='del'>-			       unsigned start, unsigned npages)</div><div class='del'>-{</div><div class='del'>-	hfi1_release_user_pages(mm, pages + start, npages, false);</div><div class='del'>-	kfree(pages);</div><div class='del'>-}</div><div class='del'>-</div><div class='ctx'> static int check_header_template(struct user_sdma_request *req,</div><div class='ctx'> 				 struct hfi1_pkt_header *hdr, u32 lrhlen,</div><div class='ctx'> 				 u32 datalen)</div><div class='hunk'>@@ -1431,7 +1259,7 @@ static void user_sdma_txreq_cb(struct sdma_txreq *txreq, int status)</div><div class='ctx'> 	if (req-&gt;seqcomp != req-&gt;info.npkts - 1)</div><div class='ctx'> 		return;</div><div class='ctx'> </div><div class='del'>-	user_sdma_free_request(req, false);</div><div class='add'>+	user_sdma_free_request(req);</div><div class='ctx'> 	set_comp_state(pq, cq, req-&gt;info.comp_idx, state, status);</div><div class='ctx'> 	pq_update(pq);</div><div class='ctx'> }</div><div class='hunk'>@@ -1442,10 +1270,8 @@ static inline void pq_update(struct hfi1_user_sdma_pkt_q *pq)</div><div class='ctx'> 		wake_up(&amp;pq-&gt;wait);</div><div class='ctx'> }</div><div class='ctx'> </div><div class='del'>-static void user_sdma_free_request(struct user_sdma_request *req, bool unpin)</div><div class='add'>+static void user_sdma_free_request(struct user_sdma_request *req)</div><div class='ctx'> {</div><div class='del'>-	int i;</div><div class='del'>-</div><div class='ctx'> 	if (!list_empty(&amp;req-&gt;txps)) {</div><div class='ctx'> 		struct sdma_txreq *t, *p;</div><div class='ctx'> </div><div class='hunk'>@@ -1458,21 +1284,6 @@ static void user_sdma_free_request(struct user_sdma_request *req, bool unpin)</div><div class='ctx'> 		}</div><div class='ctx'> 	}</div><div class='ctx'> </div><div class='del'>-	for (i = 0; i &lt; req-&gt;data_iovs; i++) {</div><div class='del'>-		struct sdma_mmu_node *node = req-&gt;iovs[i].node;</div><div class='del'>-</div><div class='del'>-		if (!node)</div><div class='del'>-			continue;</div><div class='del'>-</div><div class='del'>-		req-&gt;iovs[i].node = NULL;</div><div class='del'>-</div><div class='del'>-		if (unpin)</div><div class='del'>-			hfi1_mmu_rb_remove(req-&gt;pq-&gt;handler,</div><div class='del'>-					   &amp;node-&gt;rb);</div><div class='del'>-		else</div><div class='del'>-			atomic_dec(&amp;node-&gt;refcount);</div><div class='del'>-	}</div><div class='del'>-</div><div class='ctx'> 	kfree(req-&gt;tids);</div><div class='ctx'> 	clear_bit(req-&gt;info.comp_idx, req-&gt;pq-&gt;req_in_use);</div><div class='ctx'> }</div><div class='hunk'>@@ -1490,6 +1301,368 @@ static inline void set_comp_state(struct hfi1_user_sdma_pkt_q *pq,</div><div class='ctx'> 					idx, state, ret);</div><div class='ctx'> }</div><div class='ctx'> </div><div class='add'>+static void unpin_vector_pages(struct mm_struct *mm, struct page **pages,</div><div class='add'>+			       unsigned int start, unsigned int npages)</div><div class='add'>+{</div><div class='add'>+	hfi1_release_user_pages(mm, pages + start, npages, false);</div><div class='add'>+	kfree(pages);</div><div class='add'>+}</div><div class='add'>+</div><div class='add'>+static void free_system_node(struct sdma_mmu_node *node)</div><div class='add'>+{</div><div class='add'>+	if (node-&gt;npages) {</div><div class='add'>+		unpin_vector_pages(mm_from_sdma_node(node), node-&gt;pages, 0,</div><div class='add'>+				   node-&gt;npages);</div><div class='add'>+		atomic_sub(node-&gt;npages, &amp;node-&gt;pq-&gt;n_locked);</div><div class='add'>+	}</div><div class='add'>+	kfree(node);</div><div class='add'>+}</div><div class='add'>+</div><div class='add'>+static inline void acquire_node(struct sdma_mmu_node *node)</div><div class='add'>+{</div><div class='add'>+	atomic_inc(&amp;node-&gt;refcount);</div><div class='add'>+	WARN_ON(atomic_read(&amp;node-&gt;refcount) &lt; 0);</div><div class='add'>+}</div><div class='add'>+</div><div class='add'>+static inline void release_node(struct mmu_rb_handler *handler,</div><div class='add'>+				struct sdma_mmu_node *node)</div><div class='add'>+{</div><div class='add'>+	atomic_dec(&amp;node-&gt;refcount);</div><div class='add'>+	WARN_ON(atomic_read(&amp;node-&gt;refcount) &lt; 0);</div><div class='add'>+}</div><div class='add'>+</div><div class='add'>+static struct sdma_mmu_node *find_system_node(struct mmu_rb_handler *handler,</div><div class='add'>+					      unsigned long start,</div><div class='add'>+					      unsigned long end)</div><div class='add'>+{</div><div class='add'>+	struct mmu_rb_node *rb_node;</div><div class='add'>+	struct sdma_mmu_node *node;</div><div class='add'>+	unsigned long flags;</div><div class='add'>+</div><div class='add'>+	spin_lock_irqsave(&amp;handler-&gt;lock, flags);</div><div class='add'>+	rb_node = hfi1_mmu_rb_get_first(handler, start, (end - start));</div><div class='add'>+	if (!rb_node) {</div><div class='add'>+		spin_unlock_irqrestore(&amp;handler-&gt;lock, flags);</div><div class='add'>+		return NULL;</div><div class='add'>+	}</div><div class='add'>+	node = container_of(rb_node, struct sdma_mmu_node, rb);</div><div class='add'>+	acquire_node(node);</div><div class='add'>+	spin_unlock_irqrestore(&amp;handler-&gt;lock, flags);</div><div class='add'>+</div><div class='add'>+	return node;</div><div class='add'>+}</div><div class='add'>+</div><div class='add'>+static int pin_system_pages(struct user_sdma_request *req,</div><div class='add'>+			    uintptr_t start_address, size_t length,</div><div class='add'>+			    struct sdma_mmu_node *node, int npages)</div><div class='add'>+{</div><div class='add'>+	struct hfi1_user_sdma_pkt_q *pq = req-&gt;pq;</div><div class='add'>+	int pinned, cleared;</div><div class='add'>+	struct page **pages;</div><div class='add'>+</div><div class='add'>+	pages = kcalloc(npages, sizeof(*pages), GFP_KERNEL);</div><div class='add'>+	if (!pages)</div><div class='add'>+		return -ENOMEM;</div><div class='add'>+</div><div class='add'>+retry:</div><div class='add'>+	if (!hfi1_can_pin_pages(pq-&gt;dd, current-&gt;mm, atomic_read(&amp;pq-&gt;n_locked),</div><div class='add'>+				npages)) {</div><div class='add'>+		SDMA_DBG(req, "Evicting: nlocked %u npages %u",</div><div class='add'>+			 atomic_read(&amp;pq-&gt;n_locked), npages);</div><div class='add'>+		cleared = sdma_cache_evict(pq, npages);</div><div class='add'>+		if (cleared &gt;= npages)</div><div class='add'>+			goto retry;</div><div class='add'>+	}</div><div class='add'>+</div><div class='add'>+	SDMA_DBG(req, "Acquire user pages start_address %lx node-&gt;npages %u npages %u",</div><div class='add'>+		 start_address, node-&gt;npages, npages);</div><div class='add'>+	pinned = hfi1_acquire_user_pages(current-&gt;mm, start_address, npages, 0,</div><div class='add'>+					 pages);</div><div class='add'>+</div><div class='add'>+	if (pinned &lt; 0) {</div><div class='add'>+		kfree(pages);</div><div class='add'>+		SDMA_DBG(req, "pinned %d", pinned);</div><div class='add'>+		return pinned;</div><div class='add'>+	}</div><div class='add'>+	if (pinned != npages) {</div><div class='add'>+		unpin_vector_pages(current-&gt;mm, pages, node-&gt;npages, pinned);</div><div class='add'>+		SDMA_DBG(req, "npages %u pinned %d", npages, pinned);</div><div class='add'>+		return -EFAULT;</div><div class='add'>+	}</div><div class='add'>+	node-&gt;rb.addr = start_address;</div><div class='add'>+	node-&gt;rb.len = length;</div><div class='add'>+	node-&gt;pages = pages;</div><div class='add'>+	node-&gt;npages = npages;</div><div class='add'>+	atomic_add(pinned, &amp;pq-&gt;n_locked);</div><div class='add'>+	SDMA_DBG(req, "done. pinned %d", pinned);</div><div class='add'>+	return 0;</div><div class='add'>+}</div><div class='add'>+</div><div class='add'>+static int add_system_pinning(struct user_sdma_request *req,</div><div class='add'>+			      struct sdma_mmu_node **node_p,</div><div class='add'>+			      unsigned long start, unsigned long len)</div><div class='add'>+</div><div class='add'>+{</div><div class='add'>+	struct hfi1_user_sdma_pkt_q *pq = req-&gt;pq;</div><div class='add'>+	struct sdma_mmu_node *node;</div><div class='add'>+	int ret;</div><div class='add'>+</div><div class='add'>+	node = kzalloc(sizeof(*node), GFP_KERNEL);</div><div class='add'>+	if (!node)</div><div class='add'>+		return -ENOMEM;</div><div class='add'>+</div><div class='add'>+	node-&gt;pq = pq;</div><div class='add'>+	ret = pin_system_pages(req, start, len, node, PFN_DOWN(len));</div><div class='add'>+	if (ret == 0) {</div><div class='add'>+		ret = hfi1_mmu_rb_insert(pq-&gt;handler, &amp;node-&gt;rb);</div><div class='add'>+		if (ret)</div><div class='add'>+			free_system_node(node);</div><div class='add'>+		else</div><div class='add'>+			*node_p = node;</div><div class='add'>+</div><div class='add'>+		return ret;</div><div class='add'>+	}</div><div class='add'>+</div><div class='add'>+	kfree(node);</div><div class='add'>+	return ret;</div><div class='add'>+}</div><div class='add'>+</div><div class='add'>+static int get_system_cache_entry(struct user_sdma_request *req,</div><div class='add'>+				  struct sdma_mmu_node **node_p,</div><div class='add'>+				  size_t req_start, size_t req_len)</div><div class='add'>+{</div><div class='add'>+	struct hfi1_user_sdma_pkt_q *pq = req-&gt;pq;</div><div class='add'>+	u64 start = ALIGN_DOWN(req_start, PAGE_SIZE);</div><div class='add'>+	u64 end = PFN_ALIGN(req_start + req_len);</div><div class='add'>+	struct mmu_rb_handler *handler = pq-&gt;handler;</div><div class='add'>+	int ret;</div><div class='add'>+</div><div class='add'>+	if ((end - start) == 0) {</div><div class='add'>+		SDMA_DBG(req,</div><div class='add'>+			 "Request for empty cache entry req_start %lx req_len %lx start %llx end %llx",</div><div class='add'>+			 req_start, req_len, start, end);</div><div class='add'>+		return -EINVAL;</div><div class='add'>+	}</div><div class='add'>+</div><div class='add'>+	SDMA_DBG(req, "req_start %lx req_len %lu", req_start, req_len);</div><div class='add'>+</div><div class='add'>+	while (1) {</div><div class='add'>+		struct sdma_mmu_node *node =</div><div class='add'>+			find_system_node(handler, start, end);</div><div class='add'>+		u64 prepend_len = 0;</div><div class='add'>+</div><div class='add'>+		SDMA_DBG(req, "node %p start %llx end %llu", node, start, end);</div><div class='add'>+		if (!node) {</div><div class='add'>+			ret = add_system_pinning(req, node_p, start,</div><div class='add'>+						 end - start);</div><div class='add'>+			if (ret == -EEXIST) {</div><div class='add'>+				/*</div><div class='add'>+				 * Another execution context has inserted a</div><div class='add'>+				 * conficting entry first.</div><div class='add'>+				 */</div><div class='add'>+				continue;</div><div class='add'>+			}</div><div class='add'>+			return ret;</div><div class='add'>+		}</div><div class='add'>+</div><div class='add'>+		if (node-&gt;rb.addr &lt;= start) {</div><div class='add'>+			/*</div><div class='add'>+			 * This entry covers at least part of the region. If it doesn't extend</div><div class='add'>+			 * to the end, then this will be called again for the next segment.</div><div class='add'>+			 */</div><div class='add'>+			*node_p = node;</div><div class='add'>+			return 0;</div><div class='add'>+		}</div><div class='add'>+</div><div class='add'>+		SDMA_DBG(req, "prepend: node-&gt;rb.addr %lx, node-&gt;refcount %d",</div><div class='add'>+			 node-&gt;rb.addr, atomic_read(&amp;node-&gt;refcount));</div><div class='add'>+		prepend_len = node-&gt;rb.addr - start;</div><div class='add'>+</div><div class='add'>+		/*</div><div class='add'>+		 * This node will not be returned, instead a new node</div><div class='add'>+		 * will be. So release the reference.</div><div class='add'>+		 */</div><div class='add'>+		release_node(handler, node);</div><div class='add'>+</div><div class='add'>+		/* Prepend a node to cover the beginning of the allocation */</div><div class='add'>+		ret = add_system_pinning(req, node_p, start, prepend_len);</div><div class='add'>+		if (ret == -EEXIST) {</div><div class='add'>+			/* Another execution context has inserted a conficting entry first. */</div><div class='add'>+			continue;</div><div class='add'>+		}</div><div class='add'>+		return ret;</div><div class='add'>+	}</div><div class='add'>+}</div><div class='add'>+</div><div class='add'>+static int add_mapping_to_sdma_packet(struct user_sdma_request *req,</div><div class='add'>+				      struct user_sdma_txreq *tx,</div><div class='add'>+				      struct sdma_mmu_node *cache_entry,</div><div class='add'>+				      size_t start,</div><div class='add'>+				      size_t from_this_cache_entry)</div><div class='add'>+{</div><div class='add'>+	struct hfi1_user_sdma_pkt_q *pq = req-&gt;pq;</div><div class='add'>+	unsigned int page_offset;</div><div class='add'>+	unsigned int from_this_page;</div><div class='add'>+	size_t page_index;</div><div class='add'>+	void *ctx;</div><div class='add'>+	int ret;</div><div class='add'>+</div><div class='add'>+	/*</div><div class='add'>+	 * Because the cache may be more fragmented than the memory that is being accessed,</div><div class='add'>+	 * it's not strictly necessary to have a descriptor per cache entry.</div><div class='add'>+	 */</div><div class='add'>+</div><div class='add'>+	while (from_this_cache_entry) {</div><div class='add'>+		page_index = PFN_DOWN(start - cache_entry-&gt;rb.addr);</div><div class='add'>+</div><div class='add'>+		if (page_index &gt;= cache_entry-&gt;npages) {</div><div class='add'>+			SDMA_DBG(req,</div><div class='add'>+				 "Request for page_index %zu &gt;= cache_entry-&gt;npages %u",</div><div class='add'>+				 page_index, cache_entry-&gt;npages);</div><div class='add'>+			return -EINVAL;</div><div class='add'>+		}</div><div class='add'>+</div><div class='add'>+		page_offset = start - ALIGN_DOWN(start, PAGE_SIZE);</div><div class='add'>+		from_this_page = PAGE_SIZE - page_offset;</div><div class='add'>+</div><div class='add'>+		if (from_this_page &lt; from_this_cache_entry) {</div><div class='add'>+			ctx = NULL;</div><div class='add'>+		} else {</div><div class='add'>+			/*</div><div class='add'>+			 * In the case they are equal the next line has no practical effect,</div><div class='add'>+			 * but it's better to do a register to register copy than a conditional</div><div class='add'>+			 * branch.</div><div class='add'>+			 */</div><div class='add'>+			from_this_page = from_this_cache_entry;</div><div class='add'>+			ctx = cache_entry;</div><div class='add'>+		}</div><div class='add'>+</div><div class='add'>+		ret = sdma_txadd_page(pq-&gt;dd, ctx, &amp;tx-&gt;txreq,</div><div class='add'>+				      cache_entry-&gt;pages[page_index],</div><div class='add'>+				      page_offset, from_this_page);</div><div class='add'>+		if (ret) {</div><div class='add'>+			/*</div><div class='add'>+			 * When there's a failure, the entire request is freed by</div><div class='add'>+			 * user_sdma_send_pkts().</div><div class='add'>+			 */</div><div class='add'>+			SDMA_DBG(req,</div><div class='add'>+				 "sdma_txadd_page failed %d page_index %lu page_offset %u from_this_page %u",</div><div class='add'>+				 ret, page_index, page_offset, from_this_page);</div><div class='add'>+			return ret;</div><div class='add'>+		}</div><div class='add'>+		start += from_this_page;</div><div class='add'>+		from_this_cache_entry -= from_this_page;</div><div class='add'>+	}</div><div class='add'>+	return 0;</div><div class='add'>+}</div><div class='add'>+</div><div class='add'>+static int add_system_iovec_to_sdma_packet(struct user_sdma_request *req,</div><div class='add'>+					   struct user_sdma_txreq *tx,</div><div class='add'>+					   struct user_sdma_iovec *iovec,</div><div class='add'>+					   size_t from_this_iovec)</div><div class='add'>+{</div><div class='add'>+	struct mmu_rb_handler *handler = req-&gt;pq-&gt;handler;</div><div class='add'>+</div><div class='add'>+	while (from_this_iovec &gt; 0) {</div><div class='add'>+		struct sdma_mmu_node *cache_entry;</div><div class='add'>+		size_t from_this_cache_entry;</div><div class='add'>+		size_t start;</div><div class='add'>+		int ret;</div><div class='add'>+</div><div class='add'>+		start = (uintptr_t)iovec-&gt;iov.iov_base + iovec-&gt;offset;</div><div class='add'>+		ret = get_system_cache_entry(req, &amp;cache_entry, start,</div><div class='add'>+					     from_this_iovec);</div><div class='add'>+		if (ret) {</div><div class='add'>+			SDMA_DBG(req, "pin system segment failed %d", ret);</div><div class='add'>+			return ret;</div><div class='add'>+		}</div><div class='add'>+</div><div class='add'>+		from_this_cache_entry = cache_entry-&gt;rb.len - (start - cache_entry-&gt;rb.addr);</div><div class='add'>+		if (from_this_cache_entry &gt; from_this_iovec)</div><div class='add'>+			from_this_cache_entry = from_this_iovec;</div><div class='add'>+</div><div class='add'>+		ret = add_mapping_to_sdma_packet(req, tx, cache_entry, start,</div><div class='add'>+						 from_this_cache_entry);</div><div class='add'>+		if (ret) {</div><div class='add'>+			/*</div><div class='add'>+			 * We're guaranteed that there will be no descriptor</div><div class='add'>+			 * completion callback that releases this node</div><div class='add'>+			 * because only the last descriptor referencing it</div><div class='add'>+			 * has a context attached, and a failure means the</div><div class='add'>+			 * last descriptor was never added.</div><div class='add'>+			 */</div><div class='add'>+			release_node(handler, cache_entry);</div><div class='add'>+			SDMA_DBG(req, "add system segment failed %d", ret);</div><div class='add'>+			return ret;</div><div class='add'>+		}</div><div class='add'>+</div><div class='add'>+		iovec-&gt;offset += from_this_cache_entry;</div><div class='add'>+		from_this_iovec -= from_this_cache_entry;</div><div class='add'>+	}</div><div class='add'>+</div><div class='add'>+	return 0;</div><div class='add'>+}</div><div class='add'>+</div><div class='add'>+static int add_system_pages_to_sdma_packet(struct user_sdma_request *req,</div><div class='add'>+					   struct user_sdma_txreq *tx,</div><div class='add'>+					   struct user_sdma_iovec *iovec,</div><div class='add'>+					   u32 *pkt_data_remaining)</div><div class='add'>+{</div><div class='add'>+	size_t remaining_to_add = *pkt_data_remaining;</div><div class='add'>+	/*</div><div class='add'>+	 * Walk through iovec entries, ensure the associated pages</div><div class='add'>+	 * are pinned and mapped, add data to the packet until no more</div><div class='add'>+	 * data remains to be added.</div><div class='add'>+	 */</div><div class='add'>+	while (remaining_to_add &gt; 0) {</div><div class='add'>+		struct user_sdma_iovec *cur_iovec;</div><div class='add'>+		size_t from_this_iovec;</div><div class='add'>+		int ret;</div><div class='add'>+</div><div class='add'>+		cur_iovec = iovec;</div><div class='add'>+		from_this_iovec = iovec-&gt;iov.iov_len - iovec-&gt;offset;</div><div class='add'>+</div><div class='add'>+		if (from_this_iovec &gt; remaining_to_add) {</div><div class='add'>+			from_this_iovec = remaining_to_add;</div><div class='add'>+		} else {</div><div class='add'>+			/* The current iovec entry will be consumed by this pass. */</div><div class='add'>+			req-&gt;iov_idx++;</div><div class='add'>+			iovec++;</div><div class='add'>+		}</div><div class='add'>+</div><div class='add'>+		ret = add_system_iovec_to_sdma_packet(req, tx, cur_iovec,</div><div class='add'>+						      from_this_iovec);</div><div class='add'>+		if (ret)</div><div class='add'>+			return ret;</div><div class='add'>+</div><div class='add'>+		remaining_to_add -= from_this_iovec;</div><div class='add'>+	}</div><div class='add'>+	*pkt_data_remaining = remaining_to_add;</div><div class='add'>+</div><div class='add'>+	return 0;</div><div class='add'>+}</div><div class='add'>+</div><div class='add'>+void system_descriptor_complete(struct hfi1_devdata *dd,</div><div class='add'>+				struct sdma_desc *descp)</div><div class='add'>+{</div><div class='add'>+	switch (sdma_mapping_type(descp)) {</div><div class='add'>+	case SDMA_MAP_SINGLE:</div><div class='add'>+		dma_unmap_single(&amp;dd-&gt;pcidev-&gt;dev, sdma_mapping_addr(descp),</div><div class='add'>+				 sdma_mapping_len(descp), DMA_TO_DEVICE);</div><div class='add'>+		break;</div><div class='add'>+	case SDMA_MAP_PAGE:</div><div class='add'>+		dma_unmap_page(&amp;dd-&gt;pcidev-&gt;dev, sdma_mapping_addr(descp),</div><div class='add'>+			       sdma_mapping_len(descp), DMA_TO_DEVICE);</div><div class='add'>+		break;</div><div class='add'>+	}</div><div class='add'>+</div><div class='add'>+	if (descp-&gt;pinning_ctx) {</div><div class='add'>+		struct sdma_mmu_node *node = descp-&gt;pinning_ctx;</div><div class='add'>+</div><div class='add'>+		release_node(node-&gt;rb.handler, node);</div><div class='add'>+	}</div><div class='add'>+}</div><div class='add'>+</div><div class='ctx'> static bool sdma_rb_filter(struct mmu_rb_node *node, unsigned long addr,</div><div class='ctx'> 			   unsigned long len)</div><div class='ctx'> {</div><div class='hunk'>@@ -1536,8 +1709,7 @@ static void sdma_rb_remove(void *arg, struct mmu_rb_node *mnode)</div><div class='ctx'> 	struct sdma_mmu_node *node =</div><div class='ctx'> 		container_of(mnode, struct sdma_mmu_node, rb);</div><div class='ctx'> </div><div class='del'>-	unpin_sdma_pages(node);</div><div class='del'>-	kfree(node);</div><div class='add'>+	free_system_node(node);</div><div class='ctx'> }</div><div class='ctx'> </div><div class='ctx'> static int sdma_rb_invalidate(void *arg, struct mmu_rb_node *mnode)</div><div class='head'>diff --git a/drivers/infiniband/hw/hfi1/user_sdma.h b/drivers/infiniband/hw/hfi1/user_sdma.h<br/>index fabe5813990684..9d417aacfa8b76 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/infiniband/hw/hfi1/user_sdma.h?id=f84c02597857f6b9db24179f9e3ae65942e993fa'>drivers/infiniband/hw/hfi1/user_sdma.h</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/infiniband/hw/hfi1/user_sdma.h?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>drivers/infiniband/hw/hfi1/user_sdma.h</a></div><div class='hunk'>@@ -153,16 +153,11 @@ struct sdma_mmu_node {</div><div class='ctx'> struct user_sdma_iovec {</div><div class='ctx'> 	struct list_head list;</div><div class='ctx'> 	struct iovec iov;</div><div class='del'>-	/* number of pages in this vector */</div><div class='del'>-	unsigned int npages;</div><div class='del'>-	/* array of pinned pages for this vector */</div><div class='del'>-	struct page **pages;</div><div class='ctx'> 	/*</div><div class='ctx'> 	 * offset into the virtual address space of the vector at</div><div class='ctx'> 	 * which we last left off.</div><div class='ctx'> 	 */</div><div class='ctx'> 	u64 offset;</div><div class='del'>-	struct sdma_mmu_node *node;</div><div class='ctx'> };</div><div class='ctx'> </div><div class='ctx'> /* evict operation argument */</div><div class='head'>diff --git a/drivers/infiniband/hw/hfi1/verbs.c b/drivers/infiniband/hw/hfi1/verbs.c<br/>index 5f3edd255ca3ca..693922df3543b3 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/infiniband/hw/hfi1/verbs.c?id=f84c02597857f6b9db24179f9e3ae65942e993fa'>drivers/infiniband/hw/hfi1/verbs.c</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/infiniband/hw/hfi1/verbs.c?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>drivers/infiniband/hw/hfi1/verbs.c</a></div><div class='hunk'>@@ -820,8 +820,8 @@ static int build_verbs_tx_desc(</div><div class='ctx'> </div><div class='ctx'> 	/* add icrc, lt byte, and padding to flit */</div><div class='ctx'> 	if (extra_bytes)</div><div class='del'>-		ret = sdma_txadd_daddr(sde-&gt;dd, &amp;tx-&gt;txreq,</div><div class='del'>-				       sde-&gt;dd-&gt;sdma_pad_phys, extra_bytes);</div><div class='add'>+		ret = sdma_txadd_daddr(sde-&gt;dd, &amp;tx-&gt;txreq, sde-&gt;dd-&gt;sdma_pad_phys,</div><div class='add'>+				       extra_bytes);</div><div class='ctx'> </div><div class='ctx'> bail_txadd:</div><div class='ctx'> 	return ret;</div><div class='head'>diff --git a/drivers/infiniband/hw/hfi1/vnic_sdma.c b/drivers/infiniband/hw/hfi1/vnic_sdma.c<br/>index 7d90b900131ba2..7658c620a125c4 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/infiniband/hw/hfi1/vnic_sdma.c?id=f84c02597857f6b9db24179f9e3ae65942e993fa'>drivers/infiniband/hw/hfi1/vnic_sdma.c</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/infiniband/hw/hfi1/vnic_sdma.c?id=9c4c6512d7330b743c4ffd18bd999a86ca26db0d'>drivers/infiniband/hw/hfi1/vnic_sdma.c</a></div><div class='hunk'>@@ -106,6 +106,7 @@ static noinline int build_vnic_ulp_payload(struct sdma_engine *sde,</div><div class='ctx'> </div><div class='ctx'> 		/* combine physically continuous fragments later? */</div><div class='ctx'> 		ret = sdma_txadd_page(sde-&gt;dd,</div><div class='add'>+				      NULL,</div><div class='ctx'> 				      &amp;tx-&gt;txreq,</div><div class='ctx'> 				      skb_frag_page(frag),</div><div class='ctx'> 				      skb_frag_off(frag),</div></td></tr></table></div> <!-- class=content -->
<div class='footer'>generated by <a href='https://git.zx2c4.com/cgit/about/'>cgit 1.2.3-korg</a> (<a href='https://git-scm.com/'>git 2.43.0</a>) at 2025-01-11 09:14:36 +0000</div>
</div> <!-- id=cgit -->
</body>
</html>
