

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=343c5372d5e17b306db5f8f3c895539b06e3177f)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=343c5372d5e17b306db5f8f3c895539b06e3177f)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=343c5372d5e17b306db5f8f3c895539b06e3177f)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=343c5372d5e17b306db5f8f3c895539b06e3177f)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Michal Luczaj <mhal@rbox.co> | 2024-04-09 22:09:39 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-05-02 16:18:29 +0200 |
| commit | [343c5372d5e17b306db5f8f3c895539b06e3177f](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=343c5372d5e17b306db5f8f3c895539b06e3177f) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=343c5372d5e17b306db5f8f3c895539b06e3177f)) | |
| tree | [c859a2f18cc1873b40464f8d1dd0b23838997b4d](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=343c5372d5e17b306db5f8f3c895539b06e3177f) | |
| parent | [7f4c391d3b549248118c5227679f6745098c2726](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7f4c391d3b549248118c5227679f6745098c2726) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=343c5372d5e17b306db5f8f3c895539b06e3177f&id2=7f4c391d3b549248118c5227679f6745098c2726)) | |
| download | [linux-343c5372d5e17b306db5f8f3c895539b06e3177f.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-343c5372d5e17b306db5f8f3c895539b06e3177f.tar.gz) | |

af\_unix: Fix garbage collector racing against connect()[ Upstream commit 47d8ac011fe1c9251070e1bd64cb10b48193ec51 ]
Garbage collector does not take into account the risk of embryo getting
enqueued during the garbage collection. If such embryo has a peer that
carries SCM\_RIGHTS, two consecutive passes of scan\_children() may see a
different set of children. Leading to an incorrectly elevated inflight
count, and then a dangling pointer within the gc\_inflight\_list.
sockets are AF\_UNIX/SOCK\_STREAM
S is an unconnected socket
L is a listening in-flight socket bound to addr, not in fdtable
V's fd will be passed via sendmsg(), gets inflight count bumped
connect(S, addr) sendmsg(S, [V]); close(V) \_\_unix\_gc()
---------------- ------------------------- -----------
NS = unix\_create1()
skb1 = sock\_wmalloc(NS)
L = unix\_find\_other(addr)
unix\_state\_lock(L)
unix\_peer(S) = NS
// V count=1 inflight=0
NS = unix\_peer(S)
skb2 = sock\_alloc()
skb\_queue\_tail(NS, skb2[V])
// V became in-flight
// V count=2 inflight=1
close(V)
// V count=1 inflight=1
// GC candidate condition met
for u in gc\_inflight\_list:
if (total\_refs == inflight\_refs)
add u to gc\_candidates
// gc\_candidates={L, V}
for u in gc\_candidates:
scan\_children(u, dec\_inflight)
// embryo (skb1) was not
// reachable from L yet, so V's
// inflight remains unchanged
\_\_skb\_queue\_tail(L, skb1)
unix\_state\_unlock(L)
for u in gc\_candidates:
if (u.inflight)
scan\_children(u, inc\_inflight\_move\_tail)
// V count=1 inflight=2 (!)
If there is a GC-candidate listening socket, lock/unlock its state. This
makes GC wait until the end of any ongoing connect() to that socket. After
flipping the lock, a possibly SCM-laden embryo is already enqueued. And if
there is another embryo coming, it can not possibly carry SCM\_RIGHTS. At
this point, unix\_inflight() can not happen because unix\_gc\_lock is already
taken. Inflight graph remains unaffected.
Fixes: 1fd05ba5a2f2 ("[AF\_UNIX]: Rewrite garbage collector, fixes race.")
Signed-off-by: Michal Luczaj <mhal@rbox.co>
Reviewed-by: Kuniyuki Iwashima <kuniyu@amazon.com>
Link: [https://lore.kernel.org/r/20240409201047.1032217-1-mhal@rbox.co](https://lore.kernel.org/r/20240409201047.1032217-1-mhal%40rbox.co)
Signed-off-by: Paolo Abeni <pabeni@redhat.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=343c5372d5e17b306db5f8f3c895539b06e3177f)

| -rw-r--r-- | [net/unix/garbage.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/unix/garbage.c?id=343c5372d5e17b306db5f8f3c895539b06e3177f) | 18 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 17 insertions, 1 deletions

| diff --git a/net/unix/garbage.c b/net/unix/garbage.cindex 675fbe594dbb35..58525311e903a1 100644--- a/[net/unix/garbage.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/unix/garbage.c?id=7f4c391d3b549248118c5227679f6745098c2726)+++ b/[net/unix/garbage.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/unix/garbage.c?id=343c5372d5e17b306db5f8f3c895539b06e3177f)@@ -235,11 +235,22 @@ void unix\_gc(void) \* receive queues. Other, non candidate sockets \_can\_ be \* added to queue, so we must make sure only to touch \* candidates.+ \*+ \* Embryos, though never candidates themselves, affect which+ \* candidates are reachable by the garbage collector. Before+ \* being added to a listener's queue, an embryo may already+ \* receive data carrying SCM\_RIGHTS, potentially making the+ \* passed socket a candidate that is not yet reachable by the+ \* collector. It becomes reachable once the embryo is+ \* enqueued. Therefore, we must ensure that no SCM-laden+ \* embryo appears in a (candidate) listener's queue between+ \* consecutive scan\_children() calls. \*/ list\_for\_each\_entry\_safe(u, next, &gc\_inflight\_list, link) {+ struct sock \*sk = &u->sk; long total\_refs; - total\_refs = file\_count(u->sk.sk\_socket->file);+ total\_refs = file\_count(sk->sk\_socket->file);  BUG\_ON(!u->inflight); BUG\_ON(total\_refs < u->inflight);@@ -247,6 +258,11 @@ void unix\_gc(void) list\_move\_tail(&u->link, &gc\_candidates); \_\_set\_bit(UNIX\_GC\_CANDIDATE, &u->gc\_flags); \_\_set\_bit(UNIX\_GC\_MAYBE\_CYCLE, &u->gc\_flags);++ if (sk->sk\_state == TCP\_LISTEN) {+ unix\_state\_lock(sk);+ unix\_state\_unlock(sk);+ } } } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 13:03:18 +0000

