The provided content relates to CVE-2022-48840.

**Root cause of vulnerability:**
A recently introduced wait-loop in the `iavf_remove()` function, intended to ensure port initialization is complete before unregistering the network device, causes a hang during reboot/shutdown scenarios. The issue arises because the `iavf_shutdown()` callback detaches the device and sets its state to `__IAVF_REMOVE`, while the subsequent shutdown callback of the associated PF driver calls `sriov_disable()`, which indirectly calls `iavf_remove()`.  Since the adapter state is already `__IAVF_REMOVE`, the wait-loop in `iavf_remove()` becomes endless, causing the system to hang.

**Weaknesses/vulnerabilities present:**
- Infinite loop/deadlock due to incorrect state management during shutdown.
- Race condition between the `iavf_shutdown()` callback and the PF driver's shutdown sequence which both call `iavf_remove`
- Lack of a proper check in `iavf_remove()` to prevent looping when the adapter is already in remove state.

**Impact of exploitation:**
- System hang/unresponsiveness during reboot or shutdown.
- Denial of service (DoS) due to the system becoming unusable.

**Attack vectors:**
- Triggering a system reboot or shutdown.
- Having a VF bound to the iavf driver on a PF driven by either the ice or i40e driver.

**Required attacker capabilities/position:**
- Ability to initiate a system reboot/shutdown.
- Needs a system configured with the vulnerable iavf driver, and a VF on a PF driven by ice or i40e drivers.