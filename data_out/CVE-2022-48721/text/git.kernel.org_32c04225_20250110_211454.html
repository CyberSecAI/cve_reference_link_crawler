

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=341adeec9adad0874f29a0a1af35638207352a39)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=341adeec9adad0874f29a0a1af35638207352a39)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=341adeec9adad0874f29a0a1af35638207352a39)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=341adeec9adad0874f29a0a1af35638207352a39)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Wen Gu <guwen@linux.alibaba.com> | 2022-01-26 23:33:04 +0800 |
| --- | --- | --- |
| committer | David S. Miller <davem@davemloft.net> | 2022-01-31 11:07:13 +0000 |
| commit | [341adeec9adad0874f29a0a1af35638207352a39](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=341adeec9adad0874f29a0a1af35638207352a39) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=341adeec9adad0874f29a0a1af35638207352a39)) | |
| tree | [bfe9bc5f0ef8d15aa44e177d1fa37bc9970d0099](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=341adeec9adad0874f29a0a1af35638207352a39) | |
| parent | [6449520391dfc3d2cef134f11a91251a054ff7d0](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6449520391dfc3d2cef134f11a91251a054ff7d0) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=341adeec9adad0874f29a0a1af35638207352a39&id2=6449520391dfc3d2cef134f11a91251a054ff7d0)) | |
| download | [linux-341adeec9adad0874f29a0a1af35638207352a39.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-341adeec9adad0874f29a0a1af35638207352a39.tar.gz) | |

net/smc: Forward wakeup to smc socket waitqueue after fallbackWhen we replace TCP with SMC and a fallback occurs, there may be
some socket waitqueue entries remaining in smc socket->wq, such
as eppoll\_entries inserted by userspace applications.
After the fallback, data flows over TCP/IP and only clcsocket->wq
will be woken up. Applications can't be notified by the entries
which were inserted in smc socket->wq before fallback. So we need
a mechanism to wake up smc socket->wq at the same time if some
entries remaining in it.
The current workaround is to transfer the entries from smc socket->wq
to clcsock->wq during the fallback. But this may cause a crash
like this:
general protection fault, probably for non-canonical address 0xdead000000000100: 0000 [#1] PREEMPT SMP PTI
CPU: 3 PID: 0 Comm: swapper/3 Kdump: loaded Tainted: G E 5.16.0+ #107
RIP: 0010:\_\_wake\_up\_common+0x65/0x170
Call Trace:
<IRQ>
\_\_wake\_up\_common\_lock+0x7a/0xc0
sock\_def\_readable+0x3c/0x70
tcp\_data\_queue+0x4a7/0xc40
tcp\_rcv\_established+0x32f/0x660
? sk\_filter\_trim\_cap+0xcb/0x2e0
tcp\_v4\_do\_rcv+0x10b/0x260
tcp\_v4\_rcv+0xd2a/0xde0
ip\_protocol\_deliver\_rcu+0x3b/0x1d0
ip\_local\_deliver\_finish+0x54/0x60
ip\_local\_deliver+0x6a/0x110
? tcp\_v4\_early\_demux+0xa2/0x140
? tcp\_v4\_early\_demux+0x10d/0x140
ip\_sublist\_rcv\_finish+0x49/0x60
ip\_sublist\_rcv+0x19d/0x230
ip\_list\_rcv+0x13e/0x170
\_\_netif\_receive\_skb\_list\_core+0x1c2/0x240
netif\_receive\_skb\_list\_internal+0x1e6/0x320
napi\_complete\_done+0x11d/0x190
mlx5e\_napi\_poll+0x163/0x6b0 [mlx5\_core]
\_\_napi\_poll+0x3c/0x1b0
net\_rx\_action+0x27c/0x300
\_\_do\_softirq+0x114/0x2d2
irq\_exit\_rcu+0xb4/0xe0
common\_interrupt+0xba/0xe0
</IRQ>
<TASK>
The crash is caused by privately transferring waitqueue entries from
smc socket->wq to clcsock->wq. The owners of these entries, such as
epoll, have no idea that the entries have been transferred to a
different socket wait queue and still use original waitqueue spinlock
(smc socket->wq.wait.lock) to make the entries operation exclusive,
but it doesn't work. The operations to the entries, such as removing
from the waitqueue (now is clcsock->wq after fallback), may cause a
crash when clcsock waitqueue is being iterated over at the moment.
This patch tries to fix this by no longer transferring wait queue
entries privately, but introducing own implementations of clcsock's
callback functions in fallback situation. The callback functions will
forward the wakeup to smc socket->wq if clcsock->wq is actually woken
up and smc socket->wq has remaining entries.
Fixes: 2153bd1e3d3d ("net/smc: Transfer remaining wait queue entries during fallback")
Suggested-by: Karsten Graul <kgraul@linux.ibm.com>
Signed-off-by: Wen Gu <guwen@linux.alibaba.com>
Acked-by: Karsten Graul <kgraul@linux.ibm.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=341adeec9adad0874f29a0a1af35638207352a39)

| -rw-r--r-- | [net/smc/af\_smc.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/smc/af_smc.c?id=341adeec9adad0874f29a0a1af35638207352a39) | 133 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/smc/smc.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/smc/smc.h?id=341adeec9adad0874f29a0a1af35638207352a39) | 20 | |  |  |  | | --- | --- | --- | |

2 files changed, 137 insertions, 16 deletions

| diff --git a/net/smc/af\_smc.c b/net/smc/af\_smc.cindex d5ea62b82bb897..8c89d0b0ca1857 100644--- a/[net/smc/af\_smc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/smc/af_smc.c?id=6449520391dfc3d2cef134f11a91251a054ff7d0)+++ b/[net/smc/af\_smc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/smc/af_smc.c?id=341adeec9adad0874f29a0a1af35638207352a39)@@ -566,17 +566,115 @@ static void smc\_stat\_fallback(struct smc\_sock \*smc) mutex\_unlock(&net->smc.mutex\_fback\_rsn); } +/\* must be called under rcu read lock \*/+static void smc\_fback\_wakeup\_waitqueue(struct smc\_sock \*smc, void \*key)+{+ struct socket\_wq \*wq;+ \_\_poll\_t flags;++ wq = rcu\_dereference(smc->sk.sk\_wq);+ if (!skwq\_has\_sleeper(wq))+ return;++ /\* wake up smc sk->sk\_wq \*/+ if (!key) {+ /\* sk\_state\_change \*/+ wake\_up\_interruptible\_all(&wq->wait);+ } else {+ flags = key\_to\_poll(key);+ if (flags & (EPOLLIN | EPOLLOUT))+ /\* sk\_data\_ready or sk\_write\_space \*/+ wake\_up\_interruptible\_sync\_poll(&wq->wait, flags);+ else if (flags & EPOLLERR)+ /\* sk\_error\_report \*/+ wake\_up\_interruptible\_poll(&wq->wait, flags);+ }+}++static int smc\_fback\_mark\_woken(wait\_queue\_entry\_t \*wait,+ unsigned int mode, int sync, void \*key)+{+ struct smc\_mark\_woken \*mark =+ container\_of(wait, struct smc\_mark\_woken, wait\_entry);++ mark->woken = true;+ mark->key = key;+ return 0;+}++static void smc\_fback\_forward\_wakeup(struct smc\_sock \*smc, struct sock \*clcsk,+ void (\*clcsock\_callback)(struct sock \*sk))+{+ struct smc\_mark\_woken mark = { .woken = false };+ struct socket\_wq \*wq;++ init\_waitqueue\_func\_entry(&mark.wait\_entry,+ smc\_fback\_mark\_woken);+ rcu\_read\_lock();+ wq = rcu\_dereference(clcsk->sk\_wq);+ if (!wq)+ goto out;+ add\_wait\_queue(sk\_sleep(clcsk), &mark.wait\_entry);+ clcsock\_callback(clcsk);+ remove\_wait\_queue(sk\_sleep(clcsk), &mark.wait\_entry);++ if (mark.woken)+ smc\_fback\_wakeup\_waitqueue(smc, mark.key);+out:+ rcu\_read\_unlock();+}++static void smc\_fback\_state\_change(struct sock \*clcsk)+{+ struct smc\_sock \*smc =+ smc\_clcsock\_user\_data(clcsk);++ if (!smc)+ return;+ smc\_fback\_forward\_wakeup(smc, clcsk, smc->clcsk\_state\_change);+}++static void smc\_fback\_data\_ready(struct sock \*clcsk)+{+ struct smc\_sock \*smc =+ smc\_clcsock\_user\_data(clcsk);++ if (!smc)+ return;+ smc\_fback\_forward\_wakeup(smc, clcsk, smc->clcsk\_data\_ready);+}++static void smc\_fback\_write\_space(struct sock \*clcsk)+{+ struct smc\_sock \*smc =+ smc\_clcsock\_user\_data(clcsk);++ if (!smc)+ return;+ smc\_fback\_forward\_wakeup(smc, clcsk, smc->clcsk\_write\_space);+}++static void smc\_fback\_error\_report(struct sock \*clcsk)+{+ struct smc\_sock \*smc =+ smc\_clcsock\_user\_data(clcsk);++ if (!smc)+ return;+ smc\_fback\_forward\_wakeup(smc, clcsk, smc->clcsk\_error\_report);+}+ static int smc\_switch\_to\_fallback(struct smc\_sock \*smc, int reason\_code) {- wait\_queue\_head\_t \*smc\_wait = sk\_sleep(&smc->sk);- wait\_queue\_head\_t \*clc\_wait;- unsigned long flags;+ struct sock \*clcsk;  mutex\_lock(&smc->clcsock\_release\_lock); if (!smc->clcsock) { mutex\_unlock(&smc->clcsock\_release\_lock); return -EBADF; }+ clcsk = smc->clcsock->sk;+ smc->use\_fallback = true; smc->fallback\_rsn = reason\_code; smc\_stat\_fallback(smc);@@ -587,16 +685,22 @@ static int smc\_switch\_to\_fallback(struct smc\_sock \*smc, int reason\_code) smc->clcsock->wq.fasync\_list = smc->sk.sk\_socket->wq.fasync\_list; - /\* There may be some entries remaining in- \* smc socket->wq, which should be removed- \* to clcsocket->wq during the fallback.+ /\* There might be some wait entries remaining+ \* in smc sk->sk\_wq and they should be woken up+ \* as clcsock's wait queue is woken up. \*/- clc\_wait = sk\_sleep(smc->clcsock->sk);- spin\_lock\_irqsave(&smc\_wait->lock, flags);- spin\_lock\_nested(&clc\_wait->lock, SINGLE\_DEPTH\_NESTING);- list\_splice\_init(&smc\_wait->head, &clc\_wait->head);- spin\_unlock(&clc\_wait->lock);- spin\_unlock\_irqrestore(&smc\_wait->lock, flags);+ smc->clcsk\_state\_change = clcsk->sk\_state\_change;+ smc->clcsk\_data\_ready = clcsk->sk\_data\_ready;+ smc->clcsk\_write\_space = clcsk->sk\_write\_space;+ smc->clcsk\_error\_report = clcsk->sk\_error\_report;++ clcsk->sk\_state\_change = smc\_fback\_state\_change;+ clcsk->sk\_data\_ready = smc\_fback\_data\_ready;+ clcsk->sk\_write\_space = smc\_fback\_write\_space;+ clcsk->sk\_error\_report = smc\_fback\_error\_report;++ smc->clcsock->sk->sk\_user\_data =+ (void \*)((uintptr\_t)smc | SK\_USER\_DATA\_NOCOPY); } mutex\_unlock(&smc->clcsock\_release\_lock); return 0;@@ -2115,10 +2219,9 @@ out:  static void smc\_clcsock\_data\_ready(struct sock \*listen\_clcsock) {- struct smc\_sock \*lsmc;+ struct smc\_sock \*lsmc =+ smc\_clcsock\_user\_data(listen\_clcsock); - lsmc = (struct smc\_sock \*)- ((uintptr\_t)listen\_clcsock->sk\_user\_data & ~SK\_USER\_DATA\_NOCOPY); if (!lsmc) return; lsmc->clcsk\_data\_ready(listen\_clcsock);diff --git a/net/smc/smc.h b/net/smc/smc.hindex 3d0b8e300deb32..37b2001a02557e 100644--- a/[net/smc/smc.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/smc/smc.h?id=6449520391dfc3d2cef134f11a91251a054ff7d0)+++ b/[net/smc/smc.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/smc/smc.h?id=341adeec9adad0874f29a0a1af35638207352a39)@@ -139,6 +139,12 @@ enum smc\_urg\_state { SMC\_URG\_READ = 3, /\* data was already read \*/ }; +struct smc\_mark\_woken {+ bool woken;+ void \*key;+ wait\_queue\_entry\_t wait\_entry;+};+ struct smc\_connection { struct rb\_node alert\_node; struct smc\_link\_group \*lgr; /\* link group of connection \*/@@ -228,8 +234,14 @@ struct smc\_connection { struct smc\_sock { /\* smc sock container \*/ struct sock sk; struct socket \*clcsock; /\* internal tcp socket \*/+ void (\*clcsk\_state\_change)(struct sock \*sk);+ /\* original stat\_change fct. \*/ void (\*clcsk\_data\_ready)(struct sock \*sk);- /\* original data\_ready fct. \*\*/+ /\* original data\_ready fct. \*/+ void (\*clcsk\_write\_space)(struct sock \*sk);+ /\* original write\_space fct. \*/+ void (\*clcsk\_error\_report)(struct sock \*sk);+ /\* original error\_report fct. \*/ struct smc\_connection conn; /\* smc connection \*/ struct smc\_sock \*listen\_smc; /\* listen parent \*/ struct work\_struct connect\_work; /\* handle non-blocking connect\*/@@ -264,6 +276,12 @@ static inline struct smc\_sock \*smc\_sk(const struct sock \*sk) return (struct smc\_sock \*)sk; } +static inline struct smc\_sock \*smc\_clcsock\_user\_data(struct sock \*clcsk)+{+ return (struct smc\_sock \*)+ ((uintptr\_t)clcsk->sk\_user\_data & ~SK\_USER\_DATA\_NOCOPY);+}+ extern struct workqueue\_struct \*smc\_hs\_wq; /\* wq for handshake work \*/ extern struct workqueue\_struct \*smc\_close\_wq; /\* wq for close work \*/ |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 21:13:32 +0000

