

# [0patch Blog](https://blog.0patch.com/)

Security Patching Simplified To The Extreme

## Tuesday, June 4, 2019

Posted by

[Mitja Kolsek](https://www.blogger.com/profile/00089863558178974677 "author profile")

on

[June 04, 2019](https://blog.0patch.com/2019/06/another-task-scheduler-0day-another.html "permanent link")

### Another Task Scheduler 0day, Another Task Scheduler Micropatch (The SandboxEscaper Saga)

**Backward Compatibility is Hard, and so is Stacked Impersonation**

by Simon Raner and Mitja Kolsek, the 0patch Team

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgXmuPJy_weIzznZGs1PxTJ8yEFspygp8FWo5NoCIr-UjYYNGYL2P3mQapVP5ssy2ZpagJj7sLS9tlj6BSgTcqsIzjHWCQNrNOnS8B8r0A720inpb5U-pdAKM6VH6YyRs36bOJZ4RaKj3_-/s640/polar_bear_2339577.jpg)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgXmuPJy_weIzznZGs1PxTJ8yEFspygp8FWo5NoCIr-UjYYNGYL2P3mQapVP5ssy2ZpagJj7sLS9tlj6BSgTcqsIzjHWCQNrNOnS8B8r0A720inpb5U-pdAKM6VH6YyRs36bOJZ4RaKj3_-/s1600/polar_bear_2339577.jpg)

[Update 6/12/2019: Yesterday's Windows Updates include a fix for this vulnerability, 12 days after our micropatch has been released. The issue was assigned CVE-2019-1069.]

Last August [we issued a micropatch](https://blog.0patch.com/2018/08/how-we-micropatched-publicly-dropped.html) for a local privilege escalation 0day in Task Scheduler, published by [SandboxEscaper](http://sandboxescaper.blogspot.com/). The vulnerability allowed a local attacker on a Windows machine to change permissions of any chosen file, including system executables, such that the attacker would subsequently be able to modify that file. This obviously allowed for privilege escalation, although many system files can't be changed even with suitable permissions either due to being owned by TrustedInstaller or due to being in use. Nevertheless, at least one such file can always be found.

Fast forward to last week. [SandboxEscaper has dropped three Windows 0days](https://arstechnica.com/information-technology/2019/05/serial-publisher-of-windows-0days-drops-exploits-for-3-more-unfixed-flaws/), one of which is again a local privilege escalation in Task Scheduler. We tested it and it worked on a fully patched Windows 10 machine. [According to Will Dormann of CERT/CC](https://www.kb.cert.org/vuls/id/119704/), the exploit "*functions reliably on 32- and 64-bit Windows 10 platforms, as well as
Windows Server 2016 and Windows Server 2019. While Windows 8 still
contains this vulnerability, exploitation using the publicly-described
technique is limited to files where the current user has write access,
in our testing. As such, the impact on Windows 8 systems using the
technique used by the public exploit appears to be negligible. We have
not been able to demonstrate the vulnerability on Windows 7 systems.*"

## Analysis

Analysis always starts with reproducing the POC.  It comes as a Windows executable that takes two arguments, username and password of a local low-privileged user. Let's see what it does when we run it as a low-privileged user test:

C:\Temp\Vuln-5172\_bearlpe\Exploit>**whoami**
0p-win-10-ent-3\test

C:\Temp\Vuln-5172\_bearlpe\Exploit>**icacls "c:\Windows\system32\drivers\pci.sys"**
c:\Windows\system32\drivers\pci.sys NT AUTHORITY\SYSTEM:(I)(F)
                                    BUILTIN\Administrators:(I)(F)
                                    BUILTIN\Users:(I)(RX)
                                    APPLICATION PACKAGE AUTHORITY\ALL APPLICATION PACKAGES:(I)(RX)
                                    APPLICATION PACKAGE AUTHORITY\ALL RESTRICTED APP PACKAGES:(I)(RX)

Successfully processed 1 files; Failed processing 0 files

C:\Temp\Vuln-5172\_bearlpe\Exploit>**polarbear.exe test test**
SUCCESS: The parameters of scheduled task "bear" have been changed.
SUCCESS: The parameters of scheduled task "bear" have been changed.

C:\Temp\Vuln-5172\_bearlpe\Exploit>**icacls "c:\Windows\system32\drivers\pci.sys"**
c:\Windows\system32\drivers\pci.sys NT AUTHORITY\SYSTEM:(Rc,S,X,RA)
                                    0P-WIN-10-ENT-3\test:(R)
                                    BUILTIN\Administrators:(I)(R,W,D,WDAC,WO)
                                    NT AUTHORITY\SYSTEM:(I)(R,W,D,WDAC,WO)
                                    0P-WIN-10-ENT-3\test:(I)(F)

Successfully processed 1 files; Failed processing 0 files

Obviously, the POC was able to change permissions on pci.sys. Furthermore, in contrast to the last year's Task Scheduler 0day we had micropatched, this one also changed the ownership of the target file; not being owned by TrustedInstaller any more, pci.sys could be modified freely by the attacker.

Its operation is fairly simple; when launched with credentials of a low-privileged user test with password test, the POC performs these steps (as seen from its source code):

1. Copy file bear.job to c:\windows\tasks\bear.job
2. Execute schtasks.exe /change /TN \"bear\" /RU test /RP test
   (This instructs Task Scheduler to take bear.job created above and create a new scheduled tasks - resulting in a new file c:\windows\system32\tasks\Bear. Note that a legacy schtasks.exe from Windows XP is used, which uses legacy RPC interface for that.)
3. Delete  c:\windows\system32\tasks\Bear.
4. Create a [hard link](https://docs.microsoft.com/en-us/windows/desktop/fileio/hard-links-and-junctions) c:\windows\system32\tasks\Bear, pointing to system file c:\windows\system32\drivers\pci.sys.
5. Again, execute schtasks.exe /change /TN \"bear\" /RU test /RP test
   (This time, since the task already exists, Task Scheduler sets full permissions and ownership for user test on the task file. Since the task file is actually a hard link to pci.sys, it apparently changes permissions and ownership on that file.)

Observing operations against c:\windows\system32\tasks\Bear with Process Monitor during POC execution told us more:

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhB-Ghh0C2Ewz7a-iZySA8_OLciW6vnuzmM2CT8XHAqnIVWS4TdYt_t-filLLMWRqIe76WZTKdb8VNsTmPjgVaXqWOmPwR1QRcbosZz8u_h3KufDvf3-HTzMgG8-4JdGOLiHSSRxwRGGTop/s640/ProcessMonitor_SetSecurity_calls.png)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhB-Ghh0C2Ewz7a-iZySA8_OLciW6vnuzmM2CT8XHAqnIVWS4TdYt_t-filLLMWRqIe76WZTKdb8VNsTmPjgVaXqWOmPwR1QRcbosZz8u_h3KufDvf3-HTzMgG8-4JdGOLiHSSRxwRGGTop/s1600/ProcessMonitor_SetSecurity_calls.png)

Apparently, there were two SetSecurityFile operations performed on the file, with the following call stacks:

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjglm-ExH2Lkd1s_GkFsgNslBUZpwhJafy1H_9mxV4WRyetF0Oje_8FvPGKaaT9cDL-0axBBgCV8qJpSB43TKRrKiAWy-x5oAmn67ORG05m726rDsSAKNfQomJppK3n6DBK2V1HgKCUnenQ/s640/ProcessMonitor_first_SetSecurity_callStack.png)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjglm-ExH2Lkd1s_GkFsgNslBUZpwhJafy1H_9mxV4WRyetF0Oje_8FvPGKaaT9cDL-0axBBgCV8qJpSB43TKRrKiAWy-x5oAmn67ORG05m726rDsSAKNfQomJppK3n6DBK2V1HgKCUnenQ/s1600/ProcessMonitor_first_SetSecurity_callStack.png)

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjkBG_RrI1Q_hpsogrxb-eNStjRYZV0u5zXZZd7ZoSyJM6eBG_8Jmr2XVU5n62a75av1zpOT8W2F55HmDfevz2rm0G2hTd5eCSf68N4AWrfhPP9pEyQ4pikUG4KS1IbutTHX-oy4sPymaDq/s640/ProcessMonitor_second_SetSecurity_callStack.png)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjkBG_RrI1Q_hpsogrxb-eNStjRYZV0u5zXZZd7ZoSyJM6eBG_8Jmr2XVU5n62a75av1zpOT8W2F55HmDfevz2rm0G2hTd5eCSf68N4AWrfhPP9pEyQ4pikUG4KS1IbutTHX-oy4sPymaDq/s1600/ProcessMonitor_second_SetSecurity_callStack.png)

Both of these SetSecurityFile operations stem from function [\_SchRpcSetSecurity](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-tsch/a8172c11-a24a-4ad9-abd0-82bcf29d794d) in schedsvc.dll, and based on our prior experience with Task Manager's impersonation issues we assumed this function was responsible for calling SetSecurityInfo without proper impersonation. Next step: debugger.

We set a breakpoint at \_SchRpcSetSecurity and traced its execution towards the call to SetSecurityInfo - its first call being made from function SetJobFileSecurityByName. Therein, before the call to SetSecurityInfo was made, we checked the thread's access token, expecting it to be not-impersonated.

0:030> !token
TS Session ID: 0
User: S-1-5-18

...

Privs:
 ...
 14 0x000000012 SeRestorePrivilege                Attributes - Enabled
 ...
Impersonation Level: Impersonation
...

But surprise! The token *was* impersonated. Only the user it was impersonating was not the attacker's user test, but Local System (S-1-5-18). What was going on?

Was function \_SchRpcSetSecurity broken and incorrectly impersonated the caller? We found an impersonation call in it and it looked okay. Clearly we needed to understand this function better, and it's natural to start with the documentation when available. The [specification of function  \_SchRpcSetSecurity](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-tsch/a8172c11-a24a-4ad9-abd0-82bcf29d794d) describes its behavior in detail, including this step that is relevant for our analysis (the path parameter being the Bear file in our case.):

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh788JcmwKPXit7oGoHyMl5YB8im7G7AuIqQmmyhMHclxXF8wpbANL_oxH93J_7W7nV3bw1GfCWaywaRltWZ2N-IMysj715QZgmPjTGGjF958cbEqyzYZ0PaeexApCWryzlmjlZQbgo3eRS/s640/SchRpcSetSecurity_specs.PNG)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh788JcmwKPXit7oGoHyMl5YB8im7G7AuIqQmmyhMHclxXF8wpbANL_oxH93J_7W7nV3bw1GfCWaywaRltWZ2N-IMysj715QZgmPjTGGjF958cbEqyzYZ0PaeexApCWryzlmjlZQbgo3eRS/s1600/SchRpcSetSecurity_specs.PNG)

This makes sense: if someone asks Task Scheduler to change permissions on a task file, said someone should have write permissions on that file. A typical use case for this is when the user who created a task subsequently decides to have that task executed as some other user, which requires that user to have at least read access to the task file. And this is also the use case triggered by the schtasks.exe's /change option, where /RU and /RP parameters specify the "run-as" user's credentials.

We then reverse engineered \_SchRpcSetSecurity to find where this security check is implemented and find out why it doesn't work as specified.

Except we found that it *does* work as specified: the code attempts to open the Bear file with permissions to change its DACL and its owner - and if that succeeds, actually does that. Which would work great if only it was impersonating the low-privileged attacker instead of Local System (who obviously can do all that on the linked-to pci.sys file).

So why didn't the function impersonate the attacker? After some head-scratching, we remembered that this attack only works with the legacy schtasks.exe, and not with the new one. Could it be that the old schtasks.exe was calling some other RPC function than \_SchRpcSetSecurity, which then in turn called \_SchRpcSetSecurity via RPC? While still paused inside the \_SchRpcSetSecurity call, we looked at other threads in the same process - and found an interesting one with this call stack:

0:037> k
ChildEBP RetAddr
08d1dbf4 775e058a ntdll!KiFastSystemCallRet
08d1dbf8 76e35bde ntdll!NtAlpcSendWaitReceivePort+0xa
08d1dc88 76e359f4 RPCRT4!LRPC\_BASE\_CCALL::DoSendReceive+0xde
08d1dca4 76e156dc RPCRT4!LRPC\_CCALL::SendReceive+0x54
08d1e118 6ff9fa7a RPCRT4!NdrClientCall2+0xa4c
08d1e130 6ffbd524 taskcomp!SchRpcSetSecurity+0x24
08d1e17c 6ffa8536 taskcomp!RpcSession::SetSecurity+0x25
08d1ecd0 6ffa8669 taskcomp!CompatibilityAdapter::Register+0xef4
08d1ed00 6ffb13a9 taskcomp!CompatibilityAdapter::RegisterWithRetry+0x28
08d1f1f4 76e67544 taskcomp!SASetAccountInformation+0x4a9
08d1f21c 76e1665d RPCRT4!Invoke+0x34
08d1f688 76e17399 RPCRT4!NdrStubCall2+0x86d
08d1f6a4 76e48712 RPCRT4!NdrServerCall2+0x19
08d1f6e4 76e4832b RPCRT4!DispatchToStubInCNoAvrf+0x52
08d1f758 76e47d6f RPCRT4!RPC\_INTERFACE::DispatchToStubWorker+0x17b
08d1f78c 76e36b6f RPCRT4!RPC\_INTERFACE::DispatchToStub+0x8f
08d1f7f4 76e37e4d RPCRT4!LRPC\_SCALL::DispatchRequest+0x2ef
08d1f884 76e37915 RPCRT4!LRPC\_SCALL::HandleRequest+0x37d
08d1f8d0 76e36501 RPCRT4!LRPC\_ADDRESS::HandleRequest+0x325
08d1f9a8 76e324e6 RPCRT4!LRPC\_ADDRESS::ProcessIO+0x211
08d1f9e8 775827f8 RPCRT4!LrpcIoComplete+0xa6
08d1fa20 775819da ntdll!TppAlpcpExecuteCallback+0x188
08d1fbe8 74d7e529 ntdll!TppWorkerThread+0x3da
08d1fbf8 775a9ed1 KERNEL32!BaseThreadInitThunk+0x19
08d1fc54 775a9ea5 ntdll!\_\_RtlUserThreadStart+0x2b
08d1fc64 00000000 ntdll!\_RtlUserThreadStart+0x1b

Hmm, a thread in taskcomp.dll, which was itself triggered via an RPC call (as suggested by RPCRT4!Invoke) called a function named SchRpcSetSecurity, which invoked another RPC call (as suggested by RPCRT4!NdrClientCall2), and was now waiting for it to return. A few debugging sessions later, we could confirm that this is indeed what is happening: the legacy schtasks.exe makes a RPC call to a legacy RPC endpoint [SASetAccountInformation](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-tsch/ca3e0305-4582-4e75-9c27-598c715f771d) implemented in taskcomp.dll, which implements the old task scheduler instructions with RPC calls to the new ones implemented in schedsvc.dll, such as [SchRpcRegisterTask](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-tsch/849c131a-64e4-46ef-b015-9d4c599c5167) and SchRpcSetSecurity.

Our focus thus turned to taskcomp.dll. Namely, RPC calls can be stacked: process A can RPC-call process B, and then the code processing said call in process B can further RPC-call process C. In our case, schtasks.exe (running as attacker) calls RPC endpoint taskcomp!SASetAccountInformation in Task Scheduler's process svchost.exe (running as Local System), which in turn calls RPC endpoint schedsvc!\_SchRpcSetSecurity in the same svchost.exe (still running as Local System). When the latter impersonates its caller, it actually impersonates the access token of the thread in taskcomp.dll that called it, and if that thread had previously impersonated its own caller (i.e., attacker), the final impersonated token would also be attacker's. However, taskcomp.dll does not impersonate its caller; it impersonates self (Local System) to enable the SeRestorePrivilege privilege that is needed for it to set DACL and ownership on any file:

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiSGlVn_Q61QnO62EBIPhYc352nHEtkDljJqvNu06f-UDs0pAn71mhQI7bce38UbGe4vzU4xWTAWcduZH1CntjAh2zF7Q0Hv3h7W1zeyTXdcotCZFXNmlnSlQzRBbERpYv2ganMCMLwVoXR/s640/IDA_patchlet_1.PNG)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiSGlVn_Q61QnO62EBIPhYc352nHEtkDljJqvNu06f-UDs0pAn71mhQI7bce38UbGe4vzU4xWTAWcduZH1CntjAh2zF7Q0Hv3h7W1zeyTXdcotCZFXNmlnSlQzRBbERpYv2ganMCMLwVoXR/s1600/IDA_patchlet_1.PNG)

This impersonation breaks the tie with attacker's identity, and causes the subsequently executed schedsvc!\_SchRpcSetSecurity to believe it was Local System, not the attacker, who requested the change of DACL and owner on pci.sys. It was time to patch.

## Patching

Correcting the behavior of someone else's code in a complex environment is always tricky, and legacy support + task scheduling = complex, we believe it was actually an error to impersonate self in taskcomp.dll instead of impersonating the client. The latter would in fact allow the security check in schedsvc!\_SchRpcSetSecurity to perform correctly and work as intended on a regular file as well as on a hard-linked system file (correctly failing when invoked by a low-privileged user).

We therefore decided to replace self-impersonation with client-impersonation, and to do that, we removed the call to ImpersonateSalfWithPrivilege and injected a call to RpcImpersonateClient in its place.

We wrote a micropatch for this and tested it.

The POC still worked.

It turned out that there was another RPC call to SchRpcSetSecurity in taskcomp.dll, which got called when the first one was unsuccessful:

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiTuOQGeRLotoIJa2scHOaKm81Yzi6qZEwZjroCXKjjozGYnDlFdUcXJzLiE-NiBNhV2H-FkDiu8ydcPr3OEs87Y6EnjnAD-VMg-5BbmnHgwJuCCEvna7cNCBkphkxFoO7dJ3Tb0k_85lXR/s640/IDA_patchlet_2.PNG)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiTuOQGeRLotoIJa2scHOaKm81Yzi6qZEwZjroCXKjjozGYnDlFdUcXJzLiE-NiBNhV2H-FkDiu8ydcPr3OEs87Y6EnjnAD-VMg-5BbmnHgwJuCCEvna7cNCBkphkxFoO7dJ3Tb0k_85lXR/s1600/IDA_patchlet_2.PNG)

The call stack was:

0:005> k
ChildEBP RetAddr
044ffc20 6ff9a3dd taskcomp!CompatibilityAdapter::

                  [IFileChangeNotification]::SdChange+0x9235
044ffc60 6ff9a2a4 taskcomp!JournalReader::HandleWaitTimer+0x11d
044ffef0 74d7e529 taskcomp!CompatibilityAdapter::MonitorThread+0x104
044fff00 775a9ed1 KERNEL32!BaseThreadInitThunk+0x19
044fff5c 775a9ea5 ntdll!\_\_RtlUserThreadStart+0x2b
044fff6c 00000000 ntdll!\_RtlUserThreadStart+0x1b

It looked like some monitoring thread was used for getting the job done when the original call failed, but this thread was not called via RPC, and client impersonation could not be used there. We therefore decided on a more drastic approach and simply amputated the call to SetSecurity.

After that, we got the desired behavior: The legacy schtasks.exe was behaving correctly when creating a new task from a job file, and when setting a "run-as" user for an existing task that the user was allowed to change permissions on. On the other hand, the hard link trick no longer worked because the Task Scheduler process correctly identified the caller and determined that it doesn't have sufficient permissions to change DACL or ownership on a system file. Since we didn't even touch schedsvc.dll, the new (non-legacy) Task Scheduler functionality was not affected at all.

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjxWQ1CDnea2LcRfL4-W3SwmIRzffQ8Do69FI264U_3hwPjkah5rWl_ynoTQL8dGX5VAwHKHjFr1pDp9KmIlymf8EBLUL8Jm6EHV7uAwWQ7my14H_MNyYn7KQZfooV9-OAXZQzSyAY0DaXl/s640/ProcessMonitor_after_patch.png)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjxWQ1CDnea2LcRfL4-W3SwmIRzffQ8Do69FI264U_3hwPjkah5rWl_ynoTQL8dGX5VAwHKHjFr1pDp9KmIlymf8EBLUL8Jm6EHV7uAwWQ7my14H_MNyYn7KQZfooV9-OAXZQzSyAY0DaXl/s1600/ProcessMonitor_after_patch.png)

With our micropatch in place, re-launching the POC and observing the Bear task file in Process Monitor only showed two CreateFile operations from SchRpcSetSecurity's security check described above, and both ended with an ACCESS DENIED error due to correct impersonation.

This is the source code of our micropatch for 32bit Windows 10 version 1809:

;Micropatch for taskcomp.dll version 10.0.17763.1
MODULE\_PATH "..\AffectedModules\taskcomp.dll\_10.0.17763.1\_x86\taskcomp.dll"
PATCH\_ID 374
PATCH\_FORMAT\_VER 2
VULN\_ID 5172
PLATFORM win32

patchlet\_start
 PATCHLET\_ID 1
 PATCHLET\_TYPE 2
 PATCHLET\_OFFSET 0x000184dd
 PIT rpcrt4.dll!RpcImpersonateClient
 JUMPOVERBYTES 16 ; we skip the call to ImpersonateSelfWithPrivilege
 N\_ORIGINALBYTES 1

 code\_start
  mov dword [ebp-0b20h], 0 ; token (set to 0 to force the ImpersonateSelfWithPrivilege
                           ; destructor to call RpcRevertToSelf)
  push 0                   ; Impersonating the client that made the request
  call PIT\_RpcImpersonateClient
 code\_end

patchlet\_end

patchlet\_start
 PATCHLET\_ID 2
 PATCHLET\_TYPE 2
 PATCHLET\_OFFSET 0x00015e72
 JUMPOVERBYTES 5 ; we skip the call to SetSecurity@RpcSession
 N\_ORIGINALBYTES 1

 code\_start
  add    esp, 0ch       ; 3 x pop
  mov eax, 00000000h   ; simulate that SetSecurity@RpcSession() function
                       ; returned 0 (as on successfull call)
 code\_end

patchlet\_end

And here it is in action:

As always, if you have 0patch Agent installed and registered, this
micropatch is already on your computer - and applied to taskcomp.dll in your Task Scheduler service. If you don't have the 0patch Agent yet, you can [register a 0patch account](https://0patch.com/) and install it to get this micropatch applied.

Following our [guidelines on which patches to provide for free](https://0patch.zendesk.com/hc/en-us/articles/360020855914-What-are-PRO-patches-and-how-are-they-different-from-FREE-patches-),
this micropatch affects many home and education users, and is therefore
included in both FREE and PRO 0patch license until Microsoft provides
an official fix. After that the micropatch will only be included in the
PRO license.

We are currently providing this micropatch for fully updated:

1. Windows 10 version 1809 32bit
2. Windows 10 version 1809 64bit
3. Windows Server 2019

0patch PRO users are welcome to request porting this micropatch to other Windows 10 or Server versions at support@0patch.com. (Note that Windows 8, Windows 7, and their Server counterparts 2012 and 2008 don't seem to be affected.)

[![https://0patch.com/patches.html](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgZOUR-OYVRuy8TL4fD16G-N_SSwhMbMYoP_0681PTZbk340JPHT6Oc4XR6FBtFvRiiLtIQJV_xsDWdxZEOuGjtL0EQmldZe-XeemBOGeCtJn0NgJWbM5IO8iqaH0xBF1CZPye-PeoxkDrq/s640/Vuln_5172_NO-CVE_BearLPE_PatchCard_Twitter_506x253.png)](https://0patch.com/patches.html)

**One final question: Does the attacker really need a local user's password?**

We seriously doubt that. While running the legacy schtasks.exe with an incorrect password via argument /RP results in an error, the documentation for [IScheduledWorkItem::SetAccountInformation](https://docs.microsoft.com/en-us/windows/desktop/api/mstask/nf-mstask-ischeduledworkitem-setaccountinformation) method (which actually gets called by legacy schtasks.exe) states: "*If you set the TASK\_FLAG\_RUN\_ONLY\_IF\_LOGGED\_ON flag, you may also set pwszPassword to NULL for local or domain user accounts.*" We haven't tested this but it sounds reasonable that for "run only if logged on" tasks a password would not be needed. Since attacker's goal is not to have the task executed but to have Task Scheduler change permissions on a target file, we believe executing the attack should also be possible without knowing any password.

Cheers!

Simon Raner

[@mkolsek](https://twitter.com/mkolsek)

[@0patch](https://twitter.com/0patch)

[![](https://resources.blogblog.com/img/icon18_edit_allbkg.gif)](https://www.blogger.com/post-edit.g?blogID=7114610046316422325&postID=7792210195262614384&from=pencil "Edit Post")

[Email This](https://www.blogger.com/share-post.g?blogID=7114610046316422325&postID=7792210195262614384&target=email "Email This")[BlogThis!](https://www.blogger.com/share-post.g?blogID=7114610046316422325&postID=7792210195262614384&target=blog "BlogThis!")[Share to X](https://www.blogger.com/share-post.g?blogID=7114610046316422325&postID=7792210195262614384&target=twitter "Share to X")[Share to Facebook](https://www.blogger.com/share-post.g?blogID=7114610046316422325&postID=7792210195262614384&target=facebook "Share to Facebook")[Share to Pinterest](https://www.blogger.com/share-post.g?blogID=7114610046316422325&postID=7792210195262614384&target=pinterest "Share to Pinterest")

#### No comments:

#### Post a Comment

[Newer Post](https://blog.0patch.com/2019/09/keeping-windows-7-and-windows-server.html "Newer Post")

[Older Post](https://blog.0patch.com/2019/04/microsoft-edge-uses-secret-trick-and.html "Older Post")

[Home](https://blog.0patch.com/)

Subscribe to:
[Post Comments (Atom)](https://blog.0patch.com/feeds/7792210195262614384/comments/default)

## About 0patch

[0patch](https://0patch.com) (pronounced 'zero patch') is a platform for instantly distributing, applying and removing microscopic binary patches to/from running processes without having to restart these processes (much less reboot the entire computer). Brought to you by [ACROS Security](https://www.acrossecurity.com).

[Follow @0patch](https://twitter.com/0patch)

## Blog Archive

* ►
  [2024](https://blog.0patch.com/2024/)
  (23)
  + ►
    [December](https://blog.0patch.com/2024/12/)
    (1)
  + ►
    [November](https://blog.0patch.com/2024/11/)
    (4)
  + ►
    [October](https://blog.0patch.com/2024/10/)
    (2)
  + ►
    [September](https://blog.0patch.com/2024/09/)
    (1)
  + ►
    [July](https://blog.0patch.com/2024/07/)
    (2)
  + ►
    [June](https://blog.0patch.com/2024/06/)
    (2)
  + ►
    [May](https://blog.0patch.com/2024/05/)
    (1)
  + ►
    [April](https://blog.0patch.com/2024/04/)
    (4)
  + ►
    [March](https://blog.0patch.com/2024/03/)
    (1)
  + ►
    [February](https://blog.0patch.com/2024/02/)
    (4)
  + ►
    [January](https://blog.0patch.com/2024/01/)
    (1)

* ►
  [2023](https://blog.0patch.com/2023/)
  (26)
  + ►
    [November](https://blog.0patch.com/2023/11/)
    (3)
  + ►
    [October](https://blog.0patch.com/2023/10/)
    (3)
  + ►
    [September](https://blog.0patch.com/2023/09/)
    (2)
  + ►
    [August](https://blog.0patch.com/2023/08/)
    (1)
  + ►
    [July](https://blog.0patch.com/2023/07/)
    (1)
  + ►
    [June](https://blog.0patch.com/2023/06/)
    (5)
  + ►
    [May](https://blog.0patch.com/2023/05/)
    (1)
  + ►
    [April](https://blog.0patch.com/2023/04/)
    (1)
  + ►
    [March](https://blog.0patch.com/2023/03/)
    (5)
  + ►
    [February](https://blog.0patch.com/2023/02/)
    (2)
  + ►
    [January](https://blog.0patch.com/2023/01/)
    (2)

* ►
  [2022](https://blog.0patch.com/2022/)
  (26)
  + ►
    [December](https://blog.0patch.com/2022/12/)
    (3)
  + ►
    [October](https://blog.0patch.com/2022/10/)
    (6)
  + ►
    [September](https://blog.0patch.com/2022/09/)
    (3)
  + ►
    [August](https://blog.0patch.com/2022/08/)
    (2)
  + ►
    [July](https://blog.0patch.com/2022/07/)
    (2)
  + ►
    [June](https://blog.0patch.com/2022/06/)
    (3)
  + ►
    [May](https://blog.0patch.com/2022/05/)
    (2)
  + ►
    [March](https://blog.0patch.com/2022/03/)
    (4)
  + ►
    [January](https://blog.0patch.com/2022/01/)
    (1)

* ►
  [2021](https://blog.0patch.com/2021/)
  (23)
  + ►
    [December](https://blog.0patch.com/2021/12/)
    (2)
  + ►
    [November](https://blog.0patch.com/2021/11/)
    (3)
  + ►
    [October](https://blog.0patch.com/2021/10/)
    (2)
  + ►
    [September](https://blog.0patch.com/2021/09/)
    (1)
  + ►
    [August](https://blog.0patch.com/2021/08/)
    (3)
  + ►
    [July](https://blog.0patch.com/2021/07/)
    (2)
  + ►
    [June](https://blog.0patch.com/2021/06/)
    (1)
  + ►
    [May](https://blog.0patch.com/2021/05/)
    (3)
  + ►
    [March](https://blog.0patch.com/2021/03/)
    (2)
  + ►
    [February](https://blog.0patch.com/2021/02/)
    (2)
  + ►
    [January](https://blog.0patch.com/2021/01/)
    (2)

* ►
  [2020](https://blog.0patch.com/2020/)
  (19)
  + ►
    [December](https://blog.0patch.com/2020/12/)
    (2)
  + ►
    [November](https://blog.0patch.com/2020/11/)
    (2)
  + ►
    [September](https://blog.0patch.com/2020/09/)
    (1)
  + ►
    [August](https://blog.0patch.com/2020/08/)
    (2)
  + ►
    [July](https://blog.0patch.com/2020/07/)
    (3)
  + ►
    [June](https://blog.0patch.com/2020/06/)
    (2)
  + ►
    [May](https://blog.0patch.com/2020/05/)
    (2)
  + ►
    [March](https://blog.0patch.com/2020/03/)
    (1)
  + ►
    [February](https://blog.0patch.com/2020/02/)
    (2)
  + ►
    [January](https://blog.0patch.com/2020/01/)
    (2)

* ▼
  [2019](https://blog.0patch.com/2019/)
  (7)
  + ►
    [September](https://blog.0patch.com/2019/09/)
    (1)
  + ▼
    [June](https://blog.0patch.com/2019/06/)
    (1)
    - [Another Task Scheduler 0day, Another Task Schedule...](https://blog.0patch.com/2019/06/another-task-scheduler-0day-another.html)
  + ►
    [April](https://blog.0patch.com/2019/04/)
    (2)
  + ►
    [February](https://blog.0patch.com/2019/02/)
    (2)
  + ►
    [January](https://blog.0patch.com/2019/01/)
    (1)

* ►
  [2018](https://blog.0patch.com/2018/)
  (11)
  + ►
    [October](https://blog.0patch.com/2018/10/)
    (2)
  + ►
    [September](https://blog.0patch.com/2018/09/)
    (2)
  + ►
    [August](https://blog.0patch.com/2018/08/)
    (1)
  + ►
    [May](https://blog.0patch.com/2018/05/)
    (2)
  + ►
    [March](https://blog.0patch.com/2018/03/)
    (1)
  + ►
    [February](https://blog.0patch.com/2018/02/)
    (1)
  + ►
    [January](https://blog.0patch.com/2018/01/)
    (2)

* ►
  [2017](https://blog.0patch.com/2017/)
  (19)
  + ►
    [December](https://blog.0patch.com/2017/12/)
    (1)
  + ►
    [November](https://blog.0patch.com/2017/11/)
    (4)
  + ►
    [October](https://blog.0patch.com/2017/10/)
    (2)
  + ►
    [September](https://blog.0patch.com/2017/09/)
    (2)
  + ►
    [August](https://blog.0patch.com/2017/08/)
    (1)
  + ►
    [July](https://blog.0patch.com/2017/07/)
    (1)
  + ►
    [June](https://blog.0patch.com/2017/06/)
    (1)
  + ►
    [May](https://blog.0patch.com/2017/05/)
    (1)
  + ►
    [March](https://blog.0patch.com/2017/03/)
    (2)
  + ►
    [February](https://blog.0patch.com/2017/02/)
    (3)
  + ►
    [January](https://blog.0patch.com/2017/01/)
    (1)

* ►
  [2016](https://blog.0patch.com/2016/)
  (7)
  + ►
    [September](https://blog.0patch.com/2016/09/)
    (1)
  + ►
    [July](https://blog.0patch.com/2016/07/)
    (1)
  + ►
    [June](https://blog.0patch.com/2016/06/)
    (3)
  + ►
    [January](https://blog.0patch.com/2016/01/)
    (2)

## LinkedIn and Google tags

  ![](https://px.ads.linkedin.com/collect/?pid=1234785&fmt=gif)

|  |  |
| --- | --- |

Copyright ACROS Security / 0patch. Powered by [Blogger](https://www.blogger.com).

