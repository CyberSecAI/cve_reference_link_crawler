

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=4c90f90a91d75c3c73dd633827c90e8746d9f54d)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=4c90f90a91d75c3c73dd633827c90e8746d9f54d)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=4c90f90a91d75c3c73dd633827c90e8746d9f54d)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=4c90f90a91d75c3c73dd633827c90e8746d9f54d)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Pali Rohár <pali@kernel.org> | 2021-06-08 22:36:55 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2021-06-23 14:41:29 +0200 |
| commit | [4c90f90a91d75c3c73dd633827c90e8746d9f54d](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=4c90f90a91d75c3c73dd633827c90e8746d9f54d) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=4c90f90a91d75c3c73dd633827c90e8746d9f54d)) | |
| tree | [b10bc29a69d2e05ec4c7c4b2d8b1e2b804ebfada](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=4c90f90a91d75c3c73dd633827c90e8746d9f54d) | |
| parent | [0e888c237754bc30f40d627aac1f8f67cb2ed935](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=0e888c237754bc30f40d627aac1f8f67cb2ed935) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=4c90f90a91d75c3c73dd633827c90e8746d9f54d&id2=0e888c237754bc30f40d627aac1f8f67cb2ed935)) | |
| download | [linux-4c90f90a91d75c3c73dd633827c90e8746d9f54d.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-4c90f90a91d75c3c73dd633827c90e8746d9f54d.tar.gz) | |

PCI: aardvark: Fix kernel panic during PIO transfercommit f18139966d072dab8e4398c95ce955a9742e04f7 upstream.
Trying to start a new PIO transfer by writing value 0 in PIO\_START register
when previous transfer has not yet completed (which is indicated by value 1
in PIO\_START) causes an External Abort on CPU, which results in kernel
panic:
SError Interrupt on CPU0, code 0xbf000002 -- SError
Kernel panic - not syncing: Asynchronous SError Interrupt
To prevent kernel panic, it is required to reject a new PIO transfer when
previous one has not finished yet.
If previous PIO transfer is not finished yet, the kernel may issue a new
PIO request only if the previous PIO transfer timed out.
In the past the root cause of this issue was incorrectly identified (as it
often happens during link retraining or after link down event) and special
hack was implemented in Trusted Firmware to catch all SError events in EL3,
to ignore errors with code 0xbf000002 and not forwarding any other errors
to kernel and instead throw panic from EL3 Trusted Firmware handler.
Links to discussion and patches about this issue:
https://git.trustedfirmware.org/TF-A/trusted-firmware-a.git/commit/?id=3c7dcdac5c50
https://lore.kernel.org/linux-pci/20190316161243.29517-1-repk@triplefau.lt/
https://lore.kernel.org/linux-pci/971be151d24312cc533989a64bd454b4@www.loen.fr/
https://review.trustedfirmware.org/c/TF-A/trusted-firmware-a/+/1541
But the real cause was the fact that during link retraining or after link
down event the PIO transfer may take longer time, up to the 1.44s until it
times out. This increased probability that a new PIO transfer would be
issued by kernel while previous one has not finished yet.
After applying this change into the kernel, it is possible to revert the
mentioned TF-A hack and SError events do not have to be caught in TF-A EL3.
Link: [https://lore.kernel.org/r/20210608203655.31228-1-pali@kernel.org](https://lore.kernel.org/r/20210608203655.31228-1-pali%40kernel.org)
Signed-off-by: Pali Rohár <pali@kernel.org>
Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
Reviewed-by: Marek Behún <kabel@kernel.org>
Cc: stable@vger.kernel.org # 7fbcb5da811b ("PCI: aardvark: Don't rely on jiffies while holding spinlock")
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=4c90f90a91d75c3c73dd633827c90e8746d9f54d)

| -rw-r--r-- | [drivers/pci/controller/pci-aardvark.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/pci/controller/pci-aardvark.c?id=4c90f90a91d75c3c73dd633827c90e8746d9f54d) | 49 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 40 insertions, 9 deletions

| diff --git a/drivers/pci/controller/pci-aardvark.c b/drivers/pci/controller/pci-aardvark.cindex 452125983e1006..89cc6980b59641 100644--- a/[drivers/pci/controller/pci-aardvark.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/pci/controller/pci-aardvark.c?id=0e888c237754bc30f40d627aac1f8f67cb2ed935)+++ b/[drivers/pci/controller/pci-aardvark.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/pci/controller/pci-aardvark.c?id=4c90f90a91d75c3c73dd633827c90e8746d9f54d)@@ -405,7 +405,7 @@ static int advk\_pcie\_wait\_pio(struct advk\_pcie \*pcie) udelay(PIO\_RETRY\_DELAY); } - dev\_err(dev, "config read/write timed out\n");+ dev\_err(dev, "PIO read/write transfer time out\n"); return -ETIMEDOUT; } @@ -539,6 +539,35 @@ static bool advk\_pcie\_valid\_device(struct advk\_pcie \*pcie, struct pci\_bus \*bus, return true; } +static bool advk\_pcie\_pio\_is\_running(struct advk\_pcie \*pcie)+{+ struct device \*dev = &pcie->pdev->dev;++ /\*+ \* Trying to start a new PIO transfer when previous has not completed+ \* cause External Abort on CPU which results in kernel panic:+ \*+ \* SError Interrupt on CPU0, code 0xbf000002 -- SError+ \* Kernel panic - not syncing: Asynchronous SError Interrupt+ \*+ \* Functions advk\_pcie\_rd\_conf() and advk\_pcie\_wr\_conf() are protected+ \* by raw\_spin\_lock\_irqsave() at pci\_lock\_config() level to prevent+ \* concurrent calls at the same time. But because PIO transfer may take+ \* about 1.5s when link is down or card is disconnected, it means that+ \* advk\_pcie\_wait\_pio() does not always have to wait for completion.+ \*+ \* Some versions of ARM Trusted Firmware handles this External Abort at+ \* EL3 level and mask it to prevent kernel panic. Relevant TF-A commit:+ \* https://git.trustedfirmware.org/TF-A/trusted-firmware-a.git/commit/?id=3c7dcdac5c50+ \*/+ if (advk\_readl(pcie, PIO\_START)) {+ dev\_err(dev, "Previous PIO read/write transfer is still running\n");+ return true;+ }++ return false;+}+ static int advk\_pcie\_rd\_conf(struct pci\_bus \*bus, u32 devfn, int where, int size, u32 \*val) {@@ -555,9 +584,10 @@ static int advk\_pcie\_rd\_conf(struct pci\_bus \*bus, u32 devfn, return pci\_bridge\_emul\_conf\_read(&pcie->bridge, where, size, val); - /\* Start PIO \*/- advk\_writel(pcie, 0, PIO\_START);- advk\_writel(pcie, 1, PIO\_ISR);+ if (advk\_pcie\_pio\_is\_running(pcie)) {+ \*val = 0xffffffff;+ return PCIBIOS\_SET\_FAILED;+ }  /\* Program the control register \*/ reg = advk\_readl(pcie, PIO\_CTRL);@@ -576,7 +606,8 @@ static int advk\_pcie\_rd\_conf(struct pci\_bus \*bus, u32 devfn, /\* Program the data strobe \*/ advk\_writel(pcie, 0xf, PIO\_WR\_DATA\_STRB); - /\* Start the transfer \*/+ /\* Clear PIO DONE ISR and start the transfer \*/+ advk\_writel(pcie, 1, PIO\_ISR); advk\_writel(pcie, 1, PIO\_START);  ret = advk\_pcie\_wait\_pio(pcie);@@ -614,9 +645,8 @@ static int advk\_pcie\_wr\_conf(struct pci\_bus \*bus, u32 devfn, if (where % size) return PCIBIOS\_SET\_FAILED; - /\* Start PIO \*/- advk\_writel(pcie, 0, PIO\_START);- advk\_writel(pcie, 1, PIO\_ISR);+ if (advk\_pcie\_pio\_is\_running(pcie))+ return PCIBIOS\_SET\_FAILED;  /\* Program the control register \*/ reg = advk\_readl(pcie, PIO\_CTRL);@@ -643,7 +673,8 @@ static int advk\_pcie\_wr\_conf(struct pci\_bus \*bus, u32 devfn, /\* Program the data strobe \*/ advk\_writel(pcie, data\_strobe, PIO\_WR\_DATA\_STRB); - /\* Start the transfer \*/+ /\* Clear PIO DONE ISR and start the transfer \*/+ advk\_writel(pcie, 1, PIO\_ISR); advk\_writel(pcie, 1, PIO\_START);  ret = advk\_pcie\_wait\_pio(pcie); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 14:06:03 +0000

