

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=39f8a29330f433000e716eefc4b9abda05b71a82)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=39f8a29330f433000e716eefc4b9abda05b71a82)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=39f8a29330f433000e716eefc4b9abda05b71a82)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=39f8a29330f433000e716eefc4b9abda05b71a82)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Alexei Starovoitov <ast@kernel.org> | 2024-04-26 17:25:44 -0700 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-06-12 11:11:47 +0200 |
| commit | [39f8a29330f433000e716eefc4b9abda05b71a82](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=39f8a29330f433000e716eefc4b9abda05b71a82) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=39f8a29330f433000e716eefc4b9abda05b71a82)) | |
| tree | [611293d7b4c1706fbf04edec3552f0b40fd6de5d](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=39f8a29330f433000e716eefc4b9abda05b71a82) | |
| parent | [62eb07923f3693d55b0c2d9a5a4f1ad72cb6b8fd](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=62eb07923f3693d55b0c2d9a5a4f1ad72cb6b8fd) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=39f8a29330f433000e716eefc4b9abda05b71a82&id2=62eb07923f3693d55b0c2d9a5a4f1ad72cb6b8fd)) | |
| download | [linux-39f8a29330f433000e716eefc4b9abda05b71a82.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-39f8a29330f433000e716eefc4b9abda05b71a82.tar.gz) | |

bpf: Fix verifier assumptions about socket->sk[ Upstream commit 0db63c0b86e981a1e97d2596d64ceceba1a5470e ]
The verifier assumes that 'sk' field in 'struct socket' is valid
and non-NULL when 'socket' pointer itself is trusted and non-NULL.
That may not be the case when socket was just created and
passed to LSM socket\_accept hook.
Fix this verifier assumption and adjust tests.
Reported-by: Liam Wisehart <liamwisehart@meta.com>
Acked-by: Kumar Kartikeya Dwivedi <memxor@gmail.com>
Fixes: 6fcd486b3a0a ("bpf: Refactor RCU enforcement in the verifier.")
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: [https://lore.kernel.org/r/20240427002544.68803-1-alexei.starovoitov@gmail.com](https://lore.kernel.org/r/20240427002544.68803-1-alexei.starovoitov%40gmail.com)
Signed-off-by: Martin KaFai Lau <martin.lau@kernel.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=39f8a29330f433000e716eefc4b9abda05b71a82)

| -rw-r--r-- | [kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/bpf/verifier.c?id=39f8a29330f433000e716eefc4b9abda05b71a82) | 23 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [tools/testing/selftests/bpf/progs/bench\_local\_storage\_create.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/bpf/progs/bench_local_storage_create.c?id=39f8a29330f433000e716eefc4b9abda05b71a82) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/bpf/progs/local\_storage.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/bpf/progs/local_storage.c?id=39f8a29330f433000e716eefc4b9abda05b71a82) | 20 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/bpf/progs/lsm\_cgroup.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/bpf/progs/lsm_cgroup.c?id=39f8a29330f433000e716eefc4b9abda05b71a82) | 8 | |  |  |  | | --- | --- | --- | |

4 files changed, 38 insertions, 18 deletions

| diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.cindex 105fa54a492ab5..1385d01a21e4f1 100644--- a/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/verifier.c?id=62eb07923f3693d55b0c2d9a5a4f1ad72cb6b8fd)+++ b/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/verifier.c?id=39f8a29330f433000e716eefc4b9abda05b71a82)@@ -2539,6 +2539,8 @@ static void mark\_btf\_ld\_reg(struct bpf\_verifier\_env \*env, regs[regno].type = PTR\_TO\_BTF\_ID | flag; regs[regno].btf = btf; regs[regno].btf\_id = btf\_id;+ if (type\_may\_be\_null(flag))+ regs[regno].id = ++env->id\_gen; }  #define DEF\_NOT\_SUBREG (0)@@ -5373,8 +5375,6 @@ static int check\_map\_kptr\_access(struct bpf\_verifier\_env \*env, u32 regno, rcu\_safe\_kptr(kptr\_field) && in\_rcu\_cs(env) ? PTR\_MAYBE\_NULL | MEM\_RCU : PTR\_MAYBE\_NULL | PTR\_UNTRUSTED);- /\* For mark\_ptr\_or\_null\_reg \*/- val\_reg->id = ++env->id\_gen; } else if (class == BPF\_STX) { val\_reg = reg\_state(env, value\_regno); if (!register\_is\_null(val\_reg) &&@@ -5684,7 +5684,8 @@ static bool is\_trusted\_reg(const struct bpf\_reg\_state \*reg) return true;  /\* Types listed in the reg2btf\_ids are always trusted \*/- if (reg2btf\_ids[base\_type(reg->type)])+ if (reg2btf\_ids[base\_type(reg->type)] &&+ !bpf\_type\_has\_unsafe\_modifiers(reg->type)) return true;  /\* If a register is not referenced, it is trusted if it has the@@ -6263,6 +6264,7 @@ static int bpf\_map\_direct\_read(struct bpf\_map \*map, int off, int size, u64 \*val, #define BTF\_TYPE\_SAFE\_RCU(\_\_type) \_\_PASTE(\_\_type, \_\_safe\_rcu) #define BTF\_TYPE\_SAFE\_RCU\_OR\_NULL(\_\_type) \_\_PASTE(\_\_type, \_\_safe\_rcu\_or\_null) #define BTF\_TYPE\_SAFE\_TRUSTED(\_\_type) \_\_PASTE(\_\_type, \_\_safe\_trusted)+#define BTF\_TYPE\_SAFE\_TRUSTED\_OR\_NULL(\_\_type) \_\_PASTE(\_\_type, \_\_safe\_trusted\_or\_null)  /\* \* Allow list few fields as RCU trusted or full trusted.@@ -6326,7 +6328,7 @@ BTF\_TYPE\_SAFE\_TRUSTED(struct dentry) { struct inode \*d\_inode; }; -BTF\_TYPE\_SAFE\_TRUSTED(struct socket) {+BTF\_TYPE\_SAFE\_TRUSTED\_OR\_NULL(struct socket) { struct sock \*sk; }; @@ -6361,11 +6363,20 @@ static bool type\_is\_trusted(struct bpf\_verifier\_env \*env, BTF\_TYPE\_EMIT(BTF\_TYPE\_SAFE\_TRUSTED(struct linux\_binprm)); BTF\_TYPE\_EMIT(BTF\_TYPE\_SAFE\_TRUSTED(struct file)); BTF\_TYPE\_EMIT(BTF\_TYPE\_SAFE\_TRUSTED(struct dentry));- BTF\_TYPE\_EMIT(BTF\_TYPE\_SAFE\_TRUSTED(struct socket));  return btf\_nested\_type\_is\_trusted(&env->log, reg, field\_name, btf\_id, "\_\_safe\_trusted"); } +static bool type\_is\_trusted\_or\_null(struct bpf\_verifier\_env \*env,+ struct bpf\_reg\_state \*reg,+ const char \*field\_name, u32 btf\_id)+{+ BTF\_TYPE\_EMIT(BTF\_TYPE\_SAFE\_TRUSTED\_OR\_NULL(struct socket));++ return btf\_nested\_type\_is\_trusted(&env->log, reg, field\_name, btf\_id,+ "\_\_safe\_trusted\_or\_null");+}+ static int check\_ptr\_to\_btf\_access(struct bpf\_verifier\_env \*env, struct bpf\_reg\_state \*regs, int regno, int off, int size,@@ -6474,6 +6485,8 @@ static int check\_ptr\_to\_btf\_access(struct bpf\_verifier\_env \*env, \*/ if (type\_is\_trusted(env, reg, field\_name, btf\_id)) { flag |= PTR\_TRUSTED;+ } else if (type\_is\_trusted\_or\_null(env, reg, field\_name, btf\_id)) {+ flag |= PTR\_TRUSTED | PTR\_MAYBE\_NULL; } else if (in\_rcu\_cs(env) && !type\_may\_be\_null(reg->type)) { if (type\_is\_rcu(env, reg, field\_name, btf\_id)) { /\* ignore \_\_rcu tag and mark it MEM\_RCU \*/diff --git a/tools/testing/selftests/bpf/progs/bench\_local\_storage\_create.c b/tools/testing/selftests/bpf/progs/bench\_local\_storage\_create.cindex e4bfbba6c19360..c8ec0d0368e4a1 100644--- a/[tools/testing/selftests/bpf/progs/bench\_local\_storage\_create.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/bench_local_storage_create.c?id=62eb07923f3693d55b0c2d9a5a4f1ad72cb6b8fd)+++ b/[tools/testing/selftests/bpf/progs/bench\_local\_storage\_create.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/bench_local_storage_create.c?id=39f8a29330f433000e716eefc4b9abda05b71a82)@@ -61,14 +61,15 @@ SEC("lsm.s/socket\_post\_create") int BPF\_PROG(socket\_post\_create, struct socket \*sock, int family, int type, int protocol, int kern) {+ struct sock \*sk = sock->sk; struct storage \*stg; \_\_u32 pid;  pid = bpf\_get\_current\_pid\_tgid() >> 32;- if (pid != bench\_pid)+ if (pid != bench\_pid || !sk) return 0; - stg = bpf\_sk\_storage\_get(&sk\_storage\_map, sock->sk, NULL,+ stg = bpf\_sk\_storage\_get(&sk\_storage\_map, sk, NULL, BPF\_LOCAL\_STORAGE\_GET\_F\_CREATE);  if (stg)diff --git a/tools/testing/selftests/bpf/progs/local\_storage.c b/tools/testing/selftests/bpf/progs/local\_storage.cindex bc8ea56671a16a..3bf75f4ea690a5 100644--- a/[tools/testing/selftests/bpf/progs/local\_storage.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/local_storage.c?id=62eb07923f3693d55b0c2d9a5a4f1ad72cb6b8fd)+++ b/[tools/testing/selftests/bpf/progs/local\_storage.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/local_storage.c?id=39f8a29330f433000e716eefc4b9abda05b71a82)@@ -140,11 +140,12 @@ int BPF\_PROG(socket\_bind, struct socket \*sock, struct sockaddr \*address, { \_\_u32 pid = bpf\_get\_current\_pid\_tgid() >> 32; struct local\_storage \*storage;+ struct sock \*sk = sock->sk; - if (pid != monitored\_pid)+ if (pid != monitored\_pid || !sk) return 0; - storage = bpf\_sk\_storage\_get(&sk\_storage\_map, sock->sk, 0, 0);+ storage = bpf\_sk\_storage\_get(&sk\_storage\_map, sk, 0, 0); if (!storage) return 0; @@ -155,24 +156,24 @@ int BPF\_PROG(socket\_bind, struct socket \*sock, struct sockaddr \*address, /\* This tests that we can associate multiple elements \* with the local storage. \*/- storage = bpf\_sk\_storage\_get(&sk\_storage\_map2, sock->sk, 0,+ storage = bpf\_sk\_storage\_get(&sk\_storage\_map2, sk, 0, BPF\_LOCAL\_STORAGE\_GET\_F\_CREATE); if (!storage) return 0; - if (bpf\_sk\_storage\_delete(&sk\_storage\_map2, sock->sk))+ if (bpf\_sk\_storage\_delete(&sk\_storage\_map2, sk)) return 0; - storage = bpf\_sk\_storage\_get(&sk\_storage\_map2, sock->sk, 0,+ storage = bpf\_sk\_storage\_get(&sk\_storage\_map2, sk, 0, BPF\_LOCAL\_STORAGE\_GET\_F\_CREATE); if (!storage) return 0; - if (bpf\_sk\_storage\_delete(&sk\_storage\_map, sock->sk))+ if (bpf\_sk\_storage\_delete(&sk\_storage\_map, sk)) return 0;  /\* Ensure that the sk\_storage\_map is disconnected from the storage. \*/- if (!sock->sk->sk\_bpf\_storage || sock->sk->sk\_bpf\_storage->smap)+ if (!sk->sk\_bpf\_storage || sk->sk\_bpf\_storage->smap) return 0;  sk\_storage\_result = 0;@@ -185,11 +186,12 @@ int BPF\_PROG(socket\_post\_create, struct socket \*sock, int family, int type, { \_\_u32 pid = bpf\_get\_current\_pid\_tgid() >> 32; struct local\_storage \*storage;+ struct sock \*sk = sock->sk; - if (pid != monitored\_pid)+ if (pid != monitored\_pid || !sk) return 0; - storage = bpf\_sk\_storage\_get(&sk\_storage\_map, sock->sk, 0,+ storage = bpf\_sk\_storage\_get(&sk\_storage\_map, sk, 0, BPF\_LOCAL\_STORAGE\_GET\_F\_CREATE); if (!storage) return 0;diff --git a/tools/testing/selftests/bpf/progs/lsm\_cgroup.c b/tools/testing/selftests/bpf/progs/lsm\_cgroup.cindex 02c11d16b692ab..d7598538aa2dad 100644--- a/[tools/testing/selftests/bpf/progs/lsm\_cgroup.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/lsm_cgroup.c?id=62eb07923f3693d55b0c2d9a5a4f1ad72cb6b8fd)+++ b/[tools/testing/selftests/bpf/progs/lsm\_cgroup.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/lsm_cgroup.c?id=39f8a29330f433000e716eefc4b9abda05b71a82)@@ -103,11 +103,15 @@ static \_\_always\_inline int real\_bind(struct socket \*sock, int addrlen) { struct sockaddr\_ll sa = {};+ struct sock \*sk = sock->sk; - if (sock->sk->\_\_sk\_common.skc\_family != AF\_PACKET)+ if (!sk)+ return 1;++ if (sk->\_\_sk\_common.skc\_family != AF\_PACKET) return 1; - if (sock->sk->sk\_kern\_sock)+ if (sk->sk\_kern\_sock) return 1;  bpf\_probe\_read\_kernel(&sa, sizeof(sa), address); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 21:30:16 +0000

