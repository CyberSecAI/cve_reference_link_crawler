Fast Multiparty Threshold ECDSA with Fast Trustless
Setup

Rosario Gennaro1 and Steven Goldfeder2

1 City University of New York
rosario@cs.ccny.cuny.edu
2 Cornell Universty§
goldfeder@cornell.edu

Abstract. A threshold signature scheme enables distributed signing among n players such
that any subgroup of size t + 1 can sign, whereas any group with t or fewer players cannot.
While there exist previous threshold schemes for the ECDSA signature scheme, we present
the ﬁrst protocol that supports multiparty signatures for any t ≤ n with eﬃcient, dealerless
key generation. Our protocol is faster than previous solutions and signiﬁcantly reduces the
communication complexity as well. We prove our scheme secure against malicious adversaries
with a dishonest majority. We implemented our protocol, demonstrating its eﬃciency and
suitability to be deployed in practice.

Note: This revised version ﬁxes some crucial details in the protocol. The proof
of the protocol described in the previous version is not correct, though no attack
has been shown that exploits the bug in the proof. More details appear in the
intoduction.

1 Introduction

A threshold signature scheme enables n parties to share the power to issue digital signatures
under a single public key. A threshold t is speciﬁed such that any subset of t + 1 players can
jointly sign, but any smaller subset cannot. Generally, the goal is to produce signatures that are
compatible with an existing centralized signature scheme. In a threshold scheme the key generation
and signature algorithm are replaced by a communication protocol between the parties, but the
veriﬁcation algorithm remains identical to the veriﬁcation of a signature issued by a centralized
party.

In recent years there has been renewed attention to this topic, in particular to the threshold
generation of ECDSA signatures, mostly due to the use of ECDSA in Bitcoin and other cryptocur-
rencies. Indeed, a secure threshold signature schemes for ECDSA would be an eﬀective counter-
measure to the constant theft of bitcoins due to the compromise of the secret signing key that
authorizes transactions. Securing Bitcoin is equivalent to securing these keys. Instead of storing
them in a single location, keys should be split and signing should be authorized by a threshold set
of computers. A breach of any one of these machines—or any number of machines less than the
threshold—will not allow the attacker to steal any money or glean any information about the key.
Before the advent of Bitcoin, the best ECDSA threshold signature scheme was the work by
Gennaro et al. [18], which has a considerable setback. To implement a security threshold of t
players (i.e. t or less players cannot sign) it is necessary to share the key among at least 2t + 1
players, and the participation of at least 2t + 1 players is required to sign. This limitation rules out
an n-of-n sharing where all parties are required to sign. Furthermore, it requires setting up many
servers holding key shares, which may be costly and also makes the job of the attacker easier in

This is a major revision of our paper [16] that appeared at ACM CCS 2018.
§ Steven Goldfeder was at Princeton University when this research took place

2

Rosario Gennaro and Steven Goldfeder

some way (as there are more servers that can be targeted and while the honest participants need
2t + 1 players to sign, an attacker need only compromise t + 1 servers to steal the key).

In an attempt to address these issues, Mackenzie and Reiter built a specialized scheme for
the 2-out-of-2 signature case (i.e. t = 1 and n = 2) [30], a case not covered by Gennaro et al.’s
scheme. Recently much improved 2-out-of-2 schemes have been presented [12, 28]. However 2-out-
of-2 sharing is very limited and can’t express more ﬂexible sharing policies that might be required
in certain applications.

Gennaro and others in [17] (improved in [4]) address the more general (t, n) case in the threshold
optimal setting, meaning n ≥ t + 1 and that only t + 1 players are needed to sign. However, their
scheme too has a setback in that the distributed key generation protocol is very costly.

Our Result: We present a new threshold-optimal protocol for ECDSA that improves in many
signiﬁcant ways over [4, 17]. Our new protocol is faster and requires much less communication than
[4, 17]; it is also conceptually simpler and does not require a complicated distributed key generation
protocol (details of the comparison appear below).

In concurrent work that appeared in the same proceedings, Lindell et al. present a similar

protocol for multiparty threshold ECDSA with an eﬃcient key generation [29].

1.1 Overview of our solution

Consider a “generic” DSA signature algorithm that works over any cyclic group G of prime order
q generated by an element g. It uses a hash function H deﬁned from arbitrary strings into Zq, and
another hash function H (cid:48) deﬁned from G to Zq. The secret key is x chosen uniformly at random in
Zq, with a matching public key y = gx. To sign a message M , the signer computes m = H(M ) ∈ Zq,
chooses k uniformly at random in Zq and computes R = gk−1
in G and r = H (cid:48)(R) ∈ Zq. Then
she computes s = k(m + xr) mod q. The signature on M is the pair (r, s) which is veriﬁed by
computing

R(cid:48) = gms−1 mod qyrs−1 mod q in G

and accepting if H (cid:48)(R(cid:48)) = r.

The technical complication with sharing DSA signatures comes from having to jointly compute
R (which requires raising g to the inverse of a secret value k) and to compute s which requires
multiplying two secret values k, x. As shown in [18], it is suﬃcient to show how to compute two
multiplications over secret values that are shared among the players. In [18] the values are shared
via Shamir’s secret sharing, i.e., as points on a polynomial of degree t with free term the secret.
The eﬀect of multiplication is that the degree of the polynomial is doubled, which explains why
the solution in [18] requires at least 2t + 1 players to participate. To address this problem [30] uses
a multiplicative sharing of the secret key x as x = x1 · x2 (an approach taken also in [12, 28]) which
is however hard to generalize to t > 2.

A diﬀerent approach was taken in [17]: the secret key x is encrypted under a public key en-
cryption scheme E, and it is the secret key of E that is shared among the players, eﬀectively
providing a secret sharing of x. If E is an additively homomorphic encryption scheme (e.g. Pail-
lier’s [33]) they show that it is possible to construct a reasonably eﬃcient protocol, with a few
troubling bottlenecks. The major one is that the protocol requires a joint generation of the public
key/secret key pair for the additively homomorphic encryption E. When E is instantiated using
Paillier, this requires the distributed generation of an RSA modulus. Although solutions are known
for this problem (e.g. [24]), they are far from scalable and eﬃcient. To our knowledge the protocol
from [24] has never been implemented for the malicious multiparty case. The only benchmark we
are aware of for this protocol is that for the two-party semi-honest case it takes 15 minutes [28],
and we can extrapolate that it would take signiﬁcantly longer in the multiparty malicious setting.
Moreover the signature generation protocols in [4, 17] require long messages and complicated ZK
proofs.

Fast Multiparty Threshold ECDSA with Fast Trustless Setup

3

In this paper we take a diﬀerent path inspired by the SPDZ approach to multiparty computation
[9]. Given two secrets a, b shared additively among the players, i.e. a = a1 + . . . + an and b =
b1 + . . . + bn where Pi holds ai, and bi, we want to generate an additive sharing of c = ab. We
note that ab = (cid:80)
i,j aibj and therefore to get an additive sharing of ab, it is suﬃcient to obtain an
additive sharing of each individual term aibj. To that extent we use a 2-party protocol that allows
two parties to transform multiplicative shares of a secret to additive shares of the same secret. The
players engage in this protocol in a pairwise fashion to obtain an additive sharing of the product
ab.

Using this approach, we build a simple and elegant threshold ECDSA protocol for the general
multiparty setting. The players start with a (t, n) Shamir sharing of the secret key x. When t + 1
players want to sign, they generate an additive sharing of two random values k = (cid:80)
i ki and
γ = (cid:80)
i γi and they use the above idea to compute additive sharings of the products δ = kγ (which
is reconstructed in the clear) and σ = kx = (cid:80)
i wi (which is kept shared). By multiplying the local
shares of γ by the public value δ−1 the players end up with an additive sharing3 of k−1. The value
R is then easily computed in the exponent R = (cid:81)
. The value s is shared additively among
the players since each player holds si = kim + wir and s = (cid:80)

i gγiδ−1

i si.

1.2 Avoid expensive ZK Proofs in case of a Malicious Adversary

Following [28] we make minimal use of ZK proofs to detect malicious behavior by the players.

Instead we take an “optimistic” approach and run the protocol assuming everybody is honest.
We then check the validity of the resulting signature to detect if there were players who deviated
from the protocol (if the signature does not verify then obviously at least one player did not follow
the instructions).

At that point, because we possibly have a dishonest majority among the players, there is no
guarantee that we can generate a correct signature so the protocol stops and aborts. This creates
a technical complication in the proof as we have to make sure that the values revealed by the good
players do not leak any valuable information, not only in the case of good executions, but also in
the case of aborting executions. As we will see, this will require us to “distributively” check that the
shares si reconstruct a valid signature before revealing them. This check is somewhat reminiscent
of the way Canetti and Goldwasser solve a similar problem in [7] to construct threshold CCA secure
encryption based on the Cramer-Shoup scheme.
Range Proofs. Even when using the signature veriﬁcation step to detect cheating, we have to
run two relatively expensive ZK proofs during the share conversion protocol:

– a “range proof” that certain values encrypted under Paillier’s encryption scheme are “small”;
– a proof that a party knows x such that c = E(x) and y = gx where E is Paillier’s encryption

scheme.

1.3 The issue with the previous version

The previous version of the protocol did not check the range of all values encrypted under Paillier’s
encryption scheme. This creates an adversarial strategy that could leak information about an honest
party’s share. The proof of the protocol in the previous version did not take into account this leakage
and incorrectly assumed that certain subprotocols were zero-knowledge and simulatable. The issue
was reported in [37, 32].

Moreover in [37] the authors show how to leverage this information leakage to actually recover
the entire share of an honest party, and for the adversary to learn the entire secret key of the group.
Crucially, however, the attack relies on choosing a very small Paillier modulus N (approximately
the same size of the modulus q used in the DSA scheme). In our previous version we clearly stated

3 This is the famous Bar-Ilan and Beaver inversion trick [1].

4

Rosario Gennaro and Steven Goldfeder

that N > q7 therefore the attack does not apply to our previous scheme (though it worked against
implementations that neglected to check the size of the modulus).

We have now changed the protocol to make sure that all values encrypted under Paillier’s
scheme are checked to be ”small”. All changes from the previous protocol are discussed when they
arise and marked with Note about previous version header.

Finally, in the previous version we discussed a protocol where the ZK range proofs were removed
entirely. We discussed how removing these ZK proofs creates an attack that leaks some information
about the DSA secret key (and the randomizer k used in each signature) shared among the servers.
We conjectured that this information would still not allow the adversary to forge signatures. We did
not consider this ”light” protocol to be ”secure”, and never recommended it for implementation in
commercial systems. We made the conjecture to stimulate research on the ”danger” of leaking that
information. Our conjecture has been disproven in [37, 32] where it is also shown that removing
the ZK range proofs does indeed lead to an insecure protocol. We are going to leave Section 5 in
the paper as an historical record but will preface it with this new information.

1.4 Experimental Results

We implemented our scheme and found both the key generation and signing protocols to be very
eﬃcient.

The key generation protocol is easy to implement and is quite fast (under a second for any
reasonable choice of parameters). This is in stark contrast to [4, 17] for which the key generation
protocol has never been implemented, and it is hard to estimate what the actual running time
would be.

Our signing protocol is also extremely eﬃcient, and is a signiﬁcant improvement over previous

works both in terms of data transferred and running time.

With the combination of an eﬃcient key generation and signing protocol, our scheme is suitable

to be deployed in practice. We present full benchmarks and evaluations in Section 7.

2 Preliminaries

Communication Model. We assume the existence of a broadcast channel as well as point-to-point
channels connecting every pair of players.

The Adversary. We assume a probabilistic polynomial time malicious adversary, who may de-
viate from the protocol description arbitrarily. The adversary can corrupt up to t players, and it
learns the private state of all corrupted players. As in previous threshold ECDSA schemes [4, 17,
18, 28], we limit ourselves to static corruptions, meaning the adversary must choose which players
to corrupt at the beginning of the protocol. There are standard techniques for converting a protocol
secure against static corruptions to secure against adaptive corruptions [6, 25], but these will incur
an overhead.

We assume a rushing adversary, meaning that the adversary gets to speak last in a given round

and, in particular, can choose his message after seeing the honest parties’ messages.

Following [4, 17] (but unlike [18]), we assume a dishonest majority, meaning t, the number
of players the adversary corrupts, can be up to n − 1. In this case, there is no guarantee that the
protocol will complete, and we therefore do not attempt to achieve robustness, or the ability to
complete the protocol even in the presence of some misbehaving participants.

2.1 Signature Schemes

A digital signature scheme S consists of three eﬃcient algorithms:

Fast Multiparty Threshold ECDSA with Fast Trustless Setup

5

– (sk, pk)←Key-Gen(1λ), the randomized key generation algorithm which takes as input the

security parameter and returns the private signing key sk and public veriﬁcation key pk.

– σ←Sig(sk, m), the possibly randomized signing algorithm which takes as input the private key
sk and the message to be signed m and outputs a signature, σ. As the signature may be
randomized, there may be multiple valid signatures. We denote the set of valid signatures as
{Sig(sk, m)} and require that σ ∈ {Sig(sk, m)}.

– b ←Ver (pk, m, σ), the deterministic veriﬁcation algorithm, which takes as input a public key
pk, a message m and a signature σ and outputs a bit b which equals 1 if and only if σ is a valid
signature on m under pk.

To prove a signature scheme secure, we recall the standard notion of existential unforgeability

against chosen message attacks (EU-CMA) as introduced in [23].

Deﬁnition 1 (Existential unforgeability). Consider a PPT adversary A who is given public
key pk output by Key-Gen and oracle access to the signing algorithm Sig(sk, ·) with which it can
receive signatures on adaptively chosen messages of its choosing. Let M be the set of messages
queried by A. A digital signature scheme S =(Key-Gen,Sig,Ver) is said to be existentially unforge-
able if there is no such PPT adversary A that can produce a signature on a message m /∈ M,
except with negligible probability in λ.

2.2 Threshold Signatures

Threshold secret sharing. A (t, n)−threshold secret sharing of a secret x consists of n shares
x1, . . . , xn such that an eﬃcient algorithm exists that takes as input t + 1 of these shares and
outputs the secret, but t or fewer shares do not reveal any information about the secret.

Threshold signature schemes. Consider a signature scheme, S=(Key-Gen, Sig, Ver). A (t, n)-
threshold signature scheme T S for S enables distributing the signing among a group of n players,
P1, . . . , Pn such that any group of at least t + 1 of these players can jointly generate a signature,
whereas groups of size t or fewer cannot. More formally, T S consists of two protocols:

– Thresh-Key-Gen, the distributed key generation protocol, which takes as input the security
parameter 1λ. Each player Pi receives as output the public key pk as well as a private output
ski, which is Pi’s share of the private key. The values sk1, . . . , skn constitute a (t, n) threshold
secret sharing of the private key sk.

– Thresh-Sig, the distributed signing protocol which takes as public input a message m to be
signed as well as a private input ski from each player. It outputs a signature σ ∈ {Sig(sk, m)}.

Notice that the signature output by Thresh-Sig is a valid signature under Sig, the centralized
signing protocol. Thus we do not specify a threshold variant of the veriﬁcation algorithm as we
will use the centralized veriﬁcation algorithm, Ver.

In some applications, it may be acceptable to have a trusted dealer generate the private key

shares for each party. In this case, Thresh-Key-Gen would not be run.

Following [18, 19], we present a game-based deﬁnition of security analogous to EU-CMA.

Deﬁnition 2 (Unforgeable threshold signature scheme [18]). We say that a (t, n)-threshold
signature scheme T S =(Thresh-Key-Gen,Thresh-Sig) is unforgeable, if no malicious adversary who
corrupts at most t players can produce, with non-negligible (in λ) probability, the signature on any
new (i.e., previously unsigned) message m, given the view of the protocol Thresh-Key-Gen and of
the protocol Thresh-Sig on input messages m1, . . . , mk which the adversary adaptively chose as well
as signatures on those messages.

6

Rosario Gennaro and Steven Goldfeder

This is a game-based deﬁnition of security which is analogous to the notion of existential unforge-
ability under chosen message attack as deﬁned by Goldwasser, Micali, and Rivest [23]. Unlike in the
centralized EU-CMA deﬁnition, the adversary is additionally given the corrupted players’ views
of the key generation protocol as well as their views in the signing protocol for the messages it
chooses. A stronger simulation-based deﬁnition is also possible (see e.g. [17, 18, 28]). See Section
6.3 in which we show how to prove security of our protocol using this stronger simulation-based
deﬁnition.

2.3 Additively Homomorphic Encryption

Our protocol relies on an encryption scheme E that is additively homomorphic modulo a large
integer N . Let Epk(·) denote the encryption algorithm for E using public key pk. Given ciphertexts
c1 = Epk(a) and c2 = Epk(b), there is an eﬃciently computable function +E such that

c1 +E c2 = Epk(a + b mod N )

The existence of a ciphertext addition operation also implies a scalar multiplication operation,

which we denote by ×E. Given an integer a ∈ N and a ciphertext c = Epk(m), then we have

a ×E c = Epk(am mod N )

Informally, we say that E is semantically secure if for the probability distributions of the en-

cryptions of any two messages are computationally indistinguishable.

We instantiate our protocol using the additively homomorphic encryption scheme of Paillier

[33], and we recall the details here:

– Key-Gen: generate two large primes P, Q of equal length, and set N = P Q. Let λ(N ) =
lcm(P − 1, Q − 1) be the Carmichael function of N , and denote Γ = N + 1. The public key is
ZN and the secret key is λ(N ).

– Encryption: to encrypt a message m ∈ ZN , select x ∈R Z ∗
– Decryption: to decrypt a ciphertext c ∈ ZN 2, let L be a function deﬁned over the set {u ∈
ZN 2 : u = 1 mod N } computed as L(u) = (u − 1)/N . Then the decryption of c is computed as
L(cλ(N ))/L(Γ λ(N )) mod N .

N and return c = Γ mxN mod N 2.

– Homomorphic Properties: Given two ciphertexts c1, c2 ∈ ZN 2 deﬁne c1 +E c2 = c1c2 mod N 2. If
ci = E(mi) then c1 +E c2 = E(m1 + m2 mod N ). Similarly, given a ciphertext c = E(m) ∈ ZN 2
and a number a ∈ Zn we have that a ×E c = ca mod N 2 = E(am mod N ).

The security of Paillier’s cryptosystem relies on the N -residuosity decisional assumption [33],
which informally says that it is infeasible to distinguish random N -residues from random group
elements in Z ∗

N 2.

2.4 Non-Malleable Equivocable Commitments

A trapdoor commitment scheme allows a sender to commit to a message with information-theoretic
privacy. i.e., given the transcript of the commitment phase the receiver, even with inﬁnite computing
power, cannot guess the committed message better than at random. On the other hand when it
comes to opening the message, the sender is only computationally bound to the committed message.
Indeed the scheme admits a trapdoor whose knowledge allows to open a commitment in any possible
way (we will refer to this also as equivocate the commitment). This trapdoor should be hard to
compute eﬃciently.

Formally a (non-interactive) trapdoor commitment scheme consists of four algorithms KG, Com,

Ver, Equiv with the following properties:

Fast Multiparty Threshold ECDSA with Fast Trustless Setup

7

– KG is the key generation algorithm, on input the security parameter it outputs a pair {pk,
tk} where pk is the public key associated with the commitment scheme, and tk is called the
trapdoor.

– Com is the commitment algorithm. On input pk and a message M it outputs [C(M ), D(M )] =
Com(pk, M, R) where r are the coin tosses. C(M ) is the commitment string, while D(M ) is
the decommitment string, which is kept secret until opening time.

– Ver is the veriﬁcation algorithm. On input C, D and pk it either outputs a message M or ⊥.
– Equiv is the algorithm that opens a commitment in any possible way given the trapdoor in-
formation. It takes as input pk, strings M, R with [C(M ), D(M )] = Com(pk, M, R), a message
M (cid:48) (cid:54)= M and a string T . If T = tk then Equiv outputs D(cid:48) such that Ver(pk, C(M ), D(cid:48)) = M (cid:48).

We note that if the sender refuses to open a commitment we can set D = ⊥ and Ver(pk, C, ⊥) = ⊥.
Trapdoor commitments must satisfy the following properties

Correctness If [C(M ), D(M )] = Com(pk, M, R) then

Ver(pk, C(M ), D(M )) = M .

Information Theoretic Security For every message pair M, M (cid:48) the distributions C(M ) and

C(M (cid:48)) are statistically close.

Secure Binding We say that an adversary A wins if it outputs C, D, D(cid:48) such that Ver(pk, C, D) =
M , Ver(pk, C, D(cid:48)) = M (cid:48) and M (cid:54)= M (cid:48). We require that for all eﬃcient algorithms A, the
probability that A wins is negligible in the security parameter.

Such a commitment is non-malleable [13] if no adversary A, given a commitment C to a messages
m, is able to produce another commitment C (cid:48) such that after seeing the opening of C to m, A can
successfully decommit to a related message m(cid:48) (this is actually the notion of non-malleability with
respect to opening introduced in [10]).

The non-malleable commitment schemes in [10, 11] are not suitable for our purpose because
they are not “concurrently” secure, in the sense that the security deﬁnition holds only for t = 1
(i.e. the adversary sees only 1 commitment).

The stronger concurrent security notion of non-malleability for t > 1 is achieved by the schemes

presented in [8, 15, 31]), and any of them can be used in our threshold DSA scheme.

However in practice one can use any secure hash function H and deﬁne the commitment to
x as h = H(x, r), for a uniformly chosen r of length λ and assume that H behaves as a random
oracle. We use this eﬃcient random oracle version in our implementation.

2.5 The Digital Signature Standard

The Digital Signature Algorithm (DSA) was proposed by Kravitz in 1991, and adopted by NIST
in 1994 as the Digital Signature Standard (DSS) [3, 27]. ECDSA, the elliptic curve variant of DSA,
has become quite popular in recent years, especially in cryptocurruencies.

All of our results in this paper apply to both the traditional DSA and ECDSA. We present our

results using the generic G-DSA notation from [17], which we recall here.

The Public Parameters consist of a cyclic group G of prime order q, a generator g for G, a hash

function H : {0, 1}∗ → Zq, and another hash function H (cid:48) : G → Zq.

.

Key-Gen On input the security parameter, outputs a private key x chosen uniformly at random in Zq,

and a public key y = gx computed in G.

Sig On input an arbitrary message M ,
• compute m = H(M ) ∈ Zq
• choose k ∈R Zq
• compute R = gk−1
• compute s = k(m + xr) mod q

in G and r = H (cid:48)(R) ∈ Zq

8

Rosario Gennaro and Steven Goldfeder

• output σ = (r, s)
Ver On input M, σ and y,

• check that r, s ∈ Zq
• compute R(cid:48) = gms−1 mod qyrs−1 mod q in G
• Accept (output 1) iﬀ H (cid:48)(R(cid:48)) = r.

The traditional DSA algorithm is obtained by choosing large primes p, q such that q|(p − 1)
p . In this case the multiplication operation in G is

and setting G to be the order q subgroup of Z ∗
multiplication modulo p. The function H (cid:48) is deﬁned as H (cid:48)(R) = R mod q.

The ECDSA scheme is obtained by choosing G as a group of points on an elliptic curve of
cardinality q. In this case the multiplication operation in G is the group operation over the curve.
The function H (cid:48) is deﬁned as H (cid:48)(R) = Rx mod q where Rx is the x-coordinate of the point R.

2.6 Feldman’s VSS Protocol

Recall that in Shamir’s scheme [36], to share a secret σ ∈ Zq, the dealer generates a random degree
t polynomial p(·) over Zq such that p(0) = σ. The secret shares are evaluations of the polynomial

p(x) = σ + a1x + a2x2 + · · · + atxt mod q

Each player Pi receives a share σi = p(i) mod q.
In a veriﬁable secret sharing scheme, auxiliary information is published that allows players to

check that their shares are consistent and deﬁne a unique secret.

Feldman’s VSS is an extension of Shamir secret sharing in which the dealer also publishes

vi = gai in G for all i ∈ [1, t] and v0 = gσ in G.

Using this auxiliary information, each player Pi can check its share σi for consistency by veri-

fying:

gσi ?=

t
(cid:89)

j=0

vij
j

in G

If the check does not hold for any player, it raises a complaint and the protocol terminates. Note
that this is diﬀerent than the way Feldman VSS was originally presented as it assumed an honest
majority and could recover if a dishonest player raised a complaint. However, since we assume
dishonest majority in this paper, the protocol will abort if a complaint is raised.

While Feldman’s scheme does leak gσ, it can be shown via a simulation argument that nothing

else is leaked, but we omit the details here.

2.7 Assumptions

DDH. Let G be a cyclic group of prime order q, generated by g. The DDH Assumption states that
the following two distributions over G3 are computationally indistinguishable: DH = {(ga, gb, gab)
for a, b ∈R Zq} and R = {(ga, gb, gc) for a, b, c ∈R Zq}.
Strong-RSA. Let N be the product of two safe primes, N = pq, with p = 2p(cid:48) + 1 and q = 2q(cid:48) + 1
with p(cid:48), q(cid:48) primes. With φ(N ) we denote the Euler function of N , i.e. φ(N ) = (p − 1)(q − 1) = p(cid:48)q(cid:48).
With Z ∗
N we denote the set of integers between 0 and N − 1 and relatively prime to N .

Let e be an integer relatively prime to φ(N ). The RSA Assumption [34] states that it is infeasible
N it is hard to ﬁnd x such that

N . That is, given a random element s ∈R Z ∗

to compute e-roots in Z ∗
xe = s mod N .

The Strong RSA Assumption (introduced in [2]) states that given a random element s in Z ∗
N
it is hard to ﬁnd x, e (cid:54)= 1 such that xe = s mod N . The assumption diﬀers from the traditional

Fast Multiparty Threshold ECDSA with Fast Trustless Setup

9

RSA assumption in that we allow the adversary to freely choose the exponent e for which she will
be able to compute e-roots.

We now give formal deﬁnitions. Let SRSA(n) be the set of integers N , such that N is the

product of two n/2-bit safe primes.

Assumption 1 We say that the Strong RSA Assumption holds, if for all probabilistic polynomial
time adversaries A the following probability

P rob[ N ← SRSA(n) ; s ← Z ∗

N : A(N, s) = (x, e) s.t. xe = s mod N ]

is negligible in n.

3 A share conversion protocol

Assume that we have two parties Alice and Bob holding two secrets a, b ∈ Zq respectively which
we can think of as multiplicative shares of a secret x = ab mod q. Alice and Bob would like to
compute secret additive shares α, β of x, that is random values such that α + β = x = ab mod q
with Alice holding α (and a) and Bob holding β (and b).

Here we show a protocol based on an additively homomorphic scheme which has appeared many
times before in the literature (e.g. [9, 26, 28, 30]) but that we adapt to our needs. We assume that
Alice is associated with a public key EA for an additively homomorphic scheme E over an integer
N .

In the following we will refer to this protocol as an MtA (for Multiplicative to Additive) share
conversion protocol. In our protocol we also assume that B = gb might be public. In this case
an extra check for Bob is used to force him to use the correct value b. We refer to this enhanced
protocol as MtAwc (as MtA “with check”).

1. Alice initiates the protocol by

– sending cA = EA(a) to Bob
– proving in ZK that he knows a < q3 via a range proof

2. Bob computes the ciphertext cB = b ×E cA +E EA(β(cid:48)) = EA(ab + β(cid:48)) where β(cid:48) is chosen
uniformly at random in Zq5 . Bob sets his share to β = −β(cid:48) mod q. He responds to Alice by

– sending cB
– proving in ZK that he knows b < q3, β(cid:48) < q7 such that cB = b ×E cA +E EA(β(cid:48)).
– and only if B = gb is public that B = gb and
3. Alice decrypts cB to obtain α(cid:48) and sets α = α(cid:48) mod q.

Correctness. Assume both players are honest and N > q8. Then note that Alice decrypts the
value α(cid:48) = ab + β(cid:48) mod N . Note that β(cid:48) < N − ab and therefore the reduction mod N is not
executed which implies that the protocol correctly computes α, β such that α + β = x mod q.

Simulation. We ﬁrst point out that as a stand-alone protocol, we can prove security even without
the range proofs. Indeed, if the adversary corrupts Alice, then Bob’s message can be simulated
without knowledge of its input b. Indeed a simulator can just choose a random b(cid:48) ∈ Zq and act as
Bob. The distribution of the message decrypted by Alice in this simulation is statistically close to
the message decrypted when Bob uses the real b, because the “noise” β(cid:48) is uniformly distributed
in Zq5.

If the adversary corrupts Bob, then Alice’s message can be simulated without knowledge of its
input a. Indeed a simulator can just choose a random a(cid:48) ∈ Zq and act as Alice. In this case the
view of Bob is computationally indistinguishable from the real one due to the semantic security of
the encryption scheme E.

However if the range proofs are not used, a malicious Alice or Bob can cause the protocol to
“fail” by choosing large inputs. As a stand-alone protocol this is not an issue since the parties are

10

Rosario Gennaro and Steven Goldfeder

not even aware that the reduction mod N took place and no information is leaked about the other
party’s input. However, when used inside our threshold DSA protocol, this attack will cause the
signature veriﬁcation to fail, and this information is linked to the size of the other party’s input.
Consider for example the case of Alice running the protocol with input a(cid:48) = q7 + a. If Bob’s
input is “small” then the reduction mod N will not take place and the protocol will succeed, and
eventually the signature produced by our threshold DSA protocol will verify (since a(cid:48) = a mod q).
But if Bob’s input is large the protocol will fail. Similar issues arise if one does not check the range
of b and β(cid:48).

So we need security in the presence of an oracle that tells the parties if the reduction mod N
happens or not, but due to the ZK “range proofs” such reduction will only happen with negligible
probability and security holds.
Remark. On the ZK proofs and the size of the modulus N . For the ZK proofs required in the
protocol we use simpliﬁed versions of similar ZK proofs presented in [30] (and already used in
[17]). These are ZK arguments with security holding under the Strong RSA Assumption. Moreover
they require N ≈ q8 as pointed above. We point out that for typical choices of parameters, N is
approximately q8 (since q is typically 256-bit long while N is a 2048-bit RSA modulus), so this
requirement is not problematic. It is however imperative that the size of N is checked by the parties
to ensure the ZK property of the proofs4.

Note about the previous version: In our previous version we chose β(cid:48) uniformly at random
in ZN and did not impose any range check on it. This leads to a similar information leakage as
described above where if β(cid:48) is chosen close to N , a modular reduction (and therefore a failure of
the protocol) happens based on the distribution of the input a.

4 Our scheme

We now describe our protocol. The players run on input G, g the cyclic group used by the DSA
signature scheme. We assume that each player Pi is associated with a public key Ei for an additively
homomorphic encryption scheme E.

4.1 Key generation protocol

– Phase 1. Each Player Pi selects ui ∈R Zq; computes [KGCi, KGDi] = Com(gui) and broadcasts

KGCi. Each Player Pi broadcasts Ei the public key for Paillier’s cryptosystem.

– Phase 2. Each Player Pi broadcasts KGDi. Let yi be the value decommitted by Pi. The player
Pi performs a (t, n) Feldman-VSS of the value ui, with yi as the “free term in the exponent”
The public key is set to y = (cid:81)
i yi. Each player adds the private shares received during the
n Feldman VSS protocols. The resulting values xi are a (t, n) Shamir’s secret sharing of the
secret key x = (cid:80)

i ui. Note that the values Xi = gxi are public.

– Phase 3 Let Ni = piqi be the RSA modulus associated with Ei. Each player Pi proves in ZK
that he knows xi using Schnorr’s protocol [35] and that Ni is square-free using the proof of
Gennaro, Micciancio, and Rabin [21].

4.2 Signature Generation

We now describe the signature generation protocol, which is run on input m (the hash of the
message M being signed) and the output of the key generation protocol described above. We note

4 For the simple range proof that a, b < K one could alternatively use a variation of Boudot’s proof [5]
which establish K ∼ q which sets N ∼ q3. This proof is less eﬃcient that the ones from [17, 30] which
are anyway required for Bob in the MtAwc protocol. Moreover as we said earlier, N > q8 in practice
anyway so the improvement in the size of N is irrelevant for ECDSA.

Fast Multiparty Threshold ECDSA with Fast Trustless Setup

11

that the latter protocol is a t-out-of-n protocol (and thus the secret key x is shared using (t, n)
Shamir secret-sharing).

Let S ⊆ [1..n] be the set of players participating in the signature protocol. We assume that |S| =
t + 1. For the signing protocol we can share any ephemeral secrets using a (t, t + 1) secret sharing
scheme, and do not need to use the general (t, n) structure. We note that using the appropriate
Lagrangian coeﬃcients λi,S each player in S can locally map its own (t, n) share xi of x into a
(t, t + 1) share of x, wi = (λi,S)(xi), i.e. x = (cid:80)
i∈S wi. Since Xi = gxi and λi,S are public values,
all the players can compute Wi = gwi = X λi,S
.

i

– Phase 1. Each Player Pi selects ki, γi ∈R Zq; computes [Ci, Di] = Com(gγi) and broadcast Ci.

Deﬁne k = (cid:80)

i∈S ki, γ = (cid:80)

i∈S γi. Note that

kγ =

kx =

(cid:88)

i,j∈S

(cid:88)

i,j∈S

kiγj mod q

kiwj mod q

– Phase 2. Every pair of players Pi, Pj engages in two multiplicative-to-additive share conversion

subprotocols

• Pi, Pj run MtA with shares ki, γj respectively. Let αij [resp. βij] be the share received by

player Pi [resp. Pj] at the end of this protocol, i.e.

Player Pi sets δi = kiγi + (cid:80)
sharing of kγ = (cid:80)

i∈S δi

kiγj = αij + βij

j(cid:54)=i αij + (cid:80)

j(cid:54)=i βji. Note that the δi are a (t, t + 1) additive

• Pi, Pj run MtAwc with shares ki, wj respectively. Let µij [resp. νij] be the share received

by player Pi [resp. Pj] at the end of this protocol, i.e.

kiwj = µij + νij

j(cid:54)=i µij + (cid:80)

j(cid:54)=i νji. Note that the σi are a (t, t + 1) additive

Player Pi sets σi = kiwi + (cid:80)
sharing of kx = (cid:80)

i∈S σi

players compute δ−1 mod q.

– Phase 3. Every player Pi broadcasts δi and the players reconstruct δ = (cid:80)

i∈S δi = kγ. The

– Phase 4. Each Player Pi broadcasts Di. Let Γi be the values decommitted by Pi who proves in

ZK that he knows γi s.t. Γi = gγi using Schnorr’s protocol [35].
The players compute

R = [

(cid:89)

Γi]δ−1

= g((cid:80)

i∈S

γi)k−1γ−1

= gγk−1γ−1

= gk−1

i∈S

and r = H (cid:48)(R).

– Phase 5. Each player Pi sets si = mki + rσi. Note that

(cid:88)

i∈S

si = m

(cid:88)

i∈S

ki + r

(cid:88)

i∈S

σi = mk + rkx = k(m + xr) = s

i.e. the si are a (t, t + 1) sharing of s.

• (5A) Player Pi chooses (cid:96)i, ρi ∈R Zq computes Vi = Rsig(cid:96)i , Ai = gρi, and [ ˆCi, ˆDi] =

Com(Vi, Ai) and broadcasts ˆCi.
Let (cid:96) = (cid:80)

i (cid:96)i and ρ = (cid:80)

i ρi.

12

Rosario Gennaro and Steven Goldfeder

• (5B) Player Pi broadcasts ˆDi and proves in ZK that he knows si, (cid:96)i, ρi such that Vi = Rsig(cid:96)i
i∈S Vi (this should be

i . If a ZK proof fails, the protocol aborts. Let V = g−my−r (cid:81)

and Aρi
V = g(cid:96)) and A = (cid:81)

i∈S Ai.

• (5C) Player Pi computes Ui = V ρi and Ti = A(cid:96)i. It commits [ ˜Ci, ˜Di] = Com(Ui, Ti) and

broadcasts ˜Ci.

aborts.

• (5D) Player Pi broadcasts ˜Di to decommit to Ui, Ti If (cid:81)

i∈S[Ti] (cid:54)= (cid:81)

i∈S Ui the protocol

• (5E) Otherwise player Pi broadcasts si. The players compute s = (cid:80)

i∈S si. If (r, s) is not a

valid signature the players abort, otherwise they accept and end the protocol.

Let us explain the intuition behind Phase 5. To avoid expensive ZK proofs, we are potentially
reconstructing an incorrect signature, which is then checked and possibly rejected. A naive approach
to the last phase is for the players to reveal si and reconstruct s = (cid:80)
i si. But, for reasons that
will become clear in the proof, this is not provably secure—the intuitive reason being that if the
adversary makes the protocol fail by outputting an invalid signature, then the values si held by the
good players may give him valuable information.5 Naively this could be done by ﬁrst broadcasting
Si = Rsi and check that (cid:81)
i Si = Rs = gmyr according to the DSA veriﬁcation algorithm. But
for similar reasons, this step makes the proof fail. So in our protocol the players mask Rsi with
a random value g(cid:96)i. Let Vi = Rsig(cid:96)i. Then (cid:81)
i Vi = Rsg(cid:96) and therefore V = g(cid:96). The players
cannot reveal g(cid:96)i to check the correctness of V as this would “de-mask” Rsi so we “randomize” the
“aggregate” value to U = g(cid:96)ρ. Alongside the players compute g(cid:96)ρ via a distributed “Diﬃe-Hellman”
exchange. If this distributed randomized signature veriﬁcation carries out, then it is safe to release
the shares si, but if the signature does not verify then the protocol aborts here and the values si
held by the good players are never revealed in the clear.

4.3 The Zero-Knowledge Proofs

In step (5B) a player P outputs V = Rsg(cid:96) and A = gρ and must prove that he knows s, (cid:96), ρ
satisfying the above relationship. The proof for A is the classic Schnorr’s proof. For the value V a
classic (honest-veriﬁer) ZK proof for this task is as follows:

– The Prover chooses a, b ∈R Zq and sends α = Ragb
– The Veriﬁer sends a random challenge c ∈R Zq
– The Prover answers with t = a + cs mod q and u = b + c(cid:96) mod q.
– The Veriﬁer checks that Rtgu = αV c

4.4 Security Proof

In this section we prove the following

Theorem 1. Assuming that

– The DSA signature scheme is unforgeable;
– The Strong RSA Assumption holds;
– KG, Com, Ver, Equiv is a non-malleable equivocable commitment scheme;
– the DDH Assumption holds

then our threshold DSA scheme in the previous section is unforgeable.

5 We do not have an attack but we do not see a way to make a proof work either.

Fast Multiparty Threshold ECDSA with Fast Trustless Setup

13

The proof of this theorem will proceed by a traditional simulation argument, in which we show
that if there is an adversary A that forges in the threshold scheme with a signiﬁcant probability,
then we can build a forger F that forges in the centralized DSA scheme also with a signiﬁcant
probability.

So let’s assume that there is an adversary A that forges in the threshold scheme with probability

larger than (cid:15) ≥ λ−c.

We assume that the adversary controls players P2, . . . , Pt+1 and that P1 is the honest player.
We point out that because we use concurrently non-malleable commitments (where the adversary
can see many commitments from the honest players) the proof also holds if the adversary controls
less than t players and we have more than 1 honest player. So the above assumption is without
loss of generality.

Because we are assuming a rushing adversary, P1 always speaks ﬁrst at each round. Our sim-
ulator will act on behalf of P1 and interact with the adversary controlling P2, . . . , Pn. Recall how
A works: it ﬁrst participates in the key generation protocol to generate a public key y for the
threshold scheme. Then it requests the group of players to sign several messages m1, . . . , m(cid:96), and
the group engages in the signing protocol on those messages. At the end with probability at least
(cid:15) the adversary outputs a message m (cid:54)= mi and a valid signature (r, s) for it under the DSA key y.
This probability is taken over the random tape τA of A and the random tape τ1 of P1. If we denote
with A(τA)P1(τ1) the output of A at the end of the experiment described above, we can write

We say that an adversary random tape τA is good if

P robτ1,τA [ A(τA)P1(τ1) is a forgery ] ≥ (cid:15)

P robτ1[ A(τA)P1(τ1) is a forgery ] ≥

(cid:15)
2

By a standard application of Markov’s inequality we know that if τA is chosen uniformly at random,
the probability of choosing a good one is at least (cid:15)
2 .
We now turn to building the adversary F that forges in the centralized scheme. This forger
will use A as a subroutine in a “simulated” version of the threshold scheme: F will play the role
of P1 while A will control the other players. F will choose a random tape τA for A: we know that
with probability at least (cid:15)
2 it will be a good tape. From now on we assume that A runs on a good
random tape.

F runs on input a public key y for the centralized DSA scheme, which is chosen according to
the uniform distribution in G. The ﬁrst task for F is to set up an indistinguishable simulation of
the key generation protocol to result in the same public key y.

Similarly every time A requests the signature of a message mi, the forger F will receive the real
signature (ri, si) from its signature oracle. It will then simulate, in an indistinguishable fashion, an
execution of the threshold signature protocol that on input mi results in the signature (ri, si).

Because these simulations are indistinguishable from the real protocol for A, the adversary will
output a forgery with the same probability as in real life. Such a forgery m, r, s is a signature on
a message that was never queried by F to its signature oracle and therefore a valid forgery for F
as well. We now turn to the details of the simulations.

4.5 Simulating the key generation protocol

The simulation Sim-Key-Gen is described below. On input a public key y = gx for DSA the forger
F plays the role of P1 as follows. The forger F also runs on input a Paillier public key E for which
he does not know the matching secret key (this is necessary for when we have to make a reduction
to the semantic security of the Paillier encryption scheme).

Simulation: Repeat the following steps (by rewinding A) until A sends valid messages (i.e. a correct
decommitment) for P2, . . . , Pn on both iterations.

14

Rosario Gennaro and Steven Goldfeder

– F (as P1) selects a random value u1 ∈ Zq, computes [KGC1, KGD1]= Com(gu1) and broadcasts

KGC1. A broadcasts commitments KCGi for i > 1;

– Each player Pi broadcasts KGDi; let yi be the decommitted value and the accompanying
Feldman-VSS (F will follow the protocol instructions). Each player broadcasts Ei. F broacasts
E1 = E.

– Let yi denote the revealed commitment values of each party. F rewinds the adversary to the

decommitment step and

• changes the opening of P1 to

ˆKGD1 so that the committed value revealed is now ˆy1 =

y · (cid:81)n

i=2 y−1

i

.

• simulates the Feldman-VSS with free term ˆy1

– The adversary A broadcasts

ˆKGDi. Let ˆyi be the committed value revealed by A at this point

(this could be ⊥ if the adversary refused to decommit).

– The players compute ˆy = (cid:81)n

i=1 ˆyi (set to ⊥ if any of the ˆyi are set to ⊥ in the previous step).

We now prove a few lemmas about this simulation.

Lemma 1. The simulation terminates in expected polynomial time and is indistinguishable from
the real protocol.

Proof (of Lemma 1). Since A is running on a good random tape, we know that the probability
over the random choices of F, that A will correctly decommit is at least (cid:15)
2λc . Therefore we
will need to repeat the loop only a polynomial number of times in expectation.

2 > 1

The only diﬀerences between the real and the simulated views is that P1 runs a simulated
Feldman-VSS with free term in the exponent ˆy1 for which it does not know the discrete log. But
we know (see Section 2.6) that this simulation is identically distributed from the real Feldman-VSS.
So the simulation of the protocol is perfect.

Lemma 2. For a polynomially large fraction of inputs y, the simulation terminates with output y
except with negligible probability.

Proof (of Lemma 2). First we prove that if the simulation terminates on an output which is not
⊥, then it terminates with output y except with negligible probability. This is a consequence of
the non-malleability property of the commitment scheme. Indeed, if A correctly decommits KGCi
twice it must do so with the same string, no matter what P1 decommits too (except with negligible
probability)6. Therefore ˆyi = yi for i > 1 and therefore ˆy = y.

Then we prove that this happens for a polynomially large fractions of input y. Let yA = (cid:81)n
i=2 yi,
i.e.the contribution of the adversary to the output of the protocol. Note that because of non-
malleability, this value is determined and known to F by the time it rewinds the adversary. At
that point F rewinds the adversary and chooses ˆy1 = y(y−1
A ). Since y is uniformly distributed, we
have that ˆy1 is also uniformly distributed. Because A is running on a good random tape we know
that at this point there is an (cid:15)
2λc fraction of ˆy1 for which A will correctly decommit. Since
there is a 1-to-1 correspondence between y and ˆy1 we can conclude that for a (cid:15)
2λc fraction of
the input y the protocol will successfully terminate.

2 > 1

2 > 1

4.6 Signature generation simulation

After the key generation is over, F must handle the signature queries issued by the adversary A.
When A requests to sign a message m, our forger F will engage in a simulation of the threshold
signature protocol. During this simulation F will have access to a signing oracle that produces
DSA signatures under the public key y issued earlier to F.

6 This property is actually referred to as independence. This is introduced in [20] as a stronger version of

non-malleability and then proven equivalent to non-malleability in [4]).

Fast Multiparty Threshold ECDSA with Fast Trustless Setup

15

and let ˜k be the value deﬁned by the
Semi-Correct Executions. Let k be such that R = gk−1
inputs of the players in the MtA and MtAwc protocols. More speciﬁcally if ci is the encryption sent
by player Pi in the ﬁrst round of those protocols, then deﬁne ˜ki = Deci(ci) and ˜k = (cid:80)

˜ki.

We say that a protocol execution is semi-correct if in step (4) it holds that k = ˜k. Note that
this condition is well deﬁned since the values k, ˜k are uniquely determined by step (4). Note that
an execution is not semi-correct if the adversary “messes up” the computation of R by revealing
wrong shares in the computation of δ.

i

In the real run of the protocol, it is not feasible to decide if an execution is semi-correct or not.
However, as we will see, in the simulation, we can detect whether an execution is semi-correct or
not, and depending on whether it is semi-correct the simulator will decide how to simulate Phase
5.

Bird-Eye View of Simulation. First we note that for semi-correct executions the adversary,
after Step 4 can already detect if the value Rs1 which will be broadcast in Step (5) by the good
player is correct or not. In fact by this point the adversary has si for i > 1 and for a “candidate”
Rs1 can check if

(cid:89)

Rsi = Rs = gmyr

i

Moreover in such executions when we arrive to step (5A) the simulator will be able to “extract”
the value s1 for the good player, which will allow the simulation to terminate successfully.

Second, we show that a simulation that is not semi-correct will fail at step (5D) with high
probability since the value U1 contributed by the good player is indistinguishable from random.
This allows us to simulate Phase (5) by simply using a random ˜s1 for P1.

Finally, the simulator needs to detect whether or not the execution is semi-correct in order
to know which path to choose. Although detecting this is not possible in the real protocol, the
simulator can extract appropriate values to faciliate this detection. We now proceed with the
details.

4.7 Semi-correct executions

We now present a simulation that works for a semi-correct execution.

We point out that F does not know the secret values associated with P1: its correct share w1
of the secret key, and the secret key of its public key E1. The latter is necessary in order to reduce
unforgeability to the semantic security of the encryption scheme.

However F does know the shares wj of all other players. It also knows the “public key” of P1,

W1 = gw1 from the simulation of the key generation protocol.

In the following simulation F aborts whenever the protocol is supposed to abort, i.e. if the
adversary (i) refuses to decommit in steps 4, 5B or 5D or (ii) fails the ZK proof in Step 2 or 5 or
(iii) the signature (r, s) does not verify.

– Phase 1 All the players execute the protocol by broadcasting Ci (F runs the protocol correctly

for P1).
– Phase 2

• All the players execute the MtA protocol for k and γ using the values k1 and γ1 that it
chose in Phase 1. F runs the protocol correctly for P1. For each other player Pi>1, F runs
two MtA protocols, one in which it initiates (using the value k1) and one in which it is the
respondent (using the value γ1). F extracts the following values from the range proofs for
i > 1:
∗ ki
∗ γi
∗ β(cid:48)
1i

16

Rosario Gennaro and Steven Goldfeder

Note that when F is the initiator, it cannot decrypt its own share α1j during the execution
of the protocol with Pj on input k1, γj. However, using the values it extracted, it can
compute α1j = k1γi + β(cid:48)

i mod q.

• All the players execute the MtAwc protocol for k and x. Here F simulates P1 according to

the simulation described in Section 3 since it does not know its own value w1.
Moreover it extracts Pj’s resulting share ν1j from its ZK proof.

• In the protocol with Pj on input kj, w1, F does not know w1 so it just sends a random µj1

to Pj.

Note that at this point F knows the sum of σi for the bad players. Indeed

(cid:88)

i>1

σi =

(cid:88)

kiwj +

(cid:88)

µj1 +

(cid:88)

ν1j

i,j>1

j

j

and F knows all the values on the right hand side of the equation.

– Phase 3 All the players execute the protocol by revealing δi. Let δ = (cid:80)

i δi (F runs the
protocol correctly for P1 with the random shares it chose in step 2 – therefore F is eﬀectively
broadcasting a random δ1).

– Phase 4

1. Each player reveals Di to decommit to Γi
2. F queries its signature oracle and receives a signature (r, s) on m. It computes R =

gms−1

yrs−1

∈ G (note that H (cid:48)(R) = r ∈ Zq).

Rδ (cid:81)

3. F rewinds A to the decommitment step, and for P1 changes the decommitment to ˆΓ1 =
= R
Note that at this point F knows the value si held by the bad players since si = kim + σir. So
F can compute the correct s1 held by P1 as s − (cid:80)

. Note that [ ˆΓ1

i>1 Γi]δ−1

i>1 Γ −1

(cid:81)

i

i>1 si.

– Phase 5 All players execute all the steps in this phase. F uses s1 as the share for P1.

We prove the following lemma about the simulation.

Lemma 3. Assuming that

– The Strong RSA Assumption holds
– KG, Com, Ver, Equiv is a non-malleable equivocable commitment;

then the simulation has the following properties

– on input m it outputs a valid signature (r, s) or aborts.
– it is computationally indistinguishable from a semi-correct real execution

Proof (of Lemma 3).

The only diﬀerences between the real and the simulated views is the following: In the MtA
protocol the values ci = Ei(ki) are published and in the real protocol R = gk−1
i ki,
while in the simulated execution R = gˆk−1
for the ˆk chosen by the signature oracle. This is easily
seen to be computationally indistinguishable under the semantic security of Paillier’s encryption.
Indeed, when F rewinds the adversary to “ﬁx” the value of R, it implicitly changes the value
k1 that F contributes for P1 to R. If R = gˆk−1
i>1 ki. Note that Rˆk1
ki. So to distinguish between the real
is known since R
execution and the simulated one, the adversary should detect if the ciphertext sent by F for P1
in the ﬁrst round of the MtAwc protocol contains a random k1 or the random ˆk1 determined as
logR(gR− (cid:80)
ki) which is infeasible under the semantic security of Paillier’s encryption (given
that all values are proven to be “small” and no wraparound mod N happens).

ki = g, therefore Rˆk1 = gR− (cid:80)

, let (implicitly) ˆk1 = ˆk − (cid:80)

where k = (cid:80)

ˆk1+(cid:80)

i>1

i>1

i>1

Note that we are simulating a semi-correct execution with an execution which is not semi-

correct, but that’s okay because the two are indistinguishable.

Fast Multiparty Threshold ECDSA with Fast Trustless Setup

17

However, because the real execution is a semi-correct one, we know that the correct shares of
k for the adversary are the ki that the simulator knows. Therefore the value s1 computed by the
simulator is consistent with a correct share for P1 for a valid signature (r, s), which makes Phase
5 indistinguishable from the real execution to the adversary.

Let (r, s) be the signature that F receives by its signature oracle in Step 2 of Phase 4. This
is a valid signature for m. We prove that if the protocol terminates, it does so with output (r, s).
This is a consequence of the non-malleability property of the commitment scheme. Indeed, if the
adversary correctly decommits, its openings must be the same except with negligible probability.

4.8 Simulation of a non semi-correct execution

We now show how to simulate the last execution for a non semi-correct execution when ˜k (cid:54)= k.
Details follow.

– Phases 1 to 3 The simulator runs the semi-correct simulation through Phase 3 (including

aborting at Phase 4 if the adversary fails to decommit).

– Phase 4 F does not rewind the adversary to “ﬁx” the value of R, but runs the protocol normally

for P1.

– Phase 5 F chooses ˜s1 ∈R Zq and runs Phase 5 with this value instead of s1, and choosing U1

as a random group element.

Before we prove that this simulation is indistinguishable for non-semi-correct executions let us
give an intuition. Note that the only diﬀerence with the previous simulation is that here F uses
a random share ˜s1 instead of the s1 that it computed in the other simulation. The reason is that
the value s1 computed in the previous simulation is only guaranteed to be the “correct” share
of s if the execution is semi-correct. If the adversary shares ki don’t match anymore the value R
then s1 is incorrect, and therefore F chooses a random value instead. In turn this causes U1 to be
uniformly distributed and the check in step (5D) to fail.

The main point of the proof is that if the execution is not semi-correct then the value U1 is
(given the view of the adversary) computationally indistinguishable from uniform even in the real
execution (under the DDH assumption).

Our proof reﬂects the above intuition. First we prove that a real non-semi-correct execution
is indistinguishable from one in which P1 outputs a random U1. And then we prove that this is
indistinguishable from the simulation above, where the good player uses a random ˜s1 instead of
the correct s1.

Lemma 4. Assuming that

– KG, Com, Ver, Equiv is a non-malleable equivocable commitment;
– the DDH Assumptions holds

then the simulation is computationally indistinguishable from a non-semi-correct real execution

Proof (of Lemma 4).

We construct three games between the simulator (running P1) and the adversary (running all
the other players). In G0 the simulator will just run the real protocol. In G1 the simulator will
follow the real protocol but will choose U1 as a random group element. In G2 the simulator will
run the above simulation.

Indistinguishability of G0 and G1. Let us assume that there is an adversary A0 that can distinguish

between G0 and G1. We show how this contradicts the DDH Assumption.

Let ˜A = ga, ˜B = gb, ˜C = gc be the DDH challenge where either c = ab or is chosen at random

in Zq.

18

Rosario Gennaro and Steven Goldfeder

The distinguisher F0 runs A0, simulating the key generation phase so that y = ˜B = gb. It does
that by rewinding the adversary at the end of Phase 2 of the key generation protocol and changing
the decommitment of P1 to y1 = b (cid:81)

.

i>1 y−1

i

F0 also extracts the values xi from the adversary via the proof of knowledge at the end of the
key generation. Note that at this point y = ˜B and F0 knows xi, but not b and therefore not x1. In
this simulation F0 does know the secret key matching E1 (since we are not making any reduction
to the security of the encryption scheme).

Then F0 runs the signature generation protocol for a not-semi-correct execution. Remember
i∈S wi with F0 knowing
i>1 wi (which is known to F0) and therefore

here we assume that we have a (t, t + 1) sharing of the secret key. So b = (cid:80)
wi for i > 1 but not knowing w1. Denote with wA = (cid:80)
w1 = b − wA.

F0 runs the protocol normally for Phases 1,2,3, and 4. It extracts the value γi for i > 1
(and he knows γ1 since he ran P1 normally). Therefore F0 knows k such that R = gk−1
since
k = ((cid:80)
i γi)δ−1. It also knows k1 since it was chosen normally according to the protocol. Before
moving to the simulation of Phase 5, let’s look at the MtAwc protocol for the computation of the
shares σi.

We note that since F0 knows the decryption key for E1 he also knows all the shares µ1j from

the invocation of the MtAwc protocol between P1 and Pj on input k1 and wj respectively7.

For the MtAwc protocol between P1 and Pj on input w1 and kj respectively, F0 knows the
value kj input by Pj since he extracts it from the range proof in the MtA protocol, which is also
a proof of knowledge of kj. However F0 does not know w1, so he therefore sends a random µj1 to
Pj and sets (implicitly) νj1 = kjw1 − µj1.

At the end we have that the share σ1 held by P1 is

σ1 = k1w1 +

(cid:88)

j>1

µ1j +

(cid:88)

j>1

νj1

by rearranging the terms and substituting the above we get
(cid:88)

(cid:88)

σ1 = ˜kw1 +

µ1j −

µj1

j>1

j>1

where ˜k = (cid:80)
R = gk−1

.

i ki. Remember that since this is not a semi-correct execution then ˜k (cid:54)= k where

Since w1 = b − wA we have

where

σ1 = ˜kb + µ1

µ1 =

(cid:88)

j>1

µ1j −

(cid:88)

j>1

µj1 − ˜kwA

with µ1, ˜k known to F0.

Note that this allows F0 to compute the correct value

gσ1 = ˜B

˜kgµ1

and therefore the correct value of Rs1 as

Rs1 = Rk1m+rσ1 = gk−1(k1m+rσ1) = gk−1(k1m+rµ1) ˜Bk−1 ˜kr

or

Rs1 = g ˆµ1 ˜B

ˆβ1

where ˆµ1 = k−1(k1m + rµ1) and ˆβ1 = k−1˜kr and ˆµ1 and ˆβ1 are known to F0.

We now continue the simulation

7 In this case we do not need to extract anything from Pj’s ZK proof, but we still need to check that the

value sent by Pj is correct.

Fast Multiparty Threshold ECDSA with Fast Trustless Setup

19

– 5A/5B F0 selects a random (cid:96)1 and sets V1 = Rs1g(cid:96)1 A1 = gρ1 = ˜A = ga. It simulates the
ZK proof (since it does not know ρ1 or s1). It extracts si, (cid:96)i, ρi from the adversary such that
Vi = Rsig(cid:96)i = gk−1sig(cid:96)i and Ai = gρi. Let sA = (cid:80)
Note that

i>1 k−1si

V = g−my−r (cid:89)

Vi = g−my−rV1

(cid:89)

Vi

and therefore substituting the above relations (and setting (cid:96) = (cid:80)

i (cid:96)i )

i

i>1

V = g(cid:96)Rs1gsA−my−r

Note that y = ˜B so y−r = ˜B−r. Therefore

V = g(cid:96)g ˆµ1 ˜B

ˆβ1 gsA−m ˜B−r

or

V = g(cid:96)gθ ˜Bκ
where θ = ˆµ1 + sA − m and κ = ˆβ1 − r known to F0.
Note that for executions that are not semi-correct κ (cid:54)= 0

– 5C/5D F0 computes T1 = A(cid:96)1 correctly (which he can do since he knows (cid:96)1) but for U1 outputs

U1 = ˜A(cid:96)+θ ˜C κ and it aborts.

Note what happens when ˜C = gab. By our choice of a = ρ1 and b = x we have that U1 = V ρ1 as
in Game G0. However when ˜C is a random group element, U1 is uniformly distributed as in G1.

Therefore under the DDH assumption G0 and G1 are indistinguishable.

Indistinguishability of G1 and G2. We note that in G2 the simulator broadcasts a random ˜V1 = R˜s1g(cid:96)1
which is indistinguishable from the correct V1 = Rs1g(cid:96)1 because of the “mask” g(cid:96)1 which (under
the DDH) is computationally indistinguishable from a random value, given that the adversary only
has A1.

More in detail, let ˜A = ga−δ, ˜B = gb and ˜C = gab be the DDH challenge where δ = 0 or

random in Zq.

The simulator here proceeds as in G0 (i.e. the regular protocol) until Phase 5.

– 5A/5B F0 broadcasts V1 = Rs1 ˜A and A1 = ˜B. It simulates the ZK proof (since it does not
know (cid:96)1 or ρ1). It extracts si, (cid:96)i, ρi from the adversary such that Vi = Rsig(cid:96)i = gk−1sig(cid:96)i and
Ai = gρi.

– 5C/5D F0 computes U1 as a random element and T1 = ˜C ˜A

j>1

ρj and it aborts.

(cid:80)

Note what happens when ˜A = ga. By our choice, a = (cid:96)1 and b = ρ1, and we have that
V1 = Rs1 g(cid:96)1 and T1 = A(cid:96)1 as in Game G1. However when ˜A = gag−δ with a random δ, then this
is equivalent to have V1 = R˜s1g(cid:96)1 and T1 = A(cid:96)1 with a randomly distributed ˜s1 as in Game G2.

Therefore under the DDH assumption G1 and G2 are indistinguishable.

4.9 Finishing up the proof

Before we conclude the proof we note that our protocol detects the presence of a malicious adversary
by noticing that the signature does not verify. As pointed out by Lindell in [28] this strategy is
not immediately simulatable against a malicious adversary for the following reason. Consider what
happens in Phase 5: In the semi-correct simulation F rewinds the adversary to “hit” the correct
s. But if the adversary had decided to be malicious and terminate the protocol with an invalid
signature, then the protocol would not be simulatable. If F hits an invalid signature “on purpose”
(e.g. by not rewinding), then the simulation is distinguishable by a semi-honest adversary who
does hit the correct signature.

20

Rosario Gennaro and Steven Goldfeder

Luckily for a “game-based” deﬁnition of security, this is not an issue as discussed in [28]. Let
Q < λc be the maximum number of signature queries that the adversary makes. In the real protocol,
the adversary will output a forgery after (cid:96) < Q queries, either because it stops submitting queries,
or because the protocol aborts. Therefore in our simulation, following Lindell [28], we choose a
random index ι ∈ [0...Q]:

– if ι = 0 we assume that all executions are semi-correct. In this case we can always simulates

as in the previous section

– otherwise we assume that the ﬁrst ι − 1 executions are semi-correct, but at the ιth execution

the value V is not equal to g(cid:96).

With probability 1/(Q + 1) ≥ λ−c this is a correct guess.

We can now complete the proof.

Proof (of Theorem 1).

Unforgeability. The forger F described above produces an indistinguishable view for the ad-
versary A, and therefore, A will produce a forgery with the same probability as in real life. The
success probability of F is at least (cid:15)3
8Q where Q is the maximum number of queries. That’s because
F has to succeed in

– choosing a good random tape for A (this happens with probability larger than (cid:15)
2 )
– hitting a good public key y (this also happens with probability larger than (cid:15)
2 )
– guessing the correct index query (cid:96) (this happens with probability larger than 1/Q)

Under those conditions, the adversary A will output a forgery with probability at least (cid:15)
2 .

Under the security of the DSA signature scheme, the probability of success of F must be
negligible, which implies that (cid:15) must also be negligible, contradicting the assumption that A has
a non-negligible probability of forging.
Correctness. If all players are honest, the protocol fails only if one of the MtA protocols fails.
Since we have a total of 4n2 such sub-protocols executed during a run of our signature protocol,
we have that our protocol fails with probability at most 4n2

q which is negligible.

5 Removing the ZK proofs from the MtA protocol

Note about the previous version: The protocol described in this section is not secure as shown
in [37, 32]. We are leaving the section in the paper as historical record.

As we mentioned in the Introduction, the ZK proofs in the MtA protocol are the most expensive
step of our protocol due not only to the fact that these are ZK proofs over the Paillier cryptosystem,
but also that every player has to run n of them (since they are speciﬁc to each execution of the
MtA protocol).

We consider what happens if the range proofs are eliminated. As we discussed in Section 3, the
MtA protocol needs to be secure in the presence of an oracle that tells the parties if a reduction
mod N happens during the execution. Note that in reality the oracle represents the failure of the
veriﬁcation of the signature generated by the protocol, and if that happens the system is reset.
So the oracle is a very weak oracle, which stops working the moment it tells you that a reduction
mod N happened.

We conjecture that our protocol remains secure even if the ZK proofs are eliminated for Alice
and simpliﬁed for Bob in the MtA and MtAwc protocol. More precisely both the MtA and MtAwc
protocol work as follows:

– Neither party proves that their values a, b are “small”

Fast Multiparty Threshold ECDSA with Fast Trustless Setup

21

– Bob broadcasts B = gb, B(cid:48) = gβ(cid:48)

together with a ZK proof of knowledge for b, β(cid:48) mod q using

Schnorr’s prooof [35]. Alice also checks that gα = BaB(cid:48).
We point out that B = gb is public in our threshold DSA protocol. Indeed in one case b = wi,
the share of the secret key x held by player Pi and B = gb is public at the end of the key
generation phase together with a ZK proof of knowledge. In the other case b = γi, and B = gb
will be public at the end of following round which is when Alice performs the above check.

For sake of completeness here is a description of the sMtA (simpliﬁed MtA) protocol which will

replace the MtA and MtAwc protocols in our full protocol.

1. Alice initiates the protocol by

– sending cA = EA(a) to Bob

2. Bob computes the ciphertext cB = b ×E cA +E EA(β(cid:48)) = EA(ab + β(cid:48)) where β(cid:48) is chosen
uniformly at random in ZN . Bob sets his share to β = −β(cid:48) mod q. He responds to Alice by
– sending cB and B(cid:48) = gβ(cid:48)
– proving in ZK that he knows b, β(cid:48) such that B = gb and B(cid:48) = gβ(cid:48)

3. Alice decrypts cB to obtain α(cid:48). She sets α = α(cid:48) mod q and accepts only if gα = BaB(cid:48).

To support our conjecture we propose some “ad-hoc” computational assumptions, which if true
would guarantee the security of the protocol. The assumptions are new and non-standard, yet they
look reasonable. We discuss them informally below – a full proof of security will appear in the ﬁnal
version.
Information Leaked to Alice by removing the Range Proof. If we remove the proofs
that the input a used by Alice is small, we leak information about the input used by Bob via the
knowledge of whether a reduction mod N happened or not (see discussion in Section 3).

The standard approach to model this leakage is to give the simulator access to an oracle that
tells if the reduction happened or not. Recall that the Bob simulator does not know the inout b
and instead chooses a random input b(cid:48) and a random mask β(cid:48). However the simulator also queries
a modular reduction oracle with values N, a, β(cid:48) and the oracle will tell the simulator if ab + β(cid:48) is less
than N . The output of the simulator includes this “ﬂag” bit.

The oracle will stop working once a moduar reduction takes place (since in the main protocol

there will be an abort).
Information Leaked to Bob by removing the ZK Consistency Proof. Here instead we
are able to simulate Bob’s view under a stronger assumption on the Paillier cryptosystem.

If Bob is corrupted, then the simulated Alice sends the encryption of a random value cA = E(ˆa).
But then it must decide whether to accept or reject at the end of step (2) (where the real Alice
checks that gα = BaB(cid:48)) without knowing ˆa. Here we assume that the simulator is provided with
an oracle ΩcA(cB, b, β) which answers 1 if and only if Dec(cB) = b · Dec(cA) + β mod q. Then the
simulator will extract b, β from the malicious Bob’s proof of knowledge, and query ΩcA (cB, b, β),
and it accepts if the oracle answers 1.

Security cannot be based on the semantic security of the Paillier encryption scheme anymore
since the presence of the oracle immediately implies that Paillier is not semantically secure anymore.
However consider the following experiment:

– Generate a Paillier key (E, D)
– Generate two random values a0, a1 ∈R Zq and publish A = ga0
– Choose a random bit b and publish c = E(ab)
– Let b(cid:48) be the output of the adversary who is allowed restricted access to the oracle Ωc – by

restricted we mean that the oracle will stop working after it outputs 0.

We say that the Paillier-ECR assumption holds if for every PPT adversary, the probability that
b = b(cid:48) is negligibly close to 1/2. Under the Paillier-ECR assumption we can prove that no adversary
given ga0 can distinguish if the sMtA protocol was run with a0 or a1 (with both values being “high

22

Rosario Gennaro and Steven Goldfeder

entropy”—in particular randomly chosen). This is suﬃcient to simulate sMtA with high entropy
inputs, which is what is needed to prove security of our threshold DSA protocol.

We note that our Paillier-ECR assumption is a weaker version of the Paillier-EC assumption in
[28]. In the latter the oracle access is not restricted, which makes the assumption much stronger.
In our case it is suﬃcient to consider the restricted oracle since the real protocol stops if Alice
detects cheating.

5.1 Modiﬁed simulation for the threshold protocol

We ﬁrst point out that in the presence of the modular reduction oracle and under the Paillier-ECR
assumption, the sMtA protocol is simulatable so the simulation of the threshold DSA protocol
remains basically the same, with one crucial diﬀerence. When in any of the sMtA simulation the
modular reduction oracle ﬂags that a reduction mod N took place, the main simulator immediately
switches to a non-semi-correct execution since in this case the shares of k held by the players do
not match the ones used in the signature computation (i.e. the signature veriﬁcation is going to
fail). Because in real life the protocol aborts the simulation will also stop at this point.

Remark: Note that the simulation of the main protocol uses the range proofs also to extract
values known by the adversary. Since we removed the range proofs, obviously our simulator cannot
do that. However we can augment the key generation protocol with a proof of knowledge of the
secret key of the Paillier encryption key. This will allow the simulator to extract the secret keys
held by the adversary and it is easy to verify that this will enable the simulator to decrypt the
values that in the main simulation were extracted from the range proofs.

5.2 Security of the simpliﬁed protocol

The two new assumptions that we introduce are very diﬀerent in nature. The Paillier-ECR as-
sumption just makes a stronger requirement on the Paillier encryption scheme. It is orthogonal to
the security of the DSA signature scheme.

On the other hand, assuming the presence of the modular reduction oracle implies stronger
security assumptions on the unforgeability of DSA. Indeed note that when the honest player plays
the respondent (Bob) role in the sMtA protocols, his inputs are his share of ρ (the mask for
the inversion of k) and his share of x (the secret key). That means that the protocol is leaking
information about these values, and that we need to assume that DSA remains unforgeable even
when this information is leaked to the adversary.

To make things more complicated, the adversary controls n − 1 players, each with its own
Paillier modulus Ni, and therefore gets information about ρ and x from each sMtA interaction the
adversary has with the honest player (each over a diﬀerent modulus Ni).

On the positive side, the shares of ρ and x are “high entropy” secrets and a reduction mod N
can only happen once in any of the invocations of the sMtA protocol, since if that happens the
protocol ends. It is therefore plausible to assume that we do not leak enough information to allow
the adversary to forge.

This can be formalized via the following stronger assumption on the unforgeability of DSA. We

deﬁne a game between a Challenger and an Attacker:

– The Challenger receives a random DSA public key y = gx and gives the attacker a random

number ˆx ∈R Zq. Let x1 = x − ˆx mod q.

– The Attacker chooses n − 1 RSA moduli Ni > q3 for i = 2, . . . , n.
– The Attacker submits a message m and 2(n − 1) + 1 numbers λi1, λi2 ∈ ZN and ˆρ ∈ Zq for

i = 2, . . . , n.

– The Challenger chooses ρ1 ∈R Zq and βi1, βi2 ∈R ZN for i = 2, . . . , n..

Fast Multiparty Threshold ECDSA with Fast Trustless Setup

23

– The Challenger has access to an oracle that if all the values λi1x1 + β1 and λi2ρ1 + β2 are less
than N , will return (r, s) a valid DSA signature on m and also α = ρk mod q where k ∈R Zq
and r = gk−1

and ρ = ˆρ + ρ(cid:48). In this case these values are returned to the Challenger.

– Otherwise the oracle returns nothing and the game ends.

The Attacker wins if he forges a signature on a message for which the Challenger did not output
a signature. We say that the Modular DSA Security Assumption holds if the probability that an
eﬃcient adversary wins the above game is infeasible.

Theorem 2. Assuming

– The Modular DSA Security Assumption;
– The Paillier-ECR Assumption;
– that KG, Com, Ver, Equiv is a non-malleable equivocable commitment scheme;
– the DDH Assumption

then our threshold DSA scheme where the sMtA protocol replaces the MtA and MtAwc protocols,
is unforgeable.

To prove the theorem we show that an adversary who is able to forge a DSA signature in our
simpliﬁed protocol, can be turned into an attacker breaking the Modular DSA Security Assumption.
Let y = gx the DSA public key received by the Challenger. The Challenger runs a simulation
for the distributed Adversary which ends with y as the public key. This simulation is identical to
the one described in Section 4.5. Here too we assume that the adversary controls players 2, . . . , n
and that the simulator controls player 1. The Adversary now knows ˆx the sum of the shares of the
bad players but not x1 the share of the good player with x = x1 + ˆx mod q.

When the Adversary submits a message m, the Challenger runs a simulation similar to the one

described in Section 4.6.

Here the value λi1 is the value a submitted by player Pi (controlled by the adversary) as the
initiator in the ﬁrst instance of the sMtA protocol with P1 running on input x1 – βi1 is the mask
β(cid:48) used by P1 as the respondent in that same protocol.

Similarly the value λi2 is the value a submitted by player Pi (controlled by the adversary) as
the initiator in the second instance of the sMtA protocol with P1 running on input ρ1 – βi2 is the
mask β(cid:48) used by P1 as the respondent in that same protocol.

Now the oracle allowed to the Challenger is exactly the Modular Reduction Oracle needed to
simulate P1 in the sMtA protocol. Therefore the Challenger can complete the simulation, with the
only diﬀerence that if the oracle signals that a modular reduction happened in any of the protocols,
the simulation follows the non-semi-correct case.

This simulation is clearly indistinguishable from the real execution, therefore the Adversary

will forge, and therefore we have created a succesful attacker for the Modular DSA game.

6 Extensions

Here we present the following natural extensions to our result.

6.1 Other additively homomorphic schemes.

Our scheme works with any additively homomorphic scheme with no modiﬁcation. It requires an
assumption analogous to the Paillier-EC or an eﬃcient ZK Proof for the statement in the MtAwc
protocol.

We also note that it is important that security holds under “adversarially chosen” public keys
(i.e. we need to prove or assume that the adversary cannot generate a public key such that it gives
him and advantage in the MtA protocol).

24

Rosario Gennaro and Steven Goldfeder

6.2 Other multiplicative to share conversions.

Our threshold DSA scheme works with any MtA protocol, i.e. any protocol that allows two parties
to convert their multiplicative shares of a secret into additive shares.

In particular the classic approach based on oblivious transfer by Gilboa [22] can be used. The
original protocol in [22] is secure only against semi-honest adversaries, but it can be strengthened
against a malicious adversary (see the literature on SPDZ or the recent work on threshold DSA in
[12]).

6.3 Simulation-Based Security

Our proof uses the game-based deﬁnition of unforgeability. The main technical reason is that
the simulator cannot detect if the current execution is semi-correct or not, and therefore has to
guess. This prevents us from achieving the stronger notion of simulation-based security (where
each execution of the protocol can be fully simulated).

While in the real world it is unfeasible to decide if an execution is semi-correct or not, the
simulator can do that if it were able to “extract” the bad players’ inputs to the MtA protocols.
Indeed that would allow the simulator to check that the values δi, Γi sent by the bad players
in Phases 3 and 4 are consistent with the inputs entered in the MtA protocols. If they are, the
execution is semi-correct, if they are not then the execution is not semi-correct. Once the simulator
knows which execution it is, it can choose the correct simulation strategy.

We note that in our current simulation, the simulator can already extract the input ki (from the
range proof in the MtA protocol) and the input wi (the share of the secret key, which it extracted
during the key generation). But in our current simulation it is not able to extract γi since we do
not require the players to prove knowledge of it. This is the section we discussed. Even in the
current protocol, we can extract γi from the range proof and indeed we do this in our simulation.
So is our protocol simulatable as is? And if it is should we just modify the main proof to no longer
guess whether the execution is semi-correct but to use this technique

The best way to solve this is to require Pi, Pj to run MtAwc also when interacting on inputs
ki, γj, since MtAwc forces the respondent (which runs on input γi) to prove knowledge of its input.
In turn this will allow the simulator to extract γi for the bad players and detect what kind of
execution is being run.

We note that the maliciously secure OT-based MtA protocol from [12] also allows for input

extraction, and therefore if used in our protocol, it will yield a fully simulatable protocol.

6.4 Deterministic Key Generation

A very popular feature of Bitcoin wallets is deterministic key generation. Introduced in Bitcoin-
Improvement-Proposal 32 (BIP32), the idea of this scheme is to allow one to deterministicly gen-
erate many keys from a single ECDSA key. Our key sharing is compatible with BIP32 public
derivations, and we leave it as future work to prove security in this setting.

7 Implementation, Benchmarks, and Evaluation

We implemented both the key generation and signature generation of our protocol, and we conﬁrm
that they are highly eﬃcient and fast enough to be used in practice. We benchmarked the version of
our protocol from Section 5 that does not contain the range proofs, but relies on the Paillier-ECR
assumption. We compare the performance of our protocol to the runtimes of Gennaro et al. [17]
and Boneh et al. [4]. All benchmarks were single-threaded and run on an an Intel quad-core i7-6700
CPU @ 3.40GHz and 64GB of RAM. We ran the code [17] and [4] on our benchmark machine to
get an accurate comparison. It should be noted that we implemented our scheme in C while theirs

Fast Multiparty Threshold ECDSA with Fast Trustless Setup

25

is a Java implementation which calls native C libraries for the heaviest arithmetic computations.
All benchmarks were taken over the secp256k1 curve, which is is the curve used in Bitcoin and
more recently a NIST standard.

For the curve operations, we used libsecp256k1.8 We implemented the MtA protocol with Paillier

using the implementation from libhcs.9.

7.1 Benchmarking the data complexity

When compared to [17, 4], we reduce the amount of data transmitted. All ﬁgures in this section
were measured empirically from the respective implementations, and thus it is possible that they
may be further optimized in practice. For a threshold of t (i.e. when there are t + 1 participants
in the signing protocol), the total data d in bytes sent and received by a given player to/from all
other players during the signing protocol is given by: ’

In contrast, the data sent to/from a given player in [17] is given by:

dours(t) = 2, 328 + t × 5, 024 Bytes

dGennaro(t) = (t + 1) × 34, 578 Bytes

And the data transmitted per player in [4] is given by:

dBoneh(t) = (t + 1) × 38, 189 Bytes

Lastly, we mention that for the 2-of-n case, we have dours(t = 1) = 3, 976 B. In contrast, the
recent protocol of [12] requires far more than that with 86.7 KiB for 2-of-2 signing and 106.7 KiB
for 2-of-n signing. Lindell’s scheme [28] only requires 769 B to be communicated in the 2-of-2 case
(but does not support 2-of-n).

7.2 Benchmarking signature generation time

Following the methodology of [4, 17], we benchmark the raw computation time of a single player
without counting network costs. Since each player runs their computation in parallel, this represents
the running time of the entire protocol other than network latency. We ﬁnd that our protocol
signiﬁcantly outperforms both of [4, 17] when using this metric.

As in [4, 17], the protocol running time has a ﬁxed cost that is independent of the number of
players plus a linear marginal cost as the threshold increases. We stress that the signing time only
depends on the number of active participants (t + 1), but does not depend on n, the total number
of players. All times are given on a single core, and were averaged over 1000 iterations.

Our protocols running time is given by:

The running time of [17] is given by:

rours(t) = 29 + (t) × 24 milliseconds

The running time of [4] is given by:

rGennaro(t) = 142 + (t) × 52 milliseconds

rBoneh(t) = 397 + (t) × 91 milliseconds

We can see that our protocol signiﬁcantly outperforms both previous schemes. See Figure 1 for

a comparison of the concrete raw computation times for thresholds up to 20.

8 https://github.com/bitcoin-core/secp256k1
9 https://github.com/tiehuis/libhcs

26

Rosario Gennaro and Steven Goldfeder

Fig. 1. Comparison of the raw computation time as the threshold increases between this work
and previous schemes.

8 Conclusion

We have presented a threshold ECDSA protocol that is an improvement over the existing schemes
by every metric. Although [17] has been available for some time, there are still to our knowledge
no Bitcoin services or user wallets that oﬀer threshold-signature security. We believe that this is
due to the impracticality of their distributed key generation protocol. Having to rely on a trusted
dealer to distribute key shares exposes a single point of failure for the system and in doing so runs
contrary to the entire premise of using threshold signatures in the ﬁrst place.

We solve this problem by presenting and implementing a new scheme with a highly eﬃcient
distributed key generation protocol. Together with our reduction in running time and data trans-
ferred, we believe that ECDSA threshold signatures are ﬁnally mature enough for adoption.

9 Acknowledgements

We thank Harry Kalodner, Yehuda Lindell, Ariel Nof, Ben Riva, and Omer Shlomovits for useful
feedback and discussions and for pointing out errors in earlier versions.

Rosario Gennaro is supported by NSF Grant 1565403. Steven Goldfeder is supported by an NSF
Graduate Research Fellowship under grant number DGE 1148900 and NSF award CNS-1651938.

References

1. Bar-Ilan, J., Beaver, D.: Non-cryptographic fault-tolerant computing in constant number of rounds
of interaction. In: Proceedings of the eighth annual ACM Symposium on Principles of distributed
computing. pp. 201–209. ACM (1989)

2. Bari´c, N., Pﬁtzmann, B.: Collision-free accumulators and fail-stop signature schemes without trees. In:
International Conference on the Theory and Applications of Cryptographic Techniques. pp. 480–494.
Springer (1997)

3. Boneh, D.: Digital signature standard. In: Encyclopedia of cryptography and security, pp. 347–347.

Springer (2011)

4. Boneh, D., Gennaro, R., Goldfeder, S.: Using level-1 homomorphic encryption to improve threshold

dsa signatures for bitcoin wallet security. In: Latincrypt (2017)

Fast Multiparty Threshold ECDSA with Fast Trustless Setup

27

5. Boudot, F.: Eﬃcient proofs that a committed number lies in an interval. In: International Conference

on the Theory and Applications of Cryptographic Techniques. pp. 431–444. Springer (2000)

6. Canetti, R., Gennaro, R., Jarecki, S., Krawczyk, H., Rabin, T.: Adaptive security for threshold cryp-

tosystems. In: Annual International Cryptology Conference. pp. 98–116. Springer (1999)

7. Canetti, R., Goldwasser, S.: An eﬃcient Threshold public key cryptosystem secure against adaptive
chosen ciphertext attack. In: Advances in Cryptology - EUROCRYPT ’99, International Conference
on the Theory and Application of Cryptographic Techniques, Prague, Czech Republic, May 2-6, 1999,
Proceeding. pp. 90–106 (1999)

8. Damgard, I., Groth, J.: Non-interactive and reusable non-malleable commitment schemes. In: Proceed-
ings of the thirty-ﬁfth annual ACM symposium on Theory of computing. pp. 426–437. ACM (2003)
9. Damg˚ard, I., Keller, M., Larraia, E., Miles, C., Smart, N.P.: Implementing aes via an actively/covertly
secure dishonest-majority mpc protocol. In: International Conference on Security and Cryptography
for Networks. pp. 241–263. Springer (2012)

10. Di Crescenzo, G., Ishai, Y., Ostrovsky, R.: Non-interactive and non-malleable commitment. In: Pro-
ceedings of the thirtieth annual ACM symposium on Theory of computing. pp. 141–150. ACM (1998)
11. Di Crescenzo, G., Katz, J., Ostrovsky, R., Smith, A.: Eﬃcient and non-interactive non-malleable com-
mitment. In: International Conference on the Theory and Applications of Cryptographic Techniques.
pp. 40–59. Springer (2001)

12. Doerner, J., Kondi, Y., Lee, E., et al.: Secure two-party threshold ecdsa from ecdsa assumptions. In:

IEEE Symposium on Security and Privacy. p. 0. IEEE (2018)

13. Dolev, D., Dwork, C., Naor, M.: Non-malleable cryptography,”. In: Proceedings of the 23rd Annual

Symposium on the Theory of Computing, ACM (1991)

14. Fujisaki, E., Okamoto, T.: Statistical zero knowledge protocols to prove modular polynomial relations.

In: Annual International Cryptology Conference. pp. 16–30. Springer (1997)

15. Gennaro, R.: Multi-trapdoor commitments and their applications to proofs of knowledge secure under
concurrent man-in-the-middle attacks. In: Annual International Cryptology Conference. pp. 220–236.
Springer (2004)

16. Gennaro, R., Goldfeder, S.: Fast multiparty threshold ecdsa with fast trustless setup. In: Proceedings
of the 2018 ACM SIGSAC Conference on Computer and Communications Security. pp. 1179–1194.
ACM (2018)

17. Gennaro, R., Goldfeder, S., Narayanan, A.: Threshold-optimal dsa/ecdsa signatures and an application
to bitcoin wallet security. In: International Conference on Applied Cryptography and Network Security.
pp. 156–174. Springer (2016)

18. Gennaro, R., Jarecki, S., Krawczyk, H., Rabin, T.: Robust threshold dss signatures. In: International
Conference on the Theory and Applications of Cryptographic Techniques. pp. 354–371. Springer (1996)
19. Gennaro, R., Jarecki, S., Krawczyk, H., Rabin, T.: Robust threshold dss signatures. Information and

Computation 164(1), 54–84 (2001)

20. Gennaro, R., Micali, S.: Independent zero-knowledge sets. In: International Colloquium on Automata,

Languages, and Programming. pp. 34–45. Springer (2006)

21. Gennaro, R., Micciancio, D., Rabin, T.: An eﬃcient non-interactive statistical zero-knowledge proof
system for quasi-safe prime products. In: In Proc. of the 5th ACM Conference on Computer and
Communications Security (CCS-98. Citeseer (1998)

22. Gilboa, N.: Two party rsa key generation. In: Advances in Cryptology - CRYPTO ’99. pp. 116–129

(1999)

23. Goldwasser, S., Micali, S., Rivest, R.L.: A digital signature scheme secure against adaptive chosen-

message attacks. SIAM Journal on Computing 17(2), 281–308 (1988)

24. Hazay, C., Mikkelsen, G.L., Rabin, T., Toft, T.: Eﬃcient rsa key generation and threshold paillier in
the two-party setting. In: Cryptographers’ Track at the RSA Conference. pp. 313–331. Springer (2012)
25. Jarecki, S., Lysyanskaya, A.: Adaptively secure threshold cryptography: Introducing concurrency, re-
moving erasures. In: International Conference on the Theory and Applications of Cryptographic Tech-
niques. pp. 221–242. Springer (2000)

26. Keller, M., Pastro, V., Rotaru, D.: Overdrive: making spdz great again. In: Annual International
Conference on the Theory and Applications of Cryptographic Techniques. pp. 158–189. Springer (2018)

27. Kravitz, D.W.: Digital signature algorithm (Jul 27 1993), uS Patent 5,231,668
28. Lindell, Y.: Fast secure two-party ecdsa signing. In: Annual International Cryptology Conference. pp.

613–644. Springer (2017)

28

Rosario Gennaro and Steven Goldfeder

29. Lindell, Y., Nof, A.: Fast secure multiparty ecdsa with practical distributed key generation and appli-
cations to cryptocurrency custody. In: Proceedings of the 2018 ACM SIGSAC Conference on Computer
and Communications Security. pp. 1837–1854. ACM (2018)

30. MacKenzie, P., Reiter, M.K.: Two-party generation of dsa signatures. In: Annual International Cryp-

tology Conference. pp. 137–154. Springer (2001)

31. MacKenzie, P., Yang, K.: On simulation-sound trapdoor commitments. In: International Conference

on the Theory and Applications of Cryptographic Techniques. pp. 382–400. Springer (2004)

32. Makriyannis, N., Peled, U.: A note on the security of GG18 (2021), Fireblocks Blog
33. Paillier, P.: Public-key cryptosystems based on composite degree residuosity classes. In: International
Conference on the Theory and Applications of Cryptographic Techniques. pp. 223–238. Springer (1999)
34. Rivest, R.L., Shamir, A., Adleman, L.: A method for obtaining digital signatures and public-key

cryptosystems. Communications of the ACM 21(2), 120–126 (1978)

35. Schnorr, C.: Eﬃcient signature generation by smart cards. J. Cryptology 4(3), 161–174 (1991)
36. Shamir, A.: How to share a secret. Communications of the ACM 22(11), 612–613 (1979)
37. Tymokhanov, D., Shlomovits, O.: Alpha-rays: Key extraction attacks on threshold ecdsa implementa-

tions. Cryptology ePrint Archive, Report 2021/1621 (2021), https://ia.cr/2021/1621

A The ZK Proofs for the MtA protocol

In this section we describe the ZK proofs that are needed in the MtA protocol (see Section 3). The
proofs are based on similar ones from [30]: speciﬁcally we prove statements that are simpler than
the ones needed in [30].

In these proofs the Veriﬁer uses an auxiliary RSA modulus ˜N which is the product of two safe
primes ˜P = 2˜p + 1 and ˜Q = 2˜q + 1 with ˜p, ˜q primes. The Veriﬁer also uses two values h1, h2 ∈ Z ∗
˜N
according to the commitment scheme in [14]. Security is based on the assumption that the Prover
cannot solve the Strong RSA problem over ˜N .

Therefore our initialization protocol must be augmented with each player Pi generating an
additional RSA modulus ˜Ni, and values h1i, h2i, together with a proof that they are of the correct
form (see [14]).

Note: The respondent proofs have been modiﬁed with respect to the previous version of this paper
to address weaknesses pointed out in [37, 32].

A.1 Range Proof

This proof is run by Alice (the initiator) in both MtA and MtAwc protocols.

The input for this proof is a Paillier public key N, Γ and a value c ∈ ZN 2. The prover knows

m ∈ Zq and r ∈ Z ∗

N such that c = Γ mrN mod N 2, where q is the order of the DSA group.

At the end of the protocol the Veriﬁer is convinced that m ∈ [−q3, q3].

– The Prover selects α ∈R Zq3, β ∈R Z ∗

N , γ ∈R Zq3 ˜N and ρ ∈R Zq ˜N .

The Prover computes z = hm
The Prover sends z, u, w to the Veriﬁer.

1 hρ

2 mod ˜N , u = Γ αβN mod N 2, w = hα

1 hγ

2 mod ˜N .

– The Veriﬁer selects a challenge e ∈R Zq and sends it to the Prover.
– The Prover computes s = reβ mod N , s1 = em + α and s2 = eρ + γ and sends s, s1, s2 to the

Veriﬁer.

– The Veriﬁer checks that s1 ≤ q3, u = Γ s1sN c−e mod N 2 and hs1

1 hs2

2 z−e = w mod ˜N .

Completeness. By inspection. Note that there is a negligible probability of failure for the honest
prover (when α > q3 − q2 – which happens with negligible probability – it might happen that
s1 > q3).
Soundness. Let ˜N , ˜s be our Strong RSA challenge. We show how to solve it using a Prover who
succeeds on incorrect instances (i.e. where |m| > q3).

Fast Multiparty Threshold ECDSA with Fast Trustless Setup

29

Let h2 = ˜s and h1 = hχ

2 for a random χ ∈ Zq ˜N . It is not hard to see that the distribution of

these values is indistinguishable from the real one with suﬃciently high probability.

Run the Prover on a successful execution over a challenge e and then rewind him and ﬁnd a
successful execution with challenge ˆe. Therefore we have the same ﬁrst message z, u, w and two
set of answers s, s1, s2 for challenge e, and ˆs, ˆs1, ˆs2 for challenge ˆe both satisfying the veriﬁcation
equations. Let ∆E = e − ˆe, ∆s1 = s1 − ˆs1 and ∆s2 = s2 − ˆs2.

Let λ = GCD(∆s2 + χ∆s1, ∆E). Assume λ (cid:54)= ∆E: denote with λs = (∆s2 + χ∆s1)/λ and

λE = ∆E/λ > 1. Then we ﬁnd µ, ν such that µλs + νλE = 1.

Then the solution to the Strong RSA challenge is ˜x = zµ˜sν mod ˜N , λE. Indeed note that

w = hs1

1 hs2

2 z−e = hˆs1

1 hˆs2

2 z−ˆe mod ˜N

therefore

which implies

Concluding

z∆E = h∆s1

1 h∆s2

2 = ˜s∆s2+χ∆s1 mod ˜N

zλE = ˜sλS mod ˜N

˜s = ˜sµλs+νλE = [zµ˜sν]λE mod ˜N

We now need to prove that the case λ = ∆E cannot happen with high probability.
Consider ﬁrst the case λ = ∆E but ∆E does not divide ∆s1. Write χ = χ0 +χ1 ˜p˜q with χ1 chosen
uniformly at random from a set of size > q. Note that the value χ1 is information theoretically
secret from the adversary (who only has h1, h2). We have that

∆s2 + χ∆s1 = ∆s2 + χ0∆s1 + χ1∆s1 ˜p˜q

Then there is a prime power ab (with a ≥ 2) such that ab|∆E, ab−1|∆s1 but ab does not divide
∆s1. Note that this implies that ab−1|∆s2. Set c0 = (∆s2 + χ0∆s1)/ab−1 and c1 = ∆s1 ˜p˜q/ab−1.
We have that c0 + χ1c1 = 0 mod a and c1 (cid:54)= 0 mod a. The number of elements χ1 for which this
equivalence holds is at most q/a + 1 and thus the probability of this holding for a random choice
of χ1 is at most 1
q . Otherwise we are in the case above with λ (cid:54)= ∆E.
Now consider the case λ = ∆E and ∆E|∆s1. Note that this implies that ∆E|∆s2 as well. Deﬁne

q which is at most 1

a + 1

2 + 1

m1 = ∆s1/∆E, ρ1 = ∆s2/∆E, α1 = (eˆs1 − ˆes1)/∆E, γ1 = (eˆs2 − ˆes2)/∆E.

These ensure that z = hm1
Finally denote with m(cid:48)
1 = m1 mod N and α(cid:48)

2 mod ˜N , w = hα1

1 hρ1
1 = ∆s1∆−1

1 hγ1
E mod N and α(cid:48)
1 = α1 mod N , there must be r1, β(cid:48) ∈ Z ∗

2 mod ˜N , s1 = em1 + α1 and ˆs1 = ˆem1 + α1.
1 = (eˆs1 − ˆes1)∆−1
E mod N . Note that since

N such that

m(cid:48)

c = Γ m(cid:48)

1rN
1

and u = Γ α(cid:48)

1 (β(cid:48))N mod N 2

At this point we know the following facts

s1 < q3 s1 = em1 + α1 s1 = em(cid:48)

1 + α1 mod N

ˆs1 < q3 ˆs1 = ˆem1 + α1 ˆs1 = ˆem(cid:48)

1 + α1 mod N

Therefore we can prove that m1 ∈ [−q3, q3] since |m1| ≤ |∆s1| ≤ q3. But this implies that m(cid:48)
[−q3, q3] since m(cid:48)

1 = m1 mod N and N > q7.

1 ∈

Honest-Verifier Zero-Knowledge. The simulator proceeds as in [30]. Choose z, s, s1, s2, e
according to the appropriate distribution and set u = Γ s1sN c−e mod N and w = hs1
2 z−e mod
˜N .

1 hs2

30

Rosario Gennaro and Steven Goldfeder

A.2 Respondent ZK Proof for MtAwc

This proof is run by Bob (the responder) in the MtAwc protocol. For the MtA protocol a simpler
version of this proof if needed, which we present later.

The input for this proof is a Paillier public key N, Γ and two values c1, c2 ∈ ZN 2, together with

a value X in G the DSA group.

The Prover knows x ∈ Zq, y ∈ Zq5 and r ∈ Z ∗

N such that c2 = cx

1 Γ yrN mod N 2, and X = gx ∈

G, where q is the order of the DSA group.

At the end of the protocol the Veriﬁer is convinced of the above and that x ∈ [−q3, q3] and

y ∈ [−q7, q7].

– The Prover selects α ∈R Zq3 , ρ ∈R Zq ˜N , ρ(cid:48) ∈R Zq3 ˜N , σ ∈ Zq ˜N , β ∈R Z ∗

N , γ ∈R Zq7 and

τ ∈R Zq3 ˜N .
The Prover computes u = gα, z = hx
1 Γ γβN mod N 2, and w = hγ
cα
The Prover sends u, z.z(cid:48), t, v, w to the Veriﬁer.

1 hρ
2 mod ˜N .

1 hτ

2 mod ˜N , z(cid:48) = hα

1 hρ(cid:48)

2 mod ˜N , t = hy

1hσ

2 mod ˜N , v =

– The Veriﬁer selects a challenge e ∈R Zq and sends it to the Prover.
– The Prover computes s = reβ mod N , s1 = ex + α, s2 = eρ + ρ(cid:48), t1 = ey + γ and t2 = eσ + τ .

The Prover sends s, s1, s2, t1, t2 to the Veriﬁer.

– The Veriﬁer checks that s1 ≤ q3, t1 ≤ q7, g1 = X eu ∈ G, hs1

1 hs2

2 = zez(cid:48) mod ˜N , ht1

1 ht2

2 =

tew mod ˜N , and cs1

1 sN Γ t1 = ce

2v mod N 2.

Completeness. By inspection (as before there is a negligible chance of failure for the honest
prover when either α > q3 − q2 or γ > q7 − q6

Soundness. Let ˜N , ˜s be our Strong RSA challenge. We show how to solve it using a Prover who
succeeds on incorrect instances (i.e. where |x| > q3).

Let h2 = ˜s and h1 = hχ

2 for a random χ ∈ Zq ˜N . It is not hard to see that the distribution of

these values is indistinguishable from the real one with suﬃciently high probability.

Run the prover on a successful execution over a challenge e and then rewind him and ﬁnd a
successful execution with challenge ˆe. Therefore we have the same ﬁrst message u, z, z(cid:48), t, v, w and
two set of answers s, s1, s2, t1, t2 for challenge e, and ˆs, ˆs1, ˆs2, ˆt1, ˆt2 for challenge ˆe both satisﬁng
theveriﬁcation equations. Let ∆E = e − ˆe, ∆s1 = s1 − ˆs1, ∆s2 = s2 − ˆs2, ∆t1 = t1 − ˆt1 and
∆t2 = t2 − ˆt2.

Let λ = GCD(∆s2 + χ∆s1, ∆E). Assume λ (cid:54)= ∆E: denote with λs = (∆s2 + χ∆s1)/λ and

λE = ∆E/λ > 1. Then we ﬁnd µ, ν such that µλs + νλE = 1.

Then the solution to the Strong RSA challenge is ˜x = zµ˜sν mod ˜N , λE. Indeed note that

z(cid:48) = hs1

1 hs2

2 z−e = hˆs1

1 hˆs2

2 z−ˆe mod ˜N

therefore

which implies

Concluding

z∆E = h∆s1

1 h∆s2

2 = ˜s∆s2+χ∆s1 mod ˜N

zλE = ˜sλS mod ˜N

˜s = ˜sµλs+νλE = [zµ˜sν]λE mod ˜N

Let λ(cid:48) = GCD(∆t2 + χ∆t1, ∆E). In a similar way as above we can prove that if λ(cid:48) (cid:54)= ∆E then

we can solve our Strong RSA challenge.

Therefore we can limit ourselves to the case λ = λ(cid:48) = ∆E.

Fast Multiparty Threshold ECDSA with Fast Trustless Setup

31

Consider ﬁrst the case λ = λ(cid:48) = ∆E but ∆E does not divide ∆s1. Write χ = χ0 + χ1 ˜p˜q with
χ1 chosen uniformly at random from a set of size > q. Note that the value χ1 is information
theoretically secret from the adversary (who only has h1, h2). We have that

∆s2 + χ∆s1 = ∆s2 + χ0∆s1 + χ1∆s1 ˜p˜q

Then there is a prime power ab (with a ≥ 2) such that ab|∆E, ab−1|∆s1 but ab does not divide
∆s1. Note that this implies that ab−1|∆s2. Set c0 = (∆s2 + χ0∆s1)/ab−1 and c1 = ∆s1 ˜p˜q/ab−1.
We have that c0 + χ1c1 = 0 mod a and c1 (cid:54)= 0 mod a. The number of elements χ1 for which this
equivalence holds is at most q/a + 1 and thus the probability of this holding for a random choice
of χ1 is at most 1
q . Otherwise we are in the case above with λ (cid:54)= ∆E.
In a similar fashion we can remove the case in which λ = λ(cid:48) = ∆E but ∆E does not divide ∆t1.
Now consider the case λ = λ(cid:48) = ∆E with ∆E|∆s1 and ∆E|∆t1. Note that this implies that

q which is at most 1

a + 1

2 + 1

∆E|∆s2 and ∆E|∆t2as well.

Deﬁne x1 = ∆s1/∆E, ρ1 = ∆s2/∆E, α1 = (eˆs1 − ˆes1)/∆E, ρ(cid:48)

σ1 = ∆t2/∆E, γ1 = (eˆt1 − ˆet1)/∆E and τ1 = (eˆt2 − ˆet2)/∆E.

Deﬁne x(cid:48)

1 = x1 mod N and y(cid:48)

1 = y1 mod N . Note that by deﬁnition

1 = (eˆs2 − ˆes2)/∆E, y1 = ∆t1/∆E,

cx(cid:48)
1 Γ y(cid:48)

1

1 κN = c2 mod N 2

for some κ as needed. And gx1 = X ∈ G. So we have extracted the required x, y. As in the previous
proof we can establish that x1, x(cid:48)
Honest-Verifier Zero-Knowledge. The simulator proceeds as in [30] and in the previous ZK
proof.

1 ∈ [−q3, q3] and y1, y(cid:48)

1 ∈ [−q7, q7].

A.3 Respondent ZK Proof for MtA

This proof is run by Bob (the responder) in the MtA protocol. It is a simpler version of the previous
protocol where Bob only proves that x, y are small (without proving that x is the discrete log of
any public value).

The input for this proof is a Paillier public key N, Γ and two values c1, c2 ∈ ZN 2 .
The Prover knows x ∈ Zq, y ∈ Zq5 and r ∈ Z ∗

N such that c2 = cx

1 Γ yrN mod N 2 where q is the

order of the DSA group.

At the end of the protocol the Veriﬁer is convinced of the above and that x ∈ [−q3, q3] and

y ∈ [−q7, q7].

– The Prover selects α ∈R Zq3 , ρ ∈R Zq ˜N , ρ(cid:48) ∈R Zq3 ˜N , σ ∈ Zq ˜N , β ∈R Z ∗

N , γ ∈R Zq7 and

τ ∈R Zq3 ˜N .
The Prover computes z = hx
2 mod ˜N .
N 2, and w = hγ
The Prover sends z, z(cid:48), t, v, w to the Veriﬁer.

2 mod ˜N , z(cid:48) = hα

1 hρ

1 hτ

1 hρ(cid:48)

2 mod ˜N , t = hy

1hσ

2 mod ˜N , v = cα

1 Γ γβN mod

– The Veriﬁer selects a challenge e ∈R Zq and sends it to the Prover.
– The Prover computes s = reβ mod N , s1 = ex + α, s2 = eρ + ρ(cid:48), t1 = ey + γ and t2 = eσ + τ .

The Prover sends s, s1, s2, t1, t2 to the Veriﬁer.
– The Veriﬁer checks that s1 ≤ q3, t1 ≤ q7 hs1

cs1
1 sN Γ t1 = ce

2v mod N 2.

1 hs2

2 = zez(cid:48) mod ˜N , ht1

1 ht2

2 = tew mod ˜N , and

The proof is immediate from the previous one.

Note about the previous version: The respondent ZK proofs have been modiﬁed as follows.
First of all note that now y ∈ Zq5 as required by the MtA protocols. This leads to the following
changes in the ZK proof: γ was chosen in ZN while now it is chosen in Zq7 and the veriﬁer performs
the additional range check t1 ≤ q7 (no range check on t1 was performed prior). Additionally there
was a typo in the range of τ which was chosen in Zq ˜N while now it is chosen in Zq3 ˜N .

