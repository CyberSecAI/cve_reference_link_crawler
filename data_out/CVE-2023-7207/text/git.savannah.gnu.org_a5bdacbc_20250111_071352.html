

| [cgit logo](/cgit/) | [index](/cgit/) : [cpio.git](/cgit/cpio.git/ "cpio.git") | alpha-2\_50\_90 literate master |
| --- | --- | --- |
| GNU cpio |  |

| [summary](/cgit/cpio.git/)[refs](/cgit/cpio.git/refs/?id=376d663340a9dc91c91a5849e5713f07571c1628)[log](/cgit/cpio.git/log/)[tree](/cgit/cpio.git/tree/?id=376d663340a9dc91c91a5849e5713f07571c1628)[commit](/cgit/cpio.git/commit/?id=376d663340a9dc91c91a5849e5713f07571c1628)[diff](/cgit/cpio.git/diff/?id=376d663340a9dc91c91a5849e5713f07571c1628) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Sergey Poznyakoff <gray@gnu.org> | 2023-04-27 15:14:23 +0300 |
| --- | --- | --- |
| committer | Sergey Poznyakoff <gray@gnu.org> | 2023-04-28 09:39:54 +0300 |
| commit | [376d663340a9dc91c91a5849e5713f07571c1628](/cgit/cpio.git/commit/?id=376d663340a9dc91c91a5849e5713f07571c1628) ([patch](/cgit/cpio.git/patch/?id=376d663340a9dc91c91a5849e5713f07571c1628)) | |
| tree | [8b2159564f158d68482b28b6b538cae6fb0c0022](/cgit/cpio.git/tree/?id=376d663340a9dc91c91a5849e5713f07571c1628) | |
| parent | [beba8c0691add0bd2b069d7f1657462e829c1196](/cgit/cpio.git/commit/?id=beba8c0691add0bd2b069d7f1657462e829c1196) ([diff](/cgit/cpio.git/diff/?id=376d663340a9dc91c91a5849e5713f07571c1628&id2=beba8c0691add0bd2b069d7f1657462e829c1196)) | |
| download | [cpio-376d663340a9dc91c91a5849e5713f07571c1628.tar.gz](/cgit/cpio.git/snapshot/cpio-376d663340a9dc91c91a5849e5713f07571c1628.tar.gz) | |

Fix 45b0ee2b407913c533f7ded8d6f8cbeec16ff6ca.The commit in question brought in more problems than solutions. To
properly fix the issue, use symlink placeholders, modelled after
delayed symlinks in tar.
\* src/copyin.c (symlink\_placeholder)
(replace\_symlink\_placeholders): New functions.
(copyin\_link): Create symlink placeholder if --no-absolute-filenames
was given.
(process\_copy\_in): Replace placeholders after extraction.
\* tests/CVE-2015-1197.at: Update. Don't use /tmp.
[Diffstat](/cgit/cpio.git/diff/?id=376d663340a9dc91c91a5849e5713f07571c1628)

| -rw-r--r-- | [src/copyin.c](/cgit/cpio.git/diff/src/copyin.c?id=376d663340a9dc91c91a5849e5713f07571c1628) | 173 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [tests/CVE-2015-1197.at](/cgit/cpio.git/diff/tests/CVE-2015-1197.at?id=376d663340a9dc91c91a5849e5713f07571c1628) | 7 | |  |  |  | | --- | --- | --- | |

2 files changed, 153 insertions, 27 deletions

| diff --git a/src/copyin.c b/src/copyin.cindex 60cef9d..5ed2db6 100644--- a/[src/copyin.c](/cgit/cpio.git/tree/src/copyin.c?id=beba8c0691add0bd2b069d7f1657462e829c1196)+++ b/[src/copyin.c](/cgit/cpio.git/tree/src/copyin.c?id=376d663340a9dc91c91a5849e5713f07571c1628)@@ -30,6 +30,7 @@ #ifndef FNM\_PATHNAME # include <fnmatch.h> #endif+#include <hash.h>  #ifndef HAVE\_LCHOWN # define lchown(f,u,g) 0@@ -620,6 +621,136 @@ copyin\_device (struct cpio\_file\_stat\* file\_hdr) file\_hdr->c\_mtime); } +struct delayed\_link+ {+ /\* The device and inode number of the placeholder. \*/+ dev\_t dev;+ ino\_t ino;++ /\* The desired link metadata. \*/+ mode\_t mode;+ uid\_t uid;+ gid\_t gid;+ time\_t mtime;++ /\* Link source and target names. \*/+ char \*source;+ char target[1];+ };++static Hash\_table \*delayed\_link\_table;++static size\_t+dl\_hash (void const \*entry, size\_t table\_size)+{+ struct delayed\_link const \*dl = entry;+ uintmax\_t n = dl->dev;+ int nshift = (sizeof (n) - sizeof (dl->dev)) \* CHAR\_BIT;+ if (0 < nshift)+ n <<= nshift;+ n ^= dl->ino;+ return n % table\_size;+}++static bool+dl\_compare (void const \*a, void const \*b)+{+ struct delayed\_link const \*da = a, \*db = b;+ return (da->dev == db->dev) & (da->ino == db->ino);+}++static int+symlink\_placeholder (char \*oldpath, char \*newpath, struct cpio\_file\_stat \*file\_stat)+{+ int fd = open (newpath, O\_WRONLY | O\_CREAT | O\_EXCL, 0);+ struct stat st;+ struct delayed\_link \*p;+ size\_t newlen = strlen (newpath);+ + if (fd < 0)+ {+ open\_error (newpath);+ return -1;+ }+ + if (fstat (fd, &st) != 0)+ {+ stat\_error (newpath);+ close (fd);+ return -1;+ }++ close (fd);++ p = xmalloc (sizeof (\*p) + strlen (oldpath) + newlen + 1);+ p->dev = st.st\_dev;+ p->ino = st.st\_ino;++ p->mode = file\_stat->c\_mode;+ p->uid = file\_stat->c\_uid;+ p->gid = file\_stat->c\_gid;+ p->mtime = file\_stat->c\_mtime;++ strcpy (p->target, newpath);+ p->source = p->target + newlen + 1;+ strcpy (p->source, oldpath);++ if (!((delayed\_link\_table+ || (delayed\_link\_table = hash\_initialize (0, 0, dl\_hash,+ dl\_compare, free)))+ && hash\_insert (delayed\_link\_table, p)))+ xalloc\_die ();++ return 0;+}++static void+replace\_symlink\_placeholders (void)+{+ struct delayed\_link \*dl;++ if (!delayed\_link\_table)+ return;+ for (dl = hash\_get\_first (delayed\_link\_table);+ dl;+ dl = hash\_get\_next (delayed\_link\_table, dl))+ {+ struct stat st;+ + /\* Make sure the placeholder file is still there. If not,+ don't create a link, as the placeholder was probably+ removed by a later extraction. \*/+ if (lstat (dl->target, &st) == 0+ && st.st\_dev == dl->dev+ && st.st\_ino == dl->ino)+ {+ if (unlink (dl->target))+ unlink\_error (dl->target);+ else+ {+ int res = UMASKED\_SYMLINK (dl->source, dl->target, dl->mode);+ if (res < 0 && create\_dir\_flag)+ {+ create\_all\_directories (dl->target);+ res = UMASKED\_SYMLINK (dl->source, dl->target, dl->mode);+ }+ if (res < 0)+ symlink\_error (dl->source, dl->target);+ else if (!no\_chown\_flag)+ {+ uid\_t uid = set\_owner\_flag ? set\_owner : dl->uid;+ gid\_t gid = set\_group\_flag ? set\_group : dl->gid;+ if (lchown (dl->target, uid, gid) < 0 && errno != EPERM)+ chown\_error\_details (dl->target, uid, gid);+ }+ }+ }+ }+ + hash\_free (delayed\_link\_table);+ delayed\_link\_table = NULL;+}+ static void copyin\_link (struct cpio\_file\_stat \*file\_hdr, int in\_file\_des) {@@ -645,29 +776,26 @@ copyin\_link (struct cpio\_file\_stat \*file\_hdr, int in\_file\_des) link\_name = xstrdup (file\_hdr->c\_tar\_linkname); } - cpio\_safer\_name\_suffix (link\_name, true, !no\_abs\_paths\_flag, false);- - res = UMASKED\_SYMLINK (link\_name, file\_hdr->c\_name,- file\_hdr->c\_mode);- if (res < 0 && create\_dir\_flag)- {- create\_all\_directories (file\_hdr->c\_name);- res = UMASKED\_SYMLINK (link\_name, file\_hdr->c\_name, file\_hdr->c\_mode);- }- if (res < 0)- {- error (0, errno, \_("%s: Cannot symlink to %s"),- quotearg\_colon (link\_name), quote\_n (1, file\_hdr->c\_name));- free (link\_name);- return;- }- if (!no\_chown\_flag)+ if (no\_abs\_paths\_flag)+ symlink\_placeholder (link\_name, file\_hdr->c\_name, file\_hdr);+ else {- uid\_t uid = set\_owner\_flag ? set\_owner : file\_hdr->c\_uid;- gid\_t gid = set\_group\_flag ? set\_group : file\_hdr->c\_gid;- if ((lchown (file\_hdr->c\_name, uid, gid) < 0)- && errno != EPERM)- chown\_error\_details (file\_hdr->c\_name, uid, gid);+ res = UMASKED\_SYMLINK (link\_name, file\_hdr->c\_name,+ file\_hdr->c\_mode);+ if (res < 0 && create\_dir\_flag)+ {+ create\_all\_directories (file\_hdr->c\_name);+ res = UMASKED\_SYMLINK (link\_name, file\_hdr->c\_name, file\_hdr->c\_mode);+ }+ if (res < 0)+ symlink\_error (link\_name, file\_hdr->c\_name);+ else if (!no\_chown\_flag)+ {+ uid\_t uid = set\_owner\_flag ? set\_owner : file\_hdr->c\_uid;+ gid\_t gid = set\_group\_flag ? set\_group : file\_hdr->c\_gid;+ if (lchown (file\_hdr->c\_name, uid, gid) < 0 && errno != EPERM)+ chown\_error\_details (file\_hdr->c\_name, uid, gid);+ } } free (link\_name); }@@ -1425,6 +1553,7 @@ process\_copy\_in (void) if (dot\_flag) fputc ('\n', stderr); + replace\_symlink\_placeholders (); apply\_delayed\_set\_stat ();  cpio\_file\_stat\_free (&file\_hdr);diff --git a/tests/CVE-2015-1197.at b/tests/CVE-2015-1197.atindex 57ebe43..74591b1 100644--- a/[tests/CVE-2015-1197.at](/cgit/cpio.git/tree/tests/CVE-2015-1197.at?id=beba8c0691add0bd2b069d7f1657462e829c1196)+++ b/[tests/CVE-2015-1197.at](/cgit/cpio.git/tree/tests/CVE-2015-1197.at?id=376d663340a9dc91c91a5849e5713f07571c1628)@@ -24,18 +24,15 @@ AT\_DATA([filelist], [dir dir/file ])-ln -s /tmp dir-touch /tmp/file cpio -o < filelist > test.cpio-rm dir /tmp/file+rm -rf dir $tempdir cpio --no-absolute-filenames -iv < test.cpio ], [2], [], [1 block-cpio: Removing leading `/' from hard link targets dir-cpio: dir/file: Cannot open: No such file or directory+cpio: dir/file: Cannot open: Not a directory dir/file 1 block ]) |
| --- |

generated by [cgit v1.1](https://git.zx2c4.com/cgit/about/) at 2025-01-11 07:13:52 +0000

