

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=8e46a2d068c92a905d01cbb018b00d66991585ab)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=8e46a2d068c92a905d01cbb018b00d66991585ab)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=8e46a2d068c92a905d01cbb018b00d66991585ab)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=8e46a2d068c92a905d01cbb018b00d66991585ab)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Xiubo Li <xiubli@redhat.com> | 2023-12-14 16:01:03 +0800 |
| --- | --- | --- |
| committer | Ilya Dryomov <idryomov@gmail.com> | 2024-02-07 14:43:29 +0100 |
| commit | [8e46a2d068c92a905d01cbb018b00d66991585ab](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=8e46a2d068c92a905d01cbb018b00d66991585ab) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=8e46a2d068c92a905d01cbb018b00d66991585ab)) | |
| tree | [f867b81e8250c9340027f9d5dc265ed49d4eca7c](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=8e46a2d068c92a905d01cbb018b00d66991585ab) | |
| parent | [ee97302fbc0c98a25732d736fc73aaf4d62c4128](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ee97302fbc0c98a25732d736fc73aaf4d62c4128) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=8e46a2d068c92a905d01cbb018b00d66991585ab&id2=ee97302fbc0c98a25732d736fc73aaf4d62c4128)) | |
| download | [linux-8e46a2d068c92a905d01cbb018b00d66991585ab.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-8e46a2d068c92a905d01cbb018b00d66991585ab.tar.gz) | |

libceph: just wait for more data to be available on the socketA short read may occur while reading the message footer from the
socket. Later, when the socket is ready for another read, the
messenger invokes all read\_partial\_\*() handlers, including
read\_partial\_sparse\_msg\_data(). The expectation is that
read\_partial\_sparse\_msg\_data() would bail, allowing the messenger to
invoke read\_partial() for the footer and pick up where it left off.
However read\_partial\_sparse\_msg\_data() violates that and ends up
calling into the state machine in the OSD client. The sparse-read
state machine assumes that it's a new op and interprets some piece of
the footer as the sparse-read header and returns bogus extents/data
length, etc.
To determine whether read\_partial\_sparse\_msg\_data() should bail, let's
reuse cursor->total\_resid. Because once it reaches to zero that means
all the extents and data have been successfully received in last read,
else it could break out when partially reading any of the extents and
data. And then osd\_sparse\_read() could continue where it left off.
[ idryomov: changelog ]
Link: <https://tracker.ceph.com/issues/63586>
Fixes: d396f89db39a ("libceph: add sparse read support to msgr1")
Signed-off-by: Xiubo Li <xiubli@redhat.com>
Reviewed-by: Jeff Layton <jlayton@kernel.org>
Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=8e46a2d068c92a905d01cbb018b00d66991585ab)

| -rw-r--r-- | [include/linux/ceph/messenger.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/ceph/messenger.h?id=8e46a2d068c92a905d01cbb018b00d66991585ab) | 2 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/ceph/messenger\_v1.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ceph/messenger_v1.c?id=8e46a2d068c92a905d01cbb018b00d66991585ab) | 25 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/ceph/messenger\_v2.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ceph/messenger_v2.c?id=8e46a2d068c92a905d01cbb018b00d66991585ab) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/ceph/osd\_client.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ceph/osd_client.c?id=8e46a2d068c92a905d01cbb018b00d66991585ab) | 9 | |  |  |  | | --- | --- | --- | |

4 files changed, 19 insertions, 21 deletions

| diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.hindex 2eaaabbe98cb64..1717cc57cdacd3 100644--- a/[include/linux/ceph/messenger.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/ceph/messenger.h?id=ee97302fbc0c98a25732d736fc73aaf4d62c4128)+++ b/[include/linux/ceph/messenger.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/ceph/messenger.h?id=8e46a2d068c92a905d01cbb018b00d66991585ab)@@ -283,7 +283,7 @@ struct ceph\_msg { struct kref kref; bool more\_to\_follow; bool needs\_out\_seq;- bool sparse\_read;+ u64 sparse\_read\_total; int front\_alloc\_len;  struct ceph\_msgpool \*pool;diff --git a/net/ceph/messenger\_v1.c b/net/ceph/messenger\_v1.cindex 4cb60bacf5f5b4..0cb61c76b9b87d 100644--- a/[net/ceph/messenger\_v1.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ceph/messenger_v1.c?id=ee97302fbc0c98a25732d736fc73aaf4d62c4128)+++ b/[net/ceph/messenger\_v1.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ceph/messenger_v1.c?id=8e46a2d068c92a905d01cbb018b00d66991585ab)@@ -160,8 +160,9 @@ static size\_t sizeof\_footer(struct ceph\_connection \*con) static void prepare\_message\_data(struct ceph\_msg \*msg, u32 data\_len) { /\* Initialize data cursor if it's not a sparse read \*/- if (!msg->sparse\_read)- ceph\_msg\_data\_cursor\_init(&msg->cursor, msg, data\_len);+ u64 len = msg->sparse\_read\_total ? : data\_len;++ ceph\_msg\_data\_cursor\_init(&msg->cursor, msg, len); }  /\*@@ -1036,7 +1037,7 @@ static int read\_partial\_sparse\_msg\_data(struct ceph\_connection \*con) if (do\_datacrc) crc = con->in\_data\_crc; - do {+ while (cursor->total\_resid) { if (con->v1.in\_sr\_kvec.iov\_base) ret = read\_partial\_message\_chunk(con, &con->v1.in\_sr\_kvec,@@ -1044,23 +1045,23 @@ static int read\_partial\_sparse\_msg\_data(struct ceph\_connection \*con) &crc); else if (cursor->sr\_resid > 0) ret = read\_partial\_sparse\_msg\_extent(con, &crc);-- if (ret <= 0) {- if (do\_datacrc)- con->in\_data\_crc = crc;- return ret;- }+ if (ret <= 0)+ break;  memset(&con->v1.in\_sr\_kvec, 0, sizeof(con->v1.in\_sr\_kvec)); ret = con->ops->sparse\_read(con, cursor, (char \*\*)&con->v1.in\_sr\_kvec.iov\_base);+ if (ret <= 0) {+ ret = ret ? ret : 1; /\* must return > 0 to indicate success \*/+ break;+ } con->v1.in\_sr\_len = ret;- } while (ret > 0);+ }  if (do\_datacrc) con->in\_data\_crc = crc; - return ret < 0 ? ret : 1; /\* must return > 0 to indicate success \*/+ return ret; }  static int read\_partial\_msg\_data(struct ceph\_connection \*con)@@ -1253,7 +1254,7 @@ static int read\_partial\_message(struct ceph\_connection \*con) if (!m->num\_data\_items) return -EIO; - if (m->sparse\_read)+ if (m->sparse\_read\_total) ret = read\_partial\_sparse\_msg\_data(con); else if (ceph\_test\_opt(from\_msgr(con->msgr), RXBOUNCE)) ret = read\_partial\_msg\_data\_bounce(con);diff --git a/net/ceph/messenger\_v2.c b/net/ceph/messenger\_v2.cindex f8ec60e1aba3a1..a0ca5414b333df 100644--- a/[net/ceph/messenger\_v2.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ceph/messenger_v2.c?id=ee97302fbc0c98a25732d736fc73aaf4d62c4128)+++ b/[net/ceph/messenger\_v2.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ceph/messenger_v2.c?id=8e46a2d068c92a905d01cbb018b00d66991585ab)@@ -1128,7 +1128,7 @@ static int decrypt\_tail(struct ceph\_connection \*con) struct sg\_table enc\_sgt = {}; struct sg\_table sgt = {}; struct page \*\*pages = NULL;- bool sparse = con->in\_msg->sparse\_read;+ bool sparse = !!con->in\_msg->sparse\_read\_total; int dpos = 0; int tail\_len; int ret;@@ -2060,7 +2060,7 @@ static int prepare\_read\_tail\_plain(struct ceph\_connection \*con) }  if (data\_len(msg)) {- if (msg->sparse\_read)+ if (msg->sparse\_read\_total) con->v2.in\_state = IN\_S\_PREPARE\_SPARSE\_DATA; else con->v2.in\_state = IN\_S\_PREPARE\_READ\_DATA;diff --git a/net/ceph/osd\_client.c b/net/ceph/osd\_client.cindex 2cea35e4ff8ef1..9d078b37fe0b9b 100644--- a/[net/ceph/osd\_client.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ceph/osd_client.c?id=ee97302fbc0c98a25732d736fc73aaf4d62c4128)+++ b/[net/ceph/osd\_client.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ceph/osd_client.c?id=8e46a2d068c92a905d01cbb018b00d66991585ab)@@ -5510,7 +5510,7 @@ static struct ceph\_msg \*get\_reply(struct ceph\_connection \*con, }  m = ceph\_msg\_get(req->r\_reply);- m->sparse\_read = (bool)srlen;+ m->sparse\_read\_total = srlen;  dout("get\_reply tid %lld %p\n", tid, m); @@ -5777,11 +5777,8 @@ static int prep\_next\_sparse\_read(struct ceph\_connection \*con, }  if (o->o\_sparse\_op\_idx < 0) {- u64 srlen = sparse\_data\_requested(req);-- dout("%s: [%d] starting new sparse read req. srlen=0x%llx\n",- \_\_func\_\_, o->o\_osd, srlen);- ceph\_msg\_data\_cursor\_init(cursor, con->in\_msg, srlen);+ dout("%s: [%d] starting new sparse read req\n",+ \_\_func\_\_, o->o\_osd); } else { u64 end; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 18:15:49 +0000

