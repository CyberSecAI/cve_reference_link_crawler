=== Content from git.kernel.org_fe5ee968_20250111_070650.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=b4bd556467477420ee3a91fbcba73c579669edc6)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=b4bd556467477420ee3a91fbcba73c579669edc6)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b4bd556467477420ee3a91fbcba73c579669edc6)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b4bd556467477420ee3a91fbcba73c579669edc6)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Sean Christopherson <seanjc@google.com> | 2024-05-21 19:14:35 -0700 |
| --- | --- | --- |
| committer | Paolo Bonzini <pbonzini@redhat.com> | 2024-05-23 12:34:44 -0400 |
| commit | [b4bd556467477420ee3a91fbcba73c579669edc6](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b4bd556467477420ee3a91fbcba73c579669edc6) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=b4bd556467477420ee3a91fbcba73c579669edc6)) | |
| tree | [d3d0d71aff03fe03595d5d1904dad8c6ecf5a092](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=b4bd556467477420ee3a91fbcba73c579669edc6) | |
| parent | [76d5363c20eeeb937b56c0ac6c61e697bd1bf154](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=76d5363c20eeeb937b56c0ac6c61e697bd1bf154) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b4bd556467477420ee3a91fbcba73c579669edc6&id2=76d5363c20eeeb937b56c0ac6c61e697bd1bf154)) | |
| download | [linux-b4bd556467477420ee3a91fbcba73c579669edc6.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-b4bd556467477420ee3a91fbcba73c579669edc6.tar.gz) | |

KVM: SVM: WARN on vNMI + NMI window iff NMIs are outright maskedWhen requesting an NMI window, WARN on vNMI support being enabled if and
only if NMIs are actually masked, i.e. if the vCPU is already handling an
NMI. KVM's ABI for NMIs that arrive simultanesouly (from KVM's point of
view) is to inject one NMI and pend the other. When using vNMI, KVM pends
the second NMI simply by setting V\_NMI\_PENDING, and lets the CPU do the
rest (hardware automatically sets V\_NMI\_BLOCKING when an NMI is injected).
However, if KVM can't immediately inject an NMI, e.g. because the vCPU is
in an STI shadow or is running with GIF=0, then KVM will request an NMI
window and trigger the WARN (but still function correctly).
Whether or not the GIF=0 case makes sense is debatable, as the intent of
KVM's behavior is to provide functionality that is as close to real
hardware as possible. E.g. if two NMIs are sent in quick succession, the
probability of both NMIs arriving in an STI shadow is infinitesimally low
on real hardware, but significantly larger in a virtual environment, e.g.
if the vCPU is preempted in the STI shadow. For GIF=0, the argument isn't
as clear cut, because the window where two NMIs can collide is much larger
in bare metal (though still small).
That said, KVM should not have divergent behavior for the GIF=0 case based
on whether or not vNMI support is enabled. And KVM has allowed
simultaneous NMIs with GIF=0 for over a decade, since commit 7460fb4a3400
("KVM: Fix simultaneous NMIs"). I.e. KVM's GIF=0 handling shouldn't be
modified without a \*really\* good reason to do so, and if KVM's behavior
were to be modified, it should be done irrespective of vNMI support.
Fixes: fa4c027a7956 ("KVM: x86: Add support for SVM's Virtual NMI")
Cc: stable@vger.kernel.org
Cc: Santosh Shukla <Santosh.Shukla@amd.com>
Cc: Maxim Levitsky <mlevitsk@redhat.com>
Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-ID: <20240522021435.1684366-1-seanjc@google.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b4bd556467477420ee3a91fbcba73c579669edc6)

| -rw-r--r-- | [arch/x86/kvm/svm/svm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/x86/kvm/svm/svm.c?id=b4bd556467477420ee3a91fbcba73c579669edc6) | 27 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 19 insertions, 8 deletions

| diff --git a/arch/x86/kvm/svm/svm.c b/arch/x86/kvm/svm/svm.cindex c8dc25886c1658..1d3c8be39479b3 100644--- a/[arch/x86/kvm/svm/svm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/svm/svm.c?id=76d5363c20eeeb937b56c0ac6c61e697bd1bf154)+++ b/[arch/x86/kvm/svm/svm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/svm/svm.c?id=b4bd556467477420ee3a91fbcba73c579669edc6)@@ -3846,16 +3846,27 @@ static void svm\_enable\_nmi\_window(struct kvm\_vcpu \*vcpu) struct vcpu\_svm \*svm = to\_svm(vcpu);  /\*- \* KVM should never request an NMI window when vNMI is enabled, as KVM- \* allows at most one to-be-injected NMI and one pending NMI, i.e. if- \* two NMIs arrive simultaneously, KVM will inject one and set- \* V\_NMI\_PENDING for the other. WARN, but continue with the standard- \* single-step approach to try and salvage the pending NMI.+ \* If NMIs are outright masked, i.e. the vCPU is already handling an+ \* NMI, and KVM has not yet intercepted an IRET, then there is nothing+ \* more to do at this time as KVM has already enabled IRET intercepts.+ \* If KVM has already intercepted IRET, then single-step over the IRET,+ \* as NMIs aren't architecturally unmasked until the IRET completes.+ \*+ \* If vNMI is enabled, KVM should never request an NMI window if NMIs+ \* are masked, as KVM allows at most one to-be-injected NMI and one+ \* pending NMI. If two NMIs arrive simultaneously, KVM will inject one+ \* NMI and set V\_NMI\_PENDING for the other, but if and only if NMIs are+ \* unmasked. KVM \_will\_ request an NMI window in some situations, e.g.+ \* if the vCPU is in an STI shadow or if GIF=0, KVM can't immediately+ \* inject the NMI. In those situations, KVM needs to single-step over+ \* the STI shadow or intercept STGI. \*/- WARN\_ON\_ONCE(is\_vnmi\_enabled(svm));+ if (svm\_get\_nmi\_mask(vcpu)) {+ WARN\_ON\_ONCE(is\_vnmi\_enabled(svm)); - if (svm\_get\_nmi\_mask(vcpu) && !svm->awaiting\_iret\_completion)- return; /\* IRET will cause a vm exit \*/+ if (!svm->awaiting\_iret\_completion)+ return; /\* IRET will cause a vm exit \*/+ }  /\* \* SEV-ES guests are responsible for signaling when a vCPU is ready to |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 07:05:27 +0000



=== Content from git.kernel.org_fbb9df71_20250111_070651.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=f79edaf7370986d73d204b36c50cc563a4c0f356)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f79edaf7370986d73d204b36c50cc563a4c0f356)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f79edaf7370986d73d204b36c50cc563a4c0f356)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f79edaf7370986d73d204b36c50cc563a4c0f356)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Sean Christopherson <seanjc@google.com> | 2024-05-21 19:14:35 -0700 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-06-16 13:47:38 +0200 |
| commit | [f79edaf7370986d73d204b36c50cc563a4c0f356](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f79edaf7370986d73d204b36c50cc563a4c0f356) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=f79edaf7370986d73d204b36c50cc563a4c0f356)) | |
| tree | [94646a01aca321b8cdb0d30113ad32e8eaaf127c](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f79edaf7370986d73d204b36c50cc563a4c0f356) | |
| parent | [bb430ea4ba31dcc439d26e02bcbc4473cad4c6d9](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=bb430ea4ba31dcc439d26e02bcbc4473cad4c6d9) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f79edaf7370986d73d204b36c50cc563a4c0f356&id2=bb430ea4ba31dcc439d26e02bcbc4473cad4c6d9)) | |
| download | [linux-f79edaf7370986d73d204b36c50cc563a4c0f356.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-f79edaf7370986d73d204b36c50cc563a4c0f356.tar.gz) | |

KVM: SVM: WARN on vNMI + NMI window iff NMIs are outright maskedcommit b4bd556467477420ee3a91fbcba73c579669edc6 upstream.
When requesting an NMI window, WARN on vNMI support being enabled if and
only if NMIs are actually masked, i.e. if the vCPU is already handling an
NMI. KVM's ABI for NMIs that arrive simultanesouly (from KVM's point of
view) is to inject one NMI and pend the other. When using vNMI, KVM pends
the second NMI simply by setting V\_NMI\_PENDING, and lets the CPU do the
rest (hardware automatically sets V\_NMI\_BLOCKING when an NMI is injected).
However, if KVM can't immediately inject an NMI, e.g. because the vCPU is
in an STI shadow or is running with GIF=0, then KVM will request an NMI
window and trigger the WARN (but still function correctly).
Whether or not the GIF=0 case makes sense is debatable, as the intent of
KVM's behavior is to provide functionality that is as close to real
hardware as possible. E.g. if two NMIs are sent in quick succession, the
probability of both NMIs arriving in an STI shadow is infinitesimally low
on real hardware, but significantly larger in a virtual environment, e.g.
if the vCPU is preempted in the STI shadow. For GIF=0, the argument isn't
as clear cut, because the window where two NMIs can collide is much larger
in bare metal (though still small).
That said, KVM should not have divergent behavior for the GIF=0 case based
on whether or not vNMI support is enabled. And KVM has allowed
simultaneous NMIs with GIF=0 for over a decade, since commit 7460fb4a3400
("KVM: Fix simultaneous NMIs"). I.e. KVM's GIF=0 handling shouldn't be
modified without a \*really\* good reason to do so, and if KVM's behavior
were to be modified, it should be done irrespective of vNMI support.
Fixes: fa4c027a7956 ("KVM: x86: Add support for SVM's Virtual NMI")
Cc: stable@vger.kernel.org
Cc: Santosh Shukla <Santosh.Shukla@amd.com>
Cc: Maxim Levitsky <mlevitsk@redhat.com>
Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-ID: <20240522021435.1684366-1-seanjc@google.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f79edaf7370986d73d204b36c50cc563a4c0f356)

| -rw-r--r-- | [arch/x86/kvm/svm/svm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/x86/kvm/svm/svm.c?id=f79edaf7370986d73d204b36c50cc563a4c0f356) | 27 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 19 insertions, 8 deletions

| diff --git a/arch/x86/kvm/svm/svm.c b/arch/x86/kvm/svm/svm.cindex 77f1eeefcd34bf..1efbe8b33f6a17 100644--- a/[arch/x86/kvm/svm/svm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/svm/svm.c?id=bb430ea4ba31dcc439d26e02bcbc4473cad4c6d9)+++ b/[arch/x86/kvm/svm/svm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/svm/svm.c?id=f79edaf7370986d73d204b36c50cc563a4c0f356)@@ -3856,16 +3856,27 @@ static void svm\_enable\_nmi\_window(struct kvm\_vcpu \*vcpu) struct vcpu\_svm \*svm = to\_svm(vcpu);  /\*- \* KVM should never request an NMI window when vNMI is enabled, as KVM- \* allows at most one to-be-injected NMI and one pending NMI, i.e. if- \* two NMIs arrive simultaneously, KVM will inject one and set- \* V\_NMI\_PENDING for the other. WARN, but continue with the standard- \* single-step approach to try and salvage the pending NMI.+ \* If NMIs are outright masked, i.e. the vCPU is already handling an+ \* NMI, and KVM has not yet intercepted an IRET, then there is nothing+ \* more to do at this time as KVM has already enabled IRET intercepts.+ \* If KVM has already intercepted IRET, then single-step over the IRET,+ \* as NMIs aren't architecturally unmasked until the IRET completes.+ \*+ \* If vNMI is enabled, KVM should never request an NMI window if NMIs+ \* are masked, as KVM allows at most one to-be-injected NMI and one+ \* pending NMI. If two NMIs arrive simultaneously, KVM will inject one+ \* NMI and set V\_NMI\_PENDING for the other, but if and only if NMIs are+ \* unmasked. KVM \_will\_ request an NMI window in some situations, e.g.+ \* if the vCPU is in an STI shadow or if GIF=0, KVM can't immediately+ \* inject the NMI. In those situations, KVM needs to single-step over+ \* the STI shadow or intercept STGI. \*/- WARN\_ON\_ONCE(is\_vnmi\_enabled(svm));+ if (svm\_get\_nmi\_mask(vcpu)) {+ WARN\_ON\_ONCE(is\_vnmi\_enabled(svm)); - if (svm\_get\_nmi\_mask(vcpu) && !svm->awaiting\_iret\_completion)- return; /\* IRET will cause a vm exit \*/+ if (!svm->awaiting\_iret\_completion)+ return; /\* IRET will cause a vm exit \*/+ }  /\* \* SEV-ES guests are responsible for signaling when a vCPU is ready to |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 07:05:28 +0000



=== Content from git.kernel.org_dad86794_20250111_070649.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=1d87cf2eba46deaff6142366127f2323de9f84d1)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=1d87cf2eba46deaff6142366127f2323de9f84d1)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=1d87cf2eba46deaff6142366127f2323de9f84d1)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=1d87cf2eba46deaff6142366127f2323de9f84d1)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Sean Christopherson <seanjc@google.com> | 2024-05-21 19:14:35 -0700 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-06-16 13:51:02 +0200 |
| commit | [1d87cf2eba46deaff6142366127f2323de9f84d1](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=1d87cf2eba46deaff6142366127f2323de9f84d1) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=1d87cf2eba46deaff6142366127f2323de9f84d1)) | |
| tree | [3b02371d251349362b07e3261c2f7eaf734abca8](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=1d87cf2eba46deaff6142366127f2323de9f84d1) | |
| parent | [46579f06206d877b076b6835244fd36c97db82e1](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=46579f06206d877b076b6835244fd36c97db82e1) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=1d87cf2eba46deaff6142366127f2323de9f84d1&id2=46579f06206d877b076b6835244fd36c97db82e1)) | |
| download | [linux-1d87cf2eba46deaff6142366127f2323de9f84d1.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-1d87cf2eba46deaff6142366127f2323de9f84d1.tar.gz) | |

KVM: SVM: WARN on vNMI + NMI window iff NMIs are outright maskedcommit b4bd556467477420ee3a91fbcba73c579669edc6 upstream.
When requesting an NMI window, WARN on vNMI support being enabled if and
only if NMIs are actually masked, i.e. if the vCPU is already handling an
NMI. KVM's ABI for NMIs that arrive simultanesouly (from KVM's point of
view) is to inject one NMI and pend the other. When using vNMI, KVM pends
the second NMI simply by setting V\_NMI\_PENDING, and lets the CPU do the
rest (hardware automatically sets V\_NMI\_BLOCKING when an NMI is injected).
However, if KVM can't immediately inject an NMI, e.g. because the vCPU is
in an STI shadow or is running with GIF=0, then KVM will request an NMI
window and trigger the WARN (but still function correctly).
Whether or not the GIF=0 case makes sense is debatable, as the intent of
KVM's behavior is to provide functionality that is as close to real
hardware as possible. E.g. if two NMIs are sent in quick succession, the
probability of both NMIs arriving in an STI shadow is infinitesimally low
on real hardware, but significantly larger in a virtual environment, e.g.
if the vCPU is preempted in the STI shadow. For GIF=0, the argument isn't
as clear cut, because the window where two NMIs can collide is much larger
in bare metal (though still small).
That said, KVM should not have divergent behavior for the GIF=0 case based
on whether or not vNMI support is enabled. And KVM has allowed
simultaneous NMIs with GIF=0 for over a decade, since commit 7460fb4a3400
("KVM: Fix simultaneous NMIs"). I.e. KVM's GIF=0 handling shouldn't be
modified without a \*really\* good reason to do so, and if KVM's behavior
were to be modified, it should be done irrespective of vNMI support.
Fixes: fa4c027a7956 ("KVM: x86: Add support for SVM's Virtual NMI")
Cc: stable@vger.kernel.org
Cc: Santosh Shukla <Santosh.Shukla@amd.com>
Cc: Maxim Levitsky <mlevitsk@redhat.com>
Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-ID: <20240522021435.1684366-1-seanjc@google.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=1d87cf2eba46deaff6142366127f2323de9f84d1)

| -rw-r--r-- | [arch/x86/kvm/svm/svm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/x86/kvm/svm/svm.c?id=1d87cf2eba46deaff6142366127f2323de9f84d1) | 27 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 19 insertions, 8 deletions

| diff --git a/arch/x86/kvm/svm/svm.c b/arch/x86/kvm/svm/svm.cindex 9aaf83c8d57df7..308416b50b0361 100644--- a/[arch/x86/kvm/svm/svm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/svm/svm.c?id=46579f06206d877b076b6835244fd36c97db82e1)+++ b/[arch/x86/kvm/svm/svm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/svm/svm.c?id=1d87cf2eba46deaff6142366127f2323de9f84d1)@@ -3843,16 +3843,27 @@ static void svm\_enable\_nmi\_window(struct kvm\_vcpu \*vcpu) struct vcpu\_svm \*svm = to\_svm(vcpu);  /\*- \* KVM should never request an NMI window when vNMI is enabled, as KVM- \* allows at most one to-be-injected NMI and one pending NMI, i.e. if- \* two NMIs arrive simultaneously, KVM will inject one and set- \* V\_NMI\_PENDING for the other. WARN, but continue with the standard- \* single-step approach to try and salvage the pending NMI.+ \* If NMIs are outright masked, i.e. the vCPU is already handling an+ \* NMI, and KVM has not yet intercepted an IRET, then there is nothing+ \* more to do at this time as KVM has already enabled IRET intercepts.+ \* If KVM has already intercepted IRET, then single-step over the IRET,+ \* as NMIs aren't architecturally unmasked until the IRET completes.+ \*+ \* If vNMI is enabled, KVM should never request an NMI window if NMIs+ \* are masked, as KVM allows at most one to-be-injected NMI and one+ \* pending NMI. If two NMIs arrive simultaneously, KVM will inject one+ \* NMI and set V\_NMI\_PENDING for the other, but if and only if NMIs are+ \* unmasked. KVM \_will\_ request an NMI window in some situations, e.g.+ \* if the vCPU is in an STI shadow or if GIF=0, KVM can't immediately+ \* inject the NMI. In those situations, KVM needs to single-step over+ \* the STI shadow or intercept STGI. \*/- WARN\_ON\_ONCE(is\_vnmi\_enabled(svm));+ if (svm\_get\_nmi\_mask(vcpu)) {+ WARN\_ON\_ONCE(is\_vnmi\_enabled(svm)); - if (svm\_get\_nmi\_mask(vcpu) && !svm->awaiting\_iret\_completion)- return; /\* IRET will cause a vm exit \*/+ if (!svm->awaiting\_iret\_completion)+ return; /\* IRET will cause a vm exit \*/+ }  /\* \* SEV-ES guests are responsible for signaling when a vCPU is ready to |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 07:05:27 +0000


