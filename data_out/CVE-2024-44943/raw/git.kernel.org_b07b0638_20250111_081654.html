<!DOCTYPE html>
<html lang='en'>
<head>
<title>mm: gup: stop abusing try_grab_folio - kernel/git/stable/linux.git - Linux kernel stable tree</title>
<meta name='generator' content='cgit 1.2.3-korg'/>
<meta name='robots' content='noindex, nofollow'/>
<link rel='stylesheet' type='text/css' href='/cgit-data/cgit.css'/>
<script type='text/javascript' src='/cgit-data/cgit.js'></script>
<link rel='shortcut icon' href='/favicon.ico'/>
<link rel='alternate' title='Atom feed' href='https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/atom/?h=master' type='application/atom+xml'/>
<link rel='vcs-git' href='git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git' title='kernel/git/stable/linux.git Git repository'/>
<link rel='vcs-git' href='https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git' title='kernel/git/stable/linux.git Git repository'/>
<link rel='vcs-git' href='https://kernel.googlesource.com/pub/scm/linux/kernel/git/stable/linux.git' title='kernel/git/stable/linux.git Git repository'/>
</head>
<body>
<div id='cgit'><table id='header'>
<tr>
<td class='logo' rowspan='2'><a href='/'><img src='/cgit-data/cgit.png' alt='cgit logo'/></a></td>
<td class='main'><a href='/'>index</a> : <a href='/pub/scm/linux/kernel/git/stable/linux.git/'>kernel/git/stable/linux.git</a></td><td class='form'><form method='get'>
<input type='hidden' name='id' value='f442fa6141379a20b48ae3efabee827a3d260787'/><select name='h' onchange='this.form.submit();'>
<option value='linux-2.6.11.y'>linux-2.6.11.y</option>
<option value='linux-2.6.12.y'>linux-2.6.12.y</option>
<option value='linux-2.6.13.y'>linux-2.6.13.y</option>
<option value='linux-2.6.14.y'>linux-2.6.14.y</option>
<option value='linux-2.6.15.y'>linux-2.6.15.y</option>
<option value='linux-2.6.16.y'>linux-2.6.16.y</option>
<option value='linux-2.6.17.y'>linux-2.6.17.y</option>
<option value='linux-2.6.18.y'>linux-2.6.18.y</option>
<option value='linux-2.6.19.y'>linux-2.6.19.y</option>
<option value='linux-2.6.20.y'>linux-2.6.20.y</option>
<option value='linux-2.6.21.y'>linux-2.6.21.y</option>
<option value='linux-2.6.22.y'>linux-2.6.22.y</option>
<option value='linux-2.6.23.y'>linux-2.6.23.y</option>
<option value='linux-2.6.24.y'>linux-2.6.24.y</option>
<option value='linux-2.6.25.y'>linux-2.6.25.y</option>
<option value='linux-2.6.26.y'>linux-2.6.26.y</option>
<option value='linux-2.6.27.y'>linux-2.6.27.y</option>
<option value='linux-2.6.28.y'>linux-2.6.28.y</option>
<option value='linux-2.6.29.y'>linux-2.6.29.y</option>
<option value='linux-2.6.30.y'>linux-2.6.30.y</option>
<option value='linux-2.6.31.y'>linux-2.6.31.y</option>
<option value='linux-2.6.32.y'>linux-2.6.32.y</option>
<option value='linux-2.6.33.y'>linux-2.6.33.y</option>
<option value='linux-2.6.34.y'>linux-2.6.34.y</option>
<option value='linux-2.6.35.y'>linux-2.6.35.y</option>
<option value='linux-2.6.36.y'>linux-2.6.36.y</option>
<option value='linux-2.6.37.y'>linux-2.6.37.y</option>
<option value='linux-2.6.38.y'>linux-2.6.38.y</option>
<option value='linux-2.6.39.y'>linux-2.6.39.y</option>
<option value='linux-3.0.y'>linux-3.0.y</option>
<option value='linux-3.1.y'>linux-3.1.y</option>
<option value='linux-3.10.y'>linux-3.10.y</option>
<option value='linux-3.11.y'>linux-3.11.y</option>
<option value='linux-3.12.y'>linux-3.12.y</option>
<option value='linux-3.13.y'>linux-3.13.y</option>
<option value='linux-3.14.y'>linux-3.14.y</option>
<option value='linux-3.15.y'>linux-3.15.y</option>
<option value='linux-3.16.y'>linux-3.16.y</option>
<option value='linux-3.17.y'>linux-3.17.y</option>
<option value='linux-3.18.y'>linux-3.18.y</option>
<option value='linux-3.19.y'>linux-3.19.y</option>
<option value='linux-3.2.y'>linux-3.2.y</option>
<option value='linux-3.3.y'>linux-3.3.y</option>
<option value='linux-3.4.y'>linux-3.4.y</option>
<option value='linux-3.5.y'>linux-3.5.y</option>
<option value='linux-3.6.y'>linux-3.6.y</option>
<option value='linux-3.7.y'>linux-3.7.y</option>
<option value='linux-3.8.y'>linux-3.8.y</option>
<option value='linux-3.9.y'>linux-3.9.y</option>
<option value='linux-4.0.y'>linux-4.0.y</option>
<option value='linux-4.1.y'>linux-4.1.y</option>
<option value='linux-4.10.y'>linux-4.10.y</option>
<option value='linux-4.11.y'>linux-4.11.y</option>
<option value='linux-4.12.y'>linux-4.12.y</option>
<option value='linux-4.13.y'>linux-4.13.y</option>
<option value='linux-4.14.y'>linux-4.14.y</option>
<option value='linux-4.15.y'>linux-4.15.y</option>
<option value='linux-4.16.y'>linux-4.16.y</option>
<option value='linux-4.17.y'>linux-4.17.y</option>
<option value='linux-4.18.y'>linux-4.18.y</option>
<option value='linux-4.19.y'>linux-4.19.y</option>
<option value='linux-4.2.y'>linux-4.2.y</option>
<option value='linux-4.20.y'>linux-4.20.y</option>
<option value='linux-4.3.y'>linux-4.3.y</option>
<option value='linux-4.4.y'>linux-4.4.y</option>
<option value='linux-4.5.y'>linux-4.5.y</option>
<option value='linux-4.6.y'>linux-4.6.y</option>
<option value='linux-4.7.y'>linux-4.7.y</option>
<option value='linux-4.8.y'>linux-4.8.y</option>
<option value='linux-4.9.y'>linux-4.9.y</option>
<option value='linux-5.0.y'>linux-5.0.y</option>
<option value='linux-5.1.y'>linux-5.1.y</option>
<option value='linux-5.10.y'>linux-5.10.y</option>
<option value='linux-5.11.y'>linux-5.11.y</option>
<option value='linux-5.12.y'>linux-5.12.y</option>
<option value='linux-5.13.y'>linux-5.13.y</option>
<option value='linux-5.14.y'>linux-5.14.y</option>
<option value='linux-5.15.y'>linux-5.15.y</option>
<option value='linux-5.16.y'>linux-5.16.y</option>
<option value='linux-5.17.y'>linux-5.17.y</option>
<option value='linux-5.18.y'>linux-5.18.y</option>
<option value='linux-5.19.y'>linux-5.19.y</option>
<option value='linux-5.2.y'>linux-5.2.y</option>
<option value='linux-5.3.y'>linux-5.3.y</option>
<option value='linux-5.4.y'>linux-5.4.y</option>
<option value='linux-5.5.y'>linux-5.5.y</option>
<option value='linux-5.6.y'>linux-5.6.y</option>
<option value='linux-5.7.y'>linux-5.7.y</option>
<option value='linux-5.8.y'>linux-5.8.y</option>
<option value='linux-5.9.y'>linux-5.9.y</option>
<option value='linux-6.0.y'>linux-6.0.y</option>
<option value='linux-6.1.y'>linux-6.1.y</option>
<option value='linux-6.10.y'>linux-6.10.y</option>
<option value='linux-6.11.y'>linux-6.11.y</option>
<option value='linux-6.12.y'>linux-6.12.y</option>
<option value='linux-6.2.y'>linux-6.2.y</option>
<option value='linux-6.3.y'>linux-6.3.y</option>
<option value='linux-6.4.y'>linux-6.4.y</option>
<option value='linux-6.5.y'>linux-6.5.y</option>
<option value='linux-6.6.y'>linux-6.6.y</option>
<option value='linux-6.7.y'>linux-6.7.y</option>
<option value='linux-6.8.y'>linux-6.8.y</option>
<option value='linux-6.9.y'>linux-6.9.y</option>
<option value='linux-rolling-lts'>linux-rolling-lts</option>
<option value='linux-rolling-stable'>linux-rolling-stable</option>
<option value='master' selected='selected'>master</option>
</select> <input type='submit' value='switch'/></form></td></tr>
<tr><td class='sub'>Linux kernel stable tree</td><td class='sub right'>Stable Group</td></tr></table>
<table class='tabs'><tr><td>
<a href='/pub/scm/linux/kernel/git/stable/linux.git/about/'>about</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/'>summary</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=f442fa6141379a20b48ae3efabee827a3d260787'>refs</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/log/'>log</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f442fa6141379a20b48ae3efabee827a3d260787'>tree</a><a class='active' href='/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f442fa6141379a20b48ae3efabee827a3d260787'>commit</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f442fa6141379a20b48ae3efabee827a3d260787'>diff</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/stats/'>stats</a></td><td class='form'><form class='right' method='get' action='/pub/scm/linux/kernel/git/stable/linux.git/log/'>
<input type='hidden' name='id' value='f442fa6141379a20b48ae3efabee827a3d260787'/><select name='qt'>
<option value='grep'>log msg</option>
<option value='author'>author</option>
<option value='committer'>committer</option>
<option value='range'>range</option>
</select>
<input class='txt' type='search' size='10' name='q' value=''/>
<input type='submit' value='search'/>
</form>
</td></tr></table>
<div class='content'><div class='cgit-panel'><b>diff options</b><form method='get'><input type='hidden' name='id' value='f442fa6141379a20b48ae3efabee827a3d260787'/><table><tr><td colspan='2'/></tr><tr><td class='label'>context:</td><td class='ctrl'><select name='context' onchange='this.form.submit();'><option value='1'>1</option><option value='2'>2</option><option value='3' selected='selected'>3</option><option value='4'>4</option><option value='5'>5</option><option value='6'>6</option><option value='7'>7</option><option value='8'>8</option><option value='9'>9</option><option value='10'>10</option><option value='15'>15</option><option value='20'>20</option><option value='25'>25</option><option value='30'>30</option><option value='35'>35</option><option value='40'>40</option></select></td></tr><tr><td class='label'>space:</td><td class='ctrl'><select name='ignorews' onchange='this.form.submit();'><option value='0' selected='selected'>include</option><option value='1'>ignore</option></select></td></tr><tr><td class='label'>mode:</td><td class='ctrl'><select name='dt' onchange='this.form.submit();'><option value='0' selected='selected'>unified</option><option value='1'>ssdiff</option><option value='2'>stat only</option></select></td></tr><tr><td/><td class='ctrl'><noscript><input type='submit' value='reload'/></noscript></td></tr></table></form></div><table summary='commit info' class='commit-info'>
<tr><th>author</th><td>Yang Shi &lt;yang@os.amperecomputing.com&gt;</td><td class='right'>2024-06-28 12:14:58 -0700</td></tr>
<tr><th>committer</th><td>Andrew Morton &lt;akpm@linux-foundation.org&gt;</td><td class='right'>2024-07-06 11:39:51 -0700</td></tr>
<tr><th>commit</th><td colspan='2' class='oid'><a href='/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f442fa6141379a20b48ae3efabee827a3d260787'>f442fa6141379a20b48ae3efabee827a3d260787</a> (<a href='/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=f442fa6141379a20b48ae3efabee827a3d260787'>patch</a>)</td></tr>
<tr><th>tree</th><td colspan='2' class='oid'><a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f442fa6141379a20b48ae3efabee827a3d260787'>bc6e4c783fbc49aff1fd5cd451a3cdf1b7c06cad</a></td></tr>
<tr><th>parent</th><td colspan='2' class='oid'><a href='/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a9e1ddc09ca55746079cc479aa3eb6411f0d99d4'>a9e1ddc09ca55746079cc479aa3eb6411f0d99d4</a> (<a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f442fa6141379a20b48ae3efabee827a3d260787&amp;id2=a9e1ddc09ca55746079cc479aa3eb6411f0d99d4'>diff</a>)</td></tr><tr><th>download</th><td colspan='2' class='oid'><a href='/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-f442fa6141379a20b48ae3efabee827a3d260787.tar.gz'>linux-f442fa6141379a20b48ae3efabee827a3d260787.tar.gz</a><br/></td></tr></table>
<div class='commit-subject'>mm: gup: stop abusing try_grab_folio</div><div class='commit-msg'>A kernel warning was reported when pinning folio in CMA memory when
launching SEV virtual machine.  The splat looks like:

[  464.325306] WARNING: CPU: 13 PID: 6734 at mm/gup.c:1313 __get_user_pages+0x423/0x520
[  464.325464] CPU: 13 PID: 6734 Comm: qemu-kvm Kdump: loaded Not tainted 6.6.33+ #6
[  464.325477] RIP: 0010:__get_user_pages+0x423/0x520
[  464.325515] Call Trace:
[  464.325520]  &lt;TASK&gt;
[  464.325523]  ? __get_user_pages+0x423/0x520
[  464.325528]  ? __warn+0x81/0x130
[  464.325536]  ? __get_user_pages+0x423/0x520
[  464.325541]  ? report_bug+0x171/0x1a0
[  464.325549]  ? handle_bug+0x3c/0x70
[  464.325554]  ? exc_invalid_op+0x17/0x70
[  464.325558]  ? asm_exc_invalid_op+0x1a/0x20
[  464.325567]  ? __get_user_pages+0x423/0x520
[  464.325575]  __gup_longterm_locked+0x212/0x7a0
[  464.325583]  internal_get_user_pages_fast+0xfb/0x190
[  464.325590]  pin_user_pages_fast+0x47/0x60
[  464.325598]  sev_pin_memory+0xca/0x170 [kvm_amd]
[  464.325616]  sev_mem_enc_register_region+0x81/0x130 [kvm_amd]

Per the analysis done by yangge, when starting the SEV virtual machine, it
will call pin_user_pages_fast(..., FOLL_LONGTERM, ...) to pin the memory. 
But the page is in CMA area, so fast GUP will fail then fallback to the
slow path due to the longterm pinnalbe check in try_grab_folio().

The slow path will try to pin the pages then migrate them out of CMA area.
But the slow path also uses try_grab_folio() to pin the page, it will
also fail due to the same check then the above warning is triggered.

In addition, the try_grab_folio() is supposed to be used in fast path and
it elevates folio refcount by using add ref unless zero.  We are guaranteed
to have at least one stable reference in slow path, so the simple atomic add
could be used.  The performance difference should be trivial, but the
misuse may be confusing and misleading.

Redefined try_grab_folio() to try_grab_folio_fast(), and try_grab_page()
to try_grab_folio(), and use them in the proper paths.  This solves both
the abuse and the kernel warning.

The proper naming makes their usecase more clear and should prevent from
abusing in the future.

peterx said:

: The user will see the pin fails, for gpu-slow it further triggers the WARN
: right below that failure (as in the original report):
: 
:         folio = try_grab_folio(page, page_increm - 1,
:                                 foll_flags);
:         if (WARN_ON_ONCE(!folio)) { &lt;------------------------ here
:                 /*
:                         * Release the 1st page ref if the
:                         * folio is problematic, fail hard.
:                         */
:                 gup_put_folio(page_folio(page), 1,
:                                 foll_flags);
:                 ret = -EFAULT;
:                 goto out;
:         }

[1] https://lore.kernel.org/linux-mm/1719478388-31917-1-git-send-email-yangge1116@126.com/

[shy828301@gmail.com: fix implicit declaration of function try_grab_folio_fast]
  Link: https://lkml.kernel.org/r/CAHbLzkowMSso-4Nufc9hcMehQsK9PNz3OSu-+eniU-2Mm-xjhA@mail.gmail.com
Link: <a href="https://lkml.kernel.org/r/20240628191458.2605553-1-yang@os.amperecomputing.com">https://lkml.kernel.org/r/20240628191458.2605553-1-yang@os.amperecomputing.com</a>
Fixes: 57edfcfd3419 ("mm/gup: accelerate thp gup even for "pages != NULL"")
Signed-off-by: Yang Shi &lt;yang@os.amperecomputing.com&gt;
Reported-by: yangge &lt;yangge1116@126.com&gt;
Cc: Christoph Hellwig &lt;hch@infradead.org&gt;
Cc: David Hildenbrand &lt;david@redhat.com&gt;
Cc: Peter Xu &lt;peterx@redhat.com&gt;
Cc: &lt;stable@vger.kernel.org&gt;	[6.6+]
Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
</div><div class='diffstat-header'><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f442fa6141379a20b48ae3efabee827a3d260787'>Diffstat</a></div><table summary='diffstat' class='diffstat'><tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/mm/gup.c?id=f442fa6141379a20b48ae3efabee827a3d260787'>mm/gup.c</a></td><td class='right'>289</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 52.9%;'/><td class='rem' style='width: 47.1%;'/><td class='none' style='width: 0.0%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/mm/huge_memory.c?id=f442fa6141379a20b48ae3efabee827a3d260787'>mm/huge_memory.c</a></td><td class='right'>2</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.3%;'/><td class='rem' style='width: 0.3%;'/><td class='none' style='width: 99.3%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/mm/internal.h?id=f442fa6141379a20b48ae3efabee827a3d260787'>mm/internal.h</a></td><td class='right'>4</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.7%;'/><td class='rem' style='width: 0.7%;'/><td class='none' style='width: 98.6%;'/></tr></table></td></tr>
</table><div class='diffstat-summary'>3 files changed, 156 insertions, 139 deletions</div><table summary='diff' class='diff'><tr><td><div class='head'>diff --git a/mm/gup.c b/mm/gup.c<br/>index 469799f805f1fd..f1d6bc06eb523e 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/gup.c?id=a9e1ddc09ca55746079cc479aa3eb6411f0d99d4'>mm/gup.c</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/gup.c?id=f442fa6141379a20b48ae3efabee827a3d260787'>mm/gup.c</a></div><div class='hunk'>@@ -97,95 +97,6 @@ retry:</div><div class='ctx'> 	return folio;</div><div class='ctx'> }</div><div class='ctx'> </div><div class='del'>-/**</div><div class='del'>- * try_grab_folio() - Attempt to get or pin a folio.</div><div class='del'>- * @page:  pointer to page to be grabbed</div><div class='del'>- * @refs:  the value to (effectively) add to the folio's refcount</div><div class='del'>- * @flags: gup flags: these are the FOLL_* flag values.</div><div class='del'>- *</div><div class='del'>- * "grab" names in this file mean, "look at flags to decide whether to use</div><div class='del'>- * FOLL_PIN or FOLL_GET behavior, when incrementing the folio's refcount.</div><div class='del'>- *</div><div class='del'>- * Either FOLL_PIN or FOLL_GET (or neither) must be set, but not both at the</div><div class='del'>- * same time. (That's true throughout the get_user_pages*() and</div><div class='del'>- * pin_user_pages*() APIs.) Cases:</div><div class='del'>- *</div><div class='del'>- *    FOLL_GET: folio's refcount will be incremented by @refs.</div><div class='del'>- *</div><div class='del'>- *    FOLL_PIN on large folios: folio's refcount will be incremented by</div><div class='del'>- *    @refs, and its pincount will be incremented by @refs.</div><div class='del'>- *</div><div class='del'>- *    FOLL_PIN on single-page folios: folio's refcount will be incremented by</div><div class='del'>- *    @refs * GUP_PIN_COUNTING_BIAS.</div><div class='del'>- *</div><div class='del'>- * Return: The folio containing @page (with refcount appropriately</div><div class='del'>- * incremented) for success, or NULL upon failure. If neither FOLL_GET</div><div class='del'>- * nor FOLL_PIN was set, that's considered failure, and furthermore,</div><div class='del'>- * a likely bug in the caller, so a warning is also emitted.</div><div class='del'>- */</div><div class='del'>-struct folio *try_grab_folio(struct page *page, int refs, unsigned int flags)</div><div class='del'>-{</div><div class='del'>-	struct folio *folio;</div><div class='del'>-</div><div class='del'>-	if (WARN_ON_ONCE((flags &amp; (FOLL_GET | FOLL_PIN)) == 0))</div><div class='del'>-		return NULL;</div><div class='del'>-</div><div class='del'>-	if (unlikely(!(flags &amp; FOLL_PCI_P2PDMA) &amp;&amp; is_pci_p2pdma_page(page)))</div><div class='del'>-		return NULL;</div><div class='del'>-</div><div class='del'>-	if (flags &amp; FOLL_GET)</div><div class='del'>-		return try_get_folio(page, refs);</div><div class='del'>-</div><div class='del'>-	/* FOLL_PIN is set */</div><div class='del'>-</div><div class='del'>-	/*</div><div class='del'>-	 * Don't take a pin on the zero page - it's not going anywhere</div><div class='del'>-	 * and it is used in a *lot* of places.</div><div class='del'>-	 */</div><div class='del'>-	if (is_zero_page(page))</div><div class='del'>-		return page_folio(page);</div><div class='del'>-</div><div class='del'>-	folio = try_get_folio(page, refs);</div><div class='del'>-	if (!folio)</div><div class='del'>-		return NULL;</div><div class='del'>-</div><div class='del'>-	/*</div><div class='del'>-	 * Can't do FOLL_LONGTERM + FOLL_PIN gup fast path if not in a</div><div class='del'>-	 * right zone, so fail and let the caller fall back to the slow</div><div class='del'>-	 * path.</div><div class='del'>-	 */</div><div class='del'>-	if (unlikely((flags &amp; FOLL_LONGTERM) &amp;&amp;</div><div class='del'>-		     !folio_is_longterm_pinnable(folio))) {</div><div class='del'>-		if (!put_devmap_managed_folio_refs(folio, refs))</div><div class='del'>-			folio_put_refs(folio, refs);</div><div class='del'>-		return NULL;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	/*</div><div class='del'>-	 * When pinning a large folio, use an exact count to track it.</div><div class='del'>-	 *</div><div class='del'>-	 * However, be sure to *also* increment the normal folio</div><div class='del'>-	 * refcount field at least once, so that the folio really</div><div class='del'>-	 * is pinned.  That's why the refcount from the earlier</div><div class='del'>-	 * try_get_folio() is left intact.</div><div class='del'>-	 */</div><div class='del'>-	if (folio_test_large(folio))</div><div class='del'>-		atomic_add(refs, &amp;folio-&gt;_pincount);</div><div class='del'>-	else</div><div class='del'>-		folio_ref_add(folio,</div><div class='del'>-				refs * (GUP_PIN_COUNTING_BIAS - 1));</div><div class='del'>-	/*</div><div class='del'>-	 * Adjust the pincount before re-checking the PTE for changes.</div><div class='del'>-	 * This is essentially a smp_mb() and is paired with a memory</div><div class='del'>-	 * barrier in folio_try_share_anon_rmap_*().</div><div class='del'>-	 */</div><div class='del'>-	smp_mb__after_atomic();</div><div class='del'>-</div><div class='del'>-	node_stat_mod_folio(folio, NR_FOLL_PIN_ACQUIRED, refs);</div><div class='del'>-</div><div class='del'>-	return folio;</div><div class='del'>-}</div><div class='del'>-</div><div class='ctx'> static void gup_put_folio(struct folio *folio, int refs, unsigned int flags)</div><div class='ctx'> {</div><div class='ctx'> 	if (flags &amp; FOLL_PIN) {</div><div class='hunk'>@@ -203,58 +114,59 @@ static void gup_put_folio(struct folio *folio, int refs, unsigned int flags)</div><div class='ctx'> }</div><div class='ctx'> </div><div class='ctx'> /**</div><div class='del'>- * try_grab_page() - elevate a page's refcount by a flag-dependent amount</div><div class='del'>- * @page:    pointer to page to be grabbed</div><div class='del'>- * @flags:   gup flags: these are the FOLL_* flag values.</div><div class='add'>+ * try_grab_folio() - add a folio's refcount by a flag-dependent amount</div><div class='add'>+ * @folio:    pointer to folio to be grabbed</div><div class='add'>+ * @refs:     the value to (effectively) add to the folio's refcount</div><div class='add'>+ * @flags:    gup flags: these are the FOLL_* flag values</div><div class='ctx'>  *</div><div class='ctx'>  * This might not do anything at all, depending on the flags argument.</div><div class='ctx'>  *</div><div class='ctx'>  * "grab" names in this file mean, "look at flags to decide whether to use</div><div class='del'>- * FOLL_PIN or FOLL_GET behavior, when incrementing the page's refcount.</div><div class='add'>+ * FOLL_PIN or FOLL_GET behavior, when incrementing the folio's refcount.</div><div class='ctx'>  *</div><div class='ctx'>  * Either FOLL_PIN or FOLL_GET (or neither) may be set, but not both at the same</div><div class='del'>- * time. Cases: please see the try_grab_folio() documentation, with</div><div class='del'>- * "refs=1".</div><div class='add'>+ * time.</div><div class='ctx'>  *</div><div class='ctx'>  * Return: 0 for success, or if no action was required (if neither FOLL_PIN</div><div class='ctx'>  * nor FOLL_GET was set, nothing is done). A negative error code for failure:</div><div class='ctx'>  *</div><div class='del'>- *   -ENOMEM		FOLL_GET or FOLL_PIN was set, but the page could not</div><div class='add'>+ *   -ENOMEM		FOLL_GET or FOLL_PIN was set, but the folio could not</div><div class='ctx'>  *			be grabbed.</div><div class='add'>+ *</div><div class='add'>+ * It is called when we have a stable reference for the folio, typically in</div><div class='add'>+ * GUP slow path.</div><div class='ctx'>  */</div><div class='del'>-int __must_check try_grab_page(struct page *page, unsigned int flags)</div><div class='add'>+int __must_check try_grab_folio(struct folio *folio, int refs,</div><div class='add'>+				unsigned int flags)</div><div class='ctx'> {</div><div class='del'>-	struct folio *folio = page_folio(page);</div><div class='del'>-</div><div class='ctx'> 	if (WARN_ON_ONCE(folio_ref_count(folio) &lt;= 0))</div><div class='ctx'> 		return -ENOMEM;</div><div class='ctx'> </div><div class='del'>-	if (unlikely(!(flags &amp; FOLL_PCI_P2PDMA) &amp;&amp; is_pci_p2pdma_page(page)))</div><div class='add'>+	if (unlikely(!(flags &amp; FOLL_PCI_P2PDMA) &amp;&amp; is_pci_p2pdma_page(&amp;folio-&gt;page)))</div><div class='ctx'> 		return -EREMOTEIO;</div><div class='ctx'> </div><div class='ctx'> 	if (flags &amp; FOLL_GET)</div><div class='del'>-		folio_ref_inc(folio);</div><div class='add'>+		folio_ref_add(folio, refs);</div><div class='ctx'> 	else if (flags &amp; FOLL_PIN) {</div><div class='ctx'> 		/*</div><div class='ctx'> 		 * Don't take a pin on the zero page - it's not going anywhere</div><div class='ctx'> 		 * and it is used in a *lot* of places.</div><div class='ctx'> 		 */</div><div class='del'>-		if (is_zero_page(page))</div><div class='add'>+		if (is_zero_folio(folio))</div><div class='ctx'> 			return 0;</div><div class='ctx'> </div><div class='ctx'> 		/*</div><div class='del'>-		 * Similar to try_grab_folio(): be sure to *also*</div><div class='del'>-		 * increment the normal page refcount field at least once,</div><div class='add'>+		 * Increment the normal page refcount field at least once,</div><div class='ctx'> 		 * so that the page really is pinned.</div><div class='ctx'> 		 */</div><div class='ctx'> 		if (folio_test_large(folio)) {</div><div class='del'>-			folio_ref_add(folio, 1);</div><div class='del'>-			atomic_add(1, &amp;folio-&gt;_pincount);</div><div class='add'>+			folio_ref_add(folio, refs);</div><div class='add'>+			atomic_add(refs, &amp;folio-&gt;_pincount);</div><div class='ctx'> 		} else {</div><div class='del'>-			folio_ref_add(folio, GUP_PIN_COUNTING_BIAS);</div><div class='add'>+			folio_ref_add(folio, refs * GUP_PIN_COUNTING_BIAS);</div><div class='ctx'> 		}</div><div class='ctx'> </div><div class='del'>-		node_stat_mod_folio(folio, NR_FOLL_PIN_ACQUIRED, 1);</div><div class='add'>+		node_stat_mod_folio(folio, NR_FOLL_PIN_ACQUIRED, refs);</div><div class='ctx'> 	}</div><div class='ctx'> </div><div class='ctx'> 	return 0;</div><div class='hunk'>@@ -515,6 +427,102 @@ static int record_subpages(struct page *page, unsigned long sz,</div><div class='ctx'> </div><div class='ctx'> 	return nr;</div><div class='ctx'> }</div><div class='add'>+</div><div class='add'>+/**</div><div class='add'>+ * try_grab_folio_fast() - Attempt to get or pin a folio in fast path.</div><div class='add'>+ * @page:  pointer to page to be grabbed</div><div class='add'>+ * @refs:  the value to (effectively) add to the folio's refcount</div><div class='add'>+ * @flags: gup flags: these are the FOLL_* flag values.</div><div class='add'>+ *</div><div class='add'>+ * "grab" names in this file mean, "look at flags to decide whether to use</div><div class='add'>+ * FOLL_PIN or FOLL_GET behavior, when incrementing the folio's refcount.</div><div class='add'>+ *</div><div class='add'>+ * Either FOLL_PIN or FOLL_GET (or neither) must be set, but not both at the</div><div class='add'>+ * same time. (That's true throughout the get_user_pages*() and</div><div class='add'>+ * pin_user_pages*() APIs.) Cases:</div><div class='add'>+ *</div><div class='add'>+ *    FOLL_GET: folio's refcount will be incremented by @refs.</div><div class='add'>+ *</div><div class='add'>+ *    FOLL_PIN on large folios: folio's refcount will be incremented by</div><div class='add'>+ *    @refs, and its pincount will be incremented by @refs.</div><div class='add'>+ *</div><div class='add'>+ *    FOLL_PIN on single-page folios: folio's refcount will be incremented by</div><div class='add'>+ *    @refs * GUP_PIN_COUNTING_BIAS.</div><div class='add'>+ *</div><div class='add'>+ * Return: The folio containing @page (with refcount appropriately</div><div class='add'>+ * incremented) for success, or NULL upon failure. If neither FOLL_GET</div><div class='add'>+ * nor FOLL_PIN was set, that's considered failure, and furthermore,</div><div class='add'>+ * a likely bug in the caller, so a warning is also emitted.</div><div class='add'>+ *</div><div class='add'>+ * It uses add ref unless zero to elevate the folio refcount and must be called</div><div class='add'>+ * in fast path only.</div><div class='add'>+ */</div><div class='add'>+static struct folio *try_grab_folio_fast(struct page *page, int refs,</div><div class='add'>+					 unsigned int flags)</div><div class='add'>+{</div><div class='add'>+	struct folio *folio;</div><div class='add'>+</div><div class='add'>+	/* Raise warn if it is not called in fast GUP */</div><div class='add'>+	VM_WARN_ON_ONCE(!irqs_disabled());</div><div class='add'>+</div><div class='add'>+	if (WARN_ON_ONCE((flags &amp; (FOLL_GET | FOLL_PIN)) == 0))</div><div class='add'>+		return NULL;</div><div class='add'>+</div><div class='add'>+	if (unlikely(!(flags &amp; FOLL_PCI_P2PDMA) &amp;&amp; is_pci_p2pdma_page(page)))</div><div class='add'>+		return NULL;</div><div class='add'>+</div><div class='add'>+	if (flags &amp; FOLL_GET)</div><div class='add'>+		return try_get_folio(page, refs);</div><div class='add'>+</div><div class='add'>+	/* FOLL_PIN is set */</div><div class='add'>+</div><div class='add'>+	/*</div><div class='add'>+	 * Don't take a pin on the zero page - it's not going anywhere</div><div class='add'>+	 * and it is used in a *lot* of places.</div><div class='add'>+	 */</div><div class='add'>+	if (is_zero_page(page))</div><div class='add'>+		return page_folio(page);</div><div class='add'>+</div><div class='add'>+	folio = try_get_folio(page, refs);</div><div class='add'>+	if (!folio)</div><div class='add'>+		return NULL;</div><div class='add'>+</div><div class='add'>+	/*</div><div class='add'>+	 * Can't do FOLL_LONGTERM + FOLL_PIN gup fast path if not in a</div><div class='add'>+	 * right zone, so fail and let the caller fall back to the slow</div><div class='add'>+	 * path.</div><div class='add'>+	 */</div><div class='add'>+	if (unlikely((flags &amp; FOLL_LONGTERM) &amp;&amp;</div><div class='add'>+		     !folio_is_longterm_pinnable(folio))) {</div><div class='add'>+		if (!put_devmap_managed_folio_refs(folio, refs))</div><div class='add'>+			folio_put_refs(folio, refs);</div><div class='add'>+		return NULL;</div><div class='add'>+	}</div><div class='add'>+</div><div class='add'>+	/*</div><div class='add'>+	 * When pinning a large folio, use an exact count to track it.</div><div class='add'>+	 *</div><div class='add'>+	 * However, be sure to *also* increment the normal folio</div><div class='add'>+	 * refcount field at least once, so that the folio really</div><div class='add'>+	 * is pinned.  That's why the refcount from the earlier</div><div class='add'>+	 * try_get_folio() is left intact.</div><div class='add'>+	 */</div><div class='add'>+	if (folio_test_large(folio))</div><div class='add'>+		atomic_add(refs, &amp;folio-&gt;_pincount);</div><div class='add'>+	else</div><div class='add'>+		folio_ref_add(folio,</div><div class='add'>+				refs * (GUP_PIN_COUNTING_BIAS - 1));</div><div class='add'>+	/*</div><div class='add'>+	 * Adjust the pincount before re-checking the PTE for changes.</div><div class='add'>+	 * This is essentially a smp_mb() and is paired with a memory</div><div class='add'>+	 * barrier in folio_try_share_anon_rmap_*().</div><div class='add'>+	 */</div><div class='add'>+	smp_mb__after_atomic();</div><div class='add'>+</div><div class='add'>+	node_stat_mod_folio(folio, NR_FOLL_PIN_ACQUIRED, refs);</div><div class='add'>+</div><div class='add'>+	return folio;</div><div class='add'>+}</div><div class='ctx'> #endif	/* CONFIG_ARCH_HAS_HUGEPD || CONFIG_HAVE_GUP_FAST */</div><div class='ctx'> </div><div class='ctx'> #ifdef CONFIG_ARCH_HAS_HUGEPD</div><div class='hunk'>@@ -535,7 +543,7 @@ static unsigned long hugepte_addr_end(unsigned long addr, unsigned long end,</div><div class='ctx'>  */</div><div class='ctx'> static int gup_hugepte(struct vm_area_struct *vma, pte_t *ptep, unsigned long sz,</div><div class='ctx'> 		       unsigned long addr, unsigned long end, unsigned int flags,</div><div class='del'>-		       struct page **pages, int *nr)</div><div class='add'>+		       struct page **pages, int *nr, bool fast)</div><div class='ctx'> {</div><div class='ctx'> 	unsigned long pte_end;</div><div class='ctx'> 	struct page *page;</div><div class='hunk'>@@ -558,9 +566,15 @@ static int gup_hugepte(struct vm_area_struct *vma, pte_t *ptep, unsigned long sz</div><div class='ctx'> 	page = pte_page(pte);</div><div class='ctx'> 	refs = record_subpages(page, sz, addr, end, pages + *nr);</div><div class='ctx'> </div><div class='del'>-	folio = try_grab_folio(page, refs, flags);</div><div class='del'>-	if (!folio)</div><div class='del'>-		return 0;</div><div class='add'>+	if (fast) {</div><div class='add'>+		folio = try_grab_folio_fast(page, refs, flags);</div><div class='add'>+		if (!folio)</div><div class='add'>+			return 0;</div><div class='add'>+	} else {</div><div class='add'>+		folio = page_folio(page);</div><div class='add'>+		if (try_grab_folio(folio, refs, flags))</div><div class='add'>+			return 0;</div><div class='add'>+	}</div><div class='ctx'> </div><div class='ctx'> 	if (unlikely(pte_val(pte) != pte_val(ptep_get(ptep)))) {</div><div class='ctx'> 		gup_put_folio(folio, refs, flags);</div><div class='hunk'>@@ -588,7 +602,7 @@ static int gup_hugepte(struct vm_area_struct *vma, pte_t *ptep, unsigned long sz</div><div class='ctx'> static int gup_hugepd(struct vm_area_struct *vma, hugepd_t hugepd,</div><div class='ctx'> 		      unsigned long addr, unsigned int pdshift,</div><div class='ctx'> 		      unsigned long end, unsigned int flags,</div><div class='del'>-		      struct page **pages, int *nr)</div><div class='add'>+		      struct page **pages, int *nr, bool fast)</div><div class='ctx'> {</div><div class='ctx'> 	pte_t *ptep;</div><div class='ctx'> 	unsigned long sz = 1UL &lt;&lt; hugepd_shift(hugepd);</div><div class='hunk'>@@ -598,7 +612,8 @@ static int gup_hugepd(struct vm_area_struct *vma, hugepd_t hugepd,</div><div class='ctx'> 	ptep = hugepte_offset(hugepd, addr, pdshift);</div><div class='ctx'> 	do {</div><div class='ctx'> 		next = hugepte_addr_end(addr, end, sz);</div><div class='del'>-		ret = gup_hugepte(vma, ptep, sz, addr, end, flags, pages, nr);</div><div class='add'>+		ret = gup_hugepte(vma, ptep, sz, addr, end, flags, pages, nr,</div><div class='add'>+				  fast);</div><div class='ctx'> 		if (ret != 1)</div><div class='ctx'> 			return ret;</div><div class='ctx'> 	} while (ptep++, addr = next, addr != end);</div><div class='hunk'>@@ -625,7 +640,7 @@ static struct page *follow_hugepd(struct vm_area_struct *vma, hugepd_t hugepd,</div><div class='ctx'> 	ptep = hugepte_offset(hugepd, addr, pdshift);</div><div class='ctx'> 	ptl = huge_pte_lock(h, vma-&gt;vm_mm, ptep);</div><div class='ctx'> 	ret = gup_hugepd(vma, hugepd, addr, pdshift, addr + PAGE_SIZE,</div><div class='del'>-			 flags, &amp;page, &amp;nr);</div><div class='add'>+			 flags, &amp;page, &amp;nr, false);</div><div class='ctx'> 	spin_unlock(ptl);</div><div class='ctx'> </div><div class='ctx'> 	if (ret == 1) {</div><div class='hunk'>@@ -642,7 +657,7 @@ static struct page *follow_hugepd(struct vm_area_struct *vma, hugepd_t hugepd,</div><div class='ctx'> static inline int gup_hugepd(struct vm_area_struct *vma, hugepd_t hugepd,</div><div class='ctx'> 			     unsigned long addr, unsigned int pdshift,</div><div class='ctx'> 			     unsigned long end, unsigned int flags,</div><div class='del'>-			     struct page **pages, int *nr)</div><div class='add'>+			     struct page **pages, int *nr, bool fast)</div><div class='ctx'> {</div><div class='ctx'> 	return 0;</div><div class='ctx'> }</div><div class='hunk'>@@ -729,7 +744,7 @@ static struct page *follow_huge_pud(struct vm_area_struct *vma,</div><div class='ctx'> 	    gup_must_unshare(vma, flags, page))</div><div class='ctx'> 		return ERR_PTR(-EMLINK);</div><div class='ctx'> </div><div class='del'>-	ret = try_grab_page(page, flags);</div><div class='add'>+	ret = try_grab_folio(page_folio(page), 1, flags);</div><div class='ctx'> 	if (ret)</div><div class='ctx'> 		page = ERR_PTR(ret);</div><div class='ctx'> 	else</div><div class='hunk'>@@ -806,7 +821,7 @@ static struct page *follow_huge_pmd(struct vm_area_struct *vma,</div><div class='ctx'> 	VM_BUG_ON_PAGE((flags &amp; FOLL_PIN) &amp;&amp; PageAnon(page) &amp;&amp;</div><div class='ctx'> 			!PageAnonExclusive(page), page);</div><div class='ctx'> </div><div class='del'>-	ret = try_grab_page(page, flags);</div><div class='add'>+	ret = try_grab_folio(page_folio(page), 1, flags);</div><div class='ctx'> 	if (ret)</div><div class='ctx'> 		return ERR_PTR(ret);</div><div class='ctx'> </div><div class='hunk'>@@ -968,8 +983,8 @@ static struct page *follow_page_pte(struct vm_area_struct *vma,</div><div class='ctx'> 	VM_BUG_ON_PAGE((flags &amp; FOLL_PIN) &amp;&amp; PageAnon(page) &amp;&amp;</div><div class='ctx'> 		       !PageAnonExclusive(page), page);</div><div class='ctx'> </div><div class='del'>-	/* try_grab_page() does nothing unless FOLL_GET or FOLL_PIN is set. */</div><div class='del'>-	ret = try_grab_page(page, flags);</div><div class='add'>+	/* try_grab_folio() does nothing unless FOLL_GET or FOLL_PIN is set. */</div><div class='add'>+	ret = try_grab_folio(page_folio(page), 1, flags);</div><div class='ctx'> 	if (unlikely(ret)) {</div><div class='ctx'> 		page = ERR_PTR(ret);</div><div class='ctx'> 		goto out;</div><div class='hunk'>@@ -1233,7 +1248,7 @@ static int get_gate_page(struct mm_struct *mm, unsigned long address,</div><div class='ctx'> 			goto unmap;</div><div class='ctx'> 		*page = pte_page(entry);</div><div class='ctx'> 	}</div><div class='del'>-	ret = try_grab_page(*page, gup_flags);</div><div class='add'>+	ret = try_grab_folio(page_folio(*page), 1, gup_flags);</div><div class='ctx'> 	if (unlikely(ret))</div><div class='ctx'> 		goto unmap;</div><div class='ctx'> out:</div><div class='hunk'>@@ -1636,20 +1651,19 @@ next_page:</div><div class='ctx'> 			 * pages.</div><div class='ctx'> 			 */</div><div class='ctx'> 			if (page_increm &gt; 1) {</div><div class='del'>-				struct folio *folio;</div><div class='add'>+				struct folio *folio = page_folio(page);</div><div class='ctx'> </div><div class='ctx'> 				/*</div><div class='ctx'> 				 * Since we already hold refcount on the</div><div class='ctx'> 				 * large folio, this should never fail.</div><div class='ctx'> 				 */</div><div class='del'>-				folio = try_grab_folio(page, page_increm - 1,</div><div class='del'>-						       foll_flags);</div><div class='del'>-				if (WARN_ON_ONCE(!folio)) {</div><div class='add'>+				if (try_grab_folio(folio, page_increm - 1,</div><div class='add'>+						   foll_flags)) {</div><div class='ctx'> 					/*</div><div class='ctx'> 					 * Release the 1st page ref if the</div><div class='ctx'> 					 * folio is problematic, fail hard.</div><div class='ctx'> 					 */</div><div class='del'>-					gup_put_folio(page_folio(page), 1,</div><div class='add'>+					gup_put_folio(folio, 1,</div><div class='ctx'> 						      foll_flags);</div><div class='ctx'> 					ret = -EFAULT;</div><div class='ctx'> 					goto out;</div><div class='hunk'>@@ -2797,7 +2811,6 @@ EXPORT_SYMBOL(get_user_pages_unlocked);</div><div class='ctx'>  * This code is based heavily on the PowerPC implementation by Nick Piggin.</div><div class='ctx'>  */</div><div class='ctx'> #ifdef CONFIG_HAVE_GUP_FAST</div><div class='del'>-</div><div class='ctx'> /*</div><div class='ctx'>  * Used in the GUP-fast path to determine whether GUP is permitted to work on</div><div class='ctx'>  * a specific folio.</div><div class='hunk'>@@ -2962,7 +2975,7 @@ static int gup_fast_pte_range(pmd_t pmd, pmd_t *pmdp, unsigned long addr,</div><div class='ctx'> 		VM_BUG_ON(!pfn_valid(pte_pfn(pte)));</div><div class='ctx'> 		page = pte_page(pte);</div><div class='ctx'> </div><div class='del'>-		folio = try_grab_folio(page, 1, flags);</div><div class='add'>+		folio = try_grab_folio_fast(page, 1, flags);</div><div class='ctx'> 		if (!folio)</div><div class='ctx'> 			goto pte_unmap;</div><div class='ctx'> </div><div class='hunk'>@@ -3049,7 +3062,7 @@ static int gup_fast_devmap_leaf(unsigned long pfn, unsigned long addr,</div><div class='ctx'> 			break;</div><div class='ctx'> 		}</div><div class='ctx'> </div><div class='del'>-		folio = try_grab_folio(page, 1, flags);</div><div class='add'>+		folio = try_grab_folio_fast(page, 1, flags);</div><div class='ctx'> 		if (!folio) {</div><div class='ctx'> 			gup_fast_undo_dev_pagemap(nr, nr_start, flags, pages);</div><div class='ctx'> 			break;</div><div class='hunk'>@@ -3138,7 +3151,7 @@ static int gup_fast_pmd_leaf(pmd_t orig, pmd_t *pmdp, unsigned long addr,</div><div class='ctx'> 	page = pmd_page(orig);</div><div class='ctx'> 	refs = record_subpages(page, PMD_SIZE, addr, end, pages + *nr);</div><div class='ctx'> </div><div class='del'>-	folio = try_grab_folio(page, refs, flags);</div><div class='add'>+	folio = try_grab_folio_fast(page, refs, flags);</div><div class='ctx'> 	if (!folio)</div><div class='ctx'> 		return 0;</div><div class='ctx'> </div><div class='hunk'>@@ -3182,7 +3195,7 @@ static int gup_fast_pud_leaf(pud_t orig, pud_t *pudp, unsigned long addr,</div><div class='ctx'> 	page = pud_page(orig);</div><div class='ctx'> 	refs = record_subpages(page, PUD_SIZE, addr, end, pages + *nr);</div><div class='ctx'> </div><div class='del'>-	folio = try_grab_folio(page, refs, flags);</div><div class='add'>+	folio = try_grab_folio_fast(page, refs, flags);</div><div class='ctx'> 	if (!folio)</div><div class='ctx'> 		return 0;</div><div class='ctx'> </div><div class='hunk'>@@ -3222,7 +3235,7 @@ static int gup_fast_pgd_leaf(pgd_t orig, pgd_t *pgdp, unsigned long addr,</div><div class='ctx'> 	page = pgd_page(orig);</div><div class='ctx'> 	refs = record_subpages(page, PGDIR_SIZE, addr, end, pages + *nr);</div><div class='ctx'> </div><div class='del'>-	folio = try_grab_folio(page, refs, flags);</div><div class='add'>+	folio = try_grab_folio_fast(page, refs, flags);</div><div class='ctx'> 	if (!folio)</div><div class='ctx'> 		return 0;</div><div class='ctx'> </div><div class='hunk'>@@ -3276,7 +3289,8 @@ static int gup_fast_pmd_range(pud_t *pudp, pud_t pud, unsigned long addr,</div><div class='ctx'> 			 * pmd format and THP pmd format</div><div class='ctx'> 			 */</div><div class='ctx'> 			if (gup_hugepd(NULL, __hugepd(pmd_val(pmd)), addr,</div><div class='del'>-				       PMD_SHIFT, next, flags, pages, nr) != 1)</div><div class='add'>+				       PMD_SHIFT, next, flags, pages, nr,</div><div class='add'>+				       true) != 1)</div><div class='ctx'> 				return 0;</div><div class='ctx'> 		} else if (!gup_fast_pte_range(pmd, pmdp, addr, next, flags,</div><div class='ctx'> 					       pages, nr))</div><div class='hunk'>@@ -3306,7 +3320,8 @@ static int gup_fast_pud_range(p4d_t *p4dp, p4d_t p4d, unsigned long addr,</div><div class='ctx'> 				return 0;</div><div class='ctx'> 		} else if (unlikely(is_hugepd(__hugepd(pud_val(pud))))) {</div><div class='ctx'> 			if (gup_hugepd(NULL, __hugepd(pud_val(pud)), addr,</div><div class='del'>-				       PUD_SHIFT, next, flags, pages, nr) != 1)</div><div class='add'>+				       PUD_SHIFT, next, flags, pages, nr,</div><div class='add'>+				       true) != 1)</div><div class='ctx'> 				return 0;</div><div class='ctx'> 		} else if (!gup_fast_pmd_range(pudp, pud, addr, next, flags,</div><div class='ctx'> 					       pages, nr))</div><div class='hunk'>@@ -3333,7 +3348,8 @@ static int gup_fast_p4d_range(pgd_t *pgdp, pgd_t pgd, unsigned long addr,</div><div class='ctx'> 		BUILD_BUG_ON(p4d_leaf(p4d));</div><div class='ctx'> 		if (unlikely(is_hugepd(__hugepd(p4d_val(p4d))))) {</div><div class='ctx'> 			if (gup_hugepd(NULL, __hugepd(p4d_val(p4d)), addr,</div><div class='del'>-				       P4D_SHIFT, next, flags, pages, nr) != 1)</div><div class='add'>+				       P4D_SHIFT, next, flags, pages, nr,</div><div class='add'>+				       true) != 1)</div><div class='ctx'> 				return 0;</div><div class='ctx'> 		} else if (!gup_fast_pud_range(p4dp, p4d, addr, next, flags,</div><div class='ctx'> 					       pages, nr))</div><div class='hunk'>@@ -3362,7 +3378,8 @@ static void gup_fast_pgd_range(unsigned long addr, unsigned long end,</div><div class='ctx'> 				return;</div><div class='ctx'> 		} else if (unlikely(is_hugepd(__hugepd(pgd_val(pgd))))) {</div><div class='ctx'> 			if (gup_hugepd(NULL, __hugepd(pgd_val(pgd)), addr,</div><div class='del'>-				       PGDIR_SHIFT, next, flags, pages, nr) != 1)</div><div class='add'>+				       PGDIR_SHIFT, next, flags, pages, nr,</div><div class='add'>+				       true) != 1)</div><div class='ctx'> 				return;</div><div class='ctx'> 		} else if (!gup_fast_p4d_range(pgdp, pgd, addr, next, flags,</div><div class='ctx'> 					       pages, nr))</div><div class='head'>diff --git a/mm/huge_memory.c b/mm/huge_memory.c<br/>index db7946a0a28c4b..2120f7478e55ca 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/huge_memory.c?id=a9e1ddc09ca55746079cc479aa3eb6411f0d99d4'>mm/huge_memory.c</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/huge_memory.c?id=f442fa6141379a20b48ae3efabee827a3d260787'>mm/huge_memory.c</a></div><div class='hunk'>@@ -1331,7 +1331,7 @@ struct page *follow_devmap_pmd(struct vm_area_struct *vma, unsigned long addr,</div><div class='ctx'> 	if (!*pgmap)</div><div class='ctx'> 		return ERR_PTR(-EFAULT);</div><div class='ctx'> 	page = pfn_to_page(pfn);</div><div class='del'>-	ret = try_grab_page(page, flags);</div><div class='add'>+	ret = try_grab_folio(page_folio(page), 1, flags);</div><div class='ctx'> 	if (ret)</div><div class='ctx'> 		page = ERR_PTR(ret);</div><div class='ctx'> </div><div class='head'>diff --git a/mm/internal.h b/mm/internal.h<br/>index 6902b7dd85091c..cc2c5e07fad3ba 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/internal.h?id=a9e1ddc09ca55746079cc479aa3eb6411f0d99d4'>mm/internal.h</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/internal.h?id=f442fa6141379a20b48ae3efabee827a3d260787'>mm/internal.h</a></div><div class='hunk'>@@ -1182,8 +1182,8 @@ int migrate_device_coherent_page(struct page *page);</div><div class='ctx'> /*</div><div class='ctx'>  * mm/gup.c</div><div class='ctx'>  */</div><div class='del'>-struct folio *try_grab_folio(struct page *page, int refs, unsigned int flags);</div><div class='del'>-int __must_check try_grab_page(struct page *page, unsigned int flags);</div><div class='add'>+int __must_check try_grab_folio(struct folio *folio, int refs,</div><div class='add'>+				unsigned int flags);</div><div class='ctx'> </div><div class='ctx'> /*</div><div class='ctx'>  * mm/huge_memory.c</div></td></tr></table></div> <!-- class=content -->
<div class='footer'>generated by <a href='https://git.zx2c4.com/cgit/about/'>cgit 1.2.3-korg</a> (<a href='https://git-scm.com/'>git 2.43.0</a>) at 2025-01-11 08:15:31 +0000</div>
</div> <!-- id=cgit -->
</body>
</html>
