<!DOCTYPE html>
<html lang='en'>
<head>
<title>mm: gup: stop abusing try_grab_folio - kernel/git/stable/linux.git - Linux kernel stable tree</title>
<meta name='generator' content='cgit 1.2.3-korg'/>
<meta name='robots' content='noindex, nofollow'/>
<link rel='stylesheet' type='text/css' href='/cgit-data/cgit.css'/>
<script type='text/javascript' src='/cgit-data/cgit.js'></script>
<link rel='shortcut icon' href='/favicon.ico'/>
<link rel='alternate' title='Atom feed' href='https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/atom/?h=master' type='application/atom+xml'/>
<link rel='vcs-git' href='git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git' title='kernel/git/stable/linux.git Git repository'/>
<link rel='vcs-git' href='https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git' title='kernel/git/stable/linux.git Git repository'/>
<link rel='vcs-git' href='https://kernel.googlesource.com/pub/scm/linux/kernel/git/stable/linux.git' title='kernel/git/stable/linux.git Git repository'/>
</head>
<body>
<div id='cgit'><table id='header'>
<tr>
<td class='logo' rowspan='2'><a href='/'><img src='/cgit-data/cgit.png' alt='cgit logo'/></a></td>
<td class='main'><a href='/'>index</a> : <a href='/pub/scm/linux/kernel/git/stable/linux.git/'>kernel/git/stable/linux.git</a></td><td class='form'><form method='get'>
<input type='hidden' name='id' value='26273f5f4cf68b29414e403837093408a9c98e1f'/><select name='h' onchange='this.form.submit();'>
<option value='linux-2.6.11.y'>linux-2.6.11.y</option>
<option value='linux-2.6.12.y'>linux-2.6.12.y</option>
<option value='linux-2.6.13.y'>linux-2.6.13.y</option>
<option value='linux-2.6.14.y'>linux-2.6.14.y</option>
<option value='linux-2.6.15.y'>linux-2.6.15.y</option>
<option value='linux-2.6.16.y'>linux-2.6.16.y</option>
<option value='linux-2.6.17.y'>linux-2.6.17.y</option>
<option value='linux-2.6.18.y'>linux-2.6.18.y</option>
<option value='linux-2.6.19.y'>linux-2.6.19.y</option>
<option value='linux-2.6.20.y'>linux-2.6.20.y</option>
<option value='linux-2.6.21.y'>linux-2.6.21.y</option>
<option value='linux-2.6.22.y'>linux-2.6.22.y</option>
<option value='linux-2.6.23.y'>linux-2.6.23.y</option>
<option value='linux-2.6.24.y'>linux-2.6.24.y</option>
<option value='linux-2.6.25.y'>linux-2.6.25.y</option>
<option value='linux-2.6.26.y'>linux-2.6.26.y</option>
<option value='linux-2.6.27.y'>linux-2.6.27.y</option>
<option value='linux-2.6.28.y'>linux-2.6.28.y</option>
<option value='linux-2.6.29.y'>linux-2.6.29.y</option>
<option value='linux-2.6.30.y'>linux-2.6.30.y</option>
<option value='linux-2.6.31.y'>linux-2.6.31.y</option>
<option value='linux-2.6.32.y'>linux-2.6.32.y</option>
<option value='linux-2.6.33.y'>linux-2.6.33.y</option>
<option value='linux-2.6.34.y'>linux-2.6.34.y</option>
<option value='linux-2.6.35.y'>linux-2.6.35.y</option>
<option value='linux-2.6.36.y'>linux-2.6.36.y</option>
<option value='linux-2.6.37.y'>linux-2.6.37.y</option>
<option value='linux-2.6.38.y'>linux-2.6.38.y</option>
<option value='linux-2.6.39.y'>linux-2.6.39.y</option>
<option value='linux-3.0.y'>linux-3.0.y</option>
<option value='linux-3.1.y'>linux-3.1.y</option>
<option value='linux-3.10.y'>linux-3.10.y</option>
<option value='linux-3.11.y'>linux-3.11.y</option>
<option value='linux-3.12.y'>linux-3.12.y</option>
<option value='linux-3.13.y'>linux-3.13.y</option>
<option value='linux-3.14.y'>linux-3.14.y</option>
<option value='linux-3.15.y'>linux-3.15.y</option>
<option value='linux-3.16.y'>linux-3.16.y</option>
<option value='linux-3.17.y'>linux-3.17.y</option>
<option value='linux-3.18.y'>linux-3.18.y</option>
<option value='linux-3.19.y'>linux-3.19.y</option>
<option value='linux-3.2.y'>linux-3.2.y</option>
<option value='linux-3.3.y'>linux-3.3.y</option>
<option value='linux-3.4.y'>linux-3.4.y</option>
<option value='linux-3.5.y'>linux-3.5.y</option>
<option value='linux-3.6.y'>linux-3.6.y</option>
<option value='linux-3.7.y'>linux-3.7.y</option>
<option value='linux-3.8.y'>linux-3.8.y</option>
<option value='linux-3.9.y'>linux-3.9.y</option>
<option value='linux-4.0.y'>linux-4.0.y</option>
<option value='linux-4.1.y'>linux-4.1.y</option>
<option value='linux-4.10.y'>linux-4.10.y</option>
<option value='linux-4.11.y'>linux-4.11.y</option>
<option value='linux-4.12.y'>linux-4.12.y</option>
<option value='linux-4.13.y'>linux-4.13.y</option>
<option value='linux-4.14.y'>linux-4.14.y</option>
<option value='linux-4.15.y'>linux-4.15.y</option>
<option value='linux-4.16.y'>linux-4.16.y</option>
<option value='linux-4.17.y'>linux-4.17.y</option>
<option value='linux-4.18.y'>linux-4.18.y</option>
<option value='linux-4.19.y'>linux-4.19.y</option>
<option value='linux-4.2.y'>linux-4.2.y</option>
<option value='linux-4.20.y'>linux-4.20.y</option>
<option value='linux-4.3.y'>linux-4.3.y</option>
<option value='linux-4.4.y'>linux-4.4.y</option>
<option value='linux-4.5.y'>linux-4.5.y</option>
<option value='linux-4.6.y'>linux-4.6.y</option>
<option value='linux-4.7.y'>linux-4.7.y</option>
<option value='linux-4.8.y'>linux-4.8.y</option>
<option value='linux-4.9.y'>linux-4.9.y</option>
<option value='linux-5.0.y'>linux-5.0.y</option>
<option value='linux-5.1.y'>linux-5.1.y</option>
<option value='linux-5.10.y'>linux-5.10.y</option>
<option value='linux-5.11.y'>linux-5.11.y</option>
<option value='linux-5.12.y'>linux-5.12.y</option>
<option value='linux-5.13.y'>linux-5.13.y</option>
<option value='linux-5.14.y'>linux-5.14.y</option>
<option value='linux-5.15.y'>linux-5.15.y</option>
<option value='linux-5.16.y'>linux-5.16.y</option>
<option value='linux-5.17.y'>linux-5.17.y</option>
<option value='linux-5.18.y'>linux-5.18.y</option>
<option value='linux-5.19.y'>linux-5.19.y</option>
<option value='linux-5.2.y'>linux-5.2.y</option>
<option value='linux-5.3.y'>linux-5.3.y</option>
<option value='linux-5.4.y'>linux-5.4.y</option>
<option value='linux-5.5.y'>linux-5.5.y</option>
<option value='linux-5.6.y'>linux-5.6.y</option>
<option value='linux-5.7.y'>linux-5.7.y</option>
<option value='linux-5.8.y'>linux-5.8.y</option>
<option value='linux-5.9.y'>linux-5.9.y</option>
<option value='linux-6.0.y'>linux-6.0.y</option>
<option value='linux-6.1.y'>linux-6.1.y</option>
<option value='linux-6.10.y'>linux-6.10.y</option>
<option value='linux-6.11.y'>linux-6.11.y</option>
<option value='linux-6.12.y'>linux-6.12.y</option>
<option value='linux-6.2.y'>linux-6.2.y</option>
<option value='linux-6.3.y'>linux-6.3.y</option>
<option value='linux-6.4.y'>linux-6.4.y</option>
<option value='linux-6.5.y'>linux-6.5.y</option>
<option value='linux-6.6.y'>linux-6.6.y</option>
<option value='linux-6.7.y'>linux-6.7.y</option>
<option value='linux-6.8.y'>linux-6.8.y</option>
<option value='linux-6.9.y'>linux-6.9.y</option>
<option value='linux-rolling-lts'>linux-rolling-lts</option>
<option value='linux-rolling-stable'>linux-rolling-stable</option>
<option value='master' selected='selected'>master</option>
</select> <input type='submit' value='switch'/></form></td></tr>
<tr><td class='sub'>Linux kernel stable tree</td><td class='sub right'>Stable Group</td></tr></table>
<table class='tabs'><tr><td>
<a href='/pub/scm/linux/kernel/git/stable/linux.git/about/'>about</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/'>summary</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=26273f5f4cf68b29414e403837093408a9c98e1f'>refs</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/log/'>log</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=26273f5f4cf68b29414e403837093408a9c98e1f'>tree</a><a class='active' href='/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=26273f5f4cf68b29414e403837093408a9c98e1f'>commit</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=26273f5f4cf68b29414e403837093408a9c98e1f'>diff</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/stats/'>stats</a></td><td class='form'><form class='right' method='get' action='/pub/scm/linux/kernel/git/stable/linux.git/log/'>
<input type='hidden' name='id' value='26273f5f4cf68b29414e403837093408a9c98e1f'/><select name='qt'>
<option value='grep'>log msg</option>
<option value='author'>author</option>
<option value='committer'>committer</option>
<option value='range'>range</option>
</select>
<input class='txt' type='search' size='10' name='q' value=''/>
<input type='submit' value='search'/>
</form>
</td></tr></table>
<div class='content'><div class='cgit-panel'><b>diff options</b><form method='get'><input type='hidden' name='id' value='26273f5f4cf68b29414e403837093408a9c98e1f'/><table><tr><td colspan='2'/></tr><tr><td class='label'>context:</td><td class='ctrl'><select name='context' onchange='this.form.submit();'><option value='1'>1</option><option value='2'>2</option><option value='3' selected='selected'>3</option><option value='4'>4</option><option value='5'>5</option><option value='6'>6</option><option value='7'>7</option><option value='8'>8</option><option value='9'>9</option><option value='10'>10</option><option value='15'>15</option><option value='20'>20</option><option value='25'>25</option><option value='30'>30</option><option value='35'>35</option><option value='40'>40</option></select></td></tr><tr><td class='label'>space:</td><td class='ctrl'><select name='ignorews' onchange='this.form.submit();'><option value='0' selected='selected'>include</option><option value='1'>ignore</option></select></td></tr><tr><td class='label'>mode:</td><td class='ctrl'><select name='dt' onchange='this.form.submit();'><option value='0' selected='selected'>unified</option><option value='1'>ssdiff</option><option value='2'>stat only</option></select></td></tr><tr><td/><td class='ctrl'><noscript><input type='submit' value='reload'/></noscript></td></tr></table></form></div><table summary='commit info' class='commit-info'>
<tr><th>author</th><td>Yang Shi &lt;yang@os.amperecomputing.com&gt;</td><td class='right'>2024-06-28 12:14:58 -0700</td></tr>
<tr><th>committer</th><td>Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;</td><td class='right'>2024-08-19 06:04:24 +0200</td></tr>
<tr><th>commit</th><td colspan='2' class='oid'><a href='/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=26273f5f4cf68b29414e403837093408a9c98e1f'>26273f5f4cf68b29414e403837093408a9c98e1f</a> (<a href='/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=26273f5f4cf68b29414e403837093408a9c98e1f'>patch</a>)</td></tr>
<tr><th>tree</th><td colspan='2' class='oid'><a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=26273f5f4cf68b29414e403837093408a9c98e1f'>3e13c2fe46c4b66d865235ebee38a4e1a02f04e0</a></td></tr>
<tr><th>parent</th><td colspan='2' class='oid'><a href='/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9eae19001439f5004e1fb189972d929201db29ef'>9eae19001439f5004e1fb189972d929201db29ef</a> (<a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=26273f5f4cf68b29414e403837093408a9c98e1f&amp;id2=9eae19001439f5004e1fb189972d929201db29ef'>diff</a>)</td></tr><tr><th>download</th><td colspan='2' class='oid'><a href='/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-26273f5f4cf68b29414e403837093408a9c98e1f.tar.gz'>linux-26273f5f4cf68b29414e403837093408a9c98e1f.tar.gz</a><br/></td></tr></table>
<div class='commit-subject'>mm: gup: stop abusing try_grab_folio</div><div class='commit-msg'>commit f442fa6141379a20b48ae3efabee827a3d260787 upstream.

A kernel warning was reported when pinning folio in CMA memory when
launching SEV virtual machine.  The splat looks like:

[  464.325306] WARNING: CPU: 13 PID: 6734 at mm/gup.c:1313 __get_user_pages+0x423/0x520
[  464.325464] CPU: 13 PID: 6734 Comm: qemu-kvm Kdump: loaded Not tainted 6.6.33+ #6
[  464.325477] RIP: 0010:__get_user_pages+0x423/0x520
[  464.325515] Call Trace:
[  464.325520]  &lt;TASK&gt;
[  464.325523]  ? __get_user_pages+0x423/0x520
[  464.325528]  ? __warn+0x81/0x130
[  464.325536]  ? __get_user_pages+0x423/0x520
[  464.325541]  ? report_bug+0x171/0x1a0
[  464.325549]  ? handle_bug+0x3c/0x70
[  464.325554]  ? exc_invalid_op+0x17/0x70
[  464.325558]  ? asm_exc_invalid_op+0x1a/0x20
[  464.325567]  ? __get_user_pages+0x423/0x520
[  464.325575]  __gup_longterm_locked+0x212/0x7a0
[  464.325583]  internal_get_user_pages_fast+0xfb/0x190
[  464.325590]  pin_user_pages_fast+0x47/0x60
[  464.325598]  sev_pin_memory+0xca/0x170 [kvm_amd]
[  464.325616]  sev_mem_enc_register_region+0x81/0x130 [kvm_amd]

Per the analysis done by yangge, when starting the SEV virtual machine, it
will call pin_user_pages_fast(..., FOLL_LONGTERM, ...) to pin the memory.
But the page is in CMA area, so fast GUP will fail then fallback to the
slow path due to the longterm pinnalbe check in try_grab_folio().

The slow path will try to pin the pages then migrate them out of CMA area.
But the slow path also uses try_grab_folio() to pin the page, it will
also fail due to the same check then the above warning is triggered.

In addition, the try_grab_folio() is supposed to be used in fast path and
it elevates folio refcount by using add ref unless zero.  We are guaranteed
to have at least one stable reference in slow path, so the simple atomic add
could be used.  The performance difference should be trivial, but the
misuse may be confusing and misleading.

Redefined try_grab_folio() to try_grab_folio_fast(), and try_grab_page()
to try_grab_folio(), and use them in the proper paths.  This solves both
the abuse and the kernel warning.

The proper naming makes their usecase more clear and should prevent from
abusing in the future.

peterx said:

: The user will see the pin fails, for gpu-slow it further triggers the WARN
: right below that failure (as in the original report):
:
:         folio = try_grab_folio(page, page_increm - 1,
:                                 foll_flags);
:         if (WARN_ON_ONCE(!folio)) { &lt;------------------------ here
:                 /*
:                         * Release the 1st page ref if the
:                         * folio is problematic, fail hard.
:                         */
:                 gup_put_folio(page_folio(page), 1,
:                                 foll_flags);
:                 ret = -EFAULT;
:                 goto out;
:         }

[1] https://lore.kernel.org/linux-mm/1719478388-31917-1-git-send-email-yangge1116@126.com/

[shy828301@gmail.com: fix implicit declaration of function try_grab_folio_fast]
  Link: https://lkml.kernel.org/r/CAHbLzkowMSso-4Nufc9hcMehQsK9PNz3OSu-+eniU-2Mm-xjhA@mail.gmail.com
Link: <a href="https://lkml.kernel.org/r/20240628191458.2605553-1-yang@os.amperecomputing.com">https://lkml.kernel.org/r/20240628191458.2605553-1-yang@os.amperecomputing.com</a>
Fixes: 57edfcfd3419 ("mm/gup: accelerate thp gup even for "pages != NULL"")
Signed-off-by: Yang Shi &lt;yang@os.amperecomputing.com&gt;
Reported-by: yangge &lt;yangge1116@126.com&gt;
Cc: Christoph Hellwig &lt;hch@infradead.org&gt;
Cc: David Hildenbrand &lt;david@redhat.com&gt;
Cc: Peter Xu &lt;peterx@redhat.com&gt;
Cc: &lt;stable@vger.kernel.org&gt;	[6.6+]
Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;
</div><div class='diffstat-header'><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=26273f5f4cf68b29414e403837093408a9c98e1f'>Diffstat</a></div><table summary='diffstat' class='diffstat'><tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/mm/gup.c?id=26273f5f4cf68b29414e403837093408a9c98e1f'>mm/gup.c</a></td><td class='right'>251</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 51.4%;'/><td class='rem' style='width: 48.6%;'/><td class='none' style='width: 0.0%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/mm/huge_memory.c?id=26273f5f4cf68b29414e403837093408a9c98e1f'>mm/huge_memory.c</a></td><td class='right'>6</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 1.2%;'/><td class='rem' style='width: 1.2%;'/><td class='none' style='width: 97.6%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/mm/hugetlb.c?id=26273f5f4cf68b29414e403837093408a9c98e1f'>mm/hugetlb.c</a></td><td class='right'>2</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.4%;'/><td class='rem' style='width: 0.4%;'/><td class='none' style='width: 99.2%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/mm/internal.h?id=26273f5f4cf68b29414e403837093408a9c98e1f'>mm/internal.h</a></td><td class='right'>4</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.8%;'/><td class='rem' style='width: 0.8%;'/><td class='none' style='width: 98.4%;'/></tr></table></td></tr>
</table><div class='diffstat-summary'>4 files changed, 135 insertions, 128 deletions</div><table summary='diff' class='diff'><tr><td><div class='head'>diff --git a/mm/gup.c b/mm/gup.c<br/>index f50fe2219a13b6..fdd75384160d8d 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/gup.c?id=9eae19001439f5004e1fb189972d929201db29ef'>mm/gup.c</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/gup.c?id=26273f5f4cf68b29414e403837093408a9c98e1f'>mm/gup.c</a></div><div class='hunk'>@@ -97,95 +97,6 @@ retry:</div><div class='ctx'> 	return folio;</div><div class='ctx'> }</div><div class='ctx'> </div><div class='del'>-/**</div><div class='del'>- * try_grab_folio() - Attempt to get or pin a folio.</div><div class='del'>- * @page:  pointer to page to be grabbed</div><div class='del'>- * @refs:  the value to (effectively) add to the folio's refcount</div><div class='del'>- * @flags: gup flags: these are the FOLL_* flag values.</div><div class='del'>- *</div><div class='del'>- * "grab" names in this file mean, "look at flags to decide whether to use</div><div class='del'>- * FOLL_PIN or FOLL_GET behavior, when incrementing the folio's refcount.</div><div class='del'>- *</div><div class='del'>- * Either FOLL_PIN or FOLL_GET (or neither) must be set, but not both at the</div><div class='del'>- * same time. (That's true throughout the get_user_pages*() and</div><div class='del'>- * pin_user_pages*() APIs.) Cases:</div><div class='del'>- *</div><div class='del'>- *    FOLL_GET: folio's refcount will be incremented by @refs.</div><div class='del'>- *</div><div class='del'>- *    FOLL_PIN on large folios: folio's refcount will be incremented by</div><div class='del'>- *    @refs, and its pincount will be incremented by @refs.</div><div class='del'>- *</div><div class='del'>- *    FOLL_PIN on single-page folios: folio's refcount will be incremented by</div><div class='del'>- *    @refs * GUP_PIN_COUNTING_BIAS.</div><div class='del'>- *</div><div class='del'>- * Return: The folio containing @page (with refcount appropriately</div><div class='del'>- * incremented) for success, or NULL upon failure. If neither FOLL_GET</div><div class='del'>- * nor FOLL_PIN was set, that's considered failure, and furthermore,</div><div class='del'>- * a likely bug in the caller, so a warning is also emitted.</div><div class='del'>- */</div><div class='del'>-struct folio *try_grab_folio(struct page *page, int refs, unsigned int flags)</div><div class='del'>-{</div><div class='del'>-	struct folio *folio;</div><div class='del'>-</div><div class='del'>-	if (WARN_ON_ONCE((flags &amp; (FOLL_GET | FOLL_PIN)) == 0))</div><div class='del'>-		return NULL;</div><div class='del'>-</div><div class='del'>-	if (unlikely(!(flags &amp; FOLL_PCI_P2PDMA) &amp;&amp; is_pci_p2pdma_page(page)))</div><div class='del'>-		return NULL;</div><div class='del'>-</div><div class='del'>-	if (flags &amp; FOLL_GET)</div><div class='del'>-		return try_get_folio(page, refs);</div><div class='del'>-</div><div class='del'>-	/* FOLL_PIN is set */</div><div class='del'>-</div><div class='del'>-	/*</div><div class='del'>-	 * Don't take a pin on the zero page - it's not going anywhere</div><div class='del'>-	 * and it is used in a *lot* of places.</div><div class='del'>-	 */</div><div class='del'>-	if (is_zero_page(page))</div><div class='del'>-		return page_folio(page);</div><div class='del'>-</div><div class='del'>-	folio = try_get_folio(page, refs);</div><div class='del'>-	if (!folio)</div><div class='del'>-		return NULL;</div><div class='del'>-</div><div class='del'>-	/*</div><div class='del'>-	 * Can't do FOLL_LONGTERM + FOLL_PIN gup fast path if not in a</div><div class='del'>-	 * right zone, so fail and let the caller fall back to the slow</div><div class='del'>-	 * path.</div><div class='del'>-	 */</div><div class='del'>-	if (unlikely((flags &amp; FOLL_LONGTERM) &amp;&amp;</div><div class='del'>-		     !folio_is_longterm_pinnable(folio))) {</div><div class='del'>-		if (!put_devmap_managed_page_refs(&amp;folio-&gt;page, refs))</div><div class='del'>-			folio_put_refs(folio, refs);</div><div class='del'>-		return NULL;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	/*</div><div class='del'>-	 * When pinning a large folio, use an exact count to track it.</div><div class='del'>-	 *</div><div class='del'>-	 * However, be sure to *also* increment the normal folio</div><div class='del'>-	 * refcount field at least once, so that the folio really</div><div class='del'>-	 * is pinned.  That's why the refcount from the earlier</div><div class='del'>-	 * try_get_folio() is left intact.</div><div class='del'>-	 */</div><div class='del'>-	if (folio_test_large(folio))</div><div class='del'>-		atomic_add(refs, &amp;folio-&gt;_pincount);</div><div class='del'>-	else</div><div class='del'>-		folio_ref_add(folio,</div><div class='del'>-				refs * (GUP_PIN_COUNTING_BIAS - 1));</div><div class='del'>-	/*</div><div class='del'>-	 * Adjust the pincount before re-checking the PTE for changes.</div><div class='del'>-	 * This is essentially a smp_mb() and is paired with a memory</div><div class='del'>-	 * barrier in page_try_share_anon_rmap().</div><div class='del'>-	 */</div><div class='del'>-	smp_mb__after_atomic();</div><div class='del'>-</div><div class='del'>-	node_stat_mod_folio(folio, NR_FOLL_PIN_ACQUIRED, refs);</div><div class='del'>-</div><div class='del'>-	return folio;</div><div class='del'>-}</div><div class='del'>-</div><div class='ctx'> static void gup_put_folio(struct folio *folio, int refs, unsigned int flags)</div><div class='ctx'> {</div><div class='ctx'> 	if (flags &amp; FOLL_PIN) {</div><div class='hunk'>@@ -203,58 +114,59 @@ static void gup_put_folio(struct folio *folio, int refs, unsigned int flags)</div><div class='ctx'> }</div><div class='ctx'> </div><div class='ctx'> /**</div><div class='del'>- * try_grab_page() - elevate a page's refcount by a flag-dependent amount</div><div class='del'>- * @page:    pointer to page to be grabbed</div><div class='del'>- * @flags:   gup flags: these are the FOLL_* flag values.</div><div class='add'>+ * try_grab_folio() - add a folio's refcount by a flag-dependent amount</div><div class='add'>+ * @folio:    pointer to folio to be grabbed</div><div class='add'>+ * @refs:     the value to (effectively) add to the folio's refcount</div><div class='add'>+ * @flags:    gup flags: these are the FOLL_* flag values</div><div class='ctx'>  *</div><div class='ctx'>  * This might not do anything at all, depending on the flags argument.</div><div class='ctx'>  *</div><div class='ctx'>  * "grab" names in this file mean, "look at flags to decide whether to use</div><div class='del'>- * FOLL_PIN or FOLL_GET behavior, when incrementing the page's refcount.</div><div class='add'>+ * FOLL_PIN or FOLL_GET behavior, when incrementing the folio's refcount.</div><div class='ctx'>  *</div><div class='ctx'>  * Either FOLL_PIN or FOLL_GET (or neither) may be set, but not both at the same</div><div class='del'>- * time. Cases: please see the try_grab_folio() documentation, with</div><div class='del'>- * "refs=1".</div><div class='add'>+ * time.</div><div class='ctx'>  *</div><div class='ctx'>  * Return: 0 for success, or if no action was required (if neither FOLL_PIN</div><div class='ctx'>  * nor FOLL_GET was set, nothing is done). A negative error code for failure:</div><div class='ctx'>  *</div><div class='del'>- *   -ENOMEM		FOLL_GET or FOLL_PIN was set, but the page could not</div><div class='add'>+ *   -ENOMEM		FOLL_GET or FOLL_PIN was set, but the folio could not</div><div class='ctx'>  *			be grabbed.</div><div class='add'>+ *</div><div class='add'>+ * It is called when we have a stable reference for the folio, typically in</div><div class='add'>+ * GUP slow path.</div><div class='ctx'>  */</div><div class='del'>-int __must_check try_grab_page(struct page *page, unsigned int flags)</div><div class='add'>+int __must_check try_grab_folio(struct folio *folio, int refs,</div><div class='add'>+				unsigned int flags)</div><div class='ctx'> {</div><div class='del'>-	struct folio *folio = page_folio(page);</div><div class='del'>-</div><div class='ctx'> 	if (WARN_ON_ONCE(folio_ref_count(folio) &lt;= 0))</div><div class='ctx'> 		return -ENOMEM;</div><div class='ctx'> </div><div class='del'>-	if (unlikely(!(flags &amp; FOLL_PCI_P2PDMA) &amp;&amp; is_pci_p2pdma_page(page)))</div><div class='add'>+	if (unlikely(!(flags &amp; FOLL_PCI_P2PDMA) &amp;&amp; is_pci_p2pdma_page(&amp;folio-&gt;page)))</div><div class='ctx'> 		return -EREMOTEIO;</div><div class='ctx'> </div><div class='ctx'> 	if (flags &amp; FOLL_GET)</div><div class='del'>-		folio_ref_inc(folio);</div><div class='add'>+		folio_ref_add(folio, refs);</div><div class='ctx'> 	else if (flags &amp; FOLL_PIN) {</div><div class='ctx'> 		/*</div><div class='ctx'> 		 * Don't take a pin on the zero page - it's not going anywhere</div><div class='ctx'> 		 * and it is used in a *lot* of places.</div><div class='ctx'> 		 */</div><div class='del'>-		if (is_zero_page(page))</div><div class='add'>+		if (is_zero_folio(folio))</div><div class='ctx'> 			return 0;</div><div class='ctx'> </div><div class='ctx'> 		/*</div><div class='del'>-		 * Similar to try_grab_folio(): be sure to *also*</div><div class='del'>-		 * increment the normal page refcount field at least once,</div><div class='add'>+		 * Increment the normal page refcount field at least once,</div><div class='ctx'> 		 * so that the page really is pinned.</div><div class='ctx'> 		 */</div><div class='ctx'> 		if (folio_test_large(folio)) {</div><div class='del'>-			folio_ref_add(folio, 1);</div><div class='del'>-			atomic_add(1, &amp;folio-&gt;_pincount);</div><div class='add'>+			folio_ref_add(folio, refs);</div><div class='add'>+			atomic_add(refs, &amp;folio-&gt;_pincount);</div><div class='ctx'> 		} else {</div><div class='del'>-			folio_ref_add(folio, GUP_PIN_COUNTING_BIAS);</div><div class='add'>+			folio_ref_add(folio, refs * GUP_PIN_COUNTING_BIAS);</div><div class='ctx'> 		}</div><div class='ctx'> </div><div class='del'>-		node_stat_mod_folio(folio, NR_FOLL_PIN_ACQUIRED, 1);</div><div class='add'>+		node_stat_mod_folio(folio, NR_FOLL_PIN_ACQUIRED, refs);</div><div class='ctx'> 	}</div><div class='ctx'> </div><div class='ctx'> 	return 0;</div><div class='hunk'>@@ -647,8 +559,8 @@ static struct page *follow_page_pte(struct vm_area_struct *vma,</div><div class='ctx'> 	VM_BUG_ON_PAGE((flags &amp; FOLL_PIN) &amp;&amp; PageAnon(page) &amp;&amp;</div><div class='ctx'> 		       !PageAnonExclusive(page), page);</div><div class='ctx'> </div><div class='del'>-	/* try_grab_page() does nothing unless FOLL_GET or FOLL_PIN is set. */</div><div class='del'>-	ret = try_grab_page(page, flags);</div><div class='add'>+	/* try_grab_folio() does nothing unless FOLL_GET or FOLL_PIN is set. */</div><div class='add'>+	ret = try_grab_folio(page_folio(page), 1, flags);</div><div class='ctx'> 	if (unlikely(ret)) {</div><div class='ctx'> 		page = ERR_PTR(ret);</div><div class='ctx'> 		goto out;</div><div class='hunk'>@@ -899,7 +811,7 @@ static int get_gate_page(struct mm_struct *mm, unsigned long address,</div><div class='ctx'> 			goto unmap;</div><div class='ctx'> 		*page = pte_page(entry);</div><div class='ctx'> 	}</div><div class='del'>-	ret = try_grab_page(*page, gup_flags);</div><div class='add'>+	ret = try_grab_folio(page_folio(*page), 1, gup_flags);</div><div class='ctx'> 	if (unlikely(ret))</div><div class='ctx'> 		goto unmap;</div><div class='ctx'> out:</div><div class='hunk'>@@ -1302,20 +1214,19 @@ next_page:</div><div class='ctx'> 			 * pages.</div><div class='ctx'> 			 */</div><div class='ctx'> 			if (page_increm &gt; 1) {</div><div class='del'>-				struct folio *folio;</div><div class='add'>+				struct folio *folio = page_folio(page);</div><div class='ctx'> </div><div class='ctx'> 				/*</div><div class='ctx'> 				 * Since we already hold refcount on the</div><div class='ctx'> 				 * large folio, this should never fail.</div><div class='ctx'> 				 */</div><div class='del'>-				folio = try_grab_folio(page, page_increm - 1,</div><div class='del'>-						       foll_flags);</div><div class='del'>-				if (WARN_ON_ONCE(!folio)) {</div><div class='add'>+				if (try_grab_folio(folio, page_increm - 1,</div><div class='add'>+						       foll_flags)) {</div><div class='ctx'> 					/*</div><div class='ctx'> 					 * Release the 1st page ref if the</div><div class='ctx'> 					 * folio is problematic, fail hard.</div><div class='ctx'> 					 */</div><div class='del'>-					gup_put_folio(page_folio(page), 1,</div><div class='add'>+					gup_put_folio(folio, 1,</div><div class='ctx'> 						      foll_flags);</div><div class='ctx'> 					ret = -EFAULT;</div><div class='ctx'> 					goto out;</div><div class='hunk'>@@ -2541,6 +2452,102 @@ static void __maybe_unused undo_dev_pagemap(int *nr, int nr_start,</div><div class='ctx'> 	}</div><div class='ctx'> }</div><div class='ctx'> </div><div class='add'>+/**</div><div class='add'>+ * try_grab_folio_fast() - Attempt to get or pin a folio in fast path.</div><div class='add'>+ * @page:  pointer to page to be grabbed</div><div class='add'>+ * @refs:  the value to (effectively) add to the folio's refcount</div><div class='add'>+ * @flags: gup flags: these are the FOLL_* flag values.</div><div class='add'>+ *</div><div class='add'>+ * "grab" names in this file mean, "look at flags to decide whether to use</div><div class='add'>+ * FOLL_PIN or FOLL_GET behavior, when incrementing the folio's refcount.</div><div class='add'>+ *</div><div class='add'>+ * Either FOLL_PIN or FOLL_GET (or neither) must be set, but not both at the</div><div class='add'>+ * same time. (That's true throughout the get_user_pages*() and</div><div class='add'>+ * pin_user_pages*() APIs.) Cases:</div><div class='add'>+ *</div><div class='add'>+ *    FOLL_GET: folio's refcount will be incremented by @refs.</div><div class='add'>+ *</div><div class='add'>+ *    FOLL_PIN on large folios: folio's refcount will be incremented by</div><div class='add'>+ *    @refs, and its pincount will be incremented by @refs.</div><div class='add'>+ *</div><div class='add'>+ *    FOLL_PIN on single-page folios: folio's refcount will be incremented by</div><div class='add'>+ *    @refs * GUP_PIN_COUNTING_BIAS.</div><div class='add'>+ *</div><div class='add'>+ * Return: The folio containing @page (with refcount appropriately</div><div class='add'>+ * incremented) for success, or NULL upon failure. If neither FOLL_GET</div><div class='add'>+ * nor FOLL_PIN was set, that's considered failure, and furthermore,</div><div class='add'>+ * a likely bug in the caller, so a warning is also emitted.</div><div class='add'>+ *</div><div class='add'>+ * It uses add ref unless zero to elevate the folio refcount and must be called</div><div class='add'>+ * in fast path only.</div><div class='add'>+ */</div><div class='add'>+static struct folio *try_grab_folio_fast(struct page *page, int refs,</div><div class='add'>+					 unsigned int flags)</div><div class='add'>+{</div><div class='add'>+	struct folio *folio;</div><div class='add'>+</div><div class='add'>+	/* Raise warn if it is not called in fast GUP */</div><div class='add'>+	VM_WARN_ON_ONCE(!irqs_disabled());</div><div class='add'>+</div><div class='add'>+	if (WARN_ON_ONCE((flags &amp; (FOLL_GET | FOLL_PIN)) == 0))</div><div class='add'>+		return NULL;</div><div class='add'>+</div><div class='add'>+	if (unlikely(!(flags &amp; FOLL_PCI_P2PDMA) &amp;&amp; is_pci_p2pdma_page(page)))</div><div class='add'>+		return NULL;</div><div class='add'>+</div><div class='add'>+	if (flags &amp; FOLL_GET)</div><div class='add'>+		return try_get_folio(page, refs);</div><div class='add'>+</div><div class='add'>+	/* FOLL_PIN is set */</div><div class='add'>+</div><div class='add'>+	/*</div><div class='add'>+	 * Don't take a pin on the zero page - it's not going anywhere</div><div class='add'>+	 * and it is used in a *lot* of places.</div><div class='add'>+	 */</div><div class='add'>+	if (is_zero_page(page))</div><div class='add'>+		return page_folio(page);</div><div class='add'>+</div><div class='add'>+	folio = try_get_folio(page, refs);</div><div class='add'>+	if (!folio)</div><div class='add'>+		return NULL;</div><div class='add'>+</div><div class='add'>+	/*</div><div class='add'>+	 * Can't do FOLL_LONGTERM + FOLL_PIN gup fast path if not in a</div><div class='add'>+	 * right zone, so fail and let the caller fall back to the slow</div><div class='add'>+	 * path.</div><div class='add'>+	 */</div><div class='add'>+	if (unlikely((flags &amp; FOLL_LONGTERM) &amp;&amp;</div><div class='add'>+		     !folio_is_longterm_pinnable(folio))) {</div><div class='add'>+		if (!put_devmap_managed_page_refs(&amp;folio-&gt;page, refs))</div><div class='add'>+			folio_put_refs(folio, refs);</div><div class='add'>+		return NULL;</div><div class='add'>+	}</div><div class='add'>+</div><div class='add'>+	/*</div><div class='add'>+	 * When pinning a large folio, use an exact count to track it.</div><div class='add'>+	 *</div><div class='add'>+	 * However, be sure to *also* increment the normal folio</div><div class='add'>+	 * refcount field at least once, so that the folio really</div><div class='add'>+	 * is pinned.  That's why the refcount from the earlier</div><div class='add'>+	 * try_get_folio() is left intact.</div><div class='add'>+	 */</div><div class='add'>+	if (folio_test_large(folio))</div><div class='add'>+		atomic_add(refs, &amp;folio-&gt;_pincount);</div><div class='add'>+	else</div><div class='add'>+		folio_ref_add(folio,</div><div class='add'>+				refs * (GUP_PIN_COUNTING_BIAS - 1));</div><div class='add'>+	/*</div><div class='add'>+	 * Adjust the pincount before re-checking the PTE for changes.</div><div class='add'>+	 * This is essentially a smp_mb() and is paired with a memory</div><div class='add'>+	 * barrier in folio_try_share_anon_rmap_*().</div><div class='add'>+	 */</div><div class='add'>+	smp_mb__after_atomic();</div><div class='add'>+</div><div class='add'>+	node_stat_mod_folio(folio, NR_FOLL_PIN_ACQUIRED, refs);</div><div class='add'>+</div><div class='add'>+	return folio;</div><div class='add'>+}</div><div class='add'>+</div><div class='ctx'> #ifdef CONFIG_ARCH_HAS_PTE_SPECIAL</div><div class='ctx'> /*</div><div class='ctx'>  * Fast-gup relies on pte change detection to avoid concurrent pgtable</div><div class='hunk'>@@ -2605,7 +2612,7 @@ static int gup_pte_range(pmd_t pmd, pmd_t *pmdp, unsigned long addr,</div><div class='ctx'> 		VM_BUG_ON(!pfn_valid(pte_pfn(pte)));</div><div class='ctx'> 		page = pte_page(pte);</div><div class='ctx'> </div><div class='del'>-		folio = try_grab_folio(page, 1, flags);</div><div class='add'>+		folio = try_grab_folio_fast(page, 1, flags);</div><div class='ctx'> 		if (!folio)</div><div class='ctx'> 			goto pte_unmap;</div><div class='ctx'> </div><div class='hunk'>@@ -2699,7 +2706,7 @@ static int __gup_device_huge(unsigned long pfn, unsigned long addr,</div><div class='ctx'> </div><div class='ctx'> 		SetPageReferenced(page);</div><div class='ctx'> 		pages[*nr] = page;</div><div class='del'>-		if (unlikely(try_grab_page(page, flags))) {</div><div class='add'>+		if (unlikely(try_grab_folio(page_folio(page), 1, flags))) {</div><div class='ctx'> 			undo_dev_pagemap(nr, nr_start, flags, pages);</div><div class='ctx'> 			break;</div><div class='ctx'> 		}</div><div class='hunk'>@@ -2808,7 +2815,7 @@ static int gup_hugepte(pte_t *ptep, unsigned long sz, unsigned long addr,</div><div class='ctx'> 	page = nth_page(pte_page(pte), (addr &amp; (sz - 1)) &gt;&gt; PAGE_SHIFT);</div><div class='ctx'> 	refs = record_subpages(page, addr, end, pages + *nr);</div><div class='ctx'> </div><div class='del'>-	folio = try_grab_folio(page, refs, flags);</div><div class='add'>+	folio = try_grab_folio_fast(page, refs, flags);</div><div class='ctx'> 	if (!folio)</div><div class='ctx'> 		return 0;</div><div class='ctx'> </div><div class='hunk'>@@ -2879,7 +2886,7 @@ static int gup_huge_pmd(pmd_t orig, pmd_t *pmdp, unsigned long addr,</div><div class='ctx'> 	page = nth_page(pmd_page(orig), (addr &amp; ~PMD_MASK) &gt;&gt; PAGE_SHIFT);</div><div class='ctx'> 	refs = record_subpages(page, addr, end, pages + *nr);</div><div class='ctx'> </div><div class='del'>-	folio = try_grab_folio(page, refs, flags);</div><div class='add'>+	folio = try_grab_folio_fast(page, refs, flags);</div><div class='ctx'> 	if (!folio)</div><div class='ctx'> 		return 0;</div><div class='ctx'> </div><div class='hunk'>@@ -2923,7 +2930,7 @@ static int gup_huge_pud(pud_t orig, pud_t *pudp, unsigned long addr,</div><div class='ctx'> 	page = nth_page(pud_page(orig), (addr &amp; ~PUD_MASK) &gt;&gt; PAGE_SHIFT);</div><div class='ctx'> 	refs = record_subpages(page, addr, end, pages + *nr);</div><div class='ctx'> </div><div class='del'>-	folio = try_grab_folio(page, refs, flags);</div><div class='add'>+	folio = try_grab_folio_fast(page, refs, flags);</div><div class='ctx'> 	if (!folio)</div><div class='ctx'> 		return 0;</div><div class='ctx'> </div><div class='hunk'>@@ -2963,7 +2970,7 @@ static int gup_huge_pgd(pgd_t orig, pgd_t *pgdp, unsigned long addr,</div><div class='ctx'> 	page = nth_page(pgd_page(orig), (addr &amp; ~PGDIR_MASK) &gt;&gt; PAGE_SHIFT);</div><div class='ctx'> 	refs = record_subpages(page, addr, end, pages + *nr);</div><div class='ctx'> </div><div class='del'>-	folio = try_grab_folio(page, refs, flags);</div><div class='add'>+	folio = try_grab_folio_fast(page, refs, flags);</div><div class='ctx'> 	if (!folio)</div><div class='ctx'> 		return 0;</div><div class='ctx'> </div><div class='head'>diff --git a/mm/huge_memory.c b/mm/huge_memory.c<br/>index 7ac2877e76629b..f2816c9a1f3ec8 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/huge_memory.c?id=9eae19001439f5004e1fb189972d929201db29ef'>mm/huge_memory.c</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/huge_memory.c?id=26273f5f4cf68b29414e403837093408a9c98e1f'>mm/huge_memory.c</a></div><div class='hunk'>@@ -1056,7 +1056,7 @@ struct page *follow_devmap_pmd(struct vm_area_struct *vma, unsigned long addr,</div><div class='ctx'> 	if (!*pgmap)</div><div class='ctx'> 		return ERR_PTR(-EFAULT);</div><div class='ctx'> 	page = pfn_to_page(pfn);</div><div class='del'>-	ret = try_grab_page(page, flags);</div><div class='add'>+	ret = try_grab_folio(page_folio(page), 1, flags);</div><div class='ctx'> 	if (ret)</div><div class='ctx'> 		page = ERR_PTR(ret);</div><div class='ctx'> </div><div class='hunk'>@@ -1214,7 +1214,7 @@ struct page *follow_devmap_pud(struct vm_area_struct *vma, unsigned long addr,</div><div class='ctx'> 		return ERR_PTR(-EFAULT);</div><div class='ctx'> 	page = pfn_to_page(pfn);</div><div class='ctx'> </div><div class='del'>-	ret = try_grab_page(page, flags);</div><div class='add'>+	ret = try_grab_folio(page_folio(page), 1, flags);</div><div class='ctx'> 	if (ret)</div><div class='ctx'> 		page = ERR_PTR(ret);</div><div class='ctx'> </div><div class='hunk'>@@ -1475,7 +1475,7 @@ struct page *follow_trans_huge_pmd(struct vm_area_struct *vma,</div><div class='ctx'> 	VM_BUG_ON_PAGE((flags &amp; FOLL_PIN) &amp;&amp; PageAnon(page) &amp;&amp;</div><div class='ctx'> 			!PageAnonExclusive(page), page);</div><div class='ctx'> </div><div class='del'>-	ret = try_grab_page(page, flags);</div><div class='add'>+	ret = try_grab_folio(page_folio(page), 1, flags);</div><div class='ctx'> 	if (ret)</div><div class='ctx'> 		return ERR_PTR(ret);</div><div class='ctx'> </div><div class='head'>diff --git a/mm/hugetlb.c b/mm/hugetlb.c<br/>index fb7a531fce7174..0acb04c3e95291 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/hugetlb.c?id=9eae19001439f5004e1fb189972d929201db29ef'>mm/hugetlb.c</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/hugetlb.c?id=26273f5f4cf68b29414e403837093408a9c98e1f'>mm/hugetlb.c</a></div><div class='hunk'>@@ -6532,7 +6532,7 @@ struct page *hugetlb_follow_page_mask(struct vm_area_struct *vma,</div><div class='ctx'> 		 * try_grab_page() should always be able to get the page here,</div><div class='ctx'> 		 * because we hold the ptl lock and have verified pte_present().</div><div class='ctx'> 		 */</div><div class='del'>-		ret = try_grab_page(page, flags);</div><div class='add'>+		ret = try_grab_folio(page_folio(page), 1, flags);</div><div class='ctx'> </div><div class='ctx'> 		if (WARN_ON_ONCE(ret)) {</div><div class='ctx'> 			page = ERR_PTR(ret);</div><div class='head'>diff --git a/mm/internal.h b/mm/internal.h<br/>index abed947f784b7b..ef8d787a510c5c 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/internal.h?id=9eae19001439f5004e1fb189972d929201db29ef'>mm/internal.h</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/internal.h?id=26273f5f4cf68b29414e403837093408a9c98e1f'>mm/internal.h</a></div><div class='hunk'>@@ -938,8 +938,8 @@ int migrate_device_coherent_page(struct page *page);</div><div class='ctx'> /*</div><div class='ctx'>  * mm/gup.c</div><div class='ctx'>  */</div><div class='del'>-struct folio *try_grab_folio(struct page *page, int refs, unsigned int flags);</div><div class='del'>-int __must_check try_grab_page(struct page *page, unsigned int flags);</div><div class='add'>+int __must_check try_grab_folio(struct folio *folio, int refs,</div><div class='add'>+				unsigned int flags);</div><div class='ctx'> </div><div class='ctx'> /*</div><div class='ctx'>  * mm/huge_memory.c</div></td></tr></table></div> <!-- class=content -->
<div class='footer'>generated by <a href='https://git.zx2c4.com/cgit/about/'>cgit 1.2.3-korg</a> (<a href='https://git-scm.com/'>git 2.43.0</a>) at 2025-01-11 08:15:30 +0000</div>
</div> <!-- id=cgit -->
</body>
</html>
