

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=7fe9d87996062f5eb0ca476ad0257f79bf43aaf5)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=7fe9d87996062f5eb0ca476ad0257f79bf43aaf5)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7fe9d87996062f5eb0ca476ad0257f79bf43aaf5)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7fe9d87996062f5eb0ca476ad0257f79bf43aaf5)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Alan Stern <stern@rowland.harvard.edu> | 2023-08-04 15:14:14 -0400 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2023-09-19 12:22:53 +0200 |
| commit | [7fe9d87996062f5eb0ca476ad0257f79bf43aaf5](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7fe9d87996062f5eb0ca476ad0257f79bf43aaf5) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=7fe9d87996062f5eb0ca476ad0257f79bf43aaf5)) | |
| tree | [46a1c2c5d5574be91c9b6a3746d64105d5bdace9](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=7fe9d87996062f5eb0ca476ad0257f79bf43aaf5) | |
| parent | [eda9a296658203b1cc07d777c19c8c9eac6d0d17](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=eda9a296658203b1cc07d777c19c8c9eac6d0d17) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7fe9d87996062f5eb0ca476ad0257f79bf43aaf5&id2=eda9a296658203b1cc07d777c19c8c9eac6d0d17)) | |
| download | [linux-7fe9d87996062f5eb0ca476ad0257f79bf43aaf5.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-7fe9d87996062f5eb0ca476ad0257f79bf43aaf5.tar.gz) | |

USB: core: Fix race by not overwriting udev->descriptor in hub\_port\_init()commit ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b upstream.
Syzbot reported an out-of-bounds read in sysfs.c:read\_descriptors():
BUG: KASAN: slab-out-of-bounds in read\_descriptors+0x263/0x280 drivers/usb/core/sysfs.c:883
Read of size 8 at addr ffff88801e78b8c8 by task udevd/5011
CPU: 0 PID: 5011 Comm: udevd Not tainted 6.4.0-rc6-syzkaller-00195-g40f71e7cd3c6 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/27/2023
Call Trace:
<TASK>
\_\_dump\_stack lib/dump\_stack.c:88 [inline]
dump\_stack\_lvl+0xd9/0x150 lib/dump\_stack.c:106
print\_address\_description.constprop.0+0x2c/0x3c0 mm/kasan/report.c:351
print\_report mm/kasan/report.c:462 [inline]
kasan\_report+0x11c/0x130 mm/kasan/report.c:572
read\_descriptors+0x263/0x280 drivers/usb/core/sysfs.c:883
...
Allocated by task 758:
...
\_\_do\_kmalloc\_node mm/slab\_common.c:966 [inline]
\_\_kmalloc+0x5e/0x190 mm/slab\_common.c:979
kmalloc include/linux/slab.h:563 [inline]
kzalloc include/linux/slab.h:680 [inline]
usb\_get\_configuration+0x1f7/0x5170 drivers/usb/core/config.c:887
usb\_enumerate\_device drivers/usb/core/hub.c:2407 [inline]
usb\_new\_device+0x12b0/0x19d0 drivers/usb/core/hub.c:2545
As analyzed by Khazhy Kumykov, the cause of this bug is a race between
read\_descriptors() and hub\_port\_init(): The first routine uses a field
in udev->descriptor, not expecting it to change, while the second
overwrites it.
Prior to commit 45bf39f8df7f ("USB: core: Don't hold device lock while
reading the "descriptors" sysfs file") this race couldn't occur,
because the routines were mutually exclusive thanks to the device
locking. Removing that locking from read\_descriptors() exposed it to
the race.
The best way to fix the bug is to keep hub\_port\_init() from changing
udev->descriptor once udev has been initialized and registered.
Drivers expect the descriptors stored in the kernel to be immutable;
we should not undermine this expectation. In fact, this change should
have been made long ago.
So now hub\_port\_init() will take an additional argument, specifying a
buffer in which to store the device descriptor it reads. (If udev has
not yet been initialized, the buffer pointer will be NULL and then
hub\_port\_init() will store the device descriptor in udev as before.)
This eliminates the data race responsible for the out-of-bounds read.
The changes to hub\_port\_init() appear more extensive than they really
are, because of indentation changes resulting from an attempt to avoid
writing to other parts of the usb\_device structure after it has been
initialized. Similar changes should be made to the code that reads
the BOS descriptor, but that can be handled in a separate patch later
on. This patch is sufficient to fix the bug found by syzbot.
Reported-and-tested-by: syzbot+18996170f8096c6174d0@syzkaller.appspotmail.com
Closes: https://lore.kernel.org/linux-usb/000000000000c0ffe505fe86c9ca@google.com/#r
Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
Cc: Khazhy Kumykov <khazhy@google.com>
Fixes: 45bf39f8df7f ("USB: core: Don't hold device lock while reading the "descriptors" sysfs file")
Cc: stable@vger.kernel.org
Link: [https://lore.kernel.org/r/b958b47a-9a46-4c22-a9f9-e42e42c31251@rowland.harvard.edu](https://lore.kernel.org/r/b958b47a-9a46-4c22-a9f9-e42e42c31251%40rowland.harvard.edu)
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7fe9d87996062f5eb0ca476ad0257f79bf43aaf5)

| -rw-r--r-- | [drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/usb/core/hub.c?id=7fe9d87996062f5eb0ca476ad0257f79bf43aaf5) | 114 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 70 insertions, 44 deletions

| diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.cindex 36f625aaf348d0..5fd6ea435b1e5c 100644--- a/[drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/core/hub.c?id=eda9a296658203b1cc07d777c19c8c9eac6d0d17)+++ b/[drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/core/hub.c?id=7fe9d87996062f5eb0ca476ad0257f79bf43aaf5)@@ -4741,10 +4741,17 @@ static int get\_bMaxPacketSize0(struct usb\_device \*udev, \* the port lock. For a newly detected device that is not accessible \* through any global pointers, it's not necessary to lock the device, \* but it is still necessary to lock the port.+ \*+ \* For a newly detected device, @dev\_descr must be NULL. The device+ \* descriptor retrieved from the device will then be stored in+ \* @udev->descriptor. For an already existing device, @dev\_descr+ \* must be non-NULL. The device descriptor will be stored there,+ \* not in @udev->descriptor, because descriptors for registered+ \* devices are meant to be immutable. \*/ static int hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1,- int retry\_counter)+ int retry\_counter, struct usb\_device\_descriptor \*dev\_descr) { struct usb\_device \*hdev = hub->hdev; struct usb\_hcd \*hcd = bus\_to\_hcd(hdev->bus);@@ -4756,6 +4763,7 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, int devnum = udev->devnum; const char \*driver\_name; bool do\_new\_scheme;+ const bool initial = !dev\_descr; int maxp0; struct usb\_device\_descriptor \*buf, \*descr; @@ -4794,32 +4802,34 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, } oldspeed = udev->speed; - /\* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...- \* it's fixed size except for full speed devices.- \* For Wireless USB devices, ep0 max packet is always 512 (tho- \* reported as 0xff in the device descriptor). WUSB1.0[4.8.1].- \*/- switch (udev->speed) {- case USB\_SPEED\_SUPER\_PLUS:- case USB\_SPEED\_SUPER:- case USB\_SPEED\_WIRELESS: /\* fixed at 512 \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(512);- break;- case USB\_SPEED\_HIGH: /\* fixed at 64 \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);- break;- case USB\_SPEED\_FULL: /\* 8, 16, 32, or 64 \*/- /\* to determine the ep0 maxpacket size, try to read- \* the device descriptor to get bMaxPacketSize0 and- \* then correct our initial guess.+ if (initial) {+ /\* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...+ \* it's fixed size except for full speed devices.+ \* For Wireless USB devices, ep0 max packet is always 512 (tho+ \* reported as 0xff in the device descriptor). WUSB1.0[4.8.1]. \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);- break;- case USB\_SPEED\_LOW: /\* fixed at 8 \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(8);- break;- default:- goto fail;+ switch (udev->speed) {+ case USB\_SPEED\_SUPER\_PLUS:+ case USB\_SPEED\_SUPER:+ case USB\_SPEED\_WIRELESS: /\* fixed at 512 \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(512);+ break;+ case USB\_SPEED\_HIGH: /\* fixed at 64 \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);+ break;+ case USB\_SPEED\_FULL: /\* 8, 16, 32, or 64 \*/+ /\* to determine the ep0 maxpacket size, try to read+ \* the device descriptor to get bMaxPacketSize0 and+ \* then correct our initial guess.+ \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);+ break;+ case USB\_SPEED\_LOW: /\* fixed at 8 \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(8);+ break;+ default:+ goto fail;+ } }  if (udev->speed == USB\_SPEED\_WIRELESS)@@ -4842,22 +4852,24 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, if (udev->speed < USB\_SPEED\_SUPER) dev\_info(&udev->dev, "%s %s USB device number %d using %s\n",- (udev->config) ? "reset" : "new", speed,+ (initial ? "new" : "reset"), speed, devnum, driver\_name); - /\* Set up TT records, if needed \*/- if (hdev->tt) {- udev->tt = hdev->tt;- udev->ttport = hdev->ttport;- } else if (udev->speed != USB\_SPEED\_HIGH- && hdev->speed == USB\_SPEED\_HIGH) {- if (!hub->tt.hub) {- dev\_err(&udev->dev, "parent hub has no TT\n");- retval = -EINVAL;- goto fail;+ if (initial) {+ /\* Set up TT records, if needed \*/+ if (hdev->tt) {+ udev->tt = hdev->tt;+ udev->ttport = hdev->ttport;+ } else if (udev->speed != USB\_SPEED\_HIGH+ && hdev->speed == USB\_SPEED\_HIGH) {+ if (!hub->tt.hub) {+ dev\_err(&udev->dev, "parent hub has no TT\n");+ retval = -EINVAL;+ goto fail;+ }+ udev->tt = &hub->tt;+ udev->ttport = port1; }- udev->tt = &hub->tt;- udev->ttport = port1; }  /\* Why interleave GET\_DESCRIPTOR and SET\_ADDRESS this way?@@ -4886,6 +4898,12 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1,  maxp0 = get\_bMaxPacketSize0(udev, buf, GET\_DESCRIPTOR\_BUFSIZE, retries == 0);+ if (maxp0 > 0 && !initial &&+ maxp0 != udev->descriptor.bMaxPacketSize0) {+ dev\_err(&udev->dev, "device reset changed ep0 maxpacket size!\n");+ retval = -ENODEV;+ goto fail;+ }  retval = hub\_port\_reset(hub, port1, udev, delay, false); if (retval < 0) /\* error or disconnect \*/@@ -4959,6 +4977,12 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, } else { u32 delay; + if (!initial && maxp0 != udev->descriptor.bMaxPacketSize0) {+ dev\_err(&udev->dev, "device reset changed ep0 maxpacket size!\n");+ retval = -ENODEV;+ goto fail;+ }+ delay = udev->parent->hub\_delay; udev->hub\_delay = min\_t(u32, delay, USB\_TP\_TRANSMISSION\_DELAY\_MAX);@@ -5002,7 +5026,10 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, retval); goto fail; }- udev->descriptor = \*descr;+ if (initial)+ udev->descriptor = \*descr;+ else+ \*dev\_descr = \*descr; kfree(descr);  /\*@@ -5305,7 +5332,7 @@ static void hub\_port\_connect(struct usb\_hub \*hub, int port1, u16 portstatus, }  /\* reset (non-USB 3.0 devices) and get descriptor \*/- status = hub\_port\_init(hub, udev, port1, i);+ status = hub\_port\_init(hub, udev, port1, i, NULL); if (status < 0) goto loop; @@ -5921,7 +5948,7 @@ static int usb\_reset\_and\_verify\_device(struct usb\_device \*udev) struct usb\_device \*parent\_hdev = udev->parent; struct usb\_hub \*parent\_hub; struct usb\_hcd \*hcd = bus\_to\_hcd(udev->bus);- struct usb\_device\_descriptor descriptor = udev->descriptor;+ struct usb\_device\_descriptor descriptor; struct usb\_host\_bos \*bos; int i, j, ret = 0; int port1 = udev->portnum;@@ -5963,7 +5990,7 @@ static int usb\_reset\_and\_verify\_device(struct usb\_device \*udev) /\* ep0 maxpacket size may change; let the HCD know about it. \* Other endpoints will be handled by re-enumeration. \*/ usb\_ep0\_reinit(udev);- ret = hub\_port\_init(parent\_hub, udev, port1, i);+ ret = hub\_port\_init(parent\_hub, udev, port1, i, &descriptor); if (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV) break; }@@ -5975,7 +6002,6 @@ static int usb\_reset\_and\_verify\_device(struct usb\_device \*udev) /\* Device might have changed firmware (DFU or similar) \*/ if (descriptors\_changed(udev, &descriptor, bos)) { dev\_info(&udev->dev, "device firmware changed\n");- udev->descriptor = descriptor; /\* for disconnect() calls \*/ goto re\_enumerate; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 02:49:27 +0000

