=== Content from git.kernel.org_012ba54a_20250111_025051.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=8186596a663506b1124bede9fde6f243ef9f37ee)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=8186596a663506b1124bede9fde6f243ef9f37ee)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=8186596a663506b1124bede9fde6f243ef9f37ee)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=8186596a663506b1124bede9fde6f243ef9f37ee)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Alan Stern <stern@rowland.harvard.edu> | 2023-08-04 15:14:14 -0400 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2023-09-13 09:43:04 +0200 |
| commit | [8186596a663506b1124bede9fde6f243ef9f37ee](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=8186596a663506b1124bede9fde6f243ef9f37ee) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=8186596a663506b1124bede9fde6f243ef9f37ee)) | |
| tree | [68fa0b3591bcb75a2782525e774ce77c80145b52](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=8186596a663506b1124bede9fde6f243ef9f37ee) | |
| parent | [d309fa69c2e3c5e6134ac9386f833f683e66ad1a](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d309fa69c2e3c5e6134ac9386f833f683e66ad1a) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=8186596a663506b1124bede9fde6f243ef9f37ee&id2=d309fa69c2e3c5e6134ac9386f833f683e66ad1a)) | |
| download | [linux-8186596a663506b1124bede9fde6f243ef9f37ee.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-8186596a663506b1124bede9fde6f243ef9f37ee.tar.gz) | |

USB: core: Fix race by not overwriting udev->descriptor in hub\_port\_init()commit ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b upstream.
Syzbot reported an out-of-bounds read in sysfs.c:read\_descriptors():
BUG: KASAN: slab-out-of-bounds in read\_descriptors+0x263/0x280 drivers/usb/core/sysfs.c:883
Read of size 8 at addr ffff88801e78b8c8 by task udevd/5011
CPU: 0 PID: 5011 Comm: udevd Not tainted 6.4.0-rc6-syzkaller-00195-g40f71e7cd3c6 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/27/2023
Call Trace:
<TASK>
\_\_dump\_stack lib/dump\_stack.c:88 [inline]
dump\_stack\_lvl+0xd9/0x150 lib/dump\_stack.c:106
print\_address\_description.constprop.0+0x2c/0x3c0 mm/kasan/report.c:351
print\_report mm/kasan/report.c:462 [inline]
kasan\_report+0x11c/0x130 mm/kasan/report.c:572
read\_descriptors+0x263/0x280 drivers/usb/core/sysfs.c:883
...
Allocated by task 758:
...
\_\_do\_kmalloc\_node mm/slab\_common.c:966 [inline]
\_\_kmalloc+0x5e/0x190 mm/slab\_common.c:979
kmalloc include/linux/slab.h:563 [inline]
kzalloc include/linux/slab.h:680 [inline]
usb\_get\_configuration+0x1f7/0x5170 drivers/usb/core/config.c:887
usb\_enumerate\_device drivers/usb/core/hub.c:2407 [inline]
usb\_new\_device+0x12b0/0x19d0 drivers/usb/core/hub.c:2545
As analyzed by Khazhy Kumykov, the cause of this bug is a race between
read\_descriptors() and hub\_port\_init(): The first routine uses a field
in udev->descriptor, not expecting it to change, while the second
overwrites it.
Prior to commit 45bf39f8df7f ("USB: core: Don't hold device lock while
reading the "descriptors" sysfs file") this race couldn't occur,
because the routines were mutually exclusive thanks to the device
locking. Removing that locking from read\_descriptors() exposed it to
the race.
The best way to fix the bug is to keep hub\_port\_init() from changing
udev->descriptor once udev has been initialized and registered.
Drivers expect the descriptors stored in the kernel to be immutable;
we should not undermine this expectation. In fact, this change should
have been made long ago.
So now hub\_port\_init() will take an additional argument, specifying a
buffer in which to store the device descriptor it reads. (If udev has
not yet been initialized, the buffer pointer will be NULL and then
hub\_port\_init() will store the device descriptor in udev as before.)
This eliminates the data race responsible for the out-of-bounds read.
The changes to hub\_port\_init() appear more extensive than they really
are, because of indentation changes resulting from an attempt to avoid
writing to other parts of the usb\_device structure after it has been
initialized. Similar changes should be made to the code that reads
the BOS descriptor, but that can be handled in a separate patch later
on. This patch is sufficient to fix the bug found by syzbot.
Reported-and-tested-by: syzbot+18996170f8096c6174d0@syzkaller.appspotmail.com
Closes: https://lore.kernel.org/linux-usb/000000000000c0ffe505fe86c9ca@google.com/#r
Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
Cc: Khazhy Kumykov <khazhy@google.com>
Fixes: 45bf39f8df7f ("USB: core: Don't hold device lock while reading the "descriptors" sysfs file")
Cc: stable@vger.kernel.org
Link: [https://lore.kernel.org/r/b958b47a-9a46-4c22-a9f9-e42e42c31251@rowland.harvard.edu](https://lore.kernel.org/r/b958b47a-9a46-4c22-a9f9-e42e42c31251%40rowland.harvard.edu)
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=8186596a663506b1124bede9fde6f243ef9f37ee)

| -rw-r--r-- | [drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/usb/core/hub.c?id=8186596a663506b1124bede9fde6f243ef9f37ee) | 114 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 70 insertions, 44 deletions

| diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.cindex ac58dcb409a3ed..cdfbbb5a2363f4 100644--- a/[drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/core/hub.c?id=d309fa69c2e3c5e6134ac9386f833f683e66ad1a)+++ b/[drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/core/hub.c?id=8186596a663506b1124bede9fde6f243ef9f37ee)@@ -4736,10 +4736,17 @@ static int get\_bMaxPacketSize0(struct usb\_device \*udev, \* the port lock. For a newly detected device that is not accessible \* through any global pointers, it's not necessary to lock the device, \* but it is still necessary to lock the port.+ \*+ \* For a newly detected device, @dev\_descr must be NULL. The device+ \* descriptor retrieved from the device will then be stored in+ \* @udev->descriptor. For an already existing device, @dev\_descr+ \* must be non-NULL. The device descriptor will be stored there,+ \* not in @udev->descriptor, because descriptors for registered+ \* devices are meant to be immutable. \*/ static int hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1,- int retry\_counter)+ int retry\_counter, struct usb\_device\_descriptor \*dev\_descr) { struct usb\_device \*hdev = hub->hdev; struct usb\_hcd \*hcd = bus\_to\_hcd(hdev->bus);@@ -4751,6 +4758,7 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, int devnum = udev->devnum; const char \*driver\_name; bool do\_new\_scheme;+ const bool initial = !dev\_descr; int maxp0; struct usb\_device\_descriptor \*buf, \*descr; @@ -4789,32 +4797,34 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, } oldspeed = udev->speed; - /\* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...- \* it's fixed size except for full speed devices.- \* For Wireless USB devices, ep0 max packet is always 512 (tho- \* reported as 0xff in the device descriptor). WUSB1.0[4.8.1].- \*/- switch (udev->speed) {- case USB\_SPEED\_SUPER\_PLUS:- case USB\_SPEED\_SUPER:- case USB\_SPEED\_WIRELESS: /\* fixed at 512 \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(512);- break;- case USB\_SPEED\_HIGH: /\* fixed at 64 \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);- break;- case USB\_SPEED\_FULL: /\* 8, 16, 32, or 64 \*/- /\* to determine the ep0 maxpacket size, try to read- \* the device descriptor to get bMaxPacketSize0 and- \* then correct our initial guess.+ if (initial) {+ /\* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...+ \* it's fixed size except for full speed devices.+ \* For Wireless USB devices, ep0 max packet is always 512 (tho+ \* reported as 0xff in the device descriptor). WUSB1.0[4.8.1]. \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);- break;- case USB\_SPEED\_LOW: /\* fixed at 8 \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(8);- break;- default:- goto fail;+ switch (udev->speed) {+ case USB\_SPEED\_SUPER\_PLUS:+ case USB\_SPEED\_SUPER:+ case USB\_SPEED\_WIRELESS: /\* fixed at 512 \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(512);+ break;+ case USB\_SPEED\_HIGH: /\* fixed at 64 \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);+ break;+ case USB\_SPEED\_FULL: /\* 8, 16, 32, or 64 \*/+ /\* to determine the ep0 maxpacket size, try to read+ \* the device descriptor to get bMaxPacketSize0 and+ \* then correct our initial guess.+ \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);+ break;+ case USB\_SPEED\_LOW: /\* fixed at 8 \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(8);+ break;+ default:+ goto fail;+ } }  if (udev->speed == USB\_SPEED\_WIRELESS)@@ -4837,22 +4847,24 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, if (udev->speed < USB\_SPEED\_SUPER) dev\_info(&udev->dev, "%s %s USB device number %d using %s\n",- (udev->config) ? "reset" : "new", speed,+ (initial ? "new" : "reset"), speed, devnum, driver\_name); - /\* Set up TT records, if needed \*/- if (hdev->tt) {- udev->tt = hdev->tt;- udev->ttport = hdev->ttport;- } else if (udev->speed != USB\_SPEED\_HIGH- && hdev->speed == USB\_SPEED\_HIGH) {- if (!hub->tt.hub) {- dev\_err(&udev->dev, "parent hub has no TT\n");- retval = -EINVAL;- goto fail;+ if (initial) {+ /\* Set up TT records, if needed \*/+ if (hdev->tt) {+ udev->tt = hdev->tt;+ udev->ttport = hdev->ttport;+ } else if (udev->speed != USB\_SPEED\_HIGH+ && hdev->speed == USB\_SPEED\_HIGH) {+ if (!hub->tt.hub) {+ dev\_err(&udev->dev, "parent hub has no TT\n");+ retval = -EINVAL;+ goto fail;+ }+ udev->tt = &hub->tt;+ udev->ttport = port1; }- udev->tt = &hub->tt;- udev->ttport = port1; }  /\* Why interleave GET\_DESCRIPTOR and SET\_ADDRESS this way?@@ -4881,6 +4893,12 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1,  maxp0 = get\_bMaxPacketSize0(udev, buf, GET\_DESCRIPTOR\_BUFSIZE, retries == 0);+ if (maxp0 > 0 && !initial &&+ maxp0 != udev->descriptor.bMaxPacketSize0) {+ dev\_err(&udev->dev, "device reset changed ep0 maxpacket size!\n");+ retval = -ENODEV;+ goto fail;+ }  retval = hub\_port\_reset(hub, port1, udev, delay, false); if (retval < 0) /\* error or disconnect \*/@@ -4954,6 +4972,12 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, } else { u32 delay; + if (!initial && maxp0 != udev->descriptor.bMaxPacketSize0) {+ dev\_err(&udev->dev, "device reset changed ep0 maxpacket size!\n");+ retval = -ENODEV;+ goto fail;+ }+ delay = udev->parent->hub\_delay; udev->hub\_delay = min\_t(u32, delay, USB\_TP\_TRANSMISSION\_DELAY\_MAX);@@ -4997,7 +5021,10 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, retval); goto fail; }- udev->descriptor = \*descr;+ if (initial)+ udev->descriptor = \*descr;+ else+ \*dev\_descr = \*descr; kfree(descr);  /\*@@ -5302,7 +5329,7 @@ static void hub\_port\_connect(struct usb\_hub \*hub, int port1, u16 portstatus, }  /\* reset (non-USB 3.0 devices) and get descriptor \*/- status = hub\_port\_init(hub, udev, port1, i);+ status = hub\_port\_init(hub, udev, port1, i, NULL); if (status < 0) goto loop; @@ -5928,7 +5955,7 @@ static int usb\_reset\_and\_verify\_device(struct usb\_device \*udev) struct usb\_device \*parent\_hdev = udev->parent; struct usb\_hub \*parent\_hub; struct usb\_hcd \*hcd = bus\_to\_hcd(udev->bus);- struct usb\_device\_descriptor descriptor = udev->descriptor;+ struct usb\_device\_descriptor descriptor; struct usb\_host\_bos \*bos; int i, j, ret = 0; int port1 = udev->portnum;@@ -5960,7 +5987,7 @@ static int usb\_reset\_and\_verify\_device(struct usb\_device \*udev) /\* ep0 maxpacket size may change; let the HCD know about it. \* Other endpoints will be handled by re-enumeration. \*/ usb\_ep0\_reinit(udev);- ret = hub\_port\_init(parent\_hub, udev, port1, i);+ ret = hub\_port\_init(parent\_hub, udev, port1, i, &descriptor); if (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV) break; }@@ -5972,7 +5999,6 @@ static int usb\_reset\_and\_verify\_device(struct usb\_device \*udev) /\* Device might have changed firmware (DFU or similar) \*/ if (descriptors\_changed(udev, &descriptor, bos)) { dev\_info(&udev->dev, "device firmware changed\n");- udev->descriptor = descriptor; /\* for disconnect() calls \*/ goto re\_enumerate; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 02:49:28 +0000



=== Content from git.kernel.org_d03e70aa_20250111_025054.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Alan Stern <stern@rowland.harvard.edu> | 2023-08-04 15:14:14 -0400 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2023-08-08 10:45:32 +0200 |
| commit | [ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b)) | |
| tree | [7b422b0776b0070f995cd02215f85561f7d9b207](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b) | |
| parent | [de28e469da75359a2bb8cd8778b78aa64b1be1f4](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=de28e469da75359a2bb8cd8778b78aa64b1be1f4) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b&id2=de28e469da75359a2bb8cd8778b78aa64b1be1f4)) | |
| download | [linux-ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b.tar.gz) | |

USB: core: Fix race by not overwriting udev->descriptor in hub\_port\_init()Syzbot reported an out-of-bounds read in sysfs.c:read\_descriptors():
BUG: KASAN: slab-out-of-bounds in read\_descriptors+0x263/0x280 drivers/usb/core/sysfs.c:883
Read of size 8 at addr ffff88801e78b8c8 by task udevd/5011
CPU: 0 PID: 5011 Comm: udevd Not tainted 6.4.0-rc6-syzkaller-00195-g40f71e7cd3c6 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/27/2023
Call Trace:
<TASK>
\_\_dump\_stack lib/dump\_stack.c:88 [inline]
dump\_stack\_lvl+0xd9/0x150 lib/dump\_stack.c:106
print\_address\_description.constprop.0+0x2c/0x3c0 mm/kasan/report.c:351
print\_report mm/kasan/report.c:462 [inline]
kasan\_report+0x11c/0x130 mm/kasan/report.c:572
read\_descriptors+0x263/0x280 drivers/usb/core/sysfs.c:883
...
Allocated by task 758:
...
\_\_do\_kmalloc\_node mm/slab\_common.c:966 [inline]
\_\_kmalloc+0x5e/0x190 mm/slab\_common.c:979
kmalloc include/linux/slab.h:563 [inline]
kzalloc include/linux/slab.h:680 [inline]
usb\_get\_configuration+0x1f7/0x5170 drivers/usb/core/config.c:887
usb\_enumerate\_device drivers/usb/core/hub.c:2407 [inline]
usb\_new\_device+0x12b0/0x19d0 drivers/usb/core/hub.c:2545
As analyzed by Khazhy Kumykov, the cause of this bug is a race between
read\_descriptors() and hub\_port\_init(): The first routine uses a field
in udev->descriptor, not expecting it to change, while the second
overwrites it.
Prior to commit 45bf39f8df7f ("USB: core: Don't hold device lock while
reading the "descriptors" sysfs file") this race couldn't occur,
because the routines were mutually exclusive thanks to the device
locking. Removing that locking from read\_descriptors() exposed it to
the race.
The best way to fix the bug is to keep hub\_port\_init() from changing
udev->descriptor once udev has been initialized and registered.
Drivers expect the descriptors stored in the kernel to be immutable;
we should not undermine this expectation. In fact, this change should
have been made long ago.
So now hub\_port\_init() will take an additional argument, specifying a
buffer in which to store the device descriptor it reads. (If udev has
not yet been initialized, the buffer pointer will be NULL and then
hub\_port\_init() will store the device descriptor in udev as before.)
This eliminates the data race responsible for the out-of-bounds read.
The changes to hub\_port\_init() appear more extensive than they really
are, because of indentation changes resulting from an attempt to avoid
writing to other parts of the usb\_device structure after it has been
initialized. Similar changes should be made to the code that reads
the BOS descriptor, but that can be handled in a separate patch later
on. This patch is sufficient to fix the bug found by syzbot.
Reported-and-tested-by: syzbot+18996170f8096c6174d0@syzkaller.appspotmail.com
Closes: https://lore.kernel.org/linux-usb/000000000000c0ffe505fe86c9ca@google.com/#r
Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
Cc: Khazhy Kumykov <khazhy@google.com>
Fixes: 45bf39f8df7f ("USB: core: Don't hold device lock while reading the "descriptors" sysfs file")
Cc: stable@vger.kernel.org
Link: [https://lore.kernel.org/r/b958b47a-9a46-4c22-a9f9-e42e42c31251@rowland.harvard.edu](https://lore.kernel.org/r/b958b47a-9a46-4c22-a9f9-e42e42c31251%40rowland.harvard.edu)
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b)

| -rw-r--r-- | [drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/usb/core/hub.c?id=ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b) | 114 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 70 insertions, 44 deletions

| diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.cindex 9279c8ccbcf250..878913f4b4b3c7 100644--- a/[drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/core/hub.c?id=de28e469da75359a2bb8cd8778b78aa64b1be1f4)+++ b/[drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/core/hub.c?id=ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b)@@ -4816,10 +4816,17 @@ static int get\_bMaxPacketSize0(struct usb\_device \*udev, \* the port lock. For a newly detected device that is not accessible \* through any global pointers, it's not necessary to lock the device, \* but it is still necessary to lock the port.+ \*+ \* For a newly detected device, @dev\_descr must be NULL. The device+ \* descriptor retrieved from the device will then be stored in+ \* @udev->descriptor. For an already existing device, @dev\_descr+ \* must be non-NULL. The device descriptor will be stored there,+ \* not in @udev->descriptor, because descriptors for registered+ \* devices are meant to be immutable. \*/ static int hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1,- int retry\_counter)+ int retry\_counter, struct usb\_device\_descriptor \*dev\_descr) { struct usb\_device \*hdev = hub->hdev; struct usb\_hcd \*hcd = bus\_to\_hcd(hdev->bus);@@ -4831,6 +4838,7 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, int devnum = udev->devnum; const char \*driver\_name; bool do\_new\_scheme;+ const bool initial = !dev\_descr; int maxp0; struct usb\_device\_descriptor \*buf, \*descr; @@ -4869,32 +4877,34 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, } oldspeed = udev->speed; - /\* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...- \* it's fixed size except for full speed devices.- \* For Wireless USB devices, ep0 max packet is always 512 (tho- \* reported as 0xff in the device descriptor). WUSB1.0[4.8.1].- \*/- switch (udev->speed) {- case USB\_SPEED\_SUPER\_PLUS:- case USB\_SPEED\_SUPER:- case USB\_SPEED\_WIRELESS: /\* fixed at 512 \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(512);- break;- case USB\_SPEED\_HIGH: /\* fixed at 64 \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);- break;- case USB\_SPEED\_FULL: /\* 8, 16, 32, or 64 \*/- /\* to determine the ep0 maxpacket size, try to read- \* the device descriptor to get bMaxPacketSize0 and- \* then correct our initial guess.+ if (initial) {+ /\* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...+ \* it's fixed size except for full speed devices.+ \* For Wireless USB devices, ep0 max packet is always 512 (tho+ \* reported as 0xff in the device descriptor). WUSB1.0[4.8.1]. \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);- break;- case USB\_SPEED\_LOW: /\* fixed at 8 \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(8);- break;- default:- goto fail;+ switch (udev->speed) {+ case USB\_SPEED\_SUPER\_PLUS:+ case USB\_SPEED\_SUPER:+ case USB\_SPEED\_WIRELESS: /\* fixed at 512 \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(512);+ break;+ case USB\_SPEED\_HIGH: /\* fixed at 64 \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);+ break;+ case USB\_SPEED\_FULL: /\* 8, 16, 32, or 64 \*/+ /\* to determine the ep0 maxpacket size, try to read+ \* the device descriptor to get bMaxPacketSize0 and+ \* then correct our initial guess.+ \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);+ break;+ case USB\_SPEED\_LOW: /\* fixed at 8 \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(8);+ break;+ default:+ goto fail;+ } }  if (udev->speed == USB\_SPEED\_WIRELESS)@@ -4917,22 +4927,24 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, if (udev->speed < USB\_SPEED\_SUPER) dev\_info(&udev->dev, "%s %s USB device number %d using %s\n",- (udev->config) ? "reset" : "new", speed,+ (initial ? "new" : "reset"), speed, devnum, driver\_name); - /\* Set up TT records, if needed \*/- if (hdev->tt) {- udev->tt = hdev->tt;- udev->ttport = hdev->ttport;- } else if (udev->speed != USB\_SPEED\_HIGH- && hdev->speed == USB\_SPEED\_HIGH) {- if (!hub->tt.hub) {- dev\_err(&udev->dev, "parent hub has no TT\n");- retval = -EINVAL;- goto fail;+ if (initial) {+ /\* Set up TT records, if needed \*/+ if (hdev->tt) {+ udev->tt = hdev->tt;+ udev->ttport = hdev->ttport;+ } else if (udev->speed != USB\_SPEED\_HIGH+ && hdev->speed == USB\_SPEED\_HIGH) {+ if (!hub->tt.hub) {+ dev\_err(&udev->dev, "parent hub has no TT\n");+ retval = -EINVAL;+ goto fail;+ }+ udev->tt = &hub->tt;+ udev->ttport = port1; }- udev->tt = &hub->tt;- udev->ttport = port1; }  /\* Why interleave GET\_DESCRIPTOR and SET\_ADDRESS this way?@@ -4966,6 +4978,12 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1,  maxp0 = get\_bMaxPacketSize0(udev, buf, GET\_DESCRIPTOR\_BUFSIZE, retries == 0);+ if (maxp0 > 0 && !initial &&+ maxp0 != udev->descriptor.bMaxPacketSize0) {+ dev\_err(&udev->dev, "device reset changed ep0 maxpacket size!\n");+ retval = -ENODEV;+ goto fail;+ }  retval = hub\_port\_reset(hub, port1, udev, delay, false); if (retval < 0) /\* error or disconnect \*/@@ -5039,6 +5057,12 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, } else { u32 delay; + if (!initial && maxp0 != udev->descriptor.bMaxPacketSize0) {+ dev\_err(&udev->dev, "device reset changed ep0 maxpacket size!\n");+ retval = -ENODEV;+ goto fail;+ }+ delay = udev->parent->hub\_delay; udev->hub\_delay = min\_t(u32, delay, USB\_TP\_TRANSMISSION\_DELAY\_MAX);@@ -5082,7 +5106,10 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, retval); goto fail; }- udev->descriptor = \*descr;+ if (initial)+ udev->descriptor = \*descr;+ else+ \*dev\_descr = \*descr; kfree(descr);  /\*@@ -5392,7 +5419,7 @@ static void hub\_port\_connect(struct usb\_hub \*hub, int port1, u16 portstatus, }  /\* reset (non-USB 3.0 devices) and get descriptor \*/- status = hub\_port\_init(hub, udev, port1, i);+ status = hub\_port\_init(hub, udev, port1, i, NULL); if (status < 0) goto loop; @@ -6022,7 +6049,7 @@ static int usb\_reset\_and\_verify\_device(struct usb\_device \*udev) struct usb\_device \*parent\_hdev = udev->parent; struct usb\_hub \*parent\_hub; struct usb\_hcd \*hcd = bus\_to\_hcd(udev->bus);- struct usb\_device\_descriptor descriptor = udev->descriptor;+ struct usb\_device\_descriptor descriptor; struct usb\_host\_bos \*bos; int i, j, ret = 0; int port1 = udev->portnum;@@ -6058,7 +6085,7 @@ static int usb\_reset\_and\_verify\_device(struct usb\_device \*udev) /\* ep0 maxpacket size may change; let the HCD know about it. \* Other endpoints will be handled by re-enumeration. \*/ usb\_ep0\_reinit(udev);- ret = hub\_port\_init(parent\_hub, udev, port1, i);+ ret = hub\_port\_init(parent\_hub, udev, port1, i, &descriptor); if (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV) break; }@@ -6070,7 +6097,6 @@ static int usb\_reset\_and\_verify\_device(struct usb\_device \*udev) /\* Device might have changed firmware (DFU or similar) \*/ if (descriptors\_changed(udev, &descriptor, bos)) { dev\_info(&udev->dev, "device firmware changed\n");- udev->descriptor = descriptor; /\* for disconnect() calls \*/ goto re\_enumerate; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 02:49:31 +0000



=== Content from git.kernel.org_adc27ff2_20250111_025051.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=9d241c5d9a9b7ad95c90c6520272fe404d5ac88f)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=9d241c5d9a9b7ad95c90c6520272fe404d5ac88f)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9d241c5d9a9b7ad95c90c6520272fe404d5ac88f)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9d241c5d9a9b7ad95c90c6520272fe404d5ac88f)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Alan Stern <stern@rowland.harvard.edu> | 2023-08-04 15:14:14 -0400 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2023-09-19 12:20:23 +0200 |
| commit | [9d241c5d9a9b7ad95c90c6520272fe404d5ac88f](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9d241c5d9a9b7ad95c90c6520272fe404d5ac88f) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=9d241c5d9a9b7ad95c90c6520272fe404d5ac88f)) | |
| tree | [3525599eb2dffb72a9fb3ea4649faab7e56ab53d](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=9d241c5d9a9b7ad95c90c6520272fe404d5ac88f) | |
| parent | [6ceffc2ecf3de8acdce2202db1c32d8c520a230e](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6ceffc2ecf3de8acdce2202db1c32d8c520a230e) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9d241c5d9a9b7ad95c90c6520272fe404d5ac88f&id2=6ceffc2ecf3de8acdce2202db1c32d8c520a230e)) | |
| download | [linux-9d241c5d9a9b7ad95c90c6520272fe404d5ac88f.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-9d241c5d9a9b7ad95c90c6520272fe404d5ac88f.tar.gz) | |

USB: core: Fix race by not overwriting udev->descriptor in hub\_port\_init()commit ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b upstream.
Syzbot reported an out-of-bounds read in sysfs.c:read\_descriptors():
BUG: KASAN: slab-out-of-bounds in read\_descriptors+0x263/0x280 drivers/usb/core/sysfs.c:883
Read of size 8 at addr ffff88801e78b8c8 by task udevd/5011
CPU: 0 PID: 5011 Comm: udevd Not tainted 6.4.0-rc6-syzkaller-00195-g40f71e7cd3c6 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/27/2023
Call Trace:
<TASK>
\_\_dump\_stack lib/dump\_stack.c:88 [inline]
dump\_stack\_lvl+0xd9/0x150 lib/dump\_stack.c:106
print\_address\_description.constprop.0+0x2c/0x3c0 mm/kasan/report.c:351
print\_report mm/kasan/report.c:462 [inline]
kasan\_report+0x11c/0x130 mm/kasan/report.c:572
read\_descriptors+0x263/0x280 drivers/usb/core/sysfs.c:883
...
Allocated by task 758:
...
\_\_do\_kmalloc\_node mm/slab\_common.c:966 [inline]
\_\_kmalloc+0x5e/0x190 mm/slab\_common.c:979
kmalloc include/linux/slab.h:563 [inline]
kzalloc include/linux/slab.h:680 [inline]
usb\_get\_configuration+0x1f7/0x5170 drivers/usb/core/config.c:887
usb\_enumerate\_device drivers/usb/core/hub.c:2407 [inline]
usb\_new\_device+0x12b0/0x19d0 drivers/usb/core/hub.c:2545
As analyzed by Khazhy Kumykov, the cause of this bug is a race between
read\_descriptors() and hub\_port\_init(): The first routine uses a field
in udev->descriptor, not expecting it to change, while the second
overwrites it.
Prior to commit 45bf39f8df7f ("USB: core: Don't hold device lock while
reading the "descriptors" sysfs file") this race couldn't occur,
because the routines were mutually exclusive thanks to the device
locking. Removing that locking from read\_descriptors() exposed it to
the race.
The best way to fix the bug is to keep hub\_port\_init() from changing
udev->descriptor once udev has been initialized and registered.
Drivers expect the descriptors stored in the kernel to be immutable;
we should not undermine this expectation. In fact, this change should
have been made long ago.
So now hub\_port\_init() will take an additional argument, specifying a
buffer in which to store the device descriptor it reads. (If udev has
not yet been initialized, the buffer pointer will be NULL and then
hub\_port\_init() will store the device descriptor in udev as before.)
This eliminates the data race responsible for the out-of-bounds read.
The changes to hub\_port\_init() appear more extensive than they really
are, because of indentation changes resulting from an attempt to avoid
writing to other parts of the usb\_device structure after it has been
initialized. Similar changes should be made to the code that reads
the BOS descriptor, but that can be handled in a separate patch later
on. This patch is sufficient to fix the bug found by syzbot.
Reported-and-tested-by: syzbot+18996170f8096c6174d0@syzkaller.appspotmail.com
Closes: https://lore.kernel.org/linux-usb/000000000000c0ffe505fe86c9ca@google.com/#r
Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
Cc: Khazhy Kumykov <khazhy@google.com>
Fixes: 45bf39f8df7f ("USB: core: Don't hold device lock while reading the "descriptors" sysfs file")
Cc: stable@vger.kernel.org
Link: [https://lore.kernel.org/r/b958b47a-9a46-4c22-a9f9-e42e42c31251@rowland.harvard.edu](https://lore.kernel.org/r/b958b47a-9a46-4c22-a9f9-e42e42c31251%40rowland.harvard.edu)
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9d241c5d9a9b7ad95c90c6520272fe404d5ac88f)

| -rw-r--r-- | [drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/usb/core/hub.c?id=9d241c5d9a9b7ad95c90c6520272fe404d5ac88f) | 114 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 70 insertions, 44 deletions

| diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.cindex 0945cd21669efe..3ce428503e58ae 100644--- a/[drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/core/hub.c?id=6ceffc2ecf3de8acdce2202db1c32d8c520a230e)+++ b/[drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/core/hub.c?id=9d241c5d9a9b7ad95c90c6520272fe404d5ac88f)@@ -4669,10 +4669,17 @@ static int get\_bMaxPacketSize0(struct usb\_device \*udev, \* the port lock. For a newly detected device that is not accessible \* through any global pointers, it's not necessary to lock the device, \* but it is still necessary to lock the port.+ \*+ \* For a newly detected device, @dev\_descr must be NULL. The device+ \* descriptor retrieved from the device will then be stored in+ \* @udev->descriptor. For an already existing device, @dev\_descr+ \* must be non-NULL. The device descriptor will be stored there,+ \* not in @udev->descriptor, because descriptors for registered+ \* devices are meant to be immutable. \*/ static int hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1,- int retry\_counter)+ int retry\_counter, struct usb\_device\_descriptor \*dev\_descr) { struct usb\_device \*hdev = hub->hdev; struct usb\_hcd \*hcd = bus\_to\_hcd(hdev->bus);@@ -4684,6 +4691,7 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, int devnum = udev->devnum; const char \*driver\_name; bool do\_new\_scheme;+ const bool initial = !dev\_descr; int maxp0; struct usb\_device\_descriptor \*buf, \*descr; @@ -4722,32 +4730,34 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, } oldspeed = udev->speed; - /\* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...- \* it's fixed size except for full speed devices.- \* For Wireless USB devices, ep0 max packet is always 512 (tho- \* reported as 0xff in the device descriptor). WUSB1.0[4.8.1].- \*/- switch (udev->speed) {- case USB\_SPEED\_SUPER\_PLUS:- case USB\_SPEED\_SUPER:- case USB\_SPEED\_WIRELESS: /\* fixed at 512 \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(512);- break;- case USB\_SPEED\_HIGH: /\* fixed at 64 \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);- break;- case USB\_SPEED\_FULL: /\* 8, 16, 32, or 64 \*/- /\* to determine the ep0 maxpacket size, try to read- \* the device descriptor to get bMaxPacketSize0 and- \* then correct our initial guess.+ if (initial) {+ /\* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...+ \* it's fixed size except for full speed devices.+ \* For Wireless USB devices, ep0 max packet is always 512 (tho+ \* reported as 0xff in the device descriptor). WUSB1.0[4.8.1]. \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);- break;- case USB\_SPEED\_LOW: /\* fixed at 8 \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(8);- break;- default:- goto fail;+ switch (udev->speed) {+ case USB\_SPEED\_SUPER\_PLUS:+ case USB\_SPEED\_SUPER:+ case USB\_SPEED\_WIRELESS: /\* fixed at 512 \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(512);+ break;+ case USB\_SPEED\_HIGH: /\* fixed at 64 \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);+ break;+ case USB\_SPEED\_FULL: /\* 8, 16, 32, or 64 \*/+ /\* to determine the ep0 maxpacket size, try to read+ \* the device descriptor to get bMaxPacketSize0 and+ \* then correct our initial guess.+ \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);+ break;+ case USB\_SPEED\_LOW: /\* fixed at 8 \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(8);+ break;+ default:+ goto fail;+ } }  if (udev->speed == USB\_SPEED\_WIRELESS)@@ -4770,22 +4780,24 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, if (udev->speed < USB\_SPEED\_SUPER) dev\_info(&udev->dev, "%s %s USB device number %d using %s\n",- (udev->config) ? "reset" : "new", speed,+ (initial ? "new" : "reset"), speed, devnum, driver\_name); - /\* Set up TT records, if needed \*/- if (hdev->tt) {- udev->tt = hdev->tt;- udev->ttport = hdev->ttport;- } else if (udev->speed != USB\_SPEED\_HIGH- && hdev->speed == USB\_SPEED\_HIGH) {- if (!hub->tt.hub) {- dev\_err(&udev->dev, "parent hub has no TT\n");- retval = -EINVAL;- goto fail;+ if (initial) {+ /\* Set up TT records, if needed \*/+ if (hdev->tt) {+ udev->tt = hdev->tt;+ udev->ttport = hdev->ttport;+ } else if (udev->speed != USB\_SPEED\_HIGH+ && hdev->speed == USB\_SPEED\_HIGH) {+ if (!hub->tt.hub) {+ dev\_err(&udev->dev, "parent hub has no TT\n");+ retval = -EINVAL;+ goto fail;+ }+ udev->tt = &hub->tt;+ udev->ttport = port1; }- udev->tt = &hub->tt;- udev->ttport = port1; }  /\* Why interleave GET\_DESCRIPTOR and SET\_ADDRESS this way?@@ -4814,6 +4826,12 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1,  maxp0 = get\_bMaxPacketSize0(udev, buf, GET\_DESCRIPTOR\_BUFSIZE, retries == 0);+ if (maxp0 > 0 && !initial &&+ maxp0 != udev->descriptor.bMaxPacketSize0) {+ dev\_err(&udev->dev, "device reset changed ep0 maxpacket size!\n");+ retval = -ENODEV;+ goto fail;+ }  retval = hub\_port\_reset(hub, port1, udev, delay, false); if (retval < 0) /\* error or disconnect \*/@@ -4883,6 +4901,12 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, } else { u32 delay; + if (!initial && maxp0 != udev->descriptor.bMaxPacketSize0) {+ dev\_err(&udev->dev, "device reset changed ep0 maxpacket size!\n");+ retval = -ENODEV;+ goto fail;+ }+ delay = udev->parent->hub\_delay; udev->hub\_delay = min\_t(u32, delay, USB\_TP\_TRANSMISSION\_DELAY\_MAX);@@ -4926,7 +4950,10 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, retval); goto fail; }- udev->descriptor = \*descr;+ if (initial)+ udev->descriptor = \*descr;+ else+ \*dev\_descr = \*descr; kfree(descr);  /\*@@ -5229,7 +5256,7 @@ static void hub\_port\_connect(struct usb\_hub \*hub, int port1, u16 portstatus, }  /\* reset (non-USB 3.0 devices) and get descriptor \*/- status = hub\_port\_init(hub, udev, port1, i);+ status = hub\_port\_init(hub, udev, port1, i, NULL); if (status < 0) goto loop; @@ -5845,7 +5872,7 @@ static int usb\_reset\_and\_verify\_device(struct usb\_device \*udev) struct usb\_device \*parent\_hdev = udev->parent; struct usb\_hub \*parent\_hub; struct usb\_hcd \*hcd = bus\_to\_hcd(udev->bus);- struct usb\_device\_descriptor descriptor = udev->descriptor;+ struct usb\_device\_descriptor descriptor; struct usb\_host\_bos \*bos; int i, j, ret = 0; int port1 = udev->portnum;@@ -5887,7 +5914,7 @@ static int usb\_reset\_and\_verify\_device(struct usb\_device \*udev) /\* ep0 maxpacket size may change; let the HCD know about it. \* Other endpoints will be handled by re-enumeration. \*/ usb\_ep0\_reinit(udev);- ret = hub\_port\_init(parent\_hub, udev, port1, i);+ ret = hub\_port\_init(parent\_hub, udev, port1, i, &descriptor); if (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV) break; }@@ -5899,7 +5926,6 @@ static int usb\_reset\_and\_verify\_device(struct usb\_device \*udev) /\* Device might have changed firmware (DFU or similar) \*/ if (descriptors\_changed(udev, &descriptor, bos)) { dev\_info(&udev->dev, "device firmware changed\n");- udev->descriptor = descriptor; /\* for disconnect() calls \*/ goto re\_enumerate; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 02:49:29 +0000



=== Content from git.kernel.org_caf45cbe_20250111_025050.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=7fe9d87996062f5eb0ca476ad0257f79bf43aaf5)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=7fe9d87996062f5eb0ca476ad0257f79bf43aaf5)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7fe9d87996062f5eb0ca476ad0257f79bf43aaf5)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7fe9d87996062f5eb0ca476ad0257f79bf43aaf5)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Alan Stern <stern@rowland.harvard.edu> | 2023-08-04 15:14:14 -0400 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2023-09-19 12:22:53 +0200 |
| commit | [7fe9d87996062f5eb0ca476ad0257f79bf43aaf5](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7fe9d87996062f5eb0ca476ad0257f79bf43aaf5) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=7fe9d87996062f5eb0ca476ad0257f79bf43aaf5)) | |
| tree | [46a1c2c5d5574be91c9b6a3746d64105d5bdace9](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=7fe9d87996062f5eb0ca476ad0257f79bf43aaf5) | |
| parent | [eda9a296658203b1cc07d777c19c8c9eac6d0d17](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=eda9a296658203b1cc07d777c19c8c9eac6d0d17) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7fe9d87996062f5eb0ca476ad0257f79bf43aaf5&id2=eda9a296658203b1cc07d777c19c8c9eac6d0d17)) | |
| download | [linux-7fe9d87996062f5eb0ca476ad0257f79bf43aaf5.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-7fe9d87996062f5eb0ca476ad0257f79bf43aaf5.tar.gz) | |

USB: core: Fix race by not overwriting udev->descriptor in hub\_port\_init()commit ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b upstream.
Syzbot reported an out-of-bounds read in sysfs.c:read\_descriptors():
BUG: KASAN: slab-out-of-bounds in read\_descriptors+0x263/0x280 drivers/usb/core/sysfs.c:883
Read of size 8 at addr ffff88801e78b8c8 by task udevd/5011
CPU: 0 PID: 5011 Comm: udevd Not tainted 6.4.0-rc6-syzkaller-00195-g40f71e7cd3c6 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/27/2023
Call Trace:
<TASK>
\_\_dump\_stack lib/dump\_stack.c:88 [inline]
dump\_stack\_lvl+0xd9/0x150 lib/dump\_stack.c:106
print\_address\_description.constprop.0+0x2c/0x3c0 mm/kasan/report.c:351
print\_report mm/kasan/report.c:462 [inline]
kasan\_report+0x11c/0x130 mm/kasan/report.c:572
read\_descriptors+0x263/0x280 drivers/usb/core/sysfs.c:883
...
Allocated by task 758:
...
\_\_do\_kmalloc\_node mm/slab\_common.c:966 [inline]
\_\_kmalloc+0x5e/0x190 mm/slab\_common.c:979
kmalloc include/linux/slab.h:563 [inline]
kzalloc include/linux/slab.h:680 [inline]
usb\_get\_configuration+0x1f7/0x5170 drivers/usb/core/config.c:887
usb\_enumerate\_device drivers/usb/core/hub.c:2407 [inline]
usb\_new\_device+0x12b0/0x19d0 drivers/usb/core/hub.c:2545
As analyzed by Khazhy Kumykov, the cause of this bug is a race between
read\_descriptors() and hub\_port\_init(): The first routine uses a field
in udev->descriptor, not expecting it to change, while the second
overwrites it.
Prior to commit 45bf39f8df7f ("USB: core: Don't hold device lock while
reading the "descriptors" sysfs file") this race couldn't occur,
because the routines were mutually exclusive thanks to the device
locking. Removing that locking from read\_descriptors() exposed it to
the race.
The best way to fix the bug is to keep hub\_port\_init() from changing
udev->descriptor once udev has been initialized and registered.
Drivers expect the descriptors stored in the kernel to be immutable;
we should not undermine this expectation. In fact, this change should
have been made long ago.
So now hub\_port\_init() will take an additional argument, specifying a
buffer in which to store the device descriptor it reads. (If udev has
not yet been initialized, the buffer pointer will be NULL and then
hub\_port\_init() will store the device descriptor in udev as before.)
This eliminates the data race responsible for the out-of-bounds read.
The changes to hub\_port\_init() appear more extensive than they really
are, because of indentation changes resulting from an attempt to avoid
writing to other parts of the usb\_device structure after it has been
initialized. Similar changes should be made to the code that reads
the BOS descriptor, but that can be handled in a separate patch later
on. This patch is sufficient to fix the bug found by syzbot.
Reported-and-tested-by: syzbot+18996170f8096c6174d0@syzkaller.appspotmail.com
Closes: https://lore.kernel.org/linux-usb/000000000000c0ffe505fe86c9ca@google.com/#r
Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
Cc: Khazhy Kumykov <khazhy@google.com>
Fixes: 45bf39f8df7f ("USB: core: Don't hold device lock while reading the "descriptors" sysfs file")
Cc: stable@vger.kernel.org
Link: [https://lore.kernel.org/r/b958b47a-9a46-4c22-a9f9-e42e42c31251@rowland.harvard.edu](https://lore.kernel.org/r/b958b47a-9a46-4c22-a9f9-e42e42c31251%40rowland.harvard.edu)
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7fe9d87996062f5eb0ca476ad0257f79bf43aaf5)

| -rw-r--r-- | [drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/usb/core/hub.c?id=7fe9d87996062f5eb0ca476ad0257f79bf43aaf5) | 114 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 70 insertions, 44 deletions

| diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.cindex 36f625aaf348d0..5fd6ea435b1e5c 100644--- a/[drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/core/hub.c?id=eda9a296658203b1cc07d777c19c8c9eac6d0d17)+++ b/[drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/core/hub.c?id=7fe9d87996062f5eb0ca476ad0257f79bf43aaf5)@@ -4741,10 +4741,17 @@ static int get\_bMaxPacketSize0(struct usb\_device \*udev, \* the port lock. For a newly detected device that is not accessible \* through any global pointers, it's not necessary to lock the device, \* but it is still necessary to lock the port.+ \*+ \* For a newly detected device, @dev\_descr must be NULL. The device+ \* descriptor retrieved from the device will then be stored in+ \* @udev->descriptor. For an already existing device, @dev\_descr+ \* must be non-NULL. The device descriptor will be stored there,+ \* not in @udev->descriptor, because descriptors for registered+ \* devices are meant to be immutable. \*/ static int hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1,- int retry\_counter)+ int retry\_counter, struct usb\_device\_descriptor \*dev\_descr) { struct usb\_device \*hdev = hub->hdev; struct usb\_hcd \*hcd = bus\_to\_hcd(hdev->bus);@@ -4756,6 +4763,7 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, int devnum = udev->devnum; const char \*driver\_name; bool do\_new\_scheme;+ const bool initial = !dev\_descr; int maxp0; struct usb\_device\_descriptor \*buf, \*descr; @@ -4794,32 +4802,34 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, } oldspeed = udev->speed; - /\* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...- \* it's fixed size except for full speed devices.- \* For Wireless USB devices, ep0 max packet is always 512 (tho- \* reported as 0xff in the device descriptor). WUSB1.0[4.8.1].- \*/- switch (udev->speed) {- case USB\_SPEED\_SUPER\_PLUS:- case USB\_SPEED\_SUPER:- case USB\_SPEED\_WIRELESS: /\* fixed at 512 \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(512);- break;- case USB\_SPEED\_HIGH: /\* fixed at 64 \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);- break;- case USB\_SPEED\_FULL: /\* 8, 16, 32, or 64 \*/- /\* to determine the ep0 maxpacket size, try to read- \* the device descriptor to get bMaxPacketSize0 and- \* then correct our initial guess.+ if (initial) {+ /\* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...+ \* it's fixed size except for full speed devices.+ \* For Wireless USB devices, ep0 max packet is always 512 (tho+ \* reported as 0xff in the device descriptor). WUSB1.0[4.8.1]. \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);- break;- case USB\_SPEED\_LOW: /\* fixed at 8 \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(8);- break;- default:- goto fail;+ switch (udev->speed) {+ case USB\_SPEED\_SUPER\_PLUS:+ case USB\_SPEED\_SUPER:+ case USB\_SPEED\_WIRELESS: /\* fixed at 512 \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(512);+ break;+ case USB\_SPEED\_HIGH: /\* fixed at 64 \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);+ break;+ case USB\_SPEED\_FULL: /\* 8, 16, 32, or 64 \*/+ /\* to determine the ep0 maxpacket size, try to read+ \* the device descriptor to get bMaxPacketSize0 and+ \* then correct our initial guess.+ \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);+ break;+ case USB\_SPEED\_LOW: /\* fixed at 8 \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(8);+ break;+ default:+ goto fail;+ } }  if (udev->speed == USB\_SPEED\_WIRELESS)@@ -4842,22 +4852,24 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, if (udev->speed < USB\_SPEED\_SUPER) dev\_info(&udev->dev, "%s %s USB device number %d using %s\n",- (udev->config) ? "reset" : "new", speed,+ (initial ? "new" : "reset"), speed, devnum, driver\_name); - /\* Set up TT records, if needed \*/- if (hdev->tt) {- udev->tt = hdev->tt;- udev->ttport = hdev->ttport;- } else if (udev->speed != USB\_SPEED\_HIGH- && hdev->speed == USB\_SPEED\_HIGH) {- if (!hub->tt.hub) {- dev\_err(&udev->dev, "parent hub has no TT\n");- retval = -EINVAL;- goto fail;+ if (initial) {+ /\* Set up TT records, if needed \*/+ if (hdev->tt) {+ udev->tt = hdev->tt;+ udev->ttport = hdev->ttport;+ } else if (udev->speed != USB\_SPEED\_HIGH+ && hdev->speed == USB\_SPEED\_HIGH) {+ if (!hub->tt.hub) {+ dev\_err(&udev->dev, "parent hub has no TT\n");+ retval = -EINVAL;+ goto fail;+ }+ udev->tt = &hub->tt;+ udev->ttport = port1; }- udev->tt = &hub->tt;- udev->ttport = port1; }  /\* Why interleave GET\_DESCRIPTOR and SET\_ADDRESS this way?@@ -4886,6 +4898,12 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1,  maxp0 = get\_bMaxPacketSize0(udev, buf, GET\_DESCRIPTOR\_BUFSIZE, retries == 0);+ if (maxp0 > 0 && !initial &&+ maxp0 != udev->descriptor.bMaxPacketSize0) {+ dev\_err(&udev->dev, "device reset changed ep0 maxpacket size!\n");+ retval = -ENODEV;+ goto fail;+ }  retval = hub\_port\_reset(hub, port1, udev, delay, false); if (retval < 0) /\* error or disconnect \*/@@ -4959,6 +4977,12 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, } else { u32 delay; + if (!initial && maxp0 != udev->descriptor.bMaxPacketSize0) {+ dev\_err(&udev->dev, "device reset changed ep0 maxpacket size!\n");+ retval = -ENODEV;+ goto fail;+ }+ delay = udev->parent->hub\_delay; udev->hub\_delay = min\_t(u32, delay, USB\_TP\_TRANSMISSION\_DELAY\_MAX);@@ -5002,7 +5026,10 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, retval); goto fail; }- udev->descriptor = \*descr;+ if (initial)+ udev->descriptor = \*descr;+ else+ \*dev\_descr = \*descr; kfree(descr);  /\*@@ -5305,7 +5332,7 @@ static void hub\_port\_connect(struct usb\_hub \*hub, int port1, u16 portstatus, }  /\* reset (non-USB 3.0 devices) and get descriptor \*/- status = hub\_port\_init(hub, udev, port1, i);+ status = hub\_port\_init(hub, udev, port1, i, NULL); if (status < 0) goto loop; @@ -5921,7 +5948,7 @@ static int usb\_reset\_and\_verify\_device(struct usb\_device \*udev) struct usb\_device \*parent\_hdev = udev->parent; struct usb\_hub \*parent\_hub; struct usb\_hcd \*hcd = bus\_to\_hcd(udev->bus);- struct usb\_device\_descriptor descriptor = udev->descriptor;+ struct usb\_device\_descriptor descriptor; struct usb\_host\_bos \*bos; int i, j, ret = 0; int port1 = udev->portnum;@@ -5963,7 +5990,7 @@ static int usb\_reset\_and\_verify\_device(struct usb\_device \*udev) /\* ep0 maxpacket size may change; let the HCD know about it. \* Other endpoints will be handled by re-enumeration. \*/ usb\_ep0\_reinit(udev);- ret = hub\_port\_init(parent\_hub, udev, port1, i);+ ret = hub\_port\_init(parent\_hub, udev, port1, i, &descriptor); if (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV) break; }@@ -5975,7 +6002,6 @@ static int usb\_reset\_and\_verify\_device(struct usb\_device \*udev) /\* Device might have changed firmware (DFU or similar) \*/ if (descriptors\_changed(udev, &descriptor, bos)) { dev\_info(&udev->dev, "device firmware changed\n");- udev->descriptor = descriptor; /\* for disconnect() calls \*/ goto re\_enumerate; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 02:49:27 +0000



=== Content from git.kernel.org_6f1cc17e_20250111_025053.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=b9fbfb349eacc0820f91c797d7f0a3ac7a4935b5)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=b9fbfb349eacc0820f91c797d7f0a3ac7a4935b5)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b9fbfb349eacc0820f91c797d7f0a3ac7a4935b5)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b9fbfb349eacc0820f91c797d7f0a3ac7a4935b5)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Alan Stern <stern@rowland.harvard.edu> | 2023-08-04 15:14:14 -0400 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2023-09-13 09:53:08 +0200 |
| commit | [b9fbfb349eacc0820f91c797d7f0a3ac7a4935b5](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b9fbfb349eacc0820f91c797d7f0a3ac7a4935b5) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=b9fbfb349eacc0820f91c797d7f0a3ac7a4935b5)) | |
| tree | [74635fde614dfeba6f5c84e4af88441b89d22548](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=b9fbfb349eacc0820f91c797d7f0a3ac7a4935b5) | |
| parent | [91eafd344f7467d3e078d5ac5d8084f32e4e166d](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=91eafd344f7467d3e078d5ac5d8084f32e4e166d) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b9fbfb349eacc0820f91c797d7f0a3ac7a4935b5&id2=91eafd344f7467d3e078d5ac5d8084f32e4e166d)) | |
| download | [linux-b9fbfb349eacc0820f91c797d7f0a3ac7a4935b5.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-b9fbfb349eacc0820f91c797d7f0a3ac7a4935b5.tar.gz) | |

USB: core: Fix race by not overwriting udev->descriptor in hub\_port\_init()commit ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b upstream.
Syzbot reported an out-of-bounds read in sysfs.c:read\_descriptors():
BUG: KASAN: slab-out-of-bounds in read\_descriptors+0x263/0x280 drivers/usb/core/sysfs.c:883
Read of size 8 at addr ffff88801e78b8c8 by task udevd/5011
CPU: 0 PID: 5011 Comm: udevd Not tainted 6.4.0-rc6-syzkaller-00195-g40f71e7cd3c6 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/27/2023
Call Trace:
<TASK>
\_\_dump\_stack lib/dump\_stack.c:88 [inline]
dump\_stack\_lvl+0xd9/0x150 lib/dump\_stack.c:106
print\_address\_description.constprop.0+0x2c/0x3c0 mm/kasan/report.c:351
print\_report mm/kasan/report.c:462 [inline]
kasan\_report+0x11c/0x130 mm/kasan/report.c:572
read\_descriptors+0x263/0x280 drivers/usb/core/sysfs.c:883
...
Allocated by task 758:
...
\_\_do\_kmalloc\_node mm/slab\_common.c:966 [inline]
\_\_kmalloc+0x5e/0x190 mm/slab\_common.c:979
kmalloc include/linux/slab.h:563 [inline]
kzalloc include/linux/slab.h:680 [inline]
usb\_get\_configuration+0x1f7/0x5170 drivers/usb/core/config.c:887
usb\_enumerate\_device drivers/usb/core/hub.c:2407 [inline]
usb\_new\_device+0x12b0/0x19d0 drivers/usb/core/hub.c:2545
As analyzed by Khazhy Kumykov, the cause of this bug is a race between
read\_descriptors() and hub\_port\_init(): The first routine uses a field
in udev->descriptor, not expecting it to change, while the second
overwrites it.
Prior to commit 45bf39f8df7f ("USB: core: Don't hold device lock while
reading the "descriptors" sysfs file") this race couldn't occur,
because the routines were mutually exclusive thanks to the device
locking. Removing that locking from read\_descriptors() exposed it to
the race.
The best way to fix the bug is to keep hub\_port\_init() from changing
udev->descriptor once udev has been initialized and registered.
Drivers expect the descriptors stored in the kernel to be immutable;
we should not undermine this expectation. In fact, this change should
have been made long ago.
So now hub\_port\_init() will take an additional argument, specifying a
buffer in which to store the device descriptor it reads. (If udev has
not yet been initialized, the buffer pointer will be NULL and then
hub\_port\_init() will store the device descriptor in udev as before.)
This eliminates the data race responsible for the out-of-bounds read.
The changes to hub\_port\_init() appear more extensive than they really
are, because of indentation changes resulting from an attempt to avoid
writing to other parts of the usb\_device structure after it has been
initialized. Similar changes should be made to the code that reads
the BOS descriptor, but that can be handled in a separate patch later
on. This patch is sufficient to fix the bug found by syzbot.
Reported-and-tested-by: syzbot+18996170f8096c6174d0@syzkaller.appspotmail.com
Closes: https://lore.kernel.org/linux-usb/000000000000c0ffe505fe86c9ca@google.com/#r
Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
Cc: Khazhy Kumykov <khazhy@google.com>
Fixes: 45bf39f8df7f ("USB: core: Don't hold device lock while reading the "descriptors" sysfs file")
Cc: stable@vger.kernel.org
Link: [https://lore.kernel.org/r/b958b47a-9a46-4c22-a9f9-e42e42c31251@rowland.harvard.edu](https://lore.kernel.org/r/b958b47a-9a46-4c22-a9f9-e42e42c31251%40rowland.harvard.edu)
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b9fbfb349eacc0820f91c797d7f0a3ac7a4935b5)

| -rw-r--r-- | [drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/usb/core/hub.c?id=b9fbfb349eacc0820f91c797d7f0a3ac7a4935b5) | 114 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 70 insertions, 44 deletions

| diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.cindex 3ea682605d33fc..e4e1c9b43cdf1a 100644--- a/[drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/core/hub.c?id=91eafd344f7467d3e078d5ac5d8084f32e4e166d)+++ b/[drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/core/hub.c?id=b9fbfb349eacc0820f91c797d7f0a3ac7a4935b5)@@ -4793,10 +4793,17 @@ static int get\_bMaxPacketSize0(struct usb\_device \*udev, \* the port lock. For a newly detected device that is not accessible \* through any global pointers, it's not necessary to lock the device, \* but it is still necessary to lock the port.+ \*+ \* For a newly detected device, @dev\_descr must be NULL. The device+ \* descriptor retrieved from the device will then be stored in+ \* @udev->descriptor. For an already existing device, @dev\_descr+ \* must be non-NULL. The device descriptor will be stored there,+ \* not in @udev->descriptor, because descriptors for registered+ \* devices are meant to be immutable. \*/ static int hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1,- int retry\_counter)+ int retry\_counter, struct usb\_device\_descriptor \*dev\_descr) { struct usb\_device \*hdev = hub->hdev; struct usb\_hcd \*hcd = bus\_to\_hcd(hdev->bus);@@ -4808,6 +4815,7 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, int devnum = udev->devnum; const char \*driver\_name; bool do\_new\_scheme;+ const bool initial = !dev\_descr; int maxp0; struct usb\_device\_descriptor \*buf, \*descr; @@ -4846,32 +4854,34 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, } oldspeed = udev->speed; - /\* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...- \* it's fixed size except for full speed devices.- \* For Wireless USB devices, ep0 max packet is always 512 (tho- \* reported as 0xff in the device descriptor). WUSB1.0[4.8.1].- \*/- switch (udev->speed) {- case USB\_SPEED\_SUPER\_PLUS:- case USB\_SPEED\_SUPER:- case USB\_SPEED\_WIRELESS: /\* fixed at 512 \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(512);- break;- case USB\_SPEED\_HIGH: /\* fixed at 64 \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);- break;- case USB\_SPEED\_FULL: /\* 8, 16, 32, or 64 \*/- /\* to determine the ep0 maxpacket size, try to read- \* the device descriptor to get bMaxPacketSize0 and- \* then correct our initial guess.+ if (initial) {+ /\* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...+ \* it's fixed size except for full speed devices.+ \* For Wireless USB devices, ep0 max packet is always 512 (tho+ \* reported as 0xff in the device descriptor). WUSB1.0[4.8.1]. \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);- break;- case USB\_SPEED\_LOW: /\* fixed at 8 \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(8);- break;- default:- goto fail;+ switch (udev->speed) {+ case USB\_SPEED\_SUPER\_PLUS:+ case USB\_SPEED\_SUPER:+ case USB\_SPEED\_WIRELESS: /\* fixed at 512 \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(512);+ break;+ case USB\_SPEED\_HIGH: /\* fixed at 64 \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);+ break;+ case USB\_SPEED\_FULL: /\* 8, 16, 32, or 64 \*/+ /\* to determine the ep0 maxpacket size, try to read+ \* the device descriptor to get bMaxPacketSize0 and+ \* then correct our initial guess.+ \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);+ break;+ case USB\_SPEED\_LOW: /\* fixed at 8 \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(8);+ break;+ default:+ goto fail;+ } }  if (udev->speed == USB\_SPEED\_WIRELESS)@@ -4894,22 +4904,24 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, if (udev->speed < USB\_SPEED\_SUPER) dev\_info(&udev->dev, "%s %s USB device number %d using %s\n",- (udev->config) ? "reset" : "new", speed,+ (initial ? "new" : "reset"), speed, devnum, driver\_name); - /\* Set up TT records, if needed \*/- if (hdev->tt) {- udev->tt = hdev->tt;- udev->ttport = hdev->ttport;- } else if (udev->speed != USB\_SPEED\_HIGH- && hdev->speed == USB\_SPEED\_HIGH) {- if (!hub->tt.hub) {- dev\_err(&udev->dev, "parent hub has no TT\n");- retval = -EINVAL;- goto fail;+ if (initial) {+ /\* Set up TT records, if needed \*/+ if (hdev->tt) {+ udev->tt = hdev->tt;+ udev->ttport = hdev->ttport;+ } else if (udev->speed != USB\_SPEED\_HIGH+ && hdev->speed == USB\_SPEED\_HIGH) {+ if (!hub->tt.hub) {+ dev\_err(&udev->dev, "parent hub has no TT\n");+ retval = -EINVAL;+ goto fail;+ }+ udev->tt = &hub->tt;+ udev->ttport = port1; }- udev->tt = &hub->tt;- udev->ttport = port1; }  /\* Why interleave GET\_DESCRIPTOR and SET\_ADDRESS this way?@@ -4943,6 +4955,12 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1,  maxp0 = get\_bMaxPacketSize0(udev, buf, GET\_DESCRIPTOR\_BUFSIZE, retries == 0);+ if (maxp0 > 0 && !initial &&+ maxp0 != udev->descriptor.bMaxPacketSize0) {+ dev\_err(&udev->dev, "device reset changed ep0 maxpacket size!\n");+ retval = -ENODEV;+ goto fail;+ }  retval = hub\_port\_reset(hub, port1, udev, delay, false); if (retval < 0) /\* error or disconnect \*/@@ -5016,6 +5034,12 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, } else { u32 delay; + if (!initial && maxp0 != udev->descriptor.bMaxPacketSize0) {+ dev\_err(&udev->dev, "device reset changed ep0 maxpacket size!\n");+ retval = -ENODEV;+ goto fail;+ }+ delay = udev->parent->hub\_delay; udev->hub\_delay = min\_t(u32, delay, USB\_TP\_TRANSMISSION\_DELAY\_MAX);@@ -5059,7 +5083,10 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, retval); goto fail; }- udev->descriptor = \*descr;+ if (initial)+ udev->descriptor = \*descr;+ else+ \*dev\_descr = \*descr; kfree(descr);  /\*@@ -5369,7 +5396,7 @@ static void hub\_port\_connect(struct usb\_hub \*hub, int port1, u16 portstatus, }  /\* reset (non-USB 3.0 devices) and get descriptor \*/- status = hub\_port\_init(hub, udev, port1, i);+ status = hub\_port\_init(hub, udev, port1, i, NULL); if (status < 0) goto loop; @@ -5999,7 +6026,7 @@ static int usb\_reset\_and\_verify\_device(struct usb\_device \*udev) struct usb\_device \*parent\_hdev = udev->parent; struct usb\_hub \*parent\_hub; struct usb\_hcd \*hcd = bus\_to\_hcd(udev->bus);- struct usb\_device\_descriptor descriptor = udev->descriptor;+ struct usb\_device\_descriptor descriptor; struct usb\_host\_bos \*bos; int i, j, ret = 0; int port1 = udev->portnum;@@ -6035,7 +6062,7 @@ static int usb\_reset\_and\_verify\_device(struct usb\_device \*udev) /\* ep0 maxpacket size may change; let the HCD know about it. \* Other endpoints will be handled by re-enumeration. \*/ usb\_ep0\_reinit(udev);- ret = hub\_port\_init(parent\_hub, udev, port1, i);+ ret = hub\_port\_init(parent\_hub, udev, port1, i, &descriptor); if (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV) break; }@@ -6047,7 +6074,6 @@ static int usb\_reset\_and\_verify\_device(struct usb\_device \*udev) /\* Device might have changed firmware (DFU or similar) \*/ if (descriptors\_changed(udev, &descriptor, bos)) { dev\_info(&udev->dev, "device firmware changed\n");- udev->descriptor = descriptor; /\* for disconnect() calls \*/ goto re\_enumerate; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 02:49:30 +0000



=== Content from git.kernel.org_2927dbee_20250111_025052.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=b4a074b1fb222164ed7d5c0b8c922dc4a0840848)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=b4a074b1fb222164ed7d5c0b8c922dc4a0840848)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b4a074b1fb222164ed7d5c0b8c922dc4a0840848)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b4a074b1fb222164ed7d5c0b8c922dc4a0840848)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Alan Stern <stern@rowland.harvard.edu> | 2023-08-04 15:14:14 -0400 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2023-09-13 09:48:43 +0200 |
| commit | [b4a074b1fb222164ed7d5c0b8c922dc4a0840848](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b4a074b1fb222164ed7d5c0b8c922dc4a0840848) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=b4a074b1fb222164ed7d5c0b8c922dc4a0840848)) | |
| tree | [63776ec0e052012ab9130fdea59872e0c130da38](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=b4a074b1fb222164ed7d5c0b8c922dc4a0840848) | |
| parent | [256b02f63cc13d50bcd4907651c56ffd520806ef](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=256b02f63cc13d50bcd4907651c56ffd520806ef) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b4a074b1fb222164ed7d5c0b8c922dc4a0840848&id2=256b02f63cc13d50bcd4907651c56ffd520806ef)) | |
| download | [linux-b4a074b1fb222164ed7d5c0b8c922dc4a0840848.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-b4a074b1fb222164ed7d5c0b8c922dc4a0840848.tar.gz) | |

USB: core: Fix race by not overwriting udev->descriptor in hub\_port\_init()commit ff33299ec8bb80cdcc073ad9c506bd79bb2ed20b upstream.
Syzbot reported an out-of-bounds read in sysfs.c:read\_descriptors():
BUG: KASAN: slab-out-of-bounds in read\_descriptors+0x263/0x280 drivers/usb/core/sysfs.c:883
Read of size 8 at addr ffff88801e78b8c8 by task udevd/5011
CPU: 0 PID: 5011 Comm: udevd Not tainted 6.4.0-rc6-syzkaller-00195-g40f71e7cd3c6 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/27/2023
Call Trace:
<TASK>
\_\_dump\_stack lib/dump\_stack.c:88 [inline]
dump\_stack\_lvl+0xd9/0x150 lib/dump\_stack.c:106
print\_address\_description.constprop.0+0x2c/0x3c0 mm/kasan/report.c:351
print\_report mm/kasan/report.c:462 [inline]
kasan\_report+0x11c/0x130 mm/kasan/report.c:572
read\_descriptors+0x263/0x280 drivers/usb/core/sysfs.c:883
...
Allocated by task 758:
...
\_\_do\_kmalloc\_node mm/slab\_common.c:966 [inline]
\_\_kmalloc+0x5e/0x190 mm/slab\_common.c:979
kmalloc include/linux/slab.h:563 [inline]
kzalloc include/linux/slab.h:680 [inline]
usb\_get\_configuration+0x1f7/0x5170 drivers/usb/core/config.c:887
usb\_enumerate\_device drivers/usb/core/hub.c:2407 [inline]
usb\_new\_device+0x12b0/0x19d0 drivers/usb/core/hub.c:2545
As analyzed by Khazhy Kumykov, the cause of this bug is a race between
read\_descriptors() and hub\_port\_init(): The first routine uses a field
in udev->descriptor, not expecting it to change, while the second
overwrites it.
Prior to commit 45bf39f8df7f ("USB: core: Don't hold device lock while
reading the "descriptors" sysfs file") this race couldn't occur,
because the routines were mutually exclusive thanks to the device
locking. Removing that locking from read\_descriptors() exposed it to
the race.
The best way to fix the bug is to keep hub\_port\_init() from changing
udev->descriptor once udev has been initialized and registered.
Drivers expect the descriptors stored in the kernel to be immutable;
we should not undermine this expectation. In fact, this change should
have been made long ago.
So now hub\_port\_init() will take an additional argument, specifying a
buffer in which to store the device descriptor it reads. (If udev has
not yet been initialized, the buffer pointer will be NULL and then
hub\_port\_init() will store the device descriptor in udev as before.)
This eliminates the data race responsible for the out-of-bounds read.
The changes to hub\_port\_init() appear more extensive than they really
are, because of indentation changes resulting from an attempt to avoid
writing to other parts of the usb\_device structure after it has been
initialized. Similar changes should be made to the code that reads
the BOS descriptor, but that can be handled in a separate patch later
on. This patch is sufficient to fix the bug found by syzbot.
Reported-and-tested-by: syzbot+18996170f8096c6174d0@syzkaller.appspotmail.com
Closes: https://lore.kernel.org/linux-usb/000000000000c0ffe505fe86c9ca@google.com/#r
Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
Cc: Khazhy Kumykov <khazhy@google.com>
Fixes: 45bf39f8df7f ("USB: core: Don't hold device lock while reading the "descriptors" sysfs file")
Cc: stable@vger.kernel.org
Link: [https://lore.kernel.org/r/b958b47a-9a46-4c22-a9f9-e42e42c31251@rowland.harvard.edu](https://lore.kernel.org/r/b958b47a-9a46-4c22-a9f9-e42e42c31251%40rowland.harvard.edu)
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b4a074b1fb222164ed7d5c0b8c922dc4a0840848)

| -rw-r--r-- | [drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/usb/core/hub.c?id=b4a074b1fb222164ed7d5c0b8c922dc4a0840848) | 114 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 70 insertions, 44 deletions

| diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.cindex fd66187d944eed..41b36cb856106c 100644--- a/[drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/core/hub.c?id=256b02f63cc13d50bcd4907651c56ffd520806ef)+++ b/[drivers/usb/core/hub.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/core/hub.c?id=b4a074b1fb222164ed7d5c0b8c922dc4a0840848)@@ -4778,10 +4778,17 @@ static int get\_bMaxPacketSize0(struct usb\_device \*udev, \* the port lock. For a newly detected device that is not accessible \* through any global pointers, it's not necessary to lock the device, \* but it is still necessary to lock the port.+ \*+ \* For a newly detected device, @dev\_descr must be NULL. The device+ \* descriptor retrieved from the device will then be stored in+ \* @udev->descriptor. For an already existing device, @dev\_descr+ \* must be non-NULL. The device descriptor will be stored there,+ \* not in @udev->descriptor, because descriptors for registered+ \* devices are meant to be immutable. \*/ static int hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1,- int retry\_counter)+ int retry\_counter, struct usb\_device\_descriptor \*dev\_descr) { struct usb\_device \*hdev = hub->hdev; struct usb\_hcd \*hcd = bus\_to\_hcd(hdev->bus);@@ -4793,6 +4800,7 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, int devnum = udev->devnum; const char \*driver\_name; bool do\_new\_scheme;+ const bool initial = !dev\_descr; int maxp0; struct usb\_device\_descriptor \*buf, \*descr; @@ -4831,32 +4839,34 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, } oldspeed = udev->speed; - /\* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...- \* it's fixed size except for full speed devices.- \* For Wireless USB devices, ep0 max packet is always 512 (tho- \* reported as 0xff in the device descriptor). WUSB1.0[4.8.1].- \*/- switch (udev->speed) {- case USB\_SPEED\_SUPER\_PLUS:- case USB\_SPEED\_SUPER:- case USB\_SPEED\_WIRELESS: /\* fixed at 512 \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(512);- break;- case USB\_SPEED\_HIGH: /\* fixed at 64 \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);- break;- case USB\_SPEED\_FULL: /\* 8, 16, 32, or 64 \*/- /\* to determine the ep0 maxpacket size, try to read- \* the device descriptor to get bMaxPacketSize0 and- \* then correct our initial guess.+ if (initial) {+ /\* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...+ \* it's fixed size except for full speed devices.+ \* For Wireless USB devices, ep0 max packet is always 512 (tho+ \* reported as 0xff in the device descriptor). WUSB1.0[4.8.1]. \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);- break;- case USB\_SPEED\_LOW: /\* fixed at 8 \*/- udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(8);- break;- default:- goto fail;+ switch (udev->speed) {+ case USB\_SPEED\_SUPER\_PLUS:+ case USB\_SPEED\_SUPER:+ case USB\_SPEED\_WIRELESS: /\* fixed at 512 \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(512);+ break;+ case USB\_SPEED\_HIGH: /\* fixed at 64 \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);+ break;+ case USB\_SPEED\_FULL: /\* 8, 16, 32, or 64 \*/+ /\* to determine the ep0 maxpacket size, try to read+ \* the device descriptor to get bMaxPacketSize0 and+ \* then correct our initial guess.+ \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(64);+ break;+ case USB\_SPEED\_LOW: /\* fixed at 8 \*/+ udev->ep0.desc.wMaxPacketSize = cpu\_to\_le16(8);+ break;+ default:+ goto fail;+ } }  if (udev->speed == USB\_SPEED\_WIRELESS)@@ -4879,22 +4889,24 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, if (udev->speed < USB\_SPEED\_SUPER) dev\_info(&udev->dev, "%s %s USB device number %d using %s\n",- (udev->config) ? "reset" : "new", speed,+ (initial ? "new" : "reset"), speed, devnum, driver\_name); - /\* Set up TT records, if needed \*/- if (hdev->tt) {- udev->tt = hdev->tt;- udev->ttport = hdev->ttport;- } else if (udev->speed != USB\_SPEED\_HIGH- && hdev->speed == USB\_SPEED\_HIGH) {- if (!hub->tt.hub) {- dev\_err(&udev->dev, "parent hub has no TT\n");- retval = -EINVAL;- goto fail;+ if (initial) {+ /\* Set up TT records, if needed \*/+ if (hdev->tt) {+ udev->tt = hdev->tt;+ udev->ttport = hdev->ttport;+ } else if (udev->speed != USB\_SPEED\_HIGH+ && hdev->speed == USB\_SPEED\_HIGH) {+ if (!hub->tt.hub) {+ dev\_err(&udev->dev, "parent hub has no TT\n");+ retval = -EINVAL;+ goto fail;+ }+ udev->tt = &hub->tt;+ udev->ttport = port1; }- udev->tt = &hub->tt;- udev->ttport = port1; }  /\* Why interleave GET\_DESCRIPTOR and SET\_ADDRESS this way?@@ -4928,6 +4940,12 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1,  maxp0 = get\_bMaxPacketSize0(udev, buf, GET\_DESCRIPTOR\_BUFSIZE, retries == 0);+ if (maxp0 > 0 && !initial &&+ maxp0 != udev->descriptor.bMaxPacketSize0) {+ dev\_err(&udev->dev, "device reset changed ep0 maxpacket size!\n");+ retval = -ENODEV;+ goto fail;+ }  retval = hub\_port\_reset(hub, port1, udev, delay, false); if (retval < 0) /\* error or disconnect \*/@@ -5001,6 +5019,12 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, } else { u32 delay; + if (!initial && maxp0 != udev->descriptor.bMaxPacketSize0) {+ dev\_err(&udev->dev, "device reset changed ep0 maxpacket size!\n");+ retval = -ENODEV;+ goto fail;+ }+ delay = udev->parent->hub\_delay; udev->hub\_delay = min\_t(u32, delay, USB\_TP\_TRANSMISSION\_DELAY\_MAX);@@ -5044,7 +5068,10 @@ hub\_port\_init(struct usb\_hub \*hub, struct usb\_device \*udev, int port1, retval); goto fail; }- udev->descriptor = \*descr;+ if (initial)+ udev->descriptor = \*descr;+ else+ \*dev\_descr = \*descr; kfree(descr);  /\*@@ -5354,7 +5381,7 @@ static void hub\_port\_connect(struct usb\_hub \*hub, int port1, u16 portstatus, }  /\* reset (non-USB 3.0 devices) and get descriptor \*/- status = hub\_port\_init(hub, udev, port1, i);+ status = hub\_port\_init(hub, udev, port1, i, NULL); if (status < 0) goto loop; @@ -5984,7 +6011,7 @@ static int usb\_reset\_and\_verify\_device(struct usb\_device \*udev) struct usb\_device \*parent\_hdev = udev->parent; struct usb\_hub \*parent\_hub; struct usb\_hcd \*hcd = bus\_to\_hcd(udev->bus);- struct usb\_device\_descriptor descriptor = udev->descriptor;+ struct usb\_device\_descriptor descriptor; struct usb\_host\_bos \*bos; int i, j, ret = 0; int port1 = udev->portnum;@@ -6020,7 +6047,7 @@ static int usb\_reset\_and\_verify\_device(struct usb\_device \*udev) /\* ep0 maxpacket size may change; let the HCD know about it. \* Other endpoints will be handled by re-enumeration. \*/ usb\_ep0\_reinit(udev);- ret = hub\_port\_init(parent\_hub, udev, port1, i);+ ret = hub\_port\_init(parent\_hub, udev, port1, i, &descriptor); if (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV) break; }@@ -6032,7 +6059,6 @@ static int usb\_reset\_and\_verify\_device(struct usb\_device \*udev) /\* Device might have changed firmware (DFU or similar) \*/ if (descriptors\_changed(udev, &descriptor, bos)) { dev\_info(&udev->dev, "device firmware changed\n");- udev->descriptor = descriptor; /\* for disconnect() calls \*/ goto re\_enumerate; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 02:49:29 +0000


