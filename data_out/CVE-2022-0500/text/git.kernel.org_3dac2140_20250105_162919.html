

| [cgit logo](/) | [index](/) : [kernel/git/torvalds/linux.git](/pub/scm/linux/kernel/git/torvalds/linux.git/) | for-next master vsnprintf |
| --- | --- | --- |
| Linux kernel source tree | Linus Torvalds |

| [about](/pub/scm/linux/kernel/git/torvalds/linux.git/about/)[summary](/pub/scm/linux/kernel/git/torvalds/linux.git/)[refs](/pub/scm/linux/kernel/git/torvalds/linux.git/refs/?id=c25b2ae136039ffa820c26138ed4a5e5f3ab3841)[log](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)[tree](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=c25b2ae136039ffa820c26138ed4a5e5f3ab3841)[commit](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c25b2ae136039ffa820c26138ed4a5e5f3ab3841)[diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=c25b2ae136039ffa820c26138ed4a5e5f3ab3841)[stats](/pub/scm/linux/kernel/git/torvalds/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Hao Luo <haoluo@google.com> | 2021-12-16 16:31:47 -0800 |
| --- | --- | --- |
| committer | Alexei Starovoitov <ast@kernel.org> | 2021-12-18 13:27:23 -0800 |
| commit | [c25b2ae136039ffa820c26138ed4a5e5f3ab3841](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c25b2ae136039ffa820c26138ed4a5e5f3ab3841) ([patch](/pub/scm/linux/kernel/git/torvalds/linux.git/patch/?id=c25b2ae136039ffa820c26138ed4a5e5f3ab3841)) | |
| tree | [bfdb6805f2595026430786aab1bdda685143cc91](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=c25b2ae136039ffa820c26138ed4a5e5f3ab3841) | |
| parent | [3c4807322660d4290ac9062c034aed6b87243861](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=3c4807322660d4290ac9062c034aed6b87243861) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=c25b2ae136039ffa820c26138ed4a5e5f3ab3841&id2=3c4807322660d4290ac9062c034aed6b87243861)) | |
| download | [linux-c25b2ae136039ffa820c26138ed4a5e5f3ab3841.tar.gz](/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-c25b2ae136039ffa820c26138ed4a5e5f3ab3841.tar.gz) | |

bpf: Replace PTR\_TO\_XXX\_OR\_NULL with PTR\_TO\_XXX | PTR\_MAYBE\_NULLWe have introduced a new type to make bpf\_reg composable, by
allocating bits in the type to represent flags.
One of the flags is PTR\_MAYBE\_NULL which indicates a pointer
may be NULL. This patch switches the qualified reg\_types to
use this flag. The reg\_types changed in this patch include:
1. PTR\_TO\_MAP\_VALUE\_OR\_NULL
2. PTR\_TO\_SOCKET\_OR\_NULL
3. PTR\_TO\_SOCK\_COMMON\_OR\_NULL
4. PTR\_TO\_TCP\_SOCK\_OR\_NULL
5. PTR\_TO\_BTF\_ID\_OR\_NULL
6. PTR\_TO\_MEM\_OR\_NULL
7. PTR\_TO\_RDONLY\_BUF\_OR\_NULL
8. PTR\_TO\_RDWR\_BUF\_OR\_NULL
Signed-off-by: Hao Luo <haoluo@google.com>
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: [https://lore.kernel.org/r/20211217003152.48334-5-haoluo@google.com](https://lore.kernel.org/r/20211217003152.48334-5-haoluo%40google.com)
[Diffstat](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=c25b2ae136039ffa820c26138ed4a5e5f3ab3841)

| -rw-r--r-- | [include/linux/bpf.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/linux/bpf.h?id=c25b2ae136039ffa820c26138ed4a5e5f3ab3841) | 18 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/linux/bpf\_verifier.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/linux/bpf_verifier.h?id=c25b2ae136039ffa820c26138ed4a5e5f3ab3841) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/bpf/btf.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/kernel/bpf/btf.c?id=c25b2ae136039ffa820c26138ed4a5e5f3ab3841) | 7 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/bpf/map\_iter.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/kernel/bpf/map_iter.c?id=c25b2ae136039ffa820c26138ed4a5e5f3ab3841) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/kernel/bpf/verifier.c?id=c25b2ae136039ffa820c26138ed4a5e5f3ab3841) | 298 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/core/bpf\_sk\_storage.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/net/core/bpf_sk_storage.c?id=c25b2ae136039ffa820c26138ed4a5e5f3ab3841) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/core/sock\_map.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/net/core/sock_map.c?id=c25b2ae136039ffa820c26138ed4a5e5f3ab3841) | 2 | |  |  |  | | --- | --- | --- | |

7 files changed, 147 insertions, 188 deletions

| diff --git a/include/linux/bpf.h b/include/linux/bpf.hindex 975a1d5951bde1..c3de62267b84dc 100644--- a/[include/linux/bpf.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/bpf.h?id=3c4807322660d4290ac9062c034aed6b87243861)+++ b/[include/linux/bpf.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/bpf.h?id=c25b2ae136039ffa820c26138ed4a5e5f3ab3841)@@ -465,18 +465,15 @@ enum bpf\_reg\_type { PTR\_TO\_CTX, /\* reg points to bpf\_context \*/ CONST\_PTR\_TO\_MAP, /\* reg points to struct bpf\_map \*/ PTR\_TO\_MAP\_VALUE, /\* reg points to map element value \*/- PTR\_TO\_MAP\_VALUE\_OR\_NULL,/\* points to map elem value or NULL \*/+ PTR\_TO\_MAP\_KEY, /\* reg points to a map element key \*/ PTR\_TO\_STACK, /\* reg == frame\_pointer + offset \*/ PTR\_TO\_PACKET\_META, /\* skb->data - meta\_len \*/ PTR\_TO\_PACKET, /\* reg points to skb->data \*/ PTR\_TO\_PACKET\_END, /\* skb->data + headlen \*/ PTR\_TO\_FLOW\_KEYS, /\* reg points to bpf\_flow\_keys \*/ PTR\_TO\_SOCKET, /\* reg points to struct bpf\_sock \*/- PTR\_TO\_SOCKET\_OR\_NULL, /\* reg points to struct bpf\_sock or NULL \*/ PTR\_TO\_SOCK\_COMMON, /\* reg points to sock\_common \*/- PTR\_TO\_SOCK\_COMMON\_OR\_NULL, /\* reg points to sock\_common or NULL \*/ PTR\_TO\_TCP\_SOCK, /\* reg points to struct tcp\_sock \*/- PTR\_TO\_TCP\_SOCK\_OR\_NULL, /\* reg points to struct tcp\_sock or NULL \*/ PTR\_TO\_TP\_BUFFER, /\* reg points to a writable raw tp's buffer \*/ PTR\_TO\_XDP\_SOCK, /\* reg points to struct xdp\_sock \*/ /\* PTR\_TO\_BTF\_ID points to a kernel struct that does not need@@ -494,18 +491,21 @@ enum bpf\_reg\_type { \* been checked for null. Used primarily to inform the verifier \* an explicit null check is required for this struct. \*/- PTR\_TO\_BTF\_ID\_OR\_NULL, PTR\_TO\_MEM, /\* reg points to valid memory region \*/- PTR\_TO\_MEM\_OR\_NULL, /\* reg points to valid memory region or NULL \*/ PTR\_TO\_RDONLY\_BUF, /\* reg points to a readonly buffer \*/- PTR\_TO\_RDONLY\_BUF\_OR\_NULL, /\* reg points to a readonly buffer or NULL \*/ PTR\_TO\_RDWR\_BUF, /\* reg points to a read/write buffer \*/- PTR\_TO\_RDWR\_BUF\_OR\_NULL, /\* reg points to a read/write buffer or NULL \*/ PTR\_TO\_PERCPU\_BTF\_ID, /\* reg points to a percpu kernel variable \*/ PTR\_TO\_FUNC, /\* reg points to a bpf program function \*/- PTR\_TO\_MAP\_KEY, /\* reg points to a map element key \*/ \_\_BPF\_REG\_TYPE\_MAX, + /\* Extended reg\_types. \*/+ PTR\_TO\_MAP\_VALUE\_OR\_NULL = PTR\_MAYBE\_NULL | PTR\_TO\_MAP\_VALUE,+ PTR\_TO\_SOCKET\_OR\_NULL = PTR\_MAYBE\_NULL | PTR\_TO\_SOCKET,+ PTR\_TO\_SOCK\_COMMON\_OR\_NULL = PTR\_MAYBE\_NULL | PTR\_TO\_SOCK\_COMMON,+ PTR\_TO\_TCP\_SOCK\_OR\_NULL = PTR\_MAYBE\_NULL | PTR\_TO\_TCP\_SOCK,+ PTR\_TO\_BTF\_ID\_OR\_NULL = PTR\_MAYBE\_NULL | PTR\_TO\_BTF\_ID,+ PTR\_TO\_MEM\_OR\_NULL = PTR\_MAYBE\_NULL | PTR\_TO\_MEM,+ /\* This must be the last entry. Its purpose is to ensure the enum is \* wide enough to hold the higher bits reserved for bpf\_type\_flag. \*/diff --git a/include/linux/bpf\_verifier.h b/include/linux/bpf\_verifier.hindex 34e4ceaca3c772..143401d4c9d9ac 100644--- a/[include/linux/bpf\_verifier.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/bpf_verifier.h?id=3c4807322660d4290ac9062c034aed6b87243861)+++ b/[include/linux/bpf\_verifier.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/bpf_verifier.h?id=c25b2ae136039ffa820c26138ed4a5e5f3ab3841)@@ -18,6 +18,8 @@ \* that converting umax\_value to int cannot overflow. \*/ #define BPF\_MAX\_VAR\_SIZ (1 << 29)+/\* size of type\_str\_buf in bpf\_verifier. \*/+#define TYPE\_STR\_BUF\_LEN 64  /\* Liveness marks, used for registers and spilled-regs (in stack slots). \* Read marks propagate upwards until they find a write mark; they record that@@ -484,6 +486,8 @@ struct bpf\_verifier\_env { /\* Same as scratched\_regs but for stack slots \*/ u64 scratched\_stack\_slots; u32 prev\_log\_len, prev\_insn\_print\_len;+ /\* buffer used in reg\_type\_str() to generate reg\_type string \*/+ char type\_str\_buf[TYPE\_STR\_BUF\_LEN]; };  \_\_printf(2, 0) void bpf\_verifier\_vlog(struct bpf\_verifier\_log \*log,diff --git a/kernel/bpf/btf.c b/kernel/bpf/btf.cindex a17de71abd2e6d..4e2ca7bea6c4cb 100644--- a/[kernel/bpf/btf.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/kernel/bpf/btf.c?id=3c4807322660d4290ac9062c034aed6b87243861)+++ b/[kernel/bpf/btf.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/kernel/bpf/btf.c?id=c25b2ae136039ffa820c26138ed4a5e5f3ab3841)@@ -4940,10 +4940,13 @@ bool btf\_ctx\_access(int off, int size, enum bpf\_access\_type type, /\* check for PTR\_TO\_RDONLY\_BUF\_OR\_NULL or PTR\_TO\_RDWR\_BUF\_OR\_NULL \*/ for (i = 0; i < prog->aux->ctx\_arg\_info\_size; i++) { const struct bpf\_ctx\_arg\_aux \*ctx\_arg\_info = &prog->aux->ctx\_arg\_info[i];+ u32 type, flag; + type = base\_type(ctx\_arg\_info->reg\_type);+ flag = type\_flag(ctx\_arg\_info->reg\_type); if (ctx\_arg\_info->offset == off &&- (ctx\_arg\_info->reg\_type == PTR\_TO\_RDONLY\_BUF\_OR\_NULL ||- ctx\_arg\_info->reg\_type == PTR\_TO\_RDWR\_BUF\_OR\_NULL)) {+ (type == PTR\_TO\_RDWR\_BUF || type == PTR\_TO\_RDONLY\_BUF) &&+ (flag & PTR\_MAYBE\_NULL)) { info->reg\_type = ctx\_arg\_info->reg\_type; return true; }diff --git a/kernel/bpf/map\_iter.c b/kernel/bpf/map\_iter.cindex 6a9542af4212a1..631f0e44b7a9e5 100644--- a/[kernel/bpf/map\_iter.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/kernel/bpf/map_iter.c?id=3c4807322660d4290ac9062c034aed6b87243861)+++ b/[kernel/bpf/map\_iter.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/kernel/bpf/map_iter.c?id=c25b2ae136039ffa820c26138ed4a5e5f3ab3841)@@ -174,9 +174,9 @@ static const struct bpf\_iter\_reg bpf\_map\_elem\_reg\_info = { .ctx\_arg\_info\_size = 2, .ctx\_arg\_info = { { offsetof(struct bpf\_iter\_\_bpf\_map\_elem, key),- PTR\_TO\_RDONLY\_BUF\_OR\_NULL },+ PTR\_TO\_RDONLY\_BUF | PTR\_MAYBE\_NULL }, { offsetof(struct bpf\_iter\_\_bpf\_map\_elem, value),- PTR\_TO\_RDWR\_BUF\_OR\_NULL },+ PTR\_TO\_RDWR\_BUF | PTR\_MAYBE\_NULL }, }, }; diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.cindex ccc068c5c5f24a..97e9d3f31443e1 100644--- a/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/kernel/bpf/verifier.c?id=3c4807322660d4290ac9062c034aed6b87243861)+++ b/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/kernel/bpf/verifier.c?id=c25b2ae136039ffa820c26138ed4a5e5f3ab3841)@@ -442,18 +442,6 @@ static bool reg\_type\_not\_null(enum bpf\_reg\_type type) type == PTR\_TO\_SOCK\_COMMON; } -static bool reg\_type\_may\_be\_null(enum bpf\_reg\_type type)-{- return type == PTR\_TO\_MAP\_VALUE\_OR\_NULL ||- type == PTR\_TO\_SOCKET\_OR\_NULL ||- type == PTR\_TO\_SOCK\_COMMON\_OR\_NULL ||- type == PTR\_TO\_TCP\_SOCK\_OR\_NULL ||- type == PTR\_TO\_BTF\_ID\_OR\_NULL ||- type == PTR\_TO\_MEM\_OR\_NULL ||- type == PTR\_TO\_RDONLY\_BUF\_OR\_NULL ||- type == PTR\_TO\_RDWR\_BUF\_OR\_NULL;-}- static bool reg\_may\_point\_to\_spin\_lock(const struct bpf\_reg\_state \*reg) { return reg->type == PTR\_TO\_MAP\_VALUE &&@@ -462,12 +450,9 @@ static bool reg\_may\_point\_to\_spin\_lock(const struct bpf\_reg\_state \*reg)  static bool reg\_type\_may\_be\_refcounted\_or\_null(enum bpf\_reg\_type type) {- return type == PTR\_TO\_SOCKET ||- type == PTR\_TO\_SOCKET\_OR\_NULL ||- type == PTR\_TO\_TCP\_SOCK ||- type == PTR\_TO\_TCP\_SOCK\_OR\_NULL ||- type == PTR\_TO\_MEM ||- type == PTR\_TO\_MEM\_OR\_NULL;+ return base\_type(type) == PTR\_TO\_SOCKET ||+ base\_type(type) == PTR\_TO\_TCP\_SOCK ||+ base\_type(type) == PTR\_TO\_MEM; }  static bool arg\_type\_may\_be\_refcounted(enum bpf\_arg\_type type)@@ -537,39 +522,52 @@ static bool is\_cmpxchg\_insn(const struct bpf\_insn \*insn) insn->imm == BPF\_CMPXCHG; } -/\* string representation of 'enum bpf\_reg\_type' \*/-static const char \* const reg\_type\_str[] = {- [NOT\_INIT] = "?",- [SCALAR\_VALUE] = "inv",- [PTR\_TO\_CTX] = "ctx",- [CONST\_PTR\_TO\_MAP] = "map\_ptr",- [PTR\_TO\_MAP\_VALUE] = "map\_value",- [PTR\_TO\_MAP\_VALUE\_OR\_NULL] = "map\_value\_or\_null",- [PTR\_TO\_STACK] = "fp",- [PTR\_TO\_PACKET] = "pkt",- [PTR\_TO\_PACKET\_META] = "pkt\_meta",- [PTR\_TO\_PACKET\_END] = "pkt\_end",- [PTR\_TO\_FLOW\_KEYS] = "flow\_keys",- [PTR\_TO\_SOCKET] = "sock",- [PTR\_TO\_SOCKET\_OR\_NULL] = "sock\_or\_null",- [PTR\_TO\_SOCK\_COMMON] = "sock\_common",- [PTR\_TO\_SOCK\_COMMON\_OR\_NULL] = "sock\_common\_or\_null",- [PTR\_TO\_TCP\_SOCK] = "tcp\_sock",- [PTR\_TO\_TCP\_SOCK\_OR\_NULL] = "tcp\_sock\_or\_null",- [PTR\_TO\_TP\_BUFFER] = "tp\_buffer",- [PTR\_TO\_XDP\_SOCK] = "xdp\_sock",- [PTR\_TO\_BTF\_ID] = "ptr\_",- [PTR\_TO\_BTF\_ID\_OR\_NULL] = "ptr\_or\_null\_",- [PTR\_TO\_PERCPU\_BTF\_ID] = "percpu\_ptr\_",- [PTR\_TO\_MEM] = "mem",- [PTR\_TO\_MEM\_OR\_NULL] = "mem\_or\_null",- [PTR\_TO\_RDONLY\_BUF] = "rdonly\_buf",- [PTR\_TO\_RDONLY\_BUF\_OR\_NULL] = "rdonly\_buf\_or\_null",- [PTR\_TO\_RDWR\_BUF] = "rdwr\_buf",- [PTR\_TO\_RDWR\_BUF\_OR\_NULL] = "rdwr\_buf\_or\_null",- [PTR\_TO\_FUNC] = "func",- [PTR\_TO\_MAP\_KEY] = "map\_key",-};+/\* string representation of 'enum bpf\_reg\_type'+ \*+ \* Note that reg\_type\_str() can not appear more than once in a single verbose()+ \* statement.+ \*/+static const char \*reg\_type\_str(struct bpf\_verifier\_env \*env,+ enum bpf\_reg\_type type)+{+ char postfix[16] = {0};+ static const char \* const str[] = {+ [NOT\_INIT] = "?",+ [SCALAR\_VALUE] = "inv",+ [PTR\_TO\_CTX] = "ctx",+ [CONST\_PTR\_TO\_MAP] = "map\_ptr",+ [PTR\_TO\_MAP\_VALUE] = "map\_value",+ [PTR\_TO\_STACK] = "fp",+ [PTR\_TO\_PACKET] = "pkt",+ [PTR\_TO\_PACKET\_META] = "pkt\_meta",+ [PTR\_TO\_PACKET\_END] = "pkt\_end",+ [PTR\_TO\_FLOW\_KEYS] = "flow\_keys",+ [PTR\_TO\_SOCKET] = "sock",+ [PTR\_TO\_SOCK\_COMMON] = "sock\_common",+ [PTR\_TO\_TCP\_SOCK] = "tcp\_sock",+ [PTR\_TO\_TP\_BUFFER] = "tp\_buffer",+ [PTR\_TO\_XDP\_SOCK] = "xdp\_sock",+ [PTR\_TO\_BTF\_ID] = "ptr\_",+ [PTR\_TO\_PERCPU\_BTF\_ID] = "percpu\_ptr\_",+ [PTR\_TO\_MEM] = "mem",+ [PTR\_TO\_RDONLY\_BUF] = "rdonly\_buf",+ [PTR\_TO\_RDWR\_BUF] = "rdwr\_buf",+ [PTR\_TO\_FUNC] = "func",+ [PTR\_TO\_MAP\_KEY] = "map\_key",+ };++ if (type & PTR\_MAYBE\_NULL) {+ if (base\_type(type) == PTR\_TO\_BTF\_ID ||+ base\_type(type) == PTR\_TO\_PERCPU\_BTF\_ID)+ strncpy(postfix, "or\_null\_", 16);+ else+ strncpy(postfix, "\_or\_null", 16);+ }++ snprintf(env->type\_str\_buf, TYPE\_STR\_BUF\_LEN, "%s%s",+ str[base\_type(type)], postfix);+ return env->type\_str\_buf;+}  static char slot\_type\_char[] = { [STACK\_INVALID] = '?',@@ -675,7 +673,7 @@ static void print\_verifier\_state(struct bpf\_verifier\_env \*env, continue; verbose(env, " R%d", i); print\_liveness(env, reg->live);- verbose(env, "=%s", reg\_type\_str[t]);+ verbose(env, "=%s", reg\_type\_str(env, t)); if (t == SCALAR\_VALUE && reg->precise) verbose(env, "P"); if ((t == SCALAR\_VALUE || t == PTR\_TO\_STACK) &&@@ -683,9 +681,8 @@ static void print\_verifier\_state(struct bpf\_verifier\_env \*env, /\* reg->off should be 0 for SCALAR\_VALUE \*/ verbose(env, "%lld", reg->var\_off.value + reg->off); } else {- if (t == PTR\_TO\_BTF\_ID ||- t == PTR\_TO\_BTF\_ID\_OR\_NULL ||- t == PTR\_TO\_PERCPU\_BTF\_ID)+ if (base\_type(t) == PTR\_TO\_BTF\_ID ||+ base\_type(t) == PTR\_TO\_PERCPU\_BTF\_ID) verbose(env, "%s", kernel\_type\_name(reg->btf, reg->btf\_id)); verbose(env, "(id=%d", reg->id); if (reg\_type\_may\_be\_refcounted\_or\_null(t))@@ -694,10 +691,9 @@ static void print\_verifier\_state(struct bpf\_verifier\_env \*env, verbose(env, ",off=%d", reg->off); if (type\_is\_pkt\_pointer(t)) verbose(env, ",r=%d", reg->range);- else if (t == CONST\_PTR\_TO\_MAP ||- t == PTR\_TO\_MAP\_KEY ||- t == PTR\_TO\_MAP\_VALUE ||- t == PTR\_TO\_MAP\_VALUE\_OR\_NULL)+ else if (base\_type(t) == CONST\_PTR\_TO\_MAP ||+ base\_type(t) == PTR\_TO\_MAP\_KEY ||+ base\_type(t) == PTR\_TO\_MAP\_VALUE) verbose(env, ",ks=%d,vs=%d", reg->map\_ptr->key\_size, reg->map\_ptr->value\_size);@@ -769,7 +765,7 @@ static void print\_verifier\_state(struct bpf\_verifier\_env \*env, if (is\_spilled\_reg(&state->stack[i])) { reg = &state->stack[i].spilled\_ptr; t = reg->type;- verbose(env, "=%s", reg\_type\_str[t]);+ verbose(env, "=%s", reg\_type\_str(env, t)); if (t == SCALAR\_VALUE && reg->precise) verbose(env, "P"); if (t == SCALAR\_VALUE && tnum\_is\_const(reg->var\_off))@@ -1202,8 +1198,7 @@ static void mark\_reg\_known\_zero(struct bpf\_verifier\_env \*env,  static void mark\_ptr\_not\_null\_reg(struct bpf\_reg\_state \*reg) {- switch (reg->type) {- case PTR\_TO\_MAP\_VALUE\_OR\_NULL: {+ if (base\_type(reg->type) == PTR\_TO\_MAP\_VALUE) { const struct bpf\_map \*map = reg->map\_ptr;  if (map->inner\_map\_meta) {@@ -1222,32 +1217,10 @@ static void mark\_ptr\_not\_null\_reg(struct bpf\_reg\_state \*reg) } else { reg->type = PTR\_TO\_MAP\_VALUE; }- break;- }- case PTR\_TO\_SOCKET\_OR\_NULL:- reg->type = PTR\_TO\_SOCKET;- break;- case PTR\_TO\_SOCK\_COMMON\_OR\_NULL:- reg->type = PTR\_TO\_SOCK\_COMMON;- break;- case PTR\_TO\_TCP\_SOCK\_OR\_NULL:- reg->type = PTR\_TO\_TCP\_SOCK;- break;- case PTR\_TO\_BTF\_ID\_OR\_NULL:- reg->type = PTR\_TO\_BTF\_ID;- break;- case PTR\_TO\_MEM\_OR\_NULL:- reg->type = PTR\_TO\_MEM;- break;- case PTR\_TO\_RDONLY\_BUF\_OR\_NULL:- reg->type = PTR\_TO\_RDONLY\_BUF;- break;- case PTR\_TO\_RDWR\_BUF\_OR\_NULL:- reg->type = PTR\_TO\_RDWR\_BUF;- break;- default:- WARN\_ONCE(1, "unknown nullable register type");+ return; }++ reg->type &= ~PTR\_MAYBE\_NULL; }  static bool reg\_is\_pkt\_pointer(const struct bpf\_reg\_state \*reg)@@ -2103,7 +2076,7 @@ static int mark\_reg\_read(struct bpf\_verifier\_env \*env, break; if (parent->live & REG\_LIVE\_DONE) { verbose(env, "verifier BUG type %s var\_off %lld off %d\n",- reg\_type\_str[parent->type],+ reg\_type\_str(env, parent->type), parent->var\_off.value, parent->off); return -EFAULT; }@@ -2768,9 +2741,8 @@ static int mark\_chain\_precision\_stack(struct bpf\_verifier\_env \*env, int spi)  static bool is\_spillable\_regtype(enum bpf\_reg\_type type) {- switch (type) {+ switch (base\_type(type)) { case PTR\_TO\_MAP\_VALUE:- case PTR\_TO\_MAP\_VALUE\_OR\_NULL: case PTR\_TO\_STACK: case PTR\_TO\_CTX: case PTR\_TO\_PACKET:@@ -2779,21 +2751,14 @@ static bool is\_spillable\_regtype(enum bpf\_reg\_type type) case PTR\_TO\_FLOW\_KEYS: case CONST\_PTR\_TO\_MAP: case PTR\_TO\_SOCKET:- case PTR\_TO\_SOCKET\_OR\_NULL: case PTR\_TO\_SOCK\_COMMON:- case PTR\_TO\_SOCK\_COMMON\_OR\_NULL: case PTR\_TO\_TCP\_SOCK:- case PTR\_TO\_TCP\_SOCK\_OR\_NULL: case PTR\_TO\_XDP\_SOCK: case PTR\_TO\_BTF\_ID:- case PTR\_TO\_BTF\_ID\_OR\_NULL: case PTR\_TO\_RDONLY\_BUF:- case PTR\_TO\_RDONLY\_BUF\_OR\_NULL: case PTR\_TO\_RDWR\_BUF:- case PTR\_TO\_RDWR\_BUF\_OR\_NULL: case PTR\_TO\_PERCPU\_BTF\_ID: case PTR\_TO\_MEM:- case PTR\_TO\_MEM\_OR\_NULL: case PTR\_TO\_FUNC: case PTR\_TO\_MAP\_KEY: return true;@@ -3633,7 +3598,7 @@ static int check\_ctx\_access(struct bpf\_verifier\_env \*env, int insn\_idx, int off, \*/ \*reg\_type = info.reg\_type; - if (\*reg\_type == PTR\_TO\_BTF\_ID || \*reg\_type == PTR\_TO\_BTF\_ID\_OR\_NULL) {+ if (base\_type(\*reg\_type) == PTR\_TO\_BTF\_ID) { \*btf = info.btf; \*btf\_id = info.btf\_id; } else {@@ -3701,7 +3666,7 @@ static int check\_sock\_access(struct bpf\_verifier\_env \*env, int insn\_idx, }  verbose(env, "R%d invalid %s access off=%d size=%d\n",- regno, reg\_type\_str[reg->type], off, size);+ regno, reg\_type\_str(env, reg->type), off, size);  return -EACCES; }@@ -4466,7 +4431,7 @@ static int check\_mem\_access(struct bpf\_verifier\_env \*env, int insn\_idx, u32 regn } else { mark\_reg\_known\_zero(env, regs, value\_regno);- if (reg\_type\_may\_be\_null(reg\_type))+ if (type\_may\_be\_null(reg\_type)) regs[value\_regno].id = ++env->id\_gen; /\* A load of ctx field could have different \* actual load size with the one encoded in the@@ -4474,8 +4439,7 @@ static int check\_mem\_access(struct bpf\_verifier\_env \*env, int insn\_idx, u32 regn \* a sub-register. \*/ regs[value\_regno].subreg\_def = DEF\_NOT\_SUBREG;- if (reg\_type == PTR\_TO\_BTF\_ID ||- reg\_type == PTR\_TO\_BTF\_ID\_OR\_NULL) {+ if (base\_type(reg\_type) == PTR\_TO\_BTF\_ID) { regs[value\_regno].btf = btf; regs[value\_regno].btf\_id = btf\_id; }@@ -4528,7 +4492,7 @@ static int check\_mem\_access(struct bpf\_verifier\_env \*env, int insn\_idx, u32 regn } else if (type\_is\_sk\_pointer(reg->type)) { if (t == BPF\_WRITE) { verbose(env, "R%d cannot write into %s\n",- regno, reg\_type\_str[reg->type]);+ regno, reg\_type\_str(env, reg->type)); return -EACCES; } err = check\_sock\_access(env, insn\_idx, regno, off, size, t);@@ -4547,7 +4511,7 @@ static int check\_mem\_access(struct bpf\_verifier\_env \*env, int insn\_idx, u32 regn } else if (reg->type == PTR\_TO\_RDONLY\_BUF) { if (t == BPF\_WRITE) { verbose(env, "R%d cannot write into %s\n",- regno, reg\_type\_str[reg->type]);+ regno, reg\_type\_str(env, reg->type)); return -EACCES; } err = check\_buffer\_access(env, reg, regno, off, size, false,@@ -4563,7 +4527,7 @@ static int check\_mem\_access(struct bpf\_verifier\_env \*env, int insn\_idx, u32 regn mark\_reg\_unknown(env, regs, value\_regno); } else { verbose(env, "R%d invalid mem access '%s'\n", regno,- reg\_type\_str[reg->type]);+ reg\_type\_str(env, reg->type)); return -EACCES; } @@ -4630,7 +4594,7 @@ static int check\_atomic(struct bpf\_verifier\_env \*env, int insn\_idx, struct bpf\_i is\_sk\_reg(env, insn->dst\_reg)) { verbose(env, "BPF\_ATOMIC stores into R%d %s is not allowed\n", insn->dst\_reg,- reg\_type\_str[reg\_state(env, insn->dst\_reg)->type]);+ reg\_type\_str(env, reg\_state(env, insn->dst\_reg)->type)); return -EACCES; } @@ -4850,9 +4814,9 @@ static int check\_helper\_mem\_access(struct bpf\_verifier\_env \*env, int regno, register\_is\_null(reg)) return 0; - verbose(env, "R%d type=%s expected=%s\n", regno,- reg\_type\_str[reg->type],- reg\_type\_str[PTR\_TO\_STACK]);+ verbose(env, "R%d type=%s ", regno,+ reg\_type\_str(env, reg->type));+ verbose(env, "expected=%s\n", reg\_type\_str(env, PTR\_TO\_STACK)); return -EACCES; } }@@ -4863,7 +4827,7 @@ int check\_mem\_reg(struct bpf\_verifier\_env \*env, struct bpf\_reg\_state \*reg, if (register\_is\_null(reg)) return 0; - if (reg\_type\_may\_be\_null(reg->type)) {+ if (type\_may\_be\_null(reg->type)) { /\* Assuming that the register contains a value check if the memory \* access is safe. Temporarily save and restore the register's state as \* the conversion shouldn't be visible to a caller.@@ -5197,10 +5161,10 @@ static int check\_reg\_type(struct bpf\_verifier\_env \*env, u32 regno, goto found; } - verbose(env, "R%d type=%s expected=", regno, reg\_type\_str[type]);+ verbose(env, "R%d type=%s expected=", regno, reg\_type\_str(env, type)); for (j = 0; j + 1 < i; j++)- verbose(env, "%s, ", reg\_type\_str[compatible->types[j]]);- verbose(env, "%s\n", reg\_type\_str[compatible->types[j]]);+ verbose(env, "%s, ", reg\_type\_str(env, compatible->types[j]));+ verbose(env, "%s\n", reg\_type\_str(env, compatible->types[j])); return -EACCES;  found:@@ -6474,6 +6438,7 @@ static int check\_helper\_call(struct bpf\_verifier\_env \*env, struct bpf\_insn \*insn { const struct bpf\_func\_proto \*fn = NULL; enum bpf\_return\_type ret\_type;+ enum bpf\_type\_flag ret\_flag; struct bpf\_reg\_state \*regs; struct bpf\_call\_arg\_meta meta; int insn\_idx = \*insn\_idx\_p;@@ -6614,6 +6579,7 @@ static int check\_helper\_call(struct bpf\_verifier\_env \*env, struct bpf\_insn \*insn  /\* update return register (already marked as written above) \*/ ret\_type = fn->ret\_type;+ ret\_flag = type\_flag(fn->ret\_type); if (ret\_type == RET\_INTEGER) { /\* sets type to SCALAR\_VALUE \*/ mark\_reg\_unknown(env, regs, BPF\_REG\_0);@@ -6633,25 +6599,23 @@ static int check\_helper\_call(struct bpf\_verifier\_env \*env, struct bpf\_insn \*insn } regs[BPF\_REG\_0].map\_ptr = meta.map\_ptr; regs[BPF\_REG\_0].map\_uid = meta.map\_uid;- if (type\_may\_be\_null(ret\_type)) {- regs[BPF\_REG\_0].type = PTR\_TO\_MAP\_VALUE\_OR\_NULL;- } else {- regs[BPF\_REG\_0].type = PTR\_TO\_MAP\_VALUE;- if (map\_value\_has\_spin\_lock(meta.map\_ptr))- regs[BPF\_REG\_0].id = ++env->id\_gen;+ regs[BPF\_REG\_0].type = PTR\_TO\_MAP\_VALUE | ret\_flag;+ if (!type\_may\_be\_null(ret\_type) &&+ map\_value\_has\_spin\_lock(meta.map\_ptr)) {+ regs[BPF\_REG\_0].id = ++env->id\_gen; } } else if (base\_type(ret\_type) == RET\_PTR\_TO\_SOCKET) { mark\_reg\_known\_zero(env, regs, BPF\_REG\_0);- regs[BPF\_REG\_0].type = PTR\_TO\_SOCKET\_OR\_NULL;+ regs[BPF\_REG\_0].type = PTR\_TO\_SOCKET | ret\_flag; } else if (base\_type(ret\_type) == RET\_PTR\_TO\_SOCK\_COMMON) { mark\_reg\_known\_zero(env, regs, BPF\_REG\_0);- regs[BPF\_REG\_0].type = PTR\_TO\_SOCK\_COMMON\_OR\_NULL;+ regs[BPF\_REG\_0].type = PTR\_TO\_SOCK\_COMMON | ret\_flag; } else if (base\_type(ret\_type) == RET\_PTR\_TO\_TCP\_SOCK) { mark\_reg\_known\_zero(env, regs, BPF\_REG\_0);- regs[BPF\_REG\_0].type = PTR\_TO\_TCP\_SOCK\_OR\_NULL;+ regs[BPF\_REG\_0].type = PTR\_TO\_TCP\_SOCK | ret\_flag; } else if (base\_type(ret\_type) == RET\_PTR\_TO\_ALLOC\_MEM) { mark\_reg\_known\_zero(env, regs, BPF\_REG\_0);- regs[BPF\_REG\_0].type = PTR\_TO\_MEM\_OR\_NULL;+ regs[BPF\_REG\_0].type = PTR\_TO\_MEM | ret\_flag; regs[BPF\_REG\_0].mem\_size = meta.mem\_size; } else if (base\_type(ret\_type) == RET\_PTR\_TO\_MEM\_OR\_BTF\_ID) { const struct btf\_type \*t;@@ -6671,14 +6635,10 @@ static int check\_helper\_call(struct bpf\_verifier\_env \*env, struct bpf\_insn \*insn tname, PTR\_ERR(ret)); return -EINVAL; }- regs[BPF\_REG\_0].type =- (ret\_type & PTR\_MAYBE\_NULL) ?- PTR\_TO\_MEM\_OR\_NULL : PTR\_TO\_MEM;+ regs[BPF\_REG\_0].type = PTR\_TO\_MEM | ret\_flag; regs[BPF\_REG\_0].mem\_size = tsize; } else {- regs[BPF\_REG\_0].type =- (ret\_type & PTR\_MAYBE\_NULL) ?- PTR\_TO\_BTF\_ID\_OR\_NULL : PTR\_TO\_BTF\_ID;+ regs[BPF\_REG\_0].type = PTR\_TO\_BTF\_ID | ret\_flag; regs[BPF\_REG\_0].btf = meta.ret\_btf; regs[BPF\_REG\_0].btf\_id = meta.ret\_btf\_id; }@@ -6686,9 +6646,7 @@ static int check\_helper\_call(struct bpf\_verifier\_env \*env, struct bpf\_insn \*insn int ret\_btf\_id;  mark\_reg\_known\_zero(env, regs, BPF\_REG\_0);- regs[BPF\_REG\_0].type = (ret\_type & PTR\_MAYBE\_NULL) ?- PTR\_TO\_BTF\_ID\_OR\_NULL :- PTR\_TO\_BTF\_ID;+ regs[BPF\_REG\_0].type = PTR\_TO\_BTF\_ID | ret\_flag; ret\_btf\_id = \*fn->ret\_btf\_id; if (ret\_btf\_id == 0) { verbose(env, "invalid return type %u of func %s#%d\n",@@ -6707,7 +6665,7 @@ static int check\_helper\_call(struct bpf\_verifier\_env \*env, struct bpf\_insn \*insn return -EINVAL; } - if (reg\_type\_may\_be\_null(regs[BPF\_REG\_0].type))+ if (type\_may\_be\_null(regs[BPF\_REG\_0].type)) regs[BPF\_REG\_0].id = ++env->id\_gen;  if (is\_ptr\_cast\_function(func\_id)) {@@ -6916,25 +6874,25 @@ static bool check\_reg\_sane\_offset(struct bpf\_verifier\_env \*env,  if (known && (val >= BPF\_MAX\_VAR\_OFF || val <= -BPF\_MAX\_VAR\_OFF)) { verbose(env, "math between %s pointer and %lld is not allowed\n",- reg\_type\_str[type], val);+ reg\_type\_str(env, type), val); return false; }  if (reg->off >= BPF\_MAX\_VAR\_OFF || reg->off <= -BPF\_MAX\_VAR\_OFF) { verbose(env, "%s pointer offset %d is not allowed\n",- reg\_type\_str[type], reg->off);+ reg\_type\_str(env, type), reg->off); return false; }  if (smin == S64\_MIN) { verbose(env, "math between %s pointer and register with unbounded min value is not allowed\n",- reg\_type\_str[type]);+ reg\_type\_str(env, type)); return false; }  if (smin >= BPF\_MAX\_VAR\_OFF || smin <= -BPF\_MAX\_VAR\_OFF) { verbose(env, "value %lld makes %s pointer be out of bounds\n",- smin, reg\_type\_str[type]);+ smin, reg\_type\_str(env, type)); return false; } @@ -7311,11 +7269,13 @@ static int adjust\_ptr\_min\_max\_vals(struct bpf\_verifier\_env \*env, return -EACCES; } - switch (ptr\_reg->type) {- case PTR\_TO\_MAP\_VALUE\_OR\_NULL:+ if (ptr\_reg->type & PTR\_MAYBE\_NULL) { verbose(env, "R%d pointer arithmetic on %s prohibited, null-check it first\n",- dst, reg\_type\_str[ptr\_reg->type]);+ dst, reg\_type\_str(env, ptr\_reg->type)); return -EACCES;+ }++ switch (base\_type(ptr\_reg->type)) { case CONST\_PTR\_TO\_MAP: /\* smin\_val represents the known value \*/ if (known && smin\_val == 0 && opcode == BPF\_ADD)@@ -7323,14 +7283,11 @@ static int adjust\_ptr\_min\_max\_vals(struct bpf\_verifier\_env \*env, fallthrough; case PTR\_TO\_PACKET\_END: case PTR\_TO\_SOCKET:- case PTR\_TO\_SOCKET\_OR\_NULL: case PTR\_TO\_SOCK\_COMMON:- case PTR\_TO\_SOCK\_COMMON\_OR\_NULL: case PTR\_TO\_TCP\_SOCK:- case PTR\_TO\_TCP\_SOCK\_OR\_NULL: case PTR\_TO\_XDP\_SOCK: verbose(env, "R%d pointer arithmetic on %s prohibited\n",- dst, reg\_type\_str[ptr\_reg->type]);+ dst, reg\_type\_str(env, ptr\_reg->type)); return -EACCES; default: break;@@ -9049,7 +9006,7 @@ static void mark\_ptr\_or\_null\_reg(struct bpf\_func\_state \*state, struct bpf\_reg\_state \*reg, u32 id, bool is\_null) {- if (reg\_type\_may\_be\_null(reg->type) && reg->id == id &&+ if (type\_may\_be\_null(reg->type) && reg->id == id && !WARN\_ON\_ONCE(!reg->id)) { /\* Old offset (both fixed and variable parts) should \* have been known-zero, because we don't allow pointer@@ -9427,7 +9384,7 @@ static int check\_cond\_jmp\_op(struct bpf\_verifier\_env \*env, \*/ if (!is\_jmp32 && BPF\_SRC(insn->code) == BPF\_K && insn->imm == 0 && (opcode == BPF\_JEQ || opcode == BPF\_JNE) &&- reg\_type\_may\_be\_null(dst\_reg->type)) {+ type\_may\_be\_null(dst\_reg->type)) { /\* Mark all identical registers in each branch as either \* safe or unknown depending R == 0 or R != 0 conditional. \*/@@ -9681,7 +9638,7 @@ static int check\_return\_code(struct bpf\_verifier\_env \*env) /\* enforce return zero from async callbacks like timer \*/ if (reg->type != SCALAR\_VALUE) { verbose(env, "In async callback the register R0 is not a known value (%s)\n",- reg\_type\_str[reg->type]);+ reg\_type\_str(env, reg->type)); return -EINVAL; } @@ -9695,7 +9652,7 @@ static int check\_return\_code(struct bpf\_verifier\_env \*env) if (is\_subprog) { if (reg->type != SCALAR\_VALUE) { verbose(env, "At subprogram exit the register R0 is not a scalar value (%s)\n",- reg\_type\_str[reg->type]);+ reg\_type\_str(env, reg->type)); return -EINVAL; } return 0;@@ -9759,7 +9716,7 @@ static int check\_return\_code(struct bpf\_verifier\_env \*env)  if (reg->type != SCALAR\_VALUE) { verbose(env, "At program exit the register R0 is not a known value (%s)\n",- reg\_type\_str[reg->type]);+ reg\_type\_str(env, reg->type)); return -EINVAL; } @@ -10616,7 +10573,7 @@ static bool regsafe(struct bpf\_verifier\_env \*env, struct bpf\_reg\_state \*rold, return true; if (rcur->type == NOT\_INIT) return false;- switch (rold->type) {+ switch (base\_type(rold->type)) { case SCALAR\_VALUE: if (env->explore\_alu\_limits) return false;@@ -10638,6 +10595,22 @@ static bool regsafe(struct bpf\_verifier\_env \*env, struct bpf\_reg\_state \*rold, } case PTR\_TO\_MAP\_KEY: case PTR\_TO\_MAP\_VALUE:+ /\* a PTR\_TO\_MAP\_VALUE could be safe to use as a+ \* PTR\_TO\_MAP\_VALUE\_OR\_NULL into the same map.+ \* However, if the old PTR\_TO\_MAP\_VALUE\_OR\_NULL then got NULL-+ \* checked, doing so could have affected others with the same+ \* id, and we can't check for that because we lost the id when+ \* we converted to a PTR\_TO\_MAP\_VALUE.+ \*/+ if (type\_may\_be\_null(rold->type)) {+ if (!type\_may\_be\_null(rcur->type))+ return false;+ if (memcmp(rold, rcur, offsetof(struct bpf\_reg\_state, id)))+ return false;+ /\* Check our ids match any regs they're supposed to \*/+ return check\_ids(rold->id, rcur->id, idmap);+ }+ /\* If the new min/max/var\_off satisfy the old ones and \* everything else matches, we are OK. \* 'id' is not compared, since it's only used for maps with@@ -10649,20 +10622,6 @@ static bool regsafe(struct bpf\_verifier\_env \*env, struct bpf\_reg\_state \*rold, return memcmp(rold, rcur, offsetof(struct bpf\_reg\_state, id)) == 0 && range\_within(rold, rcur) && tnum\_in(rold->var\_off, rcur->var\_off);- case PTR\_TO\_MAP\_VALUE\_OR\_NULL:- /\* a PTR\_TO\_MAP\_VALUE could be safe to use as a- \* PTR\_TO\_MAP\_VALUE\_OR\_NULL into the same map.- \* However, if the old PTR\_TO\_MAP\_VALUE\_OR\_NULL then got NULL-- \* checked, doing so could have affected others with the same- \* id, and we can't check for that because we lost the id when- \* we converted to a PTR\_TO\_MAP\_VALUE.- \*/- if (rcur->type != PTR\_TO\_MAP\_VALUE\_OR\_NULL)- return false;- if (memcmp(rold, rcur, offsetof(struct bpf\_reg\_state, id)))- return false;- /\* Check our ids match any regs they're supposed to \*/- return check\_ids(rold->id, rcur->id, idmap); case PTR\_TO\_PACKET\_META: case PTR\_TO\_PACKET: if (rcur->type != rold->type)@@ -10691,11 +10650,8 @@ static bool regsafe(struct bpf\_verifier\_env \*env, struct bpf\_reg\_state \*rold, case PTR\_TO\_PACKET\_END: case PTR\_TO\_FLOW\_KEYS: case PTR\_TO\_SOCKET:- case PTR\_TO\_SOCKET\_OR\_NULL: case PTR\_TO\_SOCK\_COMMON:- case PTR\_TO\_SOCK\_COMMON\_OR\_NULL: case PTR\_TO\_TCP\_SOCK:- case PTR\_TO\_TCP\_SOCK\_OR\_NULL: case PTR\_TO\_XDP\_SOCK: /\* Only valid matches are exact, which memcmp() above \* would have accepted@@ -11221,17 +11177,13 @@ next: /\* Return true if it's OK to have the same insn return a different type. \*/ static bool reg\_type\_mismatch\_ok(enum bpf\_reg\_type type) {- switch (type) {+ switch (base\_type(type)) { case PTR\_TO\_CTX: case PTR\_TO\_SOCKET:- case PTR\_TO\_SOCKET\_OR\_NULL: case PTR\_TO\_SOCK\_COMMON:- case PTR\_TO\_SOCK\_COMMON\_OR\_NULL: case PTR\_TO\_TCP\_SOCK:- case PTR\_TO\_TCP\_SOCK\_OR\_NULL: case PTR\_TO\_XDP\_SOCK: case PTR\_TO\_BTF\_ID:- case PTR\_TO\_BTF\_ID\_OR\_NULL: return false; default: return true;@@ -11457,7 +11409,7 @@ static int do\_check(struct bpf\_verifier\_env \*env) if (is\_ctx\_reg(env, insn->dst\_reg)) { verbose(env, "BPF\_ST stores into R%d %s is not allowed\n", insn->dst\_reg,- reg\_type\_str[reg\_state(env, insn->dst\_reg)->type]);+ reg\_type\_str(env, reg\_state(env, insn->dst\_reg)->type)); return -EACCES; } diff --git a/net/core/bpf\_sk\_storage.c b/net/core/bpf\_sk\_storage.cindex 68d2cbf8331ac5..4cb5ef8eddbc4c 100644--- a/[net/core/bpf\_sk\_storage.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/core/bpf_sk_storage.c?id=3c4807322660d4290ac9062c034aed6b87243861)+++ b/[net/core/bpf\_sk\_storage.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/core/bpf_sk_storage.c?id=c25b2ae136039ffa820c26138ed4a5e5f3ab3841)@@ -929,7 +929,7 @@ static struct bpf\_iter\_reg bpf\_sk\_storage\_map\_reg\_info = { { offsetof(struct bpf\_iter\_\_bpf\_sk\_storage\_map, sk), PTR\_TO\_BTF\_ID\_OR\_NULL }, { offsetof(struct bpf\_iter\_\_bpf\_sk\_storage\_map, value),- PTR\_TO\_RDWR\_BUF\_OR\_NULL },+ PTR\_TO\_RDWR\_BUF | PTR\_MAYBE\_NULL }, }, .seq\_info = &iter\_seq\_info, };diff --git a/net/core/sock\_map.c b/net/core/sock\_map.cindex 4ca4b11f4e5ffd..96d4ea7e6918e9 100644--- a/[net/core/sock\_map.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/core/sock_map.c?id=3c4807322660d4290ac9062c034aed6b87243861)+++ b/[net/core/sock\_map.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/core/sock_map.c?id=c25b2ae136039ffa820c26138ed4a5e5f3ab3841)@@ -1564,7 +1564,7 @@ static struct bpf\_iter\_reg sock\_map\_iter\_reg = { .ctx\_arg\_info\_size = 2, .ctx\_arg\_info = { { offsetof(struct bpf\_iter\_\_sockmap, key),- PTR\_TO\_RDONLY\_BUF\_OR\_NULL },+ PTR\_TO\_RDONLY\_BUF | PTR\_MAYBE\_NULL }, { offsetof(struct bpf\_iter\_\_sockmap, sk), PTR\_TO\_BTF\_ID\_OR\_NULL }, }, |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-05 16:27:56 +0000

