

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=eff53aea3855f71992c043cebb1c00988c17ee20)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=eff53aea3855f71992c043cebb1c00988c17ee20)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=eff53aea3855f71992c043cebb1c00988c17ee20)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=eff53aea3855f71992c043cebb1c00988c17ee20)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Deepak Gupta <debug@rivosinc.com> | 2023-09-27 22:47:59 +0000 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2023-11-28 17:19:47 +0000 |
| commit | [eff53aea3855f71992c043cebb1c00988c17ee20](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=eff53aea3855f71992c043cebb1c00988c17ee20) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=eff53aea3855f71992c043cebb1c00988c17ee20)) | |
| tree | [14d50004df6e42f4003ec7bf9fd4111ae31a1d42](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=eff53aea3855f71992c043cebb1c00988c17ee20) | |
| parent | [ef4e484ab0136e5f8616c45ad13b2f67dc922998](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ef4e484ab0136e5f8616c45ad13b2f67dc922998) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=eff53aea3855f71992c043cebb1c00988c17ee20&id2=ef4e484ab0136e5f8616c45ad13b2f67dc922998)) | |
| download | [linux-eff53aea3855f71992c043cebb1c00988c17ee20.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-eff53aea3855f71992c043cebb1c00988c17ee20.tar.gz) | |

riscv: VMAP\_STACK overflow detection thread-safe[ Upstream commit be97d0db5f44c0674480cb79ac6f5b0529b84c76 ]
commit 31da94c25aea ("riscv: add VMAP\_STACK overflow detection") added
support for CONFIG\_VMAP\_STACK. If overflow is detected, CPU switches to
`shadow\_stack` temporarily before switching finally to per-cpu
`overflow\_stack`.
If two CPUs/harts are racing and end up in over flowing kernel stack, one
or both will end up corrupting each other state because `shadow\_stack` is
not per-cpu. This patch optimizes per-cpu overflow stack switch by
directly picking per-cpu `overflow\_stack` and gets rid of `shadow\_stack`.
Following are the changes in this patch
- Defines an asm macro to obtain per-cpu symbols in destination
register.
- In entry.S, when overflow is detected, per-cpu overflow stack is
located using per-cpu asm macro. Computing per-cpu symbol requires
a temporary register. x31 is saved away into CSR\_SCRATCH
(CSR\_SCRATCH is anyways zero since we're in kernel).
Please see Links for additional relevant disccussion and alternative
solution.
Tested by `echo EXHAUST\_STACK > /sys/kernel/debug/provoke-crash/DIRECT`
Kernel crash log below
Insufficient stack space to handle exception!/debug/provoke-crash/DIRECT
Task stack: [0xff20000010a98000..0xff20000010a9c000]
Overflow stack: [0xff600001f7d98370..0xff600001f7d99370]
CPU: 1 PID: 205 Comm: bash Not tainted 6.1.0-rc2-00001-g328a1f96f7b9 #34
Hardware name: riscv-virtio,qemu (DT)
epc : \_\_memset+0x60/0xfc
ra : recursive\_loop+0x48/0xc6 [lkdtm]
epc : ffffffff808de0e4 ra : ffffffff0163a752 sp : ff20000010a97e80
gp : ffffffff815c0330 tp : ff600000820ea280 t0 : ff20000010a97e88
t1 : 000000000000002e t2 : 3233206874706564 s0 : ff20000010a982b0
s1 : 0000000000000012 a0 : ff20000010a97e88 a1 : 0000000000000000
a2 : 0000000000000400 a3 : ff20000010a98288 a4 : 0000000000000000
a5 : 0000000000000000 a6 : fffffffffffe43f0 a7 : 00007fffffffffff
s2 : ff20000010a97e88 s3 : ffffffff01644680 s4 : ff20000010a9be90
s5 : ff600000842ba6c0 s6 : 00aaaaaac29e42b0 s7 : 00fffffff0aa3684
s8 : 00aaaaaac2978040 s9 : 0000000000000065 s10: 00ffffff8a7cad10
s11: 00ffffff8a76a4e0 t3 : ffffffff815dbaf4 t4 : ffffffff815dbaf4
t5 : ffffffff815dbab8 t6 : ff20000010a9bb48
status: 0000000200000120 badaddr: ff20000010a97e88 cause: 000000000000000f
Kernel panic - not syncing: Kernel stack overflow
CPU: 1 PID: 205 Comm: bash Not tainted 6.1.0-rc2-00001-g328a1f96f7b9 #34
Hardware name: riscv-virtio,qemu (DT)
Call Trace:
[<ffffffff80006754>] dump\_backtrace+0x30/0x38
[<ffffffff808de798>] show\_stack+0x40/0x4c
[<ffffffff808ea2a8>] dump\_stack\_lvl+0x44/0x5c
[<ffffffff808ea2d8>] dump\_stack+0x18/0x20
[<ffffffff808dec06>] panic+0x126/0x2fe
[<ffffffff800065ea>] walk\_stackframe+0x0/0xf0
[<ffffffff0163a752>] recursive\_loop+0x48/0xc6 [lkdtm]
SMP: stopping secondary CPUs
---[ end Kernel panic - not syncing: Kernel stack overflow ]---
Cc: Guo Ren <guoren@kernel.org>
Cc: Jisheng Zhang <jszhang@kernel.org>
Link: [https://lore.kernel.org/linux-riscv/Y347B0x4VUNOd6V7@xhacker/T/#t](https://lore.kernel.org/linux-riscv/Y347B0x4VUNOd6V7%40xhacker/T/#t)
Link: [https://lore.kernel.org/lkml/20221124094845.1907443-1-debug@rivosinc.com/](https://lore.kernel.org/lkml/20221124094845.1907443-1-debug%40rivosinc.com/)
Signed-off-by: Deepak Gupta <debug@rivosinc.com>
Co-developed-by: Sami Tolvanen <samitolvanen@google.com>
Signed-off-by: Sami Tolvanen <samitolvanen@google.com>
Acked-by: Guo Ren <guoren@kernel.org>
Tested-by: Nathan Chancellor <nathan@kernel.org>
Link: [https://lore.kernel.org/r/20230927224757.1154247-9-samitolvanen@google.com](https://lore.kernel.org/r/20230927224757.1154247-9-samitolvanen%40google.com)
Signed-off-by: Palmer Dabbelt <palmer@rivosinc.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=eff53aea3855f71992c043cebb1c00988c17ee20)

| -rw-r--r-- | [arch/riscv/include/asm/asm-prototypes.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/riscv/include/asm/asm-prototypes.h?id=eff53aea3855f71992c043cebb1c00988c17ee20) | 1 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [arch/riscv/include/asm/asm.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/riscv/include/asm/asm.h?id=eff53aea3855f71992c043cebb1c00988c17ee20) | 22 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/riscv/include/asm/thread\_info.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/riscv/include/asm/thread_info.h?id=eff53aea3855f71992c043cebb1c00988c17ee20) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/riscv/kernel/asm-offsets.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/riscv/kernel/asm-offsets.c?id=eff53aea3855f71992c043cebb1c00988c17ee20) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/riscv/kernel/entry.S](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/riscv/kernel/entry.S?id=eff53aea3855f71992c043cebb1c00988c17ee20) | 70 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/riscv/kernel/traps.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/riscv/kernel/traps.c?id=eff53aea3855f71992c043cebb1c00988c17ee20) | 36 | |  |  |  | | --- | --- | --- | |

6 files changed, 34 insertions, 99 deletions

| diff --git a/arch/riscv/include/asm/asm-prototypes.h b/arch/riscv/include/asm/asm-prototypes.hindex 61ba8ed43d8feb..36b955c762ba08 100644--- a/[arch/riscv/include/asm/asm-prototypes.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/riscv/include/asm/asm-prototypes.h?id=ef4e484ab0136e5f8616c45ad13b2f67dc922998)+++ b/[arch/riscv/include/asm/asm-prototypes.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/riscv/include/asm/asm-prototypes.h?id=eff53aea3855f71992c043cebb1c00988c17ee20)@@ -25,7 +25,6 @@ DECLARE\_DO\_ERROR\_INFO(do\_trap\_ecall\_s); DECLARE\_DO\_ERROR\_INFO(do\_trap\_ecall\_m); DECLARE\_DO\_ERROR\_INFO(do\_trap\_break); -asmlinkage unsigned long get\_overflow\_stack(void); asmlinkage void handle\_bad\_stack(struct pt\_regs \*regs); asmlinkage void do\_page\_fault(struct pt\_regs \*regs); asmlinkage void do\_irq(struct pt\_regs \*regs);diff --git a/arch/riscv/include/asm/asm.h b/arch/riscv/include/asm/asm.hindex 114bbadaef41eb..bfb4c26f113c4b 100644--- a/[arch/riscv/include/asm/asm.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/riscv/include/asm/asm.h?id=ef4e484ab0136e5f8616c45ad13b2f67dc922998)+++ b/[arch/riscv/include/asm/asm.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/riscv/include/asm/asm.h?id=eff53aea3855f71992c043cebb1c00988c17ee20)@@ -82,6 +82,28 @@ .endr .endm +#ifdef CONFIG\_SMP+#ifdef CONFIG\_32BIT+#define PER\_CPU\_OFFSET\_SHIFT 2+#else+#define PER\_CPU\_OFFSET\_SHIFT 3+#endif++.macro asm\_per\_cpu dst sym tmp+ REG\_L \tmp, TASK\_TI\_CPU\_NUM(tp)+ slli \tmp, \tmp, PER\_CPU\_OFFSET\_SHIFT+ la \dst, \_\_per\_cpu\_offset+ add \dst, \dst, \tmp+ REG\_L \tmp, 0(\dst)+ la \dst, \sym+ add \dst, \dst, \tmp+.endm+#else /\* CONFIG\_SMP \*/+.macro asm\_per\_cpu dst sym tmp+ la \dst, \sym+.endm+#endif /\* CONFIG\_SMP \*/+ /\* save all GPs except x1 ~ x5 \*/ .macro save\_from\_x6\_to\_x31 REG\_S x6, PT\_T1(sp)diff --git a/arch/riscv/include/asm/thread\_info.h b/arch/riscv/include/asm/thread\_info.hindex 1833beb00489c3..d18ce0113ca1f1 100644--- a/[arch/riscv/include/asm/thread\_info.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/riscv/include/asm/thread_info.h?id=ef4e484ab0136e5f8616c45ad13b2f67dc922998)+++ b/[arch/riscv/include/asm/thread\_info.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/riscv/include/asm/thread_info.h?id=eff53aea3855f71992c043cebb1c00988c17ee20)@@ -34,9 +34,6 @@  #ifndef \_\_ASSEMBLY\_\_ -extern long shadow\_stack[SHADOW\_OVERFLOW\_STACK\_SIZE / sizeof(long)];-extern unsigned long spin\_shadow\_stack;- #include <asm/processor.h> #include <asm/csr.h> diff --git a/arch/riscv/kernel/asm-offsets.c b/arch/riscv/kernel/asm-offsets.cindex d6a75aac1d27a5..9f535d5de33f93 100644--- a/[arch/riscv/kernel/asm-offsets.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/riscv/kernel/asm-offsets.c?id=ef4e484ab0136e5f8616c45ad13b2f67dc922998)+++ b/[arch/riscv/kernel/asm-offsets.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/riscv/kernel/asm-offsets.c?id=eff53aea3855f71992c043cebb1c00988c17ee20)@@ -39,6 +39,7 @@ void asm\_offsets(void) OFFSET(TASK\_TI\_KERNEL\_SP, task\_struct, thread\_info.kernel\_sp); OFFSET(TASK\_TI\_USER\_SP, task\_struct, thread\_info.user\_sp); + OFFSET(TASK\_TI\_CPU\_NUM, task\_struct, thread\_info.cpu); OFFSET(TASK\_THREAD\_F0, task\_struct, thread.fstate.f[0]); OFFSET(TASK\_THREAD\_F1, task\_struct, thread.fstate.f[1]); OFFSET(TASK\_THREAD\_F2, task\_struct, thread.fstate.f[2]);diff --git a/arch/riscv/kernel/entry.S b/arch/riscv/kernel/entry.Sindex 143a2bb3e69760..3d11aa3af105e0 100644--- a/[arch/riscv/kernel/entry.S](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/riscv/kernel/entry.S?id=ef4e484ab0136e5f8616c45ad13b2f67dc922998)+++ b/[arch/riscv/kernel/entry.S](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/riscv/kernel/entry.S?id=eff53aea3855f71992c043cebb1c00988c17ee20)@@ -10,9 +10,11 @@ #include <asm/asm.h> #include <asm/csr.h> #include <asm/unistd.h>+#include <asm/page.h> #include <asm/thread\_info.h> #include <asm/asm-offsets.h> #include <asm/errata\_list.h>+#include <linux/sizes.h>  SYM\_CODE\_START(handle\_exception) /\*@@ -170,67 +172,15 @@ SYM\_CODE\_END(ret\_from\_exception)  #ifdef CONFIG\_VMAP\_STACK SYM\_CODE\_START\_LOCAL(handle\_kernel\_stack\_overflow)- /\*- \* Takes the psuedo-spinlock for the shadow stack, in case multiple- \* harts are concurrently overflowing their kernel stacks. We could- \* store any value here, but since we're overflowing the kernel stack- \* already we only have SP to use as a scratch register. So we just- \* swap in the address of the spinlock, as that's definately non-zero.- \*- \* Pairs with a store\_release in handle\_bad\_stack().- \*/-1: la sp, spin\_shadow\_stack- REG\_AMOSWAP\_AQ sp, sp, (sp)- bnez sp, 1b-- la sp, shadow\_stack- addi sp, sp, SHADOW\_OVERFLOW\_STACK\_SIZE-- //save caller register to shadow stack- addi sp, sp, -(PT\_SIZE\_ON\_STACK)- REG\_S x1, PT\_RA(sp)- REG\_S x5, PT\_T0(sp)- REG\_S x6, PT\_T1(sp)- REG\_S x7, PT\_T2(sp)- REG\_S x10, PT\_A0(sp)- REG\_S x11, PT\_A1(sp)- REG\_S x12, PT\_A2(sp)- REG\_S x13, PT\_A3(sp)- REG\_S x14, PT\_A4(sp)- REG\_S x15, PT\_A5(sp)- REG\_S x16, PT\_A6(sp)- REG\_S x17, PT\_A7(sp)- REG\_S x28, PT\_T3(sp)- REG\_S x29, PT\_T4(sp)- REG\_S x30, PT\_T5(sp)- REG\_S x31, PT\_T6(sp)-- la ra, restore\_caller\_reg- tail get\_overflow\_stack--restore\_caller\_reg:- //save per-cpu overflow stack- REG\_S a0, -8(sp)- //restore caller register from shadow\_stack- REG\_L x1, PT\_RA(sp)- REG\_L x5, PT\_T0(sp)- REG\_L x6, PT\_T1(sp)- REG\_L x7, PT\_T2(sp)- REG\_L x10, PT\_A0(sp)- REG\_L x11, PT\_A1(sp)- REG\_L x12, PT\_A2(sp)- REG\_L x13, PT\_A3(sp)- REG\_L x14, PT\_A4(sp)- REG\_L x15, PT\_A5(sp)- REG\_L x16, PT\_A6(sp)- REG\_L x17, PT\_A7(sp)- REG\_L x28, PT\_T3(sp)- REG\_L x29, PT\_T4(sp)- REG\_L x30, PT\_T5(sp)- REG\_L x31, PT\_T6(sp)+ /\* we reach here from kernel context, sscratch must be 0 \*/+ csrrw x31, CSR\_SCRATCH, x31+ asm\_per\_cpu sp, overflow\_stack, x31+ li x31, OVERFLOW\_STACK\_SIZE+ add sp, sp, x31+ /\* zero out x31 again and restore x31 \*/+ xor x31, x31, x31+ csrrw x31, CSR\_SCRATCH, x31 - //load per-cpu overflow stack- REG\_L sp, -8(sp) addi sp, sp, -(PT\_SIZE\_ON\_STACK)  //save context to overflow stackdiff --git a/arch/riscv/kernel/traps.c b/arch/riscv/kernel/traps.cindex fae8f610d867fd..67d0073fb624de 100644--- a/[arch/riscv/kernel/traps.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/riscv/kernel/traps.c?id=ef4e484ab0136e5f8616c45ad13b2f67dc922998)+++ b/[arch/riscv/kernel/traps.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/riscv/kernel/traps.c?id=eff53aea3855f71992c043cebb1c00988c17ee20)@@ -410,48 +410,14 @@ int is\_valid\_bugaddr(unsigned long pc) #endif /\* CONFIG\_GENERIC\_BUG \*/  #ifdef CONFIG\_VMAP\_STACK-/\*- \* Extra stack space that allows us to provide panic messages when the kernel- \* has overflowed its stack.- \*/-static DEFINE\_PER\_CPU(unsigned long [OVERFLOW\_STACK\_SIZE/sizeof(long)],+DEFINE\_PER\_CPU(unsigned long [OVERFLOW\_STACK\_SIZE/sizeof(long)], overflow\_stack)\_\_aligned(16);-/\*- \* A temporary stack for use by handle\_kernel\_stack\_overflow. This is used so- \* we can call into C code to get the per-hart overflow stack. Usage of this- \* stack must be protected by spin\_shadow\_stack.- \*/-long shadow\_stack[SHADOW\_OVERFLOW\_STACK\_SIZE/sizeof(long)] \_\_aligned(16);--/\*- \* A pseudo spinlock to protect the shadow stack from being used by multiple- \* harts concurrently. This isn't a real spinlock because the lock side must- \* be taken without a valid stack and only a single register, it's only taken- \* while in the process of panicing anyway so the performance and error- \* checking a proper spinlock gives us doesn't matter.- \*/-unsigned long spin\_shadow\_stack;--asmlinkage unsigned long get\_overflow\_stack(void)-{- return (unsigned long)this\_cpu\_ptr(overflow\_stack) +- OVERFLOW\_STACK\_SIZE;-}  asmlinkage void handle\_bad\_stack(struct pt\_regs \*regs) { unsigned long tsk\_stk = (unsigned long)current->stack; unsigned long ovf\_stk = (unsigned long)this\_cpu\_ptr(overflow\_stack); - /\*- \* We're done with the shadow stack by this point, as we're on the- \* overflow stack. Tell any other concurrent overflowing harts that- \* they can proceed with panicing by releasing the pseudo-spinlock.- \*- \* This pairs with an amoswap.aq in handle\_kernel\_stack\_overflow.- \*/- smp\_store\_release(&spin\_shadow\_stack, 0);- console\_verbose();  pr\_emerg("Insufficient stack space to handle exception!\n"); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 08:16:20 +0000

