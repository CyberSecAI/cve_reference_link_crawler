
[**novy's Blog**](/)

* [首页](/)
* [归档](/archives/)
* [分类](/categories/)
* [标签](/tags/)
* [关于](/about/)
* [友情链接](/links/)
* [RSS](/rss2.xml)

novy

July 2, 2023 pm

3k 字

9 分钟

 次

# PowerJob Remote Command/Code Execution

PowerJob本身没有鉴权网关，所以所有接口都可以未授权操作

首先看JobController的runImmediately方法负责执行任务，

任务调度的处理过程有点复杂，详情看

<https://blog.csdn.net/qq_42985872/article/details/128500740>

定位到类：WorkerActor

onReceiveServerScheduleJobReq方法负责处理runjob节点的请求。此时空属性的ServerScheduleJobReq对象会传递进入下一级onReceiveServerScheduleJobReq方法

![image](/images/99/o5z_FwKXzvnwzzam6CAfy6yo6t5s3OsVrfOnPTzEgtM.png)

onReceiveServerScheduleJobReq方法会根据任务类型进入不同的处理，轻量级任务进入LightTaskTracker

![image](/images/99/rXVI7l0HP6BB3M_t7AAJQBgBlHBTBx8CvVQHKiPLxtQ.png)

而重量级任务则会进入HeavyTaskTracker

![image](/images/99/fAmhwqCuTrdVvGHqGKrByefF4DAO8SwSKY3Imva5oUA.png)

跟进isLightweightTask方法查看如何判断的级别

![image](/images/99/rgPOxmOxiC4-w06HhU-pgsnuOa_8Of7YqZ42QTzBdpo.png)

从isLightweightTask方法得知，单机、固定频率、固定延迟模式都属于轻量，其他则是重量

先跟进轻量，LightTaskTracker#create

![image](/images/99/aiqoHW4qnNBfDkdgPpAWcfIKqAQM9UAVXYULHI72eRA.png)

请求传进LightTaskTracker对象：

![image](/images/99/9ERjIOBYwoBqTMWgIIfhch5xBUGmuEygw7_Q3WOWDk4.png)

在构造方法中做了大量的初始化设定，具体为：会使用父类对请求先做一次参数初始化

![image](/images/99/f4366pdLsBSPfO93M9EjEuzQ3UBiGj8gR8DEbVK9FE0.png)

此时的req是包含有控制台传来的各项参数，继续往下走，constructTaskContext方法会将各项参数封装到taskContext对象

![image](/images/99/RSfbIOenMUptyfXLQCzuu-kwfd1EcClmMkaAwVZJ7Bo.png)

![image](/images/99/Op1UdjsFJdvHYgkW5UT0xe93nvpblhu9vNTJyNLUrQE.png)

随后进入到load方法加载控制台传来的ProcessorInfo

![image](/images/99/M5E29ntyZ1aI68syFf4VsFE30QA3dxfL41W2tti_94I.png)

在PowerJobProcessorLoader#load方法中，ProcessorInfo信息又被传进pf.build方法

![image](/images/99/r_cvNoi14O69sldMY1BaD2FmMvTc-lWy-eqS3DWhwBI.png)

pf是包含 BuiltInDefaultProcessorFactory、JarContainerProcessorFactory的对象

![image](/images/99/nFJJBpgefF8uesgu0u2JYw4UOnXhC9XnH3JlceW_Smw.png)

在load流程里，会根据传进的处理器类型进入不同的Factory

![image](/images/99/CqbBr0UqhA28cOw6erogK-RPcBNzxuJYVwx8v38CLVc.png)

得到处理器参数：BUILT\_IN、EXTERNAL

![image](/images/99/pGdLPwHoWhHYOA6UTia53BAsslF5jBEs8gg9HNH4OPI.png)

分别查看两个Factory

JarContainerProcessorFactory：

根据注释得知该类是从容器加载class，从传进的参数中获取容器id以及容器里的全限定类名，格式大概是这样id#xx.xxx.xxx，当processorType是EXTERNAL时就会用到这个Factory

![image](/images/99/iqHGgwTEYfwHinPrsge7xciRTNrdfr2-MQ700IpkmYM.png)

BuiltInDefaultProcessorFactory：

BuiltInDefaultProcessorFactory是内建的默认处理器工厂，可以通过全限定类名加载处理器，在build方法中，会根据传进的ProcessorInfo信息来实例化对象，即ProcessorInfo参数就是全限定类名。当processorType是BUILT\_IN时就会用到这个Factory

![image](/images/99/wVx3T96hJAnVbGhopt6Z4vMuY9kyDEOILeGiPo2WU6o.png)

load方法走完了，回到构造方法LightTaskTracker中，实例化后的ProcessorInfo信息被封装到processorBean对象

![image](/images/99/CcvkyaUO1B7H8ajuBgt326TR6f7RmLpq2i9ZLP4D6uI.png)

![image](/images/99/7IfmcNlZ67RXPPCgK4jdOdUvbR4KxetDV5oQPyGJ1xo.png)

在初始化完所有信息后，进入到processTask方法，其会在线程池中完成被调用

![image](/images/99/WfBywAwMiUMVWyXF9NWzL15fdJv8CSVDf7uT4LRNjCQ.png)

跟进processTask方法，参数传进process

![image](/images/99/S6WHFAh1snUZ-Ho6KRiAkug7Xbluy_70PplUbIjfk64.png)

因为在此之前设置了当前线程上下文加载器

![image](/images/99/LMP7MLIZYdxxwwMBFfrkiSHzKlWdKE0UOuLVaJo6aLE.png)

所以此时被实例化的processorBean会使用到前面实例化时设置的classloader加载

![image](/images/99/fWcY4yQHj_0EVzihquGzZ7FL1I7cLQIDcJ6waiJOaPg.png)

进入到

CommonBasicProcessor#process

该类是一个通用处理器类

![image](/images/99/iaSFp6HoWgdnC5J9wnTuOXR-HQyz8NwEaT0CZ_BYO4.png)

process方法中，将包含有任务参数、任务instanceId等信息的TaskContext对象传进process0方法

![image](/images/99/2a_6OAi_dOkNlzbv6cwfeWCBmX_DcFNl_V2jXNOUSgY.png)

![image](/images/99/FoHnNt5nZewDKKfQWgsckLjRU0amt-u8nkjMywjDLHk.png)

process0方法属于AbstractScriptProcessor类，该类属于通用脚本处理器类，所有脚本插件都要继承该类。在process0方法中，会使用prepareScriptFile方法来根据控制台传来的内容生成脚本文件，文件名是instanceId

![image](/images/99/07xl9k69FGgwoTRME6gsoOdox0zj_-jENbekFDVnGOA.png)

![image](/images/99/i7Ie1F2BYZwY8VV5MPWhIvrM7NMR_K4pO_FZQ3DCz20.png)

跟进getScriptName方法发现是一个抽象方法

![image](/images/99/NVavflV4Ekk9Of5eCMiUezddZex_1TI408lgJz3UXa8.png)

所在的抽象类由多个插件类继承，用于应对不同系统的调用。在powerjob本身中自带有多个脚本处理器（插件）

![image](/images/99/0eJ5nx4fAdpZ-nabVZntMb7i9tlgH3cHEQctYOixgxk.png)

被重写的getScriptName方法大同小异，均返回对应系统的脚本文件名：cmd\_instanceId.bat/shell\_instanceId.sh

![image](/images/99/DTfharPQeHvLm2lxaa6hMNUzpagfcgporCr7IK6WKFA.png)

![image](/images/99/ry6LRdcXS7YWzvXIIeKoBtDMKz8BKxv5Ei7F8KOzLfE.png)

回到prepareScriptFile方法，最终把参数写入脚本文件

![image](/images/99/F80vz9E9xRN7k8S_-l5VLViXwPCxes26tuqLkS7cBWk.png)

回到process0方法，方法里会调用到抽象方法getRunCommand，根据子类重写的方法返回来判断要调用哪个应用来执行脚本。

也就是说，当控制台传进的processorInfo（即封装后的processorBean）是CMDProcessor类时，getRunCommand则是CMDProcessor里重写的getRunCommand方法，返回的是cmd.exe，否则就是剩余的几个Processor（python、sh、powershell）

![image](/images/99/buN2XWRZoXyK04LiPQ0Sb2Se-WLRVgyAeHf1Q9QQuAQ.png)

最终由ProcessBuilder完成对getRunCommand方法返回值的调用，scriptPath被当成返回值的参数进行执行。漏洞由此产生

剩下的HeavyTaskTracker.create不看了，可能更复杂

# 验证：

根据saveJob方法里jobInfoDO的信息构造参数保存任务，其中jobParams参数是恶意命令，最后使用runImmediately方法执行任务就会触发漏洞

| ``` 1 ``` | ``` src/main/java/tech/powerjob/server/web/controller/JobController.java ``` |
| --- | --- |

保存任务

![image](/images/99/WImONBAtVk7HWBONPNyCjFjPgVuI05Fh_SX4A73Eekg.png)

查看实体类，可以看到有一个处理器选项

Text

| ``` 1 ``` | ``` SaveJobInfoRequest ``` |
| --- | --- |

![image](/images/99/loJ8Iw5x79AczXNPAZdPBZYny0lFmmV_wYgXPi_K6mo.png)

Text

| ``` 1 ``` | ``` ProcessorType类 ``` |
| --- | --- |

![image](/images/99/1qoMlt7rpMEoeHJgQhbyphu6z7kqPZW1gJ8Iazn2r8c.png)

## V3.X及以前

在V3及以前版本中可以直接通过shell处理器的方式执行系统命令，但仅限于linux

![image](/images/99/ZJxPfgFNL8FKO84o_mpqtxbZRNgvSj9bXOxhK-Xep_Q.png)

![image](/images/99/I8i9YYIMzXo_-3BM_T0D3aIdPl_wKcctBStRl0JMSD4.png)

新建任务时，designatedWorkers可指定机器，不指定机器默认全部执行

可以查看所有机器地址

![image](/images/99/GXV_J9y4jdCxeZG698txsEUW8fNXyEA2kriV3-rXb2g.png)

processorInfo的参数为命令执行参数

![image](/images/99/ClO0n3fnusO-SUyyLCQMuGAv9KemF8gSQ7uOVjuOHs0.jpg)

搜索刚刚创建的任务关键字得出任务id

![image](/images/99/6GuiG10XvZ8PC1YMT5OySsRZ214RS2SngDu-rUfF7bw.jpg)

运行任务id得到结果id

![image](/images/99/5HZCMurI5Nl9bS7tT03kNfAzsMrB2mf9fAw5LCx1qEY.jpg)

根据id获取命令执行结果

![image](/images/99/SUaUqNXldMZhWK75tel9VlUCZCEhzzKUITeRBr02z78.jpg)

## V4.X

v4以后的处理器都是通过插件的方式调用，此时双系统都可以执行命令

![image](/images/99/rKY5sfX7RwhMpBDfrqREo0iwGjSSRMEBOO4dLEJjN88.png)

### windows：

通过内置的全限定类名执行

保存任务后，查询任务id

![image](/images/99/sh2XztQgfQkXa59C2U9jbmdczVmQmkJh38rz4rPunDo.png)

运行得到的id

![image](/images/99/cm5DLMiBDxxbcNfrcBSEFo0fojwjykAeJSu1n3ieRjQ.png)

### linux：

ShellProcessor

### python:

PythonProcessor
该脚本处理器专门处理python\_%d.py，可以往py里写入任意代码执行，但需要环境有python环境

### powershell:

PowerShellProcessor

以上都可以通过查询执行成功响应的id来查看命令回显

![image](/images/99/SUZVEelwT3BYErkVTXOIcyDBCNsR1J62MmkdUIOeqI4.png)

# tips

假如通过v3的方式在v4增加了任务，可以尝试通过接口转换执行

![image](/images/99/IJWP6bbNhMhnhCbFjzeesd7mXe916O_js2AfxAqDAck.png)

但需要目标有这个依赖

Text

| ``` 12345 ``` | ``` <dependency>    <groupId>tech.powerjob</groupId>    <artifactId>powerjob-official-processors</artifactId>    <version>4.3.3</version></dependency> ``` |
| --- | --- |

---

[代码审计](/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/)

[代码审计](/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/)

---

---

声明：
 本文章用于学习交流，严禁用于非法操作，出现后果一切自行承担，阅读此文章表示你已同意本声明。

 Disclaimer:
 This article is for study and communication. It is strictly forbidden to use it for illegal operations. All consequences shall be borne by yourself. Reading this article means that you have agreed to this statement.

[代码审计快速入门2023修改版
上一篇](/2023/07/03/112/)

[一个bsh任意代码执行
下一篇](/2023/05/18/107/)

 目录

![](/img/aa.png)

扫一扫关注我们

#### 搜索

×

关键词

© 2018-  novy`s Blog.  Powered by [Hexo](https://hexo.io)

本博客已经稳定运行：

