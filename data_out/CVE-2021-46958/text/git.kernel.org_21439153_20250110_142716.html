

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=a4794be7b00b7eda4b45fffd283ab7d76df7e5d6)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a4794be7b00b7eda4b45fffd283ab7d76df7e5d6)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a4794be7b00b7eda4b45fffd283ab7d76df7e5d6)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a4794be7b00b7eda4b45fffd283ab7d76df7e5d6)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Filipe Manana <fdmanana@suse.com> | 2021-04-05 12:32:16 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2021-05-11 14:47:15 +0200 |
| commit | [a4794be7b00b7eda4b45fffd283ab7d76df7e5d6](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a4794be7b00b7eda4b45fffd283ab7d76df7e5d6) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=a4794be7b00b7eda4b45fffd283ab7d76df7e5d6)) | |
| tree | [7918a5c99622d375c6c3750129fc3f26f98de7b6](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a4794be7b00b7eda4b45fffd283ab7d76df7e5d6) | |
| parent | [af835665ddc9fe8eef068c84d4ec216dd474e892](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=af835665ddc9fe8eef068c84d4ec216dd474e892) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a4794be7b00b7eda4b45fffd283ab7d76df7e5d6&id2=af835665ddc9fe8eef068c84d4ec216dd474e892)) | |
| download | [linux-a4794be7b00b7eda4b45fffd283ab7d76df7e5d6.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-a4794be7b00b7eda4b45fffd283ab7d76df7e5d6.tar.gz) | |

btrfs: fix race between transaction aborts and fsyncs leading to use-after-freecommit 061dde8245356d8864d29e25207aa4daa0be4d3c upstream.
There is a race between a task aborting a transaction during a commit,
a task doing an fsync and the transaction kthread, which leads to an
use-after-free of the log root tree. When this happens, it results in a
stack trace like the following:
BTRFS info (device dm-0): forced readonly
BTRFS warning (device dm-0): Skipping commit of aborted transaction.
BTRFS: error (device dm-0) in cleanup\_transaction:1958: errno=-5 IO failure
BTRFS warning (device dm-0): lost page write due to IO error on /dev/mapper/error-test (-5)
BTRFS warning (device dm-0): Skipping commit of aborted transaction.
BTRFS warning (device dm-0): direct IO failed ino 261 rw 0,0 sector 0xa4e8 len 4096 err no 10
BTRFS error (device dm-0): error writing primary super block to device 1
BTRFS warning (device dm-0): direct IO failed ino 261 rw 0,0 sector 0x12e000 len 4096 err no 10
BTRFS warning (device dm-0): direct IO failed ino 261 rw 0,0 sector 0x12e008 len 4096 err no 10
BTRFS warning (device dm-0): direct IO failed ino 261 rw 0,0 sector 0x12e010 len 4096 err no 10
BTRFS: error (device dm-0) in write\_all\_supers:4110: errno=-5 IO failure (1 errors while writing supers)
BTRFS: error (device dm-0) in btrfs\_sync\_log:3308: errno=-5 IO failure
general protection fault, probably for non-canonical address 0x6b6b6b6b6b6b6b68: 0000 [#1] PREEMPT SMP DEBUG\_PAGEALLOC PTI
CPU: 2 PID: 2458471 Comm: fsstress Not tainted 5.12.0-rc5-btrfs-next-84 #1
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04/01/2014
RIP: 0010:\_\_mutex\_lock+0x139/0xa40
Code: c0 74 19 (...)
RSP: 0018:ffff9f18830d7b00 EFLAGS: 00010202
RAX: 6b6b6b6b6b6b6b68 RBX: 0000000000000001 RCX: 0000000000000002
RDX: ffffffffb9c54d13 RSI: 0000000000000000 RDI: 0000000000000000
RBP: ffff9f18830d7bc0 R08: 0000000000000000 R09: 0000000000000000
R10: ffff9f18830d7be0 R11: 0000000000000001 R12: ffff8c6cd199c040
R13: ffff8c6c95821358 R14: 00000000fffffffb R15: ffff8c6cbcf01358
FS: 00007fa9140c2b80(0000) GS:ffff8c6fac600000(0000) knlGS:0000000000000000
CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007fa913d52000 CR3: 000000013d2b4003 CR4: 0000000000370ee0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
? \_\_btrfs\_handle\_fs\_error+0xde/0x146 [btrfs]
? btrfs\_sync\_log+0x7c1/0xf20 [btrfs]
? btrfs\_sync\_log+0x7c1/0xf20 [btrfs]
btrfs\_sync\_log+0x7c1/0xf20 [btrfs]
btrfs\_sync\_file+0x40c/0x580 [btrfs]
do\_fsync+0x38/0x70
\_\_x64\_sys\_fsync+0x10/0x20
do\_syscall\_64+0x33/0x80
entry\_SYSCALL\_64\_after\_hwframe+0x44/0xae
RIP: 0033:0x7fa9142a55c3
Code: 8b 15 09 (...)
RSP: 002b:00007fff26278d48 EFLAGS: 00000246 ORIG\_RAX: 000000000000004a
RAX: ffffffffffffffda RBX: 0000563c83cb4560 RCX: 00007fa9142a55c3
RDX: 00007fff26278cb0 RSI: 00007fff26278cb0 RDI: 0000000000000005
RBP: 0000000000000005 R08: 0000000000000001 R09: 00007fff26278d5c
R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000340
R13: 00007fff26278de0 R14: 00007fff26278d96 R15: 0000563c83ca57c0
Modules linked in: btrfs dm\_zero dm\_snapshot dm\_thin\_pool (...)
---[ end trace ee2f1b19327d791d ]---
The steps that lead to this crash are the following:
1) We are at transaction N;
2) We have two tasks with a transaction handle attached to transaction N.
Task A and Task B. Task B is doing an fsync;
3) Task B is at btrfs\_sync\_log(), and has saved fs\_info->log\_root\_tree
into a local variable named 'log\_root\_tree' at the top of
btrfs\_sync\_log(). Task B is about to call write\_all\_supers(), but
before that...
4) Task A calls btrfs\_commit\_transaction(), and after it sets the
transaction state to TRANS\_STATE\_COMMIT\_START, an error happens before
it waits for the transaction's 'num\_writers' counter to reach a value
of 1 (no one else attached to the transaction), so it jumps to the
label "cleanup\_transaction";
5) Task A then calls cleanup\_transaction(), where it aborts the
transaction, setting BTRFS\_FS\_STATE\_TRANS\_ABORTED on fs\_info->fs\_state,
setting the ->aborted field of the transaction and the handle to an
errno value and also setting BTRFS\_FS\_STATE\_ERROR on fs\_info->fs\_state.
After that, at cleanup\_transaction(), it deletes the transaction from
the list of transactions (fs\_info->trans\_list), sets the transaction
to the state TRANS\_STATE\_COMMIT\_DOING and then waits for the number
of writers to go down to 1, as it's currently 2 (1 for task A and 1
for task B);
6) The transaction kthread is running and sees that BTRFS\_FS\_STATE\_ERROR
is set in fs\_info->fs\_state, so it calls btrfs\_cleanup\_transaction().
There it sees the list fs\_info->trans\_list is empty, and then proceeds
into calling btrfs\_drop\_all\_logs(), which frees the log root tree with
a call to btrfs\_free\_log\_root\_tree();
7) Task B calls write\_all\_supers() and, shortly after, under the label
'out\_wake\_log\_root', it deferences the pointer stored in
'log\_root\_tree', which was already freed in the previous step by the
transaction kthread. This results in a use-after-free leading to a
crash.
Fix this by deleting the transaction from the list of transactions at
cleanup\_transaction() only after setting the transaction state to
TRANS\_STATE\_COMMIT\_DOING and waiting for all existing tasks that are
attached to the transaction to release their transaction handles.
This makes the transaction kthread wait for all the tasks attached to
the transaction to be done with the transaction before dropping the
log roots and doing other cleanups.
Fixes: ef67963dac255b ("btrfs: drop logs when we've aborted a transaction")
CC: stable@vger.kernel.org # 5.10+
Reviewed-by: Josef Bacik <josef@toxicpanda.com>
Signed-off-by: Filipe Manana <fdmanana@suse.com>
Signed-off-by: David Sterba <dsterba@suse.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a4794be7b00b7eda4b45fffd283ab7d76df7e5d6)

| -rw-r--r-- | [fs/btrfs/transaction.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/transaction.c?id=a4794be7b00b7eda4b45fffd283ab7d76df7e5d6) | 12 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 11 insertions, 1 deletions

| diff --git a/fs/btrfs/transaction.c b/fs/btrfs/transaction.cindex 261a50708cb897..af2f2f8704d8bc 100644--- a/[fs/btrfs/transaction.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/transaction.c?id=af835665ddc9fe8eef068c84d4ec216dd474e892)+++ b/[fs/btrfs/transaction.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/transaction.c?id=a4794be7b00b7eda4b45fffd283ab7d76df7e5d6)@@ -1950,7 +1950,6 @@ static void cleanup\_transaction(struct btrfs\_trans\_handle \*trans, int err) \*/ BUG\_ON(list\_empty(&cur\_trans->list)); - list\_del\_init(&cur\_trans->list); if (cur\_trans == fs\_info->running\_transaction) { cur\_trans->state = TRANS\_STATE\_COMMIT\_DOING; spin\_unlock(&fs\_info->trans\_lock);@@ -1959,6 +1958,17 @@ static void cleanup\_transaction(struct btrfs\_trans\_handle \*trans, int err)  spin\_lock(&fs\_info->trans\_lock); }++ /\*+ \* Now that we know no one else is still using the transaction we can+ \* remove the transaction from the list of transactions. This avoids+ \* the transaction kthread from cleaning up the transaction while some+ \* other task is still using it, which could result in a use-after-free+ \* on things like log trees, as it forces the transaction kthread to+ \* wait for this transaction to be cleaned up by us.+ \*/+ list\_del\_init(&cur\_trans->list);+ spin\_unlock(&fs\_info->trans\_lock);  btrfs\_cleanup\_one\_transaction(trans->transaction, fs\_info); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 14:25:54 +0000

