=== Content from github.com_1a773ef3_20250108_130017.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FSamsung%2FmTower%2Fissues%2F81)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FSamsung%2FmTower%2Fissues%2F81)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fissues_fragments%2Fissue_layout&source=header-repo&source_repo=Samsung%2FmTower)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[Samsung](/Samsung)
/
**[mTower](/Samsung/mTower)**
Public

* [Notifications](/login?return_to=%2FSamsung%2FmTower) You must be signed in to change notification settings
* [Fork
  17](/login?return_to=%2FSamsung%2FmTower)
* [Star
   54](/login?return_to=%2FSamsung%2FmTower)

* [Code](/Samsung/mTower)
* [Issues
  13](/Samsung/mTower/issues)
* [Pull requests
  0](/Samsung/mTower/pulls)
* [Actions](/Samsung/mTower/actions)
* [Projects
  0](/Samsung/mTower/projects)
* [Security](/Samsung/mTower/security)
* [Insights](/Samsung/mTower/pulse)

Additional navigation options

* [Code](/Samsung/mTower)
* [Issues](/Samsung/mTower/issues)
* [Pull requests](/Samsung/mTower/pulls)
* [Actions](/Samsung/mTower/actions)
* [Projects](/Samsung/mTower/projects)
* [Security](/Samsung/mTower/security)
* [Insights](/Samsung/mTower/pulse)

New issue

**Have a question about this project?** Sign up for a free GitHub account to open an issue and contact its maintainers and the community.

 [Sign up for GitHub](/signup?return_to=%2FSamsung%2FmTower%2Fissues%2Fnew%2Fchoose)

By clicking “Sign up for GitHub”, you agree to our [terms of service](https://docs.github.com/terms) and
[privacy statement](https://docs.github.com/privacy). We’ll occasionally send you account related emails.

Already on GitHub?
[Sign in](/login?return_to=%2FSamsung%2FmTower%2Fissues%2Fnew%2Fchoose)
to your account

[Jump to bottom](#issue-comment-box)

# Security: Buffer Access with Incorrect Length Value in TEE\_MACUpdate, TEE\_MACComputeFinal and TEE\_CipherUpdate #81

Closed

[c01dkit](/c01dkit) opened this issue
Sep 16, 2022
· 0 comments
 · Fixed by [#90](https://github.com/Samsung/mTower/pull/90)

Closed

# [Security: Buffer Access with Incorrect Length Value in TEE\_MACUpdate, TEE\_MACComputeFinal and TEE\_CipherUpdate](#top) #81

[c01dkit](/c01dkit) opened this issue
Sep 16, 2022
· 0 comments
 · Fixed by [#90](https://github.com/Samsung/mTower/pull/90)

## Comments

[![@c01dkit](https://avatars.githubusercontent.com/u/62790045?s=80&u=e5de5725ea146a5b4ac6012710a694ec0b710c22&v=4)](/c01dkit)

Copy link

### **[c01dkit](/c01dkit)** commented [Sep 16, 2022](#issue-1376007292) • edited Loading

| Buffer Access with Incorrect Length Value in the function TEE\_MACUpdate  **Affected components：**  affected source code file: /tee/lib/libutee/tee\_api\_objects.c, affected functions: TEE\_MACUpdate  **Attack vector(s)**  To exploit the vulnerability, invoke the function TEE\_MACUpdate and pass an excessive size value of "chunkSize".  **Suggested description of the vulnerability for use in the CVE**  Buffer Access with Incorrect Length Value vulnerablity in TEE\_MACUpdate function in Samsung Electronics mTower v0.3.0 (and earlier) allows a trusted application to trigger a Denial of Service (DoS) via invoking the function TEE\_MACUpdate with a excessive size value of "chunkSize".  **Discoverer(s)/Credits**  SyzTrust  **Reference(s)**  <https://github.com/Samsung/mTower>   [mTower/tee/lib/libutee/tee\_api\_operations.c](https://github.com/Samsung/mTower/blob/efd36709306a9afcca5b4782499d01be0c7a02a5/tee/lib/libutee/tee_api_operations.c#L1188)  Line 1188 in [efd3670](/Samsung/mTower/commit/efd36709306a9afcca5b4782499d01be0c7a02a5)   |  | res = utee\_hash\_update(operation->state, chunk, chunkSize); | | --- | --- |      [mTower/crypto/libtomcrypt/include/tomcrypt\_hash.h](https://github.com/Samsung/mTower/blob/efd36709306a9afcca5b4782499d01be0c7a02a5/crypto/libtomcrypt/include/tomcrypt_hash.h#L397)  Line 397 in [efd3670](/Samsung/mTower/commit/efd36709306a9afcca5b4782499d01be0c7a02a5)   |  | memcpy(md-> state\_var .buf + md-> state\_var.curlen, in, (size\_t)n); \ | | --- | --- |      **Additional information**  The TEE\_MACUpdate function takes an argument "chunkSize". This value is passed by TA, and TEE\_MACUpdate does not check whether it is equal to the size of "chunk" or not. With an excessive large value, executing the statement "memcpy(md-> state\_var .buf + md-> state\_var.curlen, in, (size\_t)n);" later may crash the trusted execution environment kernel and cause a Denial of Service (DoS).   ---   Buffer Access with Incorrect Length Value in the function TEE\_MACComputeFinal  **Affected components：**  affected source code file: /tee/lib/libutee/tee\_api\_objects.c, affected functions: TEE\_MACComputeFinal  **Attack vector(s)**  To exploit the vulnerability, invoke the function TEE\_MACComputeFinal and pass an excessive size value of "messageLen".  **Suggested description of the vulnerability for use in the CVE**  Buffer Access with Incorrect Length Value vulnerablity in TEE\_MACComputeFinal function in Samsung Electronics mTower v0.3.0 (and earlier) allows a trusted application to trigger a Denial of Service (DoS) via invoking the function TEE\_MACComputeFinal with a excessive size value of "messageLen".  **Discoverer(s)/Credits**  SyzTrust  **Reference(s)**  <https://github.com/Samsung/mTower>   [mTower/tee/lib/libutee/tee\_api\_operations.c](https://github.com/Samsung/mTower/blob/efd36709306a9afcca5b4782499d01be0c7a02a5/tee/lib/libutee/tee_api_operations.c#L1031)  Line 1031 in [efd3670](/Samsung/mTower/commit/efd36709306a9afcca5b4782499d01be0c7a02a5)   |  | res = utee\_cipher\_update(operation->state, srcData, | | --- | --- |      **Additional information**  The TEE\_MACComputeFinal function takes an argument "messageLen". This value is passed by TA, and TEE\_MACComputeFinal does not check whether it is the size of "message" or not. With an excessive large value, executing the statement "res = utee\_cipher\_update(operation->state, srcData, srcLen, destData, &dl);" later will crash the trusted execution environment kernel and cause a Denial of Service (DoS).   ---   Buffer Access with Incorrect Length Value in the function TEE\_CipherUpdate  **Affected components：**  affected source code file: /tee/lib/libutee/tee\_api\_objects.c, affected functions: TEE\_CipherUpdate  **Attack vector(s)**  To exploit the vulnerability, invoke the function TEE\_CipherUpdate and pass an excessive size value of "srcLen".  **Suggested description of the vulnerability for use in the CVE**  Buffer Access with Incorrect Length Value vulnerablity in TEE\_CipherUpdate function in Samsung Electronics mTower v0.3.0 (and earlier) allows a trusted application to trigger a Denial of Service (DoS) via invoking the function TEE\_CipherUpdate with a excessive size value of "srcLen".  **Discoverer(s)/Credits**  SyzTrust  **Reference(s)**  <https://github.com/Samsung/mTower>   [mTower/tee/lib/libutee/tee\_api\_operations.c](https://github.com/Samsung/mTower/blob/efd36709306a9afcca5b4782499d01be0c7a02a5/tee/lib/libutee/tee_api_operations.c#L1224)  Line 1224 in [efd3670](/Samsung/mTower/commit/efd36709306a9afcca5b4782499d01be0c7a02a5)   |  | res = utee\_hash\_final(operation->state, message, messageLen, mac, &ml); | | --- | --- |      **Additional information**  The TEE\_CipherUpdate function takes an argument "srcLen". This value is passed by TA, and TEE\_CipherUpdate does not check whether it is the size of "srcData" or not. With an excessive large value, executing the statement "res = utee\_hash\_final(operation->state, message, messageLen, mac, &ml);" later will crash the trusted execution environment kernel and cause a Denial of Service (DoS).  *THANK YOU FOR CONTRIBUTIONS IN MTOWER TEE OS!* |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| The text was updated successfully, but these errors were encountered: |

All reactions

[![@tdrozdovsky](https://avatars.githubusercontent.com/u/45031429?s=40&v=4)](/tdrozdovsky)
[tdrozdovsky](/tdrozdovsky)
mentioned this issue
[Nov 28, 2022](#ref-pullrequest-1466166308)

[Fixed CVE-2022-40760
#90](/Samsung/mTower/pull/90)
 Merged

9 tasks

[![@tdrozdovsky](https://avatars.githubusercontent.com/u/45031429?s=40&v=4)](/tdrozdovsky)
[tdrozdovsky](/tdrozdovsky)
closed this as [completed](/Samsung/mTower/issues?q=is%3Aissue+is%3Aclosed+archived%3Afalse+reason%3Acompleted)
in
[#90](/Samsung/mTower/pull/90)
[Nov 28, 2022](#event-7901503109)

[Sign up for free](/join?source=comment-repo)
**to join this conversation on GitHub**.
Already have an account?
[Sign in to comment](/login?return_to=https%3A%2F%2Fgithub.com%2FSamsung%2FmTower%2Fissues%2F81)

Assignees

No one assigned

Labels

None yet

Projects

None yet

Milestone

No milestone

Development

Successfully merging a pull request may close this issue.

 [Fixed CVE-2022-40760](/Samsung/mTower/pull/90)
 [Samsung/mTower](/Samsung/mTower)

1 participant

[![@c01dkit](https://avatars.githubusercontent.com/u/62790045?s=52&v=4)](/c01dkit)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_7be76ce0_20250108_130016.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FSamsung%2FmTower%2Fblob%2Fefd36709306a9afcca5b4782499d01be0c7a02a5%2Ftee%2Flib%2Flibutee%2Ftee_api_operations.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FSamsung%2FmTower%2Fblob%2Fefd36709306a9afcca5b4782499d01be0c7a02a5%2Ftee%2Flib%2Flibutee%2Ftee_api_operations.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=Samsung%2FmTower)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[Samsung](/Samsung)
/
**[mTower](/Samsung/mTower)**
Public

* [Notifications](/login?return_to=%2FSamsung%2FmTower) You must be signed in to change notification settings
* [Fork
  17](/login?return_to=%2FSamsung%2FmTower)
* [Star
   54](/login?return_to=%2FSamsung%2FmTower)

* [Code](/Samsung/mTower)
* [Issues
  13](/Samsung/mTower/issues)
* [Pull requests
  0](/Samsung/mTower/pulls)
* [Actions](/Samsung/mTower/actions)
* [Projects
  0](/Samsung/mTower/projects)
* [Security](/Samsung/mTower/security)
* [Insights](/Samsung/mTower/pulse)

Additional navigation options

* [Code](/Samsung/mTower)
* [Issues](/Samsung/mTower/issues)
* [Pull requests](/Samsung/mTower/pulls)
* [Actions](/Samsung/mTower/actions)
* [Projects](/Samsung/mTower/projects)
* [Security](/Samsung/mTower/security)
* [Insights](/Samsung/mTower/pulse)

## Files

 efd3670
## Breadcrumbs

1. [mTower](/Samsung/mTower/tree/efd36709306a9afcca5b4782499d01be0c7a02a5)
2. /[tee](/Samsung/mTower/tree/efd36709306a9afcca5b4782499d01be0c7a02a5/tee)
3. /[lib](/Samsung/mTower/tree/efd36709306a9afcca5b4782499d01be0c7a02a5/tee/lib)
4. /[libutee](/Samsung/mTower/tree/efd36709306a9afcca5b4782499d01be0c7a02a5/tee/lib/libutee)
/
# tee\_api\_operations.c

 Blame  Blame
## Latest commit

## History

[History](/Samsung/mTower/commits/efd36709306a9afcca5b4782499d01be0c7a02a5/tee/lib/libutee/tee_api_operations.c)1819 lines (1533 loc) · 45.8 KB efd3670
## Breadcrumbs

1. [mTower](/Samsung/mTower/tree/efd36709306a9afcca5b4782499d01be0c7a02a5)
2. /[tee](/Samsung/mTower/tree/efd36709306a9afcca5b4782499d01be0c7a02a5/tee)
3. /[lib](/Samsung/mTower/tree/efd36709306a9afcca5b4782499d01be0c7a02a5/tee/lib)
4. /[libutee](/Samsung/mTower/tree/efd36709306a9afcca5b4782499d01be0c7a02a5/tee/lib/libutee)
/
# tee\_api\_operations.c

Top
## File metadata and controls

* Code
* Blame

1819 lines (1533 loc) · 45.8 KB[Raw](https://github.com/Samsung/mTower/raw/efd36709306a9afcca5b4782499d01be0c7a02a5/tee/lib/libutee/tee_api_operations.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000// SPDX-License-Identifier: BSD-2-Clause/\* \* Copyright (c) 2014, STMicroelectronics International N.V. \* All rights reserved. \* \* Redistribution and use in source and binary forms, with or without \* modification, are permitted provided that the following conditions are met: \* \* 1. Redistributions of source code must retain the above copyright notice, \* this list of conditions and the following disclaimer. \* \* 2. Redistributions in binary form must reproduce the above copyright notice, \* this list of conditions and the following disclaimer in the documentation \* and/or other materials provided with the distribution. \* \* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" \* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE \* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \* POSSIBILITY OF SUCH DAMAGE. \*/#include <stdlib.h>#include <string.h>#include <string\_ext.h>
#include <tee\_api.h>#include <tee\_api\_defines\_extensions.h>#include <tee\_internal\_api\_extensions.h>#include <utee\_syscalls.h>#include <utee\_defines.h>#include <util.h>#include "tee\_api\_private.h"#include "utee\_types.h"
TEE\_Result utee\_cipher\_update(unsigned long state, const void \*src, size\_t src\_len, void \*dst, uint64\_t \*dst\_len);
struct \_\_TEE\_OperationHandle { TEE\_OperationInfo info; TEE\_ObjectHandle key1; TEE\_ObjectHandle key2; uint32\_t operationState;/\* Operation state : INITIAL or ACTIVE \*/ uint8\_t \*buffer; /\* buffer to collect complete blocks \*/ bool buffer\_two\_blocks; /\* True if two blocks need to be buffered \*/ size\_t block\_size; /\* Block size of cipher \*/ size\_t buffer\_offs; /\* Offset in buffer \*/ uint32\_t state; /\* Handle to state in TEE Core \*/ uint32\_t ae\_tag\_len; /\* \* tag\_len in bytes for AE operation else unused \*/};
/\* Cryptographic Operations API - Generic Operation Functions \*/
TEE\_Result TEE\_AllocateOperation(TEE\_OperationHandle \*operation, uint32\_t algorithm, uint32\_t mode, uint32\_t maxKeySize){ TEE\_Result res; TEE\_OperationHandle op = TEE\_HANDLE\_NULL; uint32\_t handle\_state = 0; size\_t block\_size = 1; uint32\_t req\_key\_usage; bool with\_private\_key = false; bool buffer\_two\_blocks = false;
 if (!operation) TEE\_Panic(0);
 if (algorithm == TEE\_ALG\_AES\_XTS) handle\_state = TEE\_HANDLE\_FLAG\_EXPECT\_TWO\_KEYS;
 /\* Check algorithm max key size \*/ switch (algorithm) { case TEE\_ALG\_DSA\_SHA1: if (maxKeySize < 512) return TEE\_ERROR\_NOT\_SUPPORTED; if (maxKeySize > 1024) return TEE\_ERROR\_NOT\_SUPPORTED; if (maxKeySize % 64 != 0) return TEE\_ERROR\_NOT\_SUPPORTED; break;
 case TEE\_ALG\_DSA\_SHA224: if (maxKeySize != 2048) return TEE\_ERROR\_NOT\_SUPPORTED; break;
 case TEE\_ALG\_DSA\_SHA256: if (maxKeySize != 2048 && maxKeySize != 3072) return TEE\_ERROR\_NOT\_SUPPORTED; break;
 case TEE\_ALG\_ECDSA\_P192: case TEE\_ALG\_ECDH\_P192: if (maxKeySize != 192) return TEE\_ERROR\_NOT\_SUPPORTED; break;
 case TEE\_ALG\_ECDSA\_P224: case TEE\_ALG\_ECDH\_P224: if (maxKeySize != 224) return TEE\_ERROR\_NOT\_SUPPORTED; break;
 case TEE\_ALG\_ECDSA\_P256: case TEE\_ALG\_ECDH\_P256: if (maxKeySize != 256) return TEE\_ERROR\_NOT\_SUPPORTED; break;
 case TEE\_ALG\_ECDSA\_P384: case TEE\_ALG\_ECDH\_P384: if (maxKeySize != 384) return TEE\_ERROR\_NOT\_SUPPORTED; break;
 case TEE\_ALG\_ECDSA\_P521: case TEE\_ALG\_ECDH\_P521: if (maxKeySize != 521) return TEE\_ERROR\_NOT\_SUPPORTED; break;
 default: break; }
 /\* Check algorithm mode \*/ switch (algorithm) { case TEE\_ALG\_AES\_CTS: case TEE\_ALG\_AES\_XTS: buffer\_two\_blocks = true; /\* FALLTHROUGH \*/ case TEE\_ALG\_AES\_ECB\_NOPAD: case TEE\_ALG\_AES\_CBC\_NOPAD: case TEE\_ALG\_AES\_CCM: case TEE\_ALG\_DES\_ECB\_NOPAD: case TEE\_ALG\_DES\_CBC\_NOPAD: case TEE\_ALG\_DES3\_ECB\_NOPAD: case TEE\_ALG\_DES3\_CBC\_NOPAD: if (TEE\_ALG\_GET\_MAIN\_ALG(algorithm) == TEE\_MAIN\_ALGO\_AES) block\_size = TEE\_AES\_BLOCK\_SIZE; else block\_size = TEE\_DES\_BLOCK\_SIZE; /\* FALLTHROUGH \*/ case TEE\_ALG\_AES\_CTR: case TEE\_ALG\_AES\_GCM: if (mode == TEE\_MODE\_ENCRYPT) req\_key\_usage = TEE\_USAGE\_ENCRYPT; else if (mode == TEE\_MODE\_DECRYPT) req\_key\_usage = TEE\_USAGE\_DECRYPT; else return TEE\_ERROR\_NOT\_SUPPORTED; break;
 case TEE\_ALG\_RSASSA\_PKCS1\_V1\_5\_MD5: case TEE\_ALG\_RSASSA\_PKCS1\_V1\_5\_SHA1: case TEE\_ALG\_RSASSA\_PKCS1\_V1\_5\_SHA224: case TEE\_ALG\_RSASSA\_PKCS1\_V1\_5\_SHA256: case TEE\_ALG\_RSASSA\_PKCS1\_V1\_5\_SHA384: case TEE\_ALG\_RSASSA\_PKCS1\_V1\_5\_SHA512: case TEE\_ALG\_RSASSA\_PKCS1\_PSS\_MGF1\_SHA1: case TEE\_ALG\_RSASSA\_PKCS1\_PSS\_MGF1\_SHA224: case TEE\_ALG\_RSASSA\_PKCS1\_PSS\_MGF1\_SHA256: case TEE\_ALG\_RSASSA\_PKCS1\_PSS\_MGF1\_SHA384: case TEE\_ALG\_RSASSA\_PKCS1\_PSS\_MGF1\_SHA512: case TEE\_ALG\_DSA\_SHA1: case TEE\_ALG\_DSA\_SHA224: case TEE\_ALG\_DSA\_SHA256: case TEE\_ALG\_ECDSA\_P192: case TEE\_ALG\_ECDSA\_P224: case TEE\_ALG\_ECDSA\_P256: case TEE\_ALG\_ECDSA\_P384: case TEE\_ALG\_ECDSA\_P521: if (mode == TEE\_MODE\_SIGN) { with\_private\_key = true; req\_key\_usage = TEE\_USAGE\_SIGN; } else if (mode == TEE\_MODE\_VERIFY) { req\_key\_usage = TEE\_USAGE\_VERIFY; } else { return TEE\_ERROR\_NOT\_SUPPORTED; } break;
 case TEE\_ALG\_RSAES\_PKCS1\_V1\_5: case TEE\_ALG\_RSAES\_PKCS1\_OAEP\_MGF1\_SHA1: case TEE\_ALG\_RSAES\_PKCS1\_OAEP\_MGF1\_SHA224: case TEE\_ALG\_RSAES\_PKCS1\_OAEP\_MGF1\_SHA256: case TEE\_ALG\_RSAES\_PKCS1\_OAEP\_MGF1\_SHA384: case TEE\_ALG\_RSAES\_PKCS1\_OAEP\_MGF1\_SHA512: if (mode == TEE\_MODE\_ENCRYPT) { req\_key\_usage = TEE\_USAGE\_ENCRYPT; } else if (mode == TEE\_MODE\_DECRYPT) { with\_private\_key = true; req\_key\_usage = TEE\_USAGE\_DECRYPT; } else { return TEE\_ERROR\_NOT\_SUPPORTED; } break;
 case TEE\_ALG\_RSA\_NOPAD: if (mode == TEE\_MODE\_ENCRYPT) { req\_key\_usage = TEE\_USAGE\_ENCRYPT | TEE\_USAGE\_VERIFY; } else if (mode == TEE\_MODE\_DECRYPT) { with\_private\_key = true; req\_key\_usage = TEE\_USAGE\_DECRYPT | TEE\_USAGE\_SIGN; } else { return TEE\_ERROR\_NOT\_SUPPORTED; } break;
 case TEE\_ALG\_DH\_DERIVE\_SHARED\_SECRET: case TEE\_ALG\_ECDH\_P192: case TEE\_ALG\_ECDH\_P224: case TEE\_ALG\_ECDH\_P256: case TEE\_ALG\_ECDH\_P384: case TEE\_ALG\_ECDH\_P521: case TEE\_ALG\_HKDF\_MD5\_DERIVE\_KEY: case TEE\_ALG\_HKDF\_SHA1\_DERIVE\_KEY: case TEE\_ALG\_HKDF\_SHA224\_DERIVE\_KEY: case TEE\_ALG\_HKDF\_SHA256\_DERIVE\_KEY: case TEE\_ALG\_HKDF\_SHA384\_DERIVE\_KEY: case TEE\_ALG\_HKDF\_SHA512\_DERIVE\_KEY: case TEE\_ALG\_CONCAT\_KDF\_SHA1\_DERIVE\_KEY: case TEE\_ALG\_CONCAT\_KDF\_SHA224\_DERIVE\_KEY: case TEE\_ALG\_CONCAT\_KDF\_SHA256\_DERIVE\_KEY: case TEE\_ALG\_CONCAT\_KDF\_SHA384\_DERIVE\_KEY: case TEE\_ALG\_CONCAT\_KDF\_SHA512\_DERIVE\_KEY: case TEE\_ALG\_PBKDF2\_HMAC\_SHA1\_DERIVE\_KEY: if (mode != TEE\_MODE\_DERIVE) return TEE\_ERROR\_NOT\_SUPPORTED; with\_private\_key = true; req\_key\_usage = TEE\_USAGE\_DERIVE; break;
 case TEE\_ALG\_MD5: case TEE\_ALG\_SHA1: case TEE\_ALG\_SHA224: case TEE\_ALG\_SHA256: case TEE\_ALG\_SHA384: case TEE\_ALG\_SHA512: if (mode != TEE\_MODE\_DIGEST) return TEE\_ERROR\_NOT\_SUPPORTED; /\* v1.1: flags always set for digest operations \*/ handle\_state |= TEE\_HANDLE\_FLAG\_KEY\_SET; req\_key\_usage = 0; break;
 case TEE\_ALG\_DES\_CBC\_MAC\_NOPAD: case TEE\_ALG\_AES\_CBC\_MAC\_NOPAD: case TEE\_ALG\_AES\_CBC\_MAC\_PKCS5: case TEE\_ALG\_AES\_CMAC: case TEE\_ALG\_DES\_CBC\_MAC\_PKCS5: case TEE\_ALG\_DES3\_CBC\_MAC\_NOPAD: case TEE\_ALG\_DES3\_CBC\_MAC\_PKCS5: case TEE\_ALG\_HMAC\_MD5: case TEE\_ALG\_HMAC\_SHA1: case TEE\_ALG\_HMAC\_SHA224: case TEE\_ALG\_HMAC\_SHA256: case TEE\_ALG\_HMAC\_SHA384: case TEE\_ALG\_HMAC\_SHA512: if (mode != TEE\_MODE\_MAC) return TEE\_ERROR\_NOT\_SUPPORTED; req\_key\_usage = TEE\_USAGE\_MAC; break;
 default: return TEE\_ERROR\_NOT\_SUPPORTED; }
 op = TEE\_Malloc(sizeof(\*op), TEE\_MALLOC\_FILL\_ZERO); if (!op) return TEE\_ERROR\_OUT\_OF\_MEMORY;
 op->info.algorithm = algorithm; op->info.operationClass = TEE\_ALG\_GET\_CLASS(algorithm); op->info.mode = mode; op->info.maxKeySize = maxKeySize; op->info.requiredKeyUsage = req\_key\_usage; op->info.handleState = handle\_state;
 if (block\_size > 1) { size\_t buffer\_size = block\_size;
 if (buffer\_two\_blocks) buffer\_size \*= 2;
 op->buffer = TEE\_Malloc(buffer\_size, TEE\_USER\_MEM\_HINT\_NO\_FILL\_ZERO); if (op->buffer == NULL) { res = TEE\_ERROR\_OUT\_OF\_MEMORY; goto out; } }
 op->block\_size = block\_size; op->buffer\_two\_blocks = buffer\_two\_blocks;
 if (TEE\_ALG\_GET\_CLASS(algorithm) != TEE\_OPERATION\_DIGEST) { uint32\_t mks = maxKeySize; TEE\_ObjectType key\_type = TEE\_ALG\_GET\_KEY\_TYPE(algorithm, with\_private\_key);
 /\* \* If two keys are expected the max key size is the sum of \* the size of both keys. \*/ if (op->info.handleState & TEE\_HANDLE\_FLAG\_EXPECT\_TWO\_KEYS) mks /= 2;
 res = TEE\_AllocateTransientObject(key\_type, mks, &op->key1); if (res != TEE\_SUCCESS) goto out;
 if (op->info.handleState & TEE\_HANDLE\_FLAG\_EXPECT\_TWO\_KEYS) { res = TEE\_AllocateTransientObject(key\_type, mks, &op->key2); if (res != TEE\_SUCCESS) goto out; } }
 res = utee\_cryp\_state\_alloc(algorithm, mode, (unsigned long)op->key1, (unsigned long)op->key2, &op->state); if (res != TEE\_SUCCESS) goto out;
 /\* \* Initialize digest operations \* Other multi-stage operations initialized w/ TEE\_xxxInit functions \* Non-applicable on asymmetric operations \*/ if (TEE\_ALG\_GET\_CLASS(algorithm) == TEE\_OPERATION\_DIGEST) { res = utee\_hash\_init(op->state, NULL, 0); if (res != TEE\_SUCCESS) goto out; /\* v1.1: flags always set for digest operations \*/ op->info.handleState |= TEE\_HANDLE\_FLAG\_INITIALIZED; }
 op->operationState = TEE\_OPERATION\_STATE\_INITIAL;
 \*operation = op;
out: if (res != TEE\_SUCCESS) { if (res != TEE\_ERROR\_OUT\_OF\_MEMORY && res != TEE\_ERROR\_NOT\_SUPPORTED) TEE\_Panic(res); if (op) { if (op->state) { TEE\_FreeOperation(op); } else { TEE\_Free(op->buffer); TEE\_FreeTransientObject(op->key1); TEE\_FreeTransientObject(op->key2); TEE\_Free(op); } } }
 return res;}
void TEE\_FreeOperation(TEE\_OperationHandle operation){ TEE\_Result res;
 if (operation == TEE\_HANDLE\_NULL) TEE\_Panic(0);
 /\* \* Note that keys should not be freed here, since they are \* claimed by the operation they will be freed by \* utee\_cryp\_state\_free(). \*/ res = utee\_cryp\_state\_free(operation->state); if (res != TEE\_SUCCESS) TEE\_Panic(res);
 TEE\_Free(operation->buffer); TEE\_Free(operation);}
void TEE\_GetOperationInfo(TEE\_OperationHandle operation, TEE\_OperationInfo \*operationInfo){ if (operation == TEE\_HANDLE\_NULL) TEE\_Panic(0);
 if (!operationInfo) TEE\_Panic(0);
 \*operationInfo = operation->info;}
TEE\_Result TEE\_GetOperationInfoMultiple(TEE\_OperationHandle operation, TEE\_OperationInfoMultiple \*operationInfoMultiple, uint32\_t \*operationSize){ TEE\_Result res = TEE\_SUCCESS; TEE\_ObjectInfo key\_info1; TEE\_ObjectInfo key\_info2; uint32\_t num\_of\_keys; size\_t n;
 if (operation == TEE\_HANDLE\_NULL) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 if (!operationInfoMultiple) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 if (!operationSize) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 num\_of\_keys = (\*operationSize-sizeof(TEE\_OperationInfoMultiple))/ sizeof(TEE\_OperationInfoKey);
 if (num\_of\_keys > 2) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 /\* Two keys flag (TEE\_ALG\_AES\_XTS only) \*/ if ((operation->info.handleState & TEE\_HANDLE\_FLAG\_EXPECT\_TWO\_KEYS) != 0 && (num\_of\_keys != 2)) { res = TEE\_ERROR\_SHORT\_BUFFER; goto out; }
 /\* Clear \*/ for (n = 0; n < num\_of\_keys; n++) { operationInfoMultiple->keyInformation[n].keySize = 0; operationInfoMultiple->keyInformation[n].requiredKeyUsage = 0; }
 if (num\_of\_keys == 2) { res = TEE\_GetObjectInfo1(operation->key2, &key\_info2); /\* Key2 is not a valid handle \*/ if (res != TEE\_SUCCESS) goto out;
 operationInfoMultiple->keyInformation[1].keySize = key\_info2.keySize; operationInfoMultiple->keyInformation[1].requiredKeyUsage = operation->info.requiredKeyUsage; }
 if (num\_of\_keys >= 1) { res = TEE\_GetObjectInfo1(operation->key1, &key\_info1); /\* Key1 is not a valid handle \*/ if (res != TEE\_SUCCESS) { if (num\_of\_keys == 2) { operationInfoMultiple->keyInformation[1]. keySize = 0; operationInfoMultiple->keyInformation[1]. requiredKeyUsage = 0; } goto out; }
 operationInfoMultiple->keyInformation[0].keySize = key\_info1.keySize; operationInfoMultiple->keyInformation[0].requiredKeyUsage = operation->info.requiredKeyUsage; }
 /\* No key \*/ operationInfoMultiple->algorithm = operation->info.algorithm; operationInfoMultiple->operationClass = operation->info.operationClass; operationInfoMultiple->mode = operation->info.mode; operationInfoMultiple->digestLength = operation->info.digestLength; operationInfoMultiple->maxKeySize = operation->info.maxKeySize; operationInfoMultiple->handleState = operation->info.handleState; operationInfoMultiple->operationState = operation->operationState; operationInfoMultiple->numberOfKeys = num\_of\_keys;
out: if (res != TEE\_SUCCESS && res != TEE\_ERROR\_SHORT\_BUFFER) TEE\_Panic(res);
 return res;}
void TEE\_ResetOperation(TEE\_OperationHandle operation){ TEE\_Result res;
 if (operation == TEE\_HANDLE\_NULL) TEE\_Panic(0);
 if (!(operation->info.handleState & TEE\_HANDLE\_FLAG\_KEY\_SET)) TEE\_Panic(0);
 operation->operationState = TEE\_OPERATION\_STATE\_INITIAL;
 if (operation->info.operationClass == TEE\_OPERATION\_DIGEST) { res = utee\_hash\_init(operation->state, NULL, 0); if (res != TEE\_SUCCESS) TEE\_Panic(res); operation->info.handleState |= TEE\_HANDLE\_FLAG\_INITIALIZED; } else { operation->info.handleState &= ~TEE\_HANDLE\_FLAG\_INITIALIZED; }}
TEE\_Result TEE\_SetOperationKey(TEE\_OperationHandle operation, TEE\_ObjectHandle key){ TEE\_Result res; uint32\_t key\_size = 0; TEE\_ObjectInfo key\_info;
 if (operation == TEE\_HANDLE\_NULL) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 if (operation->operationState != TEE\_OPERATION\_STATE\_INITIAL) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 if (key == TEE\_HANDLE\_NULL) { /\* Operation key cleared \*/ TEE\_ResetTransientObject(operation->key1); res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 /\* No key for digest operation \*/ if (operation->info.operationClass == TEE\_OPERATION\_DIGEST) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 /\* Two keys flag not expected (TEE\_ALG\_AES\_XTS excluded) \*/ if ((operation->info.handleState & TEE\_HANDLE\_FLAG\_EXPECT\_TWO\_KEYS) != 0) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 res = TEE\_GetObjectInfo1(key, &key\_info); /\* Key is not a valid handle \*/ if (res != TEE\_SUCCESS) goto out;
 /\* Supplied key has to meet required usage \*/ if ((key\_info.objectUsage & operation->info.requiredKeyUsage) != operation->info.requiredKeyUsage) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 if (operation->info.maxKeySize < key\_info.keySize) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 key\_size = key\_info.keySize;
 TEE\_ResetTransientObject(operation->key1); operation->info.handleState &= ~TEE\_HANDLE\_FLAG\_KEY\_SET;
 res = TEE\_CopyObjectAttributes1(operation->key1, key); if (res != TEE\_SUCCESS) goto out;
 operation->info.handleState |= TEE\_HANDLE\_FLAG\_KEY\_SET;
 operation->info.keySize = key\_size;
out: if (res != TEE\_SUCCESS && res != TEE\_ERROR\_CORRUPT\_OBJECT && res != TEE\_ERROR\_STORAGE\_NOT\_AVAILABLE) TEE\_Panic(res);
 return res;}
TEE\_Result TEE\_SetOperationKey2(TEE\_OperationHandle operation, TEE\_ObjectHandle key1, TEE\_ObjectHandle key2){ TEE\_Result res; uint32\_t key\_size = 0; TEE\_ObjectInfo key\_info1; TEE\_ObjectInfo key\_info2;
 if (operation == TEE\_HANDLE\_NULL) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 if (operation->operationState != TEE\_OPERATION\_STATE\_INITIAL) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 /\* \* Key1/Key2 and/or are not initialized and \* Either both keys are NULL or both are not NULL \*/ if (key1 == TEE\_HANDLE\_NULL || key2 == TEE\_HANDLE\_NULL) { /\* Clear operation key1 (if needed) \*/ if (key1 == TEE\_HANDLE\_NULL) TEE\_ResetTransientObject(operation->key1); /\* Clear operation key2 (if needed) \*/ if (key2 == TEE\_HANDLE\_NULL) TEE\_ResetTransientObject(operation->key2); res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 /\* No key for digest operation \*/ if (operation->info.operationClass == TEE\_OPERATION\_DIGEST) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 /\* Two keys flag expected (TEE\_ALG\_AES\_XTS only) \*/ if ((operation->info.handleState & TEE\_HANDLE\_FLAG\_EXPECT\_TWO\_KEYS) == 0) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 res = TEE\_GetObjectInfo1(key1, &key\_info1); /\* Key1 is not a valid handle \*/ if (res != TEE\_SUCCESS) goto out;
 /\* Supplied key has to meet required usage \*/ if ((key\_info1.objectUsage & operation->info. requiredKeyUsage) != operation->info.requiredKeyUsage) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 res = TEE\_GetObjectInfo1(key2, &key\_info2); /\* Key2 is not a valid handle \*/ if (res != TEE\_SUCCESS) { if (res == TEE\_ERROR\_CORRUPT\_OBJECT) res = TEE\_ERROR\_CORRUPT\_OBJECT\_2; goto out; }
 /\* Supplied key has to meet required usage \*/ if ((key\_info2.objectUsage & operation->info. requiredKeyUsage) != operation->info.requiredKeyUsage) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 /\* \* AES-XTS (the only multi key algorithm supported, requires the \* keys to be of equal size. \*/ if (operation->info.algorithm == TEE\_ALG\_AES\_XTS && key\_info1.keySize != key\_info2.keySize) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out;
 }
 if (operation->info.maxKeySize < key\_info1.keySize) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 /\* \* Odd that only the size of one key should be reported while \* size of two key are used when allocating the operation. \*/ key\_size = key\_info1.keySize;
 TEE\_ResetTransientObject(operation->key1); TEE\_ResetTransientObject(operation->key2); operation->info.handleState &= ~TEE\_HANDLE\_FLAG\_KEY\_SET;
 res = TEE\_CopyObjectAttributes1(operation->key1, key1); if (res != TEE\_SUCCESS) goto out;
 res = TEE\_CopyObjectAttributes1(operation->key2, key2); if (res != TEE\_SUCCESS) { if (res == TEE\_ERROR\_CORRUPT\_OBJECT) res = TEE\_ERROR\_CORRUPT\_OBJECT\_2; goto out; }
 operation->info.handleState |= TEE\_HANDLE\_FLAG\_KEY\_SET;
 operation->info.keySize = key\_size;
out: if (res != TEE\_SUCCESS && res != TEE\_ERROR\_CORRUPT\_OBJECT && res != TEE\_ERROR\_CORRUPT\_OBJECT\_2 && res != TEE\_ERROR\_STORAGE\_NOT\_AVAILABLE && res != TEE\_ERROR\_STORAGE\_NOT\_AVAILABLE\_2) TEE\_Panic(res);
 return res;}
void TEE\_CopyOperation(TEE\_OperationHandle dst\_op, TEE\_OperationHandle src\_op){ TEE\_Result res;
 if (dst\_op == TEE\_HANDLE\_NULL || src\_op == TEE\_HANDLE\_NULL) TEE\_Panic(0); if (dst\_op->info.algorithm != src\_op->info.algorithm) TEE\_Panic(0); if (src\_op->info.operationClass != TEE\_OPERATION\_DIGEST) { TEE\_ObjectHandle key1 = TEE\_HANDLE\_NULL; TEE\_ObjectHandle key2 = TEE\_HANDLE\_NULL;
 if (src\_op->info.handleState & TEE\_HANDLE\_FLAG\_KEY\_SET) { key1 = src\_op->key1; key2 = src\_op->key2; }
 if ((src\_op->info.handleState & TEE\_HANDLE\_FLAG\_EXPECT\_TWO\_KEYS) == 0) { TEE\_SetOperationKey(dst\_op, key1); } else { TEE\_SetOperationKey2(dst\_op, key1, key2); } } dst\_op->info.handleState = src\_op->info.handleState; dst\_op->info.keySize = src\_op->info.keySize; dst\_op->operationState = src\_op->operationState;
 if (dst\_op->buffer\_two\_blocks != src\_op->buffer\_two\_blocks || dst\_op->block\_size != src\_op->block\_size) TEE\_Panic(0);
 if (dst\_op->buffer != NULL) { if (src\_op->buffer == NULL) TEE\_Panic(0);
 memcpy(dst\_op->buffer, src\_op->buffer, src\_op->buffer\_offs); dst\_op->buffer\_offs = src\_op->buffer\_offs; } else if (src\_op->buffer != NULL) { TEE\_Panic(0); }
 res = utee\_cryp\_state\_copy(dst\_op->state, src\_op->state); if (res != TEE\_SUCCESS) TEE\_Panic(res);}
/\* Cryptographic Operations API - Message Digest Functions \*/
static void init\_hash\_operation(TEE\_OperationHandle operation, const void \*IV, uint32\_t IVLen){ TEE\_Result res;
 /\* \* Note : IV and IVLen are never used in current implementation \* This is why coherent values of IV and IVLen are not checked \*/ res = utee\_hash\_init(operation->state, IV, IVLen); if (res != TEE\_SUCCESS) TEE\_Panic(res); operation->buffer\_offs = 0; operation->info.handleState |= TEE\_HANDLE\_FLAG\_INITIALIZED;}
void TEE\_DigestUpdate(TEE\_OperationHandle operation, const void \*chunk, uint32\_t chunkSize){ TEE\_Result res = TEE\_ERROR\_GENERIC;
 if (operation == TEE\_HANDLE\_NULL || operation->info.operationClass != TEE\_OPERATION\_DIGEST) TEE\_Panic(0);
 operation->operationState = TEE\_OPERATION\_STATE\_ACTIVE;
 res = utee\_hash\_update(operation->state, chunk, chunkSize); if (res != TEE\_SUCCESS) TEE\_Panic(res);}
TEE\_Result TEE\_DigestDoFinal(TEE\_OperationHandle operation, const void \*chunk, uint32\_t chunkLen, void \*hash, uint32\_t \*hashLen){ TEE\_Result res; uint64\_t hl;
 if ((operation == TEE\_HANDLE\_NULL) || (!chunk && chunkLen) || !hash || !hashLen || (operation->info.operationClass != TEE\_OPERATION\_DIGEST)) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 hl = \*hashLen; res = utee\_hash\_final(operation->state, chunk, chunkLen, hash, &hl); \*hashLen = hl; if (res != TEE\_SUCCESS) goto out;
 /\* Reset operation state \*/ init\_hash\_operation(operation, NULL, 0);
 operation->operationState = TEE\_OPERATION\_STATE\_INITIAL;
out: if (res != TEE\_SUCCESS && res != TEE\_ERROR\_SHORT\_BUFFER) TEE\_Panic(res);
 return res;}
/\* Cryptographic Operations API - Symmetric Cipher Functions \*/
void TEE\_CipherInit(TEE\_OperationHandle operation, const void \*IV, uint32\_t IVLen){ TEE\_Result res;
 if (operation == TEE\_HANDLE\_NULL) TEE\_Panic(0);
 if (operation->info.operationClass != TEE\_OPERATION\_CIPHER) TEE\_Panic(0);
 if (!(operation->info.handleState & TEE\_HANDLE\_FLAG\_KEY\_SET) || !(operation->key1)) TEE\_Panic(0);
 if (operation->operationState != TEE\_OPERATION\_STATE\_INITIAL) TEE\_ResetOperation(operation);
 operation->operationState = TEE\_OPERATION\_STATE\_ACTIVE;
 res = utee\_cipher\_init(operation->state, IV, IVLen); if (res != TEE\_SUCCESS) TEE\_Panic(res);
 operation->buffer\_offs = 0; operation->info.handleState |= TEE\_HANDLE\_FLAG\_INITIALIZED;}
static TEE\_Result tee\_buffer\_update( TEE\_OperationHandle op, TEE\_Result(\*update\_func)(unsigned long state, const void \*src, size\_t slen, void \*dst, uint64\_t \*dlen), const void \*src\_data, size\_t src\_len, void \*dest\_data, uint64\_t \*dest\_len){ TEE\_Result res; const uint8\_t \*src = src\_data; size\_t slen = src\_len; uint8\_t \*dst = dest\_data; size\_t dlen = \*dest\_len; size\_t acc\_dlen = 0; uint64\_t tmp\_dlen; size\_t l; size\_t buffer\_size; size\_t buffer\_left;
 if (!src) { if (slen) TEE\_Panic(0); goto out; }
 if (op->buffer\_two\_blocks) { buffer\_size = op->block\_size \* 2; buffer\_left = 1; } else { buffer\_size = op->block\_size; buffer\_left = 0; }
 if (op->buffer\_offs > 0) { /\* Fill up complete block \*/ if (op->buffer\_offs < op->block\_size) l = MIN(slen, op->block\_size - op->buffer\_offs); else l = MIN(slen, buffer\_size - op->buffer\_offs); memcpy(op->buffer + op->buffer\_offs, src, l); op->buffer\_offs += l; src += l; slen -= l; if ((op->buffer\_offs % op->block\_size) != 0) goto out; /\* Nothing left to do \*/ }
 /\* If we can feed from buffer \*/ if ((op->buffer\_offs > 0) && ((op->buffer\_offs + slen) >= (buffer\_size + buffer\_left))) { l = ROUNDUP(op->buffer\_offs + slen - buffer\_size, op->block\_size); l = MIN(op->buffer\_offs, l); tmp\_dlen = dlen; res = update\_func(op->state, op->buffer, l, dst, &tmp\_dlen); if (res != TEE\_SUCCESS) TEE\_Panic(res); dst += tmp\_dlen; dlen -= tmp\_dlen; acc\_dlen += tmp\_dlen; op->buffer\_offs -= l; if (op->buffer\_offs > 0) { /\* \* Slen is small enough to be contained in rest buffer. \*/ memcpy(op->buffer, op->buffer + l, buffer\_size - l); memcpy(op->buffer + op->buffer\_offs, src, slen); op->buffer\_offs += slen; goto out; /\* Nothing left to do \*/ } }
 if (slen >= (buffer\_size + buffer\_left)) { /\* Buffer is empty, feed as much as possible from src \*/ if (op->info.algorithm == TEE\_ALG\_AES\_CTS) l = ROUNDUP(slen - buffer\_size, op->block\_size); else l = ROUNDUP(slen - buffer\_size + 1, op->block\_size);
 tmp\_dlen = dlen; res = update\_func(op->state, src, l, dst, &tmp\_dlen); if (res != TEE\_SUCCESS) TEE\_Panic(res); src += l; slen -= l; dst += tmp\_dlen; dlen -= tmp\_dlen; acc\_dlen += tmp\_dlen; }
 /\* Slen is small enough to be contained in buffer. \*/ memcpy(op->buffer + op->buffer\_offs, src, slen); op->buffer\_offs += slen;
out: \*dest\_len = acc\_dlen; return TEE\_SUCCESS;}
TEE\_Result TEE\_CipherUpdate(TEE\_OperationHandle operation, const void \*srcData, uint32\_t srcLen, void \*destData, uint32\_t \*destLen){ TEE\_Result res; size\_t req\_dlen; uint64\_t dl;
 if (operation == TEE\_HANDLE\_NULL || (srcData == NULL && srcLen != 0) || destLen == NULL || (destData == NULL && \*destLen != 0)) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 if (operation->info.operationClass != TEE\_OPERATION\_CIPHER) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 if ((operation->info.handleState & TEE\_HANDLE\_FLAG\_INITIALIZED) == 0) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 if (operation->operationState != TEE\_OPERATION\_STATE\_ACTIVE) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 if (!srcData && !srcLen) { \*destLen = 0; res = TEE\_SUCCESS; goto out; }
[View remainder of file in raw view](https://github.com/Samsung/mTower/raw/efd36709306a9afcca5b4782499d01be0c7a02a5/tee/lib/libutee/tee_api_operations.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


