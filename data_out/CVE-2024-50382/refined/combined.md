=== Content from github.com_6bd719dc_20250110_123743.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Frandombit%2Fbotan%2Fcommit%2F53b0cfde580e86b03d0d27a488b6c134f662e957)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Frandombit%2Fbotan%2Fcommit%2F53b0cfde580e86b03d0d27a488b6c134f662e957)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fcommit_fragments%2Frepo_layout&source=header-repo&source_repo=randombit%2Fbotan)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[randombit](/randombit)
/
**[botan](/randombit/botan)**
Public

* [Notifications](/login?return_to=%2Frandombit%2Fbotan) You must be signed in to change notification settings
* [Fork
  574](/login?return_to=%2Frandombit%2Fbotan)
* [Star
   2.8k](/login?return_to=%2Frandombit%2Fbotan)

* [Code](/randombit/botan)
* [Issues
  182](/randombit/botan/issues)
* [Pull requests
  29](/randombit/botan/pulls)
* [Discussions](/randombit/botan/discussions)
* [Actions](/randombit/botan/actions)
* [Wiki](/randombit/botan/wiki)
* [Security](/randombit/botan/security)
* [Insights](/randombit/botan/pulse)

Additional navigation options

* [Code](/randombit/botan)
* [Issues](/randombit/botan/issues)
* [Pull requests](/randombit/botan/pulls)
* [Discussions](/randombit/botan/discussions)
* [Actions](/randombit/botan/actions)
* [Wiki](/randombit/botan/wiki)
* [Security](/randombit/botan/security)
* [Insights](/randombit/botan/pulse)

## Commit

[Permalink](/randombit/botan/commit/53b0cfde580e86b03d0d27a488b6c134f662e957)

This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.

Add more value barriers to avoid compiler induced side channels

[Browse files](/randombit/botan/tree/53b0cfde580e86b03d0d27a488b6c134f662e957)
Browse the repository at this point in the history

```
The paper <https://arxiv.org/pdf/2410.13489> claims that on specific
architectures Clang and GCC may introduce jumps here. The donna128
issues only affect 32-bit processors, which explains why we would not
see it in the x86-64 valgrind runs.

The GHASH leak would seem to be generic but the authors only observed
it on RISC-V.
```

* Loading branch information

[![@randombit](https://avatars.githubusercontent.com/u/469092?s=40&v=4)](/randombit)

[randombit](/randombit/botan/commits?author=randombit "View all commits by randombit")
committed
Oct 20, 2024

1 parent
[6babd82](/randombit/botan/commit/6babd8226963dad7b25c4ae82c4f785162727d05)

commit 53b0cfd

 Show file tree

 Hide file tree

Showing
**2 changed files**
with
**4 additions**
and
**3 deletions**.

* Whitespace
* Ignore whitespace

* Split
* Unified

* src/lib/utils

  + src/lib/utils/donna128.h
    [donna128.h](#diff-61355c5d6a5f04c8ac4ab80769581bad2ad07f2a9daa726870801c7b17aeaf01)
  + ghash

    - src/lib/utils/ghash/ghash.cpp
      [ghash.cpp](#diff-5cb72bb9a8fd3b9ae9f1b9fd82632aae39b96709b82ce105142341ab08a3bf15)

## There are no files selected for viewing

5 changes: 3 additions & 2 deletions

5
[src/lib/utils/donna128.h](#diff-61355c5d6a5f04c8ac4ab80769581bad2ad07f2a9daa726870801c7b17aeaf01 "src/lib/utils/donna128.h")

Show comments

[View file](/randombit/botan/blob/53b0cfde580e86b03d0d27a488b6c134f662e957/src/lib/utils/donna128.h)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -8,6 +8,7 @@ |
|  |  | #ifndef BOTAN\_CURVE25519\_DONNA128\_H\_ |
|  |  | #define BOTAN\_CURVE25519\_DONNA128\_H\_ |
|  |  |  |
|  |  | #include <botan/internal/ct\_utils.h> |
|  |  | #include <botan/internal/mul128.h> |
|  |  | #include <type\_traits> |
|  |  |  |
| Expand Down  Expand Up | | @@ -73,14 +74,14 @@ class donna128 final { |
|  |  | l += x.l; |
|  |  | h += x.h; |
|  |  |  |
|  |  | const uint64\_t carry = (l < x.l); |
|  |  | const uint64\_t carry = CT::Mask<uint64\_t>::is\_lt(l, x.l).if\_set\_return(1); |
|  |  | h += carry; |
|  |  | return \*this; |
|  |  | } |
|  |  |  |
|  |  | constexpr donna128& operator+=(uint64\_t x) { |
|  |  | l += x; |
|  |  | const uint64\_t carry = (l < x); |
|  |  | const uint64\_t carry = CT::Mask<uint64\_t>::is\_lt(l, x).if\_set\_return(1); |
|  |  | h += carry; |
|  |  | return \*this; |
|  |  | } |
| Expand Down | |  |

2 changes: 1 addition & 1 deletion

2
[src/lib/utils/ghash/ghash.cpp](#diff-5cb72bb9a8fd3b9ae9f1b9fd82632aae39b96709b82ce105142341ab08a3bf15 "src/lib/utils/ghash/ghash.cpp")

Show comments

[View file](/randombit/botan/blob/53b0cfde580e86b03d0d27a488b6c134f662e957/src/lib/utils/ghash/ghash.cpp)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -131,7 +131,7 @@ void GHASH::key\_schedule(std::span<const uint8\_t> key) { |
|  |  | m\_HM[4 \* j + 2 \* i + 1] = H1; |
|  |  |  |
|  |  | // GCM's bit ops are reversed so we carry out of the bottom |
|  |  | const uint64\_t carry = R \* (H1 & 1); |
|  |  | const uint64\_t carry = CT::Mask<uint64\_t>::expand(H1 & 1).if\_set\_return(R); |
|  |  | H1 = (H1 >> 1) | (H0 << 63); |
|  |  | H0 = (H0 >> 1) ^ carry; |
|  |  | } |
| Expand Down | |  |

Toggle all file notes
Toggle all file annotations

### 0 comments on commit `53b0cfd`

Please
[sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Frandombit%2Fbotan%2Fcommit%2F53b0cfde580e86b03d0d27a488b6c134f662e957) to comment.

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_4b9799c0_20250110_123744.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Frandombit%2Fbotan%2Fcompare%2F3.5.0...3.6.0)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Frandombit%2Fbotan%2Fcompare%2F3.5.0...3.6.0)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fcompare%2Fshow&source=header-repo&source_repo=randombit%2Fbotan)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[randombit](/randombit)
/
**[botan](/randombit/botan)**
Public

* [Notifications](/login?return_to=%2Frandombit%2Fbotan) You must be signed in to change notification settings
* [Fork
  574](/login?return_to=%2Frandombit%2Fbotan)
* [Star
   2.8k](/login?return_to=%2Frandombit%2Fbotan)

* [Code](/randombit/botan)
* [Issues
  182](/randombit/botan/issues)
* [Pull requests
  29](/randombit/botan/pulls)
* [Discussions](/randombit/botan/discussions)
* [Actions](/randombit/botan/actions)
* [Wiki](/randombit/botan/wiki)
* [Security](/randombit/botan/security)
* [Insights](/randombit/botan/pulse)

Additional navigation options

* [Code](/randombit/botan)
* [Issues](/randombit/botan/issues)
* [Pull requests](/randombit/botan/pulls)
* [Discussions](/randombit/botan/discussions)
* [Actions](/randombit/botan/actions)
* [Wiki](/randombit/botan/wiki)
* [Security](/randombit/botan/security)
* [Insights](/randombit/botan/pulse)

[Permalink](https://github.com/randombit/botan/compare/randombit%3A2e5c7d3...randombit%3A76a8996)
# Comparing changes

 Choose two branches to see what’s changed or to start a new pull request.
If you need to, you can also  compare across forks
 or
[learn more about diff comparisons](https://docs.github.com/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-comparing-branches-in-pull-requests#three-dot-and-two-dot-git-diff-comparisons).

# Open a pull request

 Create a new pull request by comparing changes across two branches. If you need to, you can also  compare across forks
.
[Learn more about diff comparisons here](https://docs.github.com/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-comparing-branches-in-pull-requests#three-dot-and-two-dot-git-diff-comparisons).

*base repository:*
randombit/botan

Failed to load repositories. Confirm that selected base ref is valid, then try again.

 Loading

*base:*
3.5.0

Choose a base ref

Branches
Tags

Could not load branches

Nothing to show

 Loading

[{{ refName }}
default](/randombit/botan/compare/%7B%7B%20urlEncodedRefName%20%7D%7D...3.6.0)

Could not load tags

Nothing to show

[{{ refName }}
default](/randombit/botan/compare/%7B%7B%20urlEncodedRefName%20%7D%7D...3.6.0)

 Loading

...

*head repository:*
randombit/botan

Failed to load repositories. Confirm that selected head ref is valid, then try again.

 Loading

*compare:*
3.6.0

Choose a head ref

Branches
Tags

Could not load branches

Nothing to show

 Loading

[{{ refName }}
default](/randombit/botan/compare/3.5.0...%7B%7B%20urlEncodedRefName%20%7D%7D)

Could not load tags

Nothing to show

[{{ refName }}
default](/randombit/botan/compare/3.5.0...%7B%7B%20urlEncodedRefName%20%7D%7D)

 Loading

11
contributors

[Commits
422](#commits_bucket)
[Files changed
568](#files_bucket)

 Loading

 Loading

### This comparison is taking too long to generate.

Unfortunately it looks like we can’t render this comparison for you right now. It might be too big, or there might be something weird with your repository.

You can try running this command locally to see the comparison on your machine:

`git diff 3.5.0...3.6.0`

  Retry

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from arxiv.org_7f1a088d_20250110_123743.html ===
Breaking Bad: How
Compilers Break Constant-Time Implementations

Moritz Schneider
ETH Zurich

Daniele Lain
ETH Zurich

Ivan Puddu
ETH Zurich

Nicolas Dutly
ETH Zurich

Srdjan ˇCapkun
ETH Zurich

4
2
0
2

t
c
O
7
1

]

R
C
.
s
c
[

1
v
9
8
4
3
1
.
0
1
4
2
:
v
i
X
r
a

Abstract—The implementations of most hardened crypto-
graphic libraries use defensive programming techniques for side-
channel resistance. These techniques are usually specified as
guidelines to developers on specific code patterns to use or avoid.
Examples include performing arithmetic operations to choose
between two variables instead of executing a secret-dependent
branch. However, such techniques are only meaningful if they
persist across compilation. In this paper, we investigate how
optimizations used by modern compilers break the protections in-
troduced by defensive programming techniques. Specifically, how
compilers break high-level constant-time implementations used to
mitigate timing side-channel attacks. We run a large-scale exper-
iment to see if such compiler-induced issues manifest in state-
of-the-art cryptographic libraries. We develop a tool that can
profile virtually any architecture, and we use it to run trace-based
dynamic analysis on 44,604 different targets. Particularly, we
focus on the most widely deployed cryptographic libraries, which
aim to provide side-channel resistance. We are able to evaluate
whether their claims hold across various CPU architectures, in-
cluding x86-64, x86-i386, armv7, aarch64, RISC-V, and MIPS-32.
Our large-scale study reveals that several compiler-induced
secret-dependent operations occur within some of
the most
highly regarded hardened cryptographic libraries – even when
the high-level source code was formally verified to be free of side
channels. To the best of our knowledge, such findings represent
the first time these issues have been systematically observed
in the wild and provide concrete data that confirms previous
speculations about the limitations of defensive programming
techniques. One of the key takeaways of this paper is that the
state-of-the-art defensive programming techniques employed
for side-channel resistance are still inadequate, incomplete, and
bound to fail when paired with the optimizations that compilers
continuously introduce.

I. INTRODUCTION

Since the discovery of timing attacks [24], side-channel vul-
nerabilities have been one of the major concerns for developers
of security-critical code and libraries [21]. Particular attention
and expert knowledge are devoted to avoiding side-channel
issues in security-critical libraries. Three main hardening tech-
niques approaches are generally followed: i) manual assembly
hardening, ii) using special compilers that provide constant
time guarantees, and iii) hardening the source code. However,
all of these approaches suffer from practical limitations.

The first option is vetting hand-written assembly either by
a developer [42] or with automated analysis [11]. However,
this limits code portability and requires manual effort for each
supported (micro-)architecture—in practice, only the most
popular architectures are analyzed in this manner (e.g., x86 in
Vale [11]). However, security-critical libraries are expected to

the processor or

the binaries of security-critical

be deployed everywhere, leaving less vetted architectures as
second-class citizens in terms of security and hence potentially
more susceptible to attacks. A solution to this problem is
to compile the portable source code of security-critical
libraries with special compilers that automatically remove
side channels [12], [38]. However, these compilers suffer from
a set of shortcomings: support for processor architectures is
poor, they might require expert knowledge (e.g., to annotate
the code), and they struggle to provide support for modern
features of
the employed source code
languages. As a consequence, this approach is rarely used
in practice, e.g.,
libraries
provided by Linux packaging repositories are compiled with
commodity compilers such as GCC and LLVM. The third and
final approach relies on hardening the higher-level source code
using defensive programming techniques such as constant-
time programming and then compiling the hardened code
using commodity compilers. The advantage of this approach
is that commodity compilers, as opposed to special compilers,
offer support for many architectures, are maintained and get
improvements by hundreds of developers, and support the
latest CPU features. Some projects even go as far as formally
verifying the hardened higher-level code [49]. However,
commodity
or
optimizations that re-introduce side-channel vulnerabilities—
an issue that surveyed developers of security-critical libraries
are aware and afraid of [21], and that has been previously
observed in small manually crafted examples [14], [41].

compilers might

transformations

apply

As a practical compromise between the three techniques
mentioned so far, modern security-critical libraries rely on
defensive programming techniques on high-level source code
and the occasional spot check in their resulting binaries
[21]. While there exist multiple recommendations on how
to write hardened high-level source code [4], [5], and these
have been applied to various projects [15], [29], [37], [43],
it remains unclear whether they are effective at preventing
compiler-induced side-channels. Furthermore, most of these
coding recommendations were proposed before 2010, and thus
they may no longer apply to modern compilers (and/or need
updates for novel optimizations). Moreover, new processor
architectures differ significantly, and compilers may leverage
different optimization techniques that are architecture-specific.
Hitherto, it has not been studied how robust these recommen-
dations are w.r.t. modern compilers and build environments.

In this paper, we study arguably some of

the most

hardened projects: cryptographic libraries, as they need to
handle long-term secrets. Cryptographic libraries are usually
developed by experts with a particular sensibility towards
security and defensive programming. Many such libraries
consider side-channel attacks in their threat models and aim
to be side-channel free [15], [18], [29], [37], [49], and their
developers often diligently follow hardening practices. These
implementations are often called constant-time to indicate that
they behave exactly the same for different secret inputs. Some
libraries even provide formal guarantees for the absence of
side channels [49], while others use various tools and manual
analysis to eliminate side channels [15].

To understand if such constant-time development practices
survive compilation, we ran a large-scale experiment
to
see if compiler-induced side-channel vulnerabilities exist in
constant-time implementations used in the wild. We further
aimed to understand how often they appear, which kind, and
the reasons thereof. To answer this, we developed a scalable
pipeline that allows us to analyze different compiler options
for any specified target algorithm. We used our approach
to perform a systematic study of the final binary of eight
widely used cryptographic libraries on six different processor
architectures, compiled with several versions of two common
off-the-shelf compilers (GCC and LLVM) and with different
optimization levels. This results in 6608 distinct binaries.
Each binary contains multiple cryptographic primitives (e.g.,
AES, ECDSA. etc.) resulting in the total of 44,604 targets
to test (i.e., experiments)1. In each experiment, we tested
a different binary and a different cryptographic primitive
for their side-channel susceptibility. We used trace-based
dynamic analysis [19], [46] to detect secret-dependent control
the two most prominent root
flow and memory accesses,
causes of side-channel vulnerabilities.

We discover many novel compiler-induced secret-dependent
operations in state-of-the-art cryptographic libraries. These
findings show that previously-considered safe code-patterns
are being transformed into secret-dependent operations
at
the binary level. Notable findings include issues in
libraries that were formally verified to be free of such side
channels [49]. We discovered similar issues in all studied
processor architectures, all compilers, and all optimization
levels, including the default recommended ones in the studied
libraries. However, our data indicates mainstream processor
architectures, such as x86-64 and aarch64, to be less affected.
We believe this to be due to more developer focus on such
architectures, among other factors.

Our findings demonstrate that currently applied defensive
programming techniques are not always effective at mitigating
side-channel attacks, are very fragile, and may be vulnerable
with new releases of compilers. Where possible, we investigate
is causing
the compiler implementation to pinpoint what

1Each binary contains multiple cryptographic primitives. For instance, one
of the 6608 binaries is an OpenSSL compiled with LLVM 11 with -O2 for
x86-64 contains AES-GCM, HMAC-SHA1 etc. One experiment consists of
testing AES-GCM from this binary. Another experiment consists of testing
HMAC-SHA1 from the same binary, etc.

the secret dependencies to be re-introduced in otherwise
constant-time-looking source code. Generally, we found that
compilers understand certain arithmetic patterns and replace
them with secret-dependent branches or memory accesses.
Given these findings, our work highlights the need for a
more comprehensive and better
foundation for defensive
programming techniques against side channels.

Contributions.

• We study how compilers break constant-time properties
introduce timing side-
therefore,
and

across major

cryptographic

libraries

of source code and,
channels
architectures.

• We perform a large-scale study of 8 cryptographic
libraries and 11 cryptographic algorithms on 6 different
processor architectures, compiled by 2 off-the-shelf
compilers with 9 and 13 respective compiler versions
under 7 different optimization levels, leading to a total
of 44,604 experiments.

• We demonstrate compiler-induced side channels

in
state-of-the-art hardened cryptographic libraries and
find several such issues in multiple libraries. For LLVM
and for specific non-constant-time transformations, we
pinpoint the compiler pass that causes these issues.

• This paper highlights

that defensive programming
techniques for side-channel resistance are ineffective,
incomplete, and fragile with modern compilers.

Disclosure. We disclosed our findings to the respective
developers of
the libraries where we found any secret
dependence (both compiler-induced and code-level issues):
BearSSL, BoringSSL, Botan, HACL*,
and Libsodium.
Our disclosure included minimally reproducible examples
of how certain compilers can break some parts of their
implementation. All of the developers have acknowledged
our findings, and two of them have provided fixes. The other
library developers are currently working on a fix. The initial
disclosure messages are provided in Appendix A.

II. BACKGROUND

Side-channel Attacks. Side-channel attacks have been studied
extensively in the past years. There are various different types
of such attacks measuring, e.g., power consumption [23],
changes in thermal emanations [32], cache usage [28], or
the CPU branch predictor [1]. Physical side-channel attacks
require the attacker to be in physical proximity of the device,
e.g., to measure a power trace [23]. Digital side-channels can
be executed remotely, e.g., by the attacker executing some
other code in the same device [28]. Especially in the area
of digital side channels, the attacker capabilities have been
improved in the past few years with higher granularity [33],
[48] and higher synchronization up to measurements of
individual instructions [44]. In this paper, we focus on such
advanced digital side channels.

Variations exploited by side channels can be measured
across the whole execution or at a finer granularity, e.g.,

2

1

2

3

4

5

6

1

2

3

4

5

6

7

8

uint32_t select(uint32_t x, uint32_t y, uint32_t bit) {

if (bit)

return x;

else

return y;

}

(a) Not constant-time.

uint32_t ct_sel(uint32_t x, uint32_t y, uint32_t bit) {

// Create a bitmask in constant-time:
// - 0x00000000 if bit == 0
// - 0xFFFFFFFF otherwise
uint32_t mask = create_bitmask(bit);
// Select value to return in constant-time
return (x & mask) | (y & ~mask);

}

(b) Constant time.

Listing 1: An example select function from [5] that returns
either x or y based on a secret bit. (a) is not constant-time due
to branching on the secret value; (b) uses defensive program-
ming techniques (here, bit arithmetic) to run in constant-time.

that

functions, branches, and even single instructions [44]. These
variations might be induced by the internal state of the
CPU or some other component
is accessible by the
attacker executing on the same platform. Usual examples are
the shared cache [28] and the shared branch-predictor [1],
[27]. Unless the attacker can observe the leaky shared state
directly, a common technique to exploit these variations is to
convert them into timing variations. For instance, if timing
variations across the whole execution of a victim algorithm
emerge when providing different secrets as inputs, it means
that its execution takes different times depending on a secret
– and usually a subset of the program (e.g., a function) is
responsible for these variations.

Constant-time Programming. To counteract side-channel
attacks, a crucial strategy in defensive programming is
constant-time programming [4],
[5]. This methodology
involves adhering to a set of rules that seek to eliminate
any secret-dependent branching operation, memory access,
and sometimes even instructions that are known to produce
timing differences based on their arguments. A well-known
example is the select function depicted in two different
implementations in Listing 1, which returns either x or y based
on a secret bit. A non-constant-time-aware implementation of
the select function (Listing 1a) would use an if statement
to decide which value to return – thus branching depending
on a secret value. Defensive programming proposes to
replace the conditional statement with, e.g.,
the technique
shown in Listing 1b, that achieves the same result by using
bit arithmetic without secret-dependent branches. Common
techniques include using binary arithmetic to replace branches,
removing early exit conditions of loops, and avoiding table
look-ups indexed by secret data (e.g., s-boxes). We note that
these transformations can be automated [12], [38].

III. PROBLEM STATEMENT

Defensive programming techniques are often used to harden
security-critical code, as they aim to reduce the number of
vulnerabilities and programmer errors. Writing constant-time
code is one such technique that seeks to mitigate side channels
at the source code level [4], [5], and that experts rely on [37].
removing any secret-dependent
These techniques aim at
memory accesses and control-flow operations, thus reducing
the amount of secret-dependent variability and limiting the
side-channel susceptibility of these libraries. The intuition
is that if no secret-dependent operations exist, then no side
channel can exist either.

Writing small

assembly code

snippets manually to
achieve constant-time execution is not uncommon within
cryptographic libraries. Usually, small critical routines are
implemented in this fashion. However, this approach requires
manual analysis for each architecture and thus needs a
high level of expertise in a particular microarchitecture
and a significant effort for every architecture to support.
Consequently, most projects use high-level
source-code
implementations with constant-time programming techniques.
However, high-level source code is compiled to a binary by
a compiler which may optimize such defensive programming
techniques and re-introduce secret-dependent operations.

We aim to verify if such defensive programming techniques
effectively mitigate side-channel attacks down to the binary
level, considering today’s compilers and available architec-
tures, by analyzing arguably the most hardened libraries:
cryptographic libraries. Compilers and their different versions,
optimization levels, and target architectures could all affect the
final binary. Therefore, we aim to verify whether the resulting
binary for each of these parameters has any secret-dependent
operation – and whether the compiler introduced them.

Note that performing this analysis

is challenging in
practice because it generally requires being able to execute
and profile binaries on many architectures in an automated
fashion. Existing tools for analyzing such binaries are usually
not portable and only work on one architecture, e.g., Intel
Pin [20], [31], [46] for Intel Processors, or LLVM-based
approaches that only allow analyzing LLVM output [19].

Scope. We focus our study on secret-dependent memory
access and control flow operations that might be introduced
2 Since we focus on compiler-induced
by a compiler.
issues, we restrict the study to hardened side-channel free
implementations. This makes it easy to isolate the impact of
the compiler since if any issue is found in the binary, it must
have been introduced by the compiler. Cryptography libraries
are good candidates due to their threat model: generally, they
consider any secret dependency issue to be critical, and if
those are absent, then the library itself can be considered
side-channel free. We do not consider implementations that
use blinding to hide timing variations.

2There exists a third type of secret-dependent operation: some instructions
on some architectures execute with variable timing based on their arguments.
We do not consider this case in our paper.

3

Not all secret-dependent operations are equal. Some might
immediately leak the entire key, others only a single bit, and
some might not be exploitable at all. We note that for such
a study, the severity of the secret-dependent operations is
irrelevant; they should not be present altogether if defensive
programming techniques are followed. While the existence
of secret-dependent operations does not imply that relevant
information can be recovered, future attacks might improve
this, e.g., by using a novel microarchitectural structure [40] or
by increasing their granularity [2] – this is why the prevalent
defensive programming techniques for side-channel hardening
aim at removing secret dependencies altogether.

that in between the trace difference and its merge-point, no
further differences will be flagged. Therefore, this approach
only provides a lower bound for control-flow issues.

In general, our approach is similar to the approach of other
trace-based dynamic analysis tools [46], [47] that compare
sets of memory address traces for different secrets. The main
difference is in the use of emulation, that allows us to fix
non-determinism and enables us to analyze many different
architectures and compilers. We note that we merely refine
these trace-based approaches and inherit all their shortcomings
and advantages. Nevertheless, an analysis such as the one
presented in this paper is impossible with existing tools.

IV. STUDY DESIGN

To

study

side-channel

compiler-induced

issues, we
developed an analysis pipeline, as depicted in Figure 1. We
first designed a build system that allows us to target different
versions of different compilers and to specify lists of possible
values for different parameters, e.g., target architecture and
optimization level. For each library we intended to study,
we developed small applications that call the official APIs
exposed by the libraries, e.g., crypto_box in Libsodium.
These get compiled with the specified options and are linked
to the library. Finally, the resulting binaries are analyzed by
our tool that outputs secret-dependent operations and their
location in the analyzed library.

A. Detecting Secret-Dependent Operations

We developed a new tool based on emulating user-space
binaries through Qiling [26] and Unicorn [35], which are
based on QEMU.3This emulation-based approach allows
us to target any processor architecture and compiler, as
it can process any final binary. At
the same time, our
tool can detect the same issues as similar frameworks that
are based on binary instrumentation [46]. To fix potential
non-determinism, our tool hooks a set of syscalls selected by
hand to fix the randomness to a deterministic value that does
not change across multiple executions. Thus, by running in a
fully deterministic environment, we posit that if we observe
different execution traces for a given algorithm with two
different secret keys, there is a secret dependency. Our tool
emulates the execution of the target binary a configurable
number of times and records the execution trace of each run.
We manually disable certain JIT optimizations in QEMU that
impact the traces we want to collect. Finally, our tool generates
a report that states how many differences were found in traces,
the functions that led to differences, and how often these
were observed. Locating differences between multiple traces
is trivial for memory-access traces but gets more involved for
control flow. Just as in related work [45]–[47], we compare
the control-flow traces until the first difference is detected.
Afterwards, we look for a merge point where the traces re-
align. This approach is quite compute-intensive as it requires a
forward search with multiple traces and comparisons. We note

3Our tool will be released as open-source in the near future.

4

Soundness. To verify the correctness of our
tool, we
reproduced all the results found in DATA [46] for symmetric
through a
primitives in OpenSSL. In addition, we went
significant number of flagged issues by hand to verify that
they are real issues. We did not find any false positives.

Limitations. We note that by fixing the randomness, we also
fix the nonce and thus do not detect nonce leakage (that
could also lead to compromised keys) as we remove any
potential nonce dependencies. Similarly, we do not detect any
dependencies on the (fixed) plaintext or on random numbers.
All these could be analyzed one at a time with our approach,
but we defer this to future work.

Our study uses a dynamic analysis approach. Thus, we can
only find issues but not prove the absence thereof. We further
arbitrarily set the number of runs to limit compute time. As
a consequence, we might miss edge cases that only appear
for some special conditions and would appear in a larger
number of runs. Nevertheless, our findings demonstrate that
we find relevant secret dependencies (c.f., Section VI), albeit
we might have found even more with a higher number of
runs. Our approach shows similarities with (and shares some
limitations of) fuzzing systems that are also limited in their
completeness and by their execution time.

B. Study Setup

We conduct a large-scale analysis on two off-the-shelf
compilers – 9 versions of GCC and 14 versions of LLVM
– with 8 popular cryptographic libraries under 7 different
optimization levels. This results in a total of 6608 distinct
compiled binaries. We then analyze the binaries for up to
11 cryptographic primitives – depending on the library –
resulting in 44,604 experiments,
i.e., compiled high-level
functions. We then collect 8 traces for each experiment.

We executed our study on eight machines equipped with
an Intel Core i7-11700 and 32 GB of DRAM, and an
AMD-based 192-core server with 1.5 TB of DRAM. Our
experiments took around seven days of computing time.

Targeted Cryptographic Libraries. For this study, we se-
lected 8 cryptographic libraries with varying claims of side-
channel resistance: HACL* [49], Libsodium [15], Botan [29],
BearSSL [37], BoringSSL [18], OpenSSL [42], WolfSSL [36],
and MbedTLS [43]). We chose libraries that are widely used

Fig. 1: Pipeline used for the side-channel analysis. We use a dynamic analysis approach based on differential address trace
analysis [19], [46].

and/or highly regarded for their constant-time implementa-
tions. According to their documentation, all of these libraries
strive to provide side-channel resistance at the source code
level. HACL* [49] claims to achieve this fully. We note that
many of the side-channel-related claims are usually not made
with respect to the resulting binary on all architectures using
any compiler. Instead, side-channel resistance claims are usu-
ally only targeted at a limited set of architectures and compil-
ers [15] or for some intermediate representation [49]. We ana-
lyzed the library’s latest release or stable version as of March
2023. We list the commit that we tested for each library below:

• HACL*/Project Everest [49] (commit: f283af1)
• Libsodium [15] (commit: 8cc84df)
• Botan [29] (commit: 15dc32f)
• BearSSL [37] (commit: 79c060e)
• BoringSSL [18] (commit: 28f96c2)
• OpenSSL [42] (commit: a92271e)
• WolfSSL [36] (commit: 4fbd4fd)
• MbedTLS [43] (commit: 1873d3b)

Cryptographic Algorithms. We also selected a set of
algorithms to be investigated. The chosen algorithms should
be supported by as many target libraries as possible and reflect
a wide range of cryptographic primitives, from symmetric
encryption and message authentication codes to cryptographic
signatures and key exchanges. We list the chosen algorithms
and their respective support for constant-time implementations
in the libraries in Table I.

Compilers and Parameters. We compiled the target libraries
using one of 9 versions of GCC (from GCC 5 to GCC 13) or
one of 14 versions of LLVM (from LLVM 5 to LLVM 18).
We used MUSL as the underlying C standard library [17].
Note that we do not trace MUSL itself and thus will not detect
any secret dependency within it. We do this because we are
interested in studying the cryptographic libraries themselves
and not a specific libc environment in which they might
run. Since LLVM does not ship with a compatible sysroot,
we fall back on the sysroot provided by the GCC toolchain.
impact
secret-dependent memory accesses and control flow. We

We also investigated how optimization levels

tested all the libraries and compilers with up to 7 different
options: -O0, -O1, -O2, -O3, -Ofast, -Os, and -Oz4.

Finally, we also tested 6 processor architectures: x86-64,
x86-i386, armv7, aarch64, RISC-V, and MIPS-32. However,
RISC-V is only supported starting from GCC version 10 and
LLVM version 10 onwards. We believe this list to represent
a good mix of ISAs used for all kinds of computing systems.
We also note that during the disclosure, the contacted library
developers considered all these architectures as important.

All target libraries usually do not support such a large
variety of compilers, optimization levels, and architectures.
We developed some best-effort compilation scripts to be
able to compile for all of these targets. However, some
combinations of parameters either lead to a non-trivial error
during compilation, a broken binary, or the resulting binary
became so inefficient that our analysis ran out of memory on
the smaller machines (mainly with -O0).

Removing Source-Code Issues. Even though constant-time
programming has been known for a long time, some of the
issues that
targeted libraries still contain secret-dependent
are rooted in source code, e.g., AES implementations with
lookup tables. Such issues are usually not removed by the
compiler and thus also show up in our results. We target
compiler-induced issues specifically and therefore need to
filter any such issues. To achieve that, we maintain a manually
curated list of functions or files that contain timing issues
that originate from the source code and remove any issue
that links back to this list. However, such filtering has its
limitations: it does not always work due to compilers inlining
functions or other optimizations that remove or modify the
connection to the source code, and our manually curated
list might miss some source-code issues and not remove
them from our dataset. On the other hand, removing entire
functions might also remove some compiler-induced issues
within these functions. Nevertheless, for some libraries and
compilers, it was impossible to filter results by function name
as the compiler often removes this information. We manually

4The optimization level -Oz is only available in LLVM and is thus

omitted for GCC.

5

LibrariesDiﬀerential Address Trace AnalysisTracesReportsBuild011010011010Trace DiﬃngCompilerLLVM (5-15)GCC (5-11)Architecturearm, aarch64, x86, x86-64, risc-v, mipsOpt-LevelO0, O1, O2, O3, Ofast, Os, OzCompiler ParametersGenerated KeysTarget AlgoAES, ChachaPoly,hmac, ECDH, etc.TABLE I: The target cryptographic libraries and their respective support of constant-time cryptographic primitives. We use
✓and ✗ to indicate constant-time and non-constant-time implementations respectively. Unsupported cryptographic primitives
and those that use blinding as a countermeasure are also marked with ✗.

HACL*

Libsodium Botan

BearSSL

BoringSSL

OpenSSL WolfSSL MbedTLS

AES CBC
AES CTR
AES GCM
Chacha20Poly1305
HMAC SHA1
HMAC SHA256
HMAC Blake2
Curve25519
ECDH P256
ECDSA P256
RSA

✗a
✗a
✗a
✓
✓
✓
✓
✓
✓
✓
✓

✗
✗
✗a
✓
✗
✓
✗
✓
✗
✗
✗

✓
✓
✓
✓
✓
✓
✓
✓
✗c
✗c
✗c

✓
✓
✓
✓
✓
✓
✗
✓
✓
✓
✓

✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✗c

✗b
✗b
✗b
✓
✓
✓
✓
✓
✗c
✗c
✗c

✓
✓
✓
✓
✓
✓
✗
✓
✗c
✗c
✗c

✗b
✗b
✗b
✓
✓
✓
✗
✗c
✗c
✗c
✗c

a Handwritten (assembly) implementation for a subset of architectures.
b Supported but known to have secret-dependent operations on some architectures.
c Blinding is used as a side-channel countermeasure.

verify that
the other secret dependencies flagged by our
tool stem from source code that seems to follow defensive
programming guidelines for cryptographic code [5].

Automation. To run such a wide-ranging study, we developed
an experimentation framework based on Kubernetes. Our
platform takes a set of parameters to evaluate as input, e.g.,
target the library BoringSSL with all supported compilers,
all optimization levels, all architectures, and all algorithms.
It then launches individual jobs for each combination (target
algorithms are merged into the same job). Each job first
sets up the required toolchain and downloads the specified
version of the target library. Then, it builds the library with
the selected optimization level and links it to a small driver
application. Finally, our tool emulates the binary and collects
traces for the selected cryptographic algorithms. Our tool then
generates the reports and saves them to a shared network drive.

we found 15,270 compiler-induced issues in the investigated li-
braries. We list the number of issues per library in Table II. We
note that the number of issues found is exaggerated because
the same issue can appear in multiple places in a binary or
trace (e.g., due to inlining a function). For example, in Botan’s
implementation of x25519, we found a total of 5,499 issues,
4,221 of which are found in binaries for MIPS. A brief manual
analysis of the issues in Botan’s x25519 implementation on
MIPS shows the same issues popping up more than 100 times
for every experiment. This wealth of issues can overshadow
other more nuanced issues that do not appear that often. There-
fore, in some of the following analyses, we categorize each
experiment into one of four categories: whether (1) we did not
find a secret dependency within this experiment, (2) we found
at least one control-flow secret dependency, (3) we found at
least one secret-dependent memory access, and (4) we found
both secret-dependent control-flow and memory accesses.

V. ANALYSIS

B. Processor Architectures

In this section, we quantitatively analyze how compiler
parameters and libraries lead to compiler-induced secret-
dependent operations. We first discuss how many secret-
dependent operations were flagged and if there are differences
between the processor architectures, compilers, compiler ver-
sions, and optimization levels. From the total of 44,604 exper-
iments that we ran, 37,818 (84.8%) were completed success-
fully. The remaining experiments failed either due to compiler
errors or due to our system running out of memory during the
address trace collection. Of the total number of 6,608 binaries,
we compiled 5,716 successfully (86.5%). Our experiments
span 54 implementations of cryptographic primitives.

A. Found Issues

We depict all binaries with at least one control-flow and
memory accesses that were flagged to be secret dependent in
Figure 2. Notably, there is a significant difference between the
processor architectures. We found more binaries with secret
dependencies on less commonly used processor architectures,
i.e., MIPS, RISC-V, and x86-i386. This is especially notable
for RISC-V, which is only supported in 8 out of 17 compiler
versions and thus has less than half the experiments of other
architectures. Nevertheless, we found more binaries with at
least one secret-dependent operation in RISC-V compared
to x86-64, armv7, and aarch64. More mainstream processor
architectures seem to be less affected but not entirely free of
compiler-induced issues.

In the 5’716 binaries, we found at least one secret-dependent
control-flow operation in 469 (8.2%) and at least one secret-
dependent memory access in 378 (6.6%). In absolute numbers,

C. Compilers and Optimization Levels

We depict the number of binaries in which some issues
were flagged according to the compiler and the version

6

TABLE II: Number of compiler-induced secret dependent
operations found per target library across all parameters. Note
that the number of reported issues may appear very large due
to finding the same code patterns multiple times.

Library

Crypto Primitive

Flagged Issues

BearSSL

BoringSSL

Botan

HACL*

rsa
ecdh-p256
ecdsa

ecdh-p256
ecdsa

curve25519
chacha-poly1305
aes-gcm
hmac-blake2
hmac-sha1
hmac-sha2
aes-ctr
aes-cbc

rsa
ecdh-p256
ecdsa

Libsodium

curve25519

Total

460
61
46

1,104
989

5,000
336
33
26
26
26
26
26

6,729
244
136

2

15,270

Fig. 2: Binaries with at least one control-flow or memory-
based secret-dependent operation by target architecture. We
observe more compiler-induced side-channels in less popular
processor architectures.

in newer

aggressive optimizations

that produced it in Figure 3. Interestingly, older compilers
seem to introduce fewer issues. We believe this is due
compilers,
to more
potentially undoing defensive programming techniques. Some
of these optimizations are discussed in the following section
(Section VI), where we manually analyze individual binaries.
We found binaries with issues in all optimization levels as
depicted in Figure 3. We observe notable drops for LLVM’s
and GCC’s -O0. We believe that fewer enabled optimizations
also lead to fewer compiler-induced issues. We discuss in
Section VII that optimizations are one of the reasons compilers
introduce side channels; thus fewer optimizations could mean
defensive programming techniques are less likely to get inter-
fered with. However, we note that this cannot be considered a

7

solution to compiler-induces issues as we still observe some
issues with -O0. We discuss these further in Section VI-D.
We also note that the -O0 results may be misleading since
we could not analyze some algorithms on some libraries
with -O0 as our machines ran out of memory. Therefore,
the experiments with -O0 are not as thorough as the other
optimization levels. We also observe a reduction in flagged
issues with -Os. It is unclear why these differences exist.

VI. NOTABLE FINDINGS

We perform an in-depth manual analysis for a subset of
the found secret-dependent operations. Here, we discuss
some notable findings by showing the portable source
code snippet and the corresponding binary introducing the
secret dependency. If possible, we also briefly analyze the
underlying mechanism in the compiler that introduces the
secret dependency. We only discuss the simplest examples or
those that we can minimally reproduce in this section.

A. HACL*

that

that

In HACL*, we discover
secret-dependent

Secp256.
compiler
the
can introduce
control flow into the
implementation of the elliptic curve secp256. This secret
dependency is executed in HACL*’s implementation of
ECDH-p256 and ECDSA, as both rely on the secp256
implementation. The code snippet
leads to the secret
dependency can be found in Listing 2. The intended
the function cmovznz is a conditional
functionality of
move: it moves either x or y to r depending on a secret
condition (in constant time). The function achieves this by
first computing a mask of either all 1’s or all 0’s depending
on the condition (line 4 in listing 2a). Afterwards, r is set to
(y ∧ mask) ∨ (x ∧ ¬mask). Thus setting r to either x or y
depending on the mask and implicitly the condition (line
5 and 6 in listing 2a). One would expect this to be compiled
into some binary AND and OR operations. However, some
versions of LLVM understand that this is the same as a branch
and replace the bit-wise operations. On MIPS and armv7,
LLVM replaces the bitmask with a direct calculation of the
address of the selected value to be stored in r. We depict an
example resulting armv7 binary in listing 2b. On both MIPS
and armv7 we observed this behavior for versions 14 and
15 and optimization levels -Os and -Oz. On RISC-V and
x86-i386, LLVM replaces the bitmask operations with four
control flow instructions. We observe this behavior on LLVM
versions 13, 14, and 15 on all optimization levels besides -O0.
Further investigation shows that LLVM understands the
bitmask generation and arithmetic logic and replaces it with
a select IR instruction with the semantic of assigning
a variable to one of
the parameters depending on the
input condition. The culprit of this optimization is a pass
called InstCombine, which performs optimizations by
In this
combining and simplifying arithmetic operations.
case, InstCombine replaces the mask generation and
the subsequent bitwise AND and ORs with a select.
this is a
According to the LLVM documentation [30],

Fig. 3: Experiments with at least one secret-dependent operation per compiler, their respective versions, and optimization level.

potential optimization to allow the backend to decide how to
instantiate the select IR instruction based on the processor
architecture. For example, on x86-64, select is sometimes
instantiated with a cmov instruction.

B. Botan

AES-GCM. We discover compiler-induced secret-dependent
control flow in Botan’s implementation of GHASH,
the
authentication component of AES-GCM. Listing 3 shows a
simplified snippet of how Botan precomputes the H-values
for the key schedule of GHASH in a supposedly purely
arithmetic way. However, instead of just performing the XOR
operation with carry, LLVM 15 replaces this with a branch
on RISC-V: If carry is 0, then jump over the XOR.

128-bit Custom Type. We discover a similar compiler-
induced secret-dependent operation in the implementation of
a custom 128-bit wide type in Botan used in Chacha-Poly1305
and x25519. For platforms that do not natively support 128-
bit integers, Botan uses a 128-bit software implementation
that uses two 64-bit words. Botan implements the addition
operator by first adding the lower half, calculating the carry,
and then adding the upper half and the carry. We depict
Botan’s implementation in Listing 4. Similar to the previous
issue in Botan’s GHASH implementation, binaries by some
compilers first check the carry and skip the second addition

8

if the carry is not set. We observe this behavior for GCC
on MIPS and x86-i386. Interestingly, the compiler can insert
both secret-dependent control flow and memory accesses at
the same time. For example, using GCC 11.3.0 on MIPS
with -O2 produces a binary with memory and control-flow
secret dependencies. We observe this operator getting called
in Botan’s x25519 and chacha-poly1305 implementation.

C. BearSSL

Secp256. BearSSL’s implementation of the elliptic curve
secp256 contains a small routine to check a scalar; a simplified
version is shown in Listing 5. In this function, a scalar is
checked to be below the curve order. This is achieved
by comparing the scalar byte-by-byte to the curve order
(P256_N). Recent versions of LLVM for RISC-V replace the
bitmask arithmetic operations with a secret-dependent branch.

in

operation

secret-dependent

Modular Exponentiation. We discover another compiler-
BearSSL’s
induced
implementation of modular exponentiation. The source
code snippet and the corresponding x86-64 assembly can be
found in Listing 6. The desired functionality of the snippet is
similar to the cmovnz snippet described above for HACL*.
The snippet either sets x to y or to z depending on the
condition. EQ computes a mask of either all 0’s or all 1’s
depending if condition == 0. LLVM on Aarch64 and

1

2

3

4

5

1

2

3

4

5

1

2

3

4

5

6

1

2

3

4

5

6

7

void cmovznz4(uint32_t condition, uint32_t *x,

uint32_t *y, uint32_t *r) {

uint32_t mask = ~calc_mask(condition);
r[0] = (y[0] & mask) | (x[0] & ~mask);

}

1

2

3

4

5

6

cmovznz4:

cmp
movne
ldr
str
bx

r0, #0
r1, r2
r0, [r1]
r0, [r3]
lr

(a) Source code snippet.

(b) armv7 assembly (LLVM 15, -Os).

Listing 2: Simplified snippet used in HACL*’s implementation of elliptic curve P256. This function implements a conditional
move, i.e., it moves either x or y to r depending on condition. The function calc_mask creates a bitmask based
on condition with either all 1s or all 0s. LLVM replaces the bitmask arithmetic with a movne to compute the address
followed by secret-dependent memory accesses highlighted in blue in armv7 and MIPS. In RISC-V and x86-i386, the bitmask
arithmetic gets replaced with a secret-dependent branch instead.

uint64_t precompute(uint64_t H0, uint64_t H1) {
const uint64_t R = 0xE100000000000000;
const uint64_t carry = R * (H1 & 1);
return (H0 >> 1) ^ carry;

}

1

2

3

4

5

6

7

8

9

precompute:
andi
srli
beqz
li
slli
xor

.LBB0_2:

ret

%
%
%
%
%
%

(a) Simplified source code.

(b) RISC-V assembly (LLVM 15, -O2).

Listing 3: Simplified source code snippet found in Botan’s implementation of GHASH used in AES-GCM. This function is
a part of the key schedule. The compiler produces a binary that skips the addition if the carry is 0 (highlighted in blue).

uint128_t operator+=(uint128_t &x) {

l += x.l; h += x.h;
uint64_t carry = (l < x.l);
h += carry;
return *this;

}

Listing 4: Simplified source code snippet found in Botan’s
implementation of a 128-bit type used in chacha-poly1305.
The compiled binary skips the carry addition if the carry is 0.

uint32_t check_scalar(const unsigned char *k) {

uint32_t c = 0;
for (int u = 0; u < 32; u ++) {

c |= CMP(k[u], P256_N[u]);

}
return c;

}

Listing 5: Simplified check-scalar routine in BearSSL’s
implementation of secp256. This routine checks if the key is
lower than the curve order. The function CMP compares two
numbers and returns -1, 0, 1 if the first argument is smaller,
equal, or larger using binary arithmetic operations. Recent
LLVM versions on RISC-V detect the bitmask arithmetic and
replace it with a secret-dependent branch.

x86-64 replace the mask computation with a conditional
mov on x86-64 and a conditional select on Aarch64,
respectively. However,
the compiler does not use this
instruction to set the x variable directly. It uses it to compute
an address, which is then loaded and stored in x. This leads to

a secret-dependent memory access operation which leaks the
condition as either the memory location of y or z is read and
written into x. LLVM performs a part of this optimization in
the InstCombinePass where the bitmask computation is
replaced with a select IR instruction (similar to HACL*).
In the backend, the compiler then replaces the select with a
cmov or csel instruction which computes the address for
the secret-dependent memory access.

D. BoringSSL

Complex Branching Condition. Recent LLVM compilers
may split a branch with complex conditions into multiple
branches with parts of the condition in a snippet found in
BoringSSL. This behavior creates a small leak because which
branch is taken leaks which part of the condition was true or
false. We observed this behavior in the point-add routing of
P256 on armv7, MIPS, and x86-i386. A snippet that shows
the culprit branch is depicted in Listing 7. Interestingly, the
optimization level does not impact this transformation as we
observe this behavior even with no optimization (-O0).

Generic Bignum Implementation (-O0). BoringSSL aims
to be compatible with many architectures. Some of
the
more obscure architectures are supported with a generic
implementation of some big number operations. However,
this generic implementation relies on the compiler to remove
some branches that are present in the source code. With no
these branches clearly show up as
optimizations enabled,
shown in Listing 8. We also find that some combinations
of compilers and optimization levels do not optimize the
branch correctly, resulting in a secret-dependent control flow

9

1

2

3

4

5

1

2

3

4

5

6

7

uint64_t mask1 = -(uint64_t)EQ(condition, 0);
uint64_t mask2 = ~mask1;
for (int i = 0; i < len; i ++) {

x[i] = (mask1 & y[i]) | (mask2 & z[i]);

}

1

2

3

4

5

6

test
lea
lea
cmove
mov
mov

%
%
%
%
%
qword ptr [%

(a) Source code snippet.

(b) x86-64 assembly (LLVM 15, -Os).

Listing 6: Simplified source code snippet
in BearSSL. Similar code patterns are used in its modular exponentiation
implementations used in RSA, ECDH-P256, and ECDSA. Recent versions of LLVM on x86-64 replace the mask with a
cmov instruction to create the address that is used to write a value into x[i] in the instruction highlighted in blue. This
thus leaks the condition as the address of y[i] is different to z[i]. On Aarch64, LLVM inserts csel instead of cmov.

uint32_t is_nontriv_double = ct_is_zero(xneq | yneq) &

~ct_is_zero(z1nz) &
~ct_is_zero(z2nz);

if (is_nontriv_double) {

fiat_p256_point_double(x3, y3, z3, x1, y1, z1);
return;

}

Listing 7: Simplified source code snippet
in BoringSSL.
Recent versions of LLVM on armv7, MIPS, and x86-i386
insert two distinct branching instructions instead of a single
branch. Which of the two branching instructions is taken
leaks information to an attacker and depends on the secret.

operation even with optimizations enabled. This issue has
been fixed independently of our report, and we confirm that
the fix [10] removes the observed issues.

VII. PROBLEMATIC COMPILER INTERNALS

We categorize the found compiler-induced secret-dependent
operations into three types:
replacing bitmask arithmetic
with branches, arithmetic shortcuts to skip computation, and
splitting complex branching conditions into multiple branches.
The first issue was previously studied in toy examples [41],
but to the best of our knowledge, the latter two have not yet
been discussed. We analyze how and why these optimizations
are introduced in modern compilers. We note that this list
is not comprehensive, as more compiler-induced secret
dependencies might appear in future compilers. Since these
code patterns are also used in other libraries without any
introduced secret-dependent operations, we analyze whether
these patterns can be used safely.

Simplification of Bitmask Arithmetic. LLVM seems to
be very advanced in understanding and optimizing bitwise
arithmetic operations, as we found most such issues in
binaries produced by LLVM. However, we also found some
simplifications in binaries compiled by GCC, albeit less than
with LLVM. In the following, we focus on LLVM as it
optimizes bitmask arithmetic more aggressively.

Compilers do numerous optimization passes on the input
program.
In the context of bitmask arithmetic, LLVM
contains an optimization pass that tries to reduce redundant
instructions called instcombine [30]. This pass tries

to perform algebraic simplifications by employing a big
recursive pattern-matching engine. In the observed cases, the
instcombine pass replaces the mask generation and the
subsequent bitwise AND and ORs with a select LLVM
instruction. The LLVM compiler instantiates the select
instruction in the ISA-specific backend based on the processor
architecture. For example, on x86-64, select is sometimes
instantiated with a cmov instruction, and on RISC-V and
MIPS with conditional branches. Sometimes, the ISA-specific
backend removes the select instruction altogether and does
not introduce secret-dependent operations.

Since bitmask arithmetic is a popular building block
in constant-time cryptographic implementations, we also
investigate how other libraries leverage bitmasks without
producing secret-dependent operations. Many libraries use
the same implementation of various cryptographic algorithms,
such as poly1305-donna [34]. This
implementation of
poly1305 contains a bitmask arithmetic pattern in the
function poly1305_finish.
In our experiments, no
compiler produced a binary with secret-dependent operations
for this implementation. We do not know if the current
source code pattern is deliberately chosen to avoid secret-
dependent operations or if this is just a lucky coincidence.
For now, this implementation seems not to produce secret-
dependent operations with the evaluated compilers. To test
the robustness of code patterns using bitmask arithmetic, we
randomly tried innocent source code changes and observed
that compilers once again introduce secret-dependencies5.
This highlights that bitmask arithmetic is not very robust and
may unexpectedly produce secret-dependent operations. We
did not find a way to ascertain if a specific arithmetic source
code pattern is safe just by looking at the source code.

Arithmetic Shortcuts. Arithmetic shortcuts use branches to
skip further computation (c.f., Listing 3). We observed this be-
havior with both GCC and LLVM. Further manual experiments
with source code patterns show that this optimization is mainly
performed in the ISA-specific backend of the two compilers.
We believe the issues found in this study to be misguided
optimizations. Skipping an XOR instruction will be slower
than just performing the XOR as it is a very fast instruction.

5E.g., we only moved the select bitmask part to its own function.

10

1

2

3

4

5

6

7

8

9

void bn_sqr_comba8(uint32_t r[3], uint32_t a[1],

uint32_t c1, uint32_t c2,
uint32_t c3) {

uint64_t t = (uint64_t)a[0] * a[0] + c1;
c1 = (uint32_t)t;
uint32_t hi = (uint32_t)(t >> 32);
c2 += hi;
if (c2 < hi) c3++;
r[0] = c1; r[1] = c2; r[2] = c3;

10

}

1

2

3

4

5

6

7

8

9

...
lw
lw
sltu
beqz
nop
j
nop
...

$1, 16($fp)
$2, 12($fp)
$1, $1, $2
$1, $BB0_3

$BB0_2

(a) Source code snippet.

(b) MIPS assembly of the if branch (LLVM 15, -O0).

Listing 8: Simplified source code snippet in BoringSSL. BoringSSL relies on the compiler to optimize the if branch and
replace it with arithmetic operations. However, LLVM does not perform this optimization on -O0. We also found some other
cases where compilers did not correctly optimize the branch with all other optimization levels. This implementation is only
used on MIPS and RISC-V.

In the instances found in this study, the compiler’s frontend in-
jects the secret-dependent branch via a select IR instruction,
similar to the bitmask arithmetic optimization above. Since
all architectures share the same frontend in LLVM, they all
have a select instruction in their IR before the backend
optimizations. Some backends for less popular architectures,
such as MIPS and RISC-V, produce inefficient binaries that use
branches to skip an XOR operation in some LLVM versions.
Luckily, backends for the other four architectures remove the
secret-dependent select again and just perform the XOR.
To further experiment with this behavior, we manually
create a code snippet that would greatly benefit from optimiza-
tion: we created a function with a boolean input that allows a
division operation to be skipped if it is true. Advanced compil-
ers know that division is an expensive operation and, therefore,
produce a binary that skips the division if possible (e.g., when
the input is true). We managed to reproduce this with LLVM
in arguably the most popular architecture, x86-64, where an
ISA-specific pass introduces a branch that skips the division.
In summary, branches to skip expensive computations
are a common optimization in both compilers. They are
instrumental in optimizing performance in cases where the
expensive operation is often unnecessary and can be skipped.
We observed these optimizations in multiple places in modern
compilers: in the shared frontend and the architecture-specific
backend of the compiler. Current issues that we found seem
to be misguided and can be fixed with newer compilers with
better optimizations. However, we found other patterns that
did not occur in the surveyed libraries where secret-dependent
branches would be injected. Therefore, developers should
be careful in cases where an expensive operation could be
skipped for 50% of the inputs.

Complex Branch Conditions. In some cases, compilers
can split branches with complex conditions into multiple
branching instructions, each with a part of the condition
(c.f., Listing 7). This behavior allows an adversary to
leak which branching instruction was taken and thus learn
some information about the complex condition. The developer
might assume that the condition is checked atomically, but the

compiler gives no such guarantee. For the same architecture
and compilation flags, sometimes a source code pattern is safe,
but just slight tweaks to the code (still adhering to the same
pattern) lead to the compiler introducing secret-dependent
operations. Therefore, avoiding such compiler-induced secret
dependencies is very hard without binary analysis. However,
we have only rarely found this behavior and only in LLVM.

VIII. TAKEAWAYS

Defensive programming techniques can be ineffective. As
we have shown in the previous sections, cryptographic libraries
often contain compiler-induced secret dependencies even
though they apply current defensive programming techniques.
The manual analysis of the flagged issues indicates that
the issues that we find are not due to developer error but
rather unexpected transformations by the compiler. We thus
conclude that the current defensive programming techniques
are insufficient. It remains unclear if the rules are incomplete,
i.e., a new specific rule would lead to safe source code again,
or if they are fundamentally broken with modern compilers.
We defer the exploration of such new rules to future work.

Constant-time source code is brittle. As seen in our anal-
ysis of findings in Section VI, compilers apply very smart
simplifications and optimizations to source code. However,
we also demonstrated that some of these seem to introduce
side-channel vulnerabilities in some implementations. The fact
that only some implementations suffer from this suggests that
compilers currently only optimize certain code patterns in
“dangerous” ways. Avoiding such patterns is not a definite so-
lution, though: the same code patterns that, for now, seem to be
fine based on our analysis might be broken by the next gener-
ation of compilers. For example, LLVM started to aggressively
simplify bit-wise mask arithmetic to select IR instructions
starting from version 12. Our results indeed show a spike in the
number of found vulnerabilities from that version in Figure 3.
For now, LLVM only simplifies some types of bitmasks danger-
ously, and it does not recognize others – future improvements
might change this and lead to even more such issues.

11

Recommendations for libraries are that new releases should
come with a list of tested target architectures, operating
systems, compilers, and important flags. Then, users of a
library can at least use a compiler that is believed to maintain
the constant-time properties of
the library. Nevertheless,
our work demonstrates how brittle the current state of
constant-time high-level source code has become.

The Case for Continuous Testing. Some of the issues that we
discovered are produced by compilers that are up to 10 years
old. This is a significant time period, and it is unclear why
such behavior was not flagged before. We believe that rigorous
continuous testing on as many processor architectures and
compilers as possible should be the standard for cryptographic
libraries. A recent survey [21] has asked developers of cryp-
tographic libraries about the tools they use and highlights that
most libraries still lack such infrastructure. Our findings also
confirm this. We approached the maintainers of the libraries
targeted in this paper to offer our help if they want to add our
tool to their infrastructure. Some of them were receptive to
this idea, and we are currently evaluating if this is feasible.

IX. DEFENSES

In this section, we discuss potential defenses against

compiler-induced timing side-channels.

Principled Defenses. There are two principled defenses that
eliminate all compiler-induced secret dependencies: formal
analysis of the binary or using a compiler that guarantees not
to include any issues.

Formal verification of assembly is used on the predominant
processor architectures [11] only because it requires a high de-
gree of effort and know-how of the targeted processor architec-
ture. Nevertheless, such code is guaranteed to remain constant-
time as it does not go through any other transformation.

The second principled defense is using a compiler that
guarantees no such induced issues. Ideally,
the compiler
comes with formal guarantees for not changing the constant-
time behavior of source code such as CompCert [8], [9].
However, such compilers are rarely used in practice as they
lag behind commodity compilers in supported architectures
and performance. There also have been many proposals to
add passes to commodity compilers or annotate functions or
variables to disable certain optimizations [13]. However, these
efforts have not yet had the desired effect on mainstream
compilers and have not been included upstream.

that

Compilers

transform secret-dependent code into
constant-time binaries [12], [38] usually transform general-
purpose code into a linear binary that executes all branches
no matter the input. These approaches have been shown to
produce side-channel free binaries [12], but they are usually
research artifacts and, as such, not yet usable for production.

Certification. Another option is certification: Cryptographic
libraries could use tools to certify any binary produced by
a commodity compiler,
the binary
does not contain secret-dependent operations. Formal or
symbolic tools could prove the absence of secret-dependent

thus guaranteeing that

12

operations in binaries. We note that the approach used in
this paper cannot be used to provide this guarantee as we
only find such issues but cannot prove the absence thereof.
Certifying binaries notably shifts the release procedure of
major libraries as they should no longer release the source
code to be compiled but rather multiple binaries for different
architectures and operating systems. This would require a
significant effort for every single release with the upside of
security guarantees for the binary. Obviously, an important
aspect of
they are open
source, thus binary certification would be most beneficial in
conjunction with approaches akin to reproducible builds.

these libraries is the fact

that

Increased Testing. Some libraries already perform in-depth
testing prior to a new release. For instance, libsodium [15]
performs tests and analysis for more than 20 target platforms:
from WebAssembly on V8, various compilers for x86-64
Ubuntu and macOS, to Debian on SPARC. As we did not
find many issues in libsodium, this rigorous testing seems
to have a beneficial effect. However, we want to note that
libsodium is the smallest library that we test with the most
limited support for cryptographic primitives. For example,
libsodium does not support the elliptic curve secp256; instead,
they do all of their elliptic curve operations on curve25519.
Therefore, it may be unfair to compare to larger libraries
with support for more cryptographic primitives.

We remark that

increased testing does not provide any
formal guarantee of the binary compared to certification.
Nevertheless, rigorous testing can help mitigate compiler-
induced issues and detect them before they can do any harm.

X. RELATED WORK

This paper presents contributions in two main directions,
i) a new tool that allows testing for side-channels in many
architectures from a single platform, and ii) a study of
dangerous compiler transformations in constant-time libraries.
We stress that the literature is rich in terms of related tools,
and while its novelty is nuanced, as we describe below, its
main advantage is that it enables performing such a study.

Side-Channel Detection Tools. Numerous related tools detect
side channels in various targets, from static analysis of higher-
level source code to statistical tests of the final binaries. For
an extensive survey of such tools, we refer to [6] and [21].
Statistical test tools collect numerous black-box measure-
ments and use statistical tools to interpret the measurements.
For example, dudect [39] uses Welch’s t-test to check for infor-
mation leakage. While any leaks found by such tools are usu-
ally immediately exploitable, they also miss a significant num-
ber of leaks as they only consider their target as a black box. In
practice, side-channel attacks have become much more power-
ful with improved granularity and synchronization [33], [44].
Symbolic trace-based tools [16] use symbolic execution
to evaluate all paths of a target. CacheAudit [16], one of the
most well-known tools in the category, uses these traces to
provide an upper bound for the leakage. It is easy to reason
about a zero upper bound, but any other value is hard to

interpret, as it does not help to pinpoint the issue. However,
these tools are usually tailored to one processor architecture
and cannot easily be extended to others.

Formal analysis tools provide strong guarantees as they
can prove the absence of issues in a target [3], [8], [49].
However, these tools usually only reason on high-level source
code or some intermediate representation. It is unclear if and
how these guarantees translate to binaries6.

Dynamic tools enable the analysis of the actual execution
of the final binary. For example, ctgrind [25] uses Valgrind to
trace hand-annotated secret memory regions and report any
secret-dependent access to it. The closest related tools to the
one developed for our study are trace-based dynamic analysis
tools [19], [45], [47]. Trace-based approaches record a number
of traces for different secret inputs and then compare the traces
to identify secret-dependent operations. These approaches
have various advantages:
they are relatively performant,
reason about the final binary, and can precisely pinpoint the
issues. However, they are incomplete: they cannot guarantee
the absence of leaks. A final limitation of these tools is their
limited portability, as they usually rely on binary instrumen-
tation frameworks that are not portable. As such, these tools
usually only support a single processor architecture [46].

Automatically Fixing Secret Dependencies. This paper
focuses on libraries that are already hardened against all
side-channel attacks. However, the vast majority of programs
are not hardened. Various approaches that
transform non-
hardened code to a binary that contains no secret dependencies
exist [12], [38]. However, we note that these approaches are
not used by any security-critical library that we investigated.
Nevertheless, our analysis could be extended to binaries
produced by these approaches.

Studies.

Compiler-induced

Related
secret-dependent
operations have been studied in the past. They have been
reproduced using toy examples [14], [41]. The toy examples
mostly focus on binary arithmetic and how compilers may
simplify these. Binsec/Rel [14] also performs a study of
several
implementations on
cryptographic
the binary level on x86 and arm architectures. However,
investigate other architectures nor how other
they do not
compilers can affect these implementations. To the best of our
knowledge, we are the first to demonstrate compiler-induced
issues in constant-time cryptographic libraries in the wild.

constant-time

Kaufmann et al. discovered a secret dependency in a
the
curve25519 implementation [22]. They detect
Windows
runtime library introduces a secret-dependent
variation using the compiler MSVC 2015. In this paper, we
do not trace the runtime library and will not flag such issues.
All of the secret dependencies that we found purely originate
from the library itself. We remark that issues in underlying
runtime libraries are no less critical, and our approach could
also be extended to also trace them.

that

6If a formally proven compiler [7] is used, then the guarantees should

translate down to the binary.

13

XI. CONCLUSION

General-purpose compilers can interfere with hardening
techniques used to write high-level constant-time code, e.g.,
in cryptographic libraries.
In this paper, we investigated
whether this happens in the wild and to what extent. For
this, we developed a flexible pipeline based on trace-based
dynamic analysis that allowed us to measure a large number
of
libraries, compilers, optimization versions, and
processor architectures. Using our pipeline, we analyzed
whether the resulting binaries and algorithms exhibited any
of the following two behaviors: control-flow decisions and
memory accesses based on secret values, both of which are
symptomatic of non-constant-time execution.

target

Our study demonstrates that compiler-induced side-channel
vulnerabilities are widespread in cryptographic primitives of
libraries that adopt constant-time programming techniques.
We observed issues in all
tested processor architectures,
compiler versions, and optimization levels. These issues
emerged in 5 of the 8 profiled libraries – even one where
the source code was formally verified to be free of such side
channels. We analyze a few notable cases in detail: the main
secret-dependent operations introduced by the compilers are
arithmetic shortcuts to skip some computation (e.g., early exit
from loops), replacing bitmask arithmetic with branches, and
splitting complex branching conditions – directly reversing
the recommendations of defensive programming guidelines to
achieve constant-time code [5]. This suggests that compilers
silently “undo” the code patterns that developers introduce
purposefully to ensure constant-time execution.

Current principled defenses do not seem ready for mass
adoption: compilers that provide constant-time code guaran-
tees are specialized and lag behind general-purpose ones in
terms of supported architectures, features, and performance.
Formally verifying the assembly produced by compilers
requires high manual efforts and is thus reserved for the most
popular architectures only – confirmed by our findings that less
popular architectures are more subjected to compiler-induced
vulnerabilities. Distributing certified binaries would greatly
increase the efforts of developers and users of libraries alike.
Our work highlights that current defensive programming
techniques are more akin to anecdotal workarounds to
compilers’ behavior
than a systematic solution.
Our results point out that high-level constant-time code is
prone to dangerous transformations and optimizations from
compilers and calls for cooperation between developers of
security-critical libraries and general-purpose compilers.

rather

REFERENCES

[1] O. Acıiçmez, Ç. K. Koç, and J.-P. Seifert, “Predicting secret keys via
branch prediction,” in Topics in Cryptology – CT-RSA 2007, M. Abe,
Ed. Berlin, Heidelberg: Springer Berlin Heidelberg, 2006, pp. 225–242.
[2] M. R. Albrecht and K. G. Paterson, “Lucky microseconds: A timing at-
tack on amazon’s s2n implementation of tls,” in Advances in Cryptology–
EUROCRYPT 2016: 35th Annual International Conference on the The-
ory and Applications of Cryptographic Techniques, Vienna, Austria, May
8-12, 2016, Proceedings, Part I 35. Springer, 2016, pp. 622–643.

[3] J. B. Almeida, M. Barbosa, J. S. Pinto, and B. Vieira, “Formal
verification of side-channel countermeasures using self-composition,”
Science of Computer Programming, vol. 78, no. 7, pp. 796–812, 2013.
2012,

[4] J.-P. Aumasson,

“A cryptography

standard,”

coding

https://web.archive.org/web/20190203024646/https://cryptocoding.
net/index.php/Coding_rules.

[5] ——, “Cryptocoding,” 2019, https://github.com/veorq/cryptocoding.
[6] M. Barbosa, G. Barthe, K. Bhargavan, B. Blanchet, C. Cremers, K. Liao,
and B. Parno, “Sok: Computer-aided cryptography,” in 2021 IEEE
Symposium on Security and Privacy (SP). Los Alamitos, CA, USA:
IEEE Computer Society, may 2021, pp. 777–795. [Online]. Available:
https://doi.ieeecomputersociety.org/10.1109/SP40001.2021.00008
[7] G. Barthe, B. Gregoire, and V. Laporte, “Secure compilation
cryptographic
Security
IEEE
[Online]. Available:

of
side-channel
“constant-time”,”
Foundations Symposium (CSF).
Computer Society,
https://doi.ieeecomputersociety.org/10.1109/CSF.2018.00031

countermeasures: The
in

Los Alamitos, CA, USA:

jul 2018, pp. 328–343.

of
Computer

IEEE

2018

case

31st

[8] G. Barthe, G. Betarte, J. Campo, C. Luna, and D. Pichardie,
“System-level non-interference for constant-time cryptography,” in
the 2014 ACM SIGSAC Conference on Computer
Proceedings of
and Communications Security, ser. CCS ’14. New York, NY, USA:
Association for Computing Machinery, 2014, p. 1267–1279. [Online].
Available: https://doi.org/10.1145/2660267.2660283

[9] G. Barthe, S. Blazy, B. Grégoire, R. Hutin, V. Laporte, D. Pichardie, and
A. Trieu, “Formal verification of a constant-time preserving c compiler,”
Cryptology ePrint Archive, Paper 2019/926, 2019, https://eprint.iacr.
org/2019/926. [Online]. Available: https://eprint.iacr.org/2019/926
gcc

“BoringSSL: Avoid

Benjamin,

in
branches
https://boringssl.googlesource.com/boringssl/

bn/generic.c.”
+/d4396e387c820198f509a6927facea84592cddd8.

2023,

in

[10] D.

[11] B. Bond, C. Hawblitzel, M. Kapritsos, K. R. M. Leino, J. R. Lorch,
B. Parno, A. Rane, S. Setty, and L. Thompson, “Vale: Verifying High-
Performance cryptographic assembly code,” in 26th USENIX Security
Symposium (USENIX Security 17). Vancouver, BC: USENIX Associa-
tion, Aug. 2017, pp. 917–934. [Online]. Available: https://www.usenix.
org/conference/usenixsecurity17/technical-sessions/presentation/bond

[12] P. Borrello, D. C. D’Elia, L. Querzoni, and C. Giuffrida, “Constantine:
Automatic side-channel resistance using efficient control and data flow
linearization,” in Proceedings of the 2021 ACM SIGSAC Conference on
Computer and Communications Security, 2021, pp. 715–733.

[13] S. Cauligi, G. Soeller, B. Johannesmeyer, F. Brown, R. S. Wahby,
J. Renner, B. Grégoire, G. Barthe, R. Jhala, and D. Stefan, “Fact:
A dsl for timing-sensitive computation,” in Proceedings of the 40th
ACM SIGPLAN Conference on Programming Language Design and
Implementation, ser. PLDI 2019. New York, NY, USA: Association
for Computing Machinery, 2019, p. 174–189. [Online]. Available:
https://doi.org/10.1145/3314221.3314605

[14] L.-A. Daniel, S. Bardin, and T. Rezk, “Binsec/rel: Efficient relational
symbolic execution for constant-time at binary-level,” in 2020 IEEE
Symposium on Security and Privacy (SP).
IEEE, 2020, pp. 1021–1038.
https:

Available:

[Online].

[15] F.

Denis,

“libsodium.”
//github.com/jedisct1/libsodium

[16] G. Doychev, B. Köpf, L. Mauborgne, and J. Reineke, “Cacheaudit: A
tool for the static analysis of cache side channels,” ACM Transactions
on Information and System Security (TISSEC), vol. 18, no. 1, pp. 1–32,
2015.

[17] R. Felker, “musl libc,” https://musl.libc.org/.
2014.
“Boringssl,”
[18] Google,
https://boringssl.googlesource.com/boringssl/

June

[Online].

Available:

[19] S. He, M. Emmi, and G. Ciocarlie, “ct-fuzz: Fuzzing for timing leaks,”
in 2020 IEEE 13th International Conference on Software Testing,
Validation and Verification (ICST).

IEEE, 2020, pp. 466–471.

[20] Intel, “Intel pin - a dynamic binary instrumentation framework,”
2007, https://www.intel.com/content/www/us/en/developer/articles/tool/
pin-a-dynamic-binary-instrumentation-tool.html.

[21] J. Jancar, M. Fourne, D. Braga, M. Sabt, P. Schwabe, G. Barthe,
P. Fouque, and Y. Acar, ““they’re not that hard to mitigate”: What cryp-
tographic library developers think about timing attacks,” in 2022 IEEE
Symposium on Security and Privacy (SP). Los Alamitos, CA, USA:
IEEE Computer Society, may 2022, pp. 632–649. [Online]. Available:
https://doi.ieeecomputersociety.org/10.1109/SP46214.2022.9833713
[22] T. Kaufmann, H. Pelletier, S. Vaudenay, and K. Villegas, “When
Exploiting

constant-time

variable-time

binary:

source

yields

curve25519-donna built with msvc 2015,” in Cryptology and Network
Security, S. Foresti and G. Persiano, Eds. Cham: Springer International
Publishing, 2016, pp. 573–582.

[23] P. Kocher, J. Jaffe, and B. Jun, “Differential power analysis,” in
Berlin,

Advances in Cryptology — CRYPTO’ 99, M. Wiener, Ed.
Heidelberg: Springer Berlin Heidelberg, 1999, pp. 388–397.

[24] P. C. Kocher, “Timing attacks on implementations of diffie-hellman,
rsa, dss, and other systems,” in Advances in Cryptology — CRYPTO
’96, N. Koblitz, Ed. Berlin, Heidelberg: Springer Berlin Heidelberg,
1996, pp. 104–113.

[25] A. Langley, “Checking that functions are constant time with valgrind,”
https://www.imperialviolet.org/2010/04/01/ctgrind.html, April 2010.

[26] K. Lau

and A. Q. Nguyen,

“Qiling

framework,”

https:

//github.com/qilingframework/qiling.

[27] S. Lee, M.-W. Shih, P. Gera, T. Kim, H. Kim, and M. Peinado,
“Inferring fine-grained control flow inside SGX enclaves with
branch shadowing,” in 26th USENIX Security Symposium (USENIX
Security 17). Vancouver, BC: USENIX Association, Aug. 2017,
pp. 557–574. [Online]. Available: https://www.usenix.org/conference/
usenixsecurity17/technical-sessions/presentation/lee-sangho

[28] F. Liu, Y. Yarom, Q. Ge, G. Heiser, and R. B. Lee, “Last-level
cache side-channel attacks are practical,” in 2015 IEEE Symposium
on Security and Privacy (SP).
IEEE
Computer Society, may 2015, pp. 605–622.
[Online]. Available:
https://doi.ieeecomputersociety.org/10.1109/SP.2015.43

Los Alamitos, CA, USA:

[29] J. Lloyd, “Botan: Crypto and tls for modern c++,” 2000. [Online].

Available: https://botan.randombit.net/

[30] LLVM, “Llvm language reference manual,” https://llvm.org/docs/

LangRef.html.

[31] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lowney,
S. Wallace, V. J. Reddi, and K. Hazelwood, “Pin: building customized
program analysis tools with dynamic instrumentation,” Acm sigplan
notices, vol. 40, no. 6, pp. 190–200, 2005.

[32] R. J. Masti, D. Rai, A. Ranganathan, C. Müller, L. Thiele, and
S. Capkun, “Thermal covert channels on multi-core platforms,” in 24th
USENIX Security Symposium (USENIX Security 15). Washington, D.C.:
USENIX Association, Aug. 2015, pp. 865–880. [Online]. Available:
https://www.usenix.org/conference/usenixsecurity15/technical-sessions/
presentation/masti

[33] A. Moghimi, J. Wichelmann, T. Eisenbarth, and B. Sunar, “Memjam: A
false dependency attack against constant-time crypto implementations,”
International Journal of Parallel Programming, vol. 47, pp. 538–570,
2019.

[34] A.

Moon,

“poly1305-donna,”

https://github.com/floodyberry/

poly1305-donna.

[35] A. Q. Nguyen and H. V. Dang, “Unicorn: Next generation cpu emulator

framework,” https://github.com/unicorn-engine/unicorn.

[36] T. Ouska, “Wolfssl: Embedded tls library,” February 2006. [Online].

Available: https://www.wolfssl.com/

[37] T. Pornin, “Bearssl: a smaller ssl/tls library,” November 2016. [Online].

Available: https://bearssl.org/

[38] A. Rane, C. Lin, and M. Tiwari, “Raccoon: Closing digital {Side-
Channels} through obfuscated execution,” in 24th USENIX Security
Symposium (USENIX Security 15), 2015, pp. 431–446.

[39] O. Reparaz, J. Balasch, and I. Verbauwhede, “Dude, is my code constant
time?” in Proceedings of the Conference on Design, Automation &
Test in Europe, ser. DATE ’17. Leuven, BEL: European Design and
Automation Association, 2017, p. 1701–1706.

[40] E. Ronen, K. G. Paterson, and A. Shamir, “Pseudo constant

time
implementations of tls are only pseudo secure,” in Proceedings of the
2018 ACM SIGSAC Conference on Computer and Communications
Security, 2018, pp. 1397–1414.

[41] L. Simon, D. Chisnall, and R. Anderson, “What you get is what you c:
Controlling side effects in mainstream c compilers,” in 2018 IEEE Eu-
ropean Symposium on Security and Privacy (EuroS&P). Los Alamitos,
CA, USA: IEEE Computer Society, apr 2018, pp. 1–15. [Online]. Avail-
able: https://doi.ieeecomputersociety.org/10.1109/EuroSP.2018.00009

[42] The OpenSSL Project, “OpenSSL: The open source toolkit

for

SSL/TLS,” April 2003, www.openssl.org.

[43] TrustedFirmware,

“Mbedtls,”
https://www.trustedfirmware.org/projects/mbed-tls/

January 2009.

[Online]. Available:

[44] J. Van Bulck, F. Piessens, and R. Strackx, “Nemesis: Studying
microarchitectural
logic,”
in Proceedings of the 2018 ACM SIGSAC Conference on Computer

timing leaks in rudimentary cpu interrupt

14

and Communications Security, ser. CCS ’18. New York, NY, USA:
Association for Computing Machinery, 2018, p. 178–195. [Online].
Available: https://doi.org/10.1145/3243734.3243822

in

in

20).

2020,

Security

and R.

Symposium

1767–1784.

[45] S. Weiser, D.

Schrammel, L. Bodner,

(EC)DSA implementations,”
(USENIX
pp.

Spreitzer,
- big troubles: Systematically analyzing nonce
“Big numbers
29th USENIX
leakage
Security
USENIX
Association, Aug.
[Online]. Available:
https://www.usenix.org/conference/usenixsecurity20/presentation/weiser
[46] S. Weiser, A. Zankl, R. Spreitzer, K. Miller, S. Mangard, and
trace analysis: Finding
G. Sigl, “DATA – differential address
27th USENIX
address-based
Security
Baltimore, MD:
USENIX Association, Aug. 2018, pp. 603–620. [Online]. Available:
https://www.usenix.org/conference/usenixsecurity18/presentation/weiser
and B. Sunar,
“Microwalk: A framework for finding side channels in binaries,”
in Proceedings of
the 34th Annual Computer Security Applications
Conference, ser. ACSAC ’18. New York, NY, USA: Association
for Computing Machinery, 2018, p. 161–173. [Online]. Available:
https://doi.org/10.1145/3274694.3274741

[47] J. Wichelmann, A. Moghimi, T. Eisenbarth,

Symposium (USENIX Security

Side-Channels

binaries,”

18).

in

in

[48] Y. Yarom, D. Genkin, and N. Heninger, “Cachebleed: a timing attack
on openssl constant-time rsa,” Journal of Cryptographic Engineering,
vol. 7, pp. 99–112, 2017.

[49] J.-K. Zinzindohoué, K. Bhargavan, J. Protzenko, and B. Beurdouche,
“Hacl*: A verified modern cryptographic library,” in Proceedings of
the 2017 ACM SIGSAC Conference on Computer and Communications
Security, ser. CCS ’17. New York, NY, USA: Association for
Computing Machinery, 2017, p. 1789–1806.
[Online]. Available:
https://doi.org/10.1145/3133956.3134043

APPENDIX
In this appendix, we list the initial disclosure statements
to the library developers in verbatim. We note that during
the disclosure process, the developers sometimes asked for
more tests on the patch, different versions, or on even more
implementations of theirs. We complied with all of these
requests and added these results to this paper. For instance, the
HACL* developers told us about their RSA implementation,
which we subsequently tested and added to this paper.

A. HACL* Disclosure

We ran a large-scale study of compiler-induced secret-
dependent operations on HACL* using dynamic analysis.
The study covers 6 processor architectures (x86-64, x86-i386,
armv7, aarch64, mips32, RISC-V),
two compilers (LLVM
and GCC), 17 compiler versions, and 7 optimization levels.
HACL* was one of the targets of our study.

Our dynamic analysis framework calls the API of HACL*
with different keys and fixes all other randomness. Then
we collected a set of
traces which we then compared.
Any difference in the traces is highlighted as a potential
secret-dependent operation. We did not find any issue in most
of our experiments of HACL*.

However, we found a code pattern in the secp256
implementation of HACL* that
is optimized by some
compilers. The resulting binary then contains secret-dependent
operations, potentially leading to a side-channel vulnerability.
We understand that you advise people to use formally
verified compilers such as CompCert. However, many people
implementations with off-the-shelf compilers.
use your
Therefore, it would be nice if this could be fixed.

We tested the older version of the secp256 implementation
(f283af1), and the following analysis and examples are taken

15

arch

armv7

mips32el

riscv64

x86-i686

toolchain

-O1

-O2

-O3

-Ofast

-Os

-Oz

✗
LLVM 14
✗
LLVM 15
✗
LLVM 13
✗
LLVM 14
✗
LLVM 15
LLVM 13 ✓
LLVM 14 ✓
✗
LLVM 15
✗
LLVM 14
✗
LLVM 15

✗
✗
✗
✗
✗
✓
✓
✗
✗
✗

✗
✗
✗
✗
✗
✓
✓
✗
✗
✗

✗
✗
✗
✗
✗
✓
✓
✗
✗
✗

✓
✓
✓
✓
✓
✓
✓
✓
✓
✓

✓
✓
✓
✓
✓
✓
✓
✓
✓
✓

TABLE III: cmovnz in HACL*

from there. We are currently rerunning our analysis for the
current master (3e283ef), and we have already found some
preliminary secret-dependent operations in the new version.
We believe it stems from the same reason as the original
code snippet and thus first discuss the old one here.

1) CMOV: The cmovznz4 function is

supposed to
the input condition cin. However,
be independent of
to
LLVM versions 13, 14, and 15 compile the snippet
secret-dependent branches (on RISC-V) and secret-dependent
memory operations on MIPS, x86-i386, and armv7. An exam-
ple of this can be seen here: https://godbolt.org/z/z71Wv5b7j.
A table showing the affected compiler versions, architectures,
and optimization levels can be seen in Table III.

2) Current Master: A similar code pattern to the one
shown above is also used in the function point_mul in
dist/gcc-compatible/Hacl_P256.c. Our analysis
also indicates that the code path is being executed with some
dependency on the secret key. However, this function is vastly
more complex and thus harder to pinpoint where the issue
comes from. We believe it stems from the same code pattern
as above, but we are not 100% confident.

A minimal

reproducible example can be found here:
https://godbolt.org/z/6s9daKhxr. The secret-dependent branch-
ing instruction that our analysis finds is jne .LBB0_28
in line 609. A table showing the affected compiler versions,
architectures, and optimization levels can be seen in Table IV.

B. BoringSSL Disclosure

We ran a large-scale study of compiler-induced secret-
dependent operations on multiple cryptographic libraries using
dynamic analysis. The study covers 6 processor architectures
(x86-64, x86-i386, armv7, aarch64, mips32, RISC-V), two
compilers (LLVM and GCC), a total of 17 compiler versions,
and 7 optimization levels. BoringSSL was one of the targets
of our study. We only investigate secret-dependent memory
accesses and secret-dependent control flow.

framework uses emulation to
Our dynamic analysis
execute binaries for different
target architectures. We call
some of the APIs exposed by BoringSSL in the binaries.
To find secret-dependent operations, our tool executes the
binaries with different secret keys but fixes all other sources
of randomness. We then collect a trace of the executed
binaries for each secret key. Any difference in the traces
is highlighted as a potential secret-dependent operation.

-O2

-O3

-Ofast

-Os

-Oz

Arch

Compiler

O0

O1

O2

O3

Ofast

Os

Oz

arch

aarch64

armv7

mips32el

riscv64

x86-64

x86-i686

-O1

toolchain
LLVM 13 ✓
LLVM 14 ✓
LLVM 15 ✓
LLVM 13 ✓
LLVM 14 ✓
LLVM 15 ✓
LLVM 13 ✓
LLVM 14 ✓
LLVM 15 ✓
LLVM 13 ✓
LLVM 14 ✓
LLVM 15 ✓
LLVM 13 ✓
LLVM 14 ✓
LLVM 15 ✓
LLVM 13 ✓
LLVM 14 ✓
LLVM 15 ✓

✗
✗
✗
✗
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✗
✓
✓

✗
✗
✗
✗
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✗
✓
✓

✗
✗
✗
✗
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✗
✓
✓

✗
✗
✗
✗
✓
✓
✓
✓
✓
✓
✓
✗
✓
✓
✗
✗
✓
✓

✗
✗
✗
✗
✓
✓
✓
✓
✓
✓
✓
✗
✓
✓
✗
✗
✓
✓

TABLE IV: cmovnz in HACL* (current master)

Such secret-dependent operations can lead to an exploitable
side-channel vulnerability. However, we do not know if the
secret-dependent operations that we detect are exploitable at
all. Nevertheless, you might be interested in them.

We used the branch chromium−stable or 28f96c26 for our

analysis.

that

seem compiler

1) bn_mul_comba8

In general, we did not find any issue that was present in all
architectures and all compilers. Such results would indicate
issues at the source-code level. However, we found several
induced
secret-dependent operations
as they only appear
for some combination of compiler,
architecture, and optimization levels. The resulting binary
then contains secret-dependent operations, potentially leading
to a side-channel vulnerability.
bn_sqr_comba8: Our
and
analysis found secret-dependent operations in the function
bn\_mul\_comba8 and bn\_sqr \_comba8 on MIPS (mips32el).
Both functions are executed during ECDH-P256 and ECDSA.
To reproduce it and to demonstrate the secret-dependent
operation, we created a small reproducible example using
bn\_mul\_comba8:
The
resulting binary on the right contains multiple branching
instructions that depend on the parameters of this function.
One such branch can be found on line 52. Based on the source
code, we assume the issue would also pop up in other 32-bit
architectures. However, we did not observe that with x86-i386
and armv7. A table showing the affected compiler versions,
architectures, and optimization levels can be seen in Table V.
2) bn_sqr_comba4: We found a similar issue when
compiling BoringSSL on RISC-V (riscv64) in the function
reproducible example can be
bn\_sqr \_comba4. A small
found in https://godbolt.org/z/EGdnWhzsz. Note the branching
instruction on line 18.

https://godbolt.org/z/1of34165o.

We observed this behavior with the combinations of com-
pilers, architectures, and optimization levels listed in Table VI.
3) fiat_p256_point_add: Our analysis flagged a
branch in fiat \_p256\_point \_add in 32bit architectures
(i.e., armv7, x86-i386, and mips32el). However, this function

16

mips32el

✓
GCC 5.4.0
✓
GCC 6.3.0
✓
GCC 7.3.0
✓
GCC 8.4.0
✓
GCC 9.3.0
GCC 10.3.0 ✓
GCC 11.3.0 ✓
✓
LLVM 11
✓
LLVM 13
✓
LLVM 14
✓
LLVM 15

✗
✗
✗
✗
✗
✗
✗
✗
✗
✗
✗

✓
✓
✓
✓
✓
✓
✓
✗
✗
✗
✗

✓
✓
✓
✓
✓
✓
✓
✗
✗
✗
✗

✓
✓
✓
✓
✓
✓
✓
✗
✗
✗
✗

✗
✗
✗
✗
✗
✗
✗
✗
✗
✗
✗

✗
✗
✗
✗
✗
✗
✗
✗
✗
✗
✗

TABLE V: bn_mul_comba8 and bn_sqr_comba8 in
BoringSSL

Arch

riscv64

Compiler
O0
GCC 10.3.0 ✓
GCC 11.3.0 ✓

O1

O2

O3

Ofast

Os

Oz

✗
✗

✓
✓

✓
✓

✓
✓

✗
✗

✗
✗

TABLE VI: bn_sqr_comba4 in BoringSSL

the problem.

It seems as if

is significantly more complex, which makes it hard to
pinpoint
the if condition
if ( is \ _nontrivial \_double) get compiled into two distinct
branching instructions instead of a single one, and which of
these is taken depends on the secret key.
function:
reproduction
“short”
https://godbolt.org/z/sTGKdbEcK. We
LLVM
inserts two distinct branches instead of one (line 116 and 120
respectively), and which of these two is taken leaks some
information on the input.

the
believe

Here

of

is

a

Table VII lists the combinations of compilers, architectures,
and optimization levels with which we observed this behavior.

C. Botan Disclosure

We ran a large-scale study of compiler-induced secret-
dependent operations on multiple cryptographic libraries using
dynamic analysis. The study covers 6 processor architectures
(x86-64, x86-i386, armv7, aarch64, mips32, RISC-V), two
compilers (LLVM and GCC), a total of 17 compiler versions,
and 7 optimization levels. Botan was one of the targets of our
study. We only investigate secret-dependent memory accesses
and secret-dependent control flow.

Our dynamic analysis framework uses emulation to execute
binaries for different target architectures. We call some of
the APIs exposed by Botan in the binaries. To find secret-
dependent operations, our tool executes the binaries with
different secret keys but fixes all other sources of randomness.

Arch

armv7

mips32el

x86-i386

Compiler

O0

O1

O2

O3

Ofast

Os

Oz

LLVM 14
LLVM 15
LLVM 14
LLVM 15
LLVM 14
LLVM 15

✗
✗
✗
✗
✗
✗

✓
✓
✓
✓
✓
✓

✓
✓
✓
✓
✓
✓

✓
✓
✓
✓
✓
✓

✓
✓
✓
✓
✓
✓

✓
✓
✓
✓
✓
✓

✓
✓
✓
✓
✓
✓

TABLE VII: fiat_p256_point_add in BoringSSL

Arch

Compiler

O0

O1

O2

O3

Ofast

Os

Oz

Arch

Compiler

O0

O1

O2

O3

Ofast

Os

Oz

riscv64

x86-i386

LLVM 14
LLVM 15
LLVM 14
LLVM 15

✗
✗
✗
✗

✓
✓
✓
✓

✓
✓
✓
✓

✓
✓
✓
✓

✓
✓
✓
✓

✓
✓
✓
✓

✓
✓
✓
✓

TABLE VIII: hex_decode in Botan

We then collect a trace of the executed binaries for each secret
key. Any difference in the traces is highlighted as a potential
secret-dependent operation. Such secret-dependent operations
can lead to an exploitable side-channel vulnerability. However,
we do not know if the secret-dependent operations that we
detect are exploitable at all. Nevertheless, you might be
interested in them.

We analyzed the release 2.19.3 (15dc32f).
In general, we did not find any issue that was present in all
architectures and all compilers. Such results would indicate
issues at the source-code level. However, we found several
induced
secret-dependent operations
as they only appear
for some combination of compiler,
architecture, and optimization levels. The resulting binary
then contains secret-dependent operations, potentially leading
to a side-channel vulnerability.

seem compiler

that

1) hex_decode: Our analysis found secret-dependent
operations in the function hex\_decode on recent LLVM
versions
function
targeting riscv64 and x86-i386. This
is flagged in various cryptographic algorithms: multiple
modes of AES, chachapoly1305, curve25519, and HMAC
with multiple hash functions. To reproduce it and to
demonstrate the secret-dependent operation, we created a
small reproducible example: https://godbolt.org/z/hhs1KWfz7.
The resulting binary on the right contains multiple branching
instructions that depend on the parameters of this function.
One such branch can be found on line 54.

2) Custom 128bit

Table VIII lists the combinations of compilers, architectures,
and optimization levels with which we observed this behavior.
type: Our analysis flaggs a custom
128bit
type and one of its operator as secret-dependent
in the implementation of poly1305 and curve25519. More
specifically, the donna128 and its += operator is by some
compilers optimized into secret-dependent operations. We
replicated the issue and created a minimal
reproducible
example: https://godbolt.org/z/P3n3vWsdT. Note that some
compilers only sometimes introduce the branch to skip the
carry addition. E.g., in x86-i386, we observed that the compiler
did not always produce the same inline binary for the addition
operator. For example, https://godbolt.org/z/xv9fznMfK is a
larger example using x86-i386 in the function fsquare where
the compiler inserts the branch in line 193.

Table IX lists the combinations of compilers, architectures,
and optimization levels with which we observed this behavior.
3) key_schadule in GHASH: Our analysis flagged
another
function
key\_schedule in GHASH. A reproducible example can
be found here: https://godbolt.org/z/xGh6Kjzfh. Essentially,

secret-dependent

operation

the

in

mips32el

x86-i386

GCC 6.4.0
GCC 7.3.0
GCC 8.4.0
GCC 9.3.0
GCC 10.3.0
GCC 11.3.0
GCC 7.3.0
GCC 8.4.0
GCC 9.3.0
GCC 10.3.0
GCC 11.3.0

✗
✗
✗
✗
✗
✗
✗
✗
✗
✗
✗

✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓

✓
✓
✓
✓
✓
✓
✓
✓
✗
✗
✗

✓
✓
✓
✓
✓
✓
✓
✓
✗
✗
✓

✓
✓
✓
✓
✓
✓
✓
✓
✗
✗
✓

✓
✓
✓
✓
✓
✓
✓
✗
✗
✗
✗

✗
✗
✗
✗
✗
✗
✗
✗
✗
✗
✗

TABLE IX: Custom 128-bit type in Botan

the compiler understands that the carry variable can only be
1 or 0 and thus checks its value before it performs the XOR.
We found this behavior with LLVM 15 for riscv64 with

−O1, −O2, −O3, and −Ofast.

D. BearSSL Disclosure

We ran a large-scale study of compiler-induced secret-
dependent operations on multiple cryptographic libraries using
dynamic analysis. The study covers 6 processor architectures
(x86-64, x86-i386, armv7, aarch64, mips32, RISC-V), two
compilers (LLVM and GCC), a total of 17 compiler versions,
and 7 optimization levels. BearSSL was one of the targets
of our study. We only investigate secret-dependent memory
accesses and secret-dependent control flow.

framework uses emulation to
Our dynamic analysis
execute binaries for different
target architectures. We call
some of the APIs exposed by BearSSL in the binaries.
To find secret-dependent operations, our tool executes the
binaries with different secret keys but fixes all other sources
of randomness. We then collect a trace of the executed
binaries for each secret key. Any difference in the traces
is highlighted as a potential secret-dependent operation.
Such secret-dependent operations can lead to an exploitable
side-channel vulnerability. However, we do not know if the
secret-dependent operations that we detect are exploitable at
all. Nevertheless, you might be interested in them.

We used the branch master on 79c060ee for our analysis.
In general, we found one issue that was present in all
architectures and all compilers. This indicates that the issue
is at the source-code level. In addition, we found several
induced
secret-dependent operations
as they only appear
for some combination of compiler,
architecture, and optimization level. The resulting binary then
contains secret-dependent operations, potentially leading to a
side-channel vulnerability.

seem compiler

that

1) br_skey_decoder_run: We load the secret keys
from a file using br_skey_decoder_run, which seems
to contain operations that depend on the content of the file.
We made sure that our inputs were all the same type of key
(i.e., RSA) with different content. We found these issues in
every binary, so we assume they are rooted in source-code
and not introduced by compiler optimizations. We also did

17

Arch

Compiler

O0

O1

O2

O3

Ofast

Os

Oz

aarch64

armv7
x86-64

x86-i386

LLVM 13
LLVM 14
LLVM 14
LLVM 13
LLVM 13
LLVM 14
LLVM 15
LLVM 13
LLVM 14
LLVM 15

✗
✗
✗
✗
✗
✗
✗
✗
✗
✗

✗
✗
✓
✗
✓
✓
✓
✓
✓
✓

✓
✓
✗
✓
✓
✓
✓
✓
✓
✓

✗
✗
✗
✓
✓
✓
✓
✓
✓
✓

✗
✗
✗
✓
✓
✓
✓
✓
✓
✓

✗
✓
✓
✗
✓
✓
✓
✓
✓
✓

✗
✓
✓
✗
✓
✓
✓
✓
✓
✓

TABLE X: modpow_opt in BearSSL

Arch

Compiler

O0

O1

O2

O3

Ofast

Os

Oz

x86-i386

riscv64

LLVM 13
LLVM 14
LLVM 15
LLVM 13
LLVM 14
LLVM 15

✗
✗
✗
✗
✗
✗

✓
✓
✓
✓
✓
✓

✓
✓
✓
✓
✓
✓

✓
✓
✓
✓
✓
✓

✓
✓
✓
✓
✓
✓

✗
✗
✗
✗
✗
✗

✗
✓
✗
✗
✓
✗

TABLE XI: br_i31_muladd_small in BearSSL

not further evaluate where these issues come from, but you
might be interested in them either way.

2) modpow_opt: The function modpow_opt in both
i31 and i62 were flagged to contain compiler-induced issues
on some architectures and compilers. We created small snip-
pets that demonstrate the issue for i31 and i62 respectively:

• i31: https://godbolt.org/z/bnE1PrfKG
• i62: https://godbolt.org/z/nx1crrxv3
Essentially, the compiler understands the bitmasks computa-
tion that is performed using EQ and then optimizes/simplifies
the constant-time assignment. In i31 the compiler uses a
branch to jump over the assignment and in i62 the compiler
computes the address that is then used for the assignment (the
address is then leaked in the actual memory access, i.e., line
10 and 11 in the assembly output of the Godbolt link above).
Table X lists the combinations of compilers, architectures,
and optimization levels with which we observed this behavior.
3) br_i31_muladd_small: The compiler once again
seems to understand the bitwise arithmetic operations of MUX,
EQ, and GT and produces secret-dependent operations in the
function br \_i31\_muladd\_small. A small reproducible code
snippet can be found here: https://godbolt.org/z/qM9KT31vz.
Table XI lists the combinations of compilers, architectures,
and optimization levels with which we observed this behavior.
found a misguided
compiler optimization in the function check\ _scalar
in
the p256 elliptic curve implementation (both for i62 and
i64). A small reproducible example can be found here:
https://godbolt.org/z/zvh6Pjzar.

4) P256 check_scalar: We

Table XII lists the combinations of compilers, architectures,
and optimization levels with which we observed this behavior.

18

Arch

Compiler

O0

O1

O2

O3

Ofast

Os

Oz

x86-i386

riscv64

LLVM 12
LLVM 13
LLVM 14
LLVM 15
LLVM 12
LLVM 13
LLVM 14
LLVM 15

✗
✗
✗
✗
✗
✗
✗
✗

✗
✓
✓
✓
✗
✓
✓
✓

✗
✓
✓
✓
✓
✓
✓
✓

✗
✓
✓
✓
✓
✓
✓
✓

✗
✓
✓
✓
✓
✓
✓
✓

✓
✓
✓
✓
✗
✗
✗
✗

✓
✓
✓
✓
✗
✗
✓
✗

TABLE XII: check_scalar in BearSSL



=== Content from news.ycombinator.com_369f566b_20250110_123745.html ===


| |  | **[Hacker News](news)** [new](newest) | [past](front) | [comments](newcomments) | <ask> | <show> | <jobs> | <submit> | [login](login?goto=item%3Fid%3D41887153) | | --- | --- | --- | |
| --- | --- | --- | --- |
|
| |  |  | [Breaking Bad: How Compilers Break Constant-Time~Implementations](https://arxiv.org/abs/2410.13489) ([arxiv.org](from?site=arxiv.org)) | | --- | --- | --- | |  | | 66 points by [belter](user?id=belter) [79 days ago](item?id=41887153)  | [hide](hide?id=41887153&goto=item%3Fid%3D41887153) | [past](https://hn.algolia.com/?query=Breaking%20Bad%3A%20How%20Compilers%20Break%20Constant-Time~Implementations&type=story&dateRange=all&sort=byDate&storyText=false&prefix&page=0) | [favorite](fave?id=41887153&auth=64ba479fbf9d9ec8e2c775bd0b5fb5799eb87839) | [60 comments](item?id=41887153) |  | |  |  | [kibwen](user?id=kibwen) [78 days ago](item?id=41924961)   | [next](#41925936) [–]  *> Our work highlights that current defensive programming techniques are more akin to anecdotal workarounds to compilers’ behavior rather than a systematic solution. Our results point out that high-level constant-time code is prone to dangerous transformations and optimizations from compilers and calls for cooperation between developers of security-critical libraries and general-purpose compilers.* All optimizing compilers perform optimizations based on the notion of an abstract machine, which determines what semantics of the original program must be conserved. And the abstract machine for a given language is usually provided by the language that is being implemented (except for e.g. languages that just give up and say "give me C's abstract machine"). You definitely *don't* want compiler backends trying to "guess" when some defensive programming technique is being used, so that they can compile it conservatively. That's a dead-end pathway to madness. You need languages to give you the power to explicitly say "this operation is constant time, don't mess with it". And in practice they do give you this power, via inline assembly. Of course inline assembly is suboptimal for a lot of reasons, and we can certainly try to do better, but this is a language design problem, not an optimizing compiler problem. | | --- | --- | --- | | | --- | --- | --- | --- | | |  |  | [the8472](user?id=the8472) [78 days ago](item?id=41925258)   | [parent](#41924961) | [next](#41926160) [–]  Not just the abstract machines. CPUs don't guarantee constant-time execution for most instructions. And if you target wasm or some other intermediate compilation target then the first compiler can't do much about the 2nd compiler applying additional optimizations. And then there are post-link optimizations where any hypothetical "please don't optimize this" annotations would be gone. | | --- | --- | --- | | | |  |  | [pclmulqdq](user?id=pclmulqdq) [78 days ago](item?id=41925770)   | [root](#41924961) | [parent](#41925258) | [next](#41926160) [–]  In a theoretical sense only, that is true on x86 when a flag (that is always set) is not set. The vast majority of useful instructions are constant-time (in the value of the data). | | --- | --- | --- | | | |  |  | [nullc](user?id=nullc) [78 days ago](item?id=41925999)   | [root](#41924961) | [parent](#41925770) | [next](#41926160) [–]  Indeed, but the manufacturer doesn't promise anything-- for all you know the next processor generation or even microcode revision could change that. It would be nice for processor makers to explicitly specify that the common arithmetic instructions will take time which is constant in terms of their argument data. | | --- | --- | --- | | | |  |  | [pclmulqdq](user?id=pclmulqdq) [78 days ago](item?id=41926877)   | [root](#41924961) | [parent](#41925999) | [next](#41926891) [–]  They are explicitly specified by all major CPU vendors. [https://www.intel.com/content/www/us/en/developer/articles/t...](https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/best-practices/data-operand-independent-timing-isa-guidance.html) | | --- | --- | --- | | | |  |  | [nullc](user?id=nullc) [78 days ago](item?id=41931265)   | [root](#41924961) | [parent](#41926877) | [next](#41926891) [–]  TIL -- wasn't the case a number of years ago. | | --- | --- | --- | | | |  |  | [adrian\_b](user?id=adrian_b) [78 days ago](item?id=41926891)   | [root](#41924961) | [parent](#41925999) | [prev](#41926877) | [next](#41926160) [–]  Nowadays the manufacturer must promise that at least a well-defined subset of the instructions have an execution time independent of the operands. See the comment above by "cokernel\_hacker", which provides links to the Intel and Arm documentation of this feature. | | --- | --- | --- | | | |  |  | [pjc50](user?id=pjc50) [78 days ago](item?id=41926160)   | [parent](#41924961) | [prev](#41925258) | [next](#41925885) [–]  C has enough security questions hanging around it; for things like constant time operation, which has AFAIK never been promised anywhere in the C standards (and probably can't be!), I think the only reasonable solution is a new language specifically designed for the purpose. Not for writing whole programs in, but for writing fairly small amounts of code that performs arithmetic and compiles to libraries with C linkage. No VM, not even any memory allocation (make the caller do that in advance with fixed-size areas). Basically the "portable assembler" that people keep using C for despite its explicit promises in the standard to *not* be that. | | --- | --- | --- | | | |  |  | [variadix](user?id=variadix) [78 days ago](item?id=41927732)   | [root](#41924961) | [parent](#41926160) | [next](#41926289) [–]  At least for C and C++, why don’t GCC/clang implement constant time primitives as intrinsics? It would be useful in the meantime to developers working on cryptographic code, would provide better guarantees, and could emit useful errors when compiling against platforms where such guarantees cannot be provided. It would also act as prior art for standardization. I’ve always thought it was strange that assembly wasn’t used for some of these primitives, since you don’t control the codegen, but letting the compiler provide intrinsics would solve the problem without requiring every project to write their own assembly routines. | | --- | --- | --- | | | |  |  | [PaulDavisThe1st](user?id=PaulDavisThe1st) [78 days ago](item?id=41926289)   | [root](#41924961) | [parent](#41926160) | [prev](#41927732) | [next](#41925885) [–]  > the only reasonable solution is a new language specifically designed for the purpose. actual assembler is just such a language, as is being discussed here. | | --- | --- | --- | | | |  |  | [pjc50](user?id=pjc50) [78 days ago](item?id=41926308)   | [root](#41924961) | [parent](#41926289) | [next](#41925885) [–]  Sure - but that's not a portable language at all! Nor is it an especially good target for any kind of formal verification or even type-checking. | | --- | --- | --- | | | |  |  | [fuhsnn](user?id=fuhsnn) [78 days ago](item?id=41927029)   | [root](#41924961) | [parent](#41926308) | [next](#41926511) [–]  Constant-time programming itself isn't quite portable, RISC-V for example requires the Zkt extension to mandate it. | | --- | --- | --- | | | |  |  | [PaulDavisThe1st](user?id=PaulDavisThe1st) [78 days ago](item?id=41926511)   | [root](#41924961) | [parent](#41926308) | [prev](#41927029) | [next](#41926324) [–]  Given that to meet constant-time requirements, the language will need to guarantee more or less 1-for-1 (or more generally, M-for-N) translation to assembler, I don't think you're going to improve on the verification or type checking situation by changing the syntax to something else. | | --- | --- | --- | | | |  |  | [saagarjha](user?id=saagarjha) [78 days ago](item?id=41926324)   | [root](#41924961) | [parent](#41926308) | [prev](#41926511) | [next](#41925885) [–]  Neither is C, to be fair. | | --- | --- | --- | | | |  |  | [amluto](user?id=amluto) [78 days ago](item?id=41925885)   | [parent](#41924961) | [prev](#41926160) | [next](#41925969) [–]  I think a good solution involves more than operations. Consider: ```     int a = read_a_value();     a = constant_time_add(a+1);     do_something_with(a);  ``` In many languages, the compiler is free to insert entirely new operations between these statements so long as the output isn’t affected. Or the compiler could reuse a register that contained a to do something else and do something awful like zeroing that register in non-constant time. I think that new *types* are a better solution. A type could be specified such that the compiler must not use its value in a non-constant time operation, nor may the compiler leak it into an initialized value. | | --- | --- | --- | | | |  |  | [pjmlp](user?id=pjmlp) [78 days ago](item?id=41925969)   | [parent](#41924961) | [prev](#41925885) | [next](#41925292) [–]  The problem is the programming language culture, in some circles, if guessing is going too far, the compiler writers will rather opt for safety, while other language communities will stop at nothing for the ultimate performance, nitromethan powered optimising compiler. | | --- | --- | --- | | | |  |  | [GTP](user?id=GTP) [78 days ago](item?id=41925292)   | [parent](#41924961) | [prev](#41925969) | [next](#41925527) [–]  A thing that I've been wondering is, would it be enough in this specific case to turn off compiler optimizations, e.g. by using GCC's -O0 flag? | | --- | --- | --- | | | |  |  | [recursivecaveat](user?id=recursivecaveat) [78 days ago](item?id=41925682)   | [root](#41924961) | [parent](#41925292) | [next](#41925668) [–]  In this specific case, in practice, maybe. At end the of the day though it is like trying to write a metred poem in a foreign language by writing English and passing it through google translate. You're trying to precisely control properties of the output with a tool that was not designed for it, doesn't realize what you're doing, and has at every step many possible alternatives. Any success you have is tied to a specific version of the tool, there are no guarantees. | | --- | --- | --- | | | |  |  | [SAI\_Peregrinus](user?id=SAI_Peregrinus) [78 days ago](item?id=41925668)   | [root](#41924961) | [parent](#41925292) | [prev](#41925682) | [next](#41926314) [–]  In general, no. Optimizations from a compiler can't do anything regular code gen isn't allowed to do. It's just they're more likely to do some things. So in practice disabling optimization (especially using pragmas or attributes for certain critical functions) can help, but it can't be considered truly reliable. | | --- | --- | --- | | | |  |  | [fanf2](user?id=fanf2) [78 days ago](item?id=41926314)   | [root](#41924961) | [parent](#41925292) | [prev](#41925668) | [next](#41925574) [–]  The paper says, « We found binaries with issues in all optimization levels as depicted in Figure 3. We observe notable drops for LLVM's and GCC's -O0. We believe that fewer enabled optimizations also lead to fewer compiler-induced issues. We discuss in Section VII that optimizations are one of the reasons compilers introduce side channels; thus fewer optimizations could mean defensive programming techniques are less likely to get inter-fered with. However, we note that this cannot be considered a solution to compiler-induces issues as we still observe some issues with -O0. We discuss these further in Section VI-D. » | | --- | --- | --- | | | |  |  | [photochemsyn](user?id=photochemsyn) [78 days ago](item?id=41925574)   | [root](#41924961) | [parent](#41925292) | [prev](#41926314) | [next](#41928259) [–]  Libsodium does this compiler-specific pragmas and attributes (like \_\_attribute\_\_((optimize("O0")))). It's also the cryptographic library mentioned in this study with the smallest number of discovered issues, but: > "However, we want to note that libsodium is the smallest library that we test with the most limited support for cryptographic primitives. For example, libsodium does not support the elliptic curve secp256; instead,they do all of their elliptic curve operations on curve25519. Therefore, it may be unfair to compare to larger libraries with support for more cryptographic primitives." | | --- | --- | --- | | | |  |  | [badmintonbaseba](user?id=badmintonbaseba) [78 days ago](item?id=41926398)   | [root](#41924961) | [parent](#41925574) | [next](#41926440) [–]  "The optimize attribute should be used for debugging purposes only. It is not suitable in production code." [https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Common-Functio...](https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Common-Function-Attributes.html) | | --- | --- | --- | | | |  |  | [jedisct1](user?id=jedisct1) [78 days ago](item?id=41926440)   | [root](#41924961) | [parent](#41925574) | [prev](#41926398) | [next](#41925676) [–]  > Libsodium does this compiler-specific pragmas and attributes (like \_\_attribute\_\_((optimize("O0")))) It doesn't do anything like that. | | --- | --- | --- | | | |  |  | [GTP](user?id=GTP) [78 days ago](item?id=41925676)   | [root](#41924961) | [parent](#41925574) | [prev](#41926440) | [next](#41928259) [–]  Thanks, the fact that they still found issues answers my question. | | --- | --- | --- | | | |  |  | [cryptonector](user?id=cryptonector) [78 days ago](item?id=41928259)   | [root](#41924961) | [parent](#41925292) | [prev](#41925574) | [next](#41925527) [–]  Unreliable. But in combination with tests of constant-time-ness then it's ok in the short-term. In the long-term it'd be nice if the language and tooling could be told "this is to be constant-time", and even better to have a language specially crafted for these sorts of things, something between assembly and C. | | --- | --- | --- | | | |  |  | [secondcoming](user?id=secondcoming) [78 days ago](item?id=41925527)   | [parent](#41924961) | [prev](#41925292) | [next](#41925936) [–]  memset isn’t part of any abstract machine, yet compilers feel free to optimise that out, so we needed to add new functions that compilers wouldn’t touch. | | --- | --- | --- | | | |  |  | [gavinsyancey](user?id=gavinsyancey) [78 days ago](item?id=41925726)   | [root](#41924961) | [parent](#41925527) | [next](#41925936) [–]  The C language specification describes what memset does. If a program calls memset, compilers must make it behave *as if* an actual call to the memset function (as described in the standard) was made, for all observable effects that matter to the abstract machine. | | --- | --- | --- | | | |  |  | [pjc50](user?id=pjc50) [78 days ago](item?id=41926263)   | [root](#41924961) | [parent](#41925726) | [next](#41925936) [–]  .. unless the compiler spots UB anywhere near the function call, in which case all bets are off. | | --- | --- | --- | | | |  |  | [p4bl0](user?id=p4bl0) [78 days ago](item?id=41925936)   | [prev](#41924961) | [next](#41924918) [–]  The subject of my PhD thesis was formal approach to cryptographic implementation against side-channel attacks [1]. In the lab I worked at, most people wrote assembly code for precisely the reasons discussed here [2], and a part of my work consisted in applying a form of formal verification directly on assembly code rather than a more abstract version of the cryptographic algorithms. You cannot trust compilers which are designed with efficiency in mind when your main objective is security. Keeping the same semantics and going as fast as possible often break security measures. And that's not just for constant-time implementations, sometimes it's a lot more simpler than that. Some security scheme against power consumption side-channel attacks, such as dual-rail with precharge logic, require that registers are zeroed before being written to. A compiler seeing code such as: ```     x = 0                /* first write, zeroing */     x = sensitive_data   /* second write, actual value */  ``` will of course consider that the first write is never read and optimize it away, thus breaking the security scheme… Then, there's also the need to make sure that the register your using is always the same (because leakage profile may differ a lot between the different registers of a single device). All the more reasons to write critical cryptographic code in directly in assembly. [1] <https://pablo.rauzy.name/research.html#phd> [2] A ~fun anecdote: I'm a computer scientist, but most people at that lab were in electronics, and for them assembly code was considered *high level* because it was already software! | | --- | --- | --- | | | |  |  | [manoweb](user?id=manoweb) [78 days ago](item?id=41926355)   | [parent](#41925936) | [next](#41926185) [–]  Hello, isn’t part of what you were trying to achieve already taken care of if you use ‘volatile’ or a memory barrier? When writing Linux drivers these patterns are common. In some more exotic cases, even instruction barriers can be used to limit what the out of order or speculative execution is going to be | | --- | --- | --- | | | |  |  | [smaddox](user?id=smaddox) [78 days ago](item?id=41926609)   | [root](#41925936) | [parent](#41926355) | [next](#41927709) [–]  Not the OP, and not at all an expert in this area, but I was curious what the answer was, and from a bit of reading it seems like a potential reason that might not work is because volatile also prevents caching the value in a register. So if you want to keep the computation in a register, but you want to explicitly clear the value to zero before writing to it, it seems like C semantics are insufficient (at least without inline assembly). | | --- | --- | --- | | | |  |  | [manoweb](user?id=manoweb) [75 days ago](item?id=41960029)   | [root](#41925936) | [parent](#41926609) | [next](#41927709) [–]  Excuse me but what would be the use of zeroing a register before overwriting it? | | --- | --- | --- | | | |  |  | [p4bl0](user?id=p4bl0) [78 days ago](item?id=41927709)   | [root](#41925936) | [parent](#41926355) | [prev](#41926609) | [next](#41926185) [–]  Possibly (I don't know how volatile interact with registers allocation), but the thing is you don't just want this specific example to work, there are a lot of things you want to be able to *really ensure*, i.e., have rigorous proof of [1]. So maybe if the semantics is adequate and the compiler itself is formally proved like CompCert [2] you can rely on volatile, but that's a lot a assumptions. [1] See for example the work we did in this paper: *Formally Proved Security of Assembly Code Against Power Analysis: A Case Study on Balanced Logic* <https://eprint.iacr.org/2013/554> [2] <https://compcert.org/> | | --- | --- | --- | | | |  |  | [Plasmoid](user?id=Plasmoid) [78 days ago](item?id=41926185)   | [parent](#41925936) | [prev](#41926355) | [next](#41926081) [–]  How do you handle the the CPU doing out-of-order execution and other tricks to reduce actual run-time? | | --- | --- | --- | | | |  |  | [cokernel\_hacker](user?id=cokernel_hacker) [78 days ago](item?id=41926249)   | [root](#41925936) | [parent](#41926185) | [next](#41926221) [–]  ARM has DIT: [https://developer.arm.com/documentation/ddi0595/2021-06/AArc...](https://developer.arm.com/documentation/ddi0595/2021-06/AArch64-Registers/DIT--Data-Independent-Timing) Intel has DOIT: [https://www.intel.com/content/www/us/en/developer/articles/t...](https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/best-practices/data-operand-independent-timing-isa-guidance.html) The idea is that the processor will not take shortcuts that take advantage of the values it is processing. For example, a 64-bit division cannot shortcut if the operands are both small, etc. | | --- | --- | --- | | | |  |  | [namibj](user?id=namibj) [78 days ago](item?id=41927094)   | [root](#41925936) | [parent](#41926249) | [next](#41926221) [–]  Intel DOIT instruction list does not include DIV: [https://www.intel.com/content/www/us/en/developer/articles/t...](https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/resources/data-operand-independent-timing-instructions.html) | | --- | --- | --- | | | |  |  | [p4bl0](user?id=p4bl0) [78 days ago](item?id=41926221)   | [root](#41925936) | [parent](#41926185) | [prev](#41926249) | [next](#41926210) [–]  I actually don't know, we weren't working on modern CPUs but on smaller devices that were used for sensitive embedded systems. | | --- | --- | --- | | | |  |  | [pjc50](user?id=pjc50) [78 days ago](item?id=41926210)   | [root](#41925936) | [parent](#41926185) | [prev](#41926221) | [next](#41926081) [–]  OOE does not depend on the value of the operands, only on register allocation. | | --- | --- | --- | | | |  |  | [badmintonbaseba](user?id=badmintonbaseba) [78 days ago](item?id=41926081)   | [parent](#41925936) | [prev](#41926185) | [next](#41924918) [–]  I get that assembly gets you closer, but does it actually give you the *guarantees* that you need? Do you have detailed documentation of what instructions and patterns you can use to avoid timing and other side channels that applies to many CPUs that implement an instruction set? | | --- | --- | --- | | | |  |  | [pjc50](user?id=pjc50) [78 days ago](item?id=41926197)   | [root](#41925936) | [parent](#41926081) | [next](#41926161) [–]  In practice you have to go by the timings given in the datasheet, which may be tedious to find. Consumer grade CPUs aren't usually protected against other side channels. | | --- | --- | --- | | | |  |  | [p4bl0](user?id=p4bl0) [78 days ago](item?id=41926161)   | [root](#41925936) | [parent](#41926081) | [prev](#41926197) | [next](#41924918) [–]  That depends a lot on the hardware. For some embedded systems, such as 8-bit smartcards, you can get pretty detailed datasheets from the manufacturer, and the architecture is a lot simpler than modern CPUs. | | --- | --- | --- | | | |  |  | [moomin](user?id=moomin) [78 days ago](item?id=41924918)   | [prev](#41925936) | [next](#41926406) [–]  I saw a rant on here about this not so long ago: it feels ridiculous that nearly all of our security code is compiled using compilers that cannot provide the guarantees these algorithms need. | | --- | --- | --- | | | |  |  | [klooney](user?id=klooney) [78 days ago](item?id=41924991)   | [parent](#41924918) | [next](#41924962) [–]  A lot of it is in ASM, for just that reason. | | --- | --- | --- | | | |  |  | [saghm](user?id=saghm) [78 days ago](item?id=41925753)   | [root](#41924918) | [parent](#41924991) | [next](#41924962) [–]  Sure, but needing to write security code in assembly is ridiculous for other reasons | | --- | --- | --- | | | |  |  | [empath75](user?id=empath75) [78 days ago](item?id=41924962)   | [parent](#41924918) | [prev](#41924991) | [next](#41926406) [–]  Seems like a hard problem to solve, because even if you mark some block of code as DO\_NOT\_OPTIMIZE it still is likely to pull in code from elsewhere that probably has been optimized. Seems like you might have to actually just write the relevant code in inlined machine code. | | --- | --- | --- | | | |  |  | [jonhohle](user?id=jonhohle) [78 days ago](item?id=41925165)   | [root](#41924918) | [parent](#41924962) | [next](#41925119) [–]  It’s not only that, but also the semantics of the language. Is, for example, integer comparison guaranteed to be constant time? What about integer comparison with constants that require multiple load instructions (like on MIPS where all instructions are word sized so loading words requires two instructions). Is it “wrong” to do two comparisons against the high half and the low half independently, each branching on failure, if the language provides no guarantees and the outcome is the same? Ultimately security focused languages that provide operational guarantees with C linkage are probably necessary. I don’t think it’s enough to not optimize C. | | --- | --- | --- | | | |  |  | [immibis](user?id=immibis) [78 days ago](item?id=41925119)   | [root](#41924918) | [parent](#41924962) | [prev](#41925165) | [next](#41926406) [–]  Inlined micro instructions, at that, with a special flag to prevent the CPU skipping over zero runs in multipliers. | | --- | --- | --- | | | |  |  | [crest](user?id=crest) [78 days ago](item?id=41925412)   | [root](#41924918) | [parent](#41925119) | [next](#41926406) [–]  I can't wait for some uarch to fuck everyone over and decide that after tracking zeroing idioms in the the renamer the next escalation is to eliminate data dependencies if the renamer detects it's not outcome determinative e.g. AND r1, r2, r3 with the renamer having inferred that one of the inputs is zero so the other isn't needed and the result must be zero. Or tracking identity elements for operations (0 for addition/substraction, 1 for multiplication/division) to bypass the computation. | | --- | --- | --- | | | |  |  | [pjc50](user?id=pjc50) [78 days ago](item?id=41926256)   | [root](#41924918) | [parent](#41925412) | [next](#41926143) [–]  SIMD instructions are a good way to avoid this, even if you only use one column of the operands the fact that it's SIMD means operations have to happen in lockstep across the execution units. | | --- | --- | --- | | | |  |  | [gpderetta](user?id=gpderetta) [78 days ago](item?id=41927375)   | [root](#41924918) | [parent](#41926256) | [next](#41926143) [–]  Do they? An arch with bultin lane predication (like AVX512) could easily implement wide SIMD on top of narrower ALU and then skip the masked out lanes. Actual runtime would depend on the number of non masked lanes. I'm not up to date on GPU architectures, bit I wouldn't be surprised of they do this sort of stuff. | | --- | --- | --- | | | |  |  | [eigenform](user?id=eigenform) [78 days ago](item?id=41926143)   | [root](#41924918) | [parent](#41925412) | [prev](#41926256) | [next](#41925549) [–]  You [as a designer] could probably add latency synthetically and still benefit from avoiding a physical register allocation (although I guess, that's only a workaround for leaking in the time domain). edit: Anyway, if your threat model includes "attacker can discern differences in power at uop-granularity and make meaningful correlations", you are probably doomed at the outset and you should not have used an out-of-order machine in the first place. | | --- | --- | --- | | | |  |  | [marcosdumay](user?id=marcosdumay) [78 days ago](item?id=41925549)   | [root](#41924918) | [parent](#41925412) | [prev](#41926143) | [next](#41926406) [–]  Well, multiplication used to take variable time not long ago. Anyway, IMO, CPU designers seem more aware of security implications than compiler developers. I expect more attention to those things in the future, not less. | | --- | --- | --- | | | |  |  | [jedisct1](user?id=jedisct1) [78 days ago](item?id=41926406)   | [prev](#41924918) | [next](#41926043) [–]  Jasmin is an amazing tool to write code that's proven to be free of side channels, memory safe, and protected against common speculative execution attacks: <https://github.com/jasmin-lang/jasmin> I wrote AEGIS implementations in it: <https://github.com/jedisct1/aegis-jasmin> and it was a really great experience. | | --- | --- | --- | | | |  |  | [jkaptur](user?id=jkaptur) [78 days ago](item?id=41926043)   | [prev](#41926406) | [next](#41926198) [–]  If you offer a programmer a deal where you make their code x% faster on average, never slower, and the actual speedup depends on a huge number of factors making it really hard to reason about, they'll take it 99.99% 0f the time. It seems to me that the *entire* stack is built on this assumption, making life incredibly difficult the other 0.01% of the time. | | --- | --- | --- | | | |  |  | [high\_na\_euv](user?id=high_na_euv) [78 days ago](item?id=41926128)   | [parent](#41926043) | [next](#41926198) [–]  No. Nobody asks such a question and not all would answer it the same. Id rather take 5% perf. regression to my cpp code if it meant that compile time halves and errors quality will be better | | --- | --- | --- | | | |  |  | [badmintonbaseba](user?id=badmintonbaseba) [78 days ago](item?id=41926198)   | [prev](#41926043) | [next](#41929002) [–]  Maybe this is overly naive, but I always wondered whether timing side channels could be mitigated by scheduling authentication responses before doing the crypto calculations. 1. authentication request arrives 2. schedule response at a later time, generously leaving time for doing the next step 3. do part of the work that is sensitive to timing attacks 4. respond at scheduled time | | --- | --- | --- | | | |  |  | [avidiax](user?id=avidiax) [78 days ago](item?id=41926238)   | [parent](#41926198) | [next](#41929002) [–]  That applies over a network. It doesn't apply to someone that has physical access to the machine. Even if the machine delays a response, the power profile of the computation will tell the exact timing of the computation. Since there is lots of cryptography used to keep users out of their own hardware (or stolen hardware) these days, this is important. | | --- | --- | --- | | | |  |  | [Validark](user?id=Validark) [78 days ago](item?id=41929002)   | [prev](#41926198) | [next](#41930030) [–]  Good for the authors for putting the idea out there I guess, but to me it seems pretty obvious that people who never look at their assembly would have no idea whether it matches their expectations. And it's not hard. Godbolt.org is free for everyone. Checking if the code branches is super easy, you don't need a super smart runtime analysis tool to figure out if there's a branch. Ditto for everything else you want to check. | | --- | --- | --- | | | |  |  | [LorenPechtel](user?id=LorenPechtel) [78 days ago](item?id=41930030)   | [prev](#41929002) | [next](#41933862) [–]  I think the only real option is for the compilers to add a couple of limitations: 1) Allow any block of code to be defined as constant-time. The compiler is forbidden any optimizations that could break this. Constant-time routines can only call other routines that are likewise declared as constant-time. 2) Allow any operation to be defined as important. The compiler can't remove it as redundant. | | --- | --- | --- | | | |  |  | [mrngm](user?id=mrngm) [78 days ago](item?id=41933862)   | [prev](#41930030) [–]  A recent thread on compiler optimizations and cryptography (blog post by djb): <https://news.ycombinator.com/item?id=41146860> | | --- | --- | --- | | |
| |  | | --- |   [Guidelines](newsguidelines.html) | [FAQ](newsfaq.html) | [Lists](lists) | [API](https://github.com/HackerNews/API) | [Security](security.html) | [Legal](https://www.ycombinator.com/legal/) | [Apply to YC](https://www.ycombinator.com/apply/) | Contact Search: |


