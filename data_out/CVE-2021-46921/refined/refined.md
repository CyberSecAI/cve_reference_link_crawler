The provided content relates to CVE-2021-46921.

**Root cause of vulnerability:**
The vulnerability arises from a race condition in the `queued_write_lock_slowpath` function within the Linux kernel's `qrwlock` implementation. A writer attempts to acquire the lock, and although it's executed with the `wait_lock` held, readers can acquire the lock without holding `wait_lock`. The writer checks the lock's value using `atomic_cond_read_acquire()`, but the actual lock acquisition happens through a compare-and-exchange (`cmpxchg`). This creates a window where a reader might observe a value change before the write lock is fully acquired, leading to an A-B-A problem.

**Weaknesses/vulnerabilities present:**
- **Race condition:** A race condition exists between the writer's lock acquisition and a reader's access to shared data, which can lead to incorrect data visibility.
- **Out-of-order execution:** The read of the `ovflist` can be ordered ahead of the `atomic_cmpxchg_relaxed()`, causing the reader to see a change before the write lock is acquired.
- **ABA problem:** The vulnerability is specifically described as being an A-B-A problem. The reader can observe a state, see it change and revert and not realize a change occurred, leading to the race.

**Impact of exploitation:**
- **Data corruption:**  Readers may observe inconsistent data, potentially leading to data corruption or unexpected behavior. The example given with `epoll`, illustrates that the reader can see a value change out from under it.

**Attack vectors:**
- **Concurrent access to shared data:** Exploitation requires a concurrent reader and writer accessing the same data protected by a `qrwlock`.

**Required attacker capabilities/position:**
- **Ability to trigger concurrent read and write access:** The attacker must be able to trigger a scenario where a reader and a writer are accessing shared data protected by `qrwlock` concurrently.

**Additional details:**
- The fix involves switching the compare-and-exchange to use acquire semantics (`atomic_try_cmpxchg_acquire`) to ensure proper ordering, and the `atomic_cond_read` is changed to use relaxed semantics as a result.
- The vulnerability was found in the context of `epoll` where a reader does an `xchg` operation while holding the read lock, and the writer can see a value change unexpectedly.