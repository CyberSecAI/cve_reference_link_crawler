The provided content relates to CVE-2023-52480.

**Root cause of vulnerability:**
The vulnerability is due to a race condition in the ksmbd (kernel SMB server) module between the `ksmbd_session_lookup` function and the `ksmbd_expire_session` function, leading to a use-after-free (UAF).

**Weaknesses/vulnerabilities present:**
- **Race Condition:** Concurrent access to session data without proper synchronization.
- **Use-After-Free (UAF):** A session is freed in one thread (`ksmbd_expire_session`) while another thread (`ksmbd_session_lookup`) still holds a pointer to it.

**Impact of exploitation:**
- A UAF can lead to memory corruption, potentially causing a denial of service (DoS), arbitrary code execution or other undefined behavior.

**Attack vectors:**
- The vulnerability can be triggered by initiating a SMB2 session setup while the session is being expired.
- The attacker needs to establish a connection with the server to trigger the race condition.

**Required attacker capabilities/position:**
- The attacker needs to be able to interact with the SMB server
- The attacker needs to be able to trigger a session lookup at the same time the session is expired.

**Technical Details:**
The race condition occurs between the following functions and events:

1. **Thread A (`ksmbd_session_lookup`):** Tries to access a session using `xa_load` and updates the last active time.
2. **Thread B (`ksmbd_expire_session` called from `smb2_sess_setup`):** Deletes the session using `xa_erase` and frees the session structure using `ksmbd_session_destroy`, which calls `kfree(sess)`.

If `ksmbd_expire_session` frees the session after `xa_load` has returned in `ksmbd_session_lookup` but before `sess->last_active = jiffies` is executed in `ksmbd_session_lookup`, the session pointer becomes a dangling pointer, resulting in a UAF when the last_active field is accessed.

The fix involves adding a read/write semaphore (`rwsem`) `session_lock` to protect access to the session data, ensuring that lookups and expiration are synchronized. Specifically:
- `ksmbd_conn` structure is extended with a `struct rw_semaphore session_lock;`
- `ksmbd_conn_alloc` is extended to `init_rwsem(&conn->session_lock);`
- `ksmbd_session_lookup` is modified to lock and unlock the `session_lock` with `down_read` and `up_read` respectively.
- `ksmbd_expire_session` is modified to lock and unlock the `session_lock` with `down_write` and `up_write` respectively.
- `ksmbd_sessions_deregister` is modified to lock and unlock the `session_lock` with `down_write` and `up_write` respectively.