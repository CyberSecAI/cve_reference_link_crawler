The provided content relates to CVE-2024-26603.

**Root Cause:**
The vulnerability stems from relying on user-provided data (`fx_sw->xstate_size`) to determine the size of the FPU state buffer during signal handling. This allows a malicious user to specify a size smaller than required by the enabled FPU features, leading to out-of-bounds memory access during the `xrstor` operation when restoring the FPU state.

**Weaknesses:**
- **Incorrect Size Calculation**: The kernel used the user-provided `fx_sw->xstate_size` to validate memory access during FPU state restoration via `xrstor`. This size can be manipulated by a malicious user.
- **Insufficient Validation**: The `fault_in_readable` check only verified if `buf + fx_sw->xstate_size` was within the mapped area, but didn't check if the full range required by the xrstor operation was accessible.
- **Infinite Loop**: When the `xrstor` operation accessed unmapped memory, it resulted in a page fault which was caught. Since the address check using the manipulated size would pass the  `fault_in_readable`, the code would retry `xrstor` in an infinite loop.

**Impact:**
- **Denial of Service**: By crafting a malicious sigreturn frame, an attacker could cause the kernel to enter an infinite loop during FPU state restoration, effectively causing a denial of service.

**Attack Vectors:**
- **Sigreturn Frame Manipulation**: An attacker can exploit the vulnerability by crafting a specific sigreturn frame with a manipulated `fx_sw->xstate_size`.

**Required Attacker Capabilities/Position:**
- The attacker needs the ability to manipulate the FPU state and create a malicious sigreturn frame to trigger the vulnerability. This generally implies local access, but other vectors could exist if an application is processing user provided signals.