The provided content relates to CVE-2024-26725.

**Root cause of vulnerability:**
A deadlock can occur during a netlink dump operation in the dpll (Digital Phase-Locked Loop) subsystem due to incorrect lock acquisition order.

**Weaknesses/vulnerabilities present:**
The vulnerability is a circular locking dependency (ABBA deadlock). The `nlk_cb_mutex` and `dpll_lock` are acquired in different orders by different code paths during the netlink dump operation:

1.  `__netlink_dump_start()` calls `control->start(cb)` with `nlk->cb_mutex` held.
2.  `control->start(cb)` acquires `dpll_lock`.
3. `nlk->cb_mutex` is released and then re-acquired in `netlink_dump()` while `dpll_lock` is still held.

This creates a deadlock scenario if another CPU attempts the same sequence, leading to a situation where one CPU has `dpll_lock` and tries to acquire `nlk_cb_mutex`, while another CPU holds `nlk_cb_mutex` and tries to acquire `dpll_lock`.

**Impact of exploitation:**
The impact is a denial-of-service condition due to the deadlock, which would cause the system to hang or become unresponsive during dpll pin dump operations.

**Attack vectors:**
The vulnerability can be triggered by initiating a netlink dump operation on the dpll pins. This is done by sending netlink messages to the kernel using the `DPLL_CMD_PIN_GET` or `DPLL_CMD_DEVICE_GET` commands.

**Required attacker capabilities/position:**
An attacker needs the ability to send netlink messages to the kernel, typically requiring administrative privileges or the ability to control a process that can send netlink messages. The attacker does not need local access if a process with the required capability is accessible remotely.

The fix involves moving the `dpll_lock` acquisition into the `dumpit()` callback to ensure the locks are always acquired in the correct order.