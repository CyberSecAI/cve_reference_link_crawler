=== Content from git.kernel.org_35bba46b_20250111_142210.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=f8dfda798650241c1692058713ca4fef8e429061)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f8dfda798650241c1692058713ca4fef8e429061)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f8dfda798650241c1692058713ca4fef8e429061)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f8dfda798650241c1692058713ca4fef8e429061)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Pablo Neira Ayuso <pablo@netfilter.org> | 2024-08-12 12:29:24 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-08-19 05:32:17 +0200 |
| commit | [f8dfda798650241c1692058713ca4fef8e429061](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f8dfda798650241c1692058713ca4fef8e429061) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=f8dfda798650241c1692058713ca4fef8e429061)) | |
| tree | [367e45f16727d574b159cc9b07adf2e0bc50994a](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f8dfda798650241c1692058713ca4fef8e429061) | |
| parent | [61fbbac22c8ce73d0c492caf45a286c3f021c0fd](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=61fbbac22c8ce73d0c492caf45a286c3f021c0fd) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f8dfda798650241c1692058713ca4fef8e429061&id2=61fbbac22c8ce73d0c492caf45a286c3f021c0fd)) | |
| download | [linux-f8dfda798650241c1692058713ca4fef8e429061.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-f8dfda798650241c1692058713ca4fef8e429061.tar.gz) | |

netfilter: nf\_tables: use timestamp to check for set element timeoutcommit 7395dfacfff65e9938ac0889dafa1ab01e987d15 upstream
Add a timestamp field at the beginning of the transaction, store it
in the nftables per-netns area.
Update set backend .insert, .deactivate and sync gc path to use the
timestamp, this avoids that an element expires while control plane
transaction is still unfinished.
.lookup and .update, which are used from packet path, still use the
current time to check if the element has expired. And .get path and dump
also since this runs lockless under rcu read size lock. Then, there is
async gc which also needs to check the current time since it runs
asynchronously from a workqueue.
[ NB: rbtree GC updates has been excluded because GC is asynchronous. ]
Fixes: c3e1b005ed1c ("netfilter: nf\_tables: add set element timeout support")
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f8dfda798650241c1692058713ca4fef8e429061)

| -rw-r--r-- | [include/net/netfilter/nf\_tables.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/netfilter/nf_tables.h?id=f8dfda798650241c1692058713ca4fef8e429061) | 21 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/netfilter/nf\_tables\_api.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nf_tables_api.c?id=f8dfda798650241c1692058713ca4fef8e429061) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/netfilter/nft\_set\_hash.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nft_set_hash.c?id=f8dfda798650241c1692058713ca4fef8e429061) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/netfilter/nft\_set\_rbtree.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nft_set_rbtree.c?id=f8dfda798650241c1692058713ca4fef8e429061) | 6 | |  |  |  | | --- | --- | --- | |

4 files changed, 31 insertions, 5 deletions

| diff --git a/include/net/netfilter/nf\_tables.h b/include/net/netfilter/nf\_tables.hindex 4a0f51c2b3b915..9eb7d7de590fb0 100644--- a/[include/net/netfilter/nf\_tables.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/netfilter/nf_tables.h?id=61fbbac22c8ce73d0c492caf45a286c3f021c0fd)+++ b/[include/net/netfilter/nf\_tables.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/netfilter/nf_tables.h?id=f8dfda798650241c1692058713ca4fef8e429061)@@ -12,6 +12,7 @@ #include <linux/rhashtable.h> #include <net/netfilter/nf\_flow\_table.h> #include <net/netlink.h>+#include <net/netns/generic.h>  #define NFT\_JUMP\_STACK\_SIZE 16 @@ -636,10 +637,16 @@ static inline struct nft\_expr \*nft\_set\_ext\_expr(const struct nft\_set\_ext \*ext) return nft\_set\_ext(ext, NFT\_SET\_EXT\_EXPR); } -static inline bool nft\_set\_elem\_expired(const struct nft\_set\_ext \*ext)+static inline bool \_\_nft\_set\_elem\_expired(const struct nft\_set\_ext \*ext,+ u64 tstamp) { return nft\_set\_ext\_exists(ext, NFT\_SET\_EXT\_EXPIRATION) &&- time\_is\_before\_eq\_jiffies64(\*nft\_set\_ext\_expiration(ext));+ time\_after\_eq64(tstamp, \*nft\_set\_ext\_expiration(ext));+}++static inline bool nft\_set\_elem\_expired(const struct nft\_set\_ext \*ext)+{+ return \_\_nft\_set\_elem\_expired(ext, get\_jiffies\_64()); }  static inline struct nft\_set\_ext \*nft\_set\_elem\_ext(const struct nft\_set \*set,@@ -1423,11 +1430,21 @@ struct nftables\_pernet { struct list\_head module\_list; struct list\_head notify\_list; struct mutex commit\_mutex;+ u64 tstamp; unsigned int base\_seq; u8 validate\_state; unsigned int gc\_seq; }; +extern unsigned int nf\_tables\_net\_id;++static inline u64 nft\_net\_tstamp(const struct net \*net)+{+ struct nftables\_pernet \*nft\_net = net\_generic(net, nf\_tables\_net\_id);++ return nft\_net->tstamp;+}+ int nf\_msecs\_to\_jiffies64(const struct nlattr \*nla, u64 \*result); \_\_be64 nf\_jiffies64\_to\_msecs(u64 input); diff --git a/net/netfilter/nf\_tables\_api.c b/net/netfilter/nf\_tables\_api.cindex b64d3cd97ee71e..c8a1f3f14384bc 100644--- a/[net/netfilter/nf\_tables\_api.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nf_tables_api.c?id=61fbbac22c8ce73d0c492caf45a286c3f021c0fd)+++ b/[net/netfilter/nf\_tables\_api.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nf_tables_api.c?id=f8dfda798650241c1692058713ca4fef8e429061)@@ -7365,6 +7365,7 @@ static bool nf\_tables\_valid\_genid(struct net \*net, u32 genid) bool genid\_ok;  mutex\_lock(&nft\_net->commit\_mutex);+ nft\_net->tstamp = get\_jiffies\_64();  genid\_ok = genid == 0 || nft\_net->base\_seq == genid; if (!genid\_ok)diff --git a/net/netfilter/nft\_set\_hash.c b/net/netfilter/nft\_set\_hash.cindex 5e562e7cd470ba..8e249e98aeeaf3 100644--- a/[net/netfilter/nft\_set\_hash.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_hash.c?id=61fbbac22c8ce73d0c492caf45a286c3f021c0fd)+++ b/[net/netfilter/nft\_set\_hash.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_hash.c?id=f8dfda798650241c1692058713ca4fef8e429061)@@ -41,6 +41,7 @@ struct nft\_rhash\_cmp\_arg { const struct nft\_set \*set; const u32 \*key; u8 genmask;+ u64 tstamp; };  static inline u32 nft\_rhash\_key(const void \*data, u32 len, u32 seed)@@ -67,7 +68,7 @@ static inline int nft\_rhash\_cmp(struct rhashtable\_compare\_arg \*arg, return 1; if (nft\_set\_elem\_is\_dead(&he->ext)) return 1;- if (nft\_set\_elem\_expired(&he->ext))+ if (\_\_nft\_set\_elem\_expired(&he->ext, x->tstamp)) return 1; if (!nft\_set\_elem\_active(&he->ext, x->genmask)) return 1;@@ -91,6 +92,7 @@ static bool nft\_rhash\_lookup(const struct net \*net, const struct nft\_set \*set, .genmask = nft\_genmask\_cur(net), .set = set, .key = key,+ .tstamp = get\_jiffies\_64(), };  he = rhashtable\_lookup\_fast(&priv->ht, &arg, nft\_rhash\_params);@@ -109,6 +111,7 @@ static void \*nft\_rhash\_get(const struct net \*net, const struct nft\_set \*set, .genmask = nft\_genmask\_cur(net), .set = set, .key = elem->key.val.data,+ .tstamp = get\_jiffies\_64(), };  he = rhashtable\_lookup\_fast(&priv->ht, &arg, nft\_rhash\_params);@@ -132,6 +135,7 @@ static bool nft\_rhash\_update(struct nft\_set \*set, const u32 \*key, .genmask = NFT\_GENMASK\_ANY, .set = set, .key = key,+ .tstamp = get\_jiffies\_64(), };  he = rhashtable\_lookup\_fast(&priv->ht, &arg, nft\_rhash\_params);@@ -175,6 +179,7 @@ static int nft\_rhash\_insert(const struct net \*net, const struct nft\_set \*set, .genmask = nft\_genmask\_next(net), .set = set, .key = elem->key.val.data,+ .tstamp = nft\_net\_tstamp(net), }; struct nft\_rhash\_elem \*prev; @@ -217,6 +222,7 @@ static void \*nft\_rhash\_deactivate(const struct net \*net, .genmask = nft\_genmask\_next(net), .set = set, .key = elem->key.val.data,+ .tstamp = nft\_net\_tstamp(net), };  rcu\_read\_lock();diff --git a/net/netfilter/nft\_set\_rbtree.c b/net/netfilter/nft\_set\_rbtree.cindex caddacc1d4462b..f5bec0e37c0d1f 100644--- a/[net/netfilter/nft\_set\_rbtree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_rbtree.c?id=61fbbac22c8ce73d0c492caf45a286c3f021c0fd)+++ b/[net/netfilter/nft\_set\_rbtree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_rbtree.c?id=f8dfda798650241c1692058713ca4fef8e429061)@@ -318,6 +318,7 @@ static int \_\_nft\_rbtree\_insert(const struct net \*net, const struct nft\_set \*set, struct nft\_rbtree \*priv = nft\_set\_priv(set); u8 cur\_genmask = nft\_genmask\_cur(net); u8 genmask = nft\_genmask\_next(net);+ u64 tstamp = nft\_net\_tstamp(net); int d, err;  /\* Descend the tree to search for an existing element greater than the@@ -365,7 +366,7 @@ static int \_\_nft\_rbtree\_insert(const struct net \*net, const struct nft\_set \*set, /\* perform garbage collection to avoid bogus overlap reports \* but skip new elements in this transaction. \*/- if (nft\_set\_elem\_expired(&rbe->ext) &&+ if (\_\_nft\_set\_elem\_expired(&rbe->ext, tstamp) && nft\_set\_elem\_active(&rbe->ext, cur\_genmask)) { err = nft\_rbtree\_gc\_elem(set, priv, rbe); if (err < 0)@@ -540,6 +541,7 @@ static void \*nft\_rbtree\_deactivate(const struct net \*net, const struct rb\_node \*parent = priv->root.rb\_node; struct nft\_rbtree\_elem \*rbe, \*this = elem->priv; u8 genmask = nft\_genmask\_next(net);+ u64 tstamp = nft\_net\_tstamp(net); int d;  while (parent != NULL) {@@ -560,7 +562,7 @@ static void \*nft\_rbtree\_deactivate(const struct net \*net, nft\_rbtree\_interval\_end(this)) { parent = parent->rb\_right; continue;- } else if (nft\_set\_elem\_expired(&rbe->ext)) {+ } else if (\_\_nft\_set\_elem\_expired(&rbe->ext, tstamp)) { break; } else if (!nft\_set\_elem\_active(&rbe->ext, genmask)) { parent = parent->rb\_left; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 14:20:47 +0000



=== Content from git.kernel.org_03677274_20250111_142208.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=b45176b869673417ace338b87cf9cdb66e2eeb01)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=b45176b869673417ace338b87cf9cdb66e2eeb01)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b45176b869673417ace338b87cf9cdb66e2eeb01)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b45176b869673417ace338b87cf9cdb66e2eeb01)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Pablo Neira Ayuso <pablo@netfilter.org> | 2024-06-27 01:53:13 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-07-05 09:31:44 +0200 |
| commit | [b45176b869673417ace338b87cf9cdb66e2eeb01](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b45176b869673417ace338b87cf9cdb66e2eeb01) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=b45176b869673417ace338b87cf9cdb66e2eeb01)) | |
| tree | [321806fe132e83e8967bfdfc9737bcc491428956](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=b45176b869673417ace338b87cf9cdb66e2eeb01) | |
| parent | [7491c3c55c749efaacf7c92d31ad09833c7cccba](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7491c3c55c749efaacf7c92d31ad09833c7cccba) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b45176b869673417ace338b87cf9cdb66e2eeb01&id2=7491c3c55c749efaacf7c92d31ad09833c7cccba)) | |
| download | [linux-b45176b869673417ace338b87cf9cdb66e2eeb01.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-b45176b869673417ace338b87cf9cdb66e2eeb01.tar.gz) | |

netfilter: nf\_tables: use timestamp to check for set element timeoutcommit 7395dfacfff65e9938ac0889dafa1ab01e987d15 upstream
Add a timestamp field at the beginning of the transaction, store it
in the nftables per-netns area.
Update set backend .insert, .deactivate and sync gc path to use the
timestamp, this avoids that an element expires while control plane
transaction is still unfinished.
.lookup and .update, which are used from packet path, still use the
current time to check if the element has expired. And .get path and dump
also since this runs lockless under rcu read size lock. Then, there is
async gc which also needs to check the current time since it runs
asynchronously from a workqueue.
Fixes: c3e1b005ed1c ("netfilter: nf\_tables: add set element timeout support")
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b45176b869673417ace338b87cf9cdb66e2eeb01)

| -rw-r--r-- | [include/net/netfilter/nf\_tables.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/netfilter/nf_tables.h?id=b45176b869673417ace338b87cf9cdb66e2eeb01) | 16 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/netfilter/nf\_tables\_api.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nf_tables_api.c?id=b45176b869673417ace338b87cf9cdb66e2eeb01) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/netfilter/nft\_set\_hash.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nft_set_hash.c?id=b45176b869673417ace338b87cf9cdb66e2eeb01) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/netfilter/nft\_set\_pipapo.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nft_set_pipapo.c?id=b45176b869673417ace338b87cf9cdb66e2eeb01) | 18 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/netfilter/nft\_set\_rbtree.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nft_set_rbtree.c?id=b45176b869673417ace338b87cf9cdb66e2eeb01) | 6 | |  |  |  | | --- | --- | --- | |

5 files changed, 39 insertions, 13 deletions

| diff --git a/include/net/netfilter/nf\_tables.h b/include/net/netfilter/nf\_tables.hindex 2fa344cb66f60c..964cf7578bd506 100644--- a/[include/net/netfilter/nf\_tables.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/netfilter/nf_tables.h?id=7491c3c55c749efaacf7c92d31ad09833c7cccba)+++ b/[include/net/netfilter/nf\_tables.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/netfilter/nf_tables.h?id=b45176b869673417ace338b87cf9cdb66e2eeb01)@@ -784,10 +784,16 @@ static inline struct nft\_set\_elem\_expr \*nft\_set\_ext\_expr(const struct nft\_set\_ex return nft\_set\_ext(ext, NFT\_SET\_EXT\_EXPRESSIONS); } -static inline bool nft\_set\_elem\_expired(const struct nft\_set\_ext \*ext)+static inline bool \_\_nft\_set\_elem\_expired(const struct nft\_set\_ext \*ext,+ u64 tstamp) { return nft\_set\_ext\_exists(ext, NFT\_SET\_EXT\_EXPIRATION) &&- time\_is\_before\_eq\_jiffies64(\*nft\_set\_ext\_expiration(ext));+ time\_after\_eq64(tstamp, \*nft\_set\_ext\_expiration(ext));+}++static inline bool nft\_set\_elem\_expired(const struct nft\_set\_ext \*ext)+{+ return \_\_nft\_set\_elem\_expired(ext, get\_jiffies\_64()); }  static inline struct nft\_set\_ext \*nft\_set\_elem\_ext(const struct nft\_set \*set,@@ -1711,6 +1717,7 @@ struct nftables\_pernet { struct list\_head notify\_list; struct mutex commit\_mutex; u64 table\_handle;+ u64 tstamp; unsigned int base\_seq; u8 validate\_state; unsigned int gc\_seq;@@ -1723,6 +1730,11 @@ static inline struct nftables\_pernet \*nft\_pernet(const struct net \*net) return net\_generic(net, nf\_tables\_net\_id); } +static inline u64 nft\_net\_tstamp(const struct net \*net)+{+ return nft\_pernet(net)->tstamp;+}+ #define \_\_NFT\_REDUCE\_READONLY 1UL #define NFT\_REDUCE\_READONLY (void \*)\_\_NFT\_REDUCE\_READONLY diff --git a/net/netfilter/nf\_tables\_api.c b/net/netfilter/nf\_tables\_api.cindex 1c4b7a8ec2cc61..e838a6617b0aab 100644--- a/[net/netfilter/nf\_tables\_api.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nf_tables_api.c?id=7491c3c55c749efaacf7c92d31ad09833c7cccba)+++ b/[net/netfilter/nf\_tables\_api.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nf_tables_api.c?id=b45176b869673417ace338b87cf9cdb66e2eeb01)@@ -9377,6 +9377,7 @@ dead\_elem: struct nft\_trans\_gc \*nft\_trans\_gc\_catchall\_sync(struct nft\_trans\_gc \*gc) { struct nft\_set\_elem\_catchall \*catchall, \*next;+ u64 tstamp = nft\_net\_tstamp(gc->net); const struct nft\_set \*set = gc->set; struct nft\_set\_elem elem; struct nft\_set\_ext \*ext;@@ -9386,7 +9387,7 @@ struct nft\_trans\_gc \*nft\_trans\_gc\_catchall\_sync(struct nft\_trans\_gc \*gc) list\_for\_each\_entry\_safe(catchall, next, &set->catchall\_list, list) { ext = nft\_set\_elem\_ext(set, catchall->elem); - if (!nft\_set\_elem\_expired(ext))+ if (!\_\_nft\_set\_elem\_expired(ext, tstamp)) continue;  gc = nft\_trans\_gc\_queue\_sync(gc, GFP\_KERNEL);@@ -10138,6 +10139,7 @@ static bool nf\_tables\_valid\_genid(struct net \*net, u32 genid) bool genid\_ok;  mutex\_lock(&nft\_net->commit\_mutex);+ nft\_net->tstamp = get\_jiffies\_64();  genid\_ok = genid == 0 || nft\_net->base\_seq == genid; if (!genid\_ok)diff --git a/net/netfilter/nft\_set\_hash.c b/net/netfilter/nft\_set\_hash.cindex 2013de934cef09..1fd3b413350dcc 100644--- a/[net/netfilter/nft\_set\_hash.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_hash.c?id=7491c3c55c749efaacf7c92d31ad09833c7cccba)+++ b/[net/netfilter/nft\_set\_hash.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_hash.c?id=b45176b869673417ace338b87cf9cdb66e2eeb01)@@ -35,6 +35,7 @@ struct nft\_rhash\_cmp\_arg { const struct nft\_set \*set; const u32 \*key; u8 genmask;+ u64 tstamp; };  static inline u32 nft\_rhash\_key(const void \*data, u32 len, u32 seed)@@ -61,7 +62,7 @@ static inline int nft\_rhash\_cmp(struct rhashtable\_compare\_arg \*arg, return 1; if (nft\_set\_elem\_is\_dead(&he->ext)) return 1;- if (nft\_set\_elem\_expired(&he->ext))+ if (\_\_nft\_set\_elem\_expired(&he->ext, x->tstamp)) return 1; if (!nft\_set\_elem\_active(&he->ext, x->genmask)) return 1;@@ -86,6 +87,7 @@ bool nft\_rhash\_lookup(const struct net \*net, const struct nft\_set \*set, .genmask = nft\_genmask\_cur(net), .set = set, .key = key,+ .tstamp = get\_jiffies\_64(), };  he = rhashtable\_lookup(&priv->ht, &arg, nft\_rhash\_params);@@ -104,6 +106,7 @@ static void \*nft\_rhash\_get(const struct net \*net, const struct nft\_set \*set, .genmask = nft\_genmask\_cur(net), .set = set, .key = elem->key.val.data,+ .tstamp = get\_jiffies\_64(), };  he = rhashtable\_lookup(&priv->ht, &arg, nft\_rhash\_params);@@ -127,6 +130,7 @@ static bool nft\_rhash\_update(struct nft\_set \*set, const u32 \*key, .genmask = NFT\_GENMASK\_ANY, .set = set, .key = key,+ .tstamp = get\_jiffies\_64(), };  he = rhashtable\_lookup(&priv->ht, &arg, nft\_rhash\_params);@@ -170,6 +174,7 @@ static int nft\_rhash\_insert(const struct net \*net, const struct nft\_set \*set, .genmask = nft\_genmask\_next(net), .set = set, .key = elem->key.val.data,+ .tstamp = nft\_net\_tstamp(net), }; struct nft\_rhash\_elem \*prev; @@ -212,6 +217,7 @@ static void \*nft\_rhash\_deactivate(const struct net \*net, .genmask = nft\_genmask\_next(net), .set = set, .key = elem->key.val.data,+ .tstamp = nft\_net\_tstamp(net), };  rcu\_read\_lock();diff --git a/net/netfilter/nft\_set\_pipapo.c b/net/netfilter/nft\_set\_pipapo.cindex 2299ced939c47f..a56ed216c22339 100644--- a/[net/netfilter/nft\_set\_pipapo.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_pipapo.c?id=7491c3c55c749efaacf7c92d31ad09833c7cccba)+++ b/[net/netfilter/nft\_set\_pipapo.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_pipapo.c?id=b45176b869673417ace338b87cf9cdb66e2eeb01)@@ -504,6 +504,7 @@ out: \* @set: nftables API set representation \* @data: Key data to be matched against existing elements \* @genmask: If set, check that element is active in given genmask+ \* @tstamp: timestamp to check for expired elements \* \* This is essentially the same as the lookup function, except that it matches \* key data against the uncommitted copy and doesn't use preallocated maps for@@ -513,7 +514,8 @@ out: \*/ static struct nft\_pipapo\_elem \*pipapo\_get(const struct net \*net, const struct nft\_set \*set,- const u8 \*data, u8 genmask)+ const u8 \*data, u8 genmask,+ u64 tstamp) { struct nft\_pipapo\_elem \*ret = ERR\_PTR(-ENOENT); struct nft\_pipapo \*priv = nft\_set\_priv(set);@@ -566,7 +568,7 @@ next\_match: goto out;  if (last) {- if (nft\_set\_elem\_expired(&f->mt[b].e->ext))+ if (\_\_nft\_set\_elem\_expired(&f->mt[b].e->ext, tstamp)) goto next\_match; if ((genmask && !nft\_set\_elem\_active(&f->mt[b].e->ext, genmask)))@@ -603,7 +605,7 @@ static void \*nft\_pipapo\_get(const struct net \*net, const struct nft\_set \*set, const struct nft\_set\_elem \*elem, unsigned int flags) { return pipapo\_get(net, set, (const u8 \*)elem->key.val.data,- nft\_genmask\_cur(net));+ nft\_genmask\_cur(net), get\_jiffies\_64()); }  /\*\*@@ -1197,6 +1199,7 @@ static int nft\_pipapo\_insert(const struct net \*net, const struct nft\_set \*set, struct nft\_pipapo \*priv = nft\_set\_priv(set); struct nft\_pipapo\_match \*m = priv->clone; u8 genmask = nft\_genmask\_next(net);+ u64 tstamp = nft\_net\_tstamp(net); struct nft\_pipapo\_field \*f; const u8 \*start\_p, \*end\_p; int i, bsize\_max, err = 0;@@ -1206,7 +1209,7 @@ static int nft\_pipapo\_insert(const struct net \*net, const struct nft\_set \*set, else end = start; - dup = pipapo\_get(net, set, start, genmask);+ dup = pipapo\_get(net, set, start, genmask, tstamp); if (!IS\_ERR(dup)) { /\* Check if we already have the same exact entry \*/ const struct nft\_data \*dup\_key, \*dup\_end;@@ -1228,7 +1231,7 @@ static int nft\_pipapo\_insert(const struct net \*net, const struct nft\_set \*set,  if (PTR\_ERR(dup) == -ENOENT) { /\* Look for partially overlapping entries \*/- dup = pipapo\_get(net, set, end, nft\_genmask\_next(net));+ dup = pipapo\_get(net, set, end, nft\_genmask\_next(net), tstamp); }  if (PTR\_ERR(dup) != -ENOENT) {@@ -1581,6 +1584,7 @@ static void pipapo\_gc(const struct nft\_set \*\_set, struct nft\_pipapo\_match \*m) struct nft\_set \*set = (struct nft\_set \*) \_set; struct nft\_pipapo \*priv = nft\_set\_priv(set); struct net \*net = read\_pnet(&set->net);+ u64 tstamp = nft\_net\_tstamp(net); int rules\_f0, first\_rule = 0; struct nft\_pipapo\_elem \*e; struct nft\_trans\_gc \*gc;@@ -1615,7 +1619,7 @@ static void pipapo\_gc(const struct nft\_set \*\_set, struct nft\_pipapo\_match \*m) /\* synchronous gc never fails, there is no need to set on \* NFT\_SET\_ELEM\_DEAD\_BIT. \*/- if (nft\_set\_elem\_expired(&e->ext)) {+ if (\_\_nft\_set\_elem\_expired(&e->ext, tstamp)) { priv->dirty = true;  gc = nft\_trans\_gc\_queue\_sync(gc, GFP\_ATOMIC);@@ -1786,7 +1790,7 @@ static void \*pipapo\_deactivate(const struct net \*net, const struct nft\_set \*set, { struct nft\_pipapo\_elem \*e; - e = pipapo\_get(net, set, data, nft\_genmask\_next(net));+ e = pipapo\_get(net, set, data, nft\_genmask\_next(net), nft\_net\_tstamp(net)); if (IS\_ERR(e)) return NULL; diff --git a/net/netfilter/nft\_set\_rbtree.c b/net/netfilter/nft\_set\_rbtree.cindex 5bf5572e945cc3..021d9e76129a5e 100644--- a/[net/netfilter/nft\_set\_rbtree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_rbtree.c?id=7491c3c55c749efaacf7c92d31ad09833c7cccba)+++ b/[net/netfilter/nft\_set\_rbtree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_rbtree.c?id=b45176b869673417ace338b87cf9cdb66e2eeb01)@@ -314,6 +314,7 @@ static int \_\_nft\_rbtree\_insert(const struct net \*net, const struct nft\_set \*set, struct nft\_rbtree \*priv = nft\_set\_priv(set); u8 cur\_genmask = nft\_genmask\_cur(net); u8 genmask = nft\_genmask\_next(net);+ u64 tstamp = nft\_net\_tstamp(net); int d;  /\* Descend the tree to search for an existing element greater than the@@ -361,7 +362,7 @@ static int \_\_nft\_rbtree\_insert(const struct net \*net, const struct nft\_set \*set, /\* perform garbage collection to avoid bogus overlap reports \* but skip new elements in this transaction. \*/- if (nft\_set\_elem\_expired(&rbe->ext) &&+ if (\_\_nft\_set\_elem\_expired(&rbe->ext, tstamp) && nft\_set\_elem\_active(&rbe->ext, cur\_genmask)) { const struct nft\_rbtree\_elem \*removed\_end; @@ -548,6 +549,7 @@ static void \*nft\_rbtree\_deactivate(const struct net \*net, const struct rb\_node \*parent = priv->root.rb\_node; struct nft\_rbtree\_elem \*rbe, \*this = elem->priv; u8 genmask = nft\_genmask\_next(net);+ u64 tstamp = nft\_net\_tstamp(net); int d;  while (parent != NULL) {@@ -568,7 +570,7 @@ static void \*nft\_rbtree\_deactivate(const struct net \*net, nft\_rbtree\_interval\_end(this)) { parent = parent->rb\_right; continue;- } else if (nft\_set\_elem\_expired(&rbe->ext)) {+ } else if (\_\_nft\_set\_elem\_expired(&rbe->ext, tstamp)) { break; } else if (!nft\_set\_elem\_active(&rbe->ext, genmask)) { parent = parent->rb\_left; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 14:20:46 +0000



=== Content from git.kernel.org_8f0f0db7_20250111_142209.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=eaf1a29ea5d7dba8e84e9e9f3b3f47d0cd540bfe)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=eaf1a29ea5d7dba8e84e9e9f3b3f47d0cd540bfe)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=eaf1a29ea5d7dba8e84e9e9f3b3f47d0cd540bfe)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=eaf1a29ea5d7dba8e84e9e9f3b3f47d0cd540bfe)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Pablo Neira Ayuso <pablo@netfilter.org> | 2024-08-12 12:28:47 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-08-19 05:33:53 +0200 |
| commit | [eaf1a29ea5d7dba8e84e9e9f3b3f47d0cd540bfe](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=eaf1a29ea5d7dba8e84e9e9f3b3f47d0cd540bfe) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=eaf1a29ea5d7dba8e84e9e9f3b3f47d0cd540bfe)) | |
| tree | [0c0722664527176f2e74f8005e72616226ea3bbe](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=eaf1a29ea5d7dba8e84e9e9f3b3f47d0cd540bfe) | |
| parent | [cb56f8f06a7a0c1797a9ad2c41937edf32d797d8](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=cb56f8f06a7a0c1797a9ad2c41937edf32d797d8) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=eaf1a29ea5d7dba8e84e9e9f3b3f47d0cd540bfe&id2=cb56f8f06a7a0c1797a9ad2c41937edf32d797d8)) | |
| download | [linux-eaf1a29ea5d7dba8e84e9e9f3b3f47d0cd540bfe.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-eaf1a29ea5d7dba8e84e9e9f3b3f47d0cd540bfe.tar.gz) | |

netfilter: nf\_tables: use timestamp to check for set element timeoutcommit 7395dfacfff65e9938ac0889dafa1ab01e987d15 upstream
Add a timestamp field at the beginning of the transaction, store it
in the nftables per-netns area.
Update set backend .insert, .deactivate and sync gc path to use the
timestamp, this avoids that an element expires while control plane
transaction is still unfinished.
.lookup and .update, which are used from packet path, still use the
current time to check if the element has expired. And .get path and dump
also since this runs lockless under rcu read size lock. Then, there is
async gc which also needs to check the current time since it runs
asynchronously from a workqueue.
[ NB: rbtree GC updates has been excluded because GC is asynchronous. ]
Fixes: c3e1b005ed1c ("netfilter: nf\_tables: add set element timeout support")
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=eaf1a29ea5d7dba8e84e9e9f3b3f47d0cd540bfe)

| -rw-r--r-- | [include/net/netfilter/nf\_tables.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/netfilter/nf_tables.h?id=eaf1a29ea5d7dba8e84e9e9f3b3f47d0cd540bfe) | 21 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/netfilter/nf\_tables\_api.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nf_tables_api.c?id=eaf1a29ea5d7dba8e84e9e9f3b3f47d0cd540bfe) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/netfilter/nft\_set\_hash.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nft_set_hash.c?id=eaf1a29ea5d7dba8e84e9e9f3b3f47d0cd540bfe) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/netfilter/nft\_set\_rbtree.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nft_set_rbtree.c?id=eaf1a29ea5d7dba8e84e9e9f3b3f47d0cd540bfe) | 6 | |  |  |  | | --- | --- | --- | |

4 files changed, 31 insertions, 5 deletions

| diff --git a/include/net/netfilter/nf\_tables.h b/include/net/netfilter/nf\_tables.hindex 4f77e2f8e1ca8e..648aac42dfecee 100644--- a/[include/net/netfilter/nf\_tables.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/netfilter/nf_tables.h?id=cb56f8f06a7a0c1797a9ad2c41937edf32d797d8)+++ b/[include/net/netfilter/nf\_tables.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/netfilter/nf_tables.h?id=eaf1a29ea5d7dba8e84e9e9f3b3f47d0cd540bfe)@@ -13,6 +13,7 @@ #include <net/netfilter/nf\_flow\_table.h> #include <net/netlink.h> #include <net/flow\_offload.h>+#include <net/netns/generic.h>  struct module; @@ -656,10 +657,16 @@ static inline struct nft\_expr \*nft\_set\_ext\_expr(const struct nft\_set\_ext \*ext) return nft\_set\_ext(ext, NFT\_SET\_EXT\_EXPR); } -static inline bool nft\_set\_elem\_expired(const struct nft\_set\_ext \*ext)+static inline bool \_\_nft\_set\_elem\_expired(const struct nft\_set\_ext \*ext,+ u64 tstamp) { return nft\_set\_ext\_exists(ext, NFT\_SET\_EXT\_EXPIRATION) &&- time\_is\_before\_eq\_jiffies64(\*nft\_set\_ext\_expiration(ext));+ time\_after\_eq64(tstamp, \*nft\_set\_ext\_expiration(ext));+}++static inline bool nft\_set\_elem\_expired(const struct nft\_set\_ext \*ext)+{+ return \_\_nft\_set\_elem\_expired(ext, get\_jiffies\_64()); }  static inline struct nft\_set\_ext \*nft\_set\_elem\_ext(const struct nft\_set \*set,@@ -1482,9 +1489,19 @@ struct nftables\_pernet { struct list\_head module\_list; struct list\_head notify\_list; struct mutex commit\_mutex;+ u64 tstamp; unsigned int base\_seq; u8 validate\_state; unsigned int gc\_seq; }; +extern unsigned int nf\_tables\_net\_id;++static inline u64 nft\_net\_tstamp(const struct net \*net)+{+ struct nftables\_pernet \*nft\_net = net\_generic(net, nf\_tables\_net\_id);++ return nft\_net->tstamp;+}+ #endif /\* \_NET\_NF\_TABLES\_H \*/diff --git a/net/netfilter/nf\_tables\_api.c b/net/netfilter/nf\_tables\_api.cindex 2915575739e2f7..eff496a6891b31 100644--- a/[net/netfilter/nf\_tables\_api.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nf_tables_api.c?id=cb56f8f06a7a0c1797a9ad2c41937edf32d797d8)+++ b/[net/netfilter/nf\_tables\_api.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nf_tables_api.c?id=eaf1a29ea5d7dba8e84e9e9f3b3f47d0cd540bfe)@@ -7758,6 +7758,7 @@ static bool nf\_tables\_valid\_genid(struct net \*net, u32 genid) bool genid\_ok;  mutex\_lock(&nft\_net->commit\_mutex);+ nft\_net->tstamp = get\_jiffies\_64();  genid\_ok = genid == 0 || nft\_net->base\_seq == genid; if (!genid\_ok)diff --git a/net/netfilter/nft\_set\_hash.c b/net/netfilter/nft\_set\_hash.cindex 0581d5499c5a82..ec03d4c77b3df6 100644--- a/[net/netfilter/nft\_set\_hash.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_hash.c?id=cb56f8f06a7a0c1797a9ad2c41937edf32d797d8)+++ b/[net/netfilter/nft\_set\_hash.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_hash.c?id=eaf1a29ea5d7dba8e84e9e9f3b3f47d0cd540bfe)@@ -38,6 +38,7 @@ struct nft\_rhash\_cmp\_arg { const struct nft\_set \*set; const u32 \*key; u8 genmask;+ u64 tstamp; };  static inline u32 nft\_rhash\_key(const void \*data, u32 len, u32 seed)@@ -64,7 +65,7 @@ static inline int nft\_rhash\_cmp(struct rhashtable\_compare\_arg \*arg, return 1; if (nft\_set\_elem\_is\_dead(&he->ext)) return 1;- if (nft\_set\_elem\_expired(&he->ext))+ if (\_\_nft\_set\_elem\_expired(&he->ext, x->tstamp)) return 1; if (!nft\_set\_elem\_active(&he->ext, x->genmask)) return 1;@@ -88,6 +89,7 @@ static bool nft\_rhash\_lookup(const struct net \*net, const struct nft\_set \*set, .genmask = nft\_genmask\_cur(net), .set = set, .key = key,+ .tstamp = get\_jiffies\_64(), };  he = rhashtable\_lookup(&priv->ht, &arg, nft\_rhash\_params);@@ -106,6 +108,7 @@ static void \*nft\_rhash\_get(const struct net \*net, const struct nft\_set \*set, .genmask = nft\_genmask\_cur(net), .set = set, .key = elem->key.val.data,+ .tstamp = get\_jiffies\_64(), };  he = rhashtable\_lookup(&priv->ht, &arg, nft\_rhash\_params);@@ -129,6 +132,7 @@ static bool nft\_rhash\_update(struct nft\_set \*set, const u32 \*key, .genmask = NFT\_GENMASK\_ANY, .set = set, .key = key,+ .tstamp = get\_jiffies\_64(), };  he = rhashtable\_lookup(&priv->ht, &arg, nft\_rhash\_params);@@ -172,6 +176,7 @@ static int nft\_rhash\_insert(const struct net \*net, const struct nft\_set \*set, .genmask = nft\_genmask\_next(net), .set = set, .key = elem->key.val.data,+ .tstamp = nft\_net\_tstamp(net), }; struct nft\_rhash\_elem \*prev; @@ -214,6 +219,7 @@ static void \*nft\_rhash\_deactivate(const struct net \*net, .genmask = nft\_genmask\_next(net), .set = set, .key = elem->key.val.data,+ .tstamp = nft\_net\_tstamp(net), };  rcu\_read\_lock();diff --git a/net/netfilter/nft\_set\_rbtree.c b/net/netfilter/nft\_set\_rbtree.cindex 2b5f65a424b7e9..ed54cc05789998 100644--- a/[net/netfilter/nft\_set\_rbtree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_rbtree.c?id=cb56f8f06a7a0c1797a9ad2c41937edf32d797d8)+++ b/[net/netfilter/nft\_set\_rbtree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_rbtree.c?id=eaf1a29ea5d7dba8e84e9e9f3b3f47d0cd540bfe)@@ -315,6 +315,7 @@ static int \_\_nft\_rbtree\_insert(const struct net \*net, const struct nft\_set \*set, struct nft\_rbtree \*priv = nft\_set\_priv(set); u8 cur\_genmask = nft\_genmask\_cur(net); u8 genmask = nft\_genmask\_next(net);+ u64 tstamp = nft\_net\_tstamp(net); int d, err;  /\* Descend the tree to search for an existing element greater than the@@ -362,7 +363,7 @@ static int \_\_nft\_rbtree\_insert(const struct net \*net, const struct nft\_set \*set, /\* perform garbage collection to avoid bogus overlap reports \* but skip new elements in this transaction. \*/- if (nft\_set\_elem\_expired(&rbe->ext) &&+ if (\_\_nft\_set\_elem\_expired(&rbe->ext, tstamp) && nft\_set\_elem\_active(&rbe->ext, cur\_genmask)) { err = nft\_rbtree\_gc\_elem(set, priv, rbe); if (err < 0)@@ -537,6 +538,7 @@ static void \*nft\_rbtree\_deactivate(const struct net \*net, const struct rb\_node \*parent = priv->root.rb\_node; struct nft\_rbtree\_elem \*rbe, \*this = elem->priv; u8 genmask = nft\_genmask\_next(net);+ u64 tstamp = nft\_net\_tstamp(net); int d;  while (parent != NULL) {@@ -557,7 +559,7 @@ static void \*nft\_rbtree\_deactivate(const struct net \*net, nft\_rbtree\_interval\_end(this)) { parent = parent->rb\_right; continue;- } else if (nft\_set\_elem\_expired(&rbe->ext)) {+ } else if (\_\_nft\_set\_elem\_expired(&rbe->ext, tstamp)) { break; } else if (!nft\_set\_elem\_active(&rbe->ext, genmask)) { parent = parent->rb\_left; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 14:20:46 +0000



=== Content from git.kernel.org_844fa270_20250111_142206.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=0d40e8cb1d1f56a994cdd2e015af622fdca9ed4d)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=0d40e8cb1d1f56a994cdd2e015af622fdca9ed4d)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=0d40e8cb1d1f56a994cdd2e015af622fdca9ed4d)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=0d40e8cb1d1f56a994cdd2e015af622fdca9ed4d)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Pablo Neira Ayuso <pablo@netfilter.org> | 2024-08-12 12:24:43 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-08-19 05:45:50 +0200 |
| commit | [0d40e8cb1d1f56a994cdd2e015af622fdca9ed4d](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=0d40e8cb1d1f56a994cdd2e015af622fdca9ed4d) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=0d40e8cb1d1f56a994cdd2e015af622fdca9ed4d)) | |
| tree | [9e64e8bd0bc0733b3445ddf1c977e54fe0d0ec03](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=0d40e8cb1d1f56a994cdd2e015af622fdca9ed4d) | |
| parent | [9526393ed6c79003a1ae8b7844683467959960b4](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9526393ed6c79003a1ae8b7844683467959960b4) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=0d40e8cb1d1f56a994cdd2e015af622fdca9ed4d&id2=9526393ed6c79003a1ae8b7844683467959960b4)) | |
| download | [linux-0d40e8cb1d1f56a994cdd2e015af622fdca9ed4d.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-0d40e8cb1d1f56a994cdd2e015af622fdca9ed4d.tar.gz) | |

netfilter: nf\_tables: use timestamp to check for set element timeoutcommit 7395dfacfff65e9938ac0889dafa1ab01e987d15 upstream
Add a timestamp field at the beginning of the transaction, store it
in the nftables per-netns area.
Update set backend .insert, .deactivate and sync gc path to use the
timestamp, this avoids that an element expires while control plane
transaction is still unfinished.
.lookup and .update, which are used from packet path, still use the
current time to check if the element has expired. And .get path and dump
also since this runs lockless under rcu read size lock. Then, there is
async gc which also needs to check the current time since it runs
asynchronously from a workqueue.
Fixes: c3e1b005ed1c ("netfilter: nf\_tables: add set element timeout support")
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=0d40e8cb1d1f56a994cdd2e015af622fdca9ed4d)

| -rw-r--r-- | [include/net/netfilter/nf\_tables.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/netfilter/nf_tables.h?id=0d40e8cb1d1f56a994cdd2e015af622fdca9ed4d) | 16 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/netfilter/nf\_tables\_api.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nf_tables_api.c?id=0d40e8cb1d1f56a994cdd2e015af622fdca9ed4d) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/netfilter/nft\_set\_hash.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nft_set_hash.c?id=0d40e8cb1d1f56a994cdd2e015af622fdca9ed4d) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/netfilter/nft\_set\_pipapo.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nft_set_pipapo.c?id=0d40e8cb1d1f56a994cdd2e015af622fdca9ed4d) | 18 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/netfilter/nft\_set\_rbtree.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nft_set_rbtree.c?id=0d40e8cb1d1f56a994cdd2e015af622fdca9ed4d) | 6 | |  |  |  | | --- | --- | --- | |

5 files changed, 39 insertions, 13 deletions

| diff --git a/include/net/netfilter/nf\_tables.h b/include/net/netfilter/nf\_tables.hindex 3ff6b3362800be..d241c6d8174ab7 100644--- a/[include/net/netfilter/nf\_tables.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/netfilter/nf_tables.h?id=9526393ed6c79003a1ae8b7844683467959960b4)+++ b/[include/net/netfilter/nf\_tables.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/netfilter/nf_tables.h?id=0d40e8cb1d1f56a994cdd2e015af622fdca9ed4d)@@ -772,10 +772,16 @@ static inline struct nft\_set\_elem\_expr \*nft\_set\_ext\_expr(const struct nft\_set\_ex return nft\_set\_ext(ext, NFT\_SET\_EXT\_EXPRESSIONS); } -static inline bool nft\_set\_elem\_expired(const struct nft\_set\_ext \*ext)+static inline bool \_\_nft\_set\_elem\_expired(const struct nft\_set\_ext \*ext,+ u64 tstamp) { return nft\_set\_ext\_exists(ext, NFT\_SET\_EXT\_EXPIRATION) &&- time\_is\_before\_eq\_jiffies64(\*nft\_set\_ext\_expiration(ext));+ time\_after\_eq64(tstamp, \*nft\_set\_ext\_expiration(ext));+}++static inline bool nft\_set\_elem\_expired(const struct nft\_set\_ext \*ext)+{+ return \_\_nft\_set\_elem\_expired(ext, get\_jiffies\_64()); }  static inline struct nft\_set\_ext \*nft\_set\_elem\_ext(const struct nft\_set \*set,@@ -1679,6 +1685,7 @@ struct nftables\_pernet { struct list\_head notify\_list; struct mutex commit\_mutex; u64 table\_handle;+ u64 tstamp; unsigned int base\_seq; u8 validate\_state; unsigned int gc\_seq;@@ -1691,4 +1698,9 @@ static inline struct nftables\_pernet \*nft\_pernet(const struct net \*net) return net\_generic(net, nf\_tables\_net\_id); } +static inline u64 nft\_net\_tstamp(const struct net \*net)+{+ return nft\_pernet(net)->tstamp;+}+ #endif /\* \_NET\_NF\_TABLES\_H \*/diff --git a/net/netfilter/nf\_tables\_api.c b/net/netfilter/nf\_tables\_api.cindex 95c28893002e3a..04f4f75e74dae4 100644--- a/[net/netfilter/nf\_tables\_api.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nf_tables_api.c?id=9526393ed6c79003a1ae8b7844683467959960b4)+++ b/[net/netfilter/nf\_tables\_api.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nf_tables_api.c?id=0d40e8cb1d1f56a994cdd2e015af622fdca9ed4d)@@ -9185,6 +9185,7 @@ dead\_elem: struct nft\_trans\_gc \*nft\_trans\_gc\_catchall\_sync(struct nft\_trans\_gc \*gc) { struct nft\_set\_elem\_catchall \*catchall, \*next;+ u64 tstamp = nft\_net\_tstamp(gc->net); const struct nft\_set \*set = gc->set; struct nft\_set\_elem elem; struct nft\_set\_ext \*ext;@@ -9194,7 +9195,7 @@ struct nft\_trans\_gc \*nft\_trans\_gc\_catchall\_sync(struct nft\_trans\_gc \*gc) list\_for\_each\_entry\_safe(catchall, next, &set->catchall\_list, list) { ext = nft\_set\_elem\_ext(set, catchall->elem); - if (!nft\_set\_elem\_expired(ext))+ if (!\_\_nft\_set\_elem\_expired(ext, tstamp)) continue;  gc = nft\_trans\_gc\_queue\_sync(gc, GFP\_KERNEL);@@ -9946,6 +9947,7 @@ static bool nf\_tables\_valid\_genid(struct net \*net, u32 genid) bool genid\_ok;  mutex\_lock(&nft\_net->commit\_mutex);+ nft\_net->tstamp = get\_jiffies\_64();  genid\_ok = genid == 0 || nft\_net->base\_seq == genid; if (!genid\_ok)diff --git a/net/netfilter/nft\_set\_hash.c b/net/netfilter/nft\_set\_hash.cindex 2013de934cef09..1fd3b413350dcc 100644--- a/[net/netfilter/nft\_set\_hash.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_hash.c?id=9526393ed6c79003a1ae8b7844683467959960b4)+++ b/[net/netfilter/nft\_set\_hash.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_hash.c?id=0d40e8cb1d1f56a994cdd2e015af622fdca9ed4d)@@ -35,6 +35,7 @@ struct nft\_rhash\_cmp\_arg { const struct nft\_set \*set; const u32 \*key; u8 genmask;+ u64 tstamp; };  static inline u32 nft\_rhash\_key(const void \*data, u32 len, u32 seed)@@ -61,7 +62,7 @@ static inline int nft\_rhash\_cmp(struct rhashtable\_compare\_arg \*arg, return 1; if (nft\_set\_elem\_is\_dead(&he->ext)) return 1;- if (nft\_set\_elem\_expired(&he->ext))+ if (\_\_nft\_set\_elem\_expired(&he->ext, x->tstamp)) return 1; if (!nft\_set\_elem\_active(&he->ext, x->genmask)) return 1;@@ -86,6 +87,7 @@ bool nft\_rhash\_lookup(const struct net \*net, const struct nft\_set \*set, .genmask = nft\_genmask\_cur(net), .set = set, .key = key,+ .tstamp = get\_jiffies\_64(), };  he = rhashtable\_lookup(&priv->ht, &arg, nft\_rhash\_params);@@ -104,6 +106,7 @@ static void \*nft\_rhash\_get(const struct net \*net, const struct nft\_set \*set, .genmask = nft\_genmask\_cur(net), .set = set, .key = elem->key.val.data,+ .tstamp = get\_jiffies\_64(), };  he = rhashtable\_lookup(&priv->ht, &arg, nft\_rhash\_params);@@ -127,6 +130,7 @@ static bool nft\_rhash\_update(struct nft\_set \*set, const u32 \*key, .genmask = NFT\_GENMASK\_ANY, .set = set, .key = key,+ .tstamp = get\_jiffies\_64(), };  he = rhashtable\_lookup(&priv->ht, &arg, nft\_rhash\_params);@@ -170,6 +174,7 @@ static int nft\_rhash\_insert(const struct net \*net, const struct nft\_set \*set, .genmask = nft\_genmask\_next(net), .set = set, .key = elem->key.val.data,+ .tstamp = nft\_net\_tstamp(net), }; struct nft\_rhash\_elem \*prev; @@ -212,6 +217,7 @@ static void \*nft\_rhash\_deactivate(const struct net \*net, .genmask = nft\_genmask\_next(net), .set = set, .key = elem->key.val.data,+ .tstamp = nft\_net\_tstamp(net), };  rcu\_read\_lock();diff --git a/net/netfilter/nft\_set\_pipapo.c b/net/netfilter/nft\_set\_pipapo.cindex 8b1a88a16e5c1f..d9c1c467ea6848 100644--- a/[net/netfilter/nft\_set\_pipapo.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_pipapo.c?id=9526393ed6c79003a1ae8b7844683467959960b4)+++ b/[net/netfilter/nft\_set\_pipapo.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_pipapo.c?id=0d40e8cb1d1f56a994cdd2e015af622fdca9ed4d)@@ -504,6 +504,7 @@ out: \* @set: nftables API set representation \* @data: Key data to be matched against existing elements \* @genmask: If set, check that element is active in given genmask+ \* @tstamp: timestamp to check for expired elements \* \* This is essentially the same as the lookup function, except that it matches \* key data against the uncommitted copy and doesn't use preallocated maps for@@ -513,7 +514,8 @@ out: \*/ static struct nft\_pipapo\_elem \*pipapo\_get(const struct net \*net, const struct nft\_set \*set,- const u8 \*data, u8 genmask)+ const u8 \*data, u8 genmask,+ u64 tstamp) { struct nft\_pipapo\_elem \*ret = ERR\_PTR(-ENOENT); struct nft\_pipapo \*priv = nft\_set\_priv(set);@@ -568,7 +570,7 @@ next\_match: goto out;  if (last) {- if (nft\_set\_elem\_expired(&f->mt[b].e->ext))+ if (\_\_nft\_set\_elem\_expired(&f->mt[b].e->ext, tstamp)) goto next\_match; if ((genmask && !nft\_set\_elem\_active(&f->mt[b].e->ext, genmask)))@@ -605,7 +607,7 @@ static void \*nft\_pipapo\_get(const struct net \*net, const struct nft\_set \*set, const struct nft\_set\_elem \*elem, unsigned int flags) { return pipapo\_get(net, set, (const u8 \*)elem->key.val.data,- nft\_genmask\_cur(net));+ nft\_genmask\_cur(net), get\_jiffies\_64()); }  /\*\*@@ -1199,6 +1201,7 @@ static int nft\_pipapo\_insert(const struct net \*net, const struct nft\_set \*set, struct nft\_pipapo \*priv = nft\_set\_priv(set); struct nft\_pipapo\_match \*m = priv->clone; u8 genmask = nft\_genmask\_next(net);+ u64 tstamp = nft\_net\_tstamp(net); struct nft\_pipapo\_field \*f; const u8 \*start\_p, \*end\_p; int i, bsize\_max, err = 0;@@ -1208,7 +1211,7 @@ static int nft\_pipapo\_insert(const struct net \*net, const struct nft\_set \*set, else end = start; - dup = pipapo\_get(net, set, start, genmask);+ dup = pipapo\_get(net, set, start, genmask, tstamp); if (!IS\_ERR(dup)) { /\* Check if we already have the same exact entry \*/ const struct nft\_data \*dup\_key, \*dup\_end;@@ -1230,7 +1233,7 @@ static int nft\_pipapo\_insert(const struct net \*net, const struct nft\_set \*set,  if (PTR\_ERR(dup) == -ENOENT) { /\* Look for partially overlapping entries \*/- dup = pipapo\_get(net, set, end, nft\_genmask\_next(net));+ dup = pipapo\_get(net, set, end, nft\_genmask\_next(net), tstamp); }  if (PTR\_ERR(dup) != -ENOENT) {@@ -1583,6 +1586,7 @@ static void pipapo\_gc(const struct nft\_set \*\_set, struct nft\_pipapo\_match \*m) struct nft\_set \*set = (struct nft\_set \*) \_set; struct nft\_pipapo \*priv = nft\_set\_priv(set); struct net \*net = read\_pnet(&set->net);+ u64 tstamp = nft\_net\_tstamp(net); int rules\_f0, first\_rule = 0; struct nft\_pipapo\_elem \*e; struct nft\_trans\_gc \*gc;@@ -1617,7 +1621,7 @@ static void pipapo\_gc(const struct nft\_set \*\_set, struct nft\_pipapo\_match \*m) /\* synchronous gc never fails, there is no need to set on \* NFT\_SET\_ELEM\_DEAD\_BIT. \*/- if (nft\_set\_elem\_expired(&e->ext)) {+ if (\_\_nft\_set\_elem\_expired(&e->ext, tstamp)) { priv->dirty = true;  gc = nft\_trans\_gc\_queue\_sync(gc, GFP\_ATOMIC);@@ -1788,7 +1792,7 @@ static void \*pipapo\_deactivate(const struct net \*net, const struct nft\_set \*set, { struct nft\_pipapo\_elem \*e; - e = pipapo\_get(net, set, data, nft\_genmask\_next(net));+ e = pipapo\_get(net, set, data, nft\_genmask\_next(net), nft\_net\_tstamp(net)); if (IS\_ERR(e)) return NULL; diff --git a/net/netfilter/nft\_set\_rbtree.c b/net/netfilter/nft\_set\_rbtree.cindex 5bf5572e945cc3..021d9e76129a5e 100644--- a/[net/netfilter/nft\_set\_rbtree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_rbtree.c?id=9526393ed6c79003a1ae8b7844683467959960b4)+++ b/[net/netfilter/nft\_set\_rbtree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_rbtree.c?id=0d40e8cb1d1f56a994cdd2e015af622fdca9ed4d)@@ -314,6 +314,7 @@ static int \_\_nft\_rbtree\_insert(const struct net \*net, const struct nft\_set \*set, struct nft\_rbtree \*priv = nft\_set\_priv(set); u8 cur\_genmask = nft\_genmask\_cur(net); u8 genmask = nft\_genmask\_next(net);+ u64 tstamp = nft\_net\_tstamp(net); int d;  /\* Descend the tree to search for an existing element greater than the@@ -361,7 +362,7 @@ static int \_\_nft\_rbtree\_insert(const struct net \*net, const struct nft\_set \*set, /\* perform garbage collection to avoid bogus overlap reports \* but skip new elements in this transaction. \*/- if (nft\_set\_elem\_expired(&rbe->ext) &&+ if (\_\_nft\_set\_elem\_expired(&rbe->ext, tstamp) && nft\_set\_elem\_active(&rbe->ext, cur\_genmask)) { const struct nft\_rbtree\_elem \*removed\_end; @@ -548,6 +549,7 @@ static void \*nft\_rbtree\_deactivate(const struct net \*net, const struct rb\_node \*parent = priv->root.rb\_node; struct nft\_rbtree\_elem \*rbe, \*this = elem->priv; u8 genmask = nft\_genmask\_next(net);+ u64 tstamp = nft\_net\_tstamp(net); int d;  while (parent != NULL) {@@ -568,7 +570,7 @@ static void \*nft\_rbtree\_deactivate(const struct net \*net, nft\_rbtree\_interval\_end(this)) { parent = parent->rb\_right; continue;- } else if (nft\_set\_elem\_expired(&rbe->ext)) {+ } else if (\_\_nft\_set\_elem\_expired(&rbe->ext, tstamp)) { break; } else if (!nft\_set\_elem\_active(&rbe->ext, genmask)) { parent = parent->rb\_left; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 14:20:43 +0000



=== Content from git.kernel.org_42c6772b_20250111_142206.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=383182db8d58c4237772ba0764cded4938a235c3)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=383182db8d58c4237772ba0764cded4938a235c3)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=383182db8d58c4237772ba0764cded4938a235c3)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=383182db8d58c4237772ba0764cded4938a235c3)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Pablo Neira Ayuso <pablo@netfilter.org> | 2024-02-06 00:11:40 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-02-16 19:14:25 +0100 |
| commit | [383182db8d58c4237772ba0764cded4938a235c3](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=383182db8d58c4237772ba0764cded4938a235c3) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=383182db8d58c4237772ba0764cded4938a235c3)) | |
| tree | [bd4d3fb16ba20588b127b2777282aa2d516513ce](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=383182db8d58c4237772ba0764cded4938a235c3) | |
| parent | [fc46e23da74588753676e58ca5d3100a68a5632a](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=fc46e23da74588753676e58ca5d3100a68a5632a) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=383182db8d58c4237772ba0764cded4938a235c3&id2=fc46e23da74588753676e58ca5d3100a68a5632a)) | |
| download | [linux-383182db8d58c4237772ba0764cded4938a235c3.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-383182db8d58c4237772ba0764cded4938a235c3.tar.gz) | |

netfilter: nf\_tables: use timestamp to check for set element timeout[ Upstream commit 7395dfacfff65e9938ac0889dafa1ab01e987d15 ]
Add a timestamp field at the beginning of the transaction, store it
in the nftables per-netns area.
Update set backend .insert, .deactivate and sync gc path to use the
timestamp, this avoids that an element expires while control plane
transaction is still unfinished.
.lookup and .update, which are used from packet path, still use the
current time to check if the element has expired. And .get path and dump
also since this runs lockless under rcu read size lock. Then, there is
async gc which also needs to check the current time since it runs
asynchronously from a workqueue.
Fixes: c3e1b005ed1c ("netfilter: nf\_tables: add set element timeout support")
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=383182db8d58c4237772ba0764cded4938a235c3)

| -rw-r--r-- | [include/net/netfilter/nf\_tables.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/netfilter/nf_tables.h?id=383182db8d58c4237772ba0764cded4938a235c3) | 16 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/netfilter/nf\_tables\_api.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nf_tables_api.c?id=383182db8d58c4237772ba0764cded4938a235c3) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/netfilter/nft\_set\_hash.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nft_set_hash.c?id=383182db8d58c4237772ba0764cded4938a235c3) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/netfilter/nft\_set\_pipapo.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nft_set_pipapo.c?id=383182db8d58c4237772ba0764cded4938a235c3) | 18 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/netfilter/nft\_set\_rbtree.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nft_set_rbtree.c?id=383182db8d58c4237772ba0764cded4938a235c3) | 11 | |  |  |  | | --- | --- | --- | |

5 files changed, 42 insertions, 15 deletions

| diff --git a/include/net/netfilter/nf\_tables.h b/include/net/netfilter/nf\_tables.hindex 4e8ecabc5f25cc..62013d01841156 100644--- a/[include/net/netfilter/nf\_tables.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/netfilter/nf_tables.h?id=fc46e23da74588753676e58ca5d3100a68a5632a)+++ b/[include/net/netfilter/nf\_tables.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/netfilter/nf_tables.h?id=383182db8d58c4237772ba0764cded4938a235c3)@@ -798,10 +798,16 @@ static inline struct nft\_set\_elem\_expr \*nft\_set\_ext\_expr(const struct nft\_set\_ex return nft\_set\_ext(ext, NFT\_SET\_EXT\_EXPRESSIONS); } -static inline bool nft\_set\_elem\_expired(const struct nft\_set\_ext \*ext)+static inline bool \_\_nft\_set\_elem\_expired(const struct nft\_set\_ext \*ext,+ u64 tstamp) { return nft\_set\_ext\_exists(ext, NFT\_SET\_EXT\_EXPIRATION) &&- time\_is\_before\_eq\_jiffies64(\*nft\_set\_ext\_expiration(ext));+ time\_after\_eq64(tstamp, \*nft\_set\_ext\_expiration(ext));+}++static inline bool nft\_set\_elem\_expired(const struct nft\_set\_ext \*ext)+{+ return \_\_nft\_set\_elem\_expired(ext, get\_jiffies\_64()); }  static inline struct nft\_set\_ext \*nft\_set\_elem\_ext(const struct nft\_set \*set,@@ -1750,6 +1756,7 @@ struct nftables\_pernet { struct list\_head notify\_list; struct mutex commit\_mutex; u64 table\_handle;+ u64 tstamp; unsigned int base\_seq; unsigned int gc\_seq; u8 validate\_state;@@ -1762,6 +1769,11 @@ static inline struct nftables\_pernet \*nft\_pernet(const struct net \*net) return net\_generic(net, nf\_tables\_net\_id); } +static inline u64 nft\_net\_tstamp(const struct net \*net)+{+ return nft\_pernet(net)->tstamp;+}+ #define \_\_NFT\_REDUCE\_READONLY 1UL #define NFT\_REDUCE\_READONLY (void \*)\_\_NFT\_REDUCE\_READONLY diff --git a/net/netfilter/nf\_tables\_api.c b/net/netfilter/nf\_tables\_api.cindex 0e07f110a539bf..04c5aa4debc740 100644--- a/[net/netfilter/nf\_tables\_api.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nf_tables_api.c?id=fc46e23da74588753676e58ca5d3100a68a5632a)+++ b/[net/netfilter/nf\_tables\_api.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nf_tables_api.c?id=383182db8d58c4237772ba0764cded4938a235c3)@@ -9744,6 +9744,7 @@ dead\_elem: struct nft\_trans\_gc \*nft\_trans\_gc\_catchall\_sync(struct nft\_trans\_gc \*gc) { struct nft\_set\_elem\_catchall \*catchall, \*next;+ u64 tstamp = nft\_net\_tstamp(gc->net); const struct nft\_set \*set = gc->set; struct nft\_elem\_priv \*elem\_priv; struct nft\_set\_ext \*ext;@@ -9753,7 +9754,7 @@ struct nft\_trans\_gc \*nft\_trans\_gc\_catchall\_sync(struct nft\_trans\_gc \*gc) list\_for\_each\_entry\_safe(catchall, next, &set->catchall\_list, list) { ext = nft\_set\_elem\_ext(set, catchall->elem); - if (!nft\_set\_elem\_expired(ext))+ if (!\_\_nft\_set\_elem\_expired(ext, tstamp)) continue;  gc = nft\_trans\_gc\_queue\_sync(gc, GFP\_KERNEL);@@ -10539,6 +10540,7 @@ static bool nf\_tables\_valid\_genid(struct net \*net, u32 genid) bool genid\_ok;  mutex\_lock(&nft\_net->commit\_mutex);+ nft\_net->tstamp = get\_jiffies\_64();  genid\_ok = genid == 0 || nft\_net->base\_seq == genid; if (!genid\_ok)diff --git a/net/netfilter/nft\_set\_hash.c b/net/netfilter/nft\_set\_hash.cindex 6c2061bfdae6c3..6968a3b342367c 100644--- a/[net/netfilter/nft\_set\_hash.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_hash.c?id=fc46e23da74588753676e58ca5d3100a68a5632a)+++ b/[net/netfilter/nft\_set\_hash.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_hash.c?id=383182db8d58c4237772ba0764cded4938a235c3)@@ -36,6 +36,7 @@ struct nft\_rhash\_cmp\_arg { const struct nft\_set \*set; const u32 \*key; u8 genmask;+ u64 tstamp; };  static inline u32 nft\_rhash\_key(const void \*data, u32 len, u32 seed)@@ -62,7 +63,7 @@ static inline int nft\_rhash\_cmp(struct rhashtable\_compare\_arg \*arg, return 1; if (nft\_set\_elem\_is\_dead(&he->ext)) return 1;- if (nft\_set\_elem\_expired(&he->ext))+ if (\_\_nft\_set\_elem\_expired(&he->ext, x->tstamp)) return 1; if (!nft\_set\_elem\_active(&he->ext, x->genmask)) return 1;@@ -87,6 +88,7 @@ bool nft\_rhash\_lookup(const struct net \*net, const struct nft\_set \*set, .genmask = nft\_genmask\_cur(net), .set = set, .key = key,+ .tstamp = get\_jiffies\_64(), };  he = rhashtable\_lookup(&priv->ht, &arg, nft\_rhash\_params);@@ -106,6 +108,7 @@ nft\_rhash\_get(const struct net \*net, const struct nft\_set \*set, .genmask = nft\_genmask\_cur(net), .set = set, .key = elem->key.val.data,+ .tstamp = get\_jiffies\_64(), };  he = rhashtable\_lookup(&priv->ht, &arg, nft\_rhash\_params);@@ -131,6 +134,7 @@ static bool nft\_rhash\_update(struct nft\_set \*set, const u32 \*key, .genmask = NFT\_GENMASK\_ANY, .set = set, .key = key,+ .tstamp = get\_jiffies\_64(), };  he = rhashtable\_lookup(&priv->ht, &arg, nft\_rhash\_params);@@ -175,6 +179,7 @@ static int nft\_rhash\_insert(const struct net \*net, const struct nft\_set \*set, .genmask = nft\_genmask\_next(net), .set = set, .key = elem->key.val.data,+ .tstamp = nft\_net\_tstamp(net), }; struct nft\_rhash\_elem \*prev; @@ -216,6 +221,7 @@ nft\_rhash\_deactivate(const struct net \*net, const struct nft\_set \*set, .genmask = nft\_genmask\_next(net), .set = set, .key = elem->key.val.data,+ .tstamp = nft\_net\_tstamp(net), };  rcu\_read\_lock();diff --git a/net/netfilter/nft\_set\_pipapo.c b/net/netfilter/nft\_set\_pipapo.cindex a65617cd8e2e5a..ffce43e14561af 100644--- a/[net/netfilter/nft\_set\_pipapo.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_pipapo.c?id=fc46e23da74588753676e58ca5d3100a68a5632a)+++ b/[net/netfilter/nft\_set\_pipapo.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_pipapo.c?id=383182db8d58c4237772ba0764cded4938a235c3)@@ -504,6 +504,7 @@ out: \* @set: nftables API set representation \* @data: Key data to be matched against existing elements \* @genmask: If set, check that element is active in given genmask+ \* @tstamp: timestamp to check for expired elements \* \* This is essentially the same as the lookup function, except that it matches \* key data against the uncommitted copy and doesn't use preallocated maps for@@ -513,7 +514,8 @@ out: \*/ static struct nft\_pipapo\_elem \*pipapo\_get(const struct net \*net, const struct nft\_set \*set,- const u8 \*data, u8 genmask)+ const u8 \*data, u8 genmask,+ u64 tstamp) { struct nft\_pipapo\_elem \*ret = ERR\_PTR(-ENOENT); struct nft\_pipapo \*priv = nft\_set\_priv(set);@@ -566,7 +568,7 @@ next\_match: goto out;  if (last) {- if (nft\_set\_elem\_expired(&f->mt[b].e->ext))+ if (\_\_nft\_set\_elem\_expired(&f->mt[b].e->ext, tstamp)) goto next\_match; if ((genmask && !nft\_set\_elem\_active(&f->mt[b].e->ext, genmask)))@@ -606,7 +608,7 @@ nft\_pipapo\_get(const struct net \*net, const struct nft\_set \*set, struct nft\_pipapo\_elem \*e;  e = pipapo\_get(net, set, (const u8 \*)elem->key.val.data,- nft\_genmask\_cur(net));+ nft\_genmask\_cur(net), get\_jiffies\_64()); if (IS\_ERR(e)) return ERR\_CAST(e); @@ -1173,6 +1175,7 @@ static int nft\_pipapo\_insert(const struct net \*net, const struct nft\_set \*set, struct nft\_pipapo\_match \*m = priv->clone; u8 genmask = nft\_genmask\_next(net); struct nft\_pipapo\_elem \*e, \*dup;+ u64 tstamp = nft\_net\_tstamp(net); struct nft\_pipapo\_field \*f; const u8 \*start\_p, \*end\_p; int i, bsize\_max, err = 0;@@ -1182,7 +1185,7 @@ static int nft\_pipapo\_insert(const struct net \*net, const struct nft\_set \*set, else end = start; - dup = pipapo\_get(net, set, start, genmask);+ dup = pipapo\_get(net, set, start, genmask, tstamp); if (!IS\_ERR(dup)) { /\* Check if we already have the same exact entry \*/ const struct nft\_data \*dup\_key, \*dup\_end;@@ -1204,7 +1207,7 @@ static int nft\_pipapo\_insert(const struct net \*net, const struct nft\_set \*set,  if (PTR\_ERR(dup) == -ENOENT) { /\* Look for partially overlapping entries \*/- dup = pipapo\_get(net, set, end, nft\_genmask\_next(net));+ dup = pipapo\_get(net, set, end, nft\_genmask\_next(net), tstamp); }  if (PTR\_ERR(dup) != -ENOENT) {@@ -1560,6 +1563,7 @@ static void pipapo\_gc(struct nft\_set \*set, struct nft\_pipapo\_match \*m) { struct nft\_pipapo \*priv = nft\_set\_priv(set); struct net \*net = read\_pnet(&set->net);+ u64 tstamp = nft\_net\_tstamp(net); int rules\_f0, first\_rule = 0; struct nft\_pipapo\_elem \*e; struct nft\_trans\_gc \*gc;@@ -1594,7 +1598,7 @@ static void pipapo\_gc(struct nft\_set \*set, struct nft\_pipapo\_match \*m) /\* synchronous gc never fails, there is no need to set on \* NFT\_SET\_ELEM\_DEAD\_BIT. \*/- if (nft\_set\_elem\_expired(&e->ext)) {+ if (\_\_nft\_set\_elem\_expired(&e->ext, tstamp)) { priv->dirty = true;  gc = nft\_trans\_gc\_queue\_sync(gc, GFP\_ATOMIC);@@ -1769,7 +1773,7 @@ static void \*pipapo\_deactivate(const struct net \*net, const struct nft\_set \*set, { struct nft\_pipapo\_elem \*e; - e = pipapo\_get(net, set, data, nft\_genmask\_next(net));+ e = pipapo\_get(net, set, data, nft\_genmask\_next(net), nft\_net\_tstamp(net)); if (IS\_ERR(e)) return NULL; diff --git a/net/netfilter/nft\_set\_rbtree.c b/net/netfilter/nft\_set\_rbtree.cindex baa3fea4fe65c8..5fd74f993988f0 100644--- a/[net/netfilter/nft\_set\_rbtree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_rbtree.c?id=fc46e23da74588753676e58ca5d3100a68a5632a)+++ b/[net/netfilter/nft\_set\_rbtree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_rbtree.c?id=383182db8d58c4237772ba0764cded4938a235c3)@@ -313,6 +313,7 @@ static int \_\_nft\_rbtree\_insert(const struct net \*net, const struct nft\_set \*set, struct nft\_rbtree \*priv = nft\_set\_priv(set); u8 cur\_genmask = nft\_genmask\_cur(net); u8 genmask = nft\_genmask\_next(net);+ u64 tstamp = nft\_net\_tstamp(net); int d;  /\* Descend the tree to search for an existing element greater than the@@ -360,7 +361,7 @@ static int \_\_nft\_rbtree\_insert(const struct net \*net, const struct nft\_set \*set, /\* perform garbage collection to avoid bogus overlap reports \* but skip new elements in this transaction. \*/- if (nft\_set\_elem\_expired(&rbe->ext) &&+ if (\_\_nft\_set\_elem\_expired(&rbe->ext, tstamp) && nft\_set\_elem\_active(&rbe->ext, cur\_genmask)) { const struct nft\_rbtree\_elem \*removed\_end; @@ -551,6 +552,7 @@ nft\_rbtree\_deactivate(const struct net \*net, const struct nft\_set \*set, const struct nft\_rbtree \*priv = nft\_set\_priv(set); const struct rb\_node \*parent = priv->root.rb\_node; u8 genmask = nft\_genmask\_next(net);+ u64 tstamp = nft\_net\_tstamp(net); int d;  while (parent != NULL) {@@ -571,7 +573,7 @@ nft\_rbtree\_deactivate(const struct net \*net, const struct nft\_set \*set, nft\_rbtree\_interval\_end(this)) { parent = parent->rb\_right; continue;- } else if (nft\_set\_elem\_expired(&rbe->ext)) {+ } else if (\_\_nft\_set\_elem\_expired(&rbe->ext, tstamp)) { break; } else if (!nft\_set\_elem\_active(&rbe->ext, genmask)) { parent = parent->rb\_left;@@ -624,9 +626,10 @@ static void nft\_rbtree\_gc(struct nft\_set \*set) { struct nft\_rbtree \*priv = nft\_set\_priv(set); struct nft\_rbtree\_elem \*rbe, \*rbe\_end = NULL;+ struct net \*net = read\_pnet(&set->net);+ u64 tstamp = nft\_net\_tstamp(net); struct rb\_node \*node, \*next; struct nft\_trans\_gc \*gc;- struct net \*net;  set = nft\_set\_container\_of(priv); net = read\_pnet(&set->net);@@ -648,7 +651,7 @@ static void nft\_rbtree\_gc(struct nft\_set \*set) rbe\_end = rbe; continue; }- if (!nft\_set\_elem\_expired(&rbe->ext))+ if (!\_\_nft\_set\_elem\_expired(&rbe->ext, tstamp)) continue;  gc = nft\_trans\_gc\_queue\_sync(gc, GFP\_KERNEL); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 14:20:44 +0000



=== Content from git.kernel.org_f5ec4a3b_20250111_142207.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=7395dfacfff65e9938ac0889dafa1ab01e987d15)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=7395dfacfff65e9938ac0889dafa1ab01e987d15)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7395dfacfff65e9938ac0889dafa1ab01e987d15)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7395dfacfff65e9938ac0889dafa1ab01e987d15)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Pablo Neira Ayuso <pablo@netfilter.org> | 2024-02-06 00:11:40 +0100 |
| --- | --- | --- |
| committer | Pablo Neira Ayuso <pablo@netfilter.org> | 2024-02-08 12:10:19 +0100 |
| commit | [7395dfacfff65e9938ac0889dafa1ab01e987d15](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7395dfacfff65e9938ac0889dafa1ab01e987d15) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=7395dfacfff65e9938ac0889dafa1ab01e987d15)) | |
| tree | [7fc7c3c79a50488229817f9555365262da45cb3b](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=7395dfacfff65e9938ac0889dafa1ab01e987d15) | |
| parent | [38ed1c7062ada30d7c11e7a7acc749bf27aa14aa](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=38ed1c7062ada30d7c11e7a7acc749bf27aa14aa) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7395dfacfff65e9938ac0889dafa1ab01e987d15&id2=38ed1c7062ada30d7c11e7a7acc749bf27aa14aa)) | |
| download | [linux-7395dfacfff65e9938ac0889dafa1ab01e987d15.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-7395dfacfff65e9938ac0889dafa1ab01e987d15.tar.gz) | |

netfilter: nf\_tables: use timestamp to check for set element timeoutAdd a timestamp field at the beginning of the transaction, store it
in the nftables per-netns area.
Update set backend .insert, .deactivate and sync gc path to use the
timestamp, this avoids that an element expires while control plane
transaction is still unfinished.
.lookup and .update, which are used from packet path, still use the
current time to check if the element has expired. And .get path and dump
also since this runs lockless under rcu read size lock. Then, there is
async gc which also needs to check the current time since it runs
asynchronously from a workqueue.
Fixes: c3e1b005ed1c ("netfilter: nf\_tables: add set element timeout support")
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7395dfacfff65e9938ac0889dafa1ab01e987d15)

| -rw-r--r-- | [include/net/netfilter/nf\_tables.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/netfilter/nf_tables.h?id=7395dfacfff65e9938ac0889dafa1ab01e987d15) | 16 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/netfilter/nf\_tables\_api.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nf_tables_api.c?id=7395dfacfff65e9938ac0889dafa1ab01e987d15) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/netfilter/nft\_set\_hash.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nft_set_hash.c?id=7395dfacfff65e9938ac0889dafa1ab01e987d15) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/netfilter/nft\_set\_pipapo.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nft_set_pipapo.c?id=7395dfacfff65e9938ac0889dafa1ab01e987d15) | 18 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/netfilter/nft\_set\_rbtree.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nft_set_rbtree.c?id=7395dfacfff65e9938ac0889dafa1ab01e987d15) | 11 | |  |  |  | | --- | --- | --- | |

5 files changed, 42 insertions, 15 deletions

| diff --git a/include/net/netfilter/nf\_tables.h b/include/net/netfilter/nf\_tables.hindex 001226c3462156..510244cc0f8f0e 100644--- a/[include/net/netfilter/nf\_tables.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/netfilter/nf_tables.h?id=38ed1c7062ada30d7c11e7a7acc749bf27aa14aa)+++ b/[include/net/netfilter/nf\_tables.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/netfilter/nf_tables.h?id=7395dfacfff65e9938ac0889dafa1ab01e987d15)@@ -808,10 +808,16 @@ static inline struct nft\_set\_elem\_expr \*nft\_set\_ext\_expr(const struct nft\_set\_ex return nft\_set\_ext(ext, NFT\_SET\_EXT\_EXPRESSIONS); } -static inline bool nft\_set\_elem\_expired(const struct nft\_set\_ext \*ext)+static inline bool \_\_nft\_set\_elem\_expired(const struct nft\_set\_ext \*ext,+ u64 tstamp) { return nft\_set\_ext\_exists(ext, NFT\_SET\_EXT\_EXPIRATION) &&- time\_is\_before\_eq\_jiffies64(\*nft\_set\_ext\_expiration(ext));+ time\_after\_eq64(tstamp, \*nft\_set\_ext\_expiration(ext));+}++static inline bool nft\_set\_elem\_expired(const struct nft\_set\_ext \*ext)+{+ return \_\_nft\_set\_elem\_expired(ext, get\_jiffies\_64()); }  static inline struct nft\_set\_ext \*nft\_set\_elem\_ext(const struct nft\_set \*set,@@ -1779,6 +1785,7 @@ struct nftables\_pernet { struct list\_head notify\_list; struct mutex commit\_mutex; u64 table\_handle;+ u64 tstamp; unsigned int base\_seq; unsigned int gc\_seq; u8 validate\_state;@@ -1791,6 +1798,11 @@ static inline struct nftables\_pernet \*nft\_pernet(const struct net \*net) return net\_generic(net, nf\_tables\_net\_id); } +static inline u64 nft\_net\_tstamp(const struct net \*net)+{+ return nft\_pernet(net)->tstamp;+}+ #define \_\_NFT\_REDUCE\_READONLY 1UL #define NFT\_REDUCE\_READONLY (void \*)\_\_NFT\_REDUCE\_READONLY diff --git a/net/netfilter/nf\_tables\_api.c b/net/netfilter/nf\_tables\_api.cindex fc016befb46ffb..f8e3f70c35bd55 100644--- a/[net/netfilter/nf\_tables\_api.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nf_tables_api.c?id=38ed1c7062ada30d7c11e7a7acc749bf27aa14aa)+++ b/[net/netfilter/nf\_tables\_api.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nf_tables_api.c?id=7395dfacfff65e9938ac0889dafa1ab01e987d15)@@ -9827,6 +9827,7 @@ dead\_elem: struct nft\_trans\_gc \*nft\_trans\_gc\_catchall\_sync(struct nft\_trans\_gc \*gc) { struct nft\_set\_elem\_catchall \*catchall, \*next;+ u64 tstamp = nft\_net\_tstamp(gc->net); const struct nft\_set \*set = gc->set; struct nft\_elem\_priv \*elem\_priv; struct nft\_set\_ext \*ext;@@ -9836,7 +9837,7 @@ struct nft\_trans\_gc \*nft\_trans\_gc\_catchall\_sync(struct nft\_trans\_gc \*gc) list\_for\_each\_entry\_safe(catchall, next, &set->catchall\_list, list) { ext = nft\_set\_elem\_ext(set, catchall->elem); - if (!nft\_set\_elem\_expired(ext))+ if (!\_\_nft\_set\_elem\_expired(ext, tstamp)) continue;  gc = nft\_trans\_gc\_queue\_sync(gc, GFP\_KERNEL);@@ -10622,6 +10623,7 @@ static bool nf\_tables\_valid\_genid(struct net \*net, u32 genid) bool genid\_ok;  mutex\_lock(&nft\_net->commit\_mutex);+ nft\_net->tstamp = get\_jiffies\_64();  genid\_ok = genid == 0 || nft\_net->base\_seq == genid; if (!genid\_ok)diff --git a/net/netfilter/nft\_set\_hash.c b/net/netfilter/nft\_set\_hash.cindex 6c2061bfdae6c3..6968a3b342367c 100644--- a/[net/netfilter/nft\_set\_hash.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_hash.c?id=38ed1c7062ada30d7c11e7a7acc749bf27aa14aa)+++ b/[net/netfilter/nft\_set\_hash.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_hash.c?id=7395dfacfff65e9938ac0889dafa1ab01e987d15)@@ -36,6 +36,7 @@ struct nft\_rhash\_cmp\_arg { const struct nft\_set \*set; const u32 \*key; u8 genmask;+ u64 tstamp; };  static inline u32 nft\_rhash\_key(const void \*data, u32 len, u32 seed)@@ -62,7 +63,7 @@ static inline int nft\_rhash\_cmp(struct rhashtable\_compare\_arg \*arg, return 1; if (nft\_set\_elem\_is\_dead(&he->ext)) return 1;- if (nft\_set\_elem\_expired(&he->ext))+ if (\_\_nft\_set\_elem\_expired(&he->ext, x->tstamp)) return 1; if (!nft\_set\_elem\_active(&he->ext, x->genmask)) return 1;@@ -87,6 +88,7 @@ bool nft\_rhash\_lookup(const struct net \*net, const struct nft\_set \*set, .genmask = nft\_genmask\_cur(net), .set = set, .key = key,+ .tstamp = get\_jiffies\_64(), };  he = rhashtable\_lookup(&priv->ht, &arg, nft\_rhash\_params);@@ -106,6 +108,7 @@ nft\_rhash\_get(const struct net \*net, const struct nft\_set \*set, .genmask = nft\_genmask\_cur(net), .set = set, .key = elem->key.val.data,+ .tstamp = get\_jiffies\_64(), };  he = rhashtable\_lookup(&priv->ht, &arg, nft\_rhash\_params);@@ -131,6 +134,7 @@ static bool nft\_rhash\_update(struct nft\_set \*set, const u32 \*key, .genmask = NFT\_GENMASK\_ANY, .set = set, .key = key,+ .tstamp = get\_jiffies\_64(), };  he = rhashtable\_lookup(&priv->ht, &arg, nft\_rhash\_params);@@ -175,6 +179,7 @@ static int nft\_rhash\_insert(const struct net \*net, const struct nft\_set \*set, .genmask = nft\_genmask\_next(net), .set = set, .key = elem->key.val.data,+ .tstamp = nft\_net\_tstamp(net), }; struct nft\_rhash\_elem \*prev; @@ -216,6 +221,7 @@ nft\_rhash\_deactivate(const struct net \*net, const struct nft\_set \*set, .genmask = nft\_genmask\_next(net), .set = set, .key = elem->key.val.data,+ .tstamp = nft\_net\_tstamp(net), };  rcu\_read\_lock();diff --git a/net/netfilter/nft\_set\_pipapo.c b/net/netfilter/nft\_set\_pipapo.cindex f24ecdaa1c1edc..b17c1820341667 100644--- a/[net/netfilter/nft\_set\_pipapo.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_pipapo.c?id=38ed1c7062ada30d7c11e7a7acc749bf27aa14aa)+++ b/[net/netfilter/nft\_set\_pipapo.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_pipapo.c?id=7395dfacfff65e9938ac0889dafa1ab01e987d15)@@ -504,6 +504,7 @@ out: \* @set: nftables API set representation \* @data: Key data to be matched against existing elements \* @genmask: If set, check that element is active in given genmask+ \* @tstamp: timestamp to check for expired elements \* \* This is essentially the same as the lookup function, except that it matches \* key data against the uncommitted copy and doesn't use preallocated maps for@@ -513,7 +514,8 @@ out: \*/ static struct nft\_pipapo\_elem \*pipapo\_get(const struct net \*net, const struct nft\_set \*set,- const u8 \*data, u8 genmask)+ const u8 \*data, u8 genmask,+ u64 tstamp) { struct nft\_pipapo\_elem \*ret = ERR\_PTR(-ENOENT); struct nft\_pipapo \*priv = nft\_set\_priv(set);@@ -566,7 +568,7 @@ next\_match: goto out;  if (last) {- if (nft\_set\_elem\_expired(&f->mt[b].e->ext))+ if (\_\_nft\_set\_elem\_expired(&f->mt[b].e->ext, tstamp)) goto next\_match; if ((genmask && !nft\_set\_elem\_active(&f->mt[b].e->ext, genmask)))@@ -606,7 +608,7 @@ nft\_pipapo\_get(const struct net \*net, const struct nft\_set \*set, struct nft\_pipapo\_elem \*e;  e = pipapo\_get(net, set, (const u8 \*)elem->key.val.data,- nft\_genmask\_cur(net));+ nft\_genmask\_cur(net), get\_jiffies\_64()); if (IS\_ERR(e)) return ERR\_CAST(e); @@ -1173,6 +1175,7 @@ static int nft\_pipapo\_insert(const struct net \*net, const struct nft\_set \*set, struct nft\_pipapo\_match \*m = priv->clone; u8 genmask = nft\_genmask\_next(net); struct nft\_pipapo\_elem \*e, \*dup;+ u64 tstamp = nft\_net\_tstamp(net); struct nft\_pipapo\_field \*f; const u8 \*start\_p, \*end\_p; int i, bsize\_max, err = 0;@@ -1182,7 +1185,7 @@ static int nft\_pipapo\_insert(const struct net \*net, const struct nft\_set \*set, else end = start; - dup = pipapo\_get(net, set, start, genmask);+ dup = pipapo\_get(net, set, start, genmask, tstamp); if (!IS\_ERR(dup)) { /\* Check if we already have the same exact entry \*/ const struct nft\_data \*dup\_key, \*dup\_end;@@ -1204,7 +1207,7 @@ static int nft\_pipapo\_insert(const struct net \*net, const struct nft\_set \*set,  if (PTR\_ERR(dup) == -ENOENT) { /\* Look for partially overlapping entries \*/- dup = pipapo\_get(net, set, end, nft\_genmask\_next(net));+ dup = pipapo\_get(net, set, end, nft\_genmask\_next(net), tstamp); }  if (PTR\_ERR(dup) != -ENOENT) {@@ -1560,6 +1563,7 @@ static void pipapo\_gc(struct nft\_set \*set, struct nft\_pipapo\_match \*m) { struct nft\_pipapo \*priv = nft\_set\_priv(set); struct net \*net = read\_pnet(&set->net);+ u64 tstamp = nft\_net\_tstamp(net); int rules\_f0, first\_rule = 0; struct nft\_pipapo\_elem \*e; struct nft\_trans\_gc \*gc;@@ -1594,7 +1598,7 @@ static void pipapo\_gc(struct nft\_set \*set, struct nft\_pipapo\_match \*m) /\* synchronous gc never fails, there is no need to set on \* NFT\_SET\_ELEM\_DEAD\_BIT. \*/- if (nft\_set\_elem\_expired(&e->ext)) {+ if (\_\_nft\_set\_elem\_expired(&e->ext, tstamp)) { priv->dirty = true;  gc = nft\_trans\_gc\_queue\_sync(gc, GFP\_KERNEL);@@ -1769,7 +1773,7 @@ static void \*pipapo\_deactivate(const struct net \*net, const struct nft\_set \*set, { struct nft\_pipapo\_elem \*e; - e = pipapo\_get(net, set, data, nft\_genmask\_next(net));+ e = pipapo\_get(net, set, data, nft\_genmask\_next(net), nft\_net\_tstamp(net)); if (IS\_ERR(e)) return NULL; diff --git a/net/netfilter/nft\_set\_rbtree.c b/net/netfilter/nft\_set\_rbtree.cindex baa3fea4fe65c8..5fd74f993988f0 100644--- a/[net/netfilter/nft\_set\_rbtree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_rbtree.c?id=38ed1c7062ada30d7c11e7a7acc749bf27aa14aa)+++ b/[net/netfilter/nft\_set\_rbtree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_rbtree.c?id=7395dfacfff65e9938ac0889dafa1ab01e987d15)@@ -313,6 +313,7 @@ static int \_\_nft\_rbtree\_insert(const struct net \*net, const struct nft\_set \*set, struct nft\_rbtree \*priv = nft\_set\_priv(set); u8 cur\_genmask = nft\_genmask\_cur(net); u8 genmask = nft\_genmask\_next(net);+ u64 tstamp = nft\_net\_tstamp(net); int d;  /\* Descend the tree to search for an existing element greater than the@@ -360,7 +361,7 @@ static int \_\_nft\_rbtree\_insert(const struct net \*net, const struct nft\_set \*set, /\* perform garbage collection to avoid bogus overlap reports \* but skip new elements in this transaction. \*/- if (nft\_set\_elem\_expired(&rbe->ext) &&+ if (\_\_nft\_set\_elem\_expired(&rbe->ext, tstamp) && nft\_set\_elem\_active(&rbe->ext, cur\_genmask)) { const struct nft\_rbtree\_elem \*removed\_end; @@ -551,6 +552,7 @@ nft\_rbtree\_deactivate(const struct net \*net, const struct nft\_set \*set, const struct nft\_rbtree \*priv = nft\_set\_priv(set); const struct rb\_node \*parent = priv->root.rb\_node; u8 genmask = nft\_genmask\_next(net);+ u64 tstamp = nft\_net\_tstamp(net); int d;  while (parent != NULL) {@@ -571,7 +573,7 @@ nft\_rbtree\_deactivate(const struct net \*net, const struct nft\_set \*set, nft\_rbtree\_interval\_end(this)) { parent = parent->rb\_right; continue;- } else if (nft\_set\_elem\_expired(&rbe->ext)) {+ } else if (\_\_nft\_set\_elem\_expired(&rbe->ext, tstamp)) { break; } else if (!nft\_set\_elem\_active(&rbe->ext, genmask)) { parent = parent->rb\_left;@@ -624,9 +626,10 @@ static void nft\_rbtree\_gc(struct nft\_set \*set) { struct nft\_rbtree \*priv = nft\_set\_priv(set); struct nft\_rbtree\_elem \*rbe, \*rbe\_end = NULL;+ struct net \*net = read\_pnet(&set->net);+ u64 tstamp = nft\_net\_tstamp(net); struct rb\_node \*node, \*next; struct nft\_trans\_gc \*gc;- struct net \*net;  set = nft\_set\_container\_of(priv); net = read\_pnet(&set->net);@@ -648,7 +651,7 @@ static void nft\_rbtree\_gc(struct nft\_set \*set) rbe\_end = rbe; continue; }- if (!nft\_set\_elem\_expired(&rbe->ext))+ if (!\_\_nft\_set\_elem\_expired(&rbe->ext, tstamp)) continue;  gc = nft\_trans\_gc\_queue\_sync(gc, GFP\_KERNEL); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 14:20:44 +0000



=== Content from git.kernel.org_5733f6e4_20250111_142208.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=7b17de2a71e56c10335b565cc7ad238e6d984379)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=7b17de2a71e56c10335b565cc7ad238e6d984379)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7b17de2a71e56c10335b565cc7ad238e6d984379)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7b17de2a71e56c10335b565cc7ad238e6d984379)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Pablo Neira Ayuso <pablo@netfilter.org> | 2024-08-12 12:27:40 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-08-19 05:41:22 +0200 |
| commit | [7b17de2a71e56c10335b565cc7ad238e6d984379](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7b17de2a71e56c10335b565cc7ad238e6d984379) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=7b17de2a71e56c10335b565cc7ad238e6d984379)) | |
| tree | [793a13392aee487b21d1d7a28ef4efa0fdf37f55](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=7b17de2a71e56c10335b565cc7ad238e6d984379) | |
| parent | [191fc44395240130a4487c5270cc040ec2f01213](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=191fc44395240130a4487c5270cc040ec2f01213) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7b17de2a71e56c10335b565cc7ad238e6d984379&id2=191fc44395240130a4487c5270cc040ec2f01213)) | |
| download | [linux-7b17de2a71e56c10335b565cc7ad238e6d984379.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-7b17de2a71e56c10335b565cc7ad238e6d984379.tar.gz) | |

netfilter: nf\_tables: use timestamp to check for set element timeoutcommit 7395dfacfff65e9938ac0889dafa1ab01e987d15 upstream
Add a timestamp field at the beginning of the transaction, store it
in the nftables per-netns area.
Update set backend .insert, .deactivate and sync gc path to use the
timestamp, this avoids that an element expires while control plane
transaction is still unfinished.
.lookup and .update, which are used from packet path, still use the
current time to check if the element has expired. And .get path and dump
also since this runs lockless under rcu read size lock. Then, there is
async gc which also needs to check the current time since it runs
asynchronously from a workqueue.
[ NB: rbtree GC updates has been excluded because GC is asynchronous. ]
Fixes: c3e1b005ed1c ("netfilter: nf\_tables: add set element timeout support")
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7b17de2a71e56c10335b565cc7ad238e6d984379)

| -rw-r--r-- | [include/net/netfilter/nf\_tables.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/netfilter/nf_tables.h?id=7b17de2a71e56c10335b565cc7ad238e6d984379) | 21 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/netfilter/nf\_tables\_api.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nf_tables_api.c?id=7b17de2a71e56c10335b565cc7ad238e6d984379) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/netfilter/nft\_set\_hash.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nft_set_hash.c?id=7b17de2a71e56c10335b565cc7ad238e6d984379) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/netfilter/nft\_set\_pipapo.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nft_set_pipapo.c?id=7b17de2a71e56c10335b565cc7ad238e6d984379) | 18 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/netfilter/nft\_set\_rbtree.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nft_set_rbtree.c?id=7b17de2a71e56c10335b565cc7ad238e6d984379) | 6 | |  |  |  | | --- | --- | --- | |

5 files changed, 42 insertions, 12 deletions

| diff --git a/include/net/netfilter/nf\_tables.h b/include/net/netfilter/nf\_tables.hindex 2b99ee1303d925..dd7c310e721621 100644--- a/[include/net/netfilter/nf\_tables.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/netfilter/nf_tables.h?id=191fc44395240130a4487c5270cc040ec2f01213)+++ b/[include/net/netfilter/nf\_tables.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/netfilter/nf_tables.h?id=7b17de2a71e56c10335b565cc7ad238e6d984379)@@ -13,6 +13,7 @@ #include <net/netfilter/nf\_flow\_table.h> #include <net/netlink.h> #include <net/flow\_offload.h>+#include <net/netns/generic.h>  #define NFT\_MAX\_HOOKS (NF\_INET\_INGRESS + 1) @@ -686,10 +687,16 @@ static inline struct nft\_expr \*nft\_set\_ext\_expr(const struct nft\_set\_ext \*ext) return nft\_set\_ext(ext, NFT\_SET\_EXT\_EXPR); } -static inline bool nft\_set\_elem\_expired(const struct nft\_set\_ext \*ext)+static inline bool \_\_nft\_set\_elem\_expired(const struct nft\_set\_ext \*ext,+ u64 tstamp) { return nft\_set\_ext\_exists(ext, NFT\_SET\_EXT\_EXPIRATION) &&- time\_is\_before\_eq\_jiffies64(\*nft\_set\_ext\_expiration(ext));+ time\_after\_eq64(tstamp, \*nft\_set\_ext\_expiration(ext));+}++static inline bool nft\_set\_elem\_expired(const struct nft\_set\_ext \*ext)+{+ return \_\_nft\_set\_elem\_expired(ext, get\_jiffies\_64()); }  static inline struct nft\_set\_ext \*nft\_set\_elem\_ext(const struct nft\_set \*set,@@ -1580,9 +1587,19 @@ struct nftables\_pernet { struct list\_head module\_list; struct list\_head notify\_list; struct mutex commit\_mutex;+ u64 tstamp; unsigned int base\_seq; u8 validate\_state; unsigned int gc\_seq; }; +extern unsigned int nf\_tables\_net\_id;++static inline u64 nft\_net\_tstamp(const struct net \*net)+{+ struct nftables\_pernet \*nft\_net = net\_generic(net, nf\_tables\_net\_id);++ return nft\_net->tstamp;+}+ #endif /\* \_NET\_NF\_TABLES\_H \*/diff --git a/net/netfilter/nf\_tables\_api.c b/net/netfilter/nf\_tables\_api.cindex 0bc92edb7827ce..bf4c455474a6eb 100644--- a/[net/netfilter/nf\_tables\_api.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nf_tables_api.c?id=191fc44395240130a4487c5270cc040ec2f01213)+++ b/[net/netfilter/nf\_tables\_api.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nf_tables_api.c?id=7b17de2a71e56c10335b565cc7ad238e6d984379)@@ -9034,6 +9034,7 @@ static bool nf\_tables\_valid\_genid(struct net \*net, u32 genid) bool genid\_ok;  mutex\_lock(&nft\_net->commit\_mutex);+ nft\_net->tstamp = get\_jiffies\_64();  genid\_ok = genid == 0 || nft\_net->base\_seq == genid; if (!genid\_ok)diff --git a/net/netfilter/nft\_set\_hash.c b/net/netfilter/nft\_set\_hash.cindex f0a9ad1c4ea442..2499d25a5c85f2 100644--- a/[net/netfilter/nft\_set\_hash.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_hash.c?id=191fc44395240130a4487c5270cc040ec2f01213)+++ b/[net/netfilter/nft\_set\_hash.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_hash.c?id=7b17de2a71e56c10335b565cc7ad238e6d984379)@@ -38,6 +38,7 @@ struct nft\_rhash\_cmp\_arg { const struct nft\_set \*set; const u32 \*key; u8 genmask;+ u64 tstamp; };  static inline u32 nft\_rhash\_key(const void \*data, u32 len, u32 seed)@@ -64,7 +65,7 @@ static inline int nft\_rhash\_cmp(struct rhashtable\_compare\_arg \*arg, return 1; if (nft\_set\_elem\_is\_dead(&he->ext)) return 1;- if (nft\_set\_elem\_expired(&he->ext))+ if (\_\_nft\_set\_elem\_expired(&he->ext, x->tstamp)) return 1; if (!nft\_set\_elem\_active(&he->ext, x->genmask)) return 1;@@ -88,6 +89,7 @@ static bool nft\_rhash\_lookup(const struct net \*net, const struct nft\_set \*set, .genmask = nft\_genmask\_cur(net), .set = set, .key = key,+ .tstamp = get\_jiffies\_64(), };  he = rhashtable\_lookup(&priv->ht, &arg, nft\_rhash\_params);@@ -106,6 +108,7 @@ static void \*nft\_rhash\_get(const struct net \*net, const struct nft\_set \*set, .genmask = nft\_genmask\_cur(net), .set = set, .key = elem->key.val.data,+ .tstamp = get\_jiffies\_64(), };  he = rhashtable\_lookup(&priv->ht, &arg, nft\_rhash\_params);@@ -129,6 +132,7 @@ static bool nft\_rhash\_update(struct nft\_set \*set, const u32 \*key, .genmask = NFT\_GENMASK\_ANY, .set = set, .key = key,+ .tstamp = get\_jiffies\_64(), };  he = rhashtable\_lookup(&priv->ht, &arg, nft\_rhash\_params);@@ -172,6 +176,7 @@ static int nft\_rhash\_insert(const struct net \*net, const struct nft\_set \*set, .genmask = nft\_genmask\_next(net), .set = set, .key = elem->key.val.data,+ .tstamp = nft\_net\_tstamp(net), }; struct nft\_rhash\_elem \*prev; @@ -214,6 +219,7 @@ static void \*nft\_rhash\_deactivate(const struct net \*net, .genmask = nft\_genmask\_next(net), .set = set, .key = elem->key.val.data,+ .tstamp = nft\_net\_tstamp(net), };  rcu\_read\_lock();diff --git a/net/netfilter/nft\_set\_pipapo.c b/net/netfilter/nft\_set\_pipapo.cindex 5a8521abd8f5cc..9e0269e8501799 100644--- a/[net/netfilter/nft\_set\_pipapo.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_pipapo.c?id=191fc44395240130a4487c5270cc040ec2f01213)+++ b/[net/netfilter/nft\_set\_pipapo.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_pipapo.c?id=7b17de2a71e56c10335b565cc7ad238e6d984379)@@ -504,6 +504,7 @@ out: \* @set: nftables API set representation \* @data: Key data to be matched against existing elements \* @genmask: If set, check that element is active in given genmask+ \* @tstamp: timestamp to check for expired elements \* \* This is essentially the same as the lookup function, except that it matches \* key data against the uncommitted copy and doesn't use preallocated maps for@@ -513,7 +514,8 @@ out: \*/ static struct nft\_pipapo\_elem \*pipapo\_get(const struct net \*net, const struct nft\_set \*set,- const u8 \*data, u8 genmask)+ const u8 \*data, u8 genmask,+ u64 tstamp) { struct nft\_pipapo\_elem \*ret = ERR\_PTR(-ENOENT); struct nft\_pipapo \*priv = nft\_set\_priv(set);@@ -566,7 +568,7 @@ next\_match: goto out;  if (last) {- if (nft\_set\_elem\_expired(&f->mt[b].e->ext))+ if (\_\_nft\_set\_elem\_expired(&f->mt[b].e->ext, tstamp)) goto next\_match; if ((genmask && !nft\_set\_elem\_active(&f->mt[b].e->ext, genmask)))@@ -603,7 +605,7 @@ static void \*nft\_pipapo\_get(const struct net \*net, const struct nft\_set \*set, const struct nft\_set\_elem \*elem, unsigned int flags) { return pipapo\_get(net, set, (const u8 \*)elem->key.val.data,- nft\_genmask\_cur(net));+ nft\_genmask\_cur(net), get\_jiffies\_64()); }  /\*\*@@ -1197,6 +1199,7 @@ static int nft\_pipapo\_insert(const struct net \*net, const struct nft\_set \*set, struct nft\_pipapo \*priv = nft\_set\_priv(set); struct nft\_pipapo\_match \*m = priv->clone; u8 genmask = nft\_genmask\_next(net);+ u64 tstamp = nft\_net\_tstamp(net); struct nft\_pipapo\_field \*f; const u8 \*start\_p, \*end\_p; int i, bsize\_max, err = 0;@@ -1206,7 +1209,7 @@ static int nft\_pipapo\_insert(const struct net \*net, const struct nft\_set \*set, else end = start; - dup = pipapo\_get(net, set, start, genmask);+ dup = pipapo\_get(net, set, start, genmask, tstamp); if (!IS\_ERR(dup)) { /\* Check if we already have the same exact entry \*/ const struct nft\_data \*dup\_key, \*dup\_end;@@ -1228,7 +1231,7 @@ static int nft\_pipapo\_insert(const struct net \*net, const struct nft\_set \*set,  if (PTR\_ERR(dup) == -ENOENT) { /\* Look for partially overlapping entries \*/- dup = pipapo\_get(net, set, end, nft\_genmask\_next(net));+ dup = pipapo\_get(net, set, end, nft\_genmask\_next(net), tstamp); }  if (PTR\_ERR(dup) != -ENOENT) {@@ -1580,6 +1583,7 @@ static void pipapo\_gc(const struct nft\_set \*\_set, struct nft\_pipapo\_match \*m) struct nft\_set \*set = (struct nft\_set \*) \_set; struct nft\_pipapo \*priv = nft\_set\_priv(set); struct net \*net = read\_pnet(&set->net);+ u64 tstamp = nft\_net\_tstamp(net); int rules\_f0, first\_rule = 0; struct nft\_trans\_gc \*gc; @@ -1613,7 +1617,7 @@ static void pipapo\_gc(const struct nft\_set \*\_set, struct nft\_pipapo\_match \*m) /\* synchronous gc never fails, there is no need to set on \* NFT\_SET\_ELEM\_DEAD\_BIT. \*/- if (nft\_set\_elem\_expired(&e->ext)) {+ if (\_\_nft\_set\_elem\_expired(&e->ext, tstamp)) { priv->dirty = true;  gc = nft\_trans\_gc\_queue\_sync(gc, GFP\_ATOMIC);@@ -1772,7 +1776,7 @@ static void \*pipapo\_deactivate(const struct net \*net, const struct nft\_set \*set, { struct nft\_pipapo\_elem \*e; - e = pipapo\_get(net, set, data, nft\_genmask\_next(net));+ e = pipapo\_get(net, set, data, nft\_genmask\_next(net), nft\_net\_tstamp(net)); if (IS\_ERR(e)) return NULL; diff --git a/net/netfilter/nft\_set\_rbtree.c b/net/netfilter/nft\_set\_rbtree.cindex 18c0d163dc76cb..bbced30113e4e2 100644--- a/[net/netfilter/nft\_set\_rbtree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_rbtree.c?id=191fc44395240130a4487c5270cc040ec2f01213)+++ b/[net/netfilter/nft\_set\_rbtree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_rbtree.c?id=7b17de2a71e56c10335b565cc7ad238e6d984379)@@ -316,6 +316,7 @@ static int \_\_nft\_rbtree\_insert(const struct net \*net, const struct nft\_set \*set, struct nft\_rbtree \*priv = nft\_set\_priv(set); u8 cur\_genmask = nft\_genmask\_cur(net); u8 genmask = nft\_genmask\_next(net);+ u64 tstamp = nft\_net\_tstamp(net); int d;  /\* Descend the tree to search for an existing element greater than the@@ -363,7 +364,7 @@ static int \_\_nft\_rbtree\_insert(const struct net \*net, const struct nft\_set \*set, /\* perform garbage collection to avoid bogus overlap reports \* but skip new elements in this transaction. \*/- if (nft\_set\_elem\_expired(&rbe->ext) &&+ if (\_\_nft\_set\_elem\_expired(&rbe->ext, tstamp) && nft\_set\_elem\_active(&rbe->ext, cur\_genmask)) { const struct nft\_rbtree\_elem \*removed\_end; @@ -550,6 +551,7 @@ static void \*nft\_rbtree\_deactivate(const struct net \*net, const struct rb\_node \*parent = priv->root.rb\_node; struct nft\_rbtree\_elem \*rbe, \*this = elem->priv; u8 genmask = nft\_genmask\_next(net);+ u64 tstamp = nft\_net\_tstamp(net); int d;  while (parent != NULL) {@@ -570,7 +572,7 @@ static void \*nft\_rbtree\_deactivate(const struct net \*net, nft\_rbtree\_interval\_end(this)) { parent = parent->rb\_right; continue;- } else if (nft\_set\_elem\_expired(&rbe->ext)) {+ } else if (\_\_nft\_set\_elem\_expired(&rbe->ext, tstamp)) { break; } else if (!nft\_set\_elem\_active(&rbe->ext, genmask)) { parent = parent->rb\_left; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 14:20:45 +0000


