

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=f5c7e8425f18fdb9bdb7d13340651d7876890329)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f5c7e8425f18fdb9bdb7d13340651d7876890329)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f5c7e8425f18fdb9bdb7d13340651d7876890329)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f5c7e8425f18fdb9bdb7d13340651d7876890329)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Vitaly Kuznetsov <vkuznets@redhat.com> | 2021-05-03 17:08:51 +0200 |
| --- | --- | --- |
| committer | Paolo Bonzini <pbonzini@redhat.com> | 2021-05-07 06:06:11 -0400 |
| commit | [f5c7e8425f18fdb9bdb7d13340651d7876890329](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f5c7e8425f18fdb9bdb7d13340651d7876890329) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=f5c7e8425f18fdb9bdb7d13340651d7876890329)) | |
| tree | [cd510dd64d247ef4cadae1b9629d94ec5e620732](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f5c7e8425f18fdb9bdb7d13340651d7876890329) | |
| parent | [46a63924b05f335b0765ad13dae4d2d7569f25c9](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=46a63924b05f335b0765ad13dae4d2d7569f25c9) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f5c7e8425f18fdb9bdb7d13340651d7876890329&id2=46a63924b05f335b0765ad13dae4d2d7569f25c9)) | |
| download | [linux-f5c7e8425f18fdb9bdb7d13340651d7876890329.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-f5c7e8425f18fdb9bdb7d13340651d7876890329.tar.gz) | |

KVM: nVMX: Always make an attempt to map eVMCS after migrationWhen enlightened VMCS is in use and nested state is migrated with
vmx\_get\_nested\_state()/vmx\_set\_nested\_state() KVM can't map evmcs
page right away: evmcs gpa is not 'struct kvm\_vmx\_nested\_state\_hdr'
and we can't read it from VP assist page because userspace may decide
to restore HV\_X64\_MSR\_VP\_ASSIST\_PAGE after restoring nested state
(and QEMU, for example, does exactly that). To make sure eVMCS is
mapped /vmx\_set\_nested\_state() raises KVM\_REQ\_GET\_NESTED\_STATE\_PAGES
request.
Commit f2c7ef3ba955 ("KVM: nSVM: cancel KVM\_REQ\_GET\_NESTED\_STATE\_PAGES
on nested vmexit") added KVM\_REQ\_GET\_NESTED\_STATE\_PAGES clearing to
nested\_vmx\_vmexit() to make sure MSR permission bitmap is not switched
when an immediate exit from L2 to L1 happens right after migration (caused
by a pending event, for example). Unfortunately, in the exact same
situation we still need to have eVMCS mapped so
nested\_sync\_vmcs12\_to\_shadow() reflects changes in VMCS12 to eVMCS.
As a band-aid, restore nested\_get\_evmcs\_page() when clearing
KVM\_REQ\_GET\_NESTED\_STATE\_PAGES in nested\_vmx\_vmexit(). The 'fix' is far
from being ideal as we can't easily propagate possible failures and even if
we could, this is most likely already too late to do so. The whole
'KVM\_REQ\_GET\_NESTED\_STATE\_PAGES' idea for mapping eVMCS after migration
seems to be fragile as we diverge too much from the 'native' path when
vmptr loading happens on vmx\_set\_nested\_state().
Fixes: f2c7ef3ba955 ("KVM: nSVM: cancel KVM\_REQ\_GET\_NESTED\_STATE\_PAGES on nested vmexit")
Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
Message-Id: <20210503150854.1144255-2-vkuznets@redhat.com>
Cc: stable@vger.kernel.org
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f5c7e8425f18fdb9bdb7d13340651d7876890329)

| -rw-r--r-- | [arch/x86/kvm/vmx/nested.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/x86/kvm/vmx/nested.c?id=f5c7e8425f18fdb9bdb7d13340651d7876890329) | 29 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 19 insertions, 10 deletions

| diff --git a/arch/x86/kvm/vmx/nested.c b/arch/x86/kvm/vmx/nested.cindex bced7663782329..6058a65a6ede67 100644--- a/[arch/x86/kvm/vmx/nested.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/vmx/nested.c?id=46a63924b05f335b0765ad13dae4d2d7569f25c9)+++ b/[arch/x86/kvm/vmx/nested.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/vmx/nested.c?id=f5c7e8425f18fdb9bdb7d13340651d7876890329)@@ -3098,15 +3098,8 @@ static bool nested\_get\_evmcs\_page(struct kvm\_vcpu \*vcpu) nested\_vmx\_handle\_enlightened\_vmptrld(vcpu, false);  if (evmptrld\_status == EVMPTRLD\_VMFAIL ||- evmptrld\_status == EVMPTRLD\_ERROR) {- pr\_debug\_ratelimited("%s: enlightened vmptrld failed\n",- \_\_func\_\_);- vcpu->run->exit\_reason = KVM\_EXIT\_INTERNAL\_ERROR;- vcpu->run->internal.suberror =- KVM\_INTERNAL\_ERROR\_EMULATION;- vcpu->run->internal.ndata = 0;+ evmptrld\_status == EVMPTRLD\_ERROR) return false;- } }  return true;@@ -3194,8 +3187,16 @@ static bool nested\_get\_vmcs12\_pages(struct kvm\_vcpu \*vcpu)  static bool vmx\_get\_nested\_state\_pages(struct kvm\_vcpu \*vcpu) {- if (!nested\_get\_evmcs\_page(vcpu))+ if (!nested\_get\_evmcs\_page(vcpu)) {+ pr\_debug\_ratelimited("%s: enlightened vmptrld failed\n",+ \_\_func\_\_);+ vcpu->run->exit\_reason = KVM\_EXIT\_INTERNAL\_ERROR;+ vcpu->run->internal.suberror =+ KVM\_INTERNAL\_ERROR\_EMULATION;+ vcpu->run->internal.ndata = 0;+ return false;+ }  if (is\_guest\_mode(vcpu) && !nested\_get\_vmcs12\_pages(vcpu)) return false;@@ -4435,7 +4436,15 @@ void nested\_vmx\_vmexit(struct kvm\_vcpu \*vcpu, u32 vm\_exit\_reason, /\* Similarly, triple faults in L2 should never escape. \*/ WARN\_ON\_ONCE(kvm\_check\_request(KVM\_REQ\_TRIPLE\_FAULT, vcpu)); - kvm\_clear\_request(KVM\_REQ\_GET\_NESTED\_STATE\_PAGES, vcpu);+ if (kvm\_check\_request(KVM\_REQ\_GET\_NESTED\_STATE\_PAGES, vcpu)) {+ /\*+ \* KVM\_REQ\_GET\_NESTED\_STATE\_PAGES is also used to map+ \* Enlightened VMCS after migration and we still need to+ \* do that when something is forcing L2->L1 exit prior to+ \* the first L2 run.+ \*/+ (void)nested\_get\_evmcs\_page(vcpu);+ }  /\* Service the TLB flush request for L2 before switching to L1. \*/ if (kvm\_check\_request(KVM\_REQ\_TLB\_FLUSH\_CURRENT, vcpu)) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 07:17:30 +0000

