
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FeProsima%2FFast-DDS%2Fblob%2Fv2.9.0%2Fsrc%2Fcpp%2Frtps%2Fmessages%2FMessageReceiver.cpp)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FeProsima%2FFast-DDS%2Fblob%2Fv2.9.0%2Fsrc%2Fcpp%2Frtps%2Fmessages%2FMessageReceiver.cpp)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=eProsima%2FFast-DDS)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[eProsima](/eProsima)
/
**[Fast-DDS](/eProsima/Fast-DDS)**
Public

* [Notifications](/login?return_to=%2FeProsima%2FFast-DDS) You must be signed in to change notification settings
* [Fork
  787](/login?return_to=%2FeProsima%2FFast-DDS)
* [Star
   2.3k](/login?return_to=%2FeProsima%2FFast-DDS)

* [Code](/eProsima/Fast-DDS/tree/v2.9.0)
* [Issues
  48](/eProsima/Fast-DDS/issues)
* [Pull requests
  78](/eProsima/Fast-DDS/pulls)
* [Discussions](/eProsima/Fast-DDS/discussions)
* [Actions](/eProsima/Fast-DDS/actions)
* [Projects
  0](/eProsima/Fast-DDS/projects)
* [Security](/eProsima/Fast-DDS/security)
* [Insights](/eProsima/Fast-DDS/pulse)

Additional navigation options

* [Code](/eProsima/Fast-DDS/tree/v2.9.0)
* [Issues](/eProsima/Fast-DDS/issues)
* [Pull requests](/eProsima/Fast-DDS/pulls)
* [Discussions](/eProsima/Fast-DDS/discussions)
* [Actions](/eProsima/Fast-DDS/actions)
* [Projects](/eProsima/Fast-DDS/projects)
* [Security](/eProsima/Fast-DDS/security)
* [Insights](/eProsima/Fast-DDS/pulse)

## Files

 v2.9.0
## Breadcrumbs

1. [Fast-DDS](/eProsima/Fast-DDS/tree/v2.9.0)
2. /[src](/eProsima/Fast-DDS/tree/v2.9.0/src)
3. /[cpp](/eProsima/Fast-DDS/tree/v2.9.0/src/cpp)
4. /[rtps](/eProsima/Fast-DDS/tree/v2.9.0/src/cpp/rtps)
5. /[messages](/eProsima/Fast-DDS/tree/v2.9.0/src/cpp/rtps/messages)
/
# MessageReceiver.cpp

Copy path Blame  Blame
## Latest commit

## History

[History](/eProsima/Fast-DDS/commits/v2.9.0/src/cpp/rtps/messages/MessageReceiver.cpp)1424 lines (1257 loc) · 43.8 KB v2.9.0
## Breadcrumbs

1. [Fast-DDS](/eProsima/Fast-DDS/tree/v2.9.0)
2. /[src](/eProsima/Fast-DDS/tree/v2.9.0/src)
3. /[cpp](/eProsima/Fast-DDS/tree/v2.9.0/src/cpp)
4. /[rtps](/eProsima/Fast-DDS/tree/v2.9.0/src/cpp/rtps)
5. /[messages](/eProsima/Fast-DDS/tree/v2.9.0/src/cpp/rtps/messages)
/
# MessageReceiver.cpp

Top
## File metadata and controls

* Code
* Blame

1424 lines (1257 loc) · 43.8 KB[Raw](https://github.com/eProsima/Fast-DDS/raw/refs/tags/v2.9.0/src/cpp/rtps/messages/MessageReceiver.cpp)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).//// Licensed under the Apache License, Version 2.0 (the "License");// you may not use this file except in compliance with the License.// You may obtain a copy of the License at//// http://www.apache.org/licenses/LICENSE-2.0//// Unless required by applicable law or agreed to in writing, software// distributed under the License is distributed on an "AS IS" BASIS,// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.// See the License for the specific language governing permissions and// limitations under the License.
/\*\* \* @file MessageReceiver.cpp \* \*/
#include <fastdds/rtps/messages/MessageReceiver.h>
#include <cassert>#include <limits>
#include <fastdds/core/policy/ParameterList.hpp>#include <fastdds/dds/log/Log.hpp>#include <fastdds/rtps/reader/RTPSReader.h>#include <fastdds/rtps/writer/RTPSWriter.h>#include <fastrtps/utils/shared\_mutex.hpp>
#include <rtps/participant/RTPSParticipantImpl.h>#include <statistics/rtps/StatisticsBase.hpp>#include <statistics/rtps/messages/RTPSStatisticsMessages.hpp>
#define INFO\_SRC\_SUBMSG\_LENGTH 20
#define IDSTRING "(ID:" << std::this\_thread::get\_id() << ") " <<
using ParameterList = eprosima::fastdds::dds::ParameterList;
namespace eprosima {namespace fastrtps {namespace rtps {
MessageReceiver::MessageReceiver( RTPSParticipantImpl\* participant, uint32\_t rec\_buffer\_size) : participant\_(participant) , source\_version\_(c\_ProtocolVersion) , source\_vendor\_id\_(c\_VendorId\_Unknown) , source\_guid\_prefix\_(c\_GuidPrefix\_Unknown) , dest\_guid\_prefix\_(c\_GuidPrefix\_Unknown) , have\_timestamp\_(false) , timestamp\_(c\_TimeInvalid)#if HAVE\_SECURITY , crypto\_msg\_(participant->is\_secure() ? rec\_buffer\_size : 0) , crypto\_submsg\_(participant->is\_secure() ? rec\_buffer\_size : 0) , crypto\_payload\_(participant->is\_secure() ? rec\_buffer\_size : 0)#endif // if HAVE\_SECURITY{ (void)rec\_buffer\_size; EPROSIMA\_LOG\_INFO(RTPS\_MSG\_IN, "Created with CDRMessage of size: " << rec\_buffer\_size);
#if HAVE\_SECURITY if (participant->is\_secure()) { process\_data\_message\_function\_ = std::bind( &MessageReceiver::process\_data\_message\_with\_security, this, std::placeholders::\_1, std::placeholders::\_2);
 process\_data\_fragment\_message\_function\_ = std::bind( &MessageReceiver::process\_data\_fragment\_message\_with\_security, this, std::placeholders::\_1, std::placeholders::\_2, std::placeholders::\_3, std::placeholders::\_4, std::placeholders::\_5); } else {#endif // if HAVE SECURITY process\_data\_message\_function\_ = std::bind( &MessageReceiver::process\_data\_message\_without\_security, this, std::placeholders::\_1, std::placeholders::\_2);
 process\_data\_fragment\_message\_function\_ = std::bind( &MessageReceiver::process\_data\_fragment\_message\_without\_security, this, std::placeholders::\_1, std::placeholders::\_2, std::placeholders::\_3, std::placeholders::\_4, std::placeholders::\_5);#if HAVE\_SECURITY}
#endif // if HAVE SECURITY}
MessageReceiver::~MessageReceiver(){ EPROSIMA\_LOG\_INFO(RTPS\_MSG\_IN, ""); assert(associated\_writers\_.empty()); assert(associated\_readers\_.empty());}
 #if HAVE\_SECURITYvoid MessageReceiver::process\_data\_message\_with\_security( const EntityId\_t& reader\_id, CacheChange\_t& change){ auto process\_message = [&change, this](RTPSReader\* reader) { if (!reader->getAttributes().security\_attributes().is\_payload\_protected) { reader->processDataMsg(&change); return; }
 if (!reader->matched\_writer\_is\_matched(change.writerGUID)) { return; }
 if (!participant\_->security\_manager().decode\_serialized\_payload(change.serializedPayload, crypto\_payload\_, reader->getGuid(), change.writerGUID)) { return; }
 std::swap(change.serializedPayload.data, crypto\_payload\_.data); std::swap(change.serializedPayload.length, crypto\_payload\_.length);
 SerializedPayload\_t original\_payload = change.serializedPayload; reader->processDataMsg(&change); IPayloadPool\* payload\_pool = change.payload\_owner(); if (payload\_pool) { payload\_pool->release\_payload(change); change.serializedPayload = original\_payload; } original\_payload.data = nullptr; std::swap(change.serializedPayload.data, crypto\_payload\_.data); std::swap(change.serializedPayload.length, crypto\_payload\_.length); };
 findAllReaders(reader\_id, process\_message);}
void MessageReceiver::process\_data\_fragment\_message\_with\_security( const EntityId\_t& reader\_id, CacheChange\_t& change, uint32\_t sample\_size, uint32\_t fragment\_starting\_num, uint16\_t fragments\_in\_submessage){ auto process\_message = [&change, sample\_size, fragment\_starting\_num, fragments\_in\_submessage, this](RTPSReader\* reader) { if (!reader->getAttributes().security\_attributes().is\_payload\_protected) { reader->processDataFragMsg(&change, sample\_size, fragment\_starting\_num, fragments\_in\_submessage); return; }
 if (!reader->matched\_writer\_is\_matched(change.writerGUID)) { return; }
 if (!participant\_->security\_manager().decode\_serialized\_payload(change.serializedPayload, crypto\_payload\_, reader->getGuid(), change.writerGUID)) { return; }
 std::swap(change.serializedPayload.data, crypto\_payload\_.data); std::swap(change.serializedPayload.length, crypto\_payload\_.length); reader->processDataFragMsg(&change, sample\_size, fragment\_starting\_num, fragments\_in\_submessage); std::swap(change.serializedPayload.data, crypto\_payload\_.data); std::swap(change.serializedPayload.length, crypto\_payload\_.length); };
 findAllReaders(reader\_id, process\_message);}
#endif // if HAVE SECURITY
void MessageReceiver::process\_data\_message\_without\_security( const EntityId\_t& reader\_id, CacheChange\_t& change){ auto process\_message = [&change](RTPSReader\* reader) { reader->processDataMsg(&change); };
 findAllReaders(reader\_id, process\_message);}
void MessageReceiver::process\_data\_fragment\_message\_without\_security( const EntityId\_t& reader\_id, CacheChange\_t& change, uint32\_t sample\_size, uint32\_t fragment\_starting\_num, uint16\_t fragments\_in\_submessage){ auto process\_message = [&change, sample\_size, fragment\_starting\_num, fragments\_in\_submessage](RTPSReader\* reader) { reader->processDataFragMsg(&change, sample\_size, fragment\_starting\_num, fragments\_in\_submessage); };
 findAllReaders(reader\_id, process\_message);}
void MessageReceiver::associateEndpoint( Endpoint\* to\_add){ std::lock\_guard<eprosima::shared\_mutex> guard(mtx\_); if (to\_add->getAttributes().endpointKind == WRITER) { const auto writer = dynamic\_cast<RTPSWriter\*>(to\_add); for (const auto& it : associated\_writers\_) { if (it == writer) { return; } }
 associated\_writers\_.push\_back(writer); } else { const auto reader = dynamic\_cast<RTPSReader\*>(to\_add); const auto entityId = reader->getGuid().entityId; // search for set of readers by entity ID const auto readers = associated\_readers\_.find(entityId); if (readers == associated\_readers\_.end()) { auto vec = std::vector<RTPSReader\*>(); vec.push\_back(reader); associated\_readers\_.emplace(entityId, vec); } else { for (const auto& it : readers->second) { if (it == reader) { return; } }
 readers->second.push\_back(reader); } }}
void MessageReceiver::removeEndpoint( Endpoint\* to\_remove){ std::lock\_guard<eprosima::shared\_mutex> guard(mtx\_);
 if (to\_remove->getAttributes().endpointKind == WRITER) { auto\* var = dynamic\_cast<RTPSWriter\*>(to\_remove); for (auto it = associated\_writers\_.begin(); it != associated\_writers\_.end(); ++it) { if (\*it == var) { associated\_writers\_.erase(it); break; } } } else { auto readers = associated\_readers\_.find(to\_remove->getGuid().entityId); if (readers != associated\_readers\_.end()) { auto\* var = dynamic\_cast<RTPSReader\*>(to\_remove); for (auto it = readers->second.begin(); it != readers->second.end(); ++it) { if (\*it == var) { readers->second.erase(it); if (readers->second.empty()) { associated\_readers\_.erase(readers); } break; } } } }}
void MessageReceiver::reset(){ source\_version\_ = c\_ProtocolVersion; source\_vendor\_id\_ = c\_VendorId\_Unknown; source\_guid\_prefix\_ = c\_GuidPrefix\_Unknown; dest\_guid\_prefix\_ = c\_GuidPrefix\_Unknown; have\_timestamp\_ = false; timestamp\_ = c\_TimeInvalid;}
void MessageReceiver::processCDRMsg( const Locator\_t& source\_locator, const Locator\_t& reception\_locator, CDRMessage\_t\* msg){ if (msg->length < RTPSMESSAGE\_HEADER\_SIZE) { EPROSIMA\_LOG\_WARNING(RTPS\_MSG\_IN, IDSTRING "Received message too short, ignoring"); return; }
#ifdef FUZZING\_BUILD\_MODE\_UNSAFE\_FOR\_PRODUCTION GuidPrefix\_t participantGuidPrefix;#else GuidPrefix\_t participantGuidPrefix = participant\_->getGuid().guidPrefix;#endif // ifdef FUZZING\_BUILD\_MODE\_UNSAFE\_FOR\_PRODUCTION
#if HAVE\_SECURITY security::SecurityManager& security = participant\_->security\_manager(); CDRMessage\_t\* auxiliary\_buffer = &crypto\_msg\_; int decode\_ret = 0;#endif // if HAVE\_SECURITY
 { std::lock\_guard<eprosima::shared\_mutex> guard(mtx\_);
 reset();
 dest\_guid\_prefix\_ = participantGuidPrefix;
 msg->pos = 0; //Start reading at 0
 //Once everything is set, the reading begins: if (!checkRTPSHeader(msg)) { return; }
 notify\_network\_statistics(source\_locator, reception\_locator, msg);
#if HAVE\_SECURITY decode\_ret = security.decode\_rtps\_message(\*msg, \*auxiliary\_buffer, source\_guid\_prefix\_);
 if (decode\_ret < 0) { return; }
 if (decode\_ret == 0) { // The original CDRMessage buffer (msg) now points to the proprietary temporary buffer crypto\_msg\_. // The auxiliary buffer now points to the propietary temporary buffer crypto\_submsg\_. // This way each decoded sub-message will be processed using the crypto\_submsg\_ buffer. msg = auxiliary\_buffer; auxiliary\_buffer = &crypto\_submsg\_; }#endif // if HAVE\_SECURITY }
 // Loop until there are no more submessages // Each submessage processing method choses the lock kind required bool valid; SubmessageHeader\_t submsgh; //Current submessage header
 while (msg->pos < msg->length)// end of the message { CDRMessage\_t\* submessage = msg;
#if HAVE\_SECURITY decode\_ret = security.decode\_rtps\_submessage(\*msg, \*auxiliary\_buffer, source\_guid\_prefix\_);
 if (decode\_ret < 0) { return; }
 if (decode\_ret == 0) { submessage = auxiliary\_buffer; }#endif // if HAVE\_SECURITY
 //First 4 bytes must contain: ID | flags | octets to next header if (!readSubmessageHeader(submessage, &submsgh)) { return; }
 valid = true; uint32\_t next\_msg\_pos = submessage->pos; next\_msg\_pos += (submsgh.submessageLength + 3u) & ~3u; switch (submsgh.submessageId) { case DATA: { if (dest\_guid\_prefix\_ != participantGuidPrefix) { EPROSIMA\_LOG\_INFO(RTPS\_MSG\_IN, IDSTRING "Data Submsg ignored, DST is another RTPSParticipant"); } else { EPROSIMA\_LOG\_INFO(RTPS\_MSG\_IN, IDSTRING "Data Submsg received, processing."); valid = proc\_Submsg\_Data(submessage, &submsgh); } break; } case DATA\_FRAG: if (dest\_guid\_prefix\_ != participantGuidPrefix) { EPROSIMA\_LOG\_INFO(RTPS\_MSG\_IN, IDSTRING "DataFrag Submsg ignored, DST is another RTPSParticipant"); } else { EPROSIMA\_LOG\_INFO(RTPS\_MSG\_IN, IDSTRING "DataFrag Submsg received, processing."); valid = proc\_Submsg\_DataFrag(submessage, &submsgh); } break; case GAP: { if (dest\_guid\_prefix\_ != participantGuidPrefix) { EPROSIMA\_LOG\_INFO(RTPS\_MSG\_IN, IDSTRING "Gap Submsg ignored, DST is another RTPSParticipant..."); } else { EPROSIMA\_LOG\_INFO(RTPS\_MSG\_IN, IDSTRING "Gap Submsg received, processing..."); valid = proc\_Submsg\_Gap(submessage, &submsgh); } break; } case ACKNACK: { if (dest\_guid\_prefix\_ != participantGuidPrefix) { EPROSIMA\_LOG\_INFO(RTPS\_MSG\_IN, IDSTRING "Acknack Submsg ignored, DST is another RTPSParticipant..."); } else { EPROSIMA\_LOG\_INFO(RTPS\_MSG\_IN, IDSTRING "Acknack Submsg received, processing..."); valid = proc\_Submsg\_Acknack(submessage, &submsgh); } break; } case NACK\_FRAG: { if (dest\_guid\_prefix\_ != participantGuidPrefix) { EPROSIMA\_LOG\_INFO(RTPS\_MSG\_IN, IDSTRING "NackFrag Submsg ignored, DST is another RTPSParticipant..."); } else { EPROSIMA\_LOG\_INFO(RTPS\_MSG\_IN, IDSTRING "NackFrag Submsg received, processing..."); valid = proc\_Submsg\_NackFrag(submessage, &submsgh); } break; } case HEARTBEAT: { if (dest\_guid\_prefix\_ != participantGuidPrefix) { EPROSIMA\_LOG\_INFO(RTPS\_MSG\_IN, IDSTRING "HB Submsg ignored, DST is another RTPSParticipant..."); } else { EPROSIMA\_LOG\_INFO(RTPS\_MSG\_IN, IDSTRING "Heartbeat Submsg received, processing..."); valid = proc\_Submsg\_Heartbeat(submessage, &submsgh); } break; } case HEARTBEAT\_FRAG: { if (dest\_guid\_prefix\_ != participantGuidPrefix) { EPROSIMA\_LOG\_INFO(RTPS\_MSG\_IN, IDSTRING "HBFrag Submsg ignored, DST is another RTPSParticipant..."); } else { EPROSIMA\_LOG\_INFO(RTPS\_MSG\_IN, IDSTRING "HeartbeatFrag Submsg received, processing..."); valid = proc\_Submsg\_HeartbeatFrag(submessage, &submsgh); } break; } case PAD: EPROSIMA\_LOG\_WARNING(RTPS\_MSG\_IN, IDSTRING "PAD messages not yet implemented, ignoring"); break; case INFO\_DST: EPROSIMA\_LOG\_INFO(RTPS\_MSG\_IN, IDSTRING "InfoDST message received, processing..."); valid = proc\_Submsg\_InfoDST(submessage, &submsgh); break; case INFO\_SRC: EPROSIMA\_LOG\_INFO(RTPS\_MSG\_IN, IDSTRING "InfoSRC message received, processing..."); valid = proc\_Submsg\_InfoSRC(submessage, &submsgh); break; case INFO\_TS: { EPROSIMA\_LOG\_INFO(RTPS\_MSG\_IN, IDSTRING "InfoTS Submsg received, processing..."); valid = proc\_Submsg\_InfoTS(submessage, &submsgh); break; } case INFO\_REPLY: break; case INFO\_REPLY\_IP4: break; default: break; }
 if (!valid || submsgh.is\_last) { break; }
 submessage->pos = next\_msg\_pos; }
#ifndef FUZZING\_BUILD\_MODE\_UNSAFE\_FOR\_PRODUCTION participant\_->assert\_remote\_participant\_liveliness(source\_guid\_prefix\_);#endif // ifndef FUZZING\_BUILD\_MODE\_UNSAFE\_FOR\_PRODUCTION}
bool MessageReceiver::checkRTPSHeader( CDRMessage\_t\* msg){ //check and proccess the RTPS Header if (msg->buffer[0] != 'R' || msg->buffer[1] != 'T' || msg->buffer[2] != 'P' || msg->buffer[3] != 'S') { EPROSIMA\_LOG\_INFO(RTPS\_MSG\_IN, IDSTRING "Msg received with no RTPS in header, ignoring..."); return false; }
 msg->pos += 4;
 //CHECK AND SET protocol version if (msg->buffer[msg->pos] == c\_ProtocolVersion.m\_major) { source\_version\_.m\_major = msg->buffer[msg->pos]; msg->pos++; source\_version\_.m\_minor = msg->buffer[msg->pos]; msg->pos++; } else { EPROSIMA\_LOG\_WARNING(RTPS\_MSG\_IN, IDSTRING "Major RTPS Version not supported"); return false; }
 //Set source vendor id source\_vendor\_id\_[0] = msg->buffer[msg->pos]; msg->pos++; source\_vendor\_id\_[1] = msg->buffer[msg->pos]; msg->pos++; //set source guid prefix CDRMessage::readData(msg, source\_guid\_prefix\_.value, GuidPrefix\_t::size); have\_timestamp\_ = false; return true;}
bool MessageReceiver::readSubmessageHeader( CDRMessage\_t\* msg, SubmessageHeader\_t\* smh) const{ if (msg->length - msg->pos < 4) { EPROSIMA\_LOG\_WARNING(RTPS\_MSG\_IN, IDSTRING "SubmessageHeader too short"); return false; }
 smh->submessageId = msg->buffer[msg->pos]; msg->pos++; smh->flags = msg->buffer[msg->pos]; msg->pos++;
 //Set endianness of message msg->msg\_endian = (smh->flags & BIT(0)) != 0 ? LITTLEEND : BIGEND; uint16\_t length = 0; CDRMessage::readUInt16(msg, &length); if (msg->pos + length > msg->length) { EPROSIMA\_LOG\_WARNING(RTPS\_MSG\_IN, IDSTRING "SubMsg of invalid length (" << length << ") with current msg position/length (" << msg->pos << "/" << msg->length << ")"); return false; }
 if ((length == 0) && (smh->submessageId != INFO\_TS) && (smh->submessageId != PAD)) { // THIS IS THE LAST SUBMESSAGE smh->submessageLength = msg->length - msg->pos; smh->is\_last = true; } else { smh->submessageLength = length; smh->is\_last = false; }
 return true;}
bool MessageReceiver::willAReaderAcceptMsgDirectedTo( const EntityId\_t& readerID, RTPSReader\*& first\_reader) const{ first\_reader = nullptr; if (associated\_readers\_.empty()) { EPROSIMA\_LOG\_WARNING(RTPS\_MSG\_IN, IDSTRING "Data received when NO readers are listening"); return false; }
 if (readerID != c\_EntityId\_Unknown) { const auto readers = associated\_readers\_.find(readerID); if (readers != associated\_readers\_.end()) { first\_reader = readers->second.front(); return true; } } else { for (const auto& readers : associated\_readers\_) { for (const auto& it : readers.second) { if (it->m\_acceptMessagesToUnknownReaders) { first\_reader = it; return true; } } } }
 EPROSIMA\_LOG\_WARNING(RTPS\_MSG\_IN, IDSTRING "No Reader accepts this message (directed to: " << readerID << ")"); return false;}
template<typename Functor>void MessageReceiver::findAllReaders( const EntityId\_t& readerID, const Functor& callback) const{ if (readerID != c\_EntityId\_Unknown) { const auto readers = associated\_readers\_.find(readerID); if (readers != associated\_readers\_.end()) { for (const auto& it : readers->second) { callback(it); } } } else { for (const auto& readers : associated\_readers\_) { for (const auto& it : readers.second) { if (it->m\_acceptMessagesToUnknownReaders) { callback(it); } } } }}
bool MessageReceiver::proc\_Submsg\_Data( CDRMessage\_t\* msg, SubmessageHeader\_t\* smh) const{ eprosima::shared\_lock<eprosima::shared\_mutex> guard(mtx\_);
 //READ and PROCESS if (smh->submessageLength < RTPSMESSAGE\_DATA\_MIN\_LENGTH) { EPROSIMA\_LOG\_INFO(RTPS\_MSG\_IN, IDSTRING "Too short submessage received, ignoring"); return false; } //Fill flags bool values bool endiannessFlag = (smh->flags & BIT(0)) != 0; bool inlineQosFlag = (smh->flags & BIT(1)) != 0; bool dataFlag = (smh->flags & BIT(2)) != 0; bool keyFlag = (smh->flags & BIT(3)) != 0; if (keyFlag && dataFlag) { EPROSIMA\_LOG\_WARNING(RTPS\_MSG\_IN, IDSTRING "Message received with Data and Key Flag set, ignoring"); return false; }
 //Assign message endianness if (endiannessFlag) { msg->msg\_endian = LITTLEEND; } else { msg->msg\_endian = BIGEND; }
 //Extra flags don't matter now. Avoid those bytes msg->pos += 2;
 bool valid = true; int16\_t octetsToInlineQos = 0; valid &= CDRMessage::readInt16(msg, &octetsToInlineQos); //it should be 16 in this implementation
 //reader and writer ID RTPSReader\* first\_reader = nullptr; EntityId\_t readerID; valid &= CDRMessage::readEntityId(msg, &readerID);
 //WE KNOW THE READER THAT THE MESSAGE IS DIRECTED TO SO WE LOOK FOR IT: if (!willAReaderAcceptMsgDirectedTo(readerID, first\_reader)) { return false; }
 //FOUND THE READER. //We ask the reader for a cachechange to store the information. CacheChange\_t ch; ch.kind = ALIVE; ch.writerGUID.guidPrefix = source\_guid\_prefix\_; valid &= CDRMessage::readEntityId(msg, &ch.writerGUID.entityId);
 //Get sequence number valid &= CDRMessage::readSequenceNumber(msg, &ch.sequenceNumber);
 if (!valid) { return false; }
 if (ch.sequenceNumber <= SequenceNumber\_t()) { EPROSIMA\_LOG\_WARNING(RTPS\_MSG\_IN, IDSTRING "Invalid message received, bad sequence Number"); return false; }
 //Jump ahead if more parameters are before inlineQos (not in this version, maybe if further minor versions.) if (octetsToInlineQos > RTPSMESSAGE\_OCTETSTOINLINEQOS\_DATASUBMSG) { msg->pos += (octetsToInlineQos - RTPSMESSAGE\_OCTETSTOINLINEQOS\_DATASUBMSG); if (msg->pos > msg->length) { EPROSIMA\_LOG\_WARNING(RTPS\_MSG\_IN, IDSTRING "Invalid jump through msg, msg->pos " << msg->pos << " > msg->length " << msg->length); return false; } }
 uint32\_t inlineQosSize = 0;
 if (inlineQosFlag) { if (!ParameterList::updateCacheChangeFromInlineQos(ch, msg, inlineQosSize)) { EPROSIMA\_LOG\_INFO(RTPS\_MSG\_IN, IDSTRING "SubMessage Data ERROR, Inline Qos ParameterList error"); return false; } ch.inline\_qos.data = &msg->buffer[msg->pos - inlineQosSize]; ch.inline\_qos.max\_size = inlineQosSize; ch.inline\_qos.length = inlineQosSize; ch.inline\_qos.encapsulation = endiannessFlag ? PL\_CDR\_LE : PL\_CDR\_BE; ch.inline\_qos.pos = 0; }
 if (dataFlag || keyFlag) { uint32\_t payload\_size; payload\_size = smh->submessageLength - (RTPSMESSAGE\_DATA\_EXTRA\_INLINEQOS\_SIZE + octetsToInlineQos + inlineQosSize);
 if (dataFlag) { uint32\_t next\_pos = msg->pos + payload\_size; if (msg->length >= next\_pos && payload\_size > 0) { ch.serializedPayload.data = &msg->buffer[msg->pos]; ch.serializedPayload.length = payload\_size; ch.serializedPayload.max\_size = payload\_size; msg->pos = next\_pos; } else { EPROSIMA\_LOG\_WARNING(RTPS\_MSG\_IN, IDSTRING "Serialized Payload value invalid or larger than maximum allowed size" "(" << payload\_size << "/" << (msg->length - msg->pos) << ")"); return false; } } else if (keyFlag) { if (payload\_size <= 0) { EPROSIMA\_LOG\_WARNING(RTPS\_MSG\_IN, IDSTRING "Serialized Payload value invalid (" << payload\_size << ")"); return false; }
 if (payload\_size <= PARAMETER\_KEY\_HASH\_LENGTH) { memcpy(ch.instanceHandle.value, &msg->buffer[msg->pos], payload\_size); } else { EPROSIMA\_LOG\_WARNING(RTPS\_MSG\_IN, IDSTRING "Ignoring Serialized Payload for too large key-only data (" << payload\_size << ")"); } msg->pos += payload\_size; } }
 // Set sourcetimestamp if (have\_timestamp\_) { ch.sourceTimestamp = timestamp\_; }
 EPROSIMA\_LOG\_INFO(RTPS\_MSG\_IN, IDSTRING "from Writer " << ch.writerGUID << "; possible RTPSReader entities: " << associated\_readers\_.size());
 //Look for the correct reader to add the change process\_data\_message\_function\_(readerID, ch);
 IPayloadPool\* payload\_pool = ch.payload\_owner(); if (payload\_pool) { payload\_pool->release\_payload(ch); }
 //TODO(Ricardo) If an exception is thrown (ex, by fastcdr), these lines are not executed -> segmentation fault ch.serializedPayload.data = nullptr; ch.inline\_qos.data = nullptr;
 EPROSIMA\_LOG\_INFO(RTPS\_MSG\_IN, IDSTRING "Sub Message DATA processed"); return true;}
bool MessageReceiver::proc\_Submsg\_DataFrag( CDRMessage\_t\* msg, SubmessageHeader\_t\* smh) const{ eprosima::shared\_lock<eprosima::shared\_mutex> guard(mtx\_);
 //READ and PROCESS if (smh->submessageLength < RTPSMESSAGE\_DATA\_MIN\_LENGTH) { EPROSIMA\_LOG\_INFO(RTPS\_MSG\_IN, IDSTRING "Too short submessage received, ignoring"); return false; }
 //Fill flags bool values bool endiannessFlag = (smh->flags & BIT(0)) != 0; bool inlineQosFlag = (smh->flags & BIT(1)) != 0; bool keyFlag = (smh->flags & BIT(2)) != 0;
 //Assign message endianness if (endiannessFlag) { msg->msg\_endian = LITTLEEND; } else { msg->msg\_endian = BIGEND; }
 //Extra flags don't matter now. Avoid those bytes msg->pos += 2;
 bool valid = true; int16\_t octetsToInlineQos = 0; valid &= CDRMessage::readInt16(msg, &octetsToInlineQos); //it should be 16 in this implementation
 //reader and writer ID RTPSReader\* first\_reader = nullptr; EntityId\_t readerID; valid &= CDRMessage::readEntityId(msg, &readerID);
 //WE KNOW THE READER THAT THE MESSAGE IS DIRECTED TO SO WE LOOK FOR IT: if (!willAReaderAcceptMsgDirectedTo(readerID, first\_reader)) { return false; }
 //FOUND THE READER. //We ask the reader for a cachechange to store the information. CacheChange\_t ch; ch.writerGUID.guidPrefix = source\_guid\_prefix\_; valid &= CDRMessage::readEntityId(msg, &ch.writerGUID.entityId);
 //Get sequence number valid &= CDRMessage::readSequenceNumber(msg, &ch.sequenceNumber);
 if (ch.sequenceNumber <= SequenceNumber\_t()) { EPROSIMA\_LOG\_WARNING(RTPS\_MSG\_IN, IDSTRING "Invalid message received, bad sequence Number"); return false; }
 // READ FRAGMENT NUMBER uint32\_t fragmentStartingNum; valid &= CDRMessage::readUInt32(msg, &fragmentStartingNum);
 // READ FRAGMENTSINSUBMESSAGE uint16\_t fragmentsInSubmessage; valid &= CDRMessage::readUInt16(msg, &fragmentsInSubmessage);
 // READ FRAGMENTSIZE uint16\_t fragmentSize = 0; valid &= CDRMessage::readUInt16(msg, &fragmentSize);
 // READ SAMPLESIZE uint32\_t sampleSize; valid &= CDRMessage::readUInt32(msg, &sampleSize);
 if (!valid) { return false; }
 //Jump ahead if more parameters are before inlineQos (not in this version, maybe if further minor versions.) if (octetsToInlineQos > RTPSMESSAGE\_OCTETSTOINLINEQOS\_DATAFRAGSUBMSG) { msg->pos += (octetsToInlineQos - RTPSMESSAGE\_OCTETSTOINLINEQOS\_DATAFRAGSUBMSG); if (msg->pos > msg->length) { EPROSIMA\_LOG\_WARNING(RTPS\_MSG\_IN, IDSTRING "Invalid jump through msg, msg->pos " << msg->pos << " > msg->length " << msg->length); return false; } }
 uint32\_t inlineQosSize = 0;
 if (inlineQosFlag) { if (!ParameterList::updateCacheChangeFromInlineQos(ch, msg, inlineQosSize)) { EPROSIMA\_LOG\_INFO(RTPS\_MSG\_IN, IDSTRING "SubMessage Data ERROR, Inline Qos ParameterList error"); return false; } ch.inline\_qos.data = &msg->buffer[msg->pos - inlineQosSize]; ch.inline\_qos.max\_size = inlineQosSize; ch.inline\_qos.length = inlineQosSize; ch.inline\_qos.encapsulation = endiannessFlag ? PL\_CDR\_LE : PL\_CDR\_BE; ch.inline\_qos.pos = 0; }
 uint32\_t payload\_size; payload\_size = smh->submessageLength - (RTPSMESSAGE\_DATA\_EXTRA\_INLINEQOS\_SIZE + octetsToInlineQos + inlineQosSize);
 // Validations??? XXX TODO
 if (!keyFlag) { uint32\_t next\_pos = msg->pos + payload\_size; if (msg->length >= next\_pos && payload\_size > 0) { ch.kind = ALIVE; ch.serializedPayload.data = &msg->buffer[msg->pos]; ch.serializedPayload.length = payload\_size; ch.serializedPayload.max\_size = payload\_size; ch.setFragmentSize(fragmentSize);
 msg->pos = next\_pos; } else { EPROSIMA\_LOG\_WARNING(RTPS\_MSG\_IN, IDSTRING "Serialized Payload value invalid or larger than maximum allowed size " "(" << payload\_size << "/" << (msg->length - msg->pos) << ")"); return false; } } else if (keyFlag) { /\* XXX TODO Endianness\_t previous\_endian = msg->msg\_endian; if (ch->serializedPayload.encapsulation == PL\_CDR\_BE) msg->msg\_endian = BIGEND; else if (ch->serializedPayload.encapsulation == PL\_CDR\_LE) msg->msg\_endian = LITTLEEND; else { EPROSIMA\_LOG\_ERROR(RTPS\_MSG\_IN, IDSTRING"Bad encapsulation for KeyHash and status parameter list");[View remainder of file in raw view](https://github.com/eProsima/Fast-DDS/raw/refs/tags/v2.9.0/src/cpp/rtps/messages/MessageReceiver.cpp)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

