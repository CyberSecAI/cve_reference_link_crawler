

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=9f1c50cf39167ff71dc5953a3234f3f6eeb8fcb5)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=9f1c50cf39167ff71dc5953a3234f3f6eeb8fcb5)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9f1c50cf39167ff71dc5953a3234f3f6eeb8fcb5)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9f1c50cf39167ff71dc5953a3234f3f6eeb8fcb5)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | D. Wythe <alibuda@linux.alibaba.com> | 2022-02-24 23:26:19 +0800 |
| --- | --- | --- |
| committer | David S. Miller <davem@davemloft.net> | 2022-02-25 10:40:21 +0000 |
| commit | [9f1c50cf39167ff71dc5953a3234f3f6eeb8fcb5](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9f1c50cf39167ff71dc5953a3234f3f6eeb8fcb5) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=9f1c50cf39167ff71dc5953a3234f3f6eeb8fcb5)) | |
| tree | [537718b9c30efa02e3a3d96b9c25f7c672d143f5](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=9f1c50cf39167ff71dc5953a3234f3f6eeb8fcb5) | |
| parent | [087a7b944c5db409f7c1a68bf4896c56ba54eaff](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=087a7b944c5db409f7c1a68bf4896c56ba54eaff) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9f1c50cf39167ff71dc5953a3234f3f6eeb8fcb5&id2=087a7b944c5db409f7c1a68bf4896c56ba54eaff)) | |
| download | [linux-9f1c50cf39167ff71dc5953a3234f3f6eeb8fcb5.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-9f1c50cf39167ff71dc5953a3234f3f6eeb8fcb5.tar.gz) | |

net/smc: fix connection leakThere's a potential leak issue under following execution sequence :
smc\_release smc\_connect\_work
if (sk->sk\_state == SMC\_INIT)
send\_clc\_confirim
tcp\_abort();
...
sk.sk\_state = SMC\_ACTIVE
smc\_close\_active
switch(sk->sk\_state) {
...
case SMC\_ACTIVE:
smc\_close\_final()
// then wait peer closed
Unfortunately, tcp\_abort() may discard CLC CONFIRM messages that are
still in the tcp send buffer, in which case our connection token cannot
be delivered to the server side, which means that we cannot get a
passive close message at all. Therefore, it is impossible for the to be
disconnected at all.
This patch tries a very simple way to avoid this issue, once the state
has changed to SMC\_ACTIVE after tcp\_abort(), we can actively abort the
smc connection, considering that the state is SMC\_INIT before
tcp\_abort(), abandoning the complete disconnection process should not
cause too much problem.
In fact, this problem may exist as long as the CLC CONFIRM message is
not received by the server. Whether a timer should be added after
smc\_close\_final() needs to be discussed in the future. But even so, this
patch provides a faster release for connection in above case, it should
also be valuable.
Fixes: 39f41f367b08 ("net/smc: common release code for non-accepted sockets")
Signed-off-by: D. Wythe <alibuda@linux.alibaba.com>
Acked-by: Karsten Graul <kgraul@linux.ibm.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9f1c50cf39167ff71dc5953a3234f3f6eeb8fcb5)

| -rw-r--r-- | [net/smc/af\_smc.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/smc/af_smc.c?id=9f1c50cf39167ff71dc5953a3234f3f6eeb8fcb5) | 10 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 8 insertions, 2 deletions

| diff --git a/net/smc/af\_smc.c b/net/smc/af\_smc.cindex 306d9e8cd1ddce..81984c1c0e78aa 100644--- a/[net/smc/af\_smc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/smc/af_smc.c?id=087a7b944c5db409f7c1a68bf4896c56ba54eaff)+++ b/[net/smc/af\_smc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/smc/af_smc.c?id=9f1c50cf39167ff71dc5953a3234f3f6eeb8fcb5)@@ -183,7 +183,7 @@ static int smc\_release(struct socket \*sock) { struct sock \*sk = sock->sk; struct smc\_sock \*smc;- int rc = 0;+ int old\_state, rc = 0;  if (!sk) goto out;@@ -191,8 +191,10 @@ static int smc\_release(struct socket \*sock) sock\_hold(sk); /\* sock\_put below \*/ smc = smc\_sk(sk); + old\_state = sk->sk\_state;+ /\* cleanup for a dangling non-blocking connect \*/- if (smc->connect\_nonblock && sk->sk\_state == SMC\_INIT)+ if (smc->connect\_nonblock && old\_state == SMC\_INIT) tcp\_abort(smc->clcsock->sk, ECONNABORTED);  if (cancel\_work\_sync(&smc->connect\_work))@@ -206,6 +208,10 @@ static int smc\_release(struct socket \*sock) else lock\_sock(sk); + if (old\_state == SMC\_INIT && sk->sk\_state == SMC\_ACTIVE &&+ !smc->use\_fallback)+ smc\_close\_active\_abort(smc);+ rc = \_\_smc\_release(smc);  /\* detach socket \*/ |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 10:26:34 +0000

