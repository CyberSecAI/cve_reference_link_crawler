

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=2c49908634a2b97b1c3abe0589be2739ac5e7fd5)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=2c49908634a2b97b1c3abe0589be2739ac5e7fd5)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=2c49908634a2b97b1c3abe0589be2739ac5e7fd5)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=2c49908634a2b97b1c3abe0589be2739ac5e7fd5)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Qu Wenruo <wqu@suse.com> | 2024-06-17 15:18:44 +0930 |
| --- | --- | --- |
| committer | David Sterba <dsterba@suse.com> | 2024-06-25 00:34:16 +0200 |
| commit | [2c49908634a2b97b1c3abe0589be2739ac5e7fd5](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=2c49908634a2b97b1c3abe0589be2739ac5e7fd5) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=2c49908634a2b97b1c3abe0589be2739ac5e7fd5)) | |
| tree | [cca2be71108acb0e6fcdfad98a11610b77d21dc1](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=2c49908634a2b97b1c3abe0589be2739ac5e7fd5) | |
| parent | [b9fd2affe4aa99a4ca14ee87e1f38fea22ece52a](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b9fd2affe4aa99a4ca14ee87e1f38fea22ece52a) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=2c49908634a2b97b1c3abe0589be2739ac5e7fd5&id2=b9fd2affe4aa99a4ca14ee87e1f38fea22ece52a)) | |
| download | [linux-2c49908634a2b97b1c3abe0589be2739ac5e7fd5.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-2c49908634a2b97b1c3abe0589be2739ac5e7fd5.tar.gz) | |

btrfs: scrub: handle RST lookup error correctly[BUG]
When running btrfs/060 with forced RST feature, it would crash the
following ASSERT() inside scrub\_read\_endio():
ASSERT(sector\_nr < stripe->nr\_sectors);
Before that, we would have tree dump from
btrfs\_get\_raid\_extent\_offset(), as we failed to find the RST entry for
the range.
[CAUSE]
Inside scrub\_submit\_extent\_sector\_read() every time we allocated a new
bbio we immediately called btrfs\_map\_block() to make sure there was some
RST range covering the scrub target.
But if btrfs\_map\_block() fails, we immediately call endio for the bbio,
while the bbio is newly allocated, it's completely empty.
Then inside scrub\_read\_endio(), we go through the bvecs to find
the sector number (as bi\_sector is no longer reliable if the bio is
submitted to lower layers).
And since the bio is empty, such bvecs iteration would not find any
sector matching the sector, and return sector\_nr == stripe->nr\_sectors,
triggering the ASSERT().
[FIX]
Instead of calling btrfs\_map\_block() after allocating a new bbio, call
btrfs\_map\_block() first.
Since our only objective of calling btrfs\_map\_block() is only to update
stripe\_len, there is really no need to do that after btrfs\_alloc\_bio().
This new timing would avoid the problem of handling empty bbio
completely, and in fact fixes a possible race window for the old code,
where if the submission thread is the only owner of the pending\_io, the
scrub would never finish (since we didn't decrease the pending\_io
counter).
Although the root cause of RST lookup failure still needs to be
addressed.
Reviewed-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>
Signed-off-by: Qu Wenruo <wqu@suse.com>
Signed-off-by: David Sterba <dsterba@suse.com>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=2c49908634a2b97b1c3abe0589be2739ac5e7fd5)

| -rw-r--r-- | [fs/btrfs/scrub.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/scrub.c?id=2c49908634a2b97b1c3abe0589be2739ac5e7fd5) | 24 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 14 insertions, 10 deletions

| diff --git a/fs/btrfs/scrub.c b/fs/btrfs/scrub.cindex afd6932f5e895c..d7caa3732f074b 100644--- a/[fs/btrfs/scrub.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/scrub.c?id=b9fd2affe4aa99a4ca14ee87e1f38fea22ece52a)+++ b/[fs/btrfs/scrub.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/scrub.c?id=2c49908634a2b97b1c3abe0589be2739ac5e7fd5)@@ -1688,20 +1688,24 @@ static void scrub\_submit\_extent\_sector\_read(struct scrub\_ctx \*sctx, (i << fs\_info->sectorsize\_bits); int err; - bbio = btrfs\_bio\_alloc(stripe->nr\_sectors, REQ\_OP\_READ,- fs\_info, scrub\_read\_endio, stripe);- bbio->bio.bi\_iter.bi\_sector = logical >> SECTOR\_SHIFT;- io\_stripe.is\_scrub = true;+ stripe\_len = (nr\_sectors - i) << fs\_info->sectorsize\_bits;+ /\*+ \* For RST cases, we need to manually split the bbio to+ \* follow the RST boundary.+ \*/ err = btrfs\_map\_block(fs\_info, BTRFS\_MAP\_READ, logical,- &stripe\_len, &bioc, &io\_stripe,- &mirror);+ &stripe\_len, &bioc, &io\_stripe, &mirror); btrfs\_put\_bioc(bioc);- if (err) {- btrfs\_bio\_end\_io(bbio,- errno\_to\_blk\_status(err));- return;+ if (err < 0) {+ set\_bit(i, &stripe->io\_error\_bitmap);+ set\_bit(i, &stripe->error\_bitmap);+ continue; }++ bbio = btrfs\_bio\_alloc(stripe->nr\_sectors, REQ\_OP\_READ,+ fs\_info, scrub\_read\_endio, stripe);+ bbio->bio.bi\_iter.bi\_sector = logical >> SECTOR\_SHIFT; }  \_\_bio\_add\_page(&bbio->bio, page, fs\_info->sectorsize, pgoff); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 11:21:34 +0000

