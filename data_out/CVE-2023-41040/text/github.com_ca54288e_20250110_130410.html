
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fgitpython-developers%2FGitPython%2Fblob%2F1c8310d7cae144f74a671cbe17e51f63a830adbf%2Fgit%2Frefs%2Fsymbolic.py)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fgitpython-developers%2FGitPython%2Fblob%2F1c8310d7cae144f74a671cbe17e51f63a830adbf%2Fgit%2Frefs%2Fsymbolic.py)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=gitpython-developers%2FGitPython)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[gitpython-developers](/gitpython-developers)
/
**[GitPython](/gitpython-developers/GitPython)**
Public

* [Notifications](/login?return_to=%2Fgitpython-developers%2FGitPython) You must be signed in to change notification settings
* [Fork
  919](/login?return_to=%2Fgitpython-developers%2FGitPython)
* [Star
   4.7k](/login?return_to=%2Fgitpython-developers%2FGitPython)

* [Code](/gitpython-developers/GitPython)
* [Issues
  159](/gitpython-developers/GitPython/issues)
* [Pull requests
  4](/gitpython-developers/GitPython/pulls)
* [Discussions](/gitpython-developers/GitPython/discussions)
* [Actions](/gitpython-developers/GitPython/actions)
* [Security](/gitpython-developers/GitPython/security)
* [Insights](/gitpython-developers/GitPython/pulse)

Additional navigation options

* [Code](/gitpython-developers/GitPython)
* [Issues](/gitpython-developers/GitPython/issues)
* [Pull requests](/gitpython-developers/GitPython/pulls)
* [Discussions](/gitpython-developers/GitPython/discussions)
* [Actions](/gitpython-developers/GitPython/actions)
* [Security](/gitpython-developers/GitPython/security)
* [Insights](/gitpython-developers/GitPython/pulse)

## Files

 1c8310d
## Breadcrumbs

1. [GitPython](/gitpython-developers/GitPython/tree/1c8310d7cae144f74a671cbe17e51f63a830adbf)
2. /[git](/gitpython-developers/GitPython/tree/1c8310d7cae144f74a671cbe17e51f63a830adbf/git)
3. /[refs](/gitpython-developers/GitPython/tree/1c8310d7cae144f74a671cbe17e51f63a830adbf/git/refs)
/
# symbolic.py

 Blame  Blame
## Latest commit

## History

[History](/gitpython-developers/GitPython/commits/1c8310d7cae144f74a671cbe17e51f63a830adbf/git/refs/symbolic.py)767 lines (652 loc) · 29.3 KB 1c8310d
## Breadcrumbs

1. [GitPython](/gitpython-developers/GitPython/tree/1c8310d7cae144f74a671cbe17e51f63a830adbf)
2. /[git](/gitpython-developers/GitPython/tree/1c8310d7cae144f74a671cbe17e51f63a830adbf/git)
3. /[refs](/gitpython-developers/GitPython/tree/1c8310d7cae144f74a671cbe17e51f63a830adbf/git/refs)
/
# symbolic.py

Top
## File metadata and controls

* Code
* Blame

767 lines (652 loc) · 29.3 KB[Raw](https://github.com/gitpython-developers/GitPython/raw/1c8310d7cae144f74a671cbe17e51f63a830adbf/git/refs/symbolic.py)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767from git.types import PathLikeimport os
from git.compat import defencfrom git.objects import Objectfrom git.objects.commit import Commitfrom git.util import ( join\_path, join\_path\_native, to\_native\_path\_linux, assure\_directory\_exists, hex\_to\_bin, LockedFD,)from gitdb.exc import BadObject, BadName
from .log import RefLog
# typing ------------------------------------------------------------------
from typing import ( Any, Iterator, List, Tuple, Type, TypeVar, Union, TYPE\_CHECKING, cast,) # NOQAfrom git.types import Commit\_ish, PathLike # NOQA
if TYPE\_CHECKING: from git.repo import Repo from git.refs import Head, TagReference, RemoteReference, Reference from .log import RefLogEntry from git.config import GitConfigParser from git.objects.commit import Actor
T\_References = TypeVar("T\_References", bound="SymbolicReference")
# ------------------------------------------------------------------------------
\_\_all\_\_ = ["SymbolicReference"]
def \_git\_dir(repo: "Repo", path: Union[PathLike, None]) -> PathLike: """Find the git dir that's appropriate for the path""" name = f"{path}" if name in ["HEAD", "ORIG\_HEAD", "FETCH\_HEAD", "index", "logs"]: return repo.git\_dir return repo.common\_dir
class SymbolicReference(object):
 """Represents a special case of a reference such that this reference is symbolic. It does not point to a specific commit, but to another Head, which itself specifies a commit.
 A typical example for a symbolic reference is HEAD."""
 \_\_slots\_\_ = ("repo", "path") \_resolve\_ref\_on\_create = False \_points\_to\_commits\_only = True \_common\_path\_default = "" \_remote\_common\_path\_default = "refs/remotes" \_id\_attribute\_ = "name"
 def \_\_init\_\_(self, repo: "Repo", path: PathLike, check\_path: bool = False): self.repo = repo self.path = path
 def \_\_str\_\_(self) -> str: return str(self.path)
 def \_\_repr\_\_(self) -> str: return '<git.%s "%s">' % (self.\_\_class\_\_.\_\_name\_\_, self.path)
 def \_\_eq\_\_(self, other: object) -> bool: if hasattr(other, "path"): other = cast(SymbolicReference, other) return self.path == other.path return False
 def \_\_ne\_\_(self, other: object) -> bool: return not (self == other)
 def \_\_hash\_\_(self) -> int: return hash(self.path)
 @property def name(self) -> str: """ :return: In case of symbolic references, the shortest assumable name is the path itself.""" return str(self.path)
 @property def abspath(self) -> PathLike: return join\_path\_native(\_git\_dir(self.repo, self.path), self.path)
 @classmethod def \_get\_packed\_refs\_path(cls, repo: "Repo") -> str: return os.path.join(repo.common\_dir, "packed-refs")
 @classmethod def \_iter\_packed\_refs(cls, repo: "Repo") -> Iterator[Tuple[str, str]]: """Returns an iterator yielding pairs of sha1/path pairs (as strings) for the corresponding refs. :note: The packed refs file will be kept open as long as we iterate""" try: with open(cls.\_get\_packed\_refs\_path(repo), "rt", encoding="UTF-8") as fp: for line in fp: line = line.strip() if not line: continue if line.startswith("#"): # "# pack-refs with: peeled fully-peeled sorted" # the git source code shows "peeled", # "fully-peeled" and "sorted" as the keywords # that can go on this line, as per comments in git file # refs/packed-backend.c # I looked at master on 2017-10-11, # commit 111ef79afe, after tag v2.15.0-rc1 # from repo https://github.com/git/git.git if line.startswith("# pack-refs with:") and "peeled" not in line: raise TypeError("PackingType of packed-Refs not understood: %r" % line) # END abort if we do not understand the packing scheme continue # END parse comment
 # skip dereferenced tag object entries - previous line was actual # tag reference for it if line[0] == "^": continue
 yield cast(Tuple[str, str], tuple(line.split(" ", 1))) # END for each line except OSError: return None # END no packed-refs file handling # NOTE: Had try-finally block around here to close the fp, # but some python version wouldn't allow yields within that. # I believe files are closing themselves on destruction, so it is # alright.
 @classmethod def dereference\_recursive(cls, repo: "Repo", ref\_path: Union[PathLike, None]) -> str: """ :return: hexsha stored in the reference at the given ref\_path, recursively dereferencing all intermediate references as required :param repo: the repository containing the reference at ref\_path"""
 while True: hexsha, ref\_path = cls.\_get\_ref\_info(repo, ref\_path) if hexsha is not None: return hexsha # END recursive dereferencing
 @classmethod def \_get\_ref\_info\_helper( cls, repo: "Repo", ref\_path: Union[PathLike, None] ) -> Union[Tuple[str, None], Tuple[None, str]]: """Return: (str(sha), str(target\_ref\_path)) if available, the sha the file at rela\_path points to, or None. target\_ref\_path is the reference we point to, or None""" tokens: Union[None, List[str], Tuple[str, str]] = None repodir = \_git\_dir(repo, ref\_path) try: with open(os.path.join(repodir, str(ref\_path)), "rt", encoding="UTF-8") as fp: value = fp.read().rstrip() # Don't only split on spaces, but on whitespace, which allows to parse lines like # 60b64ef992065e2600bfef6187a97f92398a9144 branch 'master' of git-server:/path/to/repo tokens = value.split() assert len(tokens) != 0 except OSError: # Probably we are just packed, find our entry in the packed refs file # NOTE: We are not a symbolic ref if we are in a packed file, as these # are excluded explicitly for sha, path in cls.\_iter\_packed\_refs(repo): if path != ref\_path: continue # sha will be used tokens = sha, path break # END for each packed ref # END handle packed refs if tokens is None: raise ValueError("Reference at %r does not exist" % ref\_path)
 # is it a reference ? if tokens[0] == "ref:": return (None, tokens[1])
 # its a commit if repo.re\_hexsha\_only.match(tokens[0]): return (tokens[0], None)
 raise ValueError("Failed to parse reference information from %r" % ref\_path)
 @classmethod def \_get\_ref\_info(cls, repo: "Repo", ref\_path: Union[PathLike, None]) -> Union[Tuple[str, None], Tuple[None, str]]: """Return: (str(sha), str(target\_ref\_path)) if available, the sha the file at rela\_path points to, or None. target\_ref\_path is the reference we point to, or None""" return cls.\_get\_ref\_info\_helper(repo, ref\_path)
 def \_get\_object(self) -> Commit\_ish: """ :return: The object our ref currently refers to. Refs can be cached, they will always point to the actual object as it gets re-created on each query""" # have to be dynamic here as we may be a tag which can point to anything # Our path will be resolved to the hexsha which will be used accordingly return Object.new\_from\_sha(self.repo, hex\_to\_bin(self.dereference\_recursive(self.repo, self.path)))
 def \_get\_commit(self) -> "Commit": """ :return: Commit object we point to, works for detached and non-detached SymbolicReferences. The symbolic reference will be dereferenced recursively.""" obj = self.\_get\_object() if obj.type == "tag": obj = obj.object # END dereference tag
 if obj.type != Commit.type: raise TypeError("Symbolic Reference pointed to object %r, commit was required" % obj) # END handle type return obj
 def set\_commit( self, commit: Union[Commit, "SymbolicReference", str], logmsg: Union[str, None] = None, ) -> "SymbolicReference": """As set\_object, but restricts the type of object to be a Commit
 :raise ValueError: If commit is not a Commit object or doesn't point to a commit :return: self""" # check the type - assume the best if it is a base-string invalid\_type = False if isinstance(commit, Object): invalid\_type = commit.type != Commit.type elif isinstance(commit, SymbolicReference): invalid\_type = commit.object.type != Commit.type else: try: invalid\_type = self.repo.rev\_parse(commit).type != Commit.type except (BadObject, BadName) as e: raise ValueError("Invalid object: %s" % commit) from e # END handle exception # END verify type
 if invalid\_type: raise ValueError("Need commit, got %r" % commit) # END handle raise
 # we leave strings to the rev-parse method below self.set\_object(commit, logmsg)
 return self
 def set\_object( self, object: Union[Commit\_ish, "SymbolicReference", str], logmsg: Union[str, None] = None, ) -> "SymbolicReference": """Set the object we point to, possibly dereference our symbolic reference first. If the reference does not exist, it will be created
 :param object: a refspec, a SymbolicReference or an Object instance. SymbolicReferences will be dereferenced beforehand to obtain the object they point to :param logmsg: If not None, the message will be used in the reflog entry to be written. Otherwise the reflog is not altered :note: plain SymbolicReferences may not actually point to objects by convention :return: self""" if isinstance(object, SymbolicReference): object = object.object # @ReservedAssignment # END resolve references
 is\_detached = True try: is\_detached = self.is\_detached except ValueError: pass # END handle non-existing ones
 if is\_detached: return self.set\_reference(object, logmsg)
 # set the commit on our reference return self.\_get\_reference().set\_object(object, logmsg)
 commit = property(\_get\_commit, set\_commit, doc="Query or set commits directly") # type: ignore object = property(\_get\_object, set\_object, doc="Return the object our ref currently refers to") # type: ignore
 def \_get\_reference(self) -> "SymbolicReference": """:return: Reference Object we point to :raise TypeError: If this symbolic reference is detached, hence it doesn't point to a reference, but to a commit""" sha, target\_ref\_path = self.\_get\_ref\_info(self.repo, self.path) if target\_ref\_path is None: raise TypeError("%s is a detached symbolic reference as it points to %r" % (self, sha)) return self.from\_path(self.repo, target\_ref\_path)
 def set\_reference( self, ref: Union[Commit\_ish, "SymbolicReference", str], logmsg: Union[str, None] = None, ) -> "SymbolicReference": """Set ourselves to the given ref. It will stay a symbol if the ref is a Reference. Otherwise an Object, given as Object instance or refspec, is assumed and if valid, will be set which effectively detaches the reference if it was a purely symbolic one.
 :param ref: SymbolicReference instance, Object instance or refspec string Only if the ref is a SymbolicRef instance, we will point to it. Everything else is dereferenced to obtain the actual object. :param logmsg: If set to a string, the message will be used in the reflog. Otherwise, a reflog entry is not written for the changed reference. The previous commit of the entry will be the commit we point to now.
 See also: log\_append()
 :return: self :note: This symbolic reference will not be dereferenced. For that, see ``set\_object(...)``""" write\_value = None obj = None if isinstance(ref, SymbolicReference): write\_value = "ref: %s" % ref.path elif isinstance(ref, Object): obj = ref write\_value = ref.hexsha elif isinstance(ref, str): try: obj = self.repo.rev\_parse(ref + "^{}") # optionally deref tags write\_value = obj.hexsha except (BadObject, BadName) as e: raise ValueError("Could not extract object from %s" % ref) from e # END end try string else: raise ValueError("Unrecognized Value: %r" % ref) # END try commit attribute
 # typecheck if obj is not None and self.\_points\_to\_commits\_only and obj.type != Commit.type: raise TypeError("Require commit, got %r" % obj) # END verify type
 oldbinsha: bytes = b"" if logmsg is not None: try: oldbinsha = self.commit.binsha except ValueError: oldbinsha = Commit.NULL\_BIN\_SHA # END handle non-existing # END retrieve old hexsha
 fpath = self.abspath assure\_directory\_exists(fpath, is\_file=True)
 lfd = LockedFD(fpath) fd = lfd.open(write=True, stream=True) ok = True try: fd.write(write\_value.encode("utf-8") + b"\n") lfd.commit() ok = True finally: if not ok: lfd.rollback() # Adjust the reflog if logmsg is not None: self.log\_append(oldbinsha, logmsg)
 return self
 # aliased reference reference: Union["Head", "TagReference", "RemoteReference", "Reference"] reference = property(\_get\_reference, set\_reference, doc="Returns the Reference we point to") # type: ignore ref = reference
 def is\_valid(self) -> bool: """ :return: True if the reference is valid, hence it can be read and points to a valid object or reference.""" try: self.object except (OSError, ValueError): return False else: return True
 @property def is\_detached(self) -> bool: """ :return: True if we are a detached reference, hence we point to a specific commit instead to another reference""" try: self.ref return False except TypeError: return True
 def log(self) -> "RefLog": """ :return: RefLog for this reference. Its last entry reflects the latest change applied to this reference
 .. note:: As the log is parsed every time, its recommended to cache it for use instead of calling this method repeatedly. It should be considered read-only.""" return RefLog.from\_file(RefLog.path(self))
 def log\_append( self, oldbinsha: bytes, message: Union[str, None], newbinsha: Union[bytes, None] = None, ) -> "RefLogEntry": """Append a logentry to the logfile of this ref
 :param oldbinsha: binary sha this ref used to point to :param message: A message describing the change :param newbinsha: The sha the ref points to now. If None, our current commit sha will be used :return: added RefLogEntry instance""" # NOTE: we use the committer of the currently active commit - this should be # correct to allow overriding the committer on a per-commit level. # See https://github.com/gitpython-developers/GitPython/pull/146 try: committer\_or\_reader: Union["Actor", "GitConfigParser"] = self.commit.committer except ValueError: committer\_or\_reader = self.repo.config\_reader() # end handle newly cloned repositories if newbinsha is None: newbinsha = self.commit.binsha
 if message is None: message = ""
 return RefLog.append\_entry(committer\_or\_reader, RefLog.path(self), oldbinsha, newbinsha, message)
 def log\_entry(self, index: int) -> "RefLogEntry": """:return: RefLogEntry at the given index :param index: python list compatible positive or negative index
 .. note:: This method must read part of the reflog during execution, hence it should be used sparringly, or only if you need just one index. In that case, it will be faster than the ``log()`` method""" return RefLog.entry\_at(RefLog.path(self), index)
 @classmethod def to\_full\_path(cls, path: Union[PathLike, "SymbolicReference"]) -> PathLike: """ :return: string with a full repository-relative path which can be used to initialize a Reference instance, for instance by using ``Reference.from\_path``""" if isinstance(path, SymbolicReference): path = path.path full\_ref\_path = path if not cls.\_common\_path\_default: return full\_ref\_path if not str(path).startswith(cls.\_common\_path\_default + "/"): full\_ref\_path = "%s/%s" % (cls.\_common\_path\_default, path) return full\_ref\_path
 @classmethod def delete(cls, repo: "Repo", path: PathLike) -> None: """Delete the reference at the given path
 :param repo: Repository to delete the reference from
 :param path: Short or full path pointing to the reference, i.e. refs/myreference or just "myreference", hence 'refs/' is implied. Alternatively the symbolic reference to be deleted""" full\_ref\_path = cls.to\_full\_path(path) abs\_path = os.path.join(repo.common\_dir, full\_ref\_path) if os.path.exists(abs\_path): os.remove(abs\_path) else: # check packed refs pack\_file\_path = cls.\_get\_packed\_refs\_path(repo) try: with open(pack\_file\_path, "rb") as reader: new\_lines = [] made\_change = False dropped\_last\_line = False for line\_bytes in reader: line = line\_bytes.decode(defenc) \_, \_, line\_ref = line.partition(" ") line\_ref = line\_ref.strip() # keep line if it is a comment or if the ref to delete is not # in the line # If we deleted the last line and this one is a tag-reference object, # we drop it as well if (line.startswith("#") or full\_ref\_path != line\_ref) and ( not dropped\_last\_line or dropped\_last\_line and not line.startswith("^") ): new\_lines.append(line) dropped\_last\_line = False continue # END skip comments and lines without our path
 # drop this line made\_change = True dropped\_last\_line = True
 # write the new lines if made\_change: # write-binary is required, otherwise windows will # open the file in text mode and change LF to CRLF ! with open(pack\_file\_path, "wb") as fd: fd.writelines(line.encode(defenc) for line in new\_lines)
 except OSError: pass # it didn't exist at all
 # delete the reflog reflog\_path = RefLog.path(cls(repo, full\_ref\_path)) if os.path.isfile(reflog\_path): os.remove(reflog\_path) # END remove reflog
 @classmethod def \_create( cls: Type[T\_References], repo: "Repo", path: PathLike, resolve: bool, reference: Union["SymbolicReference", str], force: bool, logmsg: Union[str, None] = None, ) -> T\_References: """internal method used to create a new symbolic reference. If resolve is False, the reference will be taken as is, creating a proper symbolic reference. Otherwise it will be resolved to the corresponding object and a detached symbolic reference will be created instead""" git\_dir = \_git\_dir(repo, path) full\_ref\_path = cls.to\_full\_path(path) abs\_ref\_path = os.path.join(git\_dir, full\_ref\_path)
 # figure out target data target = reference if resolve: target = repo.rev\_parse(str(reference))
 if not force and os.path.isfile(abs\_ref\_path): target\_data = str(target) if isinstance(target, SymbolicReference): target\_data = str(target.path) if not resolve: target\_data = "ref: " + target\_data with open(abs\_ref\_path, "rb") as fd: existing\_data = fd.read().decode(defenc).strip() if existing\_data != target\_data: raise OSError( "Reference at %r does already exist, pointing to %r, requested was %r" % (full\_ref\_path, existing\_data, target\_data) ) # END no force handling
 ref = cls(repo, full\_ref\_path) ref.set\_reference(target, logmsg) return ref
 @classmethod def create( cls: Type[T\_References], repo: "Repo", path: PathLike, reference: Union["SymbolicReference", str] = "HEAD", logmsg: Union[str, None] = None, force: bool = False, \*\*kwargs: Any, ) -> T\_References: """Create a new symbolic reference, hence a reference pointing , to another reference.
 :param repo: Repository to create the reference in
 :param path: full path at which the new symbolic reference is supposed to be created at, i.e. "NEW\_HEAD" or "symrefs/my\_new\_symref"
 :param reference: The reference to which the new symbolic reference should point to. If it is a commit'ish, the symbolic ref will be detached.
 :param force: if True, force creation even if a symbolic reference with that name already exists. Raise OSError otherwise
 :param logmsg: If not None, the message to append to the reflog. Otherwise no reflog entry is written.
 :return: Newly created symbolic Reference
 :raise OSError: If a (Symbolic)Reference with the same name but different contents already exists.
 :note: This does not alter the current HEAD, index or Working Tree""" return cls.\_create(repo, path, cls.\_resolve\_ref\_on\_create, reference, force, logmsg)
 def rename(self, new\_path: PathLike, force: bool = False) -> "SymbolicReference": """Rename self to a new path
 :param new\_path: Either a simple name or a full path, i.e. new\_name or features/new\_name. The prefix refs/ is implied for references and will be set as needed. In case this is a symbolic ref, there is no implied prefix
 :param force: If True, the rename will succeed even if a head with the target name already exists. It will be overwritten in that case
 :return: self :raise OSError: In case a file at path but a different contents already exists""" new\_path = self.to\_full\_path(new\_path) if self.path == new\_path: return self
 new\_abs\_path = os.path.join(\_git\_dir(self.repo, new\_path), new\_path) cur\_abs\_path = os.path.join(\_git\_dir(self.repo, self.path), self.path) if os.path.isfile(new\_abs\_path): if not force: # if they point to the same file, its not an error with open(new\_abs\_path, "rb") as fd1: f1 = fd1.read().strip() with open(cur\_abs\_path, "rb") as fd2: f2 = fd2.read().strip() if f1 != f2: raise OSError("File at path %r already exists" % new\_abs\_path) # else: we could remove ourselves and use the otherone, but # but clarity we just continue as usual # END not force handling os.remove(new\_abs\_path) # END handle existing target file
 dname = os.path.dirname(new\_abs\_path) if not os.path.isdir(dname): os.makedirs(dname) # END create directory
 os.rename(cur\_abs\_path, new\_abs\_path) self.path = new\_path
 return self
 @classmethod def \_iter\_items( cls: Type[T\_References], repo: "Repo", common\_path: Union[PathLike, None] = None ) -> Iterator[T\_References]: if common\_path is None: common\_path = cls.\_common\_path\_default rela\_paths = set()
 # walk loose refs # Currently we do not follow links for root, dirs, files in os.walk(join\_path\_native(repo.common\_dir, common\_path)): if "refs" not in root.split(os.sep): # skip non-refs subfolders refs\_id = [d for d in dirs if d == "refs"] if refs\_id: dirs[0:] = ["refs"] # END prune non-refs folders
 for f in files: if f == "packed-refs": continue abs\_path = to\_native\_path\_linux(join\_path(root, f)) rela\_paths.add(abs\_path.replace(to\_native\_path\_linux(repo.common\_dir) + "/", "")) # END for each file in root directory # END for each directory to walk
 # read packed refs for \_sha, rela\_path in cls.\_iter\_packed\_refs(repo): if rela\_path.startswith(str(common\_path)): rela\_paths.add(rela\_path) # END relative path matches common path # END packed refs reading
 # return paths in sorted order for path in sorted(rela\_paths): try: yield cls.from\_path(repo, path) except ValueError: continue # END for each sorted relative refpath
 @classmethod def iter\_items( cls: Type[T\_References], repo: "Repo", common\_path: Union[PathLike, None] = None, \*args: Any, \*\*kwargs: Any, ) -> Iterator[T\_References]: """Find all refs in the repository
 :param repo: is the Repo
 :param common\_path: Optional keyword argument to the path which is to be shared by all returned Ref objects. Defaults to class specific portion if None assuring that only refs suitable for the actual class are returned.
 :return: git.SymbolicReference[], each of them is guaranteed to be a symbolic ref which is not detached and pointing to a valid ref
 List is lexicographically sorted The returned objects represent actual subclasses, such as Head or TagReference""" return (r for r in cls.\_iter\_items(repo, common\_path) if r.\_\_class\_\_ == SymbolicReference or not r.is\_detached)
 @classmethod def from\_path(cls: Type[T\_References], repo: "Repo", path: PathLike) -> T\_References: """ :param path: full .git-directory-relative path name to the Reference to instantiate :note: use to\_full\_path() if you only have a partial path of a known Reference Type :return: Instance of type Reference, Head, or Tag depending on the given path""" if not path: raise ValueError("Cannot create Reference from %r" % path)
 # Names like HEAD are inserted after the refs module is imported - we have an import dependency # cycle and don't want to import these names in-function from . import HEAD, Head, RemoteReference, TagReference, Reference
 for ref\_type in ( HEAD, Head, RemoteReference, TagReference, Reference, SymbolicReference, ): try: instance: T\_References instance = ref\_type(repo, path) if instance.\_\_class\_\_ == SymbolicReference and instance.is\_detached: raise ValueError("SymbolRef was detached, we drop it") else: return instance
 except ValueError: pass # END exception handling # END for each type to try raise ValueError("Could not find reference type suitable to handle path %r" % path)
 def is\_remote(self) -> bool: """:return: True if this symbolic reference points to a remote branch""" return str(self.path).startswith(self.\_remote\_common\_path\_default + "/")

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

