=== Content from git.kernel.org_d255c51b_20250110_221325.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=062a7f0ff46eb57aff526897bd2bebfdb1d3046a)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=062a7f0ff46eb57aff526897bd2bebfdb1d3046a)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=062a7f0ff46eb57aff526897bd2bebfdb1d3046a)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=062a7f0ff46eb57aff526897bd2bebfdb1d3046a)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Paulo Alcantara <pc@manguebit.com> | 2024-04-01 22:37:42 -0500 |
| --- | --- | --- |
| committer | Steve French <stfrench@microsoft.com> | 2024-04-02 10:09:57 -0500 |
| commit | [062a7f0ff46eb57aff526897bd2bebfdb1d3046a](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=062a7f0ff46eb57aff526897bd2bebfdb1d3046a) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=062a7f0ff46eb57aff526897bd2bebfdb1d3046a)) | |
| tree | [a65b2e2e9eb0cd89761ac42b93993765a2f2c23b](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=062a7f0ff46eb57aff526897bd2bebfdb1d3046a) | |
| parent | [e9e62243a3e2322cf639f653a0b0a88a76446ce7](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e9e62243a3e2322cf639f653a0b0a88a76446ce7) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=062a7f0ff46eb57aff526897bd2bebfdb1d3046a&id2=e9e62243a3e2322cf639f653a0b0a88a76446ce7)) | |
| download | [linux-062a7f0ff46eb57aff526897bd2bebfdb1d3046a.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-062a7f0ff46eb57aff526897bd2bebfdb1d3046a.tar.gz) | |

smb: client: guarantee refcounted children from parent sessionAvoid potential use-after-free bugs when walking DFS referrals,
mounting and performing DFS failover by ensuring that all children
from parent @tcon->ses are also refcounted. They're all needed across
the entire DFS mount. Get rid of @tcon->dfs\_ses\_list while we're at
it, too.
Cc: stable@vger.kernel.org # 6.4+
Reported-by: kernel test robot <lkp@intel.com>
Closes: https://lore.kernel.org/oe-kbuild-all/202404021527.ZlRkIxgv-lkp@intel.com/
Signed-off-by: Paulo Alcantara (Red Hat) <pc@manguebit.com>
Signed-off-by: Steve French <stfrench@microsoft.com>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=062a7f0ff46eb57aff526897bd2bebfdb1d3046a)

| -rw-r--r-- | [fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/cifsglob.h?id=062a7f0ff46eb57aff526897bd2bebfdb1d3046a) | 2 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/smb/client/cifsproto.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/cifsproto.h?id=062a7f0ff46eb57aff526897bd2bebfdb1d3046a) | 20 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/connect.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/connect.c?id=062a7f0ff46eb57aff526897bd2bebfdb1d3046a) | 25 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/dfs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/dfs.c?id=062a7f0ff46eb57aff526897bd2bebfdb1d3046a) | 51 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/dfs.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/dfs.h?id=062a7f0ff46eb57aff526897bd2bebfdb1d3046a) | 33 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/dfs\_cache.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/dfs_cache.c?id=062a7f0ff46eb57aff526897bd2bebfdb1d3046a) | 11 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/misc.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/misc.c?id=062a7f0ff46eb57aff526897bd2bebfdb1d3046a) | 6 | |  |  |  | | --- | --- | --- | |

7 files changed, 76 insertions, 72 deletions

| diff --git a/fs/smb/client/cifsglob.h b/fs/smb/client/cifsglob.hindex 7ed9d05f6890b4..286afbe346be0a 100644--- a/[fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsglob.h?id=e9e62243a3e2322cf639f653a0b0a88a76446ce7)+++ b/[fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsglob.h?id=062a7f0ff46eb57aff526897bd2bebfdb1d3046a)@@ -1281,7 +1281,6 @@ struct cifs\_tcon { struct cached\_fids \*cfids; /\* BB add field for back pointer to sb struct(s)? \*/ #ifdef CONFIG\_CIFS\_DFS\_UPCALL- struct list\_head dfs\_ses\_list; struct delayed\_work dfs\_cache\_work; #endif struct delayed\_work query\_interfaces; /\* query interfaces workqueue job \*/@@ -1804,7 +1803,6 @@ struct cifs\_mount\_ctx { struct TCP\_Server\_Info \*server; struct cifs\_ses \*ses; struct cifs\_tcon \*tcon;- struct list\_head dfs\_ses\_list; };  static inline void \_\_free\_dfs\_info\_param(struct dfs\_info3\_param \*param)diff --git a/fs/smb/client/cifsproto.h b/fs/smb/client/cifsproto.hindex 0723e1b57256b8..8e0a348f1f660e 100644--- a/[fs/smb/client/cifsproto.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsproto.h?id=e9e62243a3e2322cf639f653a0b0a88a76446ce7)+++ b/[fs/smb/client/cifsproto.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsproto.h?id=062a7f0ff46eb57aff526897bd2bebfdb1d3046a)@@ -725,31 +725,31 @@ struct super\_block \*cifs\_get\_tcon\_super(struct cifs\_tcon \*tcon); void cifs\_put\_tcon\_super(struct super\_block \*sb); int cifs\_wait\_for\_server\_reconnect(struct TCP\_Server\_Info \*server, bool retry); -/\* Put references of @ses and @ses->dfs\_root\_ses \*/+/\* Put references of @ses and its children \*/ static inline void cifs\_put\_smb\_ses(struct cifs\_ses \*ses) {- struct cifs\_ses \*rses = ses->dfs\_root\_ses;+ struct cifs\_ses \*next; - \_\_cifs\_put\_smb\_ses(ses);- if (rses)- \_\_cifs\_put\_smb\_ses(rses);+ do {+ next = ses->dfs\_root\_ses;+ \_\_cifs\_put\_smb\_ses(ses);+ } while ((ses = next)); } -/\* Get an active reference of @ses and @ses->dfs\_root\_ses.+/\* Get an active reference of @ses and its children. \* \* NOTE: make sure to call this function when incrementing reference count of \* @ses to ensure that any DFS root session attached to it (@ses->dfs\_root\_ses) \* will also get its reference count incremented. \*- \* cifs\_put\_smb\_ses() will put both references, so call it when you're done.+ \* cifs\_put\_smb\_ses() will put all references, so call it when you're done. \*/ static inline void cifs\_smb\_ses\_inc\_refcount(struct cifs\_ses \*ses) { lockdep\_assert\_held(&cifs\_tcp\_ses\_lock); - ses->ses\_count++;- if (ses->dfs\_root\_ses)- ses->dfs\_root\_ses->ses\_count++;+ for (; ses; ses = ses->dfs\_root\_ses)+ ses->ses\_count++; }  static inline bool dfs\_src\_pathname\_equal(const char \*s1, const char \*s2)diff --git a/fs/smb/client/connect.c b/fs/smb/client/connect.cindex ee29bc57300cdb..38b75cfa06e3e5 100644--- a/[fs/smb/client/connect.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/connect.c?id=e9e62243a3e2322cf639f653a0b0a88a76446ce7)+++ b/[fs/smb/client/connect.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/connect.c?id=062a7f0ff46eb57aff526897bd2bebfdb1d3046a)@@ -1866,6 +1866,9 @@ static int match\_session(struct cifs\_ses \*ses, struct smb3\_fs\_context \*ctx) ctx->sectype != ses->sectype) return 0; + if (ctx->dfs\_root\_ses != ses->dfs\_root\_ses)+ return 0;+ /\* \* If an existing session is limited to less channels than \* requested, it should not be reused@@ -2358,9 +2361,9 @@ cifs\_get\_smb\_ses(struct TCP\_Server\_Info \*server, struct smb3\_fs\_context \*ctx) \* need to lock before changing something in the session. \*/ spin\_lock(&cifs\_tcp\_ses\_lock);+ if (ctx->dfs\_root\_ses)+ cifs\_smb\_ses\_inc\_refcount(ctx->dfs\_root\_ses); ses->dfs\_root\_ses = ctx->dfs\_root\_ses;- if (ses->dfs\_root\_ses)- ses->dfs\_root\_ses->ses\_count++; list\_add(&ses->smb\_ses\_list, &server->smb\_ses\_list); spin\_unlock(&cifs\_tcp\_ses\_lock); @@ -3311,6 +3314,9 @@ void cifs\_mount\_put\_conns(struct cifs\_mount\_ctx \*mnt\_ctx) cifs\_put\_smb\_ses(mnt\_ctx->ses); else if (mnt\_ctx->server) cifs\_put\_tcp\_session(mnt\_ctx->server, 0);+ mnt\_ctx->ses = NULL;+ mnt\_ctx->tcon = NULL;+ mnt\_ctx->server = NULL; mnt\_ctx->cifs\_sb->mnt\_cifs\_flags &= ~CIFS\_MOUNT\_POSIX\_PATHS; free\_xid(mnt\_ctx->xid); }@@ -3589,8 +3595,6 @@ int cifs\_mount(struct cifs\_sb\_info \*cifs\_sb, struct smb3\_fs\_context \*ctx) bool isdfs; int rc; - INIT\_LIST\_HEAD(&mnt\_ctx.dfs\_ses\_list);- rc = dfs\_mount\_share(&mnt\_ctx, &isdfs); if (rc) goto error;@@ -3621,7 +3625,6 @@ out: return rc;  error:- dfs\_put\_root\_smb\_sessions(&mnt\_ctx.dfs\_ses\_list); cifs\_mount\_put\_conns(&mnt\_ctx); return rc; }@@ -3636,6 +3639,18 @@ int cifs\_mount(struct cifs\_sb\_info \*cifs\_sb, struct smb3\_fs\_context \*ctx) goto error;  rc = cifs\_mount\_get\_tcon(&mnt\_ctx);+ if (!rc) {+ /\*+ \* Prevent superblock from being created with any missing+ \* connections.+ \*/+ if (WARN\_ON(!mnt\_ctx.server))+ rc = -EHOSTDOWN;+ else if (WARN\_ON(!mnt\_ctx.ses))+ rc = -EACCES;+ else if (WARN\_ON(!mnt\_ctx.tcon))+ rc = -ENOENT;+ } if (rc) goto error; diff --git a/fs/smb/client/dfs.c b/fs/smb/client/dfs.cindex 449c59830039bc..3ec965547e3d4d 100644--- a/[fs/smb/client/dfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/dfs.c?id=e9e62243a3e2322cf639f653a0b0a88a76446ce7)+++ b/[fs/smb/client/dfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/dfs.c?id=062a7f0ff46eb57aff526897bd2bebfdb1d3046a)@@ -66,33 +66,20 @@ static int get\_session(struct cifs\_mount\_ctx \*mnt\_ctx, const char \*full\_path) }  /\*- \* Track individual DFS referral servers used by new DFS mount.- \*- \* On success, their lifetime will be shared by final tcon (dfs\_ses\_list).- \* Otherwise, they will be put by dfs\_put\_root\_smb\_sessions() in cifs\_mount().+ \* Get an active reference of @ses so that next call to cifs\_put\_tcon() won't+ \* release it as any new DFS referrals must go through its IPC tcon. \*/-static int add\_root\_smb\_session(struct cifs\_mount\_ctx \*mnt\_ctx)+static void add\_root\_smb\_session(struct cifs\_mount\_ctx \*mnt\_ctx) { struct smb3\_fs\_context \*ctx = mnt\_ctx->fs\_ctx;- struct dfs\_root\_ses \*root\_ses; struct cifs\_ses \*ses = mnt\_ctx->ses;  if (ses) {- root\_ses = kmalloc(sizeof(\*root\_ses), GFP\_KERNEL);- if (!root\_ses)- return -ENOMEM;-- INIT\_LIST\_HEAD(&root\_ses->list);- spin\_lock(&cifs\_tcp\_ses\_lock); cifs\_smb\_ses\_inc\_refcount(ses); spin\_unlock(&cifs\_tcp\_ses\_lock);- root\_ses->ses = ses;- list\_add\_tail(&root\_ses->list, &mnt\_ctx->dfs\_ses\_list); }- /\* Select new DFS referral server so that new referrals go through it \*/ ctx->dfs\_root\_ses = ses;- return 0; }  static inline int parse\_dfs\_target(struct smb3\_fs\_context \*ctx,@@ -185,11 +172,8 @@ again: continue; } - if (is\_refsrv) {- rc = add\_root\_smb\_session(mnt\_ctx);- if (rc)- goto out;- }+ if (is\_refsrv)+ add\_root\_smb\_session(mnt\_ctx);  rc = ref\_walk\_advance(rw); if (!rc) {@@ -232,6 +216,7 @@ static int \_\_dfs\_mount\_share(struct cifs\_mount\_ctx \*mnt\_ctx) struct smb3\_fs\_context \*ctx = mnt\_ctx->fs\_ctx; struct cifs\_tcon \*tcon; char \*origin\_fullpath;+ bool new\_tcon = true; int rc;  origin\_fullpath = dfs\_get\_path(cifs\_sb, ctx->source);@@ -239,6 +224,18 @@ static int \_\_dfs\_mount\_share(struct cifs\_mount\_ctx \*mnt\_ctx) return PTR\_ERR(origin\_fullpath);  rc = dfs\_referral\_walk(mnt\_ctx);+ if (!rc) {+ /\*+ \* Prevent superblock from being created with any missing+ \* connections.+ \*/+ if (WARN\_ON(!mnt\_ctx->server))+ rc = -EHOSTDOWN;+ else if (WARN\_ON(!mnt\_ctx->ses))+ rc = -EACCES;+ else if (WARN\_ON(!mnt\_ctx->tcon))+ rc = -ENOENT;+ } if (rc) goto out; @@ -247,15 +244,14 @@ static int \_\_dfs\_mount\_share(struct cifs\_mount\_ctx \*mnt\_ctx) if (!tcon->origin\_fullpath) { tcon->origin\_fullpath = origin\_fullpath; origin\_fullpath = NULL;+ } else {+ new\_tcon = false; } spin\_unlock(&tcon->tc\_lock); - if (list\_empty(&tcon->dfs\_ses\_list)) {- list\_replace\_init(&mnt\_ctx->dfs\_ses\_list, &tcon->dfs\_ses\_list);+ if (new\_tcon) { queue\_delayed\_work(dfscache\_wq, &tcon->dfs\_cache\_work, dfs\_cache\_get\_ttl() \* HZ);- } else {- dfs\_put\_root\_smb\_sessions(&mnt\_ctx->dfs\_ses\_list); }  out:@@ -298,7 +294,6 @@ int dfs\_mount\_share(struct cifs\_mount\_ctx \*mnt\_ctx, bool \*isdfs) if (rc) return rc; - ctx->dfs\_root\_ses = mnt\_ctx->ses; /\* \* If called with 'nodfs' mount option, then skip DFS resolving. Otherwise unconditionally \* try to get an DFS referral (even cached) to determine whether it is an DFS mount.@@ -324,7 +319,9 @@ int dfs\_mount\_share(struct cifs\_mount\_ctx \*mnt\_ctx, bool \*isdfs)  \*isdfs = true; add\_root\_smb\_session(mnt\_ctx);- return \_\_dfs\_mount\_share(mnt\_ctx);+ rc = \_\_dfs\_mount\_share(mnt\_ctx);+ dfs\_put\_root\_smb\_sessions(mnt\_ctx);+ return rc; }  /\* Update dfs referral path of superblock \*/diff --git a/fs/smb/client/dfs.h b/fs/smb/client/dfs.hindex 875ab7ae57fcdf..e5c4dcf837503a 100644--- a/[fs/smb/client/dfs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/dfs.h?id=e9e62243a3e2322cf639f653a0b0a88a76446ce7)+++ b/[fs/smb/client/dfs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/dfs.h?id=062a7f0ff46eb57aff526897bd2bebfdb1d3046a)@@ -7,7 +7,9 @@ #define \_CIFS\_DFS\_H  #include "cifsglob.h"+#include "cifsproto.h" #include "fs\_context.h"+#include "dfs\_cache.h" #include "cifs\_unicode.h" #include <linux/namei.h> @@ -114,11 +116,6 @@ static inline void ref\_walk\_set\_tgt\_hint(struct dfs\_ref\_walk \*rw) ref\_walk\_tit(rw)); } -struct dfs\_root\_ses {- struct list\_head list;- struct cifs\_ses \*ses;-};- int dfs\_parse\_target\_referral(const char \*full\_path, const struct dfs\_info3\_param \*ref, struct smb3\_fs\_context \*ctx); int dfs\_mount\_share(struct cifs\_mount\_ctx \*mnt\_ctx, bool \*isdfs);@@ -133,20 +130,32 @@ static inline int dfs\_get\_referral(struct cifs\_mount\_ctx \*mnt\_ctx, const char \*p { struct smb3\_fs\_context \*ctx = mnt\_ctx->fs\_ctx; struct cifs\_sb\_info \*cifs\_sb = mnt\_ctx->cifs\_sb;+ struct cifs\_ses \*rses = ctx->dfs\_root\_ses ?: mnt\_ctx->ses; - return dfs\_cache\_find(mnt\_ctx->xid, ctx->dfs\_root\_ses, cifs\_sb->local\_nls,+ return dfs\_cache\_find(mnt\_ctx->xid, rses, cifs\_sb->local\_nls, cifs\_remap(cifs\_sb), path, ref, tl); } -static inline void dfs\_put\_root\_smb\_sessions(struct list\_head \*head)+/\*+ \* cifs\_get\_smb\_ses() already guarantees an active reference of+ \* @ses->dfs\_root\_ses when a new session is created, so we need to put extra+ \* references of all DFS root sessions that were used across the mount process+ \* in dfs\_mount\_share().+ \*/+static inline void dfs\_put\_root\_smb\_sessions(struct cifs\_mount\_ctx \*mnt\_ctx) {- struct dfs\_root\_ses \*root, \*tmp;+ const struct smb3\_fs\_context \*ctx = mnt\_ctx->fs\_ctx;+ struct cifs\_ses \*ses = ctx->dfs\_root\_ses;+ struct cifs\_ses \*cur;++ if (!ses)+ return; - list\_for\_each\_entry\_safe(root, tmp, head, list) {- list\_del\_init(&root->list);- cifs\_put\_smb\_ses(root->ses);- kfree(root);+ for (cur = ses; cur; cur = cur->dfs\_root\_ses) {+ if (cur->dfs\_root\_ses)+ cifs\_put\_smb\_ses(cur->dfs\_root\_ses); }+ cifs\_put\_smb\_ses(ses); }  #endif /\* \_CIFS\_DFS\_H \*/diff --git a/fs/smb/client/dfs\_cache.c b/fs/smb/client/dfs\_cache.cindex 508d831fabe378..0552a864ff08f9 100644--- a/[fs/smb/client/dfs\_cache.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/dfs_cache.c?id=e9e62243a3e2322cf639f653a0b0a88a76446ce7)+++ b/[fs/smb/client/dfs\_cache.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/dfs_cache.c?id=062a7f0ff46eb57aff526897bd2bebfdb1d3046a)@@ -1278,21 +1278,12 @@ int dfs\_cache\_remount\_fs(struct cifs\_sb\_info \*cifs\_sb) void dfs\_cache\_refresh(struct work\_struct \*work) { struct TCP\_Server\_Info \*server;- struct dfs\_root\_ses \*rses; struct cifs\_tcon \*tcon; struct cifs\_ses \*ses;  tcon = container\_of(work, struct cifs\_tcon, dfs\_cache\_work.work);- ses = tcon->ses;- server = ses->server; - mutex\_lock(&server->refpath\_lock);- if (server->leaf\_fullpath)- \_\_refresh\_tcon(server->leaf\_fullpath + 1, ses, false);- mutex\_unlock(&server->refpath\_lock);-- list\_for\_each\_entry(rses, &tcon->dfs\_ses\_list, list) {- ses = rses->ses;+ for (ses = tcon->ses; ses; ses = ses->dfs\_root\_ses) { server = ses->server; mutex\_lock(&server->refpath\_lock); if (server->leaf\_fullpath)diff --git a/fs/smb/client/misc.c b/fs/smb/client/misc.cindex c3771fc81328ff..1ea22b3955a2f4 100644--- a/[fs/smb/client/misc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/misc.c?id=e9e62243a3e2322cf639f653a0b0a88a76446ce7)+++ b/[fs/smb/client/misc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/misc.c?id=062a7f0ff46eb57aff526897bd2bebfdb1d3046a)@@ -138,9 +138,6 @@ tcon\_info\_alloc(bool dir\_leases\_enabled) atomic\_set(&ret\_buf->num\_local\_opens, 0); atomic\_set(&ret\_buf->num\_remote\_opens, 0); ret\_buf->stats\_from\_time = ktime\_get\_real\_seconds();-#ifdef CONFIG\_CIFS\_DFS\_UPCALL- INIT\_LIST\_HEAD(&ret\_buf->dfs\_ses\_list);-#endif  return ret\_buf; }@@ -156,9 +153,6 @@ tconInfoFree(struct cifs\_tcon \*tcon) atomic\_dec(&tconInfoAllocCount); kfree(tcon->nativeFileSystem); kfree\_sensitive(tcon->password);-#ifdef CONFIG\_CIFS\_DFS\_UPCALL- dfs\_put\_root\_smb\_sessions(&tcon->dfs\_ses\_list);-#endif kfree(tcon->origin\_fullpath); kfree(tcon); } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 22:12:02 +0000



=== Content from git.kernel.org_aadaf969_20250110_221326.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=645f332c6b63499cc76197f9b6bffcc659ba64cc)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=645f332c6b63499cc76197f9b6bffcc659ba64cc)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=645f332c6b63499cc76197f9b6bffcc659ba64cc)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=645f332c6b63499cc76197f9b6bffcc659ba64cc)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Paulo Alcantara <pc@manguebit.com> | 2024-04-01 22:37:42 -0500 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-04-27 17:11:28 +0200 |
| commit | [645f332c6b63499cc76197f9b6bffcc659ba64cc](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=645f332c6b63499cc76197f9b6bffcc659ba64cc) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=645f332c6b63499cc76197f9b6bffcc659ba64cc)) | |
| tree | [4ae7a8e071872b942647b54b797c315a4ee8186f](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=645f332c6b63499cc76197f9b6bffcc659ba64cc) | |
| parent | [441786be0c197c30851ac63fa3a4d79332b11dff](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=441786be0c197c30851ac63fa3a4d79332b11dff) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=645f332c6b63499cc76197f9b6bffcc659ba64cc&id2=441786be0c197c30851ac63fa3a4d79332b11dff)) | |
| download | [linux-645f332c6b63499cc76197f9b6bffcc659ba64cc.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-645f332c6b63499cc76197f9b6bffcc659ba64cc.tar.gz) | |

smb: client: guarantee refcounted children from parent session[ Upstream commit 062a7f0ff46eb57aff526897bd2bebfdb1d3046a ]
Avoid potential use-after-free bugs when walking DFS referrals,
mounting and performing DFS failover by ensuring that all children
from parent @tcon->ses are also refcounted. They're all needed across
the entire DFS mount. Get rid of @tcon->dfs\_ses\_list while we're at
it, too.
Cc: stable@vger.kernel.org # 6.4+
Reported-by: kernel test robot <lkp@intel.com>
Closes: https://lore.kernel.org/oe-kbuild-all/202404021527.ZlRkIxgv-lkp@intel.com/
Signed-off-by: Paulo Alcantara (Red Hat) <pc@manguebit.com>
Signed-off-by: Steve French <stfrench@microsoft.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=645f332c6b63499cc76197f9b6bffcc659ba64cc)

| -rw-r--r-- | [fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/cifsglob.h?id=645f332c6b63499cc76197f9b6bffcc659ba64cc) | 2 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/smb/client/cifsproto.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/cifsproto.h?id=645f332c6b63499cc76197f9b6bffcc659ba64cc) | 20 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/connect.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/connect.c?id=645f332c6b63499cc76197f9b6bffcc659ba64cc) | 25 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/dfs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/dfs.c?id=645f332c6b63499cc76197f9b6bffcc659ba64cc) | 51 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/dfs.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/dfs.h?id=645f332c6b63499cc76197f9b6bffcc659ba64cc) | 33 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/dfs\_cache.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/dfs_cache.c?id=645f332c6b63499cc76197f9b6bffcc659ba64cc) | 11 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/misc.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/misc.c?id=645f332c6b63499cc76197f9b6bffcc659ba64cc) | 6 | |  |  |  | | --- | --- | --- | |

7 files changed, 76 insertions, 72 deletions

| diff --git a/fs/smb/client/cifsglob.h b/fs/smb/client/cifsglob.hindex 01d7031194671d..68fd61a5640893 100644--- a/[fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsglob.h?id=441786be0c197c30851ac63fa3a4d79332b11dff)+++ b/[fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsglob.h?id=645f332c6b63499cc76197f9b6bffcc659ba64cc)@@ -1253,7 +1253,6 @@ struct cifs\_tcon { struct cached\_fids \*cfids; /\* BB add field for back pointer to sb struct(s)? \*/ #ifdef CONFIG\_CIFS\_DFS\_UPCALL- struct list\_head dfs\_ses\_list; struct delayed\_work dfs\_cache\_work; #endif struct delayed\_work query\_interfaces; /\* query interfaces workqueue job \*/@@ -1775,7 +1774,6 @@ struct cifs\_mount\_ctx { struct TCP\_Server\_Info \*server; struct cifs\_ses \*ses; struct cifs\_tcon \*tcon;- struct list\_head dfs\_ses\_list; };  static inline void \_\_free\_dfs\_info\_param(struct dfs\_info3\_param \*param)diff --git a/fs/smb/client/cifsproto.h b/fs/smb/client/cifsproto.hindex ed257612bf0bc1..1bdad33580b572 100644--- a/[fs/smb/client/cifsproto.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsproto.h?id=441786be0c197c30851ac63fa3a4d79332b11dff)+++ b/[fs/smb/client/cifsproto.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsproto.h?id=645f332c6b63499cc76197f9b6bffcc659ba64cc)@@ -716,31 +716,31 @@ struct super\_block \*cifs\_get\_tcon\_super(struct cifs\_tcon \*tcon); void cifs\_put\_tcon\_super(struct super\_block \*sb); int cifs\_wait\_for\_server\_reconnect(struct TCP\_Server\_Info \*server, bool retry); -/\* Put references of @ses and @ses->dfs\_root\_ses \*/+/\* Put references of @ses and its children \*/ static inline void cifs\_put\_smb\_ses(struct cifs\_ses \*ses) {- struct cifs\_ses \*rses = ses->dfs\_root\_ses;+ struct cifs\_ses \*next; - \_\_cifs\_put\_smb\_ses(ses);- if (rses)- \_\_cifs\_put\_smb\_ses(rses);+ do {+ next = ses->dfs\_root\_ses;+ \_\_cifs\_put\_smb\_ses(ses);+ } while ((ses = next)); } -/\* Get an active reference of @ses and @ses->dfs\_root\_ses.+/\* Get an active reference of @ses and its children. \* \* NOTE: make sure to call this function when incrementing reference count of \* @ses to ensure that any DFS root session attached to it (@ses->dfs\_root\_ses) \* will also get its reference count incremented. \*- \* cifs\_put\_smb\_ses() will put both references, so call it when you're done.+ \* cifs\_put\_smb\_ses() will put all references, so call it when you're done. \*/ static inline void cifs\_smb\_ses\_inc\_refcount(struct cifs\_ses \*ses) { lockdep\_assert\_held(&cifs\_tcp\_ses\_lock); - ses->ses\_count++;- if (ses->dfs\_root\_ses)- ses->dfs\_root\_ses->ses\_count++;+ for (; ses; ses = ses->dfs\_root\_ses)+ ses->ses\_count++; }  static inline bool dfs\_src\_pathname\_equal(const char \*s1, const char \*s2)diff --git a/fs/smb/client/connect.c b/fs/smb/client/connect.cindex ae35855966afd6..c5705de7f9de24 100644--- a/[fs/smb/client/connect.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/connect.c?id=441786be0c197c30851ac63fa3a4d79332b11dff)+++ b/[fs/smb/client/connect.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/connect.c?id=645f332c6b63499cc76197f9b6bffcc659ba64cc)@@ -1863,6 +1863,9 @@ static int match\_session(struct cifs\_ses \*ses, struct smb3\_fs\_context \*ctx) ctx->sectype != ses->sectype) return 0; + if (ctx->dfs\_root\_ses != ses->dfs\_root\_ses)+ return 0;+ /\* \* If an existing session is limited to less channels than \* requested, it should not be reused@@ -2355,9 +2358,9 @@ cifs\_get\_smb\_ses(struct TCP\_Server\_Info \*server, struct smb3\_fs\_context \*ctx) \* need to lock before changing something in the session. \*/ spin\_lock(&cifs\_tcp\_ses\_lock);+ if (ctx->dfs\_root\_ses)+ cifs\_smb\_ses\_inc\_refcount(ctx->dfs\_root\_ses); ses->dfs\_root\_ses = ctx->dfs\_root\_ses;- if (ses->dfs\_root\_ses)- ses->dfs\_root\_ses->ses\_count++; list\_add(&ses->smb\_ses\_list, &server->smb\_ses\_list); spin\_unlock(&cifs\_tcp\_ses\_lock); @@ -3301,6 +3304,9 @@ void cifs\_mount\_put\_conns(struct cifs\_mount\_ctx \*mnt\_ctx) cifs\_put\_smb\_ses(mnt\_ctx->ses); else if (mnt\_ctx->server) cifs\_put\_tcp\_session(mnt\_ctx->server, 0);+ mnt\_ctx->ses = NULL;+ mnt\_ctx->tcon = NULL;+ mnt\_ctx->server = NULL; mnt\_ctx->cifs\_sb->mnt\_cifs\_flags &= ~CIFS\_MOUNT\_POSIX\_PATHS; free\_xid(mnt\_ctx->xid); }@@ -3579,8 +3585,6 @@ int cifs\_mount(struct cifs\_sb\_info \*cifs\_sb, struct smb3\_fs\_context \*ctx) bool isdfs; int rc; - INIT\_LIST\_HEAD(&mnt\_ctx.dfs\_ses\_list);- rc = dfs\_mount\_share(&mnt\_ctx, &isdfs); if (rc) goto error;@@ -3611,7 +3615,6 @@ out: return rc;  error:- dfs\_put\_root\_smb\_sessions(&mnt\_ctx.dfs\_ses\_list); cifs\_mount\_put\_conns(&mnt\_ctx); return rc; }@@ -3626,6 +3629,18 @@ int cifs\_mount(struct cifs\_sb\_info \*cifs\_sb, struct smb3\_fs\_context \*ctx) goto error;  rc = cifs\_mount\_get\_tcon(&mnt\_ctx);+ if (!rc) {+ /\*+ \* Prevent superblock from being created with any missing+ \* connections.+ \*/+ if (WARN\_ON(!mnt\_ctx.server))+ rc = -EHOSTDOWN;+ else if (WARN\_ON(!mnt\_ctx.ses))+ rc = -EACCES;+ else if (WARN\_ON(!mnt\_ctx.tcon))+ rc = -ENOENT;+ } if (rc) goto error; diff --git a/fs/smb/client/dfs.c b/fs/smb/client/dfs.cindex 449c59830039bc..3ec965547e3d4d 100644--- a/[fs/smb/client/dfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/dfs.c?id=441786be0c197c30851ac63fa3a4d79332b11dff)+++ b/[fs/smb/client/dfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/dfs.c?id=645f332c6b63499cc76197f9b6bffcc659ba64cc)@@ -66,33 +66,20 @@ static int get\_session(struct cifs\_mount\_ctx \*mnt\_ctx, const char \*full\_path) }  /\*- \* Track individual DFS referral servers used by new DFS mount.- \*- \* On success, their lifetime will be shared by final tcon (dfs\_ses\_list).- \* Otherwise, they will be put by dfs\_put\_root\_smb\_sessions() in cifs\_mount().+ \* Get an active reference of @ses so that next call to cifs\_put\_tcon() won't+ \* release it as any new DFS referrals must go through its IPC tcon. \*/-static int add\_root\_smb\_session(struct cifs\_mount\_ctx \*mnt\_ctx)+static void add\_root\_smb\_session(struct cifs\_mount\_ctx \*mnt\_ctx) { struct smb3\_fs\_context \*ctx = mnt\_ctx->fs\_ctx;- struct dfs\_root\_ses \*root\_ses; struct cifs\_ses \*ses = mnt\_ctx->ses;  if (ses) {- root\_ses = kmalloc(sizeof(\*root\_ses), GFP\_KERNEL);- if (!root\_ses)- return -ENOMEM;-- INIT\_LIST\_HEAD(&root\_ses->list);- spin\_lock(&cifs\_tcp\_ses\_lock); cifs\_smb\_ses\_inc\_refcount(ses); spin\_unlock(&cifs\_tcp\_ses\_lock);- root\_ses->ses = ses;- list\_add\_tail(&root\_ses->list, &mnt\_ctx->dfs\_ses\_list); }- /\* Select new DFS referral server so that new referrals go through it \*/ ctx->dfs\_root\_ses = ses;- return 0; }  static inline int parse\_dfs\_target(struct smb3\_fs\_context \*ctx,@@ -185,11 +172,8 @@ again: continue; } - if (is\_refsrv) {- rc = add\_root\_smb\_session(mnt\_ctx);- if (rc)- goto out;- }+ if (is\_refsrv)+ add\_root\_smb\_session(mnt\_ctx);  rc = ref\_walk\_advance(rw); if (!rc) {@@ -232,6 +216,7 @@ static int \_\_dfs\_mount\_share(struct cifs\_mount\_ctx \*mnt\_ctx) struct smb3\_fs\_context \*ctx = mnt\_ctx->fs\_ctx; struct cifs\_tcon \*tcon; char \*origin\_fullpath;+ bool new\_tcon = true; int rc;  origin\_fullpath = dfs\_get\_path(cifs\_sb, ctx->source);@@ -239,6 +224,18 @@ static int \_\_dfs\_mount\_share(struct cifs\_mount\_ctx \*mnt\_ctx) return PTR\_ERR(origin\_fullpath);  rc = dfs\_referral\_walk(mnt\_ctx);+ if (!rc) {+ /\*+ \* Prevent superblock from being created with any missing+ \* connections.+ \*/+ if (WARN\_ON(!mnt\_ctx->server))+ rc = -EHOSTDOWN;+ else if (WARN\_ON(!mnt\_ctx->ses))+ rc = -EACCES;+ else if (WARN\_ON(!mnt\_ctx->tcon))+ rc = -ENOENT;+ } if (rc) goto out; @@ -247,15 +244,14 @@ static int \_\_dfs\_mount\_share(struct cifs\_mount\_ctx \*mnt\_ctx) if (!tcon->origin\_fullpath) { tcon->origin\_fullpath = origin\_fullpath; origin\_fullpath = NULL;+ } else {+ new\_tcon = false; } spin\_unlock(&tcon->tc\_lock); - if (list\_empty(&tcon->dfs\_ses\_list)) {- list\_replace\_init(&mnt\_ctx->dfs\_ses\_list, &tcon->dfs\_ses\_list);+ if (new\_tcon) { queue\_delayed\_work(dfscache\_wq, &tcon->dfs\_cache\_work, dfs\_cache\_get\_ttl() \* HZ);- } else {- dfs\_put\_root\_smb\_sessions(&mnt\_ctx->dfs\_ses\_list); }  out:@@ -298,7 +294,6 @@ int dfs\_mount\_share(struct cifs\_mount\_ctx \*mnt\_ctx, bool \*isdfs) if (rc) return rc; - ctx->dfs\_root\_ses = mnt\_ctx->ses; /\* \* If called with 'nodfs' mount option, then skip DFS resolving. Otherwise unconditionally \* try to get an DFS referral (even cached) to determine whether it is an DFS mount.@@ -324,7 +319,9 @@ int dfs\_mount\_share(struct cifs\_mount\_ctx \*mnt\_ctx, bool \*isdfs)  \*isdfs = true; add\_root\_smb\_session(mnt\_ctx);- return \_\_dfs\_mount\_share(mnt\_ctx);+ rc = \_\_dfs\_mount\_share(mnt\_ctx);+ dfs\_put\_root\_smb\_sessions(mnt\_ctx);+ return rc; }  /\* Update dfs referral path of superblock \*/diff --git a/fs/smb/client/dfs.h b/fs/smb/client/dfs.hindex 875ab7ae57fcdf..e5c4dcf837503a 100644--- a/[fs/smb/client/dfs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/dfs.h?id=441786be0c197c30851ac63fa3a4d79332b11dff)+++ b/[fs/smb/client/dfs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/dfs.h?id=645f332c6b63499cc76197f9b6bffcc659ba64cc)@@ -7,7 +7,9 @@ #define \_CIFS\_DFS\_H  #include "cifsglob.h"+#include "cifsproto.h" #include "fs\_context.h"+#include "dfs\_cache.h" #include "cifs\_unicode.h" #include <linux/namei.h> @@ -114,11 +116,6 @@ static inline void ref\_walk\_set\_tgt\_hint(struct dfs\_ref\_walk \*rw) ref\_walk\_tit(rw)); } -struct dfs\_root\_ses {- struct list\_head list;- struct cifs\_ses \*ses;-};- int dfs\_parse\_target\_referral(const char \*full\_path, const struct dfs\_info3\_param \*ref, struct smb3\_fs\_context \*ctx); int dfs\_mount\_share(struct cifs\_mount\_ctx \*mnt\_ctx, bool \*isdfs);@@ -133,20 +130,32 @@ static inline int dfs\_get\_referral(struct cifs\_mount\_ctx \*mnt\_ctx, const char \*p { struct smb3\_fs\_context \*ctx = mnt\_ctx->fs\_ctx; struct cifs\_sb\_info \*cifs\_sb = mnt\_ctx->cifs\_sb;+ struct cifs\_ses \*rses = ctx->dfs\_root\_ses ?: mnt\_ctx->ses; - return dfs\_cache\_find(mnt\_ctx->xid, ctx->dfs\_root\_ses, cifs\_sb->local\_nls,+ return dfs\_cache\_find(mnt\_ctx->xid, rses, cifs\_sb->local\_nls, cifs\_remap(cifs\_sb), path, ref, tl); } -static inline void dfs\_put\_root\_smb\_sessions(struct list\_head \*head)+/\*+ \* cifs\_get\_smb\_ses() already guarantees an active reference of+ \* @ses->dfs\_root\_ses when a new session is created, so we need to put extra+ \* references of all DFS root sessions that were used across the mount process+ \* in dfs\_mount\_share().+ \*/+static inline void dfs\_put\_root\_smb\_sessions(struct cifs\_mount\_ctx \*mnt\_ctx) {- struct dfs\_root\_ses \*root, \*tmp;+ const struct smb3\_fs\_context \*ctx = mnt\_ctx->fs\_ctx;+ struct cifs\_ses \*ses = ctx->dfs\_root\_ses;+ struct cifs\_ses \*cur;++ if (!ses)+ return; - list\_for\_each\_entry\_safe(root, tmp, head, list) {- list\_del\_init(&root->list);- cifs\_put\_smb\_ses(root->ses);- kfree(root);+ for (cur = ses; cur; cur = cur->dfs\_root\_ses) {+ if (cur->dfs\_root\_ses)+ cifs\_put\_smb\_ses(cur->dfs\_root\_ses); }+ cifs\_put\_smb\_ses(ses); }  #endif /\* \_CIFS\_DFS\_H \*/diff --git a/fs/smb/client/dfs\_cache.c b/fs/smb/client/dfs\_cache.cindex 508d831fabe378..0552a864ff08f9 100644--- a/[fs/smb/client/dfs\_cache.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/dfs_cache.c?id=441786be0c197c30851ac63fa3a4d79332b11dff)+++ b/[fs/smb/client/dfs\_cache.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/dfs_cache.c?id=645f332c6b63499cc76197f9b6bffcc659ba64cc)@@ -1278,21 +1278,12 @@ int dfs\_cache\_remount\_fs(struct cifs\_sb\_info \*cifs\_sb) void dfs\_cache\_refresh(struct work\_struct \*work) { struct TCP\_Server\_Info \*server;- struct dfs\_root\_ses \*rses; struct cifs\_tcon \*tcon; struct cifs\_ses \*ses;  tcon = container\_of(work, struct cifs\_tcon, dfs\_cache\_work.work);- ses = tcon->ses;- server = ses->server; - mutex\_lock(&server->refpath\_lock);- if (server->leaf\_fullpath)- \_\_refresh\_tcon(server->leaf\_fullpath + 1, ses, false);- mutex\_unlock(&server->refpath\_lock);-- list\_for\_each\_entry(rses, &tcon->dfs\_ses\_list, list) {- ses = rses->ses;+ for (ses = tcon->ses; ses; ses = ses->dfs\_root\_ses) { server = ses->server; mutex\_lock(&server->refpath\_lock); if (server->leaf\_fullpath)diff --git a/fs/smb/client/misc.c b/fs/smb/client/misc.cindex 51413cb00e1998..74627d647818a9 100644--- a/[fs/smb/client/misc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/misc.c?id=441786be0c197c30851ac63fa3a4d79332b11dff)+++ b/[fs/smb/client/misc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/misc.c?id=645f332c6b63499cc76197f9b6bffcc659ba64cc)@@ -141,9 +141,6 @@ tcon\_info\_alloc(bool dir\_leases\_enabled) atomic\_set(&ret\_buf->num\_local\_opens, 0); atomic\_set(&ret\_buf->num\_remote\_opens, 0); ret\_buf->stats\_from\_time = ktime\_get\_real\_seconds();-#ifdef CONFIG\_CIFS\_DFS\_UPCALL- INIT\_LIST\_HEAD(&ret\_buf->dfs\_ses\_list);-#endif  return ret\_buf; }@@ -159,9 +156,6 @@ tconInfoFree(struct cifs\_tcon \*tcon) atomic\_dec(&tconInfoAllocCount); kfree(tcon->nativeFileSystem); kfree\_sensitive(tcon->password);-#ifdef CONFIG\_CIFS\_DFS\_UPCALL- dfs\_put\_root\_smb\_sessions(&tcon->dfs\_ses\_list);-#endif kfree(tcon->origin\_fullpath); kfree(tcon); } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 22:12:03 +0000



=== Content from git.kernel.org_c359b177_20250110_221327.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=e1db9ae87b7148c021daee1fcc4bc71b2ac58a79)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=e1db9ae87b7148c021daee1fcc4bc71b2ac58a79)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e1db9ae87b7148c021daee1fcc4bc71b2ac58a79)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e1db9ae87b7148c021daee1fcc4bc71b2ac58a79)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Paulo Alcantara <pc@manguebit.com> | 2024-04-01 22:37:42 -0500 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-04-10 16:38:20 +0200 |
| commit | [e1db9ae87b7148c021daee1fcc4bc71b2ac58a79](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e1db9ae87b7148c021daee1fcc4bc71b2ac58a79) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=e1db9ae87b7148c021daee1fcc4bc71b2ac58a79)) | |
| tree | [ca01b4223a148c3e01c0ee5d55b9039353e6f2f1](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=e1db9ae87b7148c021daee1fcc4bc71b2ac58a79) | |
| parent | [45f2beda1f1bc3d962ec07db1ccc3197c25499a5](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=45f2beda1f1bc3d962ec07db1ccc3197c25499a5) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e1db9ae87b7148c021daee1fcc4bc71b2ac58a79&id2=45f2beda1f1bc3d962ec07db1ccc3197c25499a5)) | |
| download | [linux-e1db9ae87b7148c021daee1fcc4bc71b2ac58a79.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-e1db9ae87b7148c021daee1fcc4bc71b2ac58a79.tar.gz) | |

smb: client: guarantee refcounted children from parent sessioncommit 062a7f0ff46eb57aff526897bd2bebfdb1d3046a upstream.
Avoid potential use-after-free bugs when walking DFS referrals,
mounting and performing DFS failover by ensuring that all children
from parent @tcon->ses are also refcounted. They're all needed across
the entire DFS mount. Get rid of @tcon->dfs\_ses\_list while we're at
it, too.
Cc: stable@vger.kernel.org # 6.4+
Reported-by: kernel test robot <lkp@intel.com>
Closes: https://lore.kernel.org/oe-kbuild-all/202404021527.ZlRkIxgv-lkp@intel.com/
Signed-off-by: Paulo Alcantara (Red Hat) <pc@manguebit.com>
Signed-off-by: Steve French <stfrench@microsoft.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e1db9ae87b7148c021daee1fcc4bc71b2ac58a79)

| -rw-r--r-- | [fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/cifsglob.h?id=e1db9ae87b7148c021daee1fcc4bc71b2ac58a79) | 2 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/smb/client/cifsproto.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/cifsproto.h?id=e1db9ae87b7148c021daee1fcc4bc71b2ac58a79) | 20 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/connect.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/connect.c?id=e1db9ae87b7148c021daee1fcc4bc71b2ac58a79) | 25 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/dfs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/dfs.c?id=e1db9ae87b7148c021daee1fcc4bc71b2ac58a79) | 51 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/dfs.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/dfs.h?id=e1db9ae87b7148c021daee1fcc4bc71b2ac58a79) | 33 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/dfs\_cache.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/dfs_cache.c?id=e1db9ae87b7148c021daee1fcc4bc71b2ac58a79) | 11 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/smb/client/misc.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/misc.c?id=e1db9ae87b7148c021daee1fcc4bc71b2ac58a79) | 6 | |  |  |  | | --- | --- | --- | |

7 files changed, 76 insertions, 72 deletions

| diff --git a/fs/smb/client/cifsglob.h b/fs/smb/client/cifsglob.hindex 06e81afe31c148..35cb27d103f2fe 100644--- a/[fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsglob.h?id=45f2beda1f1bc3d962ec07db1ccc3197c25499a5)+++ b/[fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsglob.h?id=e1db9ae87b7148c021daee1fcc4bc71b2ac58a79)@@ -1267,7 +1267,6 @@ struct cifs\_tcon { struct cached\_fids \*cfids; /\* BB add field for back pointer to sb struct(s)? \*/ #ifdef CONFIG\_CIFS\_DFS\_UPCALL- struct list\_head dfs\_ses\_list; struct delayed\_work dfs\_cache\_work; #endif struct delayed\_work query\_interfaces; /\* query interfaces workqueue job \*/@@ -1788,7 +1787,6 @@ struct cifs\_mount\_ctx { struct TCP\_Server\_Info \*server; struct cifs\_ses \*ses; struct cifs\_tcon \*tcon;- struct list\_head dfs\_ses\_list; };  static inline void \_\_free\_dfs\_info\_param(struct dfs\_info3\_param \*param)diff --git a/fs/smb/client/cifsproto.h b/fs/smb/client/cifsproto.hindex 58cfbd450a55e5..996ca413dd8bd6 100644--- a/[fs/smb/client/cifsproto.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsproto.h?id=45f2beda1f1bc3d962ec07db1ccc3197c25499a5)+++ b/[fs/smb/client/cifsproto.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsproto.h?id=e1db9ae87b7148c021daee1fcc4bc71b2ac58a79)@@ -723,31 +723,31 @@ struct super\_block \*cifs\_get\_tcon\_super(struct cifs\_tcon \*tcon); void cifs\_put\_tcon\_super(struct super\_block \*sb); int cifs\_wait\_for\_server\_reconnect(struct TCP\_Server\_Info \*server, bool retry); -/\* Put references of @ses and @ses->dfs\_root\_ses \*/+/\* Put references of @ses and its children \*/ static inline void cifs\_put\_smb\_ses(struct cifs\_ses \*ses) {- struct cifs\_ses \*rses = ses->dfs\_root\_ses;+ struct cifs\_ses \*next; - \_\_cifs\_put\_smb\_ses(ses);- if (rses)- \_\_cifs\_put\_smb\_ses(rses);+ do {+ next = ses->dfs\_root\_ses;+ \_\_cifs\_put\_smb\_ses(ses);+ } while ((ses = next)); } -/\* Get an active reference of @ses and @ses->dfs\_root\_ses.+/\* Get an active reference of @ses and its children. \* \* NOTE: make sure to call this function when incrementing reference count of \* @ses to ensure that any DFS root session attached to it (@ses->dfs\_root\_ses) \* will also get its reference count incremented. \*- \* cifs\_put\_smb\_ses() will put both references, so call it when you're done.+ \* cifs\_put\_smb\_ses() will put all references, so call it when you're done. \*/ static inline void cifs\_smb\_ses\_inc\_refcount(struct cifs\_ses \*ses) { lockdep\_assert\_held(&cifs\_tcp\_ses\_lock); - ses->ses\_count++;- if (ses->dfs\_root\_ses)- ses->dfs\_root\_ses->ses\_count++;+ for (; ses; ses = ses->dfs\_root\_ses)+ ses->ses\_count++; }  static inline bool dfs\_src\_pathname\_equal(const char \*s1, const char \*s2)diff --git a/fs/smb/client/connect.c b/fs/smb/client/connect.cindex 6202d0295fe3e0..2064bf6749ff6c 100644--- a/[fs/smb/client/connect.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/connect.c?id=45f2beda1f1bc3d962ec07db1ccc3197c25499a5)+++ b/[fs/smb/client/connect.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/connect.c?id=e1db9ae87b7148c021daee1fcc4bc71b2ac58a79)@@ -1869,6 +1869,9 @@ static int match\_session(struct cifs\_ses \*ses, struct smb3\_fs\_context \*ctx) ctx->sectype != ses->sectype) return 0; + if (ctx->dfs\_root\_ses != ses->dfs\_root\_ses)+ return 0;+ /\* \* If an existing session is limited to less channels than \* requested, it should not be reused@@ -2361,9 +2364,9 @@ cifs\_get\_smb\_ses(struct TCP\_Server\_Info \*server, struct smb3\_fs\_context \*ctx) \* need to lock before changing something in the session. \*/ spin\_lock(&cifs\_tcp\_ses\_lock);+ if (ctx->dfs\_root\_ses)+ cifs\_smb\_ses\_inc\_refcount(ctx->dfs\_root\_ses); ses->dfs\_root\_ses = ctx->dfs\_root\_ses;- if (ses->dfs\_root\_ses)- ses->dfs\_root\_ses->ses\_count++; list\_add(&ses->smb\_ses\_list, &server->smb\_ses\_list); spin\_unlock(&cifs\_tcp\_ses\_lock); @@ -3312,6 +3315,9 @@ void cifs\_mount\_put\_conns(struct cifs\_mount\_ctx \*mnt\_ctx) cifs\_put\_smb\_ses(mnt\_ctx->ses); else if (mnt\_ctx->server) cifs\_put\_tcp\_session(mnt\_ctx->server, 0);+ mnt\_ctx->ses = NULL;+ mnt\_ctx->tcon = NULL;+ mnt\_ctx->server = NULL; mnt\_ctx->cifs\_sb->mnt\_cifs\_flags &= ~CIFS\_MOUNT\_POSIX\_PATHS; free\_xid(mnt\_ctx->xid); }@@ -3590,8 +3596,6 @@ int cifs\_mount(struct cifs\_sb\_info \*cifs\_sb, struct smb3\_fs\_context \*ctx) bool isdfs; int rc; - INIT\_LIST\_HEAD(&mnt\_ctx.dfs\_ses\_list);- rc = dfs\_mount\_share(&mnt\_ctx, &isdfs); if (rc) goto error;@@ -3622,7 +3626,6 @@ out: return rc;  error:- dfs\_put\_root\_smb\_sessions(&mnt\_ctx.dfs\_ses\_list); cifs\_mount\_put\_conns(&mnt\_ctx); return rc; }@@ -3637,6 +3640,18 @@ int cifs\_mount(struct cifs\_sb\_info \*cifs\_sb, struct smb3\_fs\_context \*ctx) goto error;  rc = cifs\_mount\_get\_tcon(&mnt\_ctx);+ if (!rc) {+ /\*+ \* Prevent superblock from being created with any missing+ \* connections.+ \*/+ if (WARN\_ON(!mnt\_ctx.server))+ rc = -EHOSTDOWN;+ else if (WARN\_ON(!mnt\_ctx.ses))+ rc = -EACCES;+ else if (WARN\_ON(!mnt\_ctx.tcon))+ rc = -ENOENT;+ } if (rc) goto error; diff --git a/fs/smb/client/dfs.c b/fs/smb/client/dfs.cindex 449c59830039bc..3ec965547e3d4d 100644--- a/[fs/smb/client/dfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/dfs.c?id=45f2beda1f1bc3d962ec07db1ccc3197c25499a5)+++ b/[fs/smb/client/dfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/dfs.c?id=e1db9ae87b7148c021daee1fcc4bc71b2ac58a79)@@ -66,33 +66,20 @@ static int get\_session(struct cifs\_mount\_ctx \*mnt\_ctx, const char \*full\_path) }  /\*- \* Track individual DFS referral servers used by new DFS mount.- \*- \* On success, their lifetime will be shared by final tcon (dfs\_ses\_list).- \* Otherwise, they will be put by dfs\_put\_root\_smb\_sessions() in cifs\_mount().+ \* Get an active reference of @ses so that next call to cifs\_put\_tcon() won't+ \* release it as any new DFS referrals must go through its IPC tcon. \*/-static int add\_root\_smb\_session(struct cifs\_mount\_ctx \*mnt\_ctx)+static void add\_root\_smb\_session(struct cifs\_mount\_ctx \*mnt\_ctx) { struct smb3\_fs\_context \*ctx = mnt\_ctx->fs\_ctx;- struct dfs\_root\_ses \*root\_ses; struct cifs\_ses \*ses = mnt\_ctx->ses;  if (ses) {- root\_ses = kmalloc(sizeof(\*root\_ses), GFP\_KERNEL);- if (!root\_ses)- return -ENOMEM;-- INIT\_LIST\_HEAD(&root\_ses->list);- spin\_lock(&cifs\_tcp\_ses\_lock); cifs\_smb\_ses\_inc\_refcount(ses); spin\_unlock(&cifs\_tcp\_ses\_lock);- root\_ses->ses = ses;- list\_add\_tail(&root\_ses->list, &mnt\_ctx->dfs\_ses\_list); }- /\* Select new DFS referral server so that new referrals go through it \*/ ctx->dfs\_root\_ses = ses;- return 0; }  static inline int parse\_dfs\_target(struct smb3\_fs\_context \*ctx,@@ -185,11 +172,8 @@ again: continue; } - if (is\_refsrv) {- rc = add\_root\_smb\_session(mnt\_ctx);- if (rc)- goto out;- }+ if (is\_refsrv)+ add\_root\_smb\_session(mnt\_ctx);  rc = ref\_walk\_advance(rw); if (!rc) {@@ -232,6 +216,7 @@ static int \_\_dfs\_mount\_share(struct cifs\_mount\_ctx \*mnt\_ctx) struct smb3\_fs\_context \*ctx = mnt\_ctx->fs\_ctx; struct cifs\_tcon \*tcon; char \*origin\_fullpath;+ bool new\_tcon = true; int rc;  origin\_fullpath = dfs\_get\_path(cifs\_sb, ctx->source);@@ -239,6 +224,18 @@ static int \_\_dfs\_mount\_share(struct cifs\_mount\_ctx \*mnt\_ctx) return PTR\_ERR(origin\_fullpath);  rc = dfs\_referral\_walk(mnt\_ctx);+ if (!rc) {+ /\*+ \* Prevent superblock from being created with any missing+ \* connections.+ \*/+ if (WARN\_ON(!mnt\_ctx->server))+ rc = -EHOSTDOWN;+ else if (WARN\_ON(!mnt\_ctx->ses))+ rc = -EACCES;+ else if (WARN\_ON(!mnt\_ctx->tcon))+ rc = -ENOENT;+ } if (rc) goto out; @@ -247,15 +244,14 @@ static int \_\_dfs\_mount\_share(struct cifs\_mount\_ctx \*mnt\_ctx) if (!tcon->origin\_fullpath) { tcon->origin\_fullpath = origin\_fullpath; origin\_fullpath = NULL;+ } else {+ new\_tcon = false; } spin\_unlock(&tcon->tc\_lock); - if (list\_empty(&tcon->dfs\_ses\_list)) {- list\_replace\_init(&mnt\_ctx->dfs\_ses\_list, &tcon->dfs\_ses\_list);+ if (new\_tcon) { queue\_delayed\_work(dfscache\_wq, &tcon->dfs\_cache\_work, dfs\_cache\_get\_ttl() \* HZ);- } else {- dfs\_put\_root\_smb\_sessions(&mnt\_ctx->dfs\_ses\_list); }  out:@@ -298,7 +294,6 @@ int dfs\_mount\_share(struct cifs\_mount\_ctx \*mnt\_ctx, bool \*isdfs) if (rc) return rc; - ctx->dfs\_root\_ses = mnt\_ctx->ses; /\* \* If called with 'nodfs' mount option, then skip DFS resolving. Otherwise unconditionally \* try to get an DFS referral (even cached) to determine whether it is an DFS mount.@@ -324,7 +319,9 @@ int dfs\_mount\_share(struct cifs\_mount\_ctx \*mnt\_ctx, bool \*isdfs)  \*isdfs = true; add\_root\_smb\_session(mnt\_ctx);- return \_\_dfs\_mount\_share(mnt\_ctx);+ rc = \_\_dfs\_mount\_share(mnt\_ctx);+ dfs\_put\_root\_smb\_sessions(mnt\_ctx);+ return rc; }  /\* Update dfs referral path of superblock \*/diff --git a/fs/smb/client/dfs.h b/fs/smb/client/dfs.hindex 875ab7ae57fcdf..e5c4dcf837503a 100644--- a/[fs/smb/client/dfs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/dfs.h?id=45f2beda1f1bc3d962ec07db1ccc3197c25499a5)+++ b/[fs/smb/client/dfs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/dfs.h?id=e1db9ae87b7148c021daee1fcc4bc71b2ac58a79)@@ -7,7 +7,9 @@ #define \_CIFS\_DFS\_H  #include "cifsglob.h"+#include "cifsproto.h" #include "fs\_context.h"+#include "dfs\_cache.h" #include "cifs\_unicode.h" #include <linux/namei.h> @@ -114,11 +116,6 @@ static inline void ref\_walk\_set\_tgt\_hint(struct dfs\_ref\_walk \*rw) ref\_walk\_tit(rw)); } -struct dfs\_root\_ses {- struct list\_head list;- struct cifs\_ses \*ses;-};- int dfs\_parse\_target\_referral(const char \*full\_path, const struct dfs\_info3\_param \*ref, struct smb3\_fs\_context \*ctx); int dfs\_mount\_share(struct cifs\_mount\_ctx \*mnt\_ctx, bool \*isdfs);@@ -133,20 +130,32 @@ static inline int dfs\_get\_referral(struct cifs\_mount\_ctx \*mnt\_ctx, const char \*p { struct smb3\_fs\_context \*ctx = mnt\_ctx->fs\_ctx; struct cifs\_sb\_info \*cifs\_sb = mnt\_ctx->cifs\_sb;+ struct cifs\_ses \*rses = ctx->dfs\_root\_ses ?: mnt\_ctx->ses; - return dfs\_cache\_find(mnt\_ctx->xid, ctx->dfs\_root\_ses, cifs\_sb->local\_nls,+ return dfs\_cache\_find(mnt\_ctx->xid, rses, cifs\_sb->local\_nls, cifs\_remap(cifs\_sb), path, ref, tl); } -static inline void dfs\_put\_root\_smb\_sessions(struct list\_head \*head)+/\*+ \* cifs\_get\_smb\_ses() already guarantees an active reference of+ \* @ses->dfs\_root\_ses when a new session is created, so we need to put extra+ \* references of all DFS root sessions that were used across the mount process+ \* in dfs\_mount\_share().+ \*/+static inline void dfs\_put\_root\_smb\_sessions(struct cifs\_mount\_ctx \*mnt\_ctx) {- struct dfs\_root\_ses \*root, \*tmp;+ const struct smb3\_fs\_context \*ctx = mnt\_ctx->fs\_ctx;+ struct cifs\_ses \*ses = ctx->dfs\_root\_ses;+ struct cifs\_ses \*cur;++ if (!ses)+ return; - list\_for\_each\_entry\_safe(root, tmp, head, list) {- list\_del\_init(&root->list);- cifs\_put\_smb\_ses(root->ses);- kfree(root);+ for (cur = ses; cur; cur = cur->dfs\_root\_ses) {+ if (cur->dfs\_root\_ses)+ cifs\_put\_smb\_ses(cur->dfs\_root\_ses); }+ cifs\_put\_smb\_ses(ses); }  #endif /\* \_CIFS\_DFS\_H \*/diff --git a/fs/smb/client/dfs\_cache.c b/fs/smb/client/dfs\_cache.cindex 508d831fabe378..0552a864ff08f9 100644--- a/[fs/smb/client/dfs\_cache.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/dfs_cache.c?id=45f2beda1f1bc3d962ec07db1ccc3197c25499a5)+++ b/[fs/smb/client/dfs\_cache.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/dfs_cache.c?id=e1db9ae87b7148c021daee1fcc4bc71b2ac58a79)@@ -1278,21 +1278,12 @@ int dfs\_cache\_remount\_fs(struct cifs\_sb\_info \*cifs\_sb) void dfs\_cache\_refresh(struct work\_struct \*work) { struct TCP\_Server\_Info \*server;- struct dfs\_root\_ses \*rses; struct cifs\_tcon \*tcon; struct cifs\_ses \*ses;  tcon = container\_of(work, struct cifs\_tcon, dfs\_cache\_work.work);- ses = tcon->ses;- server = ses->server; - mutex\_lock(&server->refpath\_lock);- if (server->leaf\_fullpath)- \_\_refresh\_tcon(server->leaf\_fullpath + 1, ses, false);- mutex\_unlock(&server->refpath\_lock);-- list\_for\_each\_entry(rses, &tcon->dfs\_ses\_list, list) {- ses = rses->ses;+ for (ses = tcon->ses; ses; ses = ses->dfs\_root\_ses) { server = ses->server; mutex\_lock(&server->refpath\_lock); if (server->leaf\_fullpath)diff --git a/fs/smb/client/misc.c b/fs/smb/client/misc.cindex 0748d7b757b95a..df65cef63afb9b 100644--- a/[fs/smb/client/misc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/misc.c?id=45f2beda1f1bc3d962ec07db1ccc3197c25499a5)+++ b/[fs/smb/client/misc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/misc.c?id=e1db9ae87b7148c021daee1fcc4bc71b2ac58a79)@@ -141,9 +141,6 @@ tcon\_info\_alloc(bool dir\_leases\_enabled) atomic\_set(&ret\_buf->num\_local\_opens, 0); atomic\_set(&ret\_buf->num\_remote\_opens, 0); ret\_buf->stats\_from\_time = ktime\_get\_real\_seconds();-#ifdef CONFIG\_CIFS\_DFS\_UPCALL- INIT\_LIST\_HEAD(&ret\_buf->dfs\_ses\_list);-#endif  return ret\_buf; }@@ -159,9 +156,6 @@ tconInfoFree(struct cifs\_tcon \*tcon) atomic\_dec(&tconInfoAllocCount); kfree(tcon->nativeFileSystem); kfree\_sensitive(tcon->password);-#ifdef CONFIG\_CIFS\_DFS\_UPCALL- dfs\_put\_root\_smb\_sessions(&tcon->dfs\_ses\_list);-#endif kfree(tcon->origin\_fullpath); kfree(tcon); } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 22:12:04 +0000


