

| **[/](/viewvc)[[global]](/viewvc/global/)/[global](/viewvc/global/global/)/[htags](/viewvc/global/global/htags/)/[htags.c](/viewvc/global/global/htags/htags.c?view=log)** |  |
| --- | --- |

[![ViewVC logotype](/viewvc/*docroot*/images/viewvc-logo.png)](http://www.viewvc.org/ "ViewVC Home")
# Contents of /global/htags/htags.c

[![Parent Directory](/viewvc/*docroot*/images/back_small.png) Parent Directory](/viewvc/global/global/htags/)
| [![Revision Log](/viewvc/*docroot*/images/log.png) Revision Log](/viewvc/global/global/htags/htags.c?view=log)

---

Revision **1.236** -
([**show annotations**](/viewvc/global/global/htags/htags.c?annotate=1.236))
([**download**](/viewvc/%2Acheckout%2A/global/global/htags/htags.c?revision=1.236))

*Thu May 9 07:21:32 2024 UTC*
(8 months ago)
by *shigio*

Branch: **MAIN**

CVS Tags: **VERSION-6\_6\_14, VERSION-6\_6\_13, HEAD**

Changes since **1.235: +2 -1 lines**

File MIME type: text/plain
```
[FIXED BUGS]
A security vulnerability was found in htags.
Htags took the input provided in the dbpath option (-d) and
appended it to a command string that will later be executed by
system() function, without any escaping, leading to a command
injection vulnerability.

        $ rm -f /tmp/w
        $ htags -g -q -d '$(pwd>/tmp/w)'
        $ cat /tmp/w
        /tmp/global/htags

It was fixed. Now it just outputs an error:

        $ rm -f /tmp/w
        $ htags -g -q -d '$(pwd>/tmp/w)'
        gtags: directory '/tmp/global/htags/$(pwd>' not found.
        $ cat /tmp/w
        cat: /tmp/w: No such file or directory

```

| [1](#l1) | /\* |
| --- | --- |
| [2](#l2) | \* Copyright (c) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, |
| [3](#l3) | \* 2006, 2007, 2008, 2010, 2011, 2016 |
| [4](#l4) | \* Tama Communications Corporation |
| [5](#l5) | \* |
| [6](#l6) | \* This file is part of GNU GLOBAL. |
| [7](#l7) | \* |
| [8](#l8) | \* This program is free software: you can redistribute it and/or modify |
| [9](#l9) | \* it under the terms of the GNU General Public License as published by |
| [10](#l10) | \* the Free Software Foundation, either version 3 of the License, or |
| [11](#l11) | \* (at your option) any later version. |
| [12](#l12) | \* |
| [13](#l13) | \* This program is distributed in the hope that it will be useful, |
| [14](#l14) | \* but WITHOUT ANY WARRANTY; without even the implied warranty of |
| [15](#l15) | \* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the |
| [16](#l16) | \* GNU General Public License for more details. |
| [17](#l17) | \* |
| [18](#l18) | \* You should have received a copy of the GNU General Public License |
| [19](#l19) | \* along with this program. If not, see <<http://www.gnu.org/licenses/>>. |
| [20](#l20) | \*/ |
| [21](#l21) |  |
| [22](#l22) | #ifdef HAVE\_CONFIG\_H |
| [23](#l23) | #include <config.h> |
| [24](#l24) | #endif |
| [25](#l25) | #include <stdio.h> |
| [26](#l26) | #include <errno.h> |
| [27](#l27) | #ifdef STDC\_HEADERS |
| [28](#l28) | #include <stdlib.h> |
| [29](#l29) | #endif |
| [30](#l30) | #ifdef HAVE\_UNISTD\_H |
| [31](#l31) | #include <unistd.h> |
| [32](#l32) | #endif |
| [33](#l33) | #ifdef HAVE\_FCNTL\_H |
| [34](#l34) | #include <fcntl.h> |
| [35](#l35) | #else |
| [36](#l36) | #include <sys/file.h> |
| [37](#l37) | #endif |
| [38](#l38) | #include <signal.h> |
| [39](#l39) | #include <sys/types.h> |
| [40](#l40) | #include <sys/stat.h> |
| [41](#l41) | #include <sys/param.h> |
| [42](#l42) | #include <errno.h> |
| [43](#l43) |  |
| [44](#l44) | #include "getopt.h" |
| [45](#l45) | #include "regex.h" |
| [46](#l46) | #include "global.h" |
| [47](#l47) | #include "anchor.h" |
| [48](#l48) | #include "cache.h" |
| [49](#l49) | #include "char.h" |
| [50](#l50) | #include "common.h" |
| [51](#l51) | #include "htags.h" |
| [52](#l52) | #include "incop.h" |
| [53](#l53) | #include "path2url.h" |
| [54](#l54) | #include "const.h" |
| [55](#l55) |  |
| [56](#l56) | /\* |
| [57](#l57) | \* htags - generate hypertext (XHTML or HTML) pages from a set of source files. |
| [58](#l58) | \*/ |
| [59](#l59) |  |
| [60](#l60) | void src2html(const char \*, const char \*, int); |
| [61](#l61) | int makedupindex(void); |
| [62](#l62) | int makedefineindex(const char \*, int, STRBUF \*); |
| [63](#l63) | int makefileindex(const char \*, STRBUF \*); |
| [64](#l64) | void makeincludeindex(void); |
| [65](#l65) | int makecflowindex(const char \*, const char \*); |
| [66](#l66) |  |
| [67](#l67) | #if defined(\_WIN32) && !defined(\_\_CYGWIN\_\_) |
| [68](#l68) | #define mkdir(path,mode) mkdir(path) |
| [69](#l69) | #define link(one,two) (-1) |
| [70](#l70) | #endif |
| [71](#l71) |  |
| [72](#l72) | /\* |
| [73](#l73) | \* Global data. |
| [74](#l74) | \*/ |
| [75](#l75) | int w32 = W32; /\*\*< Windows32 environment \*/ |
| [76](#l76) | const char \*www = "<http://www.gnu.org/software/global/>"; |
| [77](#l77) | int html\_count = 0; |
| [78](#l78) | int sep = '/'; |
| [79](#l79) | const char \*save\_config; |
| [80](#l80) | const char \*save\_argv; |
| [81](#l81) |  |
| [82](#l82) | char cwdpath[MAXPATHLEN]; |
| [83](#l83) | char dbpath[MAXPATHLEN]; |
| [84](#l84) | char distpath[MAXPATHLEN]; |
| [85](#l85) | char gtagsconf[MAXPATHLEN]; |
| [86](#l86) | char datadir[MAXPATHLEN]; |
| [87](#l87) | char localstatedir[MAXPATHLEN]; |
| [88](#l88) |  |
| [89](#l89) | char gtags\_path[MAXFILLEN]; |
| [90](#l90) | char global\_path[MAXFILLEN]; |
| [91](#l91) | int gtags\_exist[GTAGLIM]; |
| [92](#l92) | const char \*null\_device = NULL\_DEVICE; |
| [93](#l93) | const char \*tmpdir = "/tmp"; |
| [94](#l94) |  |
| [95](#l95) | /\*\* |
| [96](#l96) | \* Order of items in the top page (This should be customisable variable in the future). |
| [97](#l97) | \* |
| [98](#l98) | \* 'c': caution |
| [99](#l99) | \* 's': search form |
| [100](#l100) | \* 'm': mains |
| [101](#l101) | \* 'd': definitions |
| [102](#l102) | \* 'f': files |
| [103](#l103) | \* 't': call tree |
| [104](#l104) | \*/ |
| [105](#l105) | char \*item\_order = "csmdft"; |
| [106](#l106) | /\* |
| [107](#l107) | \* options |
| [108](#l108) | \*/ |
| [109](#l109) | int aflag; /\*\*< --alphabet(-a) option \*/ |
| [110](#l110) | int fflag; /\*\*< --form(-f) option \*/ |
| [111](#l111) | int Fflag; /\*\*< --frame(-F) option \*/ |
| [112](#l112) | int gflag; /\*\*< --gtags(-g) option \*/ |
| [113](#l113) | int Iflag; /\*\*< --icon(-I) option \*/ |
| [114](#l114) | int nflag; /\*\*< --line-number(-n) option \*/ |
| [115](#l115) | int qflag; |
| [116](#l116) | int vflag; /\*\*< --verbose(-v) option \*/ |
| [117](#l117) | int wflag; /\*\*< --warning(-w) option \*/ |
| [118](#l118) | int debug; /\*\*< --debug option \*/ |
| [119](#l119) |  |
| [120](#l120) | int show\_help; /\*\*< --help command \*/ |
| [121](#l121) | int show\_version; /\*\*< --version command \*/ |
| [122](#l122) | int caution; /\*\*< --caution option \*/ |
| [123](#l123) | int dynamic; /\*\*< --dynamic(-D) option \*/ |
| [124](#l124) | int symbol; /\*\*< --symbol(-s) option \*/ |
| [125](#l125) | int suggest; /\*\*< --suggest option \*/ |
| [126](#l126) | int suggest2; /\*\*< --suggest2 option \*/ |
| [127](#l127) | int auto\_completion; /\*\*< --auto-completion \*/ |
| [128](#l128) | int tree\_view; /\*\*< --tree-view \*/ |
| [129](#l129) | int fixed\_guide; /\*\*< --fixed-guide \*/ |
| [130](#l130) | const char \*tree\_view\_type; /\*\*< --type-view=[type] \*/ |
| [131](#l131) | char \*auto\_completion\_limit = "0"; /\*\*< --auto-completion=limit \*/ |
| [132](#l132) | int statistics = STATISTICS\_STYLE\_NONE; /\*\*< --statistics option \*/ |
| [133](#l133) |  |
| [134](#l134) | int no\_order\_list; /\*\*< 1: doesn't use order list \*/ |
| [135](#l135) | int other\_files; /\*\*< 1: list other files \*/ |
| [136](#l136) | int enable\_grep = 1; /\*\*< 1: enable grep \*/ |
| [137](#l137) | int enable\_idutils = 1; /\*\*< 1: enable idutils \*/ |
| [138](#l138) | int enable\_xhtml = 1; /\*\*< 1: enable XHTML \*/ |
| [139](#l139) |  |
| [140](#l140) | const char \*main\_func = "main"; |
| [141](#l141) | const char \*cvsweb\_url; |
| [142](#l142) | int use\_cvs\_module; |
| [143](#l143) | const char \*cvsweb\_cvsroot; |
| [144](#l144) | const char \*gtagslabel; |
| [145](#l145) | const char \*title; |
| [146](#l146) | const char \*insert\_header; /\* --insert-header=<file> \*/ |
| [147](#l147) | const char \*insert\_footer; /\* --insert-footer=<file> \*/ |
| [148](#l148) | const char \*html\_header; /\* --html-header=<file> \*/ |
| [149](#l149) | const char \*jscode; /\*\*< javascript code \*/ |
| [150](#l150) | /\* |
| [151](#l151) | \* Constant values. |
| [152](#l152) | \*/ |
| [153](#l153) | const char \*title\_define\_index = "DEFINITIONS"; |
| [154](#l154) | const char \*title\_file\_index = "FILES"; |
| [155](#l155) | const char \*title\_call\_tree = "CALL TREE"; |
| [156](#l156) | const char \*title\_callee\_tree = "CALLEE TREE"; |
| [157](#l157) | const char \*title\_included\_from = "INCLUDED FROM"; |
| [158](#l158) | /\* |
| [159](#l159) | \* Function header items. |
| [160](#l160) | \*/ |
| [161](#l161) | const char \*anchor\_label[] = { |
| [162](#l162) | "&lt;", |
| [163](#l163) | "&gt;", |
| [164](#l164) | "^", |
| [165](#l165) | "v", |
| [166](#l166) | "top", |
| [167](#l167) | "bottom", |
| [168](#l168) | "index", |
| [169](#l169) | "help" |
| [170](#l170) | }; |
| [171](#l171) | const char \*anchor\_icons[] = { |
| [172](#l172) | "left", |
| [173](#l173) | "right", |
| [174](#l174) | "first", |
| [175](#l175) | "last", |
| [176](#l176) | "top", |
| [177](#l177) | "bottom", |
| [178](#l178) | "index", |
| [179](#l179) | "help" |
| [180](#l180) | }; |
| [181](#l181) | const char \*anchor\_comment[] = { |
| [182](#l182) | "previous", |
| [183](#l183) | "next", |
| [184](#l184) | "first", |
| [185](#l185) | "last", |
| [186](#l186) | "top", |
| [187](#l187) | "bottom", |
| [188](#l188) | "index", |
| [189](#l189) | "help" |
| [190](#l190) | }; |
| [191](#l191) | const char \*anchor\_msg[] = { |
| [192](#l192) | "Previous definition.", |
| [193](#l193) | "Next definition.", |
| [194](#l194) | "First definition in this file.", |
| [195](#l195) | "Last definition in this file.", |
| [196](#l196) | "Top of this file.", |
| [197](#l197) | "Bottom of this file.", |
| [198](#l198) | "Return to index page.", |
| [199](#l199) | "You are seeing now." |
| [200](#l200) | }; |
| [201](#l201) | const char \*back\_icon = "back"; |
| [202](#l202) | const char \*dir\_icon = "dir"; |
| [203](#l203) | const char \*c\_icon = "c"; |
| [204](#l204) | const char \*file\_icon = "text"; |
| [205](#l205) |  |
| [206](#l206) | const char \*icon\_files[] = { |
| [207](#l207) | "first", |
| [208](#l208) | "last", |
| [209](#l209) | "left", |
| [210](#l210) | "right", |
| [211](#l211) | "top", |
| [212](#l212) | "bottom", |
| [213](#l213) | "n\_first", |
| [214](#l214) | "n\_last", |
| [215](#l215) | "n\_left", |
| [216](#l216) | "n\_right", |
| [217](#l217) | "n\_top", |
| [218](#l218) | "n\_bottom", |
| [219](#l219) | "index", |
| [220](#l220) | "help", |
| [221](#l221) | "back", |
| [222](#l222) | "dir", |
| [223](#l223) | "c", |
| [224](#l224) | "text", |
| [225](#l225) | "pglobe" |
| [226](#l226) | }; |
| [227](#l227) | /\* |
| [228](#l228) | \* Configuration parameters. |
| [229](#l229) | \*/ |
| [230](#l230) | int ncol = 4; /\*\*< columns of line number \*/ |
| [231](#l231) | int tabs = 8; /\*\*< tab skip \*/ |
| [232](#l232) | int flist\_fields = 5; /\*\*< fields number of file list \*/ |
| [233](#l233) | int full\_path = 0; /\*\*< file index format \*/ |
| [234](#l234) | int map\_file = 0; /\*\*< 1: create MAP file \*/ |
| [235](#l235) | int filemap\_file = 1; /\*\*< 1: create FILEMAP file \*/ |
| [236](#l236) | const char \*icon\_suffix = "png"; /\*\*< icon suffix (jpg, png etc) \*/ |
| [237](#l237) | const char \*icon\_spec = "border='0' align='top'"; /\*\*< parameter in IMG tag\*/ |
| [238](#l238) | const char \*prolog\_script = NULL; /\*\*< include script at first \*/ |
| [239](#l239) | const char \*epilog\_script = NULL; /\*\*< include script at last \*/ |
| [240](#l240) | const char \*call\_file = NULL; /\*\*< file name of cflow output \*/ |
| [241](#l241) | const char \*callee\_file = NULL; /\*\*< file name of cflow output \*/ |
| [242](#l242) | int show\_position = 0; /\*\*< show current position \*/ |
| [243](#l243) | int table\_list = 0; /\*\*< tag list using table tag \*/ |
| [244](#l244) | int table\_flist = 0; /\*\*< file list using table tag \*/ |
| [245](#l245) | int colorize\_warned\_line = 0; /\*\*< colorize warned line \*/ |
| [246](#l246) | const char \*normal\_suffix = "html"; /\*\*< suffix of normal html file \*/ |
| [247](#l247) | const char \*HTML; /\*\*< HTML \*/ |
| [248](#l248) | const char \*action = "cgi-bin/global.cgi"; /\*\*< default action \*/ |
| [249](#l249) | const char \*completion\_action = "cgi-bin/completion.cgi"; /\*\*< completion\_action \*/ |
| [250](#l250) | int definition\_header=NO\_HEADER; /\*\*< (NO|BEFORE|RIGHT|AFTER)\_HEADER \*/ |
| [251](#l251) | const char \*include\_file\_suffixes = DEFAULTINCLUDEFILESUFFIXES; /\*\*< include\_file\_suffixes \*/ |
| [252](#l252) | static const char \*langmap = DEFAULTLANGMAP; /\*\*< langmap \*/ |
| [253](#l253) | int grtags\_is\_empty = 0; /\*\*< grtags\_is\_empty \*/ |
| [254](#l254) |  |
| [255](#l255) | const char \*short\_options = "acC:d:DfFghIm:nNoqst:Tvwx"; |
| [256](#l256) | struct option const long\_options[] = { |
| [257](#l257) | /\* |
| [258](#l258) | \* These options have long name and short name. |
| [259](#l259) | \* We throw them to the processing of short options. |
| [260](#l260) | \*/ |
| [261](#l261) | {"alphabet", no\_argument, NULL, 'a'}, |
| [262](#l262) | {"directory", required\_argument, NULL, 'C'}, |
| [263](#l263) | {"dbpath", required\_argument, NULL, 'd'}, |
| [264](#l264) | {"dynamic", no\_argument, NULL, 'D'}, |
| [265](#l265) | {"form", no\_argument, NULL, 'f'}, |
| [266](#l266) | {"frame", no\_argument, NULL, 'F'}, |
| [267](#l267) | {"func-header", optional\_argument, NULL, 'h'}, |
| [268](#l268) | {"gtags", no\_argument, NULL, 'g'}, |
| [269](#l269) | {"icon", no\_argument, NULL, 'I'}, |
| [270](#l270) | {"line-number", optional\_argument, NULL, 'n'}, |
| [271](#l271) | {"main-func", required\_argument, NULL, 'm'}, |
| [272](#l272) | {"other", no\_argument, NULL, 'o'}, |
| [273](#l273) | {"symbol", no\_argument, NULL, 's'}, |
| [274](#l274) | {"table-flist", optional\_argument, NULL, 'T'}, |
| [275](#l275) | {"title", required\_argument, NULL, 't'}, |
| [276](#l276) | {"verbose", no\_argument, NULL, 'v'}, |
| [277](#l277) | {"warning", no\_argument, NULL, 'w'}, |
| [278](#l278) |  |
| [279](#l279) | /\* |
| [280](#l280) | \* The following are long name only. |
| [281](#l281) | \*/ |
| [282](#l282) | /\* flag value \*/ |
| [283](#l283) | {"caution", no\_argument, &caution, 1}, |
| [284](#l284) | {"colorize-warned-line", no\_argument, &colorize\_warned\_line, 1}, |
| [285](#l285) | {"debug", no\_argument, &debug, 1}, |
| [286](#l286) | {"disable-grep", no\_argument, &enable\_grep, 0}, |
| [287](#l287) | {"disable-idutils", no\_argument, &enable\_idutils, 0}, |
| [288](#l288) | {"full-path", no\_argument, &full\_path, 1}, |
| [289](#l289) | {"fixed-guide", no\_argument, &fixed\_guide, 1}, |
| [290](#l290) | {"map-file", no\_argument, &map\_file, 1}, |
| [291](#l291) | {"no-order-list", no\_argument, &no\_order\_list, 1}, |
| [292](#l292) | {"show-position", no\_argument, &show\_position, 1}, |
| [293](#l293) | {"statistics", no\_argument, &statistics, STATISTICS\_STYLE\_TABLE}, |
| [294](#l294) | {"suggest", no\_argument, &suggest, 1}, |
| [295](#l295) | {"suggest2", no\_argument, &suggest2, 1}, |
| [296](#l296) | {"table-list", no\_argument, &table\_list, 1}, |
| [297](#l297) | {"version", no\_argument, &show\_version, 1}, |
| [298](#l298) | {"help", no\_argument, &show\_help, 1}, |
| [299](#l299) |  |
| [300](#l300) | /\* accept value \*/ |
| [301](#l301) | #define OPT\_CVSWEB 128 |
| [302](#l302) | #define OPT\_CVSWEB\_CVSROOT 129 |
| [303](#l303) | #define OPT\_NCOL 130 |
| [304](#l304) | #define OPT\_INSERT\_FOOTER 131 |
| [305](#l305) | #define OPT\_INSERT\_HEADER 132 |
| [306](#l306) | #define OPT\_ITEM\_ORDER 133 |
| [307](#l307) | #define OPT\_TABS 134 |
| [308](#l308) | #define OPT\_CFLOW 135 |
| [309](#l309) | #define OPT\_AUTO\_COMPLETION 136 |
| [310](#l310) | #define OPT\_TREE\_VIEW 137 |
| [311](#l311) | #define OPT\_HTML\_HEADER 138 |
| [312](#l312) | #define OPT\_CALL\_TREE 139 |
| [313](#l313) | #define OPT\_CALLEE\_TREE 140 |
| [314](#l314) | {"auto-completion", optional\_argument, NULL, OPT\_AUTO\_COMPLETION}, |
| [315](#l315) | {"call-tree", required\_argument, NULL, OPT\_CALL\_TREE}, |
| [316](#l316) | {"callee-tree", required\_argument, NULL, OPT\_CALLEE\_TREE}, |
| [317](#l317) | {"cflow", required\_argument, NULL, OPT\_CFLOW}, |
| [318](#l318) | {"cvsweb", required\_argument, NULL, OPT\_CVSWEB}, |
| [319](#l319) | {"cvsweb-cvsroot", required\_argument, NULL, OPT\_CVSWEB\_CVSROOT}, |
| [320](#l320) | {"gtagsconf", required\_argument, NULL, OPT\_GTAGSCONF}, |
| [321](#l321) | {"gtagslabel", required\_argument, NULL, OPT\_GTAGSLABEL}, |
| [322](#l322) | {"html-header", required\_argument,NULL, OPT\_HTML\_HEADER}, |
| [323](#l323) | {"ncol", required\_argument, NULL, OPT\_NCOL}, |
| [324](#l324) | {"insert-footer", required\_argument, NULL, OPT\_INSERT\_FOOTER}, |
| [325](#l325) | {"insert-header", required\_argument, NULL, OPT\_INSERT\_HEADER}, |
| [326](#l326) | {"item-order", required\_argument, NULL, OPT\_ITEM\_ORDER}, |
| [327](#l327) | {"tabs", required\_argument, NULL, OPT\_TABS}, |
| [328](#l328) | {"tree-view", optional\_argument, NULL, OPT\_TREE\_VIEW}, |
| [329](#l329) | { 0 } |
| [330](#l330) | }; |
| [331](#l331) |  |
| [332](#l332) | static void |
| [333](#l333) | usage(void) |
| [334](#l334) | { |
| [335](#l335) | if (!qflag) |
| [336](#l336) | fputs(usage\_const, stderr); |
| [337](#l337) | exit(2); |
| [338](#l338) | } |
| [339](#l339) | static void |
| [340](#l340) | help(void) |
| [341](#l341) | { |
| [342](#l342) | fputs(usage\_const, stdout); |
| [343](#l343) | fputs(help\_const, stdout); |
| [344](#l344) | exit(0); |
| [345](#l345) | } |
| [346](#l346) | /\*\* |
| [347](#l347) | \* Htags catch signal even if the parent ignore it. |
| [348](#l348) | \*/ |
| [349](#l349) | void |
| [350](#l350) | clean(void) |
| [351](#l351) | { |
| [352](#l352) | unload\_gpath(); |
| [353](#l353) | cache\_close(); |
| [354](#l354) | } |
| [355](#l355) | /\*\* |
| [356](#l356) | \* Signal handler. |
| [357](#l357) | \* |
| [358](#l358) | \* This handler is set up in signal\_setup(). |
| [359](#l359) | \*/ |
| [360](#l360) | static void |
| [361](#l361) | suddenly(int signo) |
| [362](#l362) | { |
| [363](#l363) | signo = 0; /\* to satisfy compiler \*/ |
| [364](#l364) |  |
| [365](#l365) | clean(); |
| [366](#l366) | exit(1); |
| [367](#l367) | } |
| [368](#l368) |  |
| [369](#l369) | /\*\* |
| [370](#l370) | \* Setup signal hander. |
| [371](#l371) | \* |
| [372](#l372) | \* Makes signals SIGINT, SIGTERM, SIGHUP and SIGQUIT |
| [373](#l373) | \* call suddenly() if triggered. |
| [374](#l374) | \*/ |
| [375](#l375) | static void |
| [376](#l376) | signal\_setup(void) |
| [377](#l377) | { |
| [378](#l378) | signal(SIGINT, suddenly); |
| [379](#l379) | signal(SIGTERM, suddenly); |
| [380](#l380) | #ifdef SIGHUP |
| [381](#l381) | signal(SIGHUP, suddenly); |
| [382](#l382) | #endif |
| [383](#l383) | #ifdef SIGQUIT |
| [384](#l384) | signal(SIGQUIT, suddenly); |
| [385](#l385) | #endif |
| [386](#l386) | } |
| [387](#l387) |  |
| [388](#l388) | /\*\* |
| [389](#l389) | \* make directory in the dist (distpath) directory. |
| [390](#l390) | \* |
| [391](#l391) | \* @param[in] name name of directory to create. |
| [392](#l392) | \* |
| [393](#l393) | \* Creates a file called "index.html" in the new directory. |
| [394](#l394) | \* |
| [395](#l395) | \* mkdir() creates the directory in mode 0775, if doesn't exist. |
| [396](#l396) | \*/ |
| [397](#l397) | static void |
| [398](#l398) | make\_directory\_in\_distpath(const char \*name) |
| [399](#l399) | { |
| [400](#l400) | char path[MAXPATHLEN]; |
| [401](#l401) | FILE \*op; |
| [402](#l402) |  |
| [403](#l403) | strlimcpy(path, makepath(distpath, name, NULL), sizeof(path)); |
| [404](#l404) | if (!test("d", path)) |
| [405](#l405) | if (mkdir(path, 0775)) |
| [406](#l406) | die("cannot make directory '%s'.", path); |
| [407](#l407) | /\* |
| [408](#l408) | \* Not to publish the directory list. |
| [409](#l409) | \*/ |
| [410](#l410) | op = fopen(makepath(path, "index.html", NULL), "w"); |
| [411](#l411) | if (op == NULL) |
| [412](#l412) | die("cannot make file '%s'.", makepath(path, "index.html", NULL)); |
| [413](#l413) | fputs(html\_begin, op); |
| [414](#l414) | fputs(html\_end, op); |
| [415](#l415) | fputc('\n', op); |
| [416](#l416) | fclose(op); |
| [417](#l417) | } |
| [418](#l418) | /\*\* |
| [419](#l419) | \* Load file. |
| [420](#l420) | \*/ |
| [421](#l421) | void |
| [422](#l422) | loadfile(const char \*file, STRBUF \*result) |
| [423](#l423) | { |
| [424](#l424) | STRBUF \*sb = strbuf\_open(0); |
| [425](#l425) | FILE \*ip = fopen(file, "r"); |
| [426](#l426) | if (!ip) |
| [427](#l427) | die("file '%s' not found.", file); |
| [428](#l428) | while (strbuf\_fgets(sb, ip, STRBUF\_NOCRLF) != NULL) |
| [429](#l429) | strbuf\_puts\_nl(result, strbuf\_value(sb)); |
| [430](#l430) | fclose(ip); |
| [431](#l431) | strbuf\_close(sb); |
| [432](#l432) | } |
| [433](#l433) | /\*\* |
| [434](#l434) | \* makeprogram: make CGI program |
| [435](#l435) | \*/ |
| [436](#l436) | static void |
| [437](#l437) | makeprogram(const char \*cgidir, const char \*file, int perm) |
| [438](#l438) | { |
| [439](#l439) | char src[MAXPATHLEN]; |
| [440](#l440) | const char \*dst = makepath(cgidir, file, NULL); |
| [441](#l441) |  |
| [442](#l442) | snprintf(src, sizeof(src), "%s/gtags/%s", datadir, file); |
| [443](#l443) | copyfile(src, dst); |
| [444](#l444) | if (chmod(dst, perm) < 0) |
| [445](#l445) | die("cannot chmod CGI program (%s).", dst); |
| [446](#l446) | html\_count++; |
| [447](#l447) | } |
| [448](#l448) | /\*\* |
| [449](#l449) | \* makerebuild: make rebuild script |
| [450](#l450) | \*/ |
| [451](#l451) | static void |
| [452](#l452) | makerebuild(const char \*file) |
| [453](#l453) | { |
| [454](#l454) | FILE \*op; |
| [455](#l455) |  |
| [456](#l456) | op = fopen(makepath(distpath, file, NULL), "w"); |
| [457](#l457) | if (!op) |
| [458](#l458) | die("cannot make rebuild script."); |
| [459](#l459) | fputs\_nl("#!/bin/sh", op); |
| [460](#l460) | fputs\_nl("#", op); |
| [461](#l461) | fputs\_nl("# rebuild.sh: rebuild hypertext with the previous context.", op); |
| [462](#l462) | fputs\_nl("#", op); |
| [463](#l463) | fputs\_nl("# Usage:", op); |
| [464](#l464) | fputs\_nl("#\t% sh rebuild.sh", op); |
| [465](#l465) | fputs\_nl("#", op); |
| [466](#l466) | fprintf(op, "cd %s && GTAGSCONF='%s' htags%s\n", cwdpath, save\_config, save\_argv); |
| [467](#l467) | fclose(op); |
| [468](#l468) | } |
| [469](#l469) | /\*\* |
| [470](#l470) | \* makehelp: make help file |
| [471](#l471) | \*/ |
| [472](#l472) | static void |
| [473](#l473) | makehelp(const char \*file) |
| [474](#l474) | { |
| [475](#l475) | const char \*\*label = Iflag ? anchor\_comment : anchor\_label; |
| [476](#l476) | const char \*\*icons = anchor\_icons; |
| [477](#l477) | const char \*\*msg = anchor\_msg; |
| [478](#l478) | int n, last = 7; |
| [479](#l479) | FILE \*op; |
| [480](#l480) |  |
| [481](#l481) | op = fopen(makepath(distpath, file, NULL), "w"); |
| [482](#l482) | if (!op) |
| [483](#l483) | die("cannot make help file."); |
| [484](#l484) | fputs\_nl(gen\_page\_begin("HELP", TOPDIR), op); |
| [485](#l485) | fputs\_nl(body\_begin, op); |
| [486](#l486) | fputs(header\_begin, op); |
| [487](#l487) | fputs("Usage of Links", op); |
| [488](#l488) | fputs\_nl(header\_end, op); |
| [489](#l489) | if (!Iflag) |
| [490](#l490) | fputs(verbatim\_begin, op); |
| [491](#l491) | fputs("/\* ", op); |
| [492](#l492) | for (n = 0; n <= last; n++) { |
| [493](#l493) | if (Iflag) { |
| [494](#l494) | fputs(gen\_image(CURRENT, icons[n], label[n]), op); |
| [495](#l495) | if (n < last) |
| [496](#l496) | fputc(' ', op); |
| [497](#l497) | } else { |
| [498](#l498) | fprintf(op, "[%s]", label[n]); |
| [499](#l499) | } |
| [500](#l500) | } |
| [501](#l501) | if (show\_position) |
| [502](#l502) | fprintf(op, "%s%s value='+<line number> <file>' %s", quote\_space, position\_begin, position\_end); |
| [503](#l503) | fputs(" \*/", op); |
| [504](#l504) | if (!Iflag) |
| [505](#l505) | fputs\_nl(verbatim\_end, op); |
| [506](#l506) | else |
| [507](#l507) | fputc('\n', op); |
| [508](#l508) | fputs\_nl(define\_list\_begin, op); |
| [509](#l509) | for (n = 0; n <= last; n++) { |
| [510](#l510) | fputs(define\_term\_begin, op); |
| [511](#l511) | if (Iflag) { |
| [512](#l512) | fputs(gen\_image(CURRENT, icons[n], label[n]), op); |
| [513](#l513) | } else { |
| [514](#l514) | fprintf(op, "[%s]", label[n]); |
| [515](#l515) | } |
| [516](#l516) | fputs(define\_term\_end, op); |
| [517](#l517) | fputs(define\_desc\_begin, op); |
| [518](#l518) | fputs(msg[n], op); |
| [519](#l519) | fputs\_nl(define\_desc\_end, op); |
| [520](#l520) | } |
| [521](#l521) | if (show\_position) { |
| [522](#l522) | fputs(define\_term\_begin, op); |
| [523](#l523) | fprintf(op, "%s%s value='+<line number> <file>' %s", quote\_space, position\_begin, position\_end); |
| [524](#l524) | fputs(define\_term\_end, op); |
| [525](#l525) | fputs(define\_desc\_begin, op); |
| [526](#l526) | fputs("The current position (line number and file name).", op); |
| [527](#l527) | fputs\_nl(define\_desc\_end, op); |
| [528](#l528) | } |
| [529](#l529) | fputs\_nl(define\_list\_end, op); |
| [530](#l530) | fputs\_nl(body\_end, op); |
| [531](#l531) | fputs\_nl(gen\_page\_end(), op); |
| [532](#l532) | fclose(op); |
| [533](#l533) | html\_count++; |
| [534](#l534) | } |
| [535](#l535) | /\* |
| [536](#l536) | \* makesearchpart: make search part |
| [537](#l537) | \* |
| [538](#l538) | \* @param[in] target $target |
| [539](#l539) | \* @return html |
| [540](#l540) | \*/ |
| [541](#l541) | static char \* |
| [542](#l542) | makesearchpart(const char \*target) |
| [543](#l543) | { |
| [544](#l544) | STATIC\_STRBUF(sb); |
| [545](#l545) |  |
| [546](#l546) | strbuf\_clear(sb); |
| [547](#l547) | strbuf\_puts(sb, header\_begin); |
| [548](#l548) | if (Fflag) |
| [549](#l549) | strbuf\_puts(sb, gen\_href\_begin(NULL, "search", normal\_suffix, NULL)); |
| [550](#l550) | strbuf\_puts(sb, "SEARCH"); |
| [551](#l551) | if (Fflag) |
| [552](#l552) | strbuf\_puts(sb, gen\_href\_end()); |
| [553](#l553) | strbuf\_puts\_nl(sb, header\_end); |
| [554](#l554) | if (!target) { |
| [555](#l555) | strbuf\_puts(sb, "Please input object name and select [Search]. POSIX's regular expression is allowed."); |
| [556](#l556) | strbuf\_puts\_nl(sb, br); |
| [557](#l557) | } |
| [558](#l558) | strbuf\_puts\_nl(sb, gen\_form\_begin(target)); |
| [559](#l559) | strbuf\_puts\_nl(sb, gen\_input("pattern", NULL, NULL)); |
| [560](#l560) | strbuf\_puts\_nl(sb, gen\_input(NULL, "Search", "submit")); |
| [561](#l561) | strbuf\_puts(sb, gen\_input(NULL, "Reset", "reset")); |
| [562](#l562) | strbuf\_puts\_nl(sb, br); |
| [563](#l563) | strbuf\_puts(sb, gen\_input\_radio("type", "definition", 1, "Retrieve the definition place of the specified symbol.")); |
| [564](#l564) | strbuf\_puts\_nl(sb, target ? "Def" : "Definition"); |
| [565](#l565) | strbuf\_puts(sb, gen\_input\_radio("type", "reference", 0, "Retrieve the reference place of the specified symbol.")); |
| [566](#l566) | strbuf\_puts\_nl(sb, target ? "Ref" : "Reference"); |
| [567](#l567) | strbuf\_puts(sb, gen\_input\_radio("type", "symbol", 0, "Retrieve the place of the specified symbol is used.")); |
| [568](#l568) | strbuf\_puts\_nl(sb, target ? "Sym" : "Other symbol"); |
| [569](#l569) | strbuf\_puts(sb, gen\_input\_radio("type", "path", 0, "Look for path name which matches to the specified pattern.")); |
| [570](#l570) | strbuf\_puts\_nl(sb, target ? "Path" : "Path name"); |
| [571](#l571) | if (enable\_grep) { |
| [572](#l572) | strbuf\_puts(sb, gen\_input\_radio("type", "grep", 0, "Retrieve lines which matches to the specified pattern.")); |
| [573](#l573) | strbuf\_puts\_nl(sb, target ? "Grep" : "Grep pattern"); |
| [574](#l574) | } |
| [575](#l575) | if (enable\_idutils && test("f", makepath(dbpath, "ID", NULL))) { |
| [576](#l576) | strbuf\_puts(sb, gen\_input\_radio("type", "idutils", 0, "Retrieve lines which matches to the specified pattern using idutils(1).")); |
| [577](#l577) | strbuf\_puts\_nl(sb, target ? "Id" : "Id pattern"); |
| [578](#l578) | } |
| [579](#l579) | strbuf\_puts\_nl(sb, br); |
| [580](#l580) | strbuf\_puts(sb, gen\_input\_checkbox("icase", NULL, "Ignore case distinctions in the pattern.")); |
| [581](#l581) | strbuf\_puts\_nl(sb, target ? "Icase" : "Ignore case"); |
| [582](#l582) | if (other\_files) { |
| [583](#l583) | strbuf\_puts(sb, gen\_input\_checkbox("other", NULL, "Files other than the source code are also retrieved.")); |
| [584](#l584) | strbuf\_puts\_nl(sb, target ? "Other" : "Other files"); |
| [585](#l585) | } |
| [586](#l586) | if (other\_files && !target) { |
| [587](#l587) | strbuf\_puts\_nl(sb, br); |
| [588](#l588) | strbuf\_puts(sb, "('Other files' is effective only to 'Path name'"); |
| [589](#l589) | if (enable\_grep) |
| [590](#l590) | strbuf\_puts(sb, " and 'Grep pattern'"); |
| [591](#l591) | strbuf\_puts\_nl(sb, ".)"); |
| [592](#l592) | } |
| [593](#l593) | strbuf\_puts\_nl(sb, gen\_form\_end()); |
| [594](#l594) | return strbuf\_value(sb); |
| [595](#l595) | } |
| [596](#l596) | /\*\* |
| [597](#l597) | \* makeindex: make index file |
| [598](#l598) | \* |
| [599](#l599) | \* @param[in] file file name |
| [600](#l600) | \* @param[in] title title of index file |
| [601](#l601) | \* @param[in] index common part |
| [602](#l602) | \*/ |
| [603](#l603) | static void |
| [604](#l604) | makeindex(const char \*file, const char \*title, const char \*index) |
| [605](#l605) | { |
| [606](#l606) | FILE \*op; |
| [607](#l607) |  |
| [608](#l608) | op = fopen(makepath(distpath, file, NULL), "w"); |
| [609](#l609) | if (!op) |
| [610](#l610) | die("cannot make file '%s'.", file); |
| [611](#l611) | if (Fflag) { |
| [612](#l612) | fputs\_nl(gen\_page\_frameset\_begin(title), op); |
| [613](#l613) | fputs\_nl(gen\_frameset\_begin("cols='200,\*'"), op); |
| [614](#l614) | if (fflag) { |
| [615](#l615) | fputs\_nl(gen\_frameset\_begin("rows='33%,33%,\*'"), op); |
| [616](#l616) | fputs\_nl(gen\_frame("search", makepath(NULL, "search", normal\_suffix)), op); |
| [617](#l617) | } else { |
| [618](#l618) | fputs\_nl(gen\_frameset\_begin("rows='50%,\*'"), op); |
| [619](#l619) | } |
| [620](#l620) | /\* |
| [621](#l621) | \* id='xxx' for XHTML |
| [622](#l622) | \* name='xxx' for HTML |
| [623](#l623) | \*/ |
| [624](#l624) | fputs\_nl(gen\_frame("defines", makepath(NULL, "defines", normal\_suffix)), op); |
| [625](#l625) | fputs\_nl(gen\_frame("files", makepath(NULL, "files", normal\_suffix)), op); |
| [626](#l626) | fputs\_nl(gen\_frameset\_end(), op); |
| [627](#l627) | fputs\_nl(gen\_frame("mains", makepath(NULL, "mains", normal\_suffix)), op); |
| [628](#l628) | fputs\_nl(noframes\_begin, op); |
| [629](#l629) | fputs\_nl(body\_begin, op); |
| [630](#l630) | fputs(index, op); |
| [631](#l631) | fputs\_nl(body\_end, op); |
| [632](#l632) | fputs\_nl(noframes\_end, op); |
| [633](#l633) | fputs\_nl(gen\_frameset\_end(), op); |
| [634](#l634) | fputs\_nl(gen\_page\_end(), op); |
| [635](#l635) | } else { |
| [636](#l636) | fputs\_nl(gen\_page\_index\_begin(title, jscode), op); |
| [637](#l637) | fputs\_nl(body\_begin, op); |
| [638](#l638) | if (insert\_header) |
| [639](#l639) | fputs(gen\_insert\_header(TOPDIR), op); |
| [640](#l640) | fputs(index, op); |
| [641](#l641) | if (insert\_footer) |
| [642](#l642) | fputs(gen\_insert\_footer(TOPDIR), op); |
| [643](#l643) | fputs\_nl(body\_end, op); |
| [644](#l644) | fputs\_nl(gen\_page\_end(), op); |
| [645](#l645) | } |
| [646](#l646) | fclose(op); |
| [647](#l647) | html\_count++; |
| [648](#l648) | } |
| [649](#l649) | /\*\* |
| [650](#l650) | \* makemainindex: make main index |
| [651](#l651) | \* |
| [652](#l652) | \* @param[in] file file name |
| [653](#l653) | \* @param[in] index common part |
| [654](#l654) | \*/ |
| [655](#l655) | static void |
| [656](#l656) | makemainindex(const char \*file, const char \*index) |
| [657](#l657) | { |
| [658](#l658) | FILE \*op; |
| [659](#l659) |  |
| [660](#l660) | op = fopen(makepath(distpath, file, NULL), "w"); |
| [661](#l661) | if (!op) |
| [662](#l662) | die("cannot make file '%s'.", file); |
| [663](#l663) | fputs\_nl(gen\_page\_index\_begin(title, jscode), op); |
| [664](#l664) | fputs\_nl(body\_begin, op); |
| [665](#l665) | if (insert\_header) |
| [666](#l666) | fputs(gen\_insert\_header(TOPDIR), op); |
| [667](#l667) | fputs(index, op); |
| [668](#l668) | if (insert\_footer) |
| [669](#l669) | fputs(gen\_insert\_footer(TOPDIR), op); |
| [670](#l670) | fputs\_nl(body\_end, op); |
| [671](#l671) | fputs\_nl(gen\_page\_end(), op); |
| [672](#l672) | fclose(op); |
| [673](#l673) | html\_count++; |
| [674](#l674) | } |
| [675](#l675) | /\*\* |
| [676](#l676) | \* makesearchindex: make search html |
| [677](#l677) | \* |
| [678](#l678) | \* @param[in] file file name |
| [679](#l679) | \*/ |
| [680](#l680) | static void |
| [681](#l681) | makesearchindex(const char \*file) |
| [682](#l682) | { |
| [683](#l683) | FILE \*op; |
| [684](#l684) |  |
| [685](#l685) | op = fopen(makepath(distpath, file, NULL), "w"); |
| [686](#l686) | if (!op) |
| [687](#l687) | die("cannot create file '%s'.", file); |
| [688](#l688) | fputs\_nl(gen\_page\_index\_begin("SEARCH", jscode), op); |
| [689](#l689) | fputs\_nl(body\_begin, op); |
| [690](#l690) | fputs(makesearchpart("mains"), op); |
| [691](#l691) | fputs\_nl(body\_end, op); |
| [692](#l692) | fputs\_nl(gen\_page\_end(), op); |
| [693](#l693) | fclose(op); |
| [694](#l694) | html\_count++; |
| [695](#l695) | } |
| [696](#l696) | /\*\* |
| [697](#l697) | \* makehtaccess: make ".htaccess" skeleton file. |
| [698](#l698) | \*/ |
| [699](#l699) | static void |
| [700](#l700) | makehtaccess(const char \*file, int perm) |
| [701](#l701) | { |
| [702](#l702) | char src[MAXPATHLEN]; |
| [703](#l703) | const char \*dst = makepath(distpath, file, NULL); |
| [704](#l704) |  |
| [705](#l705) | snprintf(src, sizeof(src), "%s/gtags/dot\_htaccess", datadir); |
| [706](#l706) | copyfile(src, dst); |
| [707](#l707) | if (chmod(dst, perm) < 0) |
| [708](#l708) | die("cannot chmod .htaccess skeleton."); |
| [709](#l709) | } |
| [710](#l710) | /\*\* |
| [711](#l711) | \* makehtml: make html files |
| [712](#l712) | \* |
| [713](#l713) | \* @param[in] total number of files. |
| [714](#l714) | \*/ |
| [715](#l715) | static void |
| [716](#l716) | makehtml(int total) |
| [717](#l717) | { |
| [718](#l718) | GFIND \*gp; |
| [719](#l719) | FILE \*anchor\_stream; |
| [720](#l720) | const char \*path; |
| [721](#l721) | int count = 0; |
| [722](#l722) |  |
| [723](#l723) | /\* |
| [724](#l724) | \* Create anchor stream for anchor\_load(). |
| [725](#l725) | \*/ |
| [726](#l726) | anchor\_stream = tmpfile(); |
| [727](#l727) | #if defined(\_WIN32) && !defined(\_\_CYGWIN\_\_) |
| [728](#l728) | /\* |
| [729](#l729) | \* tmpfile is created in the root, which user's can't write on Vista+. |
| [730](#l730) | \* Use \_tempnam and open it directly. |
| [731](#l731) | \*/ |
| [732](#l732) | if (anchor\_stream == NULL) { |
| [733](#l733) | char \*name = \_tempnam(tmpdir, "htags"); |
| [734](#l734) | anchor\_stream = fopen(name, "w+bD"); |
| [735](#l735) | free(name); |
| [736](#l736) | } |
| [737](#l737) | #endif |
| [738](#l738) | gp = gfind\_open(dbpath, NULL, other\_files ? GPATH\_BOTH : GPATH\_SOURCE, 0); |
| [739](#l739) | while ((path = gfind\_read(gp)) != NULL) { |
| [740](#l740) | if (gp->type == GPATH\_OTHER) |
| [741](#l741) | fputc(' ', anchor\_stream); |
| [742](#l742) | fputs(path, anchor\_stream); |
| [743](#l743) | fputc('\n', anchor\_stream); |
| [744](#l744) | } |
| [745](#l745) | gfind\_close(gp); |
| [746](#l746) | /\* |
| [747](#l747) | \* Prepare anchor stream for anchor\_load(). |
| [748](#l748) | \*/ |
| [749](#l749) | anchor\_prepare(anchor\_stream); |
| [750](#l750) | /\* |
| [751](#l751) | \* For each path in GPATH, convert the path into HTML file. |
| [752](#l752) | \*/ |
| [753](#l753) | gp = gfind\_open(dbpath, NULL, other\_files ? GPATH\_BOTH : GPATH\_SOURCE, 0); |
| [754](#l754) | while ((path = gfind\_read(gp)) != NULL) { |
| [755](#l755) | char html[MAXPATHLEN]; |
| [756](#l756) |  |
| [757](#l757) | if (gp->type == GPATH\_OTHER && !other\_files) |
| [758](#l758) | continue; |
| [759](#l759) | /\* |
| [760](#l760) | \* load tags belonging to the path. |
| [761](#l761) | \* The path must be start "./". |
| [762](#l762) | \*/ |
| [763](#l763) | anchor\_load(path); |
| [764](#l764) | /\* |
| [765](#l765) | \* inform the current path name to lex() function. |
| [766](#l766) | \*/ |
| [767](#l767) | save\_current\_path(path); |
| [768](#l768) | count++; |
| [769](#l769) | path += 2; /\* remove './' at the head \*/ |
| [770](#l770) | message(" [%d/%d] converting %s", count, total, path); |
| [771](#l771) | snprintf(html, sizeof(html), "%s/%s/%s.%s", distpath, SRCS, path2fid(path), HTML); |
| [772](#l772) | src2html(path, html, gp->type == GPATH\_OTHER); |
| [773](#l773) | } |
| [774](#l774) | gfind\_close(gp); |
| [775](#l775) | } |
| [776](#l776) | /\*\* |
| [777](#l777) | \* makecommonpart: make a common part for "mains.html" and "index.html" |
| [778](#l778) | \* |
| [779](#l779) | \* @param[in] title |
| [780](#l780) | \* @param[in] defines |
| [781](#l781) | \* @param[in] files |
| [782](#l782) | \* @return index common part |
| [783](#l783) | \*/ |
| [784](#l784) | static char \* |
| [785](#l785) | makecommonpart(const char \*title, const char \*defines, const char \*files) |
| [786](#l786) | { |
| [787](#l787) | FILE \*ip; |
| [788](#l788) | STRBUF \*sb = strbuf\_open(0); |
| [789](#l789) | STRBUF \*ib = strbuf\_open(0); |
| [790](#l790) | char buf[MAXFILLEN]; |
| [791](#l791) | const char \*tips = "Go to the GLOBAL project page."; |
| [792](#l792) | const char \*\_, \*item; |
| [793](#l793) |  |
| [794](#l794) | strbuf\_puts(sb, title\_begin); |
| [795](#l795) | strbuf\_puts(sb, title); |
| [796](#l796) | strbuf\_puts\_nl(sb, title\_end); |
| [797](#l797) | strbuf\_puts\_nl(sb, poweredby\_begin); |
| [798](#l798) | strbuf\_sprintf(sb, "Last updated %s%s\n", now(), br); |
| [799](#l799) | if (Iflag) { |
| [800](#l800) | snprintf(buf, sizeof(buf), "Powered by GLOBAL-%s.", get\_version()); |
| [801](#l801) | strbuf\_puts(sb, gen\_href\_begin\_with\_title\_target(NULL, www, NULL, NULL, tips,"\_top")); |
| [802](#l802) | strbuf\_puts(sb, gen\_image(CURRENT, "pglobe", buf)); |
| [803](#l803) | strbuf\_puts(sb, gen\_href\_end()); |
| [804](#l804) | strbuf\_puts(sb, br); |
| [805](#l805) | } else { |
| [806](#l806) | strbuf\_sprintf(sb, "Powered by %sGLOBAL-%s%s.%s\n", |
| [807](#l807) | gen\_href\_begin\_with\_title\_target(NULL, www, NULL, NULL, tips, "\_top"), |
| [808](#l808) | get\_version(), |
| [809](#l809) | gen\_href\_end(), |
| [810](#l810) | br); |
| [811](#l811) | } |
| [812](#l812) | strbuf\_puts\_nl(sb, poweredby\_end); |
| [813](#l813) | strbuf\_puts\_nl(sb, hr); |
| [814](#l814) | /\* |
| [815](#l815) | \* Print items according to the value of variable 'item\_order'. |
| [816](#l816) | \*/ |
| [817](#l817) | for (item = item\_order; \*item; item++) { |
| [818](#l818) | switch (\*item) { |
| [819](#l819) | case 'c': |
| [820](#l820) | if (caution) { |
| [821](#l821) | strbuf\_puts\_nl(sb, caution\_begin); |
| [822](#l822) | strbuf\_sprintf(sb, "<font size='+2' color='red'>CAUTION</font>%s\n", br); |
| [823](#l823) | strbuf\_sprintf(sb, "This hypertext consists of %d files.\n", html\_count); |
| [824](#l824) | strbuf\_puts\_nl(sb, "Please don't download the whole hypertext using a hypertext copy tool."); |
| [825](#l825) | strbuf\_puts\_nl(sb, "Our network cannot afford such traffic."); |
| [826](#l826) | strbuf\_puts\_nl(sb, "Instead, you can generate the same thing in your computer using"); |
| [827](#l827) | strbuf\_puts(sb, gen\_href\_begin\_with\_title\_target(NULL, www, NULL, NULL, NULL, "\_top")); |
| [828](#l828) | strbuf\_puts(sb, "GLOBAL source code tag system"); |
| [829](#l829) | strbuf\_puts\_nl(sb, gen\_href\_end()); |
| [830](#l830) | strbuf\_puts\_nl(sb, "Thank you."); |
| [831](#l831) | strbuf\_puts\_nl(sb, caution\_end); |
| [832](#l832) | strbuf\_sprintf(sb, "\n%s\n", hr); |
| [833](#l833) | } |
| [834](#l834) | break; |
| [835](#l835) | case 's': |
| [836](#l836) | if (fflag) { |
| [837](#l837) | strbuf\_puts(sb, makesearchpart(NULL)); |
| [838](#l838) | strbuf\_puts\_nl(sb, hr); |
| [839](#l839) | } |
| [840](#l840) | break; |
| [841](#l841) | case 't': |
| [842](#l842) | if (call\_file || callee\_file) { |
| [843](#l843) | strbuf\_puts(sb, header\_begin); |
| [844](#l844) | if (call\_file) { |
| [845](#l845) | strbuf\_puts(sb, gen\_href\_begin(NULL, "call", normal\_suffix, NULL)); |
| [846](#l846) | strbuf\_puts(sb, title\_call\_tree); |
| [847](#l847) | strbuf\_puts(sb, gen\_href\_end()); |
| [848](#l848) | } |
| [849](#l849) | if (call\_file && callee\_file) |
| [850](#l850) | strbuf\_puts(sb, " / "); |
| [851](#l851) | if (callee\_file) { |
| [852](#l852) | strbuf\_puts(sb, gen\_href\_begin(NULL, "callee", normal\_suffix, NULL)); |
| [853](#l853) | strbuf\_puts(sb, title\_callee\_tree); |
| [854](#l854) | strbuf\_puts(sb, gen\_href\_end()); |
| [855](#l855) | } |
| [856](#l856) | strbuf\_puts\_nl(sb, header\_end); |
| [857](#l857) | strbuf\_puts\_nl(sb, hr); |
| [858](#l858) | } |
| [859](#l859) | break; |
| [860](#l860) | case 'm': |
| [861](#l861) | strbuf\_sprintf(sb, "%sMAINS%s\n", header\_begin, header\_end); |
| [862](#l862) |  |
| [863](#l863) | snprintf(buf, sizeof(buf), PQUOTE "%s --result=ctags-xid --encode-path=\" \t\" --nofilter=path %s" PQUOTE, quote\_shell(global\_path), main\_func); |
| [864](#l864) | ip = popen(buf, "r"); |
| [865](#l865) | if (!ip) |
| [866](#l866) | die("cannot execute '%s'.", buf); |
| [867](#l867) | strbuf\_puts\_nl(sb, gen\_list\_begin()); |
| [868](#l868) | while ((\_ = strbuf\_fgets(ib, ip, STRBUF\_NOCRLF)) != NULL) { |
| [869](#l869) | char fid[MAXFIDLEN]; |
| [870](#l870) | const char \*ctags\_x = parse\_xid(\_, fid, NULL); |
| [871](#l871) |  |
| [872](#l872) | strbuf\_puts\_nl(sb, gen\_list\_body(SRCS, ctags\_x, fid)); |
| [873](#l873) | } |
| [874](#l874) | strbuf\_puts\_nl(sb, gen\_list\_end()); |
| [875](#l875) | if (pclose(ip) != 0) |
| [876](#l876) | die("terminated abnormally '%s' (errno = %d).", buf, errno); |
| [877](#l877) | strbuf\_puts\_nl(sb, hr); |
| [878](#l878) | break; |
| [879](#l879) | case 'd': |
| [880](#l880) | if (aflag && !Fflag) { |
| [881](#l881) | strbuf\_puts(sb, header\_begin); |
| [882](#l882) | strbuf\_puts(sb, title\_define\_index); |
| [883](#l883) | strbuf\_puts\_nl(sb, header\_end); |
| [884](#l884) | strbuf\_puts(sb, defines); |
| [885](#l885) | } else { |
| [886](#l886) | strbuf\_puts(sb, header\_begin); |
| [887](#l887) | strbuf\_puts(sb, gen\_href\_begin(NULL, "defines", normal\_suffix, NULL)); |
| [888](#l888) | strbuf\_puts(sb, title\_define\_index); |
| [889](#l889) | strbuf\_puts(sb, gen\_href\_end()); |
| [890](#l890) | strbuf\_puts\_nl(sb, header\_end); |
| [891](#l891) | } |
| [892](#l892) | strbuf\_puts\_nl(sb, hr); |
| [893](#l893) | break; |
| [894](#l894) | case 'f': |
| [895](#l895) | if (Fflag) { |
| [896](#l896) | strbuf\_puts(sb, header\_begin); |
| [897](#l897) | strbuf\_puts(sb, gen\_href\_begin(NULL, "files", normal\_suffix, NULL)); |
| [898](#l898) | strbuf\_puts(sb, title\_file\_index); |
| [899](#l899) | strbuf\_puts(sb, gen\_href\_end()); |
| [900](#l900) | strbuf\_puts\_nl(sb, header\_end); |
| [901](#l901) | } else { |
| [902](#l902) | strbuf\_puts(sb, header\_begin); |
| [903](#l903) | strbuf\_puts(sb, title\_file\_index); |
| [904](#l904) | strbuf\_puts\_nl(sb, header\_end); |
| [905](#l905) | if (tree\_view) { |
| [906](#l906) | strbuf\_puts\_nl(sb, tree\_control); |
| [907](#l907) | strbuf\_puts\_nl(sb, tree\_loading); |
| [908](#l908) | if (tree\_view\_type) { |
| [909](#l909) | strbuf\_sprintf(sb, tree\_begin\_using, tree\_view\_type); |
| [910](#l910) | strbuf\_putc(sb, '\n'); |
| [911](#l911) | } else { |
| [912](#l912) | strbuf\_puts\_nl(sb, tree\_begin); |
| [913](#l913) | } |
| [914](#l914) | } else if (table\_flist) |
| [915](#l915) | strbuf\_puts\_nl(sb, flist\_begin); |
| [916](#l916) | else if (!no\_order\_list) |
| [917](#l917) | strbuf\_puts\_nl(sb, list\_begin); |
| [918](#l918) | strbuf\_puts(sb, files); |
| [919](#l919) | if (tree\_view) |
| [920](#l920) | strbuf\_puts\_nl(sb, tree\_end); |
| [921](#l921) | else if (table\_flist) |
| [922](#l922) | strbuf\_puts\_nl(sb, flist\_end); |
| [923](#l923) | else if (!no\_order\_list) |
| [924](#l924) | strbuf\_puts\_nl(sb, list\_end); |
| [925](#l925) | else |
| [926](#l926) | strbuf\_puts\_nl(sb, br); |
| [927](#l927) | } |
| [928](#l928) | strbuf\_puts\_nl(sb, hr); |
| [929](#l929) | break; |
| [930](#l930) | default: |
| [931](#l931) | warning("unknown item '%c'. (Ignored)", \*item); |
| [932](#l932) | break; |
| [933](#l933) | } |
| [934](#l934) | } |
| [935](#l935) | strbuf\_close(ib); |
| [936](#l936) |  |
| [937](#l937) | return strbuf\_value(sb); |
| [938](#l938) | /\* doesn't close string buffer \*/ |
| [939](#l939) | } |
| [940](#l940) | /\*\* |
| [941](#l941) | \* basic check. |
| [942](#l942) | \*/ |
| [943](#l943) | static void |
| [944](#l944) | basic\_check(void) |
| [945](#l945) | { |
| [946](#l946) | const char \*p; |
| [947](#l947) |  |
| [948](#l948) | /\* |
| [949](#l949) | \* COMMAND EXISTENCE CHECK |
| [950](#l950) | \*/ |
| [951](#l951) | if (!(p = usable("gtags"))) |
| [952](#l952) | die("gtags command required but not found."); |
| [953](#l953) | strlimcpy(gtags\_path, p, sizeof(gtags\_path)); |
| [954](#l954) | if (!(p = usable("global"))) |
| [955](#l955) | die("global command required but not found."); |
| [956](#l956) | strlimcpy(global\_path, p, sizeof(global\_path)); |
| [957](#l957) | /\* |
| [958](#l958) | \* Temporary directory. |
| [959](#l959) | \*/ |
| [960](#l960) | if ((p = getenv("TMPDIR")) == NULL) |
| [961](#l961) | p = getenv("TMP"); |
| [962](#l962) | if (p != NULL && test("d", p)) |
| [963](#l963) | tmpdir = p; |
| [964](#l964) | } |
| [965](#l965) | /\*\* |
| [966](#l966) | \* load configuration variables. |
| [967](#l967) | \*/ |
| [968](#l968) | static void |
| [969](#l969) | configuration(void) |
| [970](#l970) | { |
| [971](#l971) | STRBUF \*sb = strbuf\_open(0); |
| [972](#l972) |  |
| [973](#l973) | /\* |
| [974](#l974) | \* Config variables. |
| [975](#l975) | \*/ |
| [976](#l976) | strbuf\_reset(sb); |
| [977](#l977) | if (!getconfs("datadir", sb)) |
| [978](#l978) | die("cannot get datadir directory name."); |
| [979](#l979) | strlimcpy(datadir, strbuf\_value(sb), sizeof(datadir)); |
| [980](#l980) | strbuf\_reset(sb); |
| [981](#l981) | if (!getconfs("localstatedir", sb)) |
| [982](#l982) | die("cannot get localstatedir directory name."); |
| [983](#l983) | strlimcpy(localstatedir, strbuf\_value(sb), sizeof(localstatedir)); |
| [984](#l984) | strbuf\_reset(sb); |
| [985](#l985) | if (getconfs("prolog\_script", sb)) |
| [986](#l986) | prolog\_script = check\_strdup(strbuf\_value(sb)); |
| [987](#l987) | strbuf\_reset(sb); |
| [988](#l988) | if (getconfs("epilog\_script", sb)) |
| [989](#l989) | epilog\_script = check\_strdup(strbuf\_value(sb)); |
| [990](#l990) | if (getconfb("colorize\_warned\_line")) |
| [991](#l991) | colorize\_warned\_line = 1; |
| [992](#l992) | strbuf\_reset(sb); |
| [993](#l993) | if (getconfs("include\_file\_suffixes", sb)) |
| [994](#l994) | include\_file\_suffixes = check\_strdup(strbuf\_value(sb)); |
| [995](#l995) | strbuf\_reset(sb); |
| [996](#l996) | if (getconfs("langmap", sb)) |
| [997](#l997) | langmap = check\_strdup(strbuf\_value(sb)); |
| [998](#l998) | strbuf\_close(sb); |
| [999](#l999) | } |
| [1000](#l1000) | /\*\* |
| [1001](#l1001) | \* save\_environment: save configuration data and arguments. |
| [1002](#l1002) | \*/ |
| [1003](#l1003) | static void |
| [1004](#l1004) | save\_environment(int argc, char \*const \*argv) |
| [1005](#l1005) | { |
| [1006](#l1006) | char command[MAXFILLEN]; |
| [1007](#l1007) | STRBUF \*sb = strbuf\_open(0); |
| [1008](#l1008) | STRBUF \*save\_c = strbuf\_open(0); |
| [1009](#l1009) | STRBUF \*save\_a = strbuf\_open(0); |
| [1010](#l1010) | int i; |
| [1011](#l1011) | const char \*p; |
| [1012](#l1012) | FILE \*ip; |
| [1013](#l1013) |  |
| [1014](#l1014) | /\* |
| [1015](#l1015) | \* save config values. |
| [1016](#l1016) | \*/ |
| [1017](#l1017) | snprintf(command, sizeof(command), PQUOTE "%s --config" PQUOTE, quote\_shell(gtags\_path)); |
| [1018](#l1018) | if ((ip = popen(command, "r")) == NULL) |
| [1019](#l1019) | die("cannot execute '%s'.", command); |
| [1020](#l1020) | while (strbuf\_fgets(sb, ip, STRBUF\_NOCRLF) != NULL) { |
| [1021](#l1021) | for (p = strbuf\_value(sb); \*p; p++) { |
| [1022](#l1022) | if (\*p == '\'') { |
| [1023](#l1023) | strbuf\_putc(save\_c, '\''); |
| [1024](#l1024) | strbuf\_putc(save\_c, '"'); |
| [1025](#l1025) | strbuf\_putc(save\_c, '\''); |
| [1026](#l1026) | strbuf\_putc(save\_c, '"'); |
| [1027](#l1027) | strbuf\_putc(save\_c, '\''); |
| [1028](#l1028) | } else |
| [1029](#l1029) | strbuf\_putc(save\_c, \*p); |
| [1030](#l1030) | } |
| [1031](#l1031) | } |
| [1032](#l1032) | if (pclose(ip) != 0) |
| [1033](#l1033) | die("terminated abnormally '%s' (errno = %d).", command, errno); |
| [1034](#l1034) | strbuf\_close(sb); |
| [1035](#l1035) | save\_config = strbuf\_value(save\_c); |
| [1036](#l1036) | /\* doesn't close string buffer for save config. \*/ |
| [1037](#l1037) | /\* strbuf\_close(save\_c); \*/ |
| [1038](#l1038) |  |
| [1039](#l1039) | /\* |
| [1040](#l1040) | \* save arguments. |
| [1041](#l1041) | \*/ |
| [1042](#l1042) | { |
| [1043](#l1043) | char \*opt\_gtagsconf = "--gtagsconf"; |
| [1044](#l1044) |  |
| [1045](#l1045) | for (i = 1; i < argc; i++) { |
| [1046](#l1046) | char \*blank; |
| [1047](#l1047) |  |
| [1048](#l1048) | /\* |
| [1049](#l1049) | \* skip --gtagsconf because it is already read |
| [1050](#l1050) | \* as config value. |
| [1051](#l1051) | \*/ |
| [1052](#l1052) | if ((p = locatestring(argv[i], opt\_gtagsconf, MATCH\_AT\_FIRST))) { |
| [1053](#l1053) | if (\*p == '\0') |
| [1054](#l1054) | i++; |
| [1055](#l1055) | continue; |
| [1056](#l1056) | } |
| [1057](#l1057) | blank = locatestring(argv[i], " ", MATCH\_FIRST); |
| [1058](#l1058) | strbuf\_putc(save\_a, ' '); |
| [1059](#l1059) | if (blank) |
| [1060](#l1060) | strbuf\_putc(save\_a, '\''); |
| [1061](#l1061) | strbuf\_puts(save\_a, argv[i]); |
| [1062](#l1062) | if (blank) |
| [1063](#l1063) | strbuf\_putc(save\_a, '\''); |
| [1064](#l1064) | } |
| [1065](#l1065) | } |
| [1066](#l1066) | save\_argv = strbuf\_value(save\_a); |
| [1067](#l1067) | /\* doesn't close string buffer for save arguments. \*/ |
| [1068](#l1068) | /\* strbuf\_close(save\_a); \*/ |
| [1069](#l1069) | } |
| [1070](#l1070) |  |
| [1071](#l1071) | int |
| [1072](#l1072) | main(int argc, char \*\*argv) |
| [1073](#l1073) | { |
| [1074](#l1074) | const char \*av = NULL; |
| [1075](#l1075) | int func\_total, file\_total; |
| [1076](#l1076) | char arg\_dbpath[MAXPATHLEN]; |
| [1077](#l1077) | const char \*index = NULL; |
| [1078](#l1078) | int optchar; |
| [1079](#l1079) | int option\_index = 0; |
| [1080](#l1080) | STATISTICS\_TIME \*tim; |
| [1081](#l1081) |  |
| [1082](#l1082) | /\* |
| [1083](#l1083) | \* pick up --gtagsconf, --gtagslabel and --directory (-C). |
| [1084](#l1084) | \*/ |
| [1085](#l1085) | if (preparse\_options(argc, argv) < 0) |
| [1086](#l1086) | usage(); |
| [1087](#l1087) |  |
| [1088](#l1088) | arg\_dbpath[0] = 0; |
| [1089](#l1089) | basic\_check(); |
| [1090](#l1090) | /\* |
| [1091](#l1091) | \* Load configuration values. |
| [1092](#l1092) | \*/ |
| [1093](#l1093) | if (!vgetcwd(cwdpath, sizeof(cwdpath))) |
| [1094](#l1094) | die("cannot get current directory."); |
| [1095](#l1095) | openconf(cwdpath); |
| [1096](#l1096) | configuration(); |
| [1097](#l1097) | /\* |
| [1098](#l1098) | \* setup\_langmap() is needed to use decide\_lang(). |
| [1099](#l1099) | \*/ |
| [1100](#l1100) | setup\_langmap(langmap); |
| [1101](#l1101) | save\_environment(argc, argv); |
| [1102](#l1102) | /\* |
| [1103](#l1103) | \* insert htags\_options at the head of argv. |
| [1104](#l1104) | \*/ |
| [1105](#l1105) | setenv\_from\_config(); |
| [1106](#l1106) | { |
| [1107](#l1107) | char \*env = getenv("HTAGS\_OPTIONS"); |
| [1108](#l1108) | if (env && \*env) |
| [1109](#l1109) | argv = prepend\_options(&argc, argv, env); |
| [1110](#l1110) | } |
| [1111](#l1111) | while ((optchar = getopt\_long(argc, argv, short\_options, long\_options, &option\_index)) != EOF) { |
| [1112](#l1112) | switch (optchar) { |
| [1113](#l1113) | case 0: |
| [1114](#l1114) | /\* already flags set \*/ |
| [1115](#l1115) | break; |
| [1116](#l1116) | case OPT\_AUTO\_COMPLETION: |
| [1117](#l1117) | auto\_completion = 1; |
| [1118](#l1118) | if (optarg) { |
| [1119](#l1119) | if (atoi(optarg) > 0) |
| [1120](#l1120) | auto\_completion\_limit = optarg; |
| [1121](#l1121) | else |
| [1122](#l1122) | die("The option value of --auto-completion must be numeric."); |
| [1123](#l1123) | } |
| [1124](#l1124) | break; |
| [1125](#l1125) | case OPT\_CFLOW: |
| [1126](#l1126) | call\_file = optarg; |
| [1127](#l1127) | break; |
| [1128](#l1128) | case OPT\_CALL\_TREE: |
| [1129](#l1129) | call\_file = optarg; |
| [1130](#l1130) | break; |
| [1131](#l1131) | case OPT\_CALLEE\_TREE: |
| [1132](#l1132) | callee\_file = optarg; |
| [1133](#l1133) | break; |
| [1134](#l1134) | case OPT\_CVSWEB: |
| [1135](#l1135) | cvsweb\_url = optarg; |
| [1136](#l1136) | break; |
| [1137](#l1137) | case OPT\_CVSWEB\_CVSROOT: |
| [1138](#l1138) | cvsweb\_cvsroot = optarg; |
| [1139](#l1139) | break; |
| [1140](#l1140) | case OPT\_GTAGSCONF: |
| [1141](#l1141) | case OPT\_GTAGSLABEL: |
| [1142](#l1142) | case 'C': |
| [1143](#l1143) | /\* These options are already parsed in preparse\_options(). \*/ |
| [1144](#l1144) | break; |
| [1145](#l1145) | case OPT\_INSERT\_FOOTER: |
| [1146](#l1146) | insert\_footer = optarg; |
| [1147](#l1147) | break; |
| [1148](#l1148) | case OPT\_INSERT\_HEADER: |
| [1149](#l1149) | insert\_header = optarg; |
| [1150](#l1150) | break; |
| [1151](#l1151) | case OPT\_HTML\_HEADER: |
| [1152](#l1152) | { |
| [1153](#l1153) | STATIC\_STRBUF(sb); |
| [1154](#l1154) | if (!test("r", optarg)) |
| [1155](#l1155) | die("file '%s' not found.", optarg); |
| [1156](#l1156) | strbuf\_clear(sb); |
| [1157](#l1157) | loadfile(optarg, sb); |
| [1158](#l1158) | html\_header = strbuf\_value(sb); |
| [1159](#l1159) | } |
| [1160](#l1160) | break; |
| [1161](#l1161) | case OPT\_ITEM\_ORDER: |
| [1162](#l1162) | item\_order = optarg; |
| [1163](#l1163) | break; |
| [1164](#l1164) | case OPT\_TABS: |
| [1165](#l1165) | if (atoi(optarg) > 0) |
| [1166](#l1166) | tabs = atoi(optarg); |
| [1167](#l1167) | else |
| [1168](#l1168) | die("--tabs option requires numeric value."); |
| [1169](#l1169) | break; |
| [1170](#l1170) | case OPT\_NCOL: |
| [1171](#l1171) | if (atoi(optarg) > 0) |
| [1172](#l1172) | ncol = atoi(optarg); |
| [1173](#l1173) | else |
| [1174](#l1174) | die("--ncol option requires numeric value."); |
| [1175](#l1175) | break; |
| [1176](#l1176) | case OPT\_TREE\_VIEW: |
| [1177](#l1177) | tree\_view = 1; |
| [1178](#l1178) | if (optarg) |
| [1179](#l1179) | tree\_view\_type = optarg; |
| [1180](#l1180) | break; |
| [1181](#l1181) | case 'a': |
| [1182](#l1182) | aflag++; |
| [1183](#l1183) | break; |
| [1184](#l1184) | case 'd': |
| [1185](#l1185) | strlimcpy(arg\_dbpath, optarg, sizeof(arg\_dbpath)); |
| [1186](#l1186) | break; |
| [1187](#l1187) | case 'D': |
| [1188](#l1188) | dynamic = 1; |
| [1189](#l1189) | break; |
| [1190](#l1190) | case 'f': |
| [1191](#l1191) | fflag++; |
| [1192](#l1192) | break; |
| [1193](#l1193) | case 'F': |
| [1194](#l1194) | Fflag++; |
| [1195](#l1195) | break; |
| [1196](#l1196) | case 'g': |
| [1197](#l1197) | gflag++; |
| [1198](#l1198) | break; |
| [1199](#l1199) | case 'h': |
| [1200](#l1200) | definition\_header = AFTER\_HEADER; |
| [1201](#l1201) | if (optarg) { |
| [1202](#l1202) | if (!strcmp(optarg, "before")) |
| [1203](#l1203) | definition\_header = BEFORE\_HEADER; |
| [1204](#l1204) | else if (!strcmp(optarg, "right")) |
| [1205](#l1205) | definition\_header = RIGHT\_HEADER; |
| [1206](#l1206) | else if (!strcmp(optarg, "after")) |
| [1207](#l1207) | definition\_header = AFTER\_HEADER; |
| [1208](#l1208) | else |
| [1209](#l1209) | die("The option value of --func-header must be one of 'before', 'right' and 'after'."); |
| [1210](#l1210) | } |
| [1211](#l1211) | break; |
| [1212](#l1212) | case 'I': |
| [1213](#l1213) | Iflag++; |
| [1214](#l1214) | break; |
| [1215](#l1215) | case 'm': |
| [1216](#l1216) | main\_func = optarg; |
| [1217](#l1217) | break; |
| [1218](#l1218) | case 'n': |
| [1219](#l1219) | nflag++; |
| [1220](#l1220) | if (optarg) { |
| [1221](#l1221) | if (atoi(optarg) > 0) |
| [1222](#l1222) | ncol = atoi(optarg); |
| [1223](#l1223) | else |
| [1224](#l1224) | die("The option value of --line-number must be numeric."); |
| [1225](#l1225) | } |
| [1226](#l1226) | break; |
| [1227](#l1227) | case 'o': |
| [1228](#l1228) | other\_files = 1; |
| [1229](#l1229) | break; |
| [1230](#l1230) | case 's': |
| [1231](#l1231) | symbol = 1; |
| [1232](#l1232) | break; |
| [1233](#l1233) | case 'T': |
| [1234](#l1234) | table\_flist = 1; |
| [1235](#l1235) | if (optarg) { |
| [1236](#l1236) | if (atoi(optarg) > 0) |
| [1237](#l1237) | flist\_fields = atoi(optarg); |
| [1238](#l1238) | else |
| [1239](#l1239) | die("The option value of the --table-flist must be numeric."); |
| [1240](#l1240) | } |
| [1241](#l1241) | break; |
| [1242](#l1242) | case 't': |
| [1243](#l1243) | title = optarg; |
| [1244](#l1244) | break; |
| [1245](#l1245) | case 'q': |
| [1246](#l1246) | qflag++; |
| [1247](#l1247) | break; |
| [1248](#l1248) | case 'v': |
| [1249](#l1249) | vflag++; |
| [1250](#l1250) | break; |
| [1251](#l1251) | case 'w': |
| [1252](#l1252) | wflag++; |
| [1253](#l1253) | break; |
| [1254](#l1254) | default: |
| [1255](#l1255) | usage(); |
| [1256](#l1256) | break; |
| [1257](#l1257) | } |
| [1258](#l1258) | } |
| [1259](#l1259) | if (qflag) { |
| [1260](#l1260) | vflag = 0; |
| [1261](#l1261) | setquiet(); |
| [1262](#l1262) | } |
| [1263](#l1263) | if (vflag) |
| [1264](#l1264) | setverbose(); |
| [1265](#l1265) | /\* |
| [1266](#l1266) | \* Leaving everything to htags. |
| [1267](#l1267) | \* Htags selects popular options for you. |
| [1268](#l1268) | \*/ |
| [1269](#l1269) | if (suggest2) |
| [1270](#l1270) | suggest = 1; |
| [1271](#l1271) | if (suggest) { |
| [1272](#l1272) | int gtags\_not\_found = 0; |
| [1273](#l1273) | char dbpath[MAXPATHLEN]; |
| [1274](#l1274) |  |
| [1275](#l1275) | aflag = Iflag = nflag = vflag = 1; |
| [1276](#l1276) | setverbose(); |
| [1277](#l1277) | definition\_header = AFTER\_HEADER; |
| [1278](#l1278) | other\_files = symbol = show\_position = table\_flist = fixed\_guide = 1; |
| [1279](#l1279) | if (arg\_dbpath[0]) { |
| [1280](#l1280) | if (!test("f", makepath(arg\_dbpath, dbname(GTAGS), NULL))) |
| [1281](#l1281) | gtags\_not\_found = 1; |
| [1282](#l1282) | } else if (gtagsexist(".", dbpath, sizeof(dbpath), 0) == 0) { |
| [1283](#l1283) | gtags\_not\_found = 1; |
| [1284](#l1284) | } |
| [1285](#l1285) | if (gtags\_not\_found) |
| [1286](#l1286) | gflag = 1; |
| [1287](#l1287) | } |
| [1288](#l1288) | if (suggest2) { |
| [1289](#l1289) | Fflag = 1; /\* uses frame \*/ |
| [1290](#l1290) | fflag = dynamic = 1; /\* needs a HTTP server \*/ |
| [1291](#l1291) | auto\_completion = tree\_view = 1; /\* needs javascript \*/ |
| [1292](#l1292) | } |
| [1293](#l1293) | if (call\_file && !test("fr", call\_file)) |
| [1294](#l1294) | die("cflow file not found. '%s'", call\_file); |
| [1295](#l1295) | if (callee\_file && !test("fr", callee\_file)) |
| [1296](#l1296) | die("cflow file not found. '%s'", callee\_file); |
| [1297](#l1297) | if (insert\_header && !test("fr", insert\_header)) |
| [1298](#l1298) | die("page header file '%s' not found.", insert\_header); |
| [1299](#l1299) | if (insert\_footer && !test("fr", insert\_footer)) |
| [1300](#l1300) | die("page footer file '%s' not found.", insert\_footer); |
| [1301](#l1301) | if (!fflag) |
| [1302](#l1302) | auto\_completion = 0; |
| [1303](#l1303) | argc -= optind; |
| [1304](#l1304) | argv += optind; |
| [1305](#l1305) | if (!av) |
| [1306](#l1306) | av = (argc > 0) ? \*argv : NULL; |
| [1307](#l1307) |  |
| [1308](#l1308) | if (debug) |
| [1309](#l1309) | setdebug(); |
| [1310](#l1310) | settabs(tabs); /\* setup tab skip \*/ |
| [1311](#l1311) | if (qflag) { |
| [1312](#l1312) | setquiet(); |
| [1313](#l1313) | vflag = 0; |
| [1314](#l1314) | } |
| [1315](#l1315) | if (show\_version) |
| [1316](#l1316) | version(av, vflag); |
| [1317](#l1317) | if (show\_help) |
| [1318](#l1318) | help(); |
| [1319](#l1319) | /\* |
| [1320](#l1320) | \* Invokes gtags beforehand. |
| [1321](#l1321) | \*/ |
| [1322](#l1322) | if (gflag) { |
| [1323](#l1323) | STRBUF \*sb = strbuf\_open(0); |
| [1324](#l1324) |  |
| [1325](#l1325) | strbuf\_puts(sb, gtags\_path); |
| [1326](#l1326) | if (vflag) |
| [1327](#l1327) | strbuf\_puts(sb, " -v"); |
| [1328](#l1328) | if (wflag) |
| [1329](#l1329) | strbuf\_puts(sb, " -w"); |
| [1330](#l1330) | /\* |
| [1331](#l1331) | \* Please see the release note of global-6.6.4. |
| [1332](#l1332) | if (suggest2 && enable\_idutils && usable("mkid")) |
| [1333](#l1333) | strbuf\_puts(sb, " -I"); |
| [1334](#l1334) | \*/ |
| [1335](#l1335) | if (arg\_dbpath[0]) { |
| [1336](#l1336) | strbuf\_putc(sb, ' '); |
| [1337](#l1337) | strbuf\_puts(sb, quote\_shell(arg\_dbpath)); |
| [1338](#l1338) | } |
| [1339](#l1339) | if (system(strbuf\_value(sb))) |
| [1340](#l1340) | die("cannot execute gtags(1) command."); |
| [1341](#l1341) | strbuf\_close(sb); |
| [1342](#l1342) | } |
| [1343](#l1343) | /\* |
| [1344](#l1344) | \* get dbpath. |
| [1345](#l1345) | \*/ |
| [1346](#l1346) | if (arg\_dbpath[0]) { |
| [1347](#l1347) | strlimcpy(dbpath, arg\_dbpath, sizeof(dbpath)); |
| [1348](#l1348) | } else { |
| [1349](#l1349) | int status = setupdbpath(0); |
| [1350](#l1350) | if (status < 0) |
| [1351](#l1351) | die\_with\_code(-status, "%s", gtags\_dbpath\_error); |
| [1352](#l1352) | strlimcpy(dbpath, get\_dbpath(), sizeof(dbpath)); |
| [1353](#l1353) | } |
| [1354](#l1354) | if (!title) { |
| [1355](#l1355) | char \*p = strrchr(cwdpath, sep); |
| [1356](#l1356) | title = p ? p + 1 : cwdpath; |
| [1357](#l1357) | } |
| [1358](#l1358) | if (cvsweb\_url && test("d", "CVS")) |
| [1359](#l1359) | use\_cvs\_module = 1; |
| [1360](#l1360) | /\* |
| [1361](#l1361) | \* decide directory in which we make hypertext. |
| [1362](#l1362) | \*/ |
| [1363](#l1363) | if (av) { |
| [1364](#l1364) | char realpath[MAXPATHLEN]; |
| [1365](#l1365) |  |
| [1366](#l1366) | if (!test("dw", av)) |
| [1367](#l1367) | die("'%s' is not writable directory.", av); |
| [1368](#l1368) | if (chdir(av) < 0) |
| [1369](#l1369) | die("directory '%s' not found.", av); |
| [1370](#l1370) | if (!vgetcwd(realpath, sizeof(realpath))) |
| [1371](#l1371) | die("cannot get current directory"); |
| [1372](#l1372) | if (chdir(cwdpath) < 0) |
| [1373](#l1373) | die("cannot return to original directory."); |
| [1374](#l1374) | snprintf(distpath, sizeof(distpath), "%s/HTML", realpath); |
| [1375](#l1375) | } else { |
| [1376](#l1376) | snprintf(distpath, sizeof(distpath), "%s/HTML", cwdpath); |
| [1377](#l1377) | } |
| [1378](#l1378) | /\* |
| [1379](#l1379) | \* Existence check of tag files. |
| [1380](#l1380) | \*/ |
| [1381](#l1381) | { |
| [1382](#l1382) | int i; |
| [1383](#l1383) | const char \*path; |
| [1384](#l1384) | GTOP \*gtop; |
| [1385](#l1385) |  |
| [1386](#l1386) | for (i = GPATH; i < GTAGLIM; i++) { |
| [1387](#l1387) | path = makepath(dbpath, dbname(i), NULL); |
| [1388](#l1388) | gtags\_exist[i] = test("fr", path); |
| [1389](#l1389) | } |
| [1390](#l1390) | /\* |
| [1391](#l1391) | \* Real GRTAGS includes virtual GSYMS. |
| [1392](#l1392) | \*/ |
| [1393](#l1393) | gtags\_exist[GSYMS] = symbol ? 1 : 0; |
| [1394](#l1394) | if (!gtags\_exist[GPATH] || !gtags\_exist[GTAGS] || !gtags\_exist[GRTAGS]) |
| [1395](#l1395) | die("GPATH, GTAGS and/or GRTAGS not found. Please reexecute htags with the -g option."); |
| [1396](#l1396) | /\* |
| [1397](#l1397) | \* version check. |
| [1398](#l1398) | \* Do nothing, but the version of tag file will be checked. |
| [1399](#l1399) | \*/ |
| [1400](#l1400) | gtop = gtags\_open(dbpath, cwdpath, GTAGS, GTAGS\_READ, 0); |
| [1401](#l1401) | gtags\_close(gtop); |
| [1402](#l1402) | /\* |
| [1403](#l1403) | \* Check whether GRTAGS is empty. |
| [1404](#l1404) | \*/ |
| [1405](#l1405) | gtop = gtags\_open(dbpath, cwdpath, GRTAGS, GTAGS\_READ, 0); |
| [1406](#l1406) | if (gtags\_first(gtop, NULL, 0) == NULL) |
| [1407](#l1407) | grtags\_is\_empty = 1; |
| [1408](#l1408) | gtags\_close(gtop); |
| [1409](#l1409) | } |
| [1410](#l1410) | /\* |
| [1411](#l1411) | \* make dbpath absolute. |
| [1412](#l1412) | \*/ |
| [1413](#l1413) | { |
| [1414](#l1414) | char buf[MAXPATHLEN]; |
| [1415](#l1415) | if (realpath(dbpath, buf) == NULL) |
| [1416](#l1416) | die("cannot get realpath of dbpath."); |
| [1417](#l1417) | strlimcpy(dbpath, buf, sizeof(dbpath)); |
| [1418](#l1418) | } |
| [1419](#l1419) | /\* |
| [1420](#l1420) | \* The older version (4.8.7 or former) of GPATH doesn't have files |
| [1421](#l1421) | \* other than source file. The oflag requires new version of GPATH. |
| [1422](#l1422) | \*/ |
| [1423](#l1423) | if (other\_files) { |
| [1424](#l1424) | GFIND \*gp = gfind\_open(dbpath, NULL, 0, 0); |
| [1425](#l1425) | if (gp->version < 2) |
| [1426](#l1426) | die("GPATH is old format. Please remake it by invoking gtags(1)."); |
| [1427](#l1427) | gfind\_close(gp); |
| [1428](#l1428) | } |
| [1429](#l1429) | /\* |
| [1430](#l1430) | \* for global(1) and gtags(1). |
| [1431](#l1431) | \*/ |
| [1432](#l1432) | set\_env("GTAGSROOT", cwdpath); |
| [1433](#l1433) | set\_env("GTAGSDBPATH", dbpath); |
| [1434](#l1434) | set\_env("GTAGSLIBPATH", ""); |
| [1435](#l1435) | /\*------------------------------------------------------------------ |
| [1436](#l1436) | \* MAKE FILES |
| [1437](#l1437) | \*------------------------------------------------------------------ |
| [1438](#l1438) | \* HTML/cgi-bin/global.cgi ... CGI program (1) |
| [1439](#l1439) | \* HTML/cgi-bin/ghtml.cgi ... unzip script (1) |
| [1440](#l1440) | \* HTML/.htaccess ... skeleton of .htaccess (1) |
| [1441](#l1441) | \* HTML/help.html ... help file (2) |
| [1442](#l1442) | \* HTML/R/ ... references (3) |
| [1443](#l1443) | \* HTML/D/ ... definitions (3) |
| [1444](#l1444) | \* HTML/search.html ... search index (4) |
| [1445](#l1445) | \* HTML/defines.html ... definitions index (5) |
| [1446](#l1446) | \* HTML/defines/ ... definitions index (5) |
| [1447](#l1447) | \* HTML/files/ ... file index (6) |
| [1448](#l1448) | \* HTML/index.html ... index file (7) |
| [1449](#l1449) | \* HTML/mains.html ... main index (8) |
| [1450](#l1450) | \* HTML/null.html ... main null html (8) |
| [1451](#l1451) | \* HTML/S/ ... source files (9) |
| [1452](#l1452) | \* HTML/I/ ... include file index (9) |
| [1453](#l1453) | \* HTML/rebuild.sh ... rebuild script (10) |
| [1454](#l1454) | \* HTML/style.css ... style sheet (11) |
| [1455](#l1455) | \*------------------------------------------------------------------ |
| [1456](#l1456) | \*/ |
| [1457](#l1457) | /\* for clean up \*/ |
| [1458](#l1458) | signal\_setup(); |
| [1459](#l1459) | sethandler(clean); |
| [1460](#l1460) |  |
| [1461](#l1461) | HTML = normal\_suffix; |
| [1462](#l1462) |  |
| [1463](#l1463) | message("[%s] Htags started", now()); |
| [1464](#l1464) | init\_statistics(); |
| [1465](#l1465) | /\* |
| [1466](#l1466) | \* (#) check if GTAGS, GRTAGS is the latest. |
| [1467](#l1467) | \*/ |
| [1468](#l1468) | if (get\_dbpath()) |
| [1469](#l1469) | message(" Using %s/GTAGS.", get\_dbpath()); |
| [1470](#l1470) | if (grtags\_is\_empty) |
| [1471](#l1471) | message(" GRTAGS is empty."); |
| [1472](#l1472) | if (gpath\_open(dbpath, 0) < 0) |
| [1473](#l1473) | die("GPATH not found."); |
| [1474](#l1474) | if (!w32) { |
| [1475](#l1475) | /\* UNDER CONSTRUCTION \*/ |
| [1476](#l1476) | } |
| [1477](#l1477) | if (auto\_completion || tree\_view) { |
| [1478](#l1478) | STATIC\_STRBUF(sb); |
| [1479](#l1479) | strbuf\_clear(sb); |
| [1480](#l1480) | strbuf\_puts\_nl(sb, "<script type='text/javascript' src='js/jquery.js'></script>"); |
| [1481](#l1481) | if (auto\_completion) |
| [1482](#l1482) | loadfile(makepath(datadir, "gtags/jscode\_suggest", NULL), sb); |
| [1483](#l1483) | if (tree\_view) |
| [1484](#l1484) | loadfile(makepath(datadir, "gtags/jscode\_treeview", NULL), sb); |
| [1485](#l1485) | jscode = strbuf\_value(sb); |
| [1486](#l1486) | } |
| [1487](#l1487) | /\* |
| [1488](#l1488) | \* (0) make directories |
| [1489](#l1489) | \*/ |
| [1490](#l1490) | message("[%s] (0) making directories ...", now()); |
| [1491](#l1491) | if (!test("d", distpath)) |
| [1492](#l1492) | if (mkdir(distpath, 0777) < 0) |
| [1493](#l1493) | die("cannot make directory '%s'.", distpath); |
| [1494](#l1494) | make\_directory\_in\_distpath("files"); |
| [1495](#l1495) | make\_directory\_in\_distpath("defines"); |
| [1496](#l1496) | make\_directory\_in\_distpath(SRCS); |
| [1497](#l1497) | make\_directory\_in\_distpath(INCS); |
| [1498](#l1498) | make\_directory\_in\_distpath(INCREFS); |
| [1499](#l1499) | if (!dynamic) { |
| [1500](#l1500) | make\_directory\_in\_distpath(DEFS); |
| [1501](#l1501) | make\_directory\_in\_distpath(REFS); |
| [1502](#l1502) | if (symbol) |
| [1503](#l1503) | make\_directory\_in\_distpath(SYMS); |
| [1504](#l1504) | } |
| [1505](#l1505) | if (fflag || dynamic) |
| [1506](#l1506) | make\_directory\_in\_distpath("cgi-bin"); |
| [1507](#l1507) | if (Iflag) |
| [1508](#l1508) | make\_directory\_in\_distpath("icons"); |
| [1509](#l1509) | if (auto\_completion || tree\_view) |
| [1510](#l1510) | make\_directory\_in\_distpath("js"); |
| [1511](#l1511) | /\* |
| [1512](#l1512) | \* (1) make CGI program |
| [1513](#l1513) | \*/ |
| [1514](#l1514) | if (fflag || dynamic) { |
| [1515](#l1515) | char cgidir[MAXPATHLEN]; |
| [1516](#l1516) |  |
| [1517](#l1517) | snprintf(cgidir, sizeof(cgidir), "%s/cgi-bin", distpath); |
| [1518](#l1518) | message("[%s] (1) making CGI program ...", now()); |
| [1519](#l1519) | if (fflag || dynamic) |
| [1520](#l1520) | makeprogram(cgidir, "global.cgi", 0755); |
| [1521](#l1521) | if (auto\_completion) |
| [1522](#l1522) | makeprogram(cgidir, "completion.cgi", 0755); |
| [1523](#l1523) | makehtaccess(".htaccess", 0644); |
| [1524](#l1524) | } else { |
| [1525](#l1525) | message("[%s] (1) making CGI program ...(skipped)", now()); |
| [1526](#l1526) | } |
| [1527](#l1527) | if (av) { |
| [1528](#l1528) | const char \*path = makepath(distpath, "GTAGSROOT", NULL); |
| [1529](#l1529) | FILE \*op = fopen(path, "w"); |
| [1530](#l1530) | if (op == NULL) |
| [1531](#l1531) | die("cannot make file '%s'.", path); |
| [1532](#l1532) | fputs(cwdpath, op); |
| [1533](#l1533) | fputc('\n', op); |
| [1534](#l1534) | fclose(op); |
| [1535](#l1535) | } |
| [1536](#l1536) | /\* |
| [1537](#l1537) | \* (2) make help file |
| [1538](#l1538) | \*/ |
| [1539](#l1539) | message("[%s] (2) making help.html ...", now()); |
| [1540](#l1540) | makehelp("help.html"); |
| [1541](#l1541) | /\* |
| [1542](#l1542) | \* (#) load GPATH |
| [1543](#l1543) | \*/ |
| [1544](#l1544) | load\_gpath(dbpath); |
| [1545](#l1545) |  |
| [1546](#l1546) | /\* |
| [1547](#l1547) | \* (3) make function entries (D/ and R/) |
| [1548](#l1548) | \* MAKING TAG CACHE |
| [1549](#l1549) | \*/ |
| [1550](#l1550) | message("[%s] (3) making tag lists ...", now()); |
| [1551](#l1551) | cache\_open(); |
| [1552](#l1552) | tim = statistics\_time\_start("Time of making tag lists"); |
| [1553](#l1553) | func\_total = makedupindex(); |
| [1554](#l1554) | statistics\_time\_end(tim); |
| [1555](#l1555) | message("Total %d functions.", func\_total); |
| [1556](#l1556) | /\* |
| [1557](#l1557) | \* (4) search index. (search.html) |
| [1558](#l1558) | \*/ |
| [1559](#l1559) | if (Fflag && fflag) { |
| [1560](#l1560) | message("[%s] (4) making search index ...", now()); |
| [1561](#l1561) | makesearchindex("search.html"); |
| [1562](#l1562) | } |
| [1563](#l1563) | { |
| [1564](#l1564) | STRBUF \*defines = strbuf\_open(0); |
| [1565](#l1565) | STRBUF \*files = strbuf\_open(0); |
| [1566](#l1566) |  |
| [1567](#l1567) | /\* |
| [1568](#l1568) | \* (5) make definition index (defines.html and defines/) |
| [1569](#l1569) | \* PRODUCE @defines |
| [1570](#l1570) | \*/ |
| [1571](#l1571) | message("[%s] (5) making definition index ...", now()); |
| [1572](#l1572) | tim = statistics\_time\_start("Time of making definition index"); |
| [1573](#l1573) | func\_total = makedefineindex("defines.html", func\_total, defines); |
| [1574](#l1574) | statistics\_time\_end(tim); |
| [1575](#l1575) | message("Total %d functions.", func\_total); |
| [1576](#l1576) | /\* |
| [1577](#l1577) | \* (6) make file index (files.html and files/) |
| [1578](#l1578) | \* PRODUCE @files, %includes |
| [1579](#l1579) | \*/ |
| [1580](#l1580) | message("[%s] (6) making file index ...", now()); |
| [1581](#l1581) | init\_inc(); |
| [1582](#l1582) | tim = statistics\_time\_start("Time of making file index"); |
| [1583](#l1583) | file\_total = makefileindex("files.html", files); |
| [1584](#l1584) | statistics\_time\_end(tim); |
| [1585](#l1585) | message("Total %d files.", file\_total); |
| [1586](#l1586) | html\_count += file\_total; |
| [1587](#l1587) | /\* |
| [1588](#l1588) | \* (7) make call tree using cflow(1)'s output (cflow.html) |
| [1589](#l1589) | \*/ |
| [1590](#l1590) | if (call\_file || callee\_file) { |
| [1591](#l1591) | message("[%s] (7) making cflow index ...", now()); |
| [1592](#l1592) | tim = statistics\_time\_start("Time of making cflow index"); |
| [1593](#l1593) | if (call\_file) |
| [1594](#l1594) | if (makecflowindex("call.html", call\_file) < 0) |
| [1595](#l1595) | call\_file = NULL; |
| [1596](#l1596) | if (callee\_file) |
| [1597](#l1597) | if (makecflowindex("callee.html", callee\_file) < 0) |
| [1598](#l1598) | callee\_file = NULL; |
| [1599](#l1599) | statistics\_time\_end(tim); |
| [1600](#l1600) | } |
| [1601](#l1601) | /\* |
| [1602](#l1602) | \* [#] make include file index. |
| [1603](#l1603) | \*/ |
| [1604](#l1604) | message("[%s] (#) making include file index ...", now()); |
| [1605](#l1605) | tim = statistics\_time\_start("Time of making include file index"); |
| [1606](#l1606) | makeincludeindex(); |
| [1607](#l1607) | statistics\_time\_end(tim); |
| [1608](#l1608) | /\* |
| [1609](#l1609) | \* [#] make a common part for mains.html and index.html |
| [1610](#l1610) | \* USING @defines @files |
| [1611](#l1611) | \*/ |
| [1612](#l1612) | message("[%s] (#) making a common part ...", now()); |
| [1613](#l1613) | index = makecommonpart(title, strbuf\_value(defines), strbuf\_value(files)); |
| [1614](#l1614) |  |
| [1615](#l1615) | strbuf\_close(defines); |
| [1616](#l1616) | strbuf\_close(files); |
| [1617](#l1617) | } |
| [1618](#l1618) | /\* |
| [1619](#l1619) | \* (7)make index file (index.html) |
| [1620](#l1620) | \*/ |
| [1621](#l1621) | message("[%s] (7) making index file ...", now()); |
| [1622](#l1622) | makeindex("index.html", title, index); |
| [1623](#l1623) | /\* |
| [1624](#l1624) | \* (8) make main index (mains.html) |
| [1625](#l1625) | \*/ |
| [1626](#l1626) | message("[%s] (8) making main index ...", now()); |
| [1627](#l1627) | makemainindex("mains.html", index); |
| [1628](#l1628) | /\* |
| [1629](#l1629) | \* (9) make HTML files (SRCS/) |
| [1630](#l1630) | \* USING TAG CACHE, %includes and anchor database. |
| [1631](#l1631) | \*/ |
| [1632](#l1632) | message("[%s] (9) making hypertext from source code ...", now()); |
| [1633](#l1633) | tim = statistics\_time\_start("Time of making hypertext"); |
| [1634](#l1634) | makehtml(file\_total); |
| [1635](#l1635) | statistics\_time\_end(tim); |
| [1636](#l1636) | /\* |
| [1637](#l1637) | \* (10) rebuild script. (rebuild.sh) |
| [1638](#l1638) | \* |
| [1639](#l1639) | \* Don't grant execute permission to rebuild script. |
| [1640](#l1640) | \*/ |
| [1641](#l1641) | makerebuild("rebuild.sh"); |
| [1642](#l1642) | if (chmod(makepath(distpath, "rebuild.sh", NULL), 0640) < 0) |
| [1643](#l1643) | die("cannot chmod rebuild script."); |
| [1644](#l1644) | /\* |
| [1645](#l1645) | \* (11) style sheet file (style.css) |
| [1646](#l1646) | \*/ |
| [1647](#l1647) | if (enable\_xhtml) { |
| [1648](#l1648) | char src[MAXPATHLEN]; |
| [1649](#l1649) | char dist[MAXPATHLEN]; |
| [1650](#l1650) | snprintf(src, sizeof(src), "%s/gtags/style.css", datadir); |
| [1651](#l1651) | snprintf(dist, sizeof(dist), "%s/style.css", distpath); |
| [1652](#l1652) | copyfile(src, dist); |
| [1653](#l1653) | } |
| [1654](#l1654) | if (auto\_completion || tree\_view) { |
| [1655](#l1655) | char src[MAXPATHLEN]; |
| [1656](#l1656) | char dist[MAXPATHLEN]; |
| [1657](#l1657) |  |
| [1658](#l1658) | snprintf(src, sizeof(src), "%s/gtags/jquery", datadir); |
| [1659](#l1659) | snprintf(dist, sizeof(dist), "%s/js", distpath); |
| [1660](#l1660) | copydirectory(src, dist); |
| [1661](#l1661) | snprintf(src, sizeof(src), "%s/gtags/jquery/images", datadir); |
| [1662](#l1662) | snprintf(dist, sizeof(dist), "%s/js/images", distpath); |
| [1663](#l1663) | copydirectory(src, dist); |
| [1664](#l1664) | } |
| [1665](#l1665) | message("[%s] Done.", now()); |
| [1666](#l1666) | if (vflag && (fflag || dynamic || auto\_completion)) { |
| [1667](#l1667) | message("\n[Information]\n"); |
| [1668](#l1668) | message(" o Htags was invoked with the -f, -c, -D or --auto-completion option. You should"); |
| [1669](#l1669) | message(" start http server so that cgi-bin/\*.cgi is executed as a CGI script."); |
| [1670](#l1670) | message(" Use of htags-server(1) is recommended."); |
| [1671](#l1671) | message("\n If you are using Apache, 'HTML/.htaccess' might be helpful for you.\n"); |
| [1672](#l1672) | message(" Good luck!\n"); |
| [1673](#l1673) | } |
| [1674](#l1674) | if (Iflag) { |
| [1675](#l1675) | char src[MAXPATHLEN]; |
| [1676](#l1676) | char dist[MAXPATHLEN]; |
| [1677](#l1677) |  |
| [1678](#l1678) | snprintf(src, sizeof(src), "%s/gtags/icons", datadir); |
| [1679](#l1679) | snprintf(dist, sizeof(dist), "%s/icons", distpath); |
| [1680](#l1680) | copydirectory(src, dist); |
| [1681](#l1681) | } |
| [1682](#l1682) | gpath\_close(); |
| [1683](#l1683) | /\* |
| [1684](#l1684) | \* Print statistics information. |
| [1685](#l1685) | \*/ |
| [1686](#l1686) | print\_statistics(statistics); |
| [1687](#l1687) | clean(); |
| [1688](#l1688) | return 0; |
| [1689](#l1689) | } |

---

| savannah-hackers-public@gnu.org | **[ViewVC Help](/viewvc/%2Adocroot%2A/help_rootview.html)** |
| --- | --- |
| Powered by [ViewVC 1.1.26](http://viewvc.tigris.org/) |  |

