<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>oss-security - Re: CVE-2023-6246: Heap-based buffer overflow in the
 glibc's syslog()</title>

<link href="/style.css" type="text/css" rel="stylesheet">
<style type="text/css">
.calendar { text-align: center; }
.ccell { background: #ccc; width: 5ex; padding: 2px; }

.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>
</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">


<table bgcolor="#ffffff" width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>

<td>
<a href="/"><img class="logo" src="/logo.png" border="0" width="182" height="80" alt="Openwall"></a>
<td width="100%">
<div class="nav">
<ul>
<li><a href="/">Products</a>
<ul>
<li><a href="/Owl/">Openwall GNU/*/Linux &nbsp; <i>server OS</i></a>
<li><a href="/lkrg/">Linux Kernel Runtime Guard</a>
<li><a href="/john/">John the Ripper &nbsp; <i>password cracker</i></a>
<ul>
<li><a href="/john/">Free &amp; Open Source for any platform</a>
<li><a href="/john/cloud/">in the cloud</a>
<li><a href="/john/pro/linux/">Pro for Linux</a>
<li><a href="/john/pro/macosx/">Pro for macOS</a>
</ul>
<li><a href="/wordlists/">Wordlists &nbsp; <i>for password cracking</i></a>
<li><a href="/passwdqc/">passwdqc &nbsp; <i>policy enforcement</i></a>
<ul>
<li><a href="/passwdqc/">Free &amp; Open Source for Unix</a>
<li><a href="/passwdqc/windows/">Pro for Windows (Active Directory)</a>
</ul>
<li><a href="/yescrypt/">yescrypt &nbsp; <i>KDF &amp; password hashing</i></a>
<li><a href="/yespower/">yespower &nbsp; <i>Proof-of-Work (PoW)</i></a>
<li><a href="/crypt/">crypt_blowfish &nbsp; <i>password hashing</i></a>
<li><a href="/phpass/">phpass &nbsp; <i>ditto in PHP</i></a>
<li><a href="/tcb/">tcb &nbsp; <i>better password shadowing</i></a>
<li><a href="/pam/">Pluggable Authentication Modules</a>
<li><a href="/scanlogd/">scanlogd &nbsp; <i>port scan detector</i></a>
<li><a href="/popa3d/">popa3d &nbsp; <i>tiny POP3 daemon</i></a>
<li><a href="/blists/">blists &nbsp; <i>web interface to mailing lists</i></a>
<li><a href="/msulogin/">msulogin &nbsp; <i>single user mode login</i></a>
<li><a href="/php_mt_seed/">php_mt_seed &nbsp; <i>mt_rand() cracker</i></a>
</ul>
<li><a href="/services/">Services</a>
<li id="narrow-li-1"><a>Publications</a>
<ul>
<li><a href="/articles/">Articles</a>
<li><a href="/presentations/">Presentations</a>
</ul>
<li><a>Resources</a>
<ul>
<li><a href="/lists/">Mailing lists</a>
<li><a href="https://openwall.info/wiki/">Community wiki</a>
<li><a href="https://github.com/openwall">Source code repositories (GitHub)</a>
<li><a href="https://cvsweb.openwall.com">Source code repositories (CVSweb)</a>
<li><a href="/mirrors/">File archive &amp; mirrors</a>
<li><a href="/signatures/">How to verify digital signatures</a>
<li><a href="/ove/">OVE IDs</a>
</ul>
<li id="last-li"><a href="/news">What's new</a>
</ul>
</div>


</table>


<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">
<a href="https://hashsuite.openwall.net">
Hash Suite - Windows password security audit tool. GUI, reports in PDF.</a>

</TABLE>
</TABLE>

<a href="7">[&lt;prev]</a> <a href="9">[next&gt;]</a> <a href="6">[&lt;thread-prev]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;CAAHN_R22YUwGYBqk_b2JPwdJjkYV4DzeJpwngNqS3MCdX0BHRA&#64;mail.gmail.com&gt;
Date: Tue, 30 Jan 2024 14:46:51 -0500
From: Siddhesh Poyarekar &lt;siddhesh.poyarekar&#64;...il.com&gt;
To: oss-security&#64;...ts.openwall.com
Subject: Re: CVE-2023-6246: Heap-based buffer overflow in the
 glibc's syslog()

FYI, the glibc advisory announcement is here:

<a href="https://sourceware.org/pipermail/libc-announce/2024/000037.html" rel="nofollow">https://sourceware.org/pipermail/libc-announce/2024/000037.html</a>

and here are the individual advisories:

<a href="https://sourceware.org/git/?p=glibc.git;a=blob_plain;f=advisories/GLIBC-SA-2024-0001;hb=HEAD" rel="nofollow">https://sourceware.org/git/?p=glibc.git;a=blob_plain;f=advisories/GLIBC-SA-2024-0001;hb=HEAD</a>
<a href="https://sourceware.org/git/?p=glibc.git;a=blob_plain;f=advisories/GLIBC-SA-2024-0002;hb=HEAD" rel="nofollow">https://sourceware.org/git/?p=glibc.git;a=blob_plain;f=advisories/GLIBC-SA-2024-0002;hb=HEAD</a>
<a href="https://sourceware.org/git/?p=glibc.git;a=blob_plain;f=advisories/GLIBC-SA-2024-0003;hb=HEAD" rel="nofollow">https://sourceware.org/git/?p=glibc.git;a=blob_plain;f=advisories/GLIBC-SA-2024-0003;hb=HEAD</a>

Thanks,
Sid

On Tue, Jan 30, 2024 at 1:32â€¯PM Qualys Security Advisory &lt;qsa&#64;...lys.com&gt; wrote:
&gt;
&gt;
&gt; Qualys Security Advisory
&gt;
&gt; CVE-2023-6246: Heap-based buffer overflow in the glibc's syslog()
&gt;
&gt;
&gt; ========================================================================
&gt; Contents
&gt; ========================================================================
&gt;
&gt; Summary
&gt; Analysis
&gt; Proof of concept
&gt; Exploitation
&gt; Acknowledgments
&gt; Timeline
&gt;
&gt;
&gt; ========================================================================
&gt; Summary
&gt; ========================================================================
&gt;
&gt; We discovered a heap-based buffer overflow in the GNU C Library's
&gt; __vsyslog_internal() function, which is called by both syslog() and
&gt; vsyslog(). This vulnerability was introduced in glibc 2.37 (in August
&gt; 2022) by the following commit:
&gt;
&gt;   <a href="https://sourceware.org/git?p=glibc.git;a=commit;h=52a5be0df411ef3ff45c10c7c308cb92993d15b1" rel="nofollow">https://sourceware.org/git?p=glibc.git;a=commit;h=52a5be0df411ef3ff45c10c7c308cb92993d15b1</a>
&gt;
&gt; and was also backported to glibc 2.36 because this commit was a fix for
&gt; another, minor vulnerability in __vsyslog_internal() (CVE-2022-39046, an
&gt; "uninitialized memory [read] from the heap"):
&gt;
&gt;   <a href="https://sourceware.org/bugzilla/show_bug.cgi?id=29536" rel="nofollow">https://sourceware.org/bugzilla/show_bug.cgi?id=29536</a>
&gt;
&gt; For example, we confirmed that Debian 12 and 13, Ubuntu 23.04 and 23.10,
&gt; and Fedora 37 to 39 are vulnerable to this buffer overflow. Furthermore,
&gt; we successfully exploited an up-to-date, default installation of Fedora
&gt; 38 (on amd64): a Local Privilege Escalation, from any unprivileged user
&gt; to full root. Other distributions are probably also exploitable.
&gt;
&gt; To the best of our knowledge, this vulnerability cannot be triggered
&gt; remotely in any likely scenario (because it requires an argv[0], or an
&gt; openlog() ident argument, longer than 1024 bytes to be triggered).
&gt;
&gt; Last-minute note: in December 1997 Solar Designer published information
&gt; about a very similar vulnerability in the vsyslog() of the old Linux
&gt; libc (<a href="https://insecure.org/sploits/linux.libc.5.4.38.vsyslog.html" rel="nofollow">https://insecure.org/sploits/linux.libc.5.4.38.vsyslog.html</a>).
&gt;
&gt;
&gt; ========================================================================
&gt; Analysis
&gt; ========================================================================
&gt;
&gt; In the glibc, both syslog() and vsyslog() call the vulnerable function
&gt; __vsyslog_internal():
&gt;
&gt; ------------------------------------------------------------------------
&gt; 122 __vsyslog_internal (int pri, const char *fmt, va_list ap,
&gt; 123                     unsigned int mode_flags)
&gt; 124 {
&gt; 125   /* Try to use a static buffer as an optimization.  */
&gt; 126   char bufs[1024];
&gt; 127   char *buf = NULL;
&gt; 128   size_t bufsize = 0;
&gt; ...
&gt; 171 #define SYSLOG_HEADER(__pri, __timestamp, __msgoff, pid) \
&gt; 172   "&lt;%d&gt;%s%n%s%s%.0d%s: ",                                \
&gt; 173   __pri, __timestamp, __msgoff,                          \
&gt; 174   LogTag == NULL ? __progname : LogTag,                  \
&gt; 175   "[" + (pid == 0), pid, "]" + (pid == 0)
&gt; ...
&gt; 182     l = __snprintf (bufs, sizeof bufs,
&gt; 183                     SYSLOG_HEADER (pri, timestamp, &amp;msgoff, pid));
&gt; ...
&gt; 187   if (0 &lt;= l &amp;&amp; l &lt; sizeof bufs)
&gt; 188     {
&gt; ...
&gt; 202     }
&gt; 203
&gt; 204   if (buf == NULL)
&gt; 205     {
&gt; 206       buf = malloc ((bufsize + 1) * sizeof (char));
&gt; ...
&gt; 213             __snprintf (buf, l + 1,
&gt; 214                         SYSLOG_HEADER (pri, timestamp, &amp;msgoff, pid));
&gt; ...
&gt; 221           __vsnprintf_internal (buf + l, bufsize - l + 1, fmt, apc,
&gt; 222                                 mode_flags);
&gt; ------------------------------------------------------------------------
&gt;
&gt; - at lines 182-183, SYSLOG_HEADER() includes __progname (the basename()
&gt;   of argv[0]) if LogTag is NULL (e.g., if openlog() was not called, or
&gt;   called with a NULL ident argument);
&gt;
&gt; - because a local attacker fully controls argv[0] and hence __progname
&gt;   (even when executing a SUID-root program such as su), at line 187 l
&gt;   (the return value of __snprintf()) can be larger than sizeof bufs
&gt;   (1024), in which case the code block at lines 188-202 is skipped;
&gt;
&gt; - consequently, at line 203 buf is still NULL and bufsize is still 0,
&gt;   and at line 206 a very small 1-byte buf is malloc()ated (because
&gt;   bufsize is 0);
&gt;
&gt; - at lines 213-214 this small buf is overflowed with the attacker-
&gt;   controlled __progname (because l is larger than 1024), and at lines
&gt;   221-222 this small buf is further overflowed (because bufsize - l + 1
&gt;   is 0 - l + 1, a very large size_t).
&gt;
&gt;
&gt; ========================================================================
&gt; Proof of concept
&gt; ========================================================================
&gt;
&gt; $ (exec -a "`printf '%0128000x' 1`" /usr/bin/su &lt; /dev/null)
&gt; Password: Segmentation fault (core dumped)
&gt;
&gt;
&gt; ========================================================================
&gt; Exploitation
&gt; ========================================================================
&gt;
&gt; We decided to exploit this vulnerability through su (the most common
&gt; SUID-root program) on Fedora 38. To authenticate a user, su calls the
&gt; PAM library, and if the password provided by the user is incorrect, then
&gt; PAM calls the glibc's syslog() function without calling openlog() first,
&gt; thus allowing us to trigger the buffer overflow in __vsyslog_internal():
&gt;
&gt; ------------------------------------------------------------------------
&gt; 782                         pam_syslog(pamh, LOG_NOTICE,
&gt; 783                                  "authentication failure; "
&gt; 784                                  "logname=%s uid=%d euid=%d "
&gt; 785                                  "tty=%s ruser=%s rhost=%s "
&gt; 786                                  "%s%s",
&gt; 787                                  new-&gt;name, new-&gt;uid, new-&gt;euid,
&gt; 788                                  tty ? (const char *)tty : "",
&gt; 789                                  ruser ? (const char *)ruser : "",
&gt; 790                                  rhost ? (const char *)rhost : "",
&gt; 791                                  (new-&gt;user &amp;&amp; new-&gt;user[0] != '\0')
&gt; 792                                   ? " user=" : "",
&gt; 793                                  new-&gt;user
&gt; 794                         );
&gt; ------------------------------------------------------------------------
&gt; 107 pam_syslog (const pam_handle_t *pamh, int priority,
&gt; 108             const char *fmt, ...)
&gt; 109 {
&gt; ...
&gt; 113   pam_vsyslog (pamh, priority, fmt, args);
&gt; ------------------------------------------------------------------------
&gt;  73 pam_vsyslog (const pam_handle_t *pamh, int priority,
&gt;  74              const char *fmt, va_list args)
&gt;  75 {
&gt;  ..
&gt;  81       if (asprintf (&amp;msgbuf1, "%s(%s:%s):", pamh-&gt;mod_name,
&gt;  82                     pamh-&gt;service_name?pamh-&gt;service_name:"&lt;unknown&gt;",
&gt;  83                     _pam_choice2str (pamh-&gt;choice)) &lt; 0)
&gt;  ..
&gt;  91   if (vasprintf (&amp;msgbuf2, fmt, args) &lt; 0)
&gt;  ..
&gt;  99   syslog (LOG_AUTHPRIV|priority, "%s %s",
&gt; 100           (msgbuf1 ? msgbuf1 : _PAM_SYSTEM_LOG_PREFIX), msgbuf2);
&gt; ------------------------------------------------------------------------
&gt;
&gt; But what should we overwrite in the heap to successfully exploit this
&gt; buffer overflow? Initially, because su calls setlocale(LC_ALL, ""); at
&gt; the very beginning of its su_main() function, we tried to reuse the key
&gt; idea from our Baron Samedit exploits (CVE-2021-3156 in Sudo): we wrote a
&gt; rudimentary fuzzer to execute su with a random argv[0] and random locale
&gt; environment variables and automatically inspect the resulting crashes in
&gt; gdb. Unfortunately this fuzzer failed to produce interesting results: we
&gt; only obtained a handful of unique crashes, and they did not look very
&gt; promising.
&gt;
&gt; However, we did not investigate the reasons for this failure, because
&gt; while browsing through su's source code we noticed that su_main() calls
&gt; env_whitelist_from_string() to parse the argument of the -w command-line
&gt; option:
&gt;
&gt; ------------------------------------------------------------------------
&gt; 1118                 case 'w':
&gt; 1119                         env_whitelist_from_string(su, optarg);
&gt; 1120                         break;
&gt; ------------------------------------------------------------------------
&gt;  692 static int env_whitelist_from_string(struct su_context *su, const char *str)
&gt;  693 {
&gt;  694         char **all = strv_split(str, ",");
&gt;  ...
&gt;  703         STRV_FOREACH(one, all)
&gt;  704                 env_whitelist_add(su, *one);
&gt;  705         strv_free(all);
&gt;  706         return 0;
&gt;  707 }
&gt; ------------------------------------------------------------------------
&gt;  662 static int env_whitelist_add(struct su_context *su, const char *name)
&gt;  663 {
&gt;  664         const char *env = getenv(name);
&gt;  665
&gt;  666         if (!env)
&gt;  667                 return 1;
&gt;  668         if (strv_extend(&amp;su-&gt;env_whitelist_names, name))
&gt;  669                 err_oom();
&gt;  670         if (strv_extend(&amp;su-&gt;env_whitelist_vals, env))
&gt;  671                 err_oom();
&gt;  672         return 0;
&gt;  673 }
&gt; ------------------------------------------------------------------------
&gt;
&gt; Conveniently, env_whitelist_from_string() allows us (attackers) to
&gt; malloc()ate and free() an arbitrary number of arbitrary strings at the
&gt; very beginning of su's execution: an almost perfect heap feng shui. We
&gt; therefore rewrote our fuzzer to execute su with a random argv[0] and a
&gt; random whitelist option (instead of random locale environment variables)
&gt; and immediately observed numerous unique crashes; among these, three in
&gt; particular caught our attention.
&gt;
&gt;
&gt; ========================================================================
&gt; 1/ Corruption of PAM structures
&gt; ========================================================================
&gt;
&gt; Surprisingly, our fuzzer directly overwrote two PAM function pointers
&gt; (in struct pam_data and struct handler):
&gt;
&gt; ------------------------------------------------------------------------
&gt; Thread 2.1 "su" received signal SIGSEGV, Segmentation fault.
&gt; 0x00007fa7d3b0e3ac in _pam_free_data (status=7, pamh=0x56211242ec10) at /usr/src/debug/pam-1.5.2-16.fc38.x86_64/libpam/pam_data.c:161
&gt; 161                 last-&gt;cleanup(pamh, last-&gt;data, status);
&gt; ...
&gt; =&gt; 0x7fa7d3b0e3ac &lt;pam_end+92&gt;: call   *%rax
&gt; rax            0x4141414141414141  4702111234474983745
&gt; ------------------------------------------------------------------------
&gt; Thread 2.1 "su" received signal SIGSEGV, Segmentation fault.
&gt; 0x00007f928b5e5781 in _pam_dispatch_aux (use_cached_chain=&lt;optimized out&gt;, resumed=&lt;optimized out&gt;, h=0x55f2e374aae0, flags=0, pamh=0x55f2e374aae0) at /usr/src/debug/pam-1.5.2-16.fc38.x86_64/libpam/pam_dispatch.c:110
&gt; 110                 retval = h-&gt;func(pamh, flags, h-&gt;argc, h-&gt;argv);
&gt; ...
&gt; =&gt; 0x7f928b5e5781 &lt;_pam_dispatch+465&gt;:  call   *%rax
&gt; rax            0x4545454545454545  4991471925827290437
&gt; ------------------------------------------------------------------------
&gt;
&gt; Although this sounds exciting at first (a call to 0x4141414141414141!)
&gt; we decided to not pursue this avenue of exploitation:
&gt;
&gt; - we cannot overwrite such a function pointer with null bytes (because
&gt;   we overflow __vsyslog_internal()'s buffer with a null-terminated
&gt;   string), but userland addresses contain at least two null bytes;
&gt;
&gt; - we could try to partially overwrite such a function pointer, but we do
&gt;   not control the end of the string that overflows __vsyslog_internal()'s
&gt;   buffer (the end of the aforementioned pam_syslog() format string), and
&gt;   such an uncontrolled, partially overwritten function pointer is very
&gt;   unlikely to miraculously point to a useful ROP gadget.
&gt;
&gt;
&gt; ========================================================================
&gt; 2/ Corruption of heap metadata
&gt; ========================================================================
&gt;
&gt; Unsurprisingly, our fuzzer also overwrote various pieces of heap
&gt; metadata (chunk headers managed internally by the glibc's malloc), and
&gt; therefore triggered all kinds of assertion failures and security checks:
&gt;
&gt; ------------------------------------------------------------------------
&gt; $ grep -A1 __libc_message fuzzer.out | cut -d'"' -f2 | sort -u
&gt; ...
&gt; chunk_main_arena (bck-&gt;bk)
&gt; chunk_main_arena (fwd)
&gt; corrupted double-linked list
&gt; corrupted double-linked list (not small)
&gt; corrupted size vs. prev_size
&gt; corrupted size vs. prev_size in fastbins
&gt; double free or corruption (out)
&gt; free(): corrupted unsorted chunks
&gt; free(): invalid next size (fast)
&gt; free(): invalid pointer
&gt; free(): invalid size
&gt; malloc_consolidate(): invalid chunk size
&gt; malloc(): corrupted top size
&gt; malloc(): invalid size (unsorted)
&gt; malloc(): smallbin double linked list corrupted
&gt; malloc(): unaligned tcache chunk detected
&gt; malloc(): unsorted double linked list corrupted
&gt; munmap_chunk(): invalid pointer
&gt; ------------------------------------------------------------------------
&gt;
&gt; Although some of these corruptions might be exploitable, we decided to
&gt; not pursue this avenue of exploitation either:
&gt;
&gt; - we cannot overwrite a chunk header with a size field and an fd or bk
&gt;   pointer that are both valid (they must both contain null bytes to be
&gt;   valid), which severely limits our exploitation options;
&gt;
&gt; - in any case, we would probably need a specific heap, mmap, or stack
&gt;   address to exploit such a corruption, but we do not have the luxury of
&gt;   an information leak, and all these addresses are too heavily
&gt;   randomized by ASLR to be brute forced.
&gt;
&gt;
&gt; ========================================================================
&gt; 3/ Corruption of nss structures
&gt; ========================================================================
&gt;
&gt; Our fuzzer also produced two crashes that immediately caught our
&gt; attention because they are directly related to one of the techniques
&gt; that we used to exploit Baron Samedit:
&gt;
&gt; ------------------------------------------------------------------------
&gt; Thread 2.1 "su" received signal SIGSEGV, Segmentation fault.
&gt; __GI___nss_lookup (ni=ni&#64;...ry=0x7ffe876a05e8, fct_name=fct_name&#64;...ry=0x7fbba214e4e7 "getpwnam_r", fct2_name=fct2_name&#64;...ry=0x0, fctp=fctp&#64;...ry=0x7ffe876a05f0) at nsswitch.c:67
&gt; 67        *fctp = __nss_lookup_function (*ni, fct_name);
&gt; ...
&gt; =&gt; 0x7fbba20ec50e &lt;__GI___nss_lookup+30&gt;:       mov    (%rax),%rdi
&gt; rax            0x4141414141414141  4702111234474983745
&gt; ------------------------------------------------------------------------
&gt; Thread 2.1 "su" received signal SIGSEGV, Segmentation fault.
&gt; __nss_module_get_function (module=0x4141414141414141, name=name&#64;...ry=0x7f0aed9034e7 "getpwnam_r") at nss_module.c:328
&gt; 328       if (!__nss_module_load (module))
&gt; ...
&gt; =&gt; 0x7f0aed8a34b7 &lt;__nss_module_get_function+39&gt;:       mov    (%rdi),%eax
&gt; rdi            0x4141414141414141  4702111234474983745
&gt; ------------------------------------------------------------------------
&gt;
&gt; As discussed in the "2/ struct service_user overwrite" subsection of our
&gt; Baron Samedit advisory, if we overwrite the name[] field of a heap-based
&gt; struct nss_module with a string of characters that contains a slash (for
&gt; example "A/B/C"), then at lines 180-181 the name of a shared library is
&gt; constructed ("libnss_A/B/C.so.2"), and at line 187 this shared library
&gt; is loaded from our current working directory (because its name contains
&gt; a slash, but does not start with a slash) and executed as root (because
&gt; su is a SUID-root program):
&gt;
&gt; ------------------------------------------------------------------------
&gt; 170 module_load (struct nss_module *module)
&gt; 171 {
&gt; ...
&gt; 180     if (__asprintf (&amp;shlib_name, "libnss_%s.so%s",
&gt; 181                     module-&gt;name, __nss_shlib_revision) &lt; 0)
&gt; ...
&gt; 187     handle = __libc_dlopen (shlib_name);
&gt; ------------------------------------------------------------------------
&gt;
&gt; Unfortunately, the __progname part (which we control) of the string that
&gt; overflows __vsyslog_internal()'s buffer cannot contain a slash (because
&gt; __progname is the basename() of argv[0]). Luckily, however, the part of
&gt; the overflowing string that we do not control (the pam_syslog() format
&gt; string) includes the absolute path of our tty, which contains a slash.
&gt; For example, if:
&gt;
&gt; - our tty is /dev/pts/23 (we use forkpty() in our exploit);
&gt;
&gt; - our unprivileged local user is nobody (uid 65534);
&gt;
&gt; - the argv[0] (and hence __progname) that we use to execute su is a long
&gt;   string of 'A' characters (longer than 1024);
&gt;
&gt; then we can overwrite the name[] field of a heap-based struct nss_module
&gt; with a string of the form:
&gt;
&gt;   "AAAAAAAAAA: pam_unix(su:auth): authentication failure; logname= uid=65534 euid=0 tty=/dev/pts/23 ruser=nobody rhost=  user=root"
&gt;
&gt; Consequently, if we first create the following three directories (in our
&gt; current working directory):
&gt;
&gt;   "libnss_AAAAAAAAAA: pam_unix(su:auth): authentication failure; logname= uid=65534 euid=0 tty="
&gt;   "libnss_AAAAAAAAAA: pam_unix(su:auth): authentication failure; logname= uid=65534 euid=0 tty=/dev"
&gt;   "libnss_AAAAAAAAAA: pam_unix(su:auth): authentication failure; logname= uid=65534 euid=0 tty=/dev/pts"
&gt;
&gt; and also create the following shared library (in our current working
&gt; directory):
&gt;
&gt;   "libnss_AAAAAAAAAA: pam_unix(su:auth): authentication failure; logname= uid=65534 euid=0 tty=/dev/pts/23 ruser=nobody rhost=  user=root.so.2"
&gt;
&gt; then this shared library will eventually be loaded and executed with
&gt; full root privileges. In our tests, it takes a few 10,000s of tries to
&gt; successfully brute force the exploit parameters (the length of argv[0],
&gt; and the whitelist option and its associated environment variables).
&gt;
&gt; Note: this exploit could certainly be made much more efficient; in
&gt; theory, it could even be a one-shot exploit, because we do not need to
&gt; brute force the ASLR, only the heap layout.
&gt;
&gt;
&gt; ========================================================================
&gt; Acknowledgments
&gt; ========================================================================
&gt;
&gt; We thank the glibc developers (Carlos O'Donell, Siddhesh Poyarekar,
&gt; Arjun Shankar, Florian Weimer, and Adhemerval Zanella in particular),
&gt; Red Hat Product Security (Guilherme Suckevicz in particular), and the
&gt; members of linux-distros&#64;...nwall (Salvatore Bonaccorso in particular).
&gt;
&gt;
&gt; ========================================================================
&gt; Timeline
&gt; ========================================================================
&gt;
&gt; 2023-11-07: We sent a preliminary draft of our advisory to Red Hat
&gt; Product Security.
&gt;
&gt; 2023-11-15: Red Hat Product Security acknowledged receipt of our email.
&gt;
&gt; 2023-11-16: Red Hat Product Security asked us if we could share our
&gt; exploit with them.
&gt;
&gt; 2023-11-17: We sent our exploit to Red Hat Product Security.
&gt;
&gt; 2023-11-21: Red Hat Product Security confirmed that our exploit worked,
&gt; and assigned CVE-2023-6246 to this heap-based buffer overflow in
&gt; __vsyslog_internal().
&gt;
&gt; 2023-12-05: Red Hat Product Security sent us a patch for CVE-2023-6246
&gt; (written by the glibc developers), and asked us for our feedback.
&gt;
&gt; 2023-12-07: While reviewing this patch, we discovered two more minor
&gt; vulnerabilities in the same function (an off-by-one buffer overflow and
&gt; an integer overflow). We immediately sent an analysis, proof of concept,
&gt; and patch proposal to Red Hat Product Security, and suggested that we
&gt; directly involve the glibc security team.
&gt;
&gt; 2023-12-08: Red Hat Product Security acknowledged receipt of our email,
&gt; and agreed that we should directly involve the glibc security team. We
&gt; contacted them on the same day, and they immediately replied with very
&gt; constructive comments.
&gt;
&gt; 2023-12-11: The glibc security team suggested that we postpone the
&gt; coordinated disclosure of all three vulnerabilities until January 2024
&gt; (because of the upcoming holiday season). We agreed.
&gt;
&gt; 2023-12-13: Red Hat Product Security assigned CVE-2023-6779 to the
&gt; off-by-one buffer overflow and CVE-2023-6780 to the integer overflow in
&gt; __vsyslog_internal().
&gt;
&gt; 2024-01-04: We suggested either January 23 or January 30 for the
&gt; Coordinated Release Date of these vulnerabilities. The glibc developers
&gt; agreed on January 30.
&gt;
&gt; 2024-01-12: The glibc developers sent us an updated version of the
&gt; patches for these vulnerabilities.
&gt;
&gt; 2024-01-13: We reviewed these patches, and sent our feedback to the
&gt; glibc developers.
&gt;
&gt; 2024-01-15: The glibc developers sent us the final version of the
&gt; patches for these vulnerabilities.
&gt;
&gt; 2024-01-16: We sent these patches and a draft of our advisory to the
&gt; linux-distros&#64;...nwall. They immediately acknowledged receipt of our
&gt; email.
&gt;
&gt; 2024-01-30: Coordinated Release Date (18:00 UTC).



-- 
<a href="https://gotplt.org" rel="nofollow">https://gotplt.org</a>
</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>
Please check out the
<a href="https://oss-security.openwall.org/wiki/">
Open Source Software Security Wiki</a>, which is counterpart to this
<a href="https://oss-security.openwall.org/wiki/mailing-lists/oss-security">mailing list</a>.
<p>
Confused about <a href="/lists/">mailing lists</a> and their use?
<a href="https://en.wikipedia.org/wiki/Electronic_mailing_list">Read about mailing lists on Wikipedia</a>
and check out these
<a href="https://www.complang.tuwien.ac.at/anton/mail-news-errors.html">guidelines on proper formatting of your messages</a>.
<p>

</body>
</html>
