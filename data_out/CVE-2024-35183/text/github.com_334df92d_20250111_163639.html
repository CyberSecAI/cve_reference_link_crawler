
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fwolfi-dev%2Fwolfictl%2Fblob%2F4dd6c95abb4bc0f9306350a8601057bd7a92bded%2Fpkg%2Fupdate%2Fdeps%2Fcleanup.go)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fwolfi-dev%2Fwolfictl%2Fblob%2F4dd6c95abb4bc0f9306350a8601057bd7a92bded%2Fpkg%2Fupdate%2Fdeps%2Fcleanup.go)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=wolfi-dev%2Fwolfictl)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[wolfi-dev](/wolfi-dev)
/
**[wolfictl](/wolfi-dev/wolfictl)**
Public

* [Notifications](/login?return_to=%2Fwolfi-dev%2Fwolfictl) You must be signed in to change notification settings
* [Fork
  58](/login?return_to=%2Fwolfi-dev%2Fwolfictl)
* [Star
   58](/login?return_to=%2Fwolfi-dev%2Fwolfictl)

* [Code](/wolfi-dev/wolfictl)
* [Issues
  45](/wolfi-dev/wolfictl/issues)
* [Pull requests
  30](/wolfi-dev/wolfictl/pulls)
* [Actions](/wolfi-dev/wolfictl/actions)
* [Projects
  0](/wolfi-dev/wolfictl/projects)
* [Security](/wolfi-dev/wolfictl/security)
* [Insights](/wolfi-dev/wolfictl/pulse)

Additional navigation options

* [Code](/wolfi-dev/wolfictl)
* [Issues](/wolfi-dev/wolfictl/issues)
* [Pull requests](/wolfi-dev/wolfictl/pulls)
* [Actions](/wolfi-dev/wolfictl/actions)
* [Projects](/wolfi-dev/wolfictl/projects)
* [Security](/wolfi-dev/wolfictl/security)
* [Insights](/wolfi-dev/wolfictl/pulse)

## Files

 4dd6c95
## Breadcrumbs

1. [wolfictl](/wolfi-dev/wolfictl/tree/4dd6c95abb4bc0f9306350a8601057bd7a92bded)
2. /[pkg](/wolfi-dev/wolfictl/tree/4dd6c95abb4bc0f9306350a8601057bd7a92bded/pkg)
3. /[update](/wolfi-dev/wolfictl/tree/4dd6c95abb4bc0f9306350a8601057bd7a92bded/pkg/update)
4. /[deps](/wolfi-dev/wolfictl/tree/4dd6c95abb4bc0f9306350a8601057bd7a92bded/pkg/update/deps)
/
# cleanup.go

Copy path Blame  Blame
## Latest commit

## History

[History](/wolfi-dev/wolfictl/commits/4dd6c95abb4bc0f9306350a8601057bd7a92bded/pkg/update/deps/cleanup.go)387 lines (346 loc) · 11.8 KB 4dd6c95
## Breadcrumbs

1. [wolfictl](/wolfi-dev/wolfictl/tree/4dd6c95abb4bc0f9306350a8601057bd7a92bded)
2. /[pkg](/wolfi-dev/wolfictl/tree/4dd6c95abb4bc0f9306350a8601057bd7a92bded/pkg)
3. /[update](/wolfi-dev/wolfictl/tree/4dd6c95abb4bc0f9306350a8601057bd7a92bded/pkg/update)
4. /[deps](/wolfi-dev/wolfictl/tree/4dd6c95abb4bc0f9306350a8601057bd7a92bded/pkg/update/deps)
/
# cleanup.go

Top
## File metadata and controls

* Code
* Blame

387 lines (346 loc) · 11.8 KB[Raw](https://github.com/wolfi-dev/wolfictl/raw/4dd6c95abb4bc0f9306350a8601057bd7a92bded/pkg/update/deps/cleanup.go)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387package deps
import ( "fmt" "log" "os" "os/exec" "path" "strings" "time"
 wgit "github.com/wolfi-dev/wolfictl/pkg/git"
 "chainguard.dev/melange/pkg/config" "chainguard.dev/melange/pkg/util" "github.com/dprotaso/go-yit" "github.com/go-git/go-git/v5" "github.com/go-git/go-git/v5/plumbing" "golang.org/x/exp/slices" "golang.org/x/mod/modfile" "golang.org/x/mod/semver" "gopkg.in/yaml.v3" versionutil "k8s.io/apimachinery/pkg/util/version")
func gitCheckout(p \*config.Pipeline, dir string, mutations map[string]string) error { repoValue := p.With["repository"] if repoValue == "" { return fmt.Errorf("no repository to checkout") }
 tagValue := p.With["tag"] if tagValue == "" { return fmt.Errorf("no tag to checkout") }
 // evaluate var substitutions evaluatedTag, err := util.MutateStringFromMap(mutations, tagValue) if err != nil { return err }
 cloneOpts := &git.CloneOptions{ URL: repoValue, ReferenceName: plumbing.ReferenceName(fmt.Sprintf("refs/tags/%s", evaluatedTag)), Progress: os.Stdout, RecurseSubmodules: git.NoRecurseSubmodules, Depth: 1, Auth: wgit.GetGitAuth(), }
 log.Printf("cloning sources from %s tag %s into a temporary directory '%s', this may take a while", repoValue, dir, evaluatedTag)
 maxRetries := 3 r := &git.Repository{} for attempt := 0; attempt < maxRetries; attempt++ { r, err = git.PlainClone(dir, false, cloneOpts) if err == nil { break } log.Printf("Attempt %d failed to clone %s ref %s with error: %v", attempt+1, repoValue, evaluatedTag, err) if attempt < maxRetries-1 { log.Println("Retrying...") time.Sleep(time.Second \* 2) // delete the temporary directory err = os.RemoveAll(dir) if err != nil { return fmt.Errorf("failed to remove temporary directory %s: %w", dir, err) } // recreate the directory err = os.MkdirAll(dir, 0o755)
 if err != nil { return fmt.Errorf("failed to remove temporary directory %s: %w", dir, err) } if err != nil { return fmt.Errorf("failed to remove temporary directory %s: %w", dir, err) } } else { return fmt.Errorf("failed to clone %s ref %s after %d attempts", repoValue, evaluatedTag, maxRetries) } }
 if r == nil { return fmt.Errorf("clone is empty %s ref %s", repoValue, evaluatedTag) } log.Println("git-checkout was successful")
 return nil}
func cleanupGoBumpPipelineDeps(p \*config.Pipeline, tempDir string, tidy bool) error { modroot := "" if \_, ok := p.With["modroot"]; ok { modroot = p.With["modroot"] } goVersion := "" if \_, ok := p.With["go-version"]; ok { goVersion = p.With["go-version"] } if tidy { output, err := goModTidy(path.Join(tempDir, modroot), goVersion) if err != nil { return fmt.Errorf("failed to run 'go mod tidy': %v with output: %v", err, output) } } // Read the entire go.mod one more time into memory and check that all the version constraints are met. modpath := path.Join(tempDir, modroot, "go.mod") modFile, err := parseGoModfile(modpath) if err != nil { return fmt.Errorf("unable to parse the go mod file with error: %v", err) }
 replaces := []string{} deps := []string{} if p.With["replaces"] != "" { replaces = strings.Split(p.With["replaces"], " ") } pkgReplaceVersions := map[string]string{} for \_, pkg := range replaces { replacePkg := strings.Split(pkg, "=") parts := strings.Split(replacePkg[1], "@") pkgReplaceVersions[parts[0]] = parts[1] }
 if p.With["deps"] != "" { deps = strings.Split(p.With["deps"], " ") }
 pkgRequireVersions := map[string]string{} for \_, pkg := range deps { parts := strings.Split(pkg, "@") pkgRequireVersions[parts[0]] = parts[1] }
 // Detect if the list of packages contain any replace statement for \_, replace := range modFile.Replace { if replace != nil { if \_, ok := pkgRequireVersions[replace.New.Path]; ok { if semver.IsValid(pkgRequireVersions[replace.New.Path]) { updateDependencyLists(replace.New.Path, replace.New.Version, pkgRequireVersions, &deps, "{pkg}={pkg}@{ver}") } } if \_, ok := pkgReplaceVersions[replace.New.Path]; ok { if semver.IsValid(pkgReplaceVersions[replace.New.Path]) { // If the replace block in the upstream go.mod contains a newer version then remove the existing dep from replaces updateDependencyLists(replace.New.Path, replace.New.Version, pkgReplaceVersions, &replaces, "{pkg}={pkg}@{ver}") } } } } // Detect if the list of packages contain any require statement for the package for \_, require := range modFile.Require { if require != nil { if \_, ok := pkgRequireVersions[require.Mod.Path]; ok { if semver.IsValid(pkgRequireVersions[require.Mod.Path]) { updateDependencyLists(require.Mod.Path, require.Mod.Version, pkgRequireVersions, &deps, "{pkg}@{ver}") } } if \_, ok := pkgReplaceVersions[require.Mod.Path]; ok { if semver.IsValid(pkgReplaceVersions[require.Mod.Path]) { // If the require block in the upstream go.mod contains a newer version then remove the existing dep from replaces updateDependencyLists(require.Mod.Path, require.Mod.Version, pkgReplaceVersions, &replaces, "{pkg}={pkg}@{ver}") } } } }
 if p.With["deps"] != "" { p.With["deps"] = strings.TrimSpace(strings.Join(deps, " ")) }
 if p.With["replaces"] != "" { p.With["replaces"] = strings.TrimSpace(strings.Join(replaces, " ")) }
 log.Printf("New [deps]: %v\n", p.With["deps"]) log.Printf("New [replaces]: %v\n", p.With["replaces"])
 return nil}
// optionally remove the package from the list if the version is greater or equal to the target versionfunc updateDependencyLists(pkgPath, version string, versionsMap map[string]string, list \*[]string, format string) { if targetVersion, ok := versionsMap[pkgPath]; ok && semver.IsValid(targetVersion) { // Determine comparison based on the presence of "=" in the format, which indicates a replacement. isReplace := strings.Contains(format, "=") compareResult := semver.Compare(version, targetVersion)
 // For requires, we check for >= 0; for replaces, > 0. if (!isReplace && compareResult >= 0) || (isReplace && compareResult > 0) { formattedString := strings.ReplaceAll(format, "{pkg}", pkgPath) formattedString = strings.ReplaceAll(formattedString, "{ver}", targetVersion) idx := slices.Index(\*list, formattedString) if idx != -1 { \*list = append((\*list)[:idx], (\*list)[idx+1:]...) delete(versionsMap, pkgPath) } } }}
// ContainsGoBumpPipeline checks whether there is a gobump in the wolfi package definition.// If so, we will attempt to clean the unnecessary dependencies.func ContainsGoBumpPipeline(updated \*config.Configuration) bool { for i := range updated.Pipeline { if updated.Pipeline[i].Uses == "go/bump" { return true } } return false}
func CleanupGoBumpDeps(doc \*yaml.Node, updated \*config.Configuration, tidy bool, mutations map[string]string) error { tempDir, err := os.MkdirTemp("", "wolfibump") if err != nil { return fmt.Errorf("failed to create temporary folder to clone package configs into: %w", err) } defer os.RemoveAll(tempDir)
 pipelineNode := findPipelineNode(doc) if pipelineNode == nil { return fmt.Errorf("pipeline node not found in the Wolfi definition") }
 checkedOut := false i := 0 for i < len(updated.Pipeline) { // TODO(hectorj2f): add support for fetch pipelines if updated.Pipeline[i].Uses == "git-checkout" { destinationDir := tempDir dest := updated.Pipeline[i].With["destination"] if dest != "" { destinationDir = path.Join(tempDir, dest) } err := gitCheckout(&updated.Pipeline[i], destinationDir, mutations) if err != nil { return fmt.Errorf("failed to git checkout the repository: %v", err) } checkedOut = true } if checkedOut && updated.Pipeline[i].Uses == "go/bump" { log.Printf("checking the pipeline: %v", updated.Pipeline[i])
 // get the go/bump pipeline if err := cleanupGoBumpPipelineDeps(&updated.Pipeline[i], tempDir, tidy); err != nil { return err } if updated.Pipeline[i].With["deps"] == "" && updated.Pipeline[i].With["replaces"] == "" { updated.Pipeline = slices.Delete(updated.Pipeline, i, (i + 1)) // Remove node from the yaml root node if err := removeNodeAtIndex(pipelineNode, i); err != nil { return err } // deleted element in the pipeline array continue } if err := updateGoBumpStep(pipelineNode.Content[i], &updated.Pipeline[i]); err != nil { return err } } // Increase the position in array of pipelines i++ }
 return nil}
// findPipelineNode finds the pipeline node in the YAML documentfunc findPipelineNode(doc \*yaml.Node) \*yaml.Node { it := yit.FromNode(doc).RecurseNodes() // Search for the pipeline node for node, ok := it(); ok; node, ok = it() { if node.Kind == yaml.MappingNode { // Search for the pipeline node for i := 0; i < len(node.Content); i += 2 { if node.Content[i].Value == "pipeline" { return node.Content[i+1] } } } } return nil}
// removeNodeAtIndex removes a node from a sequence node at the specified indexfunc removeNodeAtIndex(parentNode \*yaml.Node, index int) error { if parentNode.Kind != yaml.SequenceNode { return fmt.Errorf("parentNode %v is not a SequenceNode", parentNode.Kind) }
 // Check if index is within the range of the slice if index < 0 || index >= len(parentNode.Content) { return fmt.Errorf("index out of range: %d", index) }
 // Remove the node at the specified index parentNode.Content = append(parentNode.Content[:index], parentNode.Content[index+1:]...) return nil}
func updateGoBumpStep(stepNode \*yaml.Node, p \*config.Pipeline) error { updated := false for i := 0; i < len(stepNode.Content); i += 2 { if stepNode.Content[i].Value == "with" { withNode := stepNode.Content[i+1] for j := 0; j < len(withNode.Content); j += 2 { if withNode.Content[j].Value == "deps" { if p.With["deps"] == "" { withNode.Content = slices.Delete(withNode.Content, j, (j + 2)) updated = true } else { depsNode := withNode.Content[j+1] if depsNode.Kind != yaml.ScalarNode { return fmt.Errorf("deps field is not a scalar") } depsNode.Value = p.With["deps"] updated = true } } if withNode.Content[j].Value == "replaces" { if p.With["replaces"] == "" { withNode.Content = slices.Delete(withNode.Content, j, (j + 2)) updated = true } else { replacesNode := withNode.Content[j+1] if replacesNode.Kind != yaml.ScalarNode { return fmt.Errorf("replaces field is not a scalar") } replacesNode.Value = p.With["replaces"] updated = true } }
 if p.With["modroot"] != "" && withNode.Content[j].Value == "modroot" { modrootNode := withNode.Content[j+1] if modrootNode.Kind != yaml.ScalarNode { return fmt.Errorf("modroot field is not a scalar") } modrootNode.Value = p.With["modroot"] updated = true } } } } if !updated { return fmt.Errorf("go/bump step deps or replaces field not found") } return nil}
func parseGoModfile(file string) (\*modfile.File, error) { content, err := os.ReadFile(file) if err != nil { return nil, err } mod, err := modfile.Parse("go.mod", content, nil) if err != nil { return nil, err }
 return mod, nil}
func goModTidy(modroot, goVersion string) (string, error) { if goVersion == "" { cmd := exec.Command("go", "env", "GOVERSION") cmd.Stderr = os.Stderr out, err := cmd.Output() if err != nil { return "", fmt.Errorf("%v: %w", cmd, err) } goVersion = strings.TrimPrefix(strings.TrimSpace(string(out)), "go")
 v := versionutil.MustParseGeneric(goVersion) goVersion = fmt.Sprintf("%d.%d", v.Major(), v.Minor())
 log.Printf("Running go mod tidy with go version '%s' ...\n", goVersion) }
 cmd := exec.Command("go", "mod", "tidy", "-go", goVersion) cmd.Dir = modroot if bytes, err := cmd.CombinedOutput(); err != nil { return strings.TrimSpace(string(bytes)), err } return "", nil}

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

