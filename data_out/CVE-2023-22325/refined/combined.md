=== Content from www.softether.org_9f8a00a5_20250110_230532.html ===

This application requires Javascript to be enabled.

|  | Search |
| --- | --- |
| * [Top](/) * [Why SoftEther VPN](/1-features)   + [Introductions](/1-features)   + [Screenshots](/3-screens)   + [Specification](/3-spec) * [Documents](/4-docs)   + [Reference Manual](/4-docs/1-manual)   + [Tutorials](/4-docs/2-howto)   + [FAQs and KBs](/4-docs/3-kb)   + [Research Works](/4-docs/9-research) * [Download](/5-download)   + [Download SoftEther VPN](/5-download)   + [Version History](/5-download/history)   + [Source Code](/5-download/src)   + [GitHub Repository](https://github.com/SoftEtherVPN/SoftEtherVPN/) * [Support](/7-forum) * [About Project](/9-about) |

---

[SoftEther VPN Project](https://www.softether.org/ "SoftEther VPN Project")[About SoftEther VPN Project](https://www.softether.org/9-about "About SoftEther VPN Project")[News](https://www.softether.org/9-about/News "News")[SoftEther VPN Becomes Open Source](https://www.softether.org/9-about/News/800-open-source "SoftEther VPN Becomes Open Source")[2019/07/09: SE201901: SoftEther VPN Server NDIS 5.x Windows Local Bridge Driver Local Privilege Escalation Vulnerability](https://www.softether.org/9-about/News/900-SEVPN201901 "2019/07/09: SE201901: SoftEther VPN Server NDIS 5.x Windows Local Bridge Driver Local Privilege Escalation Vulnerability")[2021/11/11: Issue with Creating New L2TP/IPsec Connections on Android 12](https://www.softether.org/9-about/News/903_211111 "2021/11/11: Issue with Creating New L2TP/IPsec Connections on Android 12")[2023/06/30: SE202301: Security Advisory: CVE-2023-27395 etc: Fixed 6 vulnerabilities of SoftEther VPN in cooperation with Cisco Systems, Inc.](https://www.softether.org/9-about/News/904-SEVPN202301 "2023/06/30: SE202301: Security Advisory: CVE-2023-27395 etc: Fixed 6 vulnerabilities of SoftEther VPN in cooperation with Cisco Systems, Inc.")[2023/08/31: TunnelCrack protection implemented in SoftEther VPN Client](https://www.softether.org/9-about/News/905-TunnelCrack "2023/08/31: TunnelCrack protection implemented in SoftEther VPN Client")
##### Table of contents

1. 1. [1. CVE-2023-27395: Heap overflow in SoftEther VPN DDNS client functionality at risk of crashing and theoretically arbitrary code execution caused by a malicious man-in-the-middle attacker such like ISP-level or on national Internet communication channels](#1._CVE-2023-27395:_Heap_overflow_in_SoftEther_VPN_DDNS_client_functionality_at_risk_of_crashing_and_theoretically_arbitrary_code_execution_caused_by_a_malicious_man-in-the-middle_attacker_such_like_ISP-level_or_on_national_Internet_communication_channels)
   1. 1.1. [(1) Severity](#(1)_Severity)
   2. 1.2. [(2) Overview](#(2)_Overview)
   3. 1.3. [(3) Affected versions](#(3)_Affected_versions)
   4. 1.4. [(4) Conditions necessary for a successful attack against this vulnerability](#(4)_Conditions_necessary_for_a_successful_attack_against_this_vulnerability)
   5. 1.5. [(5) Details](#(5)_Details)
2. 2. [2. CVE-2023-22325: Integer overflow in the SoftEther VPN DDNS client functionality could result in crashing caused by a malicious man-in-the-middle attacker such like ISP-level or on national Internet communication channels](#2._CVE-2023-22325:_Integer_overflow_in_the_SoftEther_VPN_DDNS_client_functionality_could_result_in_crashing_caused_by_a_malicious_man-in-the-middle_attacker_such_like_ISP-level_or_on_national_Internet_communication_channels)
   1. 2.1. [(1) Severity](#(1)_Severity_2)
   2. 2.2. [(2) Overview](#(2)_Overview_2)
   3. 2.3. [(3) Affected versions](#(3)_Affected_versions_2)
   4. 2.4. [(4) Conditions necessary for a successful attack against this vulnerability](#(4)_Conditions_necessary_for_a_successful_attack_against_this_vulnerability_2)
   5. 2.5. [(5) Details](#(5)_Details_2)
3. 3. [3. CVE-2023-32275: Vulnerability that allows the administrator himself of a 32-bit version of VPN Client or VPN Server to see the 32-bit value heap address of each of trusted CA's certificates in the VPN process](#3._CVE-2023-32275:_Vulnerability_that_allows_the_administrator_himself_of_a_32-bit_version_of_VPN_Client_or_VPN_Server_to_see_the_32-bit_value_heap_address_of_each_of_trusted_CA's_certificates_in_the_VPN_process)
   1. 3.1. [(1) Severity](#(1)_Severity_3)
   2. 3.2. [(2) Overview](#(2)_Overview_3)
   3. 3.3. [(3) Affected versions](#(3)_Affected_versions_3)
   4. 3.4. [(4) Conditions necessary for a successful attack against this vulnerability](#(4)_Conditions_necessary_for_a_successful_attack_against_this_vulnerability_3)
   5. 3.5. [(5) Details](#(5)_Details_3)
4. 4. [4. CVE-2023-27516: If the user forget to set the administrator password of SoftEther VPN Client and enable remote administration with blank password, the administrator password of VPN Client can be changed remotely or VPN client can be used remotely by anonymouse third person](#4._CVE-2023-27516:_If_the_user_forget_to_set_the_administrator_password_of_SoftEther_VPN_Client_and_enable_remote_administration_with_blank_password.2C_the_administrator_password_of_VPN_Client_can_be_changed_remotely_or_VPN_client_can_be_used_remotely_by_anonymouse_third_person)
   1. 4.1. [(1) Severity](#(1)_Severity_4)
   2. 4.2. [(2) Overview](#(2)_Overview_4)
   3. 4.3. [(3) Affected versions](#(3)_Affected_versions_4)
   4. 4.4. [(4) Conditions necessary for a successful attack against this vulnerability](#(4)_Conditions_necessary_for_a_successful_attack_against_this_vulnerability_4)
   5. 4.5. [(5) Details](#(5)_Details_4)
5. 5. [5. CVE-2023-32634: If an attacker succeeds in launching a TCP relay program on the same port as the VPN Client on a local computer running the SoftEther VPN Client before the VPN Client process is launched, the TCP relay program can conduct a man-in-the-middle attack on communication between the administrator and the VPN Client process](#5._CVE-2023-32634:_If_an_attacker_succeeds_in_launching_a_TCP_relay_program_on_the_same_port_as_the_VPN_Client_on_a_local_computer_running_the_SoftEther_VPN_Client_before_the_VPN_Client_process_is_launched.2C_the_TCP_relay_program_can_conduct_a_man-in-the-middle_attack_on_communication_between_the_administrator_and_the_VPN_Client_process)
   1. 5.1. [(1) Severity](#(1)_Severity_5)
   2. 5.2. [(2) Overview](#(2)_Overview_5)
   3. 5.3. [(3) Affected versions](#(3)_Affected_versions_5)
   4. 5.4. [(4) Conditions necessary for a successful attack against this vulnerability](#(4)_Conditions_necessary_for_a_successful_attack_against_this_vulnerability_5)
   5. 5.5. [(5) Details](#(5)_Details_5)
6. 6. [6. CVE-2023-31192: When SoftEther VPN Client connects to an untrusted VPN Server, an invalid redirection response for the clustering (load balancing) feature causes 20 bytes of uninitialized stack space to be read](#6._CVE-2023-31192:_When_SoftEther_VPN_Client_connects_to_an_untrusted_VPN_Server.2C_an_invalid_redirection_response_for_the_clustering_(load_balancing)_feature_causes_20_bytes_of_uninitialized_stack_space_to_be_read)
   1. 6.1. [(1) Severity](#(1)_Severity_6)
   2. 6.2. [(2) Overview](#(2)_Overview_6)
   3. 6.3. [(3) Affected versions](#(3)_Affected_versions_6)
   4. 6.4. [(4) Conditions necessary for a successful attack against this vulnerability](#(4)_Conditions_necessary_for_a_successful_attack_against_this_vulnerability_6)
   5. 6.5. [(5) Details](#(5)_Details_6)
7. 7.  [New build with fixes for the above vulnerabilities](#New_build_with_fixes_for_the_above_vulnerabilities)

1. [SoftEther VPN Project](https://www.softether.org/)
2. [About SoftEther VPN Project](https://www.softether.org/9-about)
3. [News](https://www.softether.org/9-about/News)
4. [2023/06/30: SE202301: Security Advisory: CVE-2023-27395 etc: Fixed 6 vulnerabilities of SoftEther VPN in cooperation with Cisco Systems, Inc.](https://www.softether.org/9-about/News/904-SEVPN202301)

# 2023/06/30: SE202301: Security Advisory: CVE-2023-27395 etc: Fixed 6 vulnerabilities of SoftEther VPN in cooperation with Cisco Systems, Inc.

##### Table of contents

1. 1. [1. CVE-2023-27395: Heap overflow in SoftEther VPN DDNS client functionality at risk of crashing and theoretically arbitrary code execution caused by a malicious man-in-the-middle attacker such like ISP-level or on national Internet communication channels](#1._CVE-2023-27395:_Heap_overflow_in_SoftEther_VPN_DDNS_client_functionality_at_risk_of_crashing_and_theoretically_arbitrary_code_execution_caused_by_a_malicious_man-in-the-middle_attacker_such_like_ISP-level_or_on_national_Internet_communication_channels)
   1. 1.1. [(1) Severity](#(1)_Severity)
   2. 1.2. [(2) Overview](#(2)_Overview)
   3. 1.3. [(3) Affected versions](#(3)_Affected_versions)
   4. 1.4. [(4) Conditions necessary for a successful attack against this vulnerability](#(4)_Conditions_necessary_for_a_successful_attack_against_this_vulnerability)
   5. 1.5. [(5) Details](#(5)_Details)
2. 2. [2. CVE-2023-22325: Integer overflow in the SoftEther VPN DDNS client functionality could result in crashing caused by a malicious man-in-the-middle attacker such like ISP-level or on national Internet communication channels](#2._CVE-2023-22325:_Integer_overflow_in_the_SoftEther_VPN_DDNS_client_functionality_could_result_in_crashing_caused_by_a_malicious_man-in-the-middle_attacker_such_like_ISP-level_or_on_national_Internet_communication_channels)
   1. 2.1. [(1) Severity](#(1)_Severity_2)
   2. 2.2. [(2) Overview](#(2)_Overview_2)
   3. 2.3. [(3) Affected versions](#(3)_Affected_versions_2)
   4. 2.4. [(4) Conditions necessary for a successful attack against this vulnerability](#(4)_Conditions_necessary_for_a_successful_attack_against_this_vulnerability_2)
   5. 2.5. [(5) Details](#(5)_Details_2)
3. 3. [3. CVE-2023-32275: Vulnerability that allows the administrator himself of a 32-bit version of VPN Client or VPN Server to see the 32-bit value heap address of each of trusted CA's certificates in the VPN process](#3._CVE-2023-32275:_Vulnerability_that_allows_the_administrator_himself_of_a_32-bit_version_of_VPN_Client_or_VPN_Server_to_see_the_32-bit_value_heap_address_of_each_of_trusted_CA's_certificates_in_the_VPN_process)
   1. 3.1. [(1) Severity](#(1)_Severity_3)
   2. 3.2. [(2) Overview](#(2)_Overview_3)
   3. 3.3. [(3) Affected versions](#(3)_Affected_versions_3)
   4. 3.4. [(4) Conditions necessary for a successful attack against this vulnerability](#(4)_Conditions_necessary_for_a_successful_attack_against_this_vulnerability_3)
   5. 3.5. [(5) Details](#(5)_Details_3)
4. 4. [4. CVE-2023-27516: If the user forget to set the administrator password of SoftEther VPN Client and enable remote administration with blank password, the administrator password of VPN Client can be changed remotely or VPN client can be used remotely by anonymouse third person](#4._CVE-2023-27516:_If_the_user_forget_to_set_the_administrator_password_of_SoftEther_VPN_Client_and_enable_remote_administration_with_blank_password.2C_the_administrator_password_of_VPN_Client_can_be_changed_remotely_or_VPN_client_can_be_used_remotely_by_anonymouse_third_person)
   1. 4.1. [(1) Severity](#(1)_Severity_4)
   2. 4.2. [(2) Overview](#(2)_Overview_4)
   3. 4.3. [(3) Affected versions](#(3)_Affected_versions_4)
   4. 4.4. [(4) Conditions necessary for a successful attack against this vulnerability](#(4)_Conditions_necessary_for_a_successful_attack_against_this_vulnerability_4)
   5. 4.5. [(5) Details](#(5)_Details_4)
5. 5. [5. CVE-2023-32634: If an attacker succeeds in launching a TCP relay program on the same port as the VPN Client on a local computer running the SoftEther VPN Client before the VPN Client process is launched, the TCP relay program can conduct a man-in-the-middle attack on communication between the administrator and the VPN Client process](#5._CVE-2023-32634:_If_an_attacker_succeeds_in_launching_a_TCP_relay_program_on_the_same_port_as_the_VPN_Client_on_a_local_computer_running_the_SoftEther_VPN_Client_before_the_VPN_Client_process_is_launched.2C_the_TCP_relay_program_can_conduct_a_man-in-the-middle_attack_on_communication_between_the_administrator_and_the_VPN_Client_process)
   1. 5.1. [(1) Severity](#(1)_Severity_5)
   2. 5.2. [(2) Overview](#(2)_Overview_5)
   3. 5.3. [(3) Affected versions](#(3)_Affected_versions_5)
   4. 5.4. [(4) Conditions necessary for a successful attack against this vulnerability](#(4)_Conditions_necessary_for_a_successful_attack_against_this_vulnerability_5)
   5. 5.5. [(5) Details](#(5)_Details_5)
6. 6. [6. CVE-2023-31192: When SoftEther VPN Client connects to an untrusted VPN Server, an invalid redirection response for the clustering (load balancing) feature causes 20 bytes of uninitialized stack space to be read](#6._CVE-2023-31192:_When_SoftEther_VPN_Client_connects_to_an_untrusted_VPN_Server.2C_an_invalid_redirection_response_for_the_clustering_(load_balancing)_feature_causes_20_bytes_of_uninitialized_stack_space_to_be_read)
   1. 6.1. [(1) Severity](#(1)_Severity_6)
   2. 6.2. [(2) Overview](#(2)_Overview_6)
   3. 6.3. [(3) Affected versions](#(3)_Affected_versions_6)
   4. 6.4. [(4) Conditions necessary for a successful attack against this vulnerability](#(4)_Conditions_necessary_for_a_successful_attack_against_this_vulnerability_6)
   5. 6.5. [(5) Details](#(5)_Details_6)
7. 7.  [New build with fixes for the above vulnerabilities](#New_build_with_fixes_for_the_above_vulnerabilities)
June 30, 2023 by Daiyuu Nobori

Related: CVE-2023-27395, CVE-2023-22325, CVE-2023-32275, CVE-2023-27516, CVE-2023-32634, CVE-2023-31192

SoftEther VPN Security Advisory articles are published for high impact vulnerabilities (an arbitrary code execution or equivalent).

The SoftEther VPN project received a high level code review and technical assistance from [Cisco Systems, Inc. of the United States](https://www.cisco.com/ "https://www.cisco.com/") from April to June 2023 to fix several vulnerabilities in the SoftEther VPN code.

The risk of exploitation of any of the fixed vulnerabilities is low under normal usage and environment, and actual attacks are very difficult. However, SoftEther VPN is now an open source VPN software used by 7.4 million unique users worldwide, and is used daily by many users to defend against the risk of blocking attacks by national censorship firewalls and attempts to eavesdrop on communications. Therefore, as long as the slightest attack possibility exists, there is great value in preventing vulnerabilities as much as possible in anticipation of the most sophisticated cyber attackers in the world, such as malicious ISPs and man-in-the-middle attackers on national Internet communication channels. These fixes are important and useful patches for users who use SoftEther VPN and the Internet for secure communications to prevent advanced attacks that can theoretically be triggered by malicious ISPs and man-in-the-middle attackers on national Internet communication pathways.

The fixed vulnerabilities are CVE-2023-27395, CVE-2023-22325, CVE-2023-32275, CVE-2023-27516, CVE-2023-32634, and CVE-2023-31192. All of these were discovered in an outstanding code review of SoftEther VPN by Cisco Systems, Inc.

We would like to sincerely acknowledge [Cisco Systems, Inc.](https://www.cisco.com/ "https://www.cisco.com/") and Lilith, a security researcher in [the Cisco Talos division](https://www.talosintelligence.com/ "https://www.talosintelligence.com/"), for their contributions to improving security for users of SoftEther VPN over the Internet.

SoftEther VPN is open source software (Apache 2.0 license) and all modifications to the source code are publicly available.

The list of vulnerabilities is as follows. Of particular interest are vulnerabilities 1, 2, and 6, which were difficult to find without a thorough code review.

**1. CVE-2023-27395: Heap overflow in SoftEther VPN DDNS client functionality at risk of crashing and theoretically arbitrary code execution caused by a malicious man-in-the-middle attacker such like ISP-level or on national Internet communication channels**

**2. CVE-2023-22325: Integer overflow in the SoftEther VPN DDNS client functionality could result in crashing caused by a malicious man-in-the-middle attacker such like ISP-level or on national Internet communication channels**

**3. CVE-2023-32275: Vulnerability that allows the administrator himself of a 32-bit version of VPN Client or VPN Server to see the 32-bit value heap address of each of trusted CA's certificates in the VPN process**

**4. CVE-2023-27516: If the user forget to set the administrator password of SoftEther VPN Client and enable remote administration with blank password, the administrator password of VPN Client can be changed remotely or VPN client can be used remotely by anonymouse third person**

**5. CVE-2023-32634: If an attacker succeeds in launching a TCP relay program on the same port as the VPN Client on a local computer running the SoftEther VPN Client before the VPN Client process is launched, the TCP relay program can conduct a man-in-the-middle attack on communication between the administrator and the VPN Client process**

**6. CVE-2023-31192: When SoftEther VPN Client connects to an untrusted VPN Server, an invalid redirection response for the clustering (load balancing) feature causes 20 bytes of uninitialized stack space to be read**

The details are explained below.

### 1. CVE-2023-27395: Heap overflow in SoftEther VPN DDNS client functionality at risk of crashing and theoretically arbitrary code execution caused by a malicious man-in-the-middle attacker such like ISP-level or on national Internet communication channels

#### (1) Severity

CVSS v3.1: AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H (8.1)
However, as noted below, the attack requires a man-in-the-middle attack on the TCP communication between the Dynamic DNS (DDNS) client function and the DDNS server. Even in that case, arbitrary code execution has not been demonstrated, only a theoretical possibility exists. Nevertheless, we recommend updating the software as a precautionary measure.

#### (2) Overview

In the Dynamic DNS (DDNS) client function built into SoftEther VPN Server / Bridge (the same below), an attacker who succeeds in a man-in-the-middle attack on the TCP communication between the VPN Server and the DDNS server can generate a heap overflow and cause the VPN Server program to stop. The attacker must control the communication path between the VPN Server and the Internet to be able to conduct a man-in-the-middle attack. Because of the heap overflow, although usually prevented by heap address randomization and heap corruption detection possessed by the OS and runtime, the theoretical possibility exists that it can be exploited for arbitrary code execution. Therefore, an update of the VPN Server is recommended.

#### (3) Affected versions

SoftEther VPN 4.41 Build 9787 RTM and earlier

#### (4) Conditions necessary for a successful attack against this vulnerability

The attacker must have control over the Internet connection lines (ISP, WiFi, or other infrastructure) or reference DNS servers to which the VPN server is connected to the Internet, and be in a position to execute a man-in-the-middle attack that rewrites the contents of communications, such as tampering with TCP/IP communications between a dynamic DNS client and a dynamic DNS server or DNS communications preceding this.

#### (5) Details

SoftEther VPN Server has a dynamic DNS client (DDNS) function. The dynamic DNS client function periodically registers or updates itself with the dynamic DNS server.
The dynamic DNS server [https://www.softether.net/](https://www.softether.net/ "https://www.softether.net/") issues "\*\*\*\*.softether.net" (where \*\*\* is an arbitrary string desired by the user).
The communication (RPC, HTTP-based Remote Procedure Call) by the SoftEther VPN Server to register itself with the dynamic DNS server or to update its registration is performed in the background.
If an attacker meets the above "conditions," such as the attacker controlling the communication path such as the ISP line to which the VPN Server is connected to the Internet, the attacker can rewrite the contents of the RPC between the VPN Server and the dynamic DNS server, or can respond with a false RPC.
By altering or forging the RPC response and including abnormal data in the RPC response, the attacker causes a heap space overflow in the SoftEther VPN Server process that receives the response.
If the VPN Server program crashes, all users connected to the VPN Server will be disconnected and VPN communication will be unavailable until the process is restarted.
Therefore, an attacker who meets the above conditions can realize a DoS attack that disconnects VPN communication.
Note that this vulnerability is a heap area overflow, which is detected by the heap area corruption checks possessed by the OS and C runtime and causes the program to crash, but in principle, the possibility that arbitrary code execution is possible cannot be denied if an elaborate attack communication packet is created. However, neither the primary discoverer nor the developers have so far succeeded in demonstrating that arbitrary code execution is possible.
In addition to identifying and fixing the area where the heap overflow occurs, this vulnerability patch provides double prevention by changing the communication between the DNS client function and the DDNS server function, which previously used HTTP, to SSL.

### 2. CVE-2023-22325: Integer overflow in the SoftEther VPN DDNS client functionality could result in crashing caused by a malicious man-in-the-middle attacker such like ISP-level or on national Internet communication channels

#### (1) Severity

CVSS v3.1: AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H (5.9)

#### (2) Overview

In the dynamic DNS (DDNS) client function built into SoftEther VPN Server, an attacker who succeeds in a man-in-the-middle attack on the TCP communication between the VPN Server and the DDNS server can cause an integer overflow and stop only the DDNS client function part of the VPN Server program. If the DDNS client portion of the VPN Server program is stopped, even if the server's IP address changes, the change cannot be registered with the DDNS server until the VPN Server program is restarted. Then this causes a practical problem. An attacker needs to control the communication path between the VPN Server and the Internet to be able to conduct a man-in-the-middle attack.

#### (3) Affected versions

SoftEther VPN 4.41 Build 9787 RTM and earlier

#### (4) Conditions necessary for a successful attack against this vulnerability

The attacker must have control over the Internet connection lines (ISP, WiFi, or other infrastructure) or reference DNS servers to which the VPN server is connected to the Internet, and be in a position to execute a man-in-the-middle attack that rewrites the contents of communications, such as tampering with TCP/IP communications between a dynamic DNS client and a dynamic DNS server or DNS communications preceding this.

#### (5) Details

This vulnerability is similar to CVE-2023-27395. The attacker needs to send a specially crafted packet to the VPN Server to increase the maximum size of the receive buffer before tampering with the DDNS RPC response. That in itself does not cause a problem, but if the communication with the DDNS server is subsequently tampered with or the DDNS server is replaced by a false server, and the DDNS server responds with a value stating a certain large data size, the DDNS client will attempt to allocate memory space for that large data size. The DDNS client attempts to allocate memory space for that large data size. Here, an overflow on an integer variable occurs, causing a simple infinite loop and code stoppage in some DDNS client functions.
In this vulnerability patch, the part where the integer overflow occurs has been identified and fixed, and the communication between the DNS client function and the DDNS server function, which previously used HTTP, has been converted to SSL to provide a double layer of prevention.

### 3. CVE-2023-32275: Vulnerability that allows the administrator himself of a 32-bit version of VPN Client or VPN Server to see the 32-bit value heap address of each of trusted CA's certificates in the VPN process

#### (1) Severity

5.5 - CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N

#### (2) Overview

SoftEther VPN Client and SoftEther VPN Server have a function to manage the list of trusted certificate authorities (CA). The first address of the heap address that holds the certificate is responded. This is because the heap address is used as a unique ID in the memory of the certificate. This means that the administrator himself can infer the heap state from outside the VPN process without dumping the process.
Whether or not this is really a vulnerability (i.e., whether or not it is an infringement of confidentiality for the administrator who manages and controls the VPN process to be able to know the heap address of an object in the process) should be discussed, but it is true that the heap address of a certificate. The heap address of an object is important only within a single process that manages it, and outputting it outside the process is not normally expected, except for exceptional functions such as debuggers that output internal states, so we decided to fix this issue.
In the 64-bit version of SoftEther VPN, heap address is not used, so heap address is not displayed. The 64-bit version uses a hash value based on the heap address instead. However, according to the opinion of the first discoverer of the vulnerability, it is possible to use the rainbow table of hashes to guess the original heap address.

#### (3) Affected versions

SoftEther VPN 4.41 Build 9787 RTM and earlier

#### (4) Conditions necessary for a successful attack against this vulnerability

An attacker who desires to peek at the heap address must have administrative privileges to the target VPN Server or VPN Client and must be authenticated as an administrator.

#### (5) Details

In this patch, both the 32-bit and 64-bit versions have been improved to make it difficult to even create a rainbow table by using a random random number seed specific to the instance of the process when generating a unique enumeration identifier from the heap address.

### 4. CVE-2023-27516: If the user forget to set the administrator password of SoftEther VPN Client and enable remote administration with blank password, the administrator password of VPN Client can be changed remotely or VPN client can be used remotely by anonymouse third person

#### (1) Severity

7.0 - CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:L/A:L
However, the problem occurs only when the administrator forgot to set the administrator password of SoftEther VPN Client and  also enable remote administration.

#### (2) Overview

SoftEther VPN Client is divided into two parts: the main VPN Client process and the VPN Client Manager or vpncmd command line utility. The communication between the main process and the VPN Client Manager or vpncmd command line utility is done via TCP-based RPC. Normally, the VPN Client process itself and the VPN Client Manager or vpncmd command line utility reside on the same computer. Therefore, initially, they can only be controlled from the same computer (localhost, 127.0.0.1).
SoftEther VPN Client has a remote administration feature that allows the administrator to change the configuration of the VPN Client process and allow control from a remote computer (other than localhost).
If the administrator has configured the VPN Client to allow remote administration and has forgotten to set the administration password, an attacker with TCP access can connect to the VPN Client without a password, set the password without permission, and use the VPN Client functions freely. It is dangerous.

#### (3) Affected versions

SoftEther VPN 4.41 Build 9787 RTM and earlier

#### (4) Conditions necessary for a successful attack against this vulnerability

The administrator of the SoftEther VPN Client must have forgotten to set the administrator password and must have enabled remote administration. Furthermore, the VPN Client must be exposed to the Internet or otherwise able to communicate with the attacker.

#### (5) Details

This problem does not occur by default because SoftEther VPN Client is a default secure implementation and remote administration is disabled by default. However, it is possible that the administrator may forget to set the password and enable remote administration. Whether this is a vulnerability or not is a matter of debate. However, it can be assumed that a normal administrator would set a password almost 100% of the time when enabling remote management of the VPN Client. If the administrator forgets to set the password, changing the implementation so that the user authentication in remote administration is not allowed to pass has the advantage of improving security, and on the other hand, it has few disadvantages.
Therefore, we have modified the behavior of SoftEther VPN Client to prohibit remote connections if the administrator has forgotten the administrator password setting and has enabled remote administration, thereby improving security.

### 5. CVE-2023-32634: If an attacker succeeds in launching a TCP relay program on the same port as the VPN Client on a local computer running the SoftEther VPN Client before the VPN Client process is launched, the TCP relay program can conduct a man-in-the-middle attack on communication between the administrator and the VPN Client process

#### (1) Severity

7.8 - CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H

#### (2) Overview

SoftEther VPN Client is divided into two parts: the main VPN Client process and the VPN Client Manager or vpncmd command line utility. The communication between the main process and the VPN Client Manager or vpncmd command line utility is done via TCP-based RPC. Normally, the VPN Client process itself and the VPN Client Manager or vpncmd command line utility reside on the same computer. Therefore, initially, they can only be controlled from the same computer (localhost, 127.0.0.1).
Assume that an attacker has already infiltrated the local computer on which the VPN Client is running by other means (e.g., knowing the OS's user password) and can freely launch processes on the local machine. In addition, suppose that the attacker succeeds in launching a TCP relay program on the same port as the VPN Client before the VPN Client is launched. In this case, if the VPN Client is launched at a later time, the VPN Client avoids using the conflicting TCP port number and increments the TCP port number in turn, using the first free port it finds. This is referred to here as the DynamicPortListener function. In this case, the attacker's TCP relay program can accept TCP RPC connections from the administrator's VPN Client Manager and relay the communication to the true VPN Client process modified by the DynamicPortListener function. If the administrator has enabled remote administration and has set an administrator password, the TCP relay program can hijack the content of the communication after authentication.

#### (3) Affected versions

SoftEther VPN 4.41 Build 9787 RTM and earlier

#### (4) Conditions necessary for a successful attack against this vulnerability

The attacker must be able to infiltrate the computer on which the VPN Client is running by other means beforehand, and must be able to launch arbitrary programs locally.

#### (5) Details

In order for this attack to be realized, the target computer must already be logged in by the attacker and ready to execute arbitrary programs, and in practice, the threat is small.
However, there are environments where UNIX computers are SSH-shared by multiple users. And it is possible that one user may have malicious intent. In such an environment, it is desirable to have some countermeasures against this vulnerability.
In this patch, a function to enable/disable the DynamicPortListener function has been added to the VPN Client. The reason why the DynamicPortListener function is enabled by default in the Windows environment and disabled by default in the UNIX environment is that when using the VPN Client on Windows, it is usually assumed that one user occupies one terminal.
The DynamicPortListener function can be enabled/disabled by setting the DisableRpcDynamicPortListener setting value to true/false in the vpn\_client.config configuration file.

### 6. CVE-2023-31192: When SoftEther VPN Client connects to an untrusted VPN Server, an invalid redirection response for the clustering (load balancing) feature causes 20 bytes of uninitialized stack space to be read

#### (1) Severity

5.3 - CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:N

#### (2) Overview

This is a very interesting vulnerability, and the outstanding uniqueness of the first discoverer's point of view on this vulnerability is well expressed.
When the VPN Client (including the Cascade Connection function of VPN Server / Bridge) connects to the VPN Server, if the VPN Server has clustering enabled, after successful user authentication, a redirect response is returned for load balancing and fault tolerance. The redirect response contains a 20-byte one-time token code for the redirect destination called a "Ticket", which is typically copied in memory from the packet from which the VPN Client received the redirect response into a 20-byte UCHAR ticket[20] variable in the C language. If the redirection response packet does not contain a Ticket value, it is not copied. However, in this case, the variable UCHAR ticket[20] is uninitialized, and what it contains is neither defined nor predictable.
The VPN Client then connects to the VPN Server to which it was redirected, and at that time, a copy of the 20-byte UCHAR ticket[20] variable in the C language that was copied earlier is sent to the destination VPN Server as a the VPN Server is then sent a copy of the 20-byte UCHAR ticket[20] variable in the C language that was just copied. Here, the uninitialized 20-byte value is sent. This enables the destination VPN Server to obtain the value of the uninitialized 20-byte variable on the stack.

#### (3) Affected versions

SoftEther VPN 4.41 Build 9787 RTM and earlier

#### (4) Conditions necessary for a successful attack against this vulnerability

Prior to the attack, the attacker needs to induce users of the VPN Client to connect toward an unintended VPN Server by using man-in-the-middle attacks on the Internet, DNS rewriting attacks, or other techniques.
In addition, the VPN Client has a function to verify the SSL certificate of the VPN Server; if SSL certificate verification is enabled, the attacker needs to steal the private key of the SSL certificate by some means, and then launch a fake VPN Server.

#### (5) Details

This vulnerability allows a malicious VPN Server to obtain the contents of a 20-byte variable called UCHAR ticket[20] that has not been initialized when a VPN Client connects.
The question is what is in the uninitialized UCHAR ticket[20]. The contents of an uninitialized variable is undefined and unpredictable. In most cases, when the stack depth of another function called earlier is sufficient, the values of variables written in memory areas that happen to exist at the same stack depth in that other function (e.g., integer values of int i, j, k, etc. in a for loop) remain intact and are read back. This is not particularly useful information for an attacker. However, theoretically, there is a possibility that a fragment of confidential information (e.g. authentication information, heap memory address, etc.) could accidentally overlap with the 20-byte area. In this case, the attacker can read out significant information for his attack. Note that unlike higher-level languages, C language variables contain little or no meta-information (management information for managed variables) that encompasses the variable domain, so even if an attacker obtains a 20-byte value, the meaning of the contents is almost always unknown by the attacker, and the possibility of it being useful is small. Nevertheless, if there is even a small theoretical possibility that the contents of an uninitialized variable are externally exposed that could be exploited, it is important to zero-clear this as a precautionary measure to increase security as much as possible.
### New build with fixes for the above vulnerabilities

A new build was released on June 30, 2023.

* **[VPN 4.42 Build 9798 RTM](https://www.softether.org/5-download/history "Version History (ChangeLog)") or later**

---

[Japanese (日本語)](https://ja.softether.org/) | [Support](/7-forum) | [About Us](/9-about) | [University of Tsukuba](https://www.tsukuba.ac.jp/english/)
Copyright © SoftEther Project.

* [Log in](/index.php?title=Special:Userlogin&returntotitle=9-about%2FNews%2F904-SEVPN202301)

* [![](/skins/common/icons/icon-trans.gif)Templates](/Template%3A "Templates")
* [![](/skins/common/icons/icon-trans.gif)Users](/User%3A "Users")
* [![](/skins/common/icons/icon-trans.gif)Popular pages](/Special%3APopularpages "Popular pages")
* [![](/skins/common/icons/icon-trans.gif)Desktop Suite](http://www.mindtouch.com/redir/desktop-suite/ "Desktop Suite")

* ![](/skins/common/icons/icon-trans.gif)Edit page* ![](/skins/common/icons/icon-trans.gif)New page* [![](/skins/common/icons/icon-trans.gif)Save as PDF](https://www.softether.org/%40api/deki/pages/523/pdf "Save as PDF")* ![](/skins/common/icons/icon-trans.gif)Restrict access* ![](/skins/common/icons/icon-trans.gif)Attach file* ![](/skins/common/icons/icon-trans.gif)Email link* ![](/skins/common/icons/icon-trans.gif)Move page* ![](/skins/common/icons/icon-trans.gif)Delete page* ![](/skins/common/icons/icon-trans.gif)Tag* ![](/skins/common/icons/icon-trans.gif)Set page properties* [![](/skins/common/icons/icon-trans.gif)View source](/index.php?title=9-about/News/904-SEVPN202301&action=source "View source")* ![](/skins/common/icons/icon-trans.gif)Watch page

##### Table of contents

1. 1. [1. CVE-2023-27395: Heap overflow in SoftEther VPN DDNS client functionality at risk of crashing and theoretically arbitrary code execution caused by a malicious man-in-the-middle attacker such like ISP-level or on national Internet communication channels](#1._CVE-2023-27395:_Heap_overflow_in_SoftEther_VPN_DDNS_client_functionality_at_risk_of_crashing_and_theoretically_arbitrary_code_execution_caused_by_a_malicious_man-in-the-middle_attacker_such_like_ISP-level_or_on_national_Internet_communication_channels)
   1. 1.1. [(1) Severity](#(1)_Severity)
   2. 1.2. [(2) Overview](#(2)_Overview)
   3. 1.3. [(3) Affected versions](#(3)_Affected_versions)
   4. 1.4. [(4) Conditions necessary for a successful attack against this vulnerability](#(4)_Conditions_necessary_for_a_successful_attack_against_this_vulnerability)
   5. 1.5. [(5) Details](#(5)_Details)
2. 2. [2. CVE-2023-22325: Integer overflow in the SoftEther VPN DDNS client functionality could result in crashing caused by a malicious man-in-the-middle attacker such like ISP-level or on national Internet communication channels](#2._CVE-2023-22325:_Integer_overflow_in_the_SoftEther_VPN_DDNS_client_functionality_could_result_in_crashing_caused_by_a_malicious_man-in-the-middle_attacker_such_like_ISP-level_or_on_national_Internet_communication_channels)
   1. 2.1. [(1) Severity](#(1)_Severity_2)
   2. 2.2. [(2) Overview](#(2)_Overview_2)
   3. 2.3. [(3) Affected versions](#(3)_Affected_versions_2)
   4. 2.4. [(4) Conditions necessary for a successful attack against this vulnerability](#(4)_Conditions_necessary_for_a_successful_attack_against_this_vulnerability_2)
   5. 2.5. [(5) Details](#(5)_Details_2)
3. 3. [3. CVE-2023-32275: Vulnerability that allows the administrator himself of a 32-bit version of VPN Client or VPN Server to see the 32-bit value heap address of each of trusted CA's certificates in the VPN process](#3._CVE-2023-32275:_Vulnerability_that_allows_the_administrator_himself_of_a_32-bit_version_of_VPN_Client_or_VPN_Server_to_see_the_32-bit_value_heap_address_of_each_of_trusted_CA's_certificates_in_the_VPN_process)
   1. 3.1. [(1) Severity](#(1)_Severity_3)
   2. 3.2. [(2) Overview](#(2)_Overview_3)
   3. 3.3. [(3) Affected versions](#(3)_Affected_versions_3)
   4. 3.4. [(4) Conditions necessary for a successful attack against this vulnerability](#(4)_Conditions_necessary_for_a_successful_attack_against_this_vulnerability_3)
   5. 3.5. [(5) Details](#(5)_Details_3)
4. 4. [4. CVE-2023-27516: If the user forget to set the administrator password of SoftEther VPN Client and enable remote administration with blank password, the administrator password of VPN Client can be changed remotely or VPN client can be used remotely by anonymouse third person](#4._CVE-2023-27516:_If_the_user_forget_to_set_the_administrator_password_of_SoftEther_VPN_Client_and_enable_remote_administration_with_blank_password.2C_the_administrator_password_of_VPN_Client_can_be_changed_remotely_or_VPN_client_can_be_used_remotely_by_anonymouse_third_person)
   1. 4.1. [(1) Severity](#(1)_Severity_4)
   2. 4.2. [(2) Overview](#(2)_Overview_4)
   3. 4.3. [(3) Affected versions](#(3)_Affected_versions_4)
   4. 4.4. [(4) Conditions necessary for a successful attack against this vulnerability](#(4)_Conditions_necessary_for_a_successful_attack_against_this_vulnerability_4)
   5. 4.5. [(5) Details](#(5)_Details_4)
5. 5. [5. CVE-2023-32634: If an attacker succeeds in launching a TCP relay program on the same port as the VPN Client on a local computer running the SoftEther VPN Client before the VPN Client process is launched, the TCP relay program can conduct a man-in-the-middle attack on communication between the administrator and the VPN Client process](#5._CVE-2023-32634:_If_an_attacker_succeeds_in_launching_a_TCP_relay_program_on_the_same_port_as_the_VPN_Client_on_a_local_computer_running_the_SoftEther_VPN_Client_before_the_VPN_Client_process_is_launched.2C_the_TCP_relay_program_can_conduct_a_man-in-the-middle_attack_on_communication_between_the_administrator_and_the_VPN_Client_process)
   1. 5.1. [(1) Severity](#(1)_Severity_5)
   2. 5.2. [(2) Overview](#(2)_Overview_5)
   3. 5.3. [(3) Affected versions](#(3)_Affected_versions_5)
   4. 5.4. [(4) Conditions necessary for a successful attack against this vulnerability](#(4)_Conditions_necessary_for_a_successful_attack_against_this_vulnerability_5)
   5. 5.5. [(5) Details](#(5)_Details_5)
6. 6. [6. CVE-2023-31192: When SoftEther VPN Client connects to an untrusted VPN Server, an invalid redirection response for the clustering (load balancing) feature causes 20 bytes of uninitialized stack space to be read](#6._CVE-2023-31192:_When_SoftEther_VPN_Client_connects_to_an_untrusted_VPN_Server.2C_an_invalid_redirection_response_for_the_clustering_(load_balancing)_feature_causes_20_bytes_of_uninitialized_stack_space_to_be_read)
   1. 6.1. [(1) Severity](#(1)_Severity_6)
   2. 6.2. [(2) Overview](#(2)_Overview_6)
   3. 6.3. [(3) Affected versions](#(3)_Affected_versions_6)
   4. 6.4. [(4) Conditions necessary for a successful attack against this vulnerability](#(4)_Conditions_necessary_for_a_successful_attack_against_this_vulnerability_6)
   5. 6.5. [(5) Details](#(5)_Details_6)
7. 7.  [New build with fixes for the above vulnerabilities](#New_build_with_fixes_for_the_above_vulnerabilities)

* dismiss message
* view details

Message will close by itself in  seconds
Message timer has been stopped

Viewing Details:



=== Content from talosintelligence.com_36f6bb94_20250110_230530.html ===


* [Cisco Login](/users/auth/saml)

* [Intelligence Center](/reputation)

  + [# Intelligence Center](/reputation)
  + BACK
  + [Intelligence Search](/reputation_center)
  + [Email & Spam Trends](/reputation_center/email_rep)
* [Vulnerability Research](/vulnerability_info)

  + [# Vulnerability Research](/vulnerability_info)
  + BACK
  + [Vulnerability Reports](/vulnerability_reports)
  + [Microsoft Advisories](/ms_advisories)
* [Incident Response](/incident_response)

  + [# Incident Response](/incident_response)
  + BACK
  + [Reactive Services](/incident_response/services#reactive-services)
  + [Proactive Services](/incident_response/services#proactive-services)
  + Emergency Support
* [Blog](https://blog.talosintelligence.com)
* [Support](https://support.talosintelligence.com)

More

* Security Resources

  # Security Resources

  + BACK
  Security Resources
  + [Open Source Security Tools](/software)
  + [Intelligence Categories Reference](/categories)
  + [Secure Endpoint Naming Reference](/secure-endpoint-naming)
* Media

  # Media

  + BACK
  Media
  + [Talos Intelligence Blog](https://blog.talosintelligence.com)
  + [Threat Source Newsletter](https://blog.talosintelligence.com/category/threat-source-newsletter/)
  + [Beers with Talos Podcast](/podcasts/shows/beers_with_talos)
  + [Talos Takes Podcast](/podcasts/shows/talos_takes)
  + [Talos Videos](https://www.youtube.com/channel/UCPZ1DtzQkStYBSG3GTNoyfg/featured)
* Company

  # Company

  + BACK
  Company
  + [About Talos](/about)
  + [Careers](/careers)

* Under Attack?
* [Cisco Login](/users/auth/saml)

## Contact Cisco Talos Incident Response

×

Close

This form is for Incident Response service inquiries only, including emergency network security needs.

For reputation or categorization inquiries, visit the [Talos Support site](/support).
For emergency DDoS mitigation assistance, please contact the [Cisco Secure DDoS Protection Team](https://www.cisco.com/c/en/us/products/collateral/security/ddos-emergency-attack-mitigation-aag.pdf).

Name

Company (optional)

Email address

Phone number

Preferred communication:

Email

Phone

What Incident Response Service are you interested in?
General Talos IR services and retainer information
Emergency Response
IR Plan
IR Playbooks
IR Readiness Assessment
Tabletop Exercises
Compromise Assessment
Threat Hunting
Cyber Range Training
Intelligence on Demand

Please provide as much detail as possible so we can best address your needs

I acknowledge that this is an inquiry for Incident Response services and that any other use of this form will not receive a response.

Send Email
Cancel

# Talos Vulnerability Report

### TALOS-2023-1736

## SoftEther VPN DCRegister DDNS\_RPC\_MAX\_RECV\_SIZE denial of service vulnerability

##### October 12, 2023

##### CVE Number

CVE-2023-22325

##### SUMMARY

A denial of service vulnerability exists in the DCRegister DDNS\_RPC\_MAX\_RECV\_SIZE functionality of SoftEther VPN 4.41-9782-beta, 5.01.9674 and 5.02. A specially crafted network packet can lead to denial of service. An attacker can perform a man-in-the-middle attack to trigger this vulnerability.

##### CONFIRMED VULNERABLE VERSIONS

The versions below were either tested or verified to be vulnerable by Talos or confirmed to be vulnerable by the vendor.

SoftEther VPN 4.41-9782-beta

SoftEther VPN 5.01.9674

SoftEther VPN 5.02

While 5.01.9674 is a development version, it is distributed at the time of writing by Ubuntu and other Debian-based distributions.

##### PRODUCT URLS

SoftEther VPN - <https://www.softether.org/>

##### CVSSv3 SCORE

5.9 - CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H

##### CWE

CWE-835 - Loop with Unreachable Exit Condition (‘Infinite Loop’)

##### DETAILS

SoftEther is a multi-platform VPN project that provides both server and client code to connect over a variety of VPN protocols, including Wireguard, PPTP, SSTP, L2TP, etc. SoftEther has a variety of features for both enterprise and personal use, and enables Nat Traversal out-of-the-box for remote-access setups behind firewalls.

By default when SoftEther VPN server is run, the server registers itself with `ddns.softether-network.net`, such that the VPN server can traverse NAT out-of-the-box and be reachable through firewalls immediately. A specific thread is designated for this task, and it will henceforth be referred to as the DDNS client thread due to the function name designating this code path:

```
// DDNS client thread
void DCThread(THREAD *thread, void *param)
{
    DDNS_CLIENT *c;
    INTERRUPT_MANAGER *interrupt;
    // [...]
    // Validate arguments
    if (thread == NULL || param == NULL)
    {
        return;
    }

    c = (DDNS_CLIENT *)param;

    // [...]
    while (c->Halt == false){

    // [...]

    // IPv4 host registration
    if (c->NextRegisterTick_IPv4 == 0 || now >= c->NextRegisterTick_IPv4)
    {
        UINT next_interval;

        c->Err_IPv4 = DCRegister(c, false, NULL, NULL);

        if (c->Err_IPv4 == ERR_NO_ERROR)
        {
            next_interval = GenRandInterval(DDNS_REGISTER_INTERVAL_OK_MIN, DDNS_REGISTER_INTERVAL_OK_MAX);
        }
        else
        {
            next_interval = GenRandInterval(DDNS_REGISTER_INTERVAL_NG_MIN, DDNS_REGISTER_INTERVAL_NG_MAX);
        }
        //next_interval = 0;

        c->NextRegisterTick_IPv4 = Tick64() + (UINT64)next_interval;

        if (true)
        {
            DDNS_CLIENT_STATUS st;

            DCGetStatus(c, &st);

            SiApplyAzureConfig(c->Cedar->Server, &st);
        }

        AddInterrupt(interrupt, c->NextRegisterTick_IPv4);
    }

```

As long as the `DDNS_CLIENT` object never has its `Halt` flag set, we continuously loop through the different timers, checking to see if our public facing IP addresses have changed or not, so we know if we need to update the public SoftEther DDNS server’s settings for our hostname. This basic IP address checking is simple unencrypted traffic over UDP port 5004, and is not too interesting, but the other DDNS traffic that gets sent is also unencrypted and is a lot more useful. Continuing in DCThread:

```
// DDNS client thread
void DCThread(THREAD *thread, void *param)
{
    // [...]
            // IPv4 host registration
    if (c->NextRegisterTick_IPv4 == 0 || now >= c->NextRegisterTick_IPv4)
    {
        UINT next_interval;

        c->Err_IPv4 = DCRegister(c, false, NULL, NULL); // [1]

        if (c->Err_IPv4 == ERR_NO_ERROR)
        {
            next_interval = GenRandInterval(DDNS_REGISTER_INTERVAL_OK_MIN, DDNS_REGISTER_INTERVAL_OK_MAX);
        }
        else
        {
            next_interval = GenRandInterval(DDNS_REGISTER_INTERVAL_NG_MIN, DDNS_REGISTER_INTERVAL_NG_MAX);
        }
        //next_interval = 0;

        c->NextRegisterTick_IPv4 = Tick64() + (UINT64)next_interval;

        if (true)
        {
            DDNS_CLIENT_STATUS st;

            DCGetStatus(c, &st);

            SiApplyAzureConfig(c->Cedar->Server, &st);
        }

        AddInterrupt(interrupt, c->NextRegisterTick_IPv4);
    }

```

Assuming that our IP address has changed, or the timeout has occurred, or even if our server is just starting, we end up hitting the `DCRegister` [1] function, which contains more of the actual network packet processing:

```
// Execution of registration
UINT DCRegister(DDNS_CLIENT *c, bool ipv6, DDNS_REGISTER_PARAM *p, char *replace_v6)
{
    char *url;
    char url2[MAX_SIZE];
    char url3[MAX_SIZE];
    PACK *req, *ret;
    char key_str[MAX_SIZE];
    UCHAR machine_key[SHA1_SIZE];
    char machine_key_str[MAX_SIZE];
    char machine_name[MAX_SIZE];
    BUF *cert_hash = NULL;
    UINT err = ERR_INTERNAL_ERROR;
    UCHAR key_hash[SHA1_SIZE];
    char key_hash_str[MAX_SIZE];
    bool use_azure = false;
    char current_azure_ip[MAX_SIZE];
    INTERNET_SETTING t;
    UINT build = 0;
    char add_header_name[64];
    char add_header_value[64];
    // Validate arguments
    if (c == NULL)
    {
        return ERR_INTERNAL_ERROR;
    }

    // [...]

    Format(url2, sizeof(url2), "%s?v=%I64u", url, Rand64());
    Format(url3, sizeof(url3), url2, key_hash_str[2], key_hash_str[3]);

    ReplaceStr(url3, sizeof(url3), url3, "https://", "http://");

    ReplaceStr(url3, sizeof(url3), url3, ".servers", ".open.servers");

    cert_hash = StrToBin(DDNS_CERT_HASH);

    Debug("WpcCall: %s\n", url3);
    ret = WpcCallEx2(url3, &t, DDNS_CONNECT_TIMEOUT, DDNS_COMM_TIMEOUT, "register", req,  // [2]
        NULL, NULL, ((cert_hash != NULL && ((cert_hash->Size % SHA1_SIZE) == 0)) ? cert_hash->Buf : NULL),
        (cert_hash != NULL ? cert_hash->Size / SHA1_SIZE : 0),
        NULL, DDNS_RPC_MAX_RECV_SIZE,   // dyn32, (128 * 1024 * 1024)...
        add_header_name, add_header_value,
        DDNS_SNI_VER_STRING);
    Debug("WpcCall Ret: %u\n", ret);

    FreeBuf(cert_hash);

    FreePack(req);

    err = GetErrorFromPack(ret);

    ExtractAndApplyDynList(ret);  // [3]

```

We can ignore most of the initialization code. For our purposes, we only really care that the `WpcCallEx2` function reaches out to a DNS name like `xc.xi.dev.open.servers.ddns.softether-network.net` and sends an unencrypted UDP request that asks for a NAT traversal token looking like so:

```
0000   00 00 00 03 00 00 00 07 6f 70 63 6f 64 65 00 00   ........opcode..
0010   00 02 00 00 00 01 00 00 00 09 67 65 74 5f 74 6f   ..........get_to
0020   6b 65 6e 00 00 00 08 74 72 61 6e 5f 69 64 00 00   ken....tran_id..
0030   00 04 00 00 00 01 11 55 11 bb aa 87 e8 55 00 00   ................
0040   00 16 6e 61 74 5f 74 72 61 76 65 72 73 61 6c 5f   ..nat_traversal_
0050   76 65 72 73 69 6f 6e 00 00 00 00 00 00 00 01 00   version.........
0060   00 00 01                                          ...

```

Before going further we must briefly describe the simple TLV protocol format here, which looks like:

```
struct packed_item {
    size_t namelen;
    char name[namelen+1];
    uint32_t value_type;  // [4]
    // value/data
}

struct packed_buffer {
    uint32_t number_of_items;
    struct packed_item[number_of_items];
}

```

The value types for each item in the buffer [4] can be `VALUE_INT`, `VALUE_DATA`, `VALUE_STR`, `VALUE_UNISTR` or `VALUE_INT64`, which is then followed immediately by the item itself. Their size and format is dependent on the type. Regardless, this packed buffer packet data is from the response to `WpcCallEx2` [2], which then gets fed into the `ExtractAndApplyDynList` function at [3]:

```
// Apply by extracting dynamic value list from the specified PACK
void ExtractAndApplyDynList(PACK *p)
{
    BUF *b;
    // Validate arguments
    if (p == NULL)
    {
        return;
    }

    b = PackGetBuf(p, "DynList"); // [4]
    if (b == NULL)
    {
        return;
    }

    AddDynList(b);  // [5]

    FreeBuf(b);
}

```

This function tries to unpack the `DynList` item from the response buffer as another nested packed buffer and then passes this validated buffer into `AddDynList` [5]:

```
// Insert the data to the dynamic value list
void AddDynList(BUF *b)
{
    PACK *p;
    TOKEN_LIST *t;
    // Validate arguments
    if (b == NULL)
    {
        return;
    }

    SeekBufToBegin(b);

    p = BufToPack(b);  // [6]
    if (p == NULL)
    {
        return;
    }

    t = GetPackElementNames(p);
    if (t != NULL)
    {
        UINT i;

        for (i = 0; i < t->NumTokens; i++) // [7]
        {
            char *name = t->Token[i];
            UINT64 v = PackGetInt64(p, name);

            SetDynListValue(name, v); // [8]
        }

        FreeToken(t);
    }

    FreePack(p);
}

```

At [6], the input buffer (which is essentially a C++ std::string) is parsed to make sure it follows the “packed\_buffer” format as mentioned above. It then walks the names of each of the items at [7] and passes the name and value (assuming it’s a UINT64) into the `SetDynListValue` function at [8]:

```
// Set the value to the dynamic value list
void SetDynListValue(char *name, UINT64 value)
{
    // Validate arguments
    if (name == NULL)
    {
        return;
    }

    if (g_dyn_value_list == NULL)
    {
        return;
    }

    LockList(g_dyn_value_list);
    {
        UINT i;
        DYN_VALUE *v = NULL;

        for (i = 0; i < LIST_NUM(g_dyn_value_list); i++)
        {
            DYN_VALUE *vv = LIST_DATA(g_dyn_value_list, i);  // [9]

            if (StrCmpi(vv->Name, name) == 0)
            {
                v = vv;
                break;
            }
        }

        if (v == NULL)
        {
            v = ZeroMalloc(sizeof(DYN_VALUE)); // DYN_VALUE == { char[256], uint64_t }
            StrCpy(v->Name, sizeof(v->Name), name);

            Add(g_dyn_value_list, v);
        }

        v->Value = value;
    }
    UnlockList(g_dyn_value_list);
}

```

Finally getting somewhat to the core of the matter, `SetDynListValue` safely walks the `g_dyn_value_list` global list to see if the name matches any existing items. If so, we replace the value. If not, we allocate a new item and add it to the list. But this begs the questions of “what is in the `g_dyn_value_list`?” and “what are these items used for?”. The only place values are read out of this list is via the `DYN64` macro as follows:

```
#define       DYN32(id, default_value)        (UINT)DYN64(id, (UINT)default_value)
#define DYN64(id, default_value)    ( (UINT64)GetDynValueOrDefaultSafe ( #id , (UINT64)( default_value )))

```

Which then points us to `GetDynValueOrDefaultSafe`:

```
UINT64 GetDynValueOrDefaultSafe(char *name, UINT64 default_value)
{
    return GetDynValueOrDefault(name, default_value, default_value / (UINT64)5, default_value * (UINT64)50);
}

```

This call to `DYN32` is used in a number of places that all deal with either NAT-T or DDNS, but to save bandwidth, here are just the DDNS occurrences:

```
Cedar/DDNS.h:#define    DDNS_RPC_MAX_RECV_SIZE                                  DYN32(DDNS_RPC_MAX_RECV_SIZE, (128 * 1024 * 1024))  // [10]
Cedar/DDNS.h:#define    DDNS_CONNECT_TIMEOUT                                    DYN32(DDNS_CONNECT_TIMEOUT, (15 * 1000))
Cedar/DDNS.h:#define    DDNS_COMM_TIMEOUT                                       DYN32(DDNS_COMM_TIMEOUT, (60 * 1000))
Cedar/DDNS.h:#define    DDNS_REGISTER_INTERVAL_OK_MIN                           DYN32(DDNS_REGISTER_INTERVAL_OK_MIN, (1 * 60 * 60 * 1000))
Cedar/DDNS.h:#define    DDNS_REGISTER_INTERVAL_OK_MAX                           DYN32(DDNS_REGISTER_INTERVAL_OK_MAX, (2 * 60 * 60 * 1000))
Cedar/DDNS.h:#define    DDNS_REGISTER_INTERVAL_NG_MIN                           DYN32(DDNS_REGISTER_INTERVAL_NG_MIN, (1 * 60 * 1000))
Cedar/DDNS.h:#define    DDNS_REGISTER_INTERVAL_NG_MAX                           DYN32(DDNS_REGISTER_INTERVAL_NG_MAX, (5 * 60 * 1000))
Cedar/DDNS.h:#define    DDNS_GETMYIP_INTERVAL_OK_MIN                            DYN32(DDNS_GETMYIP_INTERVAL_OK_MIN, (10 * 60 * 1000))
Cedar/DDNS.h:#define    DDNS_GETMYIP_INTERVAL_OK_MAX                            DYN32(DDNS_GETMYIP_INTERVAL_OK_MAX, (20 * 60 * 1000))
Cedar/DDNS.h:#define    DDNS_GETMYIP_INTERVAL_NG_MIN                            DYN32(DDNS_GETMYIP_INTERVAL_NG_MIN, (1 * 60 * 1000))
Cedar/DDNS.h:#define    DDNS_GETMYIP_INTERVAL_NG_MAX                            DYN32(DDNS_GETMYIP_INTERVAL_NG_MAX, (5 * 60 * 1000))
Cedar/DDNS.h:#define    DDNS_VPN_AZURE_CONNECT_ERROR_DDNS_RETRY_TIME_DIFF       DYN32(DDNS_VPN_AZURE_CONNECT_ERROR_DDNS_RETRY_TIME_DIFF, (120 * 1000))
Cedar/DDNS.h:#define    DDNS_VPN_AZURE_CONNECT_ERROR_DDNS_RETRY_TIME_DIFF_MAX   DYN32(DDNS_VPN_AZURE_CONNECT_ERROR_DDNS_RETRY_TIME_DIFF_MAX, (10 * 60 * 1000))

```

Out of all of these, we’ve actually already seen one before in the source above: `DDNS_RPC_MAX_RECV_SIZE` [10] up in the `DCRegister` function:

```
// Execution of registration
UINT DCRegister(DDNS_CLIENT *c, bool ipv6, DDNS_REGISTER_PARAM *p, char *replace_v6)
{

    // [...]
    ret = WpcCallEx2(url3, &t, DDNS_CONNECT_TIMEOUT, DDNS_COMM_TIMEOUT, "register", req,   // okay, at least 1 bug, maybe 2.
        NULL, NULL, ((cert_hash != NULL && ((cert_hash->Size % SHA1_SIZE) == 0)) ? cert_hash->Buf : NULL),
        (cert_hash != NULL ? cert_hash->Size / SHA1_SIZE : 0),
        NULL, DDNS_RPC_MAX_RECV_SIZE,   // dyn32, (128 * 1024 * 1024)...
        add_header_name, add_header_value,
        DDNS_SNI_VER_STRING);

    // [...]

/*
PACK *WpcCallEx2(char *url, INTERNET_SETTING *setting, UINT timeout_connect, UINT timeout_comm,
            char *function_name, PACK *pack, X *cert, K *key, void *sha1_cert_hash, UINT num_hashes, bool *cancel, UINT max_recv_size,
            char *additional_header_name, char *additional_header_value, char *sni_string)
*/

```

The `DDNS_RPC_MAX_RECV_SIZE` dynamic list item is used as the `UINT max_recv_size` inside of `WpcCallEx2`, so following exactly how that parameter is used:

```
PACK *WpcCallEx2(char *url, INTERNET_SETTING *setting, UINT timeout_connect, UINT timeout_comm,
                char *function_name, PACK *pack, X *cert, K *key, void *sha1_cert_hash, UINT num_hashes, bool *cancel, UINT max_recv_size,
                char *additional_header_name, char *additional_header_value, char *sni_string)
{

    // [...]
    recv = HttpRequestEx3(&data, setting, timeout_connect, timeout_comm, &error,
        false, b->Buf, NULL, NULL, sha1_cert_hash, num_hashes, cancel, max_recv_size, // [11]
        NULL, NULL);

```

It gets eventually passed into the `HttpRequestEx3` function at [11] and used as follows:

```
BUF *HttpRequestEx3(URL_DATA *data, INTERNET_SETTING *setting,
                    UINT timeout_connect, UINT timeout_comm,
                    UINT *error_code, bool check_ssl_trust, char *post_data,
                    WPC_RECV_CALLBACK *recv_callback, void *recv_callback_param, void *sha1_cert_hash, UINT num_hashes,
                    bool *cancel, UINT max_recv_size, char *header_name, char *header_value)
{
    /// [...]

CONT:
    // Receive
    h = RecvHttpHeader(s);    // [12]
    if (h == NULL)
    {
        Disconnect(s);
        ReleaseSock(s);

        *error_code = ERR_DISCONNECTED;

        return NULL;
    }

    http_error_code = 0;
    if (StrLen(h->Method) == 8)
    {
        if (Cmp(h->Method, "HTTP/1.", 7) == 0)
        {
            http_error_code = ToInt(h->Target);
        }
    }

    *error_code = ERR_NO_ERROR;

    switch (http_error_code) { ... }
    // [...]

    // Get the length of the content
    content_len = GetContentLength(h); //
    if (max_recv_size != 0)
    {
        content_len = MIN(content_len, max_recv_size); // [13]
    }

    FreeHttpHeader(h);

    socket_buffer = Malloc(socket_buffer_size); // 64000

    // Receive the content
    recv_buf = NewBuf();

    while (true)
    {
        UINT recvsize = MIN(socket_buffer_size, content_len - recv_buf->Size); // [14]
        UINT size;

        if (recv_callback != NULL) // generally null
        {
            if (recv_callback(recv_callback_param,
                content_len, recv_buf->Size, recv_buf) == false)
            {
                // Cancel the reception
                *error_code = ERR_USER_CANCEL;
                goto RECV_CANCEL;
            }
        }

        if (recvsize == 0)
        {
            break;
        }

        size = Recv(s, socket_buffer, recvsize, s->SecureMode);  // [15]
        if (size == 0)
        {
            // Disconnected
            *error_code = ERR_DISCONNECTED;

RECV_CANCEL:
            FreeBuf(recv_buf);
            Free(socket_buffer);
            Disconnect(s);
            ReleaseSock(s);

            return NULL;
        }

        WriteBuf(recv_buf, socket_buffer, size); // [16]
    }

```

After sending an inconsequential HTTP request unencrypted above [12], we finally see our `max_recv_size` at [13], as it is used to determine the `content_len` of the response. After this, we just keep receiving bytes at [15] until we have read in `content_len - recv_buf->Size` bytes [14]. After receiving the bytes, they are written from the `socket_buffer` into the `Buffer *recv_buf` at [16], which essentially acts as an `std::string`. But how many bytes can this buffer actually hold? Normally these `Buffer *` objects will keep doubling in size every time they reach capacity inside `WriteBuf`:

```
// Adjusting the buffer size
void AdjustBufSize(BUF *b, UINT new_size)
{
    // Validate arguments
    if (b == NULL)
    {
        return;
    }

    if (b->SizeReserved >= new_size)
    {
        return;
    }

    while (b->SizeReserved < new_size)        // [17]
    {
        b->SizeReserved = b->SizeReserved * 2;
    }
    b->Buf = ReAlloc(b->Buf, b->SizeReserved);

    // KS
    KS_INC(KS_ADJUST_BUFSIZE_COUNT);
}

```

Curiously, the doubling continuously occurs inside of the while loop at [17], presumably in case the `new_size` is significantly larger. Regardless, this design decision will become important soon. Another point to note about `AdjustBufSize` is that both `b->SizeReserved` and `new_size` are `UINT` sized, i.e. 32-bits. Also, since every buffer starts out with 0x2800 bytes for `b->SizeReserved`, if `new_size` is ever greater than 0x80000000, then the while statement at [17] turns into an infinite loop since `(0x2800 << 20) == 0x80000000`. If we hit the loop one more time, `b->SizeReserved` overflows to 0x1, restarting the whole process.

With the vulnerability explained, we have to quickly figure out how to get a `new_size` that’s greater than 0x80000000. This problem turns out to be a lot simpler than expected, as we simply need to keep expanding a buffer to reach this point. Thus, if we remember from [13], `content_len = MIN(content_len, max_recv_size);`, so the minimum of the `content_len` and `max_recv_size` is how large our resulting buffer is. Content length is the easier one, since it’s simply read in from the HTTP response’s headers. To get our `max_recv_size` where we need it, we have to set the `DDNS_RPC_MAX_RECV_SIZE` global dynamic list variable via a different request (this can be achieved via `RUDPProcess_NatT_Recv` UDP traffic, also MITM’able). Since `DYN64` ends up eventually resulting in ` GetDynValueOrDefault(name, default\_value, default\_value / (UINT64)5, default\_value \* (UINT64)50); `as listed above, and also because the default` DDNS\_RPC\_MAX\_RECV\_SIZE `is` 128 \* 1024 \* 1024 `(0x8000000), any value we assign to` DDNS\_RPC\_MAX\_RECV\_SIZE `that is over 0x8000000 will result in` 128 \* 1024 \* 1024 \* 50` (0x190000000) being returned as the value (since it’s the ‘safe’ upper-bound), which is over the 0x80000000 limit that we need to cause the infinite loop. Even though 0x190000000 gets truncated to 0x90000000 due to UINT32 variables being used, we get lucky that 0x90000000 is still greater than 0x80000000.

Thus, in summary, we assign `DDNS_RPC_MAX_RECV_SIZE` to anything over 0x8000000 via the unencrypted NAT-T UDP traffic. We then respond to an unencrypted HTTP request with an HTTP response that has a Content-Length greater than 0x80000000. Finally, we have to send at least 0x80000000 bytes for our buffer to expand, resulting in an infinite loop and disabling of SoftEther’s DDNS thread. While only denying service to a single thread, the server would become inaccessible through NAT or firewalls, denying one of the major use-cases of this product.

### Crash Information

```
 Thread 26 (Thread 0x7f861c049380 (LWP 8103) "vpnserver"):
#0  AdjustBufSize (b=0x7f85b800f680, new_size=2684416000) at /softether/SoftEtherVPN_orig/src/Mayaqua/Memory.c:3117
#1  0x00007f861d3e8978 in WriteBuf (size=64000, buf=0x7f85b8015eb0, b=0x7f85b800f680) at /softether/SoftEtherVPN_orig/src/Mayaqua/Memory.c:2758
#2  WriteBuf (b=0x7f85b800f680, buf=0x7f85b8015eb0, size=64000) at /softether/SoftEtherVPN_orig/src/Mayaqua/Memory.c:2745
#3  0x00007f861d5c393a in HttpRequestEx3 (data=data@entry=0x7f861c042be0, setting=setting@entry=0x7f861c043f80, timeout_connect=timeout_connect@entry=15000, timeout_comm=timeout_comm@entry=60000, error_code=error_code@entry=0x7f861c042b2c, check_ssl_trust=check_ssl_trust
@entry=false, post_data=0x7f85b8013690 "PACK0000"..., recv_callback=0x0, recv_c
allback_param=0x0, sha1_cert_hash=<optimized out>, num_hashes=<optimized out>, cancel=0x0, max_recv_size=4294967295, header_name=0x0, header_value=0x0) at /softether/SoftEtherVPN_orig/src/Cedar/Wpc.c:966
#4  0x00007f861d5c4849 in WpcCallEx2 (url=url@entry=0x7f861c0449d0 "http://xx.xx.dev.open.servers-v6.ddns.softether-network.net/ddns/ddns.aspx?v=22222222222", setting=setting@entry=0x7f861c043f80, timeout_connect=15000, timeout_comm=timeout_comm@entry=60000, func
tion_name=function_name@entry=0x7f861d5d2eeb "register", pack=pack@entry=0x7f85b8007b90, cert=0x0, key=0x0, sha1_cert_hash=0x7f85b800c820, num_hashes=5, cancel=0x0, max_recv_size=4294967295, additional_header_name=0x7f861c0446d0 "", additional_header_value=0x7f861c044710 "", sni_string=0x7f861d5d2dbe "DDNS") at /softether/SoftEtherVPN_orig/src/Cedar/Wpc.c:116
#5  0x00007f861d53842d in DCRegister (c=c@entry=0x5615c7e8f2d0, ipv6=ipv6@entry=true, p=p@entry=0x0, replace_v6=replace_v6@entry=0x0) at /softether/SoftEtherVPN_orig/src/Cedar/DDNS.c:556
#6  0x00007f861d538cce in DCThread (param=0x5615c7e8f2d0, thread=<optimized out>) at /softether/SoftEtherVPN_orig/src/Cedar/DDNS.c:346
#7  0x00007f861d3e143d in ThreadPoolProc (param=0x5615c7e86bb0, t=0x5615c7e8edd0) at /softether/SoftEtherVPN_orig/src/Mayaqua/Kernel.c:872
#8  ThreadPoolProc (t=0x5615c7e8edd0, param=0x5615c7e86bb0) at /softether/SoftEtherVPN_orig/src/Mayaqua/Kernel.c:827
#9  0x00007f861d41d7d1 in UnixDefaultThreadProc (param=0x5615c7e8f060) at /softether/SoftEtherVPN_orig/src/Mayaqua/Unix.c:1594
#10 0x00007f861d094b43 in start_thread (arg=<optimized out>) at ./nptl/pthread_create.c:442
#11 0x00007f861d126a00 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81

```
##### VENDOR RESPONSE

The vendor issued an advisory:
https://www.softether.org/9-about/News/904-SEVPN202301

##### TIMELINE

2023-04-03 - Vendor Disclosure

2023-04-03 - Initial Vendor Contact

2023-06-30 - Vendor Patch Release

2023-10-12 - Public Release

##### Credit

Discovered by Lilith >\_> of Cisco Talos.

---

[Vulnerability Reports](/vulnerability_reports) [Next Report

TALOS-2023-1735](/vulnerability_reports/TALOS-2023-1735) [Previous Report

TALOS-2023-1737](/vulnerability_reports/TALOS-2023-1737)

* + ###### [Intelligence Center](/reputation)
  + [Intelligence Search](/reputation_center)
  + [Email & Spam Trends](/reputation_center/email_rep)
* + ###### [Vulnerability Research](/vulnerability_info)
  + [Vulnerability Reports](/vulnerability_reports)
  + [Microsoft Advisories](/ms_advisories)
* + ###### [Incident Response](/incident_response)
  + [Reactive Services](/incident_response/services#reactive-services)
  + [Proactive Services](/incident_response/services#proactive-services)
  + Emergency Support
* + ###### Security Resources
  + [Open Source Security Tools](/software)
  + [Intelligence Categories Reference](/categories)
  + [Secure Endpoint Naming Reference](/secure-endpoint-naming)
* + ###### Media
  + [Talos Intelligence Blog](https://blog.talosintelligence.com)
  + [Threat Source Newsletter](https://blog.talosintelligence.com/category/threat-source-newsletter/)
  + [Beers with Talos Podcast](/podcasts/shows/beers_with_talos)
  + [Talos Takes Podcast](/podcasts/shows/talos_takes)
  + [Talos Videos](https://www.youtube.com/channel/UCPZ1DtzQkStYBSG3GTNoyfg/featured)
* + ###### Support
  + [Support Documentation](https://support.talosintelligence.com)
* + ###### Company
  + [About Talos](/about)
  + [Careers](/careers)
  + [Cisco Security](https://www.cisco.com/c/en/us/products/security/product-listing.html)

###### Follow us

[![Cisco](/assets/logo_cisco_white-d87b7f7d3152ad412e48aad924a972cc5b802b7a53cb56b0792a4456c9b7b3a5.svg)](http://tools.cisco.com/security/center/home.x)

©
2025
Cisco Systems, Inc. and/or its affiliates. All rights
reserved. View our
[Privacy Policy.](http://www.cisco.com/web/siteassets/legal/privacy_full.html)



=== Content from www.talosintelligence.com_6e5f5cfc_20250110_230533.html ===


* [Cisco Login](/users/auth/saml)

* [Intelligence Center](/reputation)

  + [# Intelligence Center](/reputation)
  + BACK
  + [Intelligence Search](/reputation_center)
  + [Email & Spam Trends](/reputation_center/email_rep)
* [Vulnerability Research](/vulnerability_info)

  + [# Vulnerability Research](/vulnerability_info)
  + BACK
  + [Vulnerability Reports](/vulnerability_reports)
  + [Microsoft Advisories](/ms_advisories)
* [Incident Response](/incident_response)

  + [# Incident Response](/incident_response)
  + BACK
  + [Reactive Services](/incident_response/services#reactive-services)
  + [Proactive Services](/incident_response/services#proactive-services)
  + Emergency Support
* [Blog](https://blog.talosintelligence.com)
* [Support](https://support.talosintelligence.com)

More

* Security Resources

  # Security Resources

  + BACK
  Security Resources
  + [Open Source Security Tools](/software)
  + [Intelligence Categories Reference](/categories)
  + [Secure Endpoint Naming Reference](/secure-endpoint-naming)
* Media

  # Media

  + BACK
  Media
  + [Talos Intelligence Blog](https://blog.talosintelligence.com)
  + [Threat Source Newsletter](https://blog.talosintelligence.com/category/threat-source-newsletter/)
  + [Beers with Talos Podcast](/podcasts/shows/beers_with_talos)
  + [Talos Takes Podcast](/podcasts/shows/talos_takes)
  + [Talos Videos](https://www.youtube.com/channel/UCPZ1DtzQkStYBSG3GTNoyfg/featured)
* Company

  # Company

  + BACK
  Company
  + [About Talos](/about)
  + [Careers](/careers)

* Under Attack?
* [Cisco Login](/users/auth/saml)

## Contact Cisco Talos Incident Response

×

Close

This form is for Incident Response service inquiries only, including emergency network security needs.

For reputation or categorization inquiries, visit the [Talos Support site](/support).
For emergency DDoS mitigation assistance, please contact the [Cisco Secure DDoS Protection Team](https://www.cisco.com/c/en/us/products/collateral/security/ddos-emergency-attack-mitigation-aag.pdf).

Name

Company (optional)

Email address

Phone number

Preferred communication:

Email

Phone

What Incident Response Service are you interested in?
General Talos IR services and retainer information
Emergency Response
IR Plan
IR Playbooks
IR Readiness Assessment
Tabletop Exercises
Compromise Assessment
Threat Hunting
Cyber Range Training
Intelligence on Demand

Please provide as much detail as possible so we can best address your needs

I acknowledge that this is an inquiry for Incident Response services and that any other use of this form will not receive a response.

Send Email
Cancel

# Talos Vulnerability Report

### TALOS-2023-1736

## SoftEther VPN DCRegister DDNS\_RPC\_MAX\_RECV\_SIZE denial of service vulnerability

##### October 12, 2023

##### CVE Number

CVE-2023-22325

##### SUMMARY

A denial of service vulnerability exists in the DCRegister DDNS\_RPC\_MAX\_RECV\_SIZE functionality of SoftEther VPN 4.41-9782-beta, 5.01.9674 and 5.02. A specially crafted network packet can lead to denial of service. An attacker can perform a man-in-the-middle attack to trigger this vulnerability.

##### CONFIRMED VULNERABLE VERSIONS

The versions below were either tested or verified to be vulnerable by Talos or confirmed to be vulnerable by the vendor.

SoftEther VPN 4.41-9782-beta

SoftEther VPN 5.01.9674

SoftEther VPN 5.02

While 5.01.9674 is a development version, it is distributed at the time of writing by Ubuntu and other Debian-based distributions.

##### PRODUCT URLS

SoftEther VPN - <https://www.softether.org/>

##### CVSSv3 SCORE

5.9 - CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H

##### CWE

CWE-835 - Loop with Unreachable Exit Condition (‘Infinite Loop’)

##### DETAILS

SoftEther is a multi-platform VPN project that provides both server and client code to connect over a variety of VPN protocols, including Wireguard, PPTP, SSTP, L2TP, etc. SoftEther has a variety of features for both enterprise and personal use, and enables Nat Traversal out-of-the-box for remote-access setups behind firewalls.

By default when SoftEther VPN server is run, the server registers itself with `ddns.softether-network.net`, such that the VPN server can traverse NAT out-of-the-box and be reachable through firewalls immediately. A specific thread is designated for this task, and it will henceforth be referred to as the DDNS client thread due to the function name designating this code path:

```
// DDNS client thread
void DCThread(THREAD *thread, void *param)
{
    DDNS_CLIENT *c;
    INTERRUPT_MANAGER *interrupt;
    // [...]
    // Validate arguments
    if (thread == NULL || param == NULL)
    {
        return;
    }

    c = (DDNS_CLIENT *)param;

    // [...]
    while (c->Halt == false){

    // [...]

    // IPv4 host registration
    if (c->NextRegisterTick_IPv4 == 0 || now >= c->NextRegisterTick_IPv4)
    {
        UINT next_interval;

        c->Err_IPv4 = DCRegister(c, false, NULL, NULL);

        if (c->Err_IPv4 == ERR_NO_ERROR)
        {
            next_interval = GenRandInterval(DDNS_REGISTER_INTERVAL_OK_MIN, DDNS_REGISTER_INTERVAL_OK_MAX);
        }
        else
        {
            next_interval = GenRandInterval(DDNS_REGISTER_INTERVAL_NG_MIN, DDNS_REGISTER_INTERVAL_NG_MAX);
        }
        //next_interval = 0;

        c->NextRegisterTick_IPv4 = Tick64() + (UINT64)next_interval;

        if (true)
        {
            DDNS_CLIENT_STATUS st;

            DCGetStatus(c, &st);

            SiApplyAzureConfig(c->Cedar->Server, &st);
        }

        AddInterrupt(interrupt, c->NextRegisterTick_IPv4);
    }

```

As long as the `DDNS_CLIENT` object never has its `Halt` flag set, we continuously loop through the different timers, checking to see if our public facing IP addresses have changed or not, so we know if we need to update the public SoftEther DDNS server’s settings for our hostname. This basic IP address checking is simple unencrypted traffic over UDP port 5004, and is not too interesting, but the other DDNS traffic that gets sent is also unencrypted and is a lot more useful. Continuing in DCThread:

```
// DDNS client thread
void DCThread(THREAD *thread, void *param)
{
    // [...]
            // IPv4 host registration
    if (c->NextRegisterTick_IPv4 == 0 || now >= c->NextRegisterTick_IPv4)
    {
        UINT next_interval;

        c->Err_IPv4 = DCRegister(c, false, NULL, NULL); // [1]

        if (c->Err_IPv4 == ERR_NO_ERROR)
        {
            next_interval = GenRandInterval(DDNS_REGISTER_INTERVAL_OK_MIN, DDNS_REGISTER_INTERVAL_OK_MAX);
        }
        else
        {
            next_interval = GenRandInterval(DDNS_REGISTER_INTERVAL_NG_MIN, DDNS_REGISTER_INTERVAL_NG_MAX);
        }
        //next_interval = 0;

        c->NextRegisterTick_IPv4 = Tick64() + (UINT64)next_interval;

        if (true)
        {
            DDNS_CLIENT_STATUS st;

            DCGetStatus(c, &st);

            SiApplyAzureConfig(c->Cedar->Server, &st);
        }

        AddInterrupt(interrupt, c->NextRegisterTick_IPv4);
    }

```

Assuming that our IP address has changed, or the timeout has occurred, or even if our server is just starting, we end up hitting the `DCRegister` [1] function, which contains more of the actual network packet processing:

```
// Execution of registration
UINT DCRegister(DDNS_CLIENT *c, bool ipv6, DDNS_REGISTER_PARAM *p, char *replace_v6)
{
    char *url;
    char url2[MAX_SIZE];
    char url3[MAX_SIZE];
    PACK *req, *ret;
    char key_str[MAX_SIZE];
    UCHAR machine_key[SHA1_SIZE];
    char machine_key_str[MAX_SIZE];
    char machine_name[MAX_SIZE];
    BUF *cert_hash = NULL;
    UINT err = ERR_INTERNAL_ERROR;
    UCHAR key_hash[SHA1_SIZE];
    char key_hash_str[MAX_SIZE];
    bool use_azure = false;
    char current_azure_ip[MAX_SIZE];
    INTERNET_SETTING t;
    UINT build = 0;
    char add_header_name[64];
    char add_header_value[64];
    // Validate arguments
    if (c == NULL)
    {
        return ERR_INTERNAL_ERROR;
    }

    // [...]

    Format(url2, sizeof(url2), "%s?v=%I64u", url, Rand64());
    Format(url3, sizeof(url3), url2, key_hash_str[2], key_hash_str[3]);

    ReplaceStr(url3, sizeof(url3), url3, "https://", "http://");

    ReplaceStr(url3, sizeof(url3), url3, ".servers", ".open.servers");

    cert_hash = StrToBin(DDNS_CERT_HASH);

    Debug("WpcCall: %s\n", url3);
    ret = WpcCallEx2(url3, &t, DDNS_CONNECT_TIMEOUT, DDNS_COMM_TIMEOUT, "register", req,  // [2]
        NULL, NULL, ((cert_hash != NULL && ((cert_hash->Size % SHA1_SIZE) == 0)) ? cert_hash->Buf : NULL),
        (cert_hash != NULL ? cert_hash->Size / SHA1_SIZE : 0),
        NULL, DDNS_RPC_MAX_RECV_SIZE,   // dyn32, (128 * 1024 * 1024)...
        add_header_name, add_header_value,
        DDNS_SNI_VER_STRING);
    Debug("WpcCall Ret: %u\n", ret);

    FreeBuf(cert_hash);

    FreePack(req);

    err = GetErrorFromPack(ret);

    ExtractAndApplyDynList(ret);  // [3]

```

We can ignore most of the initialization code. For our purposes, we only really care that the `WpcCallEx2` function reaches out to a DNS name like `xc.xi.dev.open.servers.ddns.softether-network.net` and sends an unencrypted UDP request that asks for a NAT traversal token looking like so:

```
0000   00 00 00 03 00 00 00 07 6f 70 63 6f 64 65 00 00   ........opcode..
0010   00 02 00 00 00 01 00 00 00 09 67 65 74 5f 74 6f   ..........get_to
0020   6b 65 6e 00 00 00 08 74 72 61 6e 5f 69 64 00 00   ken....tran_id..
0030   00 04 00 00 00 01 11 55 11 bb aa 87 e8 55 00 00   ................
0040   00 16 6e 61 74 5f 74 72 61 76 65 72 73 61 6c 5f   ..nat_traversal_
0050   76 65 72 73 69 6f 6e 00 00 00 00 00 00 00 01 00   version.........
0060   00 00 01                                          ...

```

Before going further we must briefly describe the simple TLV protocol format here, which looks like:

```
struct packed_item {
    size_t namelen;
    char name[namelen+1];
    uint32_t value_type;  // [4]
    // value/data
}

struct packed_buffer {
    uint32_t number_of_items;
    struct packed_item[number_of_items];
}

```

The value types for each item in the buffer [4] can be `VALUE_INT`, `VALUE_DATA`, `VALUE_STR`, `VALUE_UNISTR` or `VALUE_INT64`, which is then followed immediately by the item itself. Their size and format is dependent on the type. Regardless, this packed buffer packet data is from the response to `WpcCallEx2` [2], which then gets fed into the `ExtractAndApplyDynList` function at [3]:

```
// Apply by extracting dynamic value list from the specified PACK
void ExtractAndApplyDynList(PACK *p)
{
    BUF *b;
    // Validate arguments
    if (p == NULL)
    {
        return;
    }

    b = PackGetBuf(p, "DynList"); // [4]
    if (b == NULL)
    {
        return;
    }

    AddDynList(b);  // [5]

    FreeBuf(b);
}

```

This function tries to unpack the `DynList` item from the response buffer as another nested packed buffer and then passes this validated buffer into `AddDynList` [5]:

```
// Insert the data to the dynamic value list
void AddDynList(BUF *b)
{
    PACK *p;
    TOKEN_LIST *t;
    // Validate arguments
    if (b == NULL)
    {
        return;
    }

    SeekBufToBegin(b);

    p = BufToPack(b);  // [6]
    if (p == NULL)
    {
        return;
    }

    t = GetPackElementNames(p);
    if (t != NULL)
    {
        UINT i;

        for (i = 0; i < t->NumTokens; i++) // [7]
        {
            char *name = t->Token[i];
            UINT64 v = PackGetInt64(p, name);

            SetDynListValue(name, v); // [8]
        }

        FreeToken(t);
    }

    FreePack(p);
}

```

At [6], the input buffer (which is essentially a C++ std::string) is parsed to make sure it follows the “packed\_buffer” format as mentioned above. It then walks the names of each of the items at [7] and passes the name and value (assuming it’s a UINT64) into the `SetDynListValue` function at [8]:

```
// Set the value to the dynamic value list
void SetDynListValue(char *name, UINT64 value)
{
    // Validate arguments
    if (name == NULL)
    {
        return;
    }

    if (g_dyn_value_list == NULL)
    {
        return;
    }

    LockList(g_dyn_value_list);
    {
        UINT i;
        DYN_VALUE *v = NULL;

        for (i = 0; i < LIST_NUM(g_dyn_value_list); i++)
        {
            DYN_VALUE *vv = LIST_DATA(g_dyn_value_list, i);  // [9]

            if (StrCmpi(vv->Name, name) == 0)
            {
                v = vv;
                break;
            }
        }

        if (v == NULL)
        {
            v = ZeroMalloc(sizeof(DYN_VALUE)); // DYN_VALUE == { char[256], uint64_t }
            StrCpy(v->Name, sizeof(v->Name), name);

            Add(g_dyn_value_list, v);
        }

        v->Value = value;
    }
    UnlockList(g_dyn_value_list);
}

```

Finally getting somewhat to the core of the matter, `SetDynListValue` safely walks the `g_dyn_value_list` global list to see if the name matches any existing items. If so, we replace the value. If not, we allocate a new item and add it to the list. But this begs the questions of “what is in the `g_dyn_value_list`?” and “what are these items used for?”. The only place values are read out of this list is via the `DYN64` macro as follows:

```
#define       DYN32(id, default_value)        (UINT)DYN64(id, (UINT)default_value)
#define DYN64(id, default_value)    ( (UINT64)GetDynValueOrDefaultSafe ( #id , (UINT64)( default_value )))

```

Which then points us to `GetDynValueOrDefaultSafe`:

```
UINT64 GetDynValueOrDefaultSafe(char *name, UINT64 default_value)
{
    return GetDynValueOrDefault(name, default_value, default_value / (UINT64)5, default_value * (UINT64)50);
}

```

This call to `DYN32` is used in a number of places that all deal with either NAT-T or DDNS, but to save bandwidth, here are just the DDNS occurrences:

```
Cedar/DDNS.h:#define    DDNS_RPC_MAX_RECV_SIZE                                  DYN32(DDNS_RPC_MAX_RECV_SIZE, (128 * 1024 * 1024))  // [10]
Cedar/DDNS.h:#define    DDNS_CONNECT_TIMEOUT                                    DYN32(DDNS_CONNECT_TIMEOUT, (15 * 1000))
Cedar/DDNS.h:#define    DDNS_COMM_TIMEOUT                                       DYN32(DDNS_COMM_TIMEOUT, (60 * 1000))
Cedar/DDNS.h:#define    DDNS_REGISTER_INTERVAL_OK_MIN                           DYN32(DDNS_REGISTER_INTERVAL_OK_MIN, (1 * 60 * 60 * 1000))
Cedar/DDNS.h:#define    DDNS_REGISTER_INTERVAL_OK_MAX                           DYN32(DDNS_REGISTER_INTERVAL_OK_MAX, (2 * 60 * 60 * 1000))
Cedar/DDNS.h:#define    DDNS_REGISTER_INTERVAL_NG_MIN                           DYN32(DDNS_REGISTER_INTERVAL_NG_MIN, (1 * 60 * 1000))
Cedar/DDNS.h:#define    DDNS_REGISTER_INTERVAL_NG_MAX                           DYN32(DDNS_REGISTER_INTERVAL_NG_MAX, (5 * 60 * 1000))
Cedar/DDNS.h:#define    DDNS_GETMYIP_INTERVAL_OK_MIN                            DYN32(DDNS_GETMYIP_INTERVAL_OK_MIN, (10 * 60 * 1000))
Cedar/DDNS.h:#define    DDNS_GETMYIP_INTERVAL_OK_MAX                            DYN32(DDNS_GETMYIP_INTERVAL_OK_MAX, (20 * 60 * 1000))
Cedar/DDNS.h:#define    DDNS_GETMYIP_INTERVAL_NG_MIN                            DYN32(DDNS_GETMYIP_INTERVAL_NG_MIN, (1 * 60 * 1000))
Cedar/DDNS.h:#define    DDNS_GETMYIP_INTERVAL_NG_MAX                            DYN32(DDNS_GETMYIP_INTERVAL_NG_MAX, (5 * 60 * 1000))
Cedar/DDNS.h:#define    DDNS_VPN_AZURE_CONNECT_ERROR_DDNS_RETRY_TIME_DIFF       DYN32(DDNS_VPN_AZURE_CONNECT_ERROR_DDNS_RETRY_TIME_DIFF, (120 * 1000))
Cedar/DDNS.h:#define    DDNS_VPN_AZURE_CONNECT_ERROR_DDNS_RETRY_TIME_DIFF_MAX   DYN32(DDNS_VPN_AZURE_CONNECT_ERROR_DDNS_RETRY_TIME_DIFF_MAX, (10 * 60 * 1000))

```

Out of all of these, we’ve actually already seen one before in the source above: `DDNS_RPC_MAX_RECV_SIZE` [10] up in the `DCRegister` function:

```
// Execution of registration
UINT DCRegister(DDNS_CLIENT *c, bool ipv6, DDNS_REGISTER_PARAM *p, char *replace_v6)
{

    // [...]
    ret = WpcCallEx2(url3, &t, DDNS_CONNECT_TIMEOUT, DDNS_COMM_TIMEOUT, "register", req,   // okay, at least 1 bug, maybe 2.
        NULL, NULL, ((cert_hash != NULL && ((cert_hash->Size % SHA1_SIZE) == 0)) ? cert_hash->Buf : NULL),
        (cert_hash != NULL ? cert_hash->Size / SHA1_SIZE : 0),
        NULL, DDNS_RPC_MAX_RECV_SIZE,   // dyn32, (128 * 1024 * 1024)...
        add_header_name, add_header_value,
        DDNS_SNI_VER_STRING);

    // [...]

/*
PACK *WpcCallEx2(char *url, INTERNET_SETTING *setting, UINT timeout_connect, UINT timeout_comm,
            char *function_name, PACK *pack, X *cert, K *key, void *sha1_cert_hash, UINT num_hashes, bool *cancel, UINT max_recv_size,
            char *additional_header_name, char *additional_header_value, char *sni_string)
*/

```

The `DDNS_RPC_MAX_RECV_SIZE` dynamic list item is used as the `UINT max_recv_size` inside of `WpcCallEx2`, so following exactly how that parameter is used:

```
PACK *WpcCallEx2(char *url, INTERNET_SETTING *setting, UINT timeout_connect, UINT timeout_comm,
                char *function_name, PACK *pack, X *cert, K *key, void *sha1_cert_hash, UINT num_hashes, bool *cancel, UINT max_recv_size,
                char *additional_header_name, char *additional_header_value, char *sni_string)
{

    // [...]
    recv = HttpRequestEx3(&data, setting, timeout_connect, timeout_comm, &error,
        false, b->Buf, NULL, NULL, sha1_cert_hash, num_hashes, cancel, max_recv_size, // [11]
        NULL, NULL);

```

It gets eventually passed into the `HttpRequestEx3` function at [11] and used as follows:

```
BUF *HttpRequestEx3(URL_DATA *data, INTERNET_SETTING *setting,
                    UINT timeout_connect, UINT timeout_comm,
                    UINT *error_code, bool check_ssl_trust, char *post_data,
                    WPC_RECV_CALLBACK *recv_callback, void *recv_callback_param, void *sha1_cert_hash, UINT num_hashes,
                    bool *cancel, UINT max_recv_size, char *header_name, char *header_value)
{
    /// [...]

CONT:
    // Receive
    h = RecvHttpHeader(s);    // [12]
    if (h == NULL)
    {
        Disconnect(s);
        ReleaseSock(s);

        *error_code = ERR_DISCONNECTED;

        return NULL;
    }

    http_error_code = 0;
    if (StrLen(h->Method) == 8)
    {
        if (Cmp(h->Method, "HTTP/1.", 7) == 0)
        {
            http_error_code = ToInt(h->Target);
        }
    }

    *error_code = ERR_NO_ERROR;

    switch (http_error_code) { ... }
    // [...]

    // Get the length of the content
    content_len = GetContentLength(h); //
    if (max_recv_size != 0)
    {
        content_len = MIN(content_len, max_recv_size); // [13]
    }

    FreeHttpHeader(h);

    socket_buffer = Malloc(socket_buffer_size); // 64000

    // Receive the content
    recv_buf = NewBuf();

    while (true)
    {
        UINT recvsize = MIN(socket_buffer_size, content_len - recv_buf->Size); // [14]
        UINT size;

        if (recv_callback != NULL) // generally null
        {
            if (recv_callback(recv_callback_param,
                content_len, recv_buf->Size, recv_buf) == false)
            {
                // Cancel the reception
                *error_code = ERR_USER_CANCEL;
                goto RECV_CANCEL;
            }
        }

        if (recvsize == 0)
        {
            break;
        }

        size = Recv(s, socket_buffer, recvsize, s->SecureMode);  // [15]
        if (size == 0)
        {
            // Disconnected
            *error_code = ERR_DISCONNECTED;

RECV_CANCEL:
            FreeBuf(recv_buf);
            Free(socket_buffer);
            Disconnect(s);
            ReleaseSock(s);

            return NULL;
        }

        WriteBuf(recv_buf, socket_buffer, size); // [16]
    }

```

After sending an inconsequential HTTP request unencrypted above [12], we finally see our `max_recv_size` at [13], as it is used to determine the `content_len` of the response. After this, we just keep receiving bytes at [15] until we have read in `content_len - recv_buf->Size` bytes [14]. After receiving the bytes, they are written from the `socket_buffer` into the `Buffer *recv_buf` at [16], which essentially acts as an `std::string`. But how many bytes can this buffer actually hold? Normally these `Buffer *` objects will keep doubling in size every time they reach capacity inside `WriteBuf`:

```
// Adjusting the buffer size
void AdjustBufSize(BUF *b, UINT new_size)
{
    // Validate arguments
    if (b == NULL)
    {
        return;
    }

    if (b->SizeReserved >= new_size)
    {
        return;
    }

    while (b->SizeReserved < new_size)        // [17]
    {
        b->SizeReserved = b->SizeReserved * 2;
    }
    b->Buf = ReAlloc(b->Buf, b->SizeReserved);

    // KS
    KS_INC(KS_ADJUST_BUFSIZE_COUNT);
}

```

Curiously, the doubling continuously occurs inside of the while loop at [17], presumably in case the `new_size` is significantly larger. Regardless, this design decision will become important soon. Another point to note about `AdjustBufSize` is that both `b->SizeReserved` and `new_size` are `UINT` sized, i.e. 32-bits. Also, since every buffer starts out with 0x2800 bytes for `b->SizeReserved`, if `new_size` is ever greater than 0x80000000, then the while statement at [17] turns into an infinite loop since `(0x2800 << 20) == 0x80000000`. If we hit the loop one more time, `b->SizeReserved` overflows to 0x1, restarting the whole process.

With the vulnerability explained, we have to quickly figure out how to get a `new_size` that’s greater than 0x80000000. This problem turns out to be a lot simpler than expected, as we simply need to keep expanding a buffer to reach this point. Thus, if we remember from [13], `content_len = MIN(content_len, max_recv_size);`, so the minimum of the `content_len` and `max_recv_size` is how large our resulting buffer is. Content length is the easier one, since it’s simply read in from the HTTP response’s headers. To get our `max_recv_size` where we need it, we have to set the `DDNS_RPC_MAX_RECV_SIZE` global dynamic list variable via a different request (this can be achieved via `RUDPProcess_NatT_Recv` UDP traffic, also MITM’able). Since `DYN64` ends up eventually resulting in ` GetDynValueOrDefault(name, default\_value, default\_value / (UINT64)5, default\_value \* (UINT64)50); `as listed above, and also because the default` DDNS\_RPC\_MAX\_RECV\_SIZE `is` 128 \* 1024 \* 1024 `(0x8000000), any value we assign to` DDNS\_RPC\_MAX\_RECV\_SIZE `that is over 0x8000000 will result in` 128 \* 1024 \* 1024 \* 50` (0x190000000) being returned as the value (since it’s the ‘safe’ upper-bound), which is over the 0x80000000 limit that we need to cause the infinite loop. Even though 0x190000000 gets truncated to 0x90000000 due to UINT32 variables being used, we get lucky that 0x90000000 is still greater than 0x80000000.

Thus, in summary, we assign `DDNS_RPC_MAX_RECV_SIZE` to anything over 0x8000000 via the unencrypted NAT-T UDP traffic. We then respond to an unencrypted HTTP request with an HTTP response that has a Content-Length greater than 0x80000000. Finally, we have to send at least 0x80000000 bytes for our buffer to expand, resulting in an infinite loop and disabling of SoftEther’s DDNS thread. While only denying service to a single thread, the server would become inaccessible through NAT or firewalls, denying one of the major use-cases of this product.

### Crash Information

```
 Thread 26 (Thread 0x7f861c049380 (LWP 8103) "vpnserver"):
#0  AdjustBufSize (b=0x7f85b800f680, new_size=2684416000) at /softether/SoftEtherVPN_orig/src/Mayaqua/Memory.c:3117
#1  0x00007f861d3e8978 in WriteBuf (size=64000, buf=0x7f85b8015eb0, b=0x7f85b800f680) at /softether/SoftEtherVPN_orig/src/Mayaqua/Memory.c:2758
#2  WriteBuf (b=0x7f85b800f680, buf=0x7f85b8015eb0, size=64000) at /softether/SoftEtherVPN_orig/src/Mayaqua/Memory.c:2745
#3  0x00007f861d5c393a in HttpRequestEx3 (data=data@entry=0x7f861c042be0, setting=setting@entry=0x7f861c043f80, timeout_connect=timeout_connect@entry=15000, timeout_comm=timeout_comm@entry=60000, error_code=error_code@entry=0x7f861c042b2c, check_ssl_trust=check_ssl_trust
@entry=false, post_data=0x7f85b8013690 "PACK0000"..., recv_callback=0x0, recv_c
allback_param=0x0, sha1_cert_hash=<optimized out>, num_hashes=<optimized out>, cancel=0x0, max_recv_size=4294967295, header_name=0x0, header_value=0x0) at /softether/SoftEtherVPN_orig/src/Cedar/Wpc.c:966
#4  0x00007f861d5c4849 in WpcCallEx2 (url=url@entry=0x7f861c0449d0 "http://xx.xx.dev.open.servers-v6.ddns.softether-network.net/ddns/ddns.aspx?v=22222222222", setting=setting@entry=0x7f861c043f80, timeout_connect=15000, timeout_comm=timeout_comm@entry=60000, func
tion_name=function_name@entry=0x7f861d5d2eeb "register", pack=pack@entry=0x7f85b8007b90, cert=0x0, key=0x0, sha1_cert_hash=0x7f85b800c820, num_hashes=5, cancel=0x0, max_recv_size=4294967295, additional_header_name=0x7f861c0446d0 "", additional_header_value=0x7f861c044710 "", sni_string=0x7f861d5d2dbe "DDNS") at /softether/SoftEtherVPN_orig/src/Cedar/Wpc.c:116
#5  0x00007f861d53842d in DCRegister (c=c@entry=0x5615c7e8f2d0, ipv6=ipv6@entry=true, p=p@entry=0x0, replace_v6=replace_v6@entry=0x0) at /softether/SoftEtherVPN_orig/src/Cedar/DDNS.c:556
#6  0x00007f861d538cce in DCThread (param=0x5615c7e8f2d0, thread=<optimized out>) at /softether/SoftEtherVPN_orig/src/Cedar/DDNS.c:346
#7  0x00007f861d3e143d in ThreadPoolProc (param=0x5615c7e86bb0, t=0x5615c7e8edd0) at /softether/SoftEtherVPN_orig/src/Mayaqua/Kernel.c:872
#8  ThreadPoolProc (t=0x5615c7e8edd0, param=0x5615c7e86bb0) at /softether/SoftEtherVPN_orig/src/Mayaqua/Kernel.c:827
#9  0x00007f861d41d7d1 in UnixDefaultThreadProc (param=0x5615c7e8f060) at /softether/SoftEtherVPN_orig/src/Mayaqua/Unix.c:1594
#10 0x00007f861d094b43 in start_thread (arg=<optimized out>) at ./nptl/pthread_create.c:442
#11 0x00007f861d126a00 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81

```
##### VENDOR RESPONSE

The vendor issued an advisory:
https://www.softether.org/9-about/News/904-SEVPN202301

##### TIMELINE

2023-04-03 - Vendor Disclosure

2023-04-03 - Initial Vendor Contact

2023-06-30 - Vendor Patch Release

2023-10-12 - Public Release

##### Credit

Discovered by Lilith >\_> of Cisco Talos.

---

[Vulnerability Reports](/vulnerability_reports) [Next Report

TALOS-2023-1735](/vulnerability_reports/TALOS-2023-1735) [Previous Report

TALOS-2023-1737](/vulnerability_reports/TALOS-2023-1737)

* + ###### [Intelligence Center](/reputation)
  + [Intelligence Search](/reputation_center)
  + [Email & Spam Trends](/reputation_center/email_rep)
* + ###### [Vulnerability Research](/vulnerability_info)
  + [Vulnerability Reports](/vulnerability_reports)
  + [Microsoft Advisories](/ms_advisories)
* + ###### [Incident Response](/incident_response)
  + [Reactive Services](/incident_response/services#reactive-services)
  + [Proactive Services](/incident_response/services#proactive-services)
  + Emergency Support
* + ###### Security Resources
  + [Open Source Security Tools](/software)
  + [Intelligence Categories Reference](/categories)
  + [Secure Endpoint Naming Reference](/secure-endpoint-naming)
* + ###### Media
  + [Talos Intelligence Blog](https://blog.talosintelligence.com)
  + [Threat Source Newsletter](https://blog.talosintelligence.com/category/threat-source-newsletter/)
  + [Beers with Talos Podcast](/podcasts/shows/beers_with_talos)
  + [Talos Takes Podcast](/podcasts/shows/talos_takes)
  + [Talos Videos](https://www.youtube.com/channel/UCPZ1DtzQkStYBSG3GTNoyfg/featured)
* + ###### Support
  + [Support Documentation](https://support.talosintelligence.com)
* + ###### Company
  + [About Talos](/about)
  + [Careers](/careers)
  + [Cisco Security](https://www.cisco.com/c/en/us/products/security/product-listing.html)

###### Follow us

[![Cisco](/assets/logo_cisco_white-d87b7f7d3152ad412e48aad924a972cc5b802b7a53cb56b0792a4456c9b7b3a5.svg)](http://tools.cisco.com/security/center/home.x)

©
2025
Cisco Systems, Inc. and/or its affiliates. All rights
reserved. View our
[Privacy Policy.](http://www.cisco.com/web/siteassets/legal/privacy_full.html)


