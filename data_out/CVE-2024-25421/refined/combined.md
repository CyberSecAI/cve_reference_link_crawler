=== Content from github.com_bd8a20a0_20250110_153417.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Figniterealtime%2FOpenfire%2Fblob%2Fmain%2Fxmppserver%2Fsrc%2Fmain%2Fjava%2Forg%2Fjivesoftware%2Fopenfire%2Fmuc%2Fspi%2FLocalMUCRoomManager.java)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Figniterealtime%2FOpenfire%2Fblob%2Fmain%2Fxmppserver%2Fsrc%2Fmain%2Fjava%2Forg%2Fjivesoftware%2Fopenfire%2Fmuc%2Fspi%2FLocalMUCRoomManager.java)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=igniterealtime%2FOpenfire)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[igniterealtime](/igniterealtime)
/
**[Openfire](/igniterealtime/Openfire)**
Public

* [Notifications](/login?return_to=%2Figniterealtime%2FOpenfire) You must be signed in to change notification settings
* [Fork
  1.4k](/login?return_to=%2Figniterealtime%2FOpenfire)
* [Star
   2.9k](/login?return_to=%2Figniterealtime%2FOpenfire)

* [Code](/igniterealtime/Openfire)
* [Pull requests
  18](/igniterealtime/Openfire/pulls)
* [Actions](/igniterealtime/Openfire/actions)
* [Projects
  0](/igniterealtime/Openfire/projects)
* [Wiki](/igniterealtime/Openfire/wiki)
* [Security](/igniterealtime/Openfire/security)
* [Insights](/igniterealtime/Openfire/pulse)

Additional navigation options

* [Code](/igniterealtime/Openfire)
* [Pull requests](/igniterealtime/Openfire/pulls)
* [Actions](/igniterealtime/Openfire/actions)
* [Projects](/igniterealtime/Openfire/projects)
* [Wiki](/igniterealtime/Openfire/wiki)
* [Security](/igniterealtime/Openfire/security)
* [Insights](/igniterealtime/Openfire/pulse)

## Files

 main
## Breadcrumbs

1. [Openfire](/igniterealtime/Openfire/tree/main)
2. /[xmppserver](/igniterealtime/Openfire/tree/main/xmppserver)
3. /[src](/igniterealtime/Openfire/tree/main/xmppserver/src)
4. /[main](/igniterealtime/Openfire/tree/main/xmppserver/src/main)
5. /[java](/igniterealtime/Openfire/tree/main/xmppserver/src/main/java)
6. /[org](/igniterealtime/Openfire/tree/main/xmppserver/src/main/java/org)
7. /[jivesoftware](/igniterealtime/Openfire/tree/main/xmppserver/src/main/java/org/jivesoftware)
8. /[openfire](/igniterealtime/Openfire/tree/main/xmppserver/src/main/java/org/jivesoftware/openfire)
9. /[muc](/igniterealtime/Openfire/tree/main/xmppserver/src/main/java/org/jivesoftware/openfire/muc)
10. /[spi](/igniterealtime/Openfire/tree/main/xmppserver/src/main/java/org/jivesoftware/openfire/muc/spi)
/
# LocalMUCRoomManager.java

 Blame  Blame
## Latest commit

## History

[History](/igniterealtime/Openfire/commits/main/xmppserver/src/main/java/org/jivesoftware/openfire/muc/spi/LocalMUCRoomManager.java)662 lines (599 loc) · 32.8 KB main
## Breadcrumbs

1. [Openfire](/igniterealtime/Openfire/tree/main)
2. /[xmppserver](/igniterealtime/Openfire/tree/main/xmppserver)
3. /[src](/igniterealtime/Openfire/tree/main/xmppserver/src)
4. /[main](/igniterealtime/Openfire/tree/main/xmppserver/src/main)
5. /[java](/igniterealtime/Openfire/tree/main/xmppserver/src/main/java)
6. /[org](/igniterealtime/Openfire/tree/main/xmppserver/src/main/java/org)
7. /[jivesoftware](/igniterealtime/Openfire/tree/main/xmppserver/src/main/java/org/jivesoftware)
8. /[openfire](/igniterealtime/Openfire/tree/main/xmppserver/src/main/java/org/jivesoftware/openfire)
9. /[muc](/igniterealtime/Openfire/tree/main/xmppserver/src/main/java/org/jivesoftware/openfire/muc)
10. /[spi](/igniterealtime/Openfire/tree/main/xmppserver/src/main/java/org/jivesoftware/openfire/muc/spi)
/
# LocalMUCRoomManager.java

Top
## File metadata and controls

* Code
* Blame

662 lines (599 loc) · 32.8 KB[Raw](https://github.com/igniterealtime/Openfire/raw/refs/heads/main/xmppserver/src/main/java/org/jivesoftware/openfire/muc/spi/LocalMUCRoomManager.java)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662/\* \* Copyright (C) 2016-2025 Ignite Realtime Foundation. All rights reserved. \* \* Licensed under the Apache License, Version 2.0 (the "License"); \* you may not use this file except in compliance with the License. \* You may obtain a copy of the License at \* \* http://www.apache.org/licenses/LICENSE-2.0 \* \* Unless required by applicable law or agreed to in writing, software \* distributed under the License is distributed on an "AS IS" BASIS, \* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \* See the License for the specific language governing permissions and \* limitations under the License. \*/package org.jivesoftware.openfire.muc.spi;
import org.jivesoftware.openfire.RoutingTable;import org.jivesoftware.openfire.XMPPServer;import org.jivesoftware.openfire.cluster.ClusteredCacheEntryListener;import org.jivesoftware.openfire.cluster.NodeID;import org.jivesoftware.openfire.event.GroupEventDispatcher;import org.jivesoftware.openfire.event.UserEventDispatcher;import org.jivesoftware.openfire.muc.\*;import org.jivesoftware.openfire.spi.RoutingTableImpl;import org.jivesoftware.openfire.user.UserNotFoundException;import org.jivesoftware.util.cache.Cache;import org.jivesoftware.util.cache.CacheFactory;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.xmpp.packet.JID;import org.xmpp.packet.Presence;
import javax.annotation.Nonnull;import javax.annotation.Nullable;import java.time.Duration;import java.util.\*;import java.util.concurrent.locks.Lock;import java.util.stream.Collectors;
/\*\* \* Each instance of this class takes responsibility of maintaining the in-memory representation of MUCRooms for exactly \* one instance of {@link org.jivesoftware.openfire.muc.MultiUserChatService}, which is expected to be the sole invoking \* entity. This instance that is provided as an argument to the constructor. This class makes extensive use of the \* 'package' access modifier to reflect this. \* \* It is the responsibility of invoking codes that changes applied to instances managed by this class are made available \* to other users (eg: cluster nodes). To achieve this, the {@link #sync(MUCRoom)} method must be used. Changes to an \* instance that are not synced will not be reflected in subsequent instances returned by the various getters in this \* class (behavior can differ based on the deployment model of Openfire: clustered environments are more susceptible to \* data loss than a single-server Openfire instance. \* \* To control (cluster-wide) access to instances, a MUCRoom-based Lock instance can be obtained through {@link #getLock(String)}. \* \* @author <a href="mailto:583424568@qq.com">wuchang</a> 2016-1-14 \* @author Guus der Kinderen, guus.der.kinderen@gmail.com \*/public class LocalMUCRoomManager{ private static final Logger Log = LoggerFactory.getLogger(LocalMUCRoomManager.class);
 /\*\* \* Name of the MUC service that this instance is operating for. \*/ private final String serviceName;
 /\*\* \* Chat rooms for this service, mapped by their name. \* \* @see #getLocalRooms() which holds content that needs to remain accessible to the local cluster node. \*/ private final Cache<String, MUCRoom> ROOM\_CACHE;
 /\*\* \* Counters for the data that is in ROOM\_CACHE. Used to return statistics without having to iterate over the \* entire content of ROOM\_CACHE. \*/ private final Cache<String, Long> ROOM\_CACHE\_STATS;
 /\*\* \* The key used in {@link #ROOM\_CACHE\_STATS} to keep track of the amount of non-persistent rooms in the cache. \*/ private static final String STAT\_KEY\_ROOMCOUNT\_NONPERSISTENT = "Amount of MUC rooms (non-persistent)";
 /\*\* \* A cluster-local copy of rooms, used to (re)populating #ROOM\_CACHE upon cluster join or leave. \*/ private final Map<String, MUCRoom> localRooms = new HashMap<>();
 /\*\* \* Creates a new instance, specific for the provided MUC service. \* \* @param service The service for which the new instance will be operating. \*/ LocalMUCRoomManager(@Nonnull final MultiUserChatService service) { this.serviceName = service.getServiceName(); Log.debug("Instantiating for service '{}'", serviceName); ROOM\_CACHE = CacheFactory.createCache("MUC Service '" + serviceName + "' Rooms"); ROOM\_CACHE.setMaxLifetime(-1); ROOM\_CACHE.setMaxCacheSize(-1L); ROOM\_CACHE\_STATS = CacheFactory.createCache("MUC Service '" + serviceName + "' Room Statistics"); ROOM\_CACHE\_STATS.setMaxLifetime(-1); ROOM\_CACHE\_STATS.setMaxCacheSize(-1L); }
 /\*\* \* Returns the number of chat rooms that are currently actively loaded in memory. \* \* @return a chat room count. \*/ int size() { final int result = ROOM\_CACHE.size(); Log.trace("Room count for service '{}': {}", serviceName, result); return result; }
 /\*\* \* Generates a mutex object that controls cluster-wide access to a MUCRoom instance that represents the room in this \* service identified by the provided name. \* \* The lock, once returned, is not acquired/set. \* \* @param roomName Name of the room for which to return a lock. \* @return The lock (which has not been set yet). \*/ @Nonnull Lock getLock(@Nonnull final String roomName) { Log.trace("Obtaining lock for room '{}' of service '{}'", roomName, serviceName); return ROOM\_CACHE.getLock(roomName); }
 /\*\* \* Adds a room instance to this manager. \* \* @param room The room to be added. \*/ void add(@Nonnull final MUCRoom room) { final Lock lock = ROOM\_CACHE.getLock(room.getName()); lock.lock(); try { Log.trace("Adding room '{}' of service '{}'", room.getName(), serviceName); final MUCRoom oldValue = ROOM\_CACHE.put(room.getName(), room); localRooms.put(room.getName(), room); updateNonPersistentRoomStat(oldValue, room); } finally { lock.unlock(); }
 GroupEventDispatcher.addListener(room); // TODO this event listener is added only in the node where the room is created. Does this mean that events are not propagated in a cluster? UserEventDispatcher.addListener(room); }
 /\*\* \* Makes available the current state of the provided MUCRoom instance to all nodes in the Openfire cluster (if the \* local server is part of such a cluster). This method should be used whenever a MUCRoom instance has been changed. \* \* @param room The room for which to persist state changes across the Openfire cluster. \*/ void sync(@Nonnull final MUCRoom room) { final Lock lock = ROOM\_CACHE.getLock(room.getName()); lock.lock(); try { Log.trace("Syncing room '{}' of service '{}' (destroy: {})", room.getName(), serviceName, room.isDestroyed); if (room.isDestroyed) { ROOM\_CACHE.remove(room.getName()); localRooms.remove(room.getName()); updateNonPersistentRoomStat(null, room); } else { final MUCRoom oldValue = ROOM\_CACHE.put(room.getName(), room); localRooms.put(room.getName(), room); updateNonPersistentRoomStat(oldValue, room); } } finally { lock.unlock(); } }
 // TODO As modifications to rooms won't be persisted in the cache without the room having being explicitly put back in the cache, // this method probably needs work. Documentation should be added and/or this should return an Unmodifiable collection (although // that still does not rule out modifications to individual collection items. Can we replace it completely with a 'getRoomNames()' // method, which would then force usage to acquire a lock before operating on a room. Collection<MUCRoom> getAll() { return ROOM\_CACHE.values(); }
 /\*\* \* Retrieve a specific room, if one is currently managed by this instance. \* \* Note that when obtaining a room instance using this method, the caller should take responsibility to make sure \* that any changes to the instance will become visible to other cluster nodes (which is done by invoking \* {@link #sync(MUCRoom)}. Where appropriate, the caller should apply mutex (as returned by {@link #getLock(String)}) \* to control concurrent access to the returned instance. \* \* @param roomName The name of the room to retrieve. \* @return The room \*/ @Nullable MUCRoom get(@Nonnull final String roomName) { return ROOM\_CACHE.get(roomName); }
 /\*\* \* Removes a room instance from this manager. \* \* This method will only remove the instance from management (and trigger appropriate event listeners). It will not \* remove the room from the database, if it's in there. \* \* @param roomName The name of the room to be removed. \*/ @Nullable MUCRoom remove(@Nonnull final String roomName) { //memory leak will happen if we forget remove it from GroupEventDispatcher final Lock lock = ROOM\_CACHE.getLock(roomName); lock.lock(); try { Log.trace("Removing room '{}' of service '{}'", roomName, serviceName); final MUCRoom room = ROOM\_CACHE.remove(roomName); if (room != null) { room.getRoomHistory().purge(); GroupEventDispatcher.removeListener(room); UserEventDispatcher.removeListener(room); updateNonPersistentRoomStat(room, null); } localRooms.remove(roomName); return room; } finally { lock.unlock(); } }
 /\*\* \* Removes rooms that have only been inactive since a certain date from memory. This does not destroy the room: it \* can be reloaded from the database on-demand. Note that this method is expected to operate on persistent rooms \* only, as non-persistent rooms will be destroyed immediately after the last occupant leaves. \* \* @param cleanUpDate The cut-off date. \* @return The total amount of time that the removed rooms had 'chat-time'. \*/ Duration unloadInactiveRooms(@Nonnull final Date cleanUpDate) { Duration totalChatTime = Duration.ZERO; final Set<String> roomNames = getAll().stream().map(MUCRoom::getName).collect(Collectors.toSet()); for (final String roomName : roomNames) { final Lock lock = ROOM\_CACHE.getLock(roomName); lock.lock(); try { final MUCRoom room = get(roomName); if (room != null && room.getEmptyDate() != null && room.getEmptyDate().before(cleanUpDate)) { Log.debug("Unloading chat room (due to inactivity): {}", roomName); remove(roomName); totalChatTime = totalChatTime.plus(Duration.ofMillis(room.getChatLength())); } } finally { lock.unlock(); } } return totalChatTime; }
 /\*\* \* When the local node is joining or leaving a cluster, {@link org.jivesoftware.util.cache.CacheFactory} will swap \* the implementation used to instantiate caches. This causes the cache content to be 'reset': it will no longer \* contain the data that's provided by the local node. This method restores data that's provided by the local node \* in the cache. It is expected to be invoked right after joining the cluster. \* \* This method checks whether local occupant nicknames clash with remote ones. If a clash is detected, both \* occupants are kicked out of the room. \* \* ({@link org.jivesoftware.openfire.cluster.ClusterEventListener#joinedCluster()} or leaving \* \* @param occupantManager The occupant manager that contains local occupant registration. \* @return The set of local occupants that is in the room after processing. This is the original set of local occupants of the room minus any occupants that were kicked out. \*/ public Set<OccupantManager.Occupant> restoreCacheContentAfterJoin(@Nonnull final OccupantManager occupantManager) { Log.debug( "Restoring cache content for cache '{}' after we joined the cluster, by adding all MUC Rooms that are known to the local node.", ROOM\_CACHE.getName() );
 final Set<OccupantManager.Occupant> localOccupants = occupantManager.getLocalOccupants(); final Set<OccupantManager.Occupant> occupantsToRetain = new HashSet<>(localOccupants);
 final Map<String, List<OccupantManager.Occupant>> localOccupantByRoom = localOccupants.stream().collect(Collectors.groupingBy(OccupantManager.Occupant::getRoomName));
 // The state of the rooms in the clustered cache should be modified to include our local occupants. for (Map.Entry<String, MUCRoom> localRoomEntry : localRooms.entrySet()) { final String roomName = localRoomEntry.getKey(); Log.trace("Re-adding local room '{}' to cluster cache.", roomName);
 final Lock lock = ROOM\_CACHE.getLock(roomName); lock.lock(); try { final MUCRoom localRoom = localRoomEntry.getValue(); if (!ROOM\_CACHE.containsKey(roomName)) { Log.trace("Room was not known to the cluster. Added our representation."); ROOM\_CACHE.put(roomName, localRoom); updateNonPersistentRoomStat(null, localRoom); } else { Log.trace("Room was known to the cluster. Merging our local representation with cluster-provided data."); final MUCRoom roomInCluster = ROOM\_CACHE.get(roomName);
 // Get all occupants that were provided by the local node, and add them to the cluster-representation. final List<OccupantManager.Occupant> localOccupantsToRestore = localOccupantByRoom.get(roomName); if (localOccupantsToRestore != null) { Log.trace("These occupants of the room are recognized as living on our cluster node. Adding them from the cluster-based room: {}", localOccupantsToRestore.stream().map(OccupantManager.Occupant::getRealJID).map(JID::toString).collect(Collectors.joining( ", " ))); for (OccupantManager.Occupant localOccupantToRestore : localOccupantsToRestore ) { // Get the Role for the local occupant from the local representation of the room, and add that to the cluster room. final MUCOccupant localOccupant = localRoom.getOccupantByFullJID(localOccupantToRestore.getRealJID());
 if (localOccupant == null) { Log.trace("Trying to add occupant '{}' but no role for that occupant exists in the local room. Data inconsistency?", localOccupantToRestore.getRealJID()); continue; } else { Log.trace("Found localOccupantRole {} for localOccupantToRestore {}, client route = {}", localOccupant, localOccupantToRestore.getRealJID(), XMPPServer.getInstance().getRoutingTable().getClientRoute(localOccupantToRestore.getRealJID())); }
 // OF-2165 // Check if the nickname of this occupant already existed for another user in the room. // If it did, we need to kick the users out. With sincere apologies. String nickBeingAddedToRoom = localOccupant.getNickname(); boolean occupantWasKicked = false; try { final List<MUCOccupant> existingOccupantsWithSameNick = roomInCluster.getOccupantsByNickname(nickBeingAddedToRoom); final List<JID> otherUsersWithSameNick = existingOccupantsWithSameNick.stream().map(MUCOccupant::getUserAddress).filter(bareJid -> !bareJid.equals(localOccupant.getUserAddress())).collect(Collectors.toList()); if (!otherUsersWithSameNick.isEmpty()) {
 // We will be routing presences to several users. The routing table may not have // finished updating the client routes. However those are needed for routing the // stanzas, specifically the local client route. So do that first. RoutingTable routingTable = XMPPServer.getInstance().getRoutingTable(); if (routingTable instanceof RoutingTableImpl) { RoutingTableImpl.class.cast(routingTable).addLocalClientRoutesToCache(); }
 // There is at least one remote occupant, being a different user, with the same nick. // Kick all. otherUsersWithSameNick.forEach(jid -> kickOccupantBecauseOfNicknameCollision(roomInCluster, nickBeingAddedToRoom, jid, occupantManager)); final JID localUserToBeKickedFullJid = localOccupantToRestore.getRealJID();
 // Now kick the local user. It has to be added to the room for a short instant so that it can actually be kicked out. // Normally we would do this with:// roomInCluster.addOccupantRole(localOccupantRole); // But that notifies other nodes as well about the new occupant. We don't want that, this is // entirely a local affair. Therefore perform two separate steps instead, without invoking // occupant joined events. roomInCluster.occupants.add(localOccupant); occupantManager.registerOccupantJoinedLocally(localOccupant.getOccupantJID().asBareJID(), localOccupant.getUserAddress(), localOccupant.getNickname());
 // Just added. Now kick out. kickOccupantBecauseOfNicknameCollision(roomInCluster, nickBeingAddedToRoom, localUserToBeKickedFullJid, occupantManager);
 // Inform other nodes of the kick, so they can remove the occupants from their occupant registration occupantManager.occupantNickKicked(roomInCluster.getJID(), nickBeingAddedToRoom);
 occupantWasKicked = true; } } catch (UserNotFoundException e) { // This is actually the happy path. There is no remote occupant in the room with the same nick. Proceed. }
 if (!occupantWasKicked) { roomInCluster.addOccupant(localOccupant); } else { occupantsToRetain.remove(localOccupantToRestore); } } }
 if (!roomInCluster.equals(localRoom)) { // TODO: unsure if #equals() is enough to verify equality here. Log.warn("Joined an Openfire cluster on which a room exists that clashes with a room that exists locally. Room name: '{}' on service '{}'", roomName, serviceName); // TODO: handle collision. Two nodes have different rooms using the same name. }
 // Sync room back to make cluster aware of changes. Log.debug("Re-added local room '{}' to cache, with occupants: {}", roomName, roomInCluster.getOccupants().stream().map(MUCOccupant::getUserAddress).map(JID::toString).collect(Collectors.joining( ", " ))); ROOM\_CACHE.put(roomName, roomInCluster); // The implementation of this method does not allow configuration to be changed that warrants a update toe ROOM\_CACHE\_STATS
 // TODO: update the local copy of the room with occupants, maybe? } } finally { lock.unlock(); } }
 // Add a cluster listener to clean up locally stored data when another cluster node removes it from the cache. ROOM\_CACHE.addClusteredCacheEntryListener(new ClusteredCacheEntryListener<String, MUCRoom>() { @Override public void entryAdded(@Nonnull String key, @Nullable MUCRoom newValue, @Nonnull NodeID nodeID) { }
 @Override public void entryRemoved(@Nonnull String key, @Nullable MUCRoom oldValue, @Nonnull NodeID nodeID) { localRooms.remove(key); final MultiUserChatService service = XMPPServer.getInstance().getMultiUserChatManager().getMultiUserChatService(serviceName); if (service != null) { final long roomID = -1; // Unused by OccupantManager. service.getOccupantManager().roomDestroyed(roomID, new JID(key, service.getServiceDomain(), null)); } }
 @Override public void entryUpdated(@Nonnull String key, @Nullable MUCRoom oldValue, @Nullable MUCRoom newValue, @Nonnull NodeID nodeID) { }
 @Override public void entryEvicted(@Nonnull String key, @Nullable MUCRoom oldValue, @Nonnull NodeID nodeID) { localRooms.remove(key); final MultiUserChatService service = XMPPServer.getInstance().getMultiUserChatManager().getMultiUserChatService(serviceName); if (service != null) { final long roomID = -1; // Unused by OccupantManager. service.getOccupantManager().roomDestroyed(roomID, new JID(key, service.getServiceDomain(), null)); } }
 @Override public void mapCleared(@Nonnull NodeID nodeID) { }
 @Override public void mapEvicted(@Nonnull NodeID nodeID) { } }, false, false);
 return occupantsToRetain; }
 /\*\* \* Kick a user out of a room for reason of nickname collision. \* @param room The room to kick the user out of. \* @param nickBeingAddedToRoom The nickname that is the cause of the problem. \* @param userToBeKicked The full jid of the user to be kicked. \* @param occupantManager The occupant manager that contains local occupant registration. \*/ private void kickOccupantBecauseOfNicknameCollision(MUCRoom room, String nickBeingAddedToRoom, JID userToBeKicked, @Nonnull OccupantManager occupantManager) { Log.info( "Occupant {} of room {} with nickname {} has to be kicked out because the nickname clashes with another user in the same room.", userToBeKicked, room.getName(), nickBeingAddedToRoom );
 // Kick the user from all the rooms that he/she had previously joined. try { final List<Presence> kickedPresences = room.kickOccupant(userToBeKicked, room.getSelfRepresentation().getAffiliation(), room.getSelfRepresentation().getRole(), null, null,"Nickname clash with other user in the same room.");
 for(final Presence kickedPresence : kickedPresences) { Log.trace("Kick presence to be sent to room: {}", kickedPresence);
 // Send the updated presence to the room occupants, but only those on this local node. room.send(kickedPresence, room.getSelfRepresentation()); }
 Log.debug("Kicked occupant '{}' out of room '{}'.", userToBeKicked, room.getName()); } catch (final ForbiddenException | NotAllowedException e) { // Do nothing since we cannot kick owners or admins Log.debug("Occupant '{}' not kicked out of room '{}' because of '{}'.", userToBeKicked, room.getName(), e.getMessage()); } }
 /\*\* \* When the local node is joining or leaving a cluster, {@link org.jivesoftware.util.cache.CacheFactory} will swap \* the implementation used to instantiate caches. This causes the cache content to be 'reset': it will no longer \* contain the data that's provided by the local node. This method restores data that's provided by the local node \* in the cache. It is expected to be invoked right after leaving the cluster. \* \* ({@link org.jivesoftware.openfire.cluster.ClusterEventListener#leftCluster()} a cluster. \*/ void restoreCacheContentAfterLeave(@Nullable final Set<OccupantManager.Occupant> occupantsOnRemovedNodes) { Log.debug( "Restoring cache content for cache '{}' after we left the cluster, by adding all MUC Rooms that are known to the local node.", ROOM\_CACHE.getName() );
 final Map<String, List<OccupantManager.Occupant>> occupantsOnRemovedNodesByRoom; if (occupantsOnRemovedNodes == null) { occupantsOnRemovedNodesByRoom = Collections.emptyMap(); } else { occupantsOnRemovedNodesByRoom = occupantsOnRemovedNodes.stream().collect(Collectors.groupingBy(OccupantManager.Occupant::getRoomName)); }
 for (Map.Entry<String, MUCRoom> localRoomEntry : localRooms.entrySet()) { final String roomName = localRoomEntry.getKey(); Log.trace("Re-adding local room '{}' to cluster cache.", roomName); final Lock lock = ROOM\_CACHE.getLock(roomName); lock.lock(); try { final MUCRoom room = localRoomEntry.getValue();
 // The state of the rooms in the clustered cache should be modified to remove all but our local occupants. final List<OccupantManager.Occupant> occupantsToRemove = occupantsOnRemovedNodesByRoom.get(roomName); if (occupantsToRemove != null) { Log.trace("These occupants of the room are recognized as living on another cluster node. Removing them from the room: {}", occupantsToRemove.stream().map(OccupantManager.Occupant::getRealJID).map(JID::toString).collect(Collectors.joining( ", " ))); for (OccupantManager.Occupant occupantToRemove : occupantsToRemove) { final MUCOccupant occupant = room.getOccupantByFullJID(occupantToRemove.getRealJID()); if (occupant == null) { Log.trace("Trying to remove occupant '{}' but no role for that occupant exists in the room. Data inconsistency?", occupantToRemove.getRealJID()); continue; } room.removeOccupant(occupant); } }
 // Place room in cluster cache. Log.trace("Re-added local room '{}' to cache, with occupants: {}", roomName, room.getOccupants().stream().map(MUCOccupant::getUserAddress).map(JID::toString).collect(Collectors.joining( ", " ))); ROOM\_CACHE.put(roomName, room); } finally { lock.unlock(); } } recomputeNonPersistentRoomCount(); }
 /\*\* \* This method detects rooms that we know of 'locally' (in the data structure that supports the room cache), but which \* are not (no longer) in the cache. \* \* When a cluster node crashes out of the cluster (eg: network interruption), it has been observed that the cache can \* 'break'. Presumably, the affected cache entry wasn't "physically" stored on the server, and as the network connection \* is gone, a backup cannot be obtained either. \* \* This method attempts to identify, remove and return rooms that are lost in these cases, which is intended to be \* used (only) when processing a "cluster break" event. \* \* @return room names that were known to the local server, but not (any more) in the clustered cache. \*/ @Nonnull public synchronized Set<String> detectAndRemoveLostRooms() { Log.debug("Looking for rooms that have 'dropped out' of the cache (likely as a result of a network failure).");
 final Set<String> localRoomNames = localRooms.keySet(); final Set<String> cachedRoomNames = ROOM\_CACHE.keySet(); final Set<String> roomNamesNotInCache = new HashSet<>(localRoomNames); roomNamesNotInCache.removeAll(cachedRoomNames);
 if (roomNamesNotInCache.isEmpty()) { Log.debug("Found no rooms that are missing from the cache."); } else { Log.info("Found {} rooms that we know locally, but are not (no longer) in the cache. This can occur when a cluster node fails, but should not occur otherwise. Missing rooms: {}", roomNamesNotInCache.size(), String.join(", ", roomNamesNotInCache)); localRooms.keySet().removeAll(roomNamesNotInCache); } return roomNamesNotInCache; }
 public Cache<String, MUCRoom> getROOM\_CACHE() { return ROOM\_CACHE; }
 public Map<String, MUCRoom> getLocalRooms() { return localRooms; }
 /\*\* \* Modifies the statistic in {@link #ROOM\_CACHE\_STATS} that keeps a count of all non-persisted MUC rooms \* (key: {@link #STAT\_KEY\_ROOMCOUNT\_NONPERSISTENT}), based on a rooms that are removed from or added to {@link #ROOM\_CACHE} \* \* @param oldValue a room that was removed from {@link #ROOM\_CACHE} \* @param newValue a room that was added to {@link #ROOM\_CACHE} \*/ private void updateNonPersistentRoomStat(@Nullable final MUCRoom oldValue, @Nullable final MUCRoom newValue) { int delta = 0; if (oldValue != null && !oldValue.isPersistent()) { delta--; } if (newValue != null && !newValue.isPersistent()) { delta++; } if (delta < 0) { decrementStatistic(STAT\_KEY\_ROOMCOUNT\_NONPERSISTENT); } else if (delta > 0) { incrementStatistic(STAT\_KEY\_ROOMCOUNT\_NONPERSISTENT); } }
 /\*\* \* Increments (+1) a number-based value of a statistic as maintained in {@link #ROOM\_CACHE\_STATS}. \* \* @param key the key used to store the statistic in the cache. \*/ private void incrementStatistic(@Nonnull final String key) { final Lock lock = ROOM\_CACHE\_STATS.getLock(key); lock.lock(); try { Long count = ROOM\_CACHE\_STATS.getOrDefault(key, 0L); count++; ROOM\_CACHE\_STATS.put(key, count); } finally { lock.unlock(); } }
 /\*\* \* Decrements (-1) a number-based value of a statistic as maintained in {@link #ROOM\_CACHE\_STATS}. \* \* @param key the key used to store the statistic in the cache. \*/ private void decrementStatistic(@Nonnull final String key) { final Lock lock = ROOM\_CACHE\_STATS.getLock(key); lock.lock(); try { Long count = ROOM\_CACHE\_STATS.getOrDefault(key, 0L); count--; ROOM\_CACHE\_STATS.put(key, count); } finally { lock.unlock(); } }
 /\*\* \* Iterates over all MUC rooms (in the cache, non-cached rooms are obviously not non-persistent) and counts the \* number of non-persistent rooms. \* \* This method is more resource intensive, but perhaps more accurate, than {@link #getNonPersistentRoomCount()}. \* \* @return The count of non-persistent MUC rooms. \*/ public long recomputeNonPersistentRoomCount() { final long count = getAll().stream().filter(room -> !room.isPersistent()).count(); final Lock lock = ROOM\_CACHE\_STATS.getLock(STAT\_KEY\_ROOMCOUNT\_NONPERSISTENT); lock.lock(); try { final Long oldCount = ROOM\_CACHE\_STATS.put(STAT\_KEY\_ROOMCOUNT\_NONPERSISTENT, count); if (oldCount != null && oldCount != count) { Log.warn("Recomputed the amount of non persistent MUC rooms. The amount registered was {}, while the new count is {}", oldCount, count); } return count; } finally { lock.unlock(); } }
 /\*\* \* Returns a count of all rooms that are non-persistent. \* \* The statistic returned by this method is based on a derived value. It is not based on a direct re-evaluation of \* each room. \* \* This method is not as resource intensive, but perhaps less accurate, than {@link #recomputeNonPersistentRoomCount()}. \* \* @return The count of non-persistent MUC rooms. \*/ public long getNonPersistentRoomCount() { final Lock lock = ROOM\_CACHE\_STATS.getLock(STAT\_KEY\_ROOMCOUNT\_NONPERSISTENT); lock.lock(); try { return ROOM\_CACHE\_STATS.getOrDefault(STAT\_KEY\_ROOMCOUNT\_NONPERSISTENT, 0L); } finally { lock.unlock(); } }}

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from www.igniterealtime.org_ab6a2f57_20250110_153424.html ===


1. [Home](/)
2. [Projects](/projects/)
3. [Downloads](/downloads/)
4. [Community](https://discourse.igniterealtime.org/)
5. [Fans](/fans/)
6. [Support](/support/)
7. [News](/news/)

* [Openfire](./)
* [Plugins](plugins.jsp)
* [Documentation](documentation.jsp)
* [Issue Tracker](https://issues.igniterealtime.org/browse/OF)
* [JavaDocs](https://download.igniterealtime.org/openfire/docs/latest/documentation/javadoc/)
* [Connection Manager Module](connection_manager.jsp)

# Openfire4.9.2

Openfire is a real time collaboration (RTC) server licensed under the Open Source Apache License. It
uses the only widely adopted open protocol for instant messaging, XMPP Openfire is incredibly easy
to setup and administer, but offers rock-solid security and performance.

![](../../images/ignite_screenshot_openfire3.gif)[Download](../../downloads/#openfire)**Openfire 4.9.2** Latest release: November 11, 2024
# Openfire4.9.2

Latest [Blog](https://discourse.igniterealtime.org//tags/c/blogs/ignite-realtime-blogs/5/openfire) Entries
[![](/images/rss.gif)](https://discourse.igniterealtime.org//c/blogs/ignite-realtime-blogs.rss)![Guus der Kinderen](https://discourse.igniterealtime.org//user_avatar/discourse.igniterealtime.org/guus/32/9043_2.png)[1](https://discourse.igniterealtime.org/t/version-1-2-0-of-threaddump-plugin-released)
## [Version 1.2.0 of Threaddump plugin Released!](https://discourse.igniterealtime.org/t/version-1-2-0-of-threaddump-plugin-released "Version 1.2.0 of Threaddump plugin Released!")

Posted by [Guus der Kinderen](https://discourse.igniterealtime.org/u/guus)2 months, 6 days ago

Today, we’ve released a new version of the Threaddump plugin for Openfire: version 1.2.0.

The Threaddump plugin is a handy plugin to collect diagnostics, useful for drilling down into the inner workings of Openfire. It can be of great value for developers, but is of little use to others.

In this new release, compatibility with Openfire versions 4.8.0 and later has been restored! To do so, some functionality was sacrificed: the plugin will no longer offer the possibility to automatically generate thread dumps when core thread pools reach a certain level of activity.

As always, your instance of Openfire should automatically make available to update in the next few hours. Alternatively, you can download the new release of the plugin at the [Threaddump plugin’s archive page](https://www.igniterealtime.org/projects/openfire/plugin-archive.jsp?plugin=threaddump).

For other release announcements and news follow us on [Mastodon](https://toot.igniterealtime.org/%40news) or [X](https://x.com/IgniteRealtime)

Tags:
openfire, release
[1](https://discourse.igniterealtime.org/t/version-1-2-0-of-threaddump-plugin-released)![Guus der Kinderen](https://discourse.igniterealtime.org//user_avatar/discourse.igniterealtime.org/guus/32/9043_2.png)[6](https://discourse.igniterealtime.org/t/openfire-4-9-1-release)
## [Openfire 4.9.1 release](https://discourse.igniterealtime.org/t/openfire-4-9-1-release "Openfire 4.9.1 release")

Posted by [Guus der Kinderen](https://discourse.igniterealtime.org/u/guus)2 months, 1 week ago

The [Ignite Realtime community](https://www.igniterealtime.org/) is happy to be able to announce the immediate availability of version 4.9.1 of [Openfire](https://www.igniterealtime.org/projects/openfire/), its cross-platform real-time collaboration server based on the XMPP protocol!

4.9.1 is a bugfix and maintenance release. Among its most important fixes is one for a memory leak that affected all recent versions of Openfire (but was likely noticeable only on those servers that see high volume of users logging in and out). The complete list of changes that have gone into this release can be seen in the [change log](https://download.igniterealtime.org/openfire/docs/latest/changelog.html).

Please give this version a try! You can [download installers of Openfire here](https://igniterealtime.org/downloads/#openfire). Our documentation contains an [upgrade guide](https://download.igniterealtime.org/openfire/docs/latest/documentation/upgrade-guide.html) that helps you update from an older version.

The integrity of these artifacts can be checked with the following `sha256sum` values:

```
8c489503f24e35003e2930873037950a4a08bc276be1338b6a0928db0f0eb37d  openfire-4.9.1-1.noarch.rpm
1e80a119c4e1d0b57d79aa83cbdbccf138a1dc8a4086ac10ae851dec4f78742d  openfire_4.9.1_all.deb
69a946dacd5e4f515aa4d935c05978b5a60279119379bcfe0df477023e7a6f05  openfire_4_9_1.dmg
c4d7b15ab6814086ce5e8a1d6b243a442b8743a21282a1a4c5b7d615f9e52638  openfire_4_9_1.exe
d9f0dd50600ee726802bba8bc8415bf9f0f427be54933e6c987cef7cca012bb4  openfire_4_9_1.tar.gz
de45aaf1ad01235f2b812db5127af7d3dc4bc63984a9e4852f1f3d5332df7659  openfire_4_9_1_x64.exe
89b61cbdab265981fad4ab4562066222a2c3a9a68f83b6597ab2cb5609b2b1d7  openfire_4_9_1.zip

```

We would love to hear from you! If you have any questions, please stop by our [community forum](https://discourse.igniterealtime.org/) or our [live groupchat](https://www.igniterealtime.org/support/group_chat.jsp). We are always looking for volunteers interested in helping out with Openfire development!

For other release announcements and news follow us on [Mastodon](https://toot.igniterealtime.org/%40news) or [X](https://x.com/IgniteRealtime)

Tags:
openfire, planetjabber, release
[6](https://discourse.igniterealtime.org/t/openfire-4-9-1-release)![Guus der Kinderen](https://discourse.igniterealtime.org//user_avatar/discourse.igniterealtime.org/guus/32/9043_2.png)[6](https://discourse.igniterealtime.org/t/openfire-4-9-0-release)
## [Openfire 4.9.0 release!](https://discourse.igniterealtime.org/t/openfire-4-9-0-release "Openfire 4.9.0 release!")

Posted by [Guus der Kinderen](https://discourse.igniterealtime.org/u/guus)3 months, 3 weeks ago

The [Ignite Realtime community](https://www.igniterealtime.org/) is happy to be able to announce the immediate availability of version 4.9.0 of [Openfire](https://www.igniterealtime.org/projects/openfire/), its cross-platform real-time collaboration server based on the XMPP protocol!

As compared to the previous non-patch release, this one is a bit smaller. This mostly is a maintenance release, and includes some preparations (deprecations, mainly) for a future release.

Highlights for this release:

* A problem has been fixed that caused, under certain conditions, a client connection to be disconnected. This appears to have affected clients sending multi-byte character data more than others.
* Community member Akbar Azimifar has provided a full Persian translation for Openfire!

The list of changes that have gone into the Openfire 4.9.0 release has some more items though! Please review the [change log](https://download.igniterealtime.org/openfire/docs/latest/changelog.html) for all of the details.

Interested in getting started? You can [download installers of Openfire here](https://igniterealtime.org/downloads/#openfire). Our documentation contains an [upgrade guide](https://download.igniterealtime.org/openfire/docs/latest/documentation/upgrade-guide.html) that helps you update from an older version.

The integrity of these artifacts can be checked with the following `sha256sum` values:

```
7973cc2faef01cb2f03d3f2ec59aff9b2001d16b2755b4cc0da48cc92b74d18a  openfire-4.9.0-1.noarch.rpm
a0cd627c629b00bb65b6080e06b8d13376ec0a4170fd27e863af0573e3b4f791  openfire_4.9.0_all.deb
bf62c02b0efe1d37fc505f6942a9cf058975746453d6d0218007b75b908a5c3c  openfire_4_9_0.dmg
1082d9864df897befa47230c251d91ec0780930900b2ab2768aaabd96d7b5dd9  openfire_4_9_0.exe
12a4a5e5794ecb64a7da718646208390d0eb593c02a33a630f968eec6e5a93a0  openfire_4_9_0.tar.gz
c86bdb1c6afd4e2e013c4909a980cbac088fc51401db6e9792d43e532963df72  openfire_4_9_0_x64.exe
97efe5bfe8a7ab3ea73a01391af436096a040d202f3d06f599bc4af1cd7bccf0  openfire_4_9_0.zip

```

We would love to hear from you! If you have any questions, please stop by our [community forum](https://discourse.igniterealtime.org/) or our [live groupchat](https://www.igniterealtime.org/support/group_chat.jsp). We are always looking for volunteers interested in helping out with Openfire development!

For other release announcements and news follow us on [Mastodon](https://toot.igniterealtime.org/%40news) or [X](https://x.com/IgniteRealtime)

Tags:
openfire, planetjabber, release
[6](https://discourse.igniterealtime.org/t/openfire-4-9-0-release)![Guus der Kinderen](https://discourse.igniterealtime.org//user_avatar/discourse.igniterealtime.org/guus/32/9043_2.png)[1](https://discourse.igniterealtime.org/t/openfire-http-file-upload-plugin-v1-4-1-release)
## [Openfire HTTP File Upload plugin v1.4.1 release!](https://discourse.igniterealtime.org/t/openfire-http-file-upload-plugin-v1-4-1-release "Openfire HTTP File Upload plugin v1.4.1 release!")

Posted by [Guus der Kinderen](https://discourse.igniterealtime.org/u/guus)3 months, 3 weeks ago

We have now released version 1.4.1 of the HTTP File Upload plugin!

This plugin adds functionality to Openfire that allows clients to share files, as defined in the [XEP-0363 ‘HTTP File Upload’ specification](https://xmpp.org/extensions/xep-0363.html).

This release brings [two changes](https://www.igniterealtime.org/projects/openfire/plugins/1.4.1/httpfileupload/changelog.html), both provided by community members (thanks!):

* Vladislav updated the Ukrainian translation;
* Anno created an admin console page for this plugin.

As always, your instance of Openfire should automatically make available to update in the next few hours. Alternatively, you can download the new release of the plugin at the [HTTP File Upload plugin’s archive page](https://www.igniterealtime.org/projects/openfire/plugin-archive.jsp?plugin=httpfileupload).

For other release announcements and news follow us on [Mastodon](https://toot.igniterealtime.org/%40news) or [X](https://x.com/IgniteRealtime)

Tags:
openfire, planetjabber, release
[1](https://discourse.igniterealtime.org/t/openfire-http-file-upload-plugin-v1-4-1-release)![Guus der Kinderen](https://discourse.igniterealtime.org//user_avatar/discourse.igniterealtime.org/guus/32/9043_2.png)[1](https://discourse.igniterealtime.org/t/openfire-hazelcast-plugin-version-3-0-0)
## [Openfire Hazelcast plugin version 3.0.0](https://discourse.igniterealtime.org/t/openfire-hazelcast-plugin-version-3-0-0 "Openfire Hazelcast plugin version 3.0.0")

Posted by [Guus der Kinderen](https://discourse.igniterealtime.org/u/guus)3 months, 4 weeks ago

Earlier today, [we blogged about a boatload of Openfire plugins](https://discourse.igniterealtime.org/t/openfire-plugin-maintenance-releases) for which we made available maintenance releases.

Apart from that, we’ve also made a more notable release: that of the Hazelcast plugin for Openfire.

The [Hazelcast plugin for Openfire](https://www.igniterealtime.org/projects/openfire/plugin-archive.jsp?plugin=hazelcast) adds clustering support to Openfire. It is based on [the Hazelcast platform](https://hazelcast.com/).

This release brings a major upgrade of the platform. It migrates from version 3.12.5 to 5.3.7.

As a result, replacing an older version of the plugin with this new release requires some careful planning. Notably, the configuration stored on-disk has changed (and is unlikely to be compatible between versions). Please refer to the readme of the plugin for details.

A big thank you goes out to community member Arwen for making this upgrade happen!

As usual, the new version of the plugin will become available in your Openfire server within the next few hours. Alternatively, you can download the plugin from [its archive page](https://www.igniterealtime.org/projects/openfire/plugin-archive.jsp?plugin=hazelcast).

For other release announcements and news follow us on [Mastodon](https://toot.igniterealtime.org/%40news) or [X](https://x.com/IgniteRealtime)

Tags:
openfire, planetjabber, release
[1](https://discourse.igniterealtime.org/t/openfire-hazelcast-plugin-version-3-0-0)

| [dwd](https://discourse.igniterealtime.org/u/dwd) | **[dwd](https://discourse.igniterealtime.org/u/dwd)** Tech wizard by trade, problem solver by nature, pun master by choice. |
| --- | --- |

**Latest Build** 4.9.2
**Downloads** 9,468,905
**License** Open Source Apache
**Platforms** Windows, Linux, Unix, Mac OS X

# Latest Discussions

![](https://discourse.igniterealtime.org//letter_avatar_proxy/v4/letter/r/a3d4f5/16.png)
**Rakesh Moradiya** in "[RE: Openfire enable stream management in strophe.js in reactJS](https://discourse.igniterealtime.org/t/re-openfire-enable-stream-management-in-strophe-js-in-reactjs)"

![](https://discourse.igniterealtime.org//letter_avatar_proxy/v4/letter/b/5f8ce5/16.png)
**bashkim** in "[Installation instructions for RPM Linux](https://discourse.igniterealtime.org/t/installation-instructions-for-rpm-linux)"

![](https://discourse.igniterealtime.org//user_avatar/discourse.igniterealtime.org/felix_roble/16/11082_2.png)
**Felix Roble** in "[Problemas de acceso aconsola](https://discourse.igniterealtime.org/t/problemas-de-acceso-aconsola)"

![](https://discourse.igniterealtime.org//user_avatar/discourse.igniterealtime.org/zhou_joe/16/11069_2.png)
**zhou joe** in "[Does openfire has any plan to fix the CVE-2024-6763](https://discourse.igniterealtime.org/t/does-openfire-has-any-plan-to-fix-the-cve-2024-6763)"

![](https://discourse.igniterealtime.org//letter_avatar_proxy/v4/letter/y/87869e/16.png)
**youssefJoo** in "[Client Unable to Reconnect After Connection Loss in Openfire 4.7.3 on Docker Swarm](https://discourse.igniterealtime.org/t/client-unable-to-reconnect-after-connection-loss-in-openfire-4-7-3-on-docker-swarm)"

[Home](/) | [Projects](/projects/) | [Downloads](/downloads/) | [Community](https://discourse.igniterealtime.org/) | [Fans](/fans/) | [Support](/support/) | [News](/news/)



=== Content from www.hackthebox.com_ade53d96_20250110_153419.html ===


[![Hack The Box: Cybersecurity Training ](/images/landingv3/logo-htb-blog.svg)](/blog)
Popular Topics

* [JOIN NOW](https://account.hackthebox.com/register%20)

[ALL](/blog)
[Red Teaming](/blog/category/red-teaming)
[Blue Teaming](/blog/category/blue-teaming)
[Cyber Teams](/blog/category/cyber-teams)
[Education](/blog/category/education)
[CISO Diaries](/blog/category/ciso-diaries)
[Events](/blog/category/events)
[HTB Insider](/blog/category/htb-insider)
[Customer Stories](/blog/category/customer-stories)
[Write-Ups](/blog/category/write-ups)
[CVE Explained](/blog/category/cve-explained)
[News](/blog/category/news)
[Career Stories](/blog/category/career-stories)
[Humans of HTB](/blog/category/humans-of-htb)

CVE Explained

8
min read

# Openfire CVEs explained (CVE-2024-25420 & CVE-2024-25421)

## An in-depth look at Openfire CVEs (CVE-2024-25420 & CVE-2024-25421): featuring two improper access control issues affecting the application.

[![xRogue avatar](/images/landingv3/blog/authors/placeholder.webp)](https://www.hackthebox.com/blog/author/xRogue)

[xRogue](https://www.hackthebox.com/blog/author/xRogue),

Mar 26

2024

![Hack The Box Article](https://www.hackthebox.com/storage/blog/gjLIGRDug2949V11AeJYQhFaQlOwi9Y2.jpg)

#### Table of Contents

* [What are CVE-2024-25420 & CVE-2024-25421?](#mcetoc_1hpt7q8ga6qd)
* [Steps to exploit CVE-2024-25420](#mcetoc_1hpt7q8ga6qe)
* [Steps to exploit CVE-2024-25421](#mcetoc_1hpt7q8ga6qf)
* [Analyzing CVE-2024-25420](#mcetoc_1hpt7q8ga6qg)
* [Analyzing CVE-2024-25421](#mcetoc_1hpt7q8ga6qh)
* [Impact of Openfire CVEs](#mcetoc_1hpt7q8ga6qi)
  + [CVE-2024-25420](#mcetoc_1hpt7q8ga6qj)
  + [CVE-2024-25421](#mcetoc_1hpt7q8ga6qk)
* [Stay ahead of threats with Hack The Box](#mcetoc_1hpt7q8ga6ql)

Openfire is a real-time collaboration (RTC) server licensed under the Open Source Apache License. It is written in Java and uses the XMPP protocol for instant messaging. During our work, Hack The Box was able to identify two improper access control issues affecting the application.

## What are CVE-2024-25420 & CVE-2024-25421?

The first issue lies in the way the application is managing deleted administrative users. When an administrative user is created, his admin privileges are saved in a system property called admin.authorizedJIDs and the key used is the account’s username. If the administrative user is deleted, his username is not deleted from the admin.authorizedJIDs system property.

This way, if a new user is created with the same username, the new user is automatically an administrator. The new user does not need to be created from the administrative panel of the application. It can be created through an XMPP registration. This issue is registered as CVE-2024-25420.

The second issue is similar, but the underlying cause is different.

If a user is added to a group chat, his affiliation along with other related data are stored in the cache.

When this user is deleted, the cache is not updated to reflect the new state of the group, allowing a new user with the same username to gain access to the group chat with the same level of privileges as the previously deleted user. This issue is registered as CVE-2024-25421.

## Steps to exploit CVE-2024-25420

To replicate this vulnerability, take the following steps:

1. Create an admin user.

![](data:image/png;base64...)

2. Delete the admin user.

![](data:image/png;base64...)

3. Create a new user with the same username as the deleted admin user. We created the user through XMPP using pidgin for this example.

![](data:image/png;base64...)

4. Log in with the new account through the web application.

![](data:image/png;base64...)

## Steps to exploit CVE-2024-25421

To replicate CVE-2024-25421, take the following steps:

1. Create a new user and add him to a group chat (under any affiliation – for this example, Admin).

![](data:image/png;base64...)

2. Delete the user.

![](data:image/png;base64...)

3. Notice that the user is still in the admin list of the group chat.

![](data:image/png;base64...)

4. Create a new user with the same username.

![](data:image/png;base64...)

5. Search through the group list and notice the user has access to the group chat.

![](data:image/png;base64...)

6. Notice that the user can see previous messages and perform the actions that correspond to his role (for example, if he was an owner he could do run/config).

![](data:image/png;base64...)

## Analyzing CVE-2024-25420

During user creation, when the admin checkbox is ticked, the isUserAdmin() function of the AdminManager class is called.

```
public boolean isUserAdmin(String username, boolean allowAdminIfEmpty) {
    if (adminList == null {
    loadAdminList() ;
    }
    if (allowAdminIfEmpty && adminList.isEmpty()) {
        return "admin".equals(username) ;
    }
    JID userJID = XMPPServer.getInstance().createJID(username, null);

    return adminlist.contains(userJID);
}

```

The function initially returns false, since the username is not present in the adminList variable, which contains the values of the admin.authorizedJIDs system property. If this function returns false, the addAdminAccount function of the AdminManager class is called, which adds the user to the adminList.

```
public void addAdminAccount(String username) {
    if (adminList == null) {
        loadAdminList();
    }

    JID userJID = XMPPServer.getInstance().createJID(username, null);
    if (adminList.contains(userJID)) {
        // Already have them.
        return;
    }

    // Add new admin to cache.
    adminList.add(userJID);
    // Store updated list of admins with provider.
    provider.setAdmins(adminList);
}

```

The function essentially leads to the setValue() function of the SystemProperty class which sets the property through the JiveGlobals.setProperty() function.

```
public void setValue(final T value) {
    JiveGlobals.setProperty(key, TO_STRING.get(getConverterClass()).apply(value, this), isEncrypted());
}

```

Although on user creation the admin.authorizedJIDs system property is edited accordingly, the same operation is not performed during user deletion. On user deletion, the deleteUser() function from the UserManager class is called.

```
public void deleteUser(final User user) {
    if (provider.isReadOnly()) {
        throw new UnsupportedOperationException("User provider is read-only.");
    }

    final String username = user.getUsername();
    // Make sure that the username is valid.
    try {
        /*username =*/ Stringprep.nodeprep(username);
    }
    catch (final StringprepException se) {
        throw new IllegalArgumentException("Invalid username: " + username, se);
    }

    // Fire event.
    final Map<String,Object> params = Collections.emptyMap();
    UserEventDispatcher.dispatchEvent(user, UserEventDispatcher.EventType.user_deleting, params);

    provider.deleteUser(user.getUsername());
    // Remove the user from cache.
    userCache.remove(user.getUsername());
}

```

This is the base function that fires off a series of events (especially through the dispatchEvent() function) that ensures proper user deletion.

At no point during these operations or the ones that come after, should you perform the same kind of operation (setProperty) on the system property as the create user operations did. The function for deletion of the username from the system property exists:

```
public void removeAdminAccount(String username) {
    if (adminList == null) {
        loadAdminList();
    }
    JID userJID = XMPPServer.getInstance().createJID(username, null);
    if (!adminList.contains(userJID)) {
        return;
    }
    // Remove user from admin list cache.
    adminList.remove(userJID);
    // Store updated list of admins with provider.
    provider.setAdmins(adminList);
}

```

(removeAdminAccount() on AdminManager class) but it is never called. The result is, that the username remains in the admin.authorizedJIDs system property even if the user is deleted.

This way, if another user creates a new user with the same username as the deleted user, the isUserAdmin() function will return true, granting access to the administration panel.

## Analyzing CVE-2024-25421

When the group chat management page is visited, one of the functions that is being called is the getChatRoom() function from the MultiUserChatService class.

This function tries to load the room properties from the ROOM\_CACHE, but if the room cache is not initialized, it initializes it from the database (which is where the room’s original properties are stored for consistency) and stores it in the ROOM\_CACHE at the end of the if condition.

```
public MUCRoom getChatRoom(@Nonnull final String roomName, @Nonnull final JID userjid) throws NotAllowedE
    MUCRoom room;
    boolean loaded = false;
    boolean created = false;
    final Lock lock = localMUCRoomManager.getLock(roomName);
    lock.lock();
    try {
        room = localMUCRoomManager.get(roomName); // Get from ROOM_CACHE
        if (room == null) {
            room = new MUCRoom(this, roomName);
            // If the room is persistent Load the configuration values from the DB
            try {
                // Try to load the room's configuration from the database (if the room is
                // persistent but was added to the DB after the server was started up or the
                // room may be an old room that was not present in memory)
                MUCPersistenceManager.loadFromDB(room); // Load from DB if not found
                loaded = true;
    }
}
localMUCRoomManager.add(room);

```

This ROOM\_CACHE value will not change until the web server is restarted, for two reasons:

1. The expiry date is set to never expire.

```
LocalMUCRoomManager(@Nonnull final MultiUserChatService service)
{
    this.serviceName = service.getServiceName();
    Log.debug("Instantiating for service '{}':, serviceName);
    ROOM_CACHE = CacheFactory.createCache("MUC Service '" + serviceName + "' Rooms");
    ROOM_CACHE.setMaxLifetime(-1);
    ROOM_CACHE.setMaxCacheSize(-1L);
    ROOM_CACHE_STATS = CacheFactory.createCache("MUC Service '" + serviceName + "' Room Statistics");
    ROOM_CACHE_STATS.setMaxLifetime(-1);
    ROOM_CACHE_STATS.setMaxCacheSize(-1L);
}

```

2. At no point in the communication between the client and the server, the ROOM\_CACHE is re-evaluated (not even after user deletion which is what we are after here).

Since the ROOM\_CACHE will continue to include the deleted user in its properties, and it is not refreshed after user deletion, a user that creates a new user with the same username, will have access to the group chat with the corresponding affiliation, until the ROOM\_CACHE is refreshed (which in this case, until the server restarts, since the expiry is to never expire).

## Impact of Openfire CVEs

### **CVE-2024-25420**

Users can bruteforce known commonly used administrator usernames during registration, in hopes of finding a deleted admin account to gain access to the admin panel. Deletion of the default “admin” user is common, making this attack easier to perform.

This attack vector is even more prevalent if the attacker has some internal knowledge of the organization (for example if they already have gained access to the company’s internal network) and tries to bruteforce known usernames.

Even from the public internet, attackers can figure out a wordlist of possible usernames through OSINT sources (e.g. LinkedIn), especially of former employees, to use against the service.

### **CVE-2024-25421**

Since websites are generally aiming for a constant workflow and don’t restart often, the impact of the specific bug can be quite significant.

An attacker can brute force registration of OSINT gathered usernames and then try to refresh the group chat list of each account they registered in hopes of gaining access to the group chats that a now-deleted user had.

This becomes even more prevalent in internal environments, where the attacker could gather information about users that have been deleted/left the organization etc.

## Stay ahead of threats with Hack The Box

At HTB, we release new content every month based on recent threats and vulnerabilities. Keep your team up to speed on the latest CVEs using HTB Enterprise Platform:

[Train on the latest threats](https://enterprise.hackthebox.com/login)

| **Author bio: Stavros Manis (xRogue), Content Engineer, Hack The Box**  Stavros Manis works as a Content Engineer at Hack the Box, where he ensures the Machines on the platform are high-quality and realistic.  He has experience as a penetration tester, working on security projects for big companies in finance, health, and construction. He also has experience in cybersecurity defense, having worked as a SOC analyst in Greece to help protect companies' users and assets.  You can find him on [LinkedIn](https://gr.linkedin.com/in/stavros-manis-9a93a41ab) and [Twitter](https://twitter.com/_xRogue__). |
| --- |

## Latest News

[![Hack the Box Blog](/storage/blog/AYGrs5RGIPsFvPrV1mPJbybUIZlUfOjo.jpg)

Red Teaming

10
min read

## How to write better security reports (for techies & execs)

[![Adam Luvshis (FalconSpy) avatar](/images/landingv3/blog/authors/placeholder.webp)](https://www.hackthebox.com/blog/author/Adam%20Luvshis%20%28FalconSpy%29)
[![Grahame Turner avatar](/images/landingv3/blog/authors/placeholder.webp)](https://www.hackthebox.com/blog/author/Grahame%20Turner)

[Adam Luvshis (FalconSpy)](https://www.hackthebox.com/blog/author/Adam%20Luvshis%20%28FalconSpy%29)
&

[Grahame Turner](https://www.hackthebox.com/blog/author/Grahame%20Turner)
,
Jan 08,
2025](https://www.hackthebox.com/blog/security-report-writing)

[![Hack the Box Blog](/storage/blog/jkT6J2CcLvBvFrfgPDMzENOuSe45NXfX.jpg)

Events

4
min read

## HTB University CTF 2024 recap

[![JXoaT avatar](/images/landingv3/blog/authors/JXoaT.png)](https://www.hackthebox.com/blog/author/JXoaT)
[JXoaT](https://www.hackthebox.com/blog/author/JXoaT), Dec 31,
2024](https://www.hackthebox.com/blog/htb-university-ctf-2024-recap)

[![Hack the Box Blog](/storage/blog/IS13beT8mIAYHkMCOJ8LcJyYmsZp2PcM.jpg)

Red Teaming

6
min read

## Hit the neon streets of Sunset Bay in Season 7 Vice!

[![JXoaT avatar](/images/landingv3/blog/authors/JXoaT.png)](https://www.hackthebox.com/blog/author/JXoaT)
[JXoaT](https://www.hackthebox.com/blog/author/JXoaT), Dec 30,
2024](https://www.hackthebox.com/blog/HTB-Season-7-Vice)

![Hack The Blog](/images/landingv3/logo-htb-blog.svg)
## The latest news and updates, direct from Hack The Box

[Read More](https://www.hackthebox.com/blog)

Products

Individuals

[HTB Academy](https://academy.hackthebox.com)
[HTB Labs](https://www.hackthebox.com/hacker/hacking-labs)
[Elite Red Team Labs](https://www.hackthebox.com/hacker/pro-labs)
[Capture The Flag](https://www.hackthebox.com/hacker/ctf)
[Certifications](https://academy.hackthebox.com/preview/certifications)

Teams

[Academy for Business](https://academy.hackthebox.com/academy-for-business)
[Dedicated Labs](https://www.hackthebox.com/business/dedicated-labs)
[Professional Labs](https://www.hackthebox.com/business/professional-labs)
[BlackSky: Cloud Labs](https://www.hackthebox.com/business/professional-labs/cloud-labs-blacksky)
[Start a free trial](https://enterprise.hackthebox.com/create-company)

Solutions

Industries

[Government](https://resources.hackthebox.com/government)
[Finance](https://www.hackthebox.com/industry/finance)
[Manufacturing](https://resources.hackthebox.com/manufacturing)
[Healthcare](https://resources.hackthebox.com/healthcare)
[Consulting](https://www.hackthebox.com/industry/professional-services)

Pricing

[For Individuals](https://www.hackthebox.com/hacker/pricing)
[For Teams](https://www.hackthebox.com/business/pricing)

Resources

Community

[Blog](https://www.hackthebox.com/blog)
[Upcoming Events](https://www.hackthebox.com/events)
[Meetups](https://www.hackthebox.com/meetups)
[Affiliate Program](https://resources.hackthebox.com/affiliates)
[SME Program](https://resources.hackthebox.com/become-an-htb-subject-matter-expert)
[Ambassador Program](https://www.hackthebox.com/host-a-meetup)
[Parrot OS](https://parrotsec.org/)

Get Help

[Help Center](https://help.hackthebox.com)
[Contact Support](https://www.hackthebox.com/contact-us)

Company

[About us](https://www.hackthebox.com/about-us)
[Careers](https://www.hackthebox.com/join-us)
[Social Impact](https://www.hackthebox.com/community)
[Brand Guidelines](https://drive.google.com/file/d/1HVUeR2Kk4zNEojqqgvow1RAQgKqhptFn/view)
[Certificate Validation](https://www.hackthebox.com/certificates)
[Legal](https://www.hackthebox.com/legal)

Contact us

[Press](https://www.hackthebox.com/blog/category/news)
[Partners](https://www.hackthebox.com/channel-partners)
[Enterprise Sales](https://www.hackthebox.com/business-cyber-security-training)

Store

[HTB Swag](https://hackthebox.store)
[Buy Gift Cards](https://www.hackthebox.com/giftcards)

Cookie
Settings
[Privacy Policy](https://resources.hackthebox.com/hubfs/Legal/PN.pdf)

[User Agreement](https://resources.hackthebox.com/hubfs/Legal/UA.pdf)

© 2025 Hack The Box

Products

Individuals

[HTB Academy](https://academy.hackthebox.com)
[HTB Labs](https://www.hackthebox.com/hacker/hacking-labs)
[Elite Red Team Labs](https://www.hackthebox.com/hacker/pro-labs)
[Capture The Flag](https://www.hackthebox.com/hacker/ctf)
[Certifications](https://academy.hackthebox.com/preview/certifications)

Teams

[Academy for Business](https://academy.hackthebox.com/academy-for-business)
[Dedicated Labs](https://www.hackthebox.com/business/dedicated-labs)
[Professional Labs](https://www.hackthebox.com/business/professional-labs)
[BlackSky: Cloud Labs](https://www.hackthebox.com/business/professional-labs/cloud-labs-blacksky)
[Start a free trial](https://enterprise.hackthebox.com/create-company)

Solutions

Industries

[Government](https://resources.hackthebox.com/government)
[Finance](https://www.hackthebox.com/industry/finance)
[Manufacturing](https://resources.hackthebox.com/manufacturing)
[Healthcare](https://resources.hackthebox.com/healthcare)
[Consulting](https://www.hackthebox.com/industry/professional-services)

Pricing

[For Individuals](https://www.hackthebox.com/hacker/pricing)
[For Teams](https://www.hackthebox.com/business/pricing)

Resources

Community

[Blog](https://www.hackthebox.com/blog)
[Upcoming Events](https://www.hackthebox.com/events)
[Meetups](https://www.hackthebox.com/meetups)
[Affiliate Program](https://resources.hackthebox.com/affiliates)
[SME Program](https://resources.hackthebox.com/become-an-htb-subject-matter-expert)
[Ambassador Program](https://www.hackthebox.com/host-a-meetup)
[Parrot OS](https://parrotsec.org/)

Get Help

[Help Center](https://help.hackthebox.com)
[Contact Support](https://www.hackthebox.com/contact-us)

Company

[About us](https://www.hackthebox.com/about-us)
[Careers](https://www.hackthebox.com/join-us)
[Social Impact](https://www.hackthebox.com/community)
[Brand Guidelines](https://drive.google.com/file/d/1HVUeR2Kk4zNEojqqgvow1RAQgKqhptFn/view)
[Certificate Validation](https://www.hackthebox.com/certificates)
[Legal](https://www.hackthebox.com/legal)

Contact us

[Press](https://www.hackthebox.com/blog/category/news)
[Partners](https://www.hackthebox.com/channel-partners)
[Enterprise Sales](https://www.hackthebox.com/business-cyber-security-training)

Store

[HTB Swag](https://hackthebox.store)
[Buy Gift Cards](https://www.hackthebox.com/giftcards)

Cookie
Settings
[Privacy Policy](https://resources.hackthebox.com/hubfs/Legal/PN.pdf)

[User Agreement](https://resources.hackthebox.com/hubfs/Legal/UA.pdf)

© 2025 Hack The Box


