[Jump to content](#bodyContent)

Main menu

Main menu
move to sidebar
hide

Navigation

* [Main page](/wiki/Main_Page "Visit the main page [z]")
* [Contents](/wiki/Wikipedia%3AContents "Guides to browsing Wikipedia")
* [Current events](/wiki/Portal%3ACurrent_events "Articles related to current events")
* [Random article](/wiki/Special%3ARandom "Visit a randomly selected article [x]")
* [About Wikipedia](/wiki/Wikipedia%3AAbout "Learn about Wikipedia and how it works")
* [Contact us](//en.wikipedia.org/wiki/Wikipedia%3AContact_us "How to contact Wikipedia")

Contribute

* [Help](/wiki/Help%3AContents "Guidance on how to use and edit Wikipedia")
* [Learn to edit](/wiki/Help%3AIntroduction "Learn how to edit Wikipedia")
* [Community portal](/wiki/Wikipedia%3ACommunity_portal "The hub for editors")
* [Recent changes](/wiki/Special%3ARecentChanges "A list of recent changes to Wikipedia [r]")
* [Upload file](/wiki/Wikipedia%3AFile_upload_wizard "Add images or other media for use on Wikipedia")

[![](/static/images/icons/wikipedia.png)
![Wikipedia](/static/images/mobile/copyright/wikipedia-wordmark-en.svg)
![The Free Encyclopedia](/static/images/mobile/copyright/wikipedia-tagline-en.svg)](/wiki/Main_Page)

[Search](/wiki/Special%3ASearch "Search Wikipedia [f]")

Search

Appearance

* [Donate](https://donate.wikimedia.org/?wmf_source=donate&wmf_medium=sidebar&wmf_campaign=en.wikipedia.org&uselang=en)
* [Create account](/w/index.php?title=Special:CreateAccount&returnto=Time+complexity "You are encouraged to create an account and log in; however, it is not mandatory")
* [Log in](/w/index.php?title=Special:UserLogin&returnto=Time+complexity "You're encouraged to log in; however, it's not mandatory. [o]")

Personal tools

* [Donate](https://donate.wikimedia.org/?wmf_source=donate&wmf_medium=sidebar&wmf_campaign=en.wikipedia.org&uselang=en)
* [Create account](/w/index.php?title=Special:CreateAccount&returnto=Time+complexity "You are encouraged to create an account and log in; however, it is not mandatory")
* [Log in](/w/index.php?title=Special:UserLogin&returnto=Time+complexity "You're encouraged to log in; however, it's not mandatory. [o]")

Pages for logged out editors [learn more](/wiki/Help%3AIntroduction)

* [Contributions](/wiki/Special%3AMyContributions "A list of edits made from this IP address [y]")
* [Talk](/wiki/Special%3AMyTalk "Discussion about edits from this IP address [n]")

## Contents

move to sidebar
hide

* (Top)
* [1
  Table of common time complexities](#Table_of_common_time_complexities)
* [2
  Constant time](#Constant_time)
* [3
  Logarithmic time](#Logarithmic_time)
* [4
  Polylogarithmic time](#Polylogarithmic_time)
* [5
  Sub-linear time](#Sub-linear_time)
* [6
  Linear time](#Linear_time)
* [7
  Quasilinear time](#Quasilinear_time)
* [8
  Sub-quadratic time](#Sub-quadratic_time)
* [9
  Polynomial time](#Polynomial_time)

  Toggle Polynomial time subsection
  + [9.1
    Complexity classes](#Complexity_classes)
* [10
  Superpolynomial time](#Superpolynomial_time)
* [11
  Quasi-polynomial time](#Quasi-polynomial_time)

  Toggle Quasi-polynomial time subsection
  + [11.1
    Relation to NP-complete problems](#Relation_to_NP-complete_problems)
* [12
  Sub-exponential time](#Sub-exponential_time)

  Toggle Sub-exponential time subsection
  + [12.1
    First definition](#First_definition)
  + [12.2
    Second definition](#Second_definition)
    - [12.2.1
      Exponential time hypothesis](#Exponential_time_hypothesis)
* [13
  Exponential time](#Exponential_time)
* [14
  Factorial time](#Factorial_time)
* [15
  Double exponential time](#Double_exponential_time)
* [16
  See also](#See_also)
* [17
  References](#References)

Toggle the table of contents

# Time complexity

29 languages

* [العربية](https://ar.wikipedia.org/wiki/%D8%AA%D8%B9%D9%82%D9%8A%D8%AF_%D8%A7%D9%84%D9%88%D9%82%D8%AA "تعقيد الوقت – Arabic")
* [閩南語 / Bân-lâm-gú](https://zh-min-nan.wikipedia.org/wiki/S%C3%AE-kan_ho%CC%8Dk-cha%CC%8Dp-s%C3%A8ng "Sî-kan ho̍k-cha̍p-sèng – Minnan")
* [Български](https://bg.wikipedia.org/wiki/%D0%92%D1%80%D0%B5%D0%BC%D0%B5%D0%B2%D0%B0_%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82 "Времева сложност – Bulgarian")
* [Català](https://ca.wikipedia.org/wiki/Complexitat_temporal "Complexitat temporal – Catalan")
* [Čeština](https://cs.wikipedia.org/wiki/Asymptotick%C3%A1_slo%C5%BEitost "Asymptotická složitost – Czech")
* [Dansk](https://da.wikipedia.org/wiki/Tidskompleksitet "Tidskompleksitet – Danish")
* [Deutsch](https://de.wikipedia.org/wiki/Zeitkomplexit%C3%A4t "Zeitkomplexität – German")
* [Español](https://es.wikipedia.org/wiki/Complejidad_temporal "Complejidad temporal – Spanish")
* [فارسی](https://fa.wikipedia.org/wiki/%D8%B2%D9%85%D8%A7%D9%86_%D8%A7%D8%AC%D8%B1%D8%A7%DB%8C_%D8%A7%D9%84%DA%AF%D9%88%D8%B1%DB%8C%D8%AA%D9%85 "زمان اجرای الگوریتم – Persian")
* [Français](https://fr.wikipedia.org/wiki/Complexit%C3%A9_en_temps "Complexité en temps – French")
* [한국어](https://ko.wikipedia.org/wiki/%EC%8B%9C%EA%B0%84_%EB%B3%B5%EC%9E%A1%EB%8F%84 "시간 복잡도 – Korean")
* [हिन्दी](https://hi.wikipedia.org/wiki/%E0%A4%B8%E0%A4%AE%E0%A4%AF_%E0%A4%9C%E0%A4%9F%E0%A4%BF%E0%A4%B2%E0%A4%A4%E0%A4%BE "समय जटिलता – Hindi")
* [Bahasa Indonesia](https://id.wikipedia.org/wiki/Kompleksitas_waktu "Kompleksitas waktu – Indonesian")
* [Italiano](https://it.wikipedia.org/wiki/Complessit%C3%A0_temporale "Complessità temporale – Italian")
* [עברית](https://he.wikipedia.org/wiki/%D7%A1%D7%99%D7%91%D7%95%D7%9B%D7%99%D7%95%D7%AA_%D7%96%D7%9E%D7%9F "סיבוכיות זמן – Hebrew")
* [മലയാളം](https://ml.wikipedia.org/wiki/%E0%B4%B8%E0%B4%AE%E0%B4%AF_%E0%B4%B8%E0%B4%99%E0%B5%8D%E0%B4%95%E0%B5%80%E0%B5%BC%E0%B4%A3%E0%B5%8D%E0%B4%A3%E0%B4%A4_%28%E0%B4%95%E0%B4%AE%E0%B5%8D%E0%B4%AA%E0%B5%8D%E0%B4%AF%E0%B5%82%E0%B4%9F%E0%B5%8D%E0%B4%9F%E0%B5%BC_%E0%B4%B6%E0%B4%BE%E0%B4%B8%E0%B5%8D%E0%B4%A4%E0%B5%8D%E0%B4%B0%E0%B4%82%29 "സമയ സങ്കീർണ്ണത (കമ്പ്യൂട്ടർ ശാസ്ത്രം) – Malayalam")
* [Монгол](https://mn.wikipedia.org/wiki/%D0%A6%D0%B0%D0%B3%D0%B8%D0%B9%D0%BD_%D0%BD%D0%B0%D1%80%D0%B8%D0%B9%D0%BD_%D1%82%D3%A9%D0%B2%D3%A9%D0%B3%D1%82%D1%8D%D0%B9_%D0%B1%D0%B0%D0%B9%D0%B4%D0%B0%D0%BB "Цагийн нарийн төвөгтэй байдал – Mongolian")
* [Norsk bokmål](https://no.wikipedia.org/wiki/Tidskompleksitet "Tidskompleksitet – Norwegian Bokmål")
* [Português](https://pt.wikipedia.org/wiki/Complexidade_temporal "Complexidade temporal – Portuguese")
* [Română](https://ro.wikipedia.org/wiki/Complexitate_%C3%AEn_timp "Complexitate în timp – Romanian")
* [Русский](https://ru.wikipedia.org/wiki/%D0%92%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0 "Временная сложность алгоритма – Russian")
* [Slovenčina](https://sk.wikipedia.org/wiki/V%C3%BDpo%C4%8Dtov%C3%A1_zlo%C5%BEitos%C5%A5 "Výpočtová zložitosť – Slovak")
* [Српски / srpski](https://sr.wikipedia.org/wiki/%D0%A1%D1%83%D0%B1%D0%B5%D0%BA%D1%81%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%86%D0%B8%D1%98%D0%B0%D0%BB%D0%BD%D0%BE_%D0%B2%D1%80%D0%B5%D0%BC%D0%B5 "Субекспоненцијално време – Serbian")
* [Suomi](https://fi.wikipedia.org/wiki/Aikavaatimus "Aikavaatimus – Finnish")
* [Svenska](https://sv.wikipedia.org/wiki/Tidskomplexitet "Tidskomplexitet – Swedish")
* [Türkçe](https://tr.wikipedia.org/wiki/Zaman_karma%C5%9F%C4%B1kl%C4%B1%C4%9F%C4%B1 "Zaman karmaşıklığı – Turkish")
* [Українська](https://uk.wikipedia.org/wiki/%D0%A7%D0%B0%D1%81%D0%BE%D0%B2%D0%B0_%D1%81%D0%BA%D0%BB%D0%B0%D0%B4%D0%BD%D1%96%D1%81%D1%82%D1%8C "Часова складність – Ukrainian")
* [粵語](https://zh-yue.wikipedia.org/wiki/%E6%99%82%E9%96%93%E8%A4%87%E9%9B%9C%E5%BA%A6 "時間複雜度 – Cantonese")
* [中文](https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6 "时间复杂度 – Chinese")

[Edit links](https://www.wikidata.org/wiki/Special%3AEntityPage/Q2393193#sitelinks-wikipedia "Edit interlanguage links")

* [Article](/wiki/Time_complexity "View the content page [c]")
* [Talk](/wiki/Talk%3ATime_complexity "Discuss improvements to the content page [t]")

English

* [Read](/wiki/Time_complexity)
* [Edit](/w/index.php?title=Time_complexity&action=edit "Edit this page [e]")
* [View history](/w/index.php?title=Time_complexity&action=history "Past revisions of this page [h]")

Tools

Tools
move to sidebar
hide

Actions

* [Read](/wiki/Time_complexity)
* [Edit](/w/index.php?title=Time_complexity&action=edit "Edit this page [e]")
* [View history](/w/index.php?title=Time_complexity&action=history)

General

* [What links here](/wiki/Special%3AWhatLinksHere/Time_complexity "List of all English Wikipedia pages containing links to this page [j]")
* [Related changes](/wiki/Special%3ARecentChangesLinked/Time_complexity "Recent changes in pages linked from this page [k]")
* [Upload file](/wiki/Wikipedia%3AFile_Upload_Wizard "Upload files [u]")
* [Special pages](/wiki/Special%3ASpecialPages "A list of all special pages [q]")
* [Permanent link](/w/index.php?title=Time_complexity&oldid=1263568428 "Permanent link to this revision of this page")
* [Page information](/w/index.php?title=Time_complexity&action=info "More information about this page")
* [Cite this page](/w/index.php?title=Special:CiteThisPage&page=Time_complexity&id=1263568428&wpFormIdentifier=titleform "Information on how to cite this page")
* [Get shortened URL](/w/index.php?title=Special:UrlShortener&url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FTime_complexity)
* [Download QR code](/w/index.php?title=Special:QrCode&url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FTime_complexity)

Print/export

* [Download as PDF](/w/index.php?title=Special:DownloadAsPdf&page=Time_complexity&action=show-download-screen "Download this page as a PDF file")
* [Printable version](/w/index.php?title=Time_complexity&printable=yes "Printable version of this page [p]")

In other projects

* [Wikidata item](https://www.wikidata.org/wiki/Special%3AEntityPage/Q2393193 "Structured data on this page hosted by Wikidata [g]")

Appearance
move to sidebar
hide

From Wikipedia, the free encyclopedia

Estimate of time taken for running an algorithm
"Running time" redirects here. Not to be confused with [Running Time (film)](/wiki/Running_Time_%28film%29 "Running Time (film)").
[![](//upload.wikimedia.org/wikipedia/commons/thumb/7/7e/Comparison_computational_complexity.svg/220px-Comparison_computational_complexity.svg.png)](/wiki/File%3AComparison_computational_complexity.svg)

Graphs of functions commonly used in the [analysis of algorithms](/wiki/Analysis_of_algorithms "Analysis of algorithms"), showing the number of operations *N* as the result of input size *n* for each function

In [theoretical computer science](/wiki/Theoretical_computer_science "Theoretical computer science"), the **time complexity** is the [computational complexity](/wiki/Computational_complexity "Computational complexity") that describes the amount of computer time it takes to run an [algorithm](/wiki/Algorithm "Algorithm"). Time complexity is commonly estimated by counting the number of elementary operations performed by the algorithm, supposing that each elementary operation takes a fixed amount of time to perform. Thus, the amount of time taken and the number of elementary operations performed by the algorithm are taken to be related by a [constant factor](/wiki/Constant_factor "Constant factor").

Since an algorithm's running time may vary among different inputs of the same size, one commonly considers the [worst-case time complexity](/wiki/Worst-case_complexity "Worst-case complexity"), which is the maximum amount of time required for inputs of a given size. Less common, and usually specified explicitly, is the [average-case complexity](/wiki/Average-case_complexity "Average-case complexity"), which is the average of the time taken on inputs of a given size (this makes sense because there are only a finite number of possible inputs of a given size). In both cases, the time complexity is generally expressed as a [function](/wiki/Function_%28mathematics%29 "Function (mathematics)") of the size of the input.[[1]](#cite_note-Sipser-1): 226 Since this function is generally difficult to compute exactly, and the running time for small inputs is usually not consequential, one commonly focuses on the behavior of the complexity when the input size increases—that is, the [asymptotic behavior](/wiki/Asymptotic_analysis "Asymptotic analysis") of the complexity. Therefore, the time complexity is commonly expressed using [big O notation](/wiki/Big_O_notation "Big O notation"), typically
O
(
n
)

{\displaystyle O(n)}

![{\displaystyle O(n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/34109fe397fdcff370079185bfdb65826cb5565a),
O
(
n
log
⁡
n
)

{\displaystyle O(n\log n)}

![{\displaystyle O(n\log n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/9d2320768fb54880ca4356e61f60eb02a3f9d9f1),
O
(
n
α

)

{\displaystyle O(n^{\alpha })}

![{\displaystyle O(n^{\alpha })}](https://wikimedia.org/api/rest_v1/media/math/render/svg/cec66a4a63247dd112a6ec9dd8eae41909e6b300),
O
(
2
n

)

{\displaystyle O(2^{n})}

![{\displaystyle O(2^{n})}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d4b1a4ff0bc4f81ebf79f28260c6fb54ee08ff8d), etc., where n is the size in units of [bits](/wiki/Bit "Bit") needed to represent the input.

Algorithmic complexities are classified according to the type of function appearing in the big O notation. For example, an algorithm with time complexity
O
(
n
)

{\displaystyle O(n)}

![{\displaystyle O(n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/34109fe397fdcff370079185bfdb65826cb5565a) is a *linear time algorithm* and an algorithm with time complexity
O
(
n
α

)

{\displaystyle O(n^{\alpha })}

![{\displaystyle O(n^{\alpha })}](https://wikimedia.org/api/rest_v1/media/math/render/svg/cec66a4a63247dd112a6ec9dd8eae41909e6b300) for some constant
α
>
0

{\displaystyle \alpha >0}

![{\displaystyle \alpha >0}](https://wikimedia.org/api/rest_v1/media/math/render/svg/edd4f784b6e8bb68fa774213ceacbab2d97825dc) is a *polynomial time algorithm*.

## Table of common time complexities

[[edit](/w/index.php?title=Time_complexity&action=edit&section=1 "Edit section: Table of common time complexities")]
Further information: [Computational complexity of mathematical operations](/wiki/Computational_complexity_of_mathematical_operations "Computational complexity of mathematical operations")

The following table summarizes some classes of commonly encountered time complexities. In the table, poly(*x*) = *x**O*(1), i.e., polynomial in *x*.

| Name | [Complexity class](/wiki/Complexity_class "Complexity class") | Time complexity (*O*(*n*)) | Examples of running times | Example algorithms |
| --- | --- | --- | --- | --- |
| constant time |  | O ( 1 )   {\displaystyle O(1)}  {\displaystyle O(1)} | 10 | Finding the median value in a sorted [array](/wiki/Array_data_structure "Array data structure") of numbers. Calculating (−1)*n*. |
| [inverse Ackermann](/wiki/Inverse_Ackermann_function "Inverse Ackermann function") time |  | O (   α ( n ) )     {\displaystyle O{\bigl (}\alpha (n){\bigr )}}  {\displaystyle O{\bigl (}\alpha (n){\bigr )}} |  | [Amortized time](/wiki/Amortized_time "Amortized time") per operation using a [disjoint set](/wiki/Disjoint_set_data_structure "Disjoint set data structure") |
| [iterated logarithmic](/wiki/Iterated_logarithm "Iterated logarithm") time |  | O ( log ∗   ⁡ n )   {\displaystyle O(\log ^{\*}n)}  {\displaystyle O(\log ^{*}n)} |  | [Distributed coloring of cycles](/wiki/Cole-Vishkin_algorithm "Cole-Vishkin algorithm") |
| log-logarithmic |  | O ( log ⁡ log ⁡ n )   {\displaystyle O(\log \log n)}  {\displaystyle O(\log \log n)} |  | Amortized time per operation using a bounded [priority queue](/wiki/Priority_queue "Priority queue")[[2]](#cite_note-2) |
| logarithmic time | [DLOGTIME](/wiki/DLOGTIME "DLOGTIME") | O ( log ⁡ n )   {\displaystyle O(\log n)}  {\displaystyle O(\log n)} | log ⁡ n   {\displaystyle \log n}  {\displaystyle \log n},  log ⁡ ( n 2   )   {\displaystyle \log(n^{2})}  {\displaystyle \log(n^{2})} | [Binary search](/wiki/Binary_search "Binary search") |
| polylogarithmic time |  | poly  ( log ⁡ n )   {\displaystyle {\text{poly}}(\log n)}  {\displaystyle {\text{poly}}(\log n)} | ( log ⁡ n ) 2     {\displaystyle (\log n)^{2}}  {\displaystyle (\log n)^{2}} |  |
| fractional power |  | O ( n c   )   {\displaystyle O(n^{c})}  {\displaystyle O(n^{c})} where  0 < c < 1   {\displaystyle 0<c<1}  {\displaystyle 0<c<1} | n 1 2      {\displaystyle n^{\frac {1}{2}}}  {\displaystyle n^{\frac {1}{2}}},  n 2 3      {\displaystyle n^{\frac {2}{3}}}  {\displaystyle n^{\frac {2}{3}}} | [Range searching](/wiki/Range_searching "Range searching") in a [*k*-d tree](/wiki/K-d_tree "K-d tree") |
| linear time |  | O ( n )   {\displaystyle O(n)}  {\displaystyle O(n)} | n,  2 n + 5   {\displaystyle 2n+5}  {\displaystyle 2n+5} | Finding the smallest or largest item in an unsorted [array](/wiki/Array_data_structure "Array data structure"). [Kadane's algorithm](/wiki/Kadane%27s_algorithm "Kadane's algorithm"). [Linear search](/wiki/Linear_search "Linear search"). |
| "n log-star n" time |  | O ( n log ∗   ⁡ n )   {\displaystyle O(n\log ^{\*}n)}  {\displaystyle O(n\log ^{*}n)} |  | [Seidel](/wiki/Raimund_Seidel "Raimund Seidel")'s [polygon triangulation](/wiki/Polygon_triangulation "Polygon triangulation") algorithm. |
| linearithmic time |  | O ( n log ⁡ n )   {\displaystyle O(n\log n)}  {\displaystyle O(n\log n)} | n log ⁡ n   {\displaystyle n\log n}  {\displaystyle n\log n},  log ⁡ n !   {\displaystyle \log n!}  {\displaystyle \log n!} | Fastest possible [comparison sort](/wiki/Comparison_sort "Comparison sort"). [Fast Fourier transform](/wiki/Fast_Fourier_transform "Fast Fourier transform"). |
| quasilinear time |  | n poly  ( log ⁡ n )   {\displaystyle n{\text{poly}}(\log n)}  {\displaystyle n{\text{poly}}(\log n)} | n log 2   ⁡ n   {\displaystyle n\log ^{2}n}  {\displaystyle n\log ^{2}n} | [Multipoint polynomial evaluation](/wiki/Polynomial_evaluation#Multipoint_evaluation "Polynomial evaluation") |
| quadratic time |  | O ( n 2   )   {\displaystyle O(n^{2})}  {\displaystyle O(n^{2})} | n 2     {\displaystyle n^{2}}  {\displaystyle n^{2}} | [Bubble sort](/wiki/Bubble_sort "Bubble sort"). [Insertion sort](/wiki/Insertion_sort "Insertion sort"). [Direct convolution](/wiki/Convolution_theorem "Convolution theorem") |
| cubic time |  | O ( n 3   )   {\displaystyle O(n^{3})}  {\displaystyle O(n^{3})} | n 3     {\displaystyle n^{3}}  {\displaystyle n^{3}} | Naive multiplication of two  n × n   {\displaystyle n\times n}  {\displaystyle n\times n} matrices. Calculating [partial correlation](/wiki/Partial_correlation "Partial correlation"). |
| polynomial time | [P](/wiki/P_%28complexity%29 "P (complexity)") | 2 O ( log ⁡ n )   = poly  ( n )   {\displaystyle 2^{O(\log n)}={\text{poly}}(n)}  {\displaystyle 2^{O(\log n)}={\text{poly}}(n)} | n 2   + n   {\displaystyle n^{2}+n}  {\displaystyle n^{2}+n},  n 10     {\displaystyle n^{10}}  {\displaystyle n^{10}} | [Karmarkar's algorithm](/wiki/Karmarkar%27s_algorithm "Karmarkar's algorithm") for [linear programming](/wiki/Linear_programming "Linear programming"). [AKS primality test](/wiki/AKS_primality_test "AKS primality test")[[3]](#cite_note-tao-aks-3)[[4]](#cite_note-4) |
| quasi-polynomial time | QP | 2 poly  ( log ⁡ n )     {\displaystyle 2^{{\text{poly}}(\log n)}}  {\displaystyle 2^{{\text{poly}}(\log n)}} | n log ⁡ log ⁡ n     {\displaystyle n^{\log \log n}}  {\displaystyle n^{\log \log n}},  n log ⁡ n     {\displaystyle n^{\log n}}  {\displaystyle n^{\log n}} | Best-known *O*(log2*n*)-[approximation algorithm](/wiki/Approximation_algorithm "Approximation algorithm") for the directed [Steiner tree problem](/wiki/Steiner_tree_problem "Steiner tree problem"), best known [parity game](/wiki/Parity_game "Parity game") solver,[[5]](#cite_note-5) best known [graph isomorphism](/wiki/Graph_isomorphism "Graph isomorphism") algorithm |
| sub-exponential time(first definition) | SUBEXP | O ( 2 n ϵ     )   {\displaystyle O(2^{n^{\epsilon }})}  {\displaystyle O(2^{n^{\epsilon }})} for all  0 < ϵ < 1   {\displaystyle 0<\epsilon <1}  {\displaystyle 0<\epsilon <1} |  | Contains [BPP](/wiki/Bounded-error_probabilistic_polynomial "Bounded-error probabilistic polynomial") unless EXPTIME (see below) equals [MA](/wiki/Arthur%E2%80%93Merlin_protocol#MA "Arthur–Merlin protocol").[[6]](#cite_note-bpp-6) |
| sub-exponential time(second definition) |  | 2 o ( n )     {\displaystyle 2^{o(n)}}  {\displaystyle 2^{o(n)}} | 2 n 3       {\displaystyle 2^{\sqrt[{3}]{n}}}  {\displaystyle 2^{\sqrt[{3}]{n}}} | [Best classical algorithm](/wiki/General_number_field_sieve "General number field sieve") for [integer factorization](/wiki/Integer_factorization "Integer factorization") formerly-best algorithm for [graph isomorphism](/wiki/Graph_isomorphism_problem "Graph isomorphism problem") |
| exponential time(with linear exponent) | [E](/wiki/E_%28complexity%29 "E (complexity)") | 2 O ( n )     {\displaystyle 2^{O(n)}}  {\displaystyle 2^{O(n)}} | 1.1 n     {\displaystyle 1.1^{n}}  {\displaystyle 1.1^{n}},  10 n     {\displaystyle 10^{n}}  {\displaystyle 10^{n}} | Solving the [traveling salesman problem](/wiki/Traveling_salesman_problem "Traveling salesman problem") using [dynamic programming](/wiki/Dynamic_programming "Dynamic programming") |
| factorial time |  | O ( n ) ! = 2 O ( n log ⁡ n )     {\displaystyle O(n)!=2^{O(n\log n)}}  {\displaystyle O(n)!=2^{O(n\log n)}} | n ! , n n   , 2 n log ⁡ n     {\displaystyle n!,n^{n},2^{n\log n}}  {\displaystyle n!,n^{n},2^{n\log n}} | Solving the [traveling salesman problem](/wiki/Travelling_salesman_problem "Travelling salesman problem") via [brute-force search](/wiki/Brute-force_search "Brute-force search") |
| exponential time | [EXPTIME](/wiki/EXPTIME "EXPTIME") | 2 poly  ( n )     {\displaystyle 2^{{\text{poly}}(n)}}  {\displaystyle 2^{{\text{poly}}(n)}} | 2 n     {\displaystyle 2^{n}}  {\displaystyle 2^{n}},  2 n 2       {\displaystyle 2^{n^{2}}}  {\displaystyle 2^{n^{2}}} | Solving [matrix chain multiplication](/wiki/Matrix_chain_multiplication "Matrix chain multiplication") via [brute-force search](/wiki/Brute-force_search "Brute-force search") |
| double exponential time | [2-EXPTIME](/wiki/2-EXPTIME "2-EXPTIME") | 2 2 poly  ( n )       {\displaystyle 2^{2^{{\text{poly}}(n)}}}  {\displaystyle 2^{2^{{\text{poly}}(n)}}} | 2 2 n       {\displaystyle 2^{2^{n}}}  {\displaystyle 2^{2^{n}}} | Deciding the truth of a given statement in [Presburger arithmetic](/wiki/Presburger_arithmetic "Presburger arithmetic") |

## Constant time

[[edit](/w/index.php?title=Time_complexity&action=edit&section=2 "Edit section: Constant time")]
"Constant time" redirects here. For programming technique to avoid a timing attack, see [Timing attack § Avoidance](/wiki/Timing_attack#Avoidance "Timing attack").

An algorithm is said to be **constant time** (also written as
O
(
1
)

{\textstyle O(1)}

![{\textstyle O(1)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/55a2cd47ca6554fafc21bbef3331256c7e1631ad) time) if the value of
T
(
n
)

{\textstyle T(n)}

![{\textstyle T(n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/0b5ecab7146650b99bab59b6e97e228de0a4c61a) (the complexity of the algorithm) is bounded by a value that does not depend on the size of the input. For example, accessing any single element in an [array](/wiki/Array_data_structure "Array data structure") takes constant time as only one [operation](/wiki/Instruction_%28computer_science%29 "Instruction (computer science)") has to be performed to locate it. In a similar manner, finding the minimal value in an array sorted in ascending order; it is the first element. However, finding the minimal value in an unordered array is not a constant time operation as scanning over each [element](/wiki/Element_%28math%29 "Element (math)") in the array is needed in order to determine the minimal value. Hence it is a linear time operation, taking
O
(
n
)

{\textstyle O(n)}

![{\textstyle O(n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e73234cd485b947e68d1d78823313db65ef226d7) time. If the number of elements is known in advance and does not change, however, such an algorithm can still be said to run in constant time.

Despite the name "constant time", the running time does not have to be independent of the problem size, but an upper bound for the running time has to be independent of the problem size. For example, the task "exchange the values of a and b if necessary so that
a
≤
b

{\textstyle a\leq b}

![{\textstyle a\leq b}](https://wikimedia.org/api/rest_v1/media/math/render/svg/80bc3e45cdf18025be4beb90f84cf7b58cfcaf46)" is called constant time even though the time may depend on whether or not it is already true that
a
≤
b

{\textstyle a\leq b}

![{\textstyle a\leq b}](https://wikimedia.org/api/rest_v1/media/math/render/svg/80bc3e45cdf18025be4beb90f84cf7b58cfcaf46). However, there is some constant t such that the time required is always *at most* t.

## Logarithmic time

[[edit](/w/index.php?title=Time_complexity&action=edit&section=3 "Edit section: Logarithmic time")]
Further information: [Logarithmic growth](/wiki/Logarithmic_growth "Logarithmic growth")

An algorithm is said to take **logarithmic time** when
T
(
n
)
=
O
(
log
⁡
n
)

{\displaystyle T(n)=O(\log n)}

![{\displaystyle T(n)=O(\log n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/298f88c665173713636b659403fdabaf115a15e0). Since
log
a

⁡
n

{\displaystyle \log \_{a}n}

![{\displaystyle \log _{a}n}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2170c522b640ec2801a86c6c8bc66f9ae10e2c34) and
log
b

⁡
n

{\displaystyle \log \_{b}n}

![{\displaystyle \log _{b}n}](https://wikimedia.org/api/rest_v1/media/math/render/svg/52d9386c0be26d3cd2bc042a9856d4c3dd9a6f2a) are related by a [constant multiplier](/wiki/Logarithmic_identities#Changing_the_base "Logarithmic identities"), and such a [multiplier is irrelevant](/wiki/Big_O_notation#Multiplication_by_a_constant "Big O notation") to big O classification, the standard usage for logarithmic-time algorithms is
O
(
log
⁡
n
)

{\displaystyle O(\log n)}

![{\displaystyle O(\log n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/aae0f22048ba6b7c05dbae17b056bfa16e21807d) regardless of the base of the logarithm appearing in the expression of T.

Algorithms taking logarithmic time are commonly found in operations on [binary trees](/wiki/Binary_tree "Binary tree") or when using [binary search](/wiki/Binary_search "Binary search").

An
O
(
log
⁡
n
)

{\displaystyle O(\log n)}

![{\displaystyle O(\log n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/aae0f22048ba6b7c05dbae17b056bfa16e21807d) algorithm is considered highly efficient, as the ratio of the number of operations to the size of the input decreases and tends to zero when n increases. An algorithm that must access all elements of its input cannot take logarithmic time, as the time taken for reading an input of size n is of the order of n.

An example of logarithmic time is given by dictionary search. Consider a [dictionary](/wiki/Dictionary_%28data_structure%29 "Dictionary (data structure)") *D* which contains n entries, sorted in [alphabetical order](/wiki/Alphabetical_order "Alphabetical order"). We suppose that, for
1
≤
k
≤
n

{\displaystyle 1\leq k\leq n}

![{\displaystyle 1\leq k\leq n}](https://wikimedia.org/api/rest_v1/media/math/render/svg/78ec00bc2eb99b403bee93def3c12ae87f1e3c3d), one may access the kth entry of the dictionary in a constant time. Let
D
(
k
)

{\displaystyle D(k)}

![{\displaystyle D(k)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/f9c571e1520ae00f08fd58fb4d577491f592901a) denote this kth entry. Under these hypotheses, the test to see if a word w is in the dictionary may be done in logarithmic time: consider
D
(
⌊
n
2

⌋

)

{\displaystyle D\left(\left\lfloor {\frac {n}{2}}\right\rfloor \right)}

![{\displaystyle D\left(\left\lfloor {\frac {n}{2}}\right\rfloor \right)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2edee9939c593f103c81f5819e73e1de781e6532), where
⌊

⌋

{\displaystyle \lfloor \;\rfloor }

![{\displaystyle \lfloor \;\rfloor }](https://wikimedia.org/api/rest_v1/media/math/render/svg/8d1d99deef81d9e1b3f2757b901042a218e2322a) denotes the [floor function](/wiki/Floor_function "Floor function"). If
w
=
D
(
⌊
n
2

⌋

)

{\displaystyle w=D\left(\left\lfloor {\frac {n}{2}}\right\rfloor \right)}

![{\displaystyle w=D\left(\left\lfloor {\frac {n}{2}}\right\rfloor \right)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/32c796b219fc3540120b41a96017eda688c08b3e)--that is to say, the word w is exactly in the middle of the dictionary--then we are done. Else, if
w
<
D
(
⌊
n
2

⌋

)

{\displaystyle w<D\left(\left\lfloor {\frac {n}{2}}\right\rfloor \right)}

![{\displaystyle w<D\left(\left\lfloor {\frac {n}{2}}\right\rfloor \right)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a3a6bdb8f549a2be360fb7331528fbf3c13bd288)--i.e., if the word w comes earlier in alphabetical order than the middle word of the whole dictionary--we continue the search in the same way in the left (i.e. earlier) half of the dictionary, and then again repeatedly until the correct word is found. Otherwise, if it comes after the middle word, continue similarly with the right half of the dictionary. This algorithm is similar to the method often used to find an entry in a paper dictionary. As a result, the search space within the dictionary decreases as the algorithm gets closer to the target word.

## Polylogarithmic time

[[edit](/w/index.php?title=Time_complexity&action=edit&section=4 "Edit section: Polylogarithmic time")]

An algorithm is said to run in **[polylogarithmic](/wiki/Polylogarithmic_function "Polylogarithmic function") time** if its time
T
(
n
)

{\displaystyle T(n)}

![{\displaystyle T(n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/0be5a46684e1279c27414b285fa995f30407d002) is
O
(

(
log
⁡
n
)
k

)

{\displaystyle O{\bigl (}(\log n)^{k}{\bigr )}}

![{\displaystyle O{\bigl (}(\log n)^{k}{\bigr )}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2d550792fa06ee0782c8d0e4b7668ede8f5388b2) for some constant k. Another way to write this is
O
(
log
k

⁡
n
)

{\displaystyle O(\log ^{k}n)}

![{\displaystyle O(\log ^{k}n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/0261ca9897bad579fede1c3b4e2a20717b66fb5c).

For example, [matrix chain ordering](/wiki/Matrix_chain_multiplication "Matrix chain multiplication") can be solved in polylogarithmic time on a [parallel random-access machine](/wiki/Parallel_random-access_machine "Parallel random-access machine"),[[7]](#cite_note-7) and [a graph](/wiki/Graph_%28discrete_mathematics%29 "Graph (discrete mathematics)") can be [determined to be planar](/wiki/Planarity_testing "Planarity testing") in a [fully dynamic](/wiki/Dynamic_connectivity "Dynamic connectivity") way in
O
(
log
3

⁡
n
)

{\displaystyle O(\log ^{3}n)}

![{\displaystyle O(\log ^{3}n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a7f77c48b4c4e7b58b75244a9c512673896f6236) time per insert/delete operation.[[8]](#cite_note-8)

## Sub-linear time

[[edit](/w/index.php?title=Time_complexity&action=edit&section=5 "Edit section: Sub-linear time")]

An algorithm is said to run in **sub-linear time** (often spelled **sublinear time**) if
T
(
n
)
=
o
(
n
)

{\displaystyle T(n)=o(n)}

![{\displaystyle T(n)=o(n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/cded9a3b1a3b5dc08a44b03338c5b54821c90a1b). In particular this includes algorithms with the time complexities defined above.

The specific term *sublinear time algorithm* commonly refers to randomized algorithms that sample a small fraction of their inputs and process them efficiently to [approximately](/wiki/Approximation_algorithm "Approximation algorithm") infer properties of the entire instance.[[9]](#cite_note-9) This type of sublinear time algorithm is closely related to [property testing](/wiki/Property_testing "Property testing") and [statistics](/wiki/Statistics "Statistics").

Other settings where algorithms can run in sublinear time include:

* [Parallel algorithms](/wiki/Parallel_algorithm "Parallel algorithm") that have linear or greater total [work](/wiki/Analysis_of_parallel_algorithms#Definitions "Analysis of parallel algorithms") (allowing them to read the entire input), but sub-linear [depth](/wiki/Analysis_of_parallel_algorithms#Definitions "Analysis of parallel algorithms").
* Algorithms that have [guaranteed assumptions](/wiki/Promise_problem "Promise problem") on the input structure. An important example are operations on [data structures](/wiki/Data_structures "Data structures"), e.g. [binary search](/wiki/Binary_search_algorithm "Binary search algorithm") in a sorted array.
* Algorithms that search for local structure in the input, for example finding a local minimum in a 1-D array (can be solved in
  O
  (
  log
  ⁡
  (
  n
  )
  )

  {\displaystyle O(\log(n))}

  ![{\displaystyle O(\log(n))}](https://wikimedia.org/api/rest_v1/media/math/render/svg/7d3f404959a75e486669fd7618e00046eb00bb24) time using a variant of binary search).  A closely related notion is that of [Local Computation Algorithms (LCA)](/w/index.php?title=Local_Computation_Algorithms_(LCA)&action=edit&redlink=1 "Local Computation Algorithms (LCA) (page does not exist)") where the algorithm receives a large input and queries to local information about some valid large output.[[10]](#cite_note-10)

## Linear time

[[edit](/w/index.php?title=Time_complexity&action=edit&section=6 "Edit section: Linear time")]

An algorithm is said to take **linear time**, or
O
(
n
)

{\displaystyle O(n)}

![{\displaystyle O(n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/34109fe397fdcff370079185bfdb65826cb5565a) time, if its time complexity is
O
(
n
)

{\displaystyle O(n)}

![{\displaystyle O(n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/34109fe397fdcff370079185bfdb65826cb5565a). Informally, this means that the running time increases at most linearly with the size of the input. More precisely, this means that there is a constant c such that the running time is at most
c
n

{\displaystyle cn}

![{\displaystyle cn}](https://wikimedia.org/api/rest_v1/media/math/render/svg/7f0390269a433e7f1a987b5968c6229e43cd7a2b) for every input of size n. For example, a procedure that adds up all elements of a list requires time proportional to the length of the list, if the adding time is constant, or, at least, bounded by a constant.

Linear time is the best possible time complexity in situations where the algorithm has to sequentially read its entire input. Therefore, much research has been invested into discovering algorithms exhibiting linear time or, at least, nearly linear time. This research includes both software and hardware methods. There are several hardware technologies which exploit [parallelism](/wiki/Parallel_computing "Parallel computing") to provide this. An example is [content-addressable memory](/wiki/Content-addressable_memory "Content-addressable memory"). This concept of linear time is used in string matching algorithms such as the [Boyer–Moore string-search algorithm](/wiki/Boyer%E2%80%93Moore_string-search_algorithm "Boyer–Moore string-search algorithm") and [Ukkonen's algorithm](/wiki/Ukkonen%27s_algorithm "Ukkonen's algorithm").

## Quasilinear time

[[edit](/w/index.php?title=Time_complexity&action=edit&section=7 "Edit section: Quasilinear time")]

An algorithm is said to run in **quasilinear time** (also referred to as **log-linear time**) if
T
(
n
)
=
O
(
n
log
k

⁡
n
)

{\displaystyle T(n)=O(n\log ^{k}n)}

![{\displaystyle T(n)=O(n\log ^{k}n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/fb4711e3053ab6bb92b05c83b9e3037f1213784b) for some positive constant k;[[11]](#cite_note-11) **linearithmic time** is the case
k
=
1

{\displaystyle k=1}

![{\displaystyle k=1}](https://wikimedia.org/api/rest_v1/media/math/render/svg/6c035ffa69b5bca8bf2d16c3da3aaad79a8bcbfa).[[12]](#cite_note-12) Using [soft O notation](/wiki/Soft_O_notation "Soft O notation") these algorithms are
O
~

(
n
)

{\displaystyle {\tilde {O}}(n)}

![{\displaystyle {\tilde {O}}(n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/725007a6715e12268a37cbbc5194302dfb7e69a5). Quasilinear time algorithms are also
O
(
n
1
+
ε

)

{\displaystyle O(n^{1+\varepsilon })}

![{\displaystyle O(n^{1+\varepsilon })}](https://wikimedia.org/api/rest_v1/media/math/render/svg/13194779a160ce780eee140bc714e50f6e2b62a9) for every constant
ε
>
0

{\displaystyle \varepsilon >0}

![{\displaystyle \varepsilon >0}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e04ec3670b50384a3ce48aca42e7cc5131a06b12) and thus run faster than any polynomial time algorithm whose time bound includes a term
n
c

{\displaystyle n^{c}}

![{\displaystyle n^{c}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/3a62b39da47c098d4cec1ac794318335b381c436) for any
c
>
1

{\displaystyle c>1}

![{\displaystyle c>1}](https://wikimedia.org/api/rest_v1/media/math/render/svg/bd1d6b5c226641ad3def8e65631f0eb463d9c67a).

Algorithms which run in quasilinear time include:

* [In-place merge sort](/wiki/In-place_merge_sort "In-place merge sort"),
  O
  (
  n
  log
  2

  ⁡
  n
  )

  {\displaystyle O(n\log ^{2}n)}

  ![{\displaystyle O(n\log ^{2}n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/48c36489701bc8023db2f8d6bc809b14a7f8dd4e)
* [Quicksort](/wiki/Quicksort "Quicksort"),
  O
  (
  n
  log
  ⁡
  n
  )

  {\displaystyle O(n\log n)}

  ![{\displaystyle O(n\log n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/9d2320768fb54880ca4356e61f60eb02a3f9d9f1), in its randomized version, has a running time that is
  O
  (
  n
  log
  ⁡
  n
  )

  {\displaystyle O(n\log n)}

  ![{\displaystyle O(n\log n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/9d2320768fb54880ca4356e61f60eb02a3f9d9f1) in expectation on the worst-case input. Its non-randomized version has an
  O
  (
  n
  log
  ⁡
  n
  )

  {\displaystyle O(n\log n)}

  ![{\displaystyle O(n\log n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/9d2320768fb54880ca4356e61f60eb02a3f9d9f1) running time only when considering average case complexity.
* [Heapsort](/wiki/Heapsort "Heapsort"),
  O
  (
  n
  log
  ⁡
  n
  )

  {\displaystyle O(n\log n)}

  ![{\displaystyle O(n\log n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/9d2320768fb54880ca4356e61f60eb02a3f9d9f1), [merge sort](/wiki/Merge_sort "Merge sort"), [introsort](/wiki/Introsort "Introsort"), binary tree sort, [smoothsort](/wiki/Smoothsort "Smoothsort"), [patience sorting](/wiki/Patience_sorting "Patience sorting"), etc. in the worst case
* [Fast Fourier transforms](/wiki/Fast_Fourier_transform "Fast Fourier transform"),
  O
  (
  n
  log
  ⁡
  n
  )

  {\displaystyle O(n\log n)}

  ![{\displaystyle O(n\log n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/9d2320768fb54880ca4356e61f60eb02a3f9d9f1)
* [Monge array](/wiki/Monge_array "Monge array") calculation,
  O
  (
  n
  log
  ⁡
  n
  )

  {\displaystyle O(n\log n)}

  ![{\displaystyle O(n\log n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/9d2320768fb54880ca4356e61f60eb02a3f9d9f1)

In many cases, the
O
(
n
log
⁡
n
)

{\displaystyle O(n\log n)}

![{\displaystyle O(n\log n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/9d2320768fb54880ca4356e61f60eb02a3f9d9f1) running time is simply the result of performing a
Θ
(
log
⁡
n
)

{\displaystyle \Theta (\log n)}

![{\displaystyle \Theta (\log n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/65bac5223de9c91eb3e89a032b5c51fd3041dc66) operation n times (for the notation, see [Big O notation § Family of Bachmann–Landau notations](/wiki/Big_O_notation#Family_of_Bachmann–Landau_notations "Big O notation")). For example, [binary tree sort](/wiki/Binary_tree_sort "Binary tree sort") creates a [binary tree](/wiki/Binary_tree "Binary tree") by inserting each element of the n-sized array one by one. Since the insert operation on a [self-balancing binary search tree](/wiki/Self-balancing_binary_search_tree "Self-balancing binary search tree") takes
O
(
log
⁡
n
)

{\displaystyle O(\log n)}

![{\displaystyle O(\log n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/aae0f22048ba6b7c05dbae17b056bfa16e21807d) time, the entire algorithm takes
O
(
n
log
⁡
n
)

{\displaystyle O(n\log n)}

![{\displaystyle O(n\log n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/9d2320768fb54880ca4356e61f60eb02a3f9d9f1) time.

[Comparison sorts](/wiki/Comparison_sort "Comparison sort") require at least
Ω
(
n
log
⁡
n
)

{\displaystyle \Omega (n\log n)}

![{\displaystyle \Omega (n\log n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/00663e988b37b064dbfe30791c3ad477907cc3a4) comparisons in the worst case because
log
⁡
(
n
!
)
=
Θ
(
n
log
⁡
n
)

{\displaystyle \log(n!)=\Theta (n\log n)}

![{\displaystyle \log(n!)=\Theta (n\log n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/74ad099d9cb60cd65e4234ed770a3923973eea8a), by [Stirling's approximation](/wiki/Stirling%27s_approximation "Stirling's approximation"). They also frequently arise from the [recurrence relation](/wiki/Recurrence_relation "Recurrence relation")
T
(
n
)
=
2
T
(
n
2

)

+
O
(
n
)

{\textstyle T(n)=2T\left({\frac {n}{2}}\right)+O(n)}

![{\textstyle T(n)=2T\left({\frac {n}{2}}\right)+O(n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/b8cd0d7755d0bc79417b34d5a5ef603155de31d2).

## Sub-quadratic time

[[edit](/w/index.php?title=Time_complexity&action=edit&section=8 "Edit section: Sub-quadratic time")]

An [algorithm](/wiki/Algorithm "Algorithm") is said to be **subquadratic time** if
T
(
n
)
=
o
(
n
2

)

{\displaystyle T(n)=o(n^{2})}

![{\displaystyle T(n)=o(n^{2})}](https://wikimedia.org/api/rest_v1/media/math/render/svg/b5a1fa201043da51e8f5fcadfc9922764da3408b).

For example, simple, comparison-based [sorting algorithms](/wiki/Sorting_algorithm "Sorting algorithm") are quadratic (e.g. [insertion sort](/wiki/Insertion_sort "Insertion sort")), but more advanced algorithms can be found that are subquadratic (e.g. [shell sort](/wiki/Shell_sort "Shell sort")). No general-purpose sorts run in linear time, but the change from quadratic to sub-quadratic is of great practical importance.

## Polynomial time

[[edit](/w/index.php?title=Time_complexity&action=edit&section=9 "Edit section: Polynomial time")]
Main article: [P (complexity)](/wiki/P_%28complexity%29 "P (complexity)")

An algorithm is said to be of **polynomial time** if its running time is [upper bounded](/wiki/Upper_bound "Upper bound") by a [polynomial](/wiki/Polynomial "Polynomial") expression in the size of the input for the algorithm, that is, *T*(*n*) = *O*(*n**k*) for some positive constant *k*.[[1]](#cite_note-Sipser-1)[[13]](#cite_note-13) [Problems](/wiki/Decision_problem "Decision problem") for which a deterministic polynomial-time algorithm exists belong to the [complexity class](/wiki/Complexity_class "Complexity class") **[P](/wiki/P_%28complexity%29 "P (complexity)")**, which is central in the field of [computational complexity theory](/wiki/Computational_complexity_theory "Computational complexity theory"). [Cobham's thesis](/wiki/Cobham%27s_thesis "Cobham's thesis") states that polynomial time is a synonym for "tractable", "feasible", "efficient", or "fast".[[14]](#cite_note-14)

Some examples of polynomial-time algorithms:

* The [selection sort](/wiki/Selection_sort "Selection sort") sorting algorithm on *n* integers performs
  A
  n
  2

  {\displaystyle An^{2}}

  ![{\displaystyle An^{2}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2796e53b94e7bd410c057a6d425c4923ed580156) operations for some constant *A*. Thus it runs in time
  O
  (
  n
  2

  )

  {\displaystyle O(n^{2})}

  ![{\displaystyle O(n^{2})}](https://wikimedia.org/api/rest_v1/media/math/render/svg/6cd9594a16cb898b8f2a2dff9227a385ec183392) and is a polynomial-time algorithm.
* All the basic arithmetic operations (addition, subtraction, multiplication, division, and comparison) can be done in polynomial time.
* [Maximum matchings](/wiki/Maximum_matching "Maximum matching") in [graphs](/wiki/Graph_%28discrete_mathematics%29 "Graph (discrete mathematics)") can be found in polynomial time. In some contexts, especially in [optimization](/wiki/Optimization_%28mathematics%29 "Optimization (mathematics)"), one differentiates between **[strongly polynomial time](/wiki/Strongly-polynomial_time "Strongly-polynomial time")** and **weakly polynomial time** algorithms.

These two concepts are only relevant if the inputs to the algorithms consist of integers.

### Complexity classes

[[edit](/w/index.php?title=Time_complexity&action=edit&section=10 "Edit section: Complexity classes")]

The concept of polynomial time leads to several complexity classes in computational complexity theory. Some important classes defined using polynomial time are the following.

* **[P](/wiki/P_%28complexity%29 "P (complexity)")**: The [complexity class](/wiki/Complexity_class "Complexity class") of [decision problems](/wiki/Decision_problem "Decision problem") that can be solved on a [deterministic Turing machine](/wiki/Deterministic_Turing_machine "Deterministic Turing machine") in polynomial time
* **[NP](/wiki/NP_%28complexity%29 "NP (complexity)")**: The complexity class of decision problems that can be solved on a [non-deterministic Turing machine](/wiki/Non-deterministic_Turing_machine "Non-deterministic Turing machine") in polynomial time
* **[ZPP](/wiki/ZPP_%28complexity%29 "ZPP (complexity)")**: The complexity class of decision problems that can be solved with zero error on a [probabilistic Turing machine](/wiki/Probabilistic_Turing_machine "Probabilistic Turing machine") in polynomial time
* **[RP](/wiki/RP_%28complexity%29 "RP (complexity)")**: The complexity class of decision problems that can be solved with 1-sided error on a probabilistic Turing machine in polynomial time.
* **[BPP](/wiki/BPP_%28complexity%29 "BPP (complexity)")**: The complexity class of decision problems that can be solved with 2-sided error on a probabilistic Turing machine in polynomial time
* **[BQP](/wiki/BQP "BQP")**: The complexity class of decision problems that can be solved with 2-sided error on a [quantum Turing machine](/wiki/Quantum_Turing_machine "Quantum Turing machine") in polynomial time

P is the smallest time-complexity class on a deterministic machine which is [robust](/wiki/Robustness_%28computer_science%29 "Robustness (computer science)") in terms of machine model changes. (For example, a change from a single-tape Turing machine to a multi-tape machine can lead to a quadratic speedup, but any algorithm that runs in polynomial time under one model also does so on the other.) Any given [abstract machine](/wiki/Abstract_machine "Abstract machine") will have a complexity class corresponding to the problems which can be solved in polynomial time on that machine.

## Superpolynomial time

[[edit](/w/index.php?title=Time_complexity&action=edit&section=11 "Edit section: Superpolynomial time")]

An algorithm is defined to take **superpolynomial time** if *T*(*n*) is not bounded above by any polynomial. Using [little omega notation](/wiki/Big_O_notation#Family_of_Bachmann–Landau_notations "Big O notation"), it is *ω*(*n**c*) time for all constants *c*, where *n* is the input parameter, typically the number of bits in the input.

For example, an algorithm that runs for 2*n* steps on an input of size *n* requires superpolynomial time (more specifically, exponential time).

An algorithm that uses exponential resources is clearly superpolynomial, but some algorithms are only very weakly superpolynomial. For example, the [Adleman–Pomerance–Rumely primality test](/wiki/Adleman%E2%80%93Pomerance%E2%80%93Rumely_primality_test "Adleman–Pomerance–Rumely primality test") runs for *n**O*(log log *n*) time on *n*-bit inputs; this grows faster than any polynomial for large enough *n*, but the input size must become impractically large before it cannot be dominated by a polynomial with small degree.

An algorithm that requires superpolynomial time lies outside the [complexity class](/wiki/Complexity_class "Complexity class") **[P](/wiki/P_%28complexity%29 "P (complexity)")**. [Cobham's thesis](/wiki/Cobham%27s_thesis "Cobham's thesis") posits that these algorithms are impractical, and in many cases they are. Since the [P versus NP problem](/wiki/P_versus_NP_problem "P versus NP problem") is unresolved, it is unknown whether [NP-complete](/wiki/NP-complete "NP-complete") problems require superpolynomial time.

## Quasi-polynomial time

[[edit](/w/index.php?title=Time_complexity&action=edit&section=12 "Edit section: Quasi-polynomial time")]
Main article: [Quasi-polynomial time](/wiki/Quasi-polynomial_time "Quasi-polynomial time")

**Quasi-polynomial time** algorithms are algorithms whose running time exhibits [quasi-polynomial growth](/wiki/Quasi-polynomial_growth "Quasi-polynomial growth"), a type of behavior that may be slower than polynomial time but yet is significantly faster than [exponential time](/wiki/Exponential_time "Exponential time"). The worst case running time of a quasi-polynomial time algorithm is
2
O
(
log
c

⁡
n
)

{\displaystyle 2^{O(\log ^{c}n)}}

![{\displaystyle 2^{O(\log ^{c}n)}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/8bf734f7fea354217d29a8bc1a007044ab520aae) for some fixed
c
>
0

{\displaystyle c>0}

![{\displaystyle c>0}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2ba126f626d61752f62eaacaf11761a54de4dc84). When
c
=
1

{\displaystyle c=1}

![{\displaystyle c=1}](https://wikimedia.org/api/rest_v1/media/math/render/svg/3e3467f9e219a5ea38a30da5c3a02c2c23f61a79) this gives polynomial time, and for
c
<
1

{\displaystyle c<1}

![{\displaystyle c<1}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d8f310fc940b3622eefb2bb82bb2cb2a049a60c2) it gives sub-linear time.

There are some problems for which we know quasi-polynomial time algorithms, but no polynomial time algorithm is known. Such problems arise in approximation algorithms; a famous example is the directed [Steiner tree problem](/wiki/Steiner_tree_problem "Steiner tree problem"), for which there is a quasi-polynomial time approximation algorithm achieving an approximation factor of
O
(
log
3

⁡
n
)

{\displaystyle O(\log ^{3}n)}

![{\displaystyle O(\log ^{3}n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a7f77c48b4c4e7b58b75244a9c512673896f6236) (*n* being the number of vertices), but showing the existence of such a polynomial time algorithm is an open problem.

Other computational problems with quasi-polynomial time solutions but no known polynomial time solution include the [planted clique](/wiki/Planted_clique "Planted clique") problem in which the goal is to [find a large clique](/wiki/Clique_problem "Clique problem") in the union of a clique and a [random graph](/wiki/Random_graph "Random graph"). Although quasi-polynomially solvable, it has been conjectured that the planted clique problem has no polynomial time solution; this planted clique conjecture has been used as a [computational hardness assumption](/wiki/Computational_hardness_assumption "Computational hardness assumption") to prove the difficulty of several other problems in computational [game theory](/wiki/Game_theory "Game theory"), [property testing](/wiki/Property_testing "Property testing"), and [machine learning](/wiki/Machine_learning "Machine learning").[[15]](#cite_note-15)

The complexity class **QP** consists of all problems that have quasi-polynomial time algorithms. It can be defined in terms of [DTIME](/wiki/DTIME "DTIME") as follows.[[16]](#cite_note-16)

QP

=
⋃
c
∈
N

DTIME

(
2
log
c

⁡
n

)

{\displaystyle {\mbox{QP}}=\bigcup \_{c\in \mathbb {N} }{\mbox{DTIME}}\left(2^{\log ^{c}n}\right)}

![{\displaystyle {\mbox{QP}}=\bigcup _{c\in \mathbb {N} }{\mbox{DTIME}}\left(2^{\log ^{c}n}\right)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/efc34b706aa344b0652e533568b621f576904089)
### Relation to NP-complete problems

[[edit](/w/index.php?title=Time_complexity&action=edit&section=13 "Edit section: Relation to NP-complete problems")]

In complexity theory, the unsolved [P versus NP](/wiki/P_versus_NP "P versus NP") problem asks if all problems in NP have polynomial-time algorithms. All the best-known algorithms for [NP-complete](/wiki/NP-complete "NP-complete") problems like 3SAT etc. take exponential time. Indeed, it is conjectured for many natural NP-complete problems that they do not have sub-exponential time algorithms. Here "sub-exponential time" is taken to mean the second definition presented below. (On the other hand, many graph problems represented in the natural way by adjacency matrices are solvable in subexponential time simply because the size of the input is the square of the number of vertices.) This conjecture (for the k-SAT problem) is known as the [exponential time hypothesis](/wiki/Exponential_time_hypothesis "Exponential time hypothesis").[[17]](#cite_note-ETH-17) Since it is conjectured that NP-complete problems do not have quasi-polynomial time algorithms, some inapproximability results in the field of [approximation algorithms](/wiki/Approximation_algorithms "Approximation algorithms") make the assumption that NP-complete problems do not have quasi-polynomial time algorithms. For example, see the known inapproximability results for the [set cover](/wiki/Set_cover "Set cover") problem.

## Sub-exponential time

[[edit](/w/index.php?title=Time_complexity&action=edit&section=14 "Edit section: Sub-exponential time")]

The term **[sub-exponential](/wiki/Infra-exponential "Infra-exponential") time** is used to express that the running time of some algorithm may grow faster than any polynomial but is still significantly smaller than an exponential. In this sense, problems that have sub-exponential time algorithms are somewhat more tractable than those that only have exponential algorithms. The precise definition of "sub-exponential" is not generally agreed upon,[[18]](#cite_note-18) however the two most widely used are below.

### First definition

[[edit](/w/index.php?title=Time_complexity&action=edit&section=15 "Edit section: First definition")]

A problem is said to be sub-exponential time solvable if it can be solved in running times whose logarithms grow smaller than any given polynomial. More precisely, a problem is in sub-exponential time if for every *ε* > 0 there exists an algorithm which solves the problem in time *O*(2*n**ε*). The set of all such problems is the complexity class **SUBEXP** which can be defined in terms of [DTIME](/wiki/DTIME "DTIME") as follows.[[6]](#cite_note-bpp-6)[[19]](#cite_note-19)[[20]](#cite_note-20)[[21]](#cite_note-21)

SUBEXP

=
⋂
ε
>
0

DTIME

(
2
n
ε

)

{\displaystyle {\text{SUBEXP}}=\bigcap \_{\varepsilon >0}{\text{DTIME}}\left(2^{n^{\varepsilon }}\right)}

![{\displaystyle {\text{SUBEXP}}=\bigcap _{\varepsilon >0}{\text{DTIME}}\left(2^{n^{\varepsilon }}\right)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/4250b13f4892da1b3905e37beee2070232690b3f)

This notion of sub-exponential is non-uniform in terms of *ε* in the sense that *ε* is not part of the input and each ε may have its own algorithm for the problem.

### Second definition

[[edit](/w/index.php?title=Time_complexity&action=edit&section=16 "Edit section: Second definition")]

Some authors define sub-exponential time as running times in
2
o
(
n
)

{\displaystyle 2^{o(n)}}

![{\displaystyle 2^{o(n)}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/98ee27d18f582367c1c737ddc1c3380a92c93c0b).[[17]](#cite_note-ETH-17)[[22]](#cite_note-22)[[23]](#cite_note-23) This definition allows larger running times than the first definition of sub-exponential time. An example of such a sub-exponential time algorithm is the best-known classical algorithm for integer factorization, the [general number field sieve](/wiki/General_number_field_sieve "General number field sieve"), which runs in time about
2
O
~

(
n
1
/

3

)

{\displaystyle 2^{{\tilde {O}}(n^{1/3})}}

![{\displaystyle 2^{{\tilde {O}}(n^{1/3})}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/30d319f41f6fb8ab309bf15ad8a64c870cb52021), where the length of the input is n. Another example was the [graph isomorphism problem](/wiki/Graph_isomorphism_problem "Graph isomorphism problem"), which the best known algorithm from 1982 to 2016 solved in
2
O
(
n
log
⁡
n

)

{\displaystyle 2^{O\left({\sqrt {n\log n}}\right)}}

![{\displaystyle 2^{O\left({\sqrt {n\log n}}\right)}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/421e4106c1d0cbf0b63861e4473c479865a04a07). However, at [STOC](/wiki/Symposium_on_Theory_of_Computing "Symposium on Theory of Computing") 2016 a quasi-polynomial time algorithm was presented.[[24]](#cite_note-24)

It makes a difference whether the algorithm is allowed to be sub-exponential in the size of the instance, the number of vertices, or the number of edges. In [parameterized complexity](/wiki/Parameterized_complexity "Parameterized complexity"), this difference is made explicit by considering pairs
(
L
,
k
)

{\displaystyle (L,k)}

![{\displaystyle (L,k)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/60912d6e9f29e343e9e77d28e3a19ede88d9d655) of [decision problems](/wiki/Decision_problem "Decision problem") and parameters *k*. **SUBEPT** is the class of all parameterized problems that run in time sub-exponential in *k* and polynomial in the input size *n*:[[25]](#cite_note-25)

SUBEPT

=
DTIME

(
2
o
(
k
)

⋅
poly

(
n
)

)

.

{\displaystyle {\text{SUBEPT}}={\text{DTIME}}\left(2^{o(k)}\cdot {\text{poly}}(n)\right).}

![{\displaystyle {\text{SUBEPT}}={\text{DTIME}}\left(2^{o(k)}\cdot {\text{poly}}(n)\right).}](https://wikimedia.org/api/rest_v1/media/math/render/svg/ff05fe27e749e87ad729180e2538feb7414883e8)

More precisely, SUBEPT is the class of all parameterized problems
(
L
,
k
)

{\displaystyle (L,k)}

![{\displaystyle (L,k)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/60912d6e9f29e343e9e77d28e3a19ede88d9d655) for which there is a [computable function](/wiki/Computable_function "Computable function")
f
:
N

→
N

{\displaystyle f:\mathbb {N} \to \mathbb {N} }

![{\displaystyle f:\mathbb {N} \to \mathbb {N} }](https://wikimedia.org/api/rest_v1/media/math/render/svg/dfa847e103c9e2e5075b1b510f67aad8ceae9349) with
f
∈
o
(
k
)

{\displaystyle f\in o(k)}

![{\displaystyle f\in o(k)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/ea31b6df475b663254eeea2570f974d8ce662741) and an algorithm that decides *L* in time
2
f
(
k
)

⋅
poly

(
n
)

{\displaystyle 2^{f(k)}\cdot {\text{poly}}(n)}

![{\displaystyle 2^{f(k)}\cdot {\text{poly}}(n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e830c3a9cf201dda30b0a6126e1cf7b7c66569a7).

#### Exponential time hypothesis

[[edit](/w/index.php?title=Time_complexity&action=edit&section=17 "Edit section: Exponential time hypothesis")]
Main article: [Exponential time hypothesis](/wiki/Exponential_time_hypothesis "Exponential time hypothesis")

The **exponential time hypothesis** (**ETH**) is that [3SAT](/wiki/3SAT "3SAT"), the satisfiability problem of Boolean formulas in [conjunctive normal form](/wiki/Conjunctive_normal_form "Conjunctive normal form") with at most three literals per clause and with *n* variables, cannot be solved in time 2*o*(*n*). More precisely, the hypothesis is that there is some absolute constant *c* > 0 such that 3SAT cannot be decided in time 2*cn* by any deterministic Turing machine. With *m* denoting the number of clauses, ETH is equivalent to the hypothesis that *k*SAT cannot be solved in time 2*o*(*m*) for any integer *k* ≥ 3.[[26]](#cite_note-26) The exponential time hypothesis implies [P ≠ NP](/wiki/P_%E2%89%A0_NP "P ≠ NP").

## Exponential time

[[edit](/w/index.php?title=Time_complexity&action=edit&section=18 "Edit section: Exponential time")]

An algorithm is said to be **exponential time**, if *T*(*n*) is upper bounded by 2poly(*n*), where poly(*n*) is some polynomial in *n*. More formally, an algorithm is exponential time if *T*(*n*) is bounded by *O*(2*n**k*) for some constant *k*. Problems which admit exponential time algorithms on a deterministic Turing machine form the complexity class known as **[EXP](/wiki/EXP "EXP")**.

EXP

=
⋃
c
∈
R
+

DTIME

(
2
n
c

)

{\displaystyle {\text{EXP}}=\bigcup \_{c\in \mathbb {R\_{+}} }{\text{DTIME}}\left(2^{n^{c}}\right)}

![{\displaystyle {\text{EXP}}=\bigcup _{c\in \mathbb {R_{+}} }{\text{DTIME}}\left(2^{n^{c}}\right)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/7a45ff8152c4e2a1e24055289239ac8888314d12)

Sometimes, exponential time is used to refer to algorithms that have *T*(*n*) = 2*O*(*n*), where the exponent is at most a linear function of *n*. This gives rise to the complexity class **[E](/wiki/E_%28complexity%29 "E (complexity)")**.

E

=
⋃
c
∈
N

DTIME

(
2
c
n

)

{\displaystyle {\text{E}}=\bigcup \_{c\in \mathbb {N} }{\text{DTIME}}\left(2^{cn}\right)}

![{\displaystyle {\text{E}}=\bigcup _{c\in \mathbb {N} }{\text{DTIME}}\left(2^{cn}\right)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/90a73905632297c23232f3ea47c87409aff8d53e)
## Factorial time

[[edit](/w/index.php?title=Time_complexity&action=edit&section=19 "Edit section: Factorial time")]

An algorithm is said to be **factorial time** if *T(n)* is upper bounded by the [factorial function](/wiki/Factorial_function "Factorial function") *n!*. Factorial time is a subset of exponential time (EXP) because
n
!
≤
n
n

=
2
n
log
⁡
n

=
O
(
2
n
1
+
ϵ

)

{\displaystyle n!\leq n^{n}=2^{n\log n}=O\left(2^{n^{1+\epsilon }}\right)}

![{\displaystyle n!\leq n^{n}=2^{n\log n}=O\left(2^{n^{1+\epsilon }}\right)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/7d00a62e76b74b7da06d90644aa16abd7b7c95f5) for all
ϵ
>
0

{\displaystyle \epsilon >0}

![{\displaystyle \epsilon >0}](https://wikimedia.org/api/rest_v1/media/math/render/svg/568095ad3924314374a5ab68fae17343661f2a71). However, it is not a subset of E.

An example of an algorithm that runs in factorial time is [bogosort](/wiki/Bogosort "Bogosort"), a notoriously inefficient sorting algorithm based on [trial and error](/wiki/Trial_and_error "Trial and error"). Bogosort sorts a list of *n* items by repeatedly [shuffling](/wiki/Shuffling "Shuffling") the list until it is found to be sorted. In the average case, each pass through the bogosort algorithm will examine one of the *n*! orderings of the *n* items. If the items are distinct, only one such ordering is sorted. Bogosort shares patrimony with the [infinite monkey theorem](/wiki/Infinite_monkey_theorem "Infinite monkey theorem").

## Double exponential time

[[edit](/w/index.php?title=Time_complexity&action=edit&section=20 "Edit section: Double exponential time")]

An algorithm is said to be [double exponential](/wiki/Double_exponential_function "Double exponential function") time if *T*(*n*) is upper bounded by 22poly(*n*), where poly(*n*) is some polynomial in *n*. Such algorithms belong to the complexity class [2-EXPTIME](/wiki/2-EXPTIME "2-EXPTIME").

2-EXPTIME

=
⋃
c
∈
N

DTIME

(
2
2
n
c

)

{\displaystyle {\mbox{2-EXPTIME}}=\bigcup \_{c\in \mathbb {N} }{\mbox{DTIME}}\left(2^{2^{n^{c}}}\right)}

![{\displaystyle {\mbox{2-EXPTIME}}=\bigcup _{c\in \mathbb {N} }{\mbox{DTIME}}\left(2^{2^{n^{c}}}\right)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/0ae0eedc226c47bc0d6bf831c2796d3f4412762b)

Well-known double exponential time algorithms include:

* Decision procedures for [Presburger arithmetic](/wiki/Presburger_arithmetic "Presburger arithmetic")
* Computing a [Gröbner basis](/wiki/Gr%C3%B6bner_basis "Gröbner basis") (in the worst case[[27]](#cite_note-27))
* [Quantifier elimination](/wiki/Quantifier_elimination "Quantifier elimination") on [real closed fields](/wiki/Real_closed_field "Real closed field") takes at least double exponential time,[[28]](#cite_note-28) and can be done in this time.[[29]](#cite_note-29)

## See also

[[edit](/w/index.php?title=Time_complexity&action=edit&section=21 "Edit section: See also")]

* [L-notation](/wiki/L-notation "L-notation")
* [Space complexity](/wiki/Space_complexity "Space complexity")

## References

[[edit](/w/index.php?title=Time_complexity&action=edit&section=22 "Edit section: References")]

1. ^ [***a***](#cite_ref-Sipser_1-0) [***b***](#cite_ref-Sipser_1-1) [Sipser, Michael](/wiki/Michael_Sipser "Michael Sipser") (2006). *Introduction to the Theory of Computation*. Course Technology Inc. [ISBN](/wiki/ISBN_%28identifier%29 "ISBN (identifier)") [0-619-21764-2](/wiki/Special%3ABookSources/0-619-21764-2 "Special:BookSources/0-619-21764-2").
2. **[^](#cite_ref-2)** [Mehlhorn, Kurt](/wiki/Kurt_Mehlhorn "Kurt Mehlhorn"); Naher, Stefan (1990). "Bounded ordered dictionaries in *O*(log log *N*) time and *O*(*n*) space". *[Information Processing Letters](/wiki/Information_Processing_Letters "Information Processing Letters")*. **35** (4): 183–189. [doi](/wiki/Doi_%28identifier%29 "Doi (identifier)"):[10.1016/0020-0190(90)90022-P](https://doi.org/10.1016/0020-0190%2890%2990022-P).
3. **[^](#cite_ref-tao-aks_3-0)** [Tao, Terence](/wiki/Terence_Tao "Terence Tao") (2010). ["1.11 The AKS primality test"](https://terrytao.wordpress.com/2009/08/11/the-aks-primality-test/). *An epsilon of room, II: Pages from year three of a mathematical blog*. Graduate Studies in Mathematics. Vol. 117. Providence, RI: American Mathematical Society. pp. 82–86. [doi](/wiki/Doi_%28identifier%29 "Doi (identifier)"):[10.1090/gsm/117](https://doi.org/10.1090/gsm/117). [ISBN](/wiki/ISBN_%28identifier%29 "ISBN (identifier)") [978-0-8218-5280-4](/wiki/Special%3ABookSources/978-0-8218-5280-4 "Special:BookSources/978-0-8218-5280-4"). [MR](/wiki/MR_%28identifier%29 "MR (identifier)") [2780010](https://mathscinet.ams.org/mathscinet-getitem?mr=2780010).
4. **[^](#cite_ref-4)** [Lenstra, H. W. Jr.](/wiki/Hendrik_Lenstra "Hendrik Lenstra"); [Pomerance, Carl](/wiki/Carl_Pomerance "Carl Pomerance") (2019). ["Primality testing with Gaussian periods"](https://math.dartmouth.edu/~carlp/aks111216.pdf) (PDF). *[Journal of the European Mathematical Society](/wiki/Journal_of_the_European_Mathematical_Society "Journal of the European Mathematical Society")*. **21** (4): 1229–1269. [doi](/wiki/Doi_%28identifier%29 "Doi (identifier)"):[10.4171/JEMS/861](https://doi.org/10.4171/JEMS/861). [hdl](/wiki/Hdl_%28identifier%29 "Hdl (identifier)"):[21.11116/0000-0005-717D-0](https://hdl.handle.net/21.11116/0000-0005-717D-0). [MR](/wiki/MR_%28identifier%29 "MR (identifier)") [3941463](https://mathscinet.ams.org/mathscinet-getitem?mr=3941463). [S2CID](/wiki/S2CID_%28identifier%29 "S2CID (identifier)") [127807021](https://api.semanticscholar.org/CorpusID%3A127807021).
5. **[^](#cite_ref-5)** Calude, Cristian S. and Jain, Sanjay and Khoussainov, Bakhadyr and Li, Wei and Stephan, Frank (2017). ["Deciding parity games in quasipolynomial time"](https://doi.org/10.1145/3055399.3055409). *Proceedings of the 49th Annual ACM SIGACT Symposium on Theory of Computing*. Association for Computing Machinery. pp. 252–263. [doi](/wiki/Doi_%28identifier%29 "Doi (identifier)"):[10.1145/3055399.3055409](https://doi.org/10.1145/3055399.3055409). [hdl](/wiki/Hdl_%28identifier%29 "Hdl (identifier)"):[2292/31757](https://hdl.handle.net/2292/31757). [ISBN](/wiki/ISBN_%28identifier%29 "ISBN (identifier)") [9781450345286](/wiki/Special%3ABookSources/9781450345286 "Special:BookSources/9781450345286"). [S2CID](/wiki/S2CID_%28identifier%29 "S2CID (identifier)") [30338402](https://api.semanticscholar.org/CorpusID%3A30338402).`{{[cite book](/wiki/Template%3ACite_book "Template:Cite book")}}`: CS1 maint: multiple names: authors list ([link](/wiki/Category%3ACS1_maint%3A_multiple_names%3A_authors_list "Category:CS1 maint: multiple names: authors list"))
6. ^ [***a***](#cite_ref-bpp_6-0) [***b***](#cite_ref-bpp_6-1) [Babai, László](/wiki/L%C3%A1szl%C3%B3_Babai "László Babai"); [Fortnow, Lance](/wiki/Lance_Fortnow "Lance Fortnow"); [Nisan, N.](/wiki/Noam_Nisan "Noam Nisan"); [Wigderson, Avi](/wiki/Avi_Wigderson "Avi Wigderson") (1993). "BPP has subexponential time simulations unless EXPTIME has publishable proofs". *Computational Complexity*. **3** (4). Berlin, New York: [Springer-Verlag](/wiki/Springer-Verlag "Springer-Verlag"): 307–318. [doi](/wiki/Doi_%28identifier%29 "Doi (identifier)"):[10.1007/BF01275486](https://doi.org/10.1007/BF01275486). [S2CID](/wiki/S2CID_%28identifier%29 "S2CID (identifier)") [14802332](https://api.semanticscholar.org/CorpusID%3A14802332).
7. **[^](#cite_ref-7)** Bradford, Phillip G.; Rawlins, Gregory J. E.; Shannon, Gregory E. (1998). "Efficient matrix chain ordering in polylog time". *[SIAM Journal on Computing](/wiki/SIAM_Journal_on_Computing "SIAM Journal on Computing")*. **27** (2): 466–490. [doi](/wiki/Doi_%28identifier%29 "Doi (identifier)"):[10.1137/S0097539794270698](https://doi.org/10.1137/S0097539794270698). [MR](/wiki/MR_%28identifier%29 "MR (identifier)") [1616556](https://mathscinet.ams.org/mathscinet-getitem?mr=1616556).
8. **[^](#cite_ref-8)** Holm, Jacob; Rotenberg, Eva (2020). "Fully-dynamic planarity testing in polylogarithmic time". In Makarychev, Konstantin; Makarychev, Yury; Tulsiani, Madhur; Kamath, Gautam; [Chuzhoy, Julia](/wiki/Julia_Chuzhoy "Julia Chuzhoy") (eds.). *Proceedings of the 52nd Annual ACM SIGACT Symposium on Theory of Computing, STOC 2020, Chicago, IL, USA, June 22-26, 2020*. Association for Computing Machinery. pp. 167–180. [arXiv](/wiki/ArXiv_%28identifier%29 "ArXiv (identifier)"):[1911.03449](https://arxiv.org/abs/1911.03449). [doi](/wiki/Doi_%28identifier%29 "Doi (identifier)"):[10.1145/3357713.3384249](https://doi.org/10.1145/3357713.3384249). [ISBN](/wiki/ISBN_%28identifier%29 "ISBN (identifier)") [978-1-4503-6979-4](/wiki/Special%3ABookSources/978-1-4503-6979-4 "Special:BookSources/978-1-4503-6979-4").
9. **[^](#cite_ref-9)** Kumar, Ravi; [Rubinfeld, Ronitt](/wiki/Ronitt_Rubinfeld "Ronitt Rubinfeld") (2003). ["Sublinear time algorithms"](http://www.cs.princeton.edu/courses/archive/spr04/cos598B/bib/kumarR-survey.pdf) (PDF). *[SIGACT News](/wiki/SIGACT_News "SIGACT News")*. **34** (4): 57–67. [doi](/wiki/Doi_%28identifier%29 "Doi (identifier)"):[10.1145/954092.954103](https://doi.org/10.1145/954092.954103). [S2CID](/wiki/S2CID_%28identifier%29 "S2CID (identifier)") [65359](https://api.semanticscholar.org/CorpusID%3A65359).
10. **[^](#cite_ref-10)** [Rubinfeld, Ronitt](/wiki/Ronitt_Rubinfeld "Ronitt Rubinfeld") (2019). "Local Computation Algorithms". *Proceedings of the 2019 ACM Symposium on Principles of Distributed Computing (PODC)*. p. 3. [doi](/wiki/Doi_%28identifier%29 "Doi (identifier)"):[10.1145/3293611.3331587](https://doi.org/10.1145/3293611.3331587). [ISBN](/wiki/ISBN_%28identifier%29 "ISBN (identifier)") [978-1-4503-6217-7](/wiki/Special%3ABookSources/978-1-4503-6217-7 "Special:BookSources/978-1-4503-6217-7").
11. **[^](#cite_ref-11)** Naik, Ashish V.; Regan, Kenneth W.; Sivakumar, D. (1995). ["On quasilinear-time complexity theory"](http://www.cse.buffalo.edu/~regan/papers/pdf/NRS95.pdf) (PDF). *[Theoretical Computer Science](/wiki/Theoretical_Computer_Science_%28journal%29 "Theoretical Computer Science (journal)")*. **148** (2): 325–349. [doi](/wiki/Doi_%28identifier%29 "Doi (identifier)"):[10.1016/0304-3975(95)00031-Q](https://doi.org/10.1016/0304-3975%2895%2900031-Q). [MR](/wiki/MR_%28identifier%29 "MR (identifier)") [1355592](https://mathscinet.ams.org/mathscinet-getitem?mr=1355592).
12. **[^](#cite_ref-12)** Sedgewick, Robert; Wayne, Kevin (2011). [*Algorithms*](https://algs4.cs.princeton.edu/home/) (4th ed.). Pearson Education. p. 186.
13. **[^](#cite_ref-13)** [Papadimitriou, Christos H.](/wiki/Christos_H._Papadimitriou "Christos H. Papadimitriou") (1994). *Computational complexity*. Reading, Mass.: Addison-Wesley. [ISBN](/wiki/ISBN_%28identifier%29 "ISBN (identifier)") [0-201-53082-1](/wiki/Special%3ABookSources/0-201-53082-1 "Special:BookSources/0-201-53082-1").
14. **[^](#cite_ref-14)** [Cobham, Alan](/wiki/Alan_Cobham_%28mathematician%29 "Alan Cobham (mathematician)") (1965). "The intrinsic computational difficulty of functions". *Proc. Logic, Methodology, and Philosophy of Science II*. North Holland.
15. **[^](#cite_ref-15)** [Braverman, Mark](/wiki/Mark_Braverman_%28mathematician%29 "Mark Braverman (mathematician)"); Kun-Ko, Young; Rubinstein, Aviad; Weinstein, Omri (2017). "ETH hardness for densest-k-subgraph with perfect completeness". In Klein, Philip N. (ed.). *Proceedings of the Twenty-Eighth Annual ACM-SIAM Symposium on Discrete Algorithms, SODA 2017, Barcelona, Spain, Hotel Porta Fira, January 16-19*. Society for Industrial and Applied Mathematics. pp. 1326–1341. [arXiv](/wiki/ArXiv_%28identifier%29 "ArXiv (identifier)"):[1504.08352](https://arxiv.org/abs/1504.08352). [doi](/wiki/Doi_%28identifier%29 "Doi (identifier)"):[10.1137/1.9781611974782.86](https://doi.org/10.1137/1.9781611974782.86). [ISBN](/wiki/ISBN_%28identifier%29 "ISBN (identifier)") [978-1-61197-478-2](/wiki/Special%3ABookSources/978-1-61197-478-2 "Special:BookSources/978-1-61197-478-2"). [MR](/wiki/MR_%28identifier%29 "MR (identifier)") [3627815](https://mathscinet.ams.org/mathscinet-getitem?mr=3627815).
16. **[^](#cite_ref-16)** *[Complexity Zoo](/wiki/Complexity_Zoo "Complexity Zoo")*: [Class QP: Quasipolynomial-Time](https://complexityzoo.net/Complexity_Zoo%3AQ#qp)
17. ^ [***a***](#cite_ref-ETH_17-0) [***b***](#cite_ref-ETH_17-1) [Impagliazzo, Russell](/wiki/Russell_Impagliazzo "Russell Impagliazzo"); Paturi, Ramamohan (2001). ["On the complexity of k-SAT"](https://cseweb.ucsd.edu/~paturi/myPapers/pubs/ImpagliazzoPaturi_2001_jcss.pdf) (PDF). *[Journal of Computer and System Sciences](/wiki/Journal_of_Computer_and_System_Sciences "Journal of Computer and System Sciences")*. **62** (2): 367–375. [doi](/wiki/Doi_%28identifier%29 "Doi (identifier)"):[10.1006/jcss.2000.1727](https://doi.org/10.1006/jcss.2000.1727). [MR](/wiki/MR_%28identifier%29 "MR (identifier)") [1820597](https://mathscinet.ams.org/mathscinet-getitem?mr=1820597).
18. **[^](#cite_ref-18)** Aaronson, Scott (5 April 2009). ["A not-quite-exponential dilemma"](http://scottaaronson.com/blog/?p=394). *Shtetl-Optimized*. Retrieved 2 December 2009.
19. **[^](#cite_ref-19)** *[Complexity Zoo](/wiki/Complexity_Zoo "Complexity Zoo")*: [Class SUBEXP: Deterministic Subexponential-Time](https://complexityzoo.net/Complexity_Zoo%3AS#subexp)
20. **[^](#cite_ref-20)** Moser, P. (2003). "Baire's Categories on Small Complexity Classes". In Andrzej Lingas; Bengt J. Nilsson (eds.). *Fundamentals of Computation Theory: 14th International Symposium, FCT 2003, Malmö, Sweden, August 12-15, 2003, Proceedings*. [Lecture Notes in Computer Science](/wiki/Lecture_Notes_in_Computer_Science "Lecture Notes in Computer Science"). Vol. 2751. Berlin, New York: Springer-Verlag. pp. 333–342. [doi](/wiki/Doi_%28identifier%29 "Doi (identifier)"):[10.1007/978-3-540-45077-1\_31](https://doi.org/10.1007/978-3-540-45077-1_31). [ISBN](/wiki/ISBN_%28identifier%29 "ISBN (identifier)") [978-3-540-40543-6](/wiki/Special%3ABookSources/978-3-540-40543-6 "Special:BookSources/978-3-540-40543-6"). [ISSN](/wiki/ISSN_%28identifier%29 "ISSN (identifier)") [0302-9743](https://search.worldcat.org/issn/0302-9743).
21. **[^](#cite_ref-21)** Miltersen, P.B. (2001). "Derandomizing Complexity Classes". *Handbook of Randomized Computing*. Combinatorial Optimization. **9**. Kluwer Academic Pub: 843. [doi](/wiki/Doi_%28identifier%29 "Doi (identifier)"):[10.1007/978-1-4615-0013-1\_19](https://doi.org/10.1007/978-1-4615-0013-1_19) (inactive 1 November 2024). [ISBN](/wiki/ISBN_%28identifier%29 "ISBN (identifier)") [978-1-4613-4886-3](/wiki/Special%3ABookSources/978-1-4613-4886-3 "Special:BookSources/978-1-4613-4886-3").`{{[cite journal](/wiki/Template%3ACite_journal "Template:Cite journal")}}`: CS1 maint: DOI inactive as of November 2024 ([link](/wiki/Category%3ACS1_maint%3A_DOI_inactive_as_of_November_2024 "Category:CS1 maint: DOI inactive as of November 2024"))
22. **[^](#cite_ref-22)** Kuperberg, Greg (2005). "A Subexponential-Time Quantum Algorithm for the Dihedral Hidden Subgroup Problem". *SIAM Journal on Computing*. **35** (1). Philadelphia: 188. [arXiv](/wiki/ArXiv_%28identifier%29 "ArXiv (identifier)"):[quant-ph/0302112](https://arxiv.org/abs/quant-ph/0302112). [doi](/wiki/Doi_%28identifier%29 "Doi (identifier)"):[10.1137/s0097539703436345](https://doi.org/10.1137/s0097539703436345). [ISSN](/wiki/ISSN_%28identifier%29 "ISSN (identifier)") [1095-7111](https://search.worldcat.org/issn/1095-7111). [S2CID](/wiki/S2CID_%28identifier%29 "S2CID (identifier)") [15965140](https://api.semanticscholar.org/CorpusID%3A15965140).
23. **[^](#cite_ref-23)** Oded Regev (2004). "A Subexponential Time Algorithm for the Dihedral Hidden Subgroup Problem with Polynomial Space". [arXiv](/wiki/ArXiv_%28identifier%29 "ArXiv (identifier)"):[quant-ph/0406151v1](https://arxiv.org/abs/quant-ph/0406151v1).
24. **[^](#cite_ref-24)** Grohe, Martin; Neuen, Daniel (2021). "Recent advances on the graph isomorphism problem". In Dabrowski, Konrad K.; Gadouleau, Maximilien; Georgiou, Nicholas; Johnson, Matthew; Mertzios, George B.; Paulusma, Daniël (eds.). *Surveys in combinatorics 2021*. London Mathematical Society Lecture Note Series. Vol. 470. Cambridge University Press. pp. 187–234. [arXiv](/wiki/ArXiv_%28identifier%29 "ArXiv (identifier)"):[2011.01366](https://arxiv.org/abs/2011.01366). [ISBN](/wiki/ISBN_%28identifier%29 "ISBN (identifier)") [978-1-009-01888-3](/wiki/Special%3ABookSources/978-1-009-01888-3 "Special:BookSources/978-1-009-01888-3"). [MR](/wiki/MR_%28identifier%29 "MR (identifier)") [4273431](https://mathscinet.ams.org/mathscinet-getitem?mr=4273431).
25. **[^](#cite_ref-25)** Flum, Jörg; [Grohe, Martin](/wiki/Martin_Grohe "Martin Grohe") (2006). [*Parameterized Complexity Theory*](https://www.springer.com/east/home/generic/search/results?SGWID=5-40109-22-141358322-0). Springer. p. 417. [ISBN](/wiki/ISBN_%28identifier%29 "ISBN (identifier)") [978-3-540-29952-3](/wiki/Special%3ABookSources/978-3-540-29952-3 "Special:BookSources/978-3-540-29952-3").
26. **[^](#cite_ref-26)** [Impagliazzo, R.](/wiki/Russell_Impagliazzo "Russell Impagliazzo"); Paturi, R.; Zane, F. (2001). ["Which problems have strongly exponential complexity?"](https://doi.org/10.1006/jcss.2001.1774). *[Journal of Computer and System Sciences](/wiki/Journal_of_Computer_and_System_Sciences "Journal of Computer and System Sciences")*. **63** (4): 512–530. [doi](/wiki/Doi_%28identifier%29 "Doi (identifier)"):[10.1006/jcss.2001.1774](https://doi.org/10.1006/jcss.2001.1774).
27. **[^](#cite_ref-27)** [Mayr, Ernst W.](/wiki/Ernst_Mayr_%28computer_scientist%29 "Ernst Mayr (computer scientist)"); [Meyer, Albert R.](/wiki/Albert_R._Meyer "Albert R. Meyer") (1982). ["The complexity of the word problems for commutative semigroups and polynomial ideals"](https://doi.org/10.1016/0001-8708%2882%2990048-2). *[Advances in Mathematics](/wiki/Advances_in_Mathematics "Advances in Mathematics")*. **46** (3): 305–329. [doi](/wiki/Doi_%28identifier%29 "Doi (identifier)"):[10.1016/0001-8708(82)90048-2](https://doi.org/10.1016/0001-8708%2882%2990048-2). [hdl](/wiki/Hdl_%28identifier%29 "Hdl (identifier)"):[1721.1/149010](https://hdl.handle.net/1721.1/149010). [MR](/wiki/MR_%28identifier%29 "MR (identifier)") [0683204](https://mathscinet.ams.org/mathscinet-getitem?mr=0683204).
28. **[^](#cite_ref-28)** [Davenport, James H.](/wiki/James_H._Davenport "James H. Davenport"); [Heintz, Joos](/wiki/Joos_Ulrich_Heintz "Joos Ulrich Heintz") (1988). ["Real quantifier elimination is doubly exponential"](https://doi.org/10.1016/S0747-7171%2888%2980004-X). *[Journal of Symbolic Computation](/wiki/Journal_of_Symbolic_Computation "Journal of Symbolic Computation")*. **5** (1–2): 29–35. [doi](/wiki/Doi_%28identifier%29 "Doi (identifier)"):[10.1016/S0747-7171(88)80004-X](https://doi.org/10.1016/S0747-7171%2888%2980004-X). [MR](/wiki/MR_%28identifier%29 "MR (identifier)") [0949111](https://mathscinet.ams.org/mathscinet-getitem?mr=0949111).
29. **[^](#cite_ref-29)** [Collins, George E.](/wiki/George_E._Collins "George E. Collins") (1975). "Quantifier elimination for real closed fields by cylindrical algebraic decomposition". In Brakhage, H. (ed.). *Automata Theory and Formal Languages: 2nd GI Conference, Kaiserslautern, May 20–23, 1975*. Lecture Notes in Computer Science. Vol. 33. Springer. pp. 134–183. [doi](/wiki/Doi_%28identifier%29 "Doi (identifier)"):[10.1007/3-540-07407-4\_17](https://doi.org/10.1007/3-540-07407-4_17). [ISBN](/wiki/ISBN_%28identifier%29 "ISBN (identifier)") [978-3-540-07407-6](/wiki/Special%3ABookSources/978-3-540-07407-6 "Special:BookSources/978-3-540-07407-6"). [MR](/wiki/MR_%28identifier%29 "MR (identifier)") [0403962](https://mathscinet.ams.org/mathscinet-getitem?mr=0403962).

![](https://login.wikimedia.org/wiki/Special:CentralAutoLogin/start?useformat=desktop&type=1x1&usesul3=0)
Retrieved from "<https://en.wikipedia.org/w/index.php?title=Time_complexity&oldid=1263568428>"
[Categories](/wiki/Help%3ACategory "Help:Category"):

* [Analysis of algorithms](/wiki/Category%3AAnalysis_of_algorithms "Category:Analysis of algorithms")
* [Computational complexity theory](/wiki/Category%3AComputational_complexity_theory "Category:Computational complexity theory")
* [Computational resources](/wiki/Category%3AComputational_resources "Category:Computational resources")
* [Time](/wiki/Category%3ATime "Category:Time")
Hidden categories:

* [CS1 maint: multiple names: authors list](/wiki/Category%3ACS1_maint%3A_multiple_names%3A_authors_list "Category:CS1 maint: multiple names: authors list")
* [CS1 maint: DOI inactive as of November 2024](/wiki/Category%3ACS1_maint%3A_DOI_inactive_as_of_November_2024 "Category:CS1 maint: DOI inactive as of November 2024")
* [Articles with short description](/wiki/Category%3AArticles_with_short_description "Category:Articles with short description")
* [Short description matches Wikidata](/wiki/Category%3AShort_description_matches_Wikidata "Category:Short description matches Wikidata")
* [Use dmy dates from September 2019](/wiki/Category%3AUse_dmy_dates_from_September_2019 "Category:Use dmy dates from September 2019")

* This page was last edited on 17 December 2024, at 11:17 (UTC).
* Text is available under the [Creative Commons Attribution-ShareAlike 4.0 License](/wiki/Wikipedia%3AText_of_the_Creative_Commons_Attribution-ShareAlike_4.0_International_License "Wikipedia:Text of the Creative Commons Attribution-ShareAlike 4.0 International License");
  additional terms may apply. By using this site, you agree to the [Terms of Use](https://foundation.wikimedia.org/wiki/Special%3AMyLanguage/Policy%3ATerms_of_Use "foundation:Special:MyLanguage/Policy:Terms of Use") and [Privacy Policy](https://foundation.wikimedia.org/wiki/Special%3AMyLanguage/Policy%3APrivacy_policy "foundation:Special:MyLanguage/Policy:Privacy policy"). Wikipedia® is a registered trademark of the [Wikimedia Foundation, Inc.](https://wikimediafoundation.org/), a non-profit organization.

* [Privacy policy](https://foundation.wikimedia.org/wiki/Special%3AMyLanguage/Policy%3APrivacy_policy)
* [About Wikipedia](/wiki/Wikipedia%3AAbout)
* [Disclaimers](/wiki/Wikipedia%3AGeneral_disclaimer)
* [Contact Wikipedia](//en.wikipedia.org/wiki/Wikipedia%3AContact_us)
* [Code of Conduct](https://foundation.wikimedia.org/wiki/Special%3AMyLanguage/Policy%3AUniversal_Code_of_Conduct)
* [Developers](https://developer.wikimedia.org)
* [Statistics](https://stats.wikimedia.org/#/en.wikipedia.org)
* [Cookie statement](https://foundation.wikimedia.org/wiki/Special%3AMyLanguage/Policy%3ACookie_statement)
* [Mobile view](//en.m.wikipedia.org/w/index.php?title=Time_complexity&mobileaction=toggle_view_mobile)

* [![Wikimedia Foundation](/static/images/footer/wikimedia-button.svg)](https://wikimediafoundation.org/)
* [![Powered by MediaWiki](/w/resources/assets/poweredby_mediawiki.svg)](https://www.mediawiki.org/)

