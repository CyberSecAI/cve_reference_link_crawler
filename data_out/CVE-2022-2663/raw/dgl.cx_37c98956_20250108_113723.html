<!DOCTYPE html>
<html lang="en-GB">
  <head>
    <meta name="viewport" content="width=device-width">
    <title>NAT-Again: IRC NAT helper flaws</title>
    <link rel="stylesheet" href="/static/dgl.css" type="text/css">
    <link rel="alternate" href="https://dgl.cx/feed" type="application/atom+xml" title="Feed">
    <link rel="webmention" href="https://dgl.cx/i/mention">
    <link rel="pingback" href="https://dgl.cx/i/pingback">
    <link rel="canonical" href="https://dgl.cx/2022/08/nat-again-irc-cve-2022-2663">
    <link rel="icon" href="/favicon.ico" type="image/png">
    <style>
      main iframe { display: block; margin: 0 auto; text-align: center; max-width: 85vw; } iframe { padding: 2em; } a { overflow-wrap: break-word;  word-wrap: break-word; }
    </style>
  </head>
  <body>
    <div id="_">
      <header>
        <div class="background" title="Mawgan Porth, Cornwall" style="background-image: url(/static/b/11.jpg)">
          <h1><a href="/" title="Home">dgl.cx</a></h1>
          <div id="links">
            <a href="/projects">projects</a>
            <a href="/about" title="About me and this site">about</a>
          </div>
        </div>
      </header>
      <main id="content">
        <h2 class="scrollable"><a href="#_">NAT-Again: IRC NAT helper flaws</a></h2>
        <span id="spacer"></span>
        <script>
          let scrolled = false;
          let scrollable = document.querySelector("h2.scrollable");
          scrollable.classList.add("scroll");
          let startPos = scrollable.offsetTop;
          addEventListener("scroll", e => {
            if (document.scrollingElement.scrollTop > startPos/2.5) {
              if (!scrolled) {
                scrollable.classList.add("header");
                let opacity = 1 - ((document.scrollingElement.scrollTop-(startPos/2.5)*(1/startPos)));
                document.querySelector("h1 a").style.opacity = opacity;
                document.querySelector("#links").style.opacity = opacity;
                if (document.scrollingElement.scrollTop > startPos) {
                  scrolled = true;
                  scrollable.classList.add("header-full");
                  
                  
                  if ('userAgentData' in navigator &&
                      navigator.userAgentData.brands.filter(b => b.brand == 'Chromium').length) {
                    document.querySelector("#spacer").style.display = 'inline-block';
                    document.querySelector("#spacer").style.height = '40px';
                  }
                }
              }
            } else if (document.scrollingElement.scrollTop < startPos/2.5) {
              scrolled = false;
              document.querySelector("h1 a").style.opacity = 1;
              document.querySelector("#links").style.opacity = 1;
              document.querySelector("#spacer").style.display = '';
              document.querySelector("#spacer").style.height = '';
              scrollable.classList.remove('header', 'header-full');
            }
          });
        </script>
        <div class="post-body">
          <article>
<p><i><b>tl;dr:</b></i> A Linux kernel bug allows unencrypted NAT'd IRC sessions to be abused to
access resources behind NAT, or drop connections. Switch to TLS right now. Or read on.</p>

<p><a href="https://samy.pl/slipstream/">NAT slipstreaming</a> was an attack where a NAT device is
tricked into forwarding requests into a network that is behind a NAT router. The original attack is
largely mitigated and primarily targets web browsers.</p>

<p>This attack works against a standard IRC client. It is possible due to a bug in
the Linux netfilter implementation, in particular nf_conntrack_irc. I have not checked other NAT
implementations but similar attacks may be possible.</p>

<p>Interestingly the discoverer of NAT slipstreaming has an attack from 2010 called <a
href="https://samy.pl/natpin/">&quot;NAT Pinning&quot;</a> that leveraged IRC, but the novel
addition here is the fact the matching done on the message is not complete.</p>

<h3>Background on IRC</h3>

<p>IRC is a simple and very old text based protocol, each line sent or received
from the server represents a message in the IRC protocol. In order to extend
the protocol IRC clients support a protocol called Client to Client Protocol
(CTCP). CTCP simply uses the ^A character (&quot;\001&quot;) to mark the special messages
that are not messages between users, but some form of control message.</p>

<p>On top of this protocol some clients support a protocol called DCC (&quot;Direct
Client-to-Client&quot;) that allows for connections between clients, by sending the
other client the details of the IP and port to connect to. This protocol is
what nf_conntrack_irc targets in order to change the IP sent to the other
client and therefore continue to allow DCC connections in the presence of NAT.</p>

<h3>The bugs</h3>

<p>This attack leverages two bugs in nf_conntrack_irc.</p>

<p>First bug: nf_conntrack_irc does not completely match on the IRC protocol.</p>

<p>As mentioned above DCC messages are contained within a CTCP message, therefore
to find a DCC message the string &quot;\1DCC &quot; should be matched. This string should
be at the start of a message -- this is the bug, nf_conntrack_irc allows this
string anywhere within the outbound TCP stream.</p>

<p>This code snippet from
<a href="https://github.com/torvalds/linux/blob/v5.19/net/netfilter/nf_conntrack_irc.c#L154-L160">nf_conntrack_irc.c</a>
shows the main matching code, in particular it looks through the string (while loop) finding the
first instance
of &quot;\1DCC &quot; (with memcmp).</p>

<p><pre><code>  /* strlen(&quot;\1DCC SENT t AAAAAAAA P\1\n&quot;)=24
   * 5+MINMATCHLEN+strlen(&quot;t AAAAAAAA P\1\n&quot;)=14 */
  while (data &lt; data_limit - (19 + MINMATCHLEN)) {
      if (memcmp(data, &quot;\1DCC &quot;, 5)) {
          data++;
          continue;
      }
</pre></code></p>

<p>Second bug: The external IP address is not checked correctly.</p>

<p>Again, in nf_conntrack_irc.c the comment says it is checking for &quot;the internal
OR external IP&quot;. In fact this code is buggy and instead checks for the IP
address of the IRC server.</p>

<p><pre><code>    /* dcc_ip can be the internal OR external (NAT'ed) IP */
    tuple = &amp;ct-&gt;tuplehash[dir].tuple;
    if (tuple-&gt;src.u3.ip != dcc_ip &amp;&amp;
        tuple-&gt;dst.u3.ip != dcc_ip) {
          net_warn_ratelimited(&quot;Forged DCC command from %pI4: %pI4:%u\n&quot;,</code></pre></p>

<p>There is also a related third bug that allows for a DoS, if the port specified
is 0, then the packet is dropped, eventually resulting the user being
disconnected from IRC (because they cannot send any further packets on the
connection).</p>

<h3>The attack on IRC</h3>

<p>Because of the first bug, we can trick a connected IRC client into opening a
port forward of our liking by sending it a specially crafted CTCP PING message.</p>

<p>We can also take advantage of the second bug and only need to provide the
address of the server the user is connected to (often available from /whois on
IRC networks).</p>

<p>If 198.51.100.1 is the address of the IRC server the victim user is connected
to, we can craft a message by encoding the IP as a number:</p>

<p><pre>$ perl -MSocket -E'say unpack &quot;N&quot;, inet_aton(&quot;198.51.100.1&quot;)'
3325256705
</pre></p>

<p>This then leads to constructing a raw IRC message like:</p>

<p><code>PRIVMSG ExampleUser :^APING ^ADCC CHAT x 3325256705 22^A</code></p>

<p>(where ^A is Ctrl-A, to type this on some clients needs Ctrl-V Ctrl-A,
prefixing the raw command with /quote to send it from most clients.)</p>

<p>Once this command is run you should see a reply from the user's client, with
the 3325256705 number replaced with their numeric IP address. Example:</p>

<p><code>CTCP PING reply from ExampleUser: ADCC CHAT x 3221225985 22</code></p>

<p>Connecting to this IP and port should lead to port 22 on their internal
machine.</p>

<p>The above has been tested and works on Irssi and mIRC, other clients may not
respond to the PING in quite the same way. Here is a demo video of the attack
against Irssi:</p>

<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/WIq-YgQuYCA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope;
  picture-in-picture" allowfullscreen></iframe>

<p>Note because the response packet is rewritten it would be possible to use
something like this to scan for vulnerable users (in particular, it's possible
to send a CTCP PING message to a whole channel); as well as reveal an IP
address of a user, that would otherwise be &quot;cloaked&quot; by the IRC server.</p>

<p>The third bug mentioned (sending port 0), combined with the reflection attack
means it is possible to disconnect a user.</p>

<h3>Mitigations</h3>

<ul>

<li><p><b>Use TLS for IRC</b>, this means nf_conntrack_irc cannot intercept DCC requests
and DCC NAT traversal will not work without manual port forwarding. (Using TLS hopefully goes
without saying these days anyway.)</p></li>

<li><p>Since upstream kernel version 4.6 (commit <a href="https://github.com/torvalds/linux/commit/3bb398d925ec"
 title="netfilter: nf_ct_helper: disable automatic helper assignment">3bb398d925ec</a>) NAT helpers have not
been loaded by default and need a
<a href="https://home.regit.org/netfilter-en/secure-use-of-helpers/">rule to enable them</a>.
However some consumer routers use an older kernel version, or change the default back and load
helpers. (As a result of this vulnerability <a href="https://lore.kernel.org/netfilter-devel/20220826070600.8404-1-pablo@netfilter.org/T/#u" title="[PATCH nf] netfilter: remove nf_conntrack_helper sysctl
  toggle">a change is being made</a> to make the helpers require explicit configuration.)</p></li>
<li><p>In the short term remove any iptables rules referencing <code>-m helper --helper
  irc</code> and unload nf_conntrack_irc.
  On MikroTik devices remove IRC from the service ports list (<code>/ip firewall/service-port/disable irc</code>)
  </p></li>

<li>Apply the <a href="https://lore.kernel.org/netfilter-devel/20220826045658.100360-1-dgl@dgl.cx/T/">patch</a>.</li>

</ul>

<h3>Recommendations</h3>

<ul>
<li><p>Potentially entirely deprecate and remove nf_conntrack_irc, it's unclear it
has much use anymore.</p></li>
<li><p>Fix nf_conntrack_irc to match on "PRIVMSG" and " :" (case insensitively) before the DCC
string. It is unlikely IP fragmentation is a concern as in the original NAT slipstreaming attacks
because IRC is limited to 512 bytes per message, so a PING request cannot generate a fragmented
response, however this could be investigated further.</p>
<ul>
<li><p>Matching on &quot;PRIVMSG&quot; provides defence-in-depth, as a reply to a CTCP
message is sent as a &quot;NOTICE&quot;.
</p></li>
</ul>
</li>
<li><p>Fix nf_conntrack_irc to match on the external NAT'd IP (or even drop it as it
is unclear it has worked correctly and matching only the internal IP somewhat
increases the difficulty of attacking this).
<a href="https://lore.kernel.org/netfilter-devel/20220826045658.100360-1-dgl@dgl.cx/T/" title="[PATCH 1/2] netfilter: nf_conntrack_irc: Tighten matching on DCC message">Patches have been sent for these</a>.
</p></li>
<li><p>IRC clients <a href="https://github.com/ircv3/ircv3-specifications/issues/504">should implement</a> a defence-in-depth of dropping &quot;^A&quot; inside CTCP
PING responses. It is also possible for an IRC network to filter this, this vulnerability was pre-disclosed to <a
href="https://libera.chat/">Libera.Chat</a> and they have implemented filtering.</p></li>
</ul>

<p>This issue is tracked as CVE-2022-2663.</p>

<p>
<h3>Timeline</h3>
2022-07-29: Issue discovered, contacted kernel security contacts.<br>
2022-08-03: Notification to various Linux distros + MikroTik.<br>
2022-08-26: <a href="https://lore.kernel.org/netfilter-devel/20220826045658.100360-1-dgl@dgl.cx/T/">Patches</a> sent to netfilter-devel@<br>
2022-08-29: Summary details <a href="https://www.openwall.com/lists/oss-security/2022/08/30/1">sent to oss-security</a>.<br>
2022-09-01: These details released.<br>
2022-09-01: MikroTik release testing RouterOS <a href="https://mikrotik.com/download/changelogs/testing-release-tree">7.6beta4</a> containing a fix for this issue.</br>
2022-09-01: <a href="https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git/commit/?id=0efe125cfb99e6773a7434f3463f7c2fa28f3a43">First patch</a> is merged into the
net.git tree<br>
2022-09-07: <a href="https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git/commit/?id=e8d5dfd1d8747b56077d02664a8838c71ced948e">Second patch</a> is merged into the
net.git tree<br>
2022-09-15: Linux 5.19.9 and other stable kernels released on this date <a
href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=v5.19.9&id=6cf0609154b2ce8d3ae160e7506ab316400a8d3d">contain patch #1</a><br>
2022-09-28: Linux 5.19.12 and other stable kernels released on this date <a
href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=v5.19.12&id=510ea9eae5ee45f4e443023556532bda99387351">contain patch #2</a><br>
</p>

<p><i>Thanks to <a href="https://www.gresearch.co.uk/technology-innovation-and-open-source/">G-Research Open
Source</a> for supporting some of my work on this. While this may not be a critical vulnerability
alone, many open source developers use IRC so this could be used as part of a supply chain attack or similar.</p>
<div class="post-details post-info">
  <span class="post-date">29<sup>th</sup> August 2022</span>
</div>
</article>

        </div>
      </main>
      <footer>
        ©<a href="/contact" rel="author">David Leadbeater</a>
        <div>
          <a href="https://github.com/dgl" rel="me"><img src="/static/github.png" alt="GitHub"></a>
          <a href="https://infosec.exchange/@dgl" rel="me"><img src="/static/mastodon.png" alt="Mastodon"></a>
          <a href="https://dgl.cx/feed" title="Atom feed"><img src="/static/feed.png" alt="Feed"></a>
        </div>
      </footer>
      <script>
        addEventListener("load", e => {
          let ev = JSON.stringify({name: name||=('randomUUID' in crypto ? crypto.randomUUID() : Math.random()), load: (new Date).getTime(), location: ""+location, referrer: document.referrer, performance: 'performance' in window ? {...JSON.parse(JSON.stringify(performance.getEntries()[0])), name: ""} : ""});
          if (!navigator.sendBeacon("/i/l", ev)) fetch("/i/l", {body: ev});
        });
        let preF={};
        [...document.querySelectorAll("a")].filter(f => f.href.match("^"+location.origin)) .map(a => { a.addEventListener("mouseover", e => { if(!(a.href in preF)) { preF[a.href]=true; let pre = document.createElement("link"); pre.href = a.href; pre.rel = "prefetch"; document.head.append(pre)}})})
      </script>
    </div>
  </body>
</html>
