

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=9e2f9d34dd12e6e5b244ec488bcebd0c2d566c50)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=9e2f9d34dd12e6e5b244ec488bcebd0c2d566c50)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9e2f9d34dd12e6e5b244ec488bcebd0c2d566c50)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9e2f9d34dd12e6e5b244ec488bcebd0c2d566c50)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Gao Xiang <hsiangkao@linux.alibaba.com> | 2024-09-10 15:08:47 +0800 |
| --- | --- | --- |
| committer | Gao Xiang <hsiangkao@linux.alibaba.com> | 2024-09-10 15:26:15 +0800 |
| commit | [9e2f9d34dd12e6e5b244ec488bcebd0c2d566c50](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9e2f9d34dd12e6e5b244ec488bcebd0c2d566c50) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=9e2f9d34dd12e6e5b244ec488bcebd0c2d566c50)) | |
| tree | [9154ce3f181374ca44a46caf93c125e5e7fb4e00](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=9e2f9d34dd12e6e5b244ec488bcebd0c2d566c50) | |
| parent | [3fc3e45fcdeaad4b7660b560fcbc827eb733f58e](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3fc3e45fcdeaad4b7660b560fcbc827eb733f58e) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9e2f9d34dd12e6e5b244ec488bcebd0c2d566c50&id2=3fc3e45fcdeaad4b7660b560fcbc827eb733f58e)) | |
| download | [linux-9e2f9d34dd12e6e5b244ec488bcebd0c2d566c50.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-9e2f9d34dd12e6e5b244ec488bcebd0c2d566c50.tar.gz) | |

erofs: handle overlapped pclusters out of crafted images properlysyzbot reported a task hang issue due to a deadlock case where it is
waiting for the folio lock of a cached folio that will be used for
cache I/Os.
After looking into the crafted fuzzed image, I found it's formed with
several overlapped big pclusters as below:
Ext: logical offset | length : physical offset | length
0: 0.. 16384 | 16384 : 151552.. 167936 | 16384
1: 16384.. 32768 | 16384 : 155648.. 172032 | 16384
2: 32768.. 49152 | 16384 : 537223168.. 537239552 | 16384
...
Here, extent 0/1 are physically overlapped although it's entirely
\_impossible\_ for normal filesystem images generated by mkfs.
First, managed folios containing compressed data will be marked as
up-to-date and then unlocked immediately (unlike in-place folios) when
compressed I/Os are complete. If physical blocks are not submitted in
the incremental order, there should be separate BIOs to avoid dependency
issues. However, the current code mis-arranges z\_erofs\_fill\_bio\_vec()
and BIO submission which causes unexpected BIO waits.
Second, managed folios will be connected to their own pclusters for
efficient inter-queries. However, this is somewhat hard to implement
easily if overlapped big pclusters exist. Again, these only appear in
fuzzed images so let's simply fall back to temporary short-lived pages
for correctness.
Additionally, it justifies that referenced managed folios cannot be
truncated for now and reverts part of commit 2080ca1ed3e4 ("erofs: tidy
up `struct z\_erofs\_bvec`") for simplicity although it shouldn't be any
difference.
Reported-by: syzbot+4fc98ed414ae63d1ada2@syzkaller.appspotmail.com
Reported-by: syzbot+de04e06b28cfecf2281c@syzkaller.appspotmail.com
Reported-by: syzbot+c8c8238b394be4a1087d@syzkaller.appspotmail.com
Tested-by: syzbot+4fc98ed414ae63d1ada2@syzkaller.appspotmail.com
Closes: https://lore.kernel.org/r/0000000000002fda01061e334873@google.com
Fixes: 8e6c8fa9f2e9 ("erofs: enable big pcluster feature")
Signed-off-by: Gao Xiang <hsiangkao@linux.alibaba.com>
Link: [https://lore.kernel.org/r/20240910070847.3356592-1-hsiangkao@linux.alibaba.com](https://lore.kernel.org/r/20240910070847.3356592-1-hsiangkao%40linux.alibaba.com)
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9e2f9d34dd12e6e5b244ec488bcebd0c2d566c50)

| -rw-r--r-- | [fs/erofs/zdata.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/erofs/zdata.c?id=9e2f9d34dd12e6e5b244ec488bcebd0c2d566c50) | 71 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 38 insertions, 33 deletions

| diff --git a/fs/erofs/zdata.c b/fs/erofs/zdata.cindex 424f656cd765e2..a0bae499c5ff65 100644--- a/[fs/erofs/zdata.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/erofs/zdata.c?id=3fc3e45fcdeaad4b7660b560fcbc827eb733f58e)+++ b/[fs/erofs/zdata.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/erofs/zdata.c?id=9e2f9d34dd12e6e5b244ec488bcebd0c2d566c50)@@ -1428,6 +1428,7 @@ static void z\_erofs\_fill\_bio\_vec(struct bio\_vec \*bvec, struct z\_erofs\_bvec zbv; struct address\_space \*mapping; struct folio \*folio;+ struct page \*page; int bs = i\_blocksize(f->inode);  /\* Except for inplace folios, the entire folio can be used for I/Os \*/@@ -1450,7 +1451,6 @@ repeat: \* file-backed folios will be used instead. \*/ if (folio->private == (void \*)Z\_EROFS\_PREALLOCATED\_PAGE) {- folio->private = 0; tocache = true; goto out\_tocache; }@@ -1468,7 +1468,7 @@ repeat: }  folio\_lock(folio);- if (folio->mapping == mc) {+ if (likely(folio->mapping == mc)) { /\* \* The cached folio is still in managed cache but without \* a valid `->private` pcluster hint. Let's reconnect them.@@ -1478,41 +1478,44 @@ repeat: /\* compressed\_bvecs[] already takes a ref before \*/ folio\_put(folio); }-- /\* no need to submit if it is already up-to-date \*/- if (folio\_test\_uptodate(folio)) {- folio\_unlock(folio);- bvec->bv\_page = NULL;+ if (likely(folio->private == pcl)) {+ /\* don't submit cache I/Os again if already uptodate \*/+ if (folio\_test\_uptodate(folio)) {+ folio\_unlock(folio);+ bvec->bv\_page = NULL;+ }+ return; }- return;+ /\*+ \* Already linked with another pcluster, which only appears in+ \* crafted images by fuzzers for now. But handle this anyway.+ \*/+ tocache = false; /\* use temporary short-lived pages \*/+ } else {+ DBG\_BUGON(1); /\* referenced managed folios can't be truncated \*/+ tocache = true; }-- /\*- \* It has been truncated, so it's unsafe to reuse this one. Let's- \* allocate a new page for compressed data.- \*/- DBG\_BUGON(folio->mapping);- tocache = true; folio\_unlock(folio); folio\_put(folio); out\_allocfolio:- zbv.page = erofs\_allocpage(&f->pagepool, gfp | \_\_GFP\_NOFAIL);+ page = erofs\_allocpage(&f->pagepool, gfp | \_\_GFP\_NOFAIL); spin\_lock(&pcl->obj.lockref.lock);- if (pcl->compressed\_bvecs[nr].page) {- erofs\_pagepool\_add(&f->pagepool, zbv.page);+ if (unlikely(pcl->compressed\_bvecs[nr].page != zbv.page)) {+ erofs\_pagepool\_add(&f->pagepool, page); spin\_unlock(&pcl->obj.lockref.lock); cond\_resched(); goto repeat; }- bvec->bv\_page = pcl->compressed\_bvecs[nr].page = zbv.page;- folio = page\_folio(zbv.page);- /\* first mark it as a temporary shortlived folio (now 1 ref) \*/- folio->private = (void \*)Z\_EROFS\_SHORTLIVED\_PAGE;+ bvec->bv\_page = pcl->compressed\_bvecs[nr].page = page;+ folio = page\_folio(page); spin\_unlock(&pcl->obj.lockref.lock); out\_tocache: if (!tocache || bs != PAGE\_SIZE ||- filemap\_add\_folio(mc, folio, pcl->obj.index + nr, gfp))+ filemap\_add\_folio(mc, folio, pcl->obj.index + nr, gfp)) {+ /\* turn into a temporary shortlived folio (1 ref) \*/+ folio->private = (void \*)Z\_EROFS\_SHORTLIVED\_PAGE; return;+ } folio\_attach\_private(folio, pcl); /\* drop a refcount added by allocpage (then 2 refs in total here) \*/ folio\_put(folio);@@ -1647,13 +1650,10 @@ static void z\_erofs\_submit\_queue(struct z\_erofs\_decompress\_frontend \*f, cur = mdev.m\_pa; end = cur + pcl->pclustersize; do {- z\_erofs\_fill\_bio\_vec(&bvec, f, pcl, i++, mc);- if (!bvec.bv\_page)- continue;-+ bvec.bv\_page = NULL; if (bio && (cur != last\_pa || bio->bi\_bdev != mdev.m\_bdev)) {-io\_retry:+drain\_io: if (!erofs\_is\_fscache\_mode(sb)) submit\_bio(bio); else@@ -1666,6 +1666,15 @@ io\_retry: bio = NULL; } + if (!bvec.bv\_page) {+ z\_erofs\_fill\_bio\_vec(&bvec, f, pcl, i++, mc);+ if (!bvec.bv\_page)+ continue;+ if (cur + bvec.bv\_len > end)+ bvec.bv\_len = end - cur;+ DBG\_BUGON(bvec.bv\_len < sb->s\_blocksize);+ }+ if (unlikely(PageWorkingset(bvec.bv\_page)) && !memstall) { psi\_memstall\_enter(&pflags);@@ -1685,13 +1694,9 @@ io\_retry: ++nr\_bios; } - if (cur + bvec.bv\_len > end)- bvec.bv\_len = end - cur;- DBG\_BUGON(bvec.bv\_len < sb->s\_blocksize); if (!bio\_add\_page(bio, bvec.bv\_page, bvec.bv\_len, bvec.bv\_offset))- goto io\_retry;-+ goto drain\_io; last\_pa = cur + bvec.bv\_len; bypass = false; } while ((cur += bvec.bv\_len) < end); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 19:29:10 +0000

