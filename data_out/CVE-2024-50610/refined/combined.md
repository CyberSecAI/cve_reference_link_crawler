=== Content from git.savannah.gnu.org_deb0833b_20250110_230656.html ===


| [cgit logo](/cgit/) | [index](/cgit/) : [gsl.git](/cgit/gsl.git/ "gsl.git") | hermite maint-1 master movstat |
| --- | --- | --- |
| GNU Scientific Library |  |

| [summary](/cgit/gsl.git/)[refs](/cgit/gsl.git/refs/)[log](/cgit/gsl.git/log/siman/siman.c)[tree](/cgit/gsl.git/tree/siman/siman.c)[commit](/cgit/gsl.git/commit/siman/siman.c)[diff](/cgit/gsl.git/diff/siman/siman.c) | log msg author committer range |
| --- | --- |

path: [root](/cgit/gsl.git/log/)/[siman](/cgit/gsl.git/log/siman)/[siman.c](/cgit/gsl.git/log/siman/siman.c)

| Age | Commit message ([Expand](/cgit/gsl.git/log/siman/siman.c?showmsg=1)) | Author | Files | Lines |
| --- | --- | --- | --- | --- |
| 2007-09-10 | [updated copyright years](/cgit/gsl.git/commit/siman/siman.c?id=0801fc8e4229ef08fd0a846ee8c58c0fae73ae58) | bjg | 1 | -0/+1 |
| 2007-07-02 | [updated to gpl v3](/cgit/gsl.git/commit/siman/siman.c?id=d8ac9ab213b57f6aa6665217dbf6f421cf28f202) | bjg | 1 | -1/+1 |
| 2007-05-30 | [cleanup of siman code](/cgit/gsl.git/commit/siman/siman.c?id=2af6e591b6575d693e28489cdf25b50a57a0f41d) | bjg | 1 | -43/+49 |
| 2005-11-15 | [avoid underflow in exp for large uphill steps](/cgit/gsl.git/commit/siman/siman.c?id=8b0da718dca3ca19e0a1881bfd9eae89f02a5aaf) | bjg | 1 | -3/+10 |
| 2005-06-26 | [updated FSF address in copyright notices](/cgit/gsl.git/commit/siman/siman.c?id=a97359eb53027340b69309864df87d9e587e09f0) | bjg | 1 | -1/+1 |
| 2003-07-26 | [detabification](/cgit/gsl.git/commit/siman/siman.c?id=0cc9c2c196e3f0f4feb697c7034284194ab3f8ff) | bjg | 1 | -64/+64 |
| 2003-03-31 | [patch to fix gsl\_siman\_solve to use iters\_fixed\_T instead of n\_tries](/cgit/gsl.git/commit/siman/siman.c?id=23c8cdec7f3b1961649ebae181873d6c34d4e0f0) | bjg | 1 | -5/+5 |
| 2002-08-03 | [made acceptance criterion match documentation](/cgit/gsl.git/commit/siman/siman.c?id=bd34d5476cd99767ad2b95fac94fb4fc52982820) | bjg | 1 | -2/+1 |
| 2002-06-14 | [keep track of best value so far](/cgit/gsl.git/commit/siman/siman.c?id=3c1ab43050d5e02b92f52687f6e2c023937bf7ab) | bjg | 1 | -4/+22 |
| 2002-02-07 | [2002-02-07 Mark Galassi <rosalia@galassi.org>](/cgit/gsl.git/commit/siman/siman.c?id=df7ab84865a53e758f3feb03172a90b38994f586) | rosalia | 1 | -2/+2 |
| 2001-07-12 | [changed renamed gsl\_Efunc\_t to gsl\_siman\_Efunc\_t, in accordance with](/cgit/gsl.git/commit/siman/siman.c?id=d19094c28dea5b56326fdcd6c27c9bea8c308595) | bjg | 1 | -2/+2 |
| 2000-12-15 | [2000-12-15 Mark Galassi <rosalia@galassi.org>](/cgit/gsl.git/commit/siman/siman.c?id=7f1febf20bdb3819aabbb70919d8b82def95ce74) | rosalia | 1 | -3/+2 |
| 2000-12-15 | [2000-12-15 Mark Galassi <rosalia@galassi.org>](/cgit/gsl.git/commit/siman/siman.c?id=8ffc5454f17a26377f9f4ce3395f1997ce84f654) | rosalia | 1 | -11/+50 |
| 2000-05-04 | [added gpl headers](/cgit/gsl.git/commit/siman/siman.c?id=099d16712ca2e650d7942c3b7caa9bb935610089) | bjg | 1 | -0/+19 |
| 2000-02-17 | [added gsl/ and fixed build to use it](/cgit/gsl.git/commit/siman/siman.c?id=0f7a74ed1e2c7c07ff5a85820d27f9ec979e1925) | jungman | 1 | -2/+2 |
| 1999-02-14 | [1999-02-14 Mark Galassi <rosalia@cygnus.com>](/cgit/gsl.git/commit/siman/siman.c?id=34b03abdf2d4ae3d853a4558a5bb4d5f1464e39e) | rosalia | 1 | -59/+50 |
| 1998-11-18 | [added #include <config.h> to all top-level source files](/cgit/gsl.git/commit/siman/siman.c?id=5109366bf14927a90b65d311567372b7df184905) | bjg | 1 | -0/+1 |
| 1998-10-28 | [added string.h header for memcpy](/cgit/gsl.git/commit/siman/siman.c?id=6e35f61629748b5b90aad6acc4693752cbb788a9) | bjg | 1 | -0/+1 |
| 1998-08-20 | [use (char \*) judiciously to avoid warnings about void pointer](/cgit/gsl.git/commit/siman/siman.c?id=ee04e2382578b23aec654357e4b7995ede5f2d29) | bjg | 1 | -5/+7 |
| 1998-06-28 | [Converted to work with rng-style random number generators](/cgit/gsl.git/commit/siman/siman.c?id=31c82c66f1e88a65d1d2c100c477276100c58f7d) | bjg | 1 | -8/+8 |
| 1998-06-21 | [minor cleanup and reformatting](/cgit/gsl.git/commit/siman/siman.c?id=dfa9328624f29d4465c28e8973a98e7ce7c5ceab) | bjg | 1 | -133/+143 |
| 1998-06-19 | [renamed the variable "throw" so we can compile with c++](/cgit/gsl.git/commit/siman/siman.c?id=9ffb94924e652a342bc00c1f47ed29f819b70ea5) | bjg | 1 | -3/+3 |
| 1998-05-23 | [made the solving functions deterministic by removing the random seed,](/cgit/gsl.git/commit/siman/siman.c?id=c631c7eec22ba3f61e934e92e6fa92ddff80e741) | bjg | 1 | -6/+0 |
| 1997-08-16 | [minor fixes and cleanups to "make check"](/cgit/gsl.git/commit/siman/siman.c?id=2f920ec6d601aea9be6b152fb35039d42302b91a) | bjg | 1 | -0/+1 |
| 1997-02-28 | [added the travelling salesman problem and documented it](/cgit/gsl.git/commit/siman/siman.c?id=ffc0f4298cd14398aab94026b1c2972bbc7c019b) | rosalia | 1 | -1/+5 |
| 1997-02-27 | [playing around with initial conditions on siman\_test](/cgit/gsl.git/commit/siman/siman.c?id=ba783af997818027233a555b3cbb63e0acd049a0) | rosalia | 1 | -7/+32 |
| 1997-02-24 | [new work on siman](/cgit/gsl.git/commit/siman/siman.c?id=37573234ad837193cc72075999f4cbf7add20457) | rosalia | 1 | -1/+52 |
| 1997-02-20 | [little work on .eps doc files](/cgit/gsl.git/commit/siman/siman.c?id=8b04deb9804efcf929e042159d4e81b5f2c1d033) | rosalia | 1 | -77/+1 |
| 1997-02-14 | [redid the simulated annealing package and started writing the docs](/cgit/gsl.git/commit/siman/siman.c?id=48e991504d79bee73d0959dd5f2737f38f32fbc2) | rosalia | 1 | -8/+102 |
| 1997-02-14 | [added siman library](/cgit/gsl.git/commit/siman/siman.c?id=ca1a319c7245eecab61141786d89976e95785b04) | rosalia | 1 | -0/+87 |

generated by [cgit v1.1](https://git.zx2c4.com/cgit/about/) at 2025-01-10 23:06:56 +0000



=== Content from github.com_d16e38f6_20250110_230657.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fsilviadefra%2FGolDRuSh%2Fblob%2Fmain%2Fvulnerabilities%2Fgsl.md)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fsilviadefra%2FGolDRuSh%2Fblob%2Fmain%2Fvulnerabilities%2Fgsl.md)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=silviadefra%2FGolDRuSh)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[silviadefra](/silviadefra)
/
**[GolDRuSh](/silviadefra/GolDRuSh)**
Public

* [Notifications](/login?return_to=%2Fsilviadefra%2FGolDRuSh) You must be signed in to change notification settings
* [Fork
  0](/login?return_to=%2Fsilviadefra%2FGolDRuSh)
* [Star
   0](/login?return_to=%2Fsilviadefra%2FGolDRuSh)

* [Code](/silviadefra/GolDRuSh)
* [Issues
  0](/silviadefra/GolDRuSh/issues)
* [Pull requests
  0](/silviadefra/GolDRuSh/pulls)
* [Actions](/silviadefra/GolDRuSh/actions)
* [Projects
  0](/silviadefra/GolDRuSh/projects)
* [Security](/silviadefra/GolDRuSh/security)
* [Insights](/silviadefra/GolDRuSh/pulse)

Additional navigation options

* [Code](/silviadefra/GolDRuSh)
* [Issues](/silviadefra/GolDRuSh/issues)
* [Pull requests](/silviadefra/GolDRuSh/pulls)
* [Actions](/silviadefra/GolDRuSh/actions)
* [Projects](/silviadefra/GolDRuSh/projects)
* [Security](/silviadefra/GolDRuSh/security)
* [Insights](/silviadefra/GolDRuSh/pulse)

## Files

 main
## Breadcrumbs

1. [GolDRuSh](/silviadefra/GolDRuSh/tree/main)
2. /[vulnerabilities](/silviadefra/GolDRuSh/tree/main/vulnerabilities)
/
# gsl.md

Copy path Blame  Blame
## Latest commit

## History

[History](/silviadefra/GolDRuSh/commits/main/vulnerabilities/gsl.md)73 lines (65 loc) · 2.36 KB main
## Breadcrumbs

1. [GolDRuSh](/silviadefra/GolDRuSh/tree/main)
2. /[vulnerabilities](/silviadefra/GolDRuSh/tree/main/vulnerabilities)
/
# gsl.md

Top
## File metadata and controls

* Preview
* Code
* Blame

73 lines (65 loc) · 2.36 KB[Raw](https://github.com/silviadefra/GolDRuSh/raw/refs/heads/main/vulnerabilities/gsl.md)
### Vulnerability Details:

#### Type of vulnerability:

Integer Overflow

#### Location:

function `gsl_siman_solve_many` in file `gsl/siman/siman.c`

#### Description:

The vulnerability occurs when `params.n_tries` is set to a negative integer, which leads to incorrect memory allocation in the following lines of code:

```
 x = (void *) malloc (params.n_tries * element_size);
 new_x = (void *) malloc (params.n_tries * element_size);
 energies = (double *) malloc (params.n_tries * sizeof (double));
 probs = (double *) malloc (params.n_tries * sizeof (double));
 sum_probs = (double *) malloc (params.n_tries * sizeof (double));
 …
 memcpy (x, x0_p, element_size);

```

### Steps to Reproduce:

Here is a minimal code example that demonstrates the vulnerability:

```
   #include <gsl/gsl_siman.h>
   #include <gsl/gsl_rng.h>
   #include <gsl/gsl_vector.h>
   double objective_function(void *xp) {
       return 0.0;
   }
   void take_step(const gsl_rng *r, void *xp, double step_size) {
   }

   int main(void) {
       gsl_rng *r;
       gsl_rng_env_setup();
       r = gsl_rng_alloc(gsl_rng_default);
       // Initialize GSL Simulated Annealing parameters
       gsl_siman_params_t p;
       p.n_tries = -1;// Integer overflow vulnerability: invalid number of trials
       gsl_vector *x0 = gsl_vector_alloc(1);
       // Call the simulated annealing solver (this is the key call for the vulnerability)
       gsl_siman_solve_many(r, x0, objective_function, take_step, NULL, NULL, sizeof(gsl_vector), p);
       return 0;
   }

```

To compile and run the above code:

```
   $ gcc test.c -o test -lgsl
   $ catchsegv ./test
   Segmentation fault (core dumped)
   *** signal 11
   Register dump:
   RAX: 0000000000000000   RBX: fffffffffffffff8  …
   Trap: 0000000e   Error: 00000006   OldMask: 00000000   CR2: 00000000
   …
   Backtrace:
   /lib/x86_64-linux-gnu/libc.so.6(+0x1a07e1)[0x752cfd3a07e1]
   /lib/x86_64-linux-gnu/libgsl.so.27(gsl_siman_solve_many+0x10d)[0x752cfd749aed]
   ./test(+0x125b)[0x5d80a762525b]
   /lib/x86_64-linux-gnu/libc.so.6(+0x29d90)[0x752cfd229d90]
   /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0x80)[0x752cfd229e40]
   ./test(+0x10e5)[0x5d80a76250e5]

```

### Suggested Fix:

This issue could be mitigated by adding a sign check before allocating memory. For example:

```
   if (0 <= params.n_tries) {
   x = (void *) malloc (params.n_tries * element_size);
}

```

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from www.gnu.org_0d0ec9b1_20250110_230657.html ===

 [GSL](index.html)
2.8

* [Introduction](intro.html)
* [Using the Library](usage.html)
* [Error Handling](err.html)
* [Mathematical Functions](math.html)
* [Complex Numbers](complex.html)
* [Polynomials](poly.html)
* [Special Functions](specfunc.html)
* [Vectors and Matrices](vectors.html)
* [Permutations](permutation.html)
* [Combinations](combination.html)
* [Multisets](multiset.html)
* [Sorting](sort.html)
* [BLAS Support](blas.html)
* [Linear Algebra](linalg.html)
* [Eigensystems](eigen.html)
* [Fast Fourier Transforms (FFTs)](fft.html)
* [Numerical Integration](integration.html)
* [Random Number Generation](rng.html)
* [Quasi-Random Sequences](qrng.html)
* [Random Number Distributions](randist.html)
* [Statistics](statistics.html)
* [Running Statistics](rstat.html)
* [Moving Window Statistics](movstat.html)
* [Digital Filtering](filter.html)
* [Histograms](histogram.html)
* [N-tuples](ntuple.html)
* [Monte Carlo Integration](montecarlo.html)
* Simulated Annealing
  + [Simulated Annealing algorithm](#simulated-annealing-algorithm)
  + [Simulated Annealing functions](#simulated-annealing-functions)
  + [Examples](#examples)
    - [Trivial example](#trivial-example)
    - [Traveling Salesman Problem](#traveling-salesman-problem)
  + [References and Further Reading](#references-and-further-reading)
* [Ordinary Differential Equations](ode-initval.html)
* [Interpolation](interp.html)
* [Numerical Differentiation](diff.html)
* [Chebyshev Approximations](cheb.html)
* [Series Acceleration](sum.html)
* [Wavelet Transforms](dwt.html)
* [Discrete Hankel Transforms](dht.html)
* [One Dimensional Root-Finding](roots.html)
* [One Dimensional Minimization](min.html)
* [Multidimensional Root-Finding](multiroots.html)
* [Multidimensional Minimization](multimin.html)
* [Linear Least-Squares Fitting](lls.html)
* [Nonlinear Least-Squares Fitting](nls.html)
* [Basis Splines](bspline.html)
* [Sparse Matrices](spmatrix.html)
* [Sparse BLAS Support](spblas.html)
* [Sparse Linear Algebra](splinalg.html)
* [Physical Constants](const.html)
* [IEEE floating-point arithmetic](ieee754.html)
* [Debugging Numerical Programs](debug.html)
* [Contributors to GSL](contrib.html)
* [Autoconf Macros](autoconf.html)
* [GSL CBLAS Library](cblas.html)
* [GNU General Public License](gpl.html)
* [GNU Free Documentation License](fdl.html)

[GSL](index.html)

* »
* Simulated Annealing
* [View page source](_sources/siman.rst.txt)

[Next](ode-initval.html "Ordinary Differential Equations")
 [Previous](montecarlo.html "Monte Carlo Integration")

---

# Simulated Annealing[Â¶](#simulated-annealing "Permalink to this heading")

Stochastic search techniques are used when the structure of a space is
not well understood or is not smooth, so that techniques like Newtonâs
method (which requires calculating Jacobian derivative matrices) cannot
be used. In particular, these techniques are frequently used to solve
combinatorial optimization problems, such as the traveling salesman
problem.

The goal is to find a point in the space at which a real valued
*energy function* (or *cost function*) is minimized. Simulated
annealing is a minimization technique which has given good results in
avoiding local minima; it is based on the idea of taking a random walk
through the space at successively lower temperatures, where the
probability of taking a step is given by a Boltzmann distribution.

The functions described in this chapter are declared in the header file
`gsl_siman.h`.

## Simulated Annealing algorithm[Â¶](#simulated-annealing-algorithm "Permalink to this heading")

The simulated annealing algorithm takes random walks through the problem
space, looking for points with low energies; in these random walks, the
probability of taking a step is determined by the Boltzmann distribution,

![p = e^{-(E_{i+1} - E_i)/(kT)}](_images/math/ef502f4b90866c8396c7817be2612c74166848a5.png)

if
![E_{i+1} > E_i](_images/math/5e495f47cd7eff24e4edbb26905d64771009897a.png), and
![p = 1](_images/math/5710ce0ba2ecca538290ee04e400fc844d26d0a1.png) when
![E_{i+1} \le E_i](_images/math/40ab244a1a327ce771a3b9d48f826a3c9c528aba.png).

In other words, a step will occur if the new energy is lower. If
the new energy is higher, the transition can still occur, and its
likelihood is proportional to the temperature ![T](_images/math/da008f30aec40b729feeb13989fbe54555b2bba0.png) and inversely
proportional to the energy difference
![E_{i+1} - E_i](_images/math/a1d07b3d4dc218952a8495b682f774c616ecfe23.png).

The temperature ![T](_images/math/da008f30aec40b729feeb13989fbe54555b2bba0.png) is initially set to a high value, and a random
walk is carried out at that temperature. Then the temperature is
lowered very slightly according to a *cooling schedule*, for
example: ![T \rightarrow T/\mu_T](_images/math/2d5b083c7012dae63dd2a5947cc34f98243af9f4.png)
where ![\mu_T](_images/math/3b5f09916141c25d27eb415528021fdb24c5acdf.png) is slightly greater than 1.

The slight probability of taking a step that gives higher energy is what
allows simulated annealing to frequently get out of local minima.

## Simulated Annealing functions[Â¶](#simulated-annealing-functions "Permalink to this heading")

void gsl\_siman\_solve(const [gsl\_rng](rng.html#c.gsl_rng "gsl_rng") \*r, void \*x0\_p, [gsl\_siman\_Efunc\_t](#c.gsl_siman_Efunc_t "gsl_siman_Efunc_t") Ef, [gsl\_siman\_step\_t](#c.gsl_siman_step_t "gsl_siman_step_t") take\_step, [gsl\_siman\_metric\_t](#c.gsl_siman_metric_t "gsl_siman_metric_t") distance, [gsl\_siman\_print\_t](#c.gsl_siman_print_t "gsl_siman_print_t") print\_position, [gsl\_siman\_copy\_t](#c.gsl_siman_copy_t "gsl_siman_copy_t") copyfunc, [gsl\_siman\_copy\_construct\_t](#c.gsl_siman_copy_construct_t "gsl_siman_copy_construct_t") copy\_constructor, [gsl\_siman\_destroy\_t](#c.gsl_siman_destroy_t "gsl_siman_destroy_t") destructor, size\_t element\_size, [gsl\_siman\_params\_t](#c.gsl_siman_params_t "gsl_siman_params_t") params)[Â¶](#c.gsl_siman_solve "Permalink to this definition")

This function performs a simulated annealing search through a given
space. The space is specified by providing the functions [`Ef`](#c.gsl_siman_solve "Ef") and
[`distance`](#c.gsl_siman_solve "distance"). The simulated annealing steps are generated using the
random number generator [`r`](#c.gsl_siman_solve "r") and the function [`take_step`](#c.gsl_siman_solve "take_step").

The starting configuration of the system should be given by [`x0_p`](#c.gsl_siman_solve "x0_p").
The routine offers two modes for updating configurations, a fixed-size
mode and a variable-size mode. In the fixed-size mode the configuration
is stored as a single block of memory of size [`element_size`](#c.gsl_siman_solve "element_size").
Copies of this configuration are created, copied and destroyed
internally using the standard library functions `malloc()`,
`memcpy()` and `free()`. The function pointers [`copyfunc`](#c.gsl_siman_solve "copyfunc"),
[`copy_constructor`](#c.gsl_siman_solve "copy_constructor") and [`destructor`](#c.gsl_siman_solve "destructor") should be null pointers in
fixed-size mode. In the variable-size mode the functions
[`copyfunc`](#c.gsl_siman_solve "copyfunc"), [`copy_constructor`](#c.gsl_siman_solve "copy_constructor") and [`destructor`](#c.gsl_siman_solve "destructor") are used to
create, copy and destroy configurations internally. The variable
[`element_size`](#c.gsl_siman_solve "element_size") should be zero in the variable-size mode.

The [`params`](#c.gsl_siman_solve "params") structure (described below) controls the run by
providing the temperature schedule and other tunable parameters to the
algorithm.

On exit the best result achieved during the search is placed in
[`x0_p`](#c.gsl_siman_solve "x0_p"). If the annealing process has been successful this
should be a good approximation to the optimal point in the space.

If the function pointer [`print_position`](#c.gsl_siman_solve "print_position") is not null, a debugging
log will be printed to `stdout` with the following columns:

```
#-iter  #-evals  temperature  position  energy  best_energy

```

and the output of the function [`print_position`](#c.gsl_siman_solve "print_position") itself. If
[`print_position`](#c.gsl_siman_solve "print_position") is null then no information is printed.

The simulated annealing routines require several user-specified
functions to define the configuration space and energy function. The
prototypes for these functions are given below.

type gsl\_siman\_Efunc\_t[Â¶](#c.gsl_siman_Efunc_t "Permalink to this definition")

This function type should return the energy of a configuration `xp`:

```
double (*gsl_siman_Efunc_t) (void *xp)

```

type gsl\_siman\_step\_t[Â¶](#c.gsl_siman_step_t "Permalink to this definition")

This function type should modify the configuration `xp` using a random step
taken from the generator `r`, up to a maximum distance of
`step_size`:

```
void (*gsl_siman_step_t) (const gsl_rng *r, void *xp,
                          double step_size)

```

type gsl\_siman\_metric\_t[Â¶](#c.gsl_siman_metric_t "Permalink to this definition")

This function type should return the distance between two configurations
`xp` and `yp`:

```
double (*gsl_siman_metric_t) (void *xp, void *yp)

```

type gsl\_siman\_print\_t[Â¶](#c.gsl_siman_print_t "Permalink to this definition")

This function type should print the contents of the configuration `xp`:

```
void (*gsl_siman_print_t) (void *xp)

```

type gsl\_siman\_copy\_t[Â¶](#c.gsl_siman_copy_t "Permalink to this definition")

This function type should copy the configuration `source` into `dest`:

```
void (*gsl_siman_copy_t) (void *source, void *dest)

```

type gsl\_siman\_copy\_construct\_t[Â¶](#c.gsl_siman_copy_construct_t "Permalink to this definition")

This function type should create a new copy of the configuration `xp`:

```
void * (*gsl_siman_copy_construct_t) (void *xp)

```

type gsl\_siman\_destroy\_t[Â¶](#c.gsl_siman_destroy_t "Permalink to this definition")

This function type should destroy the configuration `xp`, freeing its
memory:

```
void (*gsl_siman_destroy_t) (void *xp)

```

type gsl\_siman\_params\_t[Â¶](#c.gsl_siman_params_t "Permalink to this definition")

These are the parameters that control a run of [`gsl_siman_solve()`](#c.gsl_siman_solve "gsl_siman_solve").
This structure contains all the information needed to control the
search, beyond the energy function, the step function and the initial
guess.

| `int n_tries` | The number of points to try for each step. |
| --- | --- |
| `int iters_fixed_T` | The number of iterations at each temperature. |
| `double step_size` | The maximum step size in the random walk. |
| `double k, t_initial, mu_t, t_min` | The parameters of the Boltzmann distribution and cooling schedule. |

## Examples[Â¶](#examples "Permalink to this heading")

The simulated annealing package is clumsy, and it has to be because it
is written in C, for C callers, and tries to be polymorphic at the same
time. But here we provide some examples which can be pasted into your
application with little change and should make things easier.

### Trivial example[Â¶](#trivial-example "Permalink to this heading")

The first example, in one dimensional Cartesian space, sets up an energy
function which is a damped sine wave; this has many local minima, but
only one global minimum, somewhere between 1.0 and 1.5. The initial
guess given is 15.5, which is several local minima away from the global
minimum.

```
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <gsl/gsl_siman.h>

/* set up parameters for this simulated annealing run */

/* how many points do we try before stepping */
#define N_TRIES 200

/* how many iterations for each T? */
#define ITERS_FIXED_T 1000

/* max step size in random walk */
#define STEP_SIZE 1.0

/* Boltzmann constant */
#define K 1.0

/* initial temperature */
#define T_INITIAL 0.008

/* damping factor for temperature */
#define MU_T 1.003
#define T_MIN 2.0e-6

gsl_siman_params_t params
  = {N_TRIES, ITERS_FIXED_T, STEP_SIZE,
     K, T_INITIAL, MU_T, T_MIN};

/* now some functions to test in one dimension */
double E1(void *xp)
{
  double x = * ((double *) xp);

  return exp(-pow((x-1.0),2.0))*sin(8*x);
}

double M1(void *xp, void *yp)
{
  double x = *((double *) xp);
  double y = *((double *) yp);

  return fabs(x - y);
}

void S1(const gsl_rng * r, void *xp, double step_size)
{
  double old_x = *((double *) xp);
  double new_x;

  double u = gsl_rng_uniform(r);
  new_x = u * 2 * step_size - step_size + old_x;

  memcpy(xp, &new_x, sizeof(new_x));
}

void P1(void *xp)
{
  printf ("%12g", *((double *) xp));
}

int
main(void)
{
  const gsl_rng_type * T;
  gsl_rng * r;

  double x_initial = 15.5;

  gsl_rng_env_setup();

  T = gsl_rng_default;
  r = gsl_rng_alloc(T);

  gsl_siman_solve(r, &x_initial, E1, S1, M1, P1,
                  NULL, NULL, NULL,
                  sizeof(double), params);

  gsl_rng_free (r);
  return 0;
}

```

[Fig. 16](#fig-siman-test) is generated by running
`siman_test` in the following way:

```
$ ./siman_test | awk '!/^#/ {print $1, $4}'
 | graph -y 1.34 1.4 -W0 -X generation -Y position
 | plot -Tps > siman-test.eps

```

[Fig. 17](#fig-siman-energy) is generated by running
`siman_test` in the following way:

```
$ ./siman_test | awk '!/^#/ {print $1, $5}'
 | graph -y -0.88 -0.83 -W0 -X generation -Y energy
 | plot -Tps > siman-energy.eps

```

[![_images/siman-test.png](_images/siman-test.png)](_images/siman-test.png)

Fig. 16 Example of a simulated annealing run: at higher temperatures (early in
the plot) you see that the solution can fluctuate, but at lower
temperatures it converges.[Â¶](#id1 "Permalink to this image")

[![_images/siman-energy.png](_images/siman-energy.png)](_images/siman-energy.png)

Fig. 17 Simulated annealing energy vs generation[Â¶](#id2 "Permalink to this image")

### Traveling Salesman Problem[Â¶](#traveling-salesman-problem "Permalink to this heading")

The TSP (*Traveling Salesman Problem*) is the classic combinatorial
optimization problem. I have provided a very simple version of it,
based on the coordinates of twelve cities in the southwestern United
States. This should maybe be called the *Flying Salesman Problem*,
since I am using the great-circle distance between cities, rather than
the driving distance. Also: I assume the earth is a sphere, so I donât
use geoid distances.

The [`gsl_siman_solve()`](#c.gsl_siman_solve "gsl_siman_solve") routine finds a route which is 3490.62
Kilometers long; this is confirmed by an exhaustive search of all
possible routes with the same initial city.

The full code is given below.

```
/* siman/siman_tsp.c
 *
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Mark Galassi
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

#include <config.h>
#include <math.h>
#include <string.h>
#include <stdio.h>
#include <gsl/gsl_math.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_siman.h>
#include <gsl/gsl_ieee_utils.h>

/* set up parameters for this simulated annealing run */

#define N_TRIES 200             /* how many points do we try before stepping */
#define ITERS_FIXED_T 2000      /* how many iterations for each T? */
#define STEP_SIZE 1.0           /* max step size in random walk */
#define K 1.0                   /* Boltzmann constant */
#define T_INITIAL 5000.0        /* initial temperature */
#define MU_T 1.002              /* damping factor for temperature */
#define T_MIN 5.0e-1

gsl_siman_params_t params = {N_TRIES, ITERS_FIXED_T, STEP_SIZE,
                             K, T_INITIAL, MU_T, T_MIN};

struct s_tsp_city {
  const char * name;
  double lat, longitude;        /* coordinates */
};
typedef struct s_tsp_city Stsp_city;

void prepare_distance_matrix(void);
void exhaustive_search(void);
void print_distance_matrix(void);
double city_distance(Stsp_city c1, Stsp_city c2);
double Etsp(void *xp);
double Mtsp(void *xp, void *yp);
void Stsp(const gsl_rng * r, void *xp, double step_size);
void Ptsp(void *xp);

/* in this table, latitude and longitude are obtained from the US
   Census Bureau, at http://www.census.gov/cgi-bin/gazetteer */

Stsp_city cities[] = {{"Santa Fe",    35.68,   105.95},
                      {"Phoenix",     33.54,   112.07},
                      {"Albuquerque", 35.12,   106.62},
                      {"Clovis",      34.41,   103.20},
                      {"Durango",     37.29,   107.87},
                      {"Dallas",      32.79,    96.77},
                      {"Tesuque",     35.77,   105.92},
                      {"Grants",      35.15,   107.84},
                      {"Los Alamos",  35.89,   106.28},
                      {"Las Cruces",  32.34,   106.76},
                      {"Cortez",      37.35,   108.58},
                      {"Gallup",      35.52,   108.74}};

#define N_CITIES (sizeof(cities)/sizeof(Stsp_city))

double distance_matrix[N_CITIES][N_CITIES];

/* distance between two cities */
double city_distance(Stsp_city c1, Stsp_city c2)
{
  const double earth_radius = 6375.000; /* 6000KM approximately */
  /* sin and cos of lat and long; must convert to radians */
  double sla1 = sin(c1.lat*M_PI/180), cla1 = cos(c1.lat*M_PI/180),
    slo1 = sin(c1.longitude*M_PI/180), clo1 = cos(c1.longitude*M_PI/180);
  double sla2 = sin(c2.lat*M_PI/180), cla2 = cos(c2.lat*M_PI/180),
    slo2 = sin(c2.longitude*M_PI/180), clo2 = cos(c2.longitude*M_PI/180);

  double x1 = cla1*clo1;
  double x2 = cla2*clo2;

  double y1 = cla1*slo1;
  double y2 = cla2*slo2;

  double z1 = sla1;
  double z2 = sla2;

  double dot_product = x1*x2 + y1*y2 + z1*z2;

  double angle = acos(dot_product);

  /* distance is the angle (in radians) times the earth radius */
  return angle*earth_radius;
}

/* energy for the travelling salesman problem */
double Etsp(void *xp)
{
  /* an array of N_CITIES integers describing the order */
  int *route = (int *) xp;
  double E = 0;
  unsigned int i;

  for (i = 0; i < N_CITIES; ++i) {
    /* use the distance_matrix to optimize this calculation; it had
       better be allocated!! */
    E += distance_matrix[route[i]][route[(i + 1) % N_CITIES]];
  }

  return E;
}

double Mtsp(void *xp, void *yp)
{
  int *route1 = (int *) xp, *route2 = (int *) yp;
  double distance = 0;
  unsigned int i;

  for (i = 0; i < N_CITIES; ++i) {
    distance += ((route1[i] == route2[i]) ? 0 : 1);
  }

  return distance;
}

/* take a step through the TSP space */
void Stsp(const gsl_rng * r, void *xp, double step_size)
{
  int x1, x2, dummy;
  int *route = (int *) xp;

  step_size = 0 ; /* prevent warnings about unused parameter */

  /* pick the two cities to swap in the matrix; we leave the first
     city fixed */
  x1 = (gsl_rng_get (r) % (N_CITIES-1)) + 1;
  do {
    x2 = (gsl_rng_get (r) % (N_CITIES-1)) + 1;
  } while (x2 == x1);

  dummy = route[x1];
  route[x1] = route[x2];
  route[x2] = dummy;
}

void Ptsp(void *xp)
{
  unsigned int i;
  int *route = (int *) xp;
  printf("  [");
  for (i = 0; i < N_CITIES; ++i) {
    printf(" %d ", route[i]);
  }
  printf("]  ");
}

int main(void)
{
  int x_initial[N_CITIES];
  unsigned int i;

  const gsl_rng * r = gsl_rng_alloc (gsl_rng_env_setup()) ;

  gsl_ieee_env_setup ();

  prepare_distance_matrix();

  /* set up a trivial initial route */
  printf("# initial order of cities:\n");
  for (i = 0; i < N_CITIES; ++i) {
    printf("# \"%s\"\n", cities[i].name);
    x_initial[i] = i;
  }

  printf("# distance matrix is:\n");
  print_distance_matrix();

  printf("# initial coordinates of cities (longitude and latitude)\n");
  /* this can be plotted with */
  /* ./siman_tsp > hhh ; grep city_coord hhh | awk '{print $2 "   " $3}' | xyplot -ps -d "xy" > c.eps */
  for (i = 0; i < N_CITIES+1; ++i) {
    printf("###initial_city_coord: %g %g \"%s\"\n",
           -cities[x_initial[i % N_CITIES]].longitude,
           cities[x_initial[i % N_CITIES]].lat,
           cities[x_initial[i % N_CITIES]].name);
  }

/*   exhaustive_search(); */

  gsl_siman_solve(r, x_initial, Etsp, Stsp, Mtsp, Ptsp, NULL, NULL, NULL,
                  N_CITIES*sizeof(int), params);

  printf("# final order of cities:\n");
  for (i = 0; i < N_CITIES; ++i) {
    printf("# \"%s\"\n", cities[x_initial[i]].name);
  }

  printf("# final coordinates of cities (longitude and latitude)\n");
  /* this can be plotted with */
  /* ./siman_tsp > hhh ; grep city_coord hhh | awk '{print $2 "   " $3}' | xyplot -ps -d "xy" > c.eps */
  for (i = 0; i < N_CITIES+1; ++i) {
    printf("###final_city_coord: %g %g %s\n",
           -cities[x_initial[i % N_CITIES]].longitude,
           cities[x_initial[i % N_CITIES]].lat,
           cities[x_initial[i % N_CITIES]].name);
  }

  printf("# ");
  fflush(stdout);
#if 0
  system("date");
#endif /* 0 */
  fflush(stdout);

  return 0;
}

void prepare_distance_matrix()
{
  unsigned int i, j;
  double dist;

  for (i = 0; i < N_CITIES; ++i) {
    for (j = 0; j < N_CITIES; ++j) {
      if (i == j) {
        dist = 0;
      } else {
        dist = city_distance(cities[i], cities[j]);
      }
      distance_matrix[i][j] = dist;
    }
  }
}

void print_distance_matrix()
{
  unsigned int i, j;

  for (i = 0; i < N_CITIES; ++i) {
    printf("# ");
    for (j = 0; j < N_CITIES; ++j) {
      printf("%15.8f   ", distance_matrix[i][j]);
    }
    printf("\n");
  }
}

/* [only works for 12] search the entire space for solutions */
static double best_E = 1.0e100, second_E = 1.0e100, third_E = 1.0e100;
static int best_route[N_CITIES];
static int second_route[N_CITIES];
static int third_route[N_CITIES];
static void do_all_perms(int *route, int n);

void exhaustive_search()
{
  static int initial_route[N_CITIES] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
  printf("\n# ");
  fflush(stdout);
#if 0
  system("date");
#endif
  fflush(stdout);
  do_all_perms(initial_route, 1);
  printf("\n# ");
  fflush(stdout);
#if 0
  system("date");
#endif /* 0 */
  fflush(stdout);

  printf("# exhaustive best route: ");
  Ptsp(best_route);
  printf("\n# its energy is: %g\n", best_E);

  printf("# exhaustive second_best route: ");
  Ptsp(second_route);
  printf("\n# its energy is: %g\n", second_E);

  printf("# exhaustive third_best route: ");
  Ptsp(third_route);
  printf("\n# its energy is: %g\n", third_E);
}

/* James Theiler's recursive algorithm for generating all routes */
static void do_all_perms(int *route, int n)
{
  if (n == (N_CITIES-1)) {
    /* do it! calculate the energy/cost for that route */
    double E;
    E = Etsp(route);            /* TSP energy function */
    /* now save the best 3 energies and routes */
    if (E < best_E) {
      third_E = second_E;
      memcpy(third_route, second_route, N_CITIES*sizeof(*route));
      second_E = best_E;
      memcpy(second_route, best_route, N_CITIES*sizeof(*route));
      best_E = E;
      memcpy(best_route, route, N_CITIES*sizeof(*route));
    } else if (E < second_E) {
      third_E = second_E;
      memcpy(third_route, second_route, N_CITIES*sizeof(*route));
      second_E = E;
      memcpy(second_route, route, N_CITIES*sizeof(*route));
    } else if (E < third_E) {
      third_E = E;
      memcpy(route, third_route, N_CITIES*sizeof(*route));
    }
  } else {
    int new_route[N_CITIES];
    unsigned int j;
    int swap_tmp;
    memcpy(new_route, route, N_CITIES*sizeof(*route));
    for (j = n; j < N_CITIES; ++j) {
      swap_tmp = new_route[j];
      new_route[j] = new_route[n];
      new_route[n] = swap_tmp;
      do_all_perms(new_route, n+1);
    }
  }
}

```

Below are some plots generated in the following way:

```
$ ./siman_tsp > tsp.output
$ grep -v "^#" tsp.output
 | awk '{print $1, $NF}'
 | graph -y 3300 6500 -W0 -X generation -Y distance
    -L "TSP - 12 southwest cities"
 | plot -Tps > 12-cities.eps
$ grep initial_city_coord tsp.output
  | awk '{print $2, $3}'
  | graph -X "longitude (- means west)" -Y "latitude"
     -L "TSP - initial-order" -f 0.03 -S 1 0.1
  | plot -Tps > initial-route.eps
$ grep final_city_coord tsp.output
  | awk '{print $2, $3}'
  | graph -X "longitude (- means west)" -Y "latitude"
     -L "TSP - final-order" -f 0.03 -S 1 0.1
  | plot -Tps > final-route.eps

```

This is the output showing the initial order of the cities; longitude is
negative, since it is west and I want the plot to look like a map:

```
# initial coordinates of cities (longitude and latitude)
###initial_city_coord: -105.95 35.68 Santa Fe
###initial_city_coord: -112.07 33.54 Phoenix
###initial_city_coord: -106.62 35.12 Albuquerque
###initial_city_coord: -103.2 34.41 Clovis
###initial_city_coord: -107.87 37.29 Durango
###initial_city_coord: -96.77 32.79 Dallas
###initial_city_coord: -105.92 35.77 Tesuque
###initial_city_coord: -107.84 35.15 Grants
###initial_city_coord: -106.28 35.89 Los Alamos
###initial_city_coord: -106.76 32.34 Las Cruces
###initial_city_coord: -108.58 37.35 Cortez
###initial_city_coord: -108.74 35.52 Gallup
###initial_city_coord: -105.95 35.68 Santa Fe

```

The optimal route turns out to be:

```
# final coordinates of cities (longitude and latitude)
###final_city_coord: -105.95 35.68 Santa Fe
###final_city_coord: -103.2 34.41 Clovis
###final_city_coord: -96.77 32.79 Dallas
###final_city_coord: -106.76 32.34 Las Cruces
###final_city_coord: -112.07 33.54 Phoenix
###final_city_coord: -108.74 35.52 Gallup
###final_city_coord: -108.58 37.35 Cortez
###final_city_coord: -107.87 37.29 Durango
###final_city_coord: -107.84 35.15 Grants
###final_city_coord: -106.62 35.12 Albuquerque
###final_city_coord: -106.28 35.89 Los Alamos
###final_city_coord: -105.92 35.77 Tesuque
###final_city_coord: -105.95 35.68 Santa Fe

```

[![_images/siman-initial-route.png](_images/siman-initial-route.png)](_images/siman-initial-route.png)

Fig. 18 Initial route for the 12 southwestern cities Flying Salesman Problem.[Â¶](#id3 "Permalink to this image")

[![_images/siman-final-route.png](_images/siman-final-route.png)](_images/siman-final-route.png)

Fig. 19 Final (optimal) route for the 12 southwestern cities Flying Salesman Problem.[Â¶](#id4 "Permalink to this image")

Hereâs a plot of the cost function (energy) versus generation (point in
the calculation at which a new temperature is set) for this problem:

[![_images/siman-12-cities.png](_images/siman-12-cities.png)](_images/siman-12-cities.png)

Fig. 20 Example of a simulated annealing run for the 12 southwestern cities
Flying Salesman Problem.[Â¶](#id5 "Permalink to this image")

## References and Further Reading[Â¶](#references-and-further-reading "Permalink to this heading")

Further information is available in the following book,

* *Modern Heuristic Techniques for Combinatorial Problems*, Colin R. Reeves
  (ed.), McGraw-Hill, 1995 (ISBN 0-07-709239-2).

[Next](ode-initval.html "Ordinary Differential Equations")
 [Previous](montecarlo.html "Monte Carlo Integration")

---

© Copyright 1996-2024 The GSL Team.

Built with [Sphinx](https://www.sphinx-doc.org/) using a
[theme](https://github.com/readthedocs/sphinx_rtd_theme)
provided by [Read the Docs](https://readthedocs.org).


