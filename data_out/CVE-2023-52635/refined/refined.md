```
{
  "cveId": "CVE-2023-52635",
  "baseScore": "NOINFO",
  "baseSeverity": "NOINFO",
  "attackVector": "Local",
  "attackComplexity": "High",
  "privilegesRequired": "Low",
  "userInteraction": "None",
  "scope": "Unchanged",
  "confidentialityImpact": "High",
  "integrityImpact": "High",
  "availabilityImpact": "High",
  "v3Vector": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
  "cwe": "CWE-362",
  "vulnerabilityDetails": {
    "rootCause": "The root cause is a race condition in the devfreq driver, specifically within the device_monitor_[start/stop] functions. Frequent switching of the governor in a loop can lead to timer list corruption. This is due to `cancel_delayed_work_sync()` being called concurrently with `expire_timers()`, which can cause corruption of the delayed work structure.",
    "weaknesses": [
      "Race Condition",
      "Timer list corruption",
       "Use after free"
    ],
    "impact": "The vulnerability can lead to a kernel panic or system crash due to memory corruption and an attempt to access invalid memory addresses. Specifically, a kernel paging request at a virtual address between user and kernel ranges.  The trace also indicates a memory abort and an internal error with an Oops.",
    "attackVectors": [
      "Frequent switching of the governor using sysfs interface `/sys/class/devfreq/.../governor`"
    ],
    "requiredCapabilities": "An attacker needs the ability to write to the devfreq governor sysfs interface (requires local access with low privileges to control devfreq governors)"
  },
   "affectedProduct": "Linux Kernel",
   "fixedVersions": [
    "Kernel versions including commit aed5ed595960c6d301dcd4ed31aeaa7a8054c0c6, and later backported to several kernel stable branches"
  ],
    "patchDetails": "The patch adds a `stop_polling` flag and a mutex lock (`devfreq->lock`) to synchronize the `devfreq_monitor_start` and `devfreq_monitor_stop` functions. It ensures that the delayed work isn't queued or cancelled multiple times concurrently."
}
```