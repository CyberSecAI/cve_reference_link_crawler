
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fargoproj%2Fargo-cd%2Fblob%2F54601c8fd30b86a4c4b7eb449956264372c8bde0%2Futil%2Fsession%2Fsessionmanager.go)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fargoproj%2Fargo-cd%2Fblob%2F54601c8fd30b86a4c4b7eb449956264372c8bde0%2Futil%2Fsession%2Fsessionmanager.go)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=argoproj%2Fargo-cd)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[argoproj](/argoproj)
/
**[argo-cd](/argoproj/argo-cd)**
Public

* [Notifications](/login?return_to=%2Fargoproj%2Fargo-cd) You must be signed in to change notification settings
* [Fork
  5.6k](/login?return_to=%2Fargoproj%2Fargo-cd)
* [Star
   18.4k](/login?return_to=%2Fargoproj%2Fargo-cd)

* [Code](/argoproj/argo-cd)
* [Issues
  3.1k](/argoproj/argo-cd/issues)
* [Pull requests
  475](/argoproj/argo-cd/pulls)
* [Discussions](/argoproj/argo-cd/discussions)
* [Actions](/argoproj/argo-cd/actions)
* [Projects
  5](/argoproj/argo-cd/projects)
* [Wiki](/argoproj/argo-cd/wiki)
* [Security](/argoproj/argo-cd/security)
* [Insights](/argoproj/argo-cd/pulse)

Additional navigation options

* [Code](/argoproj/argo-cd)
* [Issues](/argoproj/argo-cd/issues)
* [Pull requests](/argoproj/argo-cd/pulls)
* [Discussions](/argoproj/argo-cd/discussions)
* [Actions](/argoproj/argo-cd/actions)
* [Projects](/argoproj/argo-cd/projects)
* [Wiki](/argoproj/argo-cd/wiki)
* [Security](/argoproj/argo-cd/security)
* [Insights](/argoproj/argo-cd/pulse)

## Files

 54601c8
## Breadcrumbs

1. [argo-cd](/argoproj/argo-cd/tree/54601c8fd30b86a4c4b7eb449956264372c8bde0)
2. /[util](/argoproj/argo-cd/tree/54601c8fd30b86a4c4b7eb449956264372c8bde0/util)
3. /[session](/argoproj/argo-cd/tree/54601c8fd30b86a4c4b7eb449956264372c8bde0/util/session)
/
# sessionmanager.go

 Blame  Blame
## Latest commit

## History

[History](/argoproj/argo-cd/commits/54601c8fd30b86a4c4b7eb449956264372c8bde0/util/session/sessionmanager.go)640 lines (562 loc) · 20.5 KB 54601c8
## Breadcrumbs

1. [argo-cd](/argoproj/argo-cd/tree/54601c8fd30b86a4c4b7eb449956264372c8bde0)
2. /[util](/argoproj/argo-cd/tree/54601c8fd30b86a4c4b7eb449956264372c8bde0/util)
3. /[session](/argoproj/argo-cd/tree/54601c8fd30b86a4c4b7eb449956264372c8bde0/util/session)
/
# sessionmanager.go

Top
## File metadata and controls

* Code
* Blame

640 lines (562 loc) · 20.5 KB[Raw](https://github.com/argoproj/argo-cd/raw/54601c8fd30b86a4c4b7eb449956264372c8bde0/util/session/sessionmanager.go)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640package session
import ( "context" "errors" "fmt" "math" "math/rand" "net" "net/http" "os" "strings" "time"
 "github.com/coreos/go-oidc/v3/oidc" "github.com/golang-jwt/jwt/v4" "github.com/google/uuid" log "github.com/sirupsen/logrus" "google.golang.org/grpc/codes" "google.golang.org/grpc/status"
 "github.com/argoproj/argo-cd/v2/common" "github.com/argoproj/argo-cd/v2/pkg/client/listers/application/v1alpha1" "github.com/argoproj/argo-cd/v2/server/rbacpolicy" "github.com/argoproj/argo-cd/v2/util/cache/appstate" "github.com/argoproj/argo-cd/v2/util/dex" "github.com/argoproj/argo-cd/v2/util/env" httputil "github.com/argoproj/argo-cd/v2/util/http" jwtutil "github.com/argoproj/argo-cd/v2/util/jwt" oidcutil "github.com/argoproj/argo-cd/v2/util/oidc" passwordutil "github.com/argoproj/argo-cd/v2/util/password" "github.com/argoproj/argo-cd/v2/util/settings")
// SessionManager generates and validates JWT tokens for login sessions.type SessionManager struct { settingsMgr \*settings.SettingsManager projectsLister v1alpha1.AppProjectNamespaceLister client \*http.Client prov oidcutil.Provider storage UserStateStorage sleep func(d time.Duration) verificationDelayNoiseEnabled bool}
// LoginAttempts is a timestamped counter for failed login attemptstype LoginAttempts struct { // Time of the last failed login LastFailed time.Time `json:"lastFailed"` // Number of consecutive login failures FailCount int `json:"failCount"`}
const ( // SessionManagerClaimsIssuer fills the "iss" field of the token. SessionManagerClaimsIssuer = "argocd" AuthErrorCtxKey = "auth-error"
 // invalidLoginError, for security purposes, doesn't say whether the username or password was invalid. This does not mitigate the potential for timing attacks to determine which is which. invalidLoginError = "Invalid username or password" blankPasswordError = "Blank passwords are not allowed" accountDisabled = "Account %s is disabled" usernameTooLongError = "Username is too long (%d bytes max)" userDoesNotHaveCapability = "Account %s does not have %s capability" autoRegenerateTokenDuration = time.Minute \* 5)
const ( // Maximum length of username, too keep the cache's memory signature low maxUsernameLength = 32 // The default maximum session cache size defaultMaxCacheSize = 1000 // The default number of maximum login failures before delay kicks in defaultMaxLoginFailures = 5 // The default time in seconds for the failure window defaultFailureWindow = 300 // The password verification delay max verificationDelayNoiseMin = 500 \* time.Millisecond // The password verification delay max verificationDelayNoiseMax = 1000 \* time.Millisecond
 // environment variables to control rate limiter behaviour:
 // Max number of login failures before login delay kicks in envLoginMaxFailCount = "ARGOCD\_SESSION\_FAILURE\_MAX\_FAIL\_COUNT"
 // Number of maximum seconds the login is allowed to delay for. Default: 300 (5 minutes). envLoginFailureWindowSeconds = "ARGOCD\_SESSION\_FAILURE\_WINDOW\_SECONDS"
 // Max number of stored usernames envLoginMaxCacheSize = "ARGOCD\_SESSION\_MAX\_CACHE\_SIZE")
var ( InvalidLoginErr = status.Errorf(codes.Unauthenticated, invalidLoginError))
// Returns the maximum cache size as number of entriesfunc getMaximumCacheSize() int { return env.ParseNumFromEnv(envLoginMaxCacheSize, defaultMaxCacheSize, 1, math.MaxInt32)}
// Returns the maximum number of login failures before login delay kicks infunc getMaxLoginFailures() int { return env.ParseNumFromEnv(envLoginMaxFailCount, defaultMaxLoginFailures, 1, math.MaxInt32)}
// Returns the number of maximum seconds the login is allowed to delay forfunc getLoginFailureWindow() time.Duration { return time.Duration(env.ParseNumFromEnv(envLoginFailureWindowSeconds, defaultFailureWindow, 0, math.MaxInt32))}
// NewSessionManager creates a new session manager from Argo CD settingsfunc NewSessionManager(settingsMgr \*settings.SettingsManager, projectsLister v1alpha1.AppProjectNamespaceLister, dexServerAddr string, dexTlsConfig \*dex.DexTLSConfig, storage UserStateStorage) \*SessionManager { s := SessionManager{ settingsMgr: settingsMgr, storage: storage, sleep: time.Sleep, projectsLister: projectsLister, verificationDelayNoiseEnabled: true, } settings, err := settingsMgr.GetSettings() if err != nil { panic(err) }
 transport := &http.Transport{ Proxy: http.ProxyFromEnvironment, Dial: (&net.Dialer{ Timeout: 30 \* time.Second, KeepAlive: 30 \* time.Second, }).Dial, TLSHandshakeTimeout: 10 \* time.Second, ExpectContinueTimeout: 1 \* time.Second, }
 s.client = &http.Client{ Transport: transport, }
 if settings.DexConfig != "" { transport.TLSClientConfig = dex.TLSConfig(dexTlsConfig) addrWithProto := dex.DexServerAddressWithProtocol(dexServerAddr, dexTlsConfig) s.client.Transport = dex.NewDexRewriteURLRoundTripper(addrWithProto, s.client.Transport) } else { transport.TLSClientConfig = settings.OIDCTLSConfig() } if os.Getenv(common.EnvVarSSODebug) == "1" { s.client.Transport = httputil.DebugTransport{T: s.client.Transport} }
 return &s}
// Create creates a new token for a given subject (user) and returns it as a string.// Passing a value of `0` for secondsBeforeExpiry creates a token that never expires.// The id parameter holds an optional unique JWT token identifier and stored as a standard claim "jti" in the JWT token.func (mgr \*SessionManager) Create(subject string, secondsBeforeExpiry int64, id string) (string, error) { // Create a new token object, specifying signing method and the claims // you would like it to contain. now := time.Now().UTC() claims := jwt.RegisteredClaims{ IssuedAt: jwt.NewNumericDate(now), Issuer: SessionManagerClaimsIssuer, NotBefore: jwt.NewNumericDate(now), Subject: subject, ID: id, } if secondsBeforeExpiry > 0 { expires := now.Add(time.Duration(secondsBeforeExpiry) \* time.Second) claims.ExpiresAt = jwt.NewNumericDate(expires) }
 return mgr.signClaims(claims)}
func (mgr \*SessionManager) signClaims(claims jwt.Claims) (string, error) { token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims) settings, err := mgr.settingsMgr.GetSettings() if err != nil { return "", err } return token.SignedString(settings.ServerSignature)}
// GetSubjectAccountAndCapability analyzes Argo CD account token subject and extract account name// and the capability it was generated for (default capability is API Key).func GetSubjectAccountAndCapability(subject string) (string, settings.AccountCapability) { capability := settings.AccountCapabilityApiKey if parts := strings.Split(subject, ":"); len(parts) > 1 { subject = parts[0] switch parts[1] { case string(settings.AccountCapabilityLogin): capability = settings.AccountCapabilityLogin case string(settings.AccountCapabilityApiKey): capability = settings.AccountCapabilityApiKey } } return subject, capability}
// Parse tries to parse the provided string and returns the token claims for local login.func (mgr \*SessionManager) Parse(tokenString string) (jwt.Claims, string, error) { // Parse takes the token string and a function for looking up the key. The latter is especially // useful if you use multiple keys for your application. The standard is to use 'kid' in the // head of the token to identify which key to use, but the parsed token (head and claims) is provided // to the callback, providing flexibility. var claims jwt.MapClaims argoCDSettings, err := mgr.settingsMgr.GetSettings() if err != nil { return nil, "", err } token, err := jwt.ParseWithClaims(tokenString, &claims, func(token \*jwt.Token) (interface{}, error) { // Don't forget to validate the alg is what you expect: if \_, ok := token.Method.(\*jwt.SigningMethodHMAC); !ok { return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"]) } return argoCDSettings.ServerSignature, nil }) if err != nil { return nil, "", err }
 issuedAt, err := jwtutil.IssuedAtTime(claims) if err != nil { return nil, "", err }
 subject := jwtutil.StringField(claims, "sub") id := jwtutil.StringField(claims, "jti")
 if projName, role, ok := rbacpolicy.GetProjectRoleFromSubject(subject); ok { proj, err := mgr.projectsLister.Get(projName) if err != nil { return nil, "", err } \_, \_, err = proj.GetJWTToken(role, issuedAt.Unix(), id) if err != nil { return nil, "", err }
 return token.Claims, "", nil }
 subject, capability := GetSubjectAccountAndCapability(subject) claims["sub"] = subject
 account, err := mgr.settingsMgr.GetAccount(subject) if err != nil { return nil, "", err }
 if !account.Enabled { return nil, "", fmt.Errorf("account %s is disabled", subject) }
 if !account.HasCapability(capability) { return nil, "", fmt.Errorf("account %s does not have '%s' capability", subject, capability) }
 if id == "" || mgr.storage.IsTokenRevoked(id) { return nil, "", errors.New("token is revoked, please re-login") } else if capability == settings.AccountCapabilityApiKey && account.TokenIndex(id) == -1 { return nil, "", fmt.Errorf("account %s does not have token with id %s", subject, id) }
 if account.PasswordMtime != nil && issuedAt.Before(\*account.PasswordMtime) { return nil, "", fmt.Errorf("account password has changed since token issued") }
 newToken := "" if exp, err := jwtutil.ExpirationTime(claims); err == nil { tokenExpDuration := exp.Sub(issuedAt) remainingDuration := time.Until(exp)
 if remainingDuration < autoRegenerateTokenDuration && capability == settings.AccountCapabilityLogin { if uniqueId, err := uuid.NewRandom(); err == nil { if val, err := mgr.Create(fmt.Sprintf("%s:%s", subject, settings.AccountCapabilityLogin), int64(tokenExpDuration.Seconds()), uniqueId.String()); err == nil { newToken = val } } } } return token.Claims, newToken, nil}
// GetLoginFailures retrieves the login failure information from the cachefunc (mgr \*SessionManager) GetLoginFailures() map[string]LoginAttempts { // Get failures from the cache var failures map[string]LoginAttempts err := mgr.storage.GetLoginAttempts(&failures) if err != nil { if err != appstate.ErrCacheMiss { log.Errorf("Could not retrieve login attempts: %v", err) } failures = make(map[string]LoginAttempts) }
 return failures}
func expireOldFailedAttempts(maxAge time.Duration, failures \*map[string]LoginAttempts) int { expiredCount := 0 for key, attempt := range \*failures { if time.Since(attempt.LastFailed) > maxAge\*time.Second { expiredCount += 1 delete(\*failures, key) } } return expiredCount}
// Updates the failure count for a given username. If failed is true, increases the counter. Otherwise, sets counter back to 0.func (mgr \*SessionManager) updateFailureCount(username string, failed bool) {
 failures := mgr.GetLoginFailures()
 // Expire old entries in the cache if we have a failure window defined. if window := getLoginFailureWindow(); window > 0 { count := expireOldFailedAttempts(window, &failures) if count > 0 { log.Infof("Expired %d entries from session cache due to max age reached", count) } }
 // If we exceed a certain cache size, we need to remove random entries to // prevent overbloating the cache with fake entries, as this could lead to // memory exhaustion and ultimately in a DoS. We remove a single entry to // replace it with the new one. // // Chances are that we remove the one that is under active attack, but this // chance is low (1:cache\_size) if failed && len(failures) >= getMaximumCacheSize() { log.Warnf("Session cache size exceeds %d entries, removing random entry", getMaximumCacheSize()) idx := rand.Intn(len(failures) - 1) var rmUser string i := 0 for key := range failures { if i == idx { rmUser = key delete(failures, key) break } i++ } log.Infof("Deleted entry for user %s from cache", rmUser) }
 attempt, ok := failures[username] if !ok { attempt = LoginAttempts{FailCount: 0} }
 // On login failure, increase fail count and update last failed timestamp. // On login success, remove the entry from the cache. if failed { attempt.FailCount += 1 attempt.LastFailed = time.Now() failures[username] = attempt log.Warnf("User %s failed login %d time(s)", username, attempt.FailCount) } else { if attempt.FailCount > 0 { // Forget username for cache size enforcement, since entry in cache was deleted delete(failures, username) } }
 err := mgr.storage.SetLoginAttempts(failures) if err != nil { log.Errorf("Could not update login attempts: %v", err) }
}
// Get the current login failure attempts for given usernamefunc (mgr \*SessionManager) getFailureCount(username string) LoginAttempts { failures := mgr.GetLoginFailures() attempt, ok := failures[username] if !ok { attempt = LoginAttempts{FailCount: 0} } return attempt}
// Calculate a login delay for the given login attemptfunc (mgr \*SessionManager) exceededFailedLoginAttempts(attempt LoginAttempts) bool { maxFails := getMaxLoginFailures() failureWindow := getLoginFailureWindow()
 // Whether we are in the failure window for given attempt inWindow := func() bool { if failureWindow == 0 || time.Since(attempt.LastFailed).Seconds() <= float64(failureWindow) { return true } return false }
 // If we reached max failed attempts within failure window, we need to calc the delay if attempt.FailCount >= maxFails && inWindow() { return true }
 return false}
// VerifyUsernamePassword verifies if a username/password combo is correctfunc (mgr \*SessionManager) VerifyUsernamePassword(username string, password string) error { if password == "" { return status.Errorf(codes.Unauthenticated, blankPasswordError) } // Enforce maximum length of username on local accounts if len(username) > maxUsernameLength { return status.Errorf(codes.InvalidArgument, usernameTooLongError, maxUsernameLength) }
 start := time.Now() if mgr.verificationDelayNoiseEnabled { defer func() { // introduces random delay to protect from timing-based user enumeration attack delayNanoseconds := verificationDelayNoiseMin.Nanoseconds() + int64(rand.Intn(int(verificationDelayNoiseMax.Nanoseconds()-verificationDelayNoiseMin.Nanoseconds()))) // take into account amount of time spent since the request start delayNanoseconds = delayNanoseconds - time.Since(start).Nanoseconds() if delayNanoseconds > 0 { mgr.sleep(time.Duration(delayNanoseconds)) } }() }
 attempt := mgr.getFailureCount(username) if mgr.exceededFailedLoginAttempts(attempt) { log.Warnf("User %s had too many failed logins (%d)", username, attempt.FailCount) return InvalidLoginErr }
 account, err := mgr.settingsMgr.GetAccount(username) if err != nil { if errStatus, ok := status.FromError(err); ok && errStatus.Code() == codes.NotFound { mgr.updateFailureCount(username, true) err = InvalidLoginErr } // to prevent time-based user enumeration, we must perform a password // hash cycle to keep response time consistent (if the function were // to continue and not return here) \_, \_ = passwordutil.HashPassword("for\_consistent\_response\_time") return err }
 valid, \_ := passwordutil.VerifyPassword(password, account.PasswordHash) if !valid { mgr.updateFailureCount(username, true) return InvalidLoginErr }
 if !account.Enabled { return status.Errorf(codes.Unauthenticated, accountDisabled, username) }
 if !account.HasCapability(settings.AccountCapabilityLogin) { return status.Errorf(codes.Unauthenticated, userDoesNotHaveCapability, username, settings.AccountCapabilityLogin) } mgr.updateFailureCount(username, false) return nil}
// AuthMiddlewareFunc returns a function that can be used as an// authentication middleware for HTTP requests.func (mgr \*SessionManager) AuthMiddlewareFunc(disabled bool) func(http.Handler) http.Handler { return func(h http.Handler) http.Handler { return WithAuthMiddleware(disabled, mgr, h) }}
// TokenVerifier defines the contract to invoke token// verification logictype TokenVerifier interface { VerifyToken(token string) (jwt.Claims, string, error)}
// WithAuthMiddleware is an HTTP middleware used to ensure incoming// requests are authenticated before invoking the target handler. If// disabled is true, it will just invoke the next handler in the chain.func WithAuthMiddleware(disabled bool, authn TokenVerifier, next http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r \*http.Request) { if !disabled { cookies := r.Cookies() tokenString, err := httputil.JoinCookies(common.AuthCookieName, cookies) if err != nil { http.Error(w, "Auth cookie not found", http.StatusBadRequest) return } claims, \_, err := authn.VerifyToken(tokenString) if err != nil { http.Error(w, "Invalid token", http.StatusUnauthorized) return } ctx := r.Context() // Add claims to the context to inspect for RBAC // nolint:staticcheck ctx = context.WithValue(ctx, "claims", claims) r = r.WithContext(ctx) } next.ServeHTTP(w, r) })}
// VerifyToken verifies if a token is correct. Tokens can be issued either from us or by an IDP.// We choose how to verify based on the issuer.func (mgr \*SessionManager) VerifyToken(tokenString string) (jwt.Claims, string, error) { parser := jwt.NewParser(jwt.WithoutClaimsValidation()) var claims jwt.RegisteredClaims \_, \_, err := parser.ParseUnverified(tokenString, &claims) if err != nil { return nil, "", err } switch claims.Issuer { case SessionManagerClaimsIssuer: // Argo CD signed token return mgr.Parse(tokenString) default: // IDP signed token prov, err := mgr.provider() if err != nil { return nil, "", err }
 argoSettings, err := mgr.settingsMgr.GetSettings() if err != nil { return nil, "", fmt.Errorf("cannot access settings while verifying the token: %w", err) } if argoSettings == nil { return nil, "", fmt.Errorf("settings are not available while verifying the token") }
 idToken, err := prov.Verify(tokenString, argoSettings)
 // The token verification has failed. If the token has expired, we will // return a dummy claims only containing a value for the issuer, so the // UI can handle expired tokens appropriately. if err != nil { log.Warnf("Failed to verify token: %s", err) tokenExpiredError := &oidc.TokenExpiredError{} if errors.As(err, &tokenExpiredError) { claims = jwt.RegisteredClaims{ Issuer: "sso", } return claims, "", common.TokenVerificationErr } return nil, "", common.TokenVerificationErr }
 var claims jwt.MapClaims err = idToken.Claims(&claims) if err != nil { return nil, "", err } return claims, "", nil }}
func (mgr \*SessionManager) provider() (oidcutil.Provider, error) { if mgr.prov != nil { return mgr.prov, nil } settings, err := mgr.settingsMgr.GetSettings() if err != nil { return nil, err } if !settings.IsSSOConfigured() { return nil, fmt.Errorf("SSO is not configured") } mgr.prov = oidcutil.NewOIDCProvider(settings.IssuerURL(), mgr.client) return mgr.prov, nil}
func (mgr \*SessionManager) RevokeToken(ctx context.Context, id string, expiringAt time.Duration) error { return mgr.storage.RevokeToken(ctx, id, expiringAt)}
func LoggedIn(ctx context.Context) bool { return Sub(ctx) != "" && ctx.Value(AuthErrorCtxKey) == nil}
// Username is a helper to extract a human readable username from a contextfunc Username(ctx context.Context) string { mapClaims, ok := mapClaims(ctx) if !ok { return "" } switch jwtutil.StringField(mapClaims, "iss") { case SessionManagerClaimsIssuer: return jwtutil.StringField(mapClaims, "sub") default: return jwtutil.StringField(mapClaims, "email") }}
func Iss(ctx context.Context) string { mapClaims, ok := mapClaims(ctx) if !ok { return "" } return jwtutil.StringField(mapClaims, "iss")}
func Iat(ctx context.Context) (time.Time, error) { mapClaims, ok := mapClaims(ctx) if !ok { return time.Time{}, errors.New("unable to extract token claims") } return jwtutil.IssuedAtTime(mapClaims)}
func Sub(ctx context.Context) string { mapClaims, ok := mapClaims(ctx) if !ok { return "" } return jwtutil.StringField(mapClaims, "sub")}
func Groups(ctx context.Context, scopes []string) []string { mapClaims, ok := mapClaims(ctx) if !ok { return nil } return jwtutil.GetGroups(mapClaims, scopes)}
func mapClaims(ctx context.Context) (jwt.MapClaims, bool) { claims, ok := ctx.Value("claims").(jwt.Claims) if !ok { return nil, false } mapClaims, err := jwtutil.MapClaims(claims) if err != nil { return nil, false } return mapClaims, true}

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

