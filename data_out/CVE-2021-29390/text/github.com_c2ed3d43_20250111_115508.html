
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Flibjpeg-turbo%2Flibjpeg-turbo%2Fblob%2F4e52b66f342a803d3b8099b79607e3158d3a241c%2Fjdcoefct.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Flibjpeg-turbo%2Flibjpeg-turbo%2Fblob%2F4e52b66f342a803d3b8099b79607e3158d3a241c%2Fjdcoefct.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=libjpeg-turbo%2Flibjpeg-turbo)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[libjpeg-turbo](/libjpeg-turbo)
/
**[libjpeg-turbo](/libjpeg-turbo/libjpeg-turbo)**
Public

* [Notifications](/login?return_to=%2Flibjpeg-turbo%2Flibjpeg-turbo) You must be signed in to change notification settings
* [Fork
  1k](/login?return_to=%2Flibjpeg-turbo%2Flibjpeg-turbo)
* [Star
   3.8k](/login?return_to=%2Flibjpeg-turbo%2Flibjpeg-turbo)

* [Code](/libjpeg-turbo/libjpeg-turbo)
* [Issues
  19](/libjpeg-turbo/libjpeg-turbo/issues)
* [Pull requests
  2](/libjpeg-turbo/libjpeg-turbo/pulls)
* [Discussions](/libjpeg-turbo/libjpeg-turbo/discussions)
* [Actions](/libjpeg-turbo/libjpeg-turbo/actions)
* [Projects
  0](/libjpeg-turbo/libjpeg-turbo/projects)
* [Security](/libjpeg-turbo/libjpeg-turbo/security)
* [Insights](/libjpeg-turbo/libjpeg-turbo/pulse)

Additional navigation options

* [Code](/libjpeg-turbo/libjpeg-turbo)
* [Issues](/libjpeg-turbo/libjpeg-turbo/issues)
* [Pull requests](/libjpeg-turbo/libjpeg-turbo/pulls)
* [Discussions](/libjpeg-turbo/libjpeg-turbo/discussions)
* [Actions](/libjpeg-turbo/libjpeg-turbo/actions)
* [Projects](/libjpeg-turbo/libjpeg-turbo/projects)
* [Security](/libjpeg-turbo/libjpeg-turbo/security)
* [Insights](/libjpeg-turbo/libjpeg-turbo/pulse)

## Files

 4e52b66
## Breadcrumbs

1. [libjpeg-turbo](/libjpeg-turbo/libjpeg-turbo/tree/4e52b66f342a803d3b8099b79607e3158d3a241c)
/
# jdcoefct.c

Copy path Blame  Blame
## Latest commit

## History

[History](/libjpeg-turbo/libjpeg-turbo/commits/4e52b66f342a803d3b8099b79607e3158d3a241c/jdcoefct.c)876 lines (811 loc) · 33.2 KB 4e52b66
## Breadcrumbs

1. [libjpeg-turbo](/libjpeg-turbo/libjpeg-turbo/tree/4e52b66f342a803d3b8099b79607e3158d3a241c)
/
# jdcoefct.c

Top
## File metadata and controls

* Code
* Blame

876 lines (811 loc) · 33.2 KB[Raw](https://github.com/libjpeg-turbo/libjpeg-turbo/raw/4e52b66f342a803d3b8099b79607e3158d3a241c/jdcoefct.c)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876/\* \* jdcoefct.c \* \* This file was part of the Independent JPEG Group's software: \* Copyright (C) 1994-1997, Thomas G. Lane. \* libjpeg-turbo Modifications: \* Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB \* Copyright (C) 2010, 2015-2016, 2019-2020, D. R. Commander. \* Copyright (C) 2015, 2020, Google, Inc. \* For conditions of distribution and use, see the accompanying README.ijg \* file. \* \* This file contains the coefficient buffer controller for decompression. \* This controller is the top level of the JPEG decompressor proper. \* The coefficient buffer lies between entropy decoding and inverse-DCT steps. \* \* In buffered-image mode, this controller is the interface between \* input-oriented processing and output-oriented processing. \* Also, the input side (only) is used when reading a file for transcoding. \*/
#include "jinclude.h"#include "jdcoefct.h"#include "jpegcomp.h"
/\* Forward declarations \*/METHODDEF(int) decompress\_onepass(j\_decompress\_ptr cinfo, JSAMPIMAGE output\_buf);#ifdef D\_MULTISCAN\_FILES\_SUPPORTEDMETHODDEF(int) decompress\_data(j\_decompress\_ptr cinfo, JSAMPIMAGE output\_buf);#endif#ifdef BLOCK\_SMOOTHING\_SUPPORTEDLOCAL(boolean) smoothing\_ok(j\_decompress\_ptr cinfo);METHODDEF(int) decompress\_smooth\_data(j\_decompress\_ptr cinfo, JSAMPIMAGE output\_buf);#endif
/\* \* Initialize for an input processing pass. \*/
METHODDEF(void)start\_input\_pass(j\_decompress\_ptr cinfo){ cinfo->input\_iMCU\_row = 0; start\_iMCU\_row(cinfo);}
/\* \* Initialize for an output processing pass. \*/
METHODDEF(void)start\_output\_pass(j\_decompress\_ptr cinfo){#ifdef BLOCK\_SMOOTHING\_SUPPORTED my\_coef\_ptr coef = (my\_coef\_ptr)cinfo->coef;
 /\* If multipass, check to see whether to use block smoothing on this pass \*/ if (coef->pub.coef\_arrays != NULL) { if (cinfo->do\_block\_smoothing && smoothing\_ok(cinfo)) coef->pub.decompress\_data = decompress\_smooth\_data; else coef->pub.decompress\_data = decompress\_data; }#endif cinfo->output\_iMCU\_row = 0;}
/\* \* Decompress and return some data in the single-pass case. \* Always attempts to emit one fully interleaved MCU row ("iMCU" row). \* Input and output must run in lockstep since we have only a one-MCU buffer. \* Return value is JPEG\_ROW\_COMPLETED, JPEG\_SCAN\_COMPLETED, or JPEG\_SUSPENDED. \* \* NB: output\_buf contains a plane for each component in image, \* which we index according to the component's SOF position. \*/
METHODDEF(int)decompress\_onepass(j\_decompress\_ptr cinfo, JSAMPIMAGE output\_buf){ my\_coef\_ptr coef = (my\_coef\_ptr)cinfo->coef; JDIMENSION MCU\_col\_num; /\* index of current MCU within row \*/ JDIMENSION last\_MCU\_col = cinfo->MCUs\_per\_row - 1; JDIMENSION last\_iMCU\_row = cinfo->total\_iMCU\_rows - 1; int blkn, ci, xindex, yindex, yoffset, useful\_width; JSAMPARRAY output\_ptr; JDIMENSION start\_col, output\_col; jpeg\_component\_info \*compptr; inverse\_DCT\_method\_ptr inverse\_DCT;
 /\* Loop to process as much as one whole iMCU row \*/ for (yoffset = coef->MCU\_vert\_offset; yoffset < coef->MCU\_rows\_per\_iMCU\_row; yoffset++) { for (MCU\_col\_num = coef->MCU\_ctr; MCU\_col\_num <= last\_MCU\_col; MCU\_col\_num++) { /\* Try to fetch an MCU. Entropy decoder expects buffer to be zeroed. \*/ jzero\_far((void \*)coef->MCU\_buffer[0], (size\_t)(cinfo->blocks\_in\_MCU \* sizeof(JBLOCK))); if (!cinfo->entropy->insufficient\_data) cinfo->master->last\_good\_iMCU\_row = cinfo->input\_iMCU\_row; if (!(\*cinfo->entropy->decode\_mcu) (cinfo, coef->MCU\_buffer)) { /\* Suspension forced; update state counters and exit \*/ coef->MCU\_vert\_offset = yoffset; coef->MCU\_ctr = MCU\_col\_num; return JPEG\_SUSPENDED; }
 /\* Only perform the IDCT on blocks that are contained within the desired \* cropping region. \*/ if (MCU\_col\_num >= cinfo->master->first\_iMCU\_col && MCU\_col\_num <= cinfo->master->last\_iMCU\_col) { /\* Determine where data should go in output\_buf and do the IDCT thing. \* We skip dummy blocks at the right and bottom edges (but blkn gets \* incremented past them!). Note the inner loop relies on having \* allocated the MCU\_buffer[] blocks sequentially. \*/ blkn = 0; /\* index of current DCT block within MCU \*/ for (ci = 0; ci < cinfo->comps\_in\_scan; ci++) { compptr = cinfo->cur\_comp\_info[ci]; /\* Don't bother to IDCT an uninteresting component. \*/ if (!compptr->component\_needed) { blkn += compptr->MCU\_blocks; continue; } inverse\_DCT = cinfo->idct->inverse\_DCT[compptr->component\_index]; useful\_width = (MCU\_col\_num < last\_MCU\_col) ? compptr->MCU\_width : compptr->last\_col\_width; output\_ptr = output\_buf[compptr->component\_index] + yoffset \* compptr->\_DCT\_scaled\_size; start\_col = (MCU\_col\_num - cinfo->master->first\_iMCU\_col) \* compptr->MCU\_sample\_width; for (yindex = 0; yindex < compptr->MCU\_height; yindex++) { if (cinfo->input\_iMCU\_row < last\_iMCU\_row || yoffset + yindex < compptr->last\_row\_height) { output\_col = start\_col; for (xindex = 0; xindex < useful\_width; xindex++) { (\*inverse\_DCT) (cinfo, compptr, (JCOEFPTR)coef->MCU\_buffer[blkn + xindex], output\_ptr, output\_col); output\_col += compptr->\_DCT\_scaled\_size; } } blkn += compptr->MCU\_width; output\_ptr += compptr->\_DCT\_scaled\_size; } } } } /\* Completed an MCU row, but perhaps not an iMCU row \*/ coef->MCU\_ctr = 0; } /\* Completed the iMCU row, advance counters for next one \*/ cinfo->output\_iMCU\_row++; if (++(cinfo->input\_iMCU\_row) < cinfo->total\_iMCU\_rows) { start\_iMCU\_row(cinfo); return JPEG\_ROW\_COMPLETED; } /\* Completed the scan \*/ (\*cinfo->inputctl->finish\_input\_pass) (cinfo); return JPEG\_SCAN\_COMPLETED;}
/\* \* Dummy consume-input routine for single-pass operation. \*/
METHODDEF(int)dummy\_consume\_data(j\_decompress\_ptr cinfo){ return JPEG\_SUSPENDED; /\* Always indicate nothing was done \*/}
#ifdef D\_MULTISCAN\_FILES\_SUPPORTED
/\* \* Consume input data and store it in the full-image coefficient buffer. \* We read as much as one fully interleaved MCU row ("iMCU" row) per call, \* ie, v\_samp\_factor block rows for each component in the scan. \* Return value is JPEG\_ROW\_COMPLETED, JPEG\_SCAN\_COMPLETED, or JPEG\_SUSPENDED. \*/
METHODDEF(int)consume\_data(j\_decompress\_ptr cinfo){ my\_coef\_ptr coef = (my\_coef\_ptr)cinfo->coef; JDIMENSION MCU\_col\_num; /\* index of current MCU within row \*/ int blkn, ci, xindex, yindex, yoffset; JDIMENSION start\_col; JBLOCKARRAY buffer[MAX\_COMPS\_IN\_SCAN]; JBLOCKROW buffer\_ptr; jpeg\_component\_info \*compptr;
 /\* Align the virtual buffers for the components used in this scan. \*/ for (ci = 0; ci < cinfo->comps\_in\_scan; ci++) { compptr = cinfo->cur\_comp\_info[ci]; buffer[ci] = (\*cinfo->mem->access\_virt\_barray) ((j\_common\_ptr)cinfo, coef->whole\_image[compptr->component\_index], cinfo->input\_iMCU\_row \* compptr->v\_samp\_factor, (JDIMENSION)compptr->v\_samp\_factor, TRUE); /\* Note: entropy decoder expects buffer to be zeroed, \* but this is handled automatically by the memory manager \* because we requested a pre-zeroed array. \*/ }
 /\* Loop to process one whole iMCU row \*/ for (yoffset = coef->MCU\_vert\_offset; yoffset < coef->MCU\_rows\_per\_iMCU\_row; yoffset++) { for (MCU\_col\_num = coef->MCU\_ctr; MCU\_col\_num < cinfo->MCUs\_per\_row; MCU\_col\_num++) { /\* Construct list of pointers to DCT blocks belonging to this MCU \*/ blkn = 0; /\* index of current DCT block within MCU \*/ for (ci = 0; ci < cinfo->comps\_in\_scan; ci++) { compptr = cinfo->cur\_comp\_info[ci]; start\_col = MCU\_col\_num \* compptr->MCU\_width; for (yindex = 0; yindex < compptr->MCU\_height; yindex++) { buffer\_ptr = buffer[ci][yindex + yoffset] + start\_col; for (xindex = 0; xindex < compptr->MCU\_width; xindex++) { coef->MCU\_buffer[blkn++] = buffer\_ptr++; } } } if (!cinfo->entropy->insufficient\_data) cinfo->master->last\_good\_iMCU\_row = cinfo->input\_iMCU\_row; /\* Try to fetch the MCU. \*/ if (!(\*cinfo->entropy->decode\_mcu) (cinfo, coef->MCU\_buffer)) { /\* Suspension forced; update state counters and exit \*/ coef->MCU\_vert\_offset = yoffset; coef->MCU\_ctr = MCU\_col\_num; return JPEG\_SUSPENDED; } } /\* Completed an MCU row, but perhaps not an iMCU row \*/ coef->MCU\_ctr = 0; } /\* Completed the iMCU row, advance counters for next one \*/ if (++(cinfo->input\_iMCU\_row) < cinfo->total\_iMCU\_rows) { start\_iMCU\_row(cinfo); return JPEG\_ROW\_COMPLETED; } /\* Completed the scan \*/ (\*cinfo->inputctl->finish\_input\_pass) (cinfo); return JPEG\_SCAN\_COMPLETED;}
/\* \* Decompress and return some data in the multi-pass case. \* Always attempts to emit one fully interleaved MCU row ("iMCU" row). \* Return value is JPEG\_ROW\_COMPLETED, JPEG\_SCAN\_COMPLETED, or JPEG\_SUSPENDED. \* \* NB: output\_buf contains a plane for each component in image. \*/
METHODDEF(int)decompress\_data(j\_decompress\_ptr cinfo, JSAMPIMAGE output\_buf){ my\_coef\_ptr coef = (my\_coef\_ptr)cinfo->coef; JDIMENSION last\_iMCU\_row = cinfo->total\_iMCU\_rows - 1; JDIMENSION block\_num; int ci, block\_row, block\_rows; JBLOCKARRAY buffer; JBLOCKROW buffer\_ptr; JSAMPARRAY output\_ptr; JDIMENSION output\_col; jpeg\_component\_info \*compptr; inverse\_DCT\_method\_ptr inverse\_DCT;
 /\* Force some input to be done if we are getting ahead of the input. \*/ while (cinfo->input\_scan\_number < cinfo->output\_scan\_number || (cinfo->input\_scan\_number == cinfo->output\_scan\_number && cinfo->input\_iMCU\_row <= cinfo->output\_iMCU\_row)) { if ((\*cinfo->inputctl->consume\_input) (cinfo) == JPEG\_SUSPENDED) return JPEG\_SUSPENDED; }
 /\* OK, output from the virtual arrays. \*/ for (ci = 0, compptr = cinfo->comp\_info; ci < cinfo->num\_components; ci++, compptr++) { /\* Don't bother to IDCT an uninteresting component. \*/ if (!compptr->component\_needed) continue; /\* Align the virtual buffer for this component. \*/ buffer = (\*cinfo->mem->access\_virt\_barray) ((j\_common\_ptr)cinfo, coef->whole\_image[ci], cinfo->output\_iMCU\_row \* compptr->v\_samp\_factor, (JDIMENSION)compptr->v\_samp\_factor, FALSE); /\* Count non-dummy DCT block rows in this iMCU row. \*/ if (cinfo->output\_iMCU\_row < last\_iMCU\_row) block\_rows = compptr->v\_samp\_factor; else { /\* NB: can't use last\_row\_height here; it is input-side-dependent! \*/ block\_rows = (int)(compptr->height\_in\_blocks % compptr->v\_samp\_factor); if (block\_rows == 0) block\_rows = compptr->v\_samp\_factor; } inverse\_DCT = cinfo->idct->inverse\_DCT[ci]; output\_ptr = output\_buf[ci]; /\* Loop over all DCT blocks to be processed. \*/ for (block\_row = 0; block\_row < block\_rows; block\_row++) { buffer\_ptr = buffer[block\_row] + cinfo->master->first\_MCU\_col[ci]; output\_col = 0; for (block\_num = cinfo->master->first\_MCU\_col[ci]; block\_num <= cinfo->master->last\_MCU\_col[ci]; block\_num++) { (\*inverse\_DCT) (cinfo, compptr, (JCOEFPTR)buffer\_ptr, output\_ptr, output\_col); buffer\_ptr++; output\_col += compptr->\_DCT\_scaled\_size; } output\_ptr += compptr->\_DCT\_scaled\_size; } }
 if (++(cinfo->output\_iMCU\_row) < cinfo->total\_iMCU\_rows) return JPEG\_ROW\_COMPLETED; return JPEG\_SCAN\_COMPLETED;}
#endif /\* D\_MULTISCAN\_FILES\_SUPPORTED \*/
#ifdef BLOCK\_SMOOTHING\_SUPPORTED
/\* \* This code applies interblock smoothing; the first 9 AC coefficients are \* estimated from the DC values of a DCT block and its 24 neighboring blocks. \* We apply smoothing only for progressive JPEG decoding, and only if \* the coefficients it can estimate are not yet known to full precision. \*/
/\* Natural-order array positions of the first 9 zigzag-order coefficients \*/#define Q01\_POS 1#define Q10\_POS 8#define Q20\_POS 16#define Q11\_POS 9#define Q02\_POS 2#define Q03\_POS 3#define Q12\_POS 10#define Q21\_POS 17#define Q30\_POS 24
/\* \* Determine whether block smoothing is applicable and safe. \* We also latch the current states of the coef\_bits[] entries for the \* AC coefficients; otherwise, if the input side of the decompressor \* advances into a new scan, we might think the coefficients are known \* more accurately than they really are. \*/
LOCAL(boolean)smoothing\_ok(j\_decompress\_ptr cinfo){ my\_coef\_ptr coef = (my\_coef\_ptr)cinfo->coef; boolean smoothing\_useful = FALSE; int ci, coefi; jpeg\_component\_info \*compptr; JQUANT\_TBL \*qtable; int \*coef\_bits, \*prev\_coef\_bits; int \*coef\_bits\_latch, \*prev\_coef\_bits\_latch;
 if (!cinfo->progressive\_mode || cinfo->coef\_bits == NULL) return FALSE;
 /\* Allocate latch area if not already done \*/ if (coef->coef\_bits\_latch == NULL) coef->coef\_bits\_latch = (int \*) (\*cinfo->mem->alloc\_small) ((j\_common\_ptr)cinfo, JPOOL\_IMAGE, cinfo->num\_components \* 2 \* (SAVED\_COEFS \* sizeof(int))); coef\_bits\_latch = coef->coef\_bits\_latch; prev\_coef\_bits\_latch = &coef->coef\_bits\_latch[cinfo->num\_components \* SAVED\_COEFS];
 for (ci = 0, compptr = cinfo->comp\_info; ci < cinfo->num\_components; ci++, compptr++) { /\* All components' quantization values must already be latched. \*/ if ((qtable = compptr->quant\_table) == NULL) return FALSE; /\* Verify DC & first 9 AC quantizers are nonzero to avoid zero-divide. \*/ if (qtable->quantval[0] == 0 || qtable->quantval[Q01\_POS] == 0 || qtable->quantval[Q10\_POS] == 0 || qtable->quantval[Q20\_POS] == 0 || qtable->quantval[Q11\_POS] == 0 || qtable->quantval[Q02\_POS] == 0 || qtable->quantval[Q03\_POS] == 0 || qtable->quantval[Q12\_POS] == 0 || qtable->quantval[Q21\_POS] == 0 || qtable->quantval[Q30\_POS] == 0) return FALSE; /\* DC values must be at least partly known for all components. \*/ coef\_bits = cinfo->coef\_bits[ci]; prev\_coef\_bits = cinfo->coef\_bits[ci + cinfo->num\_components]; if (coef\_bits[0] < 0) return FALSE; coef\_bits\_latch[0] = coef\_bits[0]; /\* Block smoothing is helpful if some AC coefficients remain inaccurate. \*/ for (coefi = 1; coefi < SAVED\_COEFS; coefi++) { if (cinfo->input\_scan\_number > 1) prev\_coef\_bits\_latch[coefi] = prev\_coef\_bits[coefi]; coef\_bits\_latch[coefi] = coef\_bits[coefi]; if (coef\_bits[coefi] != 0) smoothing\_useful = TRUE; } coef\_bits\_latch += SAVED\_COEFS; prev\_coef\_bits\_latch += SAVED\_COEFS; }
 return smoothing\_useful;}
/\* \* Variant of decompress\_data for use when doing block smoothing. \*/
METHODDEF(int)decompress\_smooth\_data(j\_decompress\_ptr cinfo, JSAMPIMAGE output\_buf){ my\_coef\_ptr coef = (my\_coef\_ptr)cinfo->coef; JDIMENSION last\_iMCU\_row = cinfo->total\_iMCU\_rows - 1; JDIMENSION block\_num, last\_block\_column; int ci, block\_row, block\_rows, access\_rows; JBLOCKARRAY buffer; JBLOCKROW buffer\_ptr, prev\_prev\_block\_row, prev\_block\_row; JBLOCKROW next\_block\_row, next\_next\_block\_row; JSAMPARRAY output\_ptr; JDIMENSION output\_col; jpeg\_component\_info \*compptr; inverse\_DCT\_method\_ptr inverse\_DCT; boolean change\_dc; JCOEF \*workspace; int \*coef\_bits; JQUANT\_TBL \*quanttbl; JLONG Q00, Q01, Q02, Q03 = 0, Q10, Q11, Q12 = 0, Q20, Q21 = 0, Q30 = 0, num; int DC01, DC02, DC03, DC04, DC05, DC06, DC07, DC08, DC09, DC10, DC11, DC12, DC13, DC14, DC15, DC16, DC17, DC18, DC19, DC20, DC21, DC22, DC23, DC24, DC25; int Al, pred;
 /\* Keep a local variable to avoid looking it up more than once \*/ workspace = coef->workspace;
 /\* Force some input to be done if we are getting ahead of the input. \*/ while (cinfo->input\_scan\_number <= cinfo->output\_scan\_number && !cinfo->inputctl->eoi\_reached) { if (cinfo->input\_scan\_number == cinfo->output\_scan\_number) { /\* If input is working on current scan, we ordinarily want it to \* have completed the current row. But if input scan is DC, \* we want it to keep two rows ahead so that next two block rows' DC \* values are up to date. \*/ JDIMENSION delta = (cinfo->Ss == 0) ? 2 : 0; if (cinfo->input\_iMCU\_row > cinfo->output\_iMCU\_row + delta) break; } if ((\*cinfo->inputctl->consume\_input) (cinfo) == JPEG\_SUSPENDED) return JPEG\_SUSPENDED; }
 /\* OK, output from the virtual arrays. \*/ for (ci = 0, compptr = cinfo->comp\_info; ci < cinfo->num\_components; ci++, compptr++) { /\* Don't bother to IDCT an uninteresting component. \*/ if (!compptr->component\_needed) continue; /\* Count non-dummy DCT block rows in this iMCU row. \*/ if (cinfo->output\_iMCU\_row < last\_iMCU\_row - 1) { block\_rows = compptr->v\_samp\_factor; access\_rows = block\_rows \* 3; /\* this and next two iMCU rows \*/ } else if (cinfo->output\_iMCU\_row < last\_iMCU\_row) { block\_rows = compptr->v\_samp\_factor; access\_rows = block\_rows \* 2; /\* this and next iMCU row \*/ } else { /\* NB: can't use last\_row\_height here; it is input-side-dependent! \*/ block\_rows = (int)(compptr->height\_in\_blocks % compptr->v\_samp\_factor); if (block\_rows == 0) block\_rows = compptr->v\_samp\_factor; access\_rows = block\_rows; /\* this iMCU row only \*/ } /\* Align the virtual buffer for this component. \*/ if (cinfo->output\_iMCU\_row > 1) { access\_rows += 2 \* compptr->v\_samp\_factor; /\* prior two iMCU rows too \*/ buffer = (\*cinfo->mem->access\_virt\_barray) ((j\_common\_ptr)cinfo, coef->whole\_image[ci], (cinfo->output\_iMCU\_row - 2) \* compptr->v\_samp\_factor, (JDIMENSION)access\_rows, FALSE); buffer += 2 \* compptr->v\_samp\_factor; /\* point to current iMCU row \*/ } else if (cinfo->output\_iMCU\_row > 0) { buffer = (\*cinfo->mem->access\_virt\_barray) ((j\_common\_ptr)cinfo, coef->whole\_image[ci], (cinfo->output\_iMCU\_row - 1) \* compptr->v\_samp\_factor, (JDIMENSION)access\_rows, FALSE); buffer += compptr->v\_samp\_factor; /\* point to current iMCU row \*/ } else { buffer = (\*cinfo->mem->access\_virt\_barray) ((j\_common\_ptr)cinfo, coef->whole\_image[ci], (JDIMENSION)0, (JDIMENSION)access\_rows, FALSE); } /\* Fetch component-dependent info. \* If the current scan is incomplete, then we use the component-dependent \* info from the previous scan. \*/ if (cinfo->output\_iMCU\_row > cinfo->master->last\_good\_iMCU\_row) coef\_bits = coef->coef\_bits\_latch + ((ci + cinfo->num\_components) \* SAVED\_COEFS); else coef\_bits = coef->coef\_bits\_latch + (ci \* SAVED\_COEFS);
 /\* We only do DC interpolation if no AC coefficient data is available. \*/ change\_dc = coef\_bits[1] == -1 && coef\_bits[2] == -1 && coef\_bits[3] == -1 && coef\_bits[4] == -1 && coef\_bits[5] == -1 && coef\_bits[6] == -1 && coef\_bits[7] == -1 && coef\_bits[8] == -1 && coef\_bits[9] == -1;
 quanttbl = compptr->quant\_table; Q00 = quanttbl->quantval[0]; Q01 = quanttbl->quantval[Q01\_POS]; Q10 = quanttbl->quantval[Q10\_POS]; Q20 = quanttbl->quantval[Q20\_POS]; Q11 = quanttbl->quantval[Q11\_POS]; Q02 = quanttbl->quantval[Q02\_POS]; if (change\_dc) { Q03 = quanttbl->quantval[Q03\_POS]; Q12 = quanttbl->quantval[Q12\_POS]; Q21 = quanttbl->quantval[Q21\_POS]; Q30 = quanttbl->quantval[Q30\_POS]; } inverse\_DCT = cinfo->idct->inverse\_DCT[ci]; output\_ptr = output\_buf[ci]; /\* Loop over all DCT blocks to be processed. \*/ for (block\_row = 0; block\_row < block\_rows; block\_row++) { buffer\_ptr = buffer[block\_row] + cinfo->master->first\_MCU\_col[ci];
 if (block\_row > 0 || cinfo->output\_iMCU\_row > 0) prev\_block\_row = buffer[block\_row - 1] + cinfo->master->first\_MCU\_col[ci]; else prev\_block\_row = buffer\_ptr;
 if (block\_row > 1 || cinfo->output\_iMCU\_row > 1) prev\_prev\_block\_row = buffer[block\_row - 2] + cinfo->master->first\_MCU\_col[ci]; else prev\_prev\_block\_row = prev\_block\_row;
 if (block\_row < block\_rows - 1 || cinfo->output\_iMCU\_row < last\_iMCU\_row) next\_block\_row = buffer[block\_row + 1] + cinfo->master->first\_MCU\_col[ci]; else next\_block\_row = buffer\_ptr;
 if (block\_row < block\_rows - 2 || cinfo->output\_iMCU\_row < last\_iMCU\_row - 1) next\_next\_block\_row = buffer[block\_row + 2] + cinfo->master->first\_MCU\_col[ci]; else next\_next\_block\_row = next\_block\_row;
 /\* We fetch the surrounding DC values using a sliding-register approach. \* Initialize all 25 here so as to do the right thing on narrow pics. \*/ DC01 = DC02 = DC03 = DC04 = DC05 = (int)prev\_prev\_block\_row[0][0]; DC06 = DC07 = DC08 = DC09 = DC10 = (int)prev\_block\_row[0][0]; DC11 = DC12 = DC13 = DC14 = DC15 = (int)buffer\_ptr[0][0]; DC16 = DC17 = DC18 = DC19 = DC20 = (int)next\_block\_row[0][0]; DC21 = DC22 = DC23 = DC24 = DC25 = (int)next\_next\_block\_row[0][0]; output\_col = 0; last\_block\_column = compptr->width\_in\_blocks - 1; for (block\_num = cinfo->master->first\_MCU\_col[ci]; block\_num <= cinfo->master->last\_MCU\_col[ci]; block\_num++) { /\* Fetch current DCT block into workspace so we can modify it. \*/ jcopy\_block\_row(buffer\_ptr, (JBLOCKROW)workspace, (JDIMENSION)1); /\* Update DC values \*/ if (block\_num == cinfo->master->first\_MCU\_col[ci] && block\_num < last\_block\_column) { DC04 = (int)prev\_prev\_block\_row[1][0]; DC09 = (int)prev\_block\_row[1][0]; DC14 = (int)buffer\_ptr[1][0]; DC19 = (int)next\_block\_row[1][0]; DC24 = (int)next\_next\_block\_row[1][0]; } if (block\_num < last\_block\_column - 1) { DC05 = (int)prev\_prev\_block\_row[2][0]; DC10 = (int)prev\_block\_row[2][0]; DC15 = (int)buffer\_ptr[2][0]; DC20 = (int)next\_block\_row[2][0]; DC25 = (int)next\_next\_block\_row[2][0]; } /\* If DC interpolation is enabled, compute coefficient estimates using \* a Gaussian-like kernel, keeping the averages of the DC values. \* \* If DC interpolation is disabled, compute coefficient estimates using \* an algorithm similar to the one described in Section K.8 of the JPEG \* standard, except applied to a 5x5 window rather than a 3x3 window. \* \* An estimate is applied only if the coefficient is still zero and is \* not known to be fully accurate. \*/ /\* AC01 \*/ if ((Al = coef\_bits[1]) != 0 && workspace[1] == 0) { num = Q00 \* (change\_dc ? (-DC01 - DC02 + DC04 + DC05 - 3 \* DC06 + 13 \* DC07 - 13 \* DC09 + 3 \* DC10 - 3 \* DC11 + 38 \* DC12 - 38 \* DC14 + 3 \* DC15 - 3 \* DC16 + 13 \* DC17 - 13 \* DC19 + 3 \* DC20 - DC21 - DC22 + DC24 + DC25) : (-7 \* DC11 + 50 \* DC12 - 50 \* DC14 + 7 \* DC15)); if (num >= 0) { pred = (int)(((Q01 << 7) + num) / (Q01 << 8)); if (Al > 0 && pred >= (1 << Al)) pred = (1 << Al) - 1; } else { pred = (int)(((Q01 << 7) - num) / (Q01 << 8)); if (Al > 0 && pred >= (1 << Al)) pred = (1 << Al) - 1; pred = -pred; } workspace[1] = (JCOEF)pred; } /\* AC10 \*/ if ((Al = coef\_bits[2]) != 0 && workspace[8] == 0) { num = Q00 \* (change\_dc ? (-DC01 - 3 \* DC02 - 3 \* DC03 - 3 \* DC04 - DC05 - DC06 + 13 \* DC07 + 38 \* DC08 + 13 \* DC09 - DC10 + DC16 - 13 \* DC17 - 38 \* DC18 - 13 \* DC19 + DC20 + DC21 + 3 \* DC22 + 3 \* DC23 + 3 \* DC24 + DC25) : (-7 \* DC03 + 50 \* DC08 - 50 \* DC18 + 7 \* DC23)); if (num >= 0) { pred = (int)(((Q10 << 7) + num) / (Q10 << 8)); if (Al > 0 && pred >= (1 << Al)) pred = (1 << Al) - 1; } else { pred = (int)(((Q10 << 7) - num) / (Q10 << 8)); if (Al > 0 && pred >= (1 << Al)) pred = (1 << Al) - 1; pred = -pred; } workspace[8] = (JCOEF)pred; } /\* AC20 \*/ if ((Al = coef\_bits[3]) != 0 && workspace[16] == 0) { num = Q00 \* (change\_dc ? (DC03 + 2 \* DC07 + 7 \* DC08 + 2 \* DC09 - 5 \* DC12 - 14 \* DC13 - 5 \* DC14 + 2 \* DC17 + 7 \* DC18 + 2 \* DC19 + DC23) : (-DC03 + 13 \* DC08 - 24 \* DC13 + 13 \* DC18 - DC23)); if (num >= 0) { pred = (int)(((Q20 << 7) + num) / (Q20 << 8)); if (Al > 0 && pred >= (1 << Al)) pred = (1 << Al) - 1; } else { pred = (int)(((Q20 << 7) - num) / (Q20 << 8)); if (Al > 0 && pred >= (1 << Al)) pred = (1 << Al) - 1; pred = -pred; } workspace[16] = (JCOEF)pred; } /\* AC11 \*/ if ((Al = coef\_bits[4]) != 0 && workspace[9] == 0) { num = Q00 \* (change\_dc ? (-DC01 + DC05 + 9 \* DC07 - 9 \* DC09 - 9 \* DC17 + 9 \* DC19 + DC21 - DC25) : (DC10 + DC16 - 10 \* DC17 + 10 \* DC19 - DC02 - DC20 + DC22 - DC24 + DC04 - DC06 + 10 \* DC07 - 10 \* DC09)); if (num >= 0) { pred = (int)(((Q11 << 7) + num) / (Q11 << 8)); if (Al > 0 && pred >= (1 << Al)) pred = (1 << Al) - 1; } else { pred = (int)(((Q11 << 7) - num) / (Q11 << 8)); if (Al > 0 && pred >= (1 << Al)) pred = (1 << Al) - 1; pred = -pred; } workspace[9] = (JCOEF)pred; } /\* AC02 \*/ if ((Al = coef\_bits[5]) != 0 && workspace[2] == 0) { num = Q00 \* (change\_dc ? (2 \* DC07 - 5 \* DC08 + 2 \* DC09 + DC11 + 7 \* DC12 - 14 \* DC13 + 7 \* DC14 + DC15 + 2 \* DC17 - 5 \* DC18 + 2 \* DC19) : (-DC11 + 13 \* DC12 - 24 \* DC13 + 13 \* DC14 - DC15)); if (num >= 0) { pred = (int)(((Q02 << 7) + num) / (Q02 << 8)); if (Al > 0 && pred >= (1 << Al)) pred = (1 << Al) - 1; } else { pred = (int)(((Q02 << 7) - num) / (Q02 << 8)); if (Al > 0 && pred >= (1 << Al)) pred = (1 << Al) - 1; pred = -pred; } workspace[2] = (JCOEF)pred; } if (change\_dc) { /\* AC03 \*/ if ((Al = coef\_bits[6]) != 0 && workspace[3] == 0) { num = Q00 \* (DC07 - DC09 + 2 \* DC12 - 2 \* DC14 + DC17 - DC19); if (num >= 0) { pred = (int)(((Q03 << 7) + num) / (Q03 << 8)); if (Al > 0 && pred >= (1 << Al)) pred = (1 << Al) - 1; } else { pred = (int)(((Q03 << 7) - num) / (Q03 << 8)); if (Al > 0 && pred >= (1 << Al)) pred = (1 << Al) - 1; pred = -pred; } workspace[3] = (JCOEF)pred; } /\* AC12 \*/ if ((Al = coef\_bits[7]) != 0 && workspace[10] == 0) { num = Q00 \* (DC07 - 3 \* DC08 + DC09 - DC17 + 3 \* DC18 - DC19); if (num >= 0) { pred = (int)(((Q12 << 7) + num) / (Q12 << 8)); if (Al > 0 && pred >= (1 << Al)) pred = (1 << Al) - 1; } else { pred = (int)(((Q12 << 7) - num) / (Q12 << 8)); if (Al > 0 && pred >= (1 << Al)) pred = (1 << Al) - 1; pred = -pred; } workspace[10] = (JCOEF)pred; } /\* AC21 \*/ if ((Al = coef\_bits[8]) != 0 && workspace[17] == 0) { num = Q00 \* (DC07 - DC09 - 3 \* DC12 + 3 \* DC14 + DC17 - DC19); if (num >= 0) { pred = (int)(((Q21 << 7) + num) / (Q21 << 8)); if (Al > 0 && pred >= (1 << Al)) pred = (1 << Al) - 1; } else { pred = (int)(((Q21 << 7) - num) / (Q21 << 8)); if (Al > 0 && pred >= (1 << Al)) pred = (1 << Al) - 1; pred = -pred; } workspace[17] = (JCOEF)pred; } /\* AC30 \*/ if ((Al = coef\_bits[9]) != 0 && workspace[24] == 0) { num = Q00 \* (DC07 + 2 \* DC08 + DC09 - DC17 - 2 \* DC18 - DC19); if (num >= 0) { pred = (int)(((Q30 << 7) + num) / (Q30 << 8)); if (Al > 0 && pred >= (1 << Al)) pred = (1 << Al) - 1; } else { pred = (int)(((Q30 << 7) - num) / (Q30 << 8)); if (Al > 0 && pred >= (1 << Al)) pred = (1 << Al) - 1; pred = -pred; } workspace[24] = (JCOEF)pred; } /\* coef\_bits[0] is non-negative. Otherwise this function would not \* be called. \*/ num = Q00 \* (-2 \* DC01 - 6 \* DC02 - 8 \* DC03 - 6 \* DC04 - 2 \* DC05 - 6 \* DC06 + 6 \* DC07 + 42 \* DC08 + 6 \* DC09 - 6 \* DC10 - 8 \* DC11 + 42 \* DC12 + 152 \* DC13 + 42 \* DC14 - 8 \* DC15 - 6 \* DC16 + 6 \* DC17 + 42 \* DC18 + 6 \* DC19 - 6 \* DC20 - 2 \* DC21 - 6 \* DC22 - 8 \* DC23 - 6 \* DC24 - 2 \* DC25); if (num >= 0) { pred = (int)(((Q00 << 7) + num) / (Q00 << 8)); } else { pred = (int)(((Q00 << 7) - num) / (Q00 << 8)); pred = -pred; } workspace[0] = (JCOEF)pred; } /\* change\_dc \*/
 /\* OK, do the IDCT \*/ (\*inverse\_DCT) (cinfo, compptr, (JCOEFPTR)workspace, output\_ptr, output\_col); /\* Advance for next column \*/ DC01 = DC02; DC02 = DC03; DC03 = DC04; DC04 = DC05; DC06 = DC07; DC07 = DC08; DC08 = DC09; DC09 = DC10; DC11 = DC12; DC12 = DC13; DC13 = DC14; DC14 = DC15; DC16 = DC17; DC17 = DC18; DC18 = DC19; DC19 = DC20; DC21 = DC22; DC22 = DC23; DC23 = DC24; DC24 = DC25; buffer\_ptr++, prev\_block\_row++, next\_block\_row++, prev\_prev\_block\_row++, next\_next\_block\_row++; output\_col += compptr->\_DCT\_scaled\_size; } output\_ptr += compptr->\_DCT\_scaled\_size; } }
 if (++(cinfo->output\_iMCU\_row) < cinfo->total\_iMCU\_rows) return JPEG\_ROW\_COMPLETED; return JPEG\_SCAN\_COMPLETED;}
#endif /\* BLOCK\_SMOOTHING\_SUPPORTED \*/
/\* \* Initialize coefficient buffer controller. \*/
GLOBAL(void)jinit\_d\_coef\_controller(j\_decompress\_ptr cinfo, boolean need\_full\_buffer){ my\_coef\_ptr coef;
 coef = (my\_coef\_ptr) (\*cinfo->mem->alloc\_small) ((j\_common\_ptr)cinfo, JPOOL\_IMAGE, sizeof(my\_coef\_controller)); cinfo->coef = (struct jpeg\_d\_coef\_controller \*)coef; coef->pub.start\_input\_pass = start\_input\_pass; coef->pub.start\_output\_pass = start\_output\_pass;#ifdef BLOCK\_SMOOTHING\_SUPPORTED coef->coef\_bits\_latch = NULL;#endif
 /\* Create the coefficient buffer. \*/ if (need\_full\_buffer) {#ifdef D\_MULTISCAN\_FILES\_SUPPORTED /\* Allocate a full-image virtual array for each component, \*/ /\* padded to a multiple of samp\_factor DCT blocks in each direction. \*/ /\* Note we ask for a pre-zeroed array. \*/ int ci, access\_rows; jpeg\_component\_info \*compptr;
 for (ci = 0, compptr = cinfo->comp\_info; ci < cinfo->num\_components; ci++, compptr++) { access\_rows = compptr->v\_samp\_factor;#ifdef BLOCK\_SMOOTHING\_SUPPORTED /\* If block smoothing could be used, need a bigger window \*/ if (cinfo->progressive\_mode) access\_rows \*= 5;#endif coef->whole\_image[ci] = (\*cinfo->mem->request\_virt\_barray) ((j\_common\_ptr)cinfo, JPOOL\_IMAGE, TRUE, (JDIMENSION)jround\_up((long)compptr->width\_in\_blocks, (long)compptr->h\_samp\_factor), (JDIMENSION)jround\_up((long)compptr->height\_in\_blocks, (long)compptr->v\_samp\_factor), (JDIMENSION)access\_rows); } coef->pub.consume\_data = consume\_data; coef->pub.decompress\_data = decompress\_data; coef->pub.coef\_arrays = coef->whole\_image; /\* link to virtual arrays \*/#else ERREXIT(cinfo, JERR\_NOT\_COMPILED);#endif } else { /\* We only need a single-MCU buffer. \*/ JBLOCKROW buffer; int i;
 buffer = (JBLOCKROW) (\*cinfo->mem->alloc\_large) ((j\_common\_ptr)cinfo, JPOOL\_IMAGE, D\_MAX\_BLOCKS\_IN\_MCU \* sizeof(JBLOCK)); for (i = 0; i < D\_MAX\_BLOCKS\_IN\_MCU; i++) { coef->MCU\_buffer[i] = buffer + i; } coef->pub.consume\_data = dummy\_consume\_data; coef->pub.decompress\_data = decompress\_onepass; coef->pub.coef\_arrays = NULL; /\* flag for no virtual arrays \*/ }
 /\* Allocate the workspace buffer \*/ coef->workspace = (JCOEF \*) (\*cinfo->mem->alloc\_small) ((j\_common\_ptr)cinfo, JPOOL\_IMAGE, sizeof(JCOEF) \* DCTSIZE2);}

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

