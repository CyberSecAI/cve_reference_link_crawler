Based on the provided information, here's an analysis of the vulnerability:

**Root Cause:**

The root cause lies in the way the kernel handles CPU hotplugging in conjunction with Kernel Address Sanitizer (KASAN) and Shadow Call Stacks (SCS). When a CPU is hot-unplugged, the idle task's stack frames and SCS state are not properly reset. This leads to stale KASAN shadow and an invalid saved SCS SP.

**Weaknesses/Vulnerabilities Present:**

1.  **Stale KASAN Poisoning:** When a CPU is offlined, the KASAN shadow for the active stack frames is not cleared, potentially causing KASAN to report false warnings when the CPU is brought back online and the memory is reused. This can lead to incorrect debugging information and potential misdiagnosis.
2.  **Stale SCS SP:** The saved Shadow Call Stack (SCS) Stack Pointer (SP) of the idle task is left pointing to an arbitrary location in the shadow call stack after CPU offlining. This causes a memory leak, where a part of the shadow call stack becomes unusable and may cause issues or prevent correct execution across multiple hotplug cycles.

**Impact of Exploitation:**

*   **Bogus KASAN warnings:** Stale KASAN shadow can cause false positive warnings, making debugging more difficult.
*   **Memory Leak/Corruption:** A stale SCS SP leads to a memory leak, and over multiple hotplug cycles the entire shadow call stack may become unusable. This can also lead to memory corruption issues.
*   **Unpredictable Behavior:** The issues described above could lead to system instability or unpredictable behavior after multiple CPU hotplug cycles.

**Attack Vectors:**

*   The vulnerability is triggered by the act of hot-unplugging and then hot-plugging a CPU back into the system. An attacker could potentially exploit the issue by repeatedly hot-unplugging and hot-plugging CPUs.

**Required Attacker Capabilities/Position:**

*   The attacker needs to have the ability to hot-unplug and hot-plug CPUs. This typically requires root or administrator privileges.

**Technical Details:**

*   The issue was caused due to refactoring where KASAN and SCS cleanup was moved to a one-time idle thread initialization code, instead of before each CPU online event.
*   The fix involves resetting the SCS SP and KASAN shadow of a CPU's idle task immediately before it's onlined using `scs_task_reset(idle)` and `kasan_unpoison_task_stack(idle)` within the `bringup_cpu()` function.
*   The fix also removes the need for special initialization for the idle thread within `init_idle()` and during `idle_task_exit()`.
*   The commit includes changes in `kernel/cpu.c` and `kernel/sched/core.c`.

**Additional Notes:**

*   The issue was tested on arm64 architecture with specific gcc and clang versions with KASAN and Shadow Call Stack features enabled.
*   The fix has been tested by offlining and onlining CPUs using the sysfs interface.
*   The original commits that introduced the issue were `f1a0a376ca0c4ef1` ("sched/core: Initialize the idle task with preemption disabled").

This information provides more detail than what a typical CVE description would contain.