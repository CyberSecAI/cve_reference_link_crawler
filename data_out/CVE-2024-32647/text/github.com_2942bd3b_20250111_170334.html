
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fblob%2Fcedf7087e68e67c7bfbd47ae95dcb16b81ad2e02%2Fvyper%2Fbuiltins%2Ffunctions.py)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fblob%2Fcedf7087e68e67c7bfbd47ae95dcb16b81ad2e02%2Fvyper%2Fbuiltins%2Ffunctions.py)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=vyperlang%2Fvyper)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[vyperlang](/vyperlang)
/
**[vyper](/vyperlang/vyper)**
Public

* [Notifications](/login?return_to=%2Fvyperlang%2Fvyper) You must be signed in to change notification settings
* [Fork
  815](/login?return_to=%2Fvyperlang%2Fvyper)
* [Star
   4.9k](/login?return_to=%2Fvyperlang%2Fvyper)

* [Code](/vyperlang/vyper)
* [Issues
  413](/vyperlang/vyper/issues)
* [Pull requests
  84](/vyperlang/vyper/pulls)
* [Discussions](/vyperlang/vyper/discussions)
* [Actions](/vyperlang/vyper/actions)
* [Projects
  0](/vyperlang/vyper/projects)
* [Wiki](/vyperlang/vyper/wiki)
* [Security](/vyperlang/vyper/security)
* [Insights](/vyperlang/vyper/pulse)

Additional navigation options

* [Code](/vyperlang/vyper)
* [Issues](/vyperlang/vyper/issues)
* [Pull requests](/vyperlang/vyper/pulls)
* [Discussions](/vyperlang/vyper/discussions)
* [Actions](/vyperlang/vyper/actions)
* [Projects](/vyperlang/vyper/projects)
* [Wiki](/vyperlang/vyper/wiki)
* [Security](/vyperlang/vyper/security)
* [Insights](/vyperlang/vyper/pulse)

## Files

 cedf708
## Breadcrumbs

1. [vyper](/vyperlang/vyper/tree/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02)
2. /[vyper](/vyperlang/vyper/tree/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper)
3. /[builtins](/vyperlang/vyper/tree/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins)
/
# functions.py

Copy path Blame  Blame
## Latest commit

## History

[History](/vyperlang/vyper/commits/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py)2682 lines (2157 loc) · 90 KB cedf708
## Breadcrumbs

1. [vyper](/vyperlang/vyper/tree/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02)
2. /[vyper](/vyperlang/vyper/tree/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper)
3. /[builtins](/vyperlang/vyper/tree/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins)
/
# functions.py

Top
## File metadata and controls

* Code
* Blame

2682 lines (2157 loc) · 90 KB[Raw](https://github.com/vyperlang/vyper/raw/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000import hashlibimport mathimport operator
from vyper import ast as vy\_astfrom vyper.abi\_types import ABI\_Tuplefrom vyper.ast.validation import validate\_call\_argsfrom vyper.codegen.abi\_encoder import abi\_encodefrom vyper.codegen.context import Context, VariableRecordfrom vyper.codegen.core import ( STORE, IRnode, add\_ofst, bytes\_data\_ptr, calculate\_type\_for\_external\_return, check\_external\_call, clamp, clamp2, clamp\_basetype, clamp\_nonzero, copy\_bytes, dummy\_node\_for\_type, ensure\_eval\_once, ensure\_in\_memory, eval\_seq, get\_bytearray\_length, get\_type\_for\_exact\_size, ir\_tuple\_from\_args, make\_setter, promote\_signed\_int, sar, shl, shr, unwrap\_location,)from vyper.codegen.expr import Exprfrom vyper.codegen.ir\_node import Encoding, scope\_multifrom vyper.codegen.keccak256\_helper import keccak256\_helperfrom vyper.evm.address\_space import MEMORY, STORAGEfrom vyper.exceptions import ( ArgumentException, CompilerPanic, InvalidLiteral, InvalidType, StateAccessViolation, StructureException, TypeMismatch, UnfoldableNode, ZeroDivisionException,)from vyper.semantics.analysis.base import Modifiability, VarInfofrom vyper.semantics.analysis.utils import ( get\_common\_types, get\_exact\_type\_from\_node, get\_possible\_types\_from\_node, validate\_expected\_type,)from vyper.semantics.types import ( TYPE\_T, AddressT, BoolT, BytesM\_T, BytesT, DArrayT, DecimalT, HashMapT, IntegerT, KwargSettings, SArrayT, StringT, TupleT,)from vyper.semantics.types.bytestrings import \_BytestringTfrom vyper.semantics.types.shortcuts import ( BYTES4\_T, BYTES32\_T, INT128\_T, INT256\_T, UINT8\_T, UINT256\_T,)from vyper.semantics.types.utils import type\_from\_annotationfrom vyper.utils import ( DECIMAL\_DIVISOR, EIP\_170\_LIMIT, SHA3\_PER\_WORD, MemoryPositions, bytes\_to\_int, ceil32, fourbytes\_to\_int, keccak256, method\_id, method\_id\_int, vyper\_warn,)
from .\_convert import convertfrom .\_signatures import BuiltinFunctionT, process\_inputs
SHA256\_ADDRESS = 2SHA256\_BASE\_GAS = 60SHA256\_PER\_WORD\_GAS = 12
class FoldedFunctionT(BuiltinFunctionT): # Base class for nodes which should always be folded
 \_modifiability = Modifiability.CONSTANT
class TypenameFoldedFunctionT(FoldedFunctionT): # Base class for builtin functions that: # (1) take a typename as the only argument; and # (2) should always be folded. \_inputs = [("typename", TYPE\_T.any())]
 def fetch\_call\_return(self, node): type\_ = self.infer\_arg\_types(node)[0].typedef return type\_
 def infer\_arg\_types(self, node, expected\_return\_typ=None): validate\_call\_args(node, 1) input\_typedef = TYPE\_T(type\_from\_annotation(node.args[0])) return [input\_typedef]
class Floor(BuiltinFunctionT): \_id = "floor" \_inputs = [("value", DecimalT())] # TODO: maybe use int136? \_return\_type = INT256\_T
 def \_try\_fold(self, node): validate\_call\_args(node, 1) value = node.args[0].get\_folded\_value() if not isinstance(value, vy\_ast.Decimal): raise UnfoldableNode
 value = math.floor(value.value) return vy\_ast.Int.from\_node(node, value=value)
 @process\_inputs def build\_IR(self, expr, args, kwargs, context): arg = args[0] with arg.cache\_when\_complex("arg") as (b1, arg): ret = IRnode.from\_list( [ "if", ["slt", arg, 0], ["sdiv", ["sub", arg, DECIMAL\_DIVISOR - 1], DECIMAL\_DIVISOR], ["sdiv", arg, DECIMAL\_DIVISOR], ], typ=INT256\_T, ) return b1.resolve(ret)
class Ceil(BuiltinFunctionT): \_id = "ceil" \_inputs = [("value", DecimalT())] # TODO: maybe use int136? \_return\_type = INT256\_T
 def \_try\_fold(self, node): validate\_call\_args(node, 1) value = node.args[0].get\_folded\_value() if not isinstance(value, vy\_ast.Decimal): raise UnfoldableNode
 value = math.ceil(value.value) return vy\_ast.Int.from\_node(node, value=value)
 @process\_inputs def build\_IR(self, expr, args, kwargs, context): arg = args[0] with arg.cache\_when\_complex("arg") as (b1, arg): ret = IRnode.from\_list( [ "if", ["slt", arg, 0], ["sdiv", arg, DECIMAL\_DIVISOR], ["sdiv", ["add", arg, DECIMAL\_DIVISOR - 1], DECIMAL\_DIVISOR], ], typ=INT256\_T, ) return b1.resolve(ret)
class Convert(BuiltinFunctionT): \_id = "convert"
 def fetch\_call\_return(self, node): \_, target\_typedef = self.infer\_arg\_types(node)
 # note: more type conversion validation happens in convert.py return target\_typedef.typedef
 # TODO: push this down into convert.py for more consistency def infer\_arg\_types(self, node, expected\_return\_typ=None): validate\_call\_args(node, 2)
 target\_type = type\_from\_annotation(node.args[1]) value\_types = get\_possible\_types\_from\_node(node.args[0])
 # For `convert` of integer literals, we need to match type inference rules in # convert.py codegen routines. # TODO: This can probably be removed once constant folding for `convert` is implemented if len(value\_types) > 1 and all(isinstance(v, IntegerT) for v in value\_types): # Get the smallest (and unsigned if available) type for non-integer target types # (note this is different from the ordering returned by `get\_possible\_types\_from\_node`) if not isinstance(target\_type, IntegerT): value\_types = sorted(value\_types, key=lambda v: (v.is\_signed, v.bits), reverse=True) else: # filter out the target type from list of possible types value\_types = [i for i in value\_types if not target\_type.compare\_type(i)]
 value\_type = value\_types.pop()
 # block conversions between same type if target\_type.compare\_type(value\_type): raise InvalidType(f"Value and target type are both '{target\_type}'", node)
 return [value\_type, TYPE\_T(target\_type)]
 def build\_IR(self, expr, context): return convert(expr, context)
ADHOC\_SLICE\_NODE\_MACROS = ["~calldata", "~selfcode", "~extcode"]
# make sure we don't overrun the source buffer, checking for overflow:# valid inputs satisfy:# `assert !(start+length > src\_len || start+length < start`def \_make\_slice\_bounds\_check(start, length, src\_len): with start.cache\_when\_complex("start") as (b1, start): with add\_ofst(start, length).cache\_when\_complex("end") as (b2, end): arithmetic\_overflow = ["lt", end, start] buffer\_oob = ["gt", end, src\_len] ok = ["iszero", ["or", arithmetic\_overflow, buffer\_oob]] return b1.resolve(b2.resolve(["assert", ok]))
def \_build\_adhoc\_slice\_node(sub: IRnode, start: IRnode, length: IRnode, context: Context) -> IRnode: assert length.is\_literal, "typechecker failed" assert isinstance(length.value, int) # mypy hint
 dst\_typ = BytesT(length.value) # allocate a buffer for the return value np = context.new\_internal\_variable(dst\_typ)
 # `msg.data` by `calldatacopy` if sub.value == "~calldata": node = [ "seq", \_make\_slice\_bounds\_check(start, length, "calldatasize"), ["mstore", np, length], ["calldatacopy", np + 32, start, length], np, ]
 # `self.code` by `codecopy` elif sub.value == "~selfcode": node = [ "seq", \_make\_slice\_bounds\_check(start, length, "codesize"), ["mstore", np, length], ["codecopy", np + 32, start, length], np, ]
 # `<address>.code` by `extcodecopy` else: assert sub.value == "~extcode" and len(sub.args) == 1 node = [ "with", "\_extcode\_address", sub.args[0], [ "seq", \_make\_slice\_bounds\_check(start, length, ["extcodesize", "\_extcode\_address"]), ["mstore", np, length], ["extcodecopy", "\_extcode\_address", np + 32, start, length], np, ], ]
 assert isinstance(length.value, int) # mypy hint return IRnode.from\_list(node, typ=BytesT(length.value), location=MEMORY)
# note: this and a lot of other builtins could be refactored to accept any uint typeclass Slice(BuiltinFunctionT): \_id = "slice" \_inputs = [ ("b", (BYTES32\_T, BytesT.any(), StringT.any())), ("start", UINT256\_T), ("length", UINT256\_T), ]
 def fetch\_call\_return(self, node): arg\_type, \_, \_ = self.infer\_arg\_types(node)
 if isinstance(arg\_type, StringT): return\_type = StringT() else: return\_type = BytesT()
 # validate start and length are in bounds
 arg = node.args[0] start\_expr = node.args[1] length\_expr = node.args[2]
 # CMC 2022-03-22 NOTE slight code duplication with semantics/analysis/local is\_adhoc\_slice = arg.get("attr") == "code" or ( arg.get("value.id") == "msg" and arg.get("attr") == "data" )
 start\_literal = start\_expr.value if isinstance(start\_expr, vy\_ast.Int) else None length\_literal = length\_expr.value if isinstance(length\_expr, vy\_ast.Int) else None
 if not is\_adhoc\_slice: if length\_literal is not None: if length\_literal < 1: raise ArgumentException("Length cannot be less than 1", length\_expr)
 if length\_literal > arg\_type.length: raise ArgumentException(f"slice out of bounds for {arg\_type}", length\_expr)
 if start\_literal is not None: if start\_literal > arg\_type.length: raise ArgumentException(f"slice out of bounds for {arg\_type}", start\_expr) if length\_literal is not None and start\_literal + length\_literal > arg\_type.length: raise ArgumentException(f"slice out of bounds for {arg\_type}", node)
 # we know the length statically if length\_literal is not None: return\_type.set\_length(length\_literal) else: return\_type.set\_min\_length(arg\_type.length)
 return return\_type
 def infer\_arg\_types(self, node, expected\_return\_typ=None): self.\_validate\_arg\_types(node) # return a concrete type for `b` b\_type = get\_possible\_types\_from\_node(node.args[0]).pop() return [b\_type, self.\_inputs[1][1], self.\_inputs[2][1]]
 @process\_inputs def build\_IR(self, expr, args, kwargs, context): src, start, length = args
 # Handle `msg.data`, `self.code`, and `<address>.code` if src.value in ADHOC\_SLICE\_NODE\_MACROS: return \_build\_adhoc\_slice\_node(src, start, length, context)
 is\_bytes32 = src.typ == BYTES32\_T if src.location is None: # it's not a pointer; force it to be one since # copy\_bytes works on pointers. assert is\_bytes32, src src = ensure\_in\_memory(src, context)
 with src.cache\_when\_complex("src") as (b1, src), start.cache\_when\_complex("start") as ( b2, start, ), length.cache\_when\_complex("length") as (b3, length): if is\_bytes32: src\_maxlen = 32 else: src\_maxlen = src.typ.maxlen
 dst\_maxlen = length.value if length.is\_literal else src\_maxlen
 buflen = dst\_maxlen
 # add 32 bytes to the buffer size bc word access might # be unaligned (see below) if src.location == STORAGE: buflen += 32
 # Get returntype string or bytes assert isinstance(src.typ, \_BytestringT) or is\_bytes32 # TODO: try to get dst\_typ from semantic analysis if isinstance(src.typ, StringT): dst\_typ = StringT(dst\_maxlen) else: dst\_typ = BytesT(dst\_maxlen)
 # allocate a buffer for the return value buf = context.new\_internal\_variable(BytesT(buflen)) # assign it the correct return type. # (note mismatch between dst\_maxlen and buflen) dst = IRnode.from\_list(buf, typ=dst\_typ, location=MEMORY)
 dst\_data = bytes\_data\_ptr(dst)
 if is\_bytes32: src\_len = 32 src\_data = src else: src\_len = get\_bytearray\_length(src) src\_data = bytes\_data\_ptr(src)
 # general case. byte-for-byte copy if src.location == STORAGE: # because slice uses byte-addressing but storage # is word-aligned, this algorithm starts at some number # of bytes before the data section starts, and might copy # an extra word. the pseudocode is: # dst\_data = dst + 32 # copy\_dst = dst\_data - start % 32 # src\_data = src + 32 # copy\_src = src\_data + (start - start % 32) / 32 # = src\_data + (start // 32) # copy\_bytes(copy\_dst, copy\_src, length) # //set length AFTER copy because the length word has been clobbered! # mstore(src, length)
 # start at the first word-aligned address before `start` # e.g. start == byte 7 -> we start copying from byte 0 # start == byte 32 -> we start copying from byte 32 copy\_src = IRnode.from\_list( ["add", src\_data, ["div", start, 32]], location=src.location )
 # e.g. start == byte 0 -> we copy to dst\_data + 0 # start == byte 7 -> we copy to dst\_data - 7 # start == byte 33 -> we copy to dst\_data - 1 copy\_dst = IRnode.from\_list( ["sub", dst\_data, ["mod", start, 32]], location=dst.location )
 # len + (32 if start % 32 > 0 else 0) copy\_len = ["add", length, ["mul", 32, ["iszero", ["iszero", ["mod", start, 32]]]]] copy\_maxlen = buflen
 else: # all other address spaces (mem, calldata, code) we have # byte-aligned access so we can just do the easy thing, # memcopy(dst\_data, src\_data + dst\_data)
 copy\_src = add\_ofst(src\_data, start) copy\_dst = dst\_data copy\_len = length copy\_maxlen = buflen
 do\_copy = copy\_bytes(copy\_dst, copy\_src, copy\_len, copy\_maxlen)
 ret = [ "seq", \_make\_slice\_bounds\_check(start, length, src\_len), do\_copy, ["mstore", dst, length], # set length dst, # return pointer to dst ] ret = IRnode.from\_list(ret, typ=dst\_typ, location=MEMORY) return b1.resolve(b2.resolve(b3.resolve(ret)))
class Len(BuiltinFunctionT): \_id = "len" \_inputs = [("b", (StringT.any(), BytesT.any(), DArrayT.any()))] \_return\_type = UINT256\_T
 def \_try\_fold(self, node): validate\_call\_args(node, 1) arg = node.args[0].get\_folded\_value() if isinstance(arg, (vy\_ast.Str, vy\_ast.Bytes)): length = len(arg.value) elif isinstance(arg, vy\_ast.Hex): length = len(arg.bytes\_value) else: raise UnfoldableNode
 return vy\_ast.Int.from\_node(node, value=length)
 def infer\_arg\_types(self, node, expected\_return\_typ=None): self.\_validate\_arg\_types(node) # return a concrete type typ = get\_possible\_types\_from\_node(node.args[0]).pop() return [typ]
 def build\_IR(self, node, context): arg = Expr(node.args[0], context).ir\_node if arg.value == "~calldata": return IRnode.from\_list(["calldatasize"], typ=UINT256\_T) return get\_bytearray\_length(arg)
class Concat(BuiltinFunctionT): \_id = "concat"
 def fetch\_call\_return(self, node): arg\_types = self.infer\_arg\_types(node)
 length = 0 for arg\_t in arg\_types: length += arg\_t.length
 if isinstance(arg\_types[0], (StringT)): return\_type = StringT() else: return\_type = BytesT() return\_type.set\_length(length) return return\_type
 def infer\_arg\_types(self, node, expected\_return\_typ=None): if len(node.args) < 2: raise ArgumentException("Invalid argument count: expected at least 2", node)
 if node.keywords: raise ArgumentException("Keyword arguments are not accepted here", node.keywords[0])
 ret = [] prev\_typeclass = None for arg in node.args: validate\_expected\_type(arg, (BytesT.any(), StringT.any(), BytesM\_T.any())) arg\_t = get\_possible\_types\_from\_node(arg).pop() current\_typeclass = "String" if isinstance(arg\_t, StringT) else "Bytes" if prev\_typeclass and current\_typeclass != prev\_typeclass: raise TypeMismatch( ( "Concat expects consistent use of string or bytes types, " "use either string or bytes." ), arg, ) prev\_typeclass = current\_typeclass ret.append(arg\_t)
 return ret
 def build\_IR(self, expr, context): args = [Expr(arg, context).ir\_node for arg in expr.args] if len(args) < 2: raise StructureException("Concat expects at least two arguments", expr)
 # Maximum length of the output dst\_maxlen = sum( [arg.typ.maxlen if isinstance(arg.typ, \_BytestringT) else arg.typ.m for arg in args] )
 # TODO: try to grab these from semantic analysis if isinstance(args[0].typ, StringT): ret\_typ = StringT(dst\_maxlen) else: ret\_typ = BytesT(dst\_maxlen)
 # respect API of copy\_bytes bufsize = dst\_maxlen + 32 buf = context.new\_internal\_variable(BytesT(bufsize))
 # Node representing the position of the output in memory dst = IRnode.from\_list(buf, typ=ret\_typ, location=MEMORY, annotation="concat destination")
 ret = ["seq"] # stack item representing our current offset in the dst buffer ofst = "concat\_ofst"
 # TODO: optimize for the case where all lengths are statically known. for arg in args: dst\_data = add\_ofst(bytes\_data\_ptr(dst), ofst)
 if isinstance(arg.typ, \_BytestringT): # Ignore empty strings if arg.typ.maxlen == 0: continue
 with arg.cache\_when\_complex("arg") as (b1, arg): argdata = bytes\_data\_ptr(arg)
 with get\_bytearray\_length(arg).cache\_when\_complex("len") as (b2, arglen): do\_copy = [ "seq", copy\_bytes(dst\_data, argdata, arglen, arg.typ.maxlen), ["set", ofst, ["add", ofst, arglen]], ] ret.append(b1.resolve(b2.resolve(do\_copy)))
 else: ret.append(STORE(dst\_data, unwrap\_location(arg))) ret.append(["set", ofst, ["add", ofst, arg.typ.m]])
 ret.append(STORE(dst, ofst))
 # Memory location of the output ret.append(dst)
 return IRnode.from\_list( ["with", ofst, 0, ret], typ=ret\_typ, location=MEMORY, annotation="concat" )
class Keccak256(BuiltinFunctionT): \_id = "keccak256" # TODO allow any BytesM\_T \_inputs = [("value", (BytesT.any(), BYTES32\_T, StringT.any()))] \_return\_type = BYTES32\_T
 def \_try\_fold(self, node): validate\_call\_args(node, 1) value = node.args[0].get\_folded\_value() if isinstance(value, vy\_ast.Bytes): value = value.value elif isinstance(value, vy\_ast.Str): value = value.value.encode() elif isinstance(value, vy\_ast.Hex): value = value.bytes\_value else: raise UnfoldableNode
 hash\_ = f"0x{keccak256(value).hex()}" return vy\_ast.Hex.from\_node(node, value=hash\_)
 def infer\_arg\_types(self, node, expected\_return\_typ=None): self.\_validate\_arg\_types(node) # return a concrete type for `value` value\_type = get\_possible\_types\_from\_node(node.args[0]).pop() return [value\_type]
 @process\_inputs def build\_IR(self, expr, args, kwargs, context): assert len(args) == 1 return keccak256\_helper(args[0], context)
def \_make\_sha256\_call(inp\_start, inp\_len, out\_start, out\_len): return [ "assert", [ "staticcall", ["gas"], # gas SHA256\_ADDRESS, # address inp\_start, inp\_len, out\_start, out\_len, ], ]
class Sha256(BuiltinFunctionT): \_id = "sha256" \_inputs = [("value", (BYTES32\_T, BytesT.any(), StringT.any()))] \_return\_type = BYTES32\_T
 def \_try\_fold(self, node): validate\_call\_args(node, 1) value = node.args[0].get\_folded\_value() if isinstance(value, vy\_ast.Bytes): value = value.value elif isinstance(value, vy\_ast.Str): value = value.value.encode() elif isinstance(value, vy\_ast.Hex): value = value.bytes\_value else: raise UnfoldableNode
 hash\_ = f"0x{hashlib.sha256(value).hexdigest()}" return vy\_ast.Hex.from\_node(node, value=hash\_)
 def infer\_arg\_types(self, node, expected\_return\_typ=None): self.\_validate\_arg\_types(node) # return a concrete type for `value` value\_type = get\_possible\_types\_from\_node(node.args[0]).pop() return [value\_type]
 @process\_inputs def build\_IR(self, expr, args, kwargs, context): sub = args[0] # bytes32 input if sub.typ == BYTES32\_T: return IRnode.from\_list( [ "seq", ["mstore", MemoryPositions.FREE\_VAR\_SPACE, sub], \_make\_sha256\_call( inp\_start=MemoryPositions.FREE\_VAR\_SPACE, inp\_len=32, out\_start=MemoryPositions.FREE\_VAR\_SPACE, out\_len=32, ), ["mload", MemoryPositions.FREE\_VAR\_SPACE], # push value onto stack ], typ=BYTES32\_T, add\_gas\_estimate=SHA256\_BASE\_GAS + 1 \* SHA256\_PER\_WORD\_GAS, ) # bytearay-like input # special case if it's already in memory sub = ensure\_in\_memory(sub, context)
 return IRnode.from\_list( [ "with", "\_sub", sub, [ "seq", \_make\_sha256\_call( # TODO use add\_ofst if sub is statically known inp\_start=["add", "\_sub", 32], inp\_len=["mload", "\_sub"], out\_start=MemoryPositions.FREE\_VAR\_SPACE, out\_len=32, ), ["mload", MemoryPositions.FREE\_VAR\_SPACE], ], ], typ=BYTES32\_T, add\_gas\_estimate=SHA256\_BASE\_GAS + sub.typ.maxlen \* SHA256\_PER\_WORD\_GAS, )
class MethodID(FoldedFunctionT): \_id = "method\_id" \_inputs = [("value", StringT.any())] \_kwargs = {"output\_type": KwargSettings(TYPE\_T.any(), BytesT(4))}
 def \_try\_fold(self, node): validate\_call\_args(node, 1, ["output\_type"])
 value = node.args[0].get\_folded\_value() if not isinstance(value, vy\_ast.Str): raise InvalidType("method id must be given as a literal string", node.args[0]) if " " in value.value: raise InvalidLiteral("Invalid function signature - no spaces allowed.", node.args[0])
 return\_type = self.infer\_kwarg\_types(node)["output\_type"].typedef value = method\_id(value.value)
 if return\_type.compare\_type(BYTES4\_T): return vy\_ast.Hex.from\_node(node, value="0x" + value.hex()) else: return vy\_ast.Bytes.from\_node(node, value=value)
 def fetch\_call\_return(self, node): validate\_call\_args(node, 1, ["output\_type"])
 type\_ = self.infer\_kwarg\_types(node)["output\_type"].typedef return type\_
 def infer\_arg\_types(self, node, expected\_return\_typ=None): return [self.\_inputs[0][1]]
 def infer\_kwarg\_types(self, node): if node.keywords: output\_type = type\_from\_annotation(node.keywords[0].value) if output\_type not in (BytesT(4), BYTES4\_T): raise ArgumentException("output\_type must be Bytes[4] or bytes4", node.keywords[0]) else: # default to `Bytes[4]` output\_type = BytesT(4)
 return {"output\_type": TYPE\_T(output\_type)}
class ECRecover(BuiltinFunctionT): \_id = "ecrecover" \_inputs = [ ("hash", BYTES32\_T), ("v", (UINT256\_T, UINT8\_T)), ("r", (UINT256\_T, BYTES32\_T)), ("s", (UINT256\_T, BYTES32\_T)), ] \_return\_type = AddressT()
 def infer\_arg\_types(self, node, expected\_return\_typ=None): self.\_validate\_arg\_types(node) v\_t, r\_t, s\_t = [get\_possible\_types\_from\_node(arg).pop() for arg in node.args[1:]] return [BYTES32\_T, v\_t, r\_t, s\_t]
 @process\_inputs def build\_IR(self, expr, args, kwargs, context): input\_buf = context.new\_internal\_variable(get\_type\_for\_exact\_size(128)) output\_buf = context.new\_internal\_variable(get\_type\_for\_exact\_size(32)) return IRnode.from\_list( [ "seq", # clear output memory first, ecrecover can return 0 bytes ["mstore", output\_buf, 0], ["mstore", input\_buf, args[0]], ["mstore", input\_buf + 32, args[1]], ["mstore", input\_buf + 64, args[2]], ["mstore", input\_buf + 96, args[3]], ["staticcall", "gas", 1, input\_buf, 128, output\_buf, 32], ["mload", output\_buf], ], typ=AddressT(), )
class \_ECArith(BuiltinFunctionT): @process\_inputs def build\_IR(self, expr, \_args, kwargs, context): args\_tuple = ir\_tuple\_from\_args(\_args)
 args\_t = args\_tuple.typ input\_buf = IRnode.from\_list( context.new\_internal\_variable(args\_t), typ=args\_t, location=MEMORY ) ret\_t = self.\_return\_type
 ret = ["seq"] ret.append(make\_setter(input\_buf, args\_tuple))
 output\_buf = context.new\_internal\_variable(ret\_t)
 args\_ofst = input\_buf args\_len = args\_t.memory\_bytes\_required out\_ofst = output\_buf out\_len = ret\_t.memory\_bytes\_required
 ret.append( [ "assert", ["staticcall", ["gas"], self.\_precompile, args\_ofst, args\_len, out\_ofst, out\_len], ] ) ret.append(output\_buf)
 return IRnode.from\_list(ret, typ=ret\_t, location=MEMORY)
class ECAdd(\_ECArith): \_id = "ecadd" \_inputs = [("a", SArrayT(UINT256\_T, 2)), ("b", SArrayT(UINT256\_T, 2))] \_return\_type = SArrayT(UINT256\_T, 2) \_precompile = 0x6
class ECMul(\_ECArith): \_id = "ecmul" \_inputs = [("point", SArrayT(UINT256\_T, 2)), ("scalar", UINT256\_T)] \_return\_type = SArrayT(UINT256\_T, 2) \_precompile = 0x7
def \_generic\_element\_getter(op): def f(index): return IRnode.from\_list( [op, ["add", "\_sub", ["add", 32, ["mul", 32, index]]]], typ=INT128\_T )
 return f
def \_storage\_element\_getter(index): return IRnode.from\_list(["sload", ["add", "\_sub", ["add", 1, index]]], typ=INT128\_T)
class Extract32(BuiltinFunctionT): \_id = "extract32" \_inputs = [("b", BytesT.any()), ("start", IntegerT.unsigneds())] \_kwargs = {"output\_type": KwargSettings(TYPE\_T.any(), BYTES32\_T)}
 def fetch\_call\_return(self, node): self.\_validate\_arg\_types(node) return\_type = self.infer\_kwarg\_types(node)["output\_type"].typedef return return\_type
 def infer\_arg\_types(self, node, expected\_return\_typ=None): self.\_validate\_arg\_types(node) input\_type = get\_possible\_types\_from\_node(node.args[0]).pop() return [input\_type, UINT256\_T]
 def infer\_kwarg\_types(self, node): if node.keywords: output\_type = type\_from\_annotation(node.keywords[0].value) if not isinstance(output\_type, (AddressT, BytesM\_T, IntegerT)): raise InvalidType( "Output type must be one of integer, bytes32 or address", node.keywords[0].value ) output\_typedef = TYPE\_T(output\_type) node.keywords[0].value.\_metadata["type"] = output\_typedef else: output\_typedef = TYPE\_T(BYTES32\_T)
 return {"output\_type": output\_typedef}
 @process\_inputs def build\_IR(self, expr, args, kwargs, context): sub, index = args ret\_type = kwargs["output\_type"]
 # Get length and specific element if sub.location == STORAGE: lengetter = IRnode.from\_list(["sload", "\_sub"], typ=INT128\_T) elementgetter = \_storage\_element\_getter
 else: op = sub.location.load\_op lengetter = IRnode.from\_list([op, "\_sub"], typ=INT128\_T) elementgetter = \_generic\_element\_getter(op)
 # TODO rewrite all this with cache\_when\_complex and bitshifts
 # Special case: index known to be a multiple of 32 if isinstance(index.value, int) and not index.value % 32: o = IRnode.from\_list( [ "with", "\_sub", sub, elementgetter( ["div", clamp2(0, index, ["sub", lengetter, 32], signed=True), 32] ), ], typ=ret\_type, annotation="extracting 32 bytes", ) # General case else: o = IRnode.from\_list( [ "with", "\_sub", sub, [ "with", "\_len", lengetter, [ "with", "\_index", clamp2(0, index, ["sub", "\_len", 32], signed=True), [ "with", "\_mi32", ["mod", "\_index", 32], [ "with", "\_di32", ["div", "\_index", 32], [ "if", "\_mi32", [ "add", ["mul", elementgetter("\_di32"), ["exp", 256, "\_mi32"]], [ "div", elementgetter(["add", "\_di32", 1]), ["exp", 256, ["sub", 32, "\_mi32"]], ], ], elementgetter("\_di32"), ], ], ], ], ], ], typ=ret\_type, annotation="extract32", ) return IRnode.from\_list(clamp\_basetype(o), typ=ret\_type)
class AsWeiValue(BuiltinFunctionT): \_id = "as\_wei\_value" \_inputs = [("value", (IntegerT.any(), DecimalT())), ("unit", StringT.any())] \_return\_type = UINT256\_T
 wei\_denoms = { ("wei",): 1, ("femtoether", "kwei", "babbage"): 10\*\*3, ("picoether", "mwei", "lovelace"): 10\*\*6, ("nanoether", "gwei", "shannon"): 10\*\*9, ("microether", "szabo"): 10\*\*12, ("milliether", "finney"): 10\*\*15, ("ether",): 10\*\*18, ("kether", "grand"): 10\*\*21, }
 def get\_denomination(self, node): value = node.args[1].get\_folded\_value() if not isinstance(value, vy\_ast.Str): raise ArgumentException( "Wei denomination must be given as a literal string", node.args[1] ) try: denom = next(v for k, v in self.wei\_denoms.items() if value.value in k) except StopIteration: raise ArgumentException(f"Unknown denomination: {value.value}", node.args[1]) from None
 return denom
 def \_try\_fold(self, node): validate\_call\_args(node, 2) denom = self.get\_denomination(node)
 value = node.args[0].get\_folded\_value() if not isinstance(value, (vy\_ast.Decimal, vy\_ast.Int)): raise UnfoldableNode value = value.value
 if value < 0:[View remainder of file in raw view](https://github.com/vyperlang/vyper/raw/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

