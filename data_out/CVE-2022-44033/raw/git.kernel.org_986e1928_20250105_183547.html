<!DOCTYPE html>
<html lang='en'>
<head>
<title>char: pcmcia: remove all the drivers - kernel/git/torvalds/linux.git - Linux kernel source tree</title>
<meta name='generator' content='cgit 1.2.3-korg'/>
<meta name='robots' content='noindex, nofollow'/>
<link rel='stylesheet' type='text/css' href='/cgit-data/cgit.css'/>
<script type='text/javascript' src='/cgit-data/cgit.js'></script>
<link rel='shortcut icon' href='/favicon.ico'/>
<link rel='alternate' title='Atom feed' href='https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/atom/?h=master' type='application/atom+xml'/>
<link rel='vcs-git' href='git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git' title='kernel/git/torvalds/linux.git Git repository'/>
<link rel='vcs-git' href='https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git' title='kernel/git/torvalds/linux.git Git repository'/>
<link rel='vcs-git' href='https://kernel.googlesource.com/pub/scm/linux/kernel/git/torvalds/linux.git' title='kernel/git/torvalds/linux.git Git repository'/>
</head>
<body>
<div id='cgit'><table id='header'>
<tr>
<td class='logo' rowspan='2'><a href='/'><img src='/cgit-data/cgit.png' alt='cgit logo'/></a></td>
<td class='main'><a href='/'>index</a> : <a href='/pub/scm/linux/kernel/git/torvalds/linux.git/'>kernel/git/torvalds/linux.git</a></td><td class='form'><form method='get'>
<input type='hidden' name='id' value='9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'/><select name='h' onchange='this.form.submit();'>
<option value='for-next'>for-next</option>
<option value='master' selected='selected'>master</option>
<option value='vsnprintf'>vsnprintf</option>
</select> <input type='submit' value='switch'/></form></td></tr>
<tr><td class='sub'>Linux kernel source tree</td><td class='sub right'>Linus Torvalds</td></tr></table>
<table class='tabs'><tr><td>
<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/about/'>about</a><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/'>summary</a><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/refs/?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>refs</a><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/log/'>log</a><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>tree</a><a class='active' href='/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>commit</a><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>diff</a><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/stats/'>stats</a></td><td class='form'><form class='right' method='get' action='/pub/scm/linux/kernel/git/torvalds/linux.git/log/'>
<input type='hidden' name='id' value='9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'/><select name='qt'>
<option value='grep'>log msg</option>
<option value='author'>author</option>
<option value='committer'>committer</option>
<option value='range'>range</option>
</select>
<input class='txt' type='search' size='10' name='q' value=''/>
<input type='submit' value='search'/>
</form>
</td></tr></table>
<div class='content'><div class='cgit-panel'><b>diff options</b><form method='get'><input type='hidden' name='id' value='9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'/><table><tr><td colspan='2'/></tr><tr><td class='label'>context:</td><td class='ctrl'><select name='context' onchange='this.form.submit();'><option value='1'>1</option><option value='2'>2</option><option value='3' selected='selected'>3</option><option value='4'>4</option><option value='5'>5</option><option value='6'>6</option><option value='7'>7</option><option value='8'>8</option><option value='9'>9</option><option value='10'>10</option><option value='15'>15</option><option value='20'>20</option><option value='25'>25</option><option value='30'>30</option><option value='35'>35</option><option value='40'>40</option></select></td></tr><tr><td class='label'>space:</td><td class='ctrl'><select name='ignorews' onchange='this.form.submit();'><option value='0' selected='selected'>include</option><option value='1'>ignore</option></select></td></tr><tr><td class='label'>mode:</td><td class='ctrl'><select name='dt' onchange='this.form.submit();'><option value='0' selected='selected'>unified</option><option value='1'>ssdiff</option><option value='2'>stat only</option></select></td></tr><tr><td/><td class='ctrl'><noscript><input type='submit' value='reload'/></noscript></td></tr></table></form></div><table summary='commit info' class='commit-info'>
<tr><th>author</th><td>Jiri Slaby &lt;jirislaby@kernel.org&gt;</td><td class='right'>2023-02-22 10:23:02 +0100</td></tr>
<tr><th>committer</th><td>Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;</td><td class='right'>2023-03-09 17:30:27 +0100</td></tr>
<tr><th>commit</th><td colspan='2' class='oid'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>9b12f050c76f090cc6d0aebe0ef76fed79ec3f15</a> (<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/patch/?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>patch</a>)</td></tr>
<tr><th>tree</th><td colspan='2' class='oid'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>11a28c1deaadf23c600d83db8e89dc9a5d13b422</a></td></tr>
<tr><th>parent</th><td colspan='2' class='oid'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=3996954fa071aa20945c8ac7694684fa3c1fed68'>3996954fa071aa20945c8ac7694684fa3c1fed68</a> (<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15&amp;id2=3996954fa071aa20945c8ac7694684fa3c1fed68'>diff</a>)</td></tr><tr><th>download</th><td colspan='2' class='oid'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-9b12f050c76f090cc6d0aebe0ef76fed79ec3f15.tar.gz'>linux-9b12f050c76f090cc6d0aebe0ef76fed79ec3f15.tar.gz</a><br/></td></tr></table>
<div class='commit-subject'>char: pcmcia: remove all the drivers</div><div class='commit-msg'>These char PCMCIA drivers are buggy[1] and receive only minimal care. It
was concluded[2], that we should try to remove most pcmcia drivers
completely. Let's start with these char broken one.

Note that I also removed a UAPI header: include/uapi/linux/cm4000_cs.h.
I found only coccinelle tests mentioning some ioctl constants from that
file. But they are not actually used. Anyway, should someone complain,
we may reintroduce the header (or its parts).

[1] https://lore.kernel.org/all/f41c2765-80e0-48bc-b1e4-8cfd3230fd4a@www.fastmail.com/
[2] https://lore.kernel.org/all/c5b39544-a4fb-4796-a046-0b9be9853787@app.fastmail.com/

Signed-off-by: Jiri Slaby (SUSE) &lt;jirislaby@kernel.org&gt;
Cc: "Hyunwoo Kim" &lt;imv4bel@gmail.com&gt;
Cc: Harald Welte &lt;laforge@gnumonks.org&gt;
Cc: Lubomir Rintel &lt;lkundrak@v3.sk&gt;
Cc: Arnd Bergmann &lt;arnd@arndb.de&gt;
Cc: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;
Acked-by: Dominik Brodowski &lt;linux@dominikbrodowski.net&gt;
Reviewed-by: Arnd Bergmann &lt;arnd@arndb.de&gt;
Link: <a href="https://lore.kernel.org/r/20230222092302.6348-2-jirislaby@kernel.org">https://lore.kernel.org/r/20230222092302.6348-2-jirislaby@kernel.org</a>
Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;
</div><div class='diffstat-header'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>Diffstat</a></div><table summary='diffstat' class='diffstat'><tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/Documentation/process/magic-number.rst?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>Documentation/process/magic-number.rst</a></td><td class='right'>1</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.0%;'/><td class='rem' style='width: 0.0%;'/><td class='none' style='width: 100.0%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/Documentation/translations/it_IT/process/magic-number.rst?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>Documentation/translations/it_IT/process/magic-number.rst</a></td><td class='right'>1</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.0%;'/><td class='rem' style='width: 0.0%;'/><td class='none' style='width: 100.0%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/Documentation/translations/sp_SP/process/magic-number.rst?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>Documentation/translations/sp_SP/process/magic-number.rst</a></td><td class='right'>1</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.0%;'/><td class='rem' style='width: 0.0%;'/><td class='none' style='width: 100.0%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/Documentation/translations/zh_CN/process/magic-number.rst?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>Documentation/translations/zh_CN/process/magic-number.rst</a></td><td class='right'>1</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.0%;'/><td class='rem' style='width: 0.0%;'/><td class='none' style='width: 100.0%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/Documentation/translations/zh_TW/process/magic-number.rst?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>Documentation/translations/zh_TW/process/magic-number.rst</a></td><td class='right'>1</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.0%;'/><td class='rem' style='width: 0.0%;'/><td class='none' style='width: 100.0%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/Documentation/userspace-api/ioctl/ioctl-number.rst?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>Documentation/userspace-api/ioctl/ioctl-number.rst</a></td><td class='right'>1</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.0%;'/><td class='rem' style='width: 0.0%;'/><td class='none' style='width: 100.0%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/MAINTAINERS?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>MAINTAINERS</a></td><td class='right'>17</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.0%;'/><td class='rem' style='width: 0.4%;'/><td class='none' style='width: 99.6%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/powerpc/configs/ppc6xx_defconfig?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>arch/powerpc/configs/ppc6xx_defconfig</a></td><td class='right'>2</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.0%;'/><td class='rem' style='width: 0.0%;'/><td class='none' style='width: 100.0%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/char/Kconfig?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>drivers/char/Kconfig</a></td><td class='right'>2</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.0%;'/><td class='rem' style='width: 0.0%;'/><td class='none' style='width: 100.0%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/char/Makefile?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>drivers/char/Makefile</a></td><td class='right'>1</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.0%;'/><td class='rem' style='width: 0.0%;'/><td class='none' style='width: 100.0%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='del'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/char/pcmcia/Kconfig?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>drivers/char/pcmcia/Kconfig</a></td><td class='right'>59</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.0%;'/><td class='rem' style='width: 1.4%;'/><td class='none' style='width: 98.6%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='del'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/char/pcmcia/Makefile?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>drivers/char/pcmcia/Makefile</a></td><td class='right'>11</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.0%;'/><td class='rem' style='width: 0.3%;'/><td class='none' style='width: 99.7%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='del'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/char/pcmcia/cm4000_cs.c?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>drivers/char/pcmcia/cm4000_cs.c</a></td><td class='right'>1912</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.0%;'/><td class='rem' style='width: 44.6%;'/><td class='none' style='width: 55.4%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='del'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/char/pcmcia/cm4040_cs.c?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>drivers/char/pcmcia/cm4040_cs.c</a></td><td class='right'>684</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.0%;'/><td class='rem' style='width: 15.9%;'/><td class='none' style='width: 84.1%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='del'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/char/pcmcia/cm4040_cs.h?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>drivers/char/pcmcia/cm4040_cs.h</a></td><td class='right'>48</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.0%;'/><td class='rem' style='width: 1.1%;'/><td class='none' style='width: 98.9%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='del'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/char/pcmcia/scr24x_cs.c?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>drivers/char/pcmcia/scr24x_cs.c</a></td><td class='right'>359</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.0%;'/><td class='rem' style='width: 8.4%;'/><td class='none' style='width: 91.6%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='del'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/char/pcmcia/synclink_cs.c?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>drivers/char/pcmcia/synclink_cs.c</a></td><td class='right'>4290</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.0%;'/><td class='rem' style='width: 100.0%;'/><td class='none' style='width: 0.0%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='del'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/linux/cm4000_cs.h?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>include/linux/cm4000_cs.h</a></td><td class='right'>11</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.0%;'/><td class='rem' style='width: 0.3%;'/><td class='none' style='width: 99.7%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='del'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/uapi/linux/cm4000_cs.h?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>include/uapi/linux/cm4000_cs.h</a></td><td class='right'>64</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.0%;'/><td class='rem' style='width: 1.5%;'/><td class='none' style='width: 98.5%;'/></tr></table></td></tr>
</table><div class='diffstat-summary'>19 files changed, 0 insertions, 7466 deletions</div><table summary='diff' class='diff'><tr><td><div class='head'>diff --git a/Documentation/process/magic-number.rst b/Documentation/process/magic-number.rst<br/>index 64b5948fc1d49d..7029c3c084ee4d 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/process/magic-number.rst?id=3996954fa071aa20945c8ac7694684fa3c1fed68'>Documentation/process/magic-number.rst</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/process/magic-number.rst?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>Documentation/process/magic-number.rst</a></div><div class='hunk'>@@ -72,7 +72,6 @@ PG_MAGIC              'P'              pg_{read,write}_hdr      ``include/linux/</div><div class='ctx'> APM_BIOS_MAGIC        0x4101           apm_user                 ``arch/x86/kernel/apm_32.c``</div><div class='ctx'> FASYNC_MAGIC          0x4601           fasync_struct            ``include/linux/fs.h``</div><div class='ctx'> SLIP_MAGIC            0x5302           slip                     ``drivers/net/slip.h``</div><div class='del'>-MGSLPC_MAGIC          0x5402           mgslpc_info              ``drivers/char/pcmcia/synclink_cs.c``</div><div class='ctx'> BAYCOM_MAGIC          0x19730510       baycom_state             ``drivers/net/baycom_epp.c``</div><div class='ctx'> HDLCDRV_MAGIC         0x5ac6e778       hdlcdrv_state            ``include/linux/hdlcdrv.h``</div><div class='ctx'> KV_MAGIC              0x5f4b565f       kernel_vars_s            ``arch/mips/include/asm/sn/klkernvars.h``</div><div class='head'>diff --git a/Documentation/translations/it_IT/process/magic-number.rst b/Documentation/translations/it_IT/process/magic-number.rst<br/>index 02eb7eb2448e77..ae92ab633c168b 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/translations/it_IT/process/magic-number.rst?id=3996954fa071aa20945c8ac7694684fa3c1fed68'>Documentation/translations/it_IT/process/magic-number.rst</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/translations/it_IT/process/magic-number.rst?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>Documentation/translations/it_IT/process/magic-number.rst</a></div><div class='hunk'>@@ -78,7 +78,6 @@ PG_MAGIC              'P'              pg_{read,write}_hdr      ``include/linux/</div><div class='ctx'> APM_BIOS_MAGIC        0x4101           apm_user                 ``arch/x86/kernel/apm_32.c``</div><div class='ctx'> FASYNC_MAGIC          0x4601           fasync_struct            ``include/linux/fs.h``</div><div class='ctx'> SLIP_MAGIC            0x5302           slip                     ``drivers/net/slip.h``</div><div class='del'>-MGSLPC_MAGIC          0x5402           mgslpc_info              ``drivers/char/pcmcia/synclink_cs.c``</div><div class='ctx'> BAYCOM_MAGIC          0x19730510       baycom_state             ``drivers/net/baycom_epp.c``</div><div class='ctx'> HDLCDRV_MAGIC         0x5ac6e778       hdlcdrv_state            ``include/linux/hdlcdrv.h``</div><div class='ctx'> KV_MAGIC              0x5f4b565f       kernel_vars_s            ``arch/mips/include/asm/sn/klkernvars.h``</div><div class='head'>diff --git a/Documentation/translations/sp_SP/process/magic-number.rst b/Documentation/translations/sp_SP/process/magic-number.rst<br/>index 2b62cec34e8e28..7c7dfb4ba80bc2 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/translations/sp_SP/process/magic-number.rst?id=3996954fa071aa20945c8ac7694684fa3c1fed68'>Documentation/translations/sp_SP/process/magic-number.rst</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/translations/sp_SP/process/magic-number.rst?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>Documentation/translations/sp_SP/process/magic-number.rst</a></div><div class='hunk'>@@ -77,7 +77,6 @@ PG_MAGIC              'P'              pg_{read,write}_hdr      ``include/linux/</div><div class='ctx'> APM_BIOS_MAGIC        0x4101           apm_user                 ``arch/x86/kernel/apm_32.c``</div><div class='ctx'> FASYNC_MAGIC          0x4601           fasync_struct            ``include/linux/fs.h``</div><div class='ctx'> SLIP_MAGIC            0x5302           slip                     ``drivers/net/slip.h``</div><div class='del'>-MGSLPC_MAGIC          0x5402           mgslpc_info              ``drivers/char/pcmcia/synclink_cs.c``</div><div class='ctx'> BAYCOM_MAGIC          0x19730510       baycom_state             ``drivers/net/baycom_epp.c``</div><div class='ctx'> HDLCDRV_MAGIC         0x5ac6e778       hdlcdrv_state            ``include/linux/hdlcdrv.h``</div><div class='ctx'> KV_MAGIC              0x5f4b565f       kernel_vars_s            ``arch/mips/include/asm/sn/klkernvars.h``</div><div class='head'>diff --git a/Documentation/translations/zh_CN/process/magic-number.rst b/Documentation/translations/zh_CN/process/magic-number.rst<br/>index 0617ce125e127b..37ed33034134d8 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/translations/zh_CN/process/magic-number.rst?id=3996954fa071aa20945c8ac7694684fa3c1fed68'>Documentation/translations/zh_CN/process/magic-number.rst</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/translations/zh_CN/process/magic-number.rst?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>Documentation/translations/zh_CN/process/magic-number.rst</a></div><div class='hunk'>@@ -61,7 +61,6 @@ PG_MAGIC              'P'              pg_{read,write}_hdr      ``include/linux/</div><div class='ctx'> APM_BIOS_MAGIC        0x4101           apm_user                 ``arch/x86/kernel/apm_32.c``</div><div class='ctx'> FASYNC_MAGIC          0x4601           fasync_struct            ``include/linux/fs.h``</div><div class='ctx'> SLIP_MAGIC            0x5302           slip                     ``drivers/net/slip.h``</div><div class='del'>-MGSLPC_MAGIC          0x5402           mgslpc_info              ``drivers/char/pcmcia/synclink_cs.c``</div><div class='ctx'> BAYCOM_MAGIC          0x19730510       baycom_state             ``drivers/net/baycom_epp.c``</div><div class='ctx'> HDLCDRV_MAGIC         0x5ac6e778       hdlcdrv_state            ``include/linux/hdlcdrv.h``</div><div class='ctx'> KV_MAGIC              0x5f4b565f       kernel_vars_s            ``arch/mips/include/asm/sn/klkernvars.h``</div><div class='head'>diff --git a/Documentation/translations/zh_TW/process/magic-number.rst b/Documentation/translations/zh_TW/process/magic-number.rst<br/>index f3f7082e17c61e..1d48e1bbf5f266 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/translations/zh_TW/process/magic-number.rst?id=3996954fa071aa20945c8ac7694684fa3c1fed68'>Documentation/translations/zh_TW/process/magic-number.rst</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/translations/zh_TW/process/magic-number.rst?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>Documentation/translations/zh_TW/process/magic-number.rst</a></div><div class='hunk'>@@ -64,7 +64,6 @@ PG_MAGIC              'P'              pg_{read,write}_hdr      ``include/linux/</div><div class='ctx'> APM_BIOS_MAGIC        0x4101           apm_user                 ``arch/x86/kernel/apm_32.c``</div><div class='ctx'> FASYNC_MAGIC          0x4601           fasync_struct            ``include/linux/fs.h``</div><div class='ctx'> SLIP_MAGIC            0x5302           slip                     ``drivers/net/slip.h``</div><div class='del'>-MGSLPC_MAGIC          0x5402           mgslpc_info              ``drivers/char/pcmcia/synclink_cs.c``</div><div class='ctx'> BAYCOM_MAGIC          0x19730510       baycom_state             ``drivers/net/baycom_epp.c``</div><div class='ctx'> HDLCDRV_MAGIC         0x5ac6e778       hdlcdrv_state            ``include/linux/hdlcdrv.h``</div><div class='ctx'> KV_MAGIC              0x5f4b565f       kernel_vars_s            ``arch/mips/include/asm/sn/klkernvars.h``</div><div class='head'>diff --git a/Documentation/userspace-api/ioctl/ioctl-number.rst b/Documentation/userspace-api/ioctl/ioctl-number.rst<br/>index 0a1882e296ae08..176e8fc3f31b93 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/userspace-api/ioctl/ioctl-number.rst?id=3996954fa071aa20945c8ac7694684fa3c1fed68'>Documentation/userspace-api/ioctl/ioctl-number.rst</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/userspace-api/ioctl/ioctl-number.rst?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>Documentation/userspace-api/ioctl/ioctl-number.rst</a></div><div class='hunk'>@@ -222,7 +222,6 @@ Code  Seq#    Include File                                           Comments</div><div class='ctx'> 'b'   00-FF                                                          conflict! bit3 vme host bridge</div><div class='ctx'>                                                                      &lt;mailto:natalia@nikhefk.nikhef.nl&gt;</div><div class='ctx'> 'b'   00-0F  linux/dma-buf.h                                         conflict!</div><div class='del'>-'c'   all    linux/cm4000_cs.h                                       conflict!</div><div class='ctx'> 'c'   00-7F  linux/comstats.h                                        conflict!</div><div class='ctx'> 'c'   00-7F  linux/coda.h                                            conflict!</div><div class='ctx'> 'c'   00-1F  linux/chio.h                                            conflict!</div><div class='head'>diff --git a/MAINTAINERS b/MAINTAINERS<br/>index 8d5bc223f3053b..64068a601e59ad 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/MAINTAINERS?id=3996954fa071aa20945c8ac7694684fa3c1fed68'>MAINTAINERS</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/MAINTAINERS?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>MAINTAINERS</a></div><div class='hunk'>@@ -15322,18 +15322,6 @@ S:	Maintained</div><div class='ctx'> F:	Documentation/filesystems/omfs.rst</div><div class='ctx'> F:	fs/omfs/</div><div class='ctx'> </div><div class='del'>-OMNIKEY CARDMAN 4000 DRIVER</div><div class='del'>-M:	Harald Welte &lt;laforge@gnumonks.org&gt;</div><div class='del'>-S:	Maintained</div><div class='del'>-F:	drivers/char/pcmcia/cm4000_cs.c</div><div class='del'>-F:	include/linux/cm4000_cs.h</div><div class='del'>-F:	include/uapi/linux/cm4000_cs.h</div><div class='del'>-</div><div class='del'>-OMNIKEY CARDMAN 4040 DRIVER</div><div class='del'>-M:	Harald Welte &lt;laforge@gnumonks.org&gt;</div><div class='del'>-S:	Maintained</div><div class='del'>-F:	drivers/char/pcmcia/cm4040_cs.*</div><div class='del'>-</div><div class='ctx'> OMNIVISION OG01A1B SENSOR DRIVER</div><div class='ctx'> M:	Shawn Tu &lt;shawnx.tu@intel.com&gt;</div><div class='ctx'> L:	linux-media@vger.kernel.org</div><div class='hunk'>@@ -18609,11 +18597,6 @@ F:	include/linux/wait.h</div><div class='ctx'> F:	include/uapi/linux/sched.h</div><div class='ctx'> F:	kernel/sched/</div><div class='ctx'> </div><div class='del'>-SCR24X CHIP CARD INTERFACE DRIVER</div><div class='del'>-M:	Lubomir Rintel &lt;lkundrak@v3.sk&gt;</div><div class='del'>-S:	Supported</div><div class='del'>-F:	drivers/char/pcmcia/scr24x_cs.c</div><div class='del'>-</div><div class='ctx'> SCSI RDMA PROTOCOL (SRP) INITIATOR</div><div class='ctx'> M:	Bart Van Assche &lt;bvanassche@acm.org&gt;</div><div class='ctx'> L:	linux-rdma@vger.kernel.org</div><div class='head'>diff --git a/arch/powerpc/configs/ppc6xx_defconfig b/arch/powerpc/configs/ppc6xx_defconfig<br/>index 1102582779599b..d8729b94400efd 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/powerpc/configs/ppc6xx_defconfig?id=3996954fa071aa20945c8ac7694684fa3c1fed68'>arch/powerpc/configs/ppc6xx_defconfig</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/powerpc/configs/ppc6xx_defconfig?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>arch/powerpc/configs/ppc6xx_defconfig</a></div><div class='hunk'>@@ -614,8 +614,6 @@ CONFIG_HW_RANDOM=y</div><div class='ctx'> CONFIG_HW_RANDOM_VIRTIO=m</div><div class='ctx'> CONFIG_NVRAM=y</div><div class='ctx'> CONFIG_DTLK=m</div><div class='del'>-CONFIG_CARDMAN_4000=m</div><div class='del'>-CONFIG_CARDMAN_4040=m</div><div class='ctx'> CONFIG_IPWIRELESS=m</div><div class='ctx'> CONFIG_I2C_CHARDEV=m</div><div class='ctx'> CONFIG_I2C_HYDRA=m</div><div class='head'>diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig<br/>index 30fe9848dac1c1..801d6c83f89616 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/Kconfig?id=3996954fa071aa20945c8ac7694684fa3c1fed68'>drivers/char/Kconfig</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/Kconfig?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>drivers/char/Kconfig</a></div><div class='hunk'>@@ -247,8 +247,6 @@ config SONYPI</div><div class='ctx'> 	  To compile this driver as a module, choose M here: the</div><div class='ctx'> 	  module will be called sonypi.</div><div class='ctx'> </div><div class='del'>-source "drivers/char/pcmcia/Kconfig"</div><div class='del'>-</div><div class='ctx'> config MWAVE</div><div class='ctx'> 	tristate "ACP Modem (Mwave) support"</div><div class='ctx'> 	depends on X86 &amp;&amp; TTY</div><div class='head'>diff --git a/drivers/char/Makefile b/drivers/char/Makefile<br/>index 1b35d1724565eb..c5f532e412f1a4 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/Makefile?id=3996954fa071aa20945c8ac7694684fa3c1fed68'>drivers/char/Makefile</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/Makefile?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15'>drivers/char/Makefile</a></div><div class='hunk'>@@ -35,7 +35,6 @@ obj-$(CONFIG_TELCLOCK)		+= tlclk.o</div><div class='ctx'> </div><div class='ctx'> obj-$(CONFIG_MWAVE)		+= mwave/</div><div class='ctx'> obj-y				+= agp/</div><div class='del'>-obj-$(CONFIG_PCMCIA)		+= pcmcia/</div><div class='ctx'> </div><div class='ctx'> obj-$(CONFIG_HANGCHECK_TIMER)	+= hangcheck-timer.o</div><div class='ctx'> obj-$(CONFIG_TCG_TPM)		+= tpm/</div><div class='head'>diff --git a/drivers/char/pcmcia/Kconfig b/drivers/char/pcmcia/Kconfig<br/>deleted file mode 100644<br/>index 26724990074c87..00000000000000<br/>--- a/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/pcmcia/Kconfig?id=3996954fa071aa20945c8ac7694684fa3c1fed68'>drivers/char/pcmcia/Kconfig</a><br/>+++ /dev/null</div><div class='hunk'>@@ -1,59 +0,0 @@</div><div class='del'>-# SPDX-License-Identifier: GPL-2.0-only</div><div class='del'>-#</div><div class='del'>-# PCMCIA character device configuration</div><div class='del'>-#</div><div class='del'>-</div><div class='del'>-menu "PCMCIA character devices"</div><div class='del'>-	depends on PCMCIA!=n</div><div class='del'>-</div><div class='del'>-config SYNCLINK_CS</div><div class='del'>-	tristate "SyncLink PC Card support"</div><div class='del'>-	depends on PCMCIA &amp;&amp; TTY</div><div class='del'>-	help</div><div class='del'>-	  Enable support for the SyncLink PC Card serial adapter, running</div><div class='del'>-	  asynchronous and HDLC communications up to 512Kbps. The port is</div><div class='del'>-	  selectable for RS-232, V.35, RS-449, RS-530, and X.21</div><div class='del'>-</div><div class='del'>-	  This driver may be built as a module ( = code which can be</div><div class='del'>-	  inserted in and removed from the running kernel whenever you want).</div><div class='del'>-	  The module will be called synclink_cs.  If you want to do that, say M</div><div class='del'>-	  here.</div><div class='del'>-</div><div class='del'>-config CARDMAN_4000</div><div class='del'>-	tristate "Omnikey Cardman 4000 support"</div><div class='del'>-	depends on PCMCIA</div><div class='del'>-	select BITREVERSE</div><div class='del'>-	help</div><div class='del'>-	  Enable support for the Omnikey Cardman 4000 PCMCIA Smartcard</div><div class='del'>-	  reader.</div><div class='del'>-</div><div class='del'>-	  This kernel driver requires additional userspace support, either</div><div class='del'>-	  by the vendor-provided PC/SC ifd_handler (http://www.omnikey.com/),</div><div class='del'>-	  or via the cm4000 backend of OpenCT (http://www.opensc-project.org/opensc).</div><div class='del'>-</div><div class='del'>-config CARDMAN_4040</div><div class='del'>-	tristate "Omnikey CardMan 4040 support"</div><div class='del'>-	depends on PCMCIA</div><div class='del'>-	help</div><div class='del'>-	  Enable support for the Omnikey CardMan 4040 PCMCIA Smartcard</div><div class='del'>-	  reader.</div><div class='del'>-</div><div class='del'>-	  This card is basically a USB CCID device connected to a FIFO</div><div class='del'>-	  in I/O space.  To use the kernel driver, you will need either the</div><div class='del'>-	  PC/SC ifdhandler provided from the Omnikey homepage</div><div class='del'>-	  (http://www.omnikey.com/), or a current development version of OpenCT</div><div class='del'>-	  (http://www.opensc-project.org/opensc).</div><div class='del'>-</div><div class='del'>-config SCR24X</div><div class='del'>-	tristate "SCR24x Chip Card Interface support"</div><div class='del'>-	depends on PCMCIA</div><div class='del'>-	help</div><div class='del'>-	  Enable support for the SCR24x PCMCIA Chip Card Interface.</div><div class='del'>-</div><div class='del'>-	  To compile this driver as a module, choose M here.</div><div class='del'>-	  The module will be called scr24x_cs..</div><div class='del'>-</div><div class='del'>-	  If unsure say N.</div><div class='del'>-</div><div class='del'>-endmenu</div><div class='del'>-</div><div class='head'>diff --git a/drivers/char/pcmcia/Makefile b/drivers/char/pcmcia/Makefile<br/>deleted file mode 100644<br/>index 024eed1c4ca555..00000000000000<br/>--- a/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/pcmcia/Makefile?id=3996954fa071aa20945c8ac7694684fa3c1fed68'>drivers/char/pcmcia/Makefile</a><br/>+++ /dev/null</div><div class='hunk'>@@ -1,11 +0,0 @@</div><div class='del'>-# SPDX-License-Identifier: GPL-2.0-only</div><div class='del'>-#</div><div class='del'>-# drivers/char/pcmcia/Makefile</div><div class='del'>-#</div><div class='del'>-# Makefile for the Linux PCMCIA char device drivers.</div><div class='del'>-#</div><div class='del'>-</div><div class='del'>-obj-$(CONFIG_SYNCLINK_CS) += synclink_cs.o</div><div class='del'>-obj-$(CONFIG_CARDMAN_4000) += cm4000_cs.o</div><div class='del'>-obj-$(CONFIG_CARDMAN_4040) += cm4040_cs.o</div><div class='del'>-obj-$(CONFIG_SCR24X) += scr24x_cs.o</div><div class='head'>diff --git a/drivers/char/pcmcia/cm4000_cs.c b/drivers/char/pcmcia/cm4000_cs.c<br/>deleted file mode 100644<br/>index e656f42a28ac23..00000000000000<br/>--- a/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/pcmcia/cm4000_cs.c?id=3996954fa071aa20945c8ac7694684fa3c1fed68'>drivers/char/pcmcia/cm4000_cs.c</a><br/>+++ /dev/null</div><div class='hunk'>@@ -1,1912 +0,0 @@</div><div class='del'>- /*</div><div class='del'>-  * A driver for the PCMCIA Smartcard Reader "Omnikey CardMan Mobile 4000"</div><div class='del'>-  *</div><div class='del'>-  * cm4000_cs.c support.linux@omnikey.com</div><div class='del'>-  *</div><div class='del'>-  * Tue Oct 23 11:32:43 GMT 2001 herp - cleaned up header files</div><div class='del'>-  * Sun Jan 20 10:11:15 MET 2002 herp - added modversion header files</div><div class='del'>-  * Thu Nov 14 16:34:11 GMT 2002 mh   - added PPS functionality</div><div class='del'>-  * Tue Nov 19 16:36:27 GMT 2002 mh   - added SUSPEND/RESUME functionailty</div><div class='del'>-  * Wed Jul 28 12:55:01 CEST 2004 mh  - kernel 2.6 adjustments</div><div class='del'>-  *</div><div class='del'>-  * current version: 2.4.0gm4</div><div class='del'>-  *</div><div class='del'>-  * (C) 2000,2001,2002,2003,2004 Omnikey AG</div><div class='del'>-  *</div><div class='del'>-  * (C) 2005-2006 Harald Welte &lt;laforge@gnumonks.org&gt;</div><div class='del'>-  * 	- Adhere to Kernel process/coding-style.rst</div><div class='del'>-  * 	- Port to 2.6.13 "new" style PCMCIA</div><div class='del'>-  * 	- Check for copy_{from,to}_user return values</div><div class='del'>-  * 	- Use nonseekable_open()</div><div class='del'>-  * 	- add class interface for udev device creation</div><div class='del'>-  *</div><div class='del'>-  * All rights reserved. Licensed under dual BSD/GPL license.</div><div class='del'>-  */</div><div class='del'>-</div><div class='del'>-#include &lt;linux/kernel.h&gt;</div><div class='del'>-#include &lt;linux/module.h&gt;</div><div class='del'>-#include &lt;linux/slab.h&gt;</div><div class='del'>-#include &lt;linux/init.h&gt;</div><div class='del'>-#include &lt;linux/fs.h&gt;</div><div class='del'>-#include &lt;linux/delay.h&gt;</div><div class='del'>-#include &lt;linux/bitrev.h&gt;</div><div class='del'>-#include &lt;linux/mutex.h&gt;</div><div class='del'>-#include &lt;linux/uaccess.h&gt;</div><div class='del'>-#include &lt;linux/io.h&gt;</div><div class='del'>-</div><div class='del'>-#include &lt;pcmcia/cistpl.h&gt;</div><div class='del'>-#include &lt;pcmcia/cisreg.h&gt;</div><div class='del'>-#include &lt;pcmcia/ciscode.h&gt;</div><div class='del'>-#include &lt;pcmcia/ds.h&gt;</div><div class='del'>-</div><div class='del'>-#include &lt;linux/cm4000_cs.h&gt;</div><div class='del'>-</div><div class='del'>-/* #define ATR_CSUM */</div><div class='del'>-</div><div class='del'>-#define reader_to_dev(x)	(&amp;x-&gt;p_dev-&gt;dev)</div><div class='del'>-</div><div class='del'>-/* n (debug level) is ignored */</div><div class='del'>-/* additional debug output may be enabled by re-compiling with</div><div class='del'>- * CM4000_DEBUG set */</div><div class='del'>-/* #define CM4000_DEBUG */</div><div class='del'>-#define DEBUGP(n, rdr, x, args...) do { 		\</div><div class='del'>-		dev_dbg(reader_to_dev(rdr), "%s:" x, 	\</div><div class='del'>-			   __func__ , ## args);		\</div><div class='del'>-	} while (0)</div><div class='del'>-</div><div class='del'>-static DEFINE_MUTEX(cmm_mutex);</div><div class='del'>-</div><div class='del'>-#define	T_1SEC		(HZ)</div><div class='del'>-#define	T_10MSEC	msecs_to_jiffies(10)</div><div class='del'>-#define	T_20MSEC	msecs_to_jiffies(20)</div><div class='del'>-#define	T_40MSEC	msecs_to_jiffies(40)</div><div class='del'>-#define	T_50MSEC	msecs_to_jiffies(50)</div><div class='del'>-#define	T_100MSEC	msecs_to_jiffies(100)</div><div class='del'>-#define	T_500MSEC	msecs_to_jiffies(500)</div><div class='del'>-</div><div class='del'>-static void cm4000_release(struct pcmcia_device *link);</div><div class='del'>-</div><div class='del'>-static int major;		/* major number we get from the kernel */</div><div class='del'>-</div><div class='del'>-/* note: the first state has to have number 0 always */</div><div class='del'>-</div><div class='del'>-#define	M_FETCH_ATR	0</div><div class='del'>-#define	M_TIMEOUT_WAIT	1</div><div class='del'>-#define	M_READ_ATR_LEN	2</div><div class='del'>-#define	M_READ_ATR	3</div><div class='del'>-#define	M_ATR_PRESENT	4</div><div class='del'>-#define	M_BAD_CARD	5</div><div class='del'>-#define M_CARDOFF	6</div><div class='del'>-</div><div class='del'>-#define	LOCK_IO			0</div><div class='del'>-#define	LOCK_MONITOR		1</div><div class='del'>-</div><div class='del'>-#define IS_AUTOPPS_ACT		 6</div><div class='del'>-#define	IS_PROCBYTE_PRESENT	 7</div><div class='del'>-#define	IS_INVREV		 8</div><div class='del'>-#define IS_ANY_T0		 9</div><div class='del'>-#define	IS_ANY_T1		10</div><div class='del'>-#define	IS_ATR_PRESENT		11</div><div class='del'>-#define	IS_ATR_VALID		12</div><div class='del'>-#define	IS_CMM_ABSENT		13</div><div class='del'>-#define	IS_BAD_LENGTH		14</div><div class='del'>-#define	IS_BAD_CSUM		15</div><div class='del'>-#define	IS_BAD_CARD		16</div><div class='del'>-</div><div class='del'>-#define REG_FLAGS0(x)		(x + 0)</div><div class='del'>-#define REG_FLAGS1(x)		(x + 1)</div><div class='del'>-#define REG_NUM_BYTES(x)	(x + 2)</div><div class='del'>-#define REG_BUF_ADDR(x)		(x + 3)</div><div class='del'>-#define REG_BUF_DATA(x)		(x + 4)</div><div class='del'>-#define REG_NUM_SEND(x)		(x + 5)</div><div class='del'>-#define REG_BAUDRATE(x)		(x + 6)</div><div class='del'>-#define REG_STOPBITS(x)		(x + 7)</div><div class='del'>-</div><div class='del'>-struct cm4000_dev {</div><div class='del'>-	struct pcmcia_device *p_dev;</div><div class='del'>-</div><div class='del'>-	unsigned char atr[MAX_ATR];</div><div class='del'>-	unsigned char rbuf[512];</div><div class='del'>-	unsigned char sbuf[512];</div><div class='del'>-</div><div class='del'>-	wait_queue_head_t devq;		/* when removing cardman must not be</div><div class='del'>-					   zeroed! */</div><div class='del'>-</div><div class='del'>-	wait_queue_head_t ioq;		/* if IO is locked, wait on this Q */</div><div class='del'>-	wait_queue_head_t atrq;		/* wait for ATR valid */</div><div class='del'>-	wait_queue_head_t readq;	/* used by write to wake blk.read */</div><div class='del'>-</div><div class='del'>-	/* warning: do not move this struct group.</div><div class='del'>-	 * initialising to zero depends on it - see ZERO_DEV below.  */</div><div class='del'>-	struct_group(init,</div><div class='del'>-	unsigned char atr_csum;</div><div class='del'>-	unsigned char atr_len_retry;</div><div class='del'>-	unsigned short atr_len;</div><div class='del'>-	unsigned short rlen;	/* bytes avail. after write */</div><div class='del'>-	unsigned short rpos;	/* latest read pos. write zeroes */</div><div class='del'>-	unsigned char procbyte;	/* T=0 procedure byte */</div><div class='del'>-	unsigned char mstate;	/* state of card monitor */</div><div class='del'>-	unsigned char cwarn;	/* slow down warning */</div><div class='del'>-	unsigned char flags0;	/* cardman IO-flags 0 */</div><div class='del'>-	unsigned char flags1;	/* cardman IO-flags 1 */</div><div class='del'>-	unsigned int mdelay;	/* variable monitor speeds, in jiffies */</div><div class='del'>-</div><div class='del'>-	unsigned int baudv;	/* baud value for speed */</div><div class='del'>-	unsigned char ta1;</div><div class='del'>-	unsigned char proto;	/* T=0, T=1, ... */</div><div class='del'>-	unsigned long flags;	/* lock+flags (MONITOR,IO,ATR) * for concurrent</div><div class='del'>-				   access */</div><div class='del'>-</div><div class='del'>-	unsigned char pts[4];</div><div class='del'>-</div><div class='del'>-	struct timer_list timer;	/* used to keep monitor running */</div><div class='del'>-	int monitor_running;</div><div class='del'>-	);</div><div class='del'>-};</div><div class='del'>-</div><div class='del'>-#define	ZERO_DEV(dev)	memset(&amp;((dev)-&gt;init), 0, sizeof((dev)-&gt;init))</div><div class='del'>-</div><div class='del'>-static struct pcmcia_device *dev_table[CM4000_MAX_DEV];</div><div class='del'>-static struct class *cmm_class;</div><div class='del'>-</div><div class='del'>-/* This table doesn't use spaces after the comma between fields and thus</div><div class='del'>- * violates process/coding-style.rst.  However, I don't really think wrapping it around will</div><div class='del'>- * make it any clearer to read -HW */</div><div class='del'>-static unsigned char fi_di_table[10][14] = {</div><div class='del'>-/*FI     00   01   02   03   04   05   06   07   08   09   10   11   12   13 */</div><div class='del'>-/*DI */</div><div class='del'>-/* 0 */ {0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11},</div><div class='del'>-/* 1 */ {0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x91,0x11,0x11,0x11,0x11},</div><div class='del'>-/* 2 */ {0x02,0x12,0x22,0x32,0x11,0x11,0x11,0x11,0x11,0x92,0xA2,0xB2,0x11,0x11},</div><div class='del'>-/* 3 */ {0x03,0x13,0x23,0x33,0x43,0x53,0x63,0x11,0x11,0x93,0xA3,0xB3,0xC3,0xD3},</div><div class='del'>-/* 4 */ {0x04,0x14,0x24,0x34,0x44,0x54,0x64,0x11,0x11,0x94,0xA4,0xB4,0xC4,0xD4},</div><div class='del'>-/* 5 */ {0x00,0x15,0x25,0x35,0x45,0x55,0x65,0x11,0x11,0x95,0xA5,0xB5,0xC5,0xD5},</div><div class='del'>-/* 6 */ {0x06,0x16,0x26,0x36,0x46,0x56,0x66,0x11,0x11,0x96,0xA6,0xB6,0xC6,0xD6},</div><div class='del'>-/* 7 */ {0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11},</div><div class='del'>-/* 8 */ {0x08,0x11,0x28,0x38,0x48,0x58,0x68,0x11,0x11,0x98,0xA8,0xB8,0xC8,0xD8},</div><div class='del'>-/* 9 */ {0x09,0x19,0x29,0x39,0x49,0x59,0x69,0x11,0x11,0x99,0xA9,0xB9,0xC9,0xD9}</div><div class='del'>-};</div><div class='del'>-</div><div class='del'>-#ifndef CM4000_DEBUG</div><div class='del'>-#define	xoutb	outb</div><div class='del'>-#define	xinb	inb</div><div class='del'>-#else</div><div class='del'>-static inline void xoutb(unsigned char val, unsigned short port)</div><div class='del'>-{</div><div class='del'>-	pr_debug("outb(val=%.2x,port=%.4x)\n", val, port);</div><div class='del'>-	outb(val, port);</div><div class='del'>-}</div><div class='del'>-static inline unsigned char xinb(unsigned short port)</div><div class='del'>-{</div><div class='del'>-	unsigned char val;</div><div class='del'>-</div><div class='del'>-	val = inb(port);</div><div class='del'>-	pr_debug("%.2x=inb(%.4x)\n", val, port);</div><div class='del'>-</div><div class='del'>-	return val;</div><div class='del'>-}</div><div class='del'>-#endif</div><div class='del'>-</div><div class='del'>-static inline unsigned char invert_revert(unsigned char ch)</div><div class='del'>-{</div><div class='del'>-	return bitrev8(~ch);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void str_invert_revert(unsigned char *b, int len)</div><div class='del'>-{</div><div class='del'>-	int i;</div><div class='del'>-</div><div class='del'>-	for (i = 0; i &lt; len; i++)</div><div class='del'>-		b[i] = invert_revert(b[i]);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-#define	ATRLENCK(dev,pos) \</div><div class='del'>-	if (pos&gt;=dev-&gt;atr_len || pos&gt;=MAX_ATR) \</div><div class='del'>-		goto return_0;</div><div class='del'>-</div><div class='del'>-static unsigned int calc_baudv(unsigned char fidi)</div><div class='del'>-{</div><div class='del'>-	unsigned int wcrcf, wbrcf, fi_rfu, di_rfu;</div><div class='del'>-</div><div class='del'>-	fi_rfu = 372;</div><div class='del'>-	di_rfu = 1;</div><div class='del'>-</div><div class='del'>-	/* FI */</div><div class='del'>-	switch ((fidi &gt;&gt; 4) &amp; 0x0F) {</div><div class='del'>-	case 0x00:</div><div class='del'>-		wcrcf = 372;</div><div class='del'>-		break;</div><div class='del'>-	case 0x01:</div><div class='del'>-		wcrcf = 372;</div><div class='del'>-		break;</div><div class='del'>-	case 0x02:</div><div class='del'>-		wcrcf = 558;</div><div class='del'>-		break;</div><div class='del'>-	case 0x03:</div><div class='del'>-		wcrcf = 744;</div><div class='del'>-		break;</div><div class='del'>-	case 0x04:</div><div class='del'>-		wcrcf = 1116;</div><div class='del'>-		break;</div><div class='del'>-	case 0x05:</div><div class='del'>-		wcrcf = 1488;</div><div class='del'>-		break;</div><div class='del'>-	case 0x06:</div><div class='del'>-		wcrcf = 1860;</div><div class='del'>-		break;</div><div class='del'>-	case 0x07:</div><div class='del'>-		wcrcf = fi_rfu;</div><div class='del'>-		break;</div><div class='del'>-	case 0x08:</div><div class='del'>-		wcrcf = fi_rfu;</div><div class='del'>-		break;</div><div class='del'>-	case 0x09:</div><div class='del'>-		wcrcf = 512;</div><div class='del'>-		break;</div><div class='del'>-	case 0x0A:</div><div class='del'>-		wcrcf = 768;</div><div class='del'>-		break;</div><div class='del'>-	case 0x0B:</div><div class='del'>-		wcrcf = 1024;</div><div class='del'>-		break;</div><div class='del'>-	case 0x0C:</div><div class='del'>-		wcrcf = 1536;</div><div class='del'>-		break;</div><div class='del'>-	case 0x0D:</div><div class='del'>-		wcrcf = 2048;</div><div class='del'>-		break;</div><div class='del'>-	default:</div><div class='del'>-		wcrcf = fi_rfu;</div><div class='del'>-		break;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	/* DI */</div><div class='del'>-	switch (fidi &amp; 0x0F) {</div><div class='del'>-	case 0x00:</div><div class='del'>-		wbrcf = di_rfu;</div><div class='del'>-		break;</div><div class='del'>-	case 0x01:</div><div class='del'>-		wbrcf = 1;</div><div class='del'>-		break;</div><div class='del'>-	case 0x02:</div><div class='del'>-		wbrcf = 2;</div><div class='del'>-		break;</div><div class='del'>-	case 0x03:</div><div class='del'>-		wbrcf = 4;</div><div class='del'>-		break;</div><div class='del'>-	case 0x04:</div><div class='del'>-		wbrcf = 8;</div><div class='del'>-		break;</div><div class='del'>-	case 0x05:</div><div class='del'>-		wbrcf = 16;</div><div class='del'>-		break;</div><div class='del'>-	case 0x06:</div><div class='del'>-		wbrcf = 32;</div><div class='del'>-		break;</div><div class='del'>-	case 0x07:</div><div class='del'>-		wbrcf = di_rfu;</div><div class='del'>-		break;</div><div class='del'>-	case 0x08:</div><div class='del'>-		wbrcf = 12;</div><div class='del'>-		break;</div><div class='del'>-	case 0x09:</div><div class='del'>-		wbrcf = 20;</div><div class='del'>-		break;</div><div class='del'>-	default:</div><div class='del'>-		wbrcf = di_rfu;</div><div class='del'>-		break;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	return (wcrcf / wbrcf);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static unsigned short io_read_num_rec_bytes(unsigned int iobase,</div><div class='del'>-					    unsigned short *s)</div><div class='del'>-{</div><div class='del'>-	unsigned short tmp;</div><div class='del'>-</div><div class='del'>-	tmp = *s = 0;</div><div class='del'>-	do {</div><div class='del'>-		*s = tmp;</div><div class='del'>-		tmp = inb(REG_NUM_BYTES(iobase)) |</div><div class='del'>-				(inb(REG_FLAGS0(iobase)) &amp; 4 ? 0x100 : 0);</div><div class='del'>-	} while (tmp != *s);</div><div class='del'>-</div><div class='del'>-	return *s;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int parse_atr(struct cm4000_dev *dev)</div><div class='del'>-{</div><div class='del'>-	unsigned char any_t1, any_t0;</div><div class='del'>-	unsigned char ch, ifno;</div><div class='del'>-	int ix, done;</div><div class='del'>-</div><div class='del'>-	DEBUGP(3, dev, "-&gt; parse_atr: dev-&gt;atr_len = %i\n", dev-&gt;atr_len);</div><div class='del'>-</div><div class='del'>-	if (dev-&gt;atr_len &lt; 3) {</div><div class='del'>-		DEBUGP(5, dev, "parse_atr: atr_len &lt; 3\n");</div><div class='del'>-		return 0;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (dev-&gt;atr[0] == 0x3f)</div><div class='del'>-		set_bit(IS_INVREV, &amp;dev-&gt;flags);</div><div class='del'>-	else</div><div class='del'>-		clear_bit(IS_INVREV, &amp;dev-&gt;flags);</div><div class='del'>-	ix = 1;</div><div class='del'>-	ifno = 1;</div><div class='del'>-	ch = dev-&gt;atr[1];</div><div class='del'>-	dev-&gt;proto = 0;		/* XXX PROTO */</div><div class='del'>-	any_t1 = any_t0 = done = 0;</div><div class='del'>-	dev-&gt;ta1 = 0x11;	/* defaults to 9600 baud */</div><div class='del'>-	do {</div><div class='del'>-		if (ifno == 1 &amp;&amp; (ch &amp; 0x10)) {</div><div class='del'>-			/* read first interface byte and TA1 is present */</div><div class='del'>-			dev-&gt;ta1 = dev-&gt;atr[2];</div><div class='del'>-			DEBUGP(5, dev, "Card says FiDi is 0x%.2x\n", dev-&gt;ta1);</div><div class='del'>-			ifno++;</div><div class='del'>-		} else if ((ifno == 2) &amp;&amp; (ch &amp; 0x10)) { /* TA(2) */</div><div class='del'>-			dev-&gt;ta1 = 0x11;</div><div class='del'>-			ifno++;</div><div class='del'>-		}</div><div class='del'>-</div><div class='del'>-		DEBUGP(5, dev, "Yi=%.2x\n", ch &amp; 0xf0);</div><div class='del'>-		ix += ((ch &amp; 0x10) &gt;&gt; 4)	/* no of int.face chars */</div><div class='del'>-		    +((ch &amp; 0x20) &gt;&gt; 5)</div><div class='del'>-		    + ((ch &amp; 0x40) &gt;&gt; 6)</div><div class='del'>-		    + ((ch &amp; 0x80) &gt;&gt; 7);</div><div class='del'>-		/* ATRLENCK(dev,ix); */</div><div class='del'>-		if (ch &amp; 0x80) {	/* TDi */</div><div class='del'>-			ch = dev-&gt;atr[ix];</div><div class='del'>-			if ((ch &amp; 0x0f)) {</div><div class='del'>-				any_t1 = 1;</div><div class='del'>-				DEBUGP(5, dev, "card is capable of T=1\n");</div><div class='del'>-			} else {</div><div class='del'>-				any_t0 = 1;</div><div class='del'>-				DEBUGP(5, dev, "card is capable of T=0\n");</div><div class='del'>-			}</div><div class='del'>-		} else</div><div class='del'>-			done = 1;</div><div class='del'>-	} while (!done);</div><div class='del'>-</div><div class='del'>-	DEBUGP(5, dev, "ix=%d noHist=%d any_t1=%d\n",</div><div class='del'>-	      ix, dev-&gt;atr[1] &amp; 15, any_t1);</div><div class='del'>-	if (ix + 1 + (dev-&gt;atr[1] &amp; 0x0f) + any_t1 != dev-&gt;atr_len) {</div><div class='del'>-		DEBUGP(5, dev, "length error\n");</div><div class='del'>-		return 0;</div><div class='del'>-	}</div><div class='del'>-	if (any_t0)</div><div class='del'>-		set_bit(IS_ANY_T0, &amp;dev-&gt;flags);</div><div class='del'>-</div><div class='del'>-	if (any_t1) {		/* compute csum */</div><div class='del'>-		dev-&gt;atr_csum = 0;</div><div class='del'>-#ifdef ATR_CSUM</div><div class='del'>-		for (i = 1; i &lt; dev-&gt;atr_len; i++)</div><div class='del'>-			dev-&gt;atr_csum ^= dev-&gt;atr[i];</div><div class='del'>-		if (dev-&gt;atr_csum) {</div><div class='del'>-			set_bit(IS_BAD_CSUM, &amp;dev-&gt;flags);</div><div class='del'>-			DEBUGP(5, dev, "bad checksum\n");</div><div class='del'>-			goto return_0;</div><div class='del'>-		}</div><div class='del'>-#endif</div><div class='del'>-		if (any_t0 == 0)</div><div class='del'>-			dev-&gt;proto = 1;	/* XXX PROTO */</div><div class='del'>-		set_bit(IS_ANY_T1, &amp;dev-&gt;flags);</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	return 1;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-struct card_fixup {</div><div class='del'>-	char atr[12];</div><div class='del'>-	u_int8_t atr_len;</div><div class='del'>-	u_int8_t stopbits;</div><div class='del'>-};</div><div class='del'>-</div><div class='del'>-static struct card_fixup card_fixups[] = {</div><div class='del'>-	{	/* ACOS */</div><div class='del'>-		.atr = { 0x3b, 0xb3, 0x11, 0x00, 0x00, 0x41, 0x01 },</div><div class='del'>-		.atr_len = 7,</div><div class='del'>-		.stopbits = 0x03,</div><div class='del'>-	},</div><div class='del'>-	{	/* Motorola */</div><div class='del'>-		.atr = {0x3b, 0x76, 0x13, 0x00, 0x00, 0x80, 0x62, 0x07,</div><div class='del'>-			0x41, 0x81, 0x81 },</div><div class='del'>-		.atr_len = 11,</div><div class='del'>-		.stopbits = 0x04,</div><div class='del'>-	},</div><div class='del'>-};</div><div class='del'>-</div><div class='del'>-static void set_cardparameter(struct cm4000_dev *dev)</div><div class='del'>-{</div><div class='del'>-	int i;</div><div class='del'>-	unsigned int iobase = dev-&gt;p_dev-&gt;resource[0]-&gt;start;</div><div class='del'>-	u_int8_t stopbits = 0x02; /* ISO default */</div><div class='del'>-</div><div class='del'>-	DEBUGP(3, dev, "-&gt; set_cardparameter\n");</div><div class='del'>-</div><div class='del'>-	dev-&gt;flags1 = dev-&gt;flags1 | (((dev-&gt;baudv - 1) &amp; 0x0100) &gt;&gt; 8);</div><div class='del'>-	xoutb(dev-&gt;flags1, REG_FLAGS1(iobase));</div><div class='del'>-	DEBUGP(5, dev, "flags1 = 0x%02x\n", dev-&gt;flags1);</div><div class='del'>-</div><div class='del'>-	/* set baudrate */</div><div class='del'>-	xoutb((unsigned char)((dev-&gt;baudv - 1) &amp; 0xFF), REG_BAUDRATE(iobase));</div><div class='del'>-</div><div class='del'>-	DEBUGP(5, dev, "baudv = %i -&gt; write 0x%02x\n", dev-&gt;baudv,</div><div class='del'>-	      ((dev-&gt;baudv - 1) &amp; 0xFF));</div><div class='del'>-</div><div class='del'>-	/* set stopbits */</div><div class='del'>-	for (i = 0; i &lt; ARRAY_SIZE(card_fixups); i++) {</div><div class='del'>-		if (!memcmp(dev-&gt;atr, card_fixups[i].atr,</div><div class='del'>-			    card_fixups[i].atr_len))</div><div class='del'>-			stopbits = card_fixups[i].stopbits;</div><div class='del'>-	}</div><div class='del'>-	xoutb(stopbits, REG_STOPBITS(iobase));</div><div class='del'>-</div><div class='del'>-	DEBUGP(3, dev, "&lt;- set_cardparameter\n");</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int set_protocol(struct cm4000_dev *dev, struct ptsreq *ptsreq)</div><div class='del'>-{</div><div class='del'>-</div><div class='del'>-	unsigned long tmp, i;</div><div class='del'>-	unsigned short num_bytes_read;</div><div class='del'>-	unsigned char pts_reply[4];</div><div class='del'>-	ssize_t rc;</div><div class='del'>-	unsigned int iobase = dev-&gt;p_dev-&gt;resource[0]-&gt;start;</div><div class='del'>-</div><div class='del'>-	rc = 0;</div><div class='del'>-</div><div class='del'>-	DEBUGP(3, dev, "-&gt; set_protocol\n");</div><div class='del'>-	DEBUGP(5, dev, "ptsreq-&gt;Protocol = 0x%.8x, ptsreq-&gt;Flags=0x%.8x, "</div><div class='del'>-		 "ptsreq-&gt;pts1=0x%.2x, ptsreq-&gt;pts2=0x%.2x, "</div><div class='del'>-		 "ptsreq-&gt;pts3=0x%.2x\n", (unsigned int)ptsreq-&gt;protocol,</div><div class='del'>-		 (unsigned int)ptsreq-&gt;flags, ptsreq-&gt;pts1, ptsreq-&gt;pts2,</div><div class='del'>-		 ptsreq-&gt;pts3);</div><div class='del'>-</div><div class='del'>-	/* Fill PTS structure */</div><div class='del'>-	dev-&gt;pts[0] = 0xff;</div><div class='del'>-	dev-&gt;pts[1] = 0x00;</div><div class='del'>-	tmp = ptsreq-&gt;protocol;</div><div class='del'>-	while ((tmp = (tmp &gt;&gt; 1)) &gt; 0)</div><div class='del'>-		dev-&gt;pts[1]++;</div><div class='del'>-	dev-&gt;proto = dev-&gt;pts[1];	/* Set new protocol */</div><div class='del'>-	dev-&gt;pts[1] = (0x01 &lt;&lt; 4) | (dev-&gt;pts[1]);</div><div class='del'>-</div><div class='del'>-	/* Correct Fi/Di according to CM4000 Fi/Di table */</div><div class='del'>-	DEBUGP(5, dev, "Ta(1) from ATR is 0x%.2x\n", dev-&gt;ta1);</div><div class='del'>-	/* set Fi/Di according to ATR TA(1) */</div><div class='del'>-	dev-&gt;pts[2] = fi_di_table[dev-&gt;ta1 &amp; 0x0F][(dev-&gt;ta1 &gt;&gt; 4) &amp; 0x0F];</div><div class='del'>-</div><div class='del'>-	/* Calculate PCK character */</div><div class='del'>-	dev-&gt;pts[3] = dev-&gt;pts[0] ^ dev-&gt;pts[1] ^ dev-&gt;pts[2];</div><div class='del'>-</div><div class='del'>-	DEBUGP(5, dev, "pts0=%.2x, pts1=%.2x, pts2=%.2x, pts3=%.2x\n",</div><div class='del'>-	       dev-&gt;pts[0], dev-&gt;pts[1], dev-&gt;pts[2], dev-&gt;pts[3]);</div><div class='del'>-</div><div class='del'>-	/* check card convention */</div><div class='del'>-	if (test_bit(IS_INVREV, &amp;dev-&gt;flags))</div><div class='del'>-		str_invert_revert(dev-&gt;pts, 4);</div><div class='del'>-</div><div class='del'>-	/* reset SM */</div><div class='del'>-	xoutb(0x80, REG_FLAGS0(iobase));</div><div class='del'>-</div><div class='del'>-	/* Enable access to the message buffer */</div><div class='del'>-	DEBUGP(5, dev, "Enable access to the messages buffer\n");</div><div class='del'>-	dev-&gt;flags1 = 0x20	/* T_Active */</div><div class='del'>-	    | (test_bit(IS_INVREV, &amp;dev-&gt;flags) ? 0x02 : 0x00) /* inv parity */</div><div class='del'>-	    | ((dev-&gt;baudv &gt;&gt; 8) &amp; 0x01);	/* MSB-baud */</div><div class='del'>-	xoutb(dev-&gt;flags1, REG_FLAGS1(iobase));</div><div class='del'>-</div><div class='del'>-	DEBUGP(5, dev, "Enable message buffer -&gt; flags1 = 0x%.2x\n",</div><div class='del'>-	       dev-&gt;flags1);</div><div class='del'>-</div><div class='del'>-	/* write challenge to the buffer */</div><div class='del'>-	DEBUGP(5, dev, "Write challenge to buffer: ");</div><div class='del'>-	for (i = 0; i &lt; 4; i++) {</div><div class='del'>-		xoutb(i, REG_BUF_ADDR(iobase));</div><div class='del'>-		xoutb(dev-&gt;pts[i], REG_BUF_DATA(iobase));	/* buf data */</div><div class='del'>-#ifdef CM4000_DEBUG</div><div class='del'>-		pr_debug("0x%.2x ", dev-&gt;pts[i]);</div><div class='del'>-	}</div><div class='del'>-	pr_debug("\n");</div><div class='del'>-#else</div><div class='del'>-	}</div><div class='del'>-#endif</div><div class='del'>-</div><div class='del'>-	/* set number of bytes to write */</div><div class='del'>-	DEBUGP(5, dev, "Set number of bytes to write\n");</div><div class='del'>-	xoutb(0x04, REG_NUM_SEND(iobase));</div><div class='del'>-</div><div class='del'>-	/* Trigger CARDMAN CONTROLLER */</div><div class='del'>-	xoutb(0x50, REG_FLAGS0(iobase));</div><div class='del'>-</div><div class='del'>-	/* Monitor progress */</div><div class='del'>-	/* wait for xmit done */</div><div class='del'>-	DEBUGP(5, dev, "Waiting for NumRecBytes getting valid\n");</div><div class='del'>-</div><div class='del'>-	for (i = 0; i &lt; 100; i++) {</div><div class='del'>-		if (inb(REG_FLAGS0(iobase)) &amp; 0x08) {</div><div class='del'>-			DEBUGP(5, dev, "NumRecBytes is valid\n");</div><div class='del'>-			break;</div><div class='del'>-		}</div><div class='del'>-		/* can not sleep as this is in atomic context */</div><div class='del'>-		mdelay(10);</div><div class='del'>-	}</div><div class='del'>-	if (i == 100) {</div><div class='del'>-		DEBUGP(5, dev, "Timeout waiting for NumRecBytes getting "</div><div class='del'>-		       "valid\n");</div><div class='del'>-		rc = -EIO;</div><div class='del'>-		goto exit_setprotocol;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	DEBUGP(5, dev, "Reading NumRecBytes\n");</div><div class='del'>-	for (i = 0; i &lt; 100; i++) {</div><div class='del'>-		io_read_num_rec_bytes(iobase, &amp;num_bytes_read);</div><div class='del'>-		if (num_bytes_read &gt;= 4) {</div><div class='del'>-			DEBUGP(2, dev, "NumRecBytes = %i\n", num_bytes_read);</div><div class='del'>-			if (num_bytes_read &gt; 4) {</div><div class='del'>-				rc = -EIO;</div><div class='del'>-				goto exit_setprotocol;</div><div class='del'>-			}</div><div class='del'>-			break;</div><div class='del'>-		}</div><div class='del'>-		/* can not sleep as this is in atomic context */</div><div class='del'>-		mdelay(10);</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	/* check whether it is a short PTS reply? */</div><div class='del'>-	if (num_bytes_read == 3)</div><div class='del'>-		i = 0;</div><div class='del'>-</div><div class='del'>-	if (i == 100) {</div><div class='del'>-		DEBUGP(5, dev, "Timeout reading num_bytes_read\n");</div><div class='del'>-		rc = -EIO;</div><div class='del'>-		goto exit_setprotocol;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	DEBUGP(5, dev, "Reset the CARDMAN CONTROLLER\n");</div><div class='del'>-	xoutb(0x80, REG_FLAGS0(iobase));</div><div class='del'>-</div><div class='del'>-	/* Read PPS reply */</div><div class='del'>-	DEBUGP(5, dev, "Read PPS reply\n");</div><div class='del'>-	for (i = 0; i &lt; num_bytes_read; i++) {</div><div class='del'>-		xoutb(i, REG_BUF_ADDR(iobase));</div><div class='del'>-		pts_reply[i] = inb(REG_BUF_DATA(iobase));</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-#ifdef CM4000_DEBUG</div><div class='del'>-	DEBUGP(2, dev, "PTSreply: ");</div><div class='del'>-	for (i = 0; i &lt; num_bytes_read; i++) {</div><div class='del'>-		pr_debug("0x%.2x ", pts_reply[i]);</div><div class='del'>-	}</div><div class='del'>-	pr_debug("\n");</div><div class='del'>-#endif	/* CM4000_DEBUG */</div><div class='del'>-</div><div class='del'>-	DEBUGP(5, dev, "Clear Tactive in Flags1\n");</div><div class='del'>-	xoutb(0x20, REG_FLAGS1(iobase));</div><div class='del'>-</div><div class='del'>-	/* Compare ptsreq and ptsreply */</div><div class='del'>-	if ((dev-&gt;pts[0] == pts_reply[0]) &amp;&amp;</div><div class='del'>-	    (dev-&gt;pts[1] == pts_reply[1]) &amp;&amp;</div><div class='del'>-	    (dev-&gt;pts[2] == pts_reply[2]) &amp;&amp; (dev-&gt;pts[3] == pts_reply[3])) {</div><div class='del'>-		/* setcardparameter according to PPS */</div><div class='del'>-		dev-&gt;baudv = calc_baudv(dev-&gt;pts[2]);</div><div class='del'>-		set_cardparameter(dev);</div><div class='del'>-	} else if ((dev-&gt;pts[0] == pts_reply[0]) &amp;&amp;</div><div class='del'>-		   ((dev-&gt;pts[1] &amp; 0xef) == pts_reply[1]) &amp;&amp;</div><div class='del'>-		   ((pts_reply[0] ^ pts_reply[1]) == pts_reply[2])) {</div><div class='del'>-		/* short PTS reply, set card parameter to default values */</div><div class='del'>-		dev-&gt;baudv = calc_baudv(0x11);</div><div class='del'>-		set_cardparameter(dev);</div><div class='del'>-	} else</div><div class='del'>-		rc = -EIO;</div><div class='del'>-</div><div class='del'>-exit_setprotocol:</div><div class='del'>-	DEBUGP(3, dev, "&lt;- set_protocol\n");</div><div class='del'>-	return rc;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int io_detect_cm4000(unsigned int iobase, struct cm4000_dev *dev)</div><div class='del'>-{</div><div class='del'>-</div><div class='del'>-	/* note: statemachine is assumed to be reset */</div><div class='del'>-	if (inb(REG_FLAGS0(iobase)) &amp; 8) {</div><div class='del'>-		clear_bit(IS_ATR_VALID, &amp;dev-&gt;flags);</div><div class='del'>-		set_bit(IS_CMM_ABSENT, &amp;dev-&gt;flags);</div><div class='del'>-		return 0;	/* detect CMM = 1 -&gt; failure */</div><div class='del'>-	}</div><div class='del'>-	/* xoutb(0x40, REG_FLAGS1(iobase)); detectCMM */</div><div class='del'>-	xoutb(dev-&gt;flags1 | 0x40, REG_FLAGS1(iobase));</div><div class='del'>-	if ((inb(REG_FLAGS0(iobase)) &amp; 8) == 0) {</div><div class='del'>-		clear_bit(IS_ATR_VALID, &amp;dev-&gt;flags);</div><div class='del'>-		set_bit(IS_CMM_ABSENT, &amp;dev-&gt;flags);</div><div class='del'>-		return 0;	/* detect CMM=0 -&gt; failure */</div><div class='del'>-	}</div><div class='del'>-	/* clear detectCMM again by restoring original flags1 */</div><div class='del'>-	xoutb(dev-&gt;flags1, REG_FLAGS1(iobase));</div><div class='del'>-	return 1;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void terminate_monitor(struct cm4000_dev *dev)</div><div class='del'>-{</div><div class='del'>-</div><div class='del'>-	/* tell the monitor to stop and wait until</div><div class='del'>-	 * it terminates.</div><div class='del'>-	 */</div><div class='del'>-	DEBUGP(3, dev, "-&gt; terminate_monitor\n");</div><div class='del'>-	wait_event_interruptible(dev-&gt;devq,</div><div class='del'>-				 test_and_set_bit(LOCK_MONITOR,</div><div class='del'>-						  (void *)&amp;dev-&gt;flags));</div><div class='del'>-</div><div class='del'>-	/* now, LOCK_MONITOR has been set.</div><div class='del'>-	 * allow a last cycle in the monitor.</div><div class='del'>-	 * the monitor will indicate that it has</div><div class='del'>-	 * finished by clearing this bit.</div><div class='del'>-	 */</div><div class='del'>-	DEBUGP(5, dev, "Now allow last cycle of monitor!\n");</div><div class='del'>-	while (test_bit(LOCK_MONITOR, (void *)&amp;dev-&gt;flags))</div><div class='del'>-		msleep(25);</div><div class='del'>-</div><div class='del'>-	DEBUGP(5, dev, "Delete timer\n");</div><div class='del'>-	del_timer_sync(&amp;dev-&gt;timer);</div><div class='del'>-#ifdef CM4000_DEBUG</div><div class='del'>-	dev-&gt;monitor_running = 0;</div><div class='del'>-#endif</div><div class='del'>-</div><div class='del'>-	DEBUGP(3, dev, "&lt;- terminate_monitor\n");</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/*</div><div class='del'>- * monitor the card every 50msec. as a side-effect, retrieve the</div><div class='del'>- * atr once a card is inserted. another side-effect of retrieving the</div><div class='del'>- * atr is that the card will be powered on, so there is no need to</div><div class='del'>- * power on the card explicitly from the application: the driver</div><div class='del'>- * is already doing that for you.</div><div class='del'>- */</div><div class='del'>-</div><div class='del'>-static void monitor_card(struct timer_list *t)</div><div class='del'>-{</div><div class='del'>-	struct cm4000_dev *dev = from_timer(dev, t, timer);</div><div class='del'>-	unsigned int iobase = dev-&gt;p_dev-&gt;resource[0]-&gt;start;</div><div class='del'>-	unsigned short s;</div><div class='del'>-	struct ptsreq ptsreq;</div><div class='del'>-	int i, atrc;</div><div class='del'>-</div><div class='del'>-	DEBUGP(7, dev, "-&gt;  monitor_card\n");</div><div class='del'>-</div><div class='del'>-	/* if someone has set the lock for us: we're done! */</div><div class='del'>-	if (test_and_set_bit(LOCK_MONITOR, &amp;dev-&gt;flags)) {</div><div class='del'>-		DEBUGP(4, dev, "About to stop monitor\n");</div><div class='del'>-		/* no */</div><div class='del'>-		dev-&gt;rlen =</div><div class='del'>-		    dev-&gt;rpos =</div><div class='del'>-		    dev-&gt;atr_csum = dev-&gt;atr_len_retry = dev-&gt;cwarn = 0;</div><div class='del'>-		dev-&gt;mstate = M_FETCH_ATR;</div><div class='del'>-		clear_bit(LOCK_MONITOR, &amp;dev-&gt;flags);</div><div class='del'>-		/* close et al. are sleeping on devq, so wake it */</div><div class='del'>-		wake_up_interruptible(&amp;dev-&gt;devq);</div><div class='del'>-		DEBUGP(2, dev, "&lt;- monitor_card (we are done now)\n");</div><div class='del'>-		return;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	/* try to lock io: if it is already locked, just add another timer */</div><div class='del'>-	if (test_and_set_bit(LOCK_IO, (void *)&amp;dev-&gt;flags)) {</div><div class='del'>-		DEBUGP(4, dev, "Couldn't get IO lock\n");</div><div class='del'>-		goto return_with_timer;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	/* is a card/a reader inserted at all ? */</div><div class='del'>-	dev-&gt;flags0 = xinb(REG_FLAGS0(iobase));</div><div class='del'>-	DEBUGP(7, dev, "dev-&gt;flags0 = 0x%2x\n", dev-&gt;flags0);</div><div class='del'>-	DEBUGP(7, dev, "smartcard present: %s\n",</div><div class='del'>-	       dev-&gt;flags0 &amp; 1 ? "yes" : "no");</div><div class='del'>-	DEBUGP(7, dev, "cardman present: %s\n",</div><div class='del'>-	       dev-&gt;flags0 == 0xff ? "no" : "yes");</div><div class='del'>-</div><div class='del'>-	if ((dev-&gt;flags0 &amp; 1) == 0	/* no smartcard inserted */</div><div class='del'>-	    || dev-&gt;flags0 == 0xff) {	/* no cardman inserted */</div><div class='del'>-		/* no */</div><div class='del'>-		dev-&gt;rlen =</div><div class='del'>-		    dev-&gt;rpos =</div><div class='del'>-		    dev-&gt;atr_csum = dev-&gt;atr_len_retry = dev-&gt;cwarn = 0;</div><div class='del'>-		dev-&gt;mstate = M_FETCH_ATR;</div><div class='del'>-</div><div class='del'>-		dev-&gt;flags &amp;= 0x000000ff; /* only keep IO and MONITOR locks */</div><div class='del'>-</div><div class='del'>-		if (dev-&gt;flags0 == 0xff) {</div><div class='del'>-			DEBUGP(4, dev, "set IS_CMM_ABSENT bit\n");</div><div class='del'>-			set_bit(IS_CMM_ABSENT, &amp;dev-&gt;flags);</div><div class='del'>-		} else if (test_bit(IS_CMM_ABSENT, &amp;dev-&gt;flags)) {</div><div class='del'>-			DEBUGP(4, dev, "clear IS_CMM_ABSENT bit "</div><div class='del'>-			       "(card is removed)\n");</div><div class='del'>-			clear_bit(IS_CMM_ABSENT, &amp;dev-&gt;flags);</div><div class='del'>-		}</div><div class='del'>-</div><div class='del'>-		goto release_io;</div><div class='del'>-	} else if ((dev-&gt;flags0 &amp; 1) &amp;&amp; test_bit(IS_CMM_ABSENT, &amp;dev-&gt;flags)) {</div><div class='del'>-		/* cardman and card present but cardman was absent before</div><div class='del'>-		 * (after suspend with inserted card) */</div><div class='del'>-		DEBUGP(4, dev, "clear IS_CMM_ABSENT bit (card is inserted)\n");</div><div class='del'>-		clear_bit(IS_CMM_ABSENT, &amp;dev-&gt;flags);</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (test_bit(IS_ATR_VALID, &amp;dev-&gt;flags) == 1) {</div><div class='del'>-		DEBUGP(7, dev, "believe ATR is already valid (do nothing)\n");</div><div class='del'>-		goto release_io;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	switch (dev-&gt;mstate) {</div><div class='del'>-	case M_CARDOFF: {</div><div class='del'>-		unsigned char flags0;</div><div class='del'>-</div><div class='del'>-		DEBUGP(4, dev, "M_CARDOFF\n");</div><div class='del'>-		flags0 = inb(REG_FLAGS0(iobase));</div><div class='del'>-		if (flags0 &amp; 0x02) {</div><div class='del'>-			/* wait until Flags0 indicate power is off */</div><div class='del'>-			dev-&gt;mdelay = T_10MSEC;</div><div class='del'>-		} else {</div><div class='del'>-			/* Flags0 indicate power off and no card inserted now;</div><div class='del'>-			 * Reset CARDMAN CONTROLLER */</div><div class='del'>-			xoutb(0x80, REG_FLAGS0(iobase));</div><div class='del'>-</div><div class='del'>-			/* prepare for fetching ATR again: after card off ATR</div><div class='del'>-			 * is read again automatically */</div><div class='del'>-			dev-&gt;rlen =</div><div class='del'>-			    dev-&gt;rpos =</div><div class='del'>-			    dev-&gt;atr_csum =</div><div class='del'>-			    dev-&gt;atr_len_retry = dev-&gt;cwarn = 0;</div><div class='del'>-			dev-&gt;mstate = M_FETCH_ATR;</div><div class='del'>-</div><div class='del'>-			/* minimal gap between CARDOFF and read ATR is 50msec */</div><div class='del'>-			dev-&gt;mdelay = T_50MSEC;</div><div class='del'>-		}</div><div class='del'>-		break;</div><div class='del'>-	}</div><div class='del'>-	case M_FETCH_ATR:</div><div class='del'>-		DEBUGP(4, dev, "M_FETCH_ATR\n");</div><div class='del'>-		xoutb(0x80, REG_FLAGS0(iobase));</div><div class='del'>-		DEBUGP(4, dev, "Reset BAUDV to 9600\n");</div><div class='del'>-		dev-&gt;baudv = 0x173;	/* 9600 */</div><div class='del'>-		xoutb(0x02, REG_STOPBITS(iobase));	/* stopbits=2 */</div><div class='del'>-		xoutb(0x73, REG_BAUDRATE(iobase));	/* baud value */</div><div class='del'>-		xoutb(0x21, REG_FLAGS1(iobase));	/* T_Active=1, baud</div><div class='del'>-							   value */</div><div class='del'>-		/* warm start vs. power on: */</div><div class='del'>-		xoutb(dev-&gt;flags0 &amp; 2 ? 0x46 : 0x44, REG_FLAGS0(iobase));</div><div class='del'>-		dev-&gt;mdelay = T_40MSEC;</div><div class='del'>-		dev-&gt;mstate = M_TIMEOUT_WAIT;</div><div class='del'>-		break;</div><div class='del'>-	case M_TIMEOUT_WAIT:</div><div class='del'>-		DEBUGP(4, dev, "M_TIMEOUT_WAIT\n");</div><div class='del'>-		/* numRecBytes */</div><div class='del'>-		io_read_num_rec_bytes(iobase, &amp;dev-&gt;atr_len);</div><div class='del'>-		dev-&gt;mdelay = T_10MSEC;</div><div class='del'>-		dev-&gt;mstate = M_READ_ATR_LEN;</div><div class='del'>-		break;</div><div class='del'>-	case M_READ_ATR_LEN:</div><div class='del'>-		DEBUGP(4, dev, "M_READ_ATR_LEN\n");</div><div class='del'>-		/* infinite loop possible, since there is no timeout */</div><div class='del'>-</div><div class='del'>-#define	MAX_ATR_LEN_RETRY	100</div><div class='del'>-</div><div class='del'>-		if (dev-&gt;atr_len == io_read_num_rec_bytes(iobase, &amp;s)) {</div><div class='del'>-			if (dev-&gt;atr_len_retry++ &gt;= MAX_ATR_LEN_RETRY) {					/* + XX msec */</div><div class='del'>-				dev-&gt;mdelay = T_10MSEC;</div><div class='del'>-				dev-&gt;mstate = M_READ_ATR;</div><div class='del'>-			}</div><div class='del'>-		} else {</div><div class='del'>-			dev-&gt;atr_len = s;</div><div class='del'>-			dev-&gt;atr_len_retry = 0;	/* set new timeout */</div><div class='del'>-		}</div><div class='del'>-</div><div class='del'>-		DEBUGP(4, dev, "Current ATR_LEN = %i\n", dev-&gt;atr_len);</div><div class='del'>-		break;</div><div class='del'>-	case M_READ_ATR:</div><div class='del'>-		DEBUGP(4, dev, "M_READ_ATR\n");</div><div class='del'>-		xoutb(0x80, REG_FLAGS0(iobase));	/* reset SM */</div><div class='del'>-		for (i = 0; i &lt; dev-&gt;atr_len; i++) {</div><div class='del'>-			xoutb(i, REG_BUF_ADDR(iobase));</div><div class='del'>-			dev-&gt;atr[i] = inb(REG_BUF_DATA(iobase));</div><div class='del'>-		}</div><div class='del'>-		/* Deactivate T_Active flags */</div><div class='del'>-		DEBUGP(4, dev, "Deactivate T_Active flags\n");</div><div class='del'>-		dev-&gt;flags1 = 0x01;</div><div class='del'>-		xoutb(dev-&gt;flags1, REG_FLAGS1(iobase));</div><div class='del'>-</div><div class='del'>-		/* atr is present (which doesn't mean it's valid) */</div><div class='del'>-		set_bit(IS_ATR_PRESENT, &amp;dev-&gt;flags);</div><div class='del'>-		if (dev-&gt;atr[0] == 0x03)</div><div class='del'>-			str_invert_revert(dev-&gt;atr, dev-&gt;atr_len);</div><div class='del'>-		atrc = parse_atr(dev);</div><div class='del'>-		if (atrc == 0) {	/* atr invalid */</div><div class='del'>-			dev-&gt;mdelay = 0;</div><div class='del'>-			dev-&gt;mstate = M_BAD_CARD;</div><div class='del'>-		} else {</div><div class='del'>-			dev-&gt;mdelay = T_50MSEC;</div><div class='del'>-			dev-&gt;mstate = M_ATR_PRESENT;</div><div class='del'>-			set_bit(IS_ATR_VALID, &amp;dev-&gt;flags);</div><div class='del'>-		}</div><div class='del'>-</div><div class='del'>-		if (test_bit(IS_ATR_VALID, &amp;dev-&gt;flags) == 1) {</div><div class='del'>-			DEBUGP(4, dev, "monitor_card: ATR valid\n");</div><div class='del'>- 			/* if ta1 == 0x11, no PPS necessary (default values) */</div><div class='del'>-			/* do not do PPS with multi protocol cards */</div><div class='del'>-			if ((test_bit(IS_AUTOPPS_ACT, &amp;dev-&gt;flags) == 0) &amp;&amp;</div><div class='del'>-			    (dev-&gt;ta1 != 0x11) &amp;&amp;</div><div class='del'>-			    !(test_bit(IS_ANY_T0, &amp;dev-&gt;flags) &amp;&amp;</div><div class='del'>-			    test_bit(IS_ANY_T1, &amp;dev-&gt;flags))) {</div><div class='del'>-				DEBUGP(4, dev, "Perform AUTOPPS\n");</div><div class='del'>-				set_bit(IS_AUTOPPS_ACT, &amp;dev-&gt;flags);</div><div class='del'>-				ptsreq.protocol = (0x01 &lt;&lt; dev-&gt;proto);</div><div class='del'>-				ptsreq.flags = 0x01;</div><div class='del'>-				ptsreq.pts1 = 0x00;</div><div class='del'>-				ptsreq.pts2 = 0x00;</div><div class='del'>-				ptsreq.pts3 = 0x00;</div><div class='del'>-				if (set_protocol(dev, &amp;ptsreq) == 0) {</div><div class='del'>-					DEBUGP(4, dev, "AUTOPPS ret SUCC\n");</div><div class='del'>-					clear_bit(IS_AUTOPPS_ACT, &amp;dev-&gt;flags);</div><div class='del'>-					wake_up_interruptible(&amp;dev-&gt;atrq);</div><div class='del'>-				} else {</div><div class='del'>-					DEBUGP(4, dev, "AUTOPPS failed: "</div><div class='del'>-					       "repower using defaults\n");</div><div class='del'>-					/* prepare for repowering  */</div><div class='del'>-					clear_bit(IS_ATR_PRESENT, &amp;dev-&gt;flags);</div><div class='del'>-					clear_bit(IS_ATR_VALID, &amp;dev-&gt;flags);</div><div class='del'>-					dev-&gt;rlen =</div><div class='del'>-					    dev-&gt;rpos =</div><div class='del'>-					    dev-&gt;atr_csum =</div><div class='del'>-					    dev-&gt;atr_len_retry = dev-&gt;cwarn = 0;</div><div class='del'>-					dev-&gt;mstate = M_FETCH_ATR;</div><div class='del'>-</div><div class='del'>-					dev-&gt;mdelay = T_50MSEC;</div><div class='del'>-				}</div><div class='del'>-			} else {</div><div class='del'>-				/* for cards which use slightly different</div><div class='del'>-				 * params (extra guard time) */</div><div class='del'>-				set_cardparameter(dev);</div><div class='del'>-				if (test_bit(IS_AUTOPPS_ACT, &amp;dev-&gt;flags) == 1)</div><div class='del'>-					DEBUGP(4, dev, "AUTOPPS already active "</div><div class='del'>-					       "2nd try:use default values\n");</div><div class='del'>-				if (dev-&gt;ta1 == 0x11)</div><div class='del'>-					DEBUGP(4, dev, "No AUTOPPS necessary "</div><div class='del'>-					       "TA(1)==0x11\n");</div><div class='del'>-				if (test_bit(IS_ANY_T0, &amp;dev-&gt;flags)</div><div class='del'>-				    &amp;&amp; test_bit(IS_ANY_T1, &amp;dev-&gt;flags))</div><div class='del'>-					DEBUGP(4, dev, "Do NOT perform AUTOPPS "</div><div class='del'>-					       "with multiprotocol cards\n");</div><div class='del'>-				clear_bit(IS_AUTOPPS_ACT, &amp;dev-&gt;flags);</div><div class='del'>-				wake_up_interruptible(&amp;dev-&gt;atrq);</div><div class='del'>-			}</div><div class='del'>-		} else {</div><div class='del'>-			DEBUGP(4, dev, "ATR invalid\n");</div><div class='del'>-			wake_up_interruptible(&amp;dev-&gt;atrq);</div><div class='del'>-		}</div><div class='del'>-		break;</div><div class='del'>-	case M_BAD_CARD:</div><div class='del'>-		DEBUGP(4, dev, "M_BAD_CARD\n");</div><div class='del'>-		/* slow down warning, but prompt immediately after insertion */</div><div class='del'>-		if (dev-&gt;cwarn == 0 || dev-&gt;cwarn == 10) {</div><div class='del'>-			set_bit(IS_BAD_CARD, &amp;dev-&gt;flags);</div><div class='del'>-			dev_warn(&amp;dev-&gt;p_dev-&gt;dev, MODULE_NAME ": ");</div><div class='del'>-			if (test_bit(IS_BAD_CSUM, &amp;dev-&gt;flags)) {</div><div class='del'>-				DEBUGP(4, dev, "ATR checksum (0x%.2x, should "</div><div class='del'>-				       "be zero) failed\n", dev-&gt;atr_csum);</div><div class='del'>-			}</div><div class='del'>-#ifdef CM4000_DEBUG</div><div class='del'>-			else if (test_bit(IS_BAD_LENGTH, &amp;dev-&gt;flags)) {</div><div class='del'>-				DEBUGP(4, dev, "ATR length error\n");</div><div class='del'>-			} else {</div><div class='del'>-				DEBUGP(4, dev, "card damaged or wrong way "</div><div class='del'>-					"inserted\n");</div><div class='del'>-			}</div><div class='del'>-#endif</div><div class='del'>-			dev-&gt;cwarn = 0;</div><div class='del'>-			wake_up_interruptible(&amp;dev-&gt;atrq);	/* wake open */</div><div class='del'>-		}</div><div class='del'>-		dev-&gt;cwarn++;</div><div class='del'>-		dev-&gt;mdelay = T_100MSEC;</div><div class='del'>-		dev-&gt;mstate = M_FETCH_ATR;</div><div class='del'>-		break;</div><div class='del'>-	default:</div><div class='del'>-		DEBUGP(7, dev, "Unknown action\n");</div><div class='del'>-		break;		/* nothing */</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-release_io:</div><div class='del'>-	DEBUGP(7, dev, "release_io\n");</div><div class='del'>-	clear_bit(LOCK_IO, &amp;dev-&gt;flags);</div><div class='del'>-	wake_up_interruptible(&amp;dev-&gt;ioq);	/* whoever needs IO */</div><div class='del'>-</div><div class='del'>-return_with_timer:</div><div class='del'>-	DEBUGP(7, dev, "&lt;- monitor_card (returns with timer)\n");</div><div class='del'>-	mod_timer(&amp;dev-&gt;timer, jiffies + dev-&gt;mdelay);</div><div class='del'>-	clear_bit(LOCK_MONITOR, &amp;dev-&gt;flags);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Interface to userland (file_operations) */</div><div class='del'>-</div><div class='del'>-static ssize_t cmm_read(struct file *filp, __user char *buf, size_t count,</div><div class='del'>-			loff_t *ppos)</div><div class='del'>-{</div><div class='del'>-	struct cm4000_dev *dev = filp-&gt;private_data;</div><div class='del'>-	unsigned int iobase = dev-&gt;p_dev-&gt;resource[0]-&gt;start;</div><div class='del'>-	ssize_t rc;</div><div class='del'>-	int i, j, k;</div><div class='del'>-</div><div class='del'>-	DEBUGP(2, dev, "-&gt; cmm_read(%s,%d)\n", current-&gt;comm, current-&gt;pid);</div><div class='del'>-</div><div class='del'>-	if (count == 0)		/* according to manpage */</div><div class='del'>-		return 0;</div><div class='del'>-</div><div class='del'>-	if (!pcmcia_dev_present(dev-&gt;p_dev) || /* device removed */</div><div class='del'>-	    test_bit(IS_CMM_ABSENT, &amp;dev-&gt;flags))</div><div class='del'>-		return -ENODEV;</div><div class='del'>-</div><div class='del'>-	if (test_bit(IS_BAD_CSUM, &amp;dev-&gt;flags))</div><div class='del'>-		return -EIO;</div><div class='del'>-</div><div class='del'>-	/* also see the note about this in cmm_write */</div><div class='del'>-	if (wait_event_interruptible</div><div class='del'>-	    (dev-&gt;atrq,</div><div class='del'>-	     ((filp-&gt;f_flags &amp; O_NONBLOCK)</div><div class='del'>-	      || (test_bit(IS_ATR_PRESENT, (void *)&amp;dev-&gt;flags) != 0)))) {</div><div class='del'>-		if (filp-&gt;f_flags &amp; O_NONBLOCK)</div><div class='del'>-			return -EAGAIN;</div><div class='del'>-		return -ERESTARTSYS;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (test_bit(IS_ATR_VALID, &amp;dev-&gt;flags) == 0)</div><div class='del'>-		return -EIO;</div><div class='del'>-</div><div class='del'>-	/* this one implements blocking IO */</div><div class='del'>-	if (wait_event_interruptible</div><div class='del'>-	    (dev-&gt;readq,</div><div class='del'>-	     ((filp-&gt;f_flags &amp; O_NONBLOCK) || (dev-&gt;rpos &lt; dev-&gt;rlen)))) {</div><div class='del'>-		if (filp-&gt;f_flags &amp; O_NONBLOCK)</div><div class='del'>-			return -EAGAIN;</div><div class='del'>-		return -ERESTARTSYS;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	/* lock io */</div><div class='del'>-	if (wait_event_interruptible</div><div class='del'>-	    (dev-&gt;ioq,</div><div class='del'>-	     ((filp-&gt;f_flags &amp; O_NONBLOCK)</div><div class='del'>-	      || (test_and_set_bit(LOCK_IO, (void *)&amp;dev-&gt;flags) == 0)))) {</div><div class='del'>-		if (filp-&gt;f_flags &amp; O_NONBLOCK)</div><div class='del'>-			return -EAGAIN;</div><div class='del'>-		return -ERESTARTSYS;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	rc = 0;</div><div class='del'>-	dev-&gt;flags0 = inb(REG_FLAGS0(iobase));</div><div class='del'>-	if ((dev-&gt;flags0 &amp; 1) == 0	/* no smartcard inserted */</div><div class='del'>-	    || dev-&gt;flags0 == 0xff) {	/* no cardman inserted */</div><div class='del'>-		clear_bit(IS_ATR_VALID, &amp;dev-&gt;flags);</div><div class='del'>-		if (dev-&gt;flags0 &amp; 1) {</div><div class='del'>-			set_bit(IS_CMM_ABSENT, &amp;dev-&gt;flags);</div><div class='del'>-			rc = -ENODEV;</div><div class='del'>-		} else {</div><div class='del'>-			rc = -EIO;</div><div class='del'>-		}</div><div class='del'>-		goto release_io;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	DEBUGP(4, dev, "begin read answer\n");</div><div class='del'>-	j = min(count, (size_t)(dev-&gt;rlen - dev-&gt;rpos));</div><div class='del'>-	k = dev-&gt;rpos;</div><div class='del'>-	if (k + j &gt; 255)</div><div class='del'>-		j = 256 - k;</div><div class='del'>-	DEBUGP(4, dev, "read1 j=%d\n", j);</div><div class='del'>-	for (i = 0; i &lt; j; i++) {</div><div class='del'>-		xoutb(k++, REG_BUF_ADDR(iobase));</div><div class='del'>-		dev-&gt;rbuf[i] = xinb(REG_BUF_DATA(iobase));</div><div class='del'>-	}</div><div class='del'>-	j = min(count, (size_t)(dev-&gt;rlen - dev-&gt;rpos));</div><div class='del'>-	if (k + j &gt; 255) {</div><div class='del'>-		DEBUGP(4, dev, "read2 j=%d\n", j);</div><div class='del'>-		dev-&gt;flags1 |= 0x10;	/* MSB buf addr set */</div><div class='del'>-		xoutb(dev-&gt;flags1, REG_FLAGS1(iobase));</div><div class='del'>-		for (; i &lt; j; i++) {</div><div class='del'>-			xoutb(k++, REG_BUF_ADDR(iobase));</div><div class='del'>-			dev-&gt;rbuf[i] = xinb(REG_BUF_DATA(iobase));</div><div class='del'>-		}</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (dev-&gt;proto == 0 &amp;&amp; count &gt; dev-&gt;rlen - dev-&gt;rpos &amp;&amp; i) {</div><div class='del'>-		DEBUGP(4, dev, "T=0 and count &gt; buffer\n");</div><div class='del'>-		dev-&gt;rbuf[i] = dev-&gt;rbuf[i - 1];</div><div class='del'>-		dev-&gt;rbuf[i - 1] = dev-&gt;procbyte;</div><div class='del'>-		j++;</div><div class='del'>-	}</div><div class='del'>-	count = j;</div><div class='del'>-</div><div class='del'>-	dev-&gt;rpos = dev-&gt;rlen + 1;</div><div class='del'>-</div><div class='del'>-	/* Clear T1Active */</div><div class='del'>-	DEBUGP(4, dev, "Clear T1Active\n");</div><div class='del'>-	dev-&gt;flags1 &amp;= 0xdf;</div><div class='del'>-	xoutb(dev-&gt;flags1, REG_FLAGS1(iobase));</div><div class='del'>-</div><div class='del'>-	xoutb(0, REG_FLAGS1(iobase));	/* clear detectCMM */</div><div class='del'>-	/* last check before exit */</div><div class='del'>-	if (!io_detect_cm4000(iobase, dev)) {</div><div class='del'>-		rc = -ENODEV;</div><div class='del'>-		goto release_io;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (test_bit(IS_INVREV, &amp;dev-&gt;flags) &amp;&amp; count &gt; 0)</div><div class='del'>-		str_invert_revert(dev-&gt;rbuf, count);</div><div class='del'>-</div><div class='del'>-	if (copy_to_user(buf, dev-&gt;rbuf, count))</div><div class='del'>-		rc = -EFAULT;</div><div class='del'>-</div><div class='del'>-release_io:</div><div class='del'>-	clear_bit(LOCK_IO, &amp;dev-&gt;flags);</div><div class='del'>-	wake_up_interruptible(&amp;dev-&gt;ioq);</div><div class='del'>-</div><div class='del'>-	DEBUGP(2, dev, "&lt;- cmm_read returns: rc = %zi\n",</div><div class='del'>-	       (rc &lt; 0 ? rc : count));</div><div class='del'>-	return rc &lt; 0 ? rc : count;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static ssize_t cmm_write(struct file *filp, const char __user *buf,</div><div class='del'>-			 size_t count, loff_t *ppos)</div><div class='del'>-{</div><div class='del'>-	struct cm4000_dev *dev = filp-&gt;private_data;</div><div class='del'>-	unsigned int iobase = dev-&gt;p_dev-&gt;resource[0]-&gt;start;</div><div class='del'>-	unsigned short s;</div><div class='del'>-	unsigned char infolen;</div><div class='del'>-	unsigned char sendT0;</div><div class='del'>-	unsigned short nsend;</div><div class='del'>-	unsigned short nr;</div><div class='del'>-	ssize_t rc;</div><div class='del'>-	int i;</div><div class='del'>-</div><div class='del'>-	DEBUGP(2, dev, "-&gt; cmm_write(%s,%d)\n", current-&gt;comm, current-&gt;pid);</div><div class='del'>-</div><div class='del'>-	if (count == 0)		/* according to manpage */</div><div class='del'>-		return 0;</div><div class='del'>-</div><div class='del'>-	if (dev-&gt;proto == 0 &amp;&amp; count &lt; 4) {</div><div class='del'>-		/* T0 must have at least 4 bytes */</div><div class='del'>-		DEBUGP(4, dev, "T0 short write\n");</div><div class='del'>-		return -EIO;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	nr = count &amp; 0x1ff;	/* max bytes to write */</div><div class='del'>-</div><div class='del'>-	sendT0 = dev-&gt;proto ? 0 : nr &gt; 5 ? 0x08 : 0;</div><div class='del'>-</div><div class='del'>-	if (!pcmcia_dev_present(dev-&gt;p_dev) || /* device removed */</div><div class='del'>-	    test_bit(IS_CMM_ABSENT, &amp;dev-&gt;flags))</div><div class='del'>-		return -ENODEV;</div><div class='del'>-</div><div class='del'>-	if (test_bit(IS_BAD_CSUM, &amp;dev-&gt;flags)) {</div><div class='del'>-		DEBUGP(4, dev, "bad csum\n");</div><div class='del'>-		return -EIO;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	/*</div><div class='del'>-	 * wait for atr to become valid.</div><div class='del'>-	 * note: it is important to lock this code. if we dont, the monitor</div><div class='del'>-	 * could be run between test_bit and the call to sleep on the</div><div class='del'>-	 * atr-queue.  if *then* the monitor detects atr valid, it will wake up</div><div class='del'>-	 * any process on the atr-queue, *but* since we have been interrupted,</div><div class='del'>-	 * we do not yet sleep on this queue. this would result in a missed</div><div class='del'>-	 * wake_up and the calling process would sleep forever (until</div><div class='del'>-	 * interrupted).  also, do *not* restore_flags before sleep_on, because</div><div class='del'>-	 * this could result in the same situation!</div><div class='del'>-	 */</div><div class='del'>-	if (wait_event_interruptible</div><div class='del'>-	    (dev-&gt;atrq,</div><div class='del'>-	     ((filp-&gt;f_flags &amp; O_NONBLOCK)</div><div class='del'>-	      || (test_bit(IS_ATR_PRESENT, (void *)&amp;dev-&gt;flags) != 0)))) {</div><div class='del'>-		if (filp-&gt;f_flags &amp; O_NONBLOCK)</div><div class='del'>-			return -EAGAIN;</div><div class='del'>-		return -ERESTARTSYS;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (test_bit(IS_ATR_VALID, &amp;dev-&gt;flags) == 0) {	/* invalid atr */</div><div class='del'>-		DEBUGP(4, dev, "invalid ATR\n");</div><div class='del'>-		return -EIO;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	/* lock io */</div><div class='del'>-	if (wait_event_interruptible</div><div class='del'>-	    (dev-&gt;ioq,</div><div class='del'>-	     ((filp-&gt;f_flags &amp; O_NONBLOCK)</div><div class='del'>-	      || (test_and_set_bit(LOCK_IO, (void *)&amp;dev-&gt;flags) == 0)))) {</div><div class='del'>-		if (filp-&gt;f_flags &amp; O_NONBLOCK)</div><div class='del'>-			return -EAGAIN;</div><div class='del'>-		return -ERESTARTSYS;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (copy_from_user(dev-&gt;sbuf, buf, ((count &gt; 512) ? 512 : count)))</div><div class='del'>-		return -EFAULT;</div><div class='del'>-</div><div class='del'>-	rc = 0;</div><div class='del'>-	dev-&gt;flags0 = inb(REG_FLAGS0(iobase));</div><div class='del'>-	if ((dev-&gt;flags0 &amp; 1) == 0	/* no smartcard inserted */</div><div class='del'>-	    || dev-&gt;flags0 == 0xff) {	/* no cardman inserted */</div><div class='del'>-		clear_bit(IS_ATR_VALID, &amp;dev-&gt;flags);</div><div class='del'>-		if (dev-&gt;flags0 &amp; 1) {</div><div class='del'>-			set_bit(IS_CMM_ABSENT, &amp;dev-&gt;flags);</div><div class='del'>-			rc = -ENODEV;</div><div class='del'>-		} else {</div><div class='del'>-			DEBUGP(4, dev, "IO error\n");</div><div class='del'>-			rc = -EIO;</div><div class='del'>-		}</div><div class='del'>-		goto release_io;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	xoutb(0x80, REG_FLAGS0(iobase));	/* reset SM  */</div><div class='del'>-</div><div class='del'>-	if (!io_detect_cm4000(iobase, dev)) {</div><div class='del'>-		rc = -ENODEV;</div><div class='del'>-		goto release_io;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	/* reflect T=0 send/read mode in flags1 */</div><div class='del'>-	dev-&gt;flags1 |= (sendT0);</div><div class='del'>-</div><div class='del'>-	set_cardparameter(dev);</div><div class='del'>-</div><div class='del'>-	/* dummy read, reset flag procedure received */</div><div class='del'>-	inb(REG_FLAGS1(iobase));</div><div class='del'>-</div><div class='del'>-	dev-&gt;flags1 = 0x20	/* T_Active */</div><div class='del'>-	    | (sendT0)</div><div class='del'>-	    | (test_bit(IS_INVREV, &amp;dev-&gt;flags) ? 2 : 0)/* inverse parity  */</div><div class='del'>-	    | (((dev-&gt;baudv - 1) &amp; 0x0100) &gt;&gt; 8);	/* MSB-Baud */</div><div class='del'>-	DEBUGP(1, dev, "set dev-&gt;flags1 = 0x%.2x\n", dev-&gt;flags1);</div><div class='del'>-	xoutb(dev-&gt;flags1, REG_FLAGS1(iobase));</div><div class='del'>-</div><div class='del'>-	/* xmit data */</div><div class='del'>-	DEBUGP(4, dev, "Xmit data\n");</div><div class='del'>-	for (i = 0; i &lt; nr; i++) {</div><div class='del'>-		if (i &gt;= 256) {</div><div class='del'>-			dev-&gt;flags1 = 0x20	/* T_Active */</div><div class='del'>-			    | (sendT0)	/* SendT0 */</div><div class='del'>-				/* inverse parity: */</div><div class='del'>-			    | (test_bit(IS_INVREV, &amp;dev-&gt;flags) ? 2 : 0)</div><div class='del'>-			    | (((dev-&gt;baudv - 1) &amp; 0x0100) &gt;&gt; 8) /* MSB-Baud */</div><div class='del'>-			    | 0x10;	/* set address high */</div><div class='del'>-			DEBUGP(4, dev, "dev-&gt;flags = 0x%.2x - set address "</div><div class='del'>-			       "high\n", dev-&gt;flags1);</div><div class='del'>-			xoutb(dev-&gt;flags1, REG_FLAGS1(iobase));</div><div class='del'>-		}</div><div class='del'>-		if (test_bit(IS_INVREV, &amp;dev-&gt;flags)) {</div><div class='del'>-			DEBUGP(4, dev, "Apply inverse convention for 0x%.2x "</div><div class='del'>-				"-&gt; 0x%.2x\n", (unsigned char)dev-&gt;sbuf[i],</div><div class='del'>-			      invert_revert(dev-&gt;sbuf[i]));</div><div class='del'>-			xoutb(i, REG_BUF_ADDR(iobase));</div><div class='del'>-			xoutb(invert_revert(dev-&gt;sbuf[i]),</div><div class='del'>-			      REG_BUF_DATA(iobase));</div><div class='del'>-		} else {</div><div class='del'>-			xoutb(i, REG_BUF_ADDR(iobase));</div><div class='del'>-			xoutb(dev-&gt;sbuf[i], REG_BUF_DATA(iobase));</div><div class='del'>-		}</div><div class='del'>-	}</div><div class='del'>-	DEBUGP(4, dev, "Xmit done\n");</div><div class='del'>-</div><div class='del'>-	if (dev-&gt;proto == 0) {</div><div class='del'>-		/* T=0 proto: 0 byte reply  */</div><div class='del'>-		if (nr == 4) {</div><div class='del'>-			DEBUGP(4, dev, "T=0 assumes 0 byte reply\n");</div><div class='del'>-			xoutb(i, REG_BUF_ADDR(iobase));</div><div class='del'>-			if (test_bit(IS_INVREV, &amp;dev-&gt;flags))</div><div class='del'>-				xoutb(0xff, REG_BUF_DATA(iobase));</div><div class='del'>-			else</div><div class='del'>-				xoutb(0x00, REG_BUF_DATA(iobase));</div><div class='del'>-		}</div><div class='del'>-</div><div class='del'>-		/* numSendBytes */</div><div class='del'>-		if (sendT0)</div><div class='del'>-			nsend = nr;</div><div class='del'>-		else {</div><div class='del'>-			if (nr == 4)</div><div class='del'>-				nsend = 5;</div><div class='del'>-			else {</div><div class='del'>-				nsend = 5 + (unsigned char)dev-&gt;sbuf[4];</div><div class='del'>-				if (dev-&gt;sbuf[4] == 0)</div><div class='del'>-					nsend += 0x100;</div><div class='del'>-			}</div><div class='del'>-		}</div><div class='del'>-	} else</div><div class='del'>-		nsend = nr;</div><div class='del'>-</div><div class='del'>-	/* T0: output procedure byte */</div><div class='del'>-	if (test_bit(IS_INVREV, &amp;dev-&gt;flags)) {</div><div class='del'>-		DEBUGP(4, dev, "T=0 set Procedure byte (inverse-reverse) "</div><div class='del'>-		       "0x%.2x\n", invert_revert(dev-&gt;sbuf[1]));</div><div class='del'>-		xoutb(invert_revert(dev-&gt;sbuf[1]), REG_NUM_BYTES(iobase));</div><div class='del'>-	} else {</div><div class='del'>-		DEBUGP(4, dev, "T=0 set Procedure byte 0x%.2x\n", dev-&gt;sbuf[1]);</div><div class='del'>-		xoutb(dev-&gt;sbuf[1], REG_NUM_BYTES(iobase));</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	DEBUGP(1, dev, "set NumSendBytes = 0x%.2x\n",</div><div class='del'>-	       (unsigned char)(nsend &amp; 0xff));</div><div class='del'>-	xoutb((unsigned char)(nsend &amp; 0xff), REG_NUM_SEND(iobase));</div><div class='del'>-</div><div class='del'>-	DEBUGP(1, dev, "Trigger CARDMAN CONTROLLER (0x%.2x)\n",</div><div class='del'>-	       0x40	/* SM_Active */</div><div class='del'>-	      | (dev-&gt;flags0 &amp; 2 ? 0 : 4)	/* power on if needed */</div><div class='del'>-	      |(dev-&gt;proto ? 0x10 : 0x08)	/* T=1/T=0 */</div><div class='del'>-	      |(nsend &amp; 0x100) &gt;&gt; 8 /* MSB numSendBytes */ );</div><div class='del'>-	xoutb(0x40		/* SM_Active */</div><div class='del'>-	      | (dev-&gt;flags0 &amp; 2 ? 0 : 4)	/* power on if needed */</div><div class='del'>-	      |(dev-&gt;proto ? 0x10 : 0x08)	/* T=1/T=0 */</div><div class='del'>-	      |(nsend &amp; 0x100) &gt;&gt; 8,	/* MSB numSendBytes */</div><div class='del'>-	      REG_FLAGS0(iobase));</div><div class='del'>-</div><div class='del'>-	/* wait for xmit done */</div><div class='del'>-	if (dev-&gt;proto == 1) {</div><div class='del'>-		DEBUGP(4, dev, "Wait for xmit done\n");</div><div class='del'>-		for (i = 0; i &lt; 1000; i++) {</div><div class='del'>-			if (inb(REG_FLAGS0(iobase)) &amp; 0x08)</div><div class='del'>-				break;</div><div class='del'>-			msleep_interruptible(10);</div><div class='del'>-		}</div><div class='del'>-		if (i == 1000) {</div><div class='del'>-			DEBUGP(4, dev, "timeout waiting for xmit done\n");</div><div class='del'>-			rc = -EIO;</div><div class='del'>-			goto release_io;</div><div class='del'>-		}</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	/* T=1: wait for infoLen */</div><div class='del'>-</div><div class='del'>-	infolen = 0;</div><div class='del'>-	if (dev-&gt;proto) {</div><div class='del'>-		/* wait until infoLen is valid */</div><div class='del'>-		for (i = 0; i &lt; 6000; i++) {	/* max waiting time of 1 min */</div><div class='del'>-			io_read_num_rec_bytes(iobase, &amp;s);</div><div class='del'>-			if (s &gt;= 3) {</div><div class='del'>-				infolen = inb(REG_FLAGS1(iobase));</div><div class='del'>-				DEBUGP(4, dev, "infolen=%d\n", infolen);</div><div class='del'>-				break;</div><div class='del'>-			}</div><div class='del'>-			msleep_interruptible(10);</div><div class='del'>-		}</div><div class='del'>-		if (i == 6000) {</div><div class='del'>-			DEBUGP(4, dev, "timeout waiting for infoLen\n");</div><div class='del'>-			rc = -EIO;</div><div class='del'>-			goto release_io;</div><div class='del'>-		}</div><div class='del'>-	} else</div><div class='del'>-		clear_bit(IS_PROCBYTE_PRESENT, &amp;dev-&gt;flags);</div><div class='del'>-</div><div class='del'>-	/* numRecBytes | bit9 of numRecytes */</div><div class='del'>-	io_read_num_rec_bytes(iobase, &amp;dev-&gt;rlen);</div><div class='del'>-	for (i = 0; i &lt; 600; i++) {	/* max waiting time of 2 sec */</div><div class='del'>-		if (dev-&gt;proto) {</div><div class='del'>-			if (dev-&gt;rlen &gt;= infolen + 4)</div><div class='del'>-				break;</div><div class='del'>-		}</div><div class='del'>-		msleep_interruptible(10);</div><div class='del'>-		/* numRecBytes | bit9 of numRecytes */</div><div class='del'>-		io_read_num_rec_bytes(iobase, &amp;s);</div><div class='del'>-		if (s &gt; dev-&gt;rlen) {</div><div class='del'>-			DEBUGP(1, dev, "NumRecBytes inc (reset timeout)\n");</div><div class='del'>-			i = 0;	/* reset timeout */</div><div class='del'>-			dev-&gt;rlen = s;</div><div class='del'>-		}</div><div class='del'>-		/* T=0: we are done when numRecBytes doesn't</div><div class='del'>-		 *      increment any more and NoProcedureByte</div><div class='del'>-		 *      is set and numRecBytes == bytes sent + 6</div><div class='del'>-		 *      (header bytes + data + 1 for sw2)</div><div class='del'>-		 *      except when the card replies an error</div><div class='del'>-		 *      which means, no data will be sent back.</div><div class='del'>-		 */</div><div class='del'>-		else if (dev-&gt;proto == 0) {</div><div class='del'>-			if ((inb(REG_BUF_ADDR(iobase)) &amp; 0x80)) {</div><div class='del'>-				/* no procedure byte received since last read */</div><div class='del'>-				DEBUGP(1, dev, "NoProcedure byte set\n");</div><div class='del'>-				/* i=0; */</div><div class='del'>-			} else {</div><div class='del'>-				/* procedure byte received since last read */</div><div class='del'>-				DEBUGP(1, dev, "NoProcedure byte unset "</div><div class='del'>-					"(reset timeout)\n");</div><div class='del'>-				dev-&gt;procbyte = inb(REG_FLAGS1(iobase));</div><div class='del'>-				DEBUGP(1, dev, "Read procedure byte 0x%.2x\n",</div><div class='del'>-				      dev-&gt;procbyte);</div><div class='del'>-				i = 0;	/* resettimeout */</div><div class='del'>-			}</div><div class='del'>-			if (inb(REG_FLAGS0(iobase)) &amp; 0x08) {</div><div class='del'>-				DEBUGP(1, dev, "T0Done flag (read reply)\n");</div><div class='del'>-				break;</div><div class='del'>-			}</div><div class='del'>-		}</div><div class='del'>-		if (dev-&gt;proto)</div><div class='del'>-			infolen = inb(REG_FLAGS1(iobase));</div><div class='del'>-	}</div><div class='del'>-	if (i == 600) {</div><div class='del'>-		DEBUGP(1, dev, "timeout waiting for numRecBytes\n");</div><div class='del'>-		rc = -EIO;</div><div class='del'>-		goto release_io;</div><div class='del'>-	} else {</div><div class='del'>-		if (dev-&gt;proto == 0) {</div><div class='del'>-			DEBUGP(1, dev, "Wait for T0Done bit to be  set\n");</div><div class='del'>-			for (i = 0; i &lt; 1000; i++) {</div><div class='del'>-				if (inb(REG_FLAGS0(iobase)) &amp; 0x08)</div><div class='del'>-					break;</div><div class='del'>-				msleep_interruptible(10);</div><div class='del'>-			}</div><div class='del'>-			if (i == 1000) {</div><div class='del'>-				DEBUGP(1, dev, "timeout waiting for T0Done\n");</div><div class='del'>-				rc = -EIO;</div><div class='del'>-				goto release_io;</div><div class='del'>-			}</div><div class='del'>-</div><div class='del'>-			dev-&gt;procbyte = inb(REG_FLAGS1(iobase));</div><div class='del'>-			DEBUGP(4, dev, "Read procedure byte 0x%.2x\n",</div><div class='del'>-			      dev-&gt;procbyte);</div><div class='del'>-</div><div class='del'>-			io_read_num_rec_bytes(iobase, &amp;dev-&gt;rlen);</div><div class='del'>-			DEBUGP(4, dev, "Read NumRecBytes = %i\n", dev-&gt;rlen);</div><div class='del'>-</div><div class='del'>-		}</div><div class='del'>-	}</div><div class='del'>-	/* T=1: read offset=zero, T=0: read offset=after challenge */</div><div class='del'>-	dev-&gt;rpos = dev-&gt;proto ? 0 : nr == 4 ? 5 : nr &gt; dev-&gt;rlen ? 5 : nr;</div><div class='del'>-	DEBUGP(4, dev, "dev-&gt;rlen = %i,  dev-&gt;rpos = %i, nr = %i\n",</div><div class='del'>-	      dev-&gt;rlen, dev-&gt;rpos, nr);</div><div class='del'>-</div><div class='del'>-release_io:</div><div class='del'>-	DEBUGP(4, dev, "Reset SM\n");</div><div class='del'>-	xoutb(0x80, REG_FLAGS0(iobase));	/* reset SM */</div><div class='del'>-</div><div class='del'>-	if (rc &lt; 0) {</div><div class='del'>-		DEBUGP(4, dev, "Write failed but clear T_Active\n");</div><div class='del'>-		dev-&gt;flags1 &amp;= 0xdf;</div><div class='del'>-		xoutb(dev-&gt;flags1, REG_FLAGS1(iobase));</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	clear_bit(LOCK_IO, &amp;dev-&gt;flags);</div><div class='del'>-	wake_up_interruptible(&amp;dev-&gt;ioq);</div><div class='del'>-	wake_up_interruptible(&amp;dev-&gt;readq);	/* tell read we have data */</div><div class='del'>-</div><div class='del'>-	/* ITSEC E2: clear write buffer */</div><div class='del'>-	memset((char *)dev-&gt;sbuf, 0, 512);</div><div class='del'>-</div><div class='del'>-	/* return error or actually written bytes */</div><div class='del'>-	DEBUGP(2, dev, "&lt;- cmm_write\n");</div><div class='del'>-	return rc &lt; 0 ? rc : nr;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void start_monitor(struct cm4000_dev *dev)</div><div class='del'>-{</div><div class='del'>-	DEBUGP(3, dev, "-&gt; start_monitor\n");</div><div class='del'>-	if (!dev-&gt;monitor_running) {</div><div class='del'>-		DEBUGP(5, dev, "create, init and add timer\n");</div><div class='del'>-		timer_setup(&amp;dev-&gt;timer, monitor_card, 0);</div><div class='del'>-		dev-&gt;monitor_running = 1;</div><div class='del'>-		mod_timer(&amp;dev-&gt;timer, jiffies);</div><div class='del'>-	} else</div><div class='del'>-		DEBUGP(5, dev, "monitor already running\n");</div><div class='del'>-	DEBUGP(3, dev, "&lt;- start_monitor\n");</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void stop_monitor(struct cm4000_dev *dev)</div><div class='del'>-{</div><div class='del'>-	DEBUGP(3, dev, "-&gt; stop_monitor\n");</div><div class='del'>-	if (dev-&gt;monitor_running) {</div><div class='del'>-		DEBUGP(5, dev, "stopping monitor\n");</div><div class='del'>-		terminate_monitor(dev);</div><div class='del'>-		/* reset monitor SM */</div><div class='del'>-		clear_bit(IS_ATR_VALID, &amp;dev-&gt;flags);</div><div class='del'>-		clear_bit(IS_ATR_PRESENT, &amp;dev-&gt;flags);</div><div class='del'>-	} else</div><div class='del'>-		DEBUGP(5, dev, "monitor already stopped\n");</div><div class='del'>-	DEBUGP(3, dev, "&lt;- stop_monitor\n");</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static long cmm_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)</div><div class='del'>-{</div><div class='del'>-	struct cm4000_dev *dev = filp-&gt;private_data;</div><div class='del'>-	unsigned int iobase = dev-&gt;p_dev-&gt;resource[0]-&gt;start;</div><div class='del'>-	struct inode *inode = file_inode(filp);</div><div class='del'>-	struct pcmcia_device *link;</div><div class='del'>-	int rc;</div><div class='del'>-	void __user *argp = (void __user *)arg;</div><div class='del'>-#ifdef CM4000_DEBUG</div><div class='del'>-	char *ioctl_names[CM_IOC_MAXNR + 1] = {</div><div class='del'>-		[_IOC_NR(CM_IOCGSTATUS)] "CM_IOCGSTATUS",</div><div class='del'>-		[_IOC_NR(CM_IOCGATR)] "CM_IOCGATR",</div><div class='del'>-		[_IOC_NR(CM_IOCARDOFF)] "CM_IOCARDOFF",</div><div class='del'>-		[_IOC_NR(CM_IOCSPTS)] "CM_IOCSPTS",</div><div class='del'>-		[_IOC_NR(CM_IOSDBGLVL)] "CM4000_DBGLVL",</div><div class='del'>-	};</div><div class='del'>-	DEBUGP(3, dev, "cmm_ioctl(device=%d.%d) %s\n", imajor(inode),</div><div class='del'>-	       iminor(inode), ioctl_names[_IOC_NR(cmd)]);</div><div class='del'>-#endif</div><div class='del'>-</div><div class='del'>-	mutex_lock(&amp;cmm_mutex);</div><div class='del'>-	rc = -ENODEV;</div><div class='del'>-	link = dev_table[iminor(inode)];</div><div class='del'>-	if (!pcmcia_dev_present(link)) {</div><div class='del'>-		DEBUGP(4, dev, "DEV_OK false\n");</div><div class='del'>-		goto out;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (test_bit(IS_CMM_ABSENT, &amp;dev-&gt;flags)) {</div><div class='del'>-		DEBUGP(4, dev, "CMM_ABSENT flag set\n");</div><div class='del'>-		goto out;</div><div class='del'>-	}</div><div class='del'>-	rc = -EINVAL;</div><div class='del'>-</div><div class='del'>-	if (_IOC_TYPE(cmd) != CM_IOC_MAGIC) {</div><div class='del'>-		DEBUGP(4, dev, "ioctype mismatch\n");</div><div class='del'>-		goto out;</div><div class='del'>-	}</div><div class='del'>-	if (_IOC_NR(cmd) &gt; CM_IOC_MAXNR) {</div><div class='del'>-		DEBUGP(4, dev, "iocnr mismatch\n");</div><div class='del'>-		goto out;</div><div class='del'>-	}</div><div class='del'>-	rc = 0;</div><div class='del'>-</div><div class='del'>-	switch (cmd) {</div><div class='del'>-	case CM_IOCGSTATUS:</div><div class='del'>-		DEBUGP(4, dev, " ... in CM_IOCGSTATUS\n");</div><div class='del'>-		{</div><div class='del'>-			int status;</div><div class='del'>-</div><div class='del'>-			/* clear other bits, but leave inserted &amp; powered as</div><div class='del'>-			 * they are */</div><div class='del'>-			status = dev-&gt;flags0 &amp; 3;</div><div class='del'>-			if (test_bit(IS_ATR_PRESENT, &amp;dev-&gt;flags))</div><div class='del'>-				status |= CM_ATR_PRESENT;</div><div class='del'>-			if (test_bit(IS_ATR_VALID, &amp;dev-&gt;flags))</div><div class='del'>-				status |= CM_ATR_VALID;</div><div class='del'>-			if (test_bit(IS_CMM_ABSENT, &amp;dev-&gt;flags))</div><div class='del'>-				status |= CM_NO_READER;</div><div class='del'>-			if (test_bit(IS_BAD_CARD, &amp;dev-&gt;flags))</div><div class='del'>-				status |= CM_BAD_CARD;</div><div class='del'>-			if (copy_to_user(argp, &amp;status, sizeof(int)))</div><div class='del'>-				rc = -EFAULT;</div><div class='del'>-		}</div><div class='del'>-		break;</div><div class='del'>-	case CM_IOCGATR:</div><div class='del'>-		DEBUGP(4, dev, "... in CM_IOCGATR\n");</div><div class='del'>-		{</div><div class='del'>-			struct atreq __user *atreq = argp;</div><div class='del'>-			int tmp;</div><div class='del'>-			/* allow nonblocking io and being interrupted */</div><div class='del'>-			if (wait_event_interruptible</div><div class='del'>-			    (dev-&gt;atrq,</div><div class='del'>-			     ((filp-&gt;f_flags &amp; O_NONBLOCK)</div><div class='del'>-			      || (test_bit(IS_ATR_PRESENT, (void *)&amp;dev-&gt;flags)</div><div class='del'>-				  != 0)))) {</div><div class='del'>-				if (filp-&gt;f_flags &amp; O_NONBLOCK)</div><div class='del'>-					rc = -EAGAIN;</div><div class='del'>-				else</div><div class='del'>-					rc = -ERESTARTSYS;</div><div class='del'>-				break;</div><div class='del'>-			}</div><div class='del'>-</div><div class='del'>-			rc = -EFAULT;</div><div class='del'>-			if (test_bit(IS_ATR_VALID, &amp;dev-&gt;flags) == 0) {</div><div class='del'>-				tmp = -1;</div><div class='del'>-				if (copy_to_user(&amp;(atreq-&gt;atr_len), &amp;tmp,</div><div class='del'>-						 sizeof(int)))</div><div class='del'>-					break;</div><div class='del'>-			} else {</div><div class='del'>-				if (copy_to_user(atreq-&gt;atr, dev-&gt;atr,</div><div class='del'>-						 dev-&gt;atr_len))</div><div class='del'>-					break;</div><div class='del'>-</div><div class='del'>-				tmp = dev-&gt;atr_len;</div><div class='del'>-				if (copy_to_user(&amp;(atreq-&gt;atr_len), &amp;tmp, sizeof(int)))</div><div class='del'>-					break;</div><div class='del'>-			}</div><div class='del'>-			rc = 0;</div><div class='del'>-			break;</div><div class='del'>-		}</div><div class='del'>-	case CM_IOCARDOFF:</div><div class='del'>-</div><div class='del'>-#ifdef CM4000_DEBUG</div><div class='del'>-		DEBUGP(4, dev, "... in CM_IOCARDOFF\n");</div><div class='del'>-		if (dev-&gt;flags0 &amp; 0x01) {</div><div class='del'>-			DEBUGP(4, dev, "    Card inserted\n");</div><div class='del'>-		} else {</div><div class='del'>-			DEBUGP(2, dev, "    No card inserted\n");</div><div class='del'>-		}</div><div class='del'>-		if (dev-&gt;flags0 &amp; 0x02) {</div><div class='del'>-			DEBUGP(4, dev, "    Card powered\n");</div><div class='del'>-		} else {</div><div class='del'>-			DEBUGP(2, dev, "    Card not powered\n");</div><div class='del'>-		}</div><div class='del'>-#endif</div><div class='del'>-</div><div class='del'>-		/* is a card inserted and powered? */</div><div class='del'>-		if ((dev-&gt;flags0 &amp; 0x01) &amp;&amp; (dev-&gt;flags0 &amp; 0x02)) {</div><div class='del'>-</div><div class='del'>-			/* get IO lock */</div><div class='del'>-			if (wait_event_interruptible</div><div class='del'>-			    (dev-&gt;ioq,</div><div class='del'>-			     ((filp-&gt;f_flags &amp; O_NONBLOCK)</div><div class='del'>-			      || (test_and_set_bit(LOCK_IO, (void *)&amp;dev-&gt;flags)</div><div class='del'>-				  == 0)))) {</div><div class='del'>-				if (filp-&gt;f_flags &amp; O_NONBLOCK)</div><div class='del'>-					rc = -EAGAIN;</div><div class='del'>-				else</div><div class='del'>-					rc = -ERESTARTSYS;</div><div class='del'>-				break;</div><div class='del'>-			}</div><div class='del'>-			/* Set Flags0 = 0x42 */</div><div class='del'>-			DEBUGP(4, dev, "Set Flags0=0x42 \n");</div><div class='del'>-			xoutb(0x42, REG_FLAGS0(iobase));</div><div class='del'>-			clear_bit(IS_ATR_PRESENT, &amp;dev-&gt;flags);</div><div class='del'>-			clear_bit(IS_ATR_VALID, &amp;dev-&gt;flags);</div><div class='del'>-			dev-&gt;mstate = M_CARDOFF;</div><div class='del'>-			clear_bit(LOCK_IO, &amp;dev-&gt;flags);</div><div class='del'>-			if (wait_event_interruptible</div><div class='del'>-			    (dev-&gt;atrq,</div><div class='del'>-			     ((filp-&gt;f_flags &amp; O_NONBLOCK)</div><div class='del'>-			      || (test_bit(IS_ATR_VALID, (void *)&amp;dev-&gt;flags) !=</div><div class='del'>-				  0)))) {</div><div class='del'>-				if (filp-&gt;f_flags &amp; O_NONBLOCK)</div><div class='del'>-					rc = -EAGAIN;</div><div class='del'>-				else</div><div class='del'>-					rc = -ERESTARTSYS;</div><div class='del'>-				break;</div><div class='del'>-			}</div><div class='del'>-		}</div><div class='del'>-		/* release lock */</div><div class='del'>-		clear_bit(LOCK_IO, &amp;dev-&gt;flags);</div><div class='del'>-		wake_up_interruptible(&amp;dev-&gt;ioq);</div><div class='del'>-</div><div class='del'>-		rc = 0;</div><div class='del'>-		break;</div><div class='del'>-	case CM_IOCSPTS:</div><div class='del'>-		{</div><div class='del'>-			struct ptsreq krnptsreq;</div><div class='del'>-</div><div class='del'>-			if (copy_from_user(&amp;krnptsreq, argp,</div><div class='del'>-					   sizeof(struct ptsreq))) {</div><div class='del'>-				rc = -EFAULT;</div><div class='del'>-				break;</div><div class='del'>-			}</div><div class='del'>-</div><div class='del'>-			rc = 0;</div><div class='del'>-			DEBUGP(4, dev, "... in CM_IOCSPTS\n");</div><div class='del'>-			/* wait for ATR to get valid */</div><div class='del'>-			if (wait_event_interruptible</div><div class='del'>-			    (dev-&gt;atrq,</div><div class='del'>-			     ((filp-&gt;f_flags &amp; O_NONBLOCK)</div><div class='del'>-			      || (test_bit(IS_ATR_PRESENT, (void *)&amp;dev-&gt;flags)</div><div class='del'>-				  != 0)))) {</div><div class='del'>-				if (filp-&gt;f_flags &amp; O_NONBLOCK)</div><div class='del'>-					rc = -EAGAIN;</div><div class='del'>-				else</div><div class='del'>-					rc = -ERESTARTSYS;</div><div class='del'>-				break;</div><div class='del'>-			}</div><div class='del'>-			/* get IO lock */</div><div class='del'>-			if (wait_event_interruptible</div><div class='del'>-			    (dev-&gt;ioq,</div><div class='del'>-			     ((filp-&gt;f_flags &amp; O_NONBLOCK)</div><div class='del'>-			      || (test_and_set_bit(LOCK_IO, (void *)&amp;dev-&gt;flags)</div><div class='del'>-				  == 0)))) {</div><div class='del'>-				if (filp-&gt;f_flags &amp; O_NONBLOCK)</div><div class='del'>-					rc = -EAGAIN;</div><div class='del'>-				else</div><div class='del'>-					rc = -ERESTARTSYS;</div><div class='del'>-				break;</div><div class='del'>-			}</div><div class='del'>-</div><div class='del'>-			if ((rc = set_protocol(dev, &amp;krnptsreq)) != 0) {</div><div class='del'>-				/* auto power_on again */</div><div class='del'>-				dev-&gt;mstate = M_FETCH_ATR;</div><div class='del'>-				clear_bit(IS_ATR_VALID, &amp;dev-&gt;flags);</div><div class='del'>-			}</div><div class='del'>-			/* release lock */</div><div class='del'>-			clear_bit(LOCK_IO, &amp;dev-&gt;flags);</div><div class='del'>-			wake_up_interruptible(&amp;dev-&gt;ioq);</div><div class='del'>-</div><div class='del'>-		}</div><div class='del'>-		break;</div><div class='del'>-#ifdef CM4000_DEBUG</div><div class='del'>-	case CM_IOSDBGLVL:</div><div class='del'>-		rc = -ENOTTY;</div><div class='del'>-		break;</div><div class='del'>-#endif</div><div class='del'>-	default:</div><div class='del'>-		DEBUGP(4, dev, "... in default (unknown IOCTL code)\n");</div><div class='del'>-		rc = -ENOTTY;</div><div class='del'>-	}</div><div class='del'>-out:</div><div class='del'>-	mutex_unlock(&amp;cmm_mutex);</div><div class='del'>-	return rc;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int cmm_open(struct inode *inode, struct file *filp)</div><div class='del'>-{</div><div class='del'>-	struct cm4000_dev *dev;</div><div class='del'>-	struct pcmcia_device *link;</div><div class='del'>-	int minor = iminor(inode);</div><div class='del'>-	int ret;</div><div class='del'>-</div><div class='del'>-	if (minor &gt;= CM4000_MAX_DEV)</div><div class='del'>-		return -ENODEV;</div><div class='del'>-</div><div class='del'>-	mutex_lock(&amp;cmm_mutex);</div><div class='del'>-	link = dev_table[minor];</div><div class='del'>-	if (link == NULL || !pcmcia_dev_present(link)) {</div><div class='del'>-		ret = -ENODEV;</div><div class='del'>-		goto out;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (link-&gt;open) {</div><div class='del'>-		ret = -EBUSY;</div><div class='del'>-		goto out;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	dev = link-&gt;priv;</div><div class='del'>-	filp-&gt;private_data = dev;</div><div class='del'>-</div><div class='del'>-	DEBUGP(2, dev, "-&gt; cmm_open(device=%d.%d process=%s,%d)\n",</div><div class='del'>-	      imajor(inode), minor, current-&gt;comm, current-&gt;pid);</div><div class='del'>-</div><div class='del'>-	/* init device variables, they may be "polluted" after close</div><div class='del'>-	 * or, the device may never have been closed (i.e. open failed)</div><div class='del'>-	 */</div><div class='del'>-</div><div class='del'>-	ZERO_DEV(dev);</div><div class='del'>-</div><div class='del'>-	/* opening will always block since the</div><div class='del'>-	 * monitor will be started by open, which</div><div class='del'>-	 * means we have to wait for ATR becoming</div><div class='del'>-	 * valid = block until valid (or card</div><div class='del'>-	 * inserted)</div><div class='del'>-	 */</div><div class='del'>-	if (filp-&gt;f_flags &amp; O_NONBLOCK) {</div><div class='del'>-		ret = -EAGAIN;</div><div class='del'>-		goto out;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	dev-&gt;mdelay = T_50MSEC;</div><div class='del'>-</div><div class='del'>-	/* start monitoring the cardstatus */</div><div class='del'>-	start_monitor(dev);</div><div class='del'>-</div><div class='del'>-	link-&gt;open = 1;		/* only one open per device */</div><div class='del'>-</div><div class='del'>-	DEBUGP(2, dev, "&lt;- cmm_open\n");</div><div class='del'>-	ret = stream_open(inode, filp);</div><div class='del'>-out:</div><div class='del'>-	mutex_unlock(&amp;cmm_mutex);</div><div class='del'>-	return ret;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int cmm_close(struct inode *inode, struct file *filp)</div><div class='del'>-{</div><div class='del'>-	struct cm4000_dev *dev;</div><div class='del'>-	struct pcmcia_device *link;</div><div class='del'>-	int minor = iminor(inode);</div><div class='del'>-</div><div class='del'>-	if (minor &gt;= CM4000_MAX_DEV)</div><div class='del'>-		return -ENODEV;</div><div class='del'>-</div><div class='del'>-	link = dev_table[minor];</div><div class='del'>-	if (link == NULL)</div><div class='del'>-		return -ENODEV;</div><div class='del'>-</div><div class='del'>-	dev = link-&gt;priv;</div><div class='del'>-</div><div class='del'>-	DEBUGP(2, dev, "-&gt; cmm_close(maj/min=%d.%d)\n",</div><div class='del'>-	       imajor(inode), minor);</div><div class='del'>-</div><div class='del'>-	stop_monitor(dev);</div><div class='del'>-</div><div class='del'>-	ZERO_DEV(dev);</div><div class='del'>-</div><div class='del'>-	link-&gt;open = 0;		/* only one open per device */</div><div class='del'>-	wake_up(&amp;dev-&gt;devq);	/* socket removed? */</div><div class='del'>-</div><div class='del'>-	DEBUGP(2, dev, "cmm_close\n");</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void cmm_cm4000_release(struct pcmcia_device * link)</div><div class='del'>-{</div><div class='del'>-	struct cm4000_dev *dev = link-&gt;priv;</div><div class='del'>-</div><div class='del'>-	/* dont terminate the monitor, rather rely on</div><div class='del'>-	 * close doing that for us.</div><div class='del'>-	 */</div><div class='del'>-	DEBUGP(3, dev, "-&gt; cmm_cm4000_release\n");</div><div class='del'>-	while (link-&gt;open) {</div><div class='del'>-		printk(KERN_INFO MODULE_NAME ": delaying release until "</div><div class='del'>-		       "process has terminated\n");</div><div class='del'>-		/* note: don't interrupt us:</div><div class='del'>-		 * close the applications which own</div><div class='del'>-		 * the devices _first_ !</div><div class='del'>-		 */</div><div class='del'>-		wait_event(dev-&gt;devq, (link-&gt;open == 0));</div><div class='del'>-	}</div><div class='del'>-	/* dev-&gt;devq=NULL;	this cannot be zeroed earlier */</div><div class='del'>-	DEBUGP(3, dev, "&lt;- cmm_cm4000_release\n");</div><div class='del'>-	return;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/*==== Interface to PCMCIA Layer =======================================*/</div><div class='del'>-</div><div class='del'>-static int cm4000_config_check(struct pcmcia_device *p_dev, void *priv_data)</div><div class='del'>-{</div><div class='del'>-	return pcmcia_request_io(p_dev);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int cm4000_config(struct pcmcia_device * link, int devno)</div><div class='del'>-{</div><div class='del'>-	link-&gt;config_flags |= CONF_AUTO_SET_IO;</div><div class='del'>-</div><div class='del'>-	/* read the config-tuples */</div><div class='del'>-	if (pcmcia_loop_config(link, cm4000_config_check, NULL))</div><div class='del'>-		goto cs_release;</div><div class='del'>-</div><div class='del'>-	if (pcmcia_enable_device(link))</div><div class='del'>-		goto cs_release;</div><div class='del'>-</div><div class='del'>-	return 0;</div><div class='del'>-</div><div class='del'>-cs_release:</div><div class='del'>-	cm4000_release(link);</div><div class='del'>-	return -ENODEV;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int cm4000_suspend(struct pcmcia_device *link)</div><div class='del'>-{</div><div class='del'>-	struct cm4000_dev *dev;</div><div class='del'>-</div><div class='del'>-	dev = link-&gt;priv;</div><div class='del'>-	stop_monitor(dev);</div><div class='del'>-</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int cm4000_resume(struct pcmcia_device *link)</div><div class='del'>-{</div><div class='del'>-	struct cm4000_dev *dev;</div><div class='del'>-</div><div class='del'>-	dev = link-&gt;priv;</div><div class='del'>-	if (link-&gt;open)</div><div class='del'>-		start_monitor(dev);</div><div class='del'>-</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void cm4000_release(struct pcmcia_device *link)</div><div class='del'>-{</div><div class='del'>-	cmm_cm4000_release(link);	/* delay release until device closed */</div><div class='del'>-	pcmcia_disable_device(link);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int cm4000_probe(struct pcmcia_device *link)</div><div class='del'>-{</div><div class='del'>-	struct cm4000_dev *dev;</div><div class='del'>-	int i, ret;</div><div class='del'>-</div><div class='del'>-	for (i = 0; i &lt; CM4000_MAX_DEV; i++)</div><div class='del'>-		if (dev_table[i] == NULL)</div><div class='del'>-			break;</div><div class='del'>-</div><div class='del'>-	if (i == CM4000_MAX_DEV) {</div><div class='del'>-		printk(KERN_NOTICE MODULE_NAME ": all devices in use\n");</div><div class='del'>-		return -ENODEV;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	/* create a new cm4000_cs device */</div><div class='del'>-	dev = kzalloc(sizeof(struct cm4000_dev), GFP_KERNEL);</div><div class='del'>-	if (dev == NULL)</div><div class='del'>-		return -ENOMEM;</div><div class='del'>-</div><div class='del'>-	dev-&gt;p_dev = link;</div><div class='del'>-	link-&gt;priv = dev;</div><div class='del'>-	dev_table[i] = link;</div><div class='del'>-</div><div class='del'>-	init_waitqueue_head(&amp;dev-&gt;devq);</div><div class='del'>-	init_waitqueue_head(&amp;dev-&gt;ioq);</div><div class='del'>-	init_waitqueue_head(&amp;dev-&gt;atrq);</div><div class='del'>-	init_waitqueue_head(&amp;dev-&gt;readq);</div><div class='del'>-</div><div class='del'>-	ret = cm4000_config(link, i);</div><div class='del'>-	if (ret) {</div><div class='del'>-		dev_table[i] = NULL;</div><div class='del'>-		kfree(dev);</div><div class='del'>-		return ret;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	device_create(cmm_class, NULL, MKDEV(major, i), NULL, "cmm%d", i);</div><div class='del'>-</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void cm4000_detach(struct pcmcia_device *link)</div><div class='del'>-{</div><div class='del'>-	struct cm4000_dev *dev = link-&gt;priv;</div><div class='del'>-	int devno;</div><div class='del'>-</div><div class='del'>-	/* find device */</div><div class='del'>-	for (devno = 0; devno &lt; CM4000_MAX_DEV; devno++)</div><div class='del'>-		if (dev_table[devno] == link)</div><div class='del'>-			break;</div><div class='del'>-	if (devno == CM4000_MAX_DEV)</div><div class='del'>-		return;</div><div class='del'>-</div><div class='del'>-	stop_monitor(dev);</div><div class='del'>-</div><div class='del'>-	cm4000_release(link);</div><div class='del'>-</div><div class='del'>-	dev_table[devno] = NULL;</div><div class='del'>-	kfree(dev);</div><div class='del'>-</div><div class='del'>-	device_destroy(cmm_class, MKDEV(major, devno));</div><div class='del'>-</div><div class='del'>-	return;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static const struct file_operations cm4000_fops = {</div><div class='del'>-	.owner	= THIS_MODULE,</div><div class='del'>-	.read	= cmm_read,</div><div class='del'>-	.write	= cmm_write,</div><div class='del'>-	.unlocked_ioctl	= cmm_ioctl,</div><div class='del'>-	.open	= cmm_open,</div><div class='del'>-	.release= cmm_close,</div><div class='del'>-	.llseek = no_llseek,</div><div class='del'>-};</div><div class='del'>-</div><div class='del'>-static const struct pcmcia_device_id cm4000_ids[] = {</div><div class='del'>-	PCMCIA_DEVICE_MANF_CARD(0x0223, 0x0002),</div><div class='del'>-	PCMCIA_DEVICE_PROD_ID12("CardMan", "4000", 0x2FB368CA, 0xA2BD8C39),</div><div class='del'>-	PCMCIA_DEVICE_NULL,</div><div class='del'>-};</div><div class='del'>-MODULE_DEVICE_TABLE(pcmcia, cm4000_ids);</div><div class='del'>-</div><div class='del'>-static struct pcmcia_driver cm4000_driver = {</div><div class='del'>-	.owner	  = THIS_MODULE,</div><div class='del'>-	.name	  = "cm4000_cs",</div><div class='del'>-	.probe    = cm4000_probe,</div><div class='del'>-	.remove   = cm4000_detach,</div><div class='del'>-	.suspend  = cm4000_suspend,</div><div class='del'>-	.resume   = cm4000_resume,</div><div class='del'>-	.id_table = cm4000_ids,</div><div class='del'>-};</div><div class='del'>-</div><div class='del'>-static int __init cmm_init(void)</div><div class='del'>-{</div><div class='del'>-	int rc;</div><div class='del'>-</div><div class='del'>-	cmm_class = class_create(THIS_MODULE, "cardman_4000");</div><div class='del'>-	if (IS_ERR(cmm_class))</div><div class='del'>-		return PTR_ERR(cmm_class);</div><div class='del'>-</div><div class='del'>-	major = register_chrdev(0, DEVICE_NAME, &amp;cm4000_fops);</div><div class='del'>-	if (major &lt; 0) {</div><div class='del'>-		printk(KERN_WARNING MODULE_NAME</div><div class='del'>-			": could not get major number\n");</div><div class='del'>-		class_destroy(cmm_class);</div><div class='del'>-		return major;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	rc = pcmcia_register_driver(&amp;cm4000_driver);</div><div class='del'>-	if (rc &lt; 0) {</div><div class='del'>-		unregister_chrdev(major, DEVICE_NAME);</div><div class='del'>-		class_destroy(cmm_class);</div><div class='del'>-		return rc;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void __exit cmm_exit(void)</div><div class='del'>-{</div><div class='del'>-	pcmcia_unregister_driver(&amp;cm4000_driver);</div><div class='del'>-	unregister_chrdev(major, DEVICE_NAME);</div><div class='del'>-	class_destroy(cmm_class);</div><div class='del'>-};</div><div class='del'>-</div><div class='del'>-module_init(cmm_init);</div><div class='del'>-module_exit(cmm_exit);</div><div class='del'>-MODULE_LICENSE("Dual BSD/GPL");</div><div class='head'>diff --git a/drivers/char/pcmcia/cm4040_cs.c b/drivers/char/pcmcia/cm4040_cs.c<br/>deleted file mode 100644<br/>index 827711911da410..00000000000000<br/>--- a/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/pcmcia/cm4040_cs.c?id=3996954fa071aa20945c8ac7694684fa3c1fed68'>drivers/char/pcmcia/cm4040_cs.c</a><br/>+++ /dev/null</div><div class='hunk'>@@ -1,684 +0,0 @@</div><div class='del'>-/*</div><div class='del'>- * A driver for the Omnikey PCMCIA smartcard reader CardMan 4040</div><div class='del'>- *</div><div class='del'>- * (c) 2000-2004 Omnikey AG (http://www.omnikey.com/)</div><div class='del'>- *</div><div class='del'>- * (C) 2005-2006 Harald Welte &lt;laforge@gnumonks.org&gt;</div><div class='del'>- * 	- add support for poll()</div><div class='del'>- * 	- driver cleanup</div><div class='del'>- * 	- add waitqueues</div><div class='del'>- * 	- adhere to linux kernel coding style and policies</div><div class='del'>- * 	- support 2.6.13 "new style" pcmcia interface</div><div class='del'>- * 	- add class interface for udev device creation</div><div class='del'>- *</div><div class='del'>- * The device basically is a USB CCID compliant device that has been</div><div class='del'>- * attached to an I/O-Mapped FIFO.</div><div class='del'>- *</div><div class='del'>- * All rights reserved, Dual BSD/GPL Licensed.</div><div class='del'>- */</div><div class='del'>-</div><div class='del'>-#include &lt;linux/kernel.h&gt;</div><div class='del'>-#include &lt;linux/module.h&gt;</div><div class='del'>-#include &lt;linux/slab.h&gt;</div><div class='del'>-#include &lt;linux/init.h&gt;</div><div class='del'>-#include &lt;linux/fs.h&gt;</div><div class='del'>-#include &lt;linux/delay.h&gt;</div><div class='del'>-#include &lt;linux/poll.h&gt;</div><div class='del'>-#include &lt;linux/mutex.h&gt;</div><div class='del'>-#include &lt;linux/wait.h&gt;</div><div class='del'>-#include &lt;linux/uaccess.h&gt;</div><div class='del'>-#include &lt;asm/io.h&gt;</div><div class='del'>-</div><div class='del'>-#include &lt;pcmcia/cistpl.h&gt;</div><div class='del'>-#include &lt;pcmcia/cisreg.h&gt;</div><div class='del'>-#include &lt;pcmcia/ciscode.h&gt;</div><div class='del'>-#include &lt;pcmcia/ds.h&gt;</div><div class='del'>-</div><div class='del'>-#include "cm4040_cs.h"</div><div class='del'>-</div><div class='del'>-</div><div class='del'>-#define reader_to_dev(x)	(&amp;x-&gt;p_dev-&gt;dev)</div><div class='del'>-</div><div class='del'>-/* n (debug level) is ignored */</div><div class='del'>-/* additional debug output may be enabled by re-compiling with</div><div class='del'>- * CM4040_DEBUG set */</div><div class='del'>-/* #define CM4040_DEBUG */</div><div class='del'>-#define DEBUGP(n, rdr, x, args...) do { 		\</div><div class='del'>-		dev_dbg(reader_to_dev(rdr), "%s:" x, 	\</div><div class='del'>-			   __func__ , ## args);		\</div><div class='del'>-	} while (0)</div><div class='del'>-</div><div class='del'>-static DEFINE_MUTEX(cm4040_mutex);</div><div class='del'>-</div><div class='del'>-#define	CCID_DRIVER_BULK_DEFAULT_TIMEOUT  	(150*HZ)</div><div class='del'>-#define	CCID_DRIVER_ASYNC_POWERUP_TIMEOUT 	(35*HZ)</div><div class='del'>-#define	CCID_DRIVER_MINIMUM_TIMEOUT 		(3*HZ)</div><div class='del'>-#define READ_WRITE_BUFFER_SIZE 512</div><div class='del'>-#define POLL_LOOP_COUNT				1000</div><div class='del'>-</div><div class='del'>-/* how often to poll for fifo status change */</div><div class='del'>-#define POLL_PERIOD 				msecs_to_jiffies(10)</div><div class='del'>-</div><div class='del'>-static void reader_release(struct pcmcia_device *link);</div><div class='del'>-</div><div class='del'>-static int major;</div><div class='del'>-static struct class *cmx_class;</div><div class='del'>-</div><div class='del'>-#define		BS_READABLE	0x01</div><div class='del'>-#define		BS_WRITABLE	0x02</div><div class='del'>-</div><div class='del'>-struct reader_dev {</div><div class='del'>-	struct pcmcia_device	*p_dev;</div><div class='del'>-	wait_queue_head_t	devq;</div><div class='del'>-	wait_queue_head_t	poll_wait;</div><div class='del'>-	wait_queue_head_t	read_wait;</div><div class='del'>-	wait_queue_head_t	write_wait;</div><div class='del'>-	unsigned long 	  	buffer_status;</div><div class='del'>-	unsigned long     	timeout;</div><div class='del'>-	unsigned char     	s_buf[READ_WRITE_BUFFER_SIZE];</div><div class='del'>-	unsigned char     	r_buf[READ_WRITE_BUFFER_SIZE];</div><div class='del'>-	struct timer_list 	poll_timer;</div><div class='del'>-};</div><div class='del'>-</div><div class='del'>-static struct pcmcia_device *dev_table[CM_MAX_DEV];</div><div class='del'>-</div><div class='del'>-#ifndef CM4040_DEBUG</div><div class='del'>-#define	xoutb	outb</div><div class='del'>-#define	xinb	inb</div><div class='del'>-#else</div><div class='del'>-static inline void xoutb(unsigned char val, unsigned short port)</div><div class='del'>-{</div><div class='del'>-	pr_debug("outb(val=%.2x,port=%.4x)\n", val, port);</div><div class='del'>-	outb(val, port);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static inline unsigned char xinb(unsigned short port)</div><div class='del'>-{</div><div class='del'>-	unsigned char val;</div><div class='del'>-</div><div class='del'>-	val = inb(port);</div><div class='del'>-	pr_debug("%.2x=inb(%.4x)\n", val, port);</div><div class='del'>-	return val;</div><div class='del'>-}</div><div class='del'>-#endif</div><div class='del'>-</div><div class='del'>-/* poll the device fifo status register.  not to be confused with</div><div class='del'>- * the poll syscall. */</div><div class='del'>-static void cm4040_do_poll(struct timer_list *t)</div><div class='del'>-{</div><div class='del'>-	struct reader_dev *dev = from_timer(dev, t, poll_timer);</div><div class='del'>-	unsigned int obs = xinb(dev-&gt;p_dev-&gt;resource[0]-&gt;start</div><div class='del'>-				+ REG_OFFSET_BUFFER_STATUS);</div><div class='del'>-</div><div class='del'>-	if ((obs &amp; BSR_BULK_IN_FULL)) {</div><div class='del'>-		set_bit(BS_READABLE, &amp;dev-&gt;buffer_status);</div><div class='del'>-		DEBUGP(4, dev, "waking up read_wait\n");</div><div class='del'>-		wake_up_interruptible(&amp;dev-&gt;read_wait);</div><div class='del'>-	} else</div><div class='del'>-		clear_bit(BS_READABLE, &amp;dev-&gt;buffer_status);</div><div class='del'>-</div><div class='del'>-	if (!(obs &amp; BSR_BULK_OUT_FULL)) {</div><div class='del'>-		set_bit(BS_WRITABLE, &amp;dev-&gt;buffer_status);</div><div class='del'>-		DEBUGP(4, dev, "waking up write_wait\n");</div><div class='del'>-		wake_up_interruptible(&amp;dev-&gt;write_wait);</div><div class='del'>-	} else</div><div class='del'>-		clear_bit(BS_WRITABLE, &amp;dev-&gt;buffer_status);</div><div class='del'>-</div><div class='del'>-	if (dev-&gt;buffer_status)</div><div class='del'>-		wake_up_interruptible(&amp;dev-&gt;poll_wait);</div><div class='del'>-</div><div class='del'>-	mod_timer(&amp;dev-&gt;poll_timer, jiffies + POLL_PERIOD);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void cm4040_stop_poll(struct reader_dev *dev)</div><div class='del'>-{</div><div class='del'>-	del_timer_sync(&amp;dev-&gt;poll_timer);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int wait_for_bulk_out_ready(struct reader_dev *dev)</div><div class='del'>-{</div><div class='del'>-	int i, rc;</div><div class='del'>-	int iobase = dev-&gt;p_dev-&gt;resource[0]-&gt;start;</div><div class='del'>-</div><div class='del'>-	for (i = 0; i &lt; POLL_LOOP_COUNT; i++) {</div><div class='del'>-		if ((xinb(iobase + REG_OFFSET_BUFFER_STATUS)</div><div class='del'>-		    &amp; BSR_BULK_OUT_FULL) == 0) {</div><div class='del'>-			DEBUGP(4, dev, "BulkOut empty (i=%d)\n", i);</div><div class='del'>-			return 1;</div><div class='del'>-		}</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	DEBUGP(4, dev, "wait_event_interruptible_timeout(timeout=%ld\n",</div><div class='del'>-		dev-&gt;timeout);</div><div class='del'>-	rc = wait_event_interruptible_timeout(dev-&gt;write_wait,</div><div class='del'>-					      test_and_clear_bit(BS_WRITABLE,</div><div class='del'>-						       &amp;dev-&gt;buffer_status),</div><div class='del'>-					      dev-&gt;timeout);</div><div class='del'>-</div><div class='del'>-	if (rc &gt; 0)</div><div class='del'>-		DEBUGP(4, dev, "woke up: BulkOut empty\n");</div><div class='del'>-	else if (rc == 0)</div><div class='del'>-		DEBUGP(4, dev, "woke up: BulkOut full, returning 0 :(\n");</div><div class='del'>-	else if (rc &lt; 0)</div><div class='del'>-		DEBUGP(4, dev, "woke up: signal arrived\n");</div><div class='del'>-</div><div class='del'>-	return rc;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Write to Sync Control Register */</div><div class='del'>-static int write_sync_reg(unsigned char val, struct reader_dev *dev)</div><div class='del'>-{</div><div class='del'>-	int iobase = dev-&gt;p_dev-&gt;resource[0]-&gt;start;</div><div class='del'>-	int rc;</div><div class='del'>-</div><div class='del'>-	rc = wait_for_bulk_out_ready(dev);</div><div class='del'>-	if (rc &lt;= 0)</div><div class='del'>-		return rc;</div><div class='del'>-</div><div class='del'>-	xoutb(val, iobase + REG_OFFSET_SYNC_CONTROL);</div><div class='del'>-	rc = wait_for_bulk_out_ready(dev);</div><div class='del'>-	if (rc &lt;= 0)</div><div class='del'>-		return rc;</div><div class='del'>-</div><div class='del'>-	return 1;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int wait_for_bulk_in_ready(struct reader_dev *dev)</div><div class='del'>-{</div><div class='del'>-	int i, rc;</div><div class='del'>-	int iobase = dev-&gt;p_dev-&gt;resource[0]-&gt;start;</div><div class='del'>-</div><div class='del'>-	for (i = 0; i &lt; POLL_LOOP_COUNT; i++) {</div><div class='del'>-		if ((xinb(iobase + REG_OFFSET_BUFFER_STATUS)</div><div class='del'>-		    &amp; BSR_BULK_IN_FULL) == BSR_BULK_IN_FULL) {</div><div class='del'>-			DEBUGP(3, dev, "BulkIn full (i=%d)\n", i);</div><div class='del'>-			return 1;</div><div class='del'>-		}</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	DEBUGP(4, dev, "wait_event_interruptible_timeout(timeout=%ld\n",</div><div class='del'>-		dev-&gt;timeout);</div><div class='del'>-	rc = wait_event_interruptible_timeout(dev-&gt;read_wait,</div><div class='del'>-					      test_and_clear_bit(BS_READABLE,</div><div class='del'>-						 	&amp;dev-&gt;buffer_status),</div><div class='del'>-					      dev-&gt;timeout);</div><div class='del'>-	if (rc &gt; 0)</div><div class='del'>-		DEBUGP(4, dev, "woke up: BulkIn full\n");</div><div class='del'>-	else if (rc == 0)</div><div class='del'>-		DEBUGP(4, dev, "woke up: BulkIn not full, returning 0 :(\n");</div><div class='del'>-	else if (rc &lt; 0)</div><div class='del'>-		DEBUGP(4, dev, "woke up: signal arrived\n");</div><div class='del'>-</div><div class='del'>-	return rc;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static ssize_t cm4040_read(struct file *filp, char __user *buf,</div><div class='del'>-			size_t count, loff_t *ppos)</div><div class='del'>-{</div><div class='del'>-	struct reader_dev *dev = filp-&gt;private_data;</div><div class='del'>-	int iobase = dev-&gt;p_dev-&gt;resource[0]-&gt;start;</div><div class='del'>-	size_t bytes_to_read;</div><div class='del'>-	unsigned long i;</div><div class='del'>-	size_t min_bytes_to_read;</div><div class='del'>-	int rc;</div><div class='del'>-</div><div class='del'>-	DEBUGP(2, dev, "-&gt; cm4040_read(%s,%d)\n", current-&gt;comm, current-&gt;pid);</div><div class='del'>-</div><div class='del'>-	if (count == 0)</div><div class='del'>-		return 0;</div><div class='del'>-</div><div class='del'>-	if (count &lt; 10)</div><div class='del'>-		return -EFAULT;</div><div class='del'>-</div><div class='del'>-	if (filp-&gt;f_flags &amp; O_NONBLOCK) {</div><div class='del'>-		DEBUGP(4, dev, "filep-&gt;f_flags O_NONBLOCK set\n");</div><div class='del'>-		DEBUGP(2, dev, "&lt;- cm4040_read (failure)\n");</div><div class='del'>-		return -EAGAIN;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (!pcmcia_dev_present(dev-&gt;p_dev))</div><div class='del'>-		return -ENODEV;</div><div class='del'>-</div><div class='del'>-	for (i = 0; i &lt; 5; i++) {</div><div class='del'>-		rc = wait_for_bulk_in_ready(dev);</div><div class='del'>-		if (rc &lt;= 0) {</div><div class='del'>-			DEBUGP(5, dev, "wait_for_bulk_in_ready rc=%.2x\n", rc);</div><div class='del'>-			DEBUGP(2, dev, "&lt;- cm4040_read (failed)\n");</div><div class='del'>-			if (rc == -ERESTARTSYS)</div><div class='del'>-				return rc;</div><div class='del'>-			return -EIO;</div><div class='del'>-		}</div><div class='del'>-	  	dev-&gt;r_buf[i] = xinb(iobase + REG_OFFSET_BULK_IN);</div><div class='del'>-#ifdef CM4040_DEBUG</div><div class='del'>-		pr_debug("%lu:%2x ", i, dev-&gt;r_buf[i]);</div><div class='del'>-	}</div><div class='del'>-	pr_debug("\n");</div><div class='del'>-#else</div><div class='del'>-	}</div><div class='del'>-#endif</div><div class='del'>-</div><div class='del'>-	bytes_to_read = 5 + le32_to_cpu(*(__le32 *)&amp;dev-&gt;r_buf[1]);</div><div class='del'>-</div><div class='del'>-	DEBUGP(6, dev, "BytesToRead=%zu\n", bytes_to_read);</div><div class='del'>-</div><div class='del'>-	min_bytes_to_read = min(count, bytes_to_read + 5);</div><div class='del'>-	min_bytes_to_read = min_t(size_t, min_bytes_to_read, READ_WRITE_BUFFER_SIZE);</div><div class='del'>-</div><div class='del'>-	DEBUGP(6, dev, "Min=%zu\n", min_bytes_to_read);</div><div class='del'>-</div><div class='del'>-	for (i = 0; i &lt; (min_bytes_to_read-5); i++) {</div><div class='del'>-		rc = wait_for_bulk_in_ready(dev);</div><div class='del'>-		if (rc &lt;= 0) {</div><div class='del'>-			DEBUGP(5, dev, "wait_for_bulk_in_ready rc=%.2x\n", rc);</div><div class='del'>-			DEBUGP(2, dev, "&lt;- cm4040_read (failed)\n");</div><div class='del'>-			if (rc == -ERESTARTSYS)</div><div class='del'>-				return rc;</div><div class='del'>-			return -EIO;</div><div class='del'>-		}</div><div class='del'>-		dev-&gt;r_buf[i+5] = xinb(iobase + REG_OFFSET_BULK_IN);</div><div class='del'>-#ifdef CM4040_DEBUG</div><div class='del'>-		pr_debug("%lu:%2x ", i, dev-&gt;r_buf[i]);</div><div class='del'>-	}</div><div class='del'>-	pr_debug("\n");</div><div class='del'>-#else</div><div class='del'>-	}</div><div class='del'>-#endif</div><div class='del'>-</div><div class='del'>-	*ppos = min_bytes_to_read;</div><div class='del'>-	if (copy_to_user(buf, dev-&gt;r_buf, min_bytes_to_read))</div><div class='del'>-		return -EFAULT;</div><div class='del'>-</div><div class='del'>-	rc = wait_for_bulk_in_ready(dev);</div><div class='del'>-	if (rc &lt;= 0) {</div><div class='del'>-		DEBUGP(5, dev, "wait_for_bulk_in_ready rc=%.2x\n", rc);</div><div class='del'>-		DEBUGP(2, dev, "&lt;- cm4040_read (failed)\n");</div><div class='del'>-		if (rc == -ERESTARTSYS)</div><div class='del'>-			return rc;</div><div class='del'>-		return -EIO;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	rc = write_sync_reg(SCR_READER_TO_HOST_DONE, dev);</div><div class='del'>-	if (rc &lt;= 0) {</div><div class='del'>-		DEBUGP(5, dev, "write_sync_reg c=%.2x\n", rc);</div><div class='del'>-		DEBUGP(2, dev, "&lt;- cm4040_read (failed)\n");</div><div class='del'>-		if (rc == -ERESTARTSYS)</div><div class='del'>-			return rc;</div><div class='del'>-		else</div><div class='del'>-			return -EIO;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	xinb(iobase + REG_OFFSET_BULK_IN);</div><div class='del'>-</div><div class='del'>-	DEBUGP(2, dev, "&lt;- cm4040_read (successfully)\n");</div><div class='del'>-	return min_bytes_to_read;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static ssize_t cm4040_write(struct file *filp, const char __user *buf,</div><div class='del'>-			 size_t count, loff_t *ppos)</div><div class='del'>-{</div><div class='del'>-	struct reader_dev *dev = filp-&gt;private_data;</div><div class='del'>-	int iobase = dev-&gt;p_dev-&gt;resource[0]-&gt;start;</div><div class='del'>-	ssize_t rc;</div><div class='del'>-	int i;</div><div class='del'>-	unsigned int bytes_to_write;</div><div class='del'>-</div><div class='del'>-	DEBUGP(2, dev, "-&gt; cm4040_write(%s,%d)\n", current-&gt;comm, current-&gt;pid);</div><div class='del'>-</div><div class='del'>-	if (count == 0) {</div><div class='del'>-		DEBUGP(2, dev, "&lt;- cm4040_write empty read (successfully)\n");</div><div class='del'>-		return 0;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if ((count &lt; 5) || (count &gt; READ_WRITE_BUFFER_SIZE)) {</div><div class='del'>-		DEBUGP(2, dev, "&lt;- cm4040_write buffersize=%zd &lt; 5\n", count);</div><div class='del'>-		return -EIO;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (filp-&gt;f_flags &amp; O_NONBLOCK) {</div><div class='del'>-		DEBUGP(4, dev, "filep-&gt;f_flags O_NONBLOCK set\n");</div><div class='del'>-		DEBUGP(4, dev, "&lt;- cm4040_write (failure)\n");</div><div class='del'>-		return -EAGAIN;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (!pcmcia_dev_present(dev-&gt;p_dev))</div><div class='del'>-		return -ENODEV;</div><div class='del'>-</div><div class='del'>-	bytes_to_write = count;</div><div class='del'>-	if (copy_from_user(dev-&gt;s_buf, buf, bytes_to_write))</div><div class='del'>-		return -EFAULT;</div><div class='del'>-</div><div class='del'>-	switch (dev-&gt;s_buf[0]) {</div><div class='del'>-		case CMD_PC_TO_RDR_XFRBLOCK:</div><div class='del'>-		case CMD_PC_TO_RDR_SECURE:</div><div class='del'>-		case CMD_PC_TO_RDR_TEST_SECURE:</div><div class='del'>-		case CMD_PC_TO_RDR_OK_SECURE:</div><div class='del'>-			dev-&gt;timeout = CCID_DRIVER_BULK_DEFAULT_TIMEOUT;</div><div class='del'>-			break;</div><div class='del'>-</div><div class='del'>-		case CMD_PC_TO_RDR_ICCPOWERON:</div><div class='del'>-			dev-&gt;timeout = CCID_DRIVER_ASYNC_POWERUP_TIMEOUT;</div><div class='del'>-			break;</div><div class='del'>-</div><div class='del'>-		case CMD_PC_TO_RDR_GETSLOTSTATUS:</div><div class='del'>-		case CMD_PC_TO_RDR_ICCPOWEROFF:</div><div class='del'>-		case CMD_PC_TO_RDR_GETPARAMETERS:</div><div class='del'>-		case CMD_PC_TO_RDR_RESETPARAMETERS:</div><div class='del'>-		case CMD_PC_TO_RDR_SETPARAMETERS:</div><div class='del'>-		case CMD_PC_TO_RDR_ESCAPE:</div><div class='del'>-		case CMD_PC_TO_RDR_ICCCLOCK:</div><div class='del'>-		default:</div><div class='del'>-			dev-&gt;timeout = CCID_DRIVER_MINIMUM_TIMEOUT;</div><div class='del'>-			break;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	rc = write_sync_reg(SCR_HOST_TO_READER_START, dev);</div><div class='del'>-	if (rc &lt;= 0) {</div><div class='del'>-		DEBUGP(5, dev, "write_sync_reg c=%.2zx\n", rc);</div><div class='del'>-		DEBUGP(2, dev, "&lt;- cm4040_write (failed)\n");</div><div class='del'>-		if (rc == -ERESTARTSYS)</div><div class='del'>-			return rc;</div><div class='del'>-		else</div><div class='del'>-			return -EIO;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	DEBUGP(4, dev, "start \n");</div><div class='del'>-</div><div class='del'>-	for (i = 0; i &lt; bytes_to_write; i++) {</div><div class='del'>-		rc = wait_for_bulk_out_ready(dev);</div><div class='del'>-		if (rc &lt;= 0) {</div><div class='del'>-			DEBUGP(5, dev, "wait_for_bulk_out_ready rc=%.2zx\n",</div><div class='del'>-			       rc);</div><div class='del'>-			DEBUGP(2, dev, "&lt;- cm4040_write (failed)\n");</div><div class='del'>-			if (rc == -ERESTARTSYS)</div><div class='del'>-				return rc;</div><div class='del'>-			else</div><div class='del'>-				return -EIO;</div><div class='del'>-		}</div><div class='del'>-</div><div class='del'>-		xoutb(dev-&gt;s_buf[i],iobase + REG_OFFSET_BULK_OUT);</div><div class='del'>-	}</div><div class='del'>-	DEBUGP(4, dev, "end\n");</div><div class='del'>-</div><div class='del'>-	rc = write_sync_reg(SCR_HOST_TO_READER_DONE, dev);</div><div class='del'>-</div><div class='del'>-	if (rc &lt;= 0) {</div><div class='del'>-		DEBUGP(5, dev, "write_sync_reg c=%.2zx\n", rc);</div><div class='del'>-		DEBUGP(2, dev, "&lt;- cm4040_write (failed)\n");</div><div class='del'>-		if (rc == -ERESTARTSYS)</div><div class='del'>-			return rc;</div><div class='del'>-		else</div><div class='del'>-			return -EIO;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	DEBUGP(2, dev, "&lt;- cm4040_write (successfully)\n");</div><div class='del'>-	return count;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static __poll_t cm4040_poll(struct file *filp, poll_table *wait)</div><div class='del'>-{</div><div class='del'>-	struct reader_dev *dev = filp-&gt;private_data;</div><div class='del'>-	__poll_t mask = 0;</div><div class='del'>-</div><div class='del'>-	poll_wait(filp, &amp;dev-&gt;poll_wait, wait);</div><div class='del'>-</div><div class='del'>-	if (test_and_clear_bit(BS_READABLE, &amp;dev-&gt;buffer_status))</div><div class='del'>-		mask |= EPOLLIN | EPOLLRDNORM;</div><div class='del'>-	if (test_and_clear_bit(BS_WRITABLE, &amp;dev-&gt;buffer_status))</div><div class='del'>-		mask |= EPOLLOUT | EPOLLWRNORM;</div><div class='del'>-</div><div class='del'>-	DEBUGP(2, dev, "&lt;- cm4040_poll(%u)\n", mask);</div><div class='del'>-</div><div class='del'>-	return mask;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int cm4040_open(struct inode *inode, struct file *filp)</div><div class='del'>-{</div><div class='del'>-	struct reader_dev *dev;</div><div class='del'>-	struct pcmcia_device *link;</div><div class='del'>-	int minor = iminor(inode);</div><div class='del'>-	int ret;</div><div class='del'>-</div><div class='del'>-	if (minor &gt;= CM_MAX_DEV)</div><div class='del'>-		return -ENODEV;</div><div class='del'>-</div><div class='del'>-	mutex_lock(&amp;cm4040_mutex);</div><div class='del'>-	link = dev_table[minor];</div><div class='del'>-	if (link == NULL || !pcmcia_dev_present(link)) {</div><div class='del'>-		ret = -ENODEV;</div><div class='del'>-		goto out;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (link-&gt;open) {</div><div class='del'>-		ret = -EBUSY;</div><div class='del'>-		goto out;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	dev = link-&gt;priv;</div><div class='del'>-	filp-&gt;private_data = dev;</div><div class='del'>-</div><div class='del'>-	if (filp-&gt;f_flags &amp; O_NONBLOCK) {</div><div class='del'>-		DEBUGP(4, dev, "filep-&gt;f_flags O_NONBLOCK set\n");</div><div class='del'>-		ret = -EAGAIN;</div><div class='del'>-		goto out;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	link-&gt;open = 1;</div><div class='del'>-</div><div class='del'>-	mod_timer(&amp;dev-&gt;poll_timer, jiffies + POLL_PERIOD);</div><div class='del'>-</div><div class='del'>-	DEBUGP(2, dev, "&lt;- cm4040_open (successfully)\n");</div><div class='del'>-	ret = nonseekable_open(inode, filp);</div><div class='del'>-out:</div><div class='del'>-	mutex_unlock(&amp;cm4040_mutex);</div><div class='del'>-	return ret;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int cm4040_close(struct inode *inode, struct file *filp)</div><div class='del'>-{</div><div class='del'>-	struct reader_dev *dev = filp-&gt;private_data;</div><div class='del'>-	struct pcmcia_device *link;</div><div class='del'>-	int minor = iminor(inode);</div><div class='del'>-</div><div class='del'>-	DEBUGP(2, dev, "-&gt; cm4040_close(maj/min=%d.%d)\n", imajor(inode),</div><div class='del'>-	      iminor(inode));</div><div class='del'>-</div><div class='del'>-	if (minor &gt;= CM_MAX_DEV)</div><div class='del'>-		return -ENODEV;</div><div class='del'>-</div><div class='del'>-	link = dev_table[minor];</div><div class='del'>-	if (link == NULL)</div><div class='del'>-		return -ENODEV;</div><div class='del'>-</div><div class='del'>-	cm4040_stop_poll(dev);</div><div class='del'>-</div><div class='del'>-	link-&gt;open = 0;</div><div class='del'>-	wake_up(&amp;dev-&gt;devq);</div><div class='del'>-</div><div class='del'>-	DEBUGP(2, dev, "&lt;- cm4040_close\n");</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void cm4040_reader_release(struct pcmcia_device *link)</div><div class='del'>-{</div><div class='del'>-	struct reader_dev *dev = link-&gt;priv;</div><div class='del'>-</div><div class='del'>-	DEBUGP(3, dev, "-&gt; cm4040_reader_release\n");</div><div class='del'>-	while (link-&gt;open) {</div><div class='del'>-		DEBUGP(3, dev, MODULE_NAME ": delaying release "</div><div class='del'>-		       "until process has terminated\n");</div><div class='del'>- 		wait_event(dev-&gt;devq, (link-&gt;open == 0));</div><div class='del'>-	}</div><div class='del'>-	DEBUGP(3, dev, "&lt;- cm4040_reader_release\n");</div><div class='del'>-	return;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int cm4040_config_check(struct pcmcia_device *p_dev, void *priv_data)</div><div class='del'>-{</div><div class='del'>-	return pcmcia_request_io(p_dev);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-</div><div class='del'>-static int reader_config(struct pcmcia_device *link, int devno)</div><div class='del'>-{</div><div class='del'>-	struct reader_dev *dev;</div><div class='del'>-	int fail_rc;</div><div class='del'>-</div><div class='del'>-	link-&gt;config_flags |= CONF_AUTO_SET_IO;</div><div class='del'>-</div><div class='del'>-	if (pcmcia_loop_config(link, cm4040_config_check, NULL))</div><div class='del'>-		goto cs_release;</div><div class='del'>-</div><div class='del'>-	fail_rc = pcmcia_enable_device(link);</div><div class='del'>-	if (fail_rc != 0) {</div><div class='del'>-		dev_info(&amp;link-&gt;dev, "pcmcia_enable_device failed 0x%x\n",</div><div class='del'>-			 fail_rc);</div><div class='del'>-		goto cs_release;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	dev = link-&gt;priv;</div><div class='del'>-</div><div class='del'>-	DEBUGP(2, dev, "device " DEVICE_NAME "%d at %pR\n", devno,</div><div class='del'>-	      link-&gt;resource[0]);</div><div class='del'>-	DEBUGP(2, dev, "&lt;- reader_config (succ)\n");</div><div class='del'>-</div><div class='del'>-	return 0;</div><div class='del'>-</div><div class='del'>-cs_release:</div><div class='del'>-	reader_release(link);</div><div class='del'>-	return -ENODEV;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void reader_release(struct pcmcia_device *link)</div><div class='del'>-{</div><div class='del'>-	cm4040_reader_release(link);</div><div class='del'>-	pcmcia_disable_device(link);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int reader_probe(struct pcmcia_device *link)</div><div class='del'>-{</div><div class='del'>-	struct reader_dev *dev;</div><div class='del'>-	int i, ret;</div><div class='del'>-</div><div class='del'>-	for (i = 0; i &lt; CM_MAX_DEV; i++) {</div><div class='del'>-		if (dev_table[i] == NULL)</div><div class='del'>-			break;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (i == CM_MAX_DEV)</div><div class='del'>-		return -ENODEV;</div><div class='del'>-</div><div class='del'>-	dev = kzalloc(sizeof(struct reader_dev), GFP_KERNEL);</div><div class='del'>-	if (dev == NULL)</div><div class='del'>-		return -ENOMEM;</div><div class='del'>-</div><div class='del'>-	dev-&gt;timeout = CCID_DRIVER_MINIMUM_TIMEOUT;</div><div class='del'>-	dev-&gt;buffer_status = 0;</div><div class='del'>-</div><div class='del'>-	link-&gt;priv = dev;</div><div class='del'>-	dev-&gt;p_dev = link;</div><div class='del'>-</div><div class='del'>-	dev_table[i] = link;</div><div class='del'>-</div><div class='del'>-	init_waitqueue_head(&amp;dev-&gt;devq);</div><div class='del'>-	init_waitqueue_head(&amp;dev-&gt;poll_wait);</div><div class='del'>-	init_waitqueue_head(&amp;dev-&gt;read_wait);</div><div class='del'>-	init_waitqueue_head(&amp;dev-&gt;write_wait);</div><div class='del'>-	timer_setup(&amp;dev-&gt;poll_timer, cm4040_do_poll, 0);</div><div class='del'>-</div><div class='del'>-	ret = reader_config(link, i);</div><div class='del'>-	if (ret) {</div><div class='del'>-		dev_table[i] = NULL;</div><div class='del'>-		kfree(dev);</div><div class='del'>-		return ret;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	device_create(cmx_class, NULL, MKDEV(major, i), NULL, "cmx%d", i);</div><div class='del'>-</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void reader_detach(struct pcmcia_device *link)</div><div class='del'>-{</div><div class='del'>-	struct reader_dev *dev = link-&gt;priv;</div><div class='del'>-	int devno;</div><div class='del'>-</div><div class='del'>-	/* find device */</div><div class='del'>-	for (devno = 0; devno &lt; CM_MAX_DEV; devno++) {</div><div class='del'>-		if (dev_table[devno] == link)</div><div class='del'>-			break;</div><div class='del'>-	}</div><div class='del'>-	if (devno == CM_MAX_DEV)</div><div class='del'>-		return;</div><div class='del'>-</div><div class='del'>-	reader_release(link);</div><div class='del'>-</div><div class='del'>-	dev_table[devno] = NULL;</div><div class='del'>-	kfree(dev);</div><div class='del'>-</div><div class='del'>-	device_destroy(cmx_class, MKDEV(major, devno));</div><div class='del'>-</div><div class='del'>-	return;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static const struct file_operations reader_fops = {</div><div class='del'>-	.owner		= THIS_MODULE,</div><div class='del'>-	.read		= cm4040_read,</div><div class='del'>-	.write		= cm4040_write,</div><div class='del'>-	.open		= cm4040_open,</div><div class='del'>-	.release	= cm4040_close,</div><div class='del'>-	.poll		= cm4040_poll,</div><div class='del'>-	.llseek		= no_llseek,</div><div class='del'>-};</div><div class='del'>-</div><div class='del'>-static const struct pcmcia_device_id cm4040_ids[] = {</div><div class='del'>-	PCMCIA_DEVICE_MANF_CARD(0x0223, 0x0200),</div><div class='del'>-	PCMCIA_DEVICE_PROD_ID12("OMNIKEY", "CardMan 4040",</div><div class='del'>-				0xE32CDD8C, 0x8F23318B),</div><div class='del'>-	PCMCIA_DEVICE_NULL,</div><div class='del'>-};</div><div class='del'>-MODULE_DEVICE_TABLE(pcmcia, cm4040_ids);</div><div class='del'>-</div><div class='del'>-static struct pcmcia_driver reader_driver = {</div><div class='del'>-  	.owner		= THIS_MODULE,</div><div class='del'>-	.name		= "cm4040_cs",</div><div class='del'>-	.probe		= reader_probe,</div><div class='del'>-	.remove		= reader_detach,</div><div class='del'>-	.id_table	= cm4040_ids,</div><div class='del'>-};</div><div class='del'>-</div><div class='del'>-static int __init cm4040_init(void)</div><div class='del'>-{</div><div class='del'>-	int rc;</div><div class='del'>-</div><div class='del'>-	cmx_class = class_create(THIS_MODULE, "cardman_4040");</div><div class='del'>-	if (IS_ERR(cmx_class))</div><div class='del'>-		return PTR_ERR(cmx_class);</div><div class='del'>-</div><div class='del'>-	major = register_chrdev(0, DEVICE_NAME, &amp;reader_fops);</div><div class='del'>-	if (major &lt; 0) {</div><div class='del'>-		printk(KERN_WARNING MODULE_NAME</div><div class='del'>-			": could not get major number\n");</div><div class='del'>-		class_destroy(cmx_class);</div><div class='del'>-		return major;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	rc = pcmcia_register_driver(&amp;reader_driver);</div><div class='del'>-	if (rc &lt; 0) {</div><div class='del'>-		unregister_chrdev(major, DEVICE_NAME);</div><div class='del'>-		class_destroy(cmx_class);</div><div class='del'>-		return rc;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void __exit cm4040_exit(void)</div><div class='del'>-{</div><div class='del'>-	pcmcia_unregister_driver(&amp;reader_driver);</div><div class='del'>-	unregister_chrdev(major, DEVICE_NAME);</div><div class='del'>-	class_destroy(cmx_class);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-module_init(cm4040_init);</div><div class='del'>-module_exit(cm4040_exit);</div><div class='del'>-MODULE_LICENSE("Dual BSD/GPL");</div><div class='head'>diff --git a/drivers/char/pcmcia/cm4040_cs.h b/drivers/char/pcmcia/cm4040_cs.h<br/>deleted file mode 100644<br/>index e2ffff995d512a..00000000000000<br/>--- a/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/pcmcia/cm4040_cs.h?id=3996954fa071aa20945c8ac7694684fa3c1fed68'>drivers/char/pcmcia/cm4040_cs.h</a><br/>+++ /dev/null</div><div class='hunk'>@@ -1,48 +0,0 @@</div><div class='del'>-/* SPDX-License-Identifier: GPL-2.0 */</div><div class='del'>-#ifndef	_CM4040_H_</div><div class='del'>-#define	_CM4040_H_</div><div class='del'>-</div><div class='del'>-#define	CM_MAX_DEV		4</div><div class='del'>-</div><div class='del'>-#define	DEVICE_NAME		"cmx"</div><div class='del'>-#define	MODULE_NAME		"cm4040_cs"</div><div class='del'>-</div><div class='del'>-#define REG_OFFSET_BULK_OUT      0</div><div class='del'>-#define REG_OFFSET_BULK_IN       0</div><div class='del'>-#define REG_OFFSET_BUFFER_STATUS 1</div><div class='del'>-#define REG_OFFSET_SYNC_CONTROL  2</div><div class='del'>-</div><div class='del'>-#define BSR_BULK_IN_FULL  0x02</div><div class='del'>-#define BSR_BULK_OUT_FULL 0x01</div><div class='del'>-</div><div class='del'>-#define SCR_HOST_TO_READER_START 0x80</div><div class='del'>-#define SCR_ABORT                0x40</div><div class='del'>-#define SCR_EN_NOTIFY            0x20</div><div class='del'>-#define SCR_ACK_NOTIFY           0x10</div><div class='del'>-#define SCR_READER_TO_HOST_DONE  0x08</div><div class='del'>-#define SCR_HOST_TO_READER_DONE  0x04</div><div class='del'>-#define SCR_PULSE_INTERRUPT      0x02</div><div class='del'>-#define SCR_POWER_DOWN           0x01</div><div class='del'>-</div><div class='del'>-</div><div class='del'>-#define  CMD_PC_TO_RDR_ICCPOWERON       0x62</div><div class='del'>-#define  CMD_PC_TO_RDR_GETSLOTSTATUS    0x65</div><div class='del'>-#define  CMD_PC_TO_RDR_ICCPOWEROFF      0x63</div><div class='del'>-#define  CMD_PC_TO_RDR_SECURE           0x69</div><div class='del'>-#define  CMD_PC_TO_RDR_GETPARAMETERS    0x6C</div><div class='del'>-#define  CMD_PC_TO_RDR_RESETPARAMETERS  0x6D</div><div class='del'>-#define  CMD_PC_TO_RDR_SETPARAMETERS    0x61</div><div class='del'>-#define  CMD_PC_TO_RDR_XFRBLOCK         0x6F</div><div class='del'>-#define  CMD_PC_TO_RDR_ESCAPE           0x6B</div><div class='del'>-#define  CMD_PC_TO_RDR_ICCCLOCK         0x6E</div><div class='del'>-#define  CMD_PC_TO_RDR_TEST_SECURE      0x74</div><div class='del'>-#define  CMD_PC_TO_RDR_OK_SECURE        0x89</div><div class='del'>-</div><div class='del'>-</div><div class='del'>-#define  CMD_RDR_TO_PC_SLOTSTATUS         0x81</div><div class='del'>-#define  CMD_RDR_TO_PC_DATABLOCK          0x80</div><div class='del'>-#define  CMD_RDR_TO_PC_PARAMETERS         0x82</div><div class='del'>-#define  CMD_RDR_TO_PC_ESCAPE             0x83</div><div class='del'>-#define  CMD_RDR_TO_PC_OK_SECURE          0x89</div><div class='del'>-</div><div class='del'>-#endif	/* _CM4040_H_ */</div><div class='head'>diff --git a/drivers/char/pcmcia/scr24x_cs.c b/drivers/char/pcmcia/scr24x_cs.c<br/>deleted file mode 100644<br/>index 1bdce08fae3db5..00000000000000<br/>--- a/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/pcmcia/scr24x_cs.c?id=3996954fa071aa20945c8ac7694684fa3c1fed68'>drivers/char/pcmcia/scr24x_cs.c</a><br/>+++ /dev/null</div><div class='hunk'>@@ -1,359 +0,0 @@</div><div class='del'>-// SPDX-License-Identifier: GPL-2.0-or-later</div><div class='del'>-/*</div><div class='del'>- * SCR24x PCMCIA Smart Card Reader Driver</div><div class='del'>- *</div><div class='del'>- * Copyright (C) 2005-2006 TL Sudheendran</div><div class='del'>- * Copyright (C) 2016 Lubomir Rintel</div><div class='del'>- *</div><div class='del'>- * Derived from "scr24x_v4.2.6_Release.tar.gz" driver by TL Sudheendran.</div><div class='del'>- */</div><div class='del'>-</div><div class='del'>-#include &lt;linux/device.h&gt;</div><div class='del'>-#include &lt;linux/module.h&gt;</div><div class='del'>-#include &lt;linux/delay.h&gt;</div><div class='del'>-#include &lt;linux/cdev.h&gt;</div><div class='del'>-#include &lt;linux/slab.h&gt;</div><div class='del'>-#include &lt;linux/fs.h&gt;</div><div class='del'>-#include &lt;linux/io.h&gt;</div><div class='del'>-#include &lt;linux/uaccess.h&gt;</div><div class='del'>-</div><div class='del'>-#include &lt;pcmcia/cistpl.h&gt;</div><div class='del'>-#include &lt;pcmcia/ds.h&gt;</div><div class='del'>-</div><div class='del'>-#define CCID_HEADER_SIZE	10</div><div class='del'>-#define CCID_LENGTH_OFFSET	1</div><div class='del'>-#define CCID_MAX_LEN		271</div><div class='del'>-</div><div class='del'>-#define SCR24X_DATA(n)		(1 + n)</div><div class='del'>-#define SCR24X_CMD_STATUS	7</div><div class='del'>-#define CMD_START		0x40</div><div class='del'>-#define CMD_WRITE_BYTE		0x41</div><div class='del'>-#define CMD_READ_BYTE		0x42</div><div class='del'>-#define STATUS_BUSY		0x80</div><div class='del'>-</div><div class='del'>-struct scr24x_dev {</div><div class='del'>-	struct device *dev;</div><div class='del'>-	struct cdev c_dev;</div><div class='del'>-	unsigned char buf[CCID_MAX_LEN];</div><div class='del'>-	int devno;</div><div class='del'>-	struct mutex lock;</div><div class='del'>-	struct kref refcnt;</div><div class='del'>-	u8 __iomem *regs;</div><div class='del'>-};</div><div class='del'>-</div><div class='del'>-#define SCR24X_DEVS 8</div><div class='del'>-static DECLARE_BITMAP(scr24x_minors, SCR24X_DEVS);</div><div class='del'>-</div><div class='del'>-static struct class *scr24x_class;</div><div class='del'>-static dev_t scr24x_devt;</div><div class='del'>-</div><div class='del'>-static void scr24x_delete(struct kref *kref)</div><div class='del'>-{</div><div class='del'>-	struct scr24x_dev *dev = container_of(kref, struct scr24x_dev,</div><div class='del'>-								refcnt);</div><div class='del'>-</div><div class='del'>-	kfree(dev);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int scr24x_wait_ready(struct scr24x_dev *dev)</div><div class='del'>-{</div><div class='del'>-	u_char status;</div><div class='del'>-	int timeout = 100;</div><div class='del'>-</div><div class='del'>-	do {</div><div class='del'>-		status = ioread8(dev-&gt;regs + SCR24X_CMD_STATUS);</div><div class='del'>-		if (!(status &amp; STATUS_BUSY))</div><div class='del'>-			return 0;</div><div class='del'>-</div><div class='del'>-		msleep(20);</div><div class='del'>-	} while (--timeout);</div><div class='del'>-</div><div class='del'>-	return -EIO;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int scr24x_open(struct inode *inode, struct file *filp)</div><div class='del'>-{</div><div class='del'>-	struct scr24x_dev *dev = container_of(inode-&gt;i_cdev,</div><div class='del'>-				struct scr24x_dev, c_dev);</div><div class='del'>-</div><div class='del'>-	kref_get(&amp;dev-&gt;refcnt);</div><div class='del'>-	filp-&gt;private_data = dev;</div><div class='del'>-</div><div class='del'>-	return stream_open(inode, filp);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int scr24x_release(struct inode *inode, struct file *filp)</div><div class='del'>-{</div><div class='del'>-	struct scr24x_dev *dev = filp-&gt;private_data;</div><div class='del'>-</div><div class='del'>-	/* We must not take the dev-&gt;lock here as scr24x_delete()</div><div class='del'>-	 * might be called to remove the dev structure altogether.</div><div class='del'>-	 * We don't need the lock anyway, since after the reference</div><div class='del'>-	 * acquired in probe() is released in remove() the chrdev</div><div class='del'>-	 * is already unregistered and noone can possibly acquire</div><div class='del'>-	 * a reference via open() anymore. */</div><div class='del'>-	kref_put(&amp;dev-&gt;refcnt, scr24x_delete);</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int read_chunk(struct scr24x_dev *dev, size_t offset, size_t limit)</div><div class='del'>-{</div><div class='del'>-	size_t i, y;</div><div class='del'>-	int ret;</div><div class='del'>-</div><div class='del'>-	for (i = offset; i &lt; limit; i += 5) {</div><div class='del'>-		iowrite8(CMD_READ_BYTE, dev-&gt;regs + SCR24X_CMD_STATUS);</div><div class='del'>-		ret = scr24x_wait_ready(dev);</div><div class='del'>-		if (ret &lt; 0)</div><div class='del'>-			return ret;</div><div class='del'>-</div><div class='del'>-		for (y = 0; y &lt; 5 &amp;&amp; i + y &lt; limit; y++)</div><div class='del'>-			dev-&gt;buf[i + y] = ioread8(dev-&gt;regs + SCR24X_DATA(y));</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static ssize_t scr24x_read(struct file *filp, char __user *buf, size_t count,</div><div class='del'>-								loff_t *ppos)</div><div class='del'>-{</div><div class='del'>-	struct scr24x_dev *dev = filp-&gt;private_data;</div><div class='del'>-	int ret;</div><div class='del'>-	int len;</div><div class='del'>-</div><div class='del'>-	if (count &lt; CCID_HEADER_SIZE)</div><div class='del'>-		return -EINVAL;</div><div class='del'>-</div><div class='del'>-	if (mutex_lock_interruptible(&amp;dev-&gt;lock))</div><div class='del'>-		return -ERESTARTSYS;</div><div class='del'>-</div><div class='del'>-	if (!dev-&gt;dev) {</div><div class='del'>-		ret = -ENODEV;</div><div class='del'>-		goto out;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	ret = scr24x_wait_ready(dev);</div><div class='del'>-	if (ret &lt; 0)</div><div class='del'>-		goto out;</div><div class='del'>-	len = CCID_HEADER_SIZE;</div><div class='del'>-	ret = read_chunk(dev, 0, len);</div><div class='del'>-	if (ret &lt; 0)</div><div class='del'>-		goto out;</div><div class='del'>-</div><div class='del'>-	len += le32_to_cpu(*(__le32 *)(&amp;dev-&gt;buf[CCID_LENGTH_OFFSET]));</div><div class='del'>-	if (len &gt; sizeof(dev-&gt;buf)) {</div><div class='del'>-		ret = -EIO;</div><div class='del'>-		goto out;</div><div class='del'>-	}</div><div class='del'>-	ret = read_chunk(dev, CCID_HEADER_SIZE, len);</div><div class='del'>-	if (ret &lt; 0)</div><div class='del'>-		goto out;</div><div class='del'>-</div><div class='del'>-	if (len &lt; count)</div><div class='del'>-		count = len;</div><div class='del'>-</div><div class='del'>-	if (copy_to_user(buf, dev-&gt;buf, count)) {</div><div class='del'>-		ret = -EFAULT;</div><div class='del'>-		goto out;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	ret = count;</div><div class='del'>-out:</div><div class='del'>-	mutex_unlock(&amp;dev-&gt;lock);</div><div class='del'>-	return ret;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static ssize_t scr24x_write(struct file *filp, const char __user *buf,</div><div class='del'>-					size_t count, loff_t *ppos)</div><div class='del'>-{</div><div class='del'>-	struct scr24x_dev *dev = filp-&gt;private_data;</div><div class='del'>-	size_t i, y;</div><div class='del'>-	int ret;</div><div class='del'>-</div><div class='del'>-	if (mutex_lock_interruptible(&amp;dev-&gt;lock))</div><div class='del'>-		return -ERESTARTSYS;</div><div class='del'>-</div><div class='del'>-	if (!dev-&gt;dev) {</div><div class='del'>-		ret = -ENODEV;</div><div class='del'>-		goto out;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (count &gt; sizeof(dev-&gt;buf)) {</div><div class='del'>-		ret = -EINVAL;</div><div class='del'>-		goto out;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (copy_from_user(dev-&gt;buf, buf, count)) {</div><div class='del'>-		ret = -EFAULT;</div><div class='del'>-		goto out;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	ret = scr24x_wait_ready(dev);</div><div class='del'>-	if (ret &lt; 0)</div><div class='del'>-		goto out;</div><div class='del'>-</div><div class='del'>-	iowrite8(CMD_START, dev-&gt;regs + SCR24X_CMD_STATUS);</div><div class='del'>-	ret = scr24x_wait_ready(dev);</div><div class='del'>-	if (ret &lt; 0)</div><div class='del'>-		goto out;</div><div class='del'>-</div><div class='del'>-	for (i = 0; i &lt; count; i += 5) {</div><div class='del'>-		for (y = 0; y &lt; 5 &amp;&amp; i + y &lt; count; y++)</div><div class='del'>-			iowrite8(dev-&gt;buf[i + y], dev-&gt;regs + SCR24X_DATA(y));</div><div class='del'>-</div><div class='del'>-		iowrite8(CMD_WRITE_BYTE, dev-&gt;regs + SCR24X_CMD_STATUS);</div><div class='del'>-		ret = scr24x_wait_ready(dev);</div><div class='del'>-		if (ret &lt; 0)</div><div class='del'>-			goto out;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	ret = count;</div><div class='del'>-out:</div><div class='del'>-	mutex_unlock(&amp;dev-&gt;lock);</div><div class='del'>-	return ret;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static const struct file_operations scr24x_fops = {</div><div class='del'>-	.owner		= THIS_MODULE,</div><div class='del'>-	.read		= scr24x_read,</div><div class='del'>-	.write		= scr24x_write,</div><div class='del'>-	.open		= scr24x_open,</div><div class='del'>-	.release	= scr24x_release,</div><div class='del'>-	.llseek		= no_llseek,</div><div class='del'>-};</div><div class='del'>-</div><div class='del'>-static int scr24x_config_check(struct pcmcia_device *link, void *priv_data)</div><div class='del'>-{</div><div class='del'>-	if (resource_size(link-&gt;resource[PCMCIA_IOPORT_0]) != 0x11)</div><div class='del'>-		return -ENODEV;</div><div class='del'>-	return pcmcia_request_io(link);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int scr24x_probe(struct pcmcia_device *link)</div><div class='del'>-{</div><div class='del'>-	struct scr24x_dev *dev;</div><div class='del'>-	int ret;</div><div class='del'>-</div><div class='del'>-	dev = kzalloc(sizeof(*dev), GFP_KERNEL);</div><div class='del'>-	if (!dev)</div><div class='del'>-		return -ENOMEM;</div><div class='del'>-</div><div class='del'>-	dev-&gt;devno = find_first_zero_bit(scr24x_minors, SCR24X_DEVS);</div><div class='del'>-	if (dev-&gt;devno &gt;= SCR24X_DEVS) {</div><div class='del'>-		ret = -EBUSY;</div><div class='del'>-		goto err;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	mutex_init(&amp;dev-&gt;lock);</div><div class='del'>-	kref_init(&amp;dev-&gt;refcnt);</div><div class='del'>-</div><div class='del'>-	link-&gt;priv = dev;</div><div class='del'>-	link-&gt;config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO;</div><div class='del'>-</div><div class='del'>-	ret = pcmcia_loop_config(link, scr24x_config_check, NULL);</div><div class='del'>-	if (ret &lt; 0)</div><div class='del'>-		goto err;</div><div class='del'>-</div><div class='del'>-	dev-&gt;dev = &amp;link-&gt;dev;</div><div class='del'>-	dev-&gt;regs = devm_ioport_map(&amp;link-&gt;dev,</div><div class='del'>-				link-&gt;resource[PCMCIA_IOPORT_0]-&gt;start,</div><div class='del'>-				resource_size(link-&gt;resource[PCMCIA_IOPORT_0]));</div><div class='del'>-	if (!dev-&gt;regs) {</div><div class='del'>-		ret = -EIO;</div><div class='del'>-		goto err;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	cdev_init(&amp;dev-&gt;c_dev, &amp;scr24x_fops);</div><div class='del'>-	dev-&gt;c_dev.owner = THIS_MODULE;</div><div class='del'>-	ret = cdev_add(&amp;dev-&gt;c_dev, MKDEV(MAJOR(scr24x_devt), dev-&gt;devno), 1);</div><div class='del'>-	if (ret &lt; 0)</div><div class='del'>-		goto err;</div><div class='del'>-</div><div class='del'>-	ret = pcmcia_enable_device(link);</div><div class='del'>-	if (ret &lt; 0) {</div><div class='del'>-		pcmcia_disable_device(link);</div><div class='del'>-		goto err;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	device_create(scr24x_class, NULL, MKDEV(MAJOR(scr24x_devt), dev-&gt;devno),</div><div class='del'>-		      NULL, "scr24x%d", dev-&gt;devno);</div><div class='del'>-</div><div class='del'>-	dev_info(&amp;link-&gt;dev, "SCR24x Chip Card Interface\n");</div><div class='del'>-	return 0;</div><div class='del'>-</div><div class='del'>-err:</div><div class='del'>-	if (dev-&gt;devno &lt; SCR24X_DEVS)</div><div class='del'>-		clear_bit(dev-&gt;devno, scr24x_minors);</div><div class='del'>-	kfree (dev);</div><div class='del'>-	return ret;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void scr24x_remove(struct pcmcia_device *link)</div><div class='del'>-{</div><div class='del'>-	struct scr24x_dev *dev = (struct scr24x_dev *)link-&gt;priv;</div><div class='del'>-</div><div class='del'>-	device_destroy(scr24x_class, MKDEV(MAJOR(scr24x_devt), dev-&gt;devno));</div><div class='del'>-	mutex_lock(&amp;dev-&gt;lock);</div><div class='del'>-	pcmcia_disable_device(link);</div><div class='del'>-	cdev_del(&amp;dev-&gt;c_dev);</div><div class='del'>-	clear_bit(dev-&gt;devno, scr24x_minors);</div><div class='del'>-	dev-&gt;dev = NULL;</div><div class='del'>-	mutex_unlock(&amp;dev-&gt;lock);</div><div class='del'>-</div><div class='del'>-	kref_put(&amp;dev-&gt;refcnt, scr24x_delete);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static const struct pcmcia_device_id scr24x_ids[] = {</div><div class='del'>-	PCMCIA_DEVICE_PROD_ID12("HP", "PC Card Smart Card Reader",</div><div class='del'>-					0x53cb94f9, 0xbfdf89a5),</div><div class='del'>-	PCMCIA_DEVICE_PROD_ID1("SCR241 PCMCIA", 0x6271efa3),</div><div class='del'>-	PCMCIA_DEVICE_PROD_ID1("SCR243 PCMCIA", 0x2054e8de),</div><div class='del'>-	PCMCIA_DEVICE_PROD_ID1("SCR24x PCMCIA", 0x54a33665),</div><div class='del'>-	PCMCIA_DEVICE_NULL</div><div class='del'>-};</div><div class='del'>-MODULE_DEVICE_TABLE(pcmcia, scr24x_ids);</div><div class='del'>-</div><div class='del'>-static struct pcmcia_driver scr24x_driver = {</div><div class='del'>-	.owner		= THIS_MODULE,</div><div class='del'>-	.name		= "scr24x_cs",</div><div class='del'>-	.probe		= scr24x_probe,</div><div class='del'>-	.remove		= scr24x_remove,</div><div class='del'>-	.id_table	= scr24x_ids,</div><div class='del'>-};</div><div class='del'>-</div><div class='del'>-static int __init scr24x_init(void)</div><div class='del'>-{</div><div class='del'>-	int ret;</div><div class='del'>-</div><div class='del'>-	scr24x_class = class_create(THIS_MODULE, "scr24x");</div><div class='del'>-	if (IS_ERR(scr24x_class))</div><div class='del'>-		return PTR_ERR(scr24x_class);</div><div class='del'>-</div><div class='del'>-	ret = alloc_chrdev_region(&amp;scr24x_devt, 0, SCR24X_DEVS, "scr24x");</div><div class='del'>-	if (ret &lt; 0)  {</div><div class='del'>-		class_destroy(scr24x_class);</div><div class='del'>-		return ret;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	ret = pcmcia_register_driver(&amp;scr24x_driver);</div><div class='del'>-	if (ret &lt; 0) {</div><div class='del'>-		unregister_chrdev_region(scr24x_devt, SCR24X_DEVS);</div><div class='del'>-		class_destroy(scr24x_class);</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	return ret;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void __exit scr24x_exit(void)</div><div class='del'>-{</div><div class='del'>-	pcmcia_unregister_driver(&amp;scr24x_driver);</div><div class='del'>-	unregister_chrdev_region(scr24x_devt, SCR24X_DEVS);</div><div class='del'>-	class_destroy(scr24x_class);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-module_init(scr24x_init);</div><div class='del'>-module_exit(scr24x_exit);</div><div class='del'>-</div><div class='del'>-MODULE_AUTHOR("Lubomir Rintel");</div><div class='del'>-MODULE_DESCRIPTION("SCR24x PCMCIA Smart Card Reader Driver");</div><div class='del'>-MODULE_LICENSE("GPL");</div><div class='head'>diff --git a/drivers/char/pcmcia/synclink_cs.c b/drivers/char/pcmcia/synclink_cs.c<br/>deleted file mode 100644<br/>index 6ddfeb2fe98f07..00000000000000<br/>--- a/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/pcmcia/synclink_cs.c?id=3996954fa071aa20945c8ac7694684fa3c1fed68'>drivers/char/pcmcia/synclink_cs.c</a><br/>+++ /dev/null</div><div class='hunk'>@@ -1,4290 +0,0 @@</div><div class='del'>-/*</div><div class='del'>- * linux/drivers/char/pcmcia/synclink_cs.c</div><div class='del'>- *</div><div class='del'>- * $Id: synclink_cs.c,v 4.34 2005/09/08 13:20:54 paulkf Exp $</div><div class='del'>- *</div><div class='del'>- * Device driver for Microgate SyncLink PC Card</div><div class='del'>- * multiprotocol serial adapter.</div><div class='del'>- *</div><div class='del'>- * written by Paul Fulghum for Microgate Corporation</div><div class='del'>- * paulkf@microgate.com</div><div class='del'>- *</div><div class='del'>- * Microgate and SyncLink are trademarks of Microgate Corporation</div><div class='del'>- *</div><div class='del'>- * This code is released under the GNU General Public License (GPL)</div><div class='del'>- *</div><div class='del'>- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED</div><div class='del'>- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</div><div class='del'>- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</div><div class='del'>- * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,</div><div class='del'>- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</div><div class='del'>- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</div><div class='del'>- * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</div><div class='del'>- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,</div><div class='del'>- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</div><div class='del'>- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED</div><div class='del'>- * OF THE POSSIBILITY OF SUCH DAMAGE.</div><div class='del'>- */</div><div class='del'>-</div><div class='del'>-#define VERSION(ver,rel,seq) (((ver)&lt;&lt;16) | ((rel)&lt;&lt;8) | (seq))</div><div class='del'>-#if defined(__i386__)</div><div class='del'>-#  define BREAKPOINT() asm("   int $3");</div><div class='del'>-#else</div><div class='del'>-#  define BREAKPOINT() { }</div><div class='del'>-#endif</div><div class='del'>-</div><div class='del'>-#define MAX_DEVICE_COUNT 4</div><div class='del'>-</div><div class='del'>-#include &lt;linux/module.h&gt;</div><div class='del'>-#include &lt;linux/errno.h&gt;</div><div class='del'>-#include &lt;linux/signal.h&gt;</div><div class='del'>-#include &lt;linux/sched.h&gt;</div><div class='del'>-#include &lt;linux/timer.h&gt;</div><div class='del'>-#include &lt;linux/time.h&gt;</div><div class='del'>-#include &lt;linux/interrupt.h&gt;</div><div class='del'>-#include &lt;linux/tty.h&gt;</div><div class='del'>-#include &lt;linux/tty_flip.h&gt;</div><div class='del'>-#include &lt;linux/serial.h&gt;</div><div class='del'>-#include &lt;linux/major.h&gt;</div><div class='del'>-#include &lt;linux/string.h&gt;</div><div class='del'>-#include &lt;linux/fcntl.h&gt;</div><div class='del'>-#include &lt;linux/ptrace.h&gt;</div><div class='del'>-#include &lt;linux/ioport.h&gt;</div><div class='del'>-#include &lt;linux/mm.h&gt;</div><div class='del'>-#include &lt;linux/seq_file.h&gt;</div><div class='del'>-#include &lt;linux/slab.h&gt;</div><div class='del'>-#include &lt;linux/netdevice.h&gt;</div><div class='del'>-#include &lt;linux/vmalloc.h&gt;</div><div class='del'>-#include &lt;linux/init.h&gt;</div><div class='del'>-#include &lt;linux/delay.h&gt;</div><div class='del'>-#include &lt;linux/ioctl.h&gt;</div><div class='del'>-#include &lt;linux/synclink.h&gt;</div><div class='del'>-</div><div class='del'>-#include &lt;asm/io.h&gt;</div><div class='del'>-#include &lt;asm/irq.h&gt;</div><div class='del'>-#include &lt;asm/dma.h&gt;</div><div class='del'>-#include &lt;linux/bitops.h&gt;</div><div class='del'>-#include &lt;asm/types.h&gt;</div><div class='del'>-#include &lt;linux/termios.h&gt;</div><div class='del'>-#include &lt;linux/workqueue.h&gt;</div><div class='del'>-#include &lt;linux/hdlc.h&gt;</div><div class='del'>-</div><div class='del'>-#include &lt;pcmcia/cistpl.h&gt;</div><div class='del'>-#include &lt;pcmcia/cisreg.h&gt;</div><div class='del'>-#include &lt;pcmcia/ds.h&gt;</div><div class='del'>-</div><div class='del'>-#if defined(CONFIG_HDLC) || (defined(CONFIG_HDLC_MODULE) &amp;&amp; defined(CONFIG_SYNCLINK_CS_MODULE))</div><div class='del'>-#define SYNCLINK_GENERIC_HDLC 1</div><div class='del'>-#else</div><div class='del'>-#define SYNCLINK_GENERIC_HDLC 0</div><div class='del'>-#endif</div><div class='del'>-</div><div class='del'>-#define GET_USER(error,value,addr) error = get_user(value,addr)</div><div class='del'>-#define COPY_FROM_USER(error,dest,src,size) error = copy_from_user(dest,src,size) ? -EFAULT : 0</div><div class='del'>-#define PUT_USER(error,value,addr) error = put_user(value,addr)</div><div class='del'>-#define COPY_TO_USER(error,dest,src,size) error = copy_to_user(dest,src,size) ? -EFAULT : 0</div><div class='del'>-</div><div class='del'>-#include &lt;linux/uaccess.h&gt;</div><div class='del'>-</div><div class='del'>-static MGSL_PARAMS default_params = {</div><div class='del'>-	MGSL_MODE_HDLC,			/* unsigned long mode */</div><div class='del'>-	0,				/* unsigned char loopback; */</div><div class='del'>-	HDLC_FLAG_UNDERRUN_ABORT15,	/* unsigned short flags; */</div><div class='del'>-	HDLC_ENCODING_NRZI_SPACE,	/* unsigned char encoding; */</div><div class='del'>-	0,				/* unsigned long clock_speed; */</div><div class='del'>-	0xff,				/* unsigned char addr_filter; */</div><div class='del'>-	HDLC_CRC_16_CCITT,		/* unsigned short crc_type; */</div><div class='del'>-	HDLC_PREAMBLE_LENGTH_8BITS,	/* unsigned char preamble_length; */</div><div class='del'>-	HDLC_PREAMBLE_PATTERN_NONE,	/* unsigned char preamble; */</div><div class='del'>-	9600,				/* unsigned long data_rate; */</div><div class='del'>-	8,				/* unsigned char data_bits; */</div><div class='del'>-	1,				/* unsigned char stop_bits; */</div><div class='del'>-	ASYNC_PARITY_NONE		/* unsigned char parity; */</div><div class='del'>-};</div><div class='del'>-</div><div class='del'>-typedef struct {</div><div class='del'>-	int count;</div><div class='del'>-	unsigned char status;</div><div class='del'>-	char data[1];</div><div class='del'>-} RXBUF;</div><div class='del'>-</div><div class='del'>-/* The queue of BH actions to be performed */</div><div class='del'>-</div><div class='del'>-#define BH_RECEIVE  1</div><div class='del'>-#define BH_TRANSMIT 2</div><div class='del'>-#define BH_STATUS   4</div><div class='del'>-</div><div class='del'>-#define IO_PIN_SHUTDOWN_LIMIT 100</div><div class='del'>-</div><div class='del'>-#define RELEVANT_IFLAG(iflag) (iflag &amp; (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))</div><div class='del'>-</div><div class='del'>-struct _input_signal_events {</div><div class='del'>-	int	ri_up;</div><div class='del'>-	int	ri_down;</div><div class='del'>-	int	dsr_up;</div><div class='del'>-	int	dsr_down;</div><div class='del'>-	int	dcd_up;</div><div class='del'>-	int	dcd_down;</div><div class='del'>-	int	cts_up;</div><div class='del'>-	int	cts_down;</div><div class='del'>-};</div><div class='del'>-</div><div class='del'>-</div><div class='del'>-/*</div><div class='del'>- * Device instance data structure</div><div class='del'>- */</div><div class='del'>-</div><div class='del'>-typedef struct _mgslpc_info {</div><div class='del'>-	struct tty_port		port;</div><div class='del'>-	void *if_ptr;	/* General purpose pointer (used by SPPP) */</div><div class='del'>-	int			magic;</div><div class='del'>-	int			line;</div><div class='del'>-</div><div class='del'>-	struct mgsl_icount	icount;</div><div class='del'>-</div><div class='del'>-	int			timeout;</div><div class='del'>-	int			x_char;		/* xon/xoff character */</div><div class='del'>-	unsigned char		read_status_mask;</div><div class='del'>-	unsigned char		ignore_status_mask;</div><div class='del'>-</div><div class='del'>-	unsigned char *tx_buf;</div><div class='del'>-	int            tx_put;</div><div class='del'>-	int            tx_get;</div><div class='del'>-	int            tx_count;</div><div class='del'>-</div><div class='del'>-	/* circular list of fixed length rx buffers */</div><div class='del'>-</div><div class='del'>-	unsigned char  *rx_buf;        /* memory allocated for all rx buffers */</div><div class='del'>-	int            rx_buf_total_size; /* size of memory allocated for rx buffers */</div><div class='del'>-	int            rx_put;         /* index of next empty rx buffer */</div><div class='del'>-	int            rx_get;         /* index of next full rx buffer */</div><div class='del'>-	int            rx_buf_size;    /* size in bytes of single rx buffer */</div><div class='del'>-	int            rx_buf_count;   /* total number of rx buffers */</div><div class='del'>-	int            rx_frame_count; /* number of full rx buffers */</div><div class='del'>-</div><div class='del'>-	wait_queue_head_t	status_event_wait_q;</div><div class='del'>-	wait_queue_head_t	event_wait_q;</div><div class='del'>-	struct timer_list	tx_timer;	/* HDLC transmit timeout timer */</div><div class='del'>-	struct _mgslpc_info	*next_device;	/* device list link */</div><div class='del'>-</div><div class='del'>-	unsigned short imra_value;</div><div class='del'>-	unsigned short imrb_value;</div><div class='del'>-	unsigned char  pim_value;</div><div class='del'>-</div><div class='del'>-	spinlock_t lock;</div><div class='del'>-	struct work_struct task;		/* task structure for scheduling bh */</div><div class='del'>-</div><div class='del'>-	u32 max_frame_size;</div><div class='del'>-</div><div class='del'>-	u32 pending_bh;</div><div class='del'>-</div><div class='del'>-	bool bh_running;</div><div class='del'>-	bool bh_requested;</div><div class='del'>-</div><div class='del'>-	int dcd_chkcount; /* check counts to prevent */</div><div class='del'>-	int cts_chkcount; /* too many IRQs if a signal */</div><div class='del'>-	int dsr_chkcount; /* is floating */</div><div class='del'>-	int ri_chkcount;</div><div class='del'>-</div><div class='del'>-	bool rx_enabled;</div><div class='del'>-	bool rx_overflow;</div><div class='del'>-</div><div class='del'>-	bool tx_enabled;</div><div class='del'>-	bool tx_active;</div><div class='del'>-	bool tx_aborting;</div><div class='del'>-	u32 idle_mode;</div><div class='del'>-</div><div class='del'>-	int if_mode; /* serial interface selection (RS-232, v.35 etc) */</div><div class='del'>-</div><div class='del'>-	char device_name[25];		/* device instance name */</div><div class='del'>-</div><div class='del'>-	unsigned int io_base;	/* base I/O address of adapter */</div><div class='del'>-	unsigned int irq_level;</div><div class='del'>-</div><div class='del'>-	MGSL_PARAMS params;		/* communications parameters */</div><div class='del'>-</div><div class='del'>-	unsigned char serial_signals;	/* current serial signal states */</div><div class='del'>-</div><div class='del'>-	bool irq_occurred;		/* for diagnostics use */</div><div class='del'>-	char testing_irq;</div><div class='del'>-	unsigned int init_error;	/* startup error (DIAGS)	*/</div><div class='del'>-</div><div class='del'>-	char *flag_buf;</div><div class='del'>-	bool drop_rts_on_tx_done;</div><div class='del'>-</div><div class='del'>-	struct	_input_signal_events	input_signal_events;</div><div class='del'>-</div><div class='del'>-	/* PCMCIA support */</div><div class='del'>-	struct pcmcia_device	*p_dev;</div><div class='del'>-	int		      stop;</div><div class='del'>-</div><div class='del'>-	/* SPPP/Cisco HDLC device parts */</div><div class='del'>-	int netcount;</div><div class='del'>-	spinlock_t netlock;</div><div class='del'>-</div><div class='del'>-#if SYNCLINK_GENERIC_HDLC</div><div class='del'>-	struct net_device *netdev;</div><div class='del'>-#endif</div><div class='del'>-</div><div class='del'>-} MGSLPC_INFO;</div><div class='del'>-</div><div class='del'>-#define MGSLPC_MAGIC 0x5402</div><div class='del'>-</div><div class='del'>-/*</div><div class='del'>- * The size of the serial xmit buffer is 1 page, or 4096 bytes</div><div class='del'>- */</div><div class='del'>-#define TXBUFSIZE 4096</div><div class='del'>-</div><div class='del'>-</div><div class='del'>-#define CHA     0x00   /* channel A offset */</div><div class='del'>-#define CHB     0x40   /* channel B offset */</div><div class='del'>-</div><div class='del'>-/*</div><div class='del'>- *  FIXME: PPC has PVR defined in asm/reg.h.  For now we just undef it.</div><div class='del'>- */</div><div class='del'>-#undef PVR</div><div class='del'>-</div><div class='del'>-#define RXFIFO  0</div><div class='del'>-#define TXFIFO  0</div><div class='del'>-#define STAR    0x20</div><div class='del'>-#define CMDR    0x20</div><div class='del'>-#define RSTA    0x21</div><div class='del'>-#define PRE     0x21</div><div class='del'>-#define MODE    0x22</div><div class='del'>-#define TIMR    0x23</div><div class='del'>-#define XAD1    0x24</div><div class='del'>-#define XAD2    0x25</div><div class='del'>-#define RAH1    0x26</div><div class='del'>-#define RAH2    0x27</div><div class='del'>-#define DAFO    0x27</div><div class='del'>-#define RAL1    0x28</div><div class='del'>-#define RFC     0x28</div><div class='del'>-#define RHCR    0x29</div><div class='del'>-#define RAL2    0x29</div><div class='del'>-#define RBCL    0x2a</div><div class='del'>-#define XBCL    0x2a</div><div class='del'>-#define RBCH    0x2b</div><div class='del'>-#define XBCH    0x2b</div><div class='del'>-#define CCR0    0x2c</div><div class='del'>-#define CCR1    0x2d</div><div class='del'>-#define CCR2    0x2e</div><div class='del'>-#define CCR3    0x2f</div><div class='del'>-#define VSTR    0x34</div><div class='del'>-#define BGR     0x34</div><div class='del'>-#define RLCR    0x35</div><div class='del'>-#define AML     0x36</div><div class='del'>-#define AMH     0x37</div><div class='del'>-#define GIS     0x38</div><div class='del'>-#define IVA     0x38</div><div class='del'>-#define IPC     0x39</div><div class='del'>-#define ISR     0x3a</div><div class='del'>-#define IMR     0x3a</div><div class='del'>-#define PVR     0x3c</div><div class='del'>-#define PIS     0x3d</div><div class='del'>-#define PIM     0x3d</div><div class='del'>-#define PCR     0x3e</div><div class='del'>-#define CCR4    0x3f</div><div class='del'>-</div><div class='del'>-// IMR/ISR</div><div class='del'>-</div><div class='del'>-#define IRQ_BREAK_ON    BIT15   // rx break detected</div><div class='del'>-#define IRQ_DATAOVERRUN BIT14	// receive data overflow</div><div class='del'>-#define IRQ_ALLSENT     BIT13	// all sent</div><div class='del'>-#define IRQ_UNDERRUN    BIT12	// transmit data underrun</div><div class='del'>-#define IRQ_TIMER       BIT11	// timer interrupt</div><div class='del'>-#define IRQ_CTS         BIT10	// CTS status change</div><div class='del'>-#define IRQ_TXREPEAT    BIT9	// tx message repeat</div><div class='del'>-#define IRQ_TXFIFO      BIT8	// transmit pool ready</div><div class='del'>-#define IRQ_RXEOM       BIT7	// receive message end</div><div class='del'>-#define IRQ_EXITHUNT    BIT6	// receive frame start</div><div class='del'>-#define IRQ_RXTIME      BIT6    // rx char timeout</div><div class='del'>-#define IRQ_DCD         BIT2	// carrier detect status change</div><div class='del'>-#define IRQ_OVERRUN     BIT1	// receive frame overflow</div><div class='del'>-#define IRQ_RXFIFO      BIT0	// receive pool full</div><div class='del'>-</div><div class='del'>-// STAR</div><div class='del'>-</div><div class='del'>-#define XFW   BIT6		// transmit FIFO write enable</div><div class='del'>-#define CEC   BIT2		// command executing</div><div class='del'>-#define CTS   BIT1		// CTS state</div><div class='del'>-</div><div class='del'>-#define PVR_DTR      BIT0</div><div class='del'>-#define PVR_DSR      BIT1</div><div class='del'>-#define PVR_RI       BIT2</div><div class='del'>-#define PVR_AUTOCTS  BIT3</div><div class='del'>-#define PVR_RS232    0x20   /* 0010b */</div><div class='del'>-#define PVR_V35      0xe0   /* 1110b */</div><div class='del'>-#define PVR_RS422    0x40   /* 0100b */</div><div class='del'>-</div><div class='del'>-/* Register access functions */</div><div class='del'>-</div><div class='del'>-#define write_reg(info, reg, val) outb((val),(info)-&gt;io_base + (reg))</div><div class='del'>-#define read_reg(info, reg) inb((info)-&gt;io_base + (reg))</div><div class='del'>-</div><div class='del'>-#define read_reg16(info, reg) inw((info)-&gt;io_base + (reg))</div><div class='del'>-#define write_reg16(info, reg, val) outw((val), (info)-&gt;io_base + (reg))</div><div class='del'>-</div><div class='del'>-#define set_reg_bits(info, reg, mask) \</div><div class='del'>-	write_reg(info, (reg), \</div><div class='del'>-		 (unsigned char) (read_reg(info, (reg)) | (mask)))</div><div class='del'>-#define clear_reg_bits(info, reg, mask) \</div><div class='del'>-	write_reg(info, (reg), \</div><div class='del'>-		 (unsigned char) (read_reg(info, (reg)) &amp; ~(mask)))</div><div class='del'>-/*</div><div class='del'>- * interrupt enable/disable routines</div><div class='del'>- */</div><div class='del'>-static void irq_disable(MGSLPC_INFO *info, unsigned char channel, unsigned short mask)</div><div class='del'>-{</div><div class='del'>-	if (channel == CHA) {</div><div class='del'>-		info-&gt;imra_value |= mask;</div><div class='del'>-		write_reg16(info, CHA + IMR, info-&gt;imra_value);</div><div class='del'>-	} else {</div><div class='del'>-		info-&gt;imrb_value |= mask;</div><div class='del'>-		write_reg16(info, CHB + IMR, info-&gt;imrb_value);</div><div class='del'>-	}</div><div class='del'>-}</div><div class='del'>-static void irq_enable(MGSLPC_INFO *info, unsigned char channel, unsigned short mask)</div><div class='del'>-{</div><div class='del'>-	if (channel == CHA) {</div><div class='del'>-		info-&gt;imra_value &amp;= ~mask;</div><div class='del'>-		write_reg16(info, CHA + IMR, info-&gt;imra_value);</div><div class='del'>-	} else {</div><div class='del'>-		info-&gt;imrb_value &amp;= ~mask;</div><div class='del'>-		write_reg16(info, CHB + IMR, info-&gt;imrb_value);</div><div class='del'>-	}</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-#define port_irq_disable(info, mask) \</div><div class='del'>-	{ info-&gt;pim_value |= (mask); write_reg(info, PIM, info-&gt;pim_value); }</div><div class='del'>-</div><div class='del'>-#define port_irq_enable(info, mask) \</div><div class='del'>-	{ info-&gt;pim_value &amp;= ~(mask); write_reg(info, PIM, info-&gt;pim_value); }</div><div class='del'>-</div><div class='del'>-static void rx_start(MGSLPC_INFO *info);</div><div class='del'>-static void rx_stop(MGSLPC_INFO *info);</div><div class='del'>-</div><div class='del'>-static void tx_start(MGSLPC_INFO *info, struct tty_struct *tty);</div><div class='del'>-static void tx_stop(MGSLPC_INFO *info);</div><div class='del'>-static void tx_set_idle(MGSLPC_INFO *info);</div><div class='del'>-</div><div class='del'>-static void get_signals(MGSLPC_INFO *info);</div><div class='del'>-static void set_signals(MGSLPC_INFO *info);</div><div class='del'>-</div><div class='del'>-static void reset_device(MGSLPC_INFO *info);</div><div class='del'>-</div><div class='del'>-static void hdlc_mode(MGSLPC_INFO *info);</div><div class='del'>-static void async_mode(MGSLPC_INFO *info);</div><div class='del'>-</div><div class='del'>-static void tx_timeout(struct timer_list *t);</div><div class='del'>-</div><div class='del'>-static bool carrier_raised(struct tty_port *port);</div><div class='del'>-static void dtr_rts(struct tty_port *port, bool active);</div><div class='del'>-</div><div class='del'>-#if SYNCLINK_GENERIC_HDLC</div><div class='del'>-#define dev_to_port(D) (dev_to_hdlc(D)-&gt;priv)</div><div class='del'>-static void hdlcdev_tx_done(MGSLPC_INFO *info);</div><div class='del'>-static void hdlcdev_rx(MGSLPC_INFO *info, char *buf, int size);</div><div class='del'>-static int  hdlcdev_init(MGSLPC_INFO *info);</div><div class='del'>-static void hdlcdev_exit(MGSLPC_INFO *info);</div><div class='del'>-#endif</div><div class='del'>-</div><div class='del'>-static void trace_block(MGSLPC_INFO *info,const char* data, int count, int xmit);</div><div class='del'>-</div><div class='del'>-static bool register_test(MGSLPC_INFO *info);</div><div class='del'>-static bool irq_test(MGSLPC_INFO *info);</div><div class='del'>-static int adapter_test(MGSLPC_INFO *info);</div><div class='del'>-</div><div class='del'>-static int claim_resources(MGSLPC_INFO *info);</div><div class='del'>-static void release_resources(MGSLPC_INFO *info);</div><div class='del'>-static int mgslpc_add_device(MGSLPC_INFO *info);</div><div class='del'>-static void mgslpc_remove_device(MGSLPC_INFO *info);</div><div class='del'>-</div><div class='del'>-static bool rx_get_frame(MGSLPC_INFO *info, struct tty_struct *tty);</div><div class='del'>-static void rx_reset_buffers(MGSLPC_INFO *info);</div><div class='del'>-static int  rx_alloc_buffers(MGSLPC_INFO *info);</div><div class='del'>-static void rx_free_buffers(MGSLPC_INFO *info);</div><div class='del'>-</div><div class='del'>-static irqreturn_t mgslpc_isr(int irq, void *dev_id);</div><div class='del'>-</div><div class='del'>-/*</div><div class='del'>- * Bottom half interrupt handlers</div><div class='del'>- */</div><div class='del'>-static void bh_handler(struct work_struct *work);</div><div class='del'>-static void bh_transmit(MGSLPC_INFO *info, struct tty_struct *tty);</div><div class='del'>-static void bh_status(MGSLPC_INFO *info);</div><div class='del'>-</div><div class='del'>-/*</div><div class='del'>- * ioctl handlers</div><div class='del'>- */</div><div class='del'>-static int tiocmget(struct tty_struct *tty);</div><div class='del'>-static int tiocmset(struct tty_struct *tty,</div><div class='del'>-					unsigned int set, unsigned int clear);</div><div class='del'>-static int get_stats(MGSLPC_INFO *info, struct mgsl_icount __user *user_icount);</div><div class='del'>-static int get_params(MGSLPC_INFO *info, MGSL_PARAMS __user *user_params);</div><div class='del'>-static int set_params(MGSLPC_INFO *info, MGSL_PARAMS __user *new_params, struct tty_struct *tty);</div><div class='del'>-static int get_txidle(MGSLPC_INFO *info, int __user *idle_mode);</div><div class='del'>-static int set_txidle(MGSLPC_INFO *info, int idle_mode);</div><div class='del'>-static int set_txenable(MGSLPC_INFO *info, int enable, struct tty_struct *tty);</div><div class='del'>-static int tx_abort(MGSLPC_INFO *info);</div><div class='del'>-static int set_rxenable(MGSLPC_INFO *info, int enable);</div><div class='del'>-static int wait_events(MGSLPC_INFO *info, int __user *mask);</div><div class='del'>-</div><div class='del'>-static MGSLPC_INFO *mgslpc_device_list = NULL;</div><div class='del'>-static int mgslpc_device_count = 0;</div><div class='del'>-</div><div class='del'>-/*</div><div class='del'>- * Set this param to non-zero to load eax with the</div><div class='del'>- * .text section address and breakpoint on module load.</div><div class='del'>- * This is useful for use with gdb and add-symbol-file command.</div><div class='del'>- */</div><div class='del'>-static bool break_on_load;</div><div class='del'>-</div><div class='del'>-/*</div><div class='del'>- * Driver major number, defaults to zero to get auto</div><div class='del'>- * assigned major number. May be forced as module parameter.</div><div class='del'>- */</div><div class='del'>-static int ttymajor=0;</div><div class='del'>-</div><div class='del'>-static int debug_level = 0;</div><div class='del'>-static int maxframe[MAX_DEVICE_COUNT] = {0,};</div><div class='del'>-</div><div class='del'>-module_param(break_on_load, bool, 0);</div><div class='del'>-module_param(ttymajor, int, 0);</div><div class='del'>-module_param(debug_level, int, 0);</div><div class='del'>-module_param_array(maxframe, int, NULL, 0);</div><div class='del'>-</div><div class='del'>-MODULE_LICENSE("GPL");</div><div class='del'>-</div><div class='del'>-static char *driver_name = "SyncLink PC Card driver";</div><div class='del'>-static char *driver_version = "$Revision: 4.34 $";</div><div class='del'>-</div><div class='del'>-static struct tty_driver *serial_driver;</div><div class='del'>-</div><div class='del'>-/* number of characters left in xmit buffer before we ask for more */</div><div class='del'>-#define WAKEUP_CHARS 256</div><div class='del'>-</div><div class='del'>-static void mgslpc_change_params(MGSLPC_INFO *info, struct tty_struct *tty);</div><div class='del'>-static void mgslpc_wait_until_sent(struct tty_struct *tty, int timeout);</div><div class='del'>-</div><div class='del'>-/* PCMCIA prototypes */</div><div class='del'>-</div><div class='del'>-static int mgslpc_config(struct pcmcia_device *link);</div><div class='del'>-static void mgslpc_release(u_long arg);</div><div class='del'>-static void mgslpc_detach(struct pcmcia_device *p_dev);</div><div class='del'>-</div><div class='del'>-/*</div><div class='del'>- * 1st function defined in .text section. Calling this function in</div><div class='del'>- * init_module() followed by a breakpoint allows a remote debugger</div><div class='del'>- * (gdb) to get the .text address for the add-symbol-file command.</div><div class='del'>- * This allows remote debugging of dynamically loadable modules.</div><div class='del'>- */</div><div class='del'>-static void* mgslpc_get_text_ptr(void)</div><div class='del'>-{</div><div class='del'>-	return mgslpc_get_text_ptr;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/*</div><div class='del'>- * line discipline callback wrappers</div><div class='del'>- *</div><div class='del'>- * The wrappers maintain line discipline references</div><div class='del'>- * while calling into the line discipline.</div><div class='del'>- *</div><div class='del'>- * ldisc_receive_buf  - pass receive data to line discipline</div><div class='del'>- */</div><div class='del'>-</div><div class='del'>-static void ldisc_receive_buf(struct tty_struct *tty,</div><div class='del'>-			      const __u8 *data, char *flags, int count)</div><div class='del'>-{</div><div class='del'>-	struct tty_ldisc *ld;</div><div class='del'>-	if (!tty)</div><div class='del'>-		return;</div><div class='del'>-	ld = tty_ldisc_ref(tty);</div><div class='del'>-	if (ld) {</div><div class='del'>-		if (ld-&gt;ops-&gt;receive_buf)</div><div class='del'>-			ld-&gt;ops-&gt;receive_buf(tty, data, flags, count);</div><div class='del'>-		tty_ldisc_deref(ld);</div><div class='del'>-	}</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static const struct tty_port_operations mgslpc_port_ops = {</div><div class='del'>-	.carrier_raised = carrier_raised,</div><div class='del'>-	.dtr_rts = dtr_rts</div><div class='del'>-};</div><div class='del'>-</div><div class='del'>-static int mgslpc_probe(struct pcmcia_device *link)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *info;</div><div class='del'>-	int ret;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("mgslpc_attach\n");</div><div class='del'>-</div><div class='del'>-	info = kzalloc(sizeof(MGSLPC_INFO), GFP_KERNEL);</div><div class='del'>-	if (!info) {</div><div class='del'>-		printk("Error can't allocate device instance data\n");</div><div class='del'>-		return -ENOMEM;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	info-&gt;magic = MGSLPC_MAGIC;</div><div class='del'>-	tty_port_init(&amp;info-&gt;port);</div><div class='del'>-	info-&gt;port.ops = &amp;mgslpc_port_ops;</div><div class='del'>-	INIT_WORK(&amp;info-&gt;task, bh_handler);</div><div class='del'>-	info-&gt;max_frame_size = 4096;</div><div class='del'>-	init_waitqueue_head(&amp;info-&gt;status_event_wait_q);</div><div class='del'>-	init_waitqueue_head(&amp;info-&gt;event_wait_q);</div><div class='del'>-	spin_lock_init(&amp;info-&gt;lock);</div><div class='del'>-	spin_lock_init(&amp;info-&gt;netlock);</div><div class='del'>-	memcpy(&amp;info-&gt;params,&amp;default_params,sizeof(MGSL_PARAMS));</div><div class='del'>-	info-&gt;idle_mode = HDLC_TXIDLE_FLAGS;</div><div class='del'>-	info-&gt;imra_value = 0xffff;</div><div class='del'>-	info-&gt;imrb_value = 0xffff;</div><div class='del'>-	info-&gt;pim_value = 0xff;</div><div class='del'>-</div><div class='del'>-	info-&gt;p_dev = link;</div><div class='del'>-	link-&gt;priv = info;</div><div class='del'>-</div><div class='del'>-	/* Initialize the struct pcmcia_device structure */</div><div class='del'>-</div><div class='del'>-	ret = mgslpc_config(link);</div><div class='del'>-	if (ret != 0)</div><div class='del'>-		goto failed;</div><div class='del'>-</div><div class='del'>-	ret = mgslpc_add_device(info);</div><div class='del'>-	if (ret != 0)</div><div class='del'>-		goto failed_release;</div><div class='del'>-</div><div class='del'>-	return 0;</div><div class='del'>-</div><div class='del'>-failed_release:</div><div class='del'>-	mgslpc_release((u_long)link);</div><div class='del'>-failed:</div><div class='del'>-	tty_port_destroy(&amp;info-&gt;port);</div><div class='del'>-	kfree(info);</div><div class='del'>-	return ret;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Card has been inserted.</div><div class='del'>- */</div><div class='del'>-</div><div class='del'>-static int mgslpc_ioprobe(struct pcmcia_device *p_dev, void *priv_data)</div><div class='del'>-{</div><div class='del'>-	return pcmcia_request_io(p_dev);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int mgslpc_config(struct pcmcia_device *link)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *info = link-&gt;priv;</div><div class='del'>-	int ret;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("mgslpc_config(0x%p)\n", link);</div><div class='del'>-</div><div class='del'>-	link-&gt;config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO;</div><div class='del'>-</div><div class='del'>-	ret = pcmcia_loop_config(link, mgslpc_ioprobe, NULL);</div><div class='del'>-	if (ret != 0)</div><div class='del'>-		goto failed;</div><div class='del'>-</div><div class='del'>-	link-&gt;config_index = 8;</div><div class='del'>-	link-&gt;config_regs = PRESENT_OPTION;</div><div class='del'>-</div><div class='del'>-	ret = pcmcia_request_irq(link, mgslpc_isr);</div><div class='del'>-	if (ret)</div><div class='del'>-		goto failed;</div><div class='del'>-	ret = pcmcia_enable_device(link);</div><div class='del'>-	if (ret)</div><div class='del'>-		goto failed;</div><div class='del'>-</div><div class='del'>-	info-&gt;io_base = link-&gt;resource[0]-&gt;start;</div><div class='del'>-	info-&gt;irq_level = link-&gt;irq;</div><div class='del'>-	return 0;</div><div class='del'>-</div><div class='del'>-failed:</div><div class='del'>-	mgslpc_release((u_long)link);</div><div class='del'>-	return -ENODEV;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Card has been removed.</div><div class='del'>- * Unregister device and release PCMCIA configuration.</div><div class='del'>- * If device is open, postpone until it is closed.</div><div class='del'>- */</div><div class='del'>-static void mgslpc_release(u_long arg)</div><div class='del'>-{</div><div class='del'>-	struct pcmcia_device *link = (struct pcmcia_device *)arg;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("mgslpc_release(0x%p)\n", link);</div><div class='del'>-</div><div class='del'>-	pcmcia_disable_device(link);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void mgslpc_detach(struct pcmcia_device *link)</div><div class='del'>-{</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("mgslpc_detach(0x%p)\n", link);</div><div class='del'>-</div><div class='del'>-	((MGSLPC_INFO *)link-&gt;priv)-&gt;stop = 1;</div><div class='del'>-	mgslpc_release((u_long)link);</div><div class='del'>-</div><div class='del'>-	mgslpc_remove_device((MGSLPC_INFO *)link-&gt;priv);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int mgslpc_suspend(struct pcmcia_device *link)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *info = link-&gt;priv;</div><div class='del'>-</div><div class='del'>-	info-&gt;stop = 1;</div><div class='del'>-</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int mgslpc_resume(struct pcmcia_device *link)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *info = link-&gt;priv;</div><div class='del'>-</div><div class='del'>-	info-&gt;stop = 0;</div><div class='del'>-</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-</div><div class='del'>-static inline bool mgslpc_paranoia_check(MGSLPC_INFO *info,</div><div class='del'>-					char *name, const char *routine)</div><div class='del'>-{</div><div class='del'>-#ifdef MGSLPC_PARANOIA_CHECK</div><div class='del'>-	static const char *badmagic =</div><div class='del'>-		"Warning: bad magic number for mgsl struct (%s) in %s\n";</div><div class='del'>-	static const char *badinfo =</div><div class='del'>-		"Warning: null mgslpc_info for (%s) in %s\n";</div><div class='del'>-</div><div class='del'>-	if (!info) {</div><div class='del'>-		printk(badinfo, name, routine);</div><div class='del'>-		return true;</div><div class='del'>-	}</div><div class='del'>-	if (info-&gt;magic != MGSLPC_MAGIC) {</div><div class='del'>-		printk(badmagic, name, routine);</div><div class='del'>-		return true;</div><div class='del'>-	}</div><div class='del'>-#else</div><div class='del'>-	if (!info)</div><div class='del'>-		return true;</div><div class='del'>-#endif</div><div class='del'>-	return false;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-</div><div class='del'>-#define CMD_RXFIFO      BIT7	// release current rx FIFO</div><div class='del'>-#define CMD_RXRESET     BIT6	// receiver reset</div><div class='del'>-#define CMD_RXFIFO_READ BIT5</div><div class='del'>-#define CMD_START_TIMER BIT4</div><div class='del'>-#define CMD_TXFIFO      BIT3	// release current tx FIFO</div><div class='del'>-#define CMD_TXEOM       BIT1	// transmit end message</div><div class='del'>-#define CMD_TXRESET     BIT0	// transmit reset</div><div class='del'>-</div><div class='del'>-static bool wait_command_complete(MGSLPC_INFO *info, unsigned char channel)</div><div class='del'>-{</div><div class='del'>-	int i = 0;</div><div class='del'>-	/* wait for command completion */</div><div class='del'>-	while (read_reg(info, (unsigned char)(channel+STAR)) &amp; BIT2) {</div><div class='del'>-		udelay(1);</div><div class='del'>-		if (i++ == 1000)</div><div class='del'>-			return false;</div><div class='del'>-	}</div><div class='del'>-	return true;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void issue_command(MGSLPC_INFO *info, unsigned char channel, unsigned char cmd)</div><div class='del'>-{</div><div class='del'>-	wait_command_complete(info, channel);</div><div class='del'>-	write_reg(info, (unsigned char) (channel + CMDR), cmd);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void tx_pause(struct tty_struct *tty)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *info = (MGSLPC_INFO *)tty-&gt;driver_data;</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	if (mgslpc_paranoia_check(info, tty-&gt;name, "tx_pause"))</div><div class='del'>-		return;</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("tx_pause(%s)\n", info-&gt;device_name);</div><div class='del'>-</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-	if (info-&gt;tx_enabled)</div><div class='del'>-		tx_stop(info);</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void tx_release(struct tty_struct *tty)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *info = (MGSLPC_INFO *)tty-&gt;driver_data;</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	if (mgslpc_paranoia_check(info, tty-&gt;name, "tx_release"))</div><div class='del'>-		return;</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("tx_release(%s)\n", info-&gt;device_name);</div><div class='del'>-</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-	if (!info-&gt;tx_enabled)</div><div class='del'>-		tx_start(info, tty);</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Return next bottom half action to perform.</div><div class='del'>- * or 0 if nothing to do.</div><div class='del'>- */</div><div class='del'>-static int bh_action(MGSLPC_INFO *info)</div><div class='del'>-{</div><div class='del'>-	unsigned long flags;</div><div class='del'>-	int rc = 0;</div><div class='del'>-</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-</div><div class='del'>-	if (info-&gt;pending_bh &amp; BH_RECEIVE) {</div><div class='del'>-		info-&gt;pending_bh &amp;= ~BH_RECEIVE;</div><div class='del'>-		rc = BH_RECEIVE;</div><div class='del'>-	} else if (info-&gt;pending_bh &amp; BH_TRANSMIT) {</div><div class='del'>-		info-&gt;pending_bh &amp;= ~BH_TRANSMIT;</div><div class='del'>-		rc = BH_TRANSMIT;</div><div class='del'>-	} else if (info-&gt;pending_bh &amp; BH_STATUS) {</div><div class='del'>-		info-&gt;pending_bh &amp;= ~BH_STATUS;</div><div class='del'>-		rc = BH_STATUS;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (!rc) {</div><div class='del'>-		/* Mark BH routine as complete */</div><div class='del'>-		info-&gt;bh_running = false;</div><div class='del'>-		info-&gt;bh_requested = false;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-</div><div class='del'>-	return rc;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void bh_handler(struct work_struct *work)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *info = container_of(work, MGSLPC_INFO, task);</div><div class='del'>-	struct tty_struct *tty;</div><div class='del'>-	int action;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_BH)</div><div class='del'>-		printk("%s(%d):bh_handler(%s) entry\n",</div><div class='del'>-			__FILE__,__LINE__,info-&gt;device_name);</div><div class='del'>-</div><div class='del'>-	info-&gt;bh_running = true;</div><div class='del'>-	tty = tty_port_tty_get(&amp;info-&gt;port);</div><div class='del'>-</div><div class='del'>-	while((action = bh_action(info)) != 0) {</div><div class='del'>-</div><div class='del'>-		/* Process work item */</div><div class='del'>-		if (debug_level &gt;= DEBUG_LEVEL_BH)</div><div class='del'>-			printk("%s(%d):bh_handler() work item action=%d\n",</div><div class='del'>-				__FILE__,__LINE__,action);</div><div class='del'>-</div><div class='del'>-		switch (action) {</div><div class='del'>-</div><div class='del'>-		case BH_RECEIVE:</div><div class='del'>-			while(rx_get_frame(info, tty));</div><div class='del'>-			break;</div><div class='del'>-		case BH_TRANSMIT:</div><div class='del'>-			bh_transmit(info, tty);</div><div class='del'>-			break;</div><div class='del'>-		case BH_STATUS:</div><div class='del'>-			bh_status(info);</div><div class='del'>-			break;</div><div class='del'>-		default:</div><div class='del'>-			/* unknown work item ID */</div><div class='del'>-			printk("Unknown work item ID=%08X!\n", action);</div><div class='del'>-			break;</div><div class='del'>-		}</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	tty_kref_put(tty);</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_BH)</div><div class='del'>-		printk("%s(%d):bh_handler(%s) exit\n",</div><div class='del'>-			__FILE__,__LINE__,info-&gt;device_name);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void bh_transmit(MGSLPC_INFO *info, struct tty_struct *tty)</div><div class='del'>-{</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_BH)</div><div class='del'>-		printk("bh_transmit() entry on %s\n", info-&gt;device_name);</div><div class='del'>-</div><div class='del'>-	if (tty)</div><div class='del'>-		tty_wakeup(tty);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void bh_status(MGSLPC_INFO *info)</div><div class='del'>-{</div><div class='del'>-	info-&gt;ri_chkcount = 0;</div><div class='del'>-	info-&gt;dsr_chkcount = 0;</div><div class='del'>-	info-&gt;dcd_chkcount = 0;</div><div class='del'>-	info-&gt;cts_chkcount = 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* eom: non-zero = end of frame */</div><div class='del'>-static void rx_ready_hdlc(MGSLPC_INFO *info, int eom)</div><div class='del'>-{</div><div class='del'>-	unsigned char data[2];</div><div class='del'>-	unsigned char fifo_count, read_count, i;</div><div class='del'>-	RXBUF *buf = (RXBUF*)(info-&gt;rx_buf + (info-&gt;rx_put * info-&gt;rx_buf_size));</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_ISR)</div><div class='del'>-		printk("%s(%d):rx_ready_hdlc(eom=%d)\n", __FILE__, __LINE__, eom);</div><div class='del'>-</div><div class='del'>-	if (!info-&gt;rx_enabled)</div><div class='del'>-		return;</div><div class='del'>-</div><div class='del'>-	if (info-&gt;rx_frame_count &gt;= info-&gt;rx_buf_count) {</div><div class='del'>-		/* no more free buffers */</div><div class='del'>-		issue_command(info, CHA, CMD_RXRESET);</div><div class='del'>-		info-&gt;pending_bh |= BH_RECEIVE;</div><div class='del'>-		info-&gt;rx_overflow = true;</div><div class='del'>-		info-&gt;icount.buf_overrun++;</div><div class='del'>-		return;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (eom) {</div><div class='del'>-		/* end of frame, get FIFO count from RBCL register */</div><div class='del'>-		fifo_count = (unsigned char)(read_reg(info, CHA+RBCL) &amp; 0x1f);</div><div class='del'>-		if (fifo_count == 0)</div><div class='del'>-			fifo_count = 32;</div><div class='del'>-	} else</div><div class='del'>-		fifo_count = 32;</div><div class='del'>-</div><div class='del'>-	do {</div><div class='del'>-		if (fifo_count == 1) {</div><div class='del'>-			read_count = 1;</div><div class='del'>-			data[0] = read_reg(info, CHA + RXFIFO);</div><div class='del'>-		} else {</div><div class='del'>-			read_count = 2;</div><div class='del'>-			*((unsigned short *) data) = read_reg16(info, CHA + RXFIFO);</div><div class='del'>-		}</div><div class='del'>-		fifo_count -= read_count;</div><div class='del'>-		if (!fifo_count &amp;&amp; eom)</div><div class='del'>-			buf-&gt;status = data[--read_count];</div><div class='del'>-</div><div class='del'>-		for (i = 0; i &lt; read_count; i++) {</div><div class='del'>-			if (buf-&gt;count &gt;= info-&gt;max_frame_size) {</div><div class='del'>-				/* frame too large, reset receiver and reset current buffer */</div><div class='del'>-				issue_command(info, CHA, CMD_RXRESET);</div><div class='del'>-				buf-&gt;count = 0;</div><div class='del'>-				return;</div><div class='del'>-			}</div><div class='del'>-			*(buf-&gt;data + buf-&gt;count) = data[i];</div><div class='del'>-			buf-&gt;count++;</div><div class='del'>-		}</div><div class='del'>-	} while (fifo_count);</div><div class='del'>-</div><div class='del'>-	if (eom) {</div><div class='del'>-		info-&gt;pending_bh |= BH_RECEIVE;</div><div class='del'>-		info-&gt;rx_frame_count++;</div><div class='del'>-		info-&gt;rx_put++;</div><div class='del'>-		if (info-&gt;rx_put &gt;= info-&gt;rx_buf_count)</div><div class='del'>-			info-&gt;rx_put = 0;</div><div class='del'>-	}</div><div class='del'>-	issue_command(info, CHA, CMD_RXFIFO);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void rx_ready_async(MGSLPC_INFO *info, int tcd)</div><div class='del'>-{</div><div class='del'>-	struct tty_port *port = &amp;info-&gt;port;</div><div class='del'>-	unsigned char data, status, flag;</div><div class='del'>-	int fifo_count;</div><div class='del'>-	int work = 0;</div><div class='del'>-	struct mgsl_icount *icount = &amp;info-&gt;icount;</div><div class='del'>-</div><div class='del'>-	if (tcd) {</div><div class='del'>-		/* early termination, get FIFO count from RBCL register */</div><div class='del'>-		fifo_count = (unsigned char)(read_reg(info, CHA+RBCL) &amp; 0x1f);</div><div class='del'>-</div><div class='del'>-		/* Zero fifo count could mean 0 or 32 bytes available.</div><div class='del'>-		 * If BIT5 of STAR is set then at least 1 byte is available.</div><div class='del'>-		 */</div><div class='del'>-		if (!fifo_count &amp;&amp; (read_reg(info,CHA+STAR) &amp; BIT5))</div><div class='del'>-			fifo_count = 32;</div><div class='del'>-	} else</div><div class='del'>-		fifo_count = 32;</div><div class='del'>-</div><div class='del'>-	tty_buffer_request_room(port, fifo_count);</div><div class='del'>-	/* Flush received async data to receive data buffer. */</div><div class='del'>-	while (fifo_count) {</div><div class='del'>-		data   = read_reg(info, CHA + RXFIFO);</div><div class='del'>-		status = read_reg(info, CHA + RXFIFO);</div><div class='del'>-		fifo_count -= 2;</div><div class='del'>-</div><div class='del'>-		icount-&gt;rx++;</div><div class='del'>-		flag = TTY_NORMAL;</div><div class='del'>-</div><div class='del'>-		// if no frameing/crc error then save data</div><div class='del'>-		// BIT7:parity error</div><div class='del'>-		// BIT6:framing error</div><div class='del'>-</div><div class='del'>-		if (status &amp; (BIT7 | BIT6)) {</div><div class='del'>-			if (status &amp; BIT7)</div><div class='del'>-				icount-&gt;parity++;</div><div class='del'>-			else</div><div class='del'>-				icount-&gt;frame++;</div><div class='del'>-</div><div class='del'>-			/* discard char if tty control flags say so */</div><div class='del'>-			if (status &amp; info-&gt;ignore_status_mask)</div><div class='del'>-				continue;</div><div class='del'>-</div><div class='del'>-			status &amp;= info-&gt;read_status_mask;</div><div class='del'>-</div><div class='del'>-			if (status &amp; BIT7)</div><div class='del'>-				flag = TTY_PARITY;</div><div class='del'>-			else if (status &amp; BIT6)</div><div class='del'>-				flag = TTY_FRAME;</div><div class='del'>-		}</div><div class='del'>-		work += tty_insert_flip_char(port, data, flag);</div><div class='del'>-	}</div><div class='del'>-	issue_command(info, CHA, CMD_RXFIFO);</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_ISR) {</div><div class='del'>-		printk("%s(%d):rx_ready_async",</div><div class='del'>-			__FILE__,__LINE__);</div><div class='del'>-		printk("%s(%d):rx=%d brk=%d parity=%d frame=%d overrun=%d\n",</div><div class='del'>-			__FILE__,__LINE__,icount-&gt;rx,icount-&gt;brk,</div><div class='del'>-			icount-&gt;parity,icount-&gt;frame,icount-&gt;overrun);</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (work)</div><div class='del'>-		tty_flip_buffer_push(port);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-</div><div class='del'>-static void tx_done(MGSLPC_INFO *info, struct tty_struct *tty)</div><div class='del'>-{</div><div class='del'>-	if (!info-&gt;tx_active)</div><div class='del'>-		return;</div><div class='del'>-</div><div class='del'>-	info-&gt;tx_active = false;</div><div class='del'>-	info-&gt;tx_aborting = false;</div><div class='del'>-</div><div class='del'>-	if (info-&gt;params.mode == MGSL_MODE_ASYNC)</div><div class='del'>-		return;</div><div class='del'>-</div><div class='del'>-	info-&gt;tx_count = info-&gt;tx_put = info-&gt;tx_get = 0;</div><div class='del'>-	del_timer(&amp;info-&gt;tx_timer);</div><div class='del'>-</div><div class='del'>-	if (info-&gt;drop_rts_on_tx_done) {</div><div class='del'>-		get_signals(info);</div><div class='del'>-		if (info-&gt;serial_signals &amp; SerialSignal_RTS) {</div><div class='del'>-			info-&gt;serial_signals &amp;= ~SerialSignal_RTS;</div><div class='del'>-			set_signals(info);</div><div class='del'>-		}</div><div class='del'>-		info-&gt;drop_rts_on_tx_done = false;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-#if SYNCLINK_GENERIC_HDLC</div><div class='del'>-	if (info-&gt;netcount)</div><div class='del'>-		hdlcdev_tx_done(info);</div><div class='del'>-	else</div><div class='del'>-#endif</div><div class='del'>-	{</div><div class='del'>-		if (tty &amp;&amp; (tty-&gt;flow.stopped || tty-&gt;hw_stopped)) {</div><div class='del'>-			tx_stop(info);</div><div class='del'>-			return;</div><div class='del'>-		}</div><div class='del'>-		info-&gt;pending_bh |= BH_TRANSMIT;</div><div class='del'>-	}</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void tx_ready(MGSLPC_INFO *info, struct tty_struct *tty)</div><div class='del'>-{</div><div class='del'>-	unsigned char fifo_count = 32;</div><div class='del'>-	int c;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_ISR)</div><div class='del'>-		printk("%s(%d):tx_ready(%s)\n", __FILE__, __LINE__, info-&gt;device_name);</div><div class='del'>-</div><div class='del'>-	if (info-&gt;params.mode == MGSL_MODE_HDLC) {</div><div class='del'>-		if (!info-&gt;tx_active)</div><div class='del'>-			return;</div><div class='del'>-	} else {</div><div class='del'>-		if (tty &amp;&amp; (tty-&gt;flow.stopped || tty-&gt;hw_stopped)) {</div><div class='del'>-			tx_stop(info);</div><div class='del'>-			return;</div><div class='del'>-		}</div><div class='del'>-		if (!info-&gt;tx_count)</div><div class='del'>-			info-&gt;tx_active = false;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (!info-&gt;tx_count)</div><div class='del'>-		return;</div><div class='del'>-</div><div class='del'>-	while (info-&gt;tx_count &amp;&amp; fifo_count) {</div><div class='del'>-		c = min(2, min_t(int, fifo_count, min(info-&gt;tx_count, TXBUFSIZE - info-&gt;tx_get)));</div><div class='del'>-</div><div class='del'>-		if (c == 1) {</div><div class='del'>-			write_reg(info, CHA + TXFIFO, *(info-&gt;tx_buf + info-&gt;tx_get));</div><div class='del'>-		} else {</div><div class='del'>-			write_reg16(info, CHA + TXFIFO,</div><div class='del'>-					  *((unsigned short*)(info-&gt;tx_buf + info-&gt;tx_get)));</div><div class='del'>-		}</div><div class='del'>-		info-&gt;tx_count -= c;</div><div class='del'>-		info-&gt;tx_get = (info-&gt;tx_get + c) &amp; (TXBUFSIZE - 1);</div><div class='del'>-		fifo_count -= c;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (info-&gt;params.mode == MGSL_MODE_ASYNC) {</div><div class='del'>-		if (info-&gt;tx_count &lt; WAKEUP_CHARS)</div><div class='del'>-			info-&gt;pending_bh |= BH_TRANSMIT;</div><div class='del'>-		issue_command(info, CHA, CMD_TXFIFO);</div><div class='del'>-	} else {</div><div class='del'>-		if (info-&gt;tx_count)</div><div class='del'>-			issue_command(info, CHA, CMD_TXFIFO);</div><div class='del'>-		else</div><div class='del'>-			issue_command(info, CHA, CMD_TXFIFO + CMD_TXEOM);</div><div class='del'>-	}</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void cts_change(MGSLPC_INFO *info, struct tty_struct *tty)</div><div class='del'>-{</div><div class='del'>-	get_signals(info);</div><div class='del'>-	if ((info-&gt;cts_chkcount)++ &gt;= IO_PIN_SHUTDOWN_LIMIT)</div><div class='del'>-		irq_disable(info, CHB, IRQ_CTS);</div><div class='del'>-	info-&gt;icount.cts++;</div><div class='del'>-	if (info-&gt;serial_signals &amp; SerialSignal_CTS)</div><div class='del'>-		info-&gt;input_signal_events.cts_up++;</div><div class='del'>-	else</div><div class='del'>-		info-&gt;input_signal_events.cts_down++;</div><div class='del'>-	wake_up_interruptible(&amp;info-&gt;status_event_wait_q);</div><div class='del'>-	wake_up_interruptible(&amp;info-&gt;event_wait_q);</div><div class='del'>-</div><div class='del'>-	if (tty &amp;&amp; tty_port_cts_enabled(&amp;info-&gt;port)) {</div><div class='del'>-		if (tty-&gt;hw_stopped) {</div><div class='del'>-			if (info-&gt;serial_signals &amp; SerialSignal_CTS) {</div><div class='del'>-				if (debug_level &gt;= DEBUG_LEVEL_ISR)</div><div class='del'>-					printk("CTS tx start...");</div><div class='del'>-				tty-&gt;hw_stopped = 0;</div><div class='del'>-				tx_start(info, tty);</div><div class='del'>-				info-&gt;pending_bh |= BH_TRANSMIT;</div><div class='del'>-				return;</div><div class='del'>-			}</div><div class='del'>-		} else {</div><div class='del'>-			if (!(info-&gt;serial_signals &amp; SerialSignal_CTS)) {</div><div class='del'>-				if (debug_level &gt;= DEBUG_LEVEL_ISR)</div><div class='del'>-					printk("CTS tx stop...");</div><div class='del'>-				tty-&gt;hw_stopped = 1;</div><div class='del'>-				tx_stop(info);</div><div class='del'>-			}</div><div class='del'>-		}</div><div class='del'>-	}</div><div class='del'>-	info-&gt;pending_bh |= BH_STATUS;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void dcd_change(MGSLPC_INFO *info, struct tty_struct *tty)</div><div class='del'>-{</div><div class='del'>-	get_signals(info);</div><div class='del'>-	if ((info-&gt;dcd_chkcount)++ &gt;= IO_PIN_SHUTDOWN_LIMIT)</div><div class='del'>-		irq_disable(info, CHB, IRQ_DCD);</div><div class='del'>-	info-&gt;icount.dcd++;</div><div class='del'>-	if (info-&gt;serial_signals &amp; SerialSignal_DCD) {</div><div class='del'>-		info-&gt;input_signal_events.dcd_up++;</div><div class='del'>-	}</div><div class='del'>-	else</div><div class='del'>-		info-&gt;input_signal_events.dcd_down++;</div><div class='del'>-#if SYNCLINK_GENERIC_HDLC</div><div class='del'>-	if (info-&gt;netcount) {</div><div class='del'>-		if (info-&gt;serial_signals &amp; SerialSignal_DCD)</div><div class='del'>-			netif_carrier_on(info-&gt;netdev);</div><div class='del'>-		else</div><div class='del'>-			netif_carrier_off(info-&gt;netdev);</div><div class='del'>-	}</div><div class='del'>-#endif</div><div class='del'>-	wake_up_interruptible(&amp;info-&gt;status_event_wait_q);</div><div class='del'>-	wake_up_interruptible(&amp;info-&gt;event_wait_q);</div><div class='del'>-</div><div class='del'>-	if (tty_port_check_carrier(&amp;info-&gt;port)) {</div><div class='del'>-		if (debug_level &gt;= DEBUG_LEVEL_ISR)</div><div class='del'>-			printk("%s CD now %s...", info-&gt;device_name,</div><div class='del'>-			       (info-&gt;serial_signals &amp; SerialSignal_DCD) ? "on" : "off");</div><div class='del'>-		if (info-&gt;serial_signals &amp; SerialSignal_DCD)</div><div class='del'>-			wake_up_interruptible(&amp;info-&gt;port.open_wait);</div><div class='del'>-		else {</div><div class='del'>-			if (debug_level &gt;= DEBUG_LEVEL_ISR)</div><div class='del'>-				printk("doing serial hangup...");</div><div class='del'>-			if (tty)</div><div class='del'>-				tty_hangup(tty);</div><div class='del'>-		}</div><div class='del'>-	}</div><div class='del'>-	info-&gt;pending_bh |= BH_STATUS;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void dsr_change(MGSLPC_INFO *info)</div><div class='del'>-{</div><div class='del'>-	get_signals(info);</div><div class='del'>-	if ((info-&gt;dsr_chkcount)++ &gt;= IO_PIN_SHUTDOWN_LIMIT)</div><div class='del'>-		port_irq_disable(info, PVR_DSR);</div><div class='del'>-	info-&gt;icount.dsr++;</div><div class='del'>-	if (info-&gt;serial_signals &amp; SerialSignal_DSR)</div><div class='del'>-		info-&gt;input_signal_events.dsr_up++;</div><div class='del'>-	else</div><div class='del'>-		info-&gt;input_signal_events.dsr_down++;</div><div class='del'>-	wake_up_interruptible(&amp;info-&gt;status_event_wait_q);</div><div class='del'>-	wake_up_interruptible(&amp;info-&gt;event_wait_q);</div><div class='del'>-	info-&gt;pending_bh |= BH_STATUS;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void ri_change(MGSLPC_INFO *info)</div><div class='del'>-{</div><div class='del'>-	get_signals(info);</div><div class='del'>-	if ((info-&gt;ri_chkcount)++ &gt;= IO_PIN_SHUTDOWN_LIMIT)</div><div class='del'>-		port_irq_disable(info, PVR_RI);</div><div class='del'>-	info-&gt;icount.rng++;</div><div class='del'>-	if (info-&gt;serial_signals &amp; SerialSignal_RI)</div><div class='del'>-		info-&gt;input_signal_events.ri_up++;</div><div class='del'>-	else</div><div class='del'>-		info-&gt;input_signal_events.ri_down++;</div><div class='del'>-	wake_up_interruptible(&amp;info-&gt;status_event_wait_q);</div><div class='del'>-	wake_up_interruptible(&amp;info-&gt;event_wait_q);</div><div class='del'>-	info-&gt;pending_bh |= BH_STATUS;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Interrupt service routine entry point.</div><div class='del'>- *</div><div class='del'>- * Arguments:</div><div class='del'>- *</div><div class='del'>- * irq     interrupt number that caused interrupt</div><div class='del'>- * dev_id  device ID supplied during interrupt registration</div><div class='del'>- */</div><div class='del'>-static irqreturn_t mgslpc_isr(int dummy, void *dev_id)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *info = dev_id;</div><div class='del'>-	struct tty_struct *tty;</div><div class='del'>-	unsigned short isr;</div><div class='del'>-	unsigned char gis, pis;</div><div class='del'>-	int count=0;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_ISR)</div><div class='del'>-		printk("mgslpc_isr(%d) entry.\n", info-&gt;irq_level);</div><div class='del'>-</div><div class='del'>-	if (!(info-&gt;p_dev-&gt;_locked))</div><div class='del'>-		return IRQ_HANDLED;</div><div class='del'>-</div><div class='del'>-	tty = tty_port_tty_get(&amp;info-&gt;port);</div><div class='del'>-</div><div class='del'>-	spin_lock(&amp;info-&gt;lock);</div><div class='del'>-</div><div class='del'>-	while ((gis = read_reg(info, CHA + GIS))) {</div><div class='del'>-		if (debug_level &gt;= DEBUG_LEVEL_ISR)</div><div class='del'>-			printk("mgslpc_isr %s gis=%04X\n", info-&gt;device_name,gis);</div><div class='del'>-</div><div class='del'>-		if ((gis &amp; 0x70) || count &gt; 1000) {</div><div class='del'>-			printk("synclink_cs:hardware failed or ejected\n");</div><div class='del'>-			break;</div><div class='del'>-		}</div><div class='del'>-		count++;</div><div class='del'>-</div><div class='del'>-		if (gis &amp; (BIT1 | BIT0)) {</div><div class='del'>-			isr = read_reg16(info, CHB + ISR);</div><div class='del'>-			if (isr &amp; IRQ_DCD)</div><div class='del'>-				dcd_change(info, tty);</div><div class='del'>-			if (isr &amp; IRQ_CTS)</div><div class='del'>-				cts_change(info, tty);</div><div class='del'>-		}</div><div class='del'>-		if (gis &amp; (BIT3 | BIT2))</div><div class='del'>-		{</div><div class='del'>-			isr = read_reg16(info, CHA + ISR);</div><div class='del'>-			if (isr &amp; IRQ_TIMER) {</div><div class='del'>-				info-&gt;irq_occurred = true;</div><div class='del'>-				irq_disable(info, CHA, IRQ_TIMER);</div><div class='del'>-			}</div><div class='del'>-</div><div class='del'>-			/* receive IRQs */</div><div class='del'>-			if (isr &amp; IRQ_EXITHUNT) {</div><div class='del'>-				info-&gt;icount.exithunt++;</div><div class='del'>-				wake_up_interruptible(&amp;info-&gt;event_wait_q);</div><div class='del'>-			}</div><div class='del'>-			if (isr &amp; IRQ_BREAK_ON) {</div><div class='del'>-				info-&gt;icount.brk++;</div><div class='del'>-				if (info-&gt;port.flags &amp; ASYNC_SAK)</div><div class='del'>-					do_SAK(tty);</div><div class='del'>-			}</div><div class='del'>-			if (isr &amp; IRQ_RXTIME) {</div><div class='del'>-				issue_command(info, CHA, CMD_RXFIFO_READ);</div><div class='del'>-			}</div><div class='del'>-			if (isr &amp; (IRQ_RXEOM | IRQ_RXFIFO)) {</div><div class='del'>-				if (info-&gt;params.mode == MGSL_MODE_HDLC)</div><div class='del'>-					rx_ready_hdlc(info, isr &amp; IRQ_RXEOM);</div><div class='del'>-				else</div><div class='del'>-					rx_ready_async(info, isr &amp; IRQ_RXEOM);</div><div class='del'>-			}</div><div class='del'>-</div><div class='del'>-			/* transmit IRQs */</div><div class='del'>-			if (isr &amp; IRQ_UNDERRUN) {</div><div class='del'>-				if (info-&gt;tx_aborting)</div><div class='del'>-					info-&gt;icount.txabort++;</div><div class='del'>-				else</div><div class='del'>-					info-&gt;icount.txunder++;</div><div class='del'>-				tx_done(info, tty);</div><div class='del'>-			}</div><div class='del'>-			else if (isr &amp; IRQ_ALLSENT) {</div><div class='del'>-				info-&gt;icount.txok++;</div><div class='del'>-				tx_done(info, tty);</div><div class='del'>-			}</div><div class='del'>-			else if (isr &amp; IRQ_TXFIFO)</div><div class='del'>-				tx_ready(info, tty);</div><div class='del'>-		}</div><div class='del'>-		if (gis &amp; BIT7) {</div><div class='del'>-			pis = read_reg(info, CHA + PIS);</div><div class='del'>-			if (pis &amp; BIT1)</div><div class='del'>-				dsr_change(info);</div><div class='del'>-			if (pis &amp; BIT2)</div><div class='del'>-				ri_change(info);</div><div class='del'>-		}</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	/* Request bottom half processing if there's something</div><div class='del'>-	 * for it to do and the bh is not already running</div><div class='del'>-	 */</div><div class='del'>-</div><div class='del'>-	if (info-&gt;pending_bh &amp;&amp; !info-&gt;bh_running &amp;&amp; !info-&gt;bh_requested) {</div><div class='del'>-		if (debug_level &gt;= DEBUG_LEVEL_ISR)</div><div class='del'>-			printk("%s(%d):%s queueing bh task.\n",</div><div class='del'>-				__FILE__,__LINE__,info-&gt;device_name);</div><div class='del'>-		schedule_work(&amp;info-&gt;task);</div><div class='del'>-		info-&gt;bh_requested = true;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	spin_unlock(&amp;info-&gt;lock);</div><div class='del'>-	tty_kref_put(tty);</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_ISR)</div><div class='del'>-		printk("%s(%d):mgslpc_isr(%d)exit.\n",</div><div class='del'>-		       __FILE__, __LINE__, info-&gt;irq_level);</div><div class='del'>-</div><div class='del'>-	return IRQ_HANDLED;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Initialize and start device.</div><div class='del'>- */</div><div class='del'>-static int startup(MGSLPC_INFO * info, struct tty_struct *tty)</div><div class='del'>-{</div><div class='del'>-	int retval = 0;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s(%d):startup(%s)\n", __FILE__, __LINE__, info-&gt;device_name);</div><div class='del'>-</div><div class='del'>-	if (tty_port_initialized(&amp;info-&gt;port))</div><div class='del'>-		return 0;</div><div class='del'>-</div><div class='del'>-	if (!info-&gt;tx_buf) {</div><div class='del'>-		/* allocate a page of memory for a transmit buffer */</div><div class='del'>-		info-&gt;tx_buf = (unsigned char *)get_zeroed_page(GFP_KERNEL);</div><div class='del'>-		if (!info-&gt;tx_buf) {</div><div class='del'>-			printk(KERN_ERR"%s(%d):%s can't allocate transmit buffer\n",</div><div class='del'>-				__FILE__, __LINE__, info-&gt;device_name);</div><div class='del'>-			return -ENOMEM;</div><div class='del'>-		}</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	info-&gt;pending_bh = 0;</div><div class='del'>-</div><div class='del'>-	memset(&amp;info-&gt;icount, 0, sizeof(info-&gt;icount));</div><div class='del'>-</div><div class='del'>-	timer_setup(&amp;info-&gt;tx_timer, tx_timeout, 0);</div><div class='del'>-</div><div class='del'>-	/* Allocate and claim adapter resources */</div><div class='del'>-	retval = claim_resources(info);</div><div class='del'>-</div><div class='del'>-	/* perform existence check and diagnostics */</div><div class='del'>-	if (!retval)</div><div class='del'>-		retval = adapter_test(info);</div><div class='del'>-</div><div class='del'>-	if (retval) {</div><div class='del'>-		if (capable(CAP_SYS_ADMIN) &amp;&amp; tty)</div><div class='del'>-			set_bit(TTY_IO_ERROR, &amp;tty-&gt;flags);</div><div class='del'>-		release_resources(info);</div><div class='del'>-		return retval;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	/* program hardware for current parameters */</div><div class='del'>-	mgslpc_change_params(info, tty);</div><div class='del'>-</div><div class='del'>-	if (tty)</div><div class='del'>-		clear_bit(TTY_IO_ERROR, &amp;tty-&gt;flags);</div><div class='del'>-</div><div class='del'>-	tty_port_set_initialized(&amp;info-&gt;port, true);</div><div class='del'>-</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Called by mgslpc_close() and mgslpc_hangup() to shutdown hardware</div><div class='del'>- */</div><div class='del'>-static void shutdown(MGSLPC_INFO * info, struct tty_struct *tty)</div><div class='del'>-{</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	if (!tty_port_initialized(&amp;info-&gt;port))</div><div class='del'>-		return;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s(%d):mgslpc_shutdown(%s)\n",</div><div class='del'>-			 __FILE__, __LINE__, info-&gt;device_name);</div><div class='del'>-</div><div class='del'>-	/* clear status wait queue because status changes */</div><div class='del'>-	/* can't happen after shutting down the hardware */</div><div class='del'>-	wake_up_interruptible(&amp;info-&gt;status_event_wait_q);</div><div class='del'>-	wake_up_interruptible(&amp;info-&gt;event_wait_q);</div><div class='del'>-</div><div class='del'>-	del_timer_sync(&amp;info-&gt;tx_timer);</div><div class='del'>-</div><div class='del'>-	if (info-&gt;tx_buf) {</div><div class='del'>-		free_page((unsigned long) info-&gt;tx_buf);</div><div class='del'>-		info-&gt;tx_buf = NULL;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-</div><div class='del'>-	rx_stop(info);</div><div class='del'>-	tx_stop(info);</div><div class='del'>-</div><div class='del'>-	/* TODO:disable interrupts instead of reset to preserve signal states */</div><div class='del'>-	reset_device(info);</div><div class='del'>-</div><div class='del'>-	if (!tty || C_HUPCL(tty)) {</div><div class='del'>-		info-&gt;serial_signals &amp;= ~(SerialSignal_RTS | SerialSignal_DTR);</div><div class='del'>-		set_signals(info);</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-</div><div class='del'>-	release_resources(info);</div><div class='del'>-</div><div class='del'>-	if (tty)</div><div class='del'>-		set_bit(TTY_IO_ERROR, &amp;tty-&gt;flags);</div><div class='del'>-</div><div class='del'>-	tty_port_set_initialized(&amp;info-&gt;port, false);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void mgslpc_program_hw(MGSLPC_INFO *info, struct tty_struct *tty)</div><div class='del'>-{</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-</div><div class='del'>-	rx_stop(info);</div><div class='del'>-	tx_stop(info);</div><div class='del'>-	info-&gt;tx_count = info-&gt;tx_put = info-&gt;tx_get = 0;</div><div class='del'>-</div><div class='del'>-	if (info-&gt;params.mode == MGSL_MODE_HDLC || info-&gt;netcount)</div><div class='del'>-		hdlc_mode(info);</div><div class='del'>-	else</div><div class='del'>-		async_mode(info);</div><div class='del'>-</div><div class='del'>-	set_signals(info);</div><div class='del'>-</div><div class='del'>-	info-&gt;dcd_chkcount = 0;</div><div class='del'>-	info-&gt;cts_chkcount = 0;</div><div class='del'>-	info-&gt;ri_chkcount = 0;</div><div class='del'>-	info-&gt;dsr_chkcount = 0;</div><div class='del'>-</div><div class='del'>-	irq_enable(info, CHB, IRQ_DCD | IRQ_CTS);</div><div class='del'>-	port_irq_enable(info, (unsigned char) PVR_DSR | PVR_RI);</div><div class='del'>-	get_signals(info);</div><div class='del'>-</div><div class='del'>-	if (info-&gt;netcount || (tty &amp;&amp; C_CREAD(tty)))</div><div class='del'>-		rx_start(info);</div><div class='del'>-</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Reconfigure adapter based on new parameters</div><div class='del'>- */</div><div class='del'>-static void mgslpc_change_params(MGSLPC_INFO *info, struct tty_struct *tty)</div><div class='del'>-{</div><div class='del'>-	unsigned cflag;</div><div class='del'>-	int bits_per_char;</div><div class='del'>-</div><div class='del'>-	if (!tty)</div><div class='del'>-		return;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s(%d):mgslpc_change_params(%s)\n",</div><div class='del'>-			 __FILE__, __LINE__, info-&gt;device_name);</div><div class='del'>-</div><div class='del'>-	cflag = tty-&gt;termios.c_cflag;</div><div class='del'>-</div><div class='del'>-	/* if B0 rate (hangup) specified then negate RTS and DTR */</div><div class='del'>-	/* otherwise assert RTS and DTR */</div><div class='del'>-	if (cflag &amp; CBAUD)</div><div class='del'>-		info-&gt;serial_signals |= SerialSignal_RTS | SerialSignal_DTR;</div><div class='del'>-	else</div><div class='del'>-		info-&gt;serial_signals &amp;= ~(SerialSignal_RTS | SerialSignal_DTR);</div><div class='del'>-</div><div class='del'>-	/* byte size and parity */</div><div class='del'>-	if ((cflag &amp; CSIZE) != CS8) {</div><div class='del'>-		cflag &amp;= ~CSIZE;</div><div class='del'>-		cflag |= CS7;</div><div class='del'>-		tty-&gt;termios.c_cflag = cflag;</div><div class='del'>-	}</div><div class='del'>-	info-&gt;params.data_bits = tty_get_char_size(cflag);</div><div class='del'>-</div><div class='del'>-	if (cflag &amp; CSTOPB)</div><div class='del'>-		info-&gt;params.stop_bits = 2;</div><div class='del'>-	else</div><div class='del'>-		info-&gt;params.stop_bits = 1;</div><div class='del'>-</div><div class='del'>-	info-&gt;params.parity = ASYNC_PARITY_NONE;</div><div class='del'>-	if (cflag &amp; PARENB) {</div><div class='del'>-		if (cflag &amp; PARODD)</div><div class='del'>-			info-&gt;params.parity = ASYNC_PARITY_ODD;</div><div class='del'>-		else</div><div class='del'>-			info-&gt;params.parity = ASYNC_PARITY_EVEN;</div><div class='del'>-		if (cflag &amp; CMSPAR)</div><div class='del'>-			info-&gt;params.parity = ASYNC_PARITY_SPACE;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	/* calculate number of jiffies to transmit a full</div><div class='del'>-	 * FIFO (32 bytes) at specified data rate</div><div class='del'>-	 */</div><div class='del'>-	bits_per_char = info-&gt;params.data_bits +</div><div class='del'>-			info-&gt;params.stop_bits + 1;</div><div class='del'>-</div><div class='del'>-	/* if port data rate is set to 460800 or less then</div><div class='del'>-	 * allow tty settings to override, otherwise keep the</div><div class='del'>-	 * current data rate.</div><div class='del'>-	 */</div><div class='del'>-	if (info-&gt;params.data_rate &lt;= 460800) {</div><div class='del'>-		info-&gt;params.data_rate = tty_get_baud_rate(tty);</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (info-&gt;params.data_rate) {</div><div class='del'>-		info-&gt;timeout = (32*HZ*bits_per_char) /</div><div class='del'>-				info-&gt;params.data_rate;</div><div class='del'>-	}</div><div class='del'>-	info-&gt;timeout += HZ/50;		/* Add .02 seconds of slop */</div><div class='del'>-</div><div class='del'>-	tty_port_set_cts_flow(&amp;info-&gt;port, cflag &amp; CRTSCTS);</div><div class='del'>-	tty_port_set_check_carrier(&amp;info-&gt;port, ~cflag &amp; CLOCAL);</div><div class='del'>-</div><div class='del'>-	/* process tty input control flags */</div><div class='del'>-</div><div class='del'>-	info-&gt;read_status_mask = 0;</div><div class='del'>-	if (I_INPCK(tty))</div><div class='del'>-		info-&gt;read_status_mask |= BIT7 | BIT6;</div><div class='del'>-	if (I_IGNPAR(tty))</div><div class='del'>-		info-&gt;ignore_status_mask |= BIT7 | BIT6;</div><div class='del'>-</div><div class='del'>-	mgslpc_program_hw(info, tty);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Add a character to the transmit buffer</div><div class='del'>- */</div><div class='del'>-static int mgslpc_put_char(struct tty_struct *tty, unsigned char ch)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *info = (MGSLPC_INFO *)tty-&gt;driver_data;</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO) {</div><div class='del'>-		printk("%s(%d):mgslpc_put_char(%d) on %s\n",</div><div class='del'>-			__FILE__, __LINE__, ch, info-&gt;device_name);</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (mgslpc_paranoia_check(info, tty-&gt;name, "mgslpc_put_char"))</div><div class='del'>-		return 0;</div><div class='del'>-</div><div class='del'>-	if (!info-&gt;tx_buf)</div><div class='del'>-		return 0;</div><div class='del'>-</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-</div><div class='del'>-	if (info-&gt;params.mode == MGSL_MODE_ASYNC || !info-&gt;tx_active) {</div><div class='del'>-		if (info-&gt;tx_count &lt; TXBUFSIZE - 1) {</div><div class='del'>-			info-&gt;tx_buf[info-&gt;tx_put++] = ch;</div><div class='del'>-			info-&gt;tx_put &amp;= TXBUFSIZE-1;</div><div class='del'>-			info-&gt;tx_count++;</div><div class='del'>-		}</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-	return 1;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Enable transmitter so remaining characters in the</div><div class='del'>- * transmit buffer are sent.</div><div class='del'>- */</div><div class='del'>-static void mgslpc_flush_chars(struct tty_struct *tty)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *info = (MGSLPC_INFO *)tty-&gt;driver_data;</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s(%d):mgslpc_flush_chars() entry on %s tx_count=%d\n",</div><div class='del'>-			__FILE__, __LINE__, info-&gt;device_name, info-&gt;tx_count);</div><div class='del'>-</div><div class='del'>-	if (mgslpc_paranoia_check(info, tty-&gt;name, "mgslpc_flush_chars"))</div><div class='del'>-		return;</div><div class='del'>-</div><div class='del'>-	if (info-&gt;tx_count &lt;= 0 || tty-&gt;flow.stopped ||</div><div class='del'>-	    tty-&gt;hw_stopped || !info-&gt;tx_buf)</div><div class='del'>-		return;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s(%d):mgslpc_flush_chars() entry on %s starting transmitter\n",</div><div class='del'>-			__FILE__, __LINE__, info-&gt;device_name);</div><div class='del'>-</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-	if (!info-&gt;tx_active)</div><div class='del'>-		tx_start(info, tty);</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Send a block of data</div><div class='del'>- *</div><div class='del'>- * Arguments:</div><div class='del'>- *</div><div class='del'>- * tty        pointer to tty information structure</div><div class='del'>- * buf	      pointer to buffer containing send data</div><div class='del'>- * count      size of send data in bytes</div><div class='del'>- *</div><div class='del'>- * Returns: number of characters written</div><div class='del'>- */</div><div class='del'>-static int mgslpc_write(struct tty_struct * tty,</div><div class='del'>-			const unsigned char *buf, int count)</div><div class='del'>-{</div><div class='del'>-	int c, ret = 0;</div><div class='del'>-	MGSLPC_INFO *info = (MGSLPC_INFO *)tty-&gt;driver_data;</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s(%d):mgslpc_write(%s) count=%d\n",</div><div class='del'>-			__FILE__, __LINE__, info-&gt;device_name, count);</div><div class='del'>-</div><div class='del'>-	if (mgslpc_paranoia_check(info, tty-&gt;name, "mgslpc_write") ||</div><div class='del'>-		!info-&gt;tx_buf)</div><div class='del'>-		goto cleanup;</div><div class='del'>-</div><div class='del'>-	if (info-&gt;params.mode == MGSL_MODE_HDLC) {</div><div class='del'>-		if (count &gt; TXBUFSIZE) {</div><div class='del'>-			ret = -EIO;</div><div class='del'>-			goto cleanup;</div><div class='del'>-		}</div><div class='del'>-		if (info-&gt;tx_active)</div><div class='del'>-			goto cleanup;</div><div class='del'>-		else if (info-&gt;tx_count)</div><div class='del'>-			goto start;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	for (;;) {</div><div class='del'>-		c = min(count,</div><div class='del'>-			min(TXBUFSIZE - info-&gt;tx_count - 1,</div><div class='del'>-			    TXBUFSIZE - info-&gt;tx_put));</div><div class='del'>-		if (c &lt;= 0)</div><div class='del'>-			break;</div><div class='del'>-</div><div class='del'>-		memcpy(info-&gt;tx_buf + info-&gt;tx_put, buf, c);</div><div class='del'>-</div><div class='del'>-		spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-		info-&gt;tx_put = (info-&gt;tx_put + c) &amp; (TXBUFSIZE-1);</div><div class='del'>-		info-&gt;tx_count += c;</div><div class='del'>-		spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-</div><div class='del'>-		buf += c;</div><div class='del'>-		count -= c;</div><div class='del'>-		ret += c;</div><div class='del'>-	}</div><div class='del'>-start:</div><div class='del'>-	if (info-&gt;tx_count &amp;&amp; !tty-&gt;flow.stopped &amp;&amp; !tty-&gt;hw_stopped) {</div><div class='del'>-		spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-		if (!info-&gt;tx_active)</div><div class='del'>-			tx_start(info, tty);</div><div class='del'>-		spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-	}</div><div class='del'>-cleanup:</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s(%d):mgslpc_write(%s) returning=%d\n",</div><div class='del'>-			__FILE__, __LINE__, info-&gt;device_name, ret);</div><div class='del'>-	return ret;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Return the count of free bytes in transmit buffer</div><div class='del'>- */</div><div class='del'>-static unsigned int mgslpc_write_room(struct tty_struct *tty)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *info = (MGSLPC_INFO *)tty-&gt;driver_data;</div><div class='del'>-	int ret;</div><div class='del'>-</div><div class='del'>-	if (mgslpc_paranoia_check(info, tty-&gt;name, "mgslpc_write_room"))</div><div class='del'>-		return 0;</div><div class='del'>-</div><div class='del'>-	if (info-&gt;params.mode == MGSL_MODE_HDLC) {</div><div class='del'>-		/* HDLC (frame oriented) mode */</div><div class='del'>-		if (info-&gt;tx_active)</div><div class='del'>-			return 0;</div><div class='del'>-		else</div><div class='del'>-			return HDLC_MAX_FRAME_SIZE;</div><div class='del'>-	} else {</div><div class='del'>-		ret = TXBUFSIZE - info-&gt;tx_count - 1;</div><div class='del'>-		if (ret &lt; 0)</div><div class='del'>-			ret = 0;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s(%d):mgslpc_write_room(%s)=%d\n",</div><div class='del'>-			 __FILE__, __LINE__, info-&gt;device_name, ret);</div><div class='del'>-	return ret;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Return the count of bytes in transmit buffer</div><div class='del'>- */</div><div class='del'>-static unsigned int mgslpc_chars_in_buffer(struct tty_struct *tty)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *info = (MGSLPC_INFO *)tty-&gt;driver_data;</div><div class='del'>-	unsigned int rc;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s(%d):mgslpc_chars_in_buffer(%s)\n",</div><div class='del'>-			 __FILE__, __LINE__, info-&gt;device_name);</div><div class='del'>-</div><div class='del'>-	if (mgslpc_paranoia_check(info, tty-&gt;name, "mgslpc_chars_in_buffer"))</div><div class='del'>-		return 0;</div><div class='del'>-</div><div class='del'>-	if (info-&gt;params.mode == MGSL_MODE_HDLC)</div><div class='del'>-		rc = info-&gt;tx_active ? info-&gt;max_frame_size : 0;</div><div class='del'>-	else</div><div class='del'>-		rc = info-&gt;tx_count;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s(%d):mgslpc_chars_in_buffer(%s)=%u\n",</div><div class='del'>-			 __FILE__, __LINE__, info-&gt;device_name, rc);</div><div class='del'>-</div><div class='del'>-	return rc;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Discard all data in the send buffer</div><div class='del'>- */</div><div class='del'>-static void mgslpc_flush_buffer(struct tty_struct *tty)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *info = (MGSLPC_INFO *)tty-&gt;driver_data;</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s(%d):mgslpc_flush_buffer(%s) entry\n",</div><div class='del'>-			 __FILE__, __LINE__, info-&gt;device_name);</div><div class='del'>-</div><div class='del'>-	if (mgslpc_paranoia_check(info, tty-&gt;name, "mgslpc_flush_buffer"))</div><div class='del'>-		return;</div><div class='del'>-</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-	info-&gt;tx_count = info-&gt;tx_put = info-&gt;tx_get = 0;</div><div class='del'>-	del_timer(&amp;info-&gt;tx_timer);</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-</div><div class='del'>-	wake_up_interruptible(&amp;tty-&gt;write_wait);</div><div class='del'>-	tty_wakeup(tty);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Send a high-priority XON/XOFF character</div><div class='del'>- */</div><div class='del'>-static void mgslpc_send_xchar(struct tty_struct *tty, char ch)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *info = (MGSLPC_INFO *)tty-&gt;driver_data;</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s(%d):mgslpc_send_xchar(%s,%d)\n",</div><div class='del'>-			 __FILE__, __LINE__, info-&gt;device_name, ch);</div><div class='del'>-</div><div class='del'>-	if (mgslpc_paranoia_check(info, tty-&gt;name, "mgslpc_send_xchar"))</div><div class='del'>-		return;</div><div class='del'>-</div><div class='del'>-	info-&gt;x_char = ch;</div><div class='del'>-	if (ch) {</div><div class='del'>-		spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-		if (!info-&gt;tx_enabled)</div><div class='del'>-			tx_start(info, tty);</div><div class='del'>-		spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-	}</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Signal remote device to throttle send data (our receive data)</div><div class='del'>- */</div><div class='del'>-static void mgslpc_throttle(struct tty_struct * tty)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *info = (MGSLPC_INFO *)tty-&gt;driver_data;</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s(%d):mgslpc_throttle(%s) entry\n",</div><div class='del'>-			 __FILE__, __LINE__, info-&gt;device_name);</div><div class='del'>-</div><div class='del'>-	if (mgslpc_paranoia_check(info, tty-&gt;name, "mgslpc_throttle"))</div><div class='del'>-		return;</div><div class='del'>-</div><div class='del'>-	if (I_IXOFF(tty))</div><div class='del'>-		mgslpc_send_xchar(tty, STOP_CHAR(tty));</div><div class='del'>-</div><div class='del'>-	if (C_CRTSCTS(tty)) {</div><div class='del'>-		spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-		info-&gt;serial_signals &amp;= ~SerialSignal_RTS;</div><div class='del'>-		set_signals(info);</div><div class='del'>-		spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-	}</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Signal remote device to stop throttling send data (our receive data)</div><div class='del'>- */</div><div class='del'>-static void mgslpc_unthrottle(struct tty_struct * tty)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *info = (MGSLPC_INFO *)tty-&gt;driver_data;</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s(%d):mgslpc_unthrottle(%s) entry\n",</div><div class='del'>-			 __FILE__, __LINE__, info-&gt;device_name);</div><div class='del'>-</div><div class='del'>-	if (mgslpc_paranoia_check(info, tty-&gt;name, "mgslpc_unthrottle"))</div><div class='del'>-		return;</div><div class='del'>-</div><div class='del'>-	if (I_IXOFF(tty)) {</div><div class='del'>-		if (info-&gt;x_char)</div><div class='del'>-			info-&gt;x_char = 0;</div><div class='del'>-		else</div><div class='del'>-			mgslpc_send_xchar(tty, START_CHAR(tty));</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (C_CRTSCTS(tty)) {</div><div class='del'>-		spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-		info-&gt;serial_signals |= SerialSignal_RTS;</div><div class='del'>-		set_signals(info);</div><div class='del'>-		spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-	}</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* get the current serial statistics</div><div class='del'>- */</div><div class='del'>-static int get_stats(MGSLPC_INFO * info, struct mgsl_icount __user *user_icount)</div><div class='del'>-{</div><div class='del'>-	int err;</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("get_params(%s)\n", info-&gt;device_name);</div><div class='del'>-	if (!user_icount) {</div><div class='del'>-		memset(&amp;info-&gt;icount, 0, sizeof(info-&gt;icount));</div><div class='del'>-	} else {</div><div class='del'>-		COPY_TO_USER(err, user_icount, &amp;info-&gt;icount, sizeof(struct mgsl_icount));</div><div class='del'>-		if (err)</div><div class='del'>-			return -EFAULT;</div><div class='del'>-	}</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* get the current serial parameters</div><div class='del'>- */</div><div class='del'>-static int get_params(MGSLPC_INFO * info, MGSL_PARAMS __user *user_params)</div><div class='del'>-{</div><div class='del'>-	int err;</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("get_params(%s)\n", info-&gt;device_name);</div><div class='del'>-	COPY_TO_USER(err,user_params, &amp;info-&gt;params, sizeof(MGSL_PARAMS));</div><div class='del'>-	if (err)</div><div class='del'>-		return -EFAULT;</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* set the serial parameters</div><div class='del'>- *</div><div class='del'>- * Arguments:</div><div class='del'>- *</div><div class='del'>- *	info		pointer to device instance data</div><div class='del'>- *	new_params	user buffer containing new serial params</div><div class='del'>- *</div><div class='del'>- * Returns:	0 if success, otherwise error code</div><div class='del'>- */</div><div class='del'>-static int set_params(MGSLPC_INFO * info, MGSL_PARAMS __user *new_params, struct tty_struct *tty)</div><div class='del'>-{</div><div class='del'>-	unsigned long flags;</div><div class='del'>-	MGSL_PARAMS tmp_params;</div><div class='del'>-	int err;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s(%d):set_params %s\n", __FILE__,__LINE__,</div><div class='del'>-			info-&gt;device_name);</div><div class='del'>-	COPY_FROM_USER(err,&amp;tmp_params, new_params, sizeof(MGSL_PARAMS));</div><div class='del'>-	if (err) {</div><div class='del'>-		if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-			printk("%s(%d):set_params(%s) user buffer copy failed\n",</div><div class='del'>-				__FILE__, __LINE__, info-&gt;device_name);</div><div class='del'>-		return -EFAULT;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-	memcpy(&amp;info-&gt;params,&amp;tmp_params,sizeof(MGSL_PARAMS));</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-</div><div class='del'>-	mgslpc_change_params(info, tty);</div><div class='del'>-</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int get_txidle(MGSLPC_INFO * info, int __user *idle_mode)</div><div class='del'>-{</div><div class='del'>-	int err;</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("get_txidle(%s)=%d\n", info-&gt;device_name, info-&gt;idle_mode);</div><div class='del'>-	COPY_TO_USER(err,idle_mode, &amp;info-&gt;idle_mode, sizeof(int));</div><div class='del'>-	if (err)</div><div class='del'>-		return -EFAULT;</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int set_txidle(MGSLPC_INFO * info, int idle_mode)</div><div class='del'>-{</div><div class='del'>-	unsigned long flags;</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("set_txidle(%s,%d)\n", info-&gt;device_name, idle_mode);</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-	info-&gt;idle_mode = idle_mode;</div><div class='del'>-	tx_set_idle(info);</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int get_interface(MGSLPC_INFO * info, int __user *if_mode)</div><div class='del'>-{</div><div class='del'>-	int err;</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("get_interface(%s)=%d\n", info-&gt;device_name, info-&gt;if_mode);</div><div class='del'>-	COPY_TO_USER(err,if_mode, &amp;info-&gt;if_mode, sizeof(int));</div><div class='del'>-	if (err)</div><div class='del'>-		return -EFAULT;</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int set_interface(MGSLPC_INFO * info, int if_mode)</div><div class='del'>-{</div><div class='del'>-	unsigned long flags;</div><div class='del'>-	unsigned char val;</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("set_interface(%s,%d)\n", info-&gt;device_name, if_mode);</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-	info-&gt;if_mode = if_mode;</div><div class='del'>-</div><div class='del'>-	val = read_reg(info, PVR) &amp; 0x0f;</div><div class='del'>-	switch (info-&gt;if_mode)</div><div class='del'>-	{</div><div class='del'>-	case MGSL_INTERFACE_RS232: val |= PVR_RS232; break;</div><div class='del'>-	case MGSL_INTERFACE_V35:   val |= PVR_V35;   break;</div><div class='del'>-	case MGSL_INTERFACE_RS422: val |= PVR_RS422; break;</div><div class='del'>-	}</div><div class='del'>-	write_reg(info, PVR, val);</div><div class='del'>-</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int set_txenable(MGSLPC_INFO * info, int enable, struct tty_struct *tty)</div><div class='del'>-{</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("set_txenable(%s,%d)\n", info-&gt;device_name, enable);</div><div class='del'>-</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-	if (enable) {</div><div class='del'>-		if (!info-&gt;tx_enabled)</div><div class='del'>-			tx_start(info, tty);</div><div class='del'>-	} else {</div><div class='del'>-		if (info-&gt;tx_enabled)</div><div class='del'>-			tx_stop(info);</div><div class='del'>-	}</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int tx_abort(MGSLPC_INFO * info)</div><div class='del'>-{</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("tx_abort(%s)\n", info-&gt;device_name);</div><div class='del'>-</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-	if (info-&gt;tx_active &amp;&amp; info-&gt;tx_count &amp;&amp;</div><div class='del'>-	    info-&gt;params.mode == MGSL_MODE_HDLC) {</div><div class='del'>-		/* clear data count so FIFO is not filled on next IRQ.</div><div class='del'>-		 * This results in underrun and abort transmission.</div><div class='del'>-		 */</div><div class='del'>-		info-&gt;tx_count = info-&gt;tx_put = info-&gt;tx_get = 0;</div><div class='del'>-		info-&gt;tx_aborting = true;</div><div class='del'>-	}</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int set_rxenable(MGSLPC_INFO * info, int enable)</div><div class='del'>-{</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("set_rxenable(%s,%d)\n", info-&gt;device_name, enable);</div><div class='del'>-</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-	if (enable) {</div><div class='del'>-		if (!info-&gt;rx_enabled)</div><div class='del'>-			rx_start(info);</div><div class='del'>-	} else {</div><div class='del'>-		if (info-&gt;rx_enabled)</div><div class='del'>-			rx_stop(info);</div><div class='del'>-	}</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* wait for specified event to occur</div><div class='del'>- *</div><div class='del'>- * Arguments:		info	pointer to device instance data</div><div class='del'>- *			mask	pointer to bitmask of events to wait for</div><div class='del'>- * Return Value:	0	if successful and bit mask updated with</div><div class='del'>- *				of events triggerred,</div><div class='del'>- *			otherwise error code</div><div class='del'>- */</div><div class='del'>-static int wait_events(MGSLPC_INFO * info, int __user *mask_ptr)</div><div class='del'>-{</div><div class='del'>-	unsigned long flags;</div><div class='del'>-	int s;</div><div class='del'>-	int rc=0;</div><div class='del'>-	struct mgsl_icount cprev, cnow;</div><div class='del'>-	int events;</div><div class='del'>-	int mask;</div><div class='del'>-	struct	_input_signal_events oldsigs, newsigs;</div><div class='del'>-	DECLARE_WAITQUEUE(wait, current);</div><div class='del'>-</div><div class='del'>-	COPY_FROM_USER(rc,&amp;mask, mask_ptr, sizeof(int));</div><div class='del'>-	if (rc)</div><div class='del'>-		return  -EFAULT;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("wait_events(%s,%d)\n", info-&gt;device_name, mask);</div><div class='del'>-</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-</div><div class='del'>-	/* return immediately if state matches requested events */</div><div class='del'>-	get_signals(info);</div><div class='del'>-	s = info-&gt;serial_signals;</div><div class='del'>-	events = mask &amp;</div><div class='del'>-		( ((s &amp; SerialSignal_DSR) ? MgslEvent_DsrActive:MgslEvent_DsrInactive) +</div><div class='del'>-		  ((s &amp; SerialSignal_DCD) ? MgslEvent_DcdActive:MgslEvent_DcdInactive) +</div><div class='del'>-		  ((s &amp; SerialSignal_CTS) ? MgslEvent_CtsActive:MgslEvent_CtsInactive) +</div><div class='del'>-		  ((s &amp; SerialSignal_RI)  ? MgslEvent_RiActive :MgslEvent_RiInactive) );</div><div class='del'>-	if (events) {</div><div class='del'>-		spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-		goto exit;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	/* save current irq counts */</div><div class='del'>-	cprev = info-&gt;icount;</div><div class='del'>-	oldsigs = info-&gt;input_signal_events;</div><div class='del'>-</div><div class='del'>-	if ((info-&gt;params.mode == MGSL_MODE_HDLC) &amp;&amp;</div><div class='del'>-	    (mask &amp; MgslEvent_ExitHuntMode))</div><div class='del'>-		irq_enable(info, CHA, IRQ_EXITHUNT);</div><div class='del'>-</div><div class='del'>-	set_current_state(TASK_INTERRUPTIBLE);</div><div class='del'>-	add_wait_queue(&amp;info-&gt;event_wait_q, &amp;wait);</div><div class='del'>-</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-</div><div class='del'>-</div><div class='del'>-	for(;;) {</div><div class='del'>-		schedule();</div><div class='del'>-		if (signal_pending(current)) {</div><div class='del'>-			rc = -ERESTARTSYS;</div><div class='del'>-			break;</div><div class='del'>-		}</div><div class='del'>-</div><div class='del'>-		/* get current irq counts */</div><div class='del'>-		spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-		cnow = info-&gt;icount;</div><div class='del'>-		newsigs = info-&gt;input_signal_events;</div><div class='del'>-		set_current_state(TASK_INTERRUPTIBLE);</div><div class='del'>-		spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-</div><div class='del'>-		/* if no change, wait aborted for some reason */</div><div class='del'>-		if (newsigs.dsr_up   == oldsigs.dsr_up   &amp;&amp;</div><div class='del'>-		    newsigs.dsr_down == oldsigs.dsr_down &amp;&amp;</div><div class='del'>-		    newsigs.dcd_up   == oldsigs.dcd_up   &amp;&amp;</div><div class='del'>-		    newsigs.dcd_down == oldsigs.dcd_down &amp;&amp;</div><div class='del'>-		    newsigs.cts_up   == oldsigs.cts_up   &amp;&amp;</div><div class='del'>-		    newsigs.cts_down == oldsigs.cts_down &amp;&amp;</div><div class='del'>-		    newsigs.ri_up    == oldsigs.ri_up    &amp;&amp;</div><div class='del'>-		    newsigs.ri_down  == oldsigs.ri_down  &amp;&amp;</div><div class='del'>-		    cnow.exithunt    == cprev.exithunt   &amp;&amp;</div><div class='del'>-		    cnow.rxidle      == cprev.rxidle) {</div><div class='del'>-			rc = -EIO;</div><div class='del'>-			break;</div><div class='del'>-		}</div><div class='del'>-</div><div class='del'>-		events = mask &amp;</div><div class='del'>-			( (newsigs.dsr_up   != oldsigs.dsr_up   ? MgslEvent_DsrActive:0)   +</div><div class='del'>-			  (newsigs.dsr_down != oldsigs.dsr_down ? MgslEvent_DsrInactive:0) +</div><div class='del'>-			  (newsigs.dcd_up   != oldsigs.dcd_up   ? MgslEvent_DcdActive:0)   +</div><div class='del'>-			  (newsigs.dcd_down != oldsigs.dcd_down ? MgslEvent_DcdInactive:0) +</div><div class='del'>-			  (newsigs.cts_up   != oldsigs.cts_up   ? MgslEvent_CtsActive:0)   +</div><div class='del'>-			  (newsigs.cts_down != oldsigs.cts_down ? MgslEvent_CtsInactive:0) +</div><div class='del'>-			  (newsigs.ri_up    != oldsigs.ri_up    ? MgslEvent_RiActive:0)    +</div><div class='del'>-			  (newsigs.ri_down  != oldsigs.ri_down  ? MgslEvent_RiInactive:0)  +</div><div class='del'>-			  (cnow.exithunt    != cprev.exithunt   ? MgslEvent_ExitHuntMode:0) +</div><div class='del'>-			  (cnow.rxidle      != cprev.rxidle     ? MgslEvent_IdleReceived:0) );</div><div class='del'>-		if (events)</div><div class='del'>-			break;</div><div class='del'>-</div><div class='del'>-		cprev = cnow;</div><div class='del'>-		oldsigs = newsigs;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	remove_wait_queue(&amp;info-&gt;event_wait_q, &amp;wait);</div><div class='del'>-	set_current_state(TASK_RUNNING);</div><div class='del'>-</div><div class='del'>-	if (mask &amp; MgslEvent_ExitHuntMode) {</div><div class='del'>-		spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-		if (!waitqueue_active(&amp;info-&gt;event_wait_q))</div><div class='del'>-			irq_disable(info, CHA, IRQ_EXITHUNT);</div><div class='del'>-		spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-	}</div><div class='del'>-exit:</div><div class='del'>-	if (rc == 0)</div><div class='del'>-		PUT_USER(rc, events, mask_ptr);</div><div class='del'>-	return rc;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int modem_input_wait(MGSLPC_INFO *info,int arg)</div><div class='del'>-{</div><div class='del'>-	unsigned long flags;</div><div class='del'>-	int rc;</div><div class='del'>-	struct mgsl_icount cprev, cnow;</div><div class='del'>-	DECLARE_WAITQUEUE(wait, current);</div><div class='del'>-</div><div class='del'>-	/* save current irq counts */</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-	cprev = info-&gt;icount;</div><div class='del'>-	add_wait_queue(&amp;info-&gt;status_event_wait_q, &amp;wait);</div><div class='del'>-	set_current_state(TASK_INTERRUPTIBLE);</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-</div><div class='del'>-	for(;;) {</div><div class='del'>-		schedule();</div><div class='del'>-		if (signal_pending(current)) {</div><div class='del'>-			rc = -ERESTARTSYS;</div><div class='del'>-			break;</div><div class='del'>-		}</div><div class='del'>-</div><div class='del'>-		/* get new irq counts */</div><div class='del'>-		spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-		cnow = info-&gt;icount;</div><div class='del'>-		set_current_state(TASK_INTERRUPTIBLE);</div><div class='del'>-		spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-</div><div class='del'>-		/* if no change, wait aborted for some reason */</div><div class='del'>-		if (cnow.rng == cprev.rng &amp;&amp; cnow.dsr == cprev.dsr &amp;&amp;</div><div class='del'>-		    cnow.dcd == cprev.dcd &amp;&amp; cnow.cts == cprev.cts) {</div><div class='del'>-			rc = -EIO;</div><div class='del'>-			break;</div><div class='del'>-		}</div><div class='del'>-</div><div class='del'>-		/* check for change in caller specified modem input */</div><div class='del'>-		if ((arg &amp; TIOCM_RNG &amp;&amp; cnow.rng != cprev.rng) ||</div><div class='del'>-		    (arg &amp; TIOCM_DSR &amp;&amp; cnow.dsr != cprev.dsr) ||</div><div class='del'>-		    (arg &amp; TIOCM_CD  &amp;&amp; cnow.dcd != cprev.dcd) ||</div><div class='del'>-		    (arg &amp; TIOCM_CTS &amp;&amp; cnow.cts != cprev.cts)) {</div><div class='del'>-			rc = 0;</div><div class='del'>-			break;</div><div class='del'>-		}</div><div class='del'>-</div><div class='del'>-		cprev = cnow;</div><div class='del'>-	}</div><div class='del'>-	remove_wait_queue(&amp;info-&gt;status_event_wait_q, &amp;wait);</div><div class='del'>-	set_current_state(TASK_RUNNING);</div><div class='del'>-	return rc;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* return the state of the serial control and status signals</div><div class='del'>- */</div><div class='del'>-static int tiocmget(struct tty_struct *tty)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *info = (MGSLPC_INFO *)tty-&gt;driver_data;</div><div class='del'>-	unsigned int result;</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-	get_signals(info);</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-</div><div class='del'>-	result = ((info-&gt;serial_signals &amp; SerialSignal_RTS) ? TIOCM_RTS:0) +</div><div class='del'>-		((info-&gt;serial_signals &amp; SerialSignal_DTR) ? TIOCM_DTR:0) +</div><div class='del'>-		((info-&gt;serial_signals &amp; SerialSignal_DCD) ? TIOCM_CAR:0) +</div><div class='del'>-		((info-&gt;serial_signals &amp; SerialSignal_RI)  ? TIOCM_RNG:0) +</div><div class='del'>-		((info-&gt;serial_signals &amp; SerialSignal_DSR) ? TIOCM_DSR:0) +</div><div class='del'>-		((info-&gt;serial_signals &amp; SerialSignal_CTS) ? TIOCM_CTS:0);</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s(%d):%s tiocmget() value=%08X\n",</div><div class='del'>-			 __FILE__, __LINE__, info-&gt;device_name, result);</div><div class='del'>-	return result;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* set modem control signals (DTR/RTS)</div><div class='del'>- */</div><div class='del'>-static int tiocmset(struct tty_struct *tty,</div><div class='del'>-		    unsigned int set, unsigned int clear)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *info = (MGSLPC_INFO *)tty-&gt;driver_data;</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s(%d):%s tiocmset(%x,%x)\n",</div><div class='del'>-			__FILE__, __LINE__, info-&gt;device_name, set, clear);</div><div class='del'>-</div><div class='del'>-	if (set &amp; TIOCM_RTS)</div><div class='del'>-		info-&gt;serial_signals |= SerialSignal_RTS;</div><div class='del'>-	if (set &amp; TIOCM_DTR)</div><div class='del'>-		info-&gt;serial_signals |= SerialSignal_DTR;</div><div class='del'>-	if (clear &amp; TIOCM_RTS)</div><div class='del'>-		info-&gt;serial_signals &amp;= ~SerialSignal_RTS;</div><div class='del'>-	if (clear &amp; TIOCM_DTR)</div><div class='del'>-		info-&gt;serial_signals &amp;= ~SerialSignal_DTR;</div><div class='del'>-</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-	set_signals(info);</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Set or clear transmit break condition</div><div class='del'>- *</div><div class='del'>- * Arguments:		tty		pointer to tty instance data</div><div class='del'>- *			break_state	-1=set break condition, 0=clear</div><div class='del'>- */</div><div class='del'>-static int mgslpc_break(struct tty_struct *tty, int break_state)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO * info = (MGSLPC_INFO *)tty-&gt;driver_data;</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s(%d):mgslpc_break(%s,%d)\n",</div><div class='del'>-			 __FILE__, __LINE__, info-&gt;device_name, break_state);</div><div class='del'>-</div><div class='del'>-	if (mgslpc_paranoia_check(info, tty-&gt;name, "mgslpc_break"))</div><div class='del'>-		return -EINVAL;</div><div class='del'>-</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-	if (break_state == -1)</div><div class='del'>-		set_reg_bits(info, CHA+DAFO, BIT6);</div><div class='del'>-	else</div><div class='del'>-		clear_reg_bits(info, CHA+DAFO, BIT6);</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int mgslpc_get_icount(struct tty_struct *tty,</div><div class='del'>-				struct serial_icounter_struct *icount)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO * info = (MGSLPC_INFO *)tty-&gt;driver_data;</div><div class='del'>-	struct mgsl_icount cnow;	/* kernel counter temps */</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-	cnow = info-&gt;icount;</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-</div><div class='del'>-	icount-&gt;cts = cnow.cts;</div><div class='del'>-	icount-&gt;dsr = cnow.dsr;</div><div class='del'>-	icount-&gt;rng = cnow.rng;</div><div class='del'>-	icount-&gt;dcd = cnow.dcd;</div><div class='del'>-	icount-&gt;rx = cnow.rx;</div><div class='del'>-	icount-&gt;tx = cnow.tx;</div><div class='del'>-	icount-&gt;frame = cnow.frame;</div><div class='del'>-	icount-&gt;overrun = cnow.overrun;</div><div class='del'>-	icount-&gt;parity = cnow.parity;</div><div class='del'>-	icount-&gt;brk = cnow.brk;</div><div class='del'>-	icount-&gt;buf_overrun = cnow.buf_overrun;</div><div class='del'>-</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Service an IOCTL request</div><div class='del'>- *</div><div class='del'>- * Arguments:</div><div class='del'>- *</div><div class='del'>- *	tty	pointer to tty instance data</div><div class='del'>- *	cmd	IOCTL command code</div><div class='del'>- *	arg	command argument/context</div><div class='del'>- *</div><div class='del'>- * Return Value:	0 if success, otherwise error code</div><div class='del'>- */</div><div class='del'>-static int mgslpc_ioctl(struct tty_struct *tty,</div><div class='del'>-			unsigned int cmd, unsigned long arg)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO * info = (MGSLPC_INFO *)tty-&gt;driver_data;</div><div class='del'>-	void __user *argp = (void __user *)arg;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s(%d):mgslpc_ioctl %s cmd=%08X\n", __FILE__, __LINE__,</div><div class='del'>-			info-&gt;device_name, cmd);</div><div class='del'>-</div><div class='del'>-	if (mgslpc_paranoia_check(info, tty-&gt;name, "mgslpc_ioctl"))</div><div class='del'>-		return -ENODEV;</div><div class='del'>-</div><div class='del'>-	if (cmd != TIOCMIWAIT) {</div><div class='del'>-		if (tty_io_error(tty))</div><div class='del'>-		    return -EIO;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	switch (cmd) {</div><div class='del'>-	case MGSL_IOCGPARAMS:</div><div class='del'>-		return get_params(info, argp);</div><div class='del'>-	case MGSL_IOCSPARAMS:</div><div class='del'>-		return set_params(info, argp, tty);</div><div class='del'>-	case MGSL_IOCGTXIDLE:</div><div class='del'>-		return get_txidle(info, argp);</div><div class='del'>-	case MGSL_IOCSTXIDLE:</div><div class='del'>-		return set_txidle(info, (int)arg);</div><div class='del'>-	case MGSL_IOCGIF:</div><div class='del'>-		return get_interface(info, argp);</div><div class='del'>-	case MGSL_IOCSIF:</div><div class='del'>-		return set_interface(info,(int)arg);</div><div class='del'>-	case MGSL_IOCTXENABLE:</div><div class='del'>-		return set_txenable(info,(int)arg, tty);</div><div class='del'>-	case MGSL_IOCRXENABLE:</div><div class='del'>-		return set_rxenable(info,(int)arg);</div><div class='del'>-	case MGSL_IOCTXABORT:</div><div class='del'>-		return tx_abort(info);</div><div class='del'>-	case MGSL_IOCGSTATS:</div><div class='del'>-		return get_stats(info, argp);</div><div class='del'>-	case MGSL_IOCWAITEVENT:</div><div class='del'>-		return wait_events(info, argp);</div><div class='del'>-	case TIOCMIWAIT:</div><div class='del'>-		return modem_input_wait(info,(int)arg);</div><div class='del'>-	default:</div><div class='del'>-		return -ENOIOCTLCMD;</div><div class='del'>-	}</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Set new termios settings</div><div class='del'>- *</div><div class='del'>- * Arguments:</div><div class='del'>- *</div><div class='del'>- *	tty		pointer to tty structure</div><div class='del'>- *	termios		pointer to buffer to hold returned old termios</div><div class='del'>- */</div><div class='del'>-static void mgslpc_set_termios(struct tty_struct *tty,</div><div class='del'>-			       const struct ktermios *old_termios)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *info = (MGSLPC_INFO *)tty-&gt;driver_data;</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s(%d):mgslpc_set_termios %s\n", __FILE__, __LINE__,</div><div class='del'>-			tty-&gt;driver-&gt;name);</div><div class='del'>-</div><div class='del'>-	/* just return if nothing has changed */</div><div class='del'>-	if ((tty-&gt;termios.c_cflag == old_termios-&gt;c_cflag)</div><div class='del'>-	    &amp;&amp; (RELEVANT_IFLAG(tty-&gt;termios.c_iflag)</div><div class='del'>-		== RELEVANT_IFLAG(old_termios-&gt;c_iflag)))</div><div class='del'>-	  return;</div><div class='del'>-</div><div class='del'>-	mgslpc_change_params(info, tty);</div><div class='del'>-</div><div class='del'>-	/* Handle transition to B0 status */</div><div class='del'>-	if ((old_termios-&gt;c_cflag &amp; CBAUD) &amp;&amp; !C_BAUD(tty)) {</div><div class='del'>-		info-&gt;serial_signals &amp;= ~(SerialSignal_RTS | SerialSignal_DTR);</div><div class='del'>-		spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-		set_signals(info);</div><div class='del'>-		spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	/* Handle transition away from B0 status */</div><div class='del'>-	if (!(old_termios-&gt;c_cflag &amp; CBAUD) &amp;&amp; C_BAUD(tty)) {</div><div class='del'>-		info-&gt;serial_signals |= SerialSignal_DTR;</div><div class='del'>-		if (!C_CRTSCTS(tty) || !tty_throttled(tty))</div><div class='del'>-			info-&gt;serial_signals |= SerialSignal_RTS;</div><div class='del'>-		spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-		set_signals(info);</div><div class='del'>-		spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	/* Handle turning off CRTSCTS */</div><div class='del'>-	if (old_termios-&gt;c_cflag &amp; CRTSCTS &amp;&amp; !C_CRTSCTS(tty)) {</div><div class='del'>-		tty-&gt;hw_stopped = 0;</div><div class='del'>-		tx_release(tty);</div><div class='del'>-	}</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void mgslpc_close(struct tty_struct *tty, struct file * filp)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO * info = (MGSLPC_INFO *)tty-&gt;driver_data;</div><div class='del'>-	struct tty_port *port = &amp;info-&gt;port;</div><div class='del'>-</div><div class='del'>-	if (mgslpc_paranoia_check(info, tty-&gt;name, "mgslpc_close"))</div><div class='del'>-		return;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s(%d):mgslpc_close(%s) entry, count=%d\n",</div><div class='del'>-			 __FILE__, __LINE__, info-&gt;device_name, port-&gt;count);</div><div class='del'>-</div><div class='del'>-	if (tty_port_close_start(port, tty, filp) == 0)</div><div class='del'>-		goto cleanup;</div><div class='del'>-</div><div class='del'>-	if (tty_port_initialized(port))</div><div class='del'>-		mgslpc_wait_until_sent(tty, info-&gt;timeout);</div><div class='del'>-</div><div class='del'>-	mgslpc_flush_buffer(tty);</div><div class='del'>-</div><div class='del'>-	tty_ldisc_flush(tty);</div><div class='del'>-	shutdown(info, tty);</div><div class='del'>-	</div><div class='del'>-	tty_port_close_end(port, tty);</div><div class='del'>-	tty_port_tty_set(port, NULL);</div><div class='del'>-cleanup:</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s(%d):mgslpc_close(%s) exit, count=%d\n", __FILE__, __LINE__,</div><div class='del'>-			tty-&gt;driver-&gt;name, port-&gt;count);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Wait until the transmitter is empty.</div><div class='del'>- */</div><div class='del'>-static void mgslpc_wait_until_sent(struct tty_struct *tty, int timeout)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO * info = (MGSLPC_INFO *)tty-&gt;driver_data;</div><div class='del'>-	unsigned long orig_jiffies, char_time;</div><div class='del'>-</div><div class='del'>-	if (!info)</div><div class='del'>-		return;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s(%d):mgslpc_wait_until_sent(%s) entry\n",</div><div class='del'>-			 __FILE__, __LINE__, info-&gt;device_name);</div><div class='del'>-</div><div class='del'>-	if (mgslpc_paranoia_check(info, tty-&gt;name, "mgslpc_wait_until_sent"))</div><div class='del'>-		return;</div><div class='del'>-</div><div class='del'>-	if (!tty_port_initialized(&amp;info-&gt;port))</div><div class='del'>-		goto exit;</div><div class='del'>-</div><div class='del'>-	orig_jiffies = jiffies;</div><div class='del'>-</div><div class='del'>-	/* Set check interval to 1/5 of estimated time to</div><div class='del'>-	 * send a character, and make it at least 1. The check</div><div class='del'>-	 * interval should also be less than the timeout.</div><div class='del'>-	 * Note: use tight timings here to satisfy the NIST-PCTS.</div><div class='del'>-	 */</div><div class='del'>-</div><div class='del'>-	if (info-&gt;params.data_rate) {</div><div class='del'>-	     	char_time = info-&gt;timeout/(32 * 5);</div><div class='del'>-		if (!char_time)</div><div class='del'>-			char_time++;</div><div class='del'>-	} else</div><div class='del'>-		char_time = 1;</div><div class='del'>-</div><div class='del'>-	if (timeout)</div><div class='del'>-		char_time = min_t(unsigned long, char_time, timeout);</div><div class='del'>-</div><div class='del'>-	if (info-&gt;params.mode == MGSL_MODE_HDLC) {</div><div class='del'>-		while (info-&gt;tx_active) {</div><div class='del'>-			msleep_interruptible(jiffies_to_msecs(char_time));</div><div class='del'>-			if (signal_pending(current))</div><div class='del'>-				break;</div><div class='del'>-			if (timeout &amp;&amp; time_after(jiffies, orig_jiffies + timeout))</div><div class='del'>-				break;</div><div class='del'>-		}</div><div class='del'>-	} else {</div><div class='del'>-		while ((info-&gt;tx_count || info-&gt;tx_active) &amp;&amp;</div><div class='del'>-			info-&gt;tx_enabled) {</div><div class='del'>-			msleep_interruptible(jiffies_to_msecs(char_time));</div><div class='del'>-			if (signal_pending(current))</div><div class='del'>-				break;</div><div class='del'>-			if (timeout &amp;&amp; time_after(jiffies, orig_jiffies + timeout))</div><div class='del'>-				break;</div><div class='del'>-		}</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-exit:</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s(%d):mgslpc_wait_until_sent(%s) exit\n",</div><div class='del'>-			 __FILE__, __LINE__, info-&gt;device_name);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Called by tty_hangup() when a hangup is signaled.</div><div class='del'>- * This is the same as closing all open files for the port.</div><div class='del'>- */</div><div class='del'>-static void mgslpc_hangup(struct tty_struct *tty)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO * info = (MGSLPC_INFO *)tty-&gt;driver_data;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s(%d):mgslpc_hangup(%s)\n",</div><div class='del'>-			 __FILE__, __LINE__, info-&gt;device_name);</div><div class='del'>-</div><div class='del'>-	if (mgslpc_paranoia_check(info, tty-&gt;name, "mgslpc_hangup"))</div><div class='del'>-		return;</div><div class='del'>-</div><div class='del'>-	mgslpc_flush_buffer(tty);</div><div class='del'>-	shutdown(info, tty);</div><div class='del'>-	tty_port_hangup(&amp;info-&gt;port);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static bool carrier_raised(struct tty_port *port)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *info = container_of(port, MGSLPC_INFO, port);</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-	get_signals(info);</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-</div><div class='del'>-	return info-&gt;serial_signals &amp; SerialSignal_DCD;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void dtr_rts(struct tty_port *port, bool active)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *info = container_of(port, MGSLPC_INFO, port);</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-	if (active)</div><div class='del'>-		info-&gt;serial_signals |= SerialSignal_RTS | SerialSignal_DTR;</div><div class='del'>-	else</div><div class='del'>-		info-&gt;serial_signals &amp;= ~(SerialSignal_RTS | SerialSignal_DTR);</div><div class='del'>-	set_signals(info);</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-</div><div class='del'>-static int mgslpc_open(struct tty_struct *tty, struct file * filp)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO	*info;</div><div class='del'>-	struct tty_port *port;</div><div class='del'>-	int		retval, line;</div><div class='del'>-	unsigned long	flags;</div><div class='del'>-</div><div class='del'>-	/* verify range of specified line number */</div><div class='del'>-	line = tty-&gt;index;</div><div class='del'>-	if (line &gt;= mgslpc_device_count) {</div><div class='del'>-		printk("%s(%d):mgslpc_open with invalid line #%d.\n",</div><div class='del'>-			__FILE__, __LINE__, line);</div><div class='del'>-		return -ENODEV;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	/* find the info structure for the specified line */</div><div class='del'>-	info = mgslpc_device_list;</div><div class='del'>-	while(info &amp;&amp; info-&gt;line != line)</div><div class='del'>-		info = info-&gt;next_device;</div><div class='del'>-	if (mgslpc_paranoia_check(info, tty-&gt;name, "mgslpc_open"))</div><div class='del'>-		return -ENODEV;</div><div class='del'>-</div><div class='del'>-	port = &amp;info-&gt;port;</div><div class='del'>-	tty-&gt;driver_data = info;</div><div class='del'>-	tty_port_tty_set(port, tty);</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s(%d):mgslpc_open(%s), old ref count = %d\n",</div><div class='del'>-			 __FILE__, __LINE__, tty-&gt;driver-&gt;name, port-&gt;count);</div><div class='del'>-</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;netlock, flags);</div><div class='del'>-	if (info-&gt;netcount) {</div><div class='del'>-		retval = -EBUSY;</div><div class='del'>-		spin_unlock_irqrestore(&amp;info-&gt;netlock, flags);</div><div class='del'>-		goto cleanup;</div><div class='del'>-	}</div><div class='del'>-	spin_lock(&amp;port-&gt;lock);</div><div class='del'>-	port-&gt;count++;</div><div class='del'>-	spin_unlock(&amp;port-&gt;lock);</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;netlock, flags);</div><div class='del'>-</div><div class='del'>-	if (port-&gt;count == 1) {</div><div class='del'>-		/* 1st open on this device, init hardware */</div><div class='del'>-		retval = startup(info, tty);</div><div class='del'>-		if (retval &lt; 0)</div><div class='del'>-			goto cleanup;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	retval = tty_port_block_til_ready(&amp;info-&gt;port, tty, filp);</div><div class='del'>-	if (retval) {</div><div class='del'>-		if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-			printk("%s(%d):block_til_ready(%s) returned %d\n",</div><div class='del'>-				 __FILE__, __LINE__, info-&gt;device_name, retval);</div><div class='del'>-		goto cleanup;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s(%d):mgslpc_open(%s) success\n",</div><div class='del'>-			 __FILE__, __LINE__, info-&gt;device_name);</div><div class='del'>-	retval = 0;</div><div class='del'>-</div><div class='del'>-cleanup:</div><div class='del'>-	return retval;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/*</div><div class='del'>- * /proc fs routines....</div><div class='del'>- */</div><div class='del'>-</div><div class='del'>-static inline void line_info(struct seq_file *m, MGSLPC_INFO *info)</div><div class='del'>-{</div><div class='del'>-	char	stat_buf[30];</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	seq_printf(m, "%s:io:%04X irq:%d",</div><div class='del'>-		      info-&gt;device_name, info-&gt;io_base, info-&gt;irq_level);</div><div class='del'>-</div><div class='del'>-	/* output current serial signal states */</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-	get_signals(info);</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-</div><div class='del'>-	stat_buf[0] = 0;</div><div class='del'>-	stat_buf[1] = 0;</div><div class='del'>-	if (info-&gt;serial_signals &amp; SerialSignal_RTS)</div><div class='del'>-		strcat(stat_buf, "|RTS");</div><div class='del'>-	if (info-&gt;serial_signals &amp; SerialSignal_CTS)</div><div class='del'>-		strcat(stat_buf, "|CTS");</div><div class='del'>-	if (info-&gt;serial_signals &amp; SerialSignal_DTR)</div><div class='del'>-		strcat(stat_buf, "|DTR");</div><div class='del'>-	if (info-&gt;serial_signals &amp; SerialSignal_DSR)</div><div class='del'>-		strcat(stat_buf, "|DSR");</div><div class='del'>-	if (info-&gt;serial_signals &amp; SerialSignal_DCD)</div><div class='del'>-		strcat(stat_buf, "|CD");</div><div class='del'>-	if (info-&gt;serial_signals &amp; SerialSignal_RI)</div><div class='del'>-		strcat(stat_buf, "|RI");</div><div class='del'>-</div><div class='del'>-	if (info-&gt;params.mode == MGSL_MODE_HDLC) {</div><div class='del'>-		seq_printf(m, " HDLC txok:%d rxok:%d",</div><div class='del'>-			      info-&gt;icount.txok, info-&gt;icount.rxok);</div><div class='del'>-		if (info-&gt;icount.txunder)</div><div class='del'>-			seq_printf(m, " txunder:%d", info-&gt;icount.txunder);</div><div class='del'>-		if (info-&gt;icount.txabort)</div><div class='del'>-			seq_printf(m, " txabort:%d", info-&gt;icount.txabort);</div><div class='del'>-		if (info-&gt;icount.rxshort)</div><div class='del'>-			seq_printf(m, " rxshort:%d", info-&gt;icount.rxshort);</div><div class='del'>-		if (info-&gt;icount.rxlong)</div><div class='del'>-			seq_printf(m, " rxlong:%d", info-&gt;icount.rxlong);</div><div class='del'>-		if (info-&gt;icount.rxover)</div><div class='del'>-			seq_printf(m, " rxover:%d", info-&gt;icount.rxover);</div><div class='del'>-		if (info-&gt;icount.rxcrc)</div><div class='del'>-			seq_printf(m, " rxcrc:%d", info-&gt;icount.rxcrc);</div><div class='del'>-	} else {</div><div class='del'>-		seq_printf(m, " ASYNC tx:%d rx:%d",</div><div class='del'>-			      info-&gt;icount.tx, info-&gt;icount.rx);</div><div class='del'>-		if (info-&gt;icount.frame)</div><div class='del'>-			seq_printf(m, " fe:%d", info-&gt;icount.frame);</div><div class='del'>-		if (info-&gt;icount.parity)</div><div class='del'>-			seq_printf(m, " pe:%d", info-&gt;icount.parity);</div><div class='del'>-		if (info-&gt;icount.brk)</div><div class='del'>-			seq_printf(m, " brk:%d", info-&gt;icount.brk);</div><div class='del'>-		if (info-&gt;icount.overrun)</div><div class='del'>-			seq_printf(m, " oe:%d", info-&gt;icount.overrun);</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	/* Append serial signal status to end */</div><div class='del'>-	seq_printf(m, " %s\n", stat_buf+1);</div><div class='del'>-</div><div class='del'>-	seq_printf(m, "txactive=%d bh_req=%d bh_run=%d pending_bh=%x\n",</div><div class='del'>-		       info-&gt;tx_active,info-&gt;bh_requested,info-&gt;bh_running,</div><div class='del'>-		       info-&gt;pending_bh);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Called to print information about devices</div><div class='del'>- */</div><div class='del'>-static int mgslpc_proc_show(struct seq_file *m, void *v)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *info;</div><div class='del'>-</div><div class='del'>-	seq_printf(m, "synclink driver:%s\n", driver_version);</div><div class='del'>-</div><div class='del'>-	info = mgslpc_device_list;</div><div class='del'>-	while (info) {</div><div class='del'>-		line_info(m, info);</div><div class='del'>-		info = info-&gt;next_device;</div><div class='del'>-	}</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int rx_alloc_buffers(MGSLPC_INFO *info)</div><div class='del'>-{</div><div class='del'>-	/* each buffer has header and data */</div><div class='del'>-	info-&gt;rx_buf_size = sizeof(RXBUF) + info-&gt;max_frame_size;</div><div class='del'>-</div><div class='del'>-	/* calculate total allocation size for 8 buffers */</div><div class='del'>-	info-&gt;rx_buf_total_size = info-&gt;rx_buf_size * 8;</div><div class='del'>-</div><div class='del'>-	/* limit total allocated memory */</div><div class='del'>-	if (info-&gt;rx_buf_total_size &gt; 0x10000)</div><div class='del'>-		info-&gt;rx_buf_total_size = 0x10000;</div><div class='del'>-</div><div class='del'>-	/* calculate number of buffers */</div><div class='del'>-	info-&gt;rx_buf_count = info-&gt;rx_buf_total_size / info-&gt;rx_buf_size;</div><div class='del'>-</div><div class='del'>-	info-&gt;rx_buf = kmalloc(info-&gt;rx_buf_total_size, GFP_KERNEL);</div><div class='del'>-	if (info-&gt;rx_buf == NULL)</div><div class='del'>-		return -ENOMEM;</div><div class='del'>-</div><div class='del'>-	/* unused flag buffer to satisfy receive_buf calling interface */</div><div class='del'>-	info-&gt;flag_buf = kzalloc(info-&gt;max_frame_size, GFP_KERNEL);</div><div class='del'>-	if (!info-&gt;flag_buf) {</div><div class='del'>-		kfree(info-&gt;rx_buf);</div><div class='del'>-		info-&gt;rx_buf = NULL;</div><div class='del'>-		return -ENOMEM;</div><div class='del'>-	}</div><div class='del'>-	</div><div class='del'>-	rx_reset_buffers(info);</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void rx_free_buffers(MGSLPC_INFO *info)</div><div class='del'>-{</div><div class='del'>-	kfree(info-&gt;rx_buf);</div><div class='del'>-	info-&gt;rx_buf = NULL;</div><div class='del'>-	kfree(info-&gt;flag_buf);</div><div class='del'>-	info-&gt;flag_buf = NULL;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int claim_resources(MGSLPC_INFO *info)</div><div class='del'>-{</div><div class='del'>-	if (rx_alloc_buffers(info) &lt; 0) {</div><div class='del'>-		printk("Can't allocate rx buffer %s\n", info-&gt;device_name);</div><div class='del'>-		release_resources(info);</div><div class='del'>-		return -ENODEV;</div><div class='del'>-	}</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void release_resources(MGSLPC_INFO *info)</div><div class='del'>-{</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("release_resources(%s)\n", info-&gt;device_name);</div><div class='del'>-	rx_free_buffers(info);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Add the specified device instance data structure to the</div><div class='del'>- * global linked list of devices and increment the device count.</div><div class='del'>- *</div><div class='del'>- * Arguments:		info	pointer to device instance data</div><div class='del'>- */</div><div class='del'>-static int mgslpc_add_device(MGSLPC_INFO *info)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *current_dev = NULL;</div><div class='del'>-	struct device *tty_dev;</div><div class='del'>-	int ret;</div><div class='del'>-</div><div class='del'>-	info-&gt;next_device = NULL;</div><div class='del'>-	info-&gt;line = mgslpc_device_count;</div><div class='del'>-	sprintf(info-&gt;device_name,"ttySLP%d",info-&gt;line);</div><div class='del'>-</div><div class='del'>-	if (info-&gt;line &lt; MAX_DEVICE_COUNT) {</div><div class='del'>-		if (maxframe[info-&gt;line])</div><div class='del'>-			info-&gt;max_frame_size = maxframe[info-&gt;line];</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	mgslpc_device_count++;</div><div class='del'>-</div><div class='del'>-	if (!mgslpc_device_list)</div><div class='del'>-		mgslpc_device_list = info;</div><div class='del'>-	else {</div><div class='del'>-		current_dev = mgslpc_device_list;</div><div class='del'>-		while (current_dev-&gt;next_device)</div><div class='del'>-			current_dev = current_dev-&gt;next_device;</div><div class='del'>-		current_dev-&gt;next_device = info;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (info-&gt;max_frame_size &lt; 4096)</div><div class='del'>-		info-&gt;max_frame_size = 4096;</div><div class='del'>-	else if (info-&gt;max_frame_size &gt; 65535)</div><div class='del'>-		info-&gt;max_frame_size = 65535;</div><div class='del'>-</div><div class='del'>-	printk("SyncLink PC Card %s:IO=%04X IRQ=%d\n",</div><div class='del'>-		info-&gt;device_name, info-&gt;io_base, info-&gt;irq_level);</div><div class='del'>-</div><div class='del'>-#if SYNCLINK_GENERIC_HDLC</div><div class='del'>-	ret = hdlcdev_init(info);</div><div class='del'>-	if (ret != 0)</div><div class='del'>-		goto failed;</div><div class='del'>-#endif</div><div class='del'>-</div><div class='del'>-	tty_dev = tty_port_register_device(&amp;info-&gt;port, serial_driver, info-&gt;line,</div><div class='del'>-			&amp;info-&gt;p_dev-&gt;dev);</div><div class='del'>-	if (IS_ERR(tty_dev)) {</div><div class='del'>-		ret = PTR_ERR(tty_dev);</div><div class='del'>-#if SYNCLINK_GENERIC_HDLC</div><div class='del'>-		hdlcdev_exit(info);</div><div class='del'>-#endif</div><div class='del'>-		goto failed;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	return 0;</div><div class='del'>-</div><div class='del'>-failed:</div><div class='del'>-	if (current_dev)</div><div class='del'>-		current_dev-&gt;next_device = NULL;</div><div class='del'>-	else</div><div class='del'>-		mgslpc_device_list = NULL;</div><div class='del'>-	mgslpc_device_count--;</div><div class='del'>-	return ret;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void mgslpc_remove_device(MGSLPC_INFO *remove_info)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *info = mgslpc_device_list;</div><div class='del'>-	MGSLPC_INFO *last = NULL;</div><div class='del'>-</div><div class='del'>-	while(info) {</div><div class='del'>-		if (info == remove_info) {</div><div class='del'>-			if (last)</div><div class='del'>-				last-&gt;next_device = info-&gt;next_device;</div><div class='del'>-			else</div><div class='del'>-				mgslpc_device_list = info-&gt;next_device;</div><div class='del'>-			tty_unregister_device(serial_driver, info-&gt;line);</div><div class='del'>-#if SYNCLINK_GENERIC_HDLC</div><div class='del'>-			hdlcdev_exit(info);</div><div class='del'>-#endif</div><div class='del'>-			release_resources(info);</div><div class='del'>-			tty_port_destroy(&amp;info-&gt;port);</div><div class='del'>-			kfree(info);</div><div class='del'>-			mgslpc_device_count--;</div><div class='del'>-			return;</div><div class='del'>-		}</div><div class='del'>-		last = info;</div><div class='del'>-		info = info-&gt;next_device;</div><div class='del'>-	}</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static const struct pcmcia_device_id mgslpc_ids[] = {</div><div class='del'>-	PCMCIA_DEVICE_MANF_CARD(0x02c5, 0x0050),</div><div class='del'>-	PCMCIA_DEVICE_NULL</div><div class='del'>-};</div><div class='del'>-MODULE_DEVICE_TABLE(pcmcia, mgslpc_ids);</div><div class='del'>-</div><div class='del'>-static struct pcmcia_driver mgslpc_driver = {</div><div class='del'>-	.owner		= THIS_MODULE,</div><div class='del'>-	.name		= "synclink_cs",</div><div class='del'>-	.probe		= mgslpc_probe,</div><div class='del'>-	.remove		= mgslpc_detach,</div><div class='del'>-	.id_table	= mgslpc_ids,</div><div class='del'>-	.suspend	= mgslpc_suspend,</div><div class='del'>-	.resume		= mgslpc_resume,</div><div class='del'>-};</div><div class='del'>-</div><div class='del'>-static const struct tty_operations mgslpc_ops = {</div><div class='del'>-	.open = mgslpc_open,</div><div class='del'>-	.close = mgslpc_close,</div><div class='del'>-	.write = mgslpc_write,</div><div class='del'>-	.put_char = mgslpc_put_char,</div><div class='del'>-	.flush_chars = mgslpc_flush_chars,</div><div class='del'>-	.write_room = mgslpc_write_room,</div><div class='del'>-	.chars_in_buffer = mgslpc_chars_in_buffer,</div><div class='del'>-	.flush_buffer = mgslpc_flush_buffer,</div><div class='del'>-	.ioctl = mgslpc_ioctl,</div><div class='del'>-	.throttle = mgslpc_throttle,</div><div class='del'>-	.unthrottle = mgslpc_unthrottle,</div><div class='del'>-	.send_xchar = mgslpc_send_xchar,</div><div class='del'>-	.break_ctl = mgslpc_break,</div><div class='del'>-	.wait_until_sent = mgslpc_wait_until_sent,</div><div class='del'>-	.set_termios = mgslpc_set_termios,</div><div class='del'>-	.stop = tx_pause,</div><div class='del'>-	.start = tx_release,</div><div class='del'>-	.hangup = mgslpc_hangup,</div><div class='del'>-	.tiocmget = tiocmget,</div><div class='del'>-	.tiocmset = tiocmset,</div><div class='del'>-	.get_icount = mgslpc_get_icount,</div><div class='del'>-	.proc_show = mgslpc_proc_show,</div><div class='del'>-};</div><div class='del'>-</div><div class='del'>-static int __init synclink_cs_init(void)</div><div class='del'>-{</div><div class='del'>-	int rc;</div><div class='del'>-</div><div class='del'>-	if (break_on_load) {</div><div class='del'>-		mgslpc_get_text_ptr();</div><div class='del'>-		BREAKPOINT();</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	serial_driver = tty_alloc_driver(MAX_DEVICE_COUNT,</div><div class='del'>-			TTY_DRIVER_REAL_RAW |</div><div class='del'>-			TTY_DRIVER_DYNAMIC_DEV);</div><div class='del'>-	if (IS_ERR(serial_driver)) {</div><div class='del'>-		rc = PTR_ERR(serial_driver);</div><div class='del'>-		goto err;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	/* Initialize the tty_driver structure */</div><div class='del'>-	serial_driver-&gt;driver_name = "synclink_cs";</div><div class='del'>-	serial_driver-&gt;name = "ttySLP";</div><div class='del'>-	serial_driver-&gt;major = ttymajor;</div><div class='del'>-	serial_driver-&gt;minor_start = 64;</div><div class='del'>-	serial_driver-&gt;type = TTY_DRIVER_TYPE_SERIAL;</div><div class='del'>-	serial_driver-&gt;subtype = SERIAL_TYPE_NORMAL;</div><div class='del'>-	serial_driver-&gt;init_termios = tty_std_termios;</div><div class='del'>-	serial_driver-&gt;init_termios.c_cflag =</div><div class='del'>-	B9600 | CS8 | CREAD | HUPCL | CLOCAL;</div><div class='del'>-	tty_set_operations(serial_driver, &amp;mgslpc_ops);</div><div class='del'>-</div><div class='del'>-	rc = tty_register_driver(serial_driver);</div><div class='del'>-	if (rc &lt; 0) {</div><div class='del'>-		printk(KERN_ERR "%s(%d):Couldn't register serial driver\n",</div><div class='del'>-				__FILE__, __LINE__);</div><div class='del'>-		goto err_put_tty;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	rc = pcmcia_register_driver(&amp;mgslpc_driver);</div><div class='del'>-	if (rc &lt; 0)</div><div class='del'>-		goto err_unreg_tty;</div><div class='del'>-</div><div class='del'>-	printk(KERN_INFO "%s %s, tty major#%d\n", driver_name, driver_version,</div><div class='del'>-			serial_driver-&gt;major);</div><div class='del'>-</div><div class='del'>-	return 0;</div><div class='del'>-err_unreg_tty:</div><div class='del'>-	tty_unregister_driver(serial_driver);</div><div class='del'>-err_put_tty:</div><div class='del'>-	tty_driver_kref_put(serial_driver);</div><div class='del'>-err:</div><div class='del'>-	return rc;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void __exit synclink_cs_exit(void)</div><div class='del'>-{</div><div class='del'>-	pcmcia_unregister_driver(&amp;mgslpc_driver);</div><div class='del'>-	tty_unregister_driver(serial_driver);</div><div class='del'>-	tty_driver_kref_put(serial_driver);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-module_init(synclink_cs_init);</div><div class='del'>-module_exit(synclink_cs_exit);</div><div class='del'>-</div><div class='del'>-static void mgslpc_set_rate(MGSLPC_INFO *info, unsigned char channel, unsigned int rate)</div><div class='del'>-{</div><div class='del'>-	unsigned int M, N;</div><div class='del'>-	unsigned char val;</div><div class='del'>-</div><div class='del'>-	/* note:standard BRG mode is broken in V3.2 chip</div><div class='del'>-	 * so enhanced mode is always used</div><div class='del'>-	 */</div><div class='del'>-</div><div class='del'>-	if (rate) {</div><div class='del'>-		N = 3686400 / rate;</div><div class='del'>-		if (!N)</div><div class='del'>-			N = 1;</div><div class='del'>-		N &gt;&gt;= 1;</div><div class='del'>-		for (M = 1; N &gt; 64 &amp;&amp; M &lt; 16; M++)</div><div class='del'>-			N &gt;&gt;= 1;</div><div class='del'>-		N--;</div><div class='del'>-</div><div class='del'>-		/* BGR[5..0] = N</div><div class='del'>-		 * BGR[9..6] = M</div><div class='del'>-		 * BGR[7..0] contained in BGR register</div><div class='del'>-		 * BGR[9..8] contained in CCR2[7..6]</div><div class='del'>-		 * divisor = (N+1)*2^M</div><div class='del'>-		 *</div><div class='del'>-		 * Note: M *must* not be zero (causes asymetric duty cycle)</div><div class='del'>-		 */</div><div class='del'>-		write_reg(info, (unsigned char) (channel + BGR),</div><div class='del'>-				  (unsigned char) ((M &lt;&lt; 6) + N));</div><div class='del'>-		val = read_reg(info, (unsigned char) (channel + CCR2)) &amp; 0x3f;</div><div class='del'>-		val |= ((M &lt;&lt; 4) &amp; 0xc0);</div><div class='del'>-		write_reg(info, (unsigned char) (channel + CCR2), val);</div><div class='del'>-	}</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Enabled the AUX clock output at the specified frequency.</div><div class='del'>- */</div><div class='del'>-static void enable_auxclk(MGSLPC_INFO *info)</div><div class='del'>-{</div><div class='del'>-	unsigned char val;</div><div class='del'>-</div><div class='del'>-	/* MODE</div><div class='del'>-	 *</div><div class='del'>-	 * 07..06  MDS[1..0] 10 = transparent HDLC mode</div><div class='del'>-	 * 05      ADM Address Mode, 0 = no addr recognition</div><div class='del'>-	 * 04      TMD Timer Mode, 0 = external</div><div class='del'>-	 * 03      RAC Receiver Active, 0 = inactive</div><div class='del'>-	 * 02      RTS 0=RTS active during xmit, 1=RTS always active</div><div class='del'>-	 * 01      TRS Timer Resolution, 1=512</div><div class='del'>-	 * 00      TLP Test Loop, 0 = no loop</div><div class='del'>-	 *</div><div class='del'>-	 * 1000 0010</div><div class='del'>-	 */</div><div class='del'>-	val = 0x82;</div><div class='del'>-</div><div class='del'>-	/* channel B RTS is used to enable AUXCLK driver on SP505 */</div><div class='del'>-	if (info-&gt;params.mode == MGSL_MODE_HDLC &amp;&amp; info-&gt;params.clock_speed)</div><div class='del'>-		val |= BIT2;</div><div class='del'>-	write_reg(info, CHB + MODE, val);</div><div class='del'>-</div><div class='del'>-	/* CCR0</div><div class='del'>-	 *</div><div class='del'>-	 * 07      PU Power Up, 1=active, 0=power down</div><div class='del'>-	 * 06      MCE Master Clock Enable, 1=enabled</div><div class='del'>-	 * 05      Reserved, 0</div><div class='del'>-	 * 04..02  SC[2..0] Encoding</div><div class='del'>-	 * 01..00  SM[1..0] Serial Mode, 00=HDLC</div><div class='del'>-	 *</div><div class='del'>-	 * 11000000</div><div class='del'>-	 */</div><div class='del'>-	write_reg(info, CHB + CCR0, 0xc0);</div><div class='del'>-</div><div class='del'>-	/* CCR1</div><div class='del'>-	 *</div><div class='del'>-	 * 07      SFLG Shared Flag, 0 = disable shared flags</div><div class='del'>-	 * 06      GALP Go Active On Loop, 0 = not used</div><div class='del'>-	 * 05      GLP Go On Loop, 0 = not used</div><div class='del'>-	 * 04      ODS Output Driver Select, 1=TxD is push-pull output</div><div class='del'>-	 * 03      ITF Interframe Time Fill, 0=mark, 1=flag</div><div class='del'>-	 * 02..00  CM[2..0] Clock Mode</div><div class='del'>-	 *</div><div class='del'>-	 * 0001 0111</div><div class='del'>-	 */</div><div class='del'>-	write_reg(info, CHB + CCR1, 0x17);</div><div class='del'>-</div><div class='del'>-	/* CCR2 (Channel B)</div><div class='del'>-	 *</div><div class='del'>-	 * 07..06  BGR[9..8] Baud rate bits 9..8</div><div class='del'>-	 * 05      BDF Baud rate divisor factor, 0=1, 1=BGR value</div><div class='del'>-	 * 04      SSEL Clock source select, 1=submode b</div><div class='del'>-	 * 03      TOE 0=TxCLK is input, 1=TxCLK is output</div><div class='del'>-	 * 02      RWX Read/Write Exchange 0=disabled</div><div class='del'>-	 * 01      C32, CRC select, 0=CRC-16, 1=CRC-32</div><div class='del'>-	 * 00      DIV, data inversion 0=disabled, 1=enabled</div><div class='del'>-	 *</div><div class='del'>-	 * 0011 1000</div><div class='del'>-	 */</div><div class='del'>-	if (info-&gt;params.mode == MGSL_MODE_HDLC &amp;&amp; info-&gt;params.clock_speed)</div><div class='del'>-		write_reg(info, CHB + CCR2, 0x38);</div><div class='del'>-	else</div><div class='del'>-		write_reg(info, CHB + CCR2, 0x30);</div><div class='del'>-</div><div class='del'>-	/* CCR4</div><div class='del'>-	 *</div><div class='del'>-	 * 07      MCK4 Master Clock Divide by 4, 1=enabled</div><div class='del'>-	 * 06      EBRG Enhanced Baud Rate Generator Mode, 1=enabled</div><div class='del'>-	 * 05      TST1 Test Pin, 0=normal operation</div><div class='del'>-	 * 04      ICD Ivert Carrier Detect, 1=enabled (active low)</div><div class='del'>-	 * 03..02  Reserved, must be 0</div><div class='del'>-	 * 01..00  RFT[1..0] RxFIFO Threshold 00=32 bytes</div><div class='del'>-	 *</div><div class='del'>-	 * 0101 0000</div><div class='del'>-	 */</div><div class='del'>-	write_reg(info, CHB + CCR4, 0x50);</div><div class='del'>-</div><div class='del'>-	/* if auxclk not enabled, set internal BRG so</div><div class='del'>-	 * CTS transitions can be detected (requires TxC)</div><div class='del'>-	 */</div><div class='del'>-	if (info-&gt;params.mode == MGSL_MODE_HDLC &amp;&amp; info-&gt;params.clock_speed)</div><div class='del'>-		mgslpc_set_rate(info, CHB, info-&gt;params.clock_speed);</div><div class='del'>-	else</div><div class='del'>-		mgslpc_set_rate(info, CHB, 921600);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void loopback_enable(MGSLPC_INFO *info)</div><div class='del'>-{</div><div class='del'>-	unsigned char val;</div><div class='del'>-</div><div class='del'>-	/* CCR1:02..00  CM[2..0] Clock Mode = 111 (clock mode 7) */</div><div class='del'>-	val = read_reg(info, CHA + CCR1) | (BIT2 | BIT1 | BIT0);</div><div class='del'>-	write_reg(info, CHA + CCR1, val);</div><div class='del'>-</div><div class='del'>-	/* CCR2:04 SSEL Clock source select, 1=submode b */</div><div class='del'>-	val = read_reg(info, CHA + CCR2) | (BIT4 | BIT5);</div><div class='del'>-	write_reg(info, CHA + CCR2, val);</div><div class='del'>-</div><div class='del'>-	/* set LinkSpeed if available, otherwise default to 2Mbps */</div><div class='del'>-	if (info-&gt;params.clock_speed)</div><div class='del'>-		mgslpc_set_rate(info, CHA, info-&gt;params.clock_speed);</div><div class='del'>-	else</div><div class='del'>-		mgslpc_set_rate(info, CHA, 1843200);</div><div class='del'>-</div><div class='del'>-	/* MODE:00 TLP Test Loop, 1=loopback enabled */</div><div class='del'>-	val = read_reg(info, CHA + MODE) | BIT0;</div><div class='del'>-	write_reg(info, CHA + MODE, val);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void hdlc_mode(MGSLPC_INFO *info)</div><div class='del'>-{</div><div class='del'>-	unsigned char val;</div><div class='del'>-	unsigned char clkmode, clksubmode;</div><div class='del'>-</div><div class='del'>-	/* disable all interrupts */</div><div class='del'>-	irq_disable(info, CHA, 0xffff);</div><div class='del'>-	irq_disable(info, CHB, 0xffff);</div><div class='del'>-	port_irq_disable(info, 0xff);</div><div class='del'>-</div><div class='del'>-	/* assume clock mode 0a, rcv=RxC xmt=TxC */</div><div class='del'>-	clkmode = clksubmode = 0;</div><div class='del'>-	if (info-&gt;params.flags &amp; HDLC_FLAG_RXC_DPLL</div><div class='del'>-	    &amp;&amp; info-&gt;params.flags &amp; HDLC_FLAG_TXC_DPLL) {</div><div class='del'>-		/* clock mode 7a, rcv = DPLL, xmt = DPLL */</div><div class='del'>-		clkmode = 7;</div><div class='del'>-	} else if (info-&gt;params.flags &amp; HDLC_FLAG_RXC_BRG</div><div class='del'>-		 &amp;&amp; info-&gt;params.flags &amp; HDLC_FLAG_TXC_BRG) {</div><div class='del'>-		/* clock mode 7b, rcv = BRG, xmt = BRG */</div><div class='del'>-		clkmode = 7;</div><div class='del'>-		clksubmode = 1;</div><div class='del'>-	} else if (info-&gt;params.flags &amp; HDLC_FLAG_RXC_DPLL) {</div><div class='del'>-		if (info-&gt;params.flags &amp; HDLC_FLAG_TXC_BRG) {</div><div class='del'>-			/* clock mode 6b, rcv = DPLL, xmt = BRG/16 */</div><div class='del'>-			clkmode = 6;</div><div class='del'>-			clksubmode = 1;</div><div class='del'>-		} else {</div><div class='del'>-			/* clock mode 6a, rcv = DPLL, xmt = TxC */</div><div class='del'>-			clkmode = 6;</div><div class='del'>-		}</div><div class='del'>-	} else if (info-&gt;params.flags &amp; HDLC_FLAG_TXC_BRG) {</div><div class='del'>-		/* clock mode 0b, rcv = RxC, xmt = BRG */</div><div class='del'>-		clksubmode = 1;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	/* MODE</div><div class='del'>-	 *</div><div class='del'>-	 * 07..06  MDS[1..0] 10 = transparent HDLC mode</div><div class='del'>-	 * 05      ADM Address Mode, 0 = no addr recognition</div><div class='del'>-	 * 04      TMD Timer Mode, 0 = external</div><div class='del'>-	 * 03      RAC Receiver Active, 0 = inactive</div><div class='del'>-	 * 02      RTS 0=RTS active during xmit, 1=RTS always active</div><div class='del'>-	 * 01      TRS Timer Resolution, 1=512</div><div class='del'>-	 * 00      TLP Test Loop, 0 = no loop</div><div class='del'>-	 *</div><div class='del'>-	 * 1000 0010</div><div class='del'>-	 */</div><div class='del'>-	val = 0x82;</div><div class='del'>-	if (info-&gt;params.loopback)</div><div class='del'>-		val |= BIT0;</div><div class='del'>-</div><div class='del'>-	/* preserve RTS state */</div><div class='del'>-	if (info-&gt;serial_signals &amp; SerialSignal_RTS)</div><div class='del'>-		val |= BIT2;</div><div class='del'>-	write_reg(info, CHA + MODE, val);</div><div class='del'>-</div><div class='del'>-	/* CCR0</div><div class='del'>-	 *</div><div class='del'>-	 * 07      PU Power Up, 1=active, 0=power down</div><div class='del'>-	 * 06      MCE Master Clock Enable, 1=enabled</div><div class='del'>-	 * 05      Reserved, 0</div><div class='del'>-	 * 04..02  SC[2..0] Encoding</div><div class='del'>-	 * 01..00  SM[1..0] Serial Mode, 00=HDLC</div><div class='del'>-	 *</div><div class='del'>-	 * 11000000</div><div class='del'>-	 */</div><div class='del'>-	val = 0xc0;</div><div class='del'>-	switch (info-&gt;params.encoding)</div><div class='del'>-	{</div><div class='del'>-	case HDLC_ENCODING_NRZI:</div><div class='del'>-		val |= BIT3;</div><div class='del'>-		break;</div><div class='del'>-	case HDLC_ENCODING_BIPHASE_SPACE:</div><div class='del'>-		val |= BIT4;</div><div class='del'>-		break;		// FM0</div><div class='del'>-	case HDLC_ENCODING_BIPHASE_MARK:</div><div class='del'>-		val |= BIT4 | BIT2;</div><div class='del'>-		break;		// FM1</div><div class='del'>-	case HDLC_ENCODING_BIPHASE_LEVEL:</div><div class='del'>-		val |= BIT4 | BIT3;</div><div class='del'>-		break;		// Manchester</div><div class='del'>-	}</div><div class='del'>-	write_reg(info, CHA + CCR0, val);</div><div class='del'>-</div><div class='del'>-	/* CCR1</div><div class='del'>-	 *</div><div class='del'>-	 * 07      SFLG Shared Flag, 0 = disable shared flags</div><div class='del'>-	 * 06      GALP Go Active On Loop, 0 = not used</div><div class='del'>-	 * 05      GLP Go On Loop, 0 = not used</div><div class='del'>-	 * 04      ODS Output Driver Select, 1=TxD is push-pull output</div><div class='del'>-	 * 03      ITF Interframe Time Fill, 0=mark, 1=flag</div><div class='del'>-	 * 02..00  CM[2..0] Clock Mode</div><div class='del'>-	 *</div><div class='del'>-	 * 0001 0000</div><div class='del'>-	 */</div><div class='del'>-	val = 0x10 + clkmode;</div><div class='del'>-	write_reg(info, CHA + CCR1, val);</div><div class='del'>-</div><div class='del'>-	/* CCR2</div><div class='del'>-	 *</div><div class='del'>-	 * 07..06  BGR[9..8] Baud rate bits 9..8</div><div class='del'>-	 * 05      BDF Baud rate divisor factor, 0=1, 1=BGR value</div><div class='del'>-	 * 04      SSEL Clock source select, 1=submode b</div><div class='del'>-	 * 03      TOE 0=TxCLK is input, 0=TxCLK is input</div><div class='del'>-	 * 02      RWX Read/Write Exchange 0=disabled</div><div class='del'>-	 * 01      C32, CRC select, 0=CRC-16, 1=CRC-32</div><div class='del'>-	 * 00      DIV, data inversion 0=disabled, 1=enabled</div><div class='del'>-	 *</div><div class='del'>-	 * 0000 0000</div><div class='del'>-	 */</div><div class='del'>-	val = 0x00;</div><div class='del'>-	if (clkmode == 2 || clkmode == 3 || clkmode == 6</div><div class='del'>-	    || clkmode == 7 || (clkmode == 0 &amp;&amp; clksubmode == 1))</div><div class='del'>-		val |= BIT5;</div><div class='del'>-	if (clksubmode)</div><div class='del'>-		val |= BIT4;</div><div class='del'>-	if (info-&gt;params.crc_type == HDLC_CRC_32_CCITT)</div><div class='del'>-		val |= BIT1;</div><div class='del'>-	if (info-&gt;params.encoding == HDLC_ENCODING_NRZB)</div><div class='del'>-		val |= BIT0;</div><div class='del'>-	write_reg(info, CHA + CCR2, val);</div><div class='del'>-</div><div class='del'>-	/* CCR3</div><div class='del'>-	 *</div><div class='del'>-	 * 07..06  PRE[1..0] Preamble count 00=1, 01=2, 10=4, 11=8</div><div class='del'>-	 * 05      EPT Enable preamble transmission, 1=enabled</div><div class='del'>-	 * 04      RADD Receive address pushed to FIFO, 0=disabled</div><div class='del'>-	 * 03      CRL CRC Reset Level, 0=FFFF</div><div class='del'>-	 * 02      RCRC Rx CRC 0=On 1=Off</div><div class='del'>-	 * 01      TCRC Tx CRC 0=On 1=Off</div><div class='del'>-	 * 00      PSD DPLL Phase Shift Disable</div><div class='del'>-	 *</div><div class='del'>-	 * 0000 0000</div><div class='del'>-	 */</div><div class='del'>-	val = 0x00;</div><div class='del'>-	if (info-&gt;params.crc_type == HDLC_CRC_NONE)</div><div class='del'>-		val |= BIT2 | BIT1;</div><div class='del'>-	if (info-&gt;params.preamble != HDLC_PREAMBLE_PATTERN_NONE)</div><div class='del'>-		val |= BIT5;</div><div class='del'>-	switch (info-&gt;params.preamble_length)</div><div class='del'>-	{</div><div class='del'>-	case HDLC_PREAMBLE_LENGTH_16BITS:</div><div class='del'>-		val |= BIT6;</div><div class='del'>-		break;</div><div class='del'>-	case HDLC_PREAMBLE_LENGTH_32BITS:</div><div class='del'>-		val |= BIT6;</div><div class='del'>-		break;</div><div class='del'>-	case HDLC_PREAMBLE_LENGTH_64BITS:</div><div class='del'>-		val |= BIT7 | BIT6;</div><div class='del'>-		break;</div><div class='del'>-	}</div><div class='del'>-	write_reg(info, CHA + CCR3, val);</div><div class='del'>-</div><div class='del'>-	/* PRE - Preamble pattern */</div><div class='del'>-	val = 0;</div><div class='del'>-	switch (info-&gt;params.preamble)</div><div class='del'>-	{</div><div class='del'>-	case HDLC_PREAMBLE_PATTERN_FLAGS: val = 0x7e; break;</div><div class='del'>-	case HDLC_PREAMBLE_PATTERN_10:    val = 0xaa; break;</div><div class='del'>-	case HDLC_PREAMBLE_PATTERN_01:    val = 0x55; break;</div><div class='del'>-	case HDLC_PREAMBLE_PATTERN_ONES:  val = 0xff; break;</div><div class='del'>-	}</div><div class='del'>-	write_reg(info, CHA + PRE, val);</div><div class='del'>-</div><div class='del'>-	/* CCR4</div><div class='del'>-	 *</div><div class='del'>-	 * 07      MCK4 Master Clock Divide by 4, 1=enabled</div><div class='del'>-	 * 06      EBRG Enhanced Baud Rate Generator Mode, 1=enabled</div><div class='del'>-	 * 05      TST1 Test Pin, 0=normal operation</div><div class='del'>-	 * 04      ICD Ivert Carrier Detect, 1=enabled (active low)</div><div class='del'>-	 * 03..02  Reserved, must be 0</div><div class='del'>-	 * 01..00  RFT[1..0] RxFIFO Threshold 00=32 bytes</div><div class='del'>-	 *</div><div class='del'>-	 * 0101 0000</div><div class='del'>-	 */</div><div class='del'>-	val = 0x50;</div><div class='del'>-	write_reg(info, CHA + CCR4, val);</div><div class='del'>-	if (info-&gt;params.flags &amp; HDLC_FLAG_RXC_DPLL)</div><div class='del'>-		mgslpc_set_rate(info, CHA, info-&gt;params.clock_speed * 16);</div><div class='del'>-	else</div><div class='del'>-		mgslpc_set_rate(info, CHA, info-&gt;params.clock_speed);</div><div class='del'>-</div><div class='del'>-	/* RLCR Receive length check register</div><div class='del'>-	 *</div><div class='del'>-	 * 7     1=enable receive length check</div><div class='del'>-	 * 6..0  Max frame length = (RL + 1) * 32</div><div class='del'>-	 */</div><div class='del'>-	write_reg(info, CHA + RLCR, 0);</div><div class='del'>-</div><div class='del'>-	/* XBCH Transmit Byte Count High</div><div class='del'>-	 *</div><div class='del'>-	 * 07      DMA mode, 0 = interrupt driven</div><div class='del'>-	 * 06      NRM, 0=ABM (ignored)</div><div class='del'>-	 * 05      CAS Carrier Auto Start</div><div class='del'>-	 * 04      XC Transmit Continuously (ignored)</div><div class='del'>-	 * 03..00  XBC[10..8] Transmit byte count bits 10..8</div><div class='del'>-	 *</div><div class='del'>-	 * 0000 0000</div><div class='del'>-	 */</div><div class='del'>-	val = 0x00;</div><div class='del'>-	if (info-&gt;params.flags &amp; HDLC_FLAG_AUTO_DCD)</div><div class='del'>-		val |= BIT5;</div><div class='del'>-	write_reg(info, CHA + XBCH, val);</div><div class='del'>-	enable_auxclk(info);</div><div class='del'>-	if (info-&gt;params.loopback || info-&gt;testing_irq)</div><div class='del'>-		loopback_enable(info);</div><div class='del'>-	if (info-&gt;params.flags &amp; HDLC_FLAG_AUTO_CTS)</div><div class='del'>-	{</div><div class='del'>-		irq_enable(info, CHB, IRQ_CTS);</div><div class='del'>-		/* PVR[3] 1=AUTO CTS active */</div><div class='del'>-		set_reg_bits(info, CHA + PVR, BIT3);</div><div class='del'>-	} else</div><div class='del'>-		clear_reg_bits(info, CHA + PVR, BIT3);</div><div class='del'>-</div><div class='del'>-	irq_enable(info, CHA,</div><div class='del'>-			 IRQ_RXEOM | IRQ_RXFIFO | IRQ_ALLSENT |</div><div class='del'>-			 IRQ_UNDERRUN | IRQ_TXFIFO);</div><div class='del'>-	issue_command(info, CHA, CMD_TXRESET + CMD_RXRESET);</div><div class='del'>-	wait_command_complete(info, CHA);</div><div class='del'>-	read_reg16(info, CHA + ISR);	/* clear pending IRQs */</div><div class='del'>-</div><div class='del'>-	/* Master clock mode enabled above to allow reset commands</div><div class='del'>-	 * to complete even if no data clocks are present.</div><div class='del'>-	 *</div><div class='del'>-	 * Disable master clock mode for normal communications because</div><div class='del'>-	 * V3.2 of the ESCC2 has a bug that prevents the transmit all sent</div><div class='del'>-	 * IRQ when in master clock mode.</div><div class='del'>-	 *</div><div class='del'>-	 * Leave master clock mode enabled for IRQ test because the</div><div class='del'>-	 * timer IRQ used by the test can only happen in master clock mode.</div><div class='del'>-	 */</div><div class='del'>-	if (!info-&gt;testing_irq)</div><div class='del'>-		clear_reg_bits(info, CHA + CCR0, BIT6);</div><div class='del'>-</div><div class='del'>-	tx_set_idle(info);</div><div class='del'>-</div><div class='del'>-	tx_stop(info);</div><div class='del'>-	rx_stop(info);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void rx_stop(MGSLPC_INFO *info)</div><div class='del'>-{</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_ISR)</div><div class='del'>-		printk("%s(%d):rx_stop(%s)\n",</div><div class='del'>-			 __FILE__, __LINE__, info-&gt;device_name);</div><div class='del'>-</div><div class='del'>-	/* MODE:03 RAC Receiver Active, 0=inactive */</div><div class='del'>-	clear_reg_bits(info, CHA + MODE, BIT3);</div><div class='del'>-</div><div class='del'>-	info-&gt;rx_enabled = false;</div><div class='del'>-	info-&gt;rx_overflow = false;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void rx_start(MGSLPC_INFO *info)</div><div class='del'>-{</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_ISR)</div><div class='del'>-		printk("%s(%d):rx_start(%s)\n",</div><div class='del'>-			 __FILE__, __LINE__, info-&gt;device_name);</div><div class='del'>-</div><div class='del'>-	rx_reset_buffers(info);</div><div class='del'>-	info-&gt;rx_enabled = false;</div><div class='del'>-	info-&gt;rx_overflow = false;</div><div class='del'>-</div><div class='del'>-	/* MODE:03 RAC Receiver Active, 1=active */</div><div class='del'>-	set_reg_bits(info, CHA + MODE, BIT3);</div><div class='del'>-</div><div class='del'>-	info-&gt;rx_enabled = true;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void tx_start(MGSLPC_INFO *info, struct tty_struct *tty)</div><div class='del'>-{</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_ISR)</div><div class='del'>-		printk("%s(%d):tx_start(%s)\n",</div><div class='del'>-			 __FILE__, __LINE__, info-&gt;device_name);</div><div class='del'>-</div><div class='del'>-	if (info-&gt;tx_count) {</div><div class='del'>-		/* If auto RTS enabled and RTS is inactive, then assert */</div><div class='del'>-		/* RTS and set a flag indicating that the driver should */</div><div class='del'>-		/* negate RTS when the transmission completes. */</div><div class='del'>-		info-&gt;drop_rts_on_tx_done = false;</div><div class='del'>-</div><div class='del'>-		if (info-&gt;params.flags &amp; HDLC_FLAG_AUTO_RTS) {</div><div class='del'>-			get_signals(info);</div><div class='del'>-			if (!(info-&gt;serial_signals &amp; SerialSignal_RTS)) {</div><div class='del'>-				info-&gt;serial_signals |= SerialSignal_RTS;</div><div class='del'>-				set_signals(info);</div><div class='del'>-				info-&gt;drop_rts_on_tx_done = true;</div><div class='del'>-			}</div><div class='del'>-		}</div><div class='del'>-</div><div class='del'>-		if (info-&gt;params.mode == MGSL_MODE_ASYNC) {</div><div class='del'>-			if (!info-&gt;tx_active) {</div><div class='del'>-				info-&gt;tx_active = true;</div><div class='del'>-				tx_ready(info, tty);</div><div class='del'>-			}</div><div class='del'>-		} else {</div><div class='del'>-			info-&gt;tx_active = true;</div><div class='del'>-			tx_ready(info, tty);</div><div class='del'>-			mod_timer(&amp;info-&gt;tx_timer, jiffies +</div><div class='del'>-					msecs_to_jiffies(5000));</div><div class='del'>-		}</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (!info-&gt;tx_enabled)</div><div class='del'>-		info-&gt;tx_enabled = true;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void tx_stop(MGSLPC_INFO *info)</div><div class='del'>-{</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_ISR)</div><div class='del'>-		printk("%s(%d):tx_stop(%s)\n",</div><div class='del'>-			 __FILE__, __LINE__, info-&gt;device_name);</div><div class='del'>-</div><div class='del'>-	del_timer(&amp;info-&gt;tx_timer);</div><div class='del'>-</div><div class='del'>-	info-&gt;tx_enabled = false;</div><div class='del'>-	info-&gt;tx_active = false;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Reset the adapter to a known state and prepare it for further use.</div><div class='del'>- */</div><div class='del'>-static void reset_device(MGSLPC_INFO *info)</div><div class='del'>-{</div><div class='del'>-	/* power up both channels (set BIT7) */</div><div class='del'>-	write_reg(info, CHA + CCR0, 0x80);</div><div class='del'>-	write_reg(info, CHB + CCR0, 0x80);</div><div class='del'>-	write_reg(info, CHA + MODE, 0);</div><div class='del'>-	write_reg(info, CHB + MODE, 0);</div><div class='del'>-</div><div class='del'>-	/* disable all interrupts */</div><div class='del'>-	irq_disable(info, CHA, 0xffff);</div><div class='del'>-	irq_disable(info, CHB, 0xffff);</div><div class='del'>-	port_irq_disable(info, 0xff);</div><div class='del'>-</div><div class='del'>-	/* PCR Port Configuration Register</div><div class='del'>-	 *</div><div class='del'>-	 * 07..04  DEC[3..0] Serial I/F select outputs</div><div class='del'>-	 * 03      output, 1=AUTO CTS control enabled</div><div class='del'>-	 * 02      RI Ring Indicator input 0=active</div><div class='del'>-	 * 01      DSR input 0=active</div><div class='del'>-	 * 00      DTR output 0=active</div><div class='del'>-	 *</div><div class='del'>-	 * 0000 0110</div><div class='del'>-	 */</div><div class='del'>-	write_reg(info, PCR, 0x06);</div><div class='del'>-</div><div class='del'>-	/* PVR Port Value Register</div><div class='del'>-	 *</div><div class='del'>-	 * 07..04  DEC[3..0] Serial I/F select (0000=disabled)</div><div class='del'>-	 * 03      AUTO CTS output 1=enabled</div><div class='del'>-	 * 02      RI Ring Indicator input</div><div class='del'>-	 * 01      DSR input</div><div class='del'>-	 * 00      DTR output (1=inactive)</div><div class='del'>-	 *</div><div class='del'>-	 * 0000 0001</div><div class='del'>-	 */</div><div class='del'>-//	write_reg(info, PVR, PVR_DTR);</div><div class='del'>-</div><div class='del'>-	/* IPC Interrupt Port Configuration</div><div class='del'>-	 *</div><div class='del'>-	 * 07      VIS 1=Masked interrupts visible</div><div class='del'>-	 * 06..05  Reserved, 0</div><div class='del'>-	 * 04..03  SLA Slave address, 00 ignored</div><div class='del'>-	 * 02      CASM Cascading Mode, 1=daisy chain</div><div class='del'>-	 * 01..00  IC[1..0] Interrupt Config, 01=push-pull output, active low</div><div class='del'>-	 *</div><div class='del'>-	 * 0000 0101</div><div class='del'>-	 */</div><div class='del'>-	write_reg(info, IPC, 0x05);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void async_mode(MGSLPC_INFO *info)</div><div class='del'>-{</div><div class='del'>-	unsigned char val;</div><div class='del'>-</div><div class='del'>-	/* disable all interrupts */</div><div class='del'>-	irq_disable(info, CHA, 0xffff);</div><div class='del'>-	irq_disable(info, CHB, 0xffff);</div><div class='del'>-	port_irq_disable(info, 0xff);</div><div class='del'>-</div><div class='del'>-	/* MODE</div><div class='del'>-	 *</div><div class='del'>-	 * 07      Reserved, 0</div><div class='del'>-	 * 06      FRTS RTS State, 0=active</div><div class='del'>-	 * 05      FCTS Flow Control on CTS</div><div class='del'>-	 * 04      FLON Flow Control Enable</div><div class='del'>-	 * 03      RAC Receiver Active, 0 = inactive</div><div class='del'>-	 * 02      RTS 0=Auto RTS, 1=manual RTS</div><div class='del'>-	 * 01      TRS Timer Resolution, 1=512</div><div class='del'>-	 * 00      TLP Test Loop, 0 = no loop</div><div class='del'>-	 *</div><div class='del'>-	 * 0000 0110</div><div class='del'>-	 */</div><div class='del'>-	val = 0x06;</div><div class='del'>-	if (info-&gt;params.loopback)</div><div class='del'>-		val |= BIT0;</div><div class='del'>-</div><div class='del'>-	/* preserve RTS state */</div><div class='del'>-	if (!(info-&gt;serial_signals &amp; SerialSignal_RTS))</div><div class='del'>-		val |= BIT6;</div><div class='del'>-	write_reg(info, CHA + MODE, val);</div><div class='del'>-</div><div class='del'>-	/* CCR0</div><div class='del'>-	 *</div><div class='del'>-	 * 07      PU Power Up, 1=active, 0=power down</div><div class='del'>-	 * 06      MCE Master Clock Enable, 1=enabled</div><div class='del'>-	 * 05      Reserved, 0</div><div class='del'>-	 * 04..02  SC[2..0] Encoding, 000=NRZ</div><div class='del'>-	 * 01..00  SM[1..0] Serial Mode, 11=Async</div><div class='del'>-	 *</div><div class='del'>-	 * 1000 0011</div><div class='del'>-	 */</div><div class='del'>-	write_reg(info, CHA + CCR0, 0x83);</div><div class='del'>-</div><div class='del'>-	/* CCR1</div><div class='del'>-	 *</div><div class='del'>-	 * 07..05  Reserved, 0</div><div class='del'>-	 * 04      ODS Output Driver Select, 1=TxD is push-pull output</div><div class='del'>-	 * 03      BCR Bit Clock Rate, 1=16x</div><div class='del'>-	 * 02..00  CM[2..0] Clock Mode, 111=BRG</div><div class='del'>-	 *</div><div class='del'>-	 * 0001 1111</div><div class='del'>-	 */</div><div class='del'>-	write_reg(info, CHA + CCR1, 0x1f);</div><div class='del'>-</div><div class='del'>-	/* CCR2 (channel A)</div><div class='del'>-	 *</div><div class='del'>-	 * 07..06  BGR[9..8] Baud rate bits 9..8</div><div class='del'>-	 * 05      BDF Baud rate divisor factor, 0=1, 1=BGR value</div><div class='del'>-	 * 04      SSEL Clock source select, 1=submode b</div><div class='del'>-	 * 03      TOE 0=TxCLK is input, 0=TxCLK is input</div><div class='del'>-	 * 02      RWX Read/Write Exchange 0=disabled</div><div class='del'>-	 * 01      Reserved, 0</div><div class='del'>-	 * 00      DIV, data inversion 0=disabled, 1=enabled</div><div class='del'>-	 *</div><div class='del'>-	 * 0001 0000</div><div class='del'>-	 */</div><div class='del'>-	write_reg(info, CHA + CCR2, 0x10);</div><div class='del'>-</div><div class='del'>-	/* CCR3</div><div class='del'>-	 *</div><div class='del'>-	 * 07..01  Reserved, 0</div><div class='del'>-	 * 00      PSD DPLL Phase Shift Disable</div><div class='del'>-	 *</div><div class='del'>-	 * 0000 0000</div><div class='del'>-	 */</div><div class='del'>-	write_reg(info, CHA + CCR3, 0);</div><div class='del'>-</div><div class='del'>-	/* CCR4</div><div class='del'>-	 *</div><div class='del'>-	 * 07      MCK4 Master Clock Divide by 4, 1=enabled</div><div class='del'>-	 * 06      EBRG Enhanced Baud Rate Generator Mode, 1=enabled</div><div class='del'>-	 * 05      TST1 Test Pin, 0=normal operation</div><div class='del'>-	 * 04      ICD Ivert Carrier Detect, 1=enabled (active low)</div><div class='del'>-	 * 03..00  Reserved, must be 0</div><div class='del'>-	 *</div><div class='del'>-	 * 0101 0000</div><div class='del'>-	 */</div><div class='del'>-	write_reg(info, CHA + CCR4, 0x50);</div><div class='del'>-	mgslpc_set_rate(info, CHA, info-&gt;params.data_rate * 16);</div><div class='del'>-</div><div class='del'>-	/* DAFO Data Format</div><div class='del'>-	 *</div><div class='del'>-	 * 07      Reserved, 0</div><div class='del'>-	 * 06      XBRK transmit break, 0=normal operation</div><div class='del'>-	 * 05      Stop bits (0=1, 1=2)</div><div class='del'>-	 * 04..03  PAR[1..0] Parity (01=odd, 10=even)</div><div class='del'>-	 * 02      PAREN Parity Enable</div><div class='del'>-	 * 01..00  CHL[1..0] Character Length (00=8, 01=7)</div><div class='del'>-	 *</div><div class='del'>-	 */</div><div class='del'>-	val = 0x00;</div><div class='del'>-	if (info-&gt;params.data_bits != 8)</div><div class='del'>-		val |= BIT0;	/* 7 bits */</div><div class='del'>-	if (info-&gt;params.stop_bits != 1)</div><div class='del'>-		val |= BIT5;</div><div class='del'>-	if (info-&gt;params.parity != ASYNC_PARITY_NONE)</div><div class='del'>-	{</div><div class='del'>-		val |= BIT2;	/* Parity enable */</div><div class='del'>-		if (info-&gt;params.parity == ASYNC_PARITY_ODD)</div><div class='del'>-			val |= BIT3;</div><div class='del'>-		else</div><div class='del'>-			val |= BIT4;</div><div class='del'>-	}</div><div class='del'>-	write_reg(info, CHA + DAFO, val);</div><div class='del'>-</div><div class='del'>-	/* RFC Rx FIFO Control</div><div class='del'>-	 *</div><div class='del'>-	 * 07      Reserved, 0</div><div class='del'>-	 * 06      DPS, 1=parity bit not stored in data byte</div><div class='del'>-	 * 05      DXS, 0=all data stored in FIFO (including XON/XOFF)</div><div class='del'>-	 * 04      RFDF Rx FIFO Data Format, 1=status byte stored in FIFO</div><div class='del'>-	 * 03..02  RFTH[1..0], rx threshold, 11=16 status + 16 data byte</div><div class='del'>-	 * 01      Reserved, 0</div><div class='del'>-	 * 00      TCDE Terminate Char Detect Enable, 0=disabled</div><div class='del'>-	 *</div><div class='del'>-	 * 0101 1100</div><div class='del'>-	 */</div><div class='del'>-	write_reg(info, CHA + RFC, 0x5c);</div><div class='del'>-</div><div class='del'>-	/* RLCR Receive length check register</div><div class='del'>-	 *</div><div class='del'>-	 * Max frame length = (RL + 1) * 32</div><div class='del'>-	 */</div><div class='del'>-	write_reg(info, CHA + RLCR, 0);</div><div class='del'>-</div><div class='del'>-	/* XBCH Transmit Byte Count High</div><div class='del'>-	 *</div><div class='del'>-	 * 07      DMA mode, 0 = interrupt driven</div><div class='del'>-	 * 06      NRM, 0=ABM (ignored)</div><div class='del'>-	 * 05      CAS Carrier Auto Start</div><div class='del'>-	 * 04      XC Transmit Continuously (ignored)</div><div class='del'>-	 * 03..00  XBC[10..8] Transmit byte count bits 10..8</div><div class='del'>-	 *</div><div class='del'>-	 * 0000 0000</div><div class='del'>-	 */</div><div class='del'>-	val = 0x00;</div><div class='del'>-	if (info-&gt;params.flags &amp; HDLC_FLAG_AUTO_DCD)</div><div class='del'>-		val |= BIT5;</div><div class='del'>-	write_reg(info, CHA + XBCH, val);</div><div class='del'>-	if (info-&gt;params.flags &amp; HDLC_FLAG_AUTO_CTS)</div><div class='del'>-		irq_enable(info, CHA, IRQ_CTS);</div><div class='del'>-</div><div class='del'>-	/* MODE:03 RAC Receiver Active, 1=active */</div><div class='del'>-	set_reg_bits(info, CHA + MODE, BIT3);</div><div class='del'>-	enable_auxclk(info);</div><div class='del'>-	if (info-&gt;params.flags &amp; HDLC_FLAG_AUTO_CTS) {</div><div class='del'>-		irq_enable(info, CHB, IRQ_CTS);</div><div class='del'>-		/* PVR[3] 1=AUTO CTS active */</div><div class='del'>-		set_reg_bits(info, CHA + PVR, BIT3);</div><div class='del'>-	} else</div><div class='del'>-		clear_reg_bits(info, CHA + PVR, BIT3);</div><div class='del'>-	irq_enable(info, CHA,</div><div class='del'>-			  IRQ_RXEOM | IRQ_RXFIFO | IRQ_BREAK_ON | IRQ_RXTIME |</div><div class='del'>-			  IRQ_ALLSENT | IRQ_TXFIFO);</div><div class='del'>-	issue_command(info, CHA, CMD_TXRESET + CMD_RXRESET);</div><div class='del'>-	wait_command_complete(info, CHA);</div><div class='del'>-	read_reg16(info, CHA + ISR);	/* clear pending IRQs */</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Set the HDLC idle mode for the transmitter.</div><div class='del'>- */</div><div class='del'>-static void tx_set_idle(MGSLPC_INFO *info)</div><div class='del'>-{</div><div class='del'>-	/* Note: ESCC2 only supports flags and one idle modes */</div><div class='del'>-	if (info-&gt;idle_mode == HDLC_TXIDLE_FLAGS)</div><div class='del'>-		set_reg_bits(info, CHA + CCR1, BIT3);</div><div class='del'>-	else</div><div class='del'>-		clear_reg_bits(info, CHA + CCR1, BIT3);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* get state of the V24 status (input) signals.</div><div class='del'>- */</div><div class='del'>-static void get_signals(MGSLPC_INFO *info)</div><div class='del'>-{</div><div class='del'>-	unsigned char status = 0;</div><div class='del'>-</div><div class='del'>-	/* preserve RTS and DTR */</div><div class='del'>-	info-&gt;serial_signals &amp;= SerialSignal_RTS | SerialSignal_DTR;</div><div class='del'>-</div><div class='del'>-	if (read_reg(info, CHB + VSTR) &amp; BIT7)</div><div class='del'>-		info-&gt;serial_signals |= SerialSignal_DCD;</div><div class='del'>-	if (read_reg(info, CHB + STAR) &amp; BIT1)</div><div class='del'>-		info-&gt;serial_signals |= SerialSignal_CTS;</div><div class='del'>-</div><div class='del'>-	status = read_reg(info, CHA + PVR);</div><div class='del'>-	if (!(status &amp; PVR_RI))</div><div class='del'>-		info-&gt;serial_signals |= SerialSignal_RI;</div><div class='del'>-	if (!(status &amp; PVR_DSR))</div><div class='del'>-		info-&gt;serial_signals |= SerialSignal_DSR;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Set the state of RTS and DTR based on contents of</div><div class='del'>- * serial_signals member of device extension.</div><div class='del'>- */</div><div class='del'>-static void set_signals(MGSLPC_INFO *info)</div><div class='del'>-{</div><div class='del'>-	unsigned char val;</div><div class='del'>-</div><div class='del'>-	val = read_reg(info, CHA + MODE);</div><div class='del'>-	if (info-&gt;params.mode == MGSL_MODE_ASYNC) {</div><div class='del'>-		if (info-&gt;serial_signals &amp; SerialSignal_RTS)</div><div class='del'>-			val &amp;= ~BIT6;</div><div class='del'>-		else</div><div class='del'>-			val |= BIT6;</div><div class='del'>-	} else {</div><div class='del'>-		if (info-&gt;serial_signals &amp; SerialSignal_RTS)</div><div class='del'>-			val |= BIT2;</div><div class='del'>-		else</div><div class='del'>-			val &amp;= ~BIT2;</div><div class='del'>-	}</div><div class='del'>-	write_reg(info, CHA + MODE, val);</div><div class='del'>-</div><div class='del'>-	if (info-&gt;serial_signals &amp; SerialSignal_DTR)</div><div class='del'>-		clear_reg_bits(info, CHA + PVR, PVR_DTR);</div><div class='del'>-	else</div><div class='del'>-		set_reg_bits(info, CHA + PVR, PVR_DTR);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void rx_reset_buffers(MGSLPC_INFO *info)</div><div class='del'>-{</div><div class='del'>-	RXBUF *buf;</div><div class='del'>-	int i;</div><div class='del'>-</div><div class='del'>-	info-&gt;rx_put = 0;</div><div class='del'>-	info-&gt;rx_get = 0;</div><div class='del'>-	info-&gt;rx_frame_count = 0;</div><div class='del'>-	for (i=0 ; i &lt; info-&gt;rx_buf_count ; i++) {</div><div class='del'>-		buf = (RXBUF*)(info-&gt;rx_buf + (i * info-&gt;rx_buf_size));</div><div class='del'>-		buf-&gt;status = buf-&gt;count = 0;</div><div class='del'>-	}</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* Attempt to return a received HDLC frame</div><div class='del'>- * Only frames received without errors are returned.</div><div class='del'>- *</div><div class='del'>- * Returns true if frame returned, otherwise false</div><div class='del'>- */</div><div class='del'>-static bool rx_get_frame(MGSLPC_INFO *info, struct tty_struct *tty)</div><div class='del'>-{</div><div class='del'>-	unsigned short status;</div><div class='del'>-	RXBUF *buf;</div><div class='del'>-	unsigned int framesize = 0;</div><div class='del'>-	unsigned long flags;</div><div class='del'>-	bool return_frame = false;</div><div class='del'>-</div><div class='del'>-	if (info-&gt;rx_frame_count == 0)</div><div class='del'>-		return false;</div><div class='del'>-</div><div class='del'>-	buf = (RXBUF*)(info-&gt;rx_buf + (info-&gt;rx_get * info-&gt;rx_buf_size));</div><div class='del'>-</div><div class='del'>-	status = buf-&gt;status;</div><div class='del'>-</div><div class='del'>-	/* 07  VFR  1=valid frame</div><div class='del'>-	 * 06  RDO  1=data overrun</div><div class='del'>-	 * 05  CRC  1=OK, 0=error</div><div class='del'>-	 * 04  RAB  1=frame aborted</div><div class='del'>-	 */</div><div class='del'>-	if ((status &amp; 0xf0) != 0xA0) {</div><div class='del'>-		if (!(status &amp; BIT7) || (status &amp; BIT4))</div><div class='del'>-			info-&gt;icount.rxabort++;</div><div class='del'>-		else if (status &amp; BIT6)</div><div class='del'>-			info-&gt;icount.rxover++;</div><div class='del'>-		else if (!(status &amp; BIT5)) {</div><div class='del'>-			info-&gt;icount.rxcrc++;</div><div class='del'>-			if (info-&gt;params.crc_type &amp; HDLC_CRC_RETURN_EX)</div><div class='del'>-				return_frame = true;</div><div class='del'>-		}</div><div class='del'>-		framesize = 0;</div><div class='del'>-#if SYNCLINK_GENERIC_HDLC</div><div class='del'>-		{</div><div class='del'>-			info-&gt;netdev-&gt;stats.rx_errors++;</div><div class='del'>-			info-&gt;netdev-&gt;stats.rx_frame_errors++;</div><div class='del'>-		}</div><div class='del'>-#endif</div><div class='del'>-	} else</div><div class='del'>-		return_frame = true;</div><div class='del'>-</div><div class='del'>-	if (return_frame)</div><div class='del'>-		framesize = buf-&gt;count;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_BH)</div><div class='del'>-		printk("%s(%d):rx_get_frame(%s) status=%04X size=%d\n",</div><div class='del'>-			__FILE__, __LINE__, info-&gt;device_name, status, framesize);</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_DATA)</div><div class='del'>-		trace_block(info, buf-&gt;data, framesize, 0);</div><div class='del'>-</div><div class='del'>-	if (framesize) {</div><div class='del'>-		if ((info-&gt;params.crc_type &amp; HDLC_CRC_RETURN_EX &amp;&amp;</div><div class='del'>-		      framesize+1 &gt; info-&gt;max_frame_size) ||</div><div class='del'>-		    framesize &gt; info-&gt;max_frame_size)</div><div class='del'>-			info-&gt;icount.rxlong++;</div><div class='del'>-		else {</div><div class='del'>-			if (status &amp; BIT5)</div><div class='del'>-				info-&gt;icount.rxok++;</div><div class='del'>-</div><div class='del'>-			if (info-&gt;params.crc_type &amp; HDLC_CRC_RETURN_EX) {</div><div class='del'>-				*(buf-&gt;data + framesize) = status &amp; BIT5 ? RX_OK:RX_CRC_ERROR;</div><div class='del'>-				++framesize;</div><div class='del'>-			}</div><div class='del'>-</div><div class='del'>-#if SYNCLINK_GENERIC_HDLC</div><div class='del'>-			if (info-&gt;netcount)</div><div class='del'>-				hdlcdev_rx(info, buf-&gt;data, framesize);</div><div class='del'>-			else</div><div class='del'>-#endif</div><div class='del'>-				ldisc_receive_buf(tty, buf-&gt;data, info-&gt;flag_buf, framesize);</div><div class='del'>-		}</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-	buf-&gt;status = buf-&gt;count = 0;</div><div class='del'>-	info-&gt;rx_frame_count--;</div><div class='del'>-	info-&gt;rx_get++;</div><div class='del'>-	if (info-&gt;rx_get &gt;= info-&gt;rx_buf_count)</div><div class='del'>-		info-&gt;rx_get = 0;</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-</div><div class='del'>-	return true;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static bool register_test(MGSLPC_INFO *info)</div><div class='del'>-{</div><div class='del'>-	static unsigned char patterns[] =</div><div class='del'>-	    { 0x00, 0xff, 0xaa, 0x55, 0x69, 0x96, 0x0f };</div><div class='del'>-	static unsigned int count = ARRAY_SIZE(patterns);</div><div class='del'>-	unsigned int i;</div><div class='del'>-	bool rc = true;</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-	reset_device(info);</div><div class='del'>-</div><div class='del'>-	for (i = 0; i &lt; count; i++) {</div><div class='del'>-		write_reg(info, XAD1, patterns[i]);</div><div class='del'>-		write_reg(info, XAD2, patterns[(i + 1) % count]);</div><div class='del'>-		if ((read_reg(info, XAD1) != patterns[i]) ||</div><div class='del'>-		    (read_reg(info, XAD2) != patterns[(i + 1) % count])) {</div><div class='del'>-			rc = false;</div><div class='del'>-			break;</div><div class='del'>-		}</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-	return rc;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static bool irq_test(MGSLPC_INFO *info)</div><div class='del'>-{</div><div class='del'>-	unsigned long end_time;</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-	reset_device(info);</div><div class='del'>-</div><div class='del'>-	info-&gt;testing_irq = true;</div><div class='del'>-	hdlc_mode(info);</div><div class='del'>-</div><div class='del'>-	info-&gt;irq_occurred = false;</div><div class='del'>-</div><div class='del'>-	/* init hdlc mode */</div><div class='del'>-</div><div class='del'>-	irq_enable(info, CHA, IRQ_TIMER);</div><div class='del'>-	write_reg(info, CHA + TIMR, 0);	/* 512 cycles */</div><div class='del'>-	issue_command(info, CHA, CMD_START_TIMER);</div><div class='del'>-</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-</div><div class='del'>-	end_time=100;</div><div class='del'>-	while(end_time-- &amp;&amp; !info-&gt;irq_occurred) {</div><div class='del'>-		msleep_interruptible(10);</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	info-&gt;testing_irq = false;</div><div class='del'>-</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-	reset_device(info);</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-</div><div class='del'>-	return info-&gt;irq_occurred;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static int adapter_test(MGSLPC_INFO *info)</div><div class='del'>-{</div><div class='del'>-	if (!register_test(info)) {</div><div class='del'>-		info-&gt;init_error = DiagStatus_AddressFailure;</div><div class='del'>-		printk("%s(%d):Register test failure for device %s Addr=%04X\n",</div><div class='del'>-			__FILE__, __LINE__, info-&gt;device_name, (unsigned short)(info-&gt;io_base));</div><div class='del'>-		return -ENODEV;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (!irq_test(info)) {</div><div class='del'>-		info-&gt;init_error = DiagStatus_IrqFailure;</div><div class='del'>-		printk("%s(%d):Interrupt test failure for device %s IRQ=%d\n",</div><div class='del'>-			__FILE__, __LINE__, info-&gt;device_name, (unsigned short)(info-&gt;irq_level));</div><div class='del'>-		return -ENODEV;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s(%d):device %s passed diagnostics\n",</div><div class='del'>-			__FILE__, __LINE__, info-&gt;device_name);</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static void trace_block(MGSLPC_INFO *info,const char* data, int count, int xmit)</div><div class='del'>-{</div><div class='del'>-	int i;</div><div class='del'>-	int linecount;</div><div class='del'>-	if (xmit)</div><div class='del'>-		printk("%s tx data:\n", info-&gt;device_name);</div><div class='del'>-	else</div><div class='del'>-		printk("%s rx data:\n", info-&gt;device_name);</div><div class='del'>-</div><div class='del'>-	while(count) {</div><div class='del'>-		if (count &gt; 16)</div><div class='del'>-			linecount = 16;</div><div class='del'>-		else</div><div class='del'>-			linecount = count;</div><div class='del'>-</div><div class='del'>-		for(i=0;i&lt;linecount;i++)</div><div class='del'>-			printk("%02X ", (unsigned char)data[i]);</div><div class='del'>-		for(;i&lt;17;i++)</div><div class='del'>-			printk("   ");</div><div class='del'>-		for(i=0;i&lt;linecount;i++) {</div><div class='del'>-			if (data[i]&gt;=040 &amp;&amp; data[i]&lt;=0176)</div><div class='del'>-				printk("%c", data[i]);</div><div class='del'>-			else</div><div class='del'>-				printk(".");</div><div class='del'>-		}</div><div class='del'>-		printk("\n");</div><div class='del'>-</div><div class='del'>-		data  += linecount;</div><div class='del'>-		count -= linecount;</div><div class='del'>-	}</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/* HDLC frame time out</div><div class='del'>- * update stats and do tx completion processing</div><div class='del'>- */</div><div class='del'>-static void tx_timeout(struct timer_list *t)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *info = from_timer(info, t, tx_timer);</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s(%d):tx_timeout(%s)\n",</div><div class='del'>-			__FILE__, __LINE__, info-&gt;device_name);</div><div class='del'>-	if (info-&gt;tx_active &amp;&amp;</div><div class='del'>-	    info-&gt;params.mode == MGSL_MODE_HDLC) {</div><div class='del'>-		info-&gt;icount.txtimeout++;</div><div class='del'>-	}</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-	info-&gt;tx_active = false;</div><div class='del'>-	info-&gt;tx_count = info-&gt;tx_put = info-&gt;tx_get = 0;</div><div class='del'>-</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-</div><div class='del'>-#if SYNCLINK_GENERIC_HDLC</div><div class='del'>-	if (info-&gt;netcount)</div><div class='del'>-		hdlcdev_tx_done(info);</div><div class='del'>-	else</div><div class='del'>-#endif</div><div class='del'>-	{</div><div class='del'>-		struct tty_struct *tty = tty_port_tty_get(&amp;info-&gt;port);</div><div class='del'>-		bh_transmit(info, tty);</div><div class='del'>-		tty_kref_put(tty);</div><div class='del'>-	}</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-#if SYNCLINK_GENERIC_HDLC</div><div class='del'>-</div><div class='del'>-/*</div><div class='del'>- * called by generic HDLC layer when protocol selected (PPP, frame relay, etc.)</div><div class='del'>- * set encoding and frame check sequence (FCS) options</div><div class='del'>- *</div><div class='del'>- * dev       pointer to network device structure</div><div class='del'>- * encoding  serial encoding setting</div><div class='del'>- * parity    FCS setting</div><div class='del'>- *</div><div class='del'>- * returns 0 if success, otherwise error code</div><div class='del'>- */</div><div class='del'>-static int hdlcdev_attach(struct net_device *dev, unsigned short encoding,</div><div class='del'>-			  unsigned short parity)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *info = dev_to_port(dev);</div><div class='del'>-	struct tty_struct *tty;</div><div class='del'>-	unsigned char  new_encoding;</div><div class='del'>-	unsigned short new_crctype;</div><div class='del'>-</div><div class='del'>-	/* return error if TTY interface open */</div><div class='del'>-	if (info-&gt;port.count)</div><div class='del'>-		return -EBUSY;</div><div class='del'>-</div><div class='del'>-	switch (encoding)</div><div class='del'>-	{</div><div class='del'>-	case ENCODING_NRZ:        new_encoding = HDLC_ENCODING_NRZ; break;</div><div class='del'>-	case ENCODING_NRZI:       new_encoding = HDLC_ENCODING_NRZI_SPACE; break;</div><div class='del'>-	case ENCODING_FM_MARK:    new_encoding = HDLC_ENCODING_BIPHASE_MARK; break;</div><div class='del'>-	case ENCODING_FM_SPACE:   new_encoding = HDLC_ENCODING_BIPHASE_SPACE; break;</div><div class='del'>-	case ENCODING_MANCHESTER: new_encoding = HDLC_ENCODING_BIPHASE_LEVEL; break;</div><div class='del'>-	default: return -EINVAL;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	switch (parity)</div><div class='del'>-	{</div><div class='del'>-	case PARITY_NONE:            new_crctype = HDLC_CRC_NONE; break;</div><div class='del'>-	case PARITY_CRC16_PR1_CCITT: new_crctype = HDLC_CRC_16_CCITT; break;</div><div class='del'>-	case PARITY_CRC32_PR1_CCITT: new_crctype = HDLC_CRC_32_CCITT; break;</div><div class='del'>-	default: return -EINVAL;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	info-&gt;params.encoding = new_encoding;</div><div class='del'>-	info-&gt;params.crc_type = new_crctype;</div><div class='del'>-</div><div class='del'>-	/* if network interface up, reprogram hardware */</div><div class='del'>-	if (info-&gt;netcount) {</div><div class='del'>-		tty = tty_port_tty_get(&amp;info-&gt;port);</div><div class='del'>-		mgslpc_program_hw(info, tty);</div><div class='del'>-		tty_kref_put(tty);</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/*</div><div class='del'>- * called by generic HDLC layer to send frame</div><div class='del'>- *</div><div class='del'>- * skb  socket buffer containing HDLC frame</div><div class='del'>- * dev  pointer to network device structure</div><div class='del'>- */</div><div class='del'>-static netdev_tx_t hdlcdev_xmit(struct sk_buff *skb,</div><div class='del'>-				      struct net_device *dev)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *info = dev_to_port(dev);</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk(KERN_INFO "%s:hdlc_xmit(%s)\n", __FILE__, dev-&gt;name);</div><div class='del'>-</div><div class='del'>-	/* stop sending until this frame completes */</div><div class='del'>-	netif_stop_queue(dev);</div><div class='del'>-</div><div class='del'>-	/* copy data to device buffers */</div><div class='del'>-	skb_copy_from_linear_data(skb, info-&gt;tx_buf, skb-&gt;len);</div><div class='del'>-	info-&gt;tx_get = 0;</div><div class='del'>-	info-&gt;tx_put = info-&gt;tx_count = skb-&gt;len;</div><div class='del'>-</div><div class='del'>-	/* update network statistics */</div><div class='del'>-	dev-&gt;stats.tx_packets++;</div><div class='del'>-	dev-&gt;stats.tx_bytes += skb-&gt;len;</div><div class='del'>-</div><div class='del'>-	/* done with socket buffer, so free it */</div><div class='del'>-	dev_kfree_skb(skb);</div><div class='del'>-</div><div class='del'>-	/* save start time for transmit timeout detection */</div><div class='del'>-	netif_trans_update(dev);</div><div class='del'>-</div><div class='del'>-	/* start hardware transmitter if necessary */</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-	if (!info-&gt;tx_active) {</div><div class='del'>-		struct tty_struct *tty = tty_port_tty_get(&amp;info-&gt;port);</div><div class='del'>-		tx_start(info, tty);</div><div class='del'>-		tty_kref_put(tty);</div><div class='del'>-	}</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-</div><div class='del'>-	return NETDEV_TX_OK;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/*</div><div class='del'>- * called by network layer when interface enabled</div><div class='del'>- * claim resources and initialize hardware</div><div class='del'>- *</div><div class='del'>- * dev  pointer to network device structure</div><div class='del'>- *</div><div class='del'>- * returns 0 if success, otherwise error code</div><div class='del'>- */</div><div class='del'>-static int hdlcdev_open(struct net_device *dev)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *info = dev_to_port(dev);</div><div class='del'>-	struct tty_struct *tty;</div><div class='del'>-	int rc;</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s:hdlcdev_open(%s)\n", __FILE__, dev-&gt;name);</div><div class='del'>-</div><div class='del'>-	/* generic HDLC layer open processing */</div><div class='del'>-	rc = hdlc_open(dev);</div><div class='del'>-	if (rc != 0)</div><div class='del'>-		return rc;</div><div class='del'>-</div><div class='del'>-	/* arbitrate between network and tty opens */</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;netlock, flags);</div><div class='del'>-	if (info-&gt;port.count != 0 || info-&gt;netcount != 0) {</div><div class='del'>-		printk(KERN_WARNING "%s: hdlc_open returning busy\n", dev-&gt;name);</div><div class='del'>-		spin_unlock_irqrestore(&amp;info-&gt;netlock, flags);</div><div class='del'>-		return -EBUSY;</div><div class='del'>-	}</div><div class='del'>-	info-&gt;netcount=1;</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;netlock, flags);</div><div class='del'>-</div><div class='del'>-	tty = tty_port_tty_get(&amp;info-&gt;port);</div><div class='del'>-	/* claim resources and init adapter */</div><div class='del'>-	rc = startup(info, tty);</div><div class='del'>-	if (rc != 0) {</div><div class='del'>-		tty_kref_put(tty);</div><div class='del'>-		spin_lock_irqsave(&amp;info-&gt;netlock, flags);</div><div class='del'>-		info-&gt;netcount=0;</div><div class='del'>-		spin_unlock_irqrestore(&amp;info-&gt;netlock, flags);</div><div class='del'>-		return rc;</div><div class='del'>-	}</div><div class='del'>-	/* assert RTS and DTR, apply hardware settings */</div><div class='del'>-	info-&gt;serial_signals |= SerialSignal_RTS | SerialSignal_DTR;</div><div class='del'>-	mgslpc_program_hw(info, tty);</div><div class='del'>-	tty_kref_put(tty);</div><div class='del'>-</div><div class='del'>-	/* enable network layer transmit */</div><div class='del'>-	netif_trans_update(dev);</div><div class='del'>-	netif_start_queue(dev);</div><div class='del'>-</div><div class='del'>-	/* inform generic HDLC layer of current DCD status */</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-	get_signals(info);</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-	if (info-&gt;serial_signals &amp; SerialSignal_DCD)</div><div class='del'>-		netif_carrier_on(dev);</div><div class='del'>-	else</div><div class='del'>-		netif_carrier_off(dev);</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/*</div><div class='del'>- * called by network layer when interface is disabled</div><div class='del'>- * shutdown hardware and release resources</div><div class='del'>- *</div><div class='del'>- * dev  pointer to network device structure</div><div class='del'>- *</div><div class='del'>- * returns 0 if success, otherwise error code</div><div class='del'>- */</div><div class='del'>-static int hdlcdev_close(struct net_device *dev)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *info = dev_to_port(dev);</div><div class='del'>-	struct tty_struct *tty = tty_port_tty_get(&amp;info-&gt;port);</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s:hdlcdev_close(%s)\n", __FILE__, dev-&gt;name);</div><div class='del'>-</div><div class='del'>-	netif_stop_queue(dev);</div><div class='del'>-</div><div class='del'>-	/* shutdown adapter and release resources */</div><div class='del'>-	shutdown(info, tty);</div><div class='del'>-	tty_kref_put(tty);</div><div class='del'>-	hdlc_close(dev);</div><div class='del'>-</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;netlock, flags);</div><div class='del'>-	info-&gt;netcount=0;</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;netlock, flags);</div><div class='del'>-</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/*</div><div class='del'>- * called by network layer to process IOCTL call to network device</div><div class='del'>- *</div><div class='del'>- * dev  pointer to network device structure</div><div class='del'>- * ifs  pointer to network interface settings structure</div><div class='del'>- *</div><div class='del'>- * returns 0 if success, otherwise error code</div><div class='del'>- */</div><div class='del'>-static int hdlcdev_wan_ioctl(struct net_device *dev, struct if_settings *ifs)</div><div class='del'>-{</div><div class='del'>-	const size_t size = sizeof(sync_serial_settings);</div><div class='del'>-	sync_serial_settings new_line;</div><div class='del'>-	sync_serial_settings __user *line = ifs-&gt;ifs_ifsu.sync;</div><div class='del'>-	MGSLPC_INFO *info = dev_to_port(dev);</div><div class='del'>-	unsigned int flags;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("%s:hdlcdev_ioctl(%s)\n", __FILE__, dev-&gt;name);</div><div class='del'>-</div><div class='del'>-	/* return error if TTY interface open */</div><div class='del'>-	if (info-&gt;port.count)</div><div class='del'>-		return -EBUSY;</div><div class='del'>-</div><div class='del'>-	memset(&amp;new_line, 0, size);</div><div class='del'>-</div><div class='del'>-	switch (ifs-&gt;type) {</div><div class='del'>-	case IF_GET_IFACE: /* return current sync_serial_settings */</div><div class='del'>-</div><div class='del'>-		ifs-&gt;type = IF_IFACE_SYNC_SERIAL;</div><div class='del'>-		if (ifs-&gt;size &lt; size) {</div><div class='del'>-			ifs-&gt;size = size; /* data size wanted */</div><div class='del'>-			return -ENOBUFS;</div><div class='del'>-		}</div><div class='del'>-</div><div class='del'>-		flags = info-&gt;params.flags &amp; (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_RXC_DPLL |</div><div class='del'>-					      HDLC_FLAG_RXC_BRG    | HDLC_FLAG_RXC_TXCPIN |</div><div class='del'>-					      HDLC_FLAG_TXC_TXCPIN | HDLC_FLAG_TXC_DPLL |</div><div class='del'>-					      HDLC_FLAG_TXC_BRG    | HDLC_FLAG_TXC_RXCPIN);</div><div class='del'>-</div><div class='del'>-		switch (flags){</div><div class='del'>-		case (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_TXCPIN): new_line.clock_type = CLOCK_EXT; break;</div><div class='del'>-		case (HDLC_FLAG_RXC_BRG    | HDLC_FLAG_TXC_BRG):    new_line.clock_type = CLOCK_INT; break;</div><div class='del'>-		case (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_BRG):    new_line.clock_type = CLOCK_TXINT; break;</div><div class='del'>-		case (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_RXCPIN): new_line.clock_type = CLOCK_TXFROMRX; break;</div><div class='del'>-		default: new_line.clock_type = CLOCK_DEFAULT;</div><div class='del'>-		}</div><div class='del'>-</div><div class='del'>-		new_line.clock_rate = info-&gt;params.clock_speed;</div><div class='del'>-		new_line.loopback   = info-&gt;params.loopback ? 1:0;</div><div class='del'>-</div><div class='del'>-		if (copy_to_user(line, &amp;new_line, size))</div><div class='del'>-			return -EFAULT;</div><div class='del'>-		return 0;</div><div class='del'>-</div><div class='del'>-	case IF_IFACE_SYNC_SERIAL: /* set sync_serial_settings */</div><div class='del'>-</div><div class='del'>-		if(!capable(CAP_NET_ADMIN))</div><div class='del'>-			return -EPERM;</div><div class='del'>-		if (copy_from_user(&amp;new_line, line, size))</div><div class='del'>-			return -EFAULT;</div><div class='del'>-</div><div class='del'>-		switch (new_line.clock_type)</div><div class='del'>-		{</div><div class='del'>-		case CLOCK_EXT:      flags = HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_TXCPIN; break;</div><div class='del'>-		case CLOCK_TXFROMRX: flags = HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_RXCPIN; break;</div><div class='del'>-		case CLOCK_INT:      flags = HDLC_FLAG_RXC_BRG    | HDLC_FLAG_TXC_BRG;    break;</div><div class='del'>-		case CLOCK_TXINT:    flags = HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_BRG;    break;</div><div class='del'>-		case CLOCK_DEFAULT:  flags = info-&gt;params.flags &amp;</div><div class='del'>-					     (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_RXC_DPLL |</div><div class='del'>-					      HDLC_FLAG_RXC_BRG    | HDLC_FLAG_RXC_TXCPIN |</div><div class='del'>-					      HDLC_FLAG_TXC_TXCPIN | HDLC_FLAG_TXC_DPLL |</div><div class='del'>-					      HDLC_FLAG_TXC_BRG    | HDLC_FLAG_TXC_RXCPIN); break;</div><div class='del'>-		default: return -EINVAL;</div><div class='del'>-		}</div><div class='del'>-</div><div class='del'>-		if (new_line.loopback != 0 &amp;&amp; new_line.loopback != 1)</div><div class='del'>-			return -EINVAL;</div><div class='del'>-</div><div class='del'>-		info-&gt;params.flags &amp;= ~(HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_RXC_DPLL |</div><div class='del'>-					HDLC_FLAG_RXC_BRG    | HDLC_FLAG_RXC_TXCPIN |</div><div class='del'>-					HDLC_FLAG_TXC_TXCPIN | HDLC_FLAG_TXC_DPLL |</div><div class='del'>-					HDLC_FLAG_TXC_BRG    | HDLC_FLAG_TXC_RXCPIN);</div><div class='del'>-		info-&gt;params.flags |= flags;</div><div class='del'>-</div><div class='del'>-		info-&gt;params.loopback = new_line.loopback;</div><div class='del'>-</div><div class='del'>-		if (flags &amp; (HDLC_FLAG_RXC_BRG | HDLC_FLAG_TXC_BRG))</div><div class='del'>-			info-&gt;params.clock_speed = new_line.clock_rate;</div><div class='del'>-		else</div><div class='del'>-			info-&gt;params.clock_speed = 0;</div><div class='del'>-</div><div class='del'>-		/* if network interface up, reprogram hardware */</div><div class='del'>-		if (info-&gt;netcount) {</div><div class='del'>-			struct tty_struct *tty = tty_port_tty_get(&amp;info-&gt;port);</div><div class='del'>-			mgslpc_program_hw(info, tty);</div><div class='del'>-			tty_kref_put(tty);</div><div class='del'>-		}</div><div class='del'>-		return 0;</div><div class='del'>-	default:</div><div class='del'>-		return hdlc_ioctl(dev, ifs);</div><div class='del'>-	}</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/*</div><div class='del'>- * called by network layer when transmit timeout is detected</div><div class='del'>- *</div><div class='del'>- * dev  pointer to network device structure</div><div class='del'>- */</div><div class='del'>-static void hdlcdev_tx_timeout(struct net_device *dev, unsigned int txqueue)</div><div class='del'>-{</div><div class='del'>-	MGSLPC_INFO *info = dev_to_port(dev);</div><div class='del'>-	unsigned long flags;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("hdlcdev_tx_timeout(%s)\n", dev-&gt;name);</div><div class='del'>-</div><div class='del'>-	dev-&gt;stats.tx_errors++;</div><div class='del'>-	dev-&gt;stats.tx_aborted_errors++;</div><div class='del'>-</div><div class='del'>-	spin_lock_irqsave(&amp;info-&gt;lock, flags);</div><div class='del'>-	tx_stop(info);</div><div class='del'>-	spin_unlock_irqrestore(&amp;info-&gt;lock, flags);</div><div class='del'>-</div><div class='del'>-	netif_wake_queue(dev);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/*</div><div class='del'>- * called by device driver when transmit completes</div><div class='del'>- * reenable network layer transmit if stopped</div><div class='del'>- *</div><div class='del'>- * info  pointer to device instance information</div><div class='del'>- */</div><div class='del'>-static void hdlcdev_tx_done(MGSLPC_INFO *info)</div><div class='del'>-{</div><div class='del'>-	if (netif_queue_stopped(info-&gt;netdev))</div><div class='del'>-		netif_wake_queue(info-&gt;netdev);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/*</div><div class='del'>- * called by device driver when frame received</div><div class='del'>- * pass frame to network layer</div><div class='del'>- *</div><div class='del'>- * info  pointer to device instance information</div><div class='del'>- * buf   pointer to buffer contianing frame data</div><div class='del'>- * size  count of data bytes in buf</div><div class='del'>- */</div><div class='del'>-static void hdlcdev_rx(MGSLPC_INFO *info, char *buf, int size)</div><div class='del'>-{</div><div class='del'>-	struct sk_buff *skb = dev_alloc_skb(size);</div><div class='del'>-	struct net_device *dev = info-&gt;netdev;</div><div class='del'>-</div><div class='del'>-	if (debug_level &gt;= DEBUG_LEVEL_INFO)</div><div class='del'>-		printk("hdlcdev_rx(%s)\n", dev-&gt;name);</div><div class='del'>-</div><div class='del'>-	if (skb == NULL) {</div><div class='del'>-		printk(KERN_NOTICE "%s: can't alloc skb, dropping packet\n", dev-&gt;name);</div><div class='del'>-		dev-&gt;stats.rx_dropped++;</div><div class='del'>-		return;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	skb_put_data(skb, buf, size);</div><div class='del'>-</div><div class='del'>-	skb-&gt;protocol = hdlc_type_trans(skb, dev);</div><div class='del'>-</div><div class='del'>-	dev-&gt;stats.rx_packets++;</div><div class='del'>-	dev-&gt;stats.rx_bytes += size;</div><div class='del'>-</div><div class='del'>-	netif_rx(skb);</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-static const struct net_device_ops hdlcdev_ops = {</div><div class='del'>-	.ndo_open       = hdlcdev_open,</div><div class='del'>-	.ndo_stop       = hdlcdev_close,</div><div class='del'>-	.ndo_start_xmit = hdlc_start_xmit,</div><div class='del'>-	.ndo_siocwandev = hdlcdev_wan_ioctl,</div><div class='del'>-	.ndo_tx_timeout = hdlcdev_tx_timeout,</div><div class='del'>-};</div><div class='del'>-</div><div class='del'>-/*</div><div class='del'>- * called by device driver when adding device instance</div><div class='del'>- * do generic HDLC initialization</div><div class='del'>- *</div><div class='del'>- * info  pointer to device instance information</div><div class='del'>- *</div><div class='del'>- * returns 0 if success, otherwise error code</div><div class='del'>- */</div><div class='del'>-static int hdlcdev_init(MGSLPC_INFO *info)</div><div class='del'>-{</div><div class='del'>-	int rc;</div><div class='del'>-	struct net_device *dev;</div><div class='del'>-	hdlc_device *hdlc;</div><div class='del'>-</div><div class='del'>-	/* allocate and initialize network and HDLC layer objects */</div><div class='del'>-</div><div class='del'>-	dev = alloc_hdlcdev(info);</div><div class='del'>-	if (dev == NULL) {</div><div class='del'>-		printk(KERN_ERR "%s:hdlc device allocation failure\n", __FILE__);</div><div class='del'>-		return -ENOMEM;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	/* for network layer reporting purposes only */</div><div class='del'>-	dev-&gt;base_addr = info-&gt;io_base;</div><div class='del'>-	dev-&gt;irq       = info-&gt;irq_level;</div><div class='del'>-</div><div class='del'>-	/* network layer callbacks and settings */</div><div class='del'>-	dev-&gt;netdev_ops	    = &amp;hdlcdev_ops;</div><div class='del'>-	dev-&gt;watchdog_timeo = 10 * HZ;</div><div class='del'>-	dev-&gt;tx_queue_len   = 50;</div><div class='del'>-</div><div class='del'>-	/* generic HDLC layer callbacks and settings */</div><div class='del'>-	hdlc         = dev_to_hdlc(dev);</div><div class='del'>-	hdlc-&gt;attach = hdlcdev_attach;</div><div class='del'>-	hdlc-&gt;xmit   = hdlcdev_xmit;</div><div class='del'>-</div><div class='del'>-	/* register objects with HDLC layer */</div><div class='del'>-	rc = register_hdlc_device(dev);</div><div class='del'>-	if (rc) {</div><div class='del'>-		printk(KERN_WARNING "%s:unable to register hdlc device\n", __FILE__);</div><div class='del'>-		free_netdev(dev);</div><div class='del'>-		return rc;</div><div class='del'>-	}</div><div class='del'>-</div><div class='del'>-	info-&gt;netdev = dev;</div><div class='del'>-	return 0;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-/*</div><div class='del'>- * called by device driver when removing device instance</div><div class='del'>- * do generic HDLC cleanup</div><div class='del'>- *</div><div class='del'>- * info  pointer to device instance information</div><div class='del'>- */</div><div class='del'>-static void hdlcdev_exit(MGSLPC_INFO *info)</div><div class='del'>-{</div><div class='del'>-	unregister_hdlc_device(info-&gt;netdev);</div><div class='del'>-	free_netdev(info-&gt;netdev);</div><div class='del'>-	info-&gt;netdev = NULL;</div><div class='del'>-}</div><div class='del'>-</div><div class='del'>-#endif /* CONFIG_HDLC */</div><div class='del'>-</div><div class='head'>diff --git a/include/linux/cm4000_cs.h b/include/linux/cm4000_cs.h<br/>deleted file mode 100644<br/>index ea4958e07a14a0..00000000000000<br/>--- a/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/cm4000_cs.h?id=3996954fa071aa20945c8ac7694684fa3c1fed68'>include/linux/cm4000_cs.h</a><br/>+++ /dev/null</div><div class='hunk'>@@ -1,11 +0,0 @@</div><div class='del'>-/* SPDX-License-Identifier: GPL-2.0 */</div><div class='del'>-#ifndef	_CM4000_H_</div><div class='del'>-#define	_CM4000_H_</div><div class='del'>-</div><div class='del'>-#include &lt;uapi/linux/cm4000_cs.h&gt;</div><div class='del'>-</div><div class='del'>-</div><div class='del'>-#define	DEVICE_NAME		"cmm"</div><div class='del'>-#define	MODULE_NAME		"cm4000_cs"</div><div class='del'>-</div><div class='del'>-#endif	/* _CM4000_H_ */</div><div class='head'>diff --git a/include/uapi/linux/cm4000_cs.h b/include/uapi/linux/cm4000_cs.h<br/>deleted file mode 100644<br/>index c70a62ec8a49ac..00000000000000<br/>--- a/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/cm4000_cs.h?id=3996954fa071aa20945c8ac7694684fa3c1fed68'>include/uapi/linux/cm4000_cs.h</a><br/>+++ /dev/null</div><div class='hunk'>@@ -1,64 +0,0 @@</div><div class='del'>-/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */</div><div class='del'>-#ifndef _UAPI_CM4000_H_</div><div class='del'>-#define _UAPI_CM4000_H_</div><div class='del'>-</div><div class='del'>-#include &lt;linux/types.h&gt;</div><div class='del'>-#include &lt;linux/ioctl.h&gt;</div><div class='del'>-</div><div class='del'>-#define	MAX_ATR			33</div><div class='del'>-</div><div class='del'>-#define	CM4000_MAX_DEV		4</div><div class='del'>-</div><div class='del'>-/* those two structures are passed via ioctl() from/to userspace.  They are</div><div class='del'>- * used by existing userspace programs, so I kepth the awkward "bIFSD" naming</div><div class='del'>- * not to break compilation of userspace apps. -HW */</div><div class='del'>-</div><div class='del'>-typedef struct atreq {</div><div class='del'>-	__s32 atr_len;</div><div class='del'>-	unsigned char atr[64];</div><div class='del'>-	__s32 power_act;</div><div class='del'>-	unsigned char bIFSD;</div><div class='del'>-	unsigned char bIFSC;</div><div class='del'>-} atreq_t;</div><div class='del'>-</div><div class='del'>-</div><div class='del'>-/* what is particularly stupid in the original driver is the arch-dependent</div><div class='del'>- * member sizes. This leads to CONFIG_COMPAT breakage, since 32bit userspace</div><div class='del'>- * will lay out the structure members differently than the 64bit kernel.</div><div class='del'>- *</div><div class='del'>- * I've changed "ptsreq.protocol" from "unsigned long" to "__u32".</div><div class='del'>- * On 32bit this will make no difference.  With 64bit kernels, it will make</div><div class='del'>- * 32bit apps work, too.</div><div class='del'>- */</div><div class='del'>-</div><div class='del'>-typedef struct ptsreq {</div><div class='del'>-	__u32 protocol; /*T=0: 2^0, T=1:  2^1*/</div><div class='del'>- 	unsigned char flags;</div><div class='del'>- 	unsigned char pts1;</div><div class='del'>- 	unsigned char pts2;</div><div class='del'>-	unsigned char pts3;</div><div class='del'>-} ptsreq_t;</div><div class='del'>-</div><div class='del'>-#define	CM_IOC_MAGIC		'c'</div><div class='del'>-#define	CM_IOC_MAXNR	        255</div><div class='del'>-</div><div class='del'>-#define	CM_IOCGSTATUS		_IOR (CM_IOC_MAGIC, 0, unsigned char *)</div><div class='del'>-#define	CM_IOCGATR		_IOWR(CM_IOC_MAGIC, 1, atreq_t *)</div><div class='del'>-#define	CM_IOCSPTS		_IOW (CM_IOC_MAGIC, 2, ptsreq_t *)</div><div class='del'>-#define	CM_IOCSRDR		_IO  (CM_IOC_MAGIC, 3)</div><div class='del'>-#define CM_IOCARDOFF            _IO  (CM_IOC_MAGIC, 4)</div><div class='del'>-</div><div class='del'>-#define CM_IOSDBGLVL            _IOW(CM_IOC_MAGIC, 250, int*)</div><div class='del'>-</div><div class='del'>-/* card and device states */</div><div class='del'>-#define	CM_CARD_INSERTED		0x01</div><div class='del'>-#define	CM_CARD_POWERED			0x02</div><div class='del'>-#define	CM_ATR_PRESENT			0x04</div><div class='del'>-#define	CM_ATR_VALID	 		0x08</div><div class='del'>-#define	CM_STATE_VALID			0x0f</div><div class='del'>-/* extra info only from CM4000 */</div><div class='del'>-#define	CM_NO_READER			0x10</div><div class='del'>-#define	CM_BAD_CARD			0x20</div><div class='del'>-</div><div class='del'>-</div><div class='del'>-#endif /* _UAPI_CM4000_H_ */</div></td></tr></table></div> <!-- class=content -->
<div class='footer'>generated by <a href='https://git.zx2c4.com/cgit/about/'>cgit 1.2.3-korg</a> (<a href='https://git-scm.com/'>git 2.43.0</a>) at 2025-01-05 18:34:25 +0000</div>
</div> <!-- id=cgit -->
</body>
</html>
