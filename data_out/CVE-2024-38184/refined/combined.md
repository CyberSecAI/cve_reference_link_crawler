=== Content from msrc.microsoft.com_a5d3b251_20250111_102553.html ===
You need to enable JavaScript to run this app.

=== Content from massgrave.dev_fa95e88d_20250111_102553.html ===

[Skip to main content](#__docusaurus_skipToContent_fallback)[![MAS](/img/logo.png)![MAS](/img/logo.png)**MAS**](/)[FAQ](/faq)[Troubleshoot](/troubleshoot)[Download Windows / Office](/genuine-installation-media)[Credits](/credits)More

* [Docs](/hwid)
* [Guides](/guide_links)
* [Unsupported Products Activation](/unsupported_products_activation)
* [News](/news)
* [MAS Changelog](/changelog)
* [Our Non-Piracy Site](/our_non-piracy_site)
[Blog](/blog)[Contact Us](/contactus)[Discord](https://discord.gg/j2yFsV5ZVC "Chat with us on Discord")[GitHub](https://github.com/massgravel/Microsoft-Activation-Scripts "GitHub repository")Recent posts
### 2024

* [Keyhole](/blog/keyhole)
# Keyhole

September 6, 2024 · 10 min read[![WitherOrNot](https://avatars.githubusercontent.com/u/26913821)](/blog/authors/witherornot)[WitherOrNot](/blog/authors/witherornot)Researcher @ MASSGRAVE[![May](https://avatars.githubusercontent.com/u/112294121)](/blog/authors/may)[May](/blog/authors/may)Researcher @ MASSGRAVE

By WitherOrNot

Edited by May, Lyssa, & SpCreatePackaedLicense

## Introduction[​](#introduction "Direct link to Introduction")

In our ongoing work to bypass Windows licensing checks, we occasionally stumble upon bugs that we choose to keep secret. This decision allows us to preserve potential future activation methods by avoiding bug fixes, while also giving us valuable tools for testing or developing new methods.

One such discovery, which we've named "Keyhole", turned out to be a highly effective DRM bypass. It gave users the ability to license any Microsoft Store app or any modern Windows edition with ease.

Following the disclosure of [CVE-2024-38184](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-38184) by [Cisco TALOS](https://talosintelligence.com), we have decided to share our findings on Keyhole, which we independently uncovered around the same time it was reported to Microsoft.

## CLiP[​](#clip "Direct link to CLiP")

To understand this exploit, we must first understand CLiP, the Client Licensing Platform. This system was introduced with Windows 10, primarily as a way to implement DRM for Microsoft Store apps, and integrated with Windows activation, allowing users to buy digital licenses for Windows on the Microsoft Store.

CLiP is comprised of a few different main binaries within Windows:

* `clipup.exe` - Migrates (converts) Windows 8 store licenses, genuine tickets, and product keys to digital licenses
* `clipsvc.dll` - User-mode service responsible for managing app licenses
* `clipc.dll` - API used by applications to interact with CLiP
* `clipwinrt.dll` - Similar to `clipc.dll` but for UWP applications utilizing [Windows Runtime](https://learn.microsoft.com/en-us/windows/uwp/winrt-components).
* `clipsp.sys` - Kernel-mode driver responsible for verifying licenses

![clip diagram](/assets/images/clip_diagram-124f75d6f71b6c2618a27c1cff2b2e8d.png)

Whenever a CLiP-licensed app is installed, a signed XML file containing the license information is sent to `clipsvc.dll`; once the XML signature is verified, the XML data is stored in ClipSVC's "token store" at `%PROGRAMDATA%\Microsoft\Windows\ClipSVC\tokens.dat`.

The signed license block is then extracted from the `SPLicenseBlock` tag and sent to `clipsp.sys` for verification. After verification, the license block is deposited in the CLiP license store at `HKLM\SYSTEM\CurrentControlSet\Control\{7746D80F-97E0-4E26-9543-26B41FC22F79}`. From there, `clipsp.sys` can then re-validate the license in the future if an app requests it using the CLiP API.

note

The CLiP license store mentioned earlier is protected so that you can't view it by default, but changing the permissions to allow yourself access is very easy.

As designed, this system forms a rather strong chain-of-trust that transmits only signed data from usermode applications all the way to the kernel, making it seemingly difficult to tamper with. As we will see soon, however, this is not at all the case.

## A Little Trolling[​](#a-little-trolling "Direct link to A Little Trolling")

So far, one binary failed to receive any mention: `clipup.exe`. This is because it isn't notable when talking about Keyhole itself. However, it holds the key to messing with CLiP:

![ecc key](/assets/images/ecc_key-43ee857b98419c2aac40f465586832e7.png)

Yes, literally. A valid ECDSA key to sign XML licenses is stored in unobfuscated form, allowing anyone to very easily sign or resign XML licenses. This key is normally meant to sign temporary licenses sent to the Microsoft store to get digital licenses, but ClipSvc will happily accept it for app licenses as well.

This allows us to bypass ClipSvc's gatekeeping and effectively send any license blocks we want straight to ClipSp. With this, we entirely bypass the usermode level of the chain-of-trust, and now all that's left is to try and trick ClipSp.

## Unpacking ClipSp[​](#unpacking-clipsp "Direct link to Unpacking ClipSp")

ClipSp, from our analysis, is not a very well-written driver. It's full of copy-pasted code (from where will be shown soon), and seems to be rife with odd choices and compromises. In other words, it's a perfect environment for someone looking for a bypass. There's only one big issue: most of the interesting driver code is hidden using Microsoft's proprietary obfuscator, known as Warbird. In order to find and understand it, we need to "unpack" it, a.k.a. undoing the obfuscation. Luckily, this is rather straightforward thanks to some symbols for `clipsp.sys` that were available on Microsoft's servers.

Similar to how Warbird works [in user-mode programs](https://github.com/WitherOrNot/warbird-docs), ClipSp wraps any calls to obfuscated code with an decryption and encryption function, as shown below:

![feistel wrapper](/assets/images/encrypt_decrypt-941f0cf561633d143866fd7d085b6405.png)

So, if we can manually run these decryption functions, we could access all of the hidden code. Luckily, this is quite simple to do based on a method [by KiFilterFiberContext](https://github.com/KiFilterFiberContext/windows-software-policy), and with it, we are now able to finally find some bugs.

## License Blocks[​](#license-blocks "Direct link to License Blocks")

License blocks, mentioned previously, are what actually hold the important license information in CLiP. Their format is [well-documented](https://github.com/LukeFZ/CikExtractor) and can store many kinds of data, so we figured they were a good place to start looking for bugs.

License blocks hold their data in a tag-length-value (TLV) format, where several smaller blocks are stored together with each holding values for their data type, the length of their data, and the data itself. For example, the TLV block highlighted below has a type of `0xC9` (License Information), a length of `0xA` (10 bytes), and 10 bytes of data.

![splicenseblock tlv](data:image/png;base64...)

At the very end of a license block, there will always be a signature block, with a type of `0xCC`. This block holds the signature of all the data before it, as well as indicating which key it was signed with. And of course, since it sits after all the data being signed, there's no way to alter any of it... right?

## A Lot of Trolling[​](#a-lot-of-trolling "Direct link to A Lot of Trolling")

In the middle of experimenting with this data format, one of our members, May, had a very simple question. If the signature block signs all the data before it, what happens to the data put after it?

![image](/assets/images/test_keyhole-2019266318a4eb86944de946d449f117.png)

Above, you can see a license block for Minecraft Bedrock edition with some new data placed after it (highlighted), containing blocks copied from a Windows license. What happens if we try to install such a license?

![enterprise ltsc digital activation](/assets/images/enterprises_diglic-f46c1d1c87abacc52449035c1d5b6bce.png)

As it turns out, data after the signature block isnt checked at all... and it can even override data that came before it. Whenever two blocks of the same type are stored together, the last one overrides all the others before it. So, if we want to change any license data, we can just make a block for it and put it after the signature block!

This method lets us make licenses for anything sold on the Microsoft Store, including Windows, from any other Microsoft Store license. And since there are so many free apps with licenses, we now had the ability to make as many as we wanted for whatever we wanted. This bug essentially punched a hole straight through CLiP's DRM, so we decided to name it "Keyhole".

There is only one catch: licenses that are bound to a specific device, known as "device-locked" licenses, cannot be made from device-unlocked licenses. Since Windows digital licenses are device-locked, this meant that we needed to make them from device-locked app licenses. Luckily, many apps, including games like Roblox fit this criteria.

## Trolling Tutorial[​](#trolling-tutorial "Direct link to Trolling Tutorial")

The steps to make any Windows license you want were now dead simple. First, install an app with a device-locked license, like Roblox.

![roblox](/assets/images/step1-d16bf8fd25e622e3c3f7c9d98b3ba682.png)

Then, using a HTTPS traffic capture tool like Fiddler, intercept the license that comes from `https://licensing.mp.microsoft.com/v7.0/licenses/content`.

![fiddler](/assets/images/step2-fdf396c3c0528430845848d9fec4c090.png)

Decode the license, then extract its license block.

![license block](/assets/images/step3-4bb684ab245e953171794fc3f802e376.png)

Now, add whatever new data you need to make a new license.

![add keyholed data](/assets/images/step4-8dac9be000691c68505b8960c3efbb09.png)

Then, we just package our license block into a new XML file, sign the XML, and copy it into the folder `C:\ProgramData\Microsoft\Windows\ClipSVC\Install\Migration`.

![license in migration folder](/assets/images/step5-bba94dcf5da9eb06aacb8b9e4c193903.png)

Finally, we get ClipSvc to install our license, either by restarting it, or with the command `clipup -p`.

![clipup -p in cmd](/assets/images/step6-163e0d042791c144913521165dbdfe1b.png)

When we check our activation status, Windows is now permanently activated.

![server is digitally licensed](/assets/images/step7-1e7033378f98b575327e12a8b1d02f63.png)

With this, we were able to do things that were previously impossible, like activating Enterprise LTSC with a digital license, or even activating a legitimate KMS server with a generic key:

![26100 kms server](/assets/images/trivial-f8da32c89ba8c4cbc9e0e8f84a31d851.png)

From here, it's pretty easy to see that this simple bug completely annihilates CLiP's DRM system.

## Buzzkill[​](#buzzkill "Direct link to Buzzkill")

Having found this bug, we were quite happy that CLiP was now effectively dead. This happiness didn't last very long, though, as we recently found a [vulnerability report](https://talosintelligence.com/vulnerability_reports/TALOS-2024-1964) from Cisco TALOS that reported this exact bug. It was reported to Microsoft on April 8, right around when we first found it.

![keyhole discovery](/assets/images/kh_discovery-0289794fa2639c8751f8df4470f2102f.png)

This raises a question though: why was a DRM bug reported as a security vulnerability? At first, CLiP licenses don't seem to have anything to do with exploitation, which caused us to think the bug had been reported for no reason other than to fix Microsoft's DRM. However, Keyhole can be used as an entry point for [more serious bugs in ClipSp](https://talosintelligence.com/vulnerability_reports/TALOS-2024-1988), which prompted TALOS to make it part of their disclosure.

As for the fix itself, it's rather straightforward. As shown below, the current license block parser code immediately exits after encountering a signature block. This prevents it from processing blocks after the signature, completely patching Keyhole.

![keyhole fix](/assets/images/keyhole_fix-699ab276d7662fda612e611e42894193.png)

## Giving Season[​](#giving-season "Direct link to Giving Season")

After mourning the loss of our beloved exploit, we decided that it would only be fair to publicize our own discoveries on CLiP. So, we've released the code to [generate Keyhole licenses](https://github.com/massgravel/keyhole) and our [collection of CLiP binaries](https://archive.org/details/clipwinrt) with symbols for easier analysis. We invite you to go forth and discover more funny things in CLiP! (and [report them to us](https://massgrave.dev/contactus) instead of MS)

## And now, for something different[​](#and-now-for-something-different "Direct link to And now, for something different")

I mentioned that ClipSp's buggy code was copy-pasted, but from where? Well, the "SP" part just happens to reference a certain Microsoft game console: the Xbox One!

The Xbox One contains a chip known as the SP, or "secure processor", based on the TPMs in modern PCs. The main job of the SP is to enforce code signing, but it also handles license verification. During our research on Keyhole, we found many associations between CLiP and the Xbox One, and began wondering how they were actually related. While looking through some leaked source code, we stumbled upon this:

![ValidateLicensePolicy](/assets/images/validatelicensepolicy-ae997c165c03ff0203bf19f92f98a85b.png)

Well, this looks oddly familiar...

![keyhole bug in source code](/assets/images/src_bug-0e67719f2983a3bbd97d72a0feaf2e26.png)

And there's the same bug that's in CLiP, but in Xbox code. In fact, we weren't too surprised to find this, as we found that almost all of CLiP, from the XML format of the licenses to the TLV-based license blocks, is mostly copy-pasted straight from the Xbox One's DRM system.

note

While the Xbox SP contains the same parsing bug as in ClipSp, it parses data blocks and signature-related blocks separately. As a result, Keyhole will not work on the Xbox.

So, to those with a console that's been [collaterally damaged](https://github.com/exploits-forsale/collateral-damage), I wonder what happens if you mess with those funny-looking XML files in `S:\clip` ;)

## Credits[​](#credits "Direct link to Credits")

The research covered in this blogpost was made possible by the following people/groups:

* May - Initial discovery, testing, reverse engineering
* asdcorp - Testing, reverse engineering
* SpCreatePackaedLicense - Testing, reverse engineering, bugfix analysis
* WitherOrNot - Tool development, testing, reverse engineering, bugfix analysis
* emoose, LukeFZ - License Block format documentation
* KiFilterFiberContext - ClipSp unpacking
* Phillippe Laulheret, Cisco TALOS - Inspiring this publication, clearing up misconceptions
* Rairii - Additional info
**Tags:**

* [Windows](/blog/tags/windows)
* [Activation](/blog/tags/activation)
[Edit this page](https://github.com/massgravel/massgrave.dev/tree/main/blog/2024-09-06-Keyhole/index.md)

* [Introduction](#introduction)
* [CLiP](#clip)
* [A Little Trolling](#a-little-trolling)
* [Unpacking ClipSp](#unpacking-clipsp)
* [License Blocks](#license-blocks)
* [A Lot of Trolling](#a-lot-of-trolling)
* [Trolling Tutorial](#trolling-tutorial)
* [Buzzkill](#buzzkill)
* [Giving Season](#giving-season)
* [And now, for something different](#and-now-for-something-different)
* [Credits](#credits)



=== Content from www.talosintelligence.com_637291b6_20250111_102554.html ===


* [Cisco Login](/users/auth/saml)

* [Intelligence Center](/reputation)

  + [# Intelligence Center](/reputation)
  + BACK
  + [Intelligence Search](/reputation_center)
  + [Email & Spam Trends](/reputation_center/email_rep)
* [Vulnerability Research](/vulnerability_info)

  + [# Vulnerability Research](/vulnerability_info)
  + BACK
  + [Vulnerability Reports](/vulnerability_reports)
  + [Microsoft Advisories](/ms_advisories)
* [Incident Response](/incident_response)

  + [# Incident Response](/incident_response)
  + BACK
  + [Reactive Services](/incident_response/services#reactive-services)
  + [Proactive Services](/incident_response/services#proactive-services)
  + Emergency Support
* [Blog](https://blog.talosintelligence.com)
* [Support](https://support.talosintelligence.com)

More

* Security Resources

  # Security Resources

  + BACK
  Security Resources
  + [Open Source Security Tools](/software)
  + [Intelligence Categories Reference](/categories)
  + [Secure Endpoint Naming Reference](/secure-endpoint-naming)
* Media

  # Media

  + BACK
  Media
  + [Talos Intelligence Blog](https://blog.talosintelligence.com)
  + [Threat Source Newsletter](https://blog.talosintelligence.com/category/threat-source-newsletter/)
  + [Beers with Talos Podcast](/podcasts/shows/beers_with_talos)
  + [Talos Takes Podcast](/podcasts/shows/talos_takes)
  + [Talos Videos](https://www.youtube.com/channel/UCPZ1DtzQkStYBSG3GTNoyfg/featured)
* Company

  # Company

  + BACK
  Company
  + [About Talos](/about)
  + [Careers](/careers)

* Under Attack?
* [Cisco Login](/users/auth/saml)

## Contact Cisco Talos Incident Response

×

Close

This form is for Incident Response service inquiries only, including emergency network security needs.

For reputation or categorization inquiries, visit the [Talos Support site](/support).
For emergency DDoS mitigation assistance, please contact the [Cisco Secure DDoS Protection Team](https://www.cisco.com/c/en/us/products/collateral/security/ddos-emergency-attack-mitigation-aag.pdf).

Name

Company (optional)

Email address

Phone number

Preferred communication:

Email

Phone

What Incident Response Service are you interested in?
General Talos IR services and retainer information
Emergency Response
IR Plan
IR Playbooks
IR Readiness Assessment
Tabletop Exercises
Compromise Assessment
Threat Hunting
Cyber Range Training
Intelligence on Demand

Please provide as much detail as possible so we can best address your needs

I acknowledge that this is an inquiry for Incident Response services and that any other use of this form will not receive a response.

Send Email
Cancel

# Talos Vulnerability Report

### TALOS-2024-1964

## Microsoft CLIPSP.SYS License update signature check bypass vulnerability

##### August 13, 2024

##### CVE Number

CVE-2024-38184

##### SUMMARY

A signature check bypass vulnerability exists in the License update functionality of Microsoft CLIPSP.SYS 10.0.22621 Build 22621, 10.0.26080.1 and 10.0.26085.1. A specially crafted license blob can lead to license tampering. An attacker can use the NtQuerySystemInformation function call to trigger this vulnerability.

##### CONFIRMED VULNERABLE VERSIONS

The versions below were either tested or verified to be vulnerable by Talos or confirmed to be vulnerable by the vendor.

Microsoft CLIPSP.SYS 10.0.22621 Build 22621

Microsoft CLIPSP.SYS 10.0.26080.1

Microsoft CLIPSP.SYS 10.0.26085.1

##### PRODUCT URLS

CLIPSP.SYS - <https://www.microsoft.com/en-us/windows/windows-11>

##### CVSSv3 SCORE

6.2 - CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N

##### CWE

CWE-349 - Acceptance of Extraneous Untrusted Data With Trusted Data

##### DETAILS

CLIPSP.SYS is a driver used to implement Client License System Policy on Windows 10 and 11. It provides the functions used when handling most of the requests involving licensing, notably the implementation of many use cases involved with the SystemPolicyInformation class used in conjunction with NtQuerySystemInformation.

## Context

When calling `NtQuerySystemInformation` with the `SystemPolicyInformation` class, `ntoskrnl` will call `ExHandleSPCall2` that will process the data provided. The format is mostly undocumented and encrypted using Microsoft’s Warbird. Upon decryption of the data provided, a call handler is invoked based on the `command_id` provided and dispatches the payload to the relevant function (e.g. `SPCallServerHandleClepKdf`, `SPCallServerHandleUpdateLicense`, etc.). A substential amount of these functions are wrapers around `clipsp` functions that are stored as function pointers in the `nt!g_kernelCallbacks` globlal array.

The `SPCallServerHandleUpdateLicense` (`command_id`:100) will accept a License blob whose format is also undocumented. Once installed, these license files are stored in the `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\{7746D80F-97E0-4E26-9543-26B41FC22F79}\{A25AE4F2-1B96-4CED-8007-AA30E9B1A218}` key, only accessible to the SYSTEM user.
The format of this license file is TLV (Tag-length-value) following this format:

`
struct \_\_unaligned \_\_declspec(align(1)) LicenseParsing\_entry
{
\_\_int16 type;
\_\_int16 reserved;
int entry\_size;
char value[ANYSIZE\_ARRAY]; //expected to be of size entry\_size
};
`

## The vulnerability

The code snippet below are decompiled output and variables names were assumed from context or retrieved from public symbol servers, sdk, etc.
The addresses provided are for the canary build `26085.1.amd64fre.ge_release.240315-1352`

When calling `SPCallServerHandleUpdateLicense` the data will eventually be past to an obfuscated function inside `clipsp` that is responsible for parsing the license blob, and does the following (see 0x1C00E8AC4):

```
   while ( 1 )
    {
      v10 = (LicenseParsing_entry *)&LicenseData[v7];
      entry_size = v10->entry_size;
      if ( entry_size >= 0xFFFFF || v7 + entry_size > LicenseDataSize )
        return (unsigned int)STATUS_INVALID_PARAMETER;
      status = license_validate_entry((LicenseParsing_entry *)&LicenseData[v7], LicenseDataSize - v7);
      if ( (status & 0x80000000) != 0 )         // bad
        return status;
      v12 = license_convert_type((unsigned __int16)v10->type);// 0xce -> type 14 -> pfn
      if ( v12 < 25 )
      {
        v13 = v12;
[6]     License->field_0[v13].entry_size = v10->entry_size;
        License->field_0[v13].entry_field2 = v10->field_2;
        License->field_0[v13].entry_ptr = (__int64)&v10->first_byte;
[0]     if ( v12 == 24 )                        // type 0xCC
          break;
      }
      v7 += 8;
      if ( v12 )                                // not case 0 (aka 0x14 in license file)
        goto LABEL_10;
LABEL_11:
      if ( v7 >= (unsigned __int64)LicenseDataSize - 8 )
        return status;
    }
    License->LicenseData_ = (__int64)LicenseData;
[1] License->entry_of_type_24 = (__int64)v10;
    ExFreePoolWithTag_noTag(0i64);
    status = 0;
    v7 += 8;
LABEL_10:
    v7 += v10->entry_size;
[5] goto LABEL_11;
  }

```

We can see that at [0], if a type 0xCC (24 in the internal representation of ClipSp) is encountered, the loop is exited temporarily, and a pointer to the current entry is saved at [1] in a global structure. It is then used during signature verification, as such (See address 0x01C00EA22B):

```
  sig_len = LicenseStruct_get_some_size_for_type24(License);
  sig_data = (unsigned __int8 *)LicenseStruct_get_some_ptr_for_type24(License);
  status_ = License_validate_signature(
              context->alg_SHA256,
              hKey,
              bcryptFlags,
[2]           (UCHAR *)License->LicenseData_,
[3]           LODWORD(License->entry_of_type_24) - LODWORD(License->LicenseData_),
              &extra_data_array,
              UNUSED_ARG(),
              sig_data,
              sig_len);

```

Which does the following:

```
__int64 __fastcall License_validate_signature(
        BCRYPT_ALG_HANDLE hAlgorithm,
        BCRYPT_KEY_HANDLE hKey,
        ULONG bcryptFlags,
        UCHAR *data,
        ULONG dataLen,
        hash_extra_data *extra_data_array,
        __unused unsigned int cbHashLen,
        unsigned __int8 *sig_data,
        unsigned int sig_len)
{
  _BCRYPT_PKCS1_PADDING_INFO PaddingInfo; // rbx
  int status; // edi
  PUCHAR pbHash; // [rsp+40h] [rbp-18h] BYREF
  const WCHAR *v15; // [rsp+48h] [rbp-10h] BYREF

  PaddingInfo.pszAlgId = 0i64;
  v15 = 0i64;
  pbHash = 0i64;
  cbHashLen = 0;
  status = compute_hash_on_data_ex(hAlgorithm, data, dataLen, extra_data_array, 1u, &pbHash, &cbHashLen);
  if ( status >= 0 )
  {
    if ( (bcryptFlags & BCRYPT_PAD_PKCS1) != 0 )
    {
      v15 = L"SHA256";
      PaddingInfo.pszAlgId = (LPCWSTR)&v15;
    }
[4]    status = BCryptVerifySignature(
               hKey,
               (void *)PaddingInfo.pszAlgId,
               pbHash,
               cbHashLen,
               sig_data,
               sig_len,
               bcryptFlags);
  }
  ExFreePoolWithTag_noTag(pbHash);
  return (unsigned int)status;
}

```

The function computes the hash of the data provided at [2] assuming a length of [3] and then verify the associated signature at [4].
However, we can see at [5] that the processing of the license file can continue even though the signature blob (type 0xcc) has been reached. This means that any data added after the signature blob will be processed and never checked for authenticity during the signature check.
Furthermore, because the way data is saved in the License structure at [6] repeating tags will overwrite entries already populated. As such it’s possible to tamper with an existing license file and edit its content without having to obtain the proper signature for it.
This attack can be conducted with a low privilege user and/or from within a LPAC container thus allowing a sandboxed process to potentially tamper with more privileged files.

##### TIMELINE

2024-04-08 - Vendor Disclosure

2024-08-13 - Vendor Patch Release

2024-08-13 - Public Release

##### Credit

Discovered by Philippe Laulheret of Cisco Talos.

---

[Vulnerability Reports](/vulnerability_reports) [Next Report

TALOS-2024-1969](/vulnerability_reports/TALOS-2024-1969) [Previous Report

TALOS-2024-1965](/vulnerability_reports/TALOS-2024-1965)

* + ###### [Intelligence Center](/reputation)
  + [Intelligence Search](/reputation_center)
  + [Email & Spam Trends](/reputation_center/email_rep)
* + ###### [Vulnerability Research](/vulnerability_info)
  + [Vulnerability Reports](/vulnerability_reports)
  + [Microsoft Advisories](/ms_advisories)
* + ###### [Incident Response](/incident_response)
  + [Reactive Services](/incident_response/services#reactive-services)
  + [Proactive Services](/incident_response/services#proactive-services)
  + Emergency Support
* + ###### Security Resources
  + [Open Source Security Tools](/software)
  + [Intelligence Categories Reference](/categories)
  + [Secure Endpoint Naming Reference](/secure-endpoint-naming)
* + ###### Media
  + [Talos Intelligence Blog](https://blog.talosintelligence.com)
  + [Threat Source Newsletter](https://blog.talosintelligence.com/category/threat-source-newsletter/)
  + [Beers with Talos Podcast](/podcasts/shows/beers_with_talos)
  + [Talos Takes Podcast](/podcasts/shows/talos_takes)
  + [Talos Videos](https://www.youtube.com/channel/UCPZ1DtzQkStYBSG3GTNoyfg/featured)
* + ###### Support
  + [Support Documentation](https://support.talosintelligence.com)
* + ###### Company
  + [About Talos](/about)
  + [Careers](/careers)
  + [Cisco Security](https://www.cisco.com/c/en/us/products/security/product-listing.html)

###### Follow us

[![Cisco](/assets/logo_cisco_white-d87b7f7d3152ad412e48aad924a972cc5b802b7a53cb56b0792a4456c9b7b3a5.svg)](http://tools.cisco.com/security/center/home.x)

©
2025
Cisco Systems, Inc. and/or its affiliates. All rights
reserved. View our
[Privacy Policy.](http://www.cisco.com/web/siteassets/legal/privacy_full.html)


