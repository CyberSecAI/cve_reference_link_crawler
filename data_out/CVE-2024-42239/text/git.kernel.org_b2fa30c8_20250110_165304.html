

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=9369830518688ecd5b08ffc08ab3302ce2b5d0f7)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=9369830518688ecd5b08ffc08ab3302ce2b5d0f7)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9369830518688ecd5b08ffc08ab3302ce2b5d0f7)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9369830518688ecd5b08ffc08ab3302ce2b5d0f7)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Kumar Kartikeya Dwivedi <memxor@gmail.com> | 2024-07-09 18:54:38 +0000 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-07-18 13:21:14 +0200 |
| commit | [9369830518688ecd5b08ffc08ab3302ce2b5d0f7](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9369830518688ecd5b08ffc08ab3302ce2b5d0f7) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=9369830518688ecd5b08ffc08ab3302ce2b5d0f7)) | |
| tree | [05584c929cece210735adae11bf517068275c65b](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=9369830518688ecd5b08ffc08ab3302ce2b5d0f7) | |
| parent | [e97c862e0b4c778de1f28f02db4439a5076b19dd](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e97c862e0b4c778de1f28f02db4439a5076b19dd) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9369830518688ecd5b08ffc08ab3302ce2b5d0f7&id2=e97c862e0b4c778de1f28f02db4439a5076b19dd)) | |
| download | [linux-9369830518688ecd5b08ffc08ab3302ce2b5d0f7.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-9369830518688ecd5b08ffc08ab3302ce2b5d0f7.tar.gz) | |

bpf: Fail bpf\_timer\_cancel when callback is being cancelled[ Upstream commit d4523831f07a267a943f0dde844bf8ead7495f13 ]
Given a schedule:
timer1 cb timer2 cb
bpf\_timer\_cancel(timer2); bpf\_timer\_cancel(timer1);
Both bpf\_timer\_cancel calls would wait for the other callback to finish
executing, introducing a lockup.
Add an atomic\_t count named 'cancelling' in bpf\_hrtimer. This keeps
track of all in-flight cancellation requests for a given BPF timer.
Whenever cancelling a BPF timer, we must check if we have outstanding
cancellation requests, and if so, we must fail the operation with an
error (-EDEADLK) since cancellation is synchronous and waits for the
callback to finish executing. This implies that we can enter a deadlock
situation involving two or more timer callbacks executing in parallel
and attempting to cancel one another.
Note that we avoid incrementing the cancelling counter for the target
timer (the one being cancelled) if bpf\_timer\_cancel is not invoked from
a callback, to avoid spurious errors. The whole point of detecting
cur->cancelling and returning -EDEADLK is to not enter a busy wait loop
(which may or may not lead to a lockup). This does not apply in case the
caller is in a non-callback context, the other side can continue to
cancel as it sees fit without running into errors.
Background on prior attempts:
Earlier versions of this patch used a bool 'cancelling' bit and used the
following pattern under timer->lock to publish cancellation status.
lock(t->lock);
t->cancelling = true;
mb();
if (cur->cancelling)
return -EDEADLK;
unlock(t->lock);
hrtimer\_cancel(t->timer);
t->cancelling = false;
The store outside the critical section could overwrite a parallel
requests t->cancelling assignment to true, to ensure the parallely
executing callback observes its cancellation status.
It would be necessary to clear this cancelling bit once hrtimer\_cancel
is done, but lack of serialization introduced races. Another option was
explored where bpf\_timer\_start would clear the bit when (re)starting the
timer under timer->lock. This would ensure serialized access to the
cancelling bit, but may allow it to be cleared before in-flight
hrtimer\_cancel has finished executing, such that lockups can occur
again.
Thus, we choose an atomic counter to keep track of all outstanding
cancellation requests and use it to prevent lockups in case callbacks
attempt to cancel each other while executing in parallel.
Reported-by: Dohyun Kim <dohyunkim@google.com>
Reported-by: Neel Natu <neelnatu@google.com>
Fixes: b00628b1c7d5 ("bpf: Introduce bpf timers.")
Signed-off-by: Kumar Kartikeya Dwivedi <memxor@gmail.com>
Link: [https://lore.kernel.org/r/20240709185440.1104957-2-memxor@gmail.com](https://lore.kernel.org/r/20240709185440.1104957-2-memxor%40gmail.com)
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9369830518688ecd5b08ffc08ab3302ce2b5d0f7)

| -rw-r--r-- | [kernel/bpf/helpers.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/bpf/helpers.c?id=9369830518688ecd5b08ffc08ab3302ce2b5d0f7) | 38 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 35 insertions, 3 deletions

| diff --git a/kernel/bpf/helpers.c b/kernel/bpf/helpers.cindex c34c93aa5a5e74..9ab6be9653059e 100644--- a/[kernel/bpf/helpers.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/helpers.c?id=e97c862e0b4c778de1f28f02db4439a5076b19dd)+++ b/[kernel/bpf/helpers.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/helpers.c?id=9369830518688ecd5b08ffc08ab3302ce2b5d0f7)@@ -1106,6 +1106,7 @@ struct bpf\_async\_cb { struct bpf\_hrtimer { struct bpf\_async\_cb cb; struct hrtimer timer;+ atomic\_t cancelling; };  /\* the actual struct hidden inside uapi struct bpf\_timer \*/@@ -1204,6 +1205,7 @@ static int \_\_bpf\_async\_init(struct bpf\_async\_kern \*async, struct bpf\_map \*map, u clockid = flags & (MAX\_CLOCKS - 1); t = (struct bpf\_hrtimer \*)cb; + atomic\_set(&t->cancelling, 0); hrtimer\_init(&t->timer, clockid, HRTIMER\_MODE\_REL\_SOFT); t->timer.function = bpf\_timer\_cb; cb->value = (void \*)async - map->record->timer\_off;@@ -1364,7 +1366,8 @@ static void drop\_prog\_refcnt(struct bpf\_async\_cb \*async)  BPF\_CALL\_1(bpf\_timer\_cancel, struct bpf\_async\_kern \*, timer) {- struct bpf\_hrtimer \*t;+ struct bpf\_hrtimer \*t, \*cur\_t;+ bool inc = false; int ret = 0;  if (in\_nmi())@@ -1376,14 +1379,41 @@ BPF\_CALL\_1(bpf\_timer\_cancel, struct bpf\_async\_kern \*, timer) ret = -EINVAL; goto out; }- if (this\_cpu\_read(hrtimer\_running) == t) {++ cur\_t = this\_cpu\_read(hrtimer\_running);+ if (cur\_t == t) { /\* If bpf callback\_fn is trying to bpf\_timer\_cancel() \* its own timer the hrtimer\_cancel() will deadlock- \* since it waits for callback\_fn to finish+ \* since it waits for callback\_fn to finish.+ \*/+ ret = -EDEADLK;+ goto out;+ }++ /\* Only account in-flight cancellations when invoked from a timer+ \* callback, since we want to avoid waiting only if other \_callbacks\_+ \* are waiting on us, to avoid introducing lockups. Non-callback paths+ \* are ok, since nobody would synchronously wait for their completion.+ \*/+ if (!cur\_t)+ goto drop;+ atomic\_inc(&t->cancelling);+ /\* Need full barrier after relaxed atomic\_inc \*/+ smp\_mb\_\_after\_atomic();+ inc = true;+ if (atomic\_read(&cur\_t->cancelling)) {+ /\* We're cancelling timer t, while some other timer callback is+ \* attempting to cancel us. In such a case, it might be possible+ \* that timer t belongs to the other callback, or some other+ \* callback waiting upon it (creating transitive dependencies+ \* upon us), and we will enter a deadlock if we continue+ \* cancelling and waiting for it synchronously, since it might+ \* do the same. Bail! \*/ ret = -EDEADLK; goto out; }+drop: drop\_prog\_refcnt(&t->cb); out: \_\_bpf\_spin\_unlock\_irqrestore(&timer->lock);@@ -1391,6 +1421,8 @@ out: \* if it was running. \*/ ret = ret ?: hrtimer\_cancel(&t->timer);+ if (inc)+ atomic\_dec(&t->cancelling); rcu\_read\_unlock(); return ret; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 16:51:41 +0000

