

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=7b439aaa62fee474a0d84d67a25f4984467e7b95)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=7b439aaa62fee474a0d84d67a25f4984467e7b95)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7b439aaa62fee474a0d84d67a25f4984467e7b95)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7b439aaa62fee474a0d84d67a25f4984467e7b95)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Johan Hovold <johan+linaro@kernel.org> | 2023-10-03 17:29:24 +0200 |
| --- | --- | --- |
| committer | Lee Jones <lee@kernel.org> | 2023-11-01 10:02:16 +0000 |
| commit | [7b439aaa62fee474a0d84d67a25f4984467e7b95](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7b439aaa62fee474a0d84d67a25f4984467e7b95) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=7b439aaa62fee474a0d84d67a25f4984467e7b95)) | |
| tree | [3d36f340403108103dea38f79783db71e54d58a3](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=7b439aaa62fee474a0d84d67a25f4984467e7b95) | |
| parent | [a0fa44c261e448c531f9adb3a5189a3520f3e316](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a0fa44c261e448c531f9adb3a5189a3520f3e316) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7b439aaa62fee474a0d84d67a25f4984467e7b95&id2=a0fa44c261e448c531f9adb3a5189a3520f3e316)) | |
| download | [linux-7b439aaa62fee474a0d84d67a25f4984467e7b95.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-7b439aaa62fee474a0d84d67a25f4984467e7b95.tar.gz) | |

mfd: qcom-spmi-pmic: Fix revid implementationThe Qualcomm SPMI PMIC revid implementation is broken in multiple ways.
First, it assumes that just because the sibling base device has been
registered that means that it is also bound to a driver, which may not
be the case (e.g. due to probe deferral or asynchronous probe). This
could trigger a NULL-pointer dereference when attempting to access the
driver data of the unbound device.
Second, it accesses driver data of a sibling device directly and without
any locking, which means that the driver data may be freed while it is
being accessed (e.g. on driver unbind).
Third, it leaks a struct device reference to the sibling device which is
looked up using the spmi\_device\_from\_of() every time a function (child)
device is calling the revid function (e.g. on probe).
Fix this mess by reimplementing the revid lookup so that it is done only
at probe of the PMIC device; the base device fetches the revid info from
the hardware, while any secondary SPMI device fetches the information
from the base device and caches it so that it can be accessed safely
from its children. If the base device has not been probed yet then probe
of a secondary device is deferred.
Fixes: e9c11c6e3a0e ("mfd: qcom-spmi-pmic: expose the PMIC revid information to clients")
Cc: stable@vger.kernel.org # 6.0
Signed-off-by: Johan Hovold <johan+linaro@kernel.org>
Acked-by: Caleb Connolly <caleb.connolly@linaro.org>
Link: [https://lore.kernel.org/r/20231003152927.15000-3-johan+linaro@kernel.org](https://lore.kernel.org/r/20231003152927.15000-3-johan%2Blinaro%40kernel.org)
Signed-off-by: Lee Jones <lee@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7b439aaa62fee474a0d84d67a25f4984467e7b95)

| -rw-r--r-- | [drivers/mfd/qcom-spmi-pmic.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/mfd/qcom-spmi-pmic.c?id=7b439aaa62fee474a0d84d67a25f4984467e7b95) | 69 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 53 insertions, 16 deletions

| diff --git a/drivers/mfd/qcom-spmi-pmic.c b/drivers/mfd/qcom-spmi-pmic.cindex 47738f7e492ca9..8e449cff5cec40 100644--- a/[drivers/mfd/qcom-spmi-pmic.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/mfd/qcom-spmi-pmic.c?id=a0fa44c261e448c531f9adb3a5189a3520f3e316)+++ b/[drivers/mfd/qcom-spmi-pmic.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/mfd/qcom-spmi-pmic.c?id=7b439aaa62fee474a0d84d67a25f4984467e7b95)@@ -30,6 +30,8 @@ struct qcom\_spmi\_dev { struct qcom\_spmi\_pmic pmic; }; +static DEFINE\_MUTEX(pmic\_spmi\_revid\_lock);+ #define N\_USIDS(n) ((void \*)n)  static const struct of\_device\_id pmic\_spmi\_id\_table[] = {@@ -76,24 +78,21 @@ static const struct of\_device\_id pmic\_spmi\_id\_table[] = { \* \* This only supports PMICs with 1 or 2 USIDs. \*/-static struct spmi\_device \*qcom\_pmic\_get\_base\_usid(struct device \*dev)+static struct spmi\_device \*qcom\_pmic\_get\_base\_usid(struct spmi\_device \*sdev, struct qcom\_spmi\_dev \*ctx) {- struct spmi\_device \*sdev;- struct qcom\_spmi\_dev \*ctx; struct device\_node \*spmi\_bus; struct device\_node \*child; int function\_parent\_usid, ret; u32 pmic\_addr; - sdev = to\_spmi\_device(dev);- ctx = dev\_get\_drvdata(&sdev->dev);- /\* \* Quick return if the function device is already in the base \* USID. This will always be hit for PMICs with only 1 USID. \*/- if (sdev->usid % ctx->num\_usids == 0)+ if (sdev->usid % ctx->num\_usids == 0) {+ get\_device(&sdev->dev); return sdev;+ }  function\_parent\_usid = sdev->usid; @@ -118,10 +117,8 @@ static struct spmi\_device \*qcom\_pmic\_get\_base\_usid(struct device \*dev) sdev = spmi\_device\_from\_of(child); if (!sdev) { /\*- \* If the base USID for this PMIC hasn't probed yet- \* but the secondary USID has, then we need to defer- \* the function driver so that it will attempt to- \* probe again when the base USID is ready.+ \* If the base USID for this PMIC hasn't been+ \* registered yet then we need to defer. \*/ sdev = ERR\_PTR(-EPROBE\_DEFER); }@@ -135,6 +132,35 @@ static struct spmi\_device \*qcom\_pmic\_get\_base\_usid(struct device \*dev) return sdev; } +static int pmic\_spmi\_get\_base\_revid(struct spmi\_device \*sdev, struct qcom\_spmi\_dev \*ctx)+{+ struct qcom\_spmi\_dev \*base\_ctx;+ struct spmi\_device \*base;+ int ret = 0;++ base = qcom\_pmic\_get\_base\_usid(sdev, ctx);+ if (IS\_ERR(base))+ return PTR\_ERR(base);++ /\*+ \* Copy revid info from base device if it has probed and is still+ \* bound to its driver.+ \*/+ mutex\_lock(&pmic\_spmi\_revid\_lock);+ base\_ctx = spmi\_device\_get\_drvdata(base);+ if (!base\_ctx) {+ ret = -EPROBE\_DEFER;+ goto out\_unlock;+ }+ memcpy(&ctx->pmic, &base\_ctx->pmic, sizeof(ctx->pmic));+out\_unlock:+ mutex\_unlock(&pmic\_spmi\_revid\_lock);++ put\_device(&base->dev);++ return ret;+}+ static int pmic\_spmi\_load\_revid(struct regmap \*map, struct device \*dev, struct qcom\_spmi\_pmic \*pmic) {@@ -210,11 +236,7 @@ const struct qcom\_spmi\_pmic \*qcom\_pmic\_get(struct device \*dev) if (!of\_match\_device(pmic\_spmi\_id\_table, dev->parent)) return ERR\_PTR(-EINVAL); - sdev = qcom\_pmic\_get\_base\_usid(dev->parent);-- if (IS\_ERR(sdev))- return ERR\_CAST(sdev);-+ sdev = to\_spmi\_device(dev->parent); spmi = dev\_get\_drvdata(&sdev->dev);  return &spmi->pmic;@@ -249,16 +271,31 @@ static int pmic\_spmi\_probe(struct spmi\_device \*sdev) ret = pmic\_spmi\_load\_revid(regmap, &sdev->dev, &ctx->pmic); if (ret < 0) return ret;+ } else {+ ret = pmic\_spmi\_get\_base\_revid(sdev, ctx);+ if (ret)+ return ret; }++ mutex\_lock(&pmic\_spmi\_revid\_lock); spmi\_device\_set\_drvdata(sdev, ctx);+ mutex\_unlock(&pmic\_spmi\_revid\_lock);  return devm\_of\_platform\_populate(&sdev->dev); } +static void pmic\_spmi\_remove(struct spmi\_device \*sdev)+{+ mutex\_lock(&pmic\_spmi\_revid\_lock);+ spmi\_device\_set\_drvdata(sdev, NULL);+ mutex\_unlock(&pmic\_spmi\_revid\_lock);+}+ MODULE\_DEVICE\_TABLE(of, pmic\_spmi\_id\_table);  static struct spmi\_driver pmic\_spmi\_driver = { .probe = pmic\_spmi\_probe,+ .remove = pmic\_spmi\_remove, .driver = { .name = "pmic-spmi", .of\_match\_table = pmic\_spmi\_id\_table, |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 20:19:55 +0000

