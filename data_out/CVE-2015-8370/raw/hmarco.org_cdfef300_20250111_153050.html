<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="fr">
  <head>
    
      
      
<script async src="https://www.googletagmanager.com/gtag/js?id=G-X4RJXX4KKS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-X4RJXX4KKS');
</script>


    
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/>
    <meta name="copyright" content="Copyright &#169; Hector Marco" />
    <title>Back to 28: Grub2 Authentication Bypass 0-Day</title>
    <link href="../style.css" media="screen" rel="Stylesheet" type="text/css" />
    <style>
      .shad {
      border: solid 1px #ccc;
      border-radius: 6px;
      margin-left:auto;
      margin-right:auto;
      max-width:820px;
      padding:1em;
      box-shadow:4px 4px 6px #666;
      }
      tt { font-family: "Monospace"; font-size:100%;}
      pre {color: #fff;}
      .comment { color: #999999; font-style: italic; }
      .pre { color: #000099; }
      .string { color: #009900; }
      .char { color: #009900; }
      .float { color: #996600; }
      .int { color: #999900; }
      .bool { color: #000000; font-weight: bold; }
      .type { color: #8bf; }
      .flow { color: #8bf; }
      .keyword { color: #6dd; }
      .operator { color: #fff;  }
    </style>
  </head>
  
  <body>
    
    
    <h1>Back to 28: Grub2 Authentication 0-Day<hr>  </h1>
      <table class="h" border="0">
          <tr> <td>Authors:</td><td><tt><a href="http://hmarco.org">Hector Marco</a > &amp; <a href="http://personales.upv.es/~iripoll/" target="_blank">Ismael Ripoll</a>&nbsp; -- &nbsp;<a href="http://cybersecurity.upv.es" target="_blank">Cybersecurity Group</a></tt></td></tr>
	<tr><td>CVE:</td><td><tt>CVE-2015-8370</tt></td></tr>
	<tr><td>Comment:</td><td>Grub2 Authentication Bypass 0-Day</td></tr>
	<tr><td>Dates:</td>
	  <td>
	    <tt>December 10<sup>th</sup>, 2015 - Disclosed at <a target="_blank" href="https://www.ccn-cert.cni.es/ix-jornadas-de-seguridad-tic-del-ccn-cert/ponencias.html">IX Jornadas STIC CCN-CERT</a>.</tt><br/>
		  <tt>December 14<sup>th</sup>, 2015 - Published in the web.</tt>
	  </td>
	</tr>
      </table>
    </div> 
    <div class="bug" style="text-align: justify;"/>
    <br/>


<div  style="width:30%;  margin-left:1em; float:right; text-align:center; ">
      <table>
	<tr>
          <td><img src="grub_hacked-b.png" width="100%"/></td>
	</tr>
	<tr>
	  <td style="text-align:center"><div style="font-size:80%"><i>Back to 28 GRUB2 vulnerability</i></div></td>
	</tr>
      </table>
      <br/>
    </div>
    
<div style="font-size:80%">
    <h2>Contents</h2>
    <ol style="width:40%;" >
      <li><a href="#desc">Description.</a></li>
      <li><a href="#impact">Impact.</a></li>
      <li><a href="#vuln">The Vulnerability.</a></li>
      <li><a href="#exploit">The Exploit (PoC).</a></li>
      <li><a href="#how">How an APT could use this 0-Day.</a></li>
      <li><a href="#fix">The Fix.</a></li>
      <li><a href="#disc">Discussion.</a></li>
    </ol>
</div>
    <h2 id="desc">Description</h2>
    
   


    <p> A vulnerability in <b>Grub2</b> has been found. Versions from
      1.98 (December, 2009) to 2.02 (December, 2015) are affected.
      The vulnerability can be exploited under certain circumstances,
      allowing local attackers to bypass any kind of authentication
      (plain or hashed passwords). And so, the attacker may take
      control of the computer.
    </p>
    
    <p>
      Grub2 is the bootloader used by most Linux systems including
      some embedded systems.  This results in an incalculable number
      of affected devices.
    </p>

    <p>As shown in the picture, we successfully exploited this
      vulnerability in a Debian 7.5 under Qemu getting a <b>Grub
      rescue shell</b>.
    </p>
    
    <h3>Am I vulnerable ?</h3>
    <p>To quickly check if your system is vulnerable, when the Grub
      ask you the username, press the <i>Backspace</i> 28 times. If
      your machine reboots or you get a <b>rescue shell</b> then your
      Grub is affected.
    </p>
    
    <h2 id="impact">Impact</h2>
    
    An attacker which successfully exploits this vulnerability will
    obtain a Grub rescue shell. Grub rescue is a very powerful shell
    allowing to:
    
    <ul>
      
      <li><b>Elevation of privilege:</b> The attacker is authenticated
        without knowing a valid username nor the password. The
        attacker has full access to the grub's console (grub
        rescue).<br/>
      </li>
      
      <li><b>Information disclosure:</b> The attacker can load a
        customized kernel and initramfs (for example from a USB) and
        then from a more comfortable environment, copy the full disk
        or install a rootkit.<br/>
      </li>
      
      <li><b>Denial of service:</b> The attacker is able to destroy
        any data including the grub itself. Even in the case that the
        disk is ciphered the attacker can overwrite it, causing a
        DoS.</li><br/>
    </ul>

    <h2 id="vuln">The Vulnerability</h2>

    <p>
      The fault (bug) is in the code of Grub since version 1.98
      (December, 2009). The commit which introduced the fault was
      <tt>b391bdb2f2c5ccf29da66cecdbfb7566656a704d</tt>, affecting
      the <tt>grub_password_get()</tt> function.
    </p>
    
    <p> There are two functions which suffer the same integer
      underflow fault. The <tt>grub_username_get()</tt>
      and <tt>grub_password_get()</tt> located in
      <tt>grub-core/normal/auth.c</tt> and <tt>lib/crypto.c</tt>
      respectively.  Both functions are equal except for a call
      to <tt>printf()</tt> in the <tt>grub_username_get()</tt>. The PoC
      described here is based only on exploiting
      the <tt>grub_username_get()</tt> to obtain a <b>Grub rescue
      shell</b>.
    </p>
    <p>
      Below is the vulnerable <tt>grub_username_get()</tt> function:
    </p>
      <table width="90%" style="margin-left:auto; margin-right:auto;">
          <tr>
            <td>

<pre><span class="keyword">static</span><span class="type"> int</span>
<span style="color:#c08e21;font-weight:bold;">grub_username_get</span><span class="operator"> (</span><span class="type">char</span> buf<span class="operator">[],</span><span class="type"> unsigned</span> buf_size<span class="operator">)
{</span><span class="type">
  unsigned</span> cur_len<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span><span class="type">
  int</span> key<span class="operator">;</span><span class="flow">

  while</span><span class="operator"> (</span><span class="int">1</span><span class="operator">)
    {</span>
      key<span class="operator"> =</span> grub_getkey<span class="operator"> ();</span><span class="flow">
      if</span><span class="operator"> (</span>key<span class="operator"> ==</span><span class="char"> '\n'</span><span class="operator"> ||</span> key<span class="operator"> ==</span><span class="char"> '\r'</span><span class="operator">)</span><span class="flow">
        break</span><span class="operator">;</span><span class="flow">

      if</span><span class="operator"> (</span>key<span class="operator"> ==</span><span class="char"> '\e'</span><span class="operator">)
        {</span>
          cur_len<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span><span class="flow">
          break</span><span class="operator">;
        }</span>

     <span style="color:red; font-weight:bold;"> if (key == '\b') </span><span class="comment"> // Does not checks underflows !!
</span><span class="operator">        {</span>
         <span style="color:red; font-weight:bold;"> cur_len--;</span><span class="comment"> // Integer underflow !!
</span>          grub_printf<span class="operator"> (</span><span class="string">"\b"</span><span class="operator">);</span><span class="flow">
          continue</span><span class="operator">;
        }</span><span class="flow">

      if</span><span class="operator"> (!</span>grub_isprint<span class="operator"> (</span>key<span class="operator">))</span><span class="flow">
        continue</span><span class="operator">;</span><span class="flow">

      if</span><span class="operator"> (</span>cur_len<span class="operator"> +</span><span class="int"> 2</span><span class="operator"> &lt;</span> buf_size<span class="operator">)
        {</span>
          <span style="color:red; font-weight:bold;">buf[cur_len++] = key</span><span class="operator">;</span><span class="comment"> // Off-by-two !!
</span>          grub_printf<span class="operator"> (</span><span class="string">"%c"</span><span class="operator">,</span> key<span class="operator">);
        }
    }</span>

  <span style="color:red; font-weight:bold;">grub_memset( buf + cur_len, 0, buf_size - cur_len);</span><span class="comment"> // Out of bounds overwrite
</span>
  grub_xputs<span class="operator"> (</span><span class="string">"\n"</span><span class="operator">);</span>
  grub_refresh<span class="operator"> ();</span><span class="flow">

  return</span><span class="operator"> (</span>key<span class="operator"> !=</span><span class="char"> '\e'</span><span class="operator">);
}</span>
</pre>
	    </td>
          </tr>
          <tr>
            <td style="text-align:center" >Function <tt>grub_username_get()</tt> at <tt>grub-core/normal/auth.c</tt><hr width="40%"/></td>
          </tr>
          </table>


    The fault is caused by decrementing the <tt>cur_len</tt> variable
    without checking the range.

    <br/><br/>

   <h2 id="exploit">The Exploit (PoC)</h2> 
      

    <p> Exploiting the integer underflow can be used to cause an
      <b>Off-by-two</b> or an <b>Out of bounds overwrite</b> memory
         errors.  The former error, overwrites up to two bytes right
         under the username buffer (local variable
         called <tt>login</tt> at
         function <tt>grub_auth_check_authentication()</tt>), but this
         area does not contain any usable information to build an
         attack; actually, it is padding.</p>


         <p>
         The latter error, the <b>Out of bounds overwrite</b>, is more
         interesting because it allows to overwrite with zeros the
         zone below to the username buffer.  This is because
         the <tt><b>grub_memset()</b></tt> function tries to set to
         zero all unused bytes of the username buffer. To do that, the
         code calculates the address of the first unused byte and how
         many bytes have to be zeroed in the buffer. The results of
         these calculations are passed as arguments to
         the <tt>grub_memset()</tt> function:
         </p>

         <p >
         <tt style="font-size:100%;color:#555;">&nbsp;&nbsp;&nbsp;&nbsp;grub_memset (buf + cur_len, 0, buf_size - cur_len);</tt>
         </p>


         <p>For example, typing <it>"root"</it> as usermane,
         <tt>cur_len</tt> is 5, and the <tt>grub_memset()</tt>
         function will clear (set to zero) bytes form <tt>5</tt>
         to <tt>1024-5</tt> (the username and password buffers are
         1024 bytes) of the username buffer. This way of programming
         is quite robust. For example, if the typed username is stored
         in a clean 1024-byte array, then we can compare the whole
         1024-bytes with the valid username, rather than comparing
         both strings. This protects against some short of
         side-channels attacks, like timing attacks.  </p>
         

         <p>To abuse the <b>out of bound overwrite</b>, the attacker
         can press the <i>backspace</i> key to underflow
         the <tt>cur_len</tt> variable, producing a very high value.
         This value is later used to calculate the starting address to clear.
         
         <p >
         <tt style="font-size:100%;color:#555;">&nbsp;&nbsp;&nbsp;&nbsp;<b>memset destination address = </b>
             buf + cur_len</tt>
         </p>


         At this point, <b>a second overflow occurs</b> because
         the addition of this big value with the base address where
         the username buffer resides can not be hold in a 32-bit
         variable.  Hence, we need to manage the first underflow and
         this second overflow to calculate the destination address
         where the <tt>grub_memset()</tt> function will start to set
         to zeros the buffer:
         </p>
<span style="font-size:100%;color:#555;"><tt style="font-size:100%;">
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:red">cur_len--;</span></tt>  // Integer Underflow<br/>
<tt style="font-size:100%;">&nbsp;&nbsp;&nbsp;&nbsp;grub_memset (<span style="color:red">buf + cur_len</span>, 0, buf_size - cur_len);</tt> // Integer Overflow
</span>

         <p>The following example helps to understand how we can exploit this.
         Assuming that the username buffer resides in the address 
         <tt style="font-size:100%;">0x7f674</tt> and the attacker press the
         <i>backspace</i> key only once (producing an underflow to <tt style="font-size:100%;">0xFFFFFFFF<tt></tt></tt>)
         the resulting <it>memset</it> will be:

    
        <p>
         <tt style="font-size:100%;color:#555;">&nbsp;&nbsp;&nbsp;&nbsp;grub_memset (0x7f673, 0, 1025);</tt>
         </p>

         <p> The first argument is:  <tt style="font-size:100%;">(buf+cur_len) =
             (0x7f674+0xFFFFFFFF) = (0x7f674-1) = <b>0x7f673</b></tt>, the second argument:
         is the constant value used to overwrite the area, in this case <tt
             style="font-size:100%;"><b>0</b></tt>, and the third argument is the number of bytes
     to overwrite: <tt style="font-size:100%;">(buf_size-cur_len) = (1024-(-1)) =
         <b>1025</b></tt>. Therefore, the whole username buffer (1024) plus the very
     first byte under the buffer will be set to zero.</p>
 
         <p>Therefore, the number <i>backspace</i> keystrokes (without
         introducing any username), is the number of bytes below the
         username that are zeroed.
         </p>

        <p> Now, we are able to overwrite an arbitrary number of bytes
        below the username, we need to find out an interesting memory address
        that we can overwrite with zeros. A quick look to the current stack
        frame reveals that we were able to <b>overwrite the return
          address of the <tt>grub_memset()</tt> function</b>.  The following
        picture sketches the stack memory layout:
        </p>
        <br/>
        <table width="90%" style="margin-left:auto; margin-right:auto;">
          <tr>
            <td><img  class="shad"  src="bomba.png" width="100%"/></td>
          </tr>
          <tr>
            <td style="text-align:center" >Grub2: Redirecting the control flow.<hr width="40%"/></td>
          </tr>
          </table>

          <p>As shown in the above picture, the return address of the
          <tt>grub_memset()</tt> function is at a distance of 16-bytes from the
          username buffer. In other words, if we press the <i>backspace</i> key
          17 times, we will overwrite the highest byte of the return address.
          So, instead of returning to the caller function at <tt
          style="font-size:100%;">0x07eb53e8</tt> we will jump to 
          <tt style="font-size:100%;">0x<span style="color:red">00</span>eb53e8</tt>. 
          When the <tt>grub_memset()</tt> ends, control flow is redirected to the
          the <tt style="font-size:100%;">0x<span style="color:red">00</span>eb53e8</tt>
          address causing a reboot. The same occurs if we press the <i>backspace</i> key
          18, 19 or 20 times, in all cases the system reboots.
          </p>


          <p>At this point, <b>we are able to redirect the control
          flow</b>. 
	  </p>

	  <p> We will skip the detailed analysis of the code at:
	    0x00eb53e8, 0x000053e8 and 0x000000e8, because they jump
	    to code that reboots the computer and there is no way to
	    control the execution flow. 
	  </p>

	  <p>
	    Although it seems quite difficult to build a successful
            attack just jumping to 0x0, we will show how to do it.
          </p>


	  <h3>Is there life after jumping to 0x0 ?</h3>
<p>
	  At address 0x0 resides the IVT (Interrupt Vector Table) of
	  the processor. It contains a variety of pointers in the form
	  of segment:offset.
	  <table width="90%" style="margin-left:auto; margin-right:auto;">
            <tr>
              <td><img  class="shad" src="IVT.png" width="100%"/></td>
            </tr>
            <tr>
              <td style="text-align:center" >The lowest part of the IVT interpreted as code.<hr width="40%"/></td>
            </tr>
          </table>
	  
	  
	  At this early stage of the boot sequence, the processor and
	  the execution framework is not fully functional. Next are
	  the main differences with respect to the execution
	  environment of a regular process:
	  <ul>
	    <li>The processor is in "protected mode".  Grub2 enables this mode at the very beginning.
	    </li>
	    <li>Virtual memory is not enabled.</li>
	    <li>No memory protection. The memory is readable/writable/executable. That is, no NX/DEP.</li>
	    <li>The processor executes the 32-bit instruction set, even in 64-bit architectures.</li>
	    <li>Self modifying code is automatically handled by the processor: "<i>If
		the write affects a prefetched instruction, the prefetch queue is
		invalidated.</i>"
	    </li>
	    <li>No Stack Smashing Protector (SSP).</li>
	    <li>No Address Space Layout Randomization (ASLR).</li>
	  </ul>
	  
    Therefore, jumping to 0x0 does not cause a trap by itself, but we
     need to control the execution flow to reach the target
     function <b><tt>grub_rescue_run()</tt></b> which contains the
     main loop of the <b>Grub2 Rescue Shell</b>.

	  <h3>What do we control when jumping to 0x0</h3> 
<p>
 


<table> <tr><td style="padding-right:3em">
 The main "while" loop of the <tt>grub_username_get()</tt> ends when
  the user hits either the [Enter] or the [Esc] key. The
  register <b><tt>%ebx</tt></b> contains the value of the last typed
  key (0xd or 0x8, Enter or Esc ascii codes respectively). The
  register <b><tt>%esi</tt></b> holds the value of
  the <b><tt>cur_len</tt></b> variable.

<p>
  The instruction pointer points to the 0x0
  address. The <b><tt>%esi</tt></b> register contains the
  value <b>-28</b> (the exploit works by pressing 28 times the
  backspace), and then hitting [Enter] (<b><tt>%ebx == 0xb</tt></b>).
</p>
 
</td><td style="padding-left:0px; text-align:center;">
<pre style="text-align:left;">
eax       0x7f658
ecx       0x0		(0)
edx       0x0		(0)
<span style="color:yellow">ebx       0xd		(13)</span>
esp       0x7f664
ebp       0x0		(0)
<span style="color:red">esi       0xffff ffe4	(-28)</span>
edi       0x0		(0)
<span style="color:yellow">eip       0x0		(0)</span>
esp       0x7f664
eflags    0x200046[ PF ZF ID ]</pre>
Relevant CPU registers.</td></tr>
</table>
<h3>Reverse engineering of the IVT</h3>
<p>
  If the state of the processor is the one summarized in the
  previous table, the code at IVT implements something like a
  <tt>memcpy()</tt>, which copies from the address pointed by <tt>
  %esi</tt> to 0x0 (to itself). Therefore, <b>IVT is a self modifying
  code</b>, and we can select the block of code that we want to copy
  from.
</p>

<p>
   The following sequence shows the sequence of code actually executed
   the register <tt> %esi</tt> has the value <b><tt>-28</tt></b>
   (<b><tt>0xffffffe4</tt></b>):
</p>

 <table width="90%" style="margin-left:auto; margin-right:auto;">
            <tr>
              <td style="text-align:center"><img  class="shad" src="Self-modify-1.png" width="500px"/></td>
            </tr>
 <tr>
              <td style="text-align:center" >First  iteration.<hr width="40%"/></td>
            </tr>
            <tr>
              <td style="text-align:center"><img  class="shad" src="Self-modify-3.png" width="750px"/></td>
            </tr>
            <tr>
              <td style="text-align:center" >Second iteration.<hr width="40%"/></td>
            </tr>
          </table>
	  
 In the third iteration, the resulting code contains
 a <b><tt>retw</tt></b> instruction at <b><tt>0x0007</tt></b>. The value pointer
 by <tt>%esp</tt> is <b><tt>0xe00c</tt></b>. And so, when the retw
 instruction is executed, the execution flow jumps
 into <b><tt>0xe00c</tt></b>. This address belongs to the
 function <b><tt> grub_rescue_run()</tt></b>:

<table style="margin-left:auto; margin-right:auto;"> <tr><td valign="top">
<pre>
&lt;<span style="color:#c08e21;font-weight:bold;">grub_rescue_run</span>&gt;:
  0xdfef:    push   %ebp
  0xdff0:    mov    %esp,%ebp
  0xdff2:    sub    $0x24,%esp
  0xdff5:    push   $0xe90a
  0xdffa:    call   0xd53b   #  
  0xdfff:    add    $0x10,%esp
  0xe002:    call   0xbfd2   #    
  0xe007:    xor    %edx,%edx
  0xe009:    lea    -0xc(%ebp),%eax
<span style="color:red;">->0xe00c:    movl   $0x0,0x16ce0--></span>
  0xe016:    call   0xdf28  
  ...        ...    ...
</pre>
 
</td><td  valign="bottom" style="padding-left:0px">
<pre>
<span class="flow">void</span> __attribute__ ((noreturn)) <span style="color:#c08e21;font-weight:bold;">grub_rescue_run</span> (<span class="flow">void</span>){

  . . .

  <span class="flow">while</span> (1)
    {
      <span class="flow">char</span> *line;

      /* Print an error, if any.  */
      grub_print_error ();
<span style="color:red;">----->grub_errno = GRUB_ERR_NONE;</span>

      grub_rescue_read_line (&line, 0, NULL);
      <span class="flow">if</span> (! line || line[0] == <span class="flow">'\0'</span>)
        <span class="flow">continue</span>;

      grub_rescue_parse_line (line, grub_rescue_read_line,
                              NULL);
      grub_free (line);
    }
}</pre></td></tr>
<tr><td align="center"> Assembly code.
  </td>
  <td align="center"> Corresponding C function.</td>
</tr>
<tr><td colspan="2"><hr width="80%"/></td></tr>
</table>

<br/>
At this point, GRUB2 is in the grub rescue function, which is a
powerful shell. 

<table width="90%" style="margin-left:auto; margin-right:auto;">
  <tr >
    <td><img  class="shad"  src="Got_Rescue-1.png" width="350px"/></td>
    <td><img class="shad"   src="Got_Rescue-2.png" width="350px"/></td>
  </tr>
  <tr>
    <td style="text-align:center" >Right after 28 [Backspace] and [Enter].</td>
    <td style="text-align:center" >We've got a fully operative rescue shell.</td>
  </tr>
          </table>

 
<p>
Fortunately, the content of the memory has suffered minor
modifications, and it is possible to use all the functionality of
GRUB. Only, the first interrupt vector of the IVT has been modified,
and since the processor is now in protected mode, the IVT is no longer
used.
</p>
<h3>One step ahead</h3>
<p>

Although we reached the GRUB2 rescue function, we are not actually
authenticated. If we return to the "normal" mode, that is the grub menu and
with full editing capabilities, GRUB will ask for a valid user and password.

So, we can directly start to type GRUB2 commands, or even including new modules
to add new GRUB functionalities, to deploy the malware into the system or launch a
much more comfortable environment by running a complete bash shell from a
Linux.  To run bash in Linux, we can use the GRUB2 commands like <i>linux</i>,
<i>initrd</i> or <i>insmod</i>.

</p>

<p>Although to use GRUB2 commands to run a Linux kernel to deploy the malware is
perfectly possible, we found that, a simpler solution is to patch the code of
GRUB2 in RAM to be always authenticated and then return to the "normal" mode.
The idea to do that, is to modify the condition which checkes whether the user
has been authenticated or not. This function is
<tt><b>is_authenticated()</b></tt> in the file <tt><b>
grub-core/normal/auth.c</b></tt>. 


<table width="90%" style="margin-left:auto; margin-right:auto;">
  <tr >
    <td><img class="shad"   src="Is_Authenticated.png" width="100%"/></td>
  </tr>
  <tr>
    <td style="text-align:center" >The goal is to overwrite the condition
    with <tt><b>nop</b></tt> instructions.</td>
  </tr>
          </table><br/> 
          
          This modification is done using the GRUB2 rescue command
          <b><tt>write_word</tt></b>. And then, everything is ready to return
          back to GRUB2's normal mode. In other words, we can enter in the "edit mode"
          and GRUB2 will not ask for users or passwords.

<table width="90%" style="margin-left:auto; margin-right:auto;">
  <tr >
    <td><img  class="shad"  src="Got_Rescue-3.png" width="350px"/></td>
    <td><img class="shad"   src="Got_Rescue-4.png" width="350px"/></td>
  </tr>
  <tr>
    <td >
<pre style="font-size:80%; width:90%">grub rescue> write_word 0x7eb514e 0x90909090
grub rescue> normal
</pre>
</td>
    <td style="text-align:center" >We've got a fully operative GRUB2.</td>
  </tr>
          </table>


<br/>

   <h2 id="how">How an APT could use this 0-Day</h2>
   <p>
   Physical access is an "advanced" feature attributed to APTs (or
   insiders). One of the main goals of an APT is the theft of
   sensitive information or Cyberspying. The following is just
   a <i>very simple example</i> of how an APT could infect a system
   and obtain persistence to posteriorly steal data of a user.

   The following summarizes the system configuration:
   <ul>
      <li>BIOS/UEFI is protected with password.</li>
      <li>GRUB2 edit mode is protected with password.</li>
      <li>External boots disabled: CDROM, DVD, USB, Netboot, PXE ...</li>
      <li>The user data (HOME) is ciphered.</li>
   </ul>


   <table width="90%" style="margin-left:auto; margin-right:auto;">
      <tr>
         <td style="text-align:center"><img  class="shad" src="bootSystemOverview.png" width="90%"/></td>
      </tr>
      <tr>
         <td style="text-align:center">Boot system Overview.<hr width="40%"/></td>
      </tr>
   </table>

   As pointed before, our goal is to steal data of an user. Since the
   data is ciphered, the strategy we will use is to infect the system
   and wait until the user decrypts the data (by login into the
   system) and then access to the information in plain.
   </p>



   <h3>Preparing the environment to deploy the malware</h3>
   <p> By patching the GRUB2 as shown before, we can easily edit the
<i>linux</i> entry to load a Linux kernel and get a root shell. This
is an old but still usable trick, just by
adding <tt><b>init=/bin/bash</b></tt> to the <i>linux</i> entry, we
will get a <b>root Linux shell</b>, which is a much more comfortable
environment for deploying our malware.  </p>

<table width="90%" style="margin-left:auto; margin-right:auto;">
   <tr>
      <td><img  class="shad"  src="GRUB_bin_bash.png" width="350px"/></td>
      <td><img class="shad"   src="root_shell-0.png" width="380px"/></td>
   </tr>
   <tr>
      <td style="text-align:center" >Adding <i>/bin/bash</i> to the <i>linux</i> GRUB2 command.</td>
      <td style="text-align:center" >Bash root shell in Linux.</td>
   </tr>
</table>

   <p>
   Note that since <tt>/bin/bash</tt> is the first process to run, the
   syslog daemon is not running, and so, logs are not recorded. That
   is, this access will not be detected using normal Linux monitoring.
   </p>

   <h3>Deploying the malware and obtaining persistence</h3>

   <p> 

   In order to show how far you could go by exploiting this 0-Day
   Grub2 vulnerability, we have developed a simple PoC. This PoC is a
   modified Firefox library which creates a new process and run a
   reverse shell to a controlled server at port 53. Obviously, this is
   a simple example, and a real malware will exfiltrate the
   information much more stealthily.
   </p>

   <p>
     
     
     The modified library was uploaded
     to <a href="https://www.virustotal.com"
     target="_blank">virustotal</a> reporting 0 infections/virus out
     of 55 tools. Firefox is a web browser that uses Internet, and
     makes requests to HTTP and DNS ports, so, it not appears to be
     suspicious that our malware talk with these ports.
     
   </p>

   <p>
   
   To infect the system we simply put our modified <tt>libplc4.so</tt>
   library into a USB and then replace the original one. We have to
   mount with write permissions the system and mount the USB as shown
   in the following picture:

   <table width="100%" style="margin-left:auto; margin-right:auto;">
      <tr>
         <td style="text-align:center"><img class="shad"
         src="root_shell-1.png" /></td>
      </tr>
      <tr>
         <td style="text-align:center">Infecting the system.<hr width="40%"/></td>
      </tr>
   </table>

   </p>

   <p>When any user executes the Firefox, a reverse shell will be
   invoked. At this time all data of the user is deciphered, allowing
   us to steal any kind of information of the user. The following
   picture, shows how the user Bob (the target) is using the Firefox
   and how the user Alice (the attacker) has full access to Bob's data.

   <table width="100%" >
      <tr>
         <td style="text-align:center">
	   <img  class="shad" src="firefox_reverse_shell-1.png" width="90%"/></td>
         <td style="text-align:center">
	   <img  class="shad" src="firefox_reverse_shell-2.png" width="400"/></td>
      </tr>
      <tr>
         <td style="text-align:center">
	   The <b>victim</b> browsing the web.
	 </td>
	   <td style="text-align:center">
	     The <b>attacker</b> with a reverse shell.
	   </td>
      </tr>
      <tr>
	<td colspan="2"><hr width="90%"/>
	</td>
      </tr>
   </table>


   To finish the persistence part, it worth to mention that by a
   simple Kernel modification that resides in the <i>/boot</i>
   partition, which by default is not ciphered, we can elevate
   privileges to deploy a more persistent malware. The imagination is
   the limit.
   </p>


         <h2 id="fix">The Fix</h2>
         The bug can be easily fixed just by preventing that <tt>cur_len</tt> 
         overflows. The main vendors are already aware of this vulnerability.

         By the way, we have created the following "emergency patch" from the
         main GRUB2 git repository:

<pre>
From 88c9657960a6c5d3673a25c266781e876c181add Mon Sep 17 00:00:00 2001
From: Hector Marco-Gisbert &lt;hecmargi@upv.es&gt;
Date: Fri, 13 Nov 2015 16:21:09 +0100
Subject: [PATCH] Fix security issue when reading username and password

  This patch fixes two integer underflows at:
    * grub-core/lib/crypto.c
    * grub-core/normal/auth.c

Signed-off-by: Hector Marco-Gisbert &lt;hecmargi@upv.es&gt;
Signed-off-by: Ismael Ripoll-Ripoll &lt;iripoll@disca.upv.es&gt;
---
 grub-core/lib/crypto.c  | 2 +-
 grub-core/normal/auth.c | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/grub-core/lib/crypto.c b/grub-core/lib/crypto.c
index 010e550..524a3d8 100644
<span style="color:red">--- a/grub-core/lib/crypto.c</span>
<span style="color:green">+++ b/grub-core/lib/crypto.c</span>
@@ -468,7 +468,7 @@ grub_password_get (char buf[], unsigned buf_size)
      break;
    }
 
<span style="color:red">-      if (key == '\b')</span>
<span style="color:green">+      if (key == '\b' && cur_len)</span>
    {
      cur_len--;
      continue;
diff --git a/grub-core/normal/auth.c b/grub-core/normal/auth.c
index c6bd96e..5782ec5 100644
<span style="color:red">--- a/grub-core/normal/auth.c</span>
<span style="color:green">+++ b/grub-core/normal/auth.c</span>
@@ -172,7 +172,7 @@ grub_username_get (char buf[], unsigned buf_size)
      break;
    }
 
<span style="color:red">-      if (key == '\b')</span>
<span style="color:green">+      if (key == '\b' && cur_len)</span>
    {
      cur_len--;
      grub_printf ("\b");
--
1.9.1
</pre>
   <a href="patches/0001-Fix-CVE-2015-8370-Grub2-user-pass-vulnerability.patch"
            target="_blank">[ 0001-Fix-CVE-2015-8370-Grub2-user-pass-vulnerability.patch ]</a> 

         <br/>
         <br/>
         Patching GRUB 2.02:
<pre>
$ git clone git://git.savannah.gnu.org/grub.git grub.git
$ cd grub.git
$ wget http://hmarco.org/bugs/patches/0001-Fix-CVE-2015-8370-Grub2-user-pass-vulnerability.patch
$ git apply 0001-Fix-CVE-2015-8370-Grub2-user-pass-vulnerability.patch
</pre>


    <h2 id="disc"> Discussion</h2>
        <p>
         The successfully exploitation of the vulnerability has been
         possible because we made a very deep analysis of all
         components involved in this bug. As can be seen, the
         successful exploitation depends on many things: the BIOS
         version, the GRUB version, the amount of RAM, and whatever
         that modifies the memory layout. And each system requires
         a deep analysis to build the specific exploit.
         </p>

	
        <p>Just to mention something that we have not used here:
         the <tt>grub_memset()</tt> function can be abused so that it
         sets to zero chunks of memory without jumping to 0x0, and the
         user and password buffers can be used to store payloads.
            </p>

         <p>
	   Also, in the case of more complex attacks (those which
	   require a large underflow or payload), it would be useful
	   to use a keyboard emulation device, as for example
	   the <a href="https://www.pjrc.com/teensy/"
	   target="_blank">Teensy device</a>. We can record the attack
	   sequence of pressed keys, and replay it on the target
	   system.
            </p>

            <p>Fortunately, the method presented here to exploit the
	      GRUB2 vulnerability is not generic, but there are other
	      alternatives that could work for you. Here we are only
	      presenting one that works for us.
            </p>

         <br/>
         <br/>

         <hr>
         Hector Marco - <a href="http://hmarco.org" >http://hmarco.org</a>
         <br/>
         <br/>


   </div>
   </body>
</html>
