Based on the provided content, all the commits relate to the same vulnerability fix, specifically addressing a potential reference count leak in the qcom-ebi2.c driver within the Linux kernel.  The vulnerability is triggered during device probe if reading the reg property fails when iterating through child nodes, causing a reference count leak for the 'child' node.

Here's a breakdown:

**Root cause of vulnerability:**
- A reference count leak can occur in the `qcom_ebi2_probe` function when iterating through the child nodes. If `of_property_read_u32(child, "reg", &csindex)` returns an error, the function would return without decrementing the reference count of the `child` node obtained via `for_each_available_child_of_node()`. This can lead to a memory leak.

**Weaknesses/vulnerabilities present:**
- Reference count leak. The `for_each_available_child_of_node` macro increments the reference count, which must be decremented with `of_node_put`. Failing to do so in error conditions leads to a leak.

**Impact of exploitation:**
- A reference count leak is a memory leak, where memory allocated by the kernel is not properly freed. If this occurs repeatedly, it can lead to the system running out of memory, causing denial-of-service, instability, and eventually crashing.

**Attack vectors:**
- The vulnerability is triggered during the device probe sequence. A malicious device tree or a vulnerable configuration could lead to this leak. The vulnerability can be triggered by an attacker having control over the device tree or by providing a device tree that results in the failure of the `of_property_read_u32` function during the probe.

**Required attacker capabilities/position:**
- The attacker needs to control the device tree or influence the device configuration to cause the `of_property_read_u32` function to fail during device probing. This would mean local access or the ability to provide malicious device tree data during system boot, often requiring some degree of privileged access.
- The attacker does not need to execute arbitrary code.

**Fix:**
The fix puts `of_node_put(child)` before the `return ret;` statement, ensuring that the child node's reference count is decremented in the error condition.
```c
- if (ret)
+ if (ret) {
+    of_node_put(child);
+    return ret;
+ }
```
This fix is consistent across all the provided commits.