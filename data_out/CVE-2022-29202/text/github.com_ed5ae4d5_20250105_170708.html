
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftensorflow%2Ftensorflow%2Fblob%2Ff3b9bf4c3c0597563b289c0512e98d4ce81f886e%2Ftensorflow%2Fpython%2Fops%2Fragged%2Fragged_factory_ops.py)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftensorflow%2Ftensorflow%2Fblob%2Ff3b9bf4c3c0597563b289c0512e98d4ce81f886e%2Ftensorflow%2Fpython%2Fops%2Fragged%2Fragged_factory_ops.py)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=tensorflow%2Ftensorflow)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[tensorflow](/tensorflow)
/
**[tensorflow](/tensorflow/tensorflow)**
Public

* [Notifications](/login?return_to=%2Ftensorflow%2Ftensorflow) You must be signed in to change notification settings
* [Fork
  74.4k](/login?return_to=%2Ftensorflow%2Ftensorflow)
* [Star
   187k](/login?return_to=%2Ftensorflow%2Ftensorflow)

* [Code](/tensorflow/tensorflow)
* [Issues
  831](/tensorflow/tensorflow/issues)
* [Pull requests
  5k+](/tensorflow/tensorflow/pulls)
* [Actions](/tensorflow/tensorflow/actions)
* [Projects
  2](/tensorflow/tensorflow/projects)
* [Security](/tensorflow/tensorflow/security)
* [Insights](/tensorflow/tensorflow/pulse)

Additional navigation options

* [Code](/tensorflow/tensorflow)
* [Issues](/tensorflow/tensorflow/issues)
* [Pull requests](/tensorflow/tensorflow/pulls)
* [Actions](/tensorflow/tensorflow/actions)
* [Projects](/tensorflow/tensorflow/projects)
* [Security](/tensorflow/tensorflow/security)
* [Insights](/tensorflow/tensorflow/pulse)

## Files

 f3b9bf4
## Breadcrumbs

1. [tensorflow](/tensorflow/tensorflow/tree/f3b9bf4c3c0597563b289c0512e98d4ce81f886e)
2. /[tensorflow](/tensorflow/tensorflow/tree/f3b9bf4c3c0597563b289c0512e98d4ce81f886e/tensorflow)
3. /[python](/tensorflow/tensorflow/tree/f3b9bf4c3c0597563b289c0512e98d4ce81f886e/tensorflow/python)
4. /[ops](/tensorflow/tensorflow/tree/f3b9bf4c3c0597563b289c0512e98d4ce81f886e/tensorflow/python/ops)
5. /[ragged](/tensorflow/tensorflow/tree/f3b9bf4c3c0597563b289c0512e98d4ce81f886e/tensorflow/python/ops/ragged)
/
# ragged\_factory\_ops.py

 Blame  Blame
## Latest commit

## History

[History](/tensorflow/tensorflow/commits/f3b9bf4c3c0597563b289c0512e98d4ce81f886e/tensorflow/python/ops/ragged/ragged_factory_ops.py)350 lines (296 loc) · 14.8 KB f3b9bf4
## Breadcrumbs

1. [tensorflow](/tensorflow/tensorflow/tree/f3b9bf4c3c0597563b289c0512e98d4ce81f886e)
2. /[tensorflow](/tensorflow/tensorflow/tree/f3b9bf4c3c0597563b289c0512e98d4ce81f886e/tensorflow)
3. /[python](/tensorflow/tensorflow/tree/f3b9bf4c3c0597563b289c0512e98d4ce81f886e/tensorflow/python)
4. /[ops](/tensorflow/tensorflow/tree/f3b9bf4c3c0597563b289c0512e98d4ce81f886e/tensorflow/python/ops)
5. /[ragged](/tensorflow/tensorflow/tree/f3b9bf4c3c0597563b289c0512e98d4ce81f886e/tensorflow/python/ops/ragged)
/
# ragged\_factory\_ops.py

Top
## File metadata and controls

* Code
* Blame

350 lines (296 loc) · 14.8 KB[Raw](https://github.com/tensorflow/tensorflow/raw/f3b9bf4c3c0597563b289c0512e98d4ce81f886e/tensorflow/python/ops/ragged/ragged_factory_ops.py)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350# Copyright 2018 The TensorFlow Authors. All Rights Reserved.## Licensed under the Apache License, Version 2.0 (the "License");# you may not use this file except in compliance with the License.# You may obtain a copy of the License at## http://www.apache.org/licenses/LICENSE-2.0## Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an "AS IS" BASIS,# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.# See the License for the specific language governing permissions and# limitations under the License.# =============================================================================="""Operations for constructing RaggedTensors."""
import numpy as np
from tensorflow.python.framework import constant\_opfrom tensorflow.python.framework import dtypesfrom tensorflow.python.framework import opsfrom tensorflow.python.framework import tensor\_shapefrom tensorflow.python.ops import array\_opsfrom tensorflow.python.ops.ragged import ragged\_tensorfrom tensorflow.python.ops.ragged import ragged\_tensor\_valuefrom tensorflow.python.util import dispatchfrom tensorflow.python.util.tf\_export import tf\_export
#===============================================================================# Op to construct a constant RaggedTensor from a nested Python list.#===============================================================================@tf\_export("ragged.constant")@dispatch.add\_dispatch\_supportdef constant(pylist, dtype=None, ragged\_rank=None, inner\_shape=None, name=None, row\_splits\_dtype=dtypes.int64): """Constructs a constant RaggedTensor from a nested Python list.
 Example:
 >>> tf.ragged.constant([[1, 2], [3], [4, 5, 6]]) <tf.RaggedTensor [[1, 2], [3], [4, 5, 6]]>
 All scalar values in `pylist` must have the same nesting depth `K`, and the returned `RaggedTensor` will have rank `K`. If `pylist` contains no scalar values, then `K` is one greater than the maximum depth of empty lists in `pylist`. All scalar values in `pylist` must be compatible with `dtype`.
 Args: pylist: A nested `list`, `tuple` or `np.ndarray`. Any nested element that is not a `list`, `tuple` or `np.ndarray` must be a scalar value compatible with `dtype`. dtype: The type of elements for the returned `RaggedTensor`. If not specified, then a default is chosen based on the scalar values in `pylist`. ragged\_rank: An integer specifying the ragged rank of the returned `RaggedTensor`. Must be nonnegative and less than `K`. Defaults to `max(0, K - 1)` if `inner\_shape` is not specified. Defaults to `max(0, K - 1 - len(inner\_shape))` if `inner\_shape` is specified. inner\_shape: A tuple of integers specifying the shape for individual inner values in the returned `RaggedTensor`. Defaults to `()` if `ragged\_rank` is not specified. If `ragged\_rank` is specified, then a default is chosen based on the contents of `pylist`. name: A name prefix for the returned tensor (optional). row\_splits\_dtype: data type for the constructed `RaggedTensor`'s row\_splits. One of `tf.int32` or `tf.int64`.
 Returns: A potentially ragged tensor with rank `K` and the specified `ragged\_rank`, containing the values from `pylist`.
 Raises: ValueError: If the scalar values in `pylist` have inconsistent nesting depth; or if ragged\_rank or inner\_shape are incompatible with `pylist`. """ def ragged\_factory(values, row\_splits): row\_splits = constant\_op.constant(row\_splits, dtype=row\_splits\_dtype) return ragged\_tensor.RaggedTensor.from\_row\_splits(values, row\_splits, validate=False)
 with ops.name\_scope(name, "RaggedConstant"): return \_constant\_value(ragged\_factory, constant\_op.constant, pylist, dtype, ragged\_rank, inner\_shape)
@tf\_export(v1=["ragged.constant\_value"])@dispatch.add\_dispatch\_supportdef constant\_value(pylist, dtype=None, ragged\_rank=None, inner\_shape=None, row\_splits\_dtype="int64"): """Constructs a RaggedTensorValue from a nested Python list.
 Warning: This function returns a `RaggedTensorValue`, not a `RaggedTensor`. If you wish to construct a constant `RaggedTensor`, use [`ragged.constant(...)`](constant.md) instead.
 Example:
 >>> tf.compat.v1.ragged.constant\_value([[1, 2], [3], [4, 5, 6]]) tf.RaggedTensorValue(values=array([1, 2, 3, 4, 5, 6]), row\_splits=array([0, 2, 3, 6]))
 All scalar values in `pylist` must have the same nesting depth `K`, and the returned `RaggedTensorValue` will have rank `K`. If `pylist` contains no scalar values, then `K` is one greater than the maximum depth of empty lists in `pylist`. All scalar values in `pylist` must be compatible with `dtype`.
 Args: pylist: A nested `list`, `tuple` or `np.ndarray`. Any nested element that is not a `list` or `tuple` must be a scalar value compatible with `dtype`. dtype: `numpy.dtype`. The type of elements for the returned `RaggedTensor`. If not specified, then a default is chosen based on the scalar values in `pylist`. ragged\_rank: An integer specifying the ragged rank of the returned `RaggedTensorValue`. Must be nonnegative and less than `K`. Defaults to `max(0, K - 1)` if `inner\_shape` is not specified. Defaults to `max(0, K - 1 - len(inner\_shape))` if `inner\_shape` is specified. inner\_shape: A tuple of integers specifying the shape for individual inner values in the returned `RaggedTensorValue`. Defaults to `()` if `ragged\_rank` is not specified. If `ragged\_rank` is specified, then a default is chosen based on the contents of `pylist`. row\_splits\_dtype: data type for the constructed `RaggedTensorValue`'s row\_splits. One of `numpy.int32` or `numpy.int64`.
 Returns: A `tf.RaggedTensorValue` or `numpy.array` with rank `K` and the specified `ragged\_rank`, containing the values from `pylist`.
 Raises: ValueError: If the scalar values in `pylist` have inconsistent nesting depth; or if ragged\_rank or inner\_shape are incompatible with `pylist`. """ if dtype is not None and isinstance(dtype, dtypes.DType): dtype = dtype.as\_numpy\_dtype row\_splits\_dtype = dtypes.as\_dtype(row\_splits\_dtype).as\_numpy\_dtype def \_ragged\_factory(values, row\_splits): row\_splits = np.array(row\_splits, dtype=row\_splits\_dtype) return ragged\_tensor\_value.RaggedTensorValue(values, row\_splits)
 def \_inner\_factory(pylist, dtype, shape, name=None): # pylint: disable=unused-argument return np.reshape(np.array(pylist, dtype=dtype), shape)
 return \_constant\_value(\_ragged\_factory, \_inner\_factory, pylist, dtype, ragged\_rank, inner\_shape)
def \_constant\_value(ragged\_factory, inner\_factory, pylist, dtype, ragged\_rank, inner\_shape): """Constructs a constant RaggedTensor or RaggedTensorValue.
 Args: ragged\_factory: A factory function with the signature: `ragged\_factory(values, row\_splits)` inner\_factory: A factory function with the signature: `inner\_factory(pylist, dtype, shape, name)` pylist: A nested `list`, `tuple` or `np.ndarray`. dtype: Data type for returned value. ragged\_rank: Ragged rank for returned value. inner\_shape: Inner value shape for returned value.
 Returns: A value returned by `ragged\_factory` or `inner\_factory`.
 Raises: ValueError: If the scalar values in `pylist` have inconsistent nesting depth; or if ragged\_rank or inner\_shape are incompatible with `pylist`. """ if ragged\_tensor.is\_ragged(pylist): raise TypeError("pylist may not be a RaggedTensor or RaggedTensorValue.") # np.ndim builds an array, so we short-circuit lists and tuples. if not isinstance(pylist, (list, tuple)) and np.ndim(pylist) == 0: # Scalar value if ragged\_rank is not None and ragged\_rank != 0: raise ValueError("Invalid pylist=%r: incompatible with ragged\_rank=%d" % (pylist, ragged\_rank)) if inner\_shape is not None and inner\_shape: raise ValueError( "Invalid pylist=%r: incompatible with dim(inner\_shape)=%d" % (pylist, len(inner\_shape))) return inner\_factory(pylist, dtype, ())
 if ragged\_rank is not None and ragged\_rank < 0: raise ValueError( "Invalid ragged\_rank=%r: must be nonnegative" % ragged\_rank)
 # Find the depth of scalar values in `pylist`. scalar\_depth, max\_depth = \_find\_scalar\_and\_max\_depth(pylist) if scalar\_depth is not None: if max\_depth > scalar\_depth: raise ValueError("Invalid pylist=%r: empty list nesting is greater " "than scalar value nesting" % pylist)
 # If both inner\_shape and ragged\_rank were specified, then check that # they are compatible with pylist. if inner\_shape is not None and ragged\_rank is not None: expected\_depth = ragged\_rank + len(inner\_shape) + 1 if ((scalar\_depth is not None and expected\_depth != scalar\_depth) or (scalar\_depth is None and expected\_depth < max\_depth)): raise ValueError( "Invalid pylist=%r: incompatible with ragged\_rank=%d " "and dim(inner\_shape)=%d" % (pylist, ragged\_rank, len(inner\_shape)))
 # Check if the result is a `Tensor`. if (ragged\_rank == 0 or (ragged\_rank is None and ((max\_depth < 2) or (inner\_shape is not None and max\_depth - len(inner\_shape) < 2)))): return inner\_factory(pylist, dtype, inner\_shape)
 # Compute default value for inner\_shape. if inner\_shape is None: if ragged\_rank is None: inner\_shape = () else: inner\_shape = \_default\_inner\_shape\_for\_pylist(pylist, ragged\_rank)
 # Compute default value for ragged\_rank. if ragged\_rank is None: if scalar\_depth is None: ragged\_rank = max(1, max\_depth - 1) else: ragged\_rank = max(1, scalar\_depth - 1 - len(inner\_shape))
 # Build the splits for each ragged rank, and concatenate the inner values # into a single list. nested\_splits = [] values = pylist for dim in range(ragged\_rank): nested\_splits.append([0]) concatenated\_values = [] for row in values: nested\_splits[dim].append(nested\_splits[dim][-1] + len(row)) concatenated\_values.extend(row) values = concatenated\_values
 values = inner\_factory( values, dtype=dtype, shape=(len(values),) + inner\_shape, name="values") for row\_splits in reversed(nested\_splits): values = ragged\_factory(values, row\_splits) return values
def \_find\_scalar\_and\_max\_depth(pylist): """Finds nesting depth of scalar values in pylist.
 Args: pylist: A nested python `list` or `tuple`.
 Returns: A tuple `(scalar\_depth, max\_depth)`. `scalar\_depth` is the nesting depth of scalar values in `pylist`, or `None` if `pylist` contains no scalars. `max\_depth` is the maximum depth of `pylist` (including empty lists).
 Raises: ValueError: If pylist has inconsistent nesting depths for scalars. """ # Check if pylist is not scalar. np.ndim builds an array, so we # short-circuit lists and tuples. if isinstance(pylist, (list, tuple)) or np.ndim(pylist) != 0: scalar\_depth = None max\_depth = 1 for child in pylist: child\_scalar\_depth, child\_max\_depth = \_find\_scalar\_and\_max\_depth(child) if child\_scalar\_depth is not None: if scalar\_depth is not None and scalar\_depth != child\_scalar\_depth + 1: raise ValueError("all scalar values must have the same nesting depth") scalar\_depth = child\_scalar\_depth + 1 max\_depth = max(max\_depth, child\_max\_depth + 1) return (scalar\_depth, max\_depth) return (0, 0)
def \_default\_inner\_shape\_for\_pylist(pylist, ragged\_rank): """Computes a default inner shape for the given python list."""
 def get\_inner\_shape(item): """Returns the inner shape for a python list `item`.""" if not isinstance(item, (list, tuple)) and np.ndim(item) == 0: return () # Note that we need this check here in case `item` is not a Python list but # fakes as being one (pylist). For a scenario of this, see test added in # https://github.com/tensorflow/tensorflow/pull/48945 elif len(item) > 0: # pylint: disable=g-explicit-length-test return (len(item),) + get\_inner\_shape(item[0]) return (0,)
 def check\_inner\_shape(item, shape): """Checks that `item` has a consistent shape matching `shape`.""" is\_nested = isinstance(item, (list, tuple)) or np.ndim(item) != 0 if is\_nested != bool(shape): raise ValueError("inner values have inconsistent shape") if is\_nested: if shape[0] != len(item): raise ValueError("inner values have inconsistent shape") for child in item: check\_inner\_shape(child, shape[1:])
 # Collapse the ragged layers to get the list of inner values. flat\_values = pylist for dim in range(ragged\_rank): if not all( isinstance(v, (list, tuple)) or np.ndim(v) != 0 for v in flat\_values): raise ValueError("pylist has scalar values depth %d, but ragged\_rank=%d " "requires scalar value depth greater than %d" % (dim + 1, ragged\_rank, ragged\_rank)) flat\_values = sum((list(v) for v in flat\_values), [])
 # Compute the inner shape looking only at the leftmost elements; and then # use check\_inner\_shape to verify that other elements have the same shape. inner\_shape = get\_inner\_shape(flat\_values) check\_inner\_shape(flat\_values, inner\_shape) return inner\_shape[1:]
@tf\_export(v1=["ragged.placeholder"])@dispatch.add\_dispatch\_supportdef placeholder(dtype, ragged\_rank, value\_shape=None, name=None): """Creates a placeholder for a `tf.RaggedTensor` that will always be fed.
 \*\*Important\*\*: This ragged tensor will produce an error if evaluated. Its value must be fed using the `feed\_dict` optional argument to `Session.run()`, `Tensor.eval()`, or `Operation.run()`.
 @compatibility{eager} Placeholders are not compatible with eager execution.
 Args: dtype: The data type for the `RaggedTensor`. ragged\_rank: The ragged rank for the `RaggedTensor` value\_shape: The shape for individual flat values in the `RaggedTensor`. name: A name for the operation (optional).
 Returns: A `RaggedTensor` that may be used as a handle for feeding a value, but not evaluated directly.
 Raises: RuntimeError: if eager execution is enabled """ if ragged\_rank == 0: return array\_ops.placeholder(dtype, value\_shape, name)
 with ops.name\_scope(name, "RaggedPlaceholder", []): flat\_shape = tensor\_shape.TensorShape([None]).concatenate(value\_shape) result = array\_ops.placeholder(dtype, flat\_shape, "flat\_values") for i in reversed(range(ragged\_rank)): row\_splits = array\_ops.placeholder(dtypes.int64, [None], "row\_splits\_%d" % i) result = ragged\_tensor.RaggedTensor.from\_row\_splits(result, row\_splits, validate=False) return result

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

