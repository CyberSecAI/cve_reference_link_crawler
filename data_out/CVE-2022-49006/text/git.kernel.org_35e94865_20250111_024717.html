

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=4313e5a613049dfc1819a6dfb5f94cf2caff9452)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=4313e5a613049dfc1819a6dfb5f94cf2caff9452)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=4313e5a613049dfc1819a6dfb5f94cf2caff9452)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=4313e5a613049dfc1819a6dfb5f94cf2caff9452)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Steven Rostedt (Google) <rostedt@goodmis.org> | 2022-11-23 17:14:34 -0500 |
| --- | --- | --- |
| committer | Steven Rostedt (Google) <rostedt@goodmis.org> | 2022-11-23 19:07:12 -0500 |
| commit | [4313e5a613049dfc1819a6dfb5f94cf2caff9452](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=4313e5a613049dfc1819a6dfb5f94cf2caff9452) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=4313e5a613049dfc1819a6dfb5f94cf2caff9452)) | |
| tree | [9987d0334efa762f324680855f9d5916ba4807d1](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=4313e5a613049dfc1819a6dfb5f94cf2caff9452) | |
| parent | [e18eb8783ec4949adebc7d7b0fdb65f65bfeefd9](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e18eb8783ec4949adebc7d7b0fdb65f65bfeefd9) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=4313e5a613049dfc1819a6dfb5f94cf2caff9452&id2=e18eb8783ec4949adebc7d7b0fdb65f65bfeefd9)) | |
| download | [linux-4313e5a613049dfc1819a6dfb5f94cf2caff9452.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-4313e5a613049dfc1819a6dfb5f94cf2caff9452.tar.gz) | |

tracing: Free buffers when a used dynamic event is removedAfter 65536 dynamic events have been added and removed, the "type" field
of the event then uses the first type number that is available (not
currently used by other events). A type number is the identifier of the
binary blobs in the tracing ring buffer (known as events) to map them to
logic that can parse the binary blob.
The issue is that if a dynamic event (like a kprobe event) is traced and
is in the ring buffer, and then that event is removed (because it is
dynamic, which means it can be created and destroyed), if another dynamic
event is created that has the same number that new event's logic on
parsing the binary blob will be used.
To show how this can be an issue, the following can crash the kernel:
# cd /sys/kernel/tracing
# for i in `seq 65536`; do
echo 'p:kprobes/foo do\_sys\_openat2 $arg1:u32' > kprobe\_events
# done
For every iteration of the above, the writing to the kprobe\_events will
remove the old event and create a new one (with the same format) and
increase the type number to the next available on until the type number
reaches over 65535 which is the max number for the 16 bit type. After it
reaches that number, the logic to allocate a new number simply looks for
the next available number. When an dynamic event is removed, that number
is then available to be reused by the next dynamic event created. That is,
once the above reaches the max number, the number assigned to the event in
that loop will remain the same.
Now that means deleting one dynamic event and created another will reuse
the previous events type number. This is where bad things can happen.
After the above loop finishes, the kprobes/foo event which reads the
do\_sys\_openat2 function call's first parameter as an integer.
# echo 1 > kprobes/foo/enable
# cat /etc/passwd > /dev/null
# cat trace
cat-2211 [005] .... 2007.849603: foo: (do\_sys\_openat2+0x0/0x130) arg1=4294967196
cat-2211 [005] .... 2007.849620: foo: (do\_sys\_openat2+0x0/0x130) arg1=4294967196
cat-2211 [005] .... 2007.849838: foo: (do\_sys\_openat2+0x0/0x130) arg1=4294967196
cat-2211 [005] .... 2007.849880: foo: (do\_sys\_openat2+0x0/0x130) arg1=4294967196
# echo 0 > kprobes/foo/enable
Now if we delete the kprobe and create a new one that reads a string:
# echo 'p:kprobes/foo do\_sys\_openat2 +0($arg2):string' > kprobe\_events
And now we can the trace:
# cat trace
sendmail-1942 [002] ..... 530.136320: foo: (do\_sys\_openat2+0x0/0x240) arg1= cat-2046 [004] ..... 530.930817: foo: (do\_sys\_openat2+0x0/0x240) arg1="������������������������������������������������������������������������������������������������"
cat-2046 [004] ..... 530.930961: foo: (do\_sys\_openat2+0x0/0x240) arg1="������������������������������������������������������������������������������������������������"
cat-2046 [004] ..... 530.934278: foo: (do\_sys\_openat2+0x0/0x240) arg1="������������������������������������������������������������������������������������������������"
cat-2046 [004] ..... 530.934563: foo: (do\_sys\_openat2+0x0/0x240) arg1="������������������������������������������������������������������������������������������������"
bash-1515 [007] ..... 534.299093: foo: (do\_sys\_openat2+0x0/0x240) arg1="kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk���������@��4Z����;Y�����U
And dmesg has:
==================================================================
BUG: KASAN: use-after-free in string+0xd4/0x1c0
Read of size 1 at addr ffff88805fdbbfa0 by task cat/2049
CPU: 0 PID: 2049 Comm: cat Not tainted 6.1.0-rc6-test+ #641
Hardware name: Hewlett-Packard HP Compaq Pro 6300 SFF/339A, BIOS K01 v03.03 07/14/2016
Call Trace:
<TASK>
dump\_stack\_lvl+0x5b/0x77
print\_report+0x17f/0x47b
kasan\_report+0xad/0x130
string+0xd4/0x1c0
vsnprintf+0x500/0x840
seq\_buf\_vprintf+0x62/0xc0
trace\_seq\_printf+0x10e/0x1e0
print\_type\_string+0x90/0xa0
print\_kprobe\_event+0x16b/0x290
print\_trace\_line+0x451/0x8e0
s\_show+0x72/0x1f0
seq\_read\_iter+0x58e/0x750
seq\_read+0x115/0x160
vfs\_read+0x11d/0x460
ksys\_read+0xa9/0x130
do\_syscall\_64+0x3a/0x90
entry\_SYSCALL\_64\_after\_hwframe+0x63/0xcd
RIP: 0033:0x7fc2e972ade2
Code: c0 e9 b2 fe ff ff 50 48 8d 3d b2 3f 0a 00 e8 05 f0 01 00 0f 1f 44 00 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 0f 05 <48> 3d 00 f0 ff ff 77 56 c3 0f 1f 44 00 00 48 83 ec 28 48 89 54 24
RSP: 002b:00007ffc64e687c8 EFLAGS: 00000246 ORIG\_RAX: 0000000000000000
RAX: ffffffffffffffda RBX: 0000000000020000 RCX: 00007fc2e972ade2
RDX: 0000000000020000 RSI: 00007fc2e980d000 RDI: 0000000000000003
RBP: 00007fc2e980d000 R08: 00007fc2e980c010 R09: 0000000000000000
R10: 0000000000000022 R11: 0000000000000246 R12: 0000000000020f00
R13: 0000000000000003 R14: 0000000000020000 R15: 0000000000020000
</TASK>
The buggy address belongs to the physical page:
page:ffffea00017f6ec0 refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x5fdbb
flags: 0xfffffc0000000(node=0|zone=1|lastcpupid=0x1fffff)
raw: 000fffffc0000000 0000000000000000 ffffea00017f6ec8 0000000000000000
raw: 0000000000000000 0000000000000000 00000000ffffffff 0000000000000000
page dumped because: kasan: bad access detected
Memory state around the buggy address:
ffff88805fdbbe80: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
ffff88805fdbbf00: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
>ffff88805fdbbf80: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
^
ffff88805fdbc000: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
ffff88805fdbc080: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
==================================================================
This was found when Zheng Yejian sent a patch to convert the event type
number assignment to use IDA, which gives the next available number, and
this bug showed up in the fuzz testing by Yujie Liu and the kernel test
robot. But after further analysis, I found that this behavior is the same
as when the event type numbers go past the 16bit max (and the above shows
that).
As modules have a similar issue, but is dealt with by setting a
"WAS\_ENABLED" flag when a module event is enabled, and when the module is
freed, if any of its events were enabled, the ring buffer that holds that
event is also cleared, to prevent reading stale events. The same can be
done for dynamic events.
If any dynamic event that is being removed was enabled, then make sure the
buffers they were enabled in are now cleared.
Link: [https://lkml.kernel.org/r/20221123171434.545706e3@gandalf.local.home](https://lkml.kernel.org/r/20221123171434.545706e3%40gandalf.local.home)
Link: [https://lore.kernel.org/all/20221110020319.1259291-1-zhengyejian1@huawei.com/](https://lore.kernel.org/all/20221110020319.1259291-1-zhengyejian1%40huawei.com/)
Cc: stable@vger.kernel.org
Cc: Andrew Morton <akpm@linux-foundation.org>
Depends-on: e18eb8783ec49 ("tracing: Add tracing\_reset\_all\_online\_cpus\_unlocked() function")
Depends-on: 5448d44c38557 ("tracing: Add unified dynamic event framework")
Depends-on: 6212dd29683ee ("tracing/kprobes: Use dyn\_event framework for kprobe events")
Depends-on: 065e63f951432 ("tracing: Only have rmmod clear buffers that its events were active in")
Depends-on: 575380da8b469 ("tracing: Only clear trace buffer on module unload if event was traced")
Fixes: 77b44d1b7c283 ("tracing/kprobes: Rename Kprobe-tracer to kprobe-event")
Reported-by: Zheng Yejian <zhengyejian1@huawei.com>
Reported-by: Yujie Liu <yujie.liu@intel.com>
Reported-by: kernel test robot <yujie.liu@intel.com>
Acked-by: Masami Hiramatsu (Google) <mhiramat@kernel.org>
Signed-off-by: Steven Rostedt (Google) <rostedt@goodmis.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=4313e5a613049dfc1819a6dfb5f94cf2caff9452)

| -rw-r--r-- | [kernel/trace/trace\_dynevent.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/trace/trace_dynevent.c?id=4313e5a613049dfc1819a6dfb5f94cf2caff9452) | 2 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [kernel/trace/trace\_events.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/trace/trace_events.c?id=4313e5a613049dfc1819a6dfb5f94cf2caff9452) | 11 | |  |  |  | | --- | --- | --- | |

2 files changed, 12 insertions, 1 deletions

| diff --git a/kernel/trace/trace\_dynevent.c b/kernel/trace/trace\_dynevent.cindex 154996684fb548..4376887e0d8aab 100644--- a/[kernel/trace/trace\_dynevent.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace_dynevent.c?id=e18eb8783ec4949adebc7d7b0fdb65f65bfeefd9)+++ b/[kernel/trace/trace\_dynevent.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace_dynevent.c?id=4313e5a613049dfc1819a6dfb5f94cf2caff9452)@@ -118,6 +118,7 @@ int dyn\_event\_release(const char \*raw\_command, struct dyn\_event\_operations \*type if (ret) break; }+ tracing\_reset\_all\_online\_cpus(); mutex\_unlock(&event\_mutex); out: argv\_free(argv);@@ -214,6 +215,7 @@ int dyn\_events\_release\_all(struct dyn\_event\_operations \*type) break; } out:+ tracing\_reset\_all\_online\_cpus(); mutex\_unlock(&event\_mutex);  return ret;diff --git a/kernel/trace/trace\_events.c b/kernel/trace/trace\_events.cindex 78cd19e31dba13..f71ea6e79b3c8e 100644--- a/[kernel/trace/trace\_events.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace_events.c?id=e18eb8783ec4949adebc7d7b0fdb65f65bfeefd9)+++ b/[kernel/trace/trace\_events.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/trace/trace_events.c?id=4313e5a613049dfc1819a6dfb5f94cf2caff9452)@@ -2880,7 +2880,10 @@ static int probe\_remove\_event\_call(struct trace\_event\_call \*call) \* TRACE\_REG\_UNREGISTER. \*/ if (file->flags & EVENT\_FILE\_FL\_ENABLED)- return -EBUSY;+ goto busy;++ if (file->flags & EVENT\_FILE\_FL\_WAS\_ENABLED)+ tr->clear\_trace = true; /\* \* The do\_for\_each\_event\_file\_safe() is \* a double loop. After finding the call for this@@ -2893,6 +2896,12 @@ static int probe\_remove\_event\_call(struct trace\_event\_call \*call) \_\_trace\_remove\_event\_call(call);  return 0;+ busy:+ /\* No need to clear the trace now \*/+ list\_for\_each\_entry(tr, &ftrace\_trace\_arrays, list) {+ tr->clear\_trace = false;+ }+ return -EBUSY; }  /\* Remove an event\_call \*/ |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 02:45:54 +0000

