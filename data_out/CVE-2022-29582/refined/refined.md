```json
{
  "guidelines_version": "4",
  "relevant": true,
  "cve": "CVE-2022-29582",
  "root_cause": "A use-after-free vulnerability exists due to a race condition between the timeout flush and removal in the Linux kernel's io_uring subsystem. When IORING_OP_TIMEOUT and IORING_OP_LINK_TIMEOUT opcodes are combined in a linked submission queue entry, and another request completes concurrently, T is cancelled, and LT is cancelled by its hrtimer at the same time. When T is cleaned up, it retains a dangling reference to LT, which has already been freed by another execution context.",
  "weaknesses": [
    "Use-after-free",
    "Race condition",
    "Dangling pointer"
  ],
  "impact": "Local privilege escalation to system root. An attacker can reallocate the freed memory of LT, deferring the UaF to another struct, such as a `struct file`. By doing so, it could gain arbitrary read/write access, or obtain code execution in kernel space, resulting in a full system takeover.",
  "attack_vectors": {
    "local": true
  },
  "required_capabilities": "No special privileges are required to trigger this vulnerability. It can be triggered from an unprivileged process, even inside a container.",
    "additional_details": "The vulnerability is triggered when an application combines IORING_OP_TIMEOUT and IORING_OP_LINK_TIMEOUT opcodes in a linked submission queue entry. Exploitation involves racing the cleanup routines for the two operations, such that the linked timeout structure is freed before the parent timeout is cleaned up."
}
```