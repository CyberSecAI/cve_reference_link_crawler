
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ficing%2Fmod_h2%2Fblob%2F0a864782af0a942aa2ad4ed960a6b32cd35bcf0a%2Fmod_http2%2FREADME.md%3Fplain%3D1)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ficing%2Fmod_h2%2Fblob%2F0a864782af0a942aa2ad4ed960a6b32cd35bcf0a%2Fmod_http2%2FREADME.md%3Fplain%3D1)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=icing%2Fmod_h2)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[icing](/icing)
/
**[mod\_h2](/icing/mod_h2)**
Public

* [Notifications](/login?return_to=%2Ficing%2Fmod_h2) You must be signed in to change notification settings
* [Fork
  40](/login?return_to=%2Ficing%2Fmod_h2)
* [Star
   256](/login?return_to=%2Ficing%2Fmod_h2)

* [Code](/icing/mod_h2)
* [Issues
  16](/icing/mod_h2/issues)
* [Pull requests
  4](/icing/mod_h2/pulls)
* [Actions](/icing/mod_h2/actions)
* [Projects
  0](/icing/mod_h2/projects)
* [Wiki](/icing/mod_h2/wiki)
* [Security](/icing/mod_h2/security)
* [Insights](/icing/mod_h2/pulse)

Additional navigation options

* [Code](/icing/mod_h2)
* [Issues](/icing/mod_h2/issues)
* [Pull requests](/icing/mod_h2/pulls)
* [Actions](/icing/mod_h2/actions)
* [Projects](/icing/mod_h2/projects)
* [Wiki](/icing/mod_h2/wiki)
* [Security](/icing/mod_h2/security)
* [Insights](/icing/mod_h2/pulse)

## Files

 0a86478
## Breadcrumbs

1. [mod\_h2](/icing/mod_h2/tree/0a864782af0a942aa2ad4ed960a6b32cd35bcf0a)
2. /[mod\_http2](/icing/mod_h2/tree/0a864782af0a942aa2ad4ed960a6b32cd35bcf0a/mod_http2)
/
# README.md

Copy path Blame  Blame
## Latest commit

## History

[History](/icing/mod_h2/commits/0a864782af0a942aa2ad4ed960a6b32cd35bcf0a/mod_http2/README.md)249 lines (151 loc) · 18.7 KB 0a86478
## Breadcrumbs

1. [mod\_h2](/icing/mod_h2/tree/0a864782af0a942aa2ad4ed960a6b32cd35bcf0a)
2. /[mod\_http2](/icing/mod_h2/tree/0a864782af0a942aa2ad4ed960a6b32cd35bcf0a/mod_http2)
/
# README.md

Top
## File metadata and controls

* Preview
* Code
* Blame

249 lines (151 loc) · 18.7 KB[Raw](https://github.com/icing/mod_h2/raw/0a864782af0a942aa2ad4ed960a6b32cd35bcf0a/mod_http2/README.md)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248# mod\_h2 internals
A description of how the module's structure, the main terms used and how it overall works.
While the complete and accurate description will always be the source code, this document is intendedto serve as an entrance to understand how the module works and what its main moving parts are.
## Terms
 \* `c1`: a \*primary\* connection. This is a connection to a HTTP/2 client. \* `c2`: a \*secondary\* connection. This is an internal, virtual one used to process a request. \* `session`: the HTTP/2 state for a particular `c1` connection. \* `stream`: a HTTP/2 stream that (commonly) carries a request+body and delivers a response+body. Each stream has a unique 32 bit identifier, as defined in the HTTP/2 protocol. Stream 0 is the c1 connection itself. \* `mplx`: the multiplexer, one per `session`. It processes streams, forwards input (request bodies) and collects output from processing. To process a stream, it creates a `c2` connection. \* `worker`: polling all registered `mplx`s for `c2` connections to process. `mplx`s registers themselves at the workers when they have something to process. \* `slot`: a particular worker thread. The number of workers may vary based on server load and configuration. \* `beam`: a mechanism for transferring APR's \*buckets\* between `c1`and `c2`. More under memory.
## File Structure
Source files are all prefixed with `h2\_` followed by the main topic they are about. `h2\_c2\_filter` for example contains all input/output filter code for `c2` connections. `h2\_session` is all about the `session` instances. etc.
## Session States
HTTP/2 sessions can be in one of the following states:
 \* `INIT`: state during initialization of the session. Sends initial SETTINGS to client and transits to `BUSY` on success. \* `BUSY`: reading `c1` input, writing frames on `c1` output and checking any `c2` for I/O events. Switches to `WAIT` when `c1` input is exhausted. \* `WAIT`: collects `c1` socket and all `c2` pipes into a pollset and does a wait with connection timeout on events. Transits on `c1` input to `BUSY` again. \* `IDLE`: there are no streams to process. The session waits on new `c1` input to arrive. If a stream has been processed already, this is like a HTTP/1 \*keepalive\*. \* `DONE`: session is done processing streams and shuts down. Possibly a last GOAWAY frame is being sent. Transits to `CLEANUP` when the protocol needs have been taken care of. \* `CLEANUP`: release all internal resources. Make sure that any ongoing `c2` processing terminates.
There a sub-states in the `BUSY` and `WAIT` handling. A session may chose to no longer accept new streams from the clients while finishing processing all ongoing streams. This is, for example, triggered by a graceful shutdown of the child process. Errors and timeouts on the `c1` connection trigger a transition to `DONE`.  ## Stream States
These mostly correspond to the states described in the HTTP/2 standard, with some additions for internal handling:
 \* `IDLE`: a stream has been created by a request from the client. \* `OPEN`: all request headers have arrived. The stream can start processing. \* `RSVD\_R`: the stream (identifier) has been reserved by the client (remote). \* `RSVD\_L`: the stream (identifier) has been reserved by the session (locally). \* `CLOSED\_R`: stream was closed by the client (remote). A (possibly empty) request body is complete. \* `CLOSED\_L`: stream was closed by the session (locally) and the output is complete. \* `CLOSED`: both stream \*ends\* have been closed. \* `CLEANUP`: the session is done with the stream, its resources may be reclaimed. Such a stream is handed over to the `mplx` which performs the reclamation. This needs to take care of a potentially still running `c2` connection.
A `mplx` maintains three `stream` lists:
 \* `streams`: the active streams which are being processed (or scheduled to be). \* `shold`: the streams in `CLEANUP` which have an ongoing `c2` connection that needs to terminate first. \* `spurge`: the streams without or with a finished `c2` that can be reclaimed. ## Memory
### Setup
The APR memory model with its `pools` determines much of `mod\_h2`'s structure, initialization and resource reclamation strategies. `pools` are the foundation of everything in Apache `httpd`: lists, tables, files, pipes, sockets, data and meta data transfers (`bucket`s) are tied to them.
The fundamental restriction of `pools` is that they are not thread safe. Using the same pool from 2 threads will mess up its internal lists. The more busy the server is, the more likely this will then happen. Since everything one does with APR's features has the potential to modify its underlying pool, all the things listed above are not thread safe.
Closing a file will modify the pool it was opened with, for example. If 10 files are opened with the same pool, one is unable to use 5 of them in one thread and the rest in another. Everything that is based on the same pool needs to stay on the same thread.
A `session` handling `c1` needs to run in parallel to request processing on `c2` connections. That means `session` and `c2`s have completely separate pools.
When a session creates a stream, it creates a new \*child\* pool for it. Pool memory can only be freed by destroying the whole pool. To handle thousands of streams without leaking memory, they have to be placed in child pools that can be reclaimed when a stream is done.
A `mplx` is used by the `session` \*and\* by `c2` connections. To manage its internal structures, it also needs its own, separate pool. This one is protects via its `mutex`. It creates new `c2` connections when needed also with separate pools as processing happens in separate `worker` threads.
All these \*separate\* pools have their own APR `allocator` (the one that manages system memory) to be independent. However, there are still tied with a \*parent/child\* relationship to not lose track of them (leaking). So `c2` pools are children of `mplx` pool which is a child of the `session` pool.
### Teardown
When destroying a pool, it modifies its parent pool. When reclaiming a `c2` pool, the `mplx` pool will be changed. So, this can only be allowed to happen inside the `mplx` mutex protection. When reclaiming the `mplx`, it modifies the `session` pool. So this may only happen on the thread that works on `session`.
This means that tearing down a `session` needs to tear down the `mplx` which needs to tear down all its `c2` connections first. Or else.
### Stream Memory
Streams have their own input/output buffers, allocated from their own pool. Similar to "normal" HTTP/1 requests, they need to take care that all their outgoing data on `c1` has actually been sent, before they can be destroyed. HTTP/1 uses the `EOR` meta bucket for that. HTTP/2 has a `H2\_EOS` bucket that is similar.
On closing a stream, a `H2\_EOS` is created and send on `c1`. When this bucket is destroyed, the stream is handed to `mplx` for safe destruction. `mplx` then removes the stream from its list of active ones. It places it on its `spurge` list when the stream has no `c2`or it has already returned from the `worker`. For an active `c2`, the stream is placed into `shold`.
When a `worker` tells an `mplx` that it has finished a `c2`, the `mplx` checks if the stream is still active or if it is found in `shold`. If the stream is in `shold`, it is moved to `spurge`. It cannot be destroyed right away, since the stream's pool is a child of `session`. That would manipulate the session pool from inside a worker thread.
The purge list is instead only processed, when `session` calls the `mplx`.
### Data Transfer
With all this pool touchiness, how does request/response/bodies ever get transferred between a `stream` and its `c2` connection that does the actual work? That merits its own chapter about `bucket beams`.
## Bucket Beams
Apache httpd uses APR's `bucket brigade`s to transfer data and meta information through its connection filters. So, whatever also one does, ultimately `streams` and `c2` connections will use brigades.
The problem is: \*\*it is impossible to transfer a bucket from one brigade to another between threads\*\*.
A bucket belongs to a `bucket\_alloc` which belongs to a memory pool. All three are not thread safe and tied. Imagine transferring from brigade `b1` on thread `t1` into brigade `b2` on thread `t2`:
 \* `t1` can take data out of `b1`, but cannot put it into `b2`. \* `t2` can put data into `b2`, but cannot take it out of `b1`.
So, mod\_h2 needs something to juggle the data in between `t1` and `t2` doing their thing. That is the job of a bucket beam.
(\*The name\* "beam" is inspired by Start Trek beam technology, where people are transported from one place to another - but not instantly. They first become frozen and semi-transparent at both location, until the arrival is complete and then they disappear at the start. Same happens to buckets in a bucket beam.)
A bucket beam has two APR `ring`s (rings are a doubly linked list that works \*\*independent\*\* from pools. Yay!).
 \* `buckets\_to\_send`: when `t1` calls `h2\_beam\_send(beam, b1)`, the beam takes buckets out of `b1` and appends them to this ring.  \* `buckets\_consumed`: when `t2` calls `h2\_beam\_receive(beam, brigade)`, buckets are taken from the to\_send ring, converted to new buckets (which are appended to the receiver `brigage`) and the original ones are added to the 'consumed' ring.
The buckets in `buckets\_consumed` can then be destroyed the next time that thread `t1` calls.
### Bucket Conversions
Buckets in a beam are "converted" into new buckets (the originals from 'to\_send' are readonly). For well known meta buckets, just a new one of the corresponding type is created and added to the receiver brigade.
This concerns 'eos', 'flush' and 'error' buckets. Several other meta buckets are not converted. For example the 'eor' bucket is not passed on in any from, just added to the `buckets\_consumed` ring on transfer. This is important to make sure that all sent buckets are destroyed in the correct order.
Data buckets have their data and length extracted via `apr\_bucket\_read()` and the data is written to the receiver brigade. This makes a copy of the data. Special handling is done for 'file' and 'mmap' buckets where the file/mmap itself is `dup`ed and added to the receiver. This allows transfer of large response bodies without copying any data.
For additional conversions, beams allow registration of conversion functions. All unknown buckets are passed to them. They may add their own converted buckets to the receiver brigade.
### Beam Memory
Bucket beams can be configured with a buffer limit. This blocks senders when they try to add more (data) buckets than the limit allows. They become unblocked when a receiver takes data out. Data buckets of type 'file' or 'mmap' are not counted against this limit, as they do not really occupy memory in the beam's buffer. At least not additional memory as the sender already has created these buckets.
### Efficiency
While the response to a HTTP/2 request is being generated, the request occupies a h2 worker thread. Once theresponse is complete (headers and body buckets), and all buckets have been passed through the filter chain, therequest processing returns and the worker can be used for other requests.
Buckets, however, can only be passed when they do not exceed the memory limitations for a HTTP/2 stream. Sendingbuckets on the output stream will block, when this limit is reached, and that blocks the worker thread.
Fortunately, for static files, this limit is never reached, as file buckets have a tiny memory footprint untiltheir data is actually read. Beams will accept file buckets of any length without blocking. The same is truefor mmap buckets. Serving static files will only shortly occupy workers to lookup the file and set the response headers and all other work then happens on the c1 connection itself.
## Polling
The module `mplx` uses pipes and pollsets to monitor communications on `c1` and `c2`:
 \* for `c1` it polls the connection's \*socket\* for new incoming data. \* for `c2`s it polls `pipe\_out\_prod`, a pipe used for signalling the availability of new output. \* for `c2`s it polls `pipe\_in\_drain`, a pipe used for signalling that input has been read by `c2` (if the stream processing on a `c2` has indeed input, e.g. a request body).
The HTTP/2 protocol has in-built flow control on its streams. `c1` needs to be continuously monitored not only for new requests, but also for updates on flow control window sizes.
Flow control also is in effect for clients sending data to the server, e.g. in a POST request. That is why the consumption of such input data is being monitored. When data is passed on to a `c2`'s input, the stream's window for the client is updated (and the update sent to the client on `c1`), so more POST data can be sent.
In this way, a HTTP/2 connection is much more busy in both directions than HTTP/1 where there is a clear separation between sending and receiving phases for a request.
For `c2`s expecting input, an additional pipe is being created: `pipe\_in\_prod` which signals when `c1` has written new data to the `c2` input. This pipe is read by a `c2` waiting for additional data.
The bucket beams have callbacks for various events that are used to feed these pipes:
 \* `h2\_beam\_on\_received()`: used to signal that `c2` input has been read. \* `h2\_beam\_on\_was\_empty()`: used to signal the addition of new data.
This way, sending/receiving on a bucket beam adds notifications to the pipes.
### Timeouts
When a `session` is in state `WAIT`, it polls using the `c1` connection timeout. If polling times out, the session is shut down.
To enter `WAIT` state, a `session` needs to be sure that there is no pending data in `c1`'s input filters. A `session` enters `BUSY` state whenever it is not certain about this. A `BUSY` session uses the pollset with timeout 0, which immediately returns, and tries to read/write more on the `c1` connection.
Eventually, it will detect that `c1` input filters have nothing buffered any more and enter `WAIT` state.
A `session` enters `IDLE` state when it has no more streams to process and nothing more to send. It will then poll with a very short timeout and, when nothing changes, return the `c1` connection to the `mpm` for "keepalive" monitoring.
## Workers
The modules has its own worker pool, separate from the `mpm` worker thread. This is mostly for historical reasons, asHTTP/2 came late into the server, but separate pools make sense in order for the workers not to deadlock themselves (all workers holding a `c1` and waiting for a free worker to process their `c2`s).
The h2 workers have a fixed number of `slots` for threads and start a minimal number (all configurable). Additional threads are added in a busy situation up to the number of available slots. When such a slot becomes idle for a number of seconds (configurable), it shuts down again. Also, inactive workers shut down when the server does a graceful reload.
h2 workers manage a queue of `mplx` instances that have work to be done. An idle worker removes an mplx from the queue and asks it for a `c2` to process. When done, it informs the `mplx` that it has finished the `c2` and if it is willing to work on another `c2` from this `mplx`. It is only willing to do so when the maximum worker count has not been reached yet.
The reason for this design are:
 \* all `mplx` are for a particular `c1` and all `c1` should be treated equal. `c1`s that open many requests at once should not get preferred treatment over others that have "only" a single request. \* scheduling `c2`s directly would require creating them, potentially a lot of them, without a worker being available. 100 connections with 10 requests ongoing would hold 1000 `c2`s all the time while only a small set is being worked on. \* asking the same `mplx` for additional work is not unfair as long as more workers are available. And it results in better performance than switching workers all the time.
## Interactions with HTTP/1
The HTTP/1 protocol handling is the default in Apache httpd and there are several places where it appliesitself for "HTTP" without any consideration of the actual protocol version. There are ongoing efforts to separatethe generic HTTP processing (e.g. checks on valid headers, method name, paths, etc.) from the \*serialization\*of responses and bodies on the wire.
Two areas are noteworthy here to understand how mod\_h2 works.
#### Request Bodies
Requests in HTTP/1 have either an implied length of 0 or an announced length in the `content-length` headeror use the "chunked" transfer encoding. The standard `HTTP\_IN` filter in Apache therefore assumes that therequest has not body if both content length and chunked transfer information is missing.
Since HTTP/2 allows request bodies without announced length and no chunking, mod\_h2 must fake a chunkedrequest input for those requests.
#### Response Headers
Similarly, the server installs the `HTTP\_HEADER` filter on a request output which, on seeing the response body,inserts the response header in HTTP/1 format on the filter chain. HTTP/2 has no need for this and removes`HTTP\_HEADER` on each of its requests.
In its stead, it applies its own filter in the output that writes a special `H2HEADERS` meta bucket. Thisbucket contains response status and all headers and can be passed through the output beam. The c1 processingthen converts `H2HEADERS` buckets to the HTTP/2 HEADER frames for responses and footers.
## DDoS Protection
HTTP/2 as a protocol has more internal state than HTTP/1. This makes prevention of exploits moredifficult. The known HTTP/1 attacks, such as "Slo Loris", can also be applied and are mitigatedusing the known mod\_reqtimeout mechanisms.
But "Slo Loris" can also attack the c1 processing on the main connection. After all, the goal of suchan attack is to exhaust the server's worker thread and preventing processing of new connection. Bykeeping the HTTP/2 c1 processing occupied, the same goal can be achieved if there is no special protection in place. This has been a bit of an arms race in the last few years.
Another attack angle is aimed at exhausting the h2 workers with requests, that are slow or kept inan incomplete state or are just simply cancelled and started, again and again.
To protect against such behaviour, a mod\_h2 has an internal "mood" to obey a client based on itspast behaviour (on this connection, there is not tracking). The mood starts neutral where a clientis allowed to have 6 active requests, e.g. occupy 6 h2 workers. When responses are read by the clientin a timely fashion (no stalling), this mood rises and the limit is raised. Should the client stallresponses (drag its feet with window updates) or reset streams before a response has been seen by it,the processing limit is lowered.
Another protection against flooding is scheduling fairness between connections. If one connection has a singlerequest it needs a worker for and another has 100, both get one worker assigned, before the other 99 requestsmay receive attention.

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

