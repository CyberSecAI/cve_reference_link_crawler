

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=fc7facce686b64201dbf0b9614cc1d0bfad70010)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=fc7facce686b64201dbf0b9614cc1d0bfad70010)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=fc7facce686b64201dbf0b9614cc1d0bfad70010)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=fc7facce686b64201dbf0b9614cc1d0bfad70010)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Hugh Dickins <hughd@google.com> | 2024-07-02 00:40:55 -0700 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-07-18 13:22:48 +0200 |
| commit | [fc7facce686b64201dbf0b9614cc1d0bfad70010](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=fc7facce686b64201dbf0b9614cc1d0bfad70010) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=fc7facce686b64201dbf0b9614cc1d0bfad70010)) | |
| tree | [af9ec607f75469e2c82c625d7fc8b9160c1b1a0c](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=fc7facce686b64201dbf0b9614cc1d0bfad70010) | |
| parent | [47f9b6e49b422392fb0e348a65eb925103ba1882](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=47f9b6e49b422392fb0e348a65eb925103ba1882) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=fc7facce686b64201dbf0b9614cc1d0bfad70010&id2=47f9b6e49b422392fb0e348a65eb925103ba1882)) | |
| download | [linux-fc7facce686b64201dbf0b9614cc1d0bfad70010.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-fc7facce686b64201dbf0b9614cc1d0bfad70010.tar.gz) | |

mm: fix crashes from deferred split racing folio migrationcommit be9581ea8c058d81154251cb0695987098996cad upstream.
Even on 6.10-rc6, I've been seeing elusive "Bad page state"s (often on
flags when freeing, yet the flags shown are not bad: PG\_locked had been
set and cleared??), and VM\_BUG\_ON\_PAGE(page\_ref\_count(page) == 0)s from
deferred\_split\_scan()'s folio\_put(), and a variety of other BUG and WARN
symptoms implying double free by deferred split and large folio migration.
6.7 commit 9bcef5973e31 ("mm: memcg: fix split queue list crash when large
folio migration") was right to fix the memcg-dependent locking broken in
85ce2c517ade ("memcontrol: only transfer the memcg data for migration"),
but missed a subtlety of deferred\_split\_scan(): it moves folios to its own
local list to work on them without split\_queue\_lock, during which time
folio->\_deferred\_list is not empty, but even the "right" lock does nothing
to secure the folio and the list it is on.
Fortunately, deferred\_split\_scan() is careful to use folio\_try\_get(): so
folio\_migrate\_mapping() can avoid the race by folio\_undo\_large\_rmappable()
while the old folio's reference count is temporarily frozen to 0 - adding
such a freeze in the !mapping case too (originally, folio lock and
unmapping and no swap cache left an anon folio unreachable, so no freezing
was needed there: but the deferred split queue offers a way to reach it).
Link: [https://lkml.kernel.org/r/29c83d1a-11ca-b6c9-f92e-6ccb322af510@google.com](https://lkml.kernel.org/r/29c83d1a-11ca-b6c9-f92e-6ccb322af510%40google.com)
Fixes: 9bcef5973e31 ("mm: memcg: fix split queue list crash when large folio migration")
Signed-off-by: Hugh Dickins <hughd@google.com>
Reviewed-by: Baolin Wang <baolin.wang@linux.alibaba.com>
Cc: Barry Song <baohua@kernel.org>
Cc: David Hildenbrand <david@redhat.com>
Cc: Hugh Dickins <hughd@google.com>
Cc: Kefeng Wang <wangkefeng.wang@huawei.com>
Cc: Matthew Wilcox (Oracle) <willy@infradead.org>
Cc: Nhat Pham <nphamcs@gmail.com>
Cc: Yang Shi <shy828301@gmail.com>
Cc: Zi Yan <ziy@nvidia.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=fc7facce686b64201dbf0b9614cc1d0bfad70010)

| -rw-r--r-- | [mm/memcontrol.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/mm/memcontrol.c?id=fc7facce686b64201dbf0b9614cc1d0bfad70010) | 11 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [mm/migrate.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/mm/migrate.c?id=fc7facce686b64201dbf0b9614cc1d0bfad70010) | 13 | |  |  |  | | --- | --- | --- | |

2 files changed, 13 insertions, 11 deletions

| diff --git a/mm/memcontrol.c b/mm/memcontrol.cindex 612558f306f4a7..d960151da50c8c 100644--- a/[mm/memcontrol.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/memcontrol.c?id=47f9b6e49b422392fb0e348a65eb925103ba1882)+++ b/[mm/memcontrol.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/memcontrol.c?id=fc7facce686b64201dbf0b9614cc1d0bfad70010)@@ -7609,17 +7609,6 @@ void mem\_cgroup\_migrate(struct folio \*old, struct folio \*new)  /\* Transfer the charge and the css ref \*/ commit\_charge(new, memcg);- /\*- \* If the old folio is a large folio and is in the split queue, it needs- \* to be removed from the split queue now, in case getting an incorrect- \* split queue in destroy\_large\_folio() after the memcg of the old folio- \* is cleared.- \*- \* In addition, the old folio is about to be freed after migration, so- \* removing from the split queue a bit earlier seems reasonable.- \*/- if (folio\_test\_large(old) && folio\_test\_large\_rmappable(old))- folio\_undo\_large\_rmappable(old); old->memcg\_data = 0; } diff --git a/mm/migrate.c b/mm/migrate.cindex 73a052a382f13a..8f99fcea99e443 100644--- a/[mm/migrate.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/migrate.c?id=47f9b6e49b422392fb0e348a65eb925103ba1882)+++ b/[mm/migrate.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/migrate.c?id=fc7facce686b64201dbf0b9614cc1d0bfad70010)@@ -415,6 +415,15 @@ int folio\_migrate\_mapping(struct address\_space \*mapping, if (folio\_ref\_count(folio) != expected\_count) return -EAGAIN; + /\* Take off deferred split queue while frozen and memcg set \*/+ if (folio\_test\_large(folio) &&+ folio\_test\_large\_rmappable(folio)) {+ if (!folio\_ref\_freeze(folio, expected\_count))+ return -EAGAIN;+ folio\_undo\_large\_rmappable(folio);+ folio\_ref\_unfreeze(folio, expected\_count);+ }+ /\* No turning back from here \*/ newfolio->index = folio->index; newfolio->mapping = folio->mapping;@@ -433,6 +442,10 @@ int folio\_migrate\_mapping(struct address\_space \*mapping, return -EAGAIN; } + /\* Take off deferred split queue while frozen and memcg set \*/+ if (folio\_test\_large(folio) && folio\_test\_large\_rmappable(folio))+ folio\_undo\_large\_rmappable(folio);+ /\* \* Now we know that no one else is looking at the folio: \* no turning back from here. |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 19:24:31 +0000

