

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=642b9c520ef2f104277ad1f902f8526edbe087fb)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=642b9c520ef2f104277ad1f902f8526edbe087fb)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=642b9c520ef2f104277ad1f902f8526edbe087fb)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=642b9c520ef2f104277ad1f902f8526edbe087fb)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Qu Wenruo <wqu@suse.com> | 2024-01-17 11:02:25 +1030 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-01-31 16:19:05 -0800 |
| commit | [642b9c520ef2f104277ad1f902f8526edbe087fb](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=642b9c520ef2f104277ad1f902f8526edbe087fb) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=642b9c520ef2f104277ad1f902f8526edbe087fb)) | |
| tree | [ae692ada49258dcc6c044490cc7bbaa4ea1a4bee](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=642b9c520ef2f104277ad1f902f8526edbe087fb) | |
| parent | [d60ff1d313e6119bb142dfa7da47a05ecdf76bbe](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d60ff1d313e6119bb142dfa7da47a05ecdf76bbe) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=642b9c520ef2f104277ad1f902f8526edbe087fb&id2=d60ff1d313e6119bb142dfa7da47a05ecdf76bbe)) | |
| download | [linux-642b9c520ef2f104277ad1f902f8526edbe087fb.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-642b9c520ef2f104277ad1f902f8526edbe087fb.tar.gz) | |

btrfs: scrub: avoid use-after-free when chunk length is not 64K alignedcommit f546c4282673497a06ecb6190b50ae7f6c85b02f upstream.
[BUG]
There is a bug report that, on a ext4-converted btrfs, scrub leads to
various problems, including:
- "unable to find chunk map" errors
BTRFS info (device vdb): scrub: started on devid 1
BTRFS critical (device vdb): unable to find chunk map for logical 2214744064 length 4096
BTRFS critical (device vdb): unable to find chunk map for logical 2214744064 length 45056
This would lead to unrepariable errors.
- Use-after-free KASAN reports:
==================================================================
BUG: KASAN: slab-use-after-free in \_\_blk\_rq\_map\_sg+0x18f/0x7c0
Read of size 8 at addr ffff8881013c9040 by task btrfs/909
CPU: 0 PID: 909 Comm: btrfs Not tainted 6.7.0-x64v3-dbg #11 c50636e9419a8354555555245df535e380563b2b
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 2023.11-2 12/24/2023
Call Trace:
<TASK>
dump\_stack\_lvl+0x43/0x60
print\_report+0xcf/0x640
kasan\_report+0xa6/0xd0
\_\_blk\_rq\_map\_sg+0x18f/0x7c0
virtblk\_prep\_rq.isra.0+0x215/0x6a0 [virtio\_blk 19a65eeee9ae6fcf02edfad39bb9ddee07dcdaff]
virtio\_queue\_rqs+0xc4/0x310 [virtio\_blk 19a65eeee9ae6fcf02edfad39bb9ddee07dcdaff]
blk\_mq\_flush\_plug\_list.part.0+0x780/0x860
\_\_blk\_flush\_plug+0x1ba/0x220
blk\_finish\_plug+0x3b/0x60
submit\_initial\_group\_read+0x10a/0x290 [btrfs e57987a360bed82fe8756dcd3e0de5406ccfe965]
flush\_scrub\_stripes+0x38e/0x430 [btrfs e57987a360bed82fe8756dcd3e0de5406ccfe965]
scrub\_stripe+0x82a/0xae0 [btrfs e57987a360bed82fe8756dcd3e0de5406ccfe965]
scrub\_chunk+0x178/0x200 [btrfs e57987a360bed82fe8756dcd3e0de5406ccfe965]
scrub\_enumerate\_chunks+0x4bc/0xa30 [btrfs e57987a360bed82fe8756dcd3e0de5406ccfe965]
btrfs\_scrub\_dev+0x398/0x810 [btrfs e57987a360bed82fe8756dcd3e0de5406ccfe965]
btrfs\_ioctl+0x4b9/0x3020 [btrfs e57987a360bed82fe8756dcd3e0de5406ccfe965]
\_\_x64\_sys\_ioctl+0xbd/0x100
do\_syscall\_64+0x5d/0xe0
entry\_SYSCALL\_64\_after\_hwframe+0x63/0x6b
RIP: 0033:0x7f47e5e0952b
- Crash, mostly due to above use-after-free
[CAUSE]
The converted fs has the following data chunk layout:
item 2 key (FIRST\_CHUNK\_TREE CHUNK\_ITEM 2214658048) itemoff 16025 itemsize 80
length 86016 owner 2 stripe\_len 65536 type DATA|single
For above logical bytenr 2214744064, it's at the chunk end
(2214658048 + 86016 = 2214744064).
This means btrfs\_submit\_bio() would split the bio, and trigger endio
function for both of the two halves.
However scrub\_submit\_initial\_read() would only expect the endio function
to be called once, not any more.
This means the first endio function would already free the bbio::bio,
leaving the bvec freed, thus the 2nd endio call would lead to
use-after-free.
[FIX]
- Make sure scrub\_read\_endio() only updates bits in its range
Since we may read less than 64K at the end of the chunk, we should not
touch the bits beyond chunk boundary.
- Make sure scrub\_submit\_initial\_read() only to read the chunk range
This is done by calculating the real number of sectors we need to
read, and add sector-by-sector to the bio.
Thankfully the scrub read repair path won't need extra fixes:
- scrub\_stripe\_submit\_repair\_read()
With above fixes, we won't update error bit for range beyond chunk,
thus scrub\_stripe\_submit\_repair\_read() should never submit any read
beyond the chunk.
Reported-by: Rongrong <i@rong.moe>
Fixes: e02ee89baa66 ("btrfs: scrub: switch scrub\_simple\_mirror() to scrub\_stripe infrastructure")
Tested-by: Rongrong <i@rong.moe>
Reviewed-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>
Signed-off-by: Qu Wenruo <wqu@suse.com>
Signed-off-by: David Sterba <dsterba@suse.com>
[ Use min\_t() to fix a compiling error due to difference types ]
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=642b9c520ef2f104277ad1f902f8526edbe087fb)

| -rw-r--r-- | [fs/btrfs/scrub.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/scrub.c?id=642b9c520ef2f104277ad1f902f8526edbe087fb) | 29 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 22 insertions, 7 deletions

| diff --git a/fs/btrfs/scrub.c b/fs/btrfs/scrub.cindex 4445a52a070766..1e3ff87d044705 100644--- a/[fs/btrfs/scrub.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/scrub.c?id=d60ff1d313e6119bb142dfa7da47a05ecdf76bbe)+++ b/[fs/btrfs/scrub.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/scrub.c?id=642b9c520ef2f104277ad1f902f8526edbe087fb)@@ -1099,12 +1099,22 @@ out: static void scrub\_read\_endio(struct btrfs\_bio \*bbio) { struct scrub\_stripe \*stripe = bbio->private;+ struct bio\_vec \*bvec;+ int sector\_nr = calc\_sector\_number(stripe, bio\_first\_bvec\_all(&bbio->bio));+ int num\_sectors;+ u32 bio\_size = 0;+ int i;++ ASSERT(sector\_nr < stripe->nr\_sectors);+ bio\_for\_each\_bvec\_all(bvec, &bbio->bio, i)+ bio\_size += bvec->bv\_len;+ num\_sectors = bio\_size >> stripe->bg->fs\_info->sectorsize\_bits;  if (bbio->bio.bi\_status) {- bitmap\_set(&stripe->io\_error\_bitmap, 0, stripe->nr\_sectors);- bitmap\_set(&stripe->error\_bitmap, 0, stripe->nr\_sectors);+ bitmap\_set(&stripe->io\_error\_bitmap, sector\_nr, num\_sectors);+ bitmap\_set(&stripe->error\_bitmap, sector\_nr, num\_sectors); } else {- bitmap\_clear(&stripe->io\_error\_bitmap, 0, stripe->nr\_sectors);+ bitmap\_clear(&stripe->io\_error\_bitmap, sector\_nr, num\_sectors); } bio\_put(&bbio->bio); if (atomic\_dec\_and\_test(&stripe->pending\_io)) {@@ -1640,6 +1650,9 @@ static void scrub\_submit\_initial\_read(struct scrub\_ctx \*sctx, { struct btrfs\_fs\_info \*fs\_info = sctx->fs\_info; struct btrfs\_bio \*bbio;+ unsigned int nr\_sectors = min\_t(u64, BTRFS\_STRIPE\_LEN, stripe->bg->start ++ stripe->bg->length - stripe->logical) >>+ fs\_info->sectorsize\_bits; int mirror = stripe->mirror\_num;  ASSERT(stripe->bg);@@ -1649,14 +1662,16 @@ static void scrub\_submit\_initial\_read(struct scrub\_ctx \*sctx, bbio = btrfs\_bio\_alloc(SCRUB\_STRIPE\_PAGES, REQ\_OP\_READ, fs\_info, scrub\_read\_endio, stripe); - /\* Read the whole stripe. \*/ bbio->bio.bi\_iter.bi\_sector = stripe->logical >> SECTOR\_SHIFT;- for (int i = 0; i < BTRFS\_STRIPE\_LEN >> PAGE\_SHIFT; i++) {+ /\* Read the whole range inside the chunk boundary. \*/+ for (unsigned int cur = 0; cur < nr\_sectors; cur++) {+ struct page \*page = scrub\_stripe\_get\_page(stripe, cur);+ unsigned int pgoff = scrub\_stripe\_get\_page\_offset(stripe, cur); int ret; - ret = bio\_add\_page(&bbio->bio, stripe->pages[i], PAGE\_SIZE, 0);+ ret = bio\_add\_page(&bbio->bio, page, fs\_info->sectorsize, pgoff); /\* We should have allocated enough bio vectors. \*/- ASSERT(ret == PAGE\_SIZE);+ ASSERT(ret == fs\_info->sectorsize); } atomic\_inc(&stripe->pending\_io); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 17:39:26 +0000

