Based on the provided information, this content relates to **CVE-2024-35862**.

**Root cause of vulnerability:**
The vulnerability stems from a potential Use-After-Free (UAF) condition in the `smb2_is_network_name_deleted()` function within the Linux kernel's SMB client implementation. This occurs because the function iterates through a list of SMB sessions (`smb_ses_list`) and accesses session data without checking if the session is in the process of being torn down. If a session is being closed (status `SES_EXITING`), it might be freed while `smb2_is_network_name_deleted()` is still accessing its members, leading to the UAF vulnerability.

**Weaknesses/vulnerabilities present:**
- **Use-After-Free (UAF):** The primary weakness is a UAF, which arises when the code attempts to access memory that has already been freed.

**Impact of exploitation:**
- **Crash:** Exploiting the UAF can lead to a system crash due to accessing invalid memory.
- **Potential Arbitrary Code Execution:** While the immediate impact is likely a crash, UAF vulnerabilities can sometimes be leveraged for more severe consequences like arbitrary code execution, depending on how the freed memory is subsequently used.

**Attack vectors:**
- A malicious SMB server could trigger the UAF by manipulating session teardown while a client is running the `smb2_is_network_name_deleted()` function.

**Required attacker capabilities/position:**
- The attacker needs to control or influence a malicious SMB server that a vulnerable Linux client connects to. The attacker must be able to control the session lifecycle.

**Patch:**
The fix involves adding a check within the loop in `smb2_is_network_name_deleted()` to skip sessions that are in the `SES_EXITING` state using the `cifs_ses_exiting(ses)` helper function before accessing their members.
```diff
--- a/fs/smb/client/smb2ops.c
+++ b/fs/smb/client/smb2ops.c
@@ -2437,6 +2437,8 @@
 	spin_lock(&cifs_tcp_ses_lock);
 	list_for_each_entry(ses, &pserver->smb_ses_list, smb_ses_list) {
+		if (cifs_ses_exiting(ses))
+			continue;
 		list_for_each_entry(tcon, &ses->tcon_list, tcon_list) {
 			if (tcon->tid == le32_to_cpu(shdr->Id.SyncId.TreeId)) {
 				spin_lock(&tcon->tc_lock);
```
This prevents the function from accessing the data of a session that is being torn down and thus mitigates the UAF vulnerability.