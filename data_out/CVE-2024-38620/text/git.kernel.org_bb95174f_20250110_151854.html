

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=5af2e235b0d5b797e9531a00c50058319130e156)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=5af2e235b0d5b797e9531a00c50058319130e156)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=5af2e235b0d5b797e9531a00c50058319130e156)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5af2e235b0d5b797e9531a00c50058319130e156)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Luiz Augusto von Dentz <luiz.von.dentz@intel.com> | 2024-05-06 18:33:52 -0400 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-06-12 11:11:55 +0200 |
| commit | [5af2e235b0d5b797e9531a00c50058319130e156](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=5af2e235b0d5b797e9531a00c50058319130e156) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=5af2e235b0d5b797e9531a00c50058319130e156)) | |
| tree | [f40a7f8f5838bdfcaeb63591a22dfde5fd5df34f](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=5af2e235b0d5b797e9531a00c50058319130e156) | |
| parent | [75d7ac5e225eda7ce687c27b56a66c33fc963311](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=75d7ac5e225eda7ce687c27b56a66c33fc963311) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5af2e235b0d5b797e9531a00c50058319130e156&id2=75d7ac5e225eda7ce687c27b56a66c33fc963311)) | |
| download | [linux-5af2e235b0d5b797e9531a00c50058319130e156.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-5af2e235b0d5b797e9531a00c50058319130e156.tar.gz) | |

Bluetooth: HCI: Remove HCI\_AMP support[ Upstream commit 84a4bb6548a29326564f0e659fb8064503ecc1c7 ]
Since BT\_HS has been remove HCI\_AMP controllers no longer has any use so
remove it along with the capability of creating AMP controllers.
Since we no longer need to differentiate between AMP and Primary
controllers, as only HCI\_PRIMARY is left, this also remove
hdev->dev\_type altogether.
Fixes: e7b02296fb40 ("Bluetooth: Remove BT\_HS")
Signed-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5af2e235b0d5b797e9531a00c50058319130e156)

| -rw-r--r-- | [drivers/bluetooth/btmrvl\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/bluetooth/btmrvl_main.c?id=5af2e235b0d5b797e9531a00c50058319130e156) | 9 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/bluetooth/btrsi.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/bluetooth/btrsi.c?id=5af2e235b0d5b797e9531a00c50058319130e156) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/bluetooth/btsdio.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/bluetooth/btsdio.c?id=5af2e235b0d5b797e9531a00c50058319130e156) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/bluetooth/btusb.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/bluetooth/btusb.c?id=5af2e235b0d5b797e9531a00c50058319130e156) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/bluetooth/hci\_bcm4377.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/bluetooth/hci_bcm4377.c?id=5af2e235b0d5b797e9531a00c50058319130e156) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/bluetooth/hci\_ldisc.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/bluetooth/hci_ldisc.c?id=5af2e235b0d5b797e9531a00c50058319130e156) | 6 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/bluetooth/hci\_serdev.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/bluetooth/hci_serdev.c?id=5af2e235b0d5b797e9531a00c50058319130e156) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/bluetooth/hci\_uart.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/bluetooth/hci_uart.h?id=5af2e235b0d5b797e9531a00c50058319130e156) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/bluetooth/hci\_vhci.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/bluetooth/hci_vhci.c?id=5af2e235b0d5b797e9531a00c50058319130e156) | 10 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/bluetooth/virtio\_bt.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/bluetooth/virtio_bt.c?id=5af2e235b0d5b797e9531a00c50058319130e156) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/net/bluetooth/hci.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/bluetooth/hci.h?id=5af2e235b0d5b797e9531a00c50058319130e156) | 114 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/net/bluetooth/hci\_core.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/bluetooth/hci_core.h?id=5af2e235b0d5b797e9531a00c50058319130e156) | 46 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/uapi/linux/virtio\_bt.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/uapi/linux/virtio_bt.h?id=5af2e235b0d5b797e9531a00c50058319130e156) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/bluetooth/hci\_conn.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/bluetooth/hci_conn.c?id=5af2e235b0d5b797e9531a00c50058319130e156) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/bluetooth/hci\_core.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/bluetooth/hci_core.c?id=5af2e235b0d5b797e9531a00c50058319130e156) | 132 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/bluetooth/hci\_event.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/bluetooth/hci_event.c?id=5af2e235b0d5b797e9531a00c50058319130e156) | 147 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/bluetooth/hci\_sock.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/bluetooth/hci_sock.c?id=5af2e235b0d5b797e9531a00c50058319130e156) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/bluetooth/hci\_sync.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/bluetooth/hci_sync.c?id=5af2e235b0d5b797e9531a00c50058319130e156) | 112 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/bluetooth/l2cap\_core.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/bluetooth/l2cap_core.c?id=5af2e235b0d5b797e9531a00c50058319130e156) | 21 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/bluetooth/mgmt.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/bluetooth/mgmt.c?id=5af2e235b0d5b797e9531a00c50058319130e156) | 84 | |  |  |  | | --- | --- | --- | |

20 files changed, 49 insertions, 664 deletions

| diff --git a/drivers/bluetooth/btmrvl\_main.c b/drivers/bluetooth/btmrvl\_main.cindex 9658b33c824a70..18f34998a1204a 100644--- a/[drivers/bluetooth/btmrvl\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/bluetooth/btmrvl_main.c?id=75d7ac5e225eda7ce687c27b56a66c33fc963311)+++ b/[drivers/bluetooth/btmrvl\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/bluetooth/btmrvl_main.c?id=5af2e235b0d5b797e9531a00c50058319130e156)@@ -121,13 +121,6 @@ int btmrvl\_process\_event(struct btmrvl\_private \*priv, struct sk\_buff \*skb) ((event->data[2] == MODULE\_BROUGHT\_UP) || (event->data[2] == MODULE\_ALREADY\_UP)) ? "Bring-up succeed" : "Bring-up failed");-- if (event->length > 3 && event->data[3])- priv->btmrvl\_dev.dev\_type = HCI\_AMP;- else- priv->btmrvl\_dev.dev\_type = HCI\_PRIMARY;-- BT\_DBG("dev\_type: %d", priv->btmrvl\_dev.dev\_type); } else if (priv->btmrvl\_dev.sendcmdflag && event->data[1] == MODULE\_SHUTDOWN\_REQ) { BT\_DBG("EVENT:%s", (event->data[2]) ?@@ -686,8 +679,6 @@ int btmrvl\_register\_hdev(struct btmrvl\_private \*priv) hdev->wakeup = btmrvl\_wakeup; SET\_HCIDEV\_DEV(hdev, &card->func->dev); - hdev->dev\_type = priv->btmrvl\_dev.dev\_type;- ret = hci\_register\_dev(hdev); if (ret < 0) { BT\_ERR("Can not register HCI device");diff --git a/drivers/bluetooth/btrsi.c b/drivers/bluetooth/btrsi.cindex 634cf8f5ed2dbd..0c91d7635ac39e 100644--- a/[drivers/bluetooth/btrsi.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/bluetooth/btrsi.c?id=75d7ac5e225eda7ce687c27b56a66c33fc963311)+++ b/[drivers/bluetooth/btrsi.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/bluetooth/btrsi.c?id=5af2e235b0d5b797e9531a00c50058319130e156)@@ -134,7 +134,6 @@ static int rsi\_hci\_attach(void \*priv, struct rsi\_proto\_ops \*ops) hdev->bus = HCI\_USB;  hci\_set\_drvdata(hdev, h\_adapter);- hdev->dev\_type = HCI\_PRIMARY; hdev->open = rsi\_hci\_open; hdev->close = rsi\_hci\_close; hdev->flush = rsi\_hci\_flush;diff --git a/drivers/bluetooth/btsdio.c b/drivers/bluetooth/btsdio.cindex f19d31ee37ea89..fdcfe9c50313ea 100644--- a/[drivers/bluetooth/btsdio.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/bluetooth/btsdio.c?id=75d7ac5e225eda7ce687c27b56a66c33fc963311)+++ b/[drivers/bluetooth/btsdio.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/bluetooth/btsdio.c?id=5af2e235b0d5b797e9531a00c50058319130e156)@@ -32,9 +32,6 @@ static const struct sdio\_device\_id btsdio\_table[] = { /\* Generic Bluetooth Type-B SDIO device \*/ { SDIO\_DEVICE\_CLASS(SDIO\_CLASS\_BT\_B) }, - /\* Generic Bluetooth AMP controller \*/- { SDIO\_DEVICE\_CLASS(SDIO\_CLASS\_BT\_AMP) },- { } /\* Terminating entry \*/ }; @@ -319,11 +316,6 @@ static int btsdio\_probe(struct sdio\_func \*func, hdev->bus = HCI\_SDIO; hci\_set\_drvdata(hdev, data); - if (id->class == SDIO\_CLASS\_BT\_AMP)- hdev->dev\_type = HCI\_AMP;- else- hdev->dev\_type = HCI\_PRIMARY;- data->hdev = hdev;  SET\_HCIDEV\_DEV(hdev, &func->dev);diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.cindex d178e1464bfd21..7c271f55a9b496 100644--- a/[drivers/bluetooth/btusb.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/bluetooth/btusb.c?id=75d7ac5e225eda7ce687c27b56a66c33fc963311)+++ b/[drivers/bluetooth/btusb.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/bluetooth/btusb.c?id=5af2e235b0d5b797e9531a00c50058319130e156)@@ -4308,11 +4308,6 @@ static int btusb\_probe(struct usb\_interface \*intf, hdev->bus = HCI\_USB; hci\_set\_drvdata(hdev, data); - if (id->driver\_info & BTUSB\_AMP)- hdev->dev\_type = HCI\_AMP;- else- hdev->dev\_type = HCI\_PRIMARY;- data->hdev = hdev;  SET\_HCIDEV\_DEV(hdev, &intf->dev);diff --git a/drivers/bluetooth/hci\_bcm4377.c b/drivers/bluetooth/hci\_bcm4377.cindex 9a7243d5db71ff..0c2f15235b4cda 100644--- a/[drivers/bluetooth/hci\_bcm4377.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/bluetooth/hci_bcm4377.c?id=75d7ac5e225eda7ce687c27b56a66c33fc963311)+++ b/[drivers/bluetooth/hci\_bcm4377.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/bluetooth/hci_bcm4377.c?id=5af2e235b0d5b797e9531a00c50058319130e156)@@ -2361,7 +2361,6 @@ static int bcm4377\_probe(struct pci\_dev \*pdev, const struct pci\_device\_id \*id) bcm4377->hdev = hdev;  hdev->bus = HCI\_PCI;- hdev->dev\_type = HCI\_PRIMARY; hdev->open = bcm4377\_hci\_open; hdev->close = bcm4377\_hci\_close; hdev->send = bcm4377\_hci\_send\_frame;diff --git a/drivers/bluetooth/hci\_ldisc.c b/drivers/bluetooth/hci\_ldisc.cindex a26367e9fb197c..17a2f158a0dfab 100644--- a/[drivers/bluetooth/hci\_ldisc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/bluetooth/hci_ldisc.c?id=75d7ac5e225eda7ce687c27b56a66c33fc963311)+++ b/[drivers/bluetooth/hci\_ldisc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/bluetooth/hci_ldisc.c?id=5af2e235b0d5b797e9531a00c50058319130e156)@@ -667,11 +667,6 @@ static int hci\_uart\_register\_dev(struct hci\_uart \*hu) if (!test\_bit(HCI\_UART\_RESET\_ON\_INIT, &hu->hdev\_flags)) set\_bit(HCI\_QUIRK\_RESET\_ON\_CLOSE, &hdev->quirks); - if (test\_bit(HCI\_UART\_CREATE\_AMP, &hu->hdev\_flags))- hdev->dev\_type = HCI\_AMP;- else- hdev->dev\_type = HCI\_PRIMARY;- /\* Only call open() for the protocol after hdev is fully initialized as \* open() (or a timer/workqueue it starts) may attempt to reference it. \*/@@ -722,7 +717,6 @@ static int hci\_uart\_set\_flags(struct hci\_uart \*hu, unsigned long flags) { unsigned long valid\_flags = BIT(HCI\_UART\_RAW\_DEVICE) | BIT(HCI\_UART\_RESET\_ON\_INIT) |- BIT(HCI\_UART\_CREATE\_AMP) | BIT(HCI\_UART\_INIT\_PENDING) | BIT(HCI\_UART\_EXT\_CONFIG) | BIT(HCI\_UART\_VND\_DETECT);diff --git a/drivers/bluetooth/hci\_serdev.c b/drivers/bluetooth/hci\_serdev.cindex 611a11fbb2f3a4..1165831570e3c4 100644--- a/[drivers/bluetooth/hci\_serdev.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/bluetooth/hci_serdev.c?id=75d7ac5e225eda7ce687c27b56a66c33fc963311)+++ b/[drivers/bluetooth/hci\_serdev.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/bluetooth/hci_serdev.c?id=5af2e235b0d5b797e9531a00c50058319130e156)@@ -366,11 +366,6 @@ int hci\_uart\_register\_device\_priv(struct hci\_uart \*hu, if (test\_bit(HCI\_UART\_EXT\_CONFIG, &hu->hdev\_flags)) set\_bit(HCI\_QUIRK\_EXTERNAL\_CONFIG, &hdev->quirks); - if (test\_bit(HCI\_UART\_CREATE\_AMP, &hu->hdev\_flags))- hdev->dev\_type = HCI\_AMP;- else- hdev->dev\_type = HCI\_PRIMARY;- if (test\_bit(HCI\_UART\_INIT\_PENDING, &hu->hdev\_flags)) return 0; diff --git a/drivers/bluetooth/hci\_uart.h b/drivers/bluetooth/hci\_uart.hindex 68c8c7e95d64dc..00bf7ae82c5b72 100644--- a/[drivers/bluetooth/hci\_uart.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/bluetooth/hci_uart.h?id=75d7ac5e225eda7ce687c27b56a66c33fc963311)+++ b/[drivers/bluetooth/hci\_uart.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/bluetooth/hci_uart.h?id=5af2e235b0d5b797e9531a00c50058319130e156)@@ -37,7 +37,6 @@  #define HCI\_UART\_RAW\_DEVICE 0 #define HCI\_UART\_RESET\_ON\_INIT 1-#define HCI\_UART\_CREATE\_AMP 2 #define HCI\_UART\_INIT\_PENDING 3 #define HCI\_UART\_EXT\_CONFIG 4 #define HCI\_UART\_VND\_DETECT 5diff --git a/drivers/bluetooth/hci\_vhci.c b/drivers/bluetooth/hci\_vhci.cindex 572d68d52965f6..28750a40f0ed52 100644--- a/[drivers/bluetooth/hci\_vhci.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/bluetooth/hci_vhci.c?id=75d7ac5e225eda7ce687c27b56a66c33fc963311)+++ b/[drivers/bluetooth/hci\_vhci.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/bluetooth/hci_vhci.c?id=5af2e235b0d5b797e9531a00c50058319130e156)@@ -384,17 +384,10 @@ static int \_\_vhci\_create\_device(struct vhci\_data \*data, \_\_u8 opcode) { struct hci\_dev \*hdev; struct sk\_buff \*skb;- \_\_u8 dev\_type;  if (data->hdev) return -EBADFD; - /\* bits 0-1 are dev\_type (Primary or AMP) \*/- dev\_type = opcode & 0x03;-- if (dev\_type != HCI\_PRIMARY && dev\_type != HCI\_AMP)- return -EINVAL;- /\* bits 2-5 are reserved (must be zero) \*/ if (opcode & 0x3c) return -EINVAL;@@ -412,7 +405,6 @@ static int \_\_vhci\_create\_device(struct vhci\_data \*data, \_\_u8 opcode) data->hdev = hdev;  hdev->bus = HCI\_VIRTUAL;- hdev->dev\_type = dev\_type; hci\_set\_drvdata(hdev, data);  hdev->open = vhci\_open\_dev;@@ -634,7 +626,7 @@ static void vhci\_open\_timeout(struct work\_struct \*work) struct vhci\_data \*data = container\_of(work, struct vhci\_data, open\_timeout.work); - vhci\_create\_device(data, amp ? HCI\_AMP : HCI\_PRIMARY);+ vhci\_create\_device(data, 0x00); }  static int vhci\_open(struct inode \*inode, struct file \*file)diff --git a/drivers/bluetooth/virtio\_bt.c b/drivers/bluetooth/virtio\_bt.cindex 2ac70b560c46db..18208e152a3675 100644--- a/[drivers/bluetooth/virtio\_bt.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/bluetooth/virtio_bt.c?id=75d7ac5e225eda7ce687c27b56a66c33fc963311)+++ b/[drivers/bluetooth/virtio\_bt.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/bluetooth/virtio_bt.c?id=5af2e235b0d5b797e9531a00c50058319130e156)@@ -274,7 +274,6 @@ static int virtbt\_probe(struct virtio\_device \*vdev)  switch (type) { case VIRTIO\_BT\_CONFIG\_TYPE\_PRIMARY:- case VIRTIO\_BT\_CONFIG\_TYPE\_AMP: break; default: return -EINVAL;@@ -303,7 +302,6 @@ static int virtbt\_probe(struct virtio\_device \*vdev) vbt->hdev = hdev;  hdev->bus = HCI\_VIRTIO;- hdev->dev\_type = type; hci\_set\_drvdata(hdev, vbt);  hdev->open = virtbt\_open;diff --git a/include/net/bluetooth/hci.h b/include/net/bluetooth/hci.hindex 7367ef7e92f529..d2a280a42f3b8f 100644--- a/[include/net/bluetooth/hci.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/bluetooth/hci.h?id=75d7ac5e225eda7ce687c27b56a66c33fc963311)+++ b/[include/net/bluetooth/hci.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/bluetooth/hci.h?id=5af2e235b0d5b797e9531a00c50058319130e156)@@ -33,9 +33,6 @@ #define HCI\_MAX\_FRAME\_SIZE (HCI\_MAX\_ACL\_SIZE + 4)  #define HCI\_LINK\_KEY\_SIZE 16-#define HCI\_AMP\_LINK\_KEY\_SIZE (2 \* HCI\_LINK\_KEY\_SIZE)--#define HCI\_MAX\_AMP\_ASSOC\_SIZE 672  #define HCI\_MAX\_CPB\_DATA\_SIZE 252 @@ -71,26 +68,6 @@ #define HCI\_SMD 9 #define HCI\_VIRTIO 10 -/\* HCI controller types \*/-#define HCI\_PRIMARY 0x00-#define HCI\_AMP 0x01--/\* First BR/EDR Controller shall have ID = 0 \*/-#define AMP\_ID\_BREDR 0x00--/\* AMP controller types \*/-#define AMP\_TYPE\_BREDR 0x00-#define AMP\_TYPE\_80211 0x01--/\* AMP controller status \*/-#define AMP\_STATUS\_POWERED\_DOWN 0x00-#define AMP\_STATUS\_BLUETOOTH\_ONLY 0x01-#define AMP\_STATUS\_NO\_CAPACITY 0x02-#define AMP\_STATUS\_LOW\_CAPACITY 0x03-#define AMP\_STATUS\_MEDIUM\_CAPACITY 0x04-#define AMP\_STATUS\_HIGH\_CAPACITY 0x05-#define AMP\_STATUS\_FULL\_CAPACITY 0x06- /\* HCI device quirks \*/ enum { /\* When this quirk is set, the HCI Reset command is send when@@ -526,7 +503,6 @@ enum { #define ESCO\_LINK 0x02 /\* Low Energy links do not have defined link type. Use invented one \*/ #define LE\_LINK 0x80-#define AMP\_LINK 0x81 #define ISO\_LINK 0x82 #define INVALID\_LINK 0xff @@ -940,56 +916,6 @@ struct hci\_cp\_io\_capability\_neg\_reply { \_\_u8 reason; } \_\_packed; -#define HCI\_OP\_CREATE\_PHY\_LINK 0x0435-struct hci\_cp\_create\_phy\_link {- \_\_u8 phy\_handle;- \_\_u8 key\_len;- \_\_u8 key\_type;- \_\_u8 key[HCI\_AMP\_LINK\_KEY\_SIZE];-} \_\_packed;--#define HCI\_OP\_ACCEPT\_PHY\_LINK 0x0436-struct hci\_cp\_accept\_phy\_link {- \_\_u8 phy\_handle;- \_\_u8 key\_len;- \_\_u8 key\_type;- \_\_u8 key[HCI\_AMP\_LINK\_KEY\_SIZE];-} \_\_packed;--#define HCI\_OP\_DISCONN\_PHY\_LINK 0x0437-struct hci\_cp\_disconn\_phy\_link {- \_\_u8 phy\_handle;- \_\_u8 reason;-} \_\_packed;--struct ext\_flow\_spec {- \_\_u8 id;- \_\_u8 stype;- \_\_le16 msdu;- \_\_le32 sdu\_itime;- \_\_le32 acc\_lat;- \_\_le32 flush\_to;-} \_\_packed;--#define HCI\_OP\_CREATE\_LOGICAL\_LINK 0x0438-#define HCI\_OP\_ACCEPT\_LOGICAL\_LINK 0x0439-struct hci\_cp\_create\_accept\_logical\_link {- \_\_u8 phy\_handle;- struct ext\_flow\_spec tx\_flow\_spec;- struct ext\_flow\_spec rx\_flow\_spec;-} \_\_packed;--#define HCI\_OP\_DISCONN\_LOGICAL\_LINK 0x043a-struct hci\_cp\_disconn\_logical\_link {- \_\_le16 log\_handle;-} \_\_packed;--#define HCI\_OP\_LOGICAL\_LINK\_CANCEL 0x043b-struct hci\_cp\_logical\_link\_cancel {- \_\_u8 phy\_handle;- \_\_u8 flow\_spec\_id;-} \_\_packed;- #define HCI\_OP\_ENHANCED\_SETUP\_SYNC\_CONN 0x043d struct hci\_coding\_format { \_\_u8 id;@@ -1611,46 +1537,6 @@ struct hci\_rp\_read\_enc\_key\_size { \_\_u8 key\_size; } \_\_packed; -#define HCI\_OP\_READ\_LOCAL\_AMP\_INFO 0x1409-struct hci\_rp\_read\_local\_amp\_info {- \_\_u8 status;- \_\_u8 amp\_status;- \_\_le32 total\_bw;- \_\_le32 max\_bw;- \_\_le32 min\_latency;- \_\_le32 max\_pdu;- \_\_u8 amp\_type;- \_\_le16 pal\_cap;- \_\_le16 max\_assoc\_size;- \_\_le32 max\_flush\_to;- \_\_le32 be\_flush\_to;-} \_\_packed;--#define HCI\_OP\_READ\_LOCAL\_AMP\_ASSOC 0x140a-struct hci\_cp\_read\_local\_amp\_assoc {- \_\_u8 phy\_handle;- \_\_le16 len\_so\_far;- \_\_le16 max\_len;-} \_\_packed;-struct hci\_rp\_read\_local\_amp\_assoc {- \_\_u8 status;- \_\_u8 phy\_handle;- \_\_le16 rem\_len;- \_\_u8 frag[];-} \_\_packed;--#define HCI\_OP\_WRITE\_REMOTE\_AMP\_ASSOC 0x140b-struct hci\_cp\_write\_remote\_amp\_assoc {- \_\_u8 phy\_handle;- \_\_le16 len\_so\_far;- \_\_le16 rem\_len;- \_\_u8 frag[];-} \_\_packed;-struct hci\_rp\_write\_remote\_amp\_assoc {- \_\_u8 status;- \_\_u8 phy\_handle;-} \_\_packed;- #define HCI\_OP\_GET\_MWS\_TRANSPORT\_CONFIG 0x140c  #define HCI\_OP\_ENABLE\_DUT\_MODE 0x1803diff --git a/include/net/bluetooth/hci\_core.h b/include/net/bluetooth/hci\_core.hindex b5b0a1e1bba02e..f786d2d62fa5ef 100644--- a/[include/net/bluetooth/hci\_core.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/bluetooth/hci_core.h?id=75d7ac5e225eda7ce687c27b56a66c33fc963311)+++ b/[include/net/bluetooth/hci\_core.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/bluetooth/hci_core.h?id=5af2e235b0d5b797e9531a00c50058319130e156)@@ -126,7 +126,6 @@ enum suspended\_state { struct hci\_conn\_hash { struct list\_head list; unsigned int acl\_num;- unsigned int amp\_num; unsigned int sco\_num; unsigned int iso\_num; unsigned int le\_num;@@ -341,14 +340,6 @@ struct adv\_monitor { /\* Default authenticated payload timeout 30s \*/ #define DEFAULT\_AUTH\_PAYLOAD\_TIMEOUT 0x0bb8 -struct amp\_assoc {- \_\_u16 len;- \_\_u16 offset;- \_\_u16 rem\_len;- \_\_u16 len\_so\_far;- \_\_u8 data[HCI\_MAX\_AMP\_ASSOC\_SIZE];-};- #define HCI\_MAX\_PAGES 3  struct hci\_dev {@@ -361,7 +352,6 @@ struct hci\_dev { unsigned long flags; \_\_u16 id; \_\_u8 bus;- \_\_u8 dev\_type; bdaddr\_t bdaddr; bdaddr\_t setup\_addr; bdaddr\_t public\_addr;@@ -467,21 +457,6 @@ struct hci\_dev { \_\_u16 sniff\_min\_interval; \_\_u16 sniff\_max\_interval; - \_\_u8 amp\_status;- \_\_u32 amp\_total\_bw;- \_\_u32 amp\_max\_bw;- \_\_u32 amp\_min\_latency;- \_\_u32 amp\_max\_pdu;- \_\_u8 amp\_type;- \_\_u16 amp\_pal\_cap;- \_\_u16 amp\_assoc\_size;- \_\_u32 amp\_max\_flush\_to;- \_\_u32 amp\_be\_flush\_to;-- struct amp\_assoc loc\_assoc;-- \_\_u8 flow\_ctl\_mode;- unsigned int auto\_accept\_delay;  unsigned long quirks;@@ -501,11 +476,6 @@ struct hci\_dev { unsigned int le\_pkts; unsigned int iso\_pkts; - \_\_u16 block\_len;- \_\_u16 block\_mtu;- \_\_u16 num\_blocks;- \_\_u16 block\_cnt;- unsigned long acl\_last\_tx; unsigned long sco\_last\_tx; unsigned long le\_last\_tx;@@ -776,7 +746,6 @@ struct hci\_conn { void \*l2cap\_data; void \*sco\_data; void \*iso\_data;- struct amp\_mgr \*amp\_mgr;  struct list\_head link\_list; struct hci\_conn \*parent;@@ -803,7 +772,6 @@ struct hci\_chan { struct sk\_buff\_head data\_q; unsigned int sent; \_\_u8 state;- bool amp; };  struct hci\_conn\_params {@@ -1012,9 +980,6 @@ static inline void hci\_conn\_hash\_add(struct hci\_dev \*hdev, struct hci\_conn \*c) case ACL\_LINK: h->acl\_num++; break;- case AMP\_LINK:- h->amp\_num++;- break; case LE\_LINK: h->le\_num++; if (c->role == HCI\_ROLE\_SLAVE)@@ -1041,9 +1006,6 @@ static inline void hci\_conn\_hash\_del(struct hci\_dev \*hdev, struct hci\_conn \*c) case ACL\_LINK: h->acl\_num--; break;- case AMP\_LINK:- h->amp\_num--;- break; case LE\_LINK: h->le\_num--; if (c->role == HCI\_ROLE\_SLAVE)@@ -1065,8 +1027,6 @@ static inline unsigned int hci\_conn\_num(struct hci\_dev \*hdev, \_\_u8 type) switch (type) { case ACL\_LINK: return h->acl\_num;- case AMP\_LINK:- return h->amp\_num; case LE\_LINK: return h->le\_num; case SCO\_LINK:@@ -1083,7 +1043,7 @@ static inline unsigned int hci\_conn\_count(struct hci\_dev \*hdev) { struct hci\_conn\_hash \*c = &hdev->conn\_hash; - return c->acl\_num + c->amp\_num + c->sco\_num + c->le\_num + c->iso\_num;+ return c->acl\_num + c->sco\_num + c->le\_num + c->iso\_num; }  static inline \_\_u8 hci\_conn\_lookup\_type(struct hci\_dev \*hdev, \_\_u16 handle)@@ -1569,10 +1529,6 @@ static inline void hci\_conn\_drop(struct hci\_conn \*conn) } break; - case AMP\_LINK:- timeo = conn->disc\_timeout;- break;- default: timeo = 0; break;diff --git a/include/uapi/linux/virtio\_bt.h b/include/uapi/linux/virtio\_bt.hindex af798f4c968042..3cc7d633456b6b 100644--- a/[include/uapi/linux/virtio\_bt.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/uapi/linux/virtio_bt.h?id=75d7ac5e225eda7ce687c27b56a66c33fc963311)+++ b/[include/uapi/linux/virtio\_bt.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/uapi/linux/virtio_bt.h?id=5af2e235b0d5b797e9531a00c50058319130e156)@@ -13,7 +13,6 @@  enum virtio\_bt\_config\_type { VIRTIO\_BT\_CONFIG\_TYPE\_PRIMARY = 0,- VIRTIO\_BT\_CONFIG\_TYPE\_AMP = 1, };  enum virtio\_bt\_config\_vendor {diff --git a/net/bluetooth/hci\_conn.c b/net/bluetooth/hci\_conn.cindex 707c7710d84ec8..163b56a68bb04b 100644--- a/[net/bluetooth/hci\_conn.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/bluetooth/hci_conn.c?id=75d7ac5e225eda7ce687c27b56a66c33fc963311)+++ b/[net/bluetooth/hci\_conn.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/bluetooth/hci_conn.c?id=5af2e235b0d5b797e9531a00c50058319130e156)@@ -1200,8 +1200,7 @@ struct hci\_dev \*hci\_get\_route(bdaddr\_t \*dst, bdaddr\_t \*src, uint8\_t src\_type)  list\_for\_each\_entry(d, &hci\_dev\_list, list) { if (!test\_bit(HCI\_UP, &d->flags) ||- hci\_dev\_test\_flag(d, HCI\_USER\_CHANNEL) ||- d->dev\_type != HCI\_PRIMARY)+ hci\_dev\_test\_flag(d, HCI\_USER\_CHANNEL)) continue;  /\* Simple routing:diff --git a/net/bluetooth/hci\_core.c b/net/bluetooth/hci\_core.cindex 101ea9137dfefd..3817d6369f0cc1 100644--- a/[net/bluetooth/hci\_core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/bluetooth/hci_core.c?id=75d7ac5e225eda7ce687c27b56a66c33fc963311)+++ b/[net/bluetooth/hci\_core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/bluetooth/hci_core.c?id=5af2e235b0d5b797e9531a00c50058319130e156)@@ -395,11 +395,6 @@ int hci\_inquiry(void \_\_user \*arg) goto done; } - if (hdev->dev\_type != HCI\_PRIMARY) {- err = -EOPNOTSUPP;- goto done;- }- if (!hci\_dev\_test\_flag(hdev, HCI\_BREDR\_ENABLED)) { err = -EOPNOTSUPP; goto done;@@ -752,11 +747,6 @@ int hci\_dev\_cmd(unsigned int cmd, void \_\_user \*arg) goto done; } - if (hdev->dev\_type != HCI\_PRIMARY) {- err = -EOPNOTSUPP;- goto done;- }- if (!hci\_dev\_test\_flag(hdev, HCI\_BREDR\_ENABLED)) { err = -EOPNOTSUPP; goto done;@@ -910,7 +900,7 @@ int hci\_get\_dev\_info(void \_\_user \*arg)  strscpy(di.name, hdev->name, sizeof(di.name)); di.bdaddr = hdev->bdaddr;- di.type = (hdev->bus & 0x0f) | ((hdev->dev\_type & 0x03) << 4);+ di.type = (hdev->bus & 0x0f); di.flags = flags; di.pkt\_type = hdev->pkt\_type; if (lmp\_bredr\_capable(hdev)) {@@ -995,8 +985,7 @@ static void hci\_power\_on(struct work\_struct \*work) \*/ if (hci\_dev\_test\_flag(hdev, HCI\_RFKILLED) || hci\_dev\_test\_flag(hdev, HCI\_UNCONFIGURED) ||- (hdev->dev\_type == HCI\_PRIMARY &&- !bacmp(&hdev->bdaddr, BDADDR\_ANY) &&+ (!bacmp(&hdev->bdaddr, BDADDR\_ANY) && !bacmp(&hdev->static\_addr, BDADDR\_ANY))) { hci\_dev\_clear\_flag(hdev, HCI\_AUTO\_OFF); hci\_dev\_do\_close(hdev);@@ -2604,21 +2593,7 @@ int hci\_register\_dev(struct hci\_dev \*hdev) if (!hdev->open || !hdev->close || !hdev->send) return -EINVAL; - /\* Do not allow HCI\_AMP devices to register at index 0,- \* so the index can be used as the AMP controller ID.- \*/- switch (hdev->dev\_type) {- case HCI\_PRIMARY:- id = ida\_alloc\_max(&hci\_index\_ida, HCI\_MAX\_ID - 1, GFP\_KERNEL);- break;- case HCI\_AMP:- id = ida\_alloc\_range(&hci\_index\_ida, 1, HCI\_MAX\_ID - 1,- GFP\_KERNEL);- break;- default:- return -EINVAL;- }-+ id = ida\_alloc\_max(&hci\_index\_ida, HCI\_MAX\_ID - 1, GFP\_KERNEL); if (id < 0) return id; @@ -2670,12 +2645,10 @@ int hci\_register\_dev(struct hci\_dev \*hdev) hci\_dev\_set\_flag(hdev, HCI\_SETUP); hci\_dev\_set\_flag(hdev, HCI\_AUTO\_OFF); - if (hdev->dev\_type == HCI\_PRIMARY) {- /\* Assume BR/EDR support until proven otherwise (such as- \* through reading supported features during init.- \*/- hci\_dev\_set\_flag(hdev, HCI\_BREDR\_ENABLED);- }+ /\* Assume BR/EDR support until proven otherwise (such as+ \* through reading supported features during init.+ \*/+ hci\_dev\_set\_flag(hdev, HCI\_BREDR\_ENABLED);  write\_lock(&hci\_dev\_list\_lock); list\_add(&hdev->list, &hci\_dev\_list);@@ -3211,17 +3184,7 @@ static void hci\_queue\_acl(struct hci\_chan \*chan, struct sk\_buff\_head \*queue,  hci\_skb\_pkt\_type(skb) = HCI\_ACLDATA\_PKT; - switch (hdev->dev\_type) {- case HCI\_PRIMARY:- hci\_add\_acl\_hdr(skb, conn->handle, flags);- break;- case HCI\_AMP:- hci\_add\_acl\_hdr(skb, chan->handle, flags);- break;- default:- bt\_dev\_err(hdev, "unknown dev\_type %d", hdev->dev\_type);- return;- }+ hci\_add\_acl\_hdr(skb, conn->handle, flags);  list = skb\_shinfo(skb)->frag\_list; if (!list) {@@ -3381,9 +3344,6 @@ static inline void hci\_quote\_sent(struct hci\_conn \*conn, int num, int \*quote) case ACL\_LINK: cnt = hdev->acl\_cnt; break;- case AMP\_LINK:- cnt = hdev->block\_cnt;- break; case SCO\_LINK: case ESCO\_LINK: cnt = hdev->sco\_cnt;@@ -3581,12 +3541,6 @@ static void hci\_prio\_recalculate(struct hci\_dev \*hdev, \_\_u8 type)  } -static inline int \_\_get\_blocks(struct hci\_dev \*hdev, struct sk\_buff \*skb)-{- /\* Calculate count of blocks used by this packet \*/- return DIV\_ROUND\_UP(skb->len - HCI\_ACL\_HDR\_SIZE, hdev->block\_len);-}- static void \_\_check\_timeout(struct hci\_dev \*hdev, unsigned int cnt, u8 type) { unsigned long last\_tx;@@ -3700,81 +3654,15 @@ static void hci\_sched\_acl\_pkt(struct hci\_dev \*hdev) hci\_prio\_recalculate(hdev, ACL\_LINK); } -static void hci\_sched\_acl\_blk(struct hci\_dev \*hdev)-{- unsigned int cnt = hdev->block\_cnt;- struct hci\_chan \*chan;- struct sk\_buff \*skb;- int quote;- u8 type;-- BT\_DBG("%s", hdev->name);-- if (hdev->dev\_type == HCI\_AMP)- type = AMP\_LINK;- else- type = ACL\_LINK;-- \_\_check\_timeout(hdev, cnt, type);-- while (hdev->block\_cnt > 0 &&- (chan = hci\_chan\_sent(hdev, type, &quote))) {- u32 priority = (skb\_peek(&chan->data\_q))->priority;- while (quote > 0 && (skb = skb\_peek(&chan->data\_q))) {- int blocks;-- BT\_DBG("chan %p skb %p len %d priority %u", chan, skb,- skb->len, skb->priority);-- /\* Stop if priority has changed \*/- if (skb->priority < priority)- break;-- skb = skb\_dequeue(&chan->data\_q);-- blocks = \_\_get\_blocks(hdev, skb);- if (blocks > hdev->block\_cnt)- return;-- hci\_conn\_enter\_active\_mode(chan->conn,- bt\_cb(skb)->force\_active);-- hci\_send\_frame(hdev, skb);- hdev->acl\_last\_tx = jiffies;-- hdev->block\_cnt -= blocks;- quote -= blocks;-- chan->sent += blocks;- chan->conn->sent += blocks;- }- }-- if (cnt != hdev->block\_cnt)- hci\_prio\_recalculate(hdev, type);-}- static void hci\_sched\_acl(struct hci\_dev \*hdev) { BT\_DBG("%s", hdev->name);  /\* No ACL link over BR/EDR controller \*/- if (!hci\_conn\_num(hdev, ACL\_LINK) && hdev->dev\_type == HCI\_PRIMARY)- return;-- /\* No AMP link over AMP controller \*/- if (!hci\_conn\_num(hdev, AMP\_LINK) && hdev->dev\_type == HCI\_AMP)+ if (!hci\_conn\_num(hdev, ACL\_LINK)) return; - switch (hdev->flow\_ctl\_mode) {- case HCI\_FLOW\_CTL\_MODE\_PACKET\_BASED:- hci\_sched\_acl\_pkt(hdev);- break;-- case HCI\_FLOW\_CTL\_MODE\_BLOCK\_BASED:- hci\_sched\_acl\_blk(hdev);- break;- }+ hci\_sched\_acl\_pkt(hdev); }  static void hci\_sched\_le(struct hci\_dev \*hdev)diff --git a/net/bluetooth/hci\_event.c b/net/bluetooth/hci\_event.cindex d357ec131aa5aa..6ce4f812503f46 100644--- a/[net/bluetooth/hci\_event.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/bluetooth/hci_event.c?id=75d7ac5e225eda7ce687c27b56a66c33fc963311)+++ b/[net/bluetooth/hci\_event.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/bluetooth/hci_event.c?id=5af2e235b0d5b797e9531a00c50058319130e156)@@ -917,21 +917,6 @@ static u8 hci\_cc\_read\_local\_ext\_features(struct hci\_dev \*hdev, void \*data, return rp->status; } -static u8 hci\_cc\_read\_flow\_control\_mode(struct hci\_dev \*hdev, void \*data,- struct sk\_buff \*skb)-{- struct hci\_rp\_read\_flow\_control\_mode \*rp = data;-- bt\_dev\_dbg(hdev, "status 0x%2.2x", rp->status);-- if (rp->status)- return rp->status;-- hdev->flow\_ctl\_mode = rp->mode;-- return rp->status;-}- static u8 hci\_cc\_read\_buffer\_size(struct hci\_dev \*hdev, void \*data, struct sk\_buff \*skb) {@@ -1075,28 +1060,6 @@ static u8 hci\_cc\_write\_page\_scan\_type(struct hci\_dev \*hdev, void \*data, return rp->status; } -static u8 hci\_cc\_read\_data\_block\_size(struct hci\_dev \*hdev, void \*data,- struct sk\_buff \*skb)-{- struct hci\_rp\_read\_data\_block\_size \*rp = data;-- bt\_dev\_dbg(hdev, "status 0x%2.2x", rp->status);-- if (rp->status)- return rp->status;-- hdev->block\_mtu = \_\_le16\_to\_cpu(rp->max\_acl\_len);- hdev->block\_len = \_\_le16\_to\_cpu(rp->block\_len);- hdev->num\_blocks = \_\_le16\_to\_cpu(rp->num\_blocks);-- hdev->block\_cnt = hdev->num\_blocks;-- BT\_DBG("%s blk mtu %d cnt %d len %d", hdev->name, hdev->block\_mtu,- hdev->block\_cnt, hdev->block\_len);-- return rp->status;-}- static u8 hci\_cc\_read\_clock(struct hci\_dev \*hdev, void \*data, struct sk\_buff \*skb) {@@ -1131,30 +1094,6 @@ unlock: return rp->status; } -static u8 hci\_cc\_read\_local\_amp\_info(struct hci\_dev \*hdev, void \*data,- struct sk\_buff \*skb)-{- struct hci\_rp\_read\_local\_amp\_info \*rp = data;-- bt\_dev\_dbg(hdev, "status 0x%2.2x", rp->status);-- if (rp->status)- return rp->status;-- hdev->amp\_status = rp->amp\_status;- hdev->amp\_total\_bw = \_\_le32\_to\_cpu(rp->total\_bw);- hdev->amp\_max\_bw = \_\_le32\_to\_cpu(rp->max\_bw);- hdev->amp\_min\_latency = \_\_le32\_to\_cpu(rp->min\_latency);- hdev->amp\_max\_pdu = \_\_le32\_to\_cpu(rp->max\_pdu);- hdev->amp\_type = rp->amp\_type;- hdev->amp\_pal\_cap = \_\_le16\_to\_cpu(rp->pal\_cap);- hdev->amp\_assoc\_size = \_\_le16\_to\_cpu(rp->max\_assoc\_size);- hdev->amp\_be\_flush\_to = \_\_le32\_to\_cpu(rp->be\_flush\_to);- hdev->amp\_max\_flush\_to = \_\_le32\_to\_cpu(rp->max\_flush\_to);-- return rp->status;-}- static u8 hci\_cc\_read\_inq\_rsp\_tx\_power(struct hci\_dev \*hdev, void \*data, struct sk\_buff \*skb) {@@ -4134,12 +4073,6 @@ static const struct hci\_cc { HCI\_CC(HCI\_OP\_READ\_PAGE\_SCAN\_TYPE, hci\_cc\_read\_page\_scan\_type, sizeof(struct hci\_rp\_read\_page\_scan\_type)), HCI\_CC\_STATUS(HCI\_OP\_WRITE\_PAGE\_SCAN\_TYPE, hci\_cc\_write\_page\_scan\_type),- HCI\_CC(HCI\_OP\_READ\_DATA\_BLOCK\_SIZE, hci\_cc\_read\_data\_block\_size,- sizeof(struct hci\_rp\_read\_data\_block\_size)),- HCI\_CC(HCI\_OP\_READ\_FLOW\_CONTROL\_MODE, hci\_cc\_read\_flow\_control\_mode,- sizeof(struct hci\_rp\_read\_flow\_control\_mode)),- HCI\_CC(HCI\_OP\_READ\_LOCAL\_AMP\_INFO, hci\_cc\_read\_local\_amp\_info,- sizeof(struct hci\_rp\_read\_local\_amp\_info)), HCI\_CC(HCI\_OP\_READ\_CLOCK, hci\_cc\_read\_clock, sizeof(struct hci\_rp\_read\_clock)), HCI\_CC(HCI\_OP\_READ\_ENC\_KEY\_SIZE, hci\_cc\_read\_enc\_key\_size,@@ -4474,11 +4407,6 @@ static void hci\_num\_comp\_pkts\_evt(struct hci\_dev \*hdev, void \*data, flex\_array\_size(ev, handles, ev->num))) return; - if (hdev->flow\_ctl\_mode != HCI\_FLOW\_CTL\_MODE\_PACKET\_BASED) {- bt\_dev\_err(hdev, "wrong event for mode %d", hdev->flow\_ctl\_mode);- return;- }- bt\_dev\_dbg(hdev, "num %d", ev->num);  for (i = 0; i < ev->num; i++) {@@ -4546,78 +4474,6 @@ static void hci\_num\_comp\_pkts\_evt(struct hci\_dev \*hdev, void \*data, queue\_work(hdev->workqueue, &hdev->tx\_work); } -static struct hci\_conn \*\_\_hci\_conn\_lookup\_handle(struct hci\_dev \*hdev,- \_\_u16 handle)-{- struct hci\_chan \*chan;-- switch (hdev->dev\_type) {- case HCI\_PRIMARY:- return hci\_conn\_hash\_lookup\_handle(hdev, handle);- case HCI\_AMP:- chan = hci\_chan\_lookup\_handle(hdev, handle);- if (chan)- return chan->conn;- break;- default:- bt\_dev\_err(hdev, "unknown dev\_type %d", hdev->dev\_type);- break;- }-- return NULL;-}--static void hci\_num\_comp\_blocks\_evt(struct hci\_dev \*hdev, void \*data,- struct sk\_buff \*skb)-{- struct hci\_ev\_num\_comp\_blocks \*ev = data;- int i;-- if (!hci\_ev\_skb\_pull(hdev, skb, HCI\_EV\_NUM\_COMP\_BLOCKS,- flex\_array\_size(ev, handles, ev->num\_hndl)))- return;-- if (hdev->flow\_ctl\_mode != HCI\_FLOW\_CTL\_MODE\_BLOCK\_BASED) {- bt\_dev\_err(hdev, "wrong event for mode %d",- hdev->flow\_ctl\_mode);- return;- }-- bt\_dev\_dbg(hdev, "num\_blocks %d num\_hndl %d", ev->num\_blocks,- ev->num\_hndl);-- for (i = 0; i < ev->num\_hndl; i++) {- struct hci\_comp\_blocks\_info \*info = &ev->handles[i];- struct hci\_conn \*conn = NULL;- \_\_u16 handle, block\_count;-- handle = \_\_le16\_to\_cpu(info->handle);- block\_count = \_\_le16\_to\_cpu(info->blocks);-- conn = \_\_hci\_conn\_lookup\_handle(hdev, handle);- if (!conn)- continue;-- conn->sent -= block\_count;-- switch (conn->type) {- case ACL\_LINK:- case AMP\_LINK:- hdev->block\_cnt += block\_count;- if (hdev->block\_cnt > hdev->num\_blocks)- hdev->block\_cnt = hdev->num\_blocks;- break;-- default:- bt\_dev\_err(hdev, "unknown type %d conn %p",- conn->type, conn);- break;- }- }-- queue\_work(hdev->workqueue, &hdev->tx\_work);-}- static void hci\_mode\_change\_evt(struct hci\_dev \*hdev, void \*data, struct sk\_buff \*skb) {@@ -7531,9 +7387,6 @@ static const struct hci\_ev { /\* [0x3e = HCI\_EV\_LE\_META] \*/ HCI\_EV\_REQ\_VL(HCI\_EV\_LE\_META, hci\_le\_meta\_evt, sizeof(struct hci\_ev\_le\_meta), HCI\_MAX\_EVENT\_SIZE),- /\* [0x48 = HCI\_EV\_NUM\_COMP\_BLOCKS] \*/- HCI\_EV(HCI\_EV\_NUM\_COMP\_BLOCKS, hci\_num\_comp\_blocks\_evt,- sizeof(struct hci\_ev\_num\_comp\_blocks)), /\* [0xff = HCI\_EV\_VENDOR] \*/ HCI\_EV\_VL(HCI\_EV\_VENDOR, msft\_vendor\_evt, 0, HCI\_MAX\_EVENT\_SIZE), };diff --git a/net/bluetooth/hci\_sock.c b/net/bluetooth/hci\_sock.cindex 4ee1b976678b25..3d904ca92e9e8e 100644--- a/[net/bluetooth/hci\_sock.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/bluetooth/hci_sock.c?id=75d7ac5e225eda7ce687c27b56a66c33fc963311)+++ b/[net/bluetooth/hci\_sock.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/bluetooth/hci_sock.c?id=5af2e235b0d5b797e9531a00c50058319130e156)@@ -485,7 +485,7 @@ static struct sk\_buff \*create\_monitor\_event(struct hci\_dev \*hdev, int event) return NULL;  ni = skb\_put(skb, HCI\_MON\_NEW\_INDEX\_SIZE);- ni->type = hdev->dev\_type;+ ni->type = 0x00; /\* Old hdev->dev\_type \*/ ni->bus = hdev->bus; bacpy(&ni->bdaddr, &hdev->bdaddr); memcpy\_and\_pad(ni->name, sizeof(ni->name), hdev->name,@@ -1007,9 +1007,6 @@ static int hci\_sock\_bound\_ioctl(struct sock \*sk, unsigned int cmd, if (hci\_dev\_test\_flag(hdev, HCI\_UNCONFIGURED)) return -EOPNOTSUPP; - if (hdev->dev\_type != HCI\_PRIMARY)- return -EOPNOTSUPP;- switch (cmd) { case HCISETRAW: if (!capable(CAP\_NET\_ADMIN))diff --git a/net/bluetooth/hci\_sync.c b/net/bluetooth/hci\_sync.cindex 40f5324e1e66f8..d7ca5bd8ba3b04 100644--- a/[net/bluetooth/hci\_sync.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/bluetooth/hci_sync.c?id=75d7ac5e225eda7ce687c27b56a66c33fc963311)+++ b/[net/bluetooth/hci\_sync.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/bluetooth/hci_sync.c?id=5af2e235b0d5b797e9531a00c50058319130e156)@@ -3440,10 +3440,6 @@ static int hci\_unconf\_init\_sync(struct hci\_dev \*hdev) /\* Read Local Supported Features. \*/ static int hci\_read\_local\_features\_sync(struct hci\_dev \*hdev) {- /\* Not all AMP controllers support this command \*/- if (hdev->dev\_type == HCI\_AMP && !(hdev->commands[14] & 0x20))- return 0;- return \_\_hci\_cmd\_sync\_status(hdev, HCI\_OP\_READ\_LOCAL\_FEATURES, 0, NULL, HCI\_CMD\_TIMEOUT); }@@ -3478,51 +3474,6 @@ static int hci\_read\_local\_cmds\_sync(struct hci\_dev \*hdev) return 0; } -/\* Read Local AMP Info \*/-static int hci\_read\_local\_amp\_info\_sync(struct hci\_dev \*hdev)-{- return \_\_hci\_cmd\_sync\_status(hdev, HCI\_OP\_READ\_LOCAL\_AMP\_INFO,- 0, NULL, HCI\_CMD\_TIMEOUT);-}--/\* Read Data Blk size \*/-static int hci\_read\_data\_block\_size\_sync(struct hci\_dev \*hdev)-{- return \_\_hci\_cmd\_sync\_status(hdev, HCI\_OP\_READ\_DATA\_BLOCK\_SIZE,- 0, NULL, HCI\_CMD\_TIMEOUT);-}--/\* Read Flow Control Mode \*/-static int hci\_read\_flow\_control\_mode\_sync(struct hci\_dev \*hdev)-{- return \_\_hci\_cmd\_sync\_status(hdev, HCI\_OP\_READ\_FLOW\_CONTROL\_MODE,- 0, NULL, HCI\_CMD\_TIMEOUT);-}--/\* Read Location Data \*/-static int hci\_read\_location\_data\_sync(struct hci\_dev \*hdev)-{- return \_\_hci\_cmd\_sync\_status(hdev, HCI\_OP\_READ\_LOCATION\_DATA,- 0, NULL, HCI\_CMD\_TIMEOUT);-}--/\* AMP Controller init stage 1 command sequence \*/-static const struct hci\_init\_stage amp\_init1[] = {- /\* HCI\_OP\_READ\_LOCAL\_VERSION \*/- HCI\_INIT(hci\_read\_local\_version\_sync),- /\* HCI\_OP\_READ\_LOCAL\_COMMANDS \*/- HCI\_INIT(hci\_read\_local\_cmds\_sync),- /\* HCI\_OP\_READ\_LOCAL\_AMP\_INFO \*/- HCI\_INIT(hci\_read\_local\_amp\_info\_sync),- /\* HCI\_OP\_READ\_DATA\_BLOCK\_SIZE \*/- HCI\_INIT(hci\_read\_data\_block\_size\_sync),- /\* HCI\_OP\_READ\_FLOW\_CONTROL\_MODE \*/- HCI\_INIT(hci\_read\_flow\_control\_mode\_sync),- /\* HCI\_OP\_READ\_LOCATION\_DATA \*/- HCI\_INIT(hci\_read\_location\_data\_sync),- {}-};- static int hci\_init1\_sync(struct hci\_dev \*hdev) { int err;@@ -3536,28 +3487,9 @@ static int hci\_init1\_sync(struct hci\_dev \*hdev) return err; } - switch (hdev->dev\_type) {- case HCI\_PRIMARY:- hdev->flow\_ctl\_mode = HCI\_FLOW\_CTL\_MODE\_PACKET\_BASED;- return hci\_init\_stage\_sync(hdev, br\_init1);- case HCI\_AMP:- hdev->flow\_ctl\_mode = HCI\_FLOW\_CTL\_MODE\_BLOCK\_BASED;- return hci\_init\_stage\_sync(hdev, amp\_init1);- default:- bt\_dev\_err(hdev, "Unknown device type %d", hdev->dev\_type);- break;- }-- return 0;+ return hci\_init\_stage\_sync(hdev, br\_init1); } -/\* AMP Controller init stage 2 command sequence \*/-static const struct hci\_init\_stage amp\_init2[] = {- /\* HCI\_OP\_READ\_LOCAL\_FEATURES \*/- HCI\_INIT(hci\_read\_local\_features\_sync),- {}-};- /\* Read Buffer Size (ACL mtu, max pkt, etc.) \*/ static int hci\_read\_buffer\_size\_sync(struct hci\_dev \*hdev) {@@ -3815,9 +3747,6 @@ static int hci\_init2\_sync(struct hci\_dev \*hdev)  bt\_dev\_dbg(hdev, ""); - if (hdev->dev\_type == HCI\_AMP)- return hci\_init\_stage\_sync(hdev, amp\_init2);- err = hci\_init\_stage\_sync(hdev, hci\_init2); if (err) return err;@@ -4655,13 +4584,6 @@ static int hci\_init\_sync(struct hci\_dev \*hdev) if (err < 0) return err; - /\* HCI\_PRIMARY covers both single-mode LE, BR/EDR and dual-mode- \* BR/EDR/LE type controllers. AMP controllers only need the- \* first two stages of init.- \*/- if (hdev->dev\_type != HCI\_PRIMARY)- return 0;- err = hci\_init3\_sync(hdev); if (err < 0) return err;@@ -4890,12 +4812,8 @@ int hci\_dev\_open\_sync(struct hci\_dev \*hdev) \* In case of user channel usage, it is not important \* if a public address or static random address is \* available.- \*- \* This check is only valid for BR/EDR controllers- \* since AMP controllers do not have an address. \*/ if (!hci\_dev\_test\_flag(hdev, HCI\_USER\_CHANNEL) &&- hdev->dev\_type == HCI\_PRIMARY && !bacmp(&hdev->bdaddr, BDADDR\_ANY) && !bacmp(&hdev->static\_addr, BDADDR\_ANY)) { ret = -EADDRNOTAVAIL;@@ -4930,8 +4848,7 @@ int hci\_dev\_open\_sync(struct hci\_dev \*hdev) !hci\_dev\_test\_flag(hdev, HCI\_CONFIG) && !hci\_dev\_test\_flag(hdev, HCI\_UNCONFIGURED) && !hci\_dev\_test\_flag(hdev, HCI\_USER\_CHANNEL) &&- hci\_dev\_test\_flag(hdev, HCI\_MGMT) &&- hdev->dev\_type == HCI\_PRIMARY) {+ hci\_dev\_test\_flag(hdev, HCI\_MGMT)) { ret = hci\_powered\_update\_sync(hdev); mgmt\_power\_on(hdev, ret); }@@ -5077,8 +4994,7 @@ int hci\_dev\_close\_sync(struct hci\_dev \*hdev)  auto\_off = hci\_dev\_test\_and\_clear\_flag(hdev, HCI\_AUTO\_OFF); - if (!auto\_off && hdev->dev\_type == HCI\_PRIMARY &&- !hci\_dev\_test\_flag(hdev, HCI\_USER\_CHANNEL) &&+ if (!auto\_off && !hci\_dev\_test\_flag(hdev, HCI\_USER\_CHANNEL) && hci\_dev\_test\_flag(hdev, HCI\_MGMT)) \_\_mgmt\_power\_off(hdev); @@ -5140,9 +5056,6 @@ int hci\_dev\_close\_sync(struct hci\_dev \*hdev) hdev->flags &= BIT(HCI\_RAW); hci\_dev\_clear\_volatile\_flags(hdev); - /\* Controller radio is available but is currently powered down \*/- hdev->amp\_status = AMP\_STATUS\_POWERED\_DOWN;- memset(hdev->eir, 0, sizeof(hdev->eir)); memset(hdev->dev\_class, 0, sizeof(hdev->dev\_class)); bacpy(&hdev->random\_addr, BDADDR\_ANY);@@ -5179,8 +5092,7 @@ static int hci\_power\_on\_sync(struct hci\_dev \*hdev) \*/ if (hci\_dev\_test\_flag(hdev, HCI\_RFKILLED) || hci\_dev\_test\_flag(hdev, HCI\_UNCONFIGURED) ||- (hdev->dev\_type == HCI\_PRIMARY &&- !bacmp(&hdev->bdaddr, BDADDR\_ANY) &&+ (!bacmp(&hdev->bdaddr, BDADDR\_ANY) && !bacmp(&hdev->static\_addr, BDADDR\_ANY))) { hci\_dev\_clear\_flag(hdev, HCI\_AUTO\_OFF); hci\_dev\_close\_sync(hdev);@@ -5283,27 +5195,11 @@ int hci\_stop\_discovery\_sync(struct hci\_dev \*hdev) return 0; } -static int hci\_disconnect\_phy\_link\_sync(struct hci\_dev \*hdev, u16 handle,- u8 reason)-{- struct hci\_cp\_disconn\_phy\_link cp;-- memset(&cp, 0, sizeof(cp));- cp.phy\_handle = HCI\_PHY\_HANDLE(handle);- cp.reason = reason;-- return \_\_hci\_cmd\_sync\_status(hdev, HCI\_OP\_DISCONN\_PHY\_LINK,- sizeof(cp), &cp, HCI\_CMD\_TIMEOUT);-}- static int hci\_disconnect\_sync(struct hci\_dev \*hdev, struct hci\_conn \*conn, u8 reason) { struct hci\_cp\_disconnect cp; - if (conn->type == AMP\_LINK)- return hci\_disconnect\_phy\_link\_sync(hdev, conn->handle, reason);- if (test\_bit(HCI\_CONN\_BIG\_CREATED, &conn->flags)) { /\* This is a BIS connection, hci\_conn\_del will \* do the necessary cleanup.diff --git a/net/bluetooth/l2cap\_core.c b/net/bluetooth/l2cap\_core.cindex a754cf2c8ca8cb..37210567fbfbe7 100644--- a/[net/bluetooth/l2cap\_core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/bluetooth/l2cap_core.c?id=75d7ac5e225eda7ce687c27b56a66c33fc963311)+++ b/[net/bluetooth/l2cap\_core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/bluetooth/l2cap_core.c?id=5af2e235b0d5b797e9531a00c50058319130e156)@@ -3930,7 +3930,7 @@ static inline int l2cap\_command\_rej(struct l2cap\_conn \*conn, }  static void l2cap\_connect(struct l2cap\_conn \*conn, struct l2cap\_cmd\_hdr \*cmd,- u8 \*data, u8 rsp\_code, u8 amp\_id)+ u8 \*data, u8 rsp\_code) { struct l2cap\_conn\_req \*req = (struct l2cap\_conn\_req \*) data; struct l2cap\_conn\_rsp rsp;@@ -4009,17 +4009,8 @@ static void l2cap\_connect(struct l2cap\_conn \*conn, struct l2cap\_cmd\_hdr \*cmd, status = L2CAP\_CS\_AUTHOR\_PEND; chan->ops->defer(chan); } else {- /\* Force pending result for AMP controllers.- \* The connection will succeed after the- \* physical link is up.- \*/- if (amp\_id == AMP\_ID\_BREDR) {- l2cap\_state\_change(chan, BT\_CONFIG);- result = L2CAP\_CR\_SUCCESS;- } else {- l2cap\_state\_change(chan, BT\_CONNECT2);- result = L2CAP\_CR\_PEND;- }+ l2cap\_state\_change(chan, BT\_CONNECT2);+ result = L2CAP\_CR\_PEND; status = L2CAP\_CS\_NO\_INFO; } } else {@@ -4084,7 +4075,7 @@ static int l2cap\_connect\_req(struct l2cap\_conn \*conn, mgmt\_device\_connected(hdev, hcon, NULL, 0); hci\_dev\_unlock(hdev); - l2cap\_connect(conn, cmd, data, L2CAP\_CONN\_RSP, 0);+ l2cap\_connect(conn, cmd, data, L2CAP\_CONN\_RSP); return 0; } @@ -7497,10 +7488,6 @@ void l2cap\_recv\_acldata(struct hci\_conn \*hcon, struct sk\_buff \*skb, u16 flags) struct l2cap\_conn \*conn = hcon->l2cap\_data; int len; - /\* For AMP controller do not create l2cap conn \*/- if (!conn && hcon->hdev->dev\_type != HCI\_PRIMARY)- goto drop;- if (!conn) conn = l2cap\_conn\_add(hcon); diff --git a/net/bluetooth/mgmt.c b/net/bluetooth/mgmt.cindex ac693e64f1f9f7..0ca6593a029c09 100644--- a/[net/bluetooth/mgmt.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/bluetooth/mgmt.c?id=75d7ac5e225eda7ce687c27b56a66c33fc963311)+++ b/[net/bluetooth/mgmt.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/bluetooth/mgmt.c?id=5af2e235b0d5b797e9531a00c50058319130e156)@@ -443,8 +443,7 @@ static int read\_index\_list(struct sock \*sk, struct hci\_dev \*hdev, void \*data,  count = 0; list\_for\_each\_entry(d, &hci\_dev\_list, list) {- if (d->dev\_type == HCI\_PRIMARY &&- !hci\_dev\_test\_flag(d, HCI\_UNCONFIGURED))+ if (!hci\_dev\_test\_flag(d, HCI\_UNCONFIGURED)) count++; } @@ -468,8 +467,7 @@ static int read\_index\_list(struct sock \*sk, struct hci\_dev \*hdev, void \*data, if (test\_bit(HCI\_QUIRK\_RAW\_DEVICE, &d->quirks)) continue; - if (d->dev\_type == HCI\_PRIMARY &&- !hci\_dev\_test\_flag(d, HCI\_UNCONFIGURED)) {+ if (!hci\_dev\_test\_flag(d, HCI\_UNCONFIGURED)) { rp->index[count++] = cpu\_to\_le16(d->id); bt\_dev\_dbg(hdev, "Added hci%u", d->id); }@@ -503,8 +501,7 @@ static int read\_unconf\_index\_list(struct sock \*sk, struct hci\_dev \*hdev,  count = 0; list\_for\_each\_entry(d, &hci\_dev\_list, list) {- if (d->dev\_type == HCI\_PRIMARY &&- hci\_dev\_test\_flag(d, HCI\_UNCONFIGURED))+ if (hci\_dev\_test\_flag(d, HCI\_UNCONFIGURED)) count++; } @@ -528,8 +525,7 @@ static int read\_unconf\_index\_list(struct sock \*sk, struct hci\_dev \*hdev, if (test\_bit(HCI\_QUIRK\_RAW\_DEVICE, &d->quirks)) continue; - if (d->dev\_type == HCI\_PRIMARY &&- hci\_dev\_test\_flag(d, HCI\_UNCONFIGURED)) {+ if (hci\_dev\_test\_flag(d, HCI\_UNCONFIGURED)) { rp->index[count++] = cpu\_to\_le16(d->id); bt\_dev\_dbg(hdev, "Added hci%u", d->id); }@@ -561,10 +557,8 @@ static int read\_ext\_index\_list(struct sock \*sk, struct hci\_dev \*hdev, read\_lock(&hci\_dev\_list\_lock);  count = 0;- list\_for\_each\_entry(d, &hci\_dev\_list, list) {- if (d->dev\_type == HCI\_PRIMARY || d->dev\_type == HCI\_AMP)- count++;- }+ list\_for\_each\_entry(d, &hci\_dev\_list, list)+ count++;  rp = kmalloc(struct\_size(rp, entry, count), GFP\_ATOMIC); if (!rp) {@@ -585,16 +579,10 @@ static int read\_ext\_index\_list(struct sock \*sk, struct hci\_dev \*hdev, if (test\_bit(HCI\_QUIRK\_RAW\_DEVICE, &d->quirks)) continue; - if (d->dev\_type == HCI\_PRIMARY) {- if (hci\_dev\_test\_flag(d, HCI\_UNCONFIGURED))- rp->entry[count].type = 0x01;- else- rp->entry[count].type = 0x00;- } else if (d->dev\_type == HCI\_AMP) {- rp->entry[count].type = 0x02;- } else {- continue;- }+ if (hci\_dev\_test\_flag(d, HCI\_UNCONFIGURED))+ rp->entry[count].type = 0x01;+ else+ rp->entry[count].type = 0x00;  rp->entry[count].bus = d->bus; rp->entry[count++].index = cpu\_to\_le16(d->id);@@ -9324,23 +9312,14 @@ void mgmt\_index\_added(struct hci\_dev \*hdev) if (test\_bit(HCI\_QUIRK\_RAW\_DEVICE, &hdev->quirks)) return; - switch (hdev->dev\_type) {- case HCI\_PRIMARY:- if (hci\_dev\_test\_flag(hdev, HCI\_UNCONFIGURED)) {- mgmt\_index\_event(MGMT\_EV\_UNCONF\_INDEX\_ADDED, hdev,- NULL, 0, HCI\_MGMT\_UNCONF\_INDEX\_EVENTS);- ev.type = 0x01;- } else {- mgmt\_index\_event(MGMT\_EV\_INDEX\_ADDED, hdev, NULL, 0,- HCI\_MGMT\_INDEX\_EVENTS);- ev.type = 0x00;- }- break;- case HCI\_AMP:- ev.type = 0x02;- break;- default:- return;+ if (hci\_dev\_test\_flag(hdev, HCI\_UNCONFIGURED)) {+ mgmt\_index\_event(MGMT\_EV\_UNCONF\_INDEX\_ADDED, hdev, NULL, 0,+ HCI\_MGMT\_UNCONF\_INDEX\_EVENTS);+ ev.type = 0x01;+ } else {+ mgmt\_index\_event(MGMT\_EV\_INDEX\_ADDED, hdev, NULL, 0,+ HCI\_MGMT\_INDEX\_EVENTS);+ ev.type = 0x00; }  ev.bus = hdev->bus;@@ -9357,25 +9336,16 @@ void mgmt\_index\_removed(struct hci\_dev \*hdev) if (test\_bit(HCI\_QUIRK\_RAW\_DEVICE, &hdev->quirks)) return; - switch (hdev->dev\_type) {- case HCI\_PRIMARY:- mgmt\_pending\_foreach(0, hdev, cmd\_complete\_rsp, &status);+ mgmt\_pending\_foreach(0, hdev, cmd\_complete\_rsp, &status); - if (hci\_dev\_test\_flag(hdev, HCI\_UNCONFIGURED)) {- mgmt\_index\_event(MGMT\_EV\_UNCONF\_INDEX\_REMOVED, hdev,- NULL, 0, HCI\_MGMT\_UNCONF\_INDEX\_EVENTS);- ev.type = 0x01;- } else {- mgmt\_index\_event(MGMT\_EV\_INDEX\_REMOVED, hdev, NULL, 0,- HCI\_MGMT\_INDEX\_EVENTS);- ev.type = 0x00;- }- break;- case HCI\_AMP:- ev.type = 0x02;- break;- default:- return;+ if (hci\_dev\_test\_flag(hdev, HCI\_UNCONFIGURED)) {+ mgmt\_index\_event(MGMT\_EV\_UNCONF\_INDEX\_REMOVED, hdev, NULL, 0,+ HCI\_MGMT\_UNCONF\_INDEX\_EVENTS);+ ev.type = 0x01;+ } else {+ mgmt\_index\_event(MGMT\_EV\_INDEX\_REMOVED, hdev, NULL, 0,+ HCI\_MGMT\_INDEX\_EVENTS);+ ev.type = 0x00; }  ev.bus = hdev->bus; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 15:17:31 +0000

