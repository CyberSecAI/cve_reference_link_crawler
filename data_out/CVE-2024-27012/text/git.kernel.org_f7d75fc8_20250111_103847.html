

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=e79b47a8615d42c68aaeb68971593333667382ed)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=e79b47a8615d42c68aaeb68971593333667382ed)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e79b47a8615d42c68aaeb68971593333667382ed)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e79b47a8615d42c68aaeb68971593333667382ed)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Pablo Neira Ayuso <pablo@netfilter.org> | 2024-04-17 17:43:11 +0200 |
| --- | --- | --- |
| committer | Pablo Neira Ayuso <pablo@netfilter.org> | 2024-04-17 17:43:11 +0200 |
| commit | [e79b47a8615d42c68aaeb68971593333667382ed](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e79b47a8615d42c68aaeb68971593333667382ed) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=e79b47a8615d42c68aaeb68971593333667382ed)) | |
| tree | [afb23df81ed91da0c6fe474bfdad486eae8e12ca](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=e79b47a8615d42c68aaeb68971593333667382ed) | |
| parent | [efefd4f00c967d00ad7abe092554ffbb70c1a793](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=efefd4f00c967d00ad7abe092554ffbb70c1a793) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e79b47a8615d42c68aaeb68971593333667382ed&id2=efefd4f00c967d00ad7abe092554ffbb70c1a793)) | |
| download | [linux-e79b47a8615d42c68aaeb68971593333667382ed.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-e79b47a8615d42c68aaeb68971593333667382ed.tar.gz) | |

netfilter: nf\_tables: restore set elements when delete set failsFrom abort path, nft\_mapelem\_activate() needs to restore refcounters to
the original state. Currently, it uses the set->ops->walk() to iterate
over these set elements. The existing set iterator skips inactive
elements in the next generation, this does not work from the abort path
to restore the original state since it has to skip active elements
instead (not inactive ones).
This patch moves the check for inactive elements to the set iterator
callback, then it reverses the logic for the .activate case which
needs to skip active elements.
Toggle next generation bit for elements when delete set command is
invoked and call nft\_clear() from .activate (abort) path to restore the
next generation bit.
The splat below shows an object in mappings memleak:
[43929.457523] ------------[ cut here ]------------
[43929.457532] WARNING: CPU: 0 PID: 1139 at include/net/netfilter/nf\_tables.h:1237 nft\_setelem\_data\_deactivate+0xe4/0xf0 [nf\_tables]
[...]
[43929.458014] RIP: 0010:nft\_setelem\_data\_deactivate+0xe4/0xf0 [nf\_tables]
[43929.458076] Code: 83 f8 01 77 ab 49 8d 7c 24 08 e8 37 5e d0 de 49 8b 6c 24 08 48 8d 7d 50 e8 e9 5c d0 de 8b 45 50 8d 50 ff 89 55 50 85 c0 75 86 <0f> 0b eb 82 0f 0b eb b3 0f 1f 40 00 90 90 90 90 90 90 90 90 90 90
[43929.458081] RSP: 0018:ffff888140f9f4b0 EFLAGS: 00010246
[43929.458086] RAX: 0000000000000000 RBX: ffff8881434f5288 RCX: dffffc0000000000
[43929.458090] RDX: 00000000ffffffff RSI: ffffffffa26d28a7 RDI: ffff88810ecc9550
[43929.458093] RBP: ffff88810ecc9500 R08: 0000000000000001 R09: ffffed10281f3e8f
[43929.458096] R10: 0000000000000003 R11: ffff0000ffff0000 R12: ffff8881434f52a0
[43929.458100] R13: ffff888140f9f5f4 R14: ffff888151c7a800 R15: 0000000000000002
[43929.458103] FS: 00007f0c687c4740(0000) GS:ffff888390800000(0000) knlGS:0000000000000000
[43929.458107] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[43929.458111] CR2: 00007f58dbe5b008 CR3: 0000000123602005 CR4: 00000000001706f0
[43929.458114] Call Trace:
[43929.458118] <TASK>
[43929.458121] ? \_\_warn+0x9f/0x1a0
[43929.458127] ? nft\_setelem\_data\_deactivate+0xe4/0xf0 [nf\_tables]
[43929.458188] ? report\_bug+0x1b1/0x1e0
[43929.458196] ? handle\_bug+0x3c/0x70
[43929.458200] ? exc\_invalid\_op+0x17/0x40
[43929.458211] ? nft\_setelem\_data\_deactivate+0xd7/0xf0 [nf\_tables]
[43929.458271] ? nft\_setelem\_data\_deactivate+0xe4/0xf0 [nf\_tables]
[43929.458332] nft\_mapelem\_deactivate+0x24/0x30 [nf\_tables]
[43929.458392] nft\_rhash\_walk+0xdd/0x180 [nf\_tables]
[43929.458453] ? \_\_pfx\_nft\_rhash\_walk+0x10/0x10 [nf\_tables]
[43929.458512] ? rb\_insert\_color+0x2e/0x280
[43929.458520] nft\_map\_deactivate+0xdc/0x1e0 [nf\_tables]
[43929.458582] ? \_\_pfx\_nft\_map\_deactivate+0x10/0x10 [nf\_tables]
[43929.458642] ? \_\_pfx\_nft\_mapelem\_deactivate+0x10/0x10 [nf\_tables]
[43929.458701] ? \_\_rcu\_read\_unlock+0x46/0x70
[43929.458709] nft\_delset+0xff/0x110 [nf\_tables]
[43929.458769] nft\_flush\_table+0x16f/0x460 [nf\_tables]
[43929.458830] nf\_tables\_deltable+0x501/0x580 [nf\_tables]
Fixes: 628bd3e49cba ("netfilter: nf\_tables: drop map element references from preparation phase")
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e79b47a8615d42c68aaeb68971593333667382ed)

| -rw-r--r-- | [net/netfilter/nf\_tables\_api.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nf_tables_api.c?id=e79b47a8615d42c68aaeb68971593333667382ed) | 44 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/netfilter/nft\_set\_bitmap.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nft_set_bitmap.c?id=e79b47a8615d42c68aaeb68971593333667382ed) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/netfilter/nft\_set\_hash.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nft_set_hash.c?id=e79b47a8615d42c68aaeb68971593333667382ed) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/netfilter/nft\_set\_pipapo.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nft_set_pipapo.c?id=e79b47a8615d42c68aaeb68971593333667382ed) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/netfilter/nft\_set\_rbtree.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nft_set_rbtree.c?id=e79b47a8615d42c68aaeb68971593333667382ed) | 4 | |  |  |  | | --- | --- | --- | |

5 files changed, 45 insertions, 20 deletions

| diff --git a/net/netfilter/nf\_tables\_api.c b/net/netfilter/nf\_tables\_api.cindex a7a34db62ea93b..d0c09f899e8013 100644--- a/[net/netfilter/nf\_tables\_api.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nf_tables_api.c?id=efefd4f00c967d00ad7abe092554ffbb70c1a793)+++ b/[net/netfilter/nf\_tables\_api.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nf_tables_api.c?id=e79b47a8615d42c68aaeb68971593333667382ed)@@ -594,6 +594,12 @@ static int nft\_mapelem\_deactivate(const struct nft\_ctx \*ctx, const struct nft\_set\_iter \*iter, struct nft\_elem\_priv \*elem\_priv) {+ struct nft\_set\_ext \*ext = nft\_set\_elem\_ext(set, elem\_priv);++ if (!nft\_set\_elem\_active(ext, iter->genmask))+ return 0;++ nft\_set\_elem\_change\_active(ctx->net, set, ext); nft\_setelem\_data\_deactivate(ctx->net, set, elem\_priv);  return 0;@@ -617,6 +623,7 @@ static void nft\_map\_catchall\_deactivate(const struct nft\_ctx \*ctx, if (!nft\_set\_elem\_active(ext, genmask)) continue; + nft\_set\_elem\_change\_active(ctx->net, set, ext); nft\_setelem\_data\_deactivate(ctx->net, set, catchall->elem); break; }@@ -3880,6 +3887,9 @@ int nft\_setelem\_validate(const struct nft\_ctx \*ctx, struct nft\_set \*set, const struct nft\_data \*data; int err; + if (!nft\_set\_elem\_active(ext, iter->genmask))+ return 0;+ if (nft\_set\_ext\_exists(ext, NFT\_SET\_EXT\_FLAGS) && \*nft\_set\_ext\_flags(ext) & NFT\_SET\_ELEM\_INTERVAL\_END) return 0;@@ -3903,17 +3913,20 @@ int nft\_setelem\_validate(const struct nft\_ctx \*ctx, struct nft\_set \*set,  int nft\_set\_catchall\_validate(const struct nft\_ctx \*ctx, struct nft\_set \*set) {- u8 genmask = nft\_genmask\_next(ctx->net);+ struct nft\_set\_iter dummy\_iter = {+ .genmask = nft\_genmask\_next(ctx->net),+ }; struct nft\_set\_elem\_catchall \*catchall;+ struct nft\_set\_ext \*ext; int ret = 0;  list\_for\_each\_entry\_rcu(catchall, &set->catchall\_list, list) { ext = nft\_set\_elem\_ext(set, catchall->elem);- if (!nft\_set\_elem\_active(ext, genmask))+ if (!nft\_set\_elem\_active(ext, dummy\_iter.genmask)) continue; - ret = nft\_setelem\_validate(ctx, set, NULL, catchall->elem);+ ret = nft\_setelem\_validate(ctx, set, &dummy\_iter, catchall->elem); if (ret < 0) return ret; }@@ -5402,6 +5415,11 @@ static int nf\_tables\_bind\_check\_setelem(const struct nft\_ctx \*ctx, const struct nft\_set\_iter \*iter, struct nft\_elem\_priv \*elem\_priv) {+ const struct nft\_set\_ext \*ext = nft\_set\_elem\_ext(set, elem\_priv);++ if (!nft\_set\_elem\_active(ext, iter->genmask))+ return 0;+ return nft\_setelem\_data\_validate(ctx, set, elem\_priv); } @@ -5494,6 +5512,13 @@ static int nft\_mapelem\_activate(const struct nft\_ctx \*ctx, const struct nft\_set\_iter \*iter, struct nft\_elem\_priv \*elem\_priv) {+ struct nft\_set\_ext \*ext = nft\_set\_elem\_ext(set, elem\_priv);++ /\* called from abort path, reverse check to undo changes. \*/+ if (nft\_set\_elem\_active(ext, iter->genmask))+ return 0;++ nft\_clear(ctx->net, ext); nft\_setelem\_data\_activate(ctx->net, set, elem\_priv);  return 0;@@ -5511,6 +5536,7 @@ static void nft\_map\_catchall\_activate(const struct nft\_ctx \*ctx, if (!nft\_set\_elem\_active(ext, genmask)) continue; + nft\_clear(ctx->net, ext); nft\_setelem\_data\_activate(ctx->net, set, catchall->elem); break; }@@ -5785,6 +5811,9 @@ static int nf\_tables\_dump\_setelem(const struct nft\_ctx \*ctx, const struct nft\_set\_ext \*ext = nft\_set\_elem\_ext(set, elem\_priv); struct nft\_set\_dump\_args \*args; + if (!nft\_set\_elem\_active(ext, iter->genmask))+ return 0;+ if (nft\_set\_elem\_expired(ext) || nft\_set\_elem\_is\_dead(ext)) return 0; @@ -6635,7 +6664,7 @@ static void nft\_setelem\_activate(struct net \*net, struct nft\_set \*set, struct nft\_set\_ext \*ext = nft\_set\_elem\_ext(set, elem\_priv);  if (nft\_setelem\_is\_catchall(set, elem\_priv)) {- nft\_set\_elem\_change\_active(net, set, ext);+ nft\_clear(net, ext); } else { set->ops->activate(net, set, elem\_priv); }@@ -7317,8 +7346,12 @@ static int nft\_setelem\_flush(const struct nft\_ctx \*ctx, const struct nft\_set\_iter \*iter, struct nft\_elem\_priv \*elem\_priv) {+ const struct nft\_set\_ext \*ext = nft\_set\_elem\_ext(set, elem\_priv); struct nft\_trans \*trans; + if (!nft\_set\_elem\_active(ext, iter->genmask))+ return 0;+ trans = nft\_trans\_alloc\_gfp(ctx, NFT\_MSG\_DELSETELEM, sizeof(struct nft\_trans\_elem), GFP\_ATOMIC); if (!trans)@@ -10800,6 +10833,9 @@ static int nf\_tables\_loop\_check\_setelem(const struct nft\_ctx \*ctx, { const struct nft\_set\_ext \*ext = nft\_set\_elem\_ext(set, elem\_priv); + if (!nft\_set\_elem\_active(ext, iter->genmask))+ return 0;+ if (nft\_set\_ext\_exists(ext, NFT\_SET\_EXT\_FLAGS) && \*nft\_set\_ext\_flags(ext) & NFT\_SET\_ELEM\_INTERVAL\_END) return 0;diff --git a/net/netfilter/nft\_set\_bitmap.c b/net/netfilter/nft\_set\_bitmap.cindex 32df7a16835da3..1caa04619dc6da 100644--- a/[net/netfilter/nft\_set\_bitmap.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_bitmap.c?id=efefd4f00c967d00ad7abe092554ffbb70c1a793)+++ b/[net/netfilter/nft\_set\_bitmap.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_bitmap.c?id=e79b47a8615d42c68aaeb68971593333667382ed)@@ -172,7 +172,7 @@ static void nft\_bitmap\_activate(const struct net \*net, nft\_bitmap\_location(set, nft\_set\_ext\_key(&be->ext), &idx, &off); /\* Enter 11 state. \*/ priv->bitmap[idx] |= (genmask << off);- nft\_set\_elem\_change\_active(net, set, &be->ext);+ nft\_clear(net, &be->ext); }  static void nft\_bitmap\_flush(const struct net \*net,@@ -222,8 +222,6 @@ static void nft\_bitmap\_walk(const struct nft\_ctx \*ctx, list\_for\_each\_entry\_rcu(be, &priv->list, head) { if (iter->count < iter->skip) goto cont;- if (!nft\_set\_elem\_active(&be->ext, iter->genmask))- goto cont;  iter->err = iter->fn(ctx, set, iter, &be->priv); diff --git a/net/netfilter/nft\_set\_hash.c b/net/netfilter/nft\_set\_hash.cindex 6968a3b342367c..daa56dda737ae2 100644--- a/[net/netfilter/nft\_set\_hash.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_hash.c?id=efefd4f00c967d00ad7abe092554ffbb70c1a793)+++ b/[net/netfilter/nft\_set\_hash.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_hash.c?id=e79b47a8615d42c68aaeb68971593333667382ed)@@ -199,7 +199,7 @@ static void nft\_rhash\_activate(const struct net \*net, const struct nft\_set \*set, { struct nft\_rhash\_elem \*he = nft\_elem\_priv\_cast(elem\_priv); - nft\_set\_elem\_change\_active(net, set, &he->ext);+ nft\_clear(net, &he->ext); }  static void nft\_rhash\_flush(const struct net \*net,@@ -286,8 +286,6 @@ static void nft\_rhash\_walk(const struct nft\_ctx \*ctx, struct nft\_set \*set,  if (iter->count < iter->skip) goto cont;- if (!nft\_set\_elem\_active(&he->ext, iter->genmask))- goto cont;  iter->err = iter->fn(ctx, set, iter, &he->priv); if (iter->err < 0)@@ -599,7 +597,7 @@ static void nft\_hash\_activate(const struct net \*net, const struct nft\_set \*set, { struct nft\_hash\_elem \*he = nft\_elem\_priv\_cast(elem\_priv); - nft\_set\_elem\_change\_active(net, set, &he->ext);+ nft\_clear(net, &he->ext); }  static void nft\_hash\_flush(const struct net \*net,@@ -652,8 +650,6 @@ static void nft\_hash\_walk(const struct nft\_ctx \*ctx, struct nft\_set \*set, hlist\_for\_each\_entry\_rcu(he, &priv->table[i], node) { if (iter->count < iter->skip) goto cont;- if (!nft\_set\_elem\_active(&he->ext, iter->genmask))- goto cont;  iter->err = iter->fn(ctx, set, iter, &he->priv); if (iter->err < 0)diff --git a/net/netfilter/nft\_set\_pipapo.c b/net/netfilter/nft\_set\_pipapo.cindex 0f903d18bbea06..187138afac45d4 100644--- a/[net/netfilter/nft\_set\_pipapo.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_pipapo.c?id=efefd4f00c967d00ad7abe092554ffbb70c1a793)+++ b/[net/netfilter/nft\_set\_pipapo.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_pipapo.c?id=e79b47a8615d42c68aaeb68971593333667382ed)@@ -1847,7 +1847,7 @@ static void nft\_pipapo\_activate(const struct net \*net, { struct nft\_pipapo\_elem \*e = nft\_elem\_priv\_cast(elem\_priv); - nft\_set\_elem\_change\_active(net, set, &e->ext);+ nft\_clear(net, &e->ext); }  /\*\*@@ -2149,9 +2149,6 @@ static void nft\_pipapo\_walk(const struct nft\_ctx \*ctx, struct nft\_set \*set,  e = f->mt[r].e; - if (!nft\_set\_elem\_active(&e->ext, iter->genmask))- goto cont;- iter->err = iter->fn(ctx, set, iter, &e->priv); if (iter->err < 0) goto out;diff --git a/net/netfilter/nft\_set\_rbtree.c b/net/netfilter/nft\_set\_rbtree.cindex 9944fe479e5361..b7ea21327549b3 100644--- a/[net/netfilter/nft\_set\_rbtree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_rbtree.c?id=efefd4f00c967d00ad7abe092554ffbb70c1a793)+++ b/[net/netfilter/nft\_set\_rbtree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_set_rbtree.c?id=e79b47a8615d42c68aaeb68971593333667382ed)@@ -532,7 +532,7 @@ static void nft\_rbtree\_activate(const struct net \*net, { struct nft\_rbtree\_elem \*rbe = nft\_elem\_priv\_cast(elem\_priv); - nft\_set\_elem\_change\_active(net, set, &rbe->ext);+ nft\_clear(net, &rbe->ext); }  static void nft\_rbtree\_flush(const struct net \*net,@@ -600,8 +600,6 @@ static void nft\_rbtree\_walk(const struct nft\_ctx \*ctx,  if (iter->count < iter->skip) goto cont;- if (!nft\_set\_elem\_active(&rbe->ext, iter->genmask))- goto cont;  iter->err = iter->fn(ctx, set, iter, &rbe->priv); if (iter->err < 0) { |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 10:37:24 +0000

