```
{
  "CVE-2024-26846": {
    "description": "The module exit path has a race between deleting all controllers and freeing 'left over IDs'. To prevent double free a synchronization between `nvme_delete_ctrl` and `ida_destroy` has been added by the initial commit. There is some logic around trying to prevent from hanging forever in wait_for_completion, though it does not handle all cases. E.g., blktests is able to reproduce the situation where the module unload hangs forever. If we completely rely on the cleanup code executed from the `nvme_delete_ctrl` path, all IDs will be freed eventually. This makes calling `ida_destroy` unnecessary. We only have to ensure that all `nvme_delete_ctrl` code has been executed before we leave `nvme_fc_exit_module`. This is done by flushing the `nvme_delete_wq` workqueue. Also removes the unused `nvme_fc_wq` workqueue.",
    "root_cause": "Race condition during module unload between deleting controllers and freeing IDs, leading to potential double frees or hangs.",
    "vulnerabilities": [
      "Race condition in module exit path",
      "Potential double free due to improper synchronization",
       "Unnecessary wait in wait_for_completion that can lead to hang"
    ],
    "impact": "Module unload can hang indefinitely if the race condition occurs.",
    "attack_vectors": [
      "Triggering module unload at a specific time"
    ],
    "required_capabilities": "Ability to unload the nvme-fc module, possibly requiring root privileges."
  }
}
```