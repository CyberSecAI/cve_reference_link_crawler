

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=baa6b7eb8c66486bd64608adc63fe03b30d3c0b9)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=baa6b7eb8c66486bd64608adc63fe03b30d3c0b9)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=baa6b7eb8c66486bd64608adc63fe03b30d3c0b9)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=baa6b7eb8c66486bd64608adc63fe03b30d3c0b9)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Daniel Wagner <dwagner@suse.de> | 2024-01-31 09:51:01 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-03-01 13:34:52 +0100 |
| commit | [baa6b7eb8c66486bd64608adc63fe03b30d3c0b9](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=baa6b7eb8c66486bd64608adc63fe03b30d3c0b9) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=baa6b7eb8c66486bd64608adc63fe03b30d3c0b9)) | |
| tree | [302e6f3a9b73ab6447bc83208a3c6a51daa642c6](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=baa6b7eb8c66486bd64608adc63fe03b30d3c0b9) | |
| parent | [ffd63f243735aebc092f1fee9fc1f9d8ce20bfb4](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ffd63f243735aebc092f1fee9fc1f9d8ce20bfb4) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=baa6b7eb8c66486bd64608adc63fe03b30d3c0b9&id2=ffd63f243735aebc092f1fee9fc1f9d8ce20bfb4)) | |
| download | [linux-baa6b7eb8c66486bd64608adc63fe03b30d3c0b9.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-baa6b7eb8c66486bd64608adc63fe03b30d3c0b9.tar.gz) | |

nvme-fc: do not wait in vain when unloading module[ Upstream commit 70fbfc47a392b98e5f8dba70c6efc6839205c982 ]
The module exit path has race between deleting all controllers and
freeing 'left over IDs'. To prevent double free a synchronization
between nvme\_delete\_ctrl and ida\_destroy has been added by the initial
commit.
There is some logic around trying to prevent from hanging forever in
wait\_for\_completion, though it does not handling all cases. E.g.
blktests is able to reproduce the situation where the module unload
hangs forever.
If we completely rely on the cleanup code executed from the
nvme\_delete\_ctrl path, all IDs will be freed eventually. This makes
calling ida\_destroy unnecessary. We only have to ensure that all
nvme\_delete\_ctrl code has been executed before we leave
nvme\_fc\_exit\_module. This is done by flushing the nvme\_delete\_wq
workqueue.
While at it, remove the unused nvme\_fc\_wq workqueue too.
Reviewed-by: Christoph Hellwig <hch@lst.de>
Reviewed-by: Hannes Reinecke <hare@suse.de>
Signed-off-by: Daniel Wagner <dwagner@suse.de>
Signed-off-by: Keith Busch <kbusch@kernel.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=baa6b7eb8c66486bd64608adc63fe03b30d3c0b9)

| -rw-r--r-- | [drivers/nvme/host/fc.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/nvme/host/fc.c?id=baa6b7eb8c66486bd64608adc63fe03b30d3c0b9) | 47 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 6 insertions, 41 deletions

| diff --git a/drivers/nvme/host/fc.c b/drivers/nvme/host/fc.cindex 46cce0ec35e9a1..cdb1e706f855e5 100644--- a/[drivers/nvme/host/fc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/nvme/host/fc.c?id=ffd63f243735aebc092f1fee9fc1f9d8ce20bfb4)+++ b/[drivers/nvme/host/fc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/nvme/host/fc.c?id=baa6b7eb8c66486bd64608adc63fe03b30d3c0b9)@@ -221,11 +221,6 @@ static LIST\_HEAD(nvme\_fc\_lport\_list); static DEFINE\_IDA(nvme\_fc\_local\_port\_cnt); static DEFINE\_IDA(nvme\_fc\_ctrl\_cnt); -static struct workqueue\_struct \*nvme\_fc\_wq;--static bool nvme\_fc\_waiting\_to\_unload;-static DECLARE\_COMPLETION(nvme\_fc\_unload\_proceed);- /\* \* These items are short-term. They will eventually be moved into \* a generic FC class. See comments in module init.@@ -255,8 +250,6 @@ nvme\_fc\_free\_lport(struct kref \*ref) /\* remove from transport list \*/ spin\_lock\_irqsave(&nvme\_fc\_lock, flags); list\_del(&lport->port\_list);- if (nvme\_fc\_waiting\_to\_unload && list\_empty(&nvme\_fc\_lport\_list))- complete(&nvme\_fc\_unload\_proceed); spin\_unlock\_irqrestore(&nvme\_fc\_lock, flags);  ida\_free(&nvme\_fc\_local\_port\_cnt, lport->localport.port\_num);@@ -3893,10 +3886,6 @@ static int \_\_init nvme\_fc\_init\_module(void) { int ret; - nvme\_fc\_wq = alloc\_workqueue("nvme\_fc\_wq", WQ\_MEM\_RECLAIM, 0);- if (!nvme\_fc\_wq)- return -ENOMEM;- /\* \* NOTE: \* It is expected that in the future the kernel will combine@@ -3914,7 +3903,7 @@ static int \_\_init nvme\_fc\_init\_module(void) ret = class\_register(&fc\_class); if (ret) { pr\_err("couldn't register class fc\n");- goto out\_destroy\_wq;+ return ret; }  /\*@@ -3938,8 +3927,6 @@ out\_destroy\_device: device\_destroy(&fc\_class, MKDEV(0, 0)); out\_destroy\_class: class\_unregister(&fc\_class);-out\_destroy\_wq:- destroy\_workqueue(nvme\_fc\_wq);  return ret; }@@ -3959,45 +3946,23 @@ nvme\_fc\_delete\_controllers(struct nvme\_fc\_rport \*rport) spin\_unlock(&rport->lock); } -static void-nvme\_fc\_cleanup\_for\_unload(void)+static void \_\_exit nvme\_fc\_exit\_module(void) { struct nvme\_fc\_lport \*lport; struct nvme\_fc\_rport \*rport;-- list\_for\_each\_entry(lport, &nvme\_fc\_lport\_list, port\_list) {- list\_for\_each\_entry(rport, &lport->endp\_list, endp\_list) {- nvme\_fc\_delete\_controllers(rport);- }- }-}--static void \_\_exit nvme\_fc\_exit\_module(void)-{ unsigned long flags;- bool need\_cleanup = false;  spin\_lock\_irqsave(&nvme\_fc\_lock, flags);- nvme\_fc\_waiting\_to\_unload = true;- if (!list\_empty(&nvme\_fc\_lport\_list)) {- need\_cleanup = true;- nvme\_fc\_cleanup\_for\_unload();- }+ list\_for\_each\_entry(lport, &nvme\_fc\_lport\_list, port\_list)+ list\_for\_each\_entry(rport, &lport->endp\_list, endp\_list)+ nvme\_fc\_delete\_controllers(rport); spin\_unlock\_irqrestore(&nvme\_fc\_lock, flags);- if (need\_cleanup) {- pr\_info("%s: waiting for ctlr deletes\n", \_\_func\_\_);- wait\_for\_completion(&nvme\_fc\_unload\_proceed);- pr\_info("%s: ctrl deletes complete\n", \_\_func\_\_);- }+ flush\_workqueue(nvme\_delete\_wq);  nvmf\_unregister\_transport(&nvme\_fc\_transport); - ida\_destroy(&nvme\_fc\_local\_port\_cnt);- ida\_destroy(&nvme\_fc\_ctrl\_cnt);- device\_destroy(&fc\_class, MKDEV(0, 0)); class\_unregister(&fc\_class);- destroy\_workqueue(nvme\_fc\_wq); }  module\_init(nvme\_fc\_init\_module); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 13:53:37 +0000

