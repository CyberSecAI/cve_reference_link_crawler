<!DOCTYPE html><script defer="defer">(function(){const dataUrl = "https://cdn-docs.pingidentity.com/locations/redirects.json";
const SERVEMODE = "production";

  (() => {
    /**
     * Functions to break URL patterns into searchable objects
     */

    //
    const diagnostic = SERVEMODE === "development" ? 5 : SERVEMODE === "staging" ? 3 : 0;
    /**
     * Normalize query keys to data[old*] values
     * @param {string} str - Requested key to normalize
     * @returns {string} - Normalized `old*` key
     */
    function normalizeKeys(str) {
      let key = str.toLowerCase();
      if(diagnostic > 4) {
        console.log("normalizeKeys:", key);
      }
      if (["bundle", "bundleid", "category", "product", "pubname"].includes(key)) {
        key = "oldproduct";
      } else if (["dita:id", "page", "topicid", "topicname", "resourceid", "context", "ft:clusterid"].includes(key)) {
        key = "oldpage";
      } else if (["releasestatus_ce"].includes(key)) {
        key = "oldversion";
      } else {
        key = "oldurl";
      }
      return key;
    }

    /**
     * Convert a direct URL query string into normalized
     * key-value pairs (Zoomin and Fluid Topics)
     * @param str - Query parameters from URL string
     */
    function breakQuery(str) {
      const query = new URLSearchParams(str);
      const props = [];
      for (const [korg, val] of query) {
        const key = normalizeKeys(korg);
        props.push(`${key}|${val}`);
      }
      return props;
    }

    /**
     * Break direct URL string into key-value pair, assume
     * Zoomin format /bundle/{product}/{page}
     * @param str - Zoomin format segment of URL string
     */
    function breakZM(str) {
      if (str.startsWith("/")) {
        str = str.slice(1);
      }
      const segs = str.split("/");
      const props = [];
      for (let s = 0; s < segs.length; s += 2) {
        const key = normalizeKeys(segs[s]);
        const val = segs[s + 1];
        props.push(`${key}|${val}`);
      }
      return props;
    }

    /**
     * Break direct URL string into key-value pair, assume
     * Fluid Topics format /{product}/{page}
     * @param str - Fluid Topics format segment of URL string
     */
    function breakFT(str) {
      const segs = str.replace(/\/[rp]\/en-us\//, "").split("/");

      const props = [];
      if (Array.isArray(segs)) {
        for (let s = 0; s < segs.length; s++) {
          if (segs[s] === "") {
            segs.splice(s, 1);
          }
        }
      }

      if (segs.length < 2) {
        props.push(`oldproduct|${segs[0]}`);
        props.push(`oldpage|`);
      } else if (segs.length === 2) {
        props.push(`oldproduct|${segs[0]}`);
        props.push(`oldpage|${segs[1]}`);
      } else {
        // don't do anything
      }
      return props;
    }

    /**
     * Main calling function that takes starting URL string
     * and breaks into key-value pairs
     * @param testurl
     */
    function getProps(testurl) {
      let getprops = [];
      if (testurl.endsWith("/")) {
        testurl = testurl.slice(0, -1);
      }
      const lcurl = testurl.toLowerCase();
      const queryurl = lcurl.split("?");
      if (queryurl.length > 1) {
        getprops = breakQuery(queryurl[1]);
      } else if (lcurl.includes("/bundle/")) {
        getprops = breakZM(lcurl);
      } else if (lcurl.includes("/en-us")) {
        getprops = breakFT(lcurl);
      } else {
        // don't do anything
      }
      getprops.push(`oldurl|${testurl}`);

      const keyValuePairs = getprops.reduce((acc, item) => {
        const [key, value] = item.split("|");
        acc[key] = value;
        return acc;
      }, {});

      return keyValuePairs;
    }

    /**
     * Searches data for items that match all requested urlprops
     * @param urlprops - Normalized requested URL properties
     * @param data - Redirect data to search
     * @param ret - Return object for new* values
     */
    function searchData(urlprops, data, ret) {
      // Ignore oldurl key
      keys = Object.keys(urlprops).filter((key) => !key.endsWith("url"));

      // Iterate over each item in the data
      if (data && Array.isArray(data) && Array.isArray(keys) && keys.length > 0) {
        data.forEach((item) => {
          // Check if the item matches all specified keys
          const isMatch = keys.every((key) => {
            const skey = key;
            if (item[skey] && item[skey].toLowerCase() === urlprops[skey]) {
              return true;
            } else {
              return false;
            }
          });

          // If the item matches all keys, collect all new* values
          if (isMatch) {
            if (diagnostic > 4) {
              console.log(`Yes! Full match: ${isMatch}`, item);
            }
            for (const prop in item) {
              if (prop.startsWith("new")) {
                if (diagnostic > 4) {
                  console.log(`Adding ${prop}: ${item[prop]}`);
                }
                ret[prop] = item[prop];
              }
            }
          }
        });
      }
    }

    /**
     * Search existing redirect data for first instance of key
     * @param key - old* key to search for
     * @param urlprops - Normalized URL properties
     * @param data - Redirect data to search
     * @returns {Object} - Object containing new* values
     */
    function searchKey(key, urlprops, data, ret) {
      // set up search and return key
      const skey = `old${key}`;
      const rkey = `new${key}`;
      if (diagnostic > 3) {
        console.log(`searching for ${skey}`, urlprops[skey], `to return ${rkey}`);
      }

      // if key has value, then search for it
      if (data && urlprops[skey] && !ret.newurl && !ret[rkey]) {
        // find the item in data
        const item = data.find((item) => item[skey] == urlprops[skey]);

        if (item) {
          if (item[rkey]) {
            ret[rkey] = item[rkey];
          }

          // check if versioned product
          if (rkey === "newproduct" && item["newversion"]) {
            if (diagnostic > 3) {
              console.log("adding newversion:", item["newversion"]);
            }
            ret["newversion"] = item["newversion"];
          }
          ret[rkey] = item[rkey];
        }
      }
    }

    /**
     * Builds the target URL from the new* values
     * @param host - URL protocol and host
     * @param f - Object containing new* values
     */
    function craftUrl(host, f) {
      let newUrl = host;

      if (f.newurl) {
        // check that newurl has host info
        const re = new RegExp(/https?:\/\/[^/]+/);
        if (f.newurl.match(re)) {
          newUrl = f.newurl;
        } else {
          newUrl += f.newurl;
        }
      }

      // if product exists, then check for version
      if (f.newproduct) {
        newUrl += `/${f.newproduct}`;

        if (f.newversion) {
          newUrl += `/${f.newversion}`;
        }
      }

      if (f.newpage) {
        newUrl += `/${f.newpage}`;
      }
      return newUrl;
    }

    /**
     * Build search parameter string from URL properties
     * @param urlprops - Normalized URL properties
     * @returns {string} - Search parameter string
     */
    function setSearch(urlprops) {
      // if oldurl isn't the only property, wipe oldurl to
      // exclude from search
      if (urlprops.oldurl && Object.keys(urlprops).length > 1) {
        urlprops.oldurl = null;
      }

      // build search array
      const ext = new RegExp(/(index|)\.(s|)html/g);
      const spc = new RegExp(/[\W_]+/g);
      const urlstring = Object.values(urlprops).join(" ").replaceAll(ext, "").replaceAll(spc, " ");
      const allterms = urlstring.split(" ");

      if (diagnostic > 3) {
        console.log("Search parameters start:", allterms);
      }

      /* prettier-ignore */
      const xterm = [
        "a", "an", "and", "as", "at", "but", "by", "for",
        "from", "in", "nor", "of", "on", "or", "so", "the",
        "to", "with", "yet",
      ];

      const search = [];
      for (const term of allterms) {
        if (term !== "" && !xterm.includes(term) && !search.includes(term)) {
          search.push(term);
        }
      }

      if (diagnostic > 3) {
        console.log("Search parameters returned:", search);
      }

      return search.join(" ").trim();
    }

    /**
     * Main function to handle 404 page redirect
     */
    document.addEventListener("DOMContentLoaded", async function () {
      if (SERVEMODE === "development") {
        // local development
        try {
          urldata = JSON.parse(document.getElementById("url-data").getAttribute("data-urls"));
        } catch (error) {
          console.error("No data available for redirect", error);
          urldata = {}; // Handle the error appropriately
        }
      } else {
        // deployed mode
        urldata = await fetch(dataUrl)
          .then((response) => response.json())
          .catch(() => {
            return null; // check existence of data when searching
          });
      }

      // capture the requested URL that 404'd without host info
      const ghostprotocol = `${location.protocol}//${location.host}`;
      const olddoc = decodeURIComponent(location.href.replace(ghostprotocol, ""));
      let getprops = getProps(olddoc);

      if (diagnostic > 0) {
        console.log("olddoc:", olddoc);
        console.log("getprops:", getprops);
      }

      const reUrl = {};
      if (diagnostic > 3) {
        console.log("reUrl initiated:", reUrl);
        console.log("Step 1 - search for oldurl");
      }
      // search for the old URL in the redirect data
      // 1. find specific url
      searchKey("url", getprops, urldata, reUrl);
      if (diagnostic > 2) {
        console.log("reUrl after search", reUrl);
        console.log("Step 2 - search for exact prop match");
      }

      // 2. find match of all keys
      if (!reUrl.newurl) {
        searchData(getprops, urldata, reUrl);
      }
      if (diagnostic > 2) {
        console.log("reUrl after search", reUrl);
        console.log("Step 3 - search for individual parameters");
      }

      // 3. page, product, version
      if (!reUrl.newurl) {
        for (const key of ["page", "product", "version"]) {
          if (diagnostic > 3) {
            console.log(`reUrl before ${key}:`, reUrl);
          }
          if (!reUrl[`new${key}`]) {
            searchKey(key, getprops, urldata, reUrl);
          }
          if (diagnostic > 3) {
            console.log(`reUrl after ${key}:`, reUrl);
          }
        }
      }
      if (diagnostic > 3) {
        console.log("Penultimate reUrl:", reUrl);
      }

      // if requested product has version, then set version to latest
      const ver = new RegExp(/-\d+$/);
      if (getprops.oldproduct && getprops.oldproduct.match(ver) && !reUrl.newversion) {
        reUrl.newversion = "latest";
      }
      if (diagnostic > 2) {
        console.log("FINALreUrl:", reUrl);
      }

      let newUrl = null;
      // build new URL
      if (diagnostic > 2) {
        console.log("reURl length:", Object.keys(reUrl).length);
        console.log("getprops:", getprops);
      }
      if (Object.keys(reUrl).length > 0) {
        newUrl = craftUrl(ghostprotocol, reUrl);
      } else {
        const s = setSearch(getprops);
        let u = '';
        if(ghostprotocol.includes('staging-developer') ||
          ghostprotocol.includes('localhost') ) {
          u = 'https://staging-docs.pingidentity.com';
        } else if(ghostprotocol.includes('developer')) {
          u = 'https://docs.pingidentity.com';
        } else {
          u = ghostprotocol;
        }
        newUrl = `${u}/404-search.html?search=${s}`;
      }

      if (SERVEMODE !== "production") {
        const newUrlDisplay = document.createElement("p");
        newUrlDisplay.innerHTML = `Go to <a href="${newUrl}">${newUrl}</a>`;
        document.body.appendChild(newUrlDisplay);
      }
      if (SERVEMODE !== "development") {
        location.href = newUrl;
      }
    });
  })();
})();</script>