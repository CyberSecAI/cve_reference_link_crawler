=== Content from ftp.netbsd.org_a7161690_20250108_132741.html ===
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
NetBSD Security Advisory 2021-001
=================================
Topic: Predictable ID disclosures in IPv4 and IPv6
Version: NetBSD-current: affected
NetBSD 9.1: affected
NetBSD 8.2: affected
Severity: Possible data exfiltration from firewalled or NATed networks
Fixed: NetBSD-current: March 9, 2021
NetBSD-9 branch: March 9, 2021
NetBSD-8 branch: March 9, 2021
Please note that NetBSD releases prior to 8.2 are no longer supported.
It is recommended that all users upgrade to a supported release.
Abstract
========
IP ID randomization was not enabled by default and the randomization
algorithms were not strong enough.
Technical Details
=================
1. IPv4 and IPv6 fragment ids were not randomly generated by default.
Furthermore the randomization algorithms were not strong enough.
2. The TCP ISS random generation had an information leak.
3. The IPv6 flow label generation algorithm was not strong enough.
Solutions and Workarounds
=========================
Update the kernel to a fixed version and reboot.
There are pre-built binaries for all architectures and NetBSD versions at:
https://nycdn.netbsd.org/pub/NetBSD-daily/
For example you can find the standard GENERIC kernel for NetBSD-9/amd64 at:
https://nycdn.netbsd.org/pub/NetBSD-daily/netbsd-9/latest/amd64/binary/kernel/netbsd-GENERIC.gz
The following revisions fix the issues:
src/sys/netinet/in\_var.h 1.99,1.102
src/sys/netinet/ip6.h 1.30
src/sys/netinet/ip\_input.c 1.400
src/sys/netinet/tcp\_subr.c 1.285,1.286
src/sys/netinet/tcp\_timer.c 1.96
src/sys/netinet6/ip6\_id.c 1.20
src/sys/netinet6/ip6\_var.h 1.88
The fixed source may be obtained from the NetBSD CVS repository. The
following instructions briefly summarise how to upgrade your kernel.
In these instructions, replace:
ARCH with your architecture (from uname -m), and
KERNCONF with the name of your kernel configuration file.
To update from CVS, re-build, and re-install the kernel:
# cd src
# cvs update -d -P sys/netinet sys/netinet6
# ./build.sh kernel=KERNCONF
# mv /netbsd /netbsd.old
# cp sys/arch/ARCH/compile/obj/KERNCONF/netbsd /netbsd
# shutdown -r now
For more information on how to do this, see:
https://www.NetBSD.org/docs/guide/en/chap-kernel.html
Thanks To
=========
Amit Klein for reporting these vulnerabilities and Taylor R. Campbell
for fixing them.
More Information
================
Advisories may be updated as new information becomes available.
The most recent version of this advisory (PGP signed) can be found at
https://ftp.NetBSD.org/pub/NetBSD/security/advisories/NetBSD-SA2021-001.txt.asc
Information about NetBSD and NetBSD security can be found at
https://www.NetBSD.org/
https://www.NetBSD.org/Security/
Copyright 2021, The NetBSD Foundation, Inc. All Rights Reserved.
Redistribution permitted only in full, unmodified form.
-----BEGIN PGP SIGNATURE-----
iQIcBAEBAgAGBQJgTNu4AAoJEIkmHhf170n/bA4QAMIqhK0umvnNgu4tKLt1iL+j
plFWJpRmEgFX5DlALvsXrMZtlm3SnQ6OzwjSCmgRRbADtzTBB3t2Jeba1SjOMVa0
OQRtGi3QuD6uc40XnVYZT7kEJL8tgPBkdUBmVFFhVG27Vhyufvs5wa8QvmqWeNBs
rPS0KKB0vonAolChiaxHNIiv5ep0Xgjq9UY1otAf2r84m/lVgT3h+oQBWckN27lz
lG/GzfOm9f1JHQiwqX2dEhKU/XVcoorEcI3RMqYOyKsmnZ/YdUKMt2+12c2OGpX9
4D6YyJPMmDU8fdunCoLn5HngRTddo2sUsOcDcabsw1GCb5CEVfgxV8/G7nypYglI
8tBwTIfVAy7It5F25zsatH7+Im+yGtnAzila1Ape1eJ8NCfOlOhzIA6yc70J2GUK
KiAuVnTzLuRPKsDjgWvBO6RmQc+pDme+Jrgb2Q1i7cTagW2pv9rUluN6GQn/Pmv2
8Djc+r5fHwJH3NjNmItUGbdGk3IjOI7fCEb/Lf1FJFftW3M29NpYzPswlV/auoOM
A07pcHJ2zvR/KAnV3URfZOpba2LgjNeyF4eQ4CADg6/j42Jsz0ujBsv95Ts40lZo
vBL5lTGCJO0xiYYLayQaPQtf/rw76qfA5tj3FacIhuHb9rJAgi3Pch2iJbAKN7tP
b00faeTSn2gmx3yFdTRA
=KCmd
-----END PGP SIGNATURE-----


=== Content from arxiv.org_bebae20a_20250108_132743.html ===
2
2
0
2

g
u
A
1
3

]

R
C
.
s
c
[

5
v
4
0
6
9
0
.
2
1
1
2
:
v
i
X
r
a

Subverting Stateful Firewalls with Protocol States
(Extended Version)∗

Amit Klein

Bar Ilan University
aksecurity@gmail.com

Abstract

We analyzed the generation of protocol header ﬁelds
in the implementations of multiple TCP/IP network
stacks and found new ways to leak information about
global protocol states. We then demonstrated new
covert channels by remotely observing and modify-
ing the system’s global state via these protocol ﬁelds.
Unlike earlier works, our research focuses on hosts
that reside in ﬁrewalled networks (including source
address validation – SAV), which is a very com-
mon scenario nowadays. Our attacks are designed
to be non-disruptive – in the exﬁltration scenario,
this makes the attacks stealthier and thus extends
their longevity, and in case of host alias resolution
and similar techniques – this ensures the techniques
are ethical. We focused on ICMP, which is commonly
served by ﬁrewalls, and on UDP, which is forecasted
to take a more prominent share of the Internet traﬃc
with the advent of HTTP/3 and QUIC, though we
report results for TCP as well.

The information leakage scenarios we discovered
enable the construction of practical covert channels
which directly pierce ﬁrewalls, or indirectly establish
communication via hosts in ﬁrewalled networks that
also employ SAV. We describe and test three novel
attacks in this context: exﬁltration via the ﬁrewall
itself, exﬁltration via a DMZ host, and exﬁltration
via co-resident containers. These are three generic,
new use cases for covert channels that work around

∗This is an extended version of a paper that will be pub-

lished in NDSS 2022.

ﬁrewalling and enable devices that are not allowed
direct communication with the Internet, to still ex-
ﬁltrate data out of the network. In other words, we
exﬁltrate data from isolated networks to the Internet.
We also explain how to mount known attacks such as
host alias resolution, de-NATting and container co-
residence detection, using the new information leak-
age techniques.

1

Introduction

Our research focuses on how to exploit global state in
the UDP and ICMP protocol stacks to mount attacks
against ﬁrewalled networks and hosts. The attacks
we are interested in are data exﬁltration, host alias
resolution and de-NATting, and co-residency detec-
tion – see Table 1. In some cases, the same attacks
can be carried out over TCP, in a more eﬃcient man-
ner than existing techniques.

1.1 Motivation

Our motivating example is a highly secured network,
wherein internal machines are not allowed to com-
municate directly with the Internet. This is enforced
by a network ﬁrewall, which prevents the network
hosts from accessing the Internet, but may allow
them to access services on a neighboring internal net-
work and/or management access to the ﬁrewall itself.
Such isolated networks can be found in ﬁnancial insti-
tutions, defense industries, hospitals, sensitive infras-
tructure sites, etc. The attacker’s goal is to exﬁltrate

1

Table 1: Attack Use Cases

1.2 Organization

Use Case

Firewall Piercing
(exﬁltration)
Exﬁltration
(via DMZ)
Co-Resident
Container
Exﬁltration
Alias Detection
and de-NATting

Sender
Location
Isolated
network
Isolated
network

Isolated
network

Internet

Target Host

Firewall

Firewalled
host in DMZ
Two co-resident
containers
(internal+external)
Firewalled/NATted
host

Receiver
Location

Internet

Internet

Internet

Internet
(=Sender)

data out of an isolated network, to the Internet. The
compromised data may consist of small “strategic”
pieces of data, such as cryptographic keys, or com-
pressed text ﬁles.

We assume that an attacker controls a compro-
mised internal machine. For example, the attacker
may have installed malware on that machine, by
means out of scope for this research. The attacker’s
goal is to exﬁltrate data from this machine. It should
be noted that the machine may be part of an attacker
network of compromised machines, such that the at-
tacker funnels the data to be exﬁltrated from other
machines to the machine from which the exﬁtration
is to take place.

Our techniques are able to circumvent the ﬁrewall’s
enforcement, and allow the attacker to exﬁltrate data
from a machine in an isolated network to an Internet
host the attacker controls. The exﬁltration through-
put is hundreds to thousands bits per hour (except
for Windows), which suﬃces to transmit e.g. a 128-
bit key in less than 22 minutes.

It should be stressed that this is an example to
one use case (ﬁrewall circumvention); in the paper
we also outline other attacks, such as host alias res-
olution and de-NATting, and co-residency detection.
The motivation for these use cases is to provide op-
erational intelligence as part of a larger attack eﬀort.
Detecting that two services reside on the same host
may enable an attack against a weaker (vulnerable)
service to take over a host which also runs a more
strategic (but not vulnerable in itself) service.

Next in this section we provide background on terms
and concepts we use throughout the paper (state-
ful ﬁrewalls, host alias resolution, and co-residency),
followed by a summary of our contributions. In Sec-
tion 2 we discuss related work. Section 3 describes the
current algorithms that generate the protocol ﬁelds
of interest. Section 4 outlines our attack concepts,
Section 5 then explains how the concepts are imple-
mented per-OS, and Section 6 describes our exper-
iments. A discussion of remediation options is pro-
vided in Section 7. We draw our conclusions in Sec-
tion 8, and ﬁnally we report on the vendor status in
Section 9.

1.3 Stateful Firewalls and SAV

A stateful ﬁrewall is a “network-based ﬁrewall that
individually tracks sessions of network connections
traversing it” [50]. According to [34], “[a] stateful in-
spection ﬁrewall is the de facto standard for network
protection”. SAV, and some features of stateful ﬁre-
walls can eliminate known data leakage attacks. We
explain this below, and we note that our techniques
are not aﬀected by SAV and by stateful ﬁrewalls.

In response to an incoming invalid packet – a TCP
packet or a UDP packet destined to a closed port,
or a TCP packet (other than SYN-only to an open
port) that does not belong to an already established
TCP session – a ﬁrewall may either silently drop the
packet, or actively reject it. Rejection is carried out
by sending back a TCP RST packet in the TCP case,
or by sending back an ICMP Type 3 Code 3 packet
(“port unreachable”) in the UDP case.

Dropping invalid packets is considered a somewhat
more secure choice (at the expense of a slight overall
performance degradation due to a delay in respon-
siveness at the remote party when no rejection packet
is sent), and is oftentimes set as the default ﬁrewall
behavior.
In Appendix A, we report the results of
an experiment in which we measured and estimated
the portion of widely-used Internet hosts that do not
send any response for UDP and TCP packets arriv-
ing to closed ports. We found that the vast majority
of the Internet hosts silently drop such UDP/TCP

2

packets. Therefore, attacks that assume a response
for an invalid, connecion-less UDP/TCP packet will
fail for most servers. Our attacks, on the other hand,
only use valid and acceptable packets, and are thus
unaﬀected by stateful ﬁrewalls.

A ﬁrewall can also employ Source Address Valida-
tion (SAV), such that it does not allow traﬃc from a
ﬁrst network into a second network with source ad-
dresses outside the ﬁrst network. This security mea-
sure can prevent some trivial information leaking at-
tacks. For example, a host A on an isolated, internal
network which is prevented from sending packets to
the Internet can send a spoofed packet whose source
address C is an Internet address, to host B in the
DMZ network which is allowed to send data to the In-
ternet. Host B will then respond by sending a packet
to C, an Internet address. This can be used as a
covert channel signal. SAV prevents this by drop-
ping A’s spoofed packets since their spoofed source
address C does not match their origin (the internal
network).

Henceforth, we use the term ﬁrewall as a short-
hand for “a stateful ﬁrewall that silently drops invalid
packets, with SAV between all its networks”.

1.4 Host Alias Resolution, De-
Co-Residency
and

NATting
Detection

Note: we use the term host throughout this paper
to denote a single instance of an operating system
kernel. This can be a physical host, or – if virtual
machines are used – a single virtual machine. We use
the term physical host to explicitly exclude the latter
case.

A host alias resolution [46] (also host alias detec-
tion [16]) technique enables a remote party to infer
whether two given IP addresses map to the same host
or to two diﬀerent hosts. We can extend this into in-
ferring whether two services (deﬁned by IP address,
the listening port and the transport protocol – TCP
or UDP) map to the same host or not. For exam-
ple, one can ask whether 1.2.3.4:80 (over TCP) and
5.6.7.8:443 (over UDP) map to the same host.

De-NATting [10] [41] is a use case of host alias de-

tection, wherein the host(s) in questions reside be-
hind a NAT, and thus the two services are mapped
from their external endpoints into internal endpoints
by a NAT device.

In this research, we focus on server de-NATting,
meaning, discerning whether two external endpoints
refer to the same host or to two diﬀerent hosts. This
is in contrast to client de-NATting, which refers to
discerning whether two outbound connections (desig-
nated by their external address endpoints) are made
by a single client or by two diﬀerent clients. The ma-
terial diﬀerence is that a NATted client is likely to use
a single internal IP address, whereas a NATted server
may use two IP addresses for two diﬀerent services.
Some operating systems use the (IP SRC , IP DST ) tu-
ple to generate network ﬁelds, making it trivial to
de-NAT clients, but not servers.

Co-Residency Detection for Containers [45] is a
concept similar to host alias detection, which aims to
detect whether two endpoints on two diﬀerent con-
tainers are hosted by the same physical host. If vir-
tualization is used, then the containers may run on
two diﬀerent virtual machines. We are interested in
a variant of this concept, which is to detect whether
two endpoints on two diﬀerent containers are hosted
by the same operating system kernel.

Container technology (e.g. Docker) is available for
Linux and Windows. Our co-residency detection at-
tacks apply to Linux, but not to Windows.

1.5 Our Contribution

• New information leakage techniques based
on the statefulness of IPv4 ID, TCP ISN (IPv4
and IPv6) and IPv6 ﬂow label in popular server
operating systems: Linux, Windows Server, ma-
cOS Server, OpenBSD and NetBSD. In the IPv4
ID and TCP ISN cases, this is done without ac-
curately predicting the full values of these proto-
col ﬁelds. Our results are summarized in Table 2.
These techniques are non-disruptive, and can be
used even when the target host is ﬁrewalled, in-
cluding SAV. The attacks are algorithmic, and
therefore are not hardware-speciﬁc, nor do they
require ﬁne-grained timing or rely on race con-
ditions. And since they rely on kernel imple-

3

Table 2: Information Leaking Fields and Their Chan-
nel Properties

by Windows to manage (IP SRC , IP DST ) tuples,
including IPv4 ID management.

OS

Protocol

Field

Sender
Capabilities

Channel Bandwidth

2 Related Work

Linux

Windows

UDP/IPv4,
ICMP/IPv4
UDP/IPv4,
TCP/IPv4

IPv4 ID

IP Spooﬁng

IPv4 ID

IP Spooﬁng

macOS

UDP/IPv4

IPv4 ID

macOS

ICMP/IPv4 (rate limit)

OpenBSD

NetBSD

UDP/IPv4,
TCP/IPv4
ICMP/IPv4
TCP/IPv4,
TCP/IPv6

NetBSD

TCP/IPv6

IPv4 ID

TCP ISN

IPv6 Flow
Label

Web Traﬃc
Emission
Web Traﬃc
Emission

Web Traﬃc
Emission

Web Traﬃc
Emission
Web Traﬃc
Emission

400 b/h (UDP),
3000 b/h (ICMP)
47.4 b/h (UDP),
41.4 b/h (TCP)

1800 b/h

1800 b/h (estimated)

720 b/h (UDP, throttled),
360 b/h (TCP, throttled)
4200 b/h (ICMP)

7200 b/h (throttled)

Untested

mentations, they are agnostic to the nature of
applications/services the operating system runs.

• Exﬁltration from a ﬁrewalled network (including
SAV) and exﬁltration between co-resident con-
tainers – a new covert channel use case for
exploitation of stateful IPv4 ID, TCP ISN and
IPv6 ﬂow label. In this use case, an internal de-
vice is prevented from directly connecting to the
Internet, by a ﬁrewall, but is allowed to connect
to the ﬁrewall itself, or to a DMZ host, or to an
internal container co-residing with a 3rd party
container. Our attacks exploit the host’s global
protocol states to exﬁltrate data from the inter-
nal device to the Internet. The covert channels’
bandwidth (in bits/hour) depends on the infor-
mation leakage techniques’ bandwidth listed in
Table 2.

• Constructing a covert channel based on the new
information leakage techniques and exploiting it
for well known attack use cases: server alias res-
olution, de-NATting, container co-residency de-
tection, and idle scanning. Previously, these at-
tacks were inapplicable either due to the under-
lying information leaking technique being mit-
igated, or due to the disruptive nature of the
underlying technique or other limitations.

• A description of the present day algorithm used

2.1 IPv4 Global State and Side Chan-

nels

2.1.1 Prediction of IPv4 ID values

The IPv4 ID ﬁeld is a 16 bit identiﬁer used to re-
assemble IP packets from smaller fragments. This
ﬁeld is populated by the OS regardless of whether
fragmentation is actually needed. If the IPv4 ID ﬁeld
is generated in a predictable manner, e.g.
sequen-
tial increment per packet, then it is possible to sam-
ple the ﬁeld twice and determine whether the target
host sent another packet in between. For this ap-
proach, the IPv4 ID ﬁeld must be highly predictable,
i.e with a near-zero entropy. Note of course that if the
ID is static (e.g. 0), which is legitimate for atomic
(DF=1)1 packets [49, Section 4], then no informa-
tion is leaked. However, some operating systems (e.g.
Linux) do set DF=1 for short packets, yet still pop-
ulate the ID ﬁeld with a non-static value.

The original idle-scan technique [44] exploited se-
quential IP IDs which were very common in the oper-
ating systems of that era (1998). Later in 2008, [29]
cryptanalyzed the IPv4 ID mechanism of OpenBSD
and macOS Server and showed it to be predictable.
In response, OpenBSD and macOS Server changed
their algorithm.
In 2019, [31] attacked the IP ID
generation in Windows TCP/IPv4 and UDP/IPv4,
In response, Windows
and in Linux UDP/IPv4.
and Linux changed their algorithms. Recently, [30]
showed that the Linux TCP/IPv4 ID ﬁeld is also
predictable, and in response Linux changed that al-
gorithm as well.

The only operating systems nowadays that gener-
ate predictable (sequential) IPv4 IDs are FreeBSD
(UDP/IPv4 only) and NetBSD (only for packets
longer than 68 bytes, thus excluding e.g. TCP
RST packets). With the exception of FreeBSD and

1The IPv4 DF (“Don’t Fragment”) header ﬂag controls
fragmentation by routers. Setting DF=1 prohibits routers
from fragmenting the packet.

4

NetBSD, all operating systems we surveyed upgraded
their IPv4 ID generation scheme to a non-predictable
algorithm, hence attacks that rely on IPv4 ID predic-
tion are no longer applicable to them.

Moreover, in general, idle-scanning, which relies on
the pivot server to send an RST packet for “unex-
pected” SYN+ACK packet, does not apply to a ﬁre-
walled pivot server. A ﬁrewall is likely to silently drop
the SYN+ACK packet, or alternatively the ﬁrewall
may respond with an RST packet, without forward-
ing it to the pivot server. We do, however, note that
our NetBSD ﬂow label attack can be used for eﬃ-
cient idle scanning TCP/IPv6 hosts with NetBSD as
a pivot server, when the latter is not ﬁrewalled.

In 2008, Danezis described how to construct covert
channels from incremental IPv4 IDs [17].
But
Danezis’s use case is diﬀerent than ours. Danzeis as-
sumes the monitored party can still connect to the In-
ternet, and as such, he focuses on channel robustness,
rather than on the technicalities of implementing the
technique for ﬁrewalled networks. Additionally, that
work does not describe UDP-based techniques, IPv6-
based techniques and container-based techniques.

In contrast, the global IPv4 ID states we describe
exist in modern IPv4 ID generator implementations.
These global states are typically subtle and not easily
observed.

2.1.2 Attacks on the Linux IPv4 ID Gen-
eration Algorithm for UDP and TCP
Connection-Less Packets

The Linux IPv4 ID generation algorithm for
connection-less packets (ICMP and UDP; until v4.19
also TCP RST packets not in a connection context)
is described in Section 3.1. This construction was at-
tacked in several recent papers. Some attacks against
Linux TCP connections exploited this algorithm, ei-
ther when used for TCP RST packets [52] [3] (note
that since v4.19, the Linux kernel sets IPv4 ID to 0
in RST packets which are not in an existing connec-
tion context), or through a “downgrade attack” from
the more secure TCP IP ID generation scheme [20].
However, these attacks do not aﬀect Linux UDP and
ICMP traﬃc, which is the object of our research.
Additionally, these attacks practically require the at-

tacker to own thousands of IPv4 addresses. In 2019,
[31] exploited the Linux IP ID generation structure
to ﬁnd partial hash collisions and extract the hashing
key. In response, the hash function was modiﬁed to
use a larger key.

A recent DNS cache poisoning attack [53] involv-
ing Linux-based recursive resolvers hinges on the fact
that when two machines are behind the same NAT,
their external IPv4 address is identical, and hence
the packets sent by a Linux host to both machines
share the IPv4 ID counter. But to exploit this for
exﬁltration, the sender and receiver must be on the
same network and behind the same NAT, which is
inapplicable to an exﬁltration scenario.

Similarly to the above attacks, our attacks exploit
the counter array of the Linux IPv4 ID algorithm,
but in contrast to the previous attacks, our attacks
target ICMP and UDP services, and they do not re-
quire ownership of thousands of IPv4 addresses, or
having the sender and the receiver reside on the same
network, and can target any host.

2.1.3 IPv4 De-fragmentation Cache

Another global IPv4 state is the memory limit for
the de-fragmentation cache, a kernel data structure
that maintains the incoming IPv4 fragments. The
limit can be applied per source IP address, or glob-
ally. Overﬂowing the de-fragmentation cache can be
detected remotely, as explained in [22], and can thus
be used as a side channel. This technique requires
IPv4 fragments to traverse the Internet unmodiﬁed.
However, the prevalence of Carrier Grade NATs (CG-
NATs) reduces the attack surface of this technique.
In CGNATs, the attacker cannot space the arrival
time to the target host of fragments that belong to
the same IP packet. Rather, the ﬁrst fragment will
await virtual de-fragmentation on the CGNAT de-
vice, and will only be transmitted when the second
fragment arrives at the CGNAT. In fact, anecdo-
tal evidence from our lab’s ISP indicates that CG-
NATs may employ an even more destructive strategy,
wherein they reassemble the IPv4 packet and forward
the complete packet.

Additionally, since this attack overﬂows the de-
fragmentation cache, it is disruptive, as organic in-

5

bound fragments may be evicted from the cache be-
fore re-assembly, resulting in dropping of organic in-
bound packets.

2.2 UDP Global State and Side Chan-

nels

The UDP protocol does not contain global states per-
se. However, [2] describes a global state based on a
rate limit imposed by some kernels on ICMP proto-
col “port unreachable” messages, sent in response to
incoming UDP packets destined to closed ports. It
should be noted though, that ﬁrewalls handle UDP
packets sent to closed ports themselves (without for-
warding them to the destination host), and are likely
not to send back ICMP messages, due to security
reasons. In Appendix A we report that an estimated
85% of the widely-used Internet hosts/ﬁrewalls do not
send ICMP “port unreachable” messages.

2.3 TCP Global States and Side

Channels

Our attack on NetBSD is TCP-based, and our attacks
on Windows and OpenBSD IPv4 ID can also be used
in TCP protocols. Therefore, we also survey TCP-
based side channels, but only if they are relevant to
any of these operating systems.

In 2005, Kohno et al. [32] demonstrated device
identiﬁcation based on the device clock skew, ob-
served in the TCP timestamp ﬁeld. This work was
later improved in [37]. Windows, OpenBSD and
NetBSD do not implement TCP timestamps useful
for the [32] and [37] attacks (Windows Server does
not send a TCP timestamp at all, and OpenBSD
and NetBSD have TCP timestamp at 0.5s resolu-
tion). In the past, TCP Timestamps could be used as
a “passive” side channel for host alias resolution, as
described in [13] [26], but nowadays this only applies
to macOS.

In 2010, Ensaﬁ et al. [19] used model checking to
discover information leakage due to the rate limit on
a global TCP RST counter. Exploiting this requires
the sender client to send the server either SYN pack-
ets for a closed port, or otherwise packets that pur-
In
portedly belong to a non-existing TCP circuit.

both cases, a stateful ﬁrewall may silently drop the
packets and thwart the attack. In Appendix A, we
report that an estimated 92% of the widely-used In-
ternet hosts/ﬁrewalls drop such packets.

Additional side channels are described by [19], [14]
and [15], which are based e.g. on TCP SYN cookies
and TCP challenge ACKs. But these mechanisms are
not employed (at least not by default) by Windows,
OpenBSD and NetBSD. We see, therefore, that for
ﬁrewalled Windows Server, OpenBSD and NetBSD
hosts, there are no currently known remotely ex-
ploitable TCP global states.

2.4 Host Alias Detection and De-

NATting

Early host alias detection and de-NATting relied on
global states that are trivial to observe and follow,
and compared such global states between two end-
points. Bellovin’s seminal 2002 de-NATting paper
[10] is based on a globally incrementing IPv4 ID as a
global state. This concept was later applied to host
alias resolution, e.g. with IPv6 ID [11]. Client de-
NATting based on the IPv4 ID of outbound DNS
queries over UDP was described in [41]. This attack
relies on the incremental nature of the IP ID for a
ﬁxed (IP SRC , IP DST ) tuple, and thus cannot be ap-
plied to server de-NATting where a single host may
use multiple source IP addresses.

Nowadays, IP IDs are not generated via a global
counter (except for FreeBSD and NetBSD), and TCP
timestamps are usually generated per TCP connec-
tion (except for macOS), thus these techniques are
no longer in eﬀect. Conceptually, it is still possible to
mount host alias detection and de-NATting attacks
using the more sophisticated global states described
in the previous sub-sections, but here too, the se-
vere limitations described above for these techniques
apply. A host alias resolution technique based on
packet delay sequences is described in [47], however
this technique aims at router IP aliasing, which does
not address the question of whether two IP addresses
are served from a single host or from two distinct
hosts on the same network.

6

Table 3: Exﬁltration from Networks

Target
Network

Typical
Throughput

Air-Gapped

8b/h-4Kb/s

Isolated

1b/h-10Kb/h

Regular
(Firewalled)

100Kb/s and
above

Typical
Requirement
Proximity
(0.4m-30m)
IP spooﬁng
(in some cases)

Examples

[24], [25]

This paper, [37]

None

[36], [12], [51], [28]

2.5 Container Co-residency Detection
and Cross Container Information
Leakage

A container co-residency detection technique is de-
scribed in [45], but this attack is local, i.e. the at-
tacker’s container must co-reside with the target con-
tainer. Our attack can remotely detect that two con-
tainers reside on the same host.

Cross-container leaks are reviewed in [21], but the
attacks described there cannot be remotely mounted,
whereas our attack is remote, and does not require
the attacker to control a co-resident container.

2.6 Other Side Channels and Exﬁltra-

tion Techniques

Our exﬁltration attacks are focused on isolated net-
works.
Isolated networks are less secure than air-
gapped (or nearly air-gapped) networks, but are more
secure than ordinary networks. As can be expected,
exﬁltration techniques that work on less secure net-
works generally tend to have better throughput, but
cannot be applied to more secure networks. Specif-
ically, techniques that apply to less secure networks
typically cannot be applied to isolated networks, and
therefore cannot be compared, throughput-wise, to
our techniques, that do work against isolated net-
works. Likewise, our exﬁltration techniques do not
work against air-gapped networks, or nearly air-
gapped networks (networks behind a network pump).
Exﬁltration from air-gapped networks requires
close proximity (0.4m-30m) [23], which is a serious
limitation. The throughput varies drastically among

the techniques, from 8b/h to 4Kb/s [25]. A typ-
ical example is [24] which describes an acoustical
covert channel based on hard drive noise, yielding
3b/s throughput.

Our work is a rare example of exﬁltration from an
isolated network (without the proximity constraint).
Another example is [37], which is eﬀective against
Linux TCP services only, with 2b/h-8b/h through-
put.

Finally there are examples of exﬁltration tech-
niques that do not apply to isolated networks. For
example, [36] uses a web counter as a covert channel,
but this requires the DMZ target host to have (1) a
shared web application between the internal and the
external networks; and (2) to have a web counter in
that application. [12] uses public cloud service as a
covert channel, and [51] uses multiple public services
as a covert channel. All these covert channels are
very unlikely to apply for isolated networks as their
prerequisites are obviously inconsistent with network
isolation. In 2004, [28] demonstrated a covert chan-
nel via DNS queries (“DNS tunneling”). A through-
put analysis can be found in [1]. Though it focuses
on the downlink, it can be inferred that the uplink
throughput is in the hundreds of Kb/s, many or-
ders of magnitude better than our techniques. How-
ever, since DNS tunneling is well-known and well-
understood for almost two decades, it is very unlikely
to ﬁnd isolated networks with unrestricted access to
an Internet-connected DNS resolver.

Table 3 compares exﬁltration techniques for the

three network types.

3 Current Protocol Header
Field Generation Algorithms

3.1 Linux IPv4 ID for Connection-

Less Transport Protocols

Starting with kernel v3.16, the Linux IPv4 ID gen-
eration algorithm for connection-less transport pro-
tocol packets (e.g. UDP, ICMP) uses an array β of
2048 counters, and a corresponding array τ of their
last access times. Algorithm 1 describes how an IPv4
ID is generated. Note that the time is measured in

7

“jiﬃes” (a clock whose frequency is set at kernel com-
pile time: f =250Hz by default, f =1000Hz for some
MIPS platforms), h is a hash function, proto is the
IANA protocol number (1 for ICMP and 17 for UDP)
and net key adds a container-dependent quantity, if
applicable. Also deﬁne random(∅) = 0.

Algorithm 1 Linux IPv4 ID Generation for
Connection-less Transport Protocols
1: procedure Generate-IPID
2:

h(IP DST , IP SRC, proto, net key)

←

i
mod 2048

3:
4:
5:
6:

hop ← 1 + random({0, . . . , tnow − τ [i] − 1})
β[i] ← (β[i] + hop) mod 216
τ [i] ← tnow
return β[i]

dows handles the potentially almost inﬁnite growth
of PathSet. Obviously PathSet cannot be allowed to
grow indeﬁnitely, so PathSet objects must occasion-
ally be purged.
Indeed, Windows removes objects
from the PathSet in batches, which we term purge
sequences. Generally speaking, a purge sequence can
be triggered either by PathSet’s size exceeding some
(pretty high) thresholds, or by a PathSet growth of
5,000 or more new Path objects in 0.5 second (“ﬂood
detection”). In both cases, a purge sequence is ini-
tiated, which goes over all the Path objects in the
PathSet at a rate of 2000/sec and removes “stale”
Path objects – objects that were last accessed over
60 seconds2 ago.

3.3 macOS

Server

(Connection-
Less Transport Protocols) and
OpenBSD IPv4 ID

3.2 Windows Server IPv4 ID

Note: since Windows is closed-source, extracting via
reverse engineering, and documenting the Windows
Server IPv4 ID generation logic is part of our contri-
bution.

As of version 1903, Windows Server generates the
IPv4 ID of outbound IPv4 packets as follows. Win-
dows implements the IPv4 ID as a counter per each
(IPSRC , IP DST ) tuple that corresponds to outbound
traﬃc, where IP SRC is an address on the local ma-
chine, and IP DST is a peer address. Such tuple-
speciﬁc data is kept in an object called Path. The set
of Path objects is maintained in a hash table called
PathSet. Windows keeps a PathSet per compart-
ment, i.e. one IPv4 PathSet instance per container.
A new Path object is created upon the ﬁrst attempt
to send a packet from IP SRC to IP DST , where there
is no existing Path object with these indices. When
a new Path object is created, the IPv4 ID ﬁeld is
initialized with random data. Then, for each packet
sent from IP SRC to IP DST , the IPv4 ID in the cor-
responding Path object is incremented and used as
ID. Na¨ıvely speaking, this setup provides no leak-
age, since each tuple runs its own independent IPv4
ID counter. However, an important aspect of the
PathSet life-cycle was left out so far – how Win-

Both macOS (for connection-less transport protocols
only – e.g. UDP and ICMPv4) and OpenBSD im-
plement their IPv4 ID generation along the concept
of keeping a list of the M recently used IPv4 ID val-
ues, picking a random ID value out of the remaining
65536−M values, and updating the list of used values
accordingly (popping the oldest value and pushing
the freshly generated value). For macOS, M = 4096,
and for OpenBSD, M = 32768. Thus, it is guaran-
teed that the IPv4 ID value is unique in intervals of
length M, at the cost of reducing the entropy from
16 bits to log2(65536 − M) bits.

Note: the IPv4 ID in macOS is generated at the
macOS kernel – XNU. Therefore, the attack tech-
niques we describe are actually inherent to XNU.
However, macOS Server is the only widely-used
server operating system based on the XNU kernel,
therefore we name macOS as the attack target, rather
than XNU.

3.4 NetBSD TCP ISN

A TCP Initial Sequence Number (ISN) is generated
by each TCP connection party at the beginning of

210

seconds

in Windows

10,

determined

by

TcpipIsServerSKU.

8

the connection, as a 32-bit random starting point for
the sequence numbers it generates for the connection.
A TCP client generates and sends ISN with the TCP
SYN packet, and a TCP server generates and sends
ISN with the TCP SYN+ACK packet.

NetBSD generates the most signiﬁcant 8 bits of the
ISN as a sum of a 2Hz timer and a TCP connection
counter, modulo 256.

4 Attacks

4.1 Threat Model

All our attacks are built around the same concept.
In our attacks, there is a sender, a receiver and a
target host (or hosts), identiﬁed by one or more end-
point designations, where an endpoint is deﬁned as
a combination of IP address, protocol – TCP, UDP
or ICMP, and port (for TCP and UDP only). The
attacker controls the sender and the receiver entities,
but has no control whatsoever over the target host(s).
Therefore, one of the main concerns of this research
is to determine what attacks can be mounted in var-
ious implementations (operating systems) and roles
of the target host. Thus, when we refer to an attack
against an operating system, it is a shorthand to an
attack against a target host running that operating
system.

In one use case, the target host is a ﬁrewall pre-
venting the sender and receiver from communicating
directly.
In other use cases, the target host is ﬁre-
walled. The receiver and sender cooperate to fulﬁll
their task, and are furthermore synchronized to a sub-
second accuracy.

We use a covert channel through the target host
wherein its global state can be read and altered by
sending and receiving packets, as described below. In
Section 5 we will see that such a covert channel exists
for many target host operating systems, though the
covert channel details diﬀer between the operating
systems.

The sender entity signals a single bit by sending
packets to one of the target host’s designated end-
points. In most of our attacks, the sender can be an
non-privileged process at the system it runs on, send-

ing conventional packets. In fact, for web protocols,
such traﬃc can be emitted by an HTML page ren-
dered by a browser. However, in the Windows and
Linux attacks, the sender must be able to spoof the
source IP address of its packets, thus the sender must
run as a privileged process on its machine.

The receiver entity reads this bit by sending pack-
ets to one of the target host’s designated endpoints
(not necessarily the one used by the sender), receiving
packets from the target and analyzing them. The re-
ceiver entity typically needs access to the raw packets
at the IP level, and as such may need to run as a priv-
ileged process on its system. This is a reasonable as-
sumption since the receiver is an attacker-controlled
machine on the Internet.

In general, the attack proceeds by having the re-
ceiver send and receive some packets, thus recording
the global state of the target host. Then the sender
either sends packets to the target host (thereby
changing its global state) to signal the bit “1”, or
does nothing (thereby retaining the global state in
the target host) to signal the bit “0”. Finally, the
receiver reads the global state again, and determines
whether it changed or not, thereby reading “1” or “0”
respectively.

Naturally, there are timing constraints involved.
For example, the receiver must conclude its ﬁrst
global state extraction before the sender is allowed
to send its packets, and the sender must conclude
its global state modiﬁcation (if it takes place) before
the receiver is allowed to send packets for its sec-
ond global state extraction. Additional timing con-
straints are required for Windows covert channels.

Our attacks work best against network-wise idle (or
almost idle) target hosts. Organic traﬃc may inter-
fere with our techniques, although a minimal amount
of traﬃc can be easily mitigated by adding some mar-
gins to the threshold parameters. For example, our
Linux technique (Section 5.1) expects an increase of
no more than ∆t · f in some counter when the ma-
chine is idle. When some traﬃc happens to use that
counter, it is incremented further, say by up to n
In such case, we choose
packets per ∆t time slice.
M > n + ∆t · f (instead of M > ∆t · f ). A mild
amount of traﬃc can be mitigated by introducing re-
dundancy (e.g. majority over three same-bit trans-

9

(a)

(b)

(c)

(d)

Figure 1: Network Diagram for (a) Firewall Piercing Exﬁltration; (b) Exﬁltration (via DMZ); (c)
Exﬁltration between Co-Resident Containers; (d) Host Alias Detection and de-NATting

missions) and/or error correction codes (e.g. Reed-
Solomon [42]).

4.2 Source Address Spooﬁng and

Sender Privileges

We demonstrate our UDP attacks using the
Speciﬁcally, the sender sends
HTTP/3 protocol.
QUIC Initial packets [27] to the target host, and the
receiver sends Initial packets and receives QUIC re-
sponse packets. We demonstrate our TCP attacks
In both
using the HTTP/1.1 and SSH protocols.
cases, the attack uses open UDP/TCP port on the
target device. In our ICMP attacks, we use the stan-
dard, built-in ICMP Echo Request-Reply mechanism,
which is commonly open3 to the Internet.
In Ap-
pendix A we report that 89% of the widely-used In-
ternet hosts/ﬁrewalls surveyed responded to ICMP
Echo requests.

In the ﬁrewall bypassing scenarios, we focused on
data exﬁltration attacks, but in general, the opposite
direction – sending data into an internal network – is
also possible. This can facilitate e.g. a Command &
Control channel for the malware. We demonstrated
this direction in one test (LF-1).

3We do not consider opening ICMP to the Internet a secu-
rity vulnerability. The security issue is with the implementa-
tion of the underlying IP layer.

For the Linux and Windows attacks, the sender needs
to be able to spoof the source IP address of its pack-
ets. This requires the sender to have root privileges
on a machine which is on an internal network. With
root privileges, spooﬁng is typically trivial, using e.g.
raw sockets or libpcap. The ﬁrewall’s SAV protec-
tion still allows a device on the internal network (the
sender) to send packets with a source address from
the same (internal) network to the ﬁrewall or to the
DMZ. This suﬃces for our ﬁrewall subversion and
exﬁltration attacks. For the host alias resolution at-
tacks where the sender is on the Internet, SAV em-
ployed by ISPs may prevent address spooﬁng. Ac-
cording to [35, Fig. 4], 11.9%-30.5% of the ASes do
not employ such ﬁltering on their customers (out-
bound ﬁltering), hence can be used by the attacker to
send spoofed packets from. Naturally, the attacker
is free to choose such a network, thus having enough
non-ﬁltering networks guarantees that the attacker
can mount the attack. We conclude therefore that
packet spooﬁng over the Internet is feasible, hence
the Linux and Windows host alias resolution attacks
over the Internet are practical.

10

Firewall + NATInternetReceiverSenderInternal NetworkFirewall + NATInternal NetworkDMZInternetTarget HostSenderReceiverFirewall + NATInternal NetworkInternetSenderReceiver3rdpartyContainerIsolatedContainerHostFirewall / NATInternetSender+ReceiverTarget Host #1Target Host #2?=4.3 Firewall Piercing Exﬁltration

This use case places minimal requirements on the net-
work topology. The attacker’s goal is to exﬁltrate in-
formation from a compromised machine (the sender)
in a well guarded enterprise network. It is assumed
that the sender cannot send packets to the Internet.
Fig. 1a illustrates the network topology (each net-
work has its own background color, blue arrows rep-
resent direct communication, bold black lines deﬁne
network boundaries enforced by the ﬁrewall).

The attacker uses an ICMP-based covert channel
to exﬁltrate one bit at a time from the sender to the
receiver. The only requirement is that the ﬁrewall
responds to ICMP Echo requests both from the In-
ternet and from the internal network.

4.4 Firewall Subversion and Exﬁltra-

tion (via DMZ)

In this use case, the attacker’s goal is to exﬁltrate in-
formation from a compromised machine (the sender)
in a well guarded enterprise network. It is assumed
that the sender cannot send packets to the Internet
directly. Fig. 1b illustrates the network topology.
The sender can send and receive packets to/from a
server host in a DMZ segment of the enterprise net-
work (the target host). This server serves both in-
ternal clients such as the sender, and external Inter-
net clients such as the receiver. The target host is
protected by a stateful ﬁrewall both from the inter-
nal network and from the Internet. The ﬁrewall also
enforces SAV between the three networks (internal
network, DMZ and Internet).

The attack uses the covert channel to exﬁltrate
one bit from the compromised machine (the sender)
through the target host (the DMZ server) to the at-
tacker machine on the Internet (the receiver).

4.5 Exﬁtration via Co-Resident Con-

tainers

A special case of the exﬁltration technique described
in Section 4.4 is exﬁltration between containers.
Fig. 1c illustrates this attack scenario. In this case,
there are two co-resident containers on the same host

(kernel), which are supposedly completely isolated.
The “isolated container” resides in a completely iso-
lated local network, shown as the green network in
Fig. 1c. The other container, depicted as “3rd party
container” can belong to any entity, and is only re-
quired to run an Internet-facing service in the pro-
tocol designated for exﬁltration. None of these con-
tainers is assumed to be controlled by the attacker.

A malicious sender that resides on the local net-
work can exﬁltrate data to an Internet receiver using
the same technique described in Section 4.4, assum-
ing the global state is shared between the containers.
In a variation of this use case (not depicted in
Fig. 1c), the sender may be malware running on the
isolated container, without root privileges. Such a
sender can use 127.x.y.z as local address destinations,
instead of spooﬁng packet source addresses.

4.6 Host Alias Resolution, De-
Co-Residency
and

NATting
Detection

In this use case, the attacker’s goal is to determine
whether two endpoints reside on the same host (even
across containers, if possible) or not. The attacker is
an Internet machine, and the endpoints are located
behind a stateful ﬁrewall. The attacker runs both
the sender logic and the receiver logic, thus there is
no importance in distinguishing between the receiver
and the sender, and we will use the term “attacker”
for both. The attack applies the receiver logic to one
endpoint, and the sender logic, speciﬁcally writing
the bit “1”, to the other endpoint. If both endpoints
reside on the same host, the receiver will read the
bit “1”, but if the two endpoints reside on diﬀerent
hosts, then writing to one host does not aﬀect the
other host, and the receiver will read the bit “0”.
This use case is illustrated in Fig. 1d. If the speciﬁc
covert channel works across containers, then so will
this attack.

Since the attack implementations for host alias res-
olution and de-NATting are identical, we will hence-
forth use the term “host alias resolution” to denote
both, and we will note whether the attack also applies
to container co-residency detection, per case.

11

5

Leakage

Information
Covert Channels:
States in Protocol Fields

and
Global

We now show the existence of information leakage in
the ICMP/IPv4 and UDP/IPv4 implementations of
some popular server operating systems, and in the
TCP implementation of NetBSD. The information
leakage enables the receiver – a client of the server –
to obtain information on the state of the server. We
then show how to exploit this weakness to construct
a covert channel, in which a sender client, typically
running on a diﬀerent machine than the receiver, sig-
nals a bit by forcing the server state to meet a certain
condition or fail to meet the said condition. Thus, the
receiver and sender engage in a covert channel proto-
col in which the sender sends an arbitrary bit to the
receiver. Our attacks share some common principles,
but diﬀer in their technical details between operating
systems. In some cases, our techniques can also be
applied to TCP/IPv4.

5.1 Linux Connection-Less IPv4 ID

The global state that enables a covert channel is the
IP ID counter used by the target host to send pack-
ets to the receiver, i.e. β[R] (deﬁned in Section 3.1)
where

R =

h(IP RCVR, IP TARGET , proto, net key) mod 2048

The sender needs to send packets to the target
rapidly. When the sender can force the target to send
more than f packets per second from β[R], the re-
ceiver will be able to detect this by sampling packets
generated by the target host using the β[R] counter,
and observe that β[R] incremented at a rate > f .
Whereas when the target host does not receive sender
packets, β[R] will increment at a rate ≤ f .

There is a problem with the above approach,
though. The probability of the sender’s IP address
1
hash to collide with R is
2048 . The solution is sim-
ple: note that the sender needs only to force the tar-
get host to send packets whose IP ID is generated
using β[R]. The sender does not need to actually

receive and read those packets. And so, the sender
can simply craft packets that elicit the target host’s
response, spoof the source address of these packets
(to an unused internal network IP address), go over
enough source addresses to practically guarantee that
one of the responses uses β[R] (as explained below),
and thereby fulﬁll the condition for the attack.

We now expand the above technique into a covert
channel. For simplicity, we assume that the receiver
owns a single Internet IP address, however practi-
cally, we expect the attack to be mounted with a re-
ceiver that owns multiple IP addresses. Assume the
receiver can sample the target host at ∆t intervals,
1
∆t . Denote by M an attack
i.e. at a frequency of
parameter (threshold) ∆t · f ≤ M (cid:28) 216. Ideally, M
should be minimal to reduce the required bandwidth
of both parties (and also to avoid wrapping around),
yet should take into consideration possible noise and
jitter, i.e. M should be slightly higher than ∆t · f .
The sender chooses a list of IP addresses that will
be used for spooﬁng. The list length L is a function
of the acceptable probability p of bit read error (for
bit “1”), which happens when all L addresses do not
elicit an answer that uses β[R]. We choose a parame-
ter Λ, such that p = (1− 1
2048 < 0.001, i.e.
Λ ≥ 14148. For a receiver with a single IP address,
we set L = Λ (in our experiments, we rounded this
down to L = 14000). Assume the sender can send B
packets per second. Then transmitting one bit takes
(2M −1)·L
B

seconds. The attack works as follows:

2048 )Λ ≈ e− Λ

B

i.e.

• Receiver: During the transmission time of a
for (2M −1)·L
single bit,
seconds, the re-
ceiver samples the target host at intervals ∆t
and records the IPv4 ID ﬁeld of the server pack-
ets – ID i.
It then checks, for each i > 0, if
(ID i − ID i−1) mod 216 ≥ M + 1. If this is met
for any i > 0, then the bit transmitted is deter-
mined to be “1”. Otherwise the bit is determined
to be “0”. We show below that it is guaranteed
that the sender increments the IP ID counter by
at least M for one interval, and the receiver’s
ﬁrst sample increments it at least by 1, hence a
signalled interval should have an increment of at
least M + 1.

12

• Sender: To send a bit “1”, the sender goes
through the L addresses, and for each, spoofs
2M − 1 packets originating from the address and
whose destination is the target host, during a ∆t
time interval, over ICMP or the UDP protocol
of choice. To send a bit “0”, the sender does
nothing.

∆t

The sender needs to send 2M −1
packets per second
from each spoofed address, since there is no expec-
tation to synchronize the time the sender’s packets
arrive at the target host, with the time the receiver’s
packets arrive at the host. All 2M − 1 packets from
the same spoofed address should be sent in rapid suc-
cession. By sending 2M − 1 packets at an arbitrary
∆t interval, the sender ensures that at least one ∆t
interval sampled by the receiver will have at least M
sender packets in it. In other words, the sender can
send a burst of 2M − 1 packets from one spoofed ad-
dress (assuming this takes less than ∆t) and move on
immediately to the next spoofed address.

Note that for this technique to yield correct re-
sults, no other network traﬃc emitted by the target
host, other than to the sender and to the receiver,
must be using the β[R] counter. This is a reason-
able assumption, since the probability of the host’s
outbound traﬃc to a random address to use β[R] is
1
2048 .

This covert channel works across containers. Even
though the net key introduces dependency in the
container for which the hash is calculated, the β table
itself is shared among all containers. Since the attack
does not rely on having the same hash function for
the receiver and the sender, it follows that the at-
tack covers the case wherein the receiver is served by
one container, and the sender is served by another
container.

The covert channel also works across protocols
(protocol=1 for ICMP, 17 for UDP), by the above
argument.

Ideally, the attack is carried out with a receiver
that owns n (cid:29) 1 IPv4 addresses. In such a case the
sender needs to spoof only L = Λ
n IPv4 addresses
(similar to the birthday paradox), and thus the at-
tack speeds up by a factor of n. This requires the re-
ceiver to send an aggregate of n
∆t packets per second

to the host. The receiver needs to ﬁrst ensure that
each IP address it owns uses an exclusive counter.
For this, the receiver can employ the techniques de-
scribed in [31, Section 6] to detect collisions in pairs of
IP addresses, and remove one address from each such
pair, which results in a collision-free list. Also, once
the receiver knows which IP addresses have counters
that collide with those of the sender’s addresses, the
receiver can send packets only to these IP addresses,
which saves bandwidth. Moreover, for the ﬁrewall
piercing attack, the sender (assuming it is on the in-
ternal network) cannot spoof too many IP addresses,
since the addresses it spoofs are on the ﬁrewall’s local
network4, and thus the ﬁrewall has to have them in
its ARP cache, which is limited in size. As long as
there are less than gc thrash1 (defaults to 128) ARP
entries, garbage collection will not run [33], there-
fore the sender must keep the number of spoofed ad-
dresses below 128 (e.g. L = 127). This is feasible
as explained above when the receiver can listen on
n ≥ (cid:100) Λ

127 (cid:101) IP addresses.

The limiting factors in this attack are the sender’s
bandwidth (vs. M ·L), and the network jitter between
the receiver and the host (vs. ∆t) as a jitter value
close to ∆t may cause the receiver’s probe packets to
arrive at the host out of order.

See Appendix A.1.1 for an improved attack variant
wherein feedback from an opposite direction channel
is used to signiﬁcantly reduce the traﬃc, bandwidth,
and number of addresses required for the channel.

Linux generates the IPv6 Identiﬁcation header ex-
tension ﬁeld in a very similar manner, and using the
same table.
IPv6 fragmentation attacks are out of
scope for this research.

5.2 Windows Server IPv4 ID

5.2.1 Information Leakage

Suppose at time t, a receiver at IPv4 address IP 1
received a packet from a Windows Server target host
at IP 2, with IPv4 identiﬁer ID, and at time t(cid:48)(cid:48) > t,
the receiver received a second packet from the target

4This restriction does not apply to other attack scenarios,
since there, the sender and the target host reside on diﬀerent
networks.

13

host, with IPv4 identiﬁer ID (cid:48)(cid:48). ID originated from
a Path object indexed by (IP 1,IP 2), at time t. ID (cid:48)(cid:48)
originated from a Path object indexed by (IP 1,IP 2),
at time t(cid:48)(cid:48). If the Path object indexed by (IP 1,IP 2)
remained intact in the time window [t, t(cid:48)(cid:48)] then ID (cid:48)(cid:48) =
ID + 1 mod 216. However, if, at some time t(cid:48), t <
t(cid:48) < t(cid:48)(cid:48), this Path object was purged, then the second
packet originated from a freshly created Path object,
whose IPv4 ID is initialized with a random value, i.e.
ID (cid:48)(cid:48) = ID + 1 mod 216 with probability 2−16. The
leakage then is whether a purge occurred at time t(cid:48)
or not.

The purge timing is essential for the leakage to oc-
cur. One restriction is t(cid:48) − t ≥ 60s, as only Path
objects whose last access time is over 60 seconds ago
are purged. Another restriction relates to the ex-
act purge timing of the Path object. As we will see
below, there may be up to 20000 Path objects in the
PathSet (or even a bit higher, if the target host is not
completely idle). Since the purge rate is 2000/sec, it
may take up to 10 seconds for the speciﬁc Path object
to get purged. Therefore, the additional condition is
t(cid:48)(cid:48) − t(cid:48) ≥ 10s.

From the above t(cid:48)(cid:48) − t ≥ 70s, i.e. the minimal time
between receiver samplings is 70 seconds. We also
need take into account the fact that the ﬂood de-
tection triggering consumes another second, i.e. the
probes have to be 71s apart. Practically, we need
to pad this a bit to accommodate for Path objects
that organically get inserted into PathSet during the
normal system run. An additional 1s accommodates
2000 such objects.

Interestingly, due to a bug in Windows, oftentimes
there is an additional purge sequence right after the
ﬁrst purge sequence, taking additional 5 seconds in
our use case. This additional purge sequence does
not interfere with our covert channel, because if it
extends a few seconds beyond the next probe, that
probe will not be aﬀected, as it is not stale.

It should be noted that a leakage does not occur
across containers (compartments), since each com-
partment maintains its own IPv4 PathSet.

5.2.2 Covert Channel

The receiver and the sender have synchronized trans-
mission cycles. The receiver samples the IPv4 ID of
the host at the beginning and at the end of every
transmission cycle, by sending K UDP requests that
elicit UDP answers from the host, and observing the
IPv4 ID of the host packets. Multiple requests are
needed to cater for packet loss. The receiver deter-
mines that the transmitted bit is “0” if the diﬀer-
ence (modulo 65536) between the IDs is less than the
number of packets sent to the host during the cycle –
2K. Otherwise, the bit is determined to be “1”. The
choice of K can be arbitrary, as long as the value is
very small, with very little impact on the channel’s
performance.

The sender signals a bit “0” by not doing anything
during the transmission cycle. This guarantees that
the Path object in the host, that belongs to the re-
ceiver, is not purged, and therefore the IPv4 IDs will
remain sequential for the end-of-cycle probe. On the
other hand, for the bit “1”, the sender needs to force
that Path object to get purged. In the end-of-cycle
probe, the receiver will be assigned a new Path ob-
ject, with a random IPv4 ID base, which is very likely
to fall outside the range for bit “0”.

Thus, to transmit the bit “1”, the sender needs
to inﬂict a purge cycle on the target host. For this,
the sender can trigger the PathSet ﬂood detection,
by forcing the target host to send packets to 10000
diﬀerent IP addresses in a single second. Since the
ﬂood detection is measured in intervals of 0.5 sec-
onds (5000 new Path objects per 0.5 second), this
ensures that ﬂood detection will be triggered. In the
QUIC use case, the sender can achieve this by sending
QUIC Initial packets (1228 bytes at the IP layer) from
spoofed IP addresses to a UDP port on the target
host listening to a protocol that is on top of QUIC,
e.g. HTTP/3. The target host is then obliged to send
a QUIC response to the IP address from which the
packet allegedly originated. The required bandwidth
is therefore 98.24Mb/sec, well below the limit of mod-
ern WiFi and Ethernet networks, and an achievable
upload speed by ﬁber Internet connections.

This attack’s performance is conditional upon the
sender having bandwidth of at least 10000 packets/s

14

in the chosen protocol, and takes at least 71s per bit.
A “1” bit can be interpreted as a “0” when the new
Path object contains an IP ID that accidentally falls
into the range allowed for bit “0”. This happens with
probability 2K/65536, and only for “1” bits. Therefore,
the bit error rate is K/65536.

Note that this attack is not disruptive. Organic
Path objects are indeed removed from the PathSet,
but only if their last access time was over 60 seconds
ago. This means that two IPv4 packets/fragments
generated over 60 seconds apart may have the same
IPv4 ID, with probability 1/65536. This is not an issue
since it is highly unlikely that the ﬁrst fragment will
not be reassembled at the destination for this long.

An Internet attack cannot be mounted over ICMP,
because Windows only responds to ICMP Echo re-
quests from the local network.

collisions is:

Pr{C = 0} =

(cid:89)

0≤i,j<K

(1 − Pr{IDj+M+K = IDi})

≤

(cid:89)

(1 − 1/65536) ≈ e− K2

65536

0≤i,j<K

Since K2

65536 (cid:29) 1 this probability is negligible.

To summarize, we described a covert channel, in
which the receiver forces the target host to send back
K packets, then the sender forces the target host to
send back M packets (or none at all), and ﬁnally the
receiver forces the target host to send back additional
K packets. The receiver looks for collisions in the
IPv4 IDs of the two K packet sets. If collisions are
found, the receiver infers that the sender interacted
with the target host (bit “1”).
If no collisions are
found, the receiver infers the sender did not interact
with the target host (bit “0”).

5.3 macOS

Server

(Connection-
Less Transport Protocols) and
OpenBSD IPv4 ID

For two IPv4 ID values ID 0, ID m sampled m > 0
packets apart, we have (recall that M is the unique-
ness interval):

Pr{ID m = ID 0} =

(cid:40) 0

m ≤ M

1/(65536+m−2M−1) M < m ≤ 2M
≈ 1/65536

2M < m

Thus when we sample two IPv4 ID values, we can
statistically distinguish between a case where m(cid:48) ≥
M packets were generated in between (in such case,
Pr{ID m(cid:48)+1 = ID 0} ≥ 1/65536) and a case where m(cid:48) <
M packets were generated (Pr{ID m(cid:48)+1 = ID 0} = 0).
Practically, the receiver ﬁrst gets K packets from the
target host, as rapidly as possible. Then the sender
forces the target host to send M packets to signal the
bit 1, and no packets to signal the bit 0, and ﬁnally
the receiver gets additional K packets. K should be
picked such that K 2 (cid:29) 65536 and 2K < M (ideally
K (cid:28) M). The receiver now checks whether there
are any collisions between the two sets. When a bit
“0” is transmitted, we clearly have Pr{C = 0} = 1.
When a bit “1” is transmitted, the probability of no

The limiting factors for this attack is the receiver’s
bandwidth (vs. K) and the sender’s bandwidth (vs.
M). The jitter (assuming low values) has almost
no signiﬁcance here, as the order of packet arrival
is unimportant neither for the sender, nor for the re-
ceiver. And since both the sender and the receiver are
required to send thousands of packets, which takes a
lot more time than the typical jitter, the bandwidth
overshadows the jitter as a dominant factor.

See Appendix A.1.2 for a stealthier variant of this

attack.

In macOS 11.3 and above, an ICMP Echo rate limit
is imposed, with a threshold value in the range 251-
500 chosen at random once per boot, and applied to
1-2 second intervals. When the rate limit is exceeded
in an interval, the ICMP Echo response is generated
with probability inversely proportional to the excess
ICMP Echo request packets. That is, if the random
rate limit is R and N > R ICMP Echo requests were
already received in the interval then the next ICMP
1
N −R .
Echo request will be answered with probability
The above attack can be mounted almost as-is by
throttling it to under 125 packets/s. But a more ef-
ﬁcient attack can simply take advantage of the rate
limit to signal bits. To signal “1”, the sender sends a
burst of e.g. 600 ICMP Echo requests (which guaran-
tees an excess of at least 100 requests, thus ensuring

15

that subsequent ICMP Echo requests in that time
period has a probability ≤ 1
100 to be answered by
macOS). The sender does nothing for “0”. The re-
ceiver then sends an ICMP Echo request to the host,
which is always answered if the sender sent nothing
(“0”), but is not answered (with probability > 0.99)
if the sender sent 600 requests. This procedure needs
to be fortiﬁed with some error correction logic (to
take care of the occasional response from the server
even in the case the rate limit was exceeded). Thus
a single bit can theoretically be signalled in two sec-
onds. Due to logistic reasons, we could not test this
attack.

5.4 NetBSD TCP ISN

The TCP ISN -based global state is the number
of TCP connections established since boot (modulo
256).

The covert channel works as follows: the receiver
sends a TCP SYN packet to the NetBSD target host,
and records the most signiﬁcant 8 bits of the ISN
in the target host’s SYN+ACK response – m. The
sender then sends two or more TCP SYN packets
to the host, for bit “1”, or no packets for bit “0”.
Finally, after ∆t time, the receiver sends a TCP SYN
packet to the host, and records m(cid:48) from the host’s
SYN+ACK response. Then if (m(cid:48) − m) mod 256 >
1 + (cid:100)2∆t(cid:101), there was another connection served by
the target host, i.e. the sender signalled the bit “1”,
otherwise the sender signalled “0”.

The attack requires that the jitter be much smaller

than ∆t.

Note that unlike the well known sequential IPv4
ID attack for NetBSD, our attack also works
with TCP/IPv6, and can combine TCP/IPv6 and
TCP/IPv4 senders and receivers.

5.5 Additional Attacks

We also found additional new attacks against some
of the above operating systems, that are disruptive
and/or inferior in performance (packets required) to
the attacks described above. For sake of complete-
ness, we describe these attacks in Appendix A.2.

Note that if/when the attacks described above are ad-
dressed by the respective operating system vendors,
the attacks in Appendix A.2 may take their place as
the most eﬀective attacks (unless they are ﬁxed as
well).

5.6 Practical Considerations

5.6.1 RTT

Our attacks require some synchronization between
the time of arrival of the sender packets and the
receiver packets, at the target host.
Interestingly,
such synchronization is not aﬀected by the RTT it-
self, assuming each party knows its RTT to the tar-
get host beforehand. For simplicity, let us assume a
ﬁxed, symmetric RTT. In order for a packet to ar-
rive at time t to the target host, the sending party
needs to send it at time t− RT T
, assuming the party’s
machine time itself is synchronized. In reality, RTT
is not ﬁxed, and the RTT variance, or jitter, deter-
mines the synchronization granularity. Likewise, in
reality, RT T
is only an approximation to the end-to-
end time between two parties – the actual value may
diﬀer somewhat due to asymmetry in routing paths.
This unknown quantity can also be accumulated into
the synchronization granularity.

2

2

Moreover, in our attacks, each packet sent by the
sender and by the receiver is independent of the
previous packets, i.e.
the attacks are entirely non-
adaptive. This means that neither party needs to
wait for any response (to a previous packet) to arrive
from the target host, before sending the next packet.
Therefore, there is no signiﬁcance to the RTT in tim-
ing the attacks. The only exception is some TCP/IP
attack scenarios wherein one or two parties send an
RST in response to the host’s SYN+ACK answer.
The RST packet contains the host-generated TCP
sequence number from the host’s SYN+ACK, and
thus it relies on a previous packet from the host, i.e.
subject to RTT. However, sending the RST packets
can be done in parallel with the attack’s main packet
stream, and thus the RTT does not aﬀect the overall
attack time in this case as well.

16

5.6.2 Jitter and Bandwidth

The limiting factor for the attack speed is the sender’s
bandwidth (which we throttle for some attacks) and
the jitter, which is typically at milliseconds granu-
larity. In fact, due to its typically low value, jitter
is a limiting factor only in Linux and NetBSD, and
the sender bandwidth is a limiting factor in Linux,
OpenBSD and macOS. In Windows, the attack time
is dominated by the 60s time-to-live limit imposed
on stale Path objects, and is thus unaﬀected by jitter
and bandwidth (except that it requires the sender to
be able to send 10000 packets/s bursts).

traﬃc bandwidth (in terms of packets/s) be lower
than the bandwidth generated by the sender (or more
precisely – lower that the threshold that the reader
interprets as a signalled bit “1”). Raising this thresh-
old can compensate for interference. The Windows
technique can easily compensate several thousands
IP tuples (our experiment setup actually already has
such compensation in place) by allowing a bit more
time for purging them (purging 2000 tuples takes 1s).
The Linux technique is aﬀected by interference only if
the speciﬁc bucket used for the communication hap-
pens to also serve organic traﬃc, which is very un-
likely (probability 1
2048 per destination IP address).

5.6.3 Synchronization between the Sender

and the Receiver

We assume that the sender and receiver machines are
synchronized at 0.1s resolution. This is a fair as-
sumption, given the accuracy of present day hardware
clocks, combined with NTP which keeps the clocks
from drifting [40]. Thus the sender and receiver can
decide on a UTC time (in seconds) when they begin
the exﬁltration session. Since the exﬁltration tech-
niques are based on the receiver polling the state be-
fore and after the sender, the receiver can poll 0.1s
before the bit transmission start time, and poll again
0.1s after the bit transmission end time (all times are
in the target’s time frame, i.e. both sender and re-
ceiver should compensate based on their respective
RTTs, by transmitting at their t − RT T
). This com-
pensates up to 0.1s synchronization oﬀset between
the sender and the receiver. A coarser-grained syn-
chronization (e.g. 0.2s) can be accommodated via
increasing the bit transmission time by 0.2s.

2

5.6.4

Interference (Organic Outbound Traf-
ﬁc from the Target Host)

In the ﬁrewall piercing scenario, using ICMP, the ﬁre-
wall can be considered idle in terms of network traﬃc,
since the vast majority of the traﬃc it handles is as a
router, where the ﬁrewall is not required to generate
e.g. IPv4 IDs.

In general, our techniques are not sensitive to a
mild level of interference. The macOS and OpenBSD
techniques only require that the organic outbound

5.6.5 Packet Loss

Our techniques are not sensitive to a mild level of
packet loss.
In general, the attacks need a certain
number of packets, or a certain rate of packets in
order to succeed. Packet loss can be compensated
by increasing the number/rate of packet sent accord-
ingly.

5.6.6 Stealth vs. Throughput

We throttle the sender’s bandwidth to 100Mb/s-
150Mb/s in order not to disrupt the normal network
usage on a 1Gb/s LAN. Note that in all cases (except
Windows) we could get an almost order of magnitude
improvement in the exﬁltration bit rate by consum-
ing almost all the 1Gb/s LAN bandwidth, though this
can disrupt the network functionality for other LAN
users and end up in exposing the channel. On the
other hand, we could throttle the sender and receiver
much further, reducing the throughput, but also
the probability to get ﬂagged by network IPS/IDS.
Speciﬁcally, the NetBSD TCP ISN technique only re-
quires a few TCP connections per second, and the
Linux technique’s sender bandwidth can be reduced
by a factor of n if the receiver controls n IP addresses.
Additionally, see Appendix A.1.2 for stealthier attack
variants against macOS and OpenBSD.

17

6 Experiments

6.1 A Setup for the Exﬁltration (via
DMZ) and Firewall Piercing Ex-
periments

The exﬁltration experiments have the target host and
the sender on 1Gb/s Ethernet network (the lab net-
work in Israel). This network is connected to
the Internet via a ﬁrewall+NAT device. Where
possible, we ran two tests per attack: one with the
receiver in a transcontinental location A (Azure Am-
sterdam data center), 3300Km from the target host,
and one with the receiver in a transatlantic location
B (Azure US east coast data center), 9600Km from
the target host. We also measured the RTT aver-
age and standard deviation (the latter is indicative
of the network jitter) between the two locations and
the lab network. The average RTT for A is 79.9ms,
with standard deviation 0.3ms, and the average RTT
for B is 146.9ms with standard deviation 1.4ms. This
is slightly better than the results reported in 2014 [43]
which is expected in light of the Internet technology
improvement over the last seven years.

A single exﬁltration test transmits 128 bits from
the sender on the internal network, to the receiver
on the Internet. This message size was chosen as a
benchmark since it demonstrates that AES-128 keys
can be exﬁltrated in a reasonable amount of time.

Where needed, we used libpcap to craft arbitrary
network packets, particularly for spooﬁng the source
IP address of packets, and for accurate timing of
packets and packet bursts.

For HTTP/3 server (over QUIC and UDP), we
used Caddy Server with the experimental http3
directive. For SSH server (over TCP), we used
OpenSSH, and for HTTP/1.1 server (over TCP) we
used Apache Web Server. We used Docker version
19.03.8 for the Linux containers.

services reside on the same host (kernel). To imple-
ment this, the attacker runs a sender logic for bit “1”
against one service, and a receiver logic against the
other service. If the receiver logic reads “1”, then the
two services run on the same host. If the receiver logic
reads “0”, then the services run on diﬀerent hosts.

To demonstrate that our results are not randomly
correct, we conducted a series of 10 bit “1” transfers,
for each of the following conﬁgurations:

• Target addresses on the same host

• (Where applicable) target addresses in diﬀerent

containers on the same host (kernel)

• Target addresses in diﬀerent hosts

The expected result for the ﬁrst two conﬁgura-
tions, where the addresses are served by the same
kernel, is an all-“1” readout. The last conﬁguration
is expected to result in an all-“0” readout, since the
sender changes the state of one kernel, but the re-
ceiver probes another kernel. In other words, assum-
ing correct results in the above tests, we are able
to tell apart a situation in which the two target ad-
dresses are served from the same host (kernel), and a
situation in which they are served from two diﬀerent
hosts. This demonstrates host alias resolution, in-
cluding across containers, as well as de-NATting and
container co-residency detection.

We could only test host alias resolution with Linux,
Windows and OpenBSD, because we only had one in-
stance of macOS and NetBSD in our lab. We tested
Linux and Windows with an attacker in the lab, be-
cause the test involves the attacker spooﬁng packet
source IP addresses, and we categorically do not run
such tests over the Internet. With OpenBSD, there
is no need to spoof packet source IP addresses, and
thus it was tested with an attacker in location A.

Other aspects or the experiment are identical to

the ones described in Section 6.1.

6.2 A Setup for the Host Alias Reso-

lution Experiments

Given two services (designated by IP address and
port), host alias resolution (and de-NATting) pro-
vides a single bit of information – whether the two

6.3 Description of the Hosts and the

Network

The target hosts used in the experiments are listed
in Table 4. All hosts are located in our lab network,

18

Table 4: Hosts

OS
Ubuntu 20.04 Linux
(Linux kernel 5.8.12)
Windows 20H2
build 9042.685
macOS Big Sur 11.1
(xnu-7195.60.75-1)

OpenBSD 6.8

NetBSD 9.1

Hardware
Dell E7450: Intel i7-5600U CPU,
16GB RAM, 1Gb/s Ethernet (USB)

Intel i7-3770 CPU, 16GB RAM, 1Gb/s Ethernet

MacBook Air Model A1466: Intel i5-5250U CPU,
8GB RAM, 1Gb/s Ethernet (Thunderbolt)
Dell E7450: Intel i7-5600U CPU,
16GB RAM, 1Gb/s Ethernet (USB)
Intel NUC7CJYH: Intel Celeron J4005 CPU,
8GB RAM, 1Gb/s Ethernet

Protocol

Service

Server SW

UDP/IPv4 HTTP/3

Caddy 2.2.0

UDP/IPv4 HTTP/3
TCP/IPv4 HTTP/1.x Apache 2.2.25

Caddy 2.2.0

UDP/IPv4 HTTP/3

Caddy 2.2.0

UDP/IPv4 HTTP/3
TCP/IPv4
TCP/IPv4
TCP/IPv6

SSH
SSH
SSH

Caddy 2.2.0
OpenSSH 8.4
OpenSSH 8.0
OpenSSH 8.0

which is a 1Gb/s Ethernet network connected to the
Internet over IPv4, through a ﬁrewall + NAT device.

6.4 Experiment Descriptions

Our results are summarized in Table 5. Only the
sender and receiver locations are listed – the target
host is always on the lab net (except for OF-1). Col-
umn “Section” refers to the below sections for further
information. An empty cell indicates the results are
self explanatory.

6.4.1 Linux Exﬁltration (via DMZ) over

UDP/IPv4

In tests LE-1 and LE-2 (locations A and B, resp.), the
target is an Intel x64 machine, therefore f =250Hz.
The covert channel was deﬁned with ∆t = 10ms
(considerably lower values are not usable due to the
jitter). Theoretically, we could have used M = 3 with
this ∆t, but we set M = 6 to eliminate the occasional
timing deviation in sampling caused by jitter. Due
to logistic and budgetary constraints, the receiver in
our experiments used only a single IP address.

During the preliminary tests, we noticed that the
target machine’s CPU was mildly loaded during the
transmissions of the bit “1”. This is not expected
to happen in a production system, where the server
hardware is typically much more powerful than our
Dell machine. However, given the Dell machine’s
CPU load, one could argue that the eﬀects we observe

have to do with CPU load (either due to application
processing, or due to network processing). Ironically,
this points at another potential covert channel – mea-
suring the eﬀects of CPU load on the network traf-
ﬁc shape. But as we mention above, this is unlikely
to happen in a production network, where the CPU
power is more in balance with the network capacity.

To make sure the eﬀect we measure is only related
to the IPv4 ID information leakage, we altered the
channel deﬁnition for the purpose of the experiment.
Instead of staying idle (not transmitting anything)
for bit “0”, in the experiment, we transmit the same
amount of packets, but using a small subset of 90
spoofed source IP addresses whose counters do not
collide with the receiver’s counter. A-prioi, choosing
90 counters out of 2048 yields a good likelihood of
this condition to be met. A-posteriori, we can verify
this easily. If the receiver’s IP address IP ID counter
does collide with one of the 90 counters, the vector
of bits the receiver reads will be all 1’s. We veriﬁed
this is not the case. This revised experiment ensures
that the host’s CPU load is comparable for both “0”
and “1” bits.

Given the above results, we estimate that the bit
error rate in this channel is below 0.004. In this case,
simple error correction code can be used to correct
any sparse errors.

19

Table 5: Experiments

OS

Linux

Windows

macOS

OpenBSD

NetBSD

Test
LE-1
LE-2
LE-3
LE-4
LF-1
LF-2
LA-1a
LA-1b
LA-1c
WE-1
WE-2
WE-3

WE-4

WA-1a
WA-1b
ME-1
ME-2
OE-1
OE-2
OE-3

OE-4

OF-1
OF-2
OF-3
OA-1a
OA-1b
NE-1
NE-2
NE-3

NE-4

Test Scenario
Exﬁltration (via DMZ)
Exﬁltration (via DMZ)
Exﬁltration (container)
Exﬁltration (container)
Firewall Piercing (IPﬁre, slow)
Firewall Piercing
Alias Resolution (1 host)
Alias Resolution (2 containers)
Alias Resolution (2 hosts)
Exﬁltration (via DMZ)
Exﬁltration (via DMZ)
Exﬁltration (via DMZ)

Exﬁltration (via DMZ)

Alias Resolution (1 host)
Alias Resolution (2 hosts)
Exﬁltration (via DMZ)
Exﬁltration (via DMZ)
Exﬁltration (via DMZ)
Exﬁltration (via DMZ)
Exﬁltration (via DMZ)

Exﬁltration (via DMZ)

Firewall Piercing (slow)
Firewall Piercing (Esdenera ruleset, slow)
Firewall Piercing
Alias Resolution 1 host
Alias Resolution 2 hosts
Exﬁltration (via DMZ)
Exﬁltration (via DMZ)
Exﬁltration (via DMZ)

Exﬁltration (via DMZ)

Protocol
UDP/IPv4
UDP/IPv4
UDP/IPv4
UDP/IPv4
ICMP/IPv4
ICMP/IPv4
UDP/IPv4
UDP/IPv4
UDP/IPv4
UDP/IPv4
UDP/IPv4
TCP/IPv4
UDP/IPv4 (Sender),
TCP/IPv4 (Receiver)
UDP/IPv4
UDP/IPv4
UDP/IPv4
UDP/IPv4
UDP/IPv4
UDP/IPv4
TCP/IPv4
UDP/IPv4 (Sender),
TCP/IPv4 (Receiver)
ICMP/IPv4
ICMP/IPv4
ICMP/IPv4
UDP/IPv4
UDP/IPv4
TCP/IPv4
TCP/IPv4
TCP/IPv6
TCP/IPv6 (Sender),
TCP/IPv4 (Receiver)

Sender
Lab Net Loc. A
Lab Net Loc. B
Lab Net Loc. A
Lab Net Loc. B
Lab Net Lab Net
Lab Net Lab Net
Lab Net Lab Net
Lab Net Lab Net
Lab Net Lab Net
Lab Net Loc. A
Lab Net Loc. B
Lab Net Loc. A

Receiver Bits/Repetitions
128
128
128
128
128
128
10
10
10
128
128
128

Success
128/128
128/128
128/128
128/128
128/128
128/128
10/10
10/10
10/10
128/128
128/128
128/128

Bit rate
400 b/h
400 b/h
400 b/h
400 b/h
400 b/h
3000 b/h
N/A
N/A
N/A
47.4 b/h
47.4 b/h
41.4 b/h

Lab Net Loc. A

Lab Net Lab Net
Lab Net Lab Net
Lab Net Loc. A
Lab Net Loc. B
Lab Net Loc. A
Lab Net Loc. B
Lab Net Loc. A

Lab Net Loc. A

Loc. B
Lab Net
Lab Net Lab Net
Lab Net Lab Net
Loc. A
Loc. A
Loc. A
Loc. A
Lab Net Loc. A
Lab Net Loc. B
Lab Net Lab Net

Lab Net Loc. A

128

10
10
128
128
128
128
128

128

128
128
128
10
10
128
128
128

128

128/128

47.4 b/h

10/10
10/10
128/128
128/128
128/128
128/128
128/128

N/A
N/A
1800 b/h
1800 b/h
720 b/h
720 b/h
360 b/h

128/128

720 b/h

128/128
128/128
128/128
10/10
10/10
128/128
128/128
128/128

720 b/h
1200 b/h
4200 b/h
N/A
N/A
7200 b/h
7200 b/h
7200 b/h

128/128

7200 b/h

Section
6.4.1
6.4.1
6.4.2
6.4.2
6.4.3
6.4.3

6.4.4
6.4.4
6.4.5

6.4.6
6.4.6
6.4.7
6.4.7
6.4.8

6.4.9
6.4.9
6.4.9

6.4.10
6.4.10
6.4.11

20

6.4.2 Linux Exﬁltration via Containers over

UDP/IPv4

The LE-3 and LE-4 tests (locations A and B resp.)
are very similar to the previous section, with two co-
resident containers running on a single host (kernel).
The sender resides in the internal (isolated) network,
communicating with the internal (isolated) container
over HTTP/3, and the receiver resides on the Inter-
net, communicating with the second container over
HTTP/3. In all other aspects, these tests are identi-
cal to the one in the previous section.

we simulated Windows Server on a Windows 10 plat-
form. This was done by setting TcpipIsServerSKU to
1 and the default compartment’s IPv4 PathSet purge
threshold (32 bit quantity at oﬀset 332 of PathSet)
to 32768. This made the system behave identically to
Windows Server for the purpose of our experiments.
For the channel deﬁnition, we used K = 6. A single
bit transfer took 76s (theoretically this could be done
with 71s per bit, but due to technical issues, and
to make sure the channel can handle some organic
network traﬃc, we padded it by 5s).

6.4.3 Linux

Firewall

Piercing

over

ICMP/IPv4

Due to technical reasons, we could only conduct the
Linux ﬁrewall piercing attacks in the lab. For test LF-
1, we installed a typical Linux-based ﬁrewall image
(IPﬁre 2.25 (x86 64) running Linux kernel 4.14.112)
on a dedicated device, and conﬁgured it to block com-
munications between the internal “green” network
and the external “red” network (an Internet-facing
lab network). We then ran our attack, but for sim-
plicity of testing, we sent data from the red network
to the green network. The data transfer rate was
limited by the sender machine’s eﬀective bandwidth
– we could only send up to ≈14,000 ICMP packets/s.
A stronger sender machine would have achieved a
higher throughput.

In order to compare the speed of ICMP exﬁltration
to that of QUIC/UDP exﬁltration, we conducted an-
other experiment (LF-2), this time using the same
target machine as in 6.4.1. We used a stronger sender
that was able to send ≈130,000 ICMP packets/s, and
the throughput was 1.2 bits/s (3000 b/h), which is
7.5 times faster than the QUIC/UDP variant. Here
too, we could use a stronger sender to get even higher
exﬁltration throughput.

6.4.4 Windows

Server Exﬁltration

(via

DMZ) over UDP/IPv4

We did not have at our disposal a Windows Server
on a network that allows spooﬁng, so instead, for
tests WE-1 and WE-2 (locations A and B, resp.),

6.4.5 Windows Exﬁltration (via DMZ) over

TCP/IPv4

In experiment WE-3, we demonstrated that the
Windows covert channel can be used over TCP. In
essence, this is a very similar experiment to the one
described in Section 6.4.4, but this time we used TCP.
The sender sent SYN packets with spoofed source IP
address to the target host. These packets are short
(40 bytes at the IPv4 level) and can be transmitted
rapidly. Assuming the spoofed IP addresses are not
associated with any machines, there will not be any
transmission from these IP addresses following the
spoofed SYN packets. Windows responds immedi-
ately with a SYN+ACK packet, with additional two
retransmissions (the default “Max SYN Retransmis-
sions” is 2) at exponential backoﬀ, so the ﬁrst retrans-
mission is sent after an “Initial Retransmission Time-
Out” seconds, henceforth IRTO (in Windows Server,
by default IRTO=3s), and the second retransmission
packet is sent 2 · IRTO after the ﬁrst retransmission.
These packets are not answered of course, so ﬁnally
Windows sends an RST packet, 4·IRTO seconds after
the third SYN+ACK packet is sent (7·IRTO seconds
after the SYN packet is received). Therefore, Win-
dows sends the last packet to a spoofed IP address
21s after a SYN is received from it. This overlaps
with the 10 seconds the receiver needs to wait after
the sender’s burst in order for the purge to be con-
cluded, so only 11 seconds are actually added to the
In a lab
time-per-bit compared to the UDP case.
experiment, we found that Windows’ SYN cache is
not exhausted even by 13000 half-open connections,
thus our technique for TCP/IPv4 in Windows is non-

21

disruptive.

6.4.8 OpenBSD Exﬁltration (via DMZ) over

As for the receiver, we implement it to send an
RST packet to the target host as soon as the target
host’s SYN+ACK arrives at the receiver, thus the
Path object’s last access time is only extended by
the RTT between the target host and the receiver,
having a negligible impact on the attack timing.

We carried out the experiment similar to Sec-
tion 6.4.4, with the modiﬁed attack timing. Since we
used Windows 10 as a target host, we had to adjust its
Initial RTO value to 3000ms to simulate Windows
Server (the default Windows 10 value is 300ms).

6.4.6 macOS Exﬁltration (via DMZ) over

UDP/IPv4

In tests ME-1 and ME-2 (locations A and B, resp.),
the channel was deﬁned with K = 700, thus ensuring
that the probability for a sent bit “1” to be received as
“0” is very low (1/1767). The sender transmitted 5000
packets per bit. Theoretically, the sender needed to
send 4096 packets to signal the bit “1”, but in prac-
tice, due to server responsiveness issues, we had the
sender send some extra packets. With throttling, this
took 0.39 seconds. Due to some overheads incurred
by our speciﬁc test implementation, each bit trans-
mission took two seconds.

6.4.7 OpenBSD Exﬁltration (via DMZ) over

UDP/IPv4

In tests OE-1 and OE-2 (locations A and B, resp.),
the channel was deﬁned with K = 700, thus ensuring
that the probability for a sent bit “1” to be received
as “0” is very low (1/1767). The sender transmit-
ted 40000 packets per bit. Theoretically, the sender
needed to send 32768 packets to signal the bit “1”,
but in practice, due to server responsiveness issues
issues, we had the sender send 40000 packets. This
took 3.32 seconds. Due to some overheads incurred
by our speciﬁc test, each bit transmission took 5 sec-
onds.

TCP/IPv4

In test OE-3, the sender sent SYN packets to the
target host. Both the sender and the receiver were
implemented to send an RST packet to the target
host as soon as the target host’s SYN+ACK arrives
at the sender/receiver, to ensure no retransmissions
clutter the network and that the host’s SYN cache
is not overﬂowed, since the pending connection is re-
moved from it once the RST packet for it arrives.

We throttled the sender to about 6000 packets/sec
in order to make sure the host’s TCP SYN cache is
not exhausted (the OpenBSD SYN cache size limit
is 10255 entries). Due to the throttling, the time per
bit was extended to 10s.

6.4.9 OpenBSD Firewall Piercing

Test OF-1 was conducted over the Internet, with a
very weak machine running OpenBSD 6.7 in Location
B. That machine could only handle ≈9,000 ICMP
Echo Requests per second, which set the constraint
on the throughput. We achieved a single bit transfer
in 5s.

We also ran in-the-lab tests with ﬁrewalls (we could
not deploy Internet-facing ﬁrewalls).
In test OF-2,
we simulated an OpenBSD-based ﬁrewall. For this,
we used a PF ruleset we extracted from an Esden-
era Firewall-3 installation [39]. This ruleset explic-
itly allows ICMP traﬃc to and from the ﬁrewall, on
all interfaces. We tested OpenBSD 6.9 in this case.
In test OF-3, we measured the speed of the attack
with a sender capable of sustaining ≈68,000 ICMP
Echo Requests per second, against the usual Dell tar-
get running OpenBSD 6.8, which can serve ≈260,000
Echo Requests per second. We obtained a 0.85s bit
transfer time, but using a stronger sender machine
can signiﬁcantly increase this ﬁgure.

6.4.10 NetBSD Exﬁltration (via DMZ) over

TCP/IPv4

Our covert channel for NetBSD over IPv4 is not
in itself interesting, because NetBSD already has a
TCP/IPv4 covert channel in the form of its global

22

IPv4 ID counter. However, we wanted to empha-
size the applicability of our TCP/IPv4 technique
over the Internet since we cannot demonstrate our
TCP/IPv6 technique over the Internet due to tech-
nical constraints. By demonstrating our TCP/IPv4
covert channel over the Internet, we infer that the
same holds for our TCP/IPv6 channel.

In our NE-1 and NE-2 experiments (with senders at
A and B, resp.), we set ∆t=0.2s, with total time per
bit 0.5s (this is due to some limitations of our testing
code, and we note that theoretically NetBSD’s covert
channel can be run at much higher speeds), thus the-
oretically threshold for m − m(cid:48) should have been 2,
but we set it to 3 to avoid false positives from occa-
sional TCP connections established with the target
host.

6.4.11 NetBSD Exﬁltration (via DMZ) over

TCP/IPv6

In test NE-3 we had to use a local receiver since our
lab does not have IPv6 connectivity to the Internet.

7 Remediation and Suggestions

We begin with the easy parts, in which the attack
can be completely eliminated:

• TCP/IPv4 packets, and IPv4 packets with
DF=1 – these packets can have ID=0 or a com-
pletely random ID. In Linux, all TCP packets,
and UDP packets whose length is below the
PMTU are sent with DF=1.
In Windows and
macOS, all TCP packets are sent with DF=1.
in macOS, the TCP packets have
Moreover,
ID=0, which demonstrates that simply setting
ID=0 suﬃces for these cases. Note that e.g.
QUIC requires setting DF=1 in UDP [27, Sec-
tion 14], but Caddy Server leaves the choice of
DF to the operating system.

• TCP ISN – this ﬁeld should not contain state in-
formation, i.e. should contain random data and
client information only.

• IPv6 Flow label (see Appendix A.2.2 and Ap-
pendix A.2.3) – can be chosen at random (i.e.

using a “regular” PRNG). There is no RFC re-
quirement for the ﬂow label to have a unique
value in any time duration.

In some operating systems, a built-in ﬁltering func-
tionality facilitates overriding a protocol ﬁeld value
with a ﬁxed/random value. See Appendix A.3 for
Linux nftables examples.

The

case

challenging

is UDP/IPv4

(and
ICPMv4/IPv4) ID with DF=0. In this case, there is
a real need for the ID ﬁeld to be non-repeating to
some extent. We can make the following suggestions
to reduce the attack surface and eliminate some
attack variants, but the underlying issue is still in
eﬀect even with our suggestions:

• Maintain a separate IPv4 ID state according to
the destination address: one state for RFC1918
destination addresses (internal networks) and
another state for external destinations. This
eliminates the exﬁltration attacks where the
sender is on an internal network and can only
spoof internal network addresses.

• Maintain an IPv4 ID generator state per service
(i.e. per a listening IP address and port). This
eliminates the host alias resolution attacks. A
weaker version is to maintain a state per listening
IP address.

• Maintain an IPv4 ID generator state per con-
tainer – this eliminates the cross-container at-
tacks.

Another approach is to ensure that connection-less
transport protocols emit IPv4 packets whose length
is below a reasonably chosen minimal PMTU, and
simply set DF=1 and ID=0 for all these packets.
For example, DNS over UDP/IPv4 can function with
message length limit of 512 bytes (540 bytes includ-
ing UDP and IPv4 headers), QUIC over UDP/IPv4
can function with message length limit of 1200 bytes
(1228 bytes including UDP and IPv4 headers), and
ICMP Echo Requests whose size exceeds PMTU can
be discarded.
Finally,

it is possible to simply randomize the
IP ID, which guarantees maximum security, at the
expanse of somewhat increased malformed/dropped

23

packet rate (due to the possible ID collisions and their
eﬀect on fragment reassembly).

Note that ICMP rate limits do not eliminate the
covert channels: even an aggressive per-destination
rate limit is ineﬀective against the attack, as the at-
tacker may use multiple, possible spoofed, source IP
addresses. A global rate limit, on the other hand, fa-
cilitates a covert channel via overﬂowing (or not) the
packet counter.

8 Conclusions

We conclude that global states in network protocols
of server hosts can be exploited in various ways to
weaken the security of networks where such hosts re-
side, and to glean information on the implementation
of services which is otherwise abstracted from their
consumers.

While a global state can be as obvious as an in-
cremental counter, we also demonstrated that it can
take a more subtle form. For example in the case
of OpenBSD and macOS IPv4 ID, the observation
of collisions in IPv4 ID values (or lack thereof) is an
indication of the internal global state, which is not di-
rectly exposed to the attacker. Other such non trivial
examples are the Linux IPv4 ID generation scheme,
and the Windows IPv4 ID generation scheme.

Our work focused on ﬁrewalled hosts, which is a
very common scenario for Internet-facing servers. A
stateful ﬁrewall eliminates many known information
leakage attacks, and therefore poses a serious obsta-
cle for techniques that rely on information leakage
via a global protocol state. We described three new
attack scenarios based on information leakage via a
global protocol state: ﬁrewall piercing, exﬁltration
form a secure network, and exﬁltration across con-
tainers. We demonstrated our three new scenarios,
as well as a host alias resolution scenario and a host
alias resolution across containers scenario. All these
scenarios were demonstrated with the sender (and
the host, where applicable) behind a ﬁrewall, in re-
alistic conditions, and over the Internet where possi-
ble. We also demonstrated some cross protocol at-
tacks, e.g. where the sender uses UDP/IPv4 and
the receiver uses TCP/IPv4, and where the sender

uses TCP/IPv6 and the receiver uses TCP/IPv4. We
measured the exﬁltration bandwidth achieved, and
found it to be suﬃcient for e.g. key material exﬁltra-
tion in hours or minutes.

The problem of secure IPv4 ID generation seems
to be theoretically intractable, due to the conﬂicting
requirements – generating long sequences of unique
values, at least per (IP SRC , IP DST ) and leaking no
information, while maintaining a “reasonably sized”
state, which is much smaller than the number of ex-
pected concurrent tuples. Intuitively, this is due to
the pigeonhole principle, as it is impossible to main-
tain an independent state per tuple with less bits than
the number of concurrent tuples. However, we do
list some recommendations that considerably reduce
the attack surface and speciﬁcally address the attacks
scenarios we described.

It is important to understand that information
leakage from network protocol global states can af-
fect the security of networks and systems in surprising
and unexpected ways. In our research, we highlight
three novel attack scenarios. It is quite possible that
additional attack scenarios exist, and thus there is
room for future research on this topic.

9 Vendor Status

All vendors were notiﬁed on January 27th, 2021.

• Linux issued a patch [18] for kernel version 5.13-
rc1 that signiﬁcantly increases the size of the β
table. This patch was back-ported to versions
5.12.4, 5.11.21, LTS branches 5.10.37, 5.4.119,
4.19.196, 4.14.238, 4.9.274 and 4.4.274. Back-
ports to all 4.x branches were provided by us
based on the back-port to the 5.x versions. This
issue is tracked as CVE-2021-45486.

Linux also issued a patch replacing the exist-
ing IPv6 ID algorithm (similar to the IPv4 ID
algorithm) with a completely randomized IPv6
ID [48] which is included in version 5.14-rc1,
and was back-ported to kernel versions 5.13.3,
5.12.18, 5.10.51, 5.4.133, 4.19.198, 4.14.240,
4.9.276 and 4.4.276. This issue is tracked as
CVE-2021-45485.

24

• Microsoft informed us on March 15th, 2021,
that “[Microsoft] determined your ﬁnding does
not meet our bar for servicing”.

• Apple released a ﬁx for the IPv4 ID issue in ma-
cOS 12.1 [6], macOS 11.6.2 [5], macOS 10.15 [8],
iOS/iPadOS 15.2 [4] tvOS 15.2 [9] and watchOS
8.3 [7].

The ICMP rate limit issue was reported to Ap-
ple separately on June 11th, 2021, and regarding
it, Apple informed us on July 21st, 2021, that
“while we [Apple] do not see any security impli-
cations, we have forwarded it on to the appro-
priate team to investigate for potential future
enhancements”.

• OpenBSD has not responded to multiple re-
quests for status, has not informed us about any
decision/resolution, and has not ﬁxed the issue
in their public source code repository.

• NetBSD produced a patch [38] for NetBSD
9.2 that better randomizes the TCP ISN (CVE-
2021-45488),
(CVE-2021-
IPv6 Flow Label
45489) and IPv6 ID (CVE-2021-45484). This
patch also switches the NetBSD implementation
of the IPv4 ID ﬁeld from a simple counter to a
random number generator (CVE-2021-45487).

Acknowledgment

2019/10/25/udp-idle-scanning/,
2019.

October

[3] Geoﬀrey Alexander, Antonio M. Espinoza, and
Jedidiah R. Crandall. Detecting tcp/ip connec-
tions via ipid hash collisions. Proceedings on Pri-
vacy Enhancing Technologies, 2019(4):311 – 328,
01 Oct. 2019.

[4] Apple. About the security content of ios 15.2
and ipados 15.2. https://support.apple.com/
en-us/HT212976, December 2021.

[5] Apple. About the security content of macos
big sur 11.6.2. https://support.apple.com/
en-us/HT212979, December 2021.

[6] Apple. About the security content of macos
monterey 12.1. https://support.apple.com/
en-us/HT212978, December 2021.

[7] Apple. About the security content of macos
monterey 12.1. https://support.apple.com/
en-us/HT212975, December 2021.

[8] Apple. About the security content of security
update 2021-008 catalina. https://support.
apple.com/en-us/HT212981, December 2021.

[9] Apple. About the security content of tvos
https://support.apple.com/en-us/

15.2.
HT212980, December 2021.

We would like to thank Benny Pinkas, the anonymous
NDSS 2022 reviewers and Haixin Duan (our NDSS
shepherd) for their valuable feedback, and Ehood Po-
rat for his help in reverse engineering some parts of
Windows code.

[10] Steven M. Bellovin. A Technique for Counting
Natted Hosts. In Proceedings of the 2Nd ACM
SIGCOMM Workshop on Internet Measurment,
IMW ’02, pages 267–272, New York, NY, USA,
2002. ACM.

References

[1] Maurizio Aiello, Alessio Merlo, and Gianluca Pa-
paleo. Performance assessment and analysis of
dns tunneling tools. Logic Journal of IGPL, 21,
03 2012.

[2] Martin Albrecht.

Udp

idle

scanning.

https://martinralbrecht.wordpress.com/

[11] Robert Beverly, William Brinkmeyer, Matthew
Ipv6 alias res-
Luckie, and Justin P. Rohrer.
olution via induced fragmentation. In Matthew
Roughan and Rocky Chang, editors, Passive and
Active Measurement, pages 155–165, Berlin, Hei-
delberg, 2013. Springer Berlin Heidelberg.

[12] Chad Brubaker, Amir Houmansadr, and Vi-
taly Shmatikov. Cloudtransport: Using cloud
In
storage for censorship-resistant networking.

25

Emiliano De Cristofaro and Steven J. Murdoch,
editors, Privacy Enhancing Technologies, vol-
ume 8555 of Lecture Notes in Computer Science,
pages 1–20. Springer, 2014.

[13] Elie Bursztein. Time has something to tell us
In ´Ulfar
about network address translation.
Erlingsson and Andrei Sabelfeld, editors, Proc.
12th Nordic Workshop on Secure IT Systems
(NORDSEC 2007), Iceland, October 2007. Uni-
versity of Reykjavik.

[14] Y. Cao, Z. Qian, Z. Wang, T. Dao, S. V.
Krishnamurthy, and L. M. Marvel. Oﬀ-path
tcp exploits of the challenge ack global rate
limit. IEEE/ACM Transactions on Networking,
26(2):765–778, 2018.

[15] Yue Cao, Zhongjie Wang, Zhiyun Qian,
Chengyu Song, Srikanth V. Krishnamurthy, and
Paul Yu. Principled unearthing of tcp side chan-
nel vulnerabilities.
In Proceedings of the 2019
ACM SIGSAC Conference on Computer and
Communications Security, CCS ’19, pages 211–
224, New York, NY, USA, 2019. ACM.

[16] Weifeng Chen, Yong Huang, Bruno F. Ribeiro,
Kyoungwon Suh, Honggang Zhang, Edmundo
de Souza e Silva, Jim Kurose, and Don Towsley.
Exploiting the ipid ﬁeld to infer network path
and end-system characteristics.
In Constanti-
nos Dovrolis, editor, Passive and Active Net-
work Measurement, pages 108–120, Berlin, Hei-
delberg, 2005. Springer Berlin Heidelberg.

[17] George Danezis. Covert communications de-
spite traﬃc data retention. In Bruce Christian-
son, James A. Malcolm, Vashek Matyas, and
Michael Roe, editors, Security Protocols XVI -
16th International Workshop, Cambridge, UK,
April 16-18, 2008. Revised Selected Papers, vol-
ume 6615 of Lecture Notes in Computer Science,
pages 198–214. Springer, 2008.

[18] Eric Dumazet.

inet: use bigger hash table
https://git.kernel.

for IP ID generation.
org/pub/scm/linux/kernel/git/stable/
linux.git/commit/net/ipv4/route.c?id=

aa6dd211e4b1dde9d5dc25d699d35f789ae7eeba,
March 2021.

[19] Roya Ensaﬁ, Jong Chun Park, Deepak Kapur,
Idle port scanning
and Jedidiah R. Crandall.
and non-interference analysis of network proto-
col stacks using model checking.
In Proceed-
ings of the 19th USENIX Conference on Secu-
rity, USENIX Security’10, pages 257–272, USA,
2010. USENIX Association.

[20] Xuewei Feng, Chuanpu Fu, Qi Li, Kun Sun, and
Ke Xu. Oﬀ-path tcp exploits of the mixed ipid
In Proceedings of the 2020 ACM
assignment.
SIGSAC Conference on Computer and Commu-
nications Security, CCS ’20, page 1323–1335,
New York, NY, USA, 2020. Association for Com-
puting Machinery.

[21] X. Gao, Z. Gu, M. Kayaalp, D. Pendarakis,
and H. Wang. Containerleaks: Emerging secu-
rity threats of information leakages in container
clouds. In 2017 47th Annual IEEE/IFIP Inter-
national Conference on Dependable Systems and
Networks (DSN), pages 237–248, USA, 2017.
IEEE Computer Society.

[22] Yossi Gilad and Amir Herzberg. Fragmentation
Considered Vulnerable. ACM Trans. Inf. Syst.
Secur., 15(4):16:1–16:31, April 2013.

[23] Mordechai Guri, Assaf Kachlon, Ofer Hasson,
Gabi Kedma, Yisroel Mirsky, and Yuval Elovici.
Gsmem: Data exﬁltration from air-gapped com-
puters over GSM frequencies. In 24th USENIX
Security Symposium (USENIX Security 15),
pages 849–864, Washington, D.C., August 2015.
USENIX Association.

[24] Mordechai Guri, Yosef Solewicz, Andrey
Daidakulov, and Yuval Elovici. Acoustic data
exﬁltration from speakerless air-gapped com-
puters via covert hard-drive noise (‘diskﬁltra-
In Simon N. Foley, Dieter Gollmann,
tion’).
and Einar Snekkenes, editors, Computer Secu-
rity – ESORICS 2017, pages 98–115, Cham,
2017. Springer International Publishing.

26

[25] Mordechai Guri,

Zadov,

Andrey
Boris
Daidakulov, and Yuval Elovici. xled: Covert
data exﬁltration from air-gapped networks via
switch and router leds.
In 2018 16th Annual
Conference on Privacy, Security and Trust
(PST), pages 1–12, 2018.

[26] Veit Hailperin. Misusing tcp timestamps.
https://www.scip.ch/en/?labs.20150305,
March 2015.

[27] Jana Iyengar and Martin Thomson. QUIC: A
UDP-Based Multiplexed and Secure Transport.
RFC 9000, May 2021.

[28] Dan Kaminsky.

Black ops of dns – the
https://www.

black hat brieﬁngs 2004.
blackhat.com/presentations/bh-usa-04/
bh-us-04-kaminsky/bh-us-04-kaminsky.
ppt, 2004.

[29] Amit Klein. OpenBSD DNS Cache Poisoning
and Multiple O/S Predictable IP ID Vulner-
ability.
https://dl.packetstormsecurity.
net/papers/attack/OpenBSD_DNS_Cache_
Poisoning_and_Multiple_OS_Predictable_
IP_ID_Vulnerability.pdf, February 2008.

[30] Amit Klein. Cross layer attacks and how to use
them (for dns cache poisoning, device tracking
and more). In 2021 2021 IEEE Symposium on
Security and Privacy (SP), pages 927–944, Los
Alamitos, CA, USA, May 2021. IEEE Computer
Society.

[31] Amit Klein and Benny Pinkas. From IP ID
In 28th
to Device ID and KASLR Bypass.
USENIX Security Symposium (USENIX Secu-
rity 19), pages 1063–1080, Santa Clara, CA, Au-
gust 2019. USENIX Association.

[32] T. Kohno, A. Broido, and k. Claﬀy. Remote
physical device ﬁngerprinting.
IEEE Trans-
actions on Dependable and Secure Computing,
2(2):93–108, May 2005.

[33] Linux.

arp(7) — linux manual page.

https://man7.org/linux/man-pages/man7/
arp.7.html.

[34] Mark Lucas, Abhishek Singh, Chris Cantrell,
and Anne Henmi. Firewall Policies and VPN
Conﬁgurations. Syngress Publishing, Rockland,
MA, 2006.

[35] Matthew Luckie, Robert Beverly, Ryan Koga,
Ken Keys, Joshua A. Kroll, and k claﬀy. Net-
work hygiene, incentives, and regulation: De-
ployment of source address validation in the in-
ternet. In Proceedings of the 2019 ACM SIGSAC
Conference on Computer and Communications
Security, CCS ’19, page 465–480, New York, NY,
USA, 2019. Association for Computing Machin-
ery.

[36] Xiapu Luo, Edmond W. W. Chan, and Rocky
Crafting web counters into
K. C. Chang.
In Hein Venter, Mariki Eloﬀ,
covert channels.
Les Labuschagne, Jan Eloﬀ, and Rossouw von
Solms, editors, New Approaches for Security,
Privacy and Trust in Complex Environments,
pages 337–348, Boston, MA, 2007. Springer US.

[37] Steven J. Murdoch. Hot or not: Revealing hid-
den services by their clock skew. In Proceedings
of the 13th ACM Conference on Computer and
Communications Security, CCS ’06, page 27–36,
New York, NY, USA, 2006. Association for Com-
puting Machinery.

[38] NetBSD.

NetBSD Security Advisory 2021-
001: Predictable ID disclosures in IPv4 and
IPv6.
http://ftp.netbsd.org/pub/NetBSD/
security/advisories/NetBSD-SA2021-001.
txt.asc, March 2021.

[39] Esdenera Networks. Esdenera ﬁrewall 3. https:

//www.esdenera.com/firewall-3/.

[40] ntp.org.

Ntp faq – how accurate will my
http://www.ntp.org/ntpfaq/

clock be?
NTP-s-algo.htm#Q-ACCURATE-CLOCK, 2003.

[41] Liran Orevi, Amir Herzberg, Haim Zlatokrilov,
and Dolev Sigron. DNS-DNS: DNS-based De-
NAT Scheme.
https://www.researchgate.
net/publication/320322146_DNS-DNS_
DNS-based_De-NAT_Scheme, January 2017.

27

[42] I. Reed and G. Solomon. Polynomial codes over
certain ﬁnite ﬁelds. Journal of The Society for
Industrial and Applied Mathematics, 8:300–304,
1960.

[43] SamKnows. Quality of broadband services in
the eu. Technical report, European Commision,
October 2014.

[44] Salvatore Sanﬁlippo.

new tcp scan method.
http://seclists.org/bugtraq/1998/Dec/79,
December 1998.

[45] Sushrut Shringarputale, Patrick McDaniel,
Kevin Butler, and Thomas La Porta. Co-
residency attacks on containers are real.
In
Proceedings of the 2020 ACM SIGSAC Confer-
ence on Cloud Computing Security Workshop,
CCSW’20, page 53–66, New York, NY, USA,
2020. Association for Computing Machinery.

[46] Neil Spring, Ratul Mahajan, David Wetherall,
and Thomas Anderson. Measuring isp topolo-
gies with rocketfuel. IEEE/ACM Trans. Netw.,
12(1):2–16, February 2004.

[47] Yang Tao, Gang Hu, Bingnan Hou, Zhiping Cai,
Jing Xia, and Cheang Chak Fong. An alias reso-
lution method based on delay sequence analysis.
Computers, Materials & Continua, 63(3):1433–
1443, 2020.

id

for

use

ipv6:
generation.

[48] Willy Tarreau.
dom u32()
//git.kernel.org/pub/scm/linux/kernel/
git/torvalds/linux.git/commit/?id=
62f20e068ccc50d6ab66fdb72ba90da2b9418c99,
May 2021.

pran-
https:

[49] Dr. Joseph D. Touch. Updated Speciﬁcation of

the IPv4 ID Field. RFC 6864, February 2013.

[50] Wikipedia

contributors.
the

Stateful

ﬁre-
encyclopedia.

wall — Wikipedia,
https://en.wikipedia.org/w/index.php?
title=Stateful_firewall&oldid=987652216,
2020. [Online; accessed 25-November-2020].

free

[51] Apostolis Zarras. Leveraging internet services
to evade censorship. In Proceedings of the 19th
Information Security Conference (ISC), 2016.

[52] Xu Zhang, Jeﬀrey Knockel, and Jedidiah R.
Crandall. ONIS: Inferring TCP/IP-based Trust
Relationships Completely Oﬀ-Path.
In INFO-
COM, pages 2069–2077, Los Alamitos, CA,
USA, 2018. IEEE.

[53] Xiaofeng Zheng, Chaoyi Lu, Jian Peng, Qiushi
Yang, Dongjie Zhou, Baojun Liu, Keyu Man,
Shuang Hao, Haixin Duan, and Zhiyun Qian.
Poison over troubled forwarders: A cache poi-
soning attack targeting DNS forwarding devices.
In 29th USENIX Security Symposium (USENIX
Security 20), pages 577–593. USENIX Associa-
tion, August 2020.

A Experiment: A Survey of
from Widely-
Responses
Used Internet Servers
to
UDP, TCP and ICMP Prob-
ing

We estimate the portion of widely-used Internet hosts
which do not respond to a UDP packet to a closed
i.e. hosts that do not send back an ICMP
port,
message of any type (or any non-ICMP message) for
such invalid packets. We also estimate the portion of
widely-used Internet hosts which silently drop TCP
SYN packets to closed TCP ports. Finally, we esti-
mate the portion of widely-used Internet hosts that
respond to ICMP Echo Request (via the Ping utility).
We use the top 1000 domains in the Alexa top 1M
domain list obtained on December 13th, 2020 as a
starting point. We then query for the DNS NS (name
server) record-set for each domain, take the ﬁrst NS
record from the answer, and resolve its IPv4 address
(by sending a DNS A query and take the ﬁrst record
from the answer). This yields an IP address of an au-
thoritative DNS server for the domain at hand. This
host answers UDP queries to port 53 (DNS). As such,
it serves as a model for a reliable host that runs a

28

UDP-based service, similar to a QUIC server. More-
over, since the host is an authoritative DNS server for
a popular domain, we expect it to be highly available,
i.e. we can assume there are no downtime/service is-
sues for this host. We eliminated the duplicates in the
IP address list, and ended up in a list of 748 unique
IP addresses.

UDP Closed Ports: For each IP address, we sent
a UDP packet for three randomly chosen high ports.
These UDP ports are un-assigned by IANA, and
have no popular service associated with them, hence
are very likely to be closed. We observe whether
we receive any response from the host, either over
UDP or over ICMP. As expected, the only responses
we received were ICMP Type 3 messages (“Destina-
tion Unreachable”), mostly with Code 3 (“Port Un-
reachable”), but in three cases, we received Code 10
(“Communication with Destination Host is Adminis-
tratively Prohibited”) and in two cases we received
Code 13 (“Communication Administratively Prohib-
ited”).

TCP Closed Ports: We sent three TCP SYN
packets to each port used above, and recorded
whether we received any response back. As ex-
pected, most servers that responded, did so with
an RST packet, although one server responded with
SYN+ACK on two ports, which is likely a deceptive
practice. Regardless, we count this server as respon-
sive to TCP probes for closed ports.

ICMP Echo Requests: We sent each server
three ICMP Echo Request messages, and we recorded
whether we received any ICMP Echo Reply messages
back.

The results are as follows: 116 (15.5%) servers re-
sponded to the UDP probing, and 59 (7.9%) servers
responded to the TCP probing. The overlap was
signiﬁcant – 42 servers responded to both UDP
and TCP probing. Overall, 133 (17.8%) servers re-
sponded to either UDP or TCP. 667 (89.2%) servers
replied to ICMP Echo Requests. This set almost
completely covers the set of servers that responded
to either UDP or TCP probing – the overlap was 125
servers. In other words, the ICMP probing is almost
a complete superset of the TCP or UDP probing –
it misses about 1% of the space covered by UDP or
TCP, and contributes additional 72.5% of coverage.

A.1 Improved Attacks

A.1.1

Improved UDP/IPv4 ID Attack for
Linux

B∆t

An improvement to the technique described in Sec-
tion 5.1 is as follows: assume there also exist a one-
way channel from the receiver to the sender (which
can be implemented along the same lines of the
sender-to-receiver channel). In such a case, the im-
proved technique works in two phases.
In the ﬁrst
phase, the sender singles out one spoofed IP address
which hashes to the same counter with the receiver.
For this phase, a feedback is needed from the receiver.
In the second phase, the sender needs to spoof 2M −1
packets from a single address in order to transfer a
single bit (L times more eﬃcient in packets than the
original technique), and the receiver can read one bit
per ∆t time slot, which yields a (2M −1)L
faster trans-
fer rate. In the ﬁrst phase, the sender and receiver
engage in a binary search for a spoofed address that
hashes to the receiver’s counter. This process involves
sending (2M −1)L packets in (cid:100)log2 L(cid:101) iterations. The
sender can assume, by choosing large enough L, that
at least one spoofed address will have a counter colli-
sion in the target host with the receiver’s IP address,
and the ﬁrst phase aims to ﬁnd one such spoofed
In the ﬁrst iteration, the sender picks L
address.
2
spoofed addresses and sends the bit “1”. The receiver
sends back the bit it read. If it is “1”, the sender de-
duces that there is colliding spoofed address in the
sub-list, and proceeds with the binary search on this
list. If the bit is “0”, the sender deduces that there
is a colliding spoofed address in the complementary
sub-list, and proceeds with the binary search on the
complementary sub-list. At the end of this phase,
the sender has one address which hashes to the same
counter used for the receiver’s address. The second
phase can then proceed using a single address. Note
that the second phase does not need the receiver-to-
sender channel.

A.1.2 A Stealthier IPv4 ID Attack for ma-

cOS and OpenBSD

For macOS and OpenBSD, the IPv4 ID attack can
be made stealthier by having the sender and receiver

29

run “native” QUIC sessions with the target host, for
example HTTP/3 resource downloads. For exam-
ple, the sender can request a 4.9152MB (macOS) or
39.3216MB (OpenBSD) ﬁle (or larger) from the tar-
get host. This ensures that at least 4096 (macOS)
or 32768 (OpenBSD) QUIC packets are sent from
the target host to the sender (as each QUIC packet
carries at most 1200 payload bytes). Likewise the re-
ceiver can request a 840KB ﬁle (or larger) ﬁle from
the target host to force the host to send the receiver
at least 700 QUIC packets. Of course, instead of re-
questing one ﬁle (or resource), the sender and the
receiver can request multiple resources so that the
total number of packets sent by the host is above the
respective thresholds.

This can also be applied to OpenBSD with TCP
traﬃc.
In this case, there is an additional beneﬁt,
which is that there is no pressure on the TCP SYN
cache in the target host.

A.2 Additional Information Leakage

Attacks

A.2.1 A Covert Channel via Overﬂowing the
NetBSD and OpenBSD TCP SYN
Cache

NetBSD’s TCP SYN cache is a hash table containing
293 buckets with up to 105 entries each, and with a
global limit of 10255 entries. An inbound SYN packet
is hashed into a bucket based on the source IP ad-
dress, the source port, the destination port and a
secret 64-bit key. Then a SYN+ACK is sent, and the
bucket entry becomes a half-open connection. Statis-
tically, for evenly distributed traﬃc, the global limit
is reached before any bucket becomes full. When
the global limit is reached, the half-open connection’s
bucket5 has its oldest entry removed to keep the hash
table from overﬂowing. NetBSD responds to TCP
SYN packets as follows: a ﬁrst SYN+ACK packet is
sent immediately. A second SYN+ACK is sent af-
ter three seconds and three more SYN+ACK packets

5The bucket from which the entry is removed is the ﬁrst
non-empty bucket in the list of buckets, starting from the
half-open connection’s bucket. When the traﬃc is evenly dis-
tributed, this will be the half-open connection’s bucket.

are sent with exponential backoﬀ factor of 2. This
facilitates a side channel: let us assume that the tar-
get NetBSD host has it SYN cache table relatively
empty. An observer can send K TCP SYN packets
to an open port on a NetBSD host, and then ob-
serve the SYN+ACK packets sent back from the host,
without completing the handshake. If, during the 45
second period after the SYN packets were sent, the
TCP SYN cache becomes full due to another party
sending SYN packets, and some of the old packets’
entries get evicted, the host will not send any further
SYN+ACK packets for these evicted entries. If there
were F SYN packets sent after the SYN cache became
293 )F ≈ Ke− F
full, the observer expects K(1 − 1
293
“surviving” half-open connections for which the host
continues to send SYN+ACK packets.

We now show how to turn this into a covert chan-
nel. The receiver sends K SYN packets from K dif-
ferent TCP source ports. Then the sender can send
(10255 + µ) SYN packets from diﬀerent source ports
to the host to signal the bit “1”. Note that F = K+µ,
so the receiver observes that the host continues to
send SYN+ACK only for Ke− K+µ
293 half-open connec-
tions (in expectation). To send the bit “0”, the sender
does nothing, and the receiver observes that for all
ports (up to packet loss), the host continues sending
SYN+ACK.

For example, setting K = 10, µ = 1000 yields ex-
pected 0.32 open connections (out of 10 established
by the receiver) to continue sending SYN+ACK, with
σ = 0.56 (clearly this is not normally distributed, but
this σ value still indicates that it is extremely unlikely
to get a value above 5, for example). Thus, the re-
ceiver sends 10 SYN packets to the host, the receiver
sends (or does not send) 11225 SYN packets to the
host, and if the number of half-open connections for
which the host continues to send SYN+ACK to the
receiver is less than 5, the receiver deems that the
sender signalled the bit “1”, and otherwise, the re-
ceiver deems that the sender signalled the bit “0”.

This attack is quite expensive in terms of packet
count compared to the NetBSD TCP ISN attack.
Moreover, it is disruptive, since SYN packets from
organic clients of the host may get evicted from the
SYN cache which results in TCP connection failures.
The OpenBSD SYN cache is almost identical to

30

in
the NetBSD one, with the following exception:
OpenBSD, when 100000 insertions are made to the
current TCP SYN cache, it is frozen, and another
SYN cache instance is used as the active SYN cache
for new insertions. The impact on our technique is
that about once in 9 bits, the transmission fails be-
cause the old half-open connections from the receiver
are frozen and will not be removed (until they expire
naturally).

SYN+ACK packet is 0 (however, RST packets always
carry a random ﬂow label generated with Algorithm 2
– and this facilitates idle scanning). Also, while our
interest is in NetBSD as a TCP/IPv6 server, our anal-
ysis also covers the case of ﬂow labels generated by
NetBSD as a TCP/IPv6 client. Finally, note that
our analysis can be applied, with very minor modi-
ﬁcations, to NetBSD’s IPv6 ID generation algorithm
(A2/32).

A.2.2 A Covert Channel

via NetBSD
TCP/IPv6 Flow Label – Cryptanaly-
sis

NetBSD’s TCP/IPv6 ﬂow label ﬁeld (20 bits) is gen-
erated by the A2/20 PRNG (following the naming
convention introduced in [29]). The ﬂow label ﬁeld
comprises a most signiﬁcant bit (MSB) part, and 19
least signiﬁcant bits part. The PRNG is reseeded
every 180 seconds or 200000 internal PRNG steps
(whichever comes ﬁrst). As part of the reseeding pro-
cedure, the parameters for generating the least signif-
icant 19 bits are sampled from a strong kernel PRNG,
and the MSB is ﬂipped. Since the MSB is static be-
tween reseedings, it can be ignored for the remaining
of the discussion. The algorithm is designed to pro-
duce unique outputs during two consecutive reseeding
periods. This is not a required property for IPv6 ﬂow
label, and is probably a by-product of deriving this
algorithm from the A2/16 algorithm used for IPv4
ID generation back in 2003, which does require this
uniqueness property.

The least signiﬁcant 19 bits of the PRNG are gener-
ated using Algorithm 2. Note that in this sub-section,
M denotes a parameter of Algorithm 2, instead of its
role in the main paper.
In a single PRNG invoca-
tion, the PRNG draws a random number 1 ≤ n ≤ 4
and runs n internal steps. NetBSD’s ﬂow label gen-
eration involves two invocations of the PRNG, but
only the output of the latter one is used for the ﬂow
label ﬁeld. Thus overall, ﬂow label generation con-
sumes 2-8 internal PRNG steps (5 internal steps on
average).

Note that the pseudo-random ﬂow label is only
used by a NetBSD server after the TCP connection is
established. The ﬂow label for a NetBSD TCP/IPv6

6:

7:
8:

9:

Algorithm 2 NetBSD IPv6 Flow Label Algorithm
(19 Least Signiﬁcant Bits)

1:
2:

(cid:46) M = 279936 = 27 · 37
(cid:46) N = 524269 (prime),

ϕ(N ) = N − 1 = 22 · 32 · 14563

3: procedure Reseed
4:
5:

x ← random({0, . . . , M − 1})
s1 ← random({0, . . . , 219 − 1})
s2 ← random({0, . . . , N − 2})
a ← 72·random({0,...,219−1}) mod M
b ← random({x|0 < x < M ∧ gcd(x, M ) =

1})

g
mod N

←

2random({x|0<x<N ∧gcd(x,N −1)=1})

10: procedure Generate-FlowLabel
n ← random({1, . . . , 4})
11:
for i = 1 to n do
12:
13:

x ← (ax + b) mod M
return s1 ⊕ (gx+s2 mod N )

14:

i.e.

We now cryptanalyze Algorithm 2. We assume
that an attacker collects consecutive NetBSD ﬂow
ﬂow labels generated for consecutive
labels,
TCP/IPv6 connections. We allow a certain degree
of noise, i.e. out-of-order values, and missing values.
However, we do not allow values not generated by the
algorithm in the input data. Our analysis requires a
large portion of pairs of values to be correct, where
a pair is two consecutive ﬂow label values. We do
not require all pairs to be correct though. Our crypt-
analysis uses many concepts and techniques from the
cryptanalysis of A2/20’s sibling algorithms, A0/16
and X3/16, as reported in [29]. However, applying
the techniques for the 16 bit algorithms to the 20 bit
algorithm results in an unacceptably long (though

31

2

feasible) run time – speciﬁcally, “Phase 2” in [29] in-
volves enumeration over all (N − 1) ϕ(N −1)
combina-
tions of valid s2 and g values, which for A2/20 would
yield 235.41 values, and then going over all pairs (if
some noise is expected). This can take over an hour
when run single-threaded on a modern CPU. Our aim
in the improved cryptanalysis herein is to provide an
algorithm whose speed is 4.5-5 orders of magnitude
higher than the techniques presented in [29]. Indeed,
in our test, the typical attack runtime, when running
single-threaded on a modern CPU, is less than 50ms.
in the
ﬁrst phase, we use consecutive pairs to extract s1
(with enumeration over 219 values). This is very sim-
ilar to [29, Section 3]. In the second phase, we extract
g. In phase 3, we extract s2 in part. In phase 4, we
enumerate over the possible s2 values, and we build
a and b bit by bit (almost literally). In this phase we
also need pairs.

Our cryptanalysis comprises four phases:

We assume the attacker has L individual ﬂow label
values 0 ≤ Fi < 219 (we ignore the most signiﬁcant
bit of the ﬂow label), and among them the attacker
has P pairs of consecutive ﬂow label values (Fi, F (cid:48)
i ).
Clearly, L ≥ P + 1, with equality holds when the
values are consecutive ﬂow labels.

Phase 1 – Extracting s1: Oﬄine, attacker pre-
pares a log2(·) table for {1, . . . , N − 1}, i.e. a table
wherein (2n mod N ) (cid:55)→ (n mod (N − 1)).

Online, the attacker enumerates over all possi-
ble 219 values of s1 and analyzes the pairs (Fi, F (cid:48)
i ).
For the correct guess of s1, the following will hold:
log2(Fi ⊕ s1) = (log2 g)(xi + s2) mod (N − 1), and
likewise for F (cid:48)

i . Subtracting, we get:

log2(F (cid:48)

i ⊕ s1) − log2(Fi ⊕ s1) mod (N − 1) =

(log2 g)(x(cid:48)

i − xi) mod (N − 1)

Taking modulo 12 on both sides, keeping in mind that
12|(N − 1), we get:

log2(F (cid:48)

i ⊕ s1) − log2(Fi ⊕ s1) mod 12 =

(log2 g)(x(cid:48)

i − xi) mod 12

Now, since 12|M , and since a mod 12 = 1 by con-
struction, we have x(cid:48)
i − xi mod 12 = ni · b where
ni is the number of internal steps between xi and

x(cid:48)
i (see lines 10-12 of Algorithm 2), keeping in mind
that the algorithm is executed twice per ﬂow label,
i.e. 2 ≤ ni ≤ 8. Thus:

log2(F (cid:48)

i ⊕ s1) − log2(Fi ⊕ s1) mod 12 =

((log2 g)b)ni mod 12
Note that since g is a generator in the multiplica-
log2 g is invertible modulo
tive group modulo N ,
ϕ(N ) = N − 1, as well as modulo 12. b is invert-
ible modulo M by construction, so (log2 g)b is in-
vertible modulo 12. Therefore, ((log2 g)b mod 12 is
invertible, and so can only take four values: 1, 5, 7
or 11. Each value induces a set of 7 possible values
(only) for log2(F (cid:48)
i ⊕ s1) − log2(Fi ⊕ s1) mod 12, con-
forming to the 7 possible values of ni. If ((log2 g)b
mod 12 = 1, then log2(F (cid:48)
i ⊕ s1) − log2(Fi ⊕ s1)
mod 12 ∈ {2, 3, 4, 5, 6, 7, 8}. If ((log2 g)b mod 12 =
5, then log2(F (cid:48)
i ⊕ s1) − log2(Fi ⊕ s1) mod 12 ∈
{1, 3, 4, 6, 8, 10, 11}, and so forth.

We see, therefore, that for the correct guess of s1,
the P quantities log2(F (cid:48)
i ⊕s1)−log2(Fi ⊕s1) mod 12
all belong to one of four sets of seven values (out of
12 possible values). Denote by Cj = |{i| log2(F (cid:48)
i ⊕
s1) − log2(Fi ⊕ s1) mod 12 = j}| – the number of
times the value j ∈ {0, . . . , 11} appears in the list of
values log2(F (cid:48)
i ⊕ s1) − log2(Fi ⊕ s1) mod 12. Deﬁne:

X1 = C2 + C3 + C4 + C5 + C6 + C7 + C8

X5 = C1 + C3 + C4 + C6 + C8 + C10 + C11

X7 = C1 + C2 + C4 + C6 + C8 + C9 + C11

X11 = C4 + C5 + C6 + C7 + C8 + C9 + C10

If all P pairs are true (i.e. they are indeed pairs of
consecutive outputs from the PRNG), we will have
X1 = P or X5 = P or X7 = P or X11 = P .
If
there are some false pairs among the P pairs, this
will not hold as-is, but we can still use a statistical
approach. For an incorrect s1, a single counter C ∼
N ( P
144 P ), and a sum of 7 counters has distribution
N ( 7
144 P ). Setting a threshold at 5σ yields low
probability for false positives, thus we can posit that
for the correct s1:

12 , 11
12 P, 7· 11

max(X1, X5, X7, X11) ≥

7
12

P + 5

√

√

11
12

√

7

P

32

Since P must be at least as large as this quantity,
we can derive a minimum for P : P ≥ 77, i.e. with
P = 77 true pairs (and no false pairs), the attack can
succeed, and for P > 77 it is guaranteed that if there
√
7
are at least 7
P true pairs, the correct
s1 value will survive the ﬁrst phase.

12 P + 5

11
12

√

√

At the end of phase 1, the attacker obtains s1. Ad-
ditionally, since typically, only one of X1, X5, X7, X11
exceeds the threshold, say XI where I ∈ {1, 5, 7, 11},
the attacker also learns (log2 g)b mod 12 = I, as well
as ni for all pairs:

ni =

i ⊕ s1) − log2(Fi ⊕ s1))((log2 g)b)−1 mod 12
(log2(F (cid:48)
The attacker can also discard many false pairs – pairs
for which ni < 2 or ni > 8 are obviously false. Note
that discarding a false pair does not disqualify the
two individual outputs that form it. These values
may still be useful for the second and third phases,
which do not require pairs.

Phase 2 – Extracting g: We ﬁrst note a prop-
erty of Algorithm 2. The following two seeds yield
the same output sequences, and are thus indistin-
guishable:

• (x, s1, s2, a, b, g)

• (−x mod M, s1, −M − s2 mod (N − 1), a, −b

mod M, g−1 mod N )

To ﬁnd the g used in the PRNG, the attacker needs
to enumerate over all possible ϕ(N − 1) = 174744 =
217.41 values of g. But practically, the attacker is not
interested in the exact g used in the PRNG. From
the attacker’s perspective, it is enough to be able to
predict values, and for this, either the correct seed,
or the negated seed suﬃce. In other words, the at-
tacker can make do with enumerating over half of
the g space, i.e. 216.41 values – there is no need to
cover both g and g−1. With s1 from phase 1 and
with the guess of g, the attacker obtains xi + s2
mod (N − 1) = (log2 g)−1 log2(Fi ⊕ s1) mod (N − 1)
for all L values at the attacker’s disposal (the attacker
does not need pairs in this phase, just individual ﬂow
label values).

Now the attacker can use the fact that 0 ≤
xi < M , and that M is signiﬁcantly lower than

33

N − 1. This means that for the correct g, the set
{(log2 g)−1 log2(Fi ⊕ s1) mod (N − 1)} = {xi + s2
mod (N − 1)} will have a “hole” of size of at least
N − 1 − M in its coverage of [0, N − 1). A-priori, the
attacker does not know where the hole is (because
the attacker does not know s2), but the existence of
a hole whose size is at least E = N − 1 − M = 244332
can be detected even without knowing s2, by splitting
the range of N − 1 numbers into segments whose size
is no larger than E
2 . It is then guaranteed that one
of the segments will be empty. In our case, the maxi-
mal segment size is 122166, and the attacker needs 5
segments. For simplicity, the attacker can use equal-
sized segments with (cid:100) N −1
5 (cid:101) = 104854 elements each.
For each guess of g, the attacker goes over the the list
of (log2 g)−1 log2(Fi ⊕ s1) mod (N − 1) values, and
each value is divided by the segment size to ﬁnd the
corresponding segment. The attacker stops if there
are hits in all 5 segments. In such case, the attacker
discards the guess of g and moves on to the next one.
For the correct guess of g, on the other hand, there
will be at least one segment that is not a hit by all L
values.

Interestingly, due to the algebraic properties of the
series (xi), there may be incorrect g(cid:48) values that cause
clustering in the values

(log2 g(cid:48))−1 log2(Fi ⊕ s1) mod (N − 1) =

(log2 g(cid:48))−1(log2 g)(xi + s2) mod (N − 1)
This can result in “holes” large enough to become
false positives. When the (xi) series is truly random,
this is statistically impossible, given large enough L
values (e.g. L = 100), yet when (xi) is generated via
a linear congruential generator, this does happen.

The following paragraph contains an in-depth ex-
planation of this phenomenon, and the reader can
skip it if these details are not necessary.

To demonstrate such false positive, deﬁne:

γ = (log2 g(cid:48))−1 log2 g mod (N − 1)

Then the values that cluster are (γ · xi mod (N − 1))
(we can drop s2 as it is merely a shift, and so does not
aﬀect clustering). Now consider a situation wherein
γ · b and γ · M are “small” modulo N − 1 (by that

we mean they are close to either 0 or to N − 1).
Additionally, assume that

M
gcd(a − 1, M )

(cid:0)γ · gcd(a − 1, M ) mod (N − 1)(cid:1)

(cid:28) (N − 1)

M

a−1

i.e.

gcd(a−1,M ) gcd(a − 1, M ) mod M .

For simplicity, let us assume that ni = 1 and that
xi+1 =
the series is extracted sequentially,
axi + b mod M .
Now, xi+1 − xi mod M =
(a − 1)xi + b mod M and xi(a − 1) mod M =
xi
There are
gcd(a−1,M ) possible values for this expression:
only
M
{0, gcd(a − 1, M ), 2 · gcd(a − 1, M ), · · · , (
gcd(a−1,M ) −
1) gcd(a − 1, M )}. Deﬁne ∆i = xi+1 − xi (over the
integers). Then ∆i is either ti · gcd(a − 1, M ) + b or
ti ·gcd(a−1, M )+b−M or ti ·gcd(a−1, M )+b−2M ,
M
for some 0 ≤ ti <
gcd(a−1,M ) . Note that these
expressions are over the integers (not modulo M ).
When we multiply this by γ (modulo N − 1), we
get γ · ∆i mod (N − 1) = ti · (γ · gcd(a − 1, M )
mod (N − 1)) + (γ · b mod (N − 1)) − ui · (γ · M
mod (N − 1)) where 0 ≤ ti <
gcd(a−1,M ) and 0 ≤
ui ≤ 2. Each ∆i is therefore “small” (compared to
N − 1), so xi = x0 + (cid:80)i−1
j=0 ∆j mod (N − 1) does not
get too far from x0. This explains why there may be
(few) false positives.

M

At the end of phase 2, the attacker has the cor-
rect g, perhaps along with some false positives. The
attacker also knows which segment is inside the hole
(the empty segment) for each g candidate. There may
be more than one such segment, and in such case the
attacker can choose one segment arbitrarily as the
empty segment.

Phase 3 – Eliminating the g False Posi-
tives, and Finding s2 (Partially): For each g
candidate, the attacker ﬁnds the minimum Smin and
maximum Smax of the set {(log2 g)−1 log2(Fi ⊕ s1)
mod (N −1)} = {xi +s2 mod (N −1)} such that the
range [Smin, Smax] form a continuous segment over
the integers. If the set is entirely below the empty
segment, then the minimum and maximum are taken
from the set as usual. Likewise if the set is entirely
above the empty segment.
If there are elements in
the set both above and below the empty segment,

34

then the set starts above the empty segment, wraps
around (courtesy of the modulo (N − 1)) and ends
below the empty segment. Therefore, the minimum
is taken from the entries above the empty segment,
and the maximum of the set is taken from the entries
below the empty segment, to which we add N − 1 in
order to “undo” the wrap-around.

The attacker can easily eliminate almost all false
positives for g by discarding ranges larger than M ,
i.e. discard g if Smax − Smin + 1 > M . Additionally,
the attacker can apply a heuristic that eliminates ad-
ditional, very rare false positives wherein the cluster
is too “tight”, i.e. form a range which is “too small”.
For example, the attacker can eliminate g values that
suggest Smax−Smin+1 < M
2 . Empirically, this leaves
the attacker with a single (correct) g.

Now clearly, s2 ≤ Smin and Smax ≤ s2 + M − 1.
Put diﬀerently, Smax −M +1 ≤ s2 ≤ Smin (note that
above, we discarded g candidates for which Smax −
Smin + 1 > M i.e. Smax − M + 1 > Smin, therefore
we know that Smax − M + 1 ≤ Smin; also, we allow
negative values for s2 here). We see that there are
M + Smin − Smax possible values for s2. Since Smax
is distributed like a maximum of L random variables
uniformly distributed on [0, M ), E(Smax) = L
L+1 M ,
and similarly E(Smin) = 1
L+1 M . Therefore, E(M +
Smin − Smax) = 2

L+1 M .

At the end of phase 3, the attacker has a correct g
2
L+1 M candidates for s2, which is

and an average of
the range Smax − M + 1 ≤ s2 ≤ Smin.

Phase 4 – Finding a and Possible b and s2
Values: First, we make another observation on Al-
gorithm 2. Concerning the intermediate values gen-
erated in line 13, it is easy to see that the output
sequence induced by (x, a, b) is at oﬀset +k (modulo
M ) from the output sequence induced by ((x − k)
mod M, a, (b + (a − 1)k) mod M ) for any k. Let
us assume that s2 is correct, and so are (x0, a, b).
Let us now look at an incorrect guess s(cid:48)
2 = s2 + k
mod (N − 1). This guess will lead to an (incor-
rect) internal state x(cid:48)
0 = (x0 − k) mod (N − 1).
If ∀0≤i<L(0 ≤ xi − k < M ), then x(cid:48)
i = (xi − k)
0 = x0 − k with a(cid:48) =
mod M , and we can pair x(cid:48)
a, b(cid:48) = (b + (a − 1)k) mod M to form a sequence
such that ∀0≤i<L(xi + s2 mod (N − 1) = x(cid:48)
i + s(cid:48)
2

mod (N − 1)). We see, therefore, that for every k
for which ∀0≤i<L(0 ≤ xi − k < M ), it is impossible
to distinguish the correct sequence (with s2) from a
sequence generated with s2 + k. This gives rise, how-
ever, to an attack optimization. Instead of going over
all Smax − M ≤ s2 ≤ Smin, we can choose one arbi-
trarily, because every value in this range represents a
possible s(cid:48)

2 which keeps all x(cid:48)

i in [0, M ).

There is an important caveat here. While an arbi-
trary Smax − M + 1 ≤ s(cid:48)
2 ≤ Smin is indistinguishable
from the correct s2 for all the ﬂow label values already
observed, it may happen that a future x will fall out-
side the observed cyclic range [Smin − s2, Smax − s2].
In such case, an arbitrarily chosen s(cid:48)
2 may fail to pre-
dict the correct PRNG output for x. One can think of
this “out of bounds” x value as redeﬁning – reducing
– the range of possible s(cid:48)
2. At the extreme, if the at-
tacker has outputs for xi = 0, xj = M − 1, then (and
only then) the attacker will have a singleton “range”
for s(cid:48)

2, and thus s(cid:48)

2 = s2.

in expectancy of

The larger L is, the less likely a random x is to
fall outside the range.
In fact, the number of pos-
sible “out of range” values is identical to the size of
2
L+1 M , there-
the s2 range, i.e.
fore the probability for a random x to fall “out of
range” is ≈ 2
In fact, the attacker can choose
s2 = Smax−M +1+Smin
to further reduce this probabil-
ity. Note that since negative values of s2 are possible
if Smax − M + 1 < 0, we may need to apply modulo
(N − 1) to the chosen s2.

L+1 .

2

i for F (cid:48)

After choosing s2, the attacker uses pairs again, to
ﬁnd a (the correct one) and b (which matches the
chosen s2). Given s2, g, s1 and pairs (Fi, F (cid:48)
i ) of con-
secutive ﬂow label values, the attacker can calculate
xi = (log2 g)−1 log2(Fi ⊕ s1) − s2 mod (N − 1) for
every Fi, and likewise x(cid:48)
i . The attacker also
knows ni for every such pair. The attacker starts
with a mod 12 = 1 and b mod 12 = (log2 g)−1I
mod 12. At each step, the attacker extends a and
b by log2 3 bits each. The attacker does this by
deﬁning ˜a = 12ma + (a mod 12), ˜b = 12mb + (b
mod 12) where ma, mb ∈ {0, 1, 2} and going over all
9 combinations of ma, mb. For each combination of
ma, mb, i.e.
for each candidate of a mod 36 = ˜a, b
mod 36 = ˜b the attacker goes over all P pairs with

ni (cid:54)= 3 ∧ ni (cid:54)= 6 (it is easy to see that for pairs with
ni = 3 or ni = 6, all such ˜a values yield correct
results, hence they add no information), and counts
how many pairs yield a consistent result, i.e.

˜C =

|{i|x(cid:48)

i mod 36 = ˜anixi+(˜ani−1+· · ·+1)˜b mod 36}|
Since the condition holds for all true pairs, if all pairs
are true, we expect ˜C = ˜P where ˜P = |{i|ni
(cid:54)=
3 ∧ ni (cid:54)= 6}|.
If there are false pairs, we must use
a statistical approach instead. For a false pair (and
also, when the guess of ma, mb is wrong), the prob-
ability for the condition to hold, for a single pair, is
(cid:112) ˜P ). We
3 . Hence, for a wrong guess, ˜C ∼ N ( ˜P
1
3 ,
can use a threshold of 5σ again, and determine that
a guess of ma, mb is correct if
√

2
3

√

˜C ≥

+ 5

˜P
3

(cid:112) ˜P

2
3

The attacker applies this technique repeatedly. First,
the attacker calculates a mod 2233 and b mod 2233,
then a mod 2234 and b mod 2234, etc., until the at-
tacker has a mod 2237, b mod 2237. At this point,
the attacker moves to applying the same technique
with powers of two (this time, going over all pairs
(cid:54)= 8), to get a mod 2337, b
with ni
mod 2337, etc., until the attacker gets a mod 2737 =
a mod M = a, and b mod 2737 = b mod M = b.

(cid:54)= 4 ∧ ni

At

the end of

the attacker has
this phase,
s1, g, s2, a, b. With these values, and a recent sample
of the NetBSD ﬂow label, F , the attacker can pre-
dict the next value F (cid:48) of the ﬂow label – actually, the
attacker can provide 7 possible values, one of them
is guaranteed to be correct. For simplicity, we ig-
nore the MSB prediction, which is trivial, and assume
MSB=0. Then the attacker can calculate x which was
used for generating F : x = (log2 g)−1 log2(F ⊕s1)−s2
mod (N − 1). The attacker can then enumerate over
the 7 possible values of n, for each, the attacker cal-
culates x(cid:48) = anx + (an−1 + · · · + 1)b mod M , and
from that, F (cid:48) = s1 ⊕ (gx(cid:48)+s2 mod N ). In general,
given g, s1, s2, a, b and a sample F , the attacker can
roll forward the PRNG indeﬁnitely (up to reseeding,
of course).

35

Covert Channel: This cryptanalytic result can
be employed in order to implement a covert channel
between a sender and a receiver. The receiver ﬁrst
establishes around 100 consecutive TCP connections
with the target host, extracts the IPv6 ﬂow labels,
and obtains the next PRNG internal outputs using
the cryptanalytic techniques. The sender then ei-
ther establishes four TCP connections with the target
host, to signal the bit “1”, or does nothing, to signal
the bit “0”. Finally, the receiver establishes another
TCP connection with the target host, and extracts
the ﬁnal IPv6 ﬂow label. The receiver then matches
this value to the series of eight possible future val-
ues (corresponding to the PRNG internal steps). If
a match is found in positions 2-8 of the list, then the
receiver infers that the sender did not establish four
TCP connections with the target host (because each
TCP connection incurs at least two internal steps,
and the receiver’s ﬁnal connection also consumes at
least two internal steps – altogether 10 internal steps
at the minimum). This is interpreted by the receiver
as bit “0”. Otherwise, the receiver assumes the bit
sent was “1”.

For host alias resolution use case, the attacker can
improve the basic technique a bit, since the attacker
can observe the ﬂow label received from both end-
points, and match them to the same series (for end-
points that are mapped to the same host) or not (for
endpoints that are mapped to diﬀerent hosts).

A.2.3 A Covert Channel

via NetBSD
TCP/IPv6 Flow Label Most Signiﬁ-
cant Bit

We now describe an attack against the NetBSD
TCP/IPv6 ﬂow label generation, which does not
make any use of the speciﬁc algorithm that gener-
ates the least signiﬁcant 19 bits of the ﬂow label
ﬁeld. This is a more generic attack, compared to
Appendix A.2.2, but at the price of being much less
eﬃcient, in terms of number of packets (TCP connec-
tions) required.

The attack is based on the observation that a “pas-
sive” side channel exists in the ﬂow label generator,
in the form of the timing of the MSB ﬂip. When two
TCP/IPv6 services are served from a single NetBSD

host, the MSB in their ﬂow label ﬁelds will ﬂip si-
multaneously. But when the services are served from
diﬀerent NetBSD hosts, this is unlikely to happen.

We now calculate how many TCP connections are
In general, let S be the
needed to force a reseed.
internal steps the ﬂow label PRNG executed while
generating n ﬂow labels, then S is a sum of 2n IIDs
whose distribution is uniform on {1, 2, 3, 4}. There-
), and P rob(S ≥ 200000) =
fore, S ∼ N (5n,
Φ( 5n−200000
). We can thus force an immediate al-
gorithm reseed and MSB ﬂip with probability ≈ 1
by establishing n = 41000 TCP connections with the
target host.

10n
2

10n/2

√

√

This can be turned into an “active” covert channel.
The sender and receiver agree on time t0. Shortly
before t0, the sender establishes 41000 TCP connec-
tions with the target host and forces an algorithm
reseed. Then every ∆t seconds the sender either es-
tablishes 41000 TCP connections with the target host
to send the bit “1”, or does nothing to send the bit
“0”. Every ∆t seconds the receiver establishes a sin-
gle TCP connection with the target host, and ob-
serves whether the MSB bit ﬂipped (signalling the
bit “1”) or not (“0”). ∆t should be chosen such that
the sender can establish 41000 TCP connections with
the target host during this time period. Special care
must be taken if 180 seconds elapse since the last
transmission of the bit “1”, as this will cause the bit
to ﬂip due to a 180s timeout, and may thus result in
a false positive (reading bit “1” by the receiver). To
counteract this, the sender and receiver can decide
to skip the time slice in which 180s elapsed since the
previous bit “1” was transmitted.

A.3 Linux NetFilter/nftables

NetFilter is a network ﬁltering framework which is
built into the Linux kernel. NetFilter is controlled
from user space by the nftables utility (the nft com-
mand line). The NetFilter object hierarchy has tables
that contain chains of rules.

Assuming a table named override-ipid is cre-

ated, e.g. by running:

nft add table override-ipid

36

And assuming an output ﬁlter chain is created
at priority “raw” (i.e. at the IPv4 level, but before
fragmentation) is created, e.g. by running:

nft 'add rule override-ipid output ip
protocol==1 ip id set numgen random mod
65536'

nft 'add chain override-ipid output {type
filter hook output priority raw;}'

Finally, here is a very aggressive conﬁguration,
that unconditionally randomizes IPv4 ID:

Then a safe conﬁguration that only sets IPv4
ID=0 when DF=1 can be implemented by running:

nft 'add rule override-ipid output ip id
set numgen random mod 65536'

nft 'add rule override-ipid output ip
frag-off & 0x4000 != 0 ip id set 0x0000'

A more aggressive conﬁguration randomizes
IP
ID for ICMP packets, regardless of DF. This can be
implemented by running the following (in addition
to the above):

recently,

that until

Note
numgen random was
based on a weak Linux kernel random number
generator (this implementation was attacked in [30]).
A more secure version is available in kernel versions
5.19-rc4 and above, and in LTS branches starting
with versions 5.15.51 and 5.10.127. Using numgen
random in earlier versions is not recommended.

37


