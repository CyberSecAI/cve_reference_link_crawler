=== Content from lists.debian.org_22dbde1f_20250108_114459.html ===


---

[[Date Prev](msg00000.html)][[Date Next](msg00002.html)]
[[Thread Prev](msg00000.html)][[Thread Next](msg00002.html)]
[[Date Index](maillist.html#00001)]
[[Thread Index](threads.html#00001)]

# [SECURITY] [DLA 3173-1] linux-5.10 security update

---

* *To*: debian-lts-announce@lists.debian.org
* *Subject*: [SECURITY] [DLA 3173-1] linux-5.10 security update
* *From*: Ben Hutchings <benh@debian.org>
* *Date*: Tue, 01 Nov 2022 21:57:30 +0100
* *Message-id*: <[[ðŸ”Ž]](/msgid-search/0aec38207ef1e766fe4df3040c33d06da80343ec.camel%40debian.org)Â [0aec38207ef1e766fe4df3040c33d06da80343ec.camel@debian.org](msg00001.html)>
* *Mail-followup-to*: debian-lts@lists.debian.org
* *Reply-to*: debian-lts@lists.debian.org

---

```
-------------------------------------------------------------------------
Debian LTS Advisory DLA-3173-1                debian-lts@lists.debian.org
<https://www.debian.org/lts/security/>                        Ben Hutchings
November 1, 2022                              <https://wiki.debian.org/LTS>
-------------------------------------------------------------------------

Package        : linux-5.10
Version        : 5.10.149-2~deb10u1
CVE ID         : CVE-2021-4037 CVE-2022-0171 CVE-2022-1184 CVE-2022-1679
                 CVE-2022-2153 CVE-2022-2602 CVE-2022-2663 CVE-2022-2905
                 CVE-2022-3028 CVE-2022-3061 CVE-2022-3176 CVE-2022-3303
                 CVE-2022-3586 CVE-2022-3621 CVE-2022-3625 CVE-2022-3629
                 CVE-2022-3633 CVE-2022-3635 CVE-2022-3646 CVE-2022-3649
                 CVE-2022-20421 CVE-2022-20422 CVE-2022-39188 CVE-2022-39190
                 CVE-2022-39842 CVE-2022-40307 CVE-2022-41222 CVE-2022-41674
                 CVE-2022-42719 CVE-2022-42720 CVE-2022-42721 CVE-2022-42722
                 CVE-2022-43750
Debian Bug     : 1017425 1019248

Several vulnerabilities have been discovered in the Linux kernel that
may lead to a privilege escalation, denial of service or information
leaks.

CVE-2021-4037

    Christian Brauner reported that the inode_init_owner function for
    the XFS filesystem in the Linux kernel allows local users to
    create files with an unintended group ownership allowing attackers
    to escalate privileges by making a plain file executable and SGID.

CVE-2022-0171

    Mingwei Zhang reported that a cache incoherence issue in the SEV
    API in the KVM subsystem may result in denial of service.

CVE-2022-1184

    A flaw was discovered in the ext4 filesystem driver which can lead
    to a use-after-free. A local user permitted to mount arbitrary
    filesystems could exploit this to cause a denial of service (crash
    or memory corruption) or possibly for privilege escalation.

CVE-2022-1679

    The syzbot tool found a race condition in the ath9k_htc driver
    which can lead to a use-after-free.  This might be exploitable to
    cause a denial service (crash or memory corruption) or possibly
    for privilege escalation.

CVE-2022-2153

    "kangel" reported a flaw in the KVM implementation for x86
    processors which could lead to a null pointer dereference. A local
    user permitted to access /dev/kvm could exploit this to cause a
    denial of service (crash).

CVE-2022-2602

    A race between handling an io_uring request and the Unix socket
    garbage collector was discovered. An attacker can take advantage
    of this flaw for local privilege escalation.

CVE-2022-2663

    David Leadbeater reported flaws in the nf_conntrack_irc
    connection-tracking protocol module. When this module is enabled
    on a firewall, an external user on the same IRC network as an
    internal user could exploit its lax parsing to open arbitrary TCP
    ports in the firewall, to reveal their public IP address, or to
    block their IRC connection at the firewall.

CVE-2022-2905

    Hsin-Wei Hung reported a flaw in the eBPF verifier which can lead
    to an out-of-bounds read.  If unprivileged use of eBPF is enabled,
    this could leak sensitive information.  This was already disabled
    by default, which would fully mitigate the vulnerability.

CVE-2022-3028

    Abhishek Shah reported a race condition in the AF_KEY subsystem,
    which could lead to an out-of-bounds write or read.  A local user
    could exploit this to cause a denial of service (crash or memory
    corruption), to obtain sensitive information, or possibly for
    privilege escalation.

CVE-2022-3061

    A flaw was discovered in the i740 driver which may result in
    denial of service.

    This driver is not enabled in Debian's official kernel
    configurations.

CVE-2022-3176

    A use-after-free flaw was discovered in the io_uring subsystem
    which may result in local privilege escalation to root.

CVE-2022-3303

    A race condition in the snd_pcm_oss_sync function in the sound
    subsystem in the Linux kernel due to improper locking may result
    in denial of service.

CVE-2022-3586 (ZDI-22-1452)

    The Zero Day Initiative reported a flaw in the sch_sfb network
    scheduler, which may lead to a use-after-free and leak of
    sensitive information from the kernel.

CVE-2022-3621, CVE-2022-3646

    The syzbot tool found flaws in the nilfs2 filesystem driver which
    can lead to a null pointer dereference or memory leak.  A user
    permitted to mount arbitrary filesystem images could use these to
    cause a denial of service (crash or resource exhaustion).

CVE-2022-3625

    A flaw was discovered in the devlink subsystem which can lead to
    a use-after-free.  The security impact of this is unclear.

CVE-2022-3629

    The syzbot tool found a memory leak in the Virtual Socket Protocol
    implementation.  A local user could exploit this to cause a denial
    of service (resource exhaustion).

CVE-2022-3633

    The Linux Verification Center found a memory leak in the SAE J1939
    protocol implementation.  A local user could exploit this to cause
    a denial of service (resource exhaustion).

CVE-2022-3635

    Several race conditions were discovered in the idt77252 ATM
    driver, which can lead to a use-after-free if the module is
    removed.  The security impact of this is unclear.

CVE-2022-3649

    The syzbot tool found flaws in the nilfs2 filesystem driver which
    can lead to a use-after-free.  A user permitted to mount arbitrary
    filesystem images could use these to cause a denial of service
    (crash or memory corruption) or possibly for privilege escalation.

CVE-2022-20421

    A use-after-free vulnerability was discovered in the
    binder_inc_ref_for_node function in the Android binder driver. On
    systems where the binder driver is loaded, a local user could
    exploit this for privilege escalation.

CVE-2022-20422

    A race condition was discovered in the instruction emulator for
    64-bit Arm systems.  Concurrent changes to the sysctls that
    control the emulator could result in a null pointer dereference.
    The security impact of this is unclear.

CVE-2022-39188

    Jann Horn reported a race condition in the kernel's handling of
    unmapping of certain memory ranges. When a driver created a memory
    mapping with the VM_PFNMAP flag, which many GPU drivers do, the
    memory mapping could be removed and freed before it was flushed
    from the CPU TLBs. This could result in a page use-after-free. A
    local user with access to such a device could exploit this to
    cause a denial of service (crash or memory corruption) or possibly
    for privilege escalation.

CVE-2022-39190

    Gwangun Jung reported a flaw in the nf_tables subsystem.  A local
    user could exploit this to cause a denial of service (crash).

CVE-2022-39842

    An integer overflow was discovered in the pxa3xx-gcu video driver
    which could lead to a heap out-of-bounds write.

    This driver is not enabled in Debian's official kernel
    configurations.

CVE-2022-40307

    A race condition was discovered in the EFI capsule-loader driver,
    which could lead to use-after-free. A local user permitted to
    access this device (/dev/efi_capsule_loader) could exploit this to
    cause a denial of service (crash or memory corruption) or possibly
    for privilege escalation. However, this device is normally only
    accessible by the root user.

CVE-2022-41222

    A race condition was discovered in the memory management subsystem
    that can lead to stale TLB entries.  A local user could exploit
    this to cause a denial of service (memory corruption or crash),
    information leak, or privilege escalation.

CVE-2022-41674, CVE-2022-42719, CVE-2022-42720, CVE-2022-42721,
CVE-2022-42722

    Soenke Huster discovered several vulnerabilities in the mac80211
    subsystem triggered by WLAN frames which may result in denial of
    service or the execution of arbitrary code.

CVE-2022-43750

    The syzbot tool found that the USB monitor (usbmon) driver allowed
    user-space programs to overwrite the driver's data structures.  A
    local user permitted to access a USB monitor device could exploit
    this to cause a denial of service (memory corruption or crash) or
    possibly for privilege escalation.  However, by default only the
    root user can access such devices.

For Debian 10 buster, these problems have been fixed in version
5.10.149-2~deb10u1.  This update also fixes a regression for some
older 32-bit PCs (bug #1017425), and enables the i10nm_edac driver
(bug #1019248).  It additionally includes many more bug fixes from
stable updates 5.10.137-5.10.149 inclusive.

We recommend that you upgrade your linux-5.10 packages.

For the detailed security status of linux-5.10 please refer to
its security tracker page at:
<https://security-tracker.debian.org/tracker/linux-5.10>

Further information about Debian LTS security advisories, how to apply
these updates to your system and frequently asked questions can be
found at: <https://wiki.debian.org/LTS>

--
Ben Hutchings - Debian developer, member of kernel, installer and LTS teams

```

**Attachment:
[signature.asc](pgpf2IA2J90bh.pgp)**

*Description:* This is a digitally signed message part

---



=== Content from access.redhat.com_b6c7079a_20250108_114457.html ===


[Skip to navigation](#pfe-navigation)
[Skip to main content](#cp-main)
### Utilities

* [Subscriptions](https://access.redhat.com/management/)
* [Downloads](https://access.redhat.com/downloads/)
* [Red Hat Console](//console.redhat.com/)
* [Get Support](https://access.redhat.com/support/)

[![Red Hat Customer Portal](https://access.redhat.com/chrome_themes/nimbus/img/red-hat-customer-portal.svg)](https://access.redhat.com/)

* [Subscriptions](https://access.redhat.com/management/)
* [Downloads](https://access.redhat.com/downloads/)
* [Red Hat Console](//console.redhat.com/)
* [Get Support](https://access.redhat.com/support/)
* [Products](https://access.redhat.com/)
  ### Top Products

  + [Red Hat Enterprise Linux](https://access.redhat.com/products/red-hat-enterprise-linux/)
  + [Red Hat OpenShift](https://access.redhat.com/products/red-hat-openshift-container-platform)
  + [Red Hat Ansible Automation Platform](https://access.redhat.com/products/red-hat-ansible-automation-platform/)
  [All Products](https://access.redhat.com/products/)

  ### Downloads and Containers

  + [Downloads](https://access.redhat.com/downloads/)
  + [Packages](https://access.redhat.com/downloads/content/package-browser)
  + [Containers](https://catalog.redhat.com/software/containers/explore/)
  ### Top Resources

  + [Documentation](//docs.redhat.com/)
  + [Product Life Cycles](https://access.redhat.com/product-life-cycles/)
  + [Product Compliance](https://access.redhat.com/articles/1202803)
  + [Errata](https://access.redhat.com/errata/)
* [Knowledge](https://access.redhat.com/labs/)
  ### Red Hat Knowledge Center

  + [Knowledgebase Solutions](https://access.redhat.com/search/?q=*&p=1&rows=10&documentKind=Solution)
  + [Knowledgebase Articles](https://access.redhat.com/search/?q=*&p=1&rows=10&documentKind=Article)
  + [Customer Portal Labs](https://access.redhat.com/labs/)
  + [Errata](https://access.redhat.com/errata/)
  ### Top Product Docs

  + [Red Hat Enterprise Linux](//docs.redhat.com/en/documentation/red_hat_enterprise_linux/)
  + [Red Hat OpenShift](//docs.redhat.com/en/documentation/openshift_container_platform/)
  + [Red Hat Ansible Automation Platform](//docs.redhat.com/en/documentation/red_hat_ansible_automation_platform/)
  [All Product Docs](//docs.redhat.com/en/products)

  ### [Training and Certification](//www.redhat.com/en/services/training-and-certification)

  + [About](//www.redhat.com/en/services/training-and-certification)
  + [Course Index](//www.redhat.com/en/services/training/all-courses-exams)
  + [Certification Index](//www.redhat.com/en/services/certifications)
  + [Skill Assessment](//skills.ole.redhat.com/)
* [Security](https://access.redhat.com/security/)
  ### [Red Hat Product Security Center](https://access.redhat.com/security)

  + [Security Updates](https://access.redhat.com/security)
  + [Security Advisories](https://access.redhat.com/security/security-updates/#/security-advisories)
  + [Red Hat CVE Database](https://access.redhat.com/security/security-updates/#/cve)
  + [Errata](https://access.redhat.com/errata/)
  ### References

  + [Security Bulletins](https://access.redhat.com/security/vulnerabilities)
  + [Security Measurement](https://www.redhat.com/security/data/metrics/)
  + [Severity Ratings](https://access.redhat.com/security/updates/classification/)
  + [Security Data](https://access.redhat.com/security/data)
  ### Top Resources

  + [Security Labs](https://access.redhat.com/security/security-updates/#/security-labs)
  + [Backporting Policies](https://access.redhat.com/security/updates/backporting/)
  + [Security Blog](//redhat.com/en/blog/channel/security)
* [Support](https://access.redhat.com/support/)
  ### [Red Hat Support](https://access.redhat.com/support/)

  + [Support Cases](https://access.redhat.com/support/cases/)
  + [Troubleshoot](https://access.redhat.com/support/cases/#/troubleshoot)
  + [Get Support](https://access.redhat.com/support/)
  + [Contact Red Hat Support](https://access.redhat.com/support/contact/)
  ### [Red Hat Community Support](https://access.redhat.com/community)

  + [Customer Portal Community](https://access.redhat.com/community/)
  + [Community Discussions](https://access.redhat.com/discussions/)
  + [Red Hat Accelerator Program](https://access.redhat.com/accelerators/)
  ### Top Resources

  + [Product Life Cycles](https://access.redhat.com/product-life-cycles/)
  + [Customer Portal Labs](https://access.redhat.com/labs/)
  + [Red Hat JBoss Supported Configurations](https://access.redhat.com/support/configurations/jboss)
  + [Red Hat Insights](https://cloud.redhat.com/insights)

Or [troubleshoot an issue](/support/cases/#/troubleshoot).

English

## Select Your Language

* [English](https://access.redhat.com/changeLanguage?language=en)
* [FranÃ§ais](https://access.redhat.com/changeLanguage?language=fr)
* [í•œêµ­ì–´](https://access.redhat.com/changeLanguage?language=ko)
* [æ—¥æœ¬èªž](https://access.redhat.com/changeLanguage?language=ja)
* [ä¸­æ–‡ (ä¸­å›½)](https://access.redhat.com/changeLanguage?language=zh_CN)

### Infrastructure and Management

* [Red Hat Enterprise Linux](https://access.redhat.com/products/red-hat-enterprise-linux/)
* [Red Hat Satellite](https://access.redhat.com/products/red-hat-satellite/)
* [Red Hat Subscription Management](https://access.redhat.com/products/red-hat-subscription-management/)
* [Red Hat Insights](https://access.redhat.com/products/red-hat-insights/)
* [Red Hat Ansible Automation Platform](https://access.redhat.com/products/red-hat-ansible-automation-platform/)
### Cloud Computing

* [Red Hat OpenShift](https://access.redhat.com/products/red-hat-openshift-container-platform)
* [Red Hat OpenStack Platform](https://access.redhat.com/products/red-hat-openstack-platform/)
* [Red Hat OpenShift](https://access.redhat.com/products/red-hat-openshift-container-platform/)
* [Red Hat OpenShift AI](https://access.redhat.com/products/red-hat-openshift-ai/)
* [Red Hat OpenShift Dedicated](https://access.redhat.com/products/openshift-dedicated-red-hat/)
* [Red Hat Advanced Cluster Security for Kubernetes](https://access.redhat.com/products/red-hat-advanced-cluster-security-for-kubernetes/)
* [Red Hat Advanced Cluster Management for Kubernetes](https://access.redhat.com/products/red-hat-advanced-cluster-management-for-kubernetes/)
* [Red Hat Quay](https://access.redhat.com/products/red-hat-quay/)
* [Red Hat OpenShift Dev Spaces](https://access.redhat.com/products/red-hat-openshift-dev-spaces)
* [Red Hat OpenShift Service on AWS](https://access.redhat.com/products/red-hat-openshift-service-aws)
### Storage

* [Red Hat Gluster Storage](https://access.redhat.com/products/red-hat-storage/)
* [Red Hat Hyperconverged Infrastructure](https://access.redhat.com/products/red-hat-hyperconverged-infrastructure/)
* [Red Hat Ceph Storage](https://access.redhat.com/products/red-hat-ceph-storage/)
* [Red Hat OpenShift Data Foundation](https://access.redhat.com/products/red-hat-openshift-data-foundation)
### Runtimes

* [Red Hat Runtimes](https://access.redhat.com/products/red-hat-runtimes/)
* [Red Hat JBoss Enterprise Application Platform](https://access.redhat.com/products/red-hat-jboss-enterprise-application-platform/)
* [Red Hat Data Grid](https://access.redhat.com/products/red-hat-data-grid/)
* [Red Hat JBoss Web Server](https://access.redhat.com/products/red-hat-jboss-web-server/)
* [Red Hat build of Keycloak](https://access.redhat.com/products/red-hat-build-of-keycloak/)
* [Red Hat support for Spring Boot](https://access.redhat.com/products/spring-boot/)
* [Red Hat build of Node.js](https://access.redhat.com/products/nodejs/)
* [Red Hat build of Quarkus](https://access.redhat.com/products/quarkus/)
### Integration and Automation

* [Red Hat Application Foundations](https://access.redhat.com/products/red-hat-application-foundations/)
* [Red Hat Fuse](https://access.redhat.com/products/red-hat-fuse/)
* [Red Hat AMQ](https://access.redhat.com/products/red-hat-amq/)
* [Red Hat 3scale API Management](https://access.redhat.com/products/red-hat-3scale/)

[All Products](https://access.redhat.com/products/)

**We're sorry but cve-details doesn't work properly without JavaScript enabled. Please enable it to continue.**

[![Red Hat](https://static.redhat.com/libs/redhat/brand-assets/2/corp/logo--on-dark.svg)](https://redhat.com/en)
[X (formerly Twitter)](https://twitter.com/RedHat)
### Quick Links

* [Downloads](https://access.redhat.com/downloads/)
* [Subscriptions](https://access.redhat.com/management)
* [Support Cases](https://access.redhat.com/support)
* [Customer Service](https://access.redhat.com/support/customer-service)
* [Product Documentation](//docs.redhat.com/)

### Help

* [Contact Us](https://access.redhat.com/support/contact/)
* [Customer Portal FAQ](https://access.redhat.com/articles/33844)
* [Log-in Assistance](https://access.redhat.com/help/login_assistance)

### Site Info

* [Trust Red Hat](https://www.redhat.com/en/trust)
* [Browser Support Policy](https://www.redhat.com/en/about/browser-support)
* [Accessibility](https://www.redhat.com/en/about/digital-accessibility)
* [Awards and Recognition](https://access.redhat.com/recognition/)
* [Colophon](https://access.redhat.com/help/colophon/)

### Related Sites

* [redhat.com](https://www.redhat.com/)
* [developers.redhat.com](http://developers.redhat.com/)
* [connect.redhat.com](https://connect.redhat.com/)
* [cloud.redhat.com](https://cloud.redhat.com/)

### Red Hat legal and privacy links

* [About Red Hat](https://redhat.com/en/about/company)
* [Jobs](https://redhat.com/en/jobs)
* [Events](https://redhat.com/en/events)
* [Locations](https://redhat.com/en/about/office-locations)
* [Contact Red Hat](https://redhat.com/en/contact)
* [Red Hat Blog](https://redhat.com/en/blog)
* [Diversity, equity, and inclusion](https://redhat.com/en/about/our-culture/diversity-equity-inclusion)
* [Cool Stuff Store](https://coolstuff.redhat.com/)
* [Red Hat Summit](https://www.redhat.com/en/summit)

 Â© 2024 Red Hat, Inc.
### Red Hat legal and privacy links

* [Privacy statement](https://redhat.com/en/about/privacy-policy)
* [Terms of use](https://redhat.com/en/about/terms-use)
* [All policies and guidelines](https://redhat.com/en/about/all-policies-guidelines)
* [Digital accessibility](https://redhat.com/en/about/digital-accessibility)



=== Content from www.debian.org_a83d6985_20250108_114459.html ===


---

[[Date Prev](msg00225.html)][[Date Next](msg00227.html)]
[[Thread Prev](msg00225.html)][[Thread Next](msg00227.html)]
[[Date Index](maillist.html#00226)]
[[Thread Index](threads.html#00226)]

# [SECURITY] [DSA 5257-1] linux security update

---

* *To*: debian-security-announce@lists.debian.org
* *Subject*: [SECURITY] [DSA 5257-1] linux security update
* *From*: Salvatore Bonaccorso <carnil@debian.org>
* *Date*: Tue, 18 Oct 2022 21:06:43 +0000
* *Message-id*: <[[ðŸ”Ž]](/msgid-search/E1oktnP-00COmg-5r%40seger.debian.org)Â [E1oktnP-00COmg-5r@seger.debian.org](msg00226.html)>
* *Reply-to*: debian-security-announce-request@lists.debian.org

---

```
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

- -------------------------------------------------------------------------
Debian Security Advisory DSA-5257-1                   security@debian.org
<https://www.debian.org/security/>                     Salvatore Bonaccorso
October 18, 2022                      <https://www.debian.org/security/faq>
- -------------------------------------------------------------------------

Package        : linux
CVE ID         : CVE-2021-4037 CVE-2022-0171 CVE-2022-1184 CVE-2022-2602
                 CVE-2022-2663 CVE-2022-3061 CVE-2022-3176 CVE-2022-3303
                 CVE-2022-20421 CVE-2022-39188 CVE-2022-39842 CVE-2022-40307
                 CVE-2022-41674 CVE-2022-42719 CVE-2022-42720 CVE-2022-42721
                 CVE-2022-42722

Several vulnerabilities have been discovered in the Linux kernel that
may lead to a privilege escalation, denial of service or information
leaks.

CVE-2021-4037

    Christian Brauner reported that the inode_init_owner function for
    the XFS filesystem in the Linux kernel allows local users to create
    files with an unintended group ownership allowing attackers to
    escalate privileges by making a plain file executable and SGID.

CVE-2022-0171

    Mingwei Zhang reported that a cache incoherence issue in the SEV API
    in the KVM subsystem may result in denial of service.

CVE-2022-1184

    A flaw was discovered in the ext4 filesystem driver which can lead
    to a use-after-free. A local user permitted to mount arbitrary
    filesystems could exploit this to cause a denial of service (crash
    or memory corruption) or possibly for privilege escalation.

CVE-2022-2602

    A race between handling an io_uring request and the Unix socket
    garbage collector was discovered. An attacker can take advantage of
    this flaw for local privilege escalation.

CVE-2022-2663

    David Leadbeater reported flaws in the nf_conntrack_irc
    connection-tracking protocol module.  When this module is enabled
    on a firewall, an external user on the same IRC network as an
    internal user could exploit its lax parsing to open arbitrary TCP
    ports in the firewall, to reveal their public IP address, or to
    block their IRC connection at the firewall.

CVE-2022-3061

    A flaw was discovered in the i740 driver which may result in denial
    of service.

    This driver is not enabled in Debian's official kernel
    configurations.

CVE-2022-3176

    A use-after-free flaw was discovered in the io_uring subsystem which
    may result in local privilege escalation to root.

CVE-2022-3303

    A race condition in the snd_pcm_oss_sync function in the sound
    subsystem in the Linux kernel due to improper locking may result in
    denial of service.

CVE-2022-20421

    A use-after-free vulnerability was discovered in the
    binder_inc_ref_for_node function in the Android binder driver. On
    systems where the binder driver is loaded, a local user could
    exploit this for privilege escalation.

CVE-2022-39188

    Jann Horn reported a race condition in the kernel's handling of
    unmapping of certain memory ranges.  When a driver created a
    memory mapping with the VM_PFNMAP flag, which many GPU drivers do,
    the memory mapping could be removed and freed before it was
    flushed from the CPU TLBs.  This could result in a page use-after-
    free.  A local user with access to such a device could exploit
    this to cause a denial of service (crash or memory corruption) or
    possibly for privilege escalation.

CVE-2022-39842

    An integer overflow was discovered in the pxa3xx-gcu video driver
    which could lead to a heap out-of-bounds write.

    This driver is not enabled in Debian's official kernel
    configurations.

CVE-2022-40307

    A race condition was discovered in the EFI capsule-loader driver,
    which could lead to use-after-free.  A local user permitted to
    access this device (/dev/efi_capsule_loader) could exploit this to
    cause a denial of service (crash or memory corruption) or possibly
    for privilege escalation.  However, this device is normally only
    accessible by the root user.

CVE-2022-41674, CVE-2022-42719, CVE-2022-42720, CVE-2022-42721, CVE-2022-42722

    Soenke Huster discovered several vulnerabilities in the mac80211
    subsystem triggered by WLAN frames which may result in denial of
    service or the execution or arbitrary code.

For the stable distribution (bullseye), these problems have been fixed in
version 5.10.149-1.

We recommend that you upgrade your linux packages.

For the detailed security status of linux please refer to its security
tracker page at:
<https://security-tracker.debian.org/tracker/linux>

Further information about Debian Security Advisories, how to apply
these updates to your system and frequently asked questions can be
found at: <https://www.debian.org/security/>

Mailing list: debian-security-announce@lists.debian.org
-----BEGIN PGP SIGNATURE-----

iQKTBAEBCgB9FiEERkRAmAjBceBVMd3uBUy48xNDz0QFAmNPFS5fFIAAAAAALgAo
aXNzdWVyLWZwckBub3RhdGlvbnMub3BlbnBncC5maWZ0aGhvcnNlbWFuLm5ldDQ2
NDQ0MDk4MDhDMTcxRTA1NTMxRERFRTA1NENCOEYzMTM0M0NGNDQACgkQBUy48xND
z0Q8oBAAh2sxVENkXNYsl1xX4jU6yCJ/vLuG8HklJE+cChdxFSwjrz5fE9Y36viE
4M08WedXuAuSRKT9pCvPvvv+YNdjUaTIMHHLxCbWmWPfPboz6GRqk0RFEKABZe1t
M5W9CqEYgp9LRTPyOYFoOpMSnWQ1a3XyhLHSl2hUX9bw1GC5ovCKpUNoZ+FE0v90
v9uqM+8zdXmxe1tbAmjndCYzOoT9vaqqlU5OAaWQpqozRsa8Rv6/XiJ6mMVk8DUU
QFLoGVqoIeWRc6CYSzzNeAVOX8v4vScILk/FW1HW/WfhrqCFBwEORo4jz/2o49HN
4h/HxGlWtj/yiCUvRMR6RkQGJJOEr9vQa8Boe9z5rLzCQAPDZplp9iSu1/sdSqtV
C1wJNaTfB8di1vwEUAra/bHTty7rUwc0rPBTmKFxwnPW0IOyX4Nsb4lSsbSRtnHm
+80T8+WFWT0CMKpwOkP4GzwlZ9h7MeAKHwZpyyHc+84IS4RKl0SDkaHY/aOQ9pYB
vrl2CV+hSxw/YzpeF9w56LQ6YWzO27NmUid0nw+YFcSc0D35hvsFo+AsQ4Kkdc4p
94SkSq7zuhtdZDh1D5ZtBDfryxG2xWzgAEKcCyNTHW19iZO50K+YHzLbWzom9J6h
hI8jM/zBEGvZD8EdM3Vc710+QF6Yie1zOLNDRxNj0Zfu+0k1uXo=
=gJNm
-----END PGP SIGNATURE-----

```

---



=== Content from git.kernel.org_dfaff4fa_20250108_151246.html ===


| [cgit logo](/) | [index](/) : [kernel/git/torvalds/linux.git](/pub/scm/linux/kernel/git/torvalds/linux.git/) | for-next master vsnprintf |
| --- | --- | --- |
| Linux kernel source tree | Linus Torvalds |

| [about](/pub/scm/linux/kernel/git/torvalds/linux.git/about/)[summary](/pub/scm/linux/kernel/git/torvalds/linux.git/)[refs](/pub/scm/linux/kernel/git/torvalds/linux.git/refs/?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)[log](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)[tree](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)[commit](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)[diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)[stats](/pub/scm/linux/kernel/git/torvalds/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Linus Torvalds <torvalds@linux-foundation.org> | 2022-04-22 17:58:36 -0700 |
| --- | --- | --- |
| committer | Linus Torvalds <torvalds@linux-foundation.org> | 2022-04-22 17:58:36 -0700 |
| commit | [bb4ce2c65881a2b9bdcd384f54a260a12a89dd91](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) ([patch](/pub/scm/linux/kernel/git/torvalds/linux.git/patch/?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)) | |
| tree | [ec4d74f4a0097bc661059b4b35261024b3a3fde2](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | |
| parent | [06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91&id2=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)) | |
| parent | [e852be8b148e117e25be1c98cf72ee489b05919e](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e852be8b148e117e25be1c98cf72ee489b05919e) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91&id2=e852be8b148e117e25be1c98cf72ee489b05919e)) | |
| download | [linux-bb4ce2c65881a2b9bdcd384f54a260a12a89dd91.tar.gz](/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-bb4ce2c65881a2b9bdcd384f54a260a12a89dd91.tar.gz) | |

Merge tag 'for-linus' of git://git.kernel.org/pub/scm/virt/kvm/kvmPull kvm fixes from Paolo Bonzini:
"The main and larger change here is a workaround for AMD's lack of
cache coherency for encrypted-memory guests.
I have another patch pending, but it's waiting for review from the
architecture maintainers.
RISC-V:
- Remove 's' & 'u' as valid ISA extension
- Do not allow disabling the base extensions 'i'/'m'/'a'/'c'
x86:
- Fix NMI watchdog in guests on AMD
- Fix for SEV cache incoherency issues
- Don't re-acquire SRCU lock in complete\_emulated\_io()
- Avoid NULL pointer deref if VM creation fails
- Fix race conditions between APICv disabling and vCPU creation
- Bugfixes for disabling of APICv
- Preserve BSP MSR\_KVM\_POLL\_CONTROL across suspend/resume
selftests:
- Do not use bitfields larger than 32-bits, they differ between GCC
and clang"
\* tag 'for-linus' of git://git.kernel.org/pub/scm/virt/kvm/kvm:
kvm: selftests: introduce and use more page size-related constants
kvm: selftests: do not use bitfields larger than 32-bits for PTEs
KVM: SEV: add cache flush to solve SEV cache incoherency issues
KVM: SVM: Flush when freeing encrypted pages even on SME\_COHERENT CPUs
KVM: SVM: Simplify and harden helper to flush SEV guest page(s)
KVM: selftests: Silence compiler warning in the kvm\_page\_table\_test
KVM: x86/pmu: Update AMD PMC sample period to fix guest NMI-watchdog
x86/kvm: Preserve BSP MSR\_KVM\_POLL\_CONTROL across suspend/resume
KVM: SPDX style and spelling fixes
KVM: x86: Skip KVM\_GUESTDBG\_BLOCKIRQ APICv update if APICv is disabled
KVM: x86: Pend KVM\_REQ\_APICV\_UPDATE during vCPU creation to fix a race
KVM: nVMX: Defer APICv updates while L2 is active until L1 is active
KVM: x86: Tag APICv DISABLE inhibit, not ABSENT, if APICv is disabled
KVM: Initialize debugfs\_dentry when a VM is created to avoid NULL deref
KVM: Add helpers to wrap vcpu->srcu\_idx and yell if it's abused
KVM: RISC-V: Use kvm\_vcpu.srcu\_idx, drop RISC-V's unnecessary copy
KVM: x86: Don't re-acquire SRCU lock in complete\_emulated\_io()
RISC-V: KVM: Restrict the extensions that can be disabled
RISC-V: KVM: Remove 's' & 'u' as valid ISA extension
[Diffstat](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)

| -rw-r--r-- | [arch/powerpc/kvm/book3s\_64\_mmu\_radix.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/powerpc/kvm/book3s_64_mmu_radix.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 9 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [arch/powerpc/kvm/book3s\_hv\_nested.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/powerpc/kvm/book3s_hv_nested.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 16 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/powerpc/kvm/book3s\_rtas.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/powerpc/kvm/book3s_rtas.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/powerpc/kvm/powerpc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/powerpc/kvm/powerpc.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/riscv/include/asm/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/riscv/include/asm/kvm_host.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/riscv/kvm/vcpu.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/riscv/kvm/vcpu.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 37 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/riscv/kvm/vcpu\_exit.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/riscv/kvm/vcpu_exit.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/s390/kvm/interrupt.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/s390/kvm/interrupt.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/s390/kvm/kvm-s390.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/s390/kvm/kvm-s390.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/s390/kvm/vsie.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/s390/kvm/vsie.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/include/asm/kvm-x86-ops.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/include/asm/kvm-x86-ops.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/include/asm/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/include/asm/kvm_host.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kernel/kvm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kernel/kvm.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 13 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/pmu.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kvm/pmu.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 9 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/svm/pmu.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kvm/svm/pmu.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/svm/sev.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kvm/svm/sev.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 67 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/svm/svm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kvm/svm/svm.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/svm/svm.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kvm/svm/svm.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/vmx/nested.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kvm/vmx/nested.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/vmx/pmu\_intel.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kvm/vmx/pmu_intel.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/vmx/vmx.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kvm/vmx/vmx.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/vmx/vmx.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kvm/vmx/vmx.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/x86.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kvm/x86.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 60 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/linux/kvm_host.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 26 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/kvm/include/x86\_64/processor.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/tools/testing/selftests/kvm/include/x86_64/processor.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 17 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/kvm/kvm\_page\_table\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/tools/testing/selftests/kvm/kvm_page_table_test.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/kvm/lib/x86\_64/processor.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/tools/testing/selftests/kvm/lib/x86_64/processor.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 202 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/kvm/x86\_64/amx\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/tools/testing/selftests/kvm/x86_64/amx_test.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/kvm/x86\_64/emulator\_error\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/tools/testing/selftests/kvm/x86_64/emulator_error_test.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/kvm/x86\_64/smm\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/tools/testing/selftests/kvm/x86_64/smm_test.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/kvm/x86\_64/vmx\_tsc\_adjust\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/tools/testing/selftests/kvm/x86_64/vmx_tsc_adjust_test.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/kvm/x86\_64/xen\_shinfo\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/tools/testing/selftests/kvm/x86_64/xen_shinfo_test.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/kvm/x86\_64/xen\_vmcall\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/tools/testing/selftests/kvm/x86_64/xen_vmcall_test.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [virt/kvm/dirty\_ring.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/virt/kvm/dirty_ring.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [virt/kvm/kvm\_main.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/virt/kvm/kvm_main.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 43 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [virt/kvm/kvm\_mm.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/virt/kvm/kvm_mm.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 2 | |  |  |  | | --- | --- | --- | |

36 files changed, 316 insertions, 252 deletions

| diff --git a/arch/powerpc/kvm/book3s\_64\_mmu\_radix.c b/arch/powerpc/kvm/book3s\_64\_mmu\_radix.cindex e4ce2a35483f6f..42851c32ff3bee 100644--- a/[arch/powerpc/kvm/book3s\_64\_mmu\_radix.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/powerpc/kvm/book3s_64_mmu_radix.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/powerpc/kvm/book3s\_64\_mmu\_radix.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/powerpc/kvm/book3s_64_mmu_radix.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -168,9 +168,10 @@ int kvmppc\_mmu\_walk\_radix\_tree(struct kvm\_vcpu \*vcpu, gva\_t eaddr, return -EINVAL; /\* Read the entry from guest memory \*/ addr = base + (index \* sizeof(rpte));- vcpu->srcu\_idx = srcu\_read\_lock(&kvm->srcu);++ kvm\_vcpu\_srcu\_read\_lock(vcpu); ret = kvm\_read\_guest(kvm, addr, &rpte, sizeof(rpte));- srcu\_read\_unlock(&kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); if (ret) { if (pte\_ret\_p) \*pte\_ret\_p = addr;@@ -246,9 +247,9 @@ int kvmppc\_mmu\_radix\_translate\_table(struct kvm\_vcpu \*vcpu, gva\_t eaddr,  /\* Read the table to find the root of the radix tree \*/ ptbl = (table & PRTB\_MASK) + (table\_index \* sizeof(entry));- vcpu->srcu\_idx = srcu\_read\_lock(&kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu); ret = kvm\_read\_guest(kvm, ptbl, &entry, sizeof(entry));- srcu\_read\_unlock(&kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); if (ret) return ret; diff --git a/arch/powerpc/kvm/book3s\_hv\_nested.c b/arch/powerpc/kvm/book3s\_hv\_nested.cindex 9d373f8963ee98..c943a051c6e700 100644--- a/[arch/powerpc/kvm/book3s\_hv\_nested.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/powerpc/kvm/book3s_hv_nested.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/powerpc/kvm/book3s\_hv\_nested.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/powerpc/kvm/book3s_hv_nested.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -306,10 +306,10 @@ long kvmhv\_enter\_nested\_guest(struct kvm\_vcpu \*vcpu) /\* copy parameters in \*/ hv\_ptr = kvmppc\_get\_gpr(vcpu, 4); regs\_ptr = kvmppc\_get\_gpr(vcpu, 5);- vcpu->srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu); err = kvmhv\_read\_guest\_state\_and\_regs(vcpu, &l2\_hv, &l2\_regs, hv\_ptr, regs\_ptr);- srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); if (err) return H\_PARAMETER; @@ -410,10 +410,10 @@ long kvmhv\_enter\_nested\_guest(struct kvm\_vcpu \*vcpu) byteswap\_hv\_regs(&l2\_hv); byteswap\_pt\_regs(&l2\_regs); }- vcpu->srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu); err = kvmhv\_write\_guest\_state\_and\_regs(vcpu, &l2\_hv, &l2\_regs, hv\_ptr, regs\_ptr);- srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); if (err) return H\_AUTHORITY; @@ -600,16 +600,16 @@ long kvmhv\_copy\_tofrom\_guest\_nested(struct kvm\_vcpu \*vcpu) goto not\_found;  /\* Write what was loaded into our buffer back to the L1 guest \*/- vcpu->srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu); rc = kvm\_vcpu\_write\_guest(vcpu, gp\_to, buf, n);- srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); if (rc) goto not\_found; } else { /\* Load the data to be stored from the L1 guest into our buf \*/- vcpu->srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu); rc = kvm\_vcpu\_read\_guest(vcpu, gp\_from, buf, n);- srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); if (rc) goto not\_found; diff --git a/arch/powerpc/kvm/book3s\_rtas.c b/arch/powerpc/kvm/book3s\_rtas.cindex 0f847f1e5ddd0b..6808bda0dbc10c 100644--- a/[arch/powerpc/kvm/book3s\_rtas.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/powerpc/kvm/book3s_rtas.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/powerpc/kvm/book3s\_rtas.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/powerpc/kvm/book3s_rtas.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -229,9 +229,9 @@ int kvmppc\_rtas\_hcall(struct kvm\_vcpu \*vcpu) \*/ args\_phys = kvmppc\_get\_gpr(vcpu, 4) & KVM\_PAM; - vcpu->srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu); rc = kvm\_read\_guest(vcpu->kvm, args\_phys, &args, sizeof(args));- srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); if (rc) goto fail; diff --git a/arch/powerpc/kvm/powerpc.c b/arch/powerpc/kvm/powerpc.cindex 875c30c12db046..533c4232e5abfd 100644--- a/[arch/powerpc/kvm/powerpc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/powerpc/kvm/powerpc.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/powerpc/kvm/powerpc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/powerpc/kvm/powerpc.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -425,9 +425,9 @@ int kvmppc\_ld(struct kvm\_vcpu \*vcpu, ulong \*eaddr, int size, void \*ptr, return EMULATE\_DONE; } - vcpu->srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu); rc = kvm\_read\_guest(vcpu->kvm, pte.raddr, ptr, size);- srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); if (rc) return EMULATE\_DO\_MMIO; diff --git a/arch/riscv/include/asm/kvm\_host.h b/arch/riscv/include/asm/kvm\_host.hindex 78da839657e524..cd4bbcecb0fbf0 100644--- a/[arch/riscv/include/asm/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/riscv/include/asm/kvm_host.h?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/riscv/include/asm/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/riscv/include/asm/kvm_host.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -193,9 +193,6 @@ struct kvm\_vcpu\_arch {  /\* Don't run the VCPU (blocked) \*/ bool pause;-- /\* SRCU lock index for in-kernel run loop \*/- int srcu\_idx; };  static inline void kvm\_arch\_hardware\_unsetup(void) {}diff --git a/arch/riscv/kvm/vcpu.c b/arch/riscv/kvm/vcpu.cindex 6785aef4cbd46e..7461f964d20a92 100644--- a/[arch/riscv/kvm/vcpu.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/riscv/kvm/vcpu.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/riscv/kvm/vcpu.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/riscv/kvm/vcpu.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -38,14 +38,16 @@ const struct kvm\_stats\_header kvm\_vcpu\_stats\_header = { sizeof(kvm\_vcpu\_stats\_desc), }; -#define KVM\_RISCV\_ISA\_ALLOWED (riscv\_isa\_extension\_mask(a) | \- riscv\_isa\_extension\_mask(c) | \- riscv\_isa\_extension\_mask(d) | \- riscv\_isa\_extension\_mask(f) | \- riscv\_isa\_extension\_mask(i) | \- riscv\_isa\_extension\_mask(m) | \- riscv\_isa\_extension\_mask(s) | \- riscv\_isa\_extension\_mask(u))+#define KVM\_RISCV\_ISA\_DISABLE\_ALLOWED (riscv\_isa\_extension\_mask(d) | \+ riscv\_isa\_extension\_mask(f))++#define KVM\_RISCV\_ISA\_DISABLE\_NOT\_ALLOWED (riscv\_isa\_extension\_mask(a) | \+ riscv\_isa\_extension\_mask(c) | \+ riscv\_isa\_extension\_mask(i) | \+ riscv\_isa\_extension\_mask(m))++#define KVM\_RISCV\_ISA\_ALLOWED (KVM\_RISCV\_ISA\_DISABLE\_ALLOWED | \+ KVM\_RISCV\_ISA\_DISABLE\_NOT\_ALLOWED)  static void kvm\_riscv\_reset\_vcpu(struct kvm\_vcpu \*vcpu) {@@ -219,7 +221,8 @@ static int kvm\_riscv\_vcpu\_set\_reg\_config(struct kvm\_vcpu \*vcpu, switch (reg\_num) { case KVM\_REG\_RISCV\_CONFIG\_REG(isa): if (!vcpu->arch.ran\_atleast\_once) {- vcpu->arch.isa = reg\_val;+ /\* Ignore the disable request for these extensions \*/+ vcpu->arch.isa = reg\_val | KVM\_RISCV\_ISA\_DISABLE\_NOT\_ALLOWED; vcpu->arch.isa &= riscv\_isa\_extension\_base(NULL); vcpu->arch.isa &= KVM\_RISCV\_ISA\_ALLOWED; kvm\_riscv\_vcpu\_fp\_reset(vcpu);@@ -724,13 +727,13 @@ int kvm\_arch\_vcpu\_ioctl\_run(struct kvm\_vcpu \*vcpu) /\* Mark this VCPU ran at least once \*/ vcpu->arch.ran\_atleast\_once = true; - vcpu->arch.srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu);  /\* Process MMIO value returned from user-space \*/ if (run->exit\_reason == KVM\_EXIT\_MMIO) { ret = kvm\_riscv\_vcpu\_mmio\_return(vcpu, vcpu->run); if (ret) {- srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->arch.srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); return ret; } }@@ -739,13 +742,13 @@ int kvm\_arch\_vcpu\_ioctl\_run(struct kvm\_vcpu \*vcpu) if (run->exit\_reason == KVM\_EXIT\_RISCV\_SBI) { ret = kvm\_riscv\_vcpu\_sbi\_return(vcpu, vcpu->run); if (ret) {- srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->arch.srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); return ret; } }  if (run->immediate\_exit) {- srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->arch.srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); return -EINTR; } @@ -784,7 +787,7 @@ int kvm\_arch\_vcpu\_ioctl\_run(struct kvm\_vcpu \*vcpu) \*/ vcpu->mode = IN\_GUEST\_MODE; - srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->arch.srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); smp\_mb\_\_after\_srcu\_read\_unlock();  /\*@@ -802,7 +805,7 @@ int kvm\_arch\_vcpu\_ioctl\_run(struct kvm\_vcpu \*vcpu) vcpu->mode = OUTSIDE\_GUEST\_MODE; local\_irq\_enable(); preempt\_enable();- vcpu->arch.srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu); continue; } @@ -846,7 +849,7 @@ int kvm\_arch\_vcpu\_ioctl\_run(struct kvm\_vcpu \*vcpu)  preempt\_enable(); - vcpu->arch.srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu);  ret = kvm\_riscv\_vcpu\_exit(vcpu, run, &trap); }@@ -855,7 +858,7 @@ int kvm\_arch\_vcpu\_ioctl\_run(struct kvm\_vcpu \*vcpu)  vcpu\_put(vcpu); - srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->arch.srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu);  return ret; }diff --git a/arch/riscv/kvm/vcpu\_exit.c b/arch/riscv/kvm/vcpu\_exit.cindex aa8af129e4bb93..a72c15d4b42a59 100644--- a/[arch/riscv/kvm/vcpu\_exit.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/riscv/kvm/vcpu_exit.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/riscv/kvm/vcpu\_exit.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/riscv/kvm/vcpu_exit.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -456,9 +456,9 @@ static int stage2\_page\_fault(struct kvm\_vcpu \*vcpu, struct kvm\_run \*run, void kvm\_riscv\_vcpu\_wfi(struct kvm\_vcpu \*vcpu) { if (!kvm\_arch\_vcpu\_runnable(vcpu)) {- srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->arch.srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); kvm\_vcpu\_halt(vcpu);- vcpu->arch.srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu); kvm\_clear\_request(KVM\_REQ\_UNHALT, vcpu); } }diff --git a/arch/s390/kvm/interrupt.c b/arch/s390/kvm/interrupt.cindex 9b30beac904db8..af96dc0549a4b5 100644--- a/[arch/s390/kvm/interrupt.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/s390/kvm/interrupt.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/s390/kvm/interrupt.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/s390/kvm/interrupt.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -1334,11 +1334,11 @@ int kvm\_s390\_handle\_wait(struct kvm\_vcpu \*vcpu) hrtimer\_start(&vcpu->arch.ckc\_timer, sltime, HRTIMER\_MODE\_REL); VCPU\_EVENT(vcpu, 4, "enabled wait: %llu ns", sltime); no\_timer:- srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); kvm\_vcpu\_halt(vcpu); vcpu->valid\_wakeup = false; \_\_unset\_cpu\_idle(vcpu);- vcpu->srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu);  hrtimer\_cancel(&vcpu->arch.ckc\_timer); return 0;diff --git a/arch/s390/kvm/kvm-s390.c b/arch/s390/kvm/kvm-s390.cindex 156d1c25a3c1ec..da3dabda1a1262 100644--- a/[arch/s390/kvm/kvm-s390.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/s390/kvm/kvm-s390.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/s390/kvm/kvm-s390.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/s390/kvm/kvm-s390.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -4237,14 +4237,14 @@ static int \_\_vcpu\_run(struct kvm\_vcpu \*vcpu) \* We try to hold kvm->srcu during most of vcpu\_run (except when run- \* ning the guest), so that memslots (and other stuff) are protected \*/- vcpu->srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu);  do { rc = vcpu\_pre\_run(vcpu); if (rc) break; - srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); /\* \* As PF\_VCPU will be used in fault handler, between \* guest\_enter and guest\_exit should be no uaccess.@@ -4281,12 +4281,12 @@ static int \_\_vcpu\_run(struct kvm\_vcpu \*vcpu) \_\_enable\_cpu\_timer\_accounting(vcpu); guest\_exit\_irqoff(); local\_irq\_enable();- vcpu->srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu);  rc = vcpu\_post\_run(vcpu, exit\_reason); } while (!signal\_pending(current) && !guestdbg\_exit\_pending(vcpu) && !rc); - srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); return rc; } diff --git a/arch/s390/kvm/vsie.c b/arch/s390/kvm/vsie.cindex acda4b6fc85182..dada78b92691fa 100644--- a/[arch/s390/kvm/vsie.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/s390/kvm/vsie.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/s390/kvm/vsie.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/s390/kvm/vsie.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -1091,7 +1091,7 @@ static int do\_vsie\_run(struct kvm\_vcpu \*vcpu, struct vsie\_page \*vsie\_page)  handle\_last\_fault(vcpu, vsie\_page); - srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu);  /\* save current guest state of bp isolation override \*/ guest\_bp\_isolation = test\_thread\_flag(TIF\_ISOLATE\_BP\_GUEST);@@ -1133,7 +1133,7 @@ static int do\_vsie\_run(struct kvm\_vcpu \*vcpu, struct vsie\_page \*vsie\_page) if (!guest\_bp\_isolation) clear\_thread\_flag(TIF\_ISOLATE\_BP\_GUEST); - vcpu->srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu);  if (rc == -EINTR) { VCPU\_EVENT(vcpu, 3, "%s", "machine check");diff --git a/arch/x86/include/asm/kvm-x86-ops.h b/arch/x86/include/asm/kvm-x86-ops.hindex 3c368b639c0462..1a6d7e3f6c32c7 100644--- a/[arch/x86/include/asm/kvm-x86-ops.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/include/asm/kvm-x86-ops.h?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/x86/include/asm/kvm-x86-ops.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/include/asm/kvm-x86-ops.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -118,6 +118,7 @@ KVM\_X86\_OP\_OPTIONAL(mem\_enc\_register\_region) KVM\_X86\_OP\_OPTIONAL(mem\_enc\_unregister\_region) KVM\_X86\_OP\_OPTIONAL(vm\_copy\_enc\_context\_from) KVM\_X86\_OP\_OPTIONAL(vm\_move\_enc\_context\_from)+KVM\_X86\_OP\_OPTIONAL(guest\_memory\_reclaimed) KVM\_X86\_OP(get\_msr\_feature) KVM\_X86\_OP(can\_emulate\_instruction) KVM\_X86\_OP(apic\_init\_signal\_blocked)diff --git a/arch/x86/include/asm/kvm\_host.h b/arch/x86/include/asm/kvm\_host.hindex e0c0f0e1f754c1..4ff36610af6ab5 100644--- a/[arch/x86/include/asm/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/include/asm/kvm_host.h?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/x86/include/asm/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/include/asm/kvm_host.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -1484,6 +1484,7 @@ struct kvm\_x86\_ops { int (\*mem\_enc\_unregister\_region)(struct kvm \*kvm, struct kvm\_enc\_region \*argp); int (\*vm\_copy\_enc\_context\_from)(struct kvm \*kvm, unsigned int source\_fd); int (\*vm\_move\_enc\_context\_from)(struct kvm \*kvm, unsigned int source\_fd);+ void (\*guest\_memory\_reclaimed)(struct kvm \*kvm);  int (\*get\_msr\_feature)(struct kvm\_msr\_entry \*entry); diff --git a/arch/x86/kernel/kvm.c b/arch/x86/kernel/kvm.cindex a22deb58f86d2e..8b1c45c9cda877 100644--- a/[arch/x86/kernel/kvm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kernel/kvm.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/x86/kernel/kvm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kernel/kvm.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -69,6 +69,7 @@ static DEFINE\_PER\_CPU\_DECRYPTED(struct kvm\_vcpu\_pv\_apf\_data, apf\_reason) \_\_align DEFINE\_PER\_CPU\_DECRYPTED(struct kvm\_steal\_time, steal\_time) \_\_aligned(64) \_\_visible; static int has\_steal\_clock = 0; +static int has\_guest\_poll = 0; /\* \* No need for any "IO delay" on KVM \*/@@ -706,14 +707,26 @@ static int kvm\_cpu\_down\_prepare(unsigned int cpu)  static int kvm\_suspend(void) {+ u64 val = 0;+ kvm\_guest\_cpu\_offline(false); +#ifdef CONFIG\_ARCH\_CPUIDLE\_HALTPOLL+ if (kvm\_para\_has\_feature(KVM\_FEATURE\_POLL\_CONTROL))+ rdmsrl(MSR\_KVM\_POLL\_CONTROL, val);+ has\_guest\_poll = !(val & 1);+#endif return 0; }  static void kvm\_resume(void) { kvm\_cpu\_online(raw\_smp\_processor\_id());++#ifdef CONFIG\_ARCH\_CPUIDLE\_HALTPOLL+ if (kvm\_para\_has\_feature(KVM\_FEATURE\_POLL\_CONTROL) && has\_guest\_poll)+ wrmsrl(MSR\_KVM\_POLL\_CONTROL, 0);+#endif }  static struct syscore\_ops kvm\_syscore\_ops = {diff --git a/arch/x86/kvm/pmu.h b/arch/x86/kvm/pmu.hindex 9e66fba1d6a37d..22992b049d380f 100644--- a/[arch/x86/kvm/pmu.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/pmu.h?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/x86/kvm/pmu.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/pmu.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -138,6 +138,15 @@ static inline u64 get\_sample\_period(struct kvm\_pmc \*pmc, u64 counter\_value) return sample\_period; } +static inline void pmc\_update\_sample\_period(struct kvm\_pmc \*pmc)+{+ if (!pmc->perf\_event || pmc->is\_paused)+ return;++ perf\_event\_period(pmc->perf\_event,+ get\_sample\_period(pmc, pmc->counter));+}+ void reprogram\_gp\_counter(struct kvm\_pmc \*pmc, u64 eventsel); void reprogram\_fixed\_counter(struct kvm\_pmc \*pmc, u8 ctrl, int fixed\_idx); void reprogram\_counter(struct kvm\_pmu \*pmu, int pmc\_idx);diff --git a/arch/x86/kvm/svm/pmu.c b/arch/x86/kvm/svm/pmu.cindex 24eb935b6f85c3..b14860863c3941 100644--- a/[arch/x86/kvm/svm/pmu.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/svm/pmu.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/x86/kvm/svm/pmu.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/svm/pmu.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -257,6 +257,7 @@ static int amd\_pmu\_set\_msr(struct kvm\_vcpu \*vcpu, struct msr\_data \*msr\_info) pmc = get\_gp\_pmc\_amd(pmu, msr, PMU\_TYPE\_COUNTER); if (pmc) { pmc->counter += data - pmc\_read\_counter(pmc);+ pmc\_update\_sample\_period(pmc); return 0; } /\* MSR\_EVNTSELn \*/diff --git a/arch/x86/kvm/svm/sev.c b/arch/x86/kvm/svm/sev.cindex 537aaddc852fc4..0ad70c12c7c311 100644--- a/[arch/x86/kvm/svm/sev.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/svm/sev.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/x86/kvm/svm/sev.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/svm/sev.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -2226,51 +2226,47 @@ int sev\_cpu\_init(struct svm\_cpu\_data \*sd) \* Pages used by hardware to hold guest encrypted state must be flushed before \* returning them to the system. \*/-static void sev\_flush\_guest\_memory(struct vcpu\_svm \*svm, void \*va,- unsigned long len)+static void sev\_flush\_encrypted\_page(struct kvm\_vcpu \*vcpu, void \*va) {+ int asid = to\_kvm\_svm(vcpu->kvm)->sev\_info.asid;+ /\*- \* If hardware enforced cache coherency for encrypted mappings of the- \* same physical page is supported, nothing to do.+ \* Note! The address must be a kernel address, as regular page walk+ \* checks are performed by VM\_PAGE\_FLUSH, i.e. operating on a user+ \* address is non-deterministic and unsafe. This function deliberately+ \* takes a pointer to deter passing in a user address. \*/- if (boot\_cpu\_has(X86\_FEATURE\_SME\_COHERENT))- return;+ unsigned long addr = (unsigned long)va;  /\*- \* If the VM Page Flush MSR is supported, use it to flush the page- \* (using the page virtual address and the guest ASID).+ \* If CPU enforced cache coherency for encrypted mappings of the+ \* same physical page is supported, use CLFLUSHOPT instead. NOTE: cache+ \* flush is still needed in order to work properly with DMA devices. \*/- if (boot\_cpu\_has(X86\_FEATURE\_VM\_PAGE\_FLUSH)) {- struct kvm\_sev\_info \*sev;- unsigned long va\_start;- u64 start, stop;-- /\* Align start and stop to page boundaries. \*/- va\_start = (unsigned long)va;- start = (u64)va\_start & PAGE\_MASK;- stop = PAGE\_ALIGN((u64)va\_start + len);-- if (start < stop) {- sev = &to\_kvm\_svm(svm->vcpu.kvm)->sev\_info;+ if (boot\_cpu\_has(X86\_FEATURE\_SME\_COHERENT)) {+ clflush\_cache\_range(va, PAGE\_SIZE);+ return;+ } - while (start < stop) {- wrmsrl(MSR\_AMD64\_VM\_PAGE\_FLUSH,- start | sev->asid);+ /\*+ \* VM Page Flush takes a host virtual address and a guest ASID. Fall+ \* back to WBINVD if this faults so as not to make any problems worse+ \* by leaving stale encrypted data in the cache.+ \*/+ if (WARN\_ON\_ONCE(wrmsrl\_safe(MSR\_AMD64\_VM\_PAGE\_FLUSH, addr | asid)))+ goto do\_wbinvd; - start += PAGE\_SIZE;- }+ return; - return;- }+do\_wbinvd:+ wbinvd\_on\_all\_cpus();+} - WARN(1, "Address overflow, using WBINVD\n");- }+void sev\_guest\_memory\_reclaimed(struct kvm \*kvm)+{+ if (!sev\_guest(kvm))+ return; - /\*- \* Hardware should always have one of the above features,- \* but if not, use WBINVD and issue a warning.- \*/- WARN\_ONCE(1, "Using WBINVD to flush guest memory\n"); wbinvd\_on\_all\_cpus(); } @@ -2284,7 +2280,8 @@ void sev\_free\_vcpu(struct kvm\_vcpu \*vcpu) svm = to\_svm(vcpu);  if (vcpu->arch.guest\_state\_protected)- sev\_flush\_guest\_memory(svm, svm->sev\_es.vmsa, PAGE\_SIZE);+ sev\_flush\_encrypted\_page(vcpu, svm->sev\_es.vmsa);+ \_\_free\_page(virt\_to\_page(svm->sev\_es.vmsa));  if (svm->sev\_es.ghcb\_sa\_free)diff --git a/arch/x86/kvm/svm/svm.c b/arch/x86/kvm/svm/svm.cindex bd4c64b362d24a..7e45d03cd018a5 100644--- a/[arch/x86/kvm/svm/svm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/svm/svm.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/x86/kvm/svm/svm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/svm/svm.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -4620,6 +4620,7 @@ static struct kvm\_x86\_ops svm\_x86\_ops \_\_initdata = { .mem\_enc\_ioctl = sev\_mem\_enc\_ioctl, .mem\_enc\_register\_region = sev\_mem\_enc\_register\_region, .mem\_enc\_unregister\_region = sev\_mem\_enc\_unregister\_region,+ .guest\_memory\_reclaimed = sev\_guest\_memory\_reclaimed,  .vm\_copy\_enc\_context\_from = sev\_vm\_copy\_enc\_context\_from, .vm\_move\_enc\_context\_from = sev\_vm\_move\_enc\_context\_from,diff --git a/arch/x86/kvm/svm/svm.h b/arch/x86/kvm/svm/svm.hindex f77a7d2d39dd6d..f76deff71002cb 100644--- a/[arch/x86/kvm/svm/svm.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/svm/svm.h?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/x86/kvm/svm/svm.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/svm/svm.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -609,6 +609,8 @@ int sev\_mem\_enc\_unregister\_region(struct kvm \*kvm, struct kvm\_enc\_region \*range); int sev\_vm\_copy\_enc\_context\_from(struct kvm \*kvm, unsigned int source\_fd); int sev\_vm\_move\_enc\_context\_from(struct kvm \*kvm, unsigned int source\_fd);+void sev\_guest\_memory\_reclaimed(struct kvm \*kvm);+ void pre\_sev\_run(struct vcpu\_svm \*svm, int cpu); void \_\_init sev\_set\_cpu\_caps(void); void \_\_init sev\_hardware\_setup(void);diff --git a/arch/x86/kvm/vmx/nested.c b/arch/x86/kvm/vmx/nested.cindex f18744f7ff82c9..856c8756388330 100644--- a/[arch/x86/kvm/vmx/nested.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/vmx/nested.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/x86/kvm/vmx/nested.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/vmx/nested.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -4618,6 +4618,11 @@ void nested\_vmx\_vmexit(struct kvm\_vcpu \*vcpu, u32 vm\_exit\_reason, kvm\_make\_request(KVM\_REQ\_APIC\_PAGE\_RELOAD, vcpu); } + if (vmx->nested.update\_vmcs01\_apicv\_status) {+ vmx->nested.update\_vmcs01\_apicv\_status = false;+ kvm\_make\_request(KVM\_REQ\_APICV\_UPDATE, vcpu);+ }+ if ((vm\_exit\_reason != -1) && (enable\_shadow\_vmcs || evmptr\_is\_valid(vmx->nested.hv\_evmcs\_vmptr))) vmx->nested.need\_vmcs12\_to\_shadow\_sync = true;diff --git a/arch/x86/kvm/vmx/pmu\_intel.c b/arch/x86/kvm/vmx/pmu\_intel.cindex bc3f8512bb646d..b82b6709d7a819 100644--- a/[arch/x86/kvm/vmx/pmu\_intel.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/vmx/pmu_intel.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/x86/kvm/vmx/pmu\_intel.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/vmx/pmu_intel.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -431,15 +431,11 @@ static int intel\_pmu\_set\_msr(struct kvm\_vcpu \*vcpu, struct msr\_data \*msr\_info) !(msr & MSR\_PMC\_FULL\_WIDTH\_BIT)) data = (s64)(s32)data; pmc->counter += data - pmc\_read\_counter(pmc);- if (pmc->perf\_event && !pmc->is\_paused)- perf\_event\_period(pmc->perf\_event,- get\_sample\_period(pmc, data));+ pmc\_update\_sample\_period(pmc); return 0; } else if ((pmc = get\_fixed\_pmc(pmu, msr))) { pmc->counter += data - pmc\_read\_counter(pmc);- if (pmc->perf\_event && !pmc->is\_paused)- perf\_event\_period(pmc->perf\_event,- get\_sample\_period(pmc, data));+ pmc\_update\_sample\_period(pmc); return 0; } else if ((pmc = get\_gp\_pmc(pmu, msr, MSR\_P6\_EVNTSEL0))) { if (data == pmc->eventsel)diff --git a/arch/x86/kvm/vmx/vmx.c b/arch/x86/kvm/vmx/vmx.cindex 04d170c4b61eb4..d58b763df855f6 100644--- a/[arch/x86/kvm/vmx/vmx.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/vmx/vmx.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/x86/kvm/vmx/vmx.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/vmx/vmx.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -4174,6 +4174,11 @@ static void vmx\_refresh\_apicv\_exec\_ctrl(struct kvm\_vcpu \*vcpu) { struct vcpu\_vmx \*vmx = to\_vmx(vcpu); + if (is\_guest\_mode(vcpu)) {+ vmx->nested.update\_vmcs01\_apicv\_status = true;+ return;+ }+ pin\_controls\_set(vmx, vmx\_pin\_based\_exec\_ctrl(vmx)); if (cpu\_has\_secondary\_exec\_ctrls()) { if (kvm\_vcpu\_apicv\_active(vcpu))diff --git a/arch/x86/kvm/vmx/vmx.h b/arch/x86/kvm/vmx/vmx.hindex 9c6bfcd84008be..b98c7e96697a9a 100644--- a/[arch/x86/kvm/vmx/vmx.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/vmx/vmx.h?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/x86/kvm/vmx/vmx.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/vmx/vmx.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -183,6 +183,7 @@ struct nested\_vmx { bool change\_vmcs01\_virtual\_apic\_mode; bool reload\_vmcs01\_apic\_access\_page; bool update\_vmcs01\_cpu\_dirty\_logging;+ bool update\_vmcs01\_apicv\_status;  /\* \* Enlightened VMCS has been enabled. It does not mean that L1 has todiff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.cindex 547ba00ef64fc3..a6ab19afc638b2 100644--- a/[arch/x86/kvm/x86.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/x86.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/x86/kvm/x86.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/x86.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -9111,7 +9111,7 @@ static void kvm\_apicv\_init(struct kvm \*kvm)  if (!enable\_apicv) set\_or\_clear\_apicv\_inhibit(inhibits,- APICV\_INHIBIT\_REASON\_ABSENT, true);+ APICV\_INHIBIT\_REASON\_DISABLE, true); }  static void kvm\_sched\_yield(struct kvm\_vcpu \*vcpu, unsigned long dest\_id)@@ -9889,6 +9889,11 @@ void kvm\_arch\_mmu\_notifier\_invalidate\_range(struct kvm \*kvm, kvm\_make\_all\_cpus\_request(kvm, KVM\_REQ\_APIC\_PAGE\_RELOAD); } +void kvm\_arch\_guest\_memory\_reclaimed(struct kvm \*kvm)+{+ static\_call\_cond(kvm\_x86\_guest\_memory\_reclaimed)(kvm);+}+ static void kvm\_vcpu\_reload\_apic\_access\_page(struct kvm\_vcpu \*vcpu) { if (!lapic\_in\_kernel(vcpu))@@ -10097,7 +10102,7 @@ static int vcpu\_enter\_guest(struct kvm\_vcpu \*vcpu) /\* Store vcpu->apicv\_active before vcpu->mode. \*/ smp\_store\_release(&vcpu->mode, IN\_GUEST\_MODE); - srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu);  /\* \* 1) We should set ->mode before checking ->requests. Please see@@ -10128,7 +10133,7 @@ static int vcpu\_enter\_guest(struct kvm\_vcpu \*vcpu) smp\_wmb(); local\_irq\_enable(); preempt\_enable();- vcpu->srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu); r = 1; goto cancel\_injection; }@@ -10254,7 +10259,7 @@ static int vcpu\_enter\_guest(struct kvm\_vcpu \*vcpu) local\_irq\_enable(); preempt\_enable(); - vcpu->srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu);  /\* \* Profile KVM exit RIPs:@@ -10284,7 +10289,7 @@ out: }  /\* Called within kvm->srcu read side. \*/-static inline int vcpu\_block(struct kvm \*kvm, struct kvm\_vcpu \*vcpu)+static inline int vcpu\_block(struct kvm\_vcpu \*vcpu) { bool hv\_timer; @@ -10300,12 +10305,12 @@ static inline int vcpu\_block(struct kvm \*kvm, struct kvm\_vcpu \*vcpu) if (hv\_timer) kvm\_lapic\_switch\_to\_sw\_timer(vcpu); - srcu\_read\_unlock(&kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); if (vcpu->arch.mp\_state == KVM\_MP\_STATE\_HALTED) kvm\_vcpu\_halt(vcpu); else kvm\_vcpu\_block(vcpu);- vcpu->srcu\_idx = srcu\_read\_lock(&kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu);  if (hv\_timer) kvm\_lapic\_switch\_to\_hv\_timer(vcpu);@@ -10347,7 +10352,6 @@ static inline bool kvm\_vcpu\_running(struct kvm\_vcpu \*vcpu) static int vcpu\_run(struct kvm\_vcpu \*vcpu) { int r;- struct kvm \*kvm = vcpu->kvm;  vcpu->arch.l1tf\_flush\_l1d = true; @@ -10355,7 +10359,7 @@ static int vcpu\_run(struct kvm\_vcpu \*vcpu) if (kvm\_vcpu\_running(vcpu)) { r = vcpu\_enter\_guest(vcpu); } else {- r = vcpu\_block(kvm, vcpu);+ r = vcpu\_block(vcpu); }  if (r <= 0)@@ -10374,9 +10378,9 @@ static int vcpu\_run(struct kvm\_vcpu \*vcpu) }  if (\_\_xfer\_to\_guest\_mode\_work\_pending()) {- srcu\_read\_unlock(&kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); r = xfer\_to\_guest\_mode\_handle\_work(vcpu);- vcpu->srcu\_idx = srcu\_read\_lock(&kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu); if (r) return r; }@@ -10387,12 +10391,7 @@ static int vcpu\_run(struct kvm\_vcpu \*vcpu)  static inline int complete\_emulated\_io(struct kvm\_vcpu \*vcpu) {- int r;-- vcpu->srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);- r = kvm\_emulate\_instruction(vcpu, EMULTYPE\_NO\_DECODE);- srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->srcu\_idx);- return r;+ return kvm\_emulate\_instruction(vcpu, EMULTYPE\_NO\_DECODE); }  static int complete\_emulated\_pio(struct kvm\_vcpu \*vcpu)@@ -10484,7 +10483,6 @@ static void kvm\_put\_guest\_fpu(struct kvm\_vcpu \*vcpu) int kvm\_arch\_vcpu\_ioctl\_run(struct kvm\_vcpu \*vcpu) { struct kvm\_run \*kvm\_run = vcpu->run;- struct kvm \*kvm = vcpu->kvm; int r;  vcpu\_load(vcpu);@@ -10492,7 +10490,7 @@ int kvm\_arch\_vcpu\_ioctl\_run(struct kvm\_vcpu \*vcpu) kvm\_run->flags = 0; kvm\_load\_guest\_fpu(vcpu); - vcpu->srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu); if (unlikely(vcpu->arch.mp\_state == KVM\_MP\_STATE\_UNINITIALIZED)) { if (kvm\_run->immediate\_exit) { r = -EINTR;@@ -10504,9 +10502,9 @@ int kvm\_arch\_vcpu\_ioctl\_run(struct kvm\_vcpu \*vcpu) \*/ WARN\_ON\_ONCE(kvm\_lapic\_hv\_timer\_in\_use(vcpu)); - srcu\_read\_unlock(&kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); kvm\_vcpu\_block(vcpu);- vcpu->srcu\_idx = srcu\_read\_lock(&kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu);  if (kvm\_apic\_accept\_events(vcpu) < 0) { r = 0;@@ -10567,7 +10565,7 @@ out: if (kvm\_run->kvm\_valid\_regs) store\_regs(vcpu); post\_kvm\_run\_save(vcpu);- srcu\_read\_unlock(&kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu);  kvm\_sigset\_deactivate(vcpu); vcpu\_put(vcpu);@@ -10985,6 +10983,9 @@ static void kvm\_arch\_vcpu\_guestdbg\_update\_apicv\_inhibit(struct kvm \*kvm) struct kvm\_vcpu \*vcpu; unsigned long i; + if (!enable\_apicv)+ return;+ down\_write(&kvm->arch.apicv\_update\_lock);  kvm\_for\_each\_vcpu(i, vcpu, kvm) {@@ -11196,8 +11197,21 @@ int kvm\_arch\_vcpu\_create(struct kvm\_vcpu \*vcpu) r = kvm\_create\_lapic(vcpu, lapic\_timer\_advance\_ns); if (r < 0) goto fail\_mmu\_destroy;- if (kvm\_apicv\_activated(vcpu->kvm))++ /\*+ \* Defer evaluating inhibits until the vCPU is first run, as+ \* this vCPU will not get notified of any changes until this+ \* vCPU is visible to other vCPUs (marked online and added to+ \* the set of vCPUs). Opportunistically mark APICv active as+ \* VMX in particularly is highly unlikely to have inhibits.+ \* Ignore the current per-VM APICv state so that vCPU creation+ \* is guaranteed to run with a deterministic value, the request+ \* will ensure the vCPU gets the correct state before VM-Entry.+ \*/+ if (enable\_apicv) { vcpu->arch.apicv\_active = true;+ kvm\_make\_request(KVM\_REQ\_APICV\_UPDATE, vcpu);+ } } else static\_branch\_inc(&kvm\_has\_noapic\_vcpu); diff --git a/include/linux/kvm\_host.h b/include/linux/kvm\_host.hindex 3f9b22c4983a85..34eed5f85ed607 100644--- a/[include/linux/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/kvm_host.h?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[include/linux/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/kvm_host.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -315,7 +315,10 @@ struct kvm\_vcpu { int cpu; int vcpu\_id; /\* id given by userspace at creation \*/ int vcpu\_idx; /\* index in kvm->vcpus array \*/- int srcu\_idx;+ int \_\_\_\_srcu\_idx; /\* Don't use this directly. You've been warned. \*/+#ifdef CONFIG\_PROVE\_RCU+ int srcu\_depth;+#endif int mode; u64 requests; unsigned long guest\_debug;@@ -840,6 +843,25 @@ static inline void kvm\_vm\_bugged(struct kvm \*kvm) unlikely(\_\_ret); \ }) +static inline void kvm\_vcpu\_srcu\_read\_lock(struct kvm\_vcpu \*vcpu)+{+#ifdef CONFIG\_PROVE\_RCU+ WARN\_ONCE(vcpu->srcu\_depth++,+ "KVM: Illegal vCPU srcu\_idx LOCK, depth=%d", vcpu->srcu\_depth - 1);+#endif+ vcpu->\_\_\_\_srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+}++static inline void kvm\_vcpu\_srcu\_read\_unlock(struct kvm\_vcpu \*vcpu)+{+ srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->\_\_\_\_srcu\_idx);++#ifdef CONFIG\_PROVE\_RCU+ WARN\_ONCE(--vcpu->srcu\_depth,+ "KVM: Illegal vCPU srcu\_idx UNLOCK, depth=%d", vcpu->srcu\_depth);+#endif+}+ static inline bool kvm\_dirty\_log\_manual\_protect\_and\_init\_set(struct kvm \*kvm) { return !!(kvm->manual\_dirty\_log\_protect & KVM\_DIRTY\_LOG\_INITIALLY\_SET);@@ -2197,6 +2219,8 @@ static inline long kvm\_arch\_vcpu\_async\_ioctl(struct file \*filp, void kvm\_arch\_mmu\_notifier\_invalidate\_range(struct kvm \*kvm, unsigned long start, unsigned long end); +void kvm\_arch\_guest\_memory\_reclaimed(struct kvm \*kvm);+ #ifdef CONFIG\_HAVE\_KVM\_VCPU\_RUN\_PID\_CHANGE int kvm\_arch\_vcpu\_run\_pid\_change(struct kvm\_vcpu \*vcpu); #elsediff --git a/tools/testing/selftests/kvm/include/x86\_64/processor.h b/tools/testing/selftests/kvm/include/x86\_64/processor.hindex 37db341d4cc5c9..d0d51adec76eb8 100644--- a/[tools/testing/selftests/kvm/include/x86\_64/processor.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/include/x86_64/processor.h?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[tools/testing/selftests/kvm/include/x86\_64/processor.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/include/x86_64/processor.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -60,6 +60,23 @@ /\* CPUID.0x8000\_0001.EDX \*/ #define CPUID\_GBPAGES (1ul << 26) +/\* Page table bitfield declarations \*/+#define PTE\_PRESENT\_MASK BIT\_ULL(0)+#define PTE\_WRITABLE\_MASK BIT\_ULL(1)+#define PTE\_USER\_MASK BIT\_ULL(2)+#define PTE\_ACCESSED\_MASK BIT\_ULL(5)+#define PTE\_DIRTY\_MASK BIT\_ULL(6)+#define PTE\_LARGE\_MASK BIT\_ULL(7)+#define PTE\_GLOBAL\_MASK BIT\_ULL(8)+#define PTE\_NX\_MASK BIT\_ULL(63)++#define PAGE\_SHIFT 12+#define PAGE\_SIZE (1ULL << PAGE\_SHIFT)+#define PAGE\_MASK (~(PAGE\_SIZE-1))++#define PHYSICAL\_PAGE\_MASK GENMASK\_ULL(51, 12)+#define PTE\_GET\_PFN(pte) (((pte) & PHYSICAL\_PAGE\_MASK) >> PAGE\_SHIFT)+ /\* General Registers in 64-Bit Mode \*/ struct gpr64\_regs { u64 rax;diff --git a/tools/testing/selftests/kvm/kvm\_page\_table\_test.c b/tools/testing/selftests/kvm/kvm\_page\_table\_test.cindex ba1fdc3dcf4a90..2c4a7563a4f8ad 100644--- a/[tools/testing/selftests/kvm/kvm\_page\_table\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/kvm_page_table_test.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[tools/testing/selftests/kvm/kvm\_page\_table\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/kvm_page_table_test.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -278,7 +278,7 @@ static struct kvm\_vm \*pre\_init\_before\_test(enum vm\_guest\_mode mode, void \*arg) else guest\_test\_phys\_mem = p->phys\_offset; #ifdef \_\_s390x\_\_- alignment = max(0x100000, alignment);+ alignment = max(0x100000UL, alignment); #endif guest\_test\_phys\_mem = align\_down(guest\_test\_phys\_mem, alignment); diff --git a/tools/testing/selftests/kvm/lib/x86\_64/processor.c b/tools/testing/selftests/kvm/lib/x86\_64/processor.cindex 9f000dfb55949d..33ea5e9955d9bd 100644--- a/[tools/testing/selftests/kvm/lib/x86\_64/processor.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/lib/x86_64/processor.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[tools/testing/selftests/kvm/lib/x86\_64/processor.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/lib/x86_64/processor.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -19,38 +19,6 @@  vm\_vaddr\_t exception\_handlers; -/\* Virtual translation table structure declarations \*/-struct pageUpperEntry {- uint64\_t present:1;- uint64\_t writable:1;- uint64\_t user:1;- uint64\_t write\_through:1;- uint64\_t cache\_disable:1;- uint64\_t accessed:1;- uint64\_t ignored\_06:1;- uint64\_t page\_size:1;- uint64\_t ignored\_11\_08:4;- uint64\_t pfn:40;- uint64\_t ignored\_62\_52:11;- uint64\_t execute\_disable:1;-};--struct pageTableEntry {- uint64\_t present:1;- uint64\_t writable:1;- uint64\_t user:1;- uint64\_t write\_through:1;- uint64\_t cache\_disable:1;- uint64\_t accessed:1;- uint64\_t dirty:1;- uint64\_t reserved\_07:1;- uint64\_t global:1;- uint64\_t ignored\_11\_09:3;- uint64\_t pfn:40;- uint64\_t ignored\_62\_52:11;- uint64\_t execute\_disable:1;-};- void regs\_dump(FILE \*stream, struct kvm\_regs \*regs, uint8\_t indent) {@@ -195,23 +163,21 @@ static void \*virt\_get\_pte(struct kvm\_vm \*vm, uint64\_t pt\_pfn, uint64\_t vaddr, return &page\_table[index]; } -static struct pageUpperEntry \*virt\_create\_upper\_pte(struct kvm\_vm \*vm,- uint64\_t pt\_pfn,- uint64\_t vaddr,- uint64\_t paddr,- int level,- enum x86\_page\_size page\_size)+static uint64\_t \*virt\_create\_upper\_pte(struct kvm\_vm \*vm,+ uint64\_t pt\_pfn,+ uint64\_t vaddr,+ uint64\_t paddr,+ int level,+ enum x86\_page\_size page\_size) {- struct pageUpperEntry \*pte = virt\_get\_pte(vm, pt\_pfn, vaddr, level);-- if (!pte->present) {- pte->writable = true;- pte->present = true;- pte->page\_size = (level == page\_size);- if (pte->page\_size)- pte->pfn = paddr >> vm->page\_shift;+ uint64\_t \*pte = virt\_get\_pte(vm, pt\_pfn, vaddr, level);++ if (!(\*pte & PTE\_PRESENT\_MASK)) {+ \*pte = PTE\_PRESENT\_MASK | PTE\_WRITABLE\_MASK;+ if (level == page\_size)+ \*pte |= PTE\_LARGE\_MASK | (paddr & PHYSICAL\_PAGE\_MASK); else- pte->pfn = vm\_alloc\_page\_table(vm) >> vm->page\_shift;+ \*pte |= vm\_alloc\_page\_table(vm) & PHYSICAL\_PAGE\_MASK; } else { /\* \* Entry already present. Assert that the caller doesn't want@@ -221,7 +187,7 @@ static struct pageUpperEntry \*virt\_create\_upper\_pte(struct kvm\_vm \*vm, TEST\_ASSERT(level != page\_size, "Cannot create hugepage at level: %u, vaddr: 0x%lx\n", page\_size, vaddr);- TEST\_ASSERT(!pte->page\_size,+ TEST\_ASSERT(!(\*pte & PTE\_LARGE\_MASK), "Cannot create page table at level: %u, vaddr: 0x%lx\n", level, vaddr); }@@ -232,8 +198,8 @@ void \_\_virt\_pg\_map(struct kvm\_vm \*vm, uint64\_t vaddr, uint64\_t paddr, enum x86\_page\_size page\_size) { const uint64\_t pg\_size = 1ull << ((page\_size \* 9) + 12);- struct pageUpperEntry \*pml4e, \*pdpe, \*pde;- struct pageTableEntry \*pte;+ uint64\_t \*pml4e, \*pdpe, \*pde;+ uint64\_t \*pte;  TEST\_ASSERT(vm->mode == VM\_MODE\_PXXV48\_4K, "Unknown or unsupported guest mode, mode: 0x%x", vm->mode);@@ -257,24 +223,22 @@ void \_\_virt\_pg\_map(struct kvm\_vm \*vm, uint64\_t vaddr, uint64\_t paddr, \*/ pml4e = virt\_create\_upper\_pte(vm, vm->pgd >> vm->page\_shift, vaddr, paddr, 3, page\_size);- if (pml4e->page\_size)+ if (\*pml4e & PTE\_LARGE\_MASK) return; - pdpe = virt\_create\_upper\_pte(vm, pml4e->pfn, vaddr, paddr, 2, page\_size);- if (pdpe->page\_size)+ pdpe = virt\_create\_upper\_pte(vm, PTE\_GET\_PFN(\*pml4e), vaddr, paddr, 2, page\_size);+ if (\*pdpe & PTE\_LARGE\_MASK) return; - pde = virt\_create\_upper\_pte(vm, pdpe->pfn, vaddr, paddr, 1, page\_size);- if (pde->page\_size)+ pde = virt\_create\_upper\_pte(vm, PTE\_GET\_PFN(\*pdpe), vaddr, paddr, 1, page\_size);+ if (\*pde & PTE\_LARGE\_MASK) return;  /\* Fill in page table entry. \*/- pte = virt\_get\_pte(vm, pde->pfn, vaddr, 0);- TEST\_ASSERT(!pte->present,+ pte = virt\_get\_pte(vm, PTE\_GET\_PFN(\*pde), vaddr, 0);+ TEST\_ASSERT(!(\*pte & PTE\_PRESENT\_MASK), "PTE already present for 4k page at vaddr: 0x%lx\n", vaddr);- pte->pfn = paddr >> vm->page\_shift;- pte->writable = true;- pte->present = 1;+ \*pte = PTE\_PRESENT\_MASK | PTE\_WRITABLE\_MASK | (paddr & PHYSICAL\_PAGE\_MASK); }  void virt\_pg\_map(struct kvm\_vm \*vm, uint64\_t vaddr, uint64\_t paddr)@@ -282,22 +246,22 @@ void virt\_pg\_map(struct kvm\_vm \*vm, uint64\_t vaddr, uint64\_t paddr) \_\_virt\_pg\_map(vm, vaddr, paddr, X86\_PAGE\_SIZE\_4K); } -static struct pageTableEntry \*\_vm\_get\_page\_table\_entry(struct kvm\_vm \*vm, int vcpuid,+static uint64\_t \*\_vm\_get\_page\_table\_entry(struct kvm\_vm \*vm, int vcpuid, uint64\_t vaddr) { uint16\_t index[4];- struct pageUpperEntry \*pml4e, \*pdpe, \*pde;- struct pageTableEntry \*pte;+ uint64\_t \*pml4e, \*pdpe, \*pde;+ uint64\_t \*pte; struct kvm\_cpuid\_entry2 \*entry; struct kvm\_sregs sregs; int max\_phy\_addr;- /\* Set the bottom 52 bits. \*/- uint64\_t rsvd\_mask = 0x000fffffffffffff;+ uint64\_t rsvd\_mask = 0;  entry = kvm\_get\_supported\_cpuid\_index(0x80000008, 0); max\_phy\_addr = entry->eax & 0x000000ff;- /\* Clear the bottom bits of the reserved mask. \*/- rsvd\_mask = (rsvd\_mask >> max\_phy\_addr) << max\_phy\_addr;+ /\* Set the high bits in the reserved mask. \*/+ if (max\_phy\_addr < 52)+ rsvd\_mask = GENMASK\_ULL(51, max\_phy\_addr);  /\* \* SDM vol 3, fig 4-11 "Formats of CR3 and Paging-Structure Entries@@ -307,7 +271,7 @@ static struct pageTableEntry \*\_vm\_get\_page\_table\_entry(struct kvm\_vm \*vm, int vc \*/ vcpu\_sregs\_get(vm, vcpuid, &sregs); if ((sregs.efer & EFER\_NX) == 0) {- rsvd\_mask |= (1ull << 63);+ rsvd\_mask |= PTE\_NX\_MASK; }  TEST\_ASSERT(vm->mode == VM\_MODE\_PXXV48\_4K, "Attempt to use "@@ -329,30 +293,29 @@ static struct pageTableEntry \*\_vm\_get\_page\_table\_entry(struct kvm\_vm \*vm, int vc index[3] = (vaddr >> 39) & 0x1ffu;  pml4e = addr\_gpa2hva(vm, vm->pgd);- TEST\_ASSERT(pml4e[index[3]].present,+ TEST\_ASSERT(pml4e[index[3]] & PTE\_PRESENT\_MASK, "Expected pml4e to be present for gva: 0x%08lx", vaddr);- TEST\_ASSERT((\*(uint64\_t\*)(&pml4e[index[3]]) &- (rsvd\_mask | (1ull << 7))) == 0,+ TEST\_ASSERT((pml4e[index[3]] & (rsvd\_mask | PTE\_LARGE\_MASK)) == 0, "Unexpected reserved bits set."); - pdpe = addr\_gpa2hva(vm, pml4e[index[3]].pfn \* vm->page\_size);- TEST\_ASSERT(pdpe[index[2]].present,+ pdpe = addr\_gpa2hva(vm, PTE\_GET\_PFN(pml4e[index[3]]) \* vm->page\_size);+ TEST\_ASSERT(pdpe[index[2]] & PTE\_PRESENT\_MASK, "Expected pdpe to be present for gva: 0x%08lx", vaddr);- TEST\_ASSERT(pdpe[index[2]].page\_size == 0,+ TEST\_ASSERT(!(pdpe[index[2]] & PTE\_LARGE\_MASK), "Expected pdpe to map a pde not a 1-GByte page.");- TEST\_ASSERT((\*(uint64\_t\*)(&pdpe[index[2]]) & rsvd\_mask) == 0,+ TEST\_ASSERT((pdpe[index[2]] & rsvd\_mask) == 0, "Unexpected reserved bits set."); - pde = addr\_gpa2hva(vm, pdpe[index[2]].pfn \* vm->page\_size);- TEST\_ASSERT(pde[index[1]].present,+ pde = addr\_gpa2hva(vm, PTE\_GET\_PFN(pdpe[index[2]]) \* vm->page\_size);+ TEST\_ASSERT(pde[index[1]] & PTE\_PRESENT\_MASK, "Expected pde to be present for gva: 0x%08lx", vaddr);- TEST\_ASSERT(pde[index[1]].page\_size == 0,+ TEST\_ASSERT(!(pde[index[1]] & PTE\_LARGE\_MASK), "Expected pde to map a pte not a 2-MByte page.");- TEST\_ASSERT((\*(uint64\_t\*)(&pde[index[1]]) & rsvd\_mask) == 0,+ TEST\_ASSERT((pde[index[1]] & rsvd\_mask) == 0, "Unexpected reserved bits set."); - pte = addr\_gpa2hva(vm, pde[index[1]].pfn \* vm->page\_size);- TEST\_ASSERT(pte[index[0]].present,+ pte = addr\_gpa2hva(vm, PTE\_GET\_PFN(pde[index[1]]) \* vm->page\_size);+ TEST\_ASSERT(pte[index[0]] & PTE\_PRESENT\_MASK, "Expected pte to be present for gva: 0x%08lx", vaddr);  return &pte[index[0]];@@ -360,7 +323,7 @@ static struct pageTableEntry \*\_vm\_get\_page\_table\_entry(struct kvm\_vm \*vm, int vc  uint64\_t vm\_get\_page\_table\_entry(struct kvm\_vm \*vm, int vcpuid, uint64\_t vaddr) {- struct pageTableEntry \*pte = \_vm\_get\_page\_table\_entry(vm, vcpuid, vaddr);+ uint64\_t \*pte = \_vm\_get\_page\_table\_entry(vm, vcpuid, vaddr);  return \*(uint64\_t \*)pte; }@@ -368,18 +331,17 @@ uint64\_t vm\_get\_page\_table\_entry(struct kvm\_vm \*vm, int vcpuid, uint64\_t vaddr) void vm\_set\_page\_table\_entry(struct kvm\_vm \*vm, int vcpuid, uint64\_t vaddr, uint64\_t pte) {- struct pageTableEntry \*new\_pte = \_vm\_get\_page\_table\_entry(vm, vcpuid,- vaddr);+ uint64\_t \*new\_pte = \_vm\_get\_page\_table\_entry(vm, vcpuid, vaddr);  \*(uint64\_t \*)new\_pte = pte; }  void virt\_dump(FILE \*stream, struct kvm\_vm \*vm, uint8\_t indent) {- struct pageUpperEntry \*pml4e, \*pml4e\_start;- struct pageUpperEntry \*pdpe, \*pdpe\_start;- struct pageUpperEntry \*pde, \*pde\_start;- struct pageTableEntry \*pte, \*pte\_start;+ uint64\_t \*pml4e, \*pml4e\_start;+ uint64\_t \*pdpe, \*pdpe\_start;+ uint64\_t \*pde, \*pde\_start;+ uint64\_t \*pte, \*pte\_start;  if (!vm->pgd\_created) return;@@ -389,58 +351,58 @@ void virt\_dump(FILE \*stream, struct kvm\_vm \*vm, uint8\_t indent) fprintf(stream, "%\*s index hvaddr gpaddr " "addr w exec dirty\n", indent, "");- pml4e\_start = (struct pageUpperEntry \*) addr\_gpa2hva(vm, vm->pgd);+ pml4e\_start = (uint64\_t \*) addr\_gpa2hva(vm, vm->pgd); for (uint16\_t n1 = 0; n1 <= 0x1ffu; n1++) { pml4e = &pml4e\_start[n1];- if (!pml4e->present)+ if (!(\*pml4e & PTE\_PRESENT\_MASK)) continue;- fprintf(stream, "%\*spml4e 0x%-3zx %p 0x%-12lx 0x%-10lx %u "+ fprintf(stream, "%\*spml4e 0x%-3zx %p 0x%-12lx 0x%-10llx %u " " %u\n", indent, "", pml4e - pml4e\_start, pml4e,- addr\_hva2gpa(vm, pml4e), (uint64\_t) pml4e->pfn,- pml4e->writable, pml4e->execute\_disable);+ addr\_hva2gpa(vm, pml4e), PTE\_GET\_PFN(\*pml4e),+ !!(\*pml4e & PTE\_WRITABLE\_MASK), !!(\*pml4e & PTE\_NX\_MASK)); - pdpe\_start = addr\_gpa2hva(vm, pml4e->pfn \* vm->page\_size);+ pdpe\_start = addr\_gpa2hva(vm, \*pml4e & PHYSICAL\_PAGE\_MASK); for (uint16\_t n2 = 0; n2 <= 0x1ffu; n2++) { pdpe = &pdpe\_start[n2];- if (!pdpe->present)+ if (!(\*pdpe & PTE\_PRESENT\_MASK)) continue;- fprintf(stream, "%\*spdpe 0x%-3zx %p 0x%-12lx 0x%-10lx "+ fprintf(stream, "%\*spdpe 0x%-3zx %p 0x%-12lx 0x%-10llx " "%u %u\n", indent, "", pdpe - pdpe\_start, pdpe, addr\_hva2gpa(vm, pdpe),- (uint64\_t) pdpe->pfn, pdpe->writable,- pdpe->execute\_disable);+ PTE\_GET\_PFN(\*pdpe), !!(\*pdpe & PTE\_WRITABLE\_MASK),+ !!(\*pdpe & PTE\_NX\_MASK)); - pde\_start = addr\_gpa2hva(vm, pdpe->pfn \* vm->page\_size);+ pde\_start = addr\_gpa2hva(vm, \*pdpe & PHYSICAL\_PAGE\_MASK); for (uint16\_t n3 = 0; n3 <= 0x1ffu; n3++) { pde = &pde\_start[n3];- if (!pde->present)+ if (!(\*pde & PTE\_PRESENT\_MASK)) continue; fprintf(stream, "%\*spde 0x%-3zx %p "- "0x%-12lx 0x%-10lx %u %u\n",+ "0x%-12lx 0x%-10llx %u %u\n", indent, "", pde - pde\_start, pde, addr\_hva2gpa(vm, pde),- (uint64\_t) pde->pfn, pde->writable,- pde->execute\_disable);+ PTE\_GET\_PFN(\*pde), !!(\*pde & PTE\_WRITABLE\_MASK),+ !!(\*pde & PTE\_NX\_MASK)); - pte\_start = addr\_gpa2hva(vm, pde->pfn \* vm->page\_size);+ pte\_start = addr\_gpa2hva(vm, \*pde & PHYSICAL\_PAGE\_MASK); for (uint16\_t n4 = 0; n4 <= 0x1ffu; n4++) { pte = &pte\_start[n4];- if (!pte->present)+ if (!(\*pte & PTE\_PRESENT\_MASK)) continue; fprintf(stream, "%\*spte 0x%-3zx %p "- "0x%-12lx 0x%-10lx %u %u "+ "0x%-12lx 0x%-10llx %u %u " " %u 0x%-10lx\n", indent, "", pte - pte\_start, pte, addr\_hva2gpa(vm, pte),- (uint64\_t) pte->pfn,- pte->writable,- pte->execute\_disable,- pte->dirty,+ PTE\_GET\_PFN(\*pte),+ !!(\*pte & PTE\_WRITABLE\_MASK),+ !!(\*pte & PTE\_NX\_MASK),+ !!(\*pte & PTE\_DIRTY\_MASK), ((uint64\_t) n1 << 27) | ((uint64\_t) n2 << 18) | ((uint64\_t) n3 << 9)@@ -558,8 +520,8 @@ static void kvm\_seg\_set\_kernel\_data\_64bit(struct kvm\_vm \*vm, uint16\_t selector, vm\_paddr\_t addr\_gva2gpa(struct kvm\_vm \*vm, vm\_vaddr\_t gva) { uint16\_t index[4];- struct pageUpperEntry \*pml4e, \*pdpe, \*pde;- struct pageTableEntry \*pte;+ uint64\_t \*pml4e, \*pdpe, \*pde;+ uint64\_t \*pte;  TEST\_ASSERT(vm->mode == VM\_MODE\_PXXV48\_4K, "Attempt to use " "unknown or unsupported guest mode, mode: 0x%x", vm->mode);@@ -572,22 +534,22 @@ vm\_paddr\_t addr\_gva2gpa(struct kvm\_vm \*vm, vm\_vaddr\_t gva) if (!vm->pgd\_created) goto unmapped\_gva; pml4e = addr\_gpa2hva(vm, vm->pgd);- if (!pml4e[index[3]].present)+ if (!(pml4e[index[3]] & PTE\_PRESENT\_MASK)) goto unmapped\_gva; - pdpe = addr\_gpa2hva(vm, pml4e[index[3]].pfn \* vm->page\_size);- if (!pdpe[index[2]].present)+ pdpe = addr\_gpa2hva(vm, PTE\_GET\_PFN(pml4e[index[3]]) \* vm->page\_size);+ if (!(pdpe[index[2]] & PTE\_PRESENT\_MASK)) goto unmapped\_gva; - pde = addr\_gpa2hva(vm, pdpe[index[2]].pfn \* vm->page\_size);- if (!pde[index[1]].present)+ pde = addr\_gpa2hva(vm, PTE\_GET\_PFN(pdpe[index[2]]) \* vm->page\_size);+ if (!(pde[index[1]] & PTE\_PRESENT\_MASK)) goto unmapped\_gva; - pte = addr\_gpa2hva(vm, pde[index[1]].pfn \* vm->page\_size);- if (!pte[index[0]].present)+ pte = addr\_gpa2hva(vm, PTE\_GET\_PFN(pde[index[1]]) \* vm->page\_size);+ if (!(pte[index[0]] & PTE\_PRESENT\_MASK)) goto unmapped\_gva; - return (pte[index[0]].pfn \* vm->page\_size) + (gva & 0xfffu);+ return (PTE\_GET\_PFN(pte[index[0]]) \* vm->page\_size) + (gva & ~PAGE\_MASK);  unmapped\_gva: TEST\_FAIL("No mapping for vm virtual address, gva: 0x%lx", gva);diff --git a/tools/testing/selftests/kvm/x86\_64/amx\_test.c b/tools/testing/selftests/kvm/x86\_64/amx\_test.cindex 52a3ef6629e806..76f65c22796f2e 100644--- a/[tools/testing/selftests/kvm/x86\_64/amx\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/x86_64/amx_test.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[tools/testing/selftests/kvm/x86\_64/amx\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/x86_64/amx_test.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -29,7 +29,6 @@ #define X86\_FEATURE\_XSAVE (1 << 26) #define X86\_FEATURE\_OSXSAVE (1 << 27) -#define PAGE\_SIZE (1 << 12) #define NUM\_TILES 8 #define TILE\_SIZE 1024 #define XSAVE\_SIZE ((NUM\_TILES \* TILE\_SIZE) + PAGE\_SIZE)diff --git a/tools/testing/selftests/kvm/x86\_64/emulator\_error\_test.c b/tools/testing/selftests/kvm/x86\_64/emulator\_error\_test.cindex f070ff0224fa3f..aeb3850f81bd10 100644--- a/[tools/testing/selftests/kvm/x86\_64/emulator\_error\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/x86_64/emulator_error_test.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[tools/testing/selftests/kvm/x86\_64/emulator\_error\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/x86_64/emulator_error_test.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -12,7 +12,6 @@ #include "vmx.h"  #define VCPU\_ID 1-#define PAGE\_SIZE 4096 #define MAXPHYADDR 36  #define MEM\_REGION\_GVA 0x0000123456789000diff --git a/tools/testing/selftests/kvm/x86\_64/smm\_test.c b/tools/testing/selftests/kvm/x86\_64/smm\_test.cindex a626d40fdb4894..b4e0c860769e45 100644--- a/[tools/testing/selftests/kvm/x86\_64/smm\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/x86_64/smm_test.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[tools/testing/selftests/kvm/x86\_64/smm\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/x86_64/smm_test.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -21,8 +21,6 @@  #define VCPU\_ID 1 -#define PAGE\_SIZE 4096- #define SMRAM\_SIZE 65536 #define SMRAM\_MEMSLOT ((1 << 16) | 1) #define SMRAM\_PAGES (SMRAM\_SIZE / PAGE\_SIZE)diff --git a/tools/testing/selftests/kvm/x86\_64/vmx\_tsc\_adjust\_test.c b/tools/testing/selftests/kvm/x86\_64/vmx\_tsc\_adjust\_test.cindex e683d0ac3e45e1..19b35c607dc66c 100644--- a/[tools/testing/selftests/kvm/x86\_64/vmx\_tsc\_adjust\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/x86_64/vmx_tsc_adjust_test.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[tools/testing/selftests/kvm/x86\_64/vmx\_tsc\_adjust\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/x86_64/vmx_tsc_adjust_test.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -32,7 +32,6 @@ #define MSR\_IA32\_TSC\_ADJUST 0x3b #endif -#define PAGE\_SIZE 4096 #define VCPU\_ID 5  #define TSC\_ADJUST\_VALUE (1ll << 32)diff --git a/tools/testing/selftests/kvm/x86\_64/xen\_shinfo\_test.c b/tools/testing/selftests/kvm/x86\_64/xen\_shinfo\_test.cindex 865e17146815a6..bcd3708278593d 100644--- a/[tools/testing/selftests/kvm/x86\_64/xen\_shinfo\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/x86_64/xen_shinfo_test.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[tools/testing/selftests/kvm/x86\_64/xen\_shinfo\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/x86_64/xen_shinfo_test.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -23,7 +23,6 @@ #define SHINFO\_REGION\_GVA 0xc0000000ULL #define SHINFO\_REGION\_GPA 0xc0000000ULL #define SHINFO\_REGION\_SLOT 10-#define PAGE\_SIZE 4096  #define DUMMY\_REGION\_GPA (SHINFO\_REGION\_GPA + (2 \* PAGE\_SIZE)) #define DUMMY\_REGION\_SLOT 11diff --git a/tools/testing/selftests/kvm/x86\_64/xen\_vmcall\_test.c b/tools/testing/selftests/kvm/x86\_64/xen\_vmcall\_test.cindex adc94452b57c6c..b30fe9de1d4f6a 100644--- a/[tools/testing/selftests/kvm/x86\_64/xen\_vmcall\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/x86_64/xen_vmcall_test.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[tools/testing/selftests/kvm/x86\_64/xen\_vmcall\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/x86_64/xen_vmcall_test.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -15,7 +15,6 @@  #define HCALL\_REGION\_GPA 0xc0000000ULL #define HCALL\_REGION\_SLOT 10-#define PAGE\_SIZE 4096  static struct kvm\_vm \*vm; diff --git a/virt/kvm/dirty\_ring.c b/virt/kvm/dirty\_ring.cindex 222ecc81d7df2d..f4c2a6eb1666b9 100644--- a/[virt/kvm/dirty\_ring.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/virt/kvm/dirty_ring.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[virt/kvm/dirty\_ring.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/virt/kvm/dirty_ring.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -1,4 +1,4 @@-/\* SPDX-License-Identifier: GPL-2.0-only \*/+// SPDX-License-Identifier: GPL-2.0-only /\* \* KVM dirty ring implementation \*diff --git a/virt/kvm/kvm\_main.c b/virt/kvm/kvm\_main.cindex dfb7dabdbc63de..f30bb8c16f2659 100644--- a/[virt/kvm/kvm\_main.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/virt/kvm/kvm_main.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[virt/kvm/kvm\_main.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/virt/kvm/kvm_main.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -164,6 +164,10 @@ \_\_weak void kvm\_arch\_mmu\_notifier\_invalidate\_range(struct kvm \*kvm, { } +\_\_weak void kvm\_arch\_guest\_memory\_reclaimed(struct kvm \*kvm)+{+}+ bool kvm\_is\_zone\_device\_pfn(kvm\_pfn\_t pfn) { /\*@@ -357,6 +361,12 @@ void kvm\_flush\_remote\_tlbs(struct kvm \*kvm) EXPORT\_SYMBOL\_GPL(kvm\_flush\_remote\_tlbs); #endif +static void kvm\_flush\_shadow\_all(struct kvm \*kvm)+{+ kvm\_arch\_flush\_shadow\_all(kvm);+ kvm\_arch\_guest\_memory\_reclaimed(kvm);+}+ #ifdef KVM\_ARCH\_NR\_OBJS\_PER\_MEMORY\_CACHE static inline void \*mmu\_memory\_cache\_alloc\_obj(struct kvm\_mmu\_memory\_cache \*mc, gfp\_t gfp\_flags)@@ -485,12 +495,15 @@ typedef bool (\*hva\_handler\_t)(struct kvm \*kvm, struct kvm\_gfn\_range \*range); typedef void (\*on\_lock\_fn\_t)(struct kvm \*kvm, unsigned long start, unsigned long end); +typedef void (\*on\_unlock\_fn\_t)(struct kvm \*kvm);+ struct kvm\_hva\_range { unsigned long start; unsigned long end; pte\_t pte; hva\_handler\_t handler; on\_lock\_fn\_t on\_lock;+ on\_unlock\_fn\_t on\_unlock; bool flush\_on\_ret; bool may\_block; };@@ -578,8 +591,11 @@ static \_\_always\_inline int \_\_kvm\_handle\_hva\_range(struct kvm \*kvm, if (range->flush\_on\_ret && ret) kvm\_flush\_remote\_tlbs(kvm); - if (locked)+ if (locked) { KVM\_MMU\_UNLOCK(kvm);+ if (!IS\_KVM\_NULL\_FN(range->on\_unlock))+ range->on\_unlock(kvm);+ }  srcu\_read\_unlock(&kvm->srcu, idx); @@ -600,6 +616,7 @@ static \_\_always\_inline int kvm\_handle\_hva\_range(struct mmu\_notifier \*mn, .pte = pte, .handler = handler, .on\_lock = (void \*)kvm\_null\_fn,+ .on\_unlock = (void \*)kvm\_null\_fn, .flush\_on\_ret = true, .may\_block = false, };@@ -619,6 +636,7 @@ static \_\_always\_inline int kvm\_handle\_hva\_range\_no\_flush(struct mmu\_notifier \*mn .pte = \_\_pte(0), .handler = handler, .on\_lock = (void \*)kvm\_null\_fn,+ .on\_unlock = (void \*)kvm\_null\_fn, .flush\_on\_ret = false, .may\_block = false, };@@ -662,7 +680,7 @@ void kvm\_inc\_notifier\_count(struct kvm \*kvm, unsigned long start, kvm->mmu\_notifier\_range\_end = end; } else { /\*- \* Fully tracking multiple concurrent ranges has dimishing+ \* Fully tracking multiple concurrent ranges has diminishing \* returns. Keep things simple and just find the minimal range \* which includes the current and new ranges. As there won't be \* enough information to subtract a range after its invalidate@@ -687,6 +705,7 @@ static int kvm\_mmu\_notifier\_invalidate\_range\_start(struct mmu\_notifier \*mn, .pte = \_\_pte(0), .handler = kvm\_unmap\_gfn\_range, .on\_lock = kvm\_inc\_notifier\_count,+ .on\_unlock = kvm\_arch\_guest\_memory\_reclaimed, .flush\_on\_ret = true, .may\_block = mmu\_notifier\_range\_blockable(range), };@@ -741,6 +760,7 @@ static void kvm\_mmu\_notifier\_invalidate\_range\_end(struct mmu\_notifier \*mn, .pte = \_\_pte(0), .handler = (void \*)kvm\_null\_fn, .on\_lock = kvm\_dec\_notifier\_count,+ .on\_unlock = (void \*)kvm\_null\_fn, .flush\_on\_ret = false, .may\_block = mmu\_notifier\_range\_blockable(range), };@@ -813,7 +833,7 @@ static void kvm\_mmu\_notifier\_release(struct mmu\_notifier \*mn, int idx;  idx = srcu\_read\_lock(&kvm->srcu);- kvm\_arch\_flush\_shadow\_all(kvm);+ kvm\_flush\_shadow\_all(kvm); srcu\_read\_unlock(&kvm->srcu, idx); } @@ -955,12 +975,6 @@ static int kvm\_create\_vm\_debugfs(struct kvm \*kvm, int fd) int kvm\_debugfs\_num\_entries = kvm\_vm\_stats\_header.num\_desc + kvm\_vcpu\_stats\_header.num\_desc; - /\*- \* Force subsequent debugfs file creations to fail if the VM directory- \* is not created.- \*/- kvm->debugfs\_dentry = ERR\_PTR(-ENOENT);- if (!debugfs\_initialized()) return 0; @@ -1081,6 +1095,12 @@ static struct kvm \*kvm\_create\_vm(unsigned long type)  BUILD\_BUG\_ON(KVM\_MEM\_SLOTS\_NUM > SHRT\_MAX); + /\*+ \* Force subsequent debugfs file creations to fail if the VM directory+ \* is not created (by kvm\_create\_vm\_debugfs()).+ \*/+ kvm->debugfs\_dentry = ERR\_PTR(-ENOENT);+ if (init\_srcu\_struct(&kvm->srcu)) goto out\_err\_no\_srcu; if (init\_srcu\_struct(&kvm->irq\_srcu))@@ -1225,7 +1245,7 @@ static void kvm\_destroy\_vm(struct kvm \*kvm) WARN\_ON(rcuwait\_active(&kvm->mn\_memslots\_update\_rcuwait)); kvm->mn\_active\_invalidate\_count = 0; #else- kvm\_arch\_flush\_shadow\_all(kvm);+ kvm\_flush\_shadow\_all(kvm); #endif kvm\_arch\_destroy\_vm(kvm); kvm\_destroy\_devices(kvm);@@ -1652,6 +1672,7 @@ static void kvm\_invalidate\_memslot(struct kvm \*kvm, \* - kvm\_is\_visible\_gfn (mmu\_check\_root) \*/ kvm\_arch\_flush\_shadow\_memslot(kvm, old);+ kvm\_arch\_guest\_memory\_reclaimed(kvm);  /\* Was released by kvm\_swap\_active\_memslots, reacquire. \*/ mutex\_lock(&kvm->slots\_arch\_lock);@@ -1799,7 +1820,7 @@ static int kvm\_set\_memslot(struct kvm \*kvm,  /\* \* No need to refresh new->arch, changes after dropping slots\_arch\_lock- \* will directly hit the final, active memsot. Architectures are+ \* will directly hit the final, active memslot. Architectures are \* responsible for knowing that new->arch may be stale. \*/ kvm\_commit\_memory\_region(kvm, old, new, change);diff --git a/virt/kvm/kvm\_mm.h b/virt/kvm/kvm\_mm.hindex 34ca40823260da..41da467d99c95e 100644--- a/[virt/kvm/kvm\_mm.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/virt/kvm/kvm_mm.h?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[virt/kvm/kvm\_mm.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/virt/kvm/kvm_mm.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -1,4 +1,4 @@-// SPDX-License-Identifier: GPL-2.0-only+/\* SPDX-License-Identifier: GPL-2.0-only \*/  #ifndef \_\_KVM\_MM\_H\_\_ #define \_\_KVM\_MM\_H\_\_ 1 |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-08 15:11:23 +0000



=== Content from lkml.iu.edu_70a3c81a_20250108_151247.html ===


# [GIT PULL] x86/seves for v5.10

**From:** Borislav Petkov

**Date:**  Tue Oct 13 2020 - 07:08:36 EST

* **Next message:**   [Daniel Vetter: "Re: [PATCH v2 22/22] drm/msm: Don't implicit-sync if only a single ring"](05073.html)* **Previous message:**   [Sargun Dhillon: "[RFC PATCH] nfs: Use cred from fscontext during fsmount"](05071.html)* **Next in thread:**   [pr-tracker-bot: "Re: [GIT PULL] x86/seves for v5.10"](06629.html)* **Messages sorted by:** [[ date ]](date.html#05072) [[ thread ]](index.html#05072) [[ subject ]](subject.html#05072) [[ author ]](author.html#05072)

---

Hi Linus,

please pull the pile which enables Linux to run as an SEV-ES guest on an

AMD hypervisor.

Thx.

---

The following changes since commit f4d51dffc6c01a9e94650d95ce0104964f8ae822:

Linux 5.9-rc4 (2020-09-06 17:11:40 -0700)

are available in the Git repository at:

git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git tags/x86\_seves\_for\_v5.10

for you to fetch changes up to 0ddfb1cf3b6b07c97cff16ea69931d986f9622ee:

x86/sev-es: Use GHCB accessor for setting the MMIO scratch buffer (2020-09-25 17:12:41 +0200)

----------------------------------------------------------------

This feature enhances the current guest memory encryption support

called SEV by also encrypting the guest register state, making the

registers inaccessible to the hypervisor by en-/decrypting them on world

switches. Thus, it adds additional protection to Linux guests against

exfiltration, control flow and rollback attacks.

With SEV-ES, the guest is in full control of what registers the

hypervisor can access. This is provided by a guest-host exchange

mechanism based on a new exception vector called VMM Communication

Exception (#VC), a new instruction called VMGEXIT and a shared

Guest-Host Communication Block which is a decrypted page shared between

the guest and the hypervisor.

Intercepts to the hypervisor become #VC exceptions in an SEV-ES guest so

in order for that exception mechanism to work, the early x86 init code

needed to be made able to handle exceptions, which, in itself, brings

a bunch of very nice cleanups and improvements to the early boot code

like an early page fault handler, allowing for on-demand building of the

identity mapping. With that, !KASLR configurations do not use the EFI

page table anymore but switch to a kernel-controlled one.

The main part of this series adds the support for that new exchange

mechanism. The goal has been to keep this as much as possibly

separate from the core x86 code by concentrating the machinery in two

SEV-ES-specific files:

arch/x86/kernel/sev-es-shared.c

arch/x86/kernel/sev-es.c

Other interaction with core x86 code has been kept at minimum and behind

static keys to minimize the performance impact on !SEV-ES setups.

Work by Joerg Roedel and Thomas Lendacky and others.

----------------------------------------------------------------

Borislav Petkov (3):

Merge 'x86/kaslr' to pick up dependent bits

Merge 'x86/cpu' to pick up dependent bits

KVM: SVM: Use \_\_packed shorthand

Doug Covelli (1):

x86/vmware: Add VMware-specific handling for VMMCALL under SEV-ES

Joerg Roedel (50):

KVM: SVM: nested: Don't allocate VMCB structures on stack

KVM: SVM: Add GHCB Accessor functions

x86/traps: Move pf error codes to <asm/trap\_pf.h>

x86/insn: Make inat-tables.c suitable for pre-decompression code

x86/umip: Factor out instruction fetch

x86/umip: Factor out instruction decoding

x86/insn: Add insn\_get\_modrm\_reg\_off()

x86/insn: Add insn\_has\_rep\_prefix() helper

x86/boot/compressed/64: Disable red-zone usage

x86/boot/compressed/64: Add IDT Infrastructure

x86/boot/compressed/64: Rename kaslr\_64.c to ident\_map\_64.c

x86/boot/compressed/64: Add page-fault handler

x86/boot/compressed/64: Always switch to own page table

x86/boot/compressed/64: Don't pre-map memory in KASLR code

x86/boot/compressed/64: Change add\_identity\_map() to take start and end

x86/boot/compressed/64: Add stage1 #VC handler

x86/boot/compressed/64: Call set\_sev\_encryption\_mask() earlier

x86/boot/compressed/64: Check return value of kernel\_ident\_mapping\_init()

x86/boot/compressed/64: Add set\_page\_en/decrypted() helpers

x86/boot/compressed/64: Setup a GHCB-based VC Exception handler

x86/boot/compressed/64: Unmap GHCB page before booting the kernel

x86/fpu: Move xgetbv()/xsetbv() into a separate header

x86/idt: Split idt\_data setup out of set\_intr\_gate()

x86/head/64: Install startup GDT

x86/head/64: Load GDT after switch to virtual addresses

x86/head/64: Load segment registers earlier

x86/head/64: Switch to initial stack earlier

x86/head/64: Install a CPU bringup IDT

x86/idt: Make IDT init functions static inlines

x86/head/64: Move early exception dispatch to C code

x86/sev-es: Add SEV-ES Feature Detection

x86/sev-es: Print SEV-ES info into the kernel log

x86/sev-es: Compile early handler code into kernel image

x86/sev-es: Setup an early #VC handler

x86/sev-es: Setup GHCB-based boot #VC handler

x86/sev-es: Allocate and map an IST stack for #VC handler

x86/sev-es: Adjust #VC IST Stack on entering NMI handler

x86/dumpstack/64: Add noinstr version of get\_stack\_info()

x86/entry/64: Add entry code for #VC handler

x86/sev-es: Wire up existing #VC exit-code handlers

x86/sev-es: Handle instruction fetches from user-space

x86/sev-es: Handle MMIO String Instructions

x86/sev-es: Handle #AC Events

x86/sev-es: Handle #DB Events

x86/paravirt: Allow hypervisor-specific VMMCALL handling under SEV-ES

x86/realmode: Add SEV-ES specific trampoline entry point

x86/smpboot: Load TSS and getcpu GDT entry before loading IDT

x86/head/64: Don't call verify\_cpu() on starting APs

x86/sev-es: Support CPU offline/online

x86/sev-es: Handle NMI State

Martin Radev (1):

x86/sev-es: Check required CPU features for SEV-ES

Tom Lendacky (20):

KVM: SVM: Add GHCB definitions

x86/cpufeatures: Add SEV-ES CPU feature

x86/sev-es: Add support for handling IOIO exceptions

x86/sev-es: Add CPUID handling to #VC handler

x86/sev-es: Setup per-CPU GHCBs for the runtime handler

x86/sev-es: Add a Runtime #VC Exception Handler

x86/sev-es: Handle MMIO events

x86/sev-es: Handle MSR events

x86/sev-es: Handle DR7 read/write events

x86/sev-es: Handle WBINVD Events

x86/sev-es: Handle RDTSC(P) Events

x86/sev-es: Handle RDPMC Events

x86/sev-es: Handle INVD Events

x86/sev-es: Handle MONITOR/MONITORX Events

x86/sev-es: Handle MWAIT/MWAITX Events

x86/sev-es: Handle VMMCALL Events

x86/kvm: Add KVM-specific VMMCALL handling under SEV-ES

x86/realmode: Setup AP jump table

x86/efi: Add GHCB mappings when SEV-ES is active

x86/sev-es: Use GHCB accessor for setting the MMIO scratch buffer

arch/x86/Kconfig | 1 +

arch/x86/boot/compressed/Makefile | 11 +-

arch/x86/boot/compressed/cpuflags.c | 4 -

arch/x86/boot/compressed/head\_64.S | 33 +-

arch/x86/boot/compressed/ident\_map\_64.c | 349 +++++++

arch/x86/boot/compressed/idt\_64.c | 54 ++

arch/x86/boot/compressed/idt\_handlers\_64.S | 77 ++

arch/x86/boot/compressed/kaslr.c | 266 ++----

arch/x86/boot/compressed/kaslr\_64.c | 153 ---

arch/x86/boot/compressed/misc.c | 7 +

arch/x86/boot/compressed/misc.h | 54 +-

arch/x86/boot/compressed/sev-es.c | 214 +++++

arch/x86/entry/entry\_64.S | 80 ++

arch/x86/include/asm/cpu\_entry\_area.h | 33 +-

arch/x86/include/asm/cpufeatures.h | 2 +

arch/x86/include/asm/desc.h | 27 +

arch/x86/include/asm/desc\_defs.h | 10 +

arch/x86/include/asm/fpu/internal.h | 33 +-

arch/x86/include/asm/fpu/xcr.h | 34 +

arch/x86/include/asm/idtentry.h | 50 +

arch/x86/include/asm/insn-eval.h | 6 +

arch/x86/include/asm/mem\_encrypt.h | 5 +

arch/x86/include/asm/msr-index.h | 3 +

arch/x86/include/asm/page\_64\_types.h | 1 +

arch/x86/include/asm/pgtable.h | 2 +-

arch/x86/include/asm/processor.h | 1 +

arch/x86/include/asm/proto.h | 1 +

arch/x86/include/asm/realmode.h | 7 +

arch/x86/include/asm/segment.h | 2 +-

arch/x86/include/asm/setup.h | 6 +-

arch/x86/include/asm/sev-es.h | 114 +++

arch/x86/include/asm/special\_insns.h | 6 +

arch/x86/include/asm/stacktrace.h | 2 +

arch/x86/include/asm/svm.h | 106 ++-

arch/x86/include/asm/sync\_core.h | 34 +-

arch/x86/include/asm/trap\_pf.h | 24 +

arch/x86/include/asm/trapnr.h | 1 +

arch/x86/include/asm/traps.h | 20 +-

arch/x86/include/asm/x86\_init.h | 16 +-

arch/x86/include/uapi/asm/svm.h | 11 +

arch/x86/kernel/Makefile | 3 +

arch/x86/kernel/cpu/amd.c | 3 +-

arch/x86/kernel/cpu/common.c | 25 +

arch/x86/kernel/cpu/scattered.c | 1 +

arch/x86/kernel/cpu/vmware.c | 50 +-

arch/x86/kernel/dumpstack.c | 7 +-

arch/x86/kernel/dumpstack\_64.c | 46 +-

arch/x86/kernel/head64.c | 122 ++-

arch/x86/kernel/head\_64.S | 165 +++-

arch/x86/kernel/idt.c | 41 +-

arch/x86/kernel/kvm.c | 35 +-

arch/x86/kernel/nmi.c | 15 +

arch/x86/kernel/sev-es-shared.c | 507 ++++++++++

arch/x86/kernel/sev-es.c | 1404 ++++++++++++++++++++++++++++

arch/x86/kernel/smpboot.c | 2 +-

arch/x86/kernel/traps.c | 48 +

arch/x86/kernel/umip.c | 89 +-

arch/x86/kvm/cpuid.c | 2 +-

arch/x86/kvm/svm/nested.c | 47 +-

arch/x86/kvm/svm/svm.c | 2 +

arch/x86/lib/insn-eval.c | 130 +++

arch/x86/mm/cpu\_entry\_area.c | 3 +-

arch/x86/mm/extable.c | 1 +

arch/x86/mm/mem\_encrypt.c | 38 +-

arch/x86/mm/mem\_encrypt\_identity.c | 3 +

arch/x86/platform/efi/efi\_64.c | 10 +

arch/x86/realmode/init.c | 24 +-

arch/x86/realmode/rm/header.S | 3 +

arch/x86/realmode/rm/trampoline\_64.S | 20 +

arch/x86/tools/gen-insn-attr-x86.awk | 50 +-

tools/arch/x86/tools/gen-insn-attr-x86.awk | 50 +-

71 files changed, 4195 insertions(+), 611 deletions(-)

create mode 100644 arch/x86/boot/compressed/ident\_map\_64.c

create mode 100644 arch/x86/boot/compressed/idt\_64.c

create mode 100644 arch/x86/boot/compressed/idt\_handlers\_64.S

delete mode 100644 arch/x86/boot/compressed/kaslr\_64.c

create mode 100644 arch/x86/boot/compressed/sev-es.c

create mode 100644 arch/x86/include/asm/fpu/xcr.h

create mode 100644 arch/x86/include/asm/sev-es.h

create mode 100644 arch/x86/include/asm/trap\_pf.h

create mode 100644 arch/x86/kernel/sev-es-shared.c

create mode 100644 arch/x86/kernel/sev-es.c

--

Regards/Gruss,

Boris.

SUSE Software Solutions Germany GmbH, GF: Felix ImendÃ¶rffer, HRB 36809, AG NÃ¼rnberg

---

* **Next message:**   [Daniel Vetter: "Re: [PATCH v2 22/22] drm/msm: Don't implicit-sync if only a single ring"](05073.html)* **Previous message:**   [Sargun Dhillon: "[RFC PATCH] nfs: Use cred from fscontext during fsmount"](05071.html)* **Next in thread:**   [pr-tracker-bot: "Re: [GIT PULL] x86/seves for v5.10"](06629.html)* **Messages sorted by:** [[ date ]](date.html#05072) [[ thread ]](index.html#05072) [[ subject ]](subject.html#05072) [[ author ]](author.html#05072)



=== Content from git.kernel.org_494f69fd_20250108_151248.html ===


| [cgit logo](/) | [index](/) : [kernel/git/torvalds/linux.git](/pub/scm/linux/kernel/git/torvalds/linux.git/) | for-next master vsnprintf |
| --- | --- | --- |
| Linux kernel source tree | Linus Torvalds |

| [about](/pub/scm/linux/kernel/git/torvalds/linux.git/about/)[summary](/pub/scm/linux/kernel/git/torvalds/linux.git/)[refs](/pub/scm/linux/kernel/git/torvalds/linux.git/refs/?id=683412ccf61294d727ead4a73d97397396e69a6b)[log](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)[tree](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=683412ccf61294d727ead4a73d97397396e69a6b)[commit](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=683412ccf61294d727ead4a73d97397396e69a6b)[diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=683412ccf61294d727ead4a73d97397396e69a6b)[stats](/pub/scm/linux/kernel/git/torvalds/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Mingwei Zhang <mizhang@google.com> | 2022-04-21 03:14:07 +0000 |
| --- | --- | --- |
| committer | Paolo Bonzini <pbonzini@redhat.com> | 2022-04-21 15:41:00 -0400 |
| commit | [683412ccf61294d727ead4a73d97397396e69a6b](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=683412ccf61294d727ead4a73d97397396e69a6b) ([patch](/pub/scm/linux/kernel/git/torvalds/linux.git/patch/?id=683412ccf61294d727ead4a73d97397396e69a6b)) | |
| tree | [2e1f2e5ff4031699ee51b45341590461565f36fc](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=683412ccf61294d727ead4a73d97397396e69a6b) | |
| parent | [d45829b351ee6ec5f54dd55e6aca1f44fe239fe6](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=d45829b351ee6ec5f54dd55e6aca1f44fe239fe6) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=683412ccf61294d727ead4a73d97397396e69a6b&id2=d45829b351ee6ec5f54dd55e6aca1f44fe239fe6)) | |
| download | [linux-683412ccf61294d727ead4a73d97397396e69a6b.tar.gz](/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-683412ccf61294d727ead4a73d97397396e69a6b.tar.gz) | |

KVM: SEV: add cache flush to solve SEV cache incoherency issuesFlush the CPU caches when memory is reclaimed from an SEV guest (where
reclaim also includes it being unmapped from KVM's memslots). Due to lack
of coherency for SEV encrypted memory, failure to flush results in silent
data corruption if userspace is malicious/broken and doesn't ensure SEV
guest memory is properly pinned and unpinned.
Cache coherency is not enforced across the VM boundary in SEV (AMD APM
vol.2 Section 15.34.7). Confidential cachelines, generated by confidential
VM guests have to be explicitly flushed on the host side. If a memory page
containing dirty confidential cachelines was released by VM and reallocated
to another user, the cachelines may corrupt the new user at a later time.
KVM takes a shortcut by assuming all confidential memory remain pinned
until the end of VM lifetime. Therefore, KVM does not flush cache at
mmu\_notifier invalidation events. Because of this incorrect assumption and
the lack of cache flushing, malicous userspace can crash the host kernel:
creating a malicious VM and continuously allocates/releases unpinned
confidential memory pages when the VM is running.
Add cache flush operations to mmu\_notifier operations to ensure that any
physical memory leaving the guest VM get flushed. In particular, hook
mmu\_notifier\_invalidate\_range\_start and mmu\_notifier\_release events and
flush cache accordingly. The hook after releasing the mmu lock to avoid
contention with other vCPUs.
Cc: stable@vger.kernel.org
Suggested-by: Sean Christpherson <seanjc@google.com>
Reported-by: Mingwei Zhang <mizhang@google.com>
Signed-off-by: Mingwei Zhang <mizhang@google.com>
Message-Id: <20220421031407.2516575-4-mizhang@google.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
[Diffstat](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=683412ccf61294d727ead4a73d97397396e69a6b)

| -rw-r--r-- | [arch/x86/include/asm/kvm-x86-ops.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/include/asm/kvm-x86-ops.h?id=683412ccf61294d727ead4a73d97397396e69a6b) | 1 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [arch/x86/include/asm/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/include/asm/kvm_host.h?id=683412ccf61294d727ead4a73d97397396e69a6b) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/svm/sev.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kvm/svm/sev.c?id=683412ccf61294d727ead4a73d97397396e69a6b) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/svm/svm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kvm/svm/svm.c?id=683412ccf61294d727ead4a73d97397396e69a6b) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/svm/svm.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kvm/svm/svm.h?id=683412ccf61294d727ead4a73d97397396e69a6b) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/x86.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kvm/x86.c?id=683412ccf61294d727ead4a73d97397396e69a6b) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/linux/kvm_host.h?id=683412ccf61294d727ead4a73d97397396e69a6b) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [virt/kvm/kvm\_main.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/virt/kvm/kvm_main.c?id=683412ccf61294d727ead4a73d97397396e69a6b) | 27 | |  |  |  | | --- | --- | --- | |

8 files changed, 44 insertions, 3 deletions

| diff --git a/arch/x86/include/asm/kvm-x86-ops.h b/arch/x86/include/asm/kvm-x86-ops.hindex 3c368b639c0462..1a6d7e3f6c32c7 100644--- a/[arch/x86/include/asm/kvm-x86-ops.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/include/asm/kvm-x86-ops.h?id=d45829b351ee6ec5f54dd55e6aca1f44fe239fe6)+++ b/[arch/x86/include/asm/kvm-x86-ops.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/include/asm/kvm-x86-ops.h?id=683412ccf61294d727ead4a73d97397396e69a6b)@@ -118,6 +118,7 @@ KVM\_X86\_OP\_OPTIONAL(mem\_enc\_register\_region) KVM\_X86\_OP\_OPTIONAL(mem\_enc\_unregister\_region) KVM\_X86\_OP\_OPTIONAL(vm\_copy\_enc\_context\_from) KVM\_X86\_OP\_OPTIONAL(vm\_move\_enc\_context\_from)+KVM\_X86\_OP\_OPTIONAL(guest\_memory\_reclaimed) KVM\_X86\_OP(get\_msr\_feature) KVM\_X86\_OP(can\_emulate\_instruction) KVM\_X86\_OP(apic\_init\_signal\_blocked)diff --git a/arch/x86/include/asm/kvm\_host.h b/arch/x86/include/asm/kvm\_host.hindex e0c0f0e1f754c1..4ff36610af6ab5 100644--- a/[arch/x86/include/asm/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/include/asm/kvm_host.h?id=d45829b351ee6ec5f54dd55e6aca1f44fe239fe6)+++ b/[arch/x86/include/asm/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/include/asm/kvm_host.h?id=683412ccf61294d727ead4a73d97397396e69a6b)@@ -1484,6 +1484,7 @@ struct kvm\_x86\_ops { int (\*mem\_enc\_unregister\_region)(struct kvm \*kvm, struct kvm\_enc\_region \*argp); int (\*vm\_copy\_enc\_context\_from)(struct kvm \*kvm, unsigned int source\_fd); int (\*vm\_move\_enc\_context\_from)(struct kvm \*kvm, unsigned int source\_fd);+ void (\*guest\_memory\_reclaimed)(struct kvm \*kvm);  int (\*get\_msr\_feature)(struct kvm\_msr\_entry \*entry); diff --git a/arch/x86/kvm/svm/sev.c b/arch/x86/kvm/svm/sev.cindex 9a037598702936..0ad70c12c7c311 100644--- a/[arch/x86/kvm/svm/sev.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/svm/sev.c?id=d45829b351ee6ec5f54dd55e6aca1f44fe239fe6)+++ b/[arch/x86/kvm/svm/sev.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/svm/sev.c?id=683412ccf61294d727ead4a73d97397396e69a6b)@@ -2262,6 +2262,14 @@ do\_wbinvd: wbinvd\_on\_all\_cpus(); } +void sev\_guest\_memory\_reclaimed(struct kvm \*kvm)+{+ if (!sev\_guest(kvm))+ return;++ wbinvd\_on\_all\_cpus();+}+ void sev\_free\_vcpu(struct kvm\_vcpu \*vcpu) { struct vcpu\_svm \*svm;diff --git a/arch/x86/kvm/svm/svm.c b/arch/x86/kvm/svm/svm.cindex bd4c64b362d24a..7e45d03cd018a5 100644--- a/[arch/x86/kvm/svm/svm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/svm/svm.c?id=d45829b351ee6ec5f54dd55e6aca1f44fe239fe6)+++ b/[arch/x86/kvm/svm/svm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/svm/svm.c?id=683412ccf61294d727ead4a73d97397396e69a6b)@@ -4620,6 +4620,7 @@ static struct kvm\_x86\_ops svm\_x86\_ops \_\_initdata = { .mem\_enc\_ioctl = sev\_mem\_enc\_ioctl, .mem\_enc\_register\_region = sev\_mem\_enc\_register\_region, .mem\_enc\_unregister\_region = sev\_mem\_enc\_unregister\_region,+ .guest\_memory\_reclaimed = sev\_guest\_memory\_reclaimed,  .vm\_copy\_enc\_context\_from = sev\_vm\_copy\_enc\_context\_from, .vm\_move\_enc\_context\_from = sev\_vm\_move\_enc\_context\_from,diff --git a/arch/x86/kvm/svm/svm.h b/arch/x86/kvm/svm/svm.hindex f77a7d2d39dd6d..f76deff71002cb 100644--- a/[arch/x86/kvm/svm/svm.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/svm/svm.h?id=d45829b351ee6ec5f54dd55e6aca1f44fe239fe6)+++ b/[arch/x86/kvm/svm/svm.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/svm/svm.h?id=683412ccf61294d727ead4a73d97397396e69a6b)@@ -609,6 +609,8 @@ int sev\_mem\_enc\_unregister\_region(struct kvm \*kvm, struct kvm\_enc\_region \*range); int sev\_vm\_copy\_enc\_context\_from(struct kvm \*kvm, unsigned int source\_fd); int sev\_vm\_move\_enc\_context\_from(struct kvm \*kvm, unsigned int source\_fd);+void sev\_guest\_memory\_reclaimed(struct kvm \*kvm);+ void pre\_sev\_run(struct vcpu\_svm \*svm, int cpu); void \_\_init sev\_set\_cpu\_caps(void); void \_\_init sev\_hardware\_setup(void);diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.cindex c89dc09a764f6f..a6ab19afc638b2 100644--- a/[arch/x86/kvm/x86.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/x86.c?id=d45829b351ee6ec5f54dd55e6aca1f44fe239fe6)+++ b/[arch/x86/kvm/x86.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/x86.c?id=683412ccf61294d727ead4a73d97397396e69a6b)@@ -9889,6 +9889,11 @@ void kvm\_arch\_mmu\_notifier\_invalidate\_range(struct kvm \*kvm, kvm\_make\_all\_cpus\_request(kvm, KVM\_REQ\_APIC\_PAGE\_RELOAD); } +void kvm\_arch\_guest\_memory\_reclaimed(struct kvm \*kvm)+{+ static\_call\_cond(kvm\_x86\_guest\_memory\_reclaimed)(kvm);+}+ static void kvm\_vcpu\_reload\_apic\_access\_page(struct kvm\_vcpu \*vcpu) { if (!lapic\_in\_kernel(vcpu))diff --git a/include/linux/kvm\_host.h b/include/linux/kvm\_host.hindex 2dab4b696682e6..34eed5f85ed607 100644--- a/[include/linux/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/kvm_host.h?id=d45829b351ee6ec5f54dd55e6aca1f44fe239fe6)+++ b/[include/linux/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/kvm_host.h?id=683412ccf61294d727ead4a73d97397396e69a6b)@@ -2219,6 +2219,8 @@ static inline long kvm\_arch\_vcpu\_async\_ioctl(struct file \*filp, void kvm\_arch\_mmu\_notifier\_invalidate\_range(struct kvm \*kvm, unsigned long start, unsigned long end); +void kvm\_arch\_guest\_memory\_reclaimed(struct kvm \*kvm);+ #ifdef CONFIG\_HAVE\_KVM\_VCPU\_RUN\_PID\_CHANGE int kvm\_arch\_vcpu\_run\_pid\_change(struct kvm\_vcpu \*vcpu); #elsediff --git a/virt/kvm/kvm\_main.c b/virt/kvm/kvm\_main.cindex 2a23f24d13cf84..f30bb8c16f2659 100644--- a/[virt/kvm/kvm\_main.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/virt/kvm/kvm_main.c?id=d45829b351ee6ec5f54dd55e6aca1f44fe239fe6)+++ b/[virt/kvm/kvm\_main.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/virt/kvm/kvm_main.c?id=683412ccf61294d727ead4a73d97397396e69a6b)@@ -164,6 +164,10 @@ \_\_weak void kvm\_arch\_mmu\_notifier\_invalidate\_range(struct kvm \*kvm, { } +\_\_weak void kvm\_arch\_guest\_memory\_reclaimed(struct kvm \*kvm)+{+}+ bool kvm\_is\_zone\_device\_pfn(kvm\_pfn\_t pfn) { /\*@@ -357,6 +361,12 @@ void kvm\_flush\_remote\_tlbs(struct kvm \*kvm) EXPORT\_SYMBOL\_GPL(kvm\_flush\_remote\_tlbs); #endif +static void kvm\_flush\_shadow\_all(struct kvm \*kvm)+{+ kvm\_arch\_flush\_shadow\_all(kvm);+ kvm\_arch\_guest\_memory\_reclaimed(kvm);+}+ #ifdef KVM\_ARCH\_NR\_OBJS\_PER\_MEMORY\_CACHE static inline void \*mmu\_memory\_cache\_alloc\_obj(struct kvm\_mmu\_memory\_cache \*mc, gfp\_t gfp\_flags)@@ -485,12 +495,15 @@ typedef bool (\*hva\_handler\_t)(struct kvm \*kvm, struct kvm\_gfn\_range \*range); typedef void (\*on\_lock\_fn\_t)(struct kvm \*kvm, unsigned long start, unsigned long end); +typedef void (\*on\_unlock\_fn\_t)(struct kvm \*kvm);+ struct kvm\_hva\_range { unsigned long start; unsigned long end; pte\_t pte; hva\_handler\_t handler; on\_lock\_fn\_t on\_lock;+ on\_unlock\_fn\_t on\_unlock; bool flush\_on\_ret; bool may\_block; };@@ -578,8 +591,11 @@ static \_\_always\_inline int \_\_kvm\_handle\_hva\_range(struct kvm \*kvm, if (range->flush\_on\_ret && ret) kvm\_flush\_remote\_tlbs(kvm); - if (locked)+ if (locked) { KVM\_MMU\_UNLOCK(kvm);+ if (!IS\_KVM\_NULL\_FN(range->on\_unlock))+ range->on\_unlock(kvm);+ }  srcu\_read\_unlock(&kvm->srcu, idx); @@ -600,6 +616,7 @@ static \_\_always\_inline int kvm\_handle\_hva\_range(struct mmu\_notifier \*mn, .pte = pte, .handler = handler, .on\_lock = (void \*)kvm\_null\_fn,+ .on\_unlock = (void \*)kvm\_null\_fn, .flush\_on\_ret = true, .may\_block = false, };@@ -619,6 +636,7 @@ static \_\_always\_inline int kvm\_handle\_hva\_range\_no\_flush(struct mmu\_notifier \*mn .pte = \_\_pte(0), .handler = handler, .on\_lock = (void \*)kvm\_null\_fn,+ .on\_unlock = (void \*)kvm\_null\_fn, .flush\_on\_ret = false, .may\_block = false, };@@ -687,6 +705,7 @@ static int kvm\_mmu\_notifier\_invalidate\_range\_start(struct mmu\_notifier \*mn, .pte = \_\_pte(0), .handler = kvm\_unmap\_gfn\_range, .on\_lock = kvm\_inc\_notifier\_count,+ .on\_unlock = kvm\_arch\_guest\_memory\_reclaimed, .flush\_on\_ret = true, .may\_block = mmu\_notifier\_range\_blockable(range), };@@ -741,6 +760,7 @@ static void kvm\_mmu\_notifier\_invalidate\_range\_end(struct mmu\_notifier \*mn, .pte = \_\_pte(0), .handler = (void \*)kvm\_null\_fn, .on\_lock = kvm\_dec\_notifier\_count,+ .on\_unlock = (void \*)kvm\_null\_fn, .flush\_on\_ret = false, .may\_block = mmu\_notifier\_range\_blockable(range), };@@ -813,7 +833,7 @@ static void kvm\_mmu\_notifier\_release(struct mmu\_notifier \*mn, int idx;  idx = srcu\_read\_lock(&kvm->srcu);- kvm\_arch\_flush\_shadow\_all(kvm);+ kvm\_flush\_shadow\_all(kvm); srcu\_read\_unlock(&kvm->srcu, idx); } @@ -1225,7 +1245,7 @@ static void kvm\_destroy\_vm(struct kvm \*kvm) WARN\_ON(rcuwait\_active(&kvm->mn\_memslots\_update\_rcuwait)); kvm->mn\_active\_invalidate\_count = 0; #else- kvm\_arch\_flush\_shadow\_all(kvm);+ kvm\_flush\_shadow\_all(kvm); #endif kvm\_arch\_destroy\_vm(kvm); kvm\_destroy\_devices(kvm);@@ -1652,6 +1672,7 @@ static void kvm\_invalidate\_memslot(struct kvm \*kvm, \* - kvm\_is\_visible\_gfn (mmu\_check\_root) \*/ kvm\_arch\_flush\_shadow\_memslot(kvm, old);+ kvm\_arch\_guest\_memory\_reclaimed(kvm);  /\* Was released by kvm\_swap\_active\_memslots, reacquire. \*/ mutex\_lock(&kvm->slots\_arch\_lock); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-08 15:11:25 +0000



=== Content from access.redhat.com_c89e9204_20250108_151246.html ===


[Skip to navigation](#pfe-navigation)
[Skip to main content](#cp-main)
### Utilities

* [Subscriptions](https://access.redhat.com/management/)
* [Downloads](https://access.redhat.com/downloads/)
* [Red Hat Console](//console.redhat.com/)
* [Get Support](https://access.redhat.com/support/)

[![Red Hat Customer Portal](https://access.redhat.com/chrome_themes/nimbus/img/red-hat-customer-portal.svg)](https://access.redhat.com/)

* [Subscriptions](https://access.redhat.com/management/)
* [Downloads](https://access.redhat.com/downloads/)
* [Red Hat Console](//console.redhat.com/)
* [Get Support](https://access.redhat.com/support/)
* [Products](https://access.redhat.com/)
  ### Top Products

  + [Red Hat Enterprise Linux](https://access.redhat.com/products/red-hat-enterprise-linux/)
  + [Red Hat OpenShift](https://access.redhat.com/products/red-hat-openshift-container-platform)
  + [Red Hat Ansible Automation Platform](https://access.redhat.com/products/red-hat-ansible-automation-platform/)
  [All Products](https://access.redhat.com/products/)

  ### Downloads and Containers

  + [Downloads](https://access.redhat.com/downloads/)
  + [Packages](https://access.redhat.com/downloads/content/package-browser)
  + [Containers](https://catalog.redhat.com/software/containers/explore/)
  ### Top Resources

  + [Documentation](//docs.redhat.com/)
  + [Product Life Cycles](https://access.redhat.com/product-life-cycles/)
  + [Product Compliance](https://access.redhat.com/articles/1202803)
  + [Errata](https://access.redhat.com/errata/)
* [Knowledge](https://access.redhat.com/labs/)
  ### Red Hat Knowledge Center

  + [Knowledgebase Solutions](https://access.redhat.com/search/?q=*&p=1&rows=10&documentKind=Solution)
  + [Knowledgebase Articles](https://access.redhat.com/search/?q=*&p=1&rows=10&documentKind=Article)
  + [Customer Portal Labs](https://access.redhat.com/labs/)
  + [Errata](https://access.redhat.com/errata/)
  ### Top Product Docs

  + [Red Hat Enterprise Linux](//docs.redhat.com/en/documentation/red_hat_enterprise_linux/)
  + [Red Hat OpenShift](//docs.redhat.com/en/documentation/openshift_container_platform/)
  + [Red Hat Ansible Automation Platform](//docs.redhat.com/en/documentation/red_hat_ansible_automation_platform/)
  [All Product Docs](//docs.redhat.com/en/products)

  ### [Training and Certification](//www.redhat.com/en/services/training-and-certification)

  + [About](//www.redhat.com/en/services/training-and-certification)
  + [Course Index](//www.redhat.com/en/services/training/all-courses-exams)
  + [Certification Index](//www.redhat.com/en/services/certifications)
  + [Skill Assessment](//skills.ole.redhat.com/)
* [Security](https://access.redhat.com/security/)
  ### [Red Hat Product Security Center](https://access.redhat.com/security)

  + [Security Updates](https://access.redhat.com/security)
  + [Security Advisories](https://access.redhat.com/security/security-updates/#/security-advisories)
  + [Red Hat CVE Database](https://access.redhat.com/security/security-updates/#/cve)
  + [Errata](https://access.redhat.com/errata/)
  ### References

  + [Security Bulletins](https://access.redhat.com/security/vulnerabilities)
  + [Security Measurement](https://www.redhat.com/security/data/metrics/)
  + [Severity Ratings](https://access.redhat.com/security/updates/classification/)
  + [Security Data](https://access.redhat.com/security/data)
  ### Top Resources

  + [Security Labs](https://access.redhat.com/security/security-updates/#/security-labs)
  + [Backporting Policies](https://access.redhat.com/security/updates/backporting/)
  + [Security Blog](//redhat.com/en/blog/channel/security)
* [Support](https://access.redhat.com/support/)
  ### [Red Hat Support](https://access.redhat.com/support/)

  + [Support Cases](https://access.redhat.com/support/cases/)
  + [Troubleshoot](https://access.redhat.com/support/cases/#/troubleshoot)
  + [Get Support](https://access.redhat.com/support/)
  + [Contact Red Hat Support](https://access.redhat.com/support/contact/)
  ### [Red Hat Community Support](https://access.redhat.com/community)

  + [Customer Portal Community](https://access.redhat.com/community/)
  + [Community Discussions](https://access.redhat.com/discussions/)
  + [Red Hat Accelerator Program](https://access.redhat.com/accelerators/)
  ### Top Resources

  + [Product Life Cycles](https://access.redhat.com/product-life-cycles/)
  + [Customer Portal Labs](https://access.redhat.com/labs/)
  + [Red Hat JBoss Supported Configurations](https://access.redhat.com/support/configurations/jboss)
  + [Red Hat Insights](https://cloud.redhat.com/insights)

Or [troubleshoot an issue](/support/cases/#/troubleshoot).

English

## Select Your Language

* [English](https://access.redhat.com/changeLanguage?language=en)
* [FranÃ§ais](https://access.redhat.com/changeLanguage?language=fr)
* [í•œêµ­ì–´](https://access.redhat.com/changeLanguage?language=ko)
* [æ—¥æœ¬èªž](https://access.redhat.com/changeLanguage?language=ja)
* [ä¸­æ–‡ (ä¸­å›½)](https://access.redhat.com/changeLanguage?language=zh_CN)

### Infrastructure and Management

* [Red Hat Enterprise Linux](https://access.redhat.com/products/red-hat-enterprise-linux/)
* [Red Hat Satellite](https://access.redhat.com/products/red-hat-satellite/)
* [Red Hat Subscription Management](https://access.redhat.com/products/red-hat-subscription-management/)
* [Red Hat Insights](https://access.redhat.com/products/red-hat-insights/)
* [Red Hat Ansible Automation Platform](https://access.redhat.com/products/red-hat-ansible-automation-platform/)
### Cloud Computing

* [Red Hat OpenShift](https://access.redhat.com/products/red-hat-openshift-container-platform)
* [Red Hat OpenStack Platform](https://access.redhat.com/products/red-hat-openstack-platform/)
* [Red Hat OpenShift](https://access.redhat.com/products/red-hat-openshift-container-platform/)
* [Red Hat OpenShift AI](https://access.redhat.com/products/red-hat-openshift-ai/)
* [Red Hat OpenShift Dedicated](https://access.redhat.com/products/openshift-dedicated-red-hat/)
* [Red Hat Advanced Cluster Security for Kubernetes](https://access.redhat.com/products/red-hat-advanced-cluster-security-for-kubernetes/)
* [Red Hat Advanced Cluster Management for Kubernetes](https://access.redhat.com/products/red-hat-advanced-cluster-management-for-kubernetes/)
* [Red Hat Quay](https://access.redhat.com/products/red-hat-quay/)
* [Red Hat OpenShift Dev Spaces](https://access.redhat.com/products/red-hat-openshift-dev-spaces)
* [Red Hat OpenShift Service on AWS](https://access.redhat.com/products/red-hat-openshift-service-aws)
### Storage

* [Red Hat Gluster Storage](https://access.redhat.com/products/red-hat-storage/)
* [Red Hat Hyperconverged Infrastructure](https://access.redhat.com/products/red-hat-hyperconverged-infrastructure/)
* [Red Hat Ceph Storage](https://access.redhat.com/products/red-hat-ceph-storage/)
* [Red Hat OpenShift Data Foundation](https://access.redhat.com/products/red-hat-openshift-data-foundation)
### Runtimes

* [Red Hat Runtimes](https://access.redhat.com/products/red-hat-runtimes/)
* [Red Hat JBoss Enterprise Application Platform](https://access.redhat.com/products/red-hat-jboss-enterprise-application-platform/)
* [Red Hat Data Grid](https://access.redhat.com/products/red-hat-data-grid/)
* [Red Hat JBoss Web Server](https://access.redhat.com/products/red-hat-jboss-web-server/)
* [Red Hat build of Keycloak](https://access.redhat.com/products/red-hat-build-of-keycloak/)
* [Red Hat support for Spring Boot](https://access.redhat.com/products/spring-boot/)
* [Red Hat build of Node.js](https://access.redhat.com/products/nodejs/)
* [Red Hat build of Quarkus](https://access.redhat.com/products/quarkus/)
### Integration and Automation

* [Red Hat Application Foundations](https://access.redhat.com/products/red-hat-application-foundations/)
* [Red Hat Fuse](https://access.redhat.com/products/red-hat-fuse/)
* [Red Hat AMQ](https://access.redhat.com/products/red-hat-amq/)
* [Red Hat 3scale API Management](https://access.redhat.com/products/red-hat-3scale/)

[All Products](https://access.redhat.com/products/)

**We're sorry but cve-details doesn't work properly without JavaScript enabled. Please enable it to continue.**

[![Red Hat](https://static.redhat.com/libs/redhat/brand-assets/2/corp/logo--on-dark.svg)](https://redhat.com/en)
[X (formerly Twitter)](https://twitter.com/RedHat)
### Quick Links

* [Downloads](https://access.redhat.com/downloads/)
* [Subscriptions](https://access.redhat.com/management)
* [Support Cases](https://access.redhat.com/support)
* [Customer Service](https://access.redhat.com/support/customer-service)
* [Product Documentation](//docs.redhat.com/)

### Help

* [Contact Us](https://access.redhat.com/support/contact/)
* [Customer Portal FAQ](https://access.redhat.com/articles/33844)
* [Log-in Assistance](https://access.redhat.com/help/login_assistance)

### Site Info

* [Trust Red Hat](https://www.redhat.com/en/trust)
* [Browser Support Policy](https://www.redhat.com/en/about/browser-support)
* [Accessibility](https://www.redhat.com/en/about/digital-accessibility)
* [Awards and Recognition](https://access.redhat.com/recognition/)
* [Colophon](https://access.redhat.com/help/colophon/)

### Related Sites

* [redhat.com](https://www.redhat.com/)
* [developers.redhat.com](http://developers.redhat.com/)
* [connect.redhat.com](https://connect.redhat.com/)
* [cloud.redhat.com](https://cloud.redhat.com/)

### Red Hat legal and privacy links

* [About Red Hat](https://redhat.com/en/about/company)
* [Jobs](https://redhat.com/en/jobs)
* [Events](https://redhat.com/en/events)
* [Locations](https://redhat.com/en/about/office-locations)
* [Contact Red Hat](https://redhat.com/en/contact)
* [Red Hat Blog](https://redhat.com/en/blog)
* [Diversity, equity, and inclusion](https://redhat.com/en/about/our-culture/diversity-equity-inclusion)
* [Cool Stuff Store](https://coolstuff.redhat.com/)
* [Red Hat Summit](https://www.redhat.com/en/summit)

 Â© 2024 Red Hat, Inc.
### Red Hat legal and privacy links

* [Privacy statement](https://redhat.com/en/about/privacy-policy)
* [Terms of use](https://redhat.com/en/about/terms-use)
* [All policies and guidelines](https://redhat.com/en/about/all-policies-guidelines)
* [Digital accessibility](https://redhat.com/en/about/digital-accessibility)



=== Content from git.kernel.org_494f69fd_20250108_114459.html ===


| [cgit logo](/) | [index](/) : [kernel/git/torvalds/linux.git](/pub/scm/linux/kernel/git/torvalds/linux.git/) | for-next master vsnprintf |
| --- | --- | --- |
| Linux kernel source tree | Linus Torvalds |

| [about](/pub/scm/linux/kernel/git/torvalds/linux.git/about/)[summary](/pub/scm/linux/kernel/git/torvalds/linux.git/)[refs](/pub/scm/linux/kernel/git/torvalds/linux.git/refs/?id=683412ccf61294d727ead4a73d97397396e69a6b)[log](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)[tree](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=683412ccf61294d727ead4a73d97397396e69a6b)[commit](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=683412ccf61294d727ead4a73d97397396e69a6b)[diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=683412ccf61294d727ead4a73d97397396e69a6b)[stats](/pub/scm/linux/kernel/git/torvalds/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Mingwei Zhang <mizhang@google.com> | 2022-04-21 03:14:07 +0000 |
| --- | --- | --- |
| committer | Paolo Bonzini <pbonzini@redhat.com> | 2022-04-21 15:41:00 -0400 |
| commit | [683412ccf61294d727ead4a73d97397396e69a6b](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=683412ccf61294d727ead4a73d97397396e69a6b) ([patch](/pub/scm/linux/kernel/git/torvalds/linux.git/patch/?id=683412ccf61294d727ead4a73d97397396e69a6b)) | |
| tree | [2e1f2e5ff4031699ee51b45341590461565f36fc](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=683412ccf61294d727ead4a73d97397396e69a6b) | |
| parent | [d45829b351ee6ec5f54dd55e6aca1f44fe239fe6](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=d45829b351ee6ec5f54dd55e6aca1f44fe239fe6) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=683412ccf61294d727ead4a73d97397396e69a6b&id2=d45829b351ee6ec5f54dd55e6aca1f44fe239fe6)) | |
| download | [linux-683412ccf61294d727ead4a73d97397396e69a6b.tar.gz](/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-683412ccf61294d727ead4a73d97397396e69a6b.tar.gz) | |

KVM: SEV: add cache flush to solve SEV cache incoherency issuesFlush the CPU caches when memory is reclaimed from an SEV guest (where
reclaim also includes it being unmapped from KVM's memslots). Due to lack
of coherency for SEV encrypted memory, failure to flush results in silent
data corruption if userspace is malicious/broken and doesn't ensure SEV
guest memory is properly pinned and unpinned.
Cache coherency is not enforced across the VM boundary in SEV (AMD APM
vol.2 Section 15.34.7). Confidential cachelines, generated by confidential
VM guests have to be explicitly flushed on the host side. If a memory page
containing dirty confidential cachelines was released by VM and reallocated
to another user, the cachelines may corrupt the new user at a later time.
KVM takes a shortcut by assuming all confidential memory remain pinned
until the end of VM lifetime. Therefore, KVM does not flush cache at
mmu\_notifier invalidation events. Because of this incorrect assumption and
the lack of cache flushing, malicous userspace can crash the host kernel:
creating a malicious VM and continuously allocates/releases unpinned
confidential memory pages when the VM is running.
Add cache flush operations to mmu\_notifier operations to ensure that any
physical memory leaving the guest VM get flushed. In particular, hook
mmu\_notifier\_invalidate\_range\_start and mmu\_notifier\_release events and
flush cache accordingly. The hook after releasing the mmu lock to avoid
contention with other vCPUs.
Cc: stable@vger.kernel.org
Suggested-by: Sean Christpherson <seanjc@google.com>
Reported-by: Mingwei Zhang <mizhang@google.com>
Signed-off-by: Mingwei Zhang <mizhang@google.com>
Message-Id: <20220421031407.2516575-4-mizhang@google.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
[Diffstat](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=683412ccf61294d727ead4a73d97397396e69a6b)

| -rw-r--r-- | [arch/x86/include/asm/kvm-x86-ops.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/include/asm/kvm-x86-ops.h?id=683412ccf61294d727ead4a73d97397396e69a6b) | 1 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [arch/x86/include/asm/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/include/asm/kvm_host.h?id=683412ccf61294d727ead4a73d97397396e69a6b) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/svm/sev.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kvm/svm/sev.c?id=683412ccf61294d727ead4a73d97397396e69a6b) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/svm/svm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kvm/svm/svm.c?id=683412ccf61294d727ead4a73d97397396e69a6b) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/svm/svm.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kvm/svm/svm.h?id=683412ccf61294d727ead4a73d97397396e69a6b) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/x86.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kvm/x86.c?id=683412ccf61294d727ead4a73d97397396e69a6b) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/linux/kvm_host.h?id=683412ccf61294d727ead4a73d97397396e69a6b) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [virt/kvm/kvm\_main.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/virt/kvm/kvm_main.c?id=683412ccf61294d727ead4a73d97397396e69a6b) | 27 | |  |  |  | | --- | --- | --- | |

8 files changed, 44 insertions, 3 deletions

| diff --git a/arch/x86/include/asm/kvm-x86-ops.h b/arch/x86/include/asm/kvm-x86-ops.hindex 3c368b639c0462..1a6d7e3f6c32c7 100644--- a/[arch/x86/include/asm/kvm-x86-ops.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/include/asm/kvm-x86-ops.h?id=d45829b351ee6ec5f54dd55e6aca1f44fe239fe6)+++ b/[arch/x86/include/asm/kvm-x86-ops.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/include/asm/kvm-x86-ops.h?id=683412ccf61294d727ead4a73d97397396e69a6b)@@ -118,6 +118,7 @@ KVM\_X86\_OP\_OPTIONAL(mem\_enc\_register\_region) KVM\_X86\_OP\_OPTIONAL(mem\_enc\_unregister\_region) KVM\_X86\_OP\_OPTIONAL(vm\_copy\_enc\_context\_from) KVM\_X86\_OP\_OPTIONAL(vm\_move\_enc\_context\_from)+KVM\_X86\_OP\_OPTIONAL(guest\_memory\_reclaimed) KVM\_X86\_OP(get\_msr\_feature) KVM\_X86\_OP(can\_emulate\_instruction) KVM\_X86\_OP(apic\_init\_signal\_blocked)diff --git a/arch/x86/include/asm/kvm\_host.h b/arch/x86/include/asm/kvm\_host.hindex e0c0f0e1f754c1..4ff36610af6ab5 100644--- a/[arch/x86/include/asm/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/include/asm/kvm_host.h?id=d45829b351ee6ec5f54dd55e6aca1f44fe239fe6)+++ b/[arch/x86/include/asm/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/include/asm/kvm_host.h?id=683412ccf61294d727ead4a73d97397396e69a6b)@@ -1484,6 +1484,7 @@ struct kvm\_x86\_ops { int (\*mem\_enc\_unregister\_region)(struct kvm \*kvm, struct kvm\_enc\_region \*argp); int (\*vm\_copy\_enc\_context\_from)(struct kvm \*kvm, unsigned int source\_fd); int (\*vm\_move\_enc\_context\_from)(struct kvm \*kvm, unsigned int source\_fd);+ void (\*guest\_memory\_reclaimed)(struct kvm \*kvm);  int (\*get\_msr\_feature)(struct kvm\_msr\_entry \*entry); diff --git a/arch/x86/kvm/svm/sev.c b/arch/x86/kvm/svm/sev.cindex 9a037598702936..0ad70c12c7c311 100644--- a/[arch/x86/kvm/svm/sev.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/svm/sev.c?id=d45829b351ee6ec5f54dd55e6aca1f44fe239fe6)+++ b/[arch/x86/kvm/svm/sev.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/svm/sev.c?id=683412ccf61294d727ead4a73d97397396e69a6b)@@ -2262,6 +2262,14 @@ do\_wbinvd: wbinvd\_on\_all\_cpus(); } +void sev\_guest\_memory\_reclaimed(struct kvm \*kvm)+{+ if (!sev\_guest(kvm))+ return;++ wbinvd\_on\_all\_cpus();+}+ void sev\_free\_vcpu(struct kvm\_vcpu \*vcpu) { struct vcpu\_svm \*svm;diff --git a/arch/x86/kvm/svm/svm.c b/arch/x86/kvm/svm/svm.cindex bd4c64b362d24a..7e45d03cd018a5 100644--- a/[arch/x86/kvm/svm/svm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/svm/svm.c?id=d45829b351ee6ec5f54dd55e6aca1f44fe239fe6)+++ b/[arch/x86/kvm/svm/svm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/svm/svm.c?id=683412ccf61294d727ead4a73d97397396e69a6b)@@ -4620,6 +4620,7 @@ static struct kvm\_x86\_ops svm\_x86\_ops \_\_initdata = { .mem\_enc\_ioctl = sev\_mem\_enc\_ioctl, .mem\_enc\_register\_region = sev\_mem\_enc\_register\_region, .mem\_enc\_unregister\_region = sev\_mem\_enc\_unregister\_region,+ .guest\_memory\_reclaimed = sev\_guest\_memory\_reclaimed,  .vm\_copy\_enc\_context\_from = sev\_vm\_copy\_enc\_context\_from, .vm\_move\_enc\_context\_from = sev\_vm\_move\_enc\_context\_from,diff --git a/arch/x86/kvm/svm/svm.h b/arch/x86/kvm/svm/svm.hindex f77a7d2d39dd6d..f76deff71002cb 100644--- a/[arch/x86/kvm/svm/svm.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/svm/svm.h?id=d45829b351ee6ec5f54dd55e6aca1f44fe239fe6)+++ b/[arch/x86/kvm/svm/svm.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/svm/svm.h?id=683412ccf61294d727ead4a73d97397396e69a6b)@@ -609,6 +609,8 @@ int sev\_mem\_enc\_unregister\_region(struct kvm \*kvm, struct kvm\_enc\_region \*range); int sev\_vm\_copy\_enc\_context\_from(struct kvm \*kvm, unsigned int source\_fd); int sev\_vm\_move\_enc\_context\_from(struct kvm \*kvm, unsigned int source\_fd);+void sev\_guest\_memory\_reclaimed(struct kvm \*kvm);+ void pre\_sev\_run(struct vcpu\_svm \*svm, int cpu); void \_\_init sev\_set\_cpu\_caps(void); void \_\_init sev\_hardware\_setup(void);diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.cindex c89dc09a764f6f..a6ab19afc638b2 100644--- a/[arch/x86/kvm/x86.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/x86.c?id=d45829b351ee6ec5f54dd55e6aca1f44fe239fe6)+++ b/[arch/x86/kvm/x86.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/x86.c?id=683412ccf61294d727ead4a73d97397396e69a6b)@@ -9889,6 +9889,11 @@ void kvm\_arch\_mmu\_notifier\_invalidate\_range(struct kvm \*kvm, kvm\_make\_all\_cpus\_request(kvm, KVM\_REQ\_APIC\_PAGE\_RELOAD); } +void kvm\_arch\_guest\_memory\_reclaimed(struct kvm \*kvm)+{+ static\_call\_cond(kvm\_x86\_guest\_memory\_reclaimed)(kvm);+}+ static void kvm\_vcpu\_reload\_apic\_access\_page(struct kvm\_vcpu \*vcpu) { if (!lapic\_in\_kernel(vcpu))diff --git a/include/linux/kvm\_host.h b/include/linux/kvm\_host.hindex 2dab4b696682e6..34eed5f85ed607 100644--- a/[include/linux/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/kvm_host.h?id=d45829b351ee6ec5f54dd55e6aca1f44fe239fe6)+++ b/[include/linux/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/kvm_host.h?id=683412ccf61294d727ead4a73d97397396e69a6b)@@ -2219,6 +2219,8 @@ static inline long kvm\_arch\_vcpu\_async\_ioctl(struct file \*filp, void kvm\_arch\_mmu\_notifier\_invalidate\_range(struct kvm \*kvm, unsigned long start, unsigned long end); +void kvm\_arch\_guest\_memory\_reclaimed(struct kvm \*kvm);+ #ifdef CONFIG\_HAVE\_KVM\_VCPU\_RUN\_PID\_CHANGE int kvm\_arch\_vcpu\_run\_pid\_change(struct kvm\_vcpu \*vcpu); #elsediff --git a/virt/kvm/kvm\_main.c b/virt/kvm/kvm\_main.cindex 2a23f24d13cf84..f30bb8c16f2659 100644--- a/[virt/kvm/kvm\_main.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/virt/kvm/kvm_main.c?id=d45829b351ee6ec5f54dd55e6aca1f44fe239fe6)+++ b/[virt/kvm/kvm\_main.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/virt/kvm/kvm_main.c?id=683412ccf61294d727ead4a73d97397396e69a6b)@@ -164,6 +164,10 @@ \_\_weak void kvm\_arch\_mmu\_notifier\_invalidate\_range(struct kvm \*kvm, { } +\_\_weak void kvm\_arch\_guest\_memory\_reclaimed(struct kvm \*kvm)+{+}+ bool kvm\_is\_zone\_device\_pfn(kvm\_pfn\_t pfn) { /\*@@ -357,6 +361,12 @@ void kvm\_flush\_remote\_tlbs(struct kvm \*kvm) EXPORT\_SYMBOL\_GPL(kvm\_flush\_remote\_tlbs); #endif +static void kvm\_flush\_shadow\_all(struct kvm \*kvm)+{+ kvm\_arch\_flush\_shadow\_all(kvm);+ kvm\_arch\_guest\_memory\_reclaimed(kvm);+}+ #ifdef KVM\_ARCH\_NR\_OBJS\_PER\_MEMORY\_CACHE static inline void \*mmu\_memory\_cache\_alloc\_obj(struct kvm\_mmu\_memory\_cache \*mc, gfp\_t gfp\_flags)@@ -485,12 +495,15 @@ typedef bool (\*hva\_handler\_t)(struct kvm \*kvm, struct kvm\_gfn\_range \*range); typedef void (\*on\_lock\_fn\_t)(struct kvm \*kvm, unsigned long start, unsigned long end); +typedef void (\*on\_unlock\_fn\_t)(struct kvm \*kvm);+ struct kvm\_hva\_range { unsigned long start; unsigned long end; pte\_t pte; hva\_handler\_t handler; on\_lock\_fn\_t on\_lock;+ on\_unlock\_fn\_t on\_unlock; bool flush\_on\_ret; bool may\_block; };@@ -578,8 +591,11 @@ static \_\_always\_inline int \_\_kvm\_handle\_hva\_range(struct kvm \*kvm, if (range->flush\_on\_ret && ret) kvm\_flush\_remote\_tlbs(kvm); - if (locked)+ if (locked) { KVM\_MMU\_UNLOCK(kvm);+ if (!IS\_KVM\_NULL\_FN(range->on\_unlock))+ range->on\_unlock(kvm);+ }  srcu\_read\_unlock(&kvm->srcu, idx); @@ -600,6 +616,7 @@ static \_\_always\_inline int kvm\_handle\_hva\_range(struct mmu\_notifier \*mn, .pte = pte, .handler = handler, .on\_lock = (void \*)kvm\_null\_fn,+ .on\_unlock = (void \*)kvm\_null\_fn, .flush\_on\_ret = true, .may\_block = false, };@@ -619,6 +636,7 @@ static \_\_always\_inline int kvm\_handle\_hva\_range\_no\_flush(struct mmu\_notifier \*mn .pte = \_\_pte(0), .handler = handler, .on\_lock = (void \*)kvm\_null\_fn,+ .on\_unlock = (void \*)kvm\_null\_fn, .flush\_on\_ret = false, .may\_block = false, };@@ -687,6 +705,7 @@ static int kvm\_mmu\_notifier\_invalidate\_range\_start(struct mmu\_notifier \*mn, .pte = \_\_pte(0), .handler = kvm\_unmap\_gfn\_range, .on\_lock = kvm\_inc\_notifier\_count,+ .on\_unlock = kvm\_arch\_guest\_memory\_reclaimed, .flush\_on\_ret = true, .may\_block = mmu\_notifier\_range\_blockable(range), };@@ -741,6 +760,7 @@ static void kvm\_mmu\_notifier\_invalidate\_range\_end(struct mmu\_notifier \*mn, .pte = \_\_pte(0), .handler = (void \*)kvm\_null\_fn, .on\_lock = kvm\_dec\_notifier\_count,+ .on\_unlock = (void \*)kvm\_null\_fn, .flush\_on\_ret = false, .may\_block = mmu\_notifier\_range\_blockable(range), };@@ -813,7 +833,7 @@ static void kvm\_mmu\_notifier\_release(struct mmu\_notifier \*mn, int idx;  idx = srcu\_read\_lock(&kvm->srcu);- kvm\_arch\_flush\_shadow\_all(kvm);+ kvm\_flush\_shadow\_all(kvm); srcu\_read\_unlock(&kvm->srcu, idx); } @@ -1225,7 +1245,7 @@ static void kvm\_destroy\_vm(struct kvm \*kvm) WARN\_ON(rcuwait\_active(&kvm->mn\_memslots\_update\_rcuwait)); kvm->mn\_active\_invalidate\_count = 0; #else- kvm\_arch\_flush\_shadow\_all(kvm);+ kvm\_flush\_shadow\_all(kvm); #endif kvm\_arch\_destroy\_vm(kvm); kvm\_destroy\_devices(kvm);@@ -1652,6 +1672,7 @@ static void kvm\_invalidate\_memslot(struct kvm \*kvm, \* - kvm\_is\_visible\_gfn (mmu\_check\_root) \*/ kvm\_arch\_flush\_shadow\_memslot(kvm, old);+ kvm\_arch\_guest\_memory\_reclaimed(kvm);  /\* Was released by kvm\_swap\_active\_memslots, reacquire. \*/ mutex\_lock(&kvm->slots\_arch\_lock); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-08 11:43:36 +0000



=== Content from bugzilla.redhat.com_d3c33878_20250108_114458.html ===


* Login
  + Log in using an SSO provider:- [Fedora Account System](saml2_login.cgi?idp=Fedora%20Account%20System&target=show_bug.cgi%3Fid%3D2038940)
    - [Red Hat Associate](saml2_login.cgi?idp=Red%20Hat%20Associate&target=show_bug.cgi%3Fid%3D2038940)
    - [Red Hat Customer](saml2_login.cgi?idp=Red%20Hat%20Customer&target=show_bug.cgi%3Fid%3D2038940)+ Login using a Red Hat Bugzilla account
  + ForgotÂ Password
  + [Create an Account](createaccount.cgi)

Red Hat Bugzilla â€“ BugÂ 2038940

* [Home](./)
* [New](enter_bug.cgi)
* Search
  + [Simple Search](query.cgi?format=specific)
  + [Advanced Search](query.cgi?format=advanced)
* My Links
  + [Browse](describecomponents.cgi)
  + [Requests](request.cgi)
  + Reports
  + Current State
    - [Search](query.cgi)
    - [Tabular reports](query.cgi?format=report-table)
    - [Graphical reports](query.cgi?format=report-graph)
    - [Duplicates](duplicates.cgi)
  + Other Reports
    - [User Changes](https://bugzilla.redhat.com/page.cgi?id=user_activity.html)
  + Plotly Reports
    - [Bug Status](https://bugzilla.redhat.com/page.cgi?id=bug_status.html)
    - [Bug Severity](https://bugzilla.redhat.com/page.cgi?id=bug_severity.html)
    - [Non-Defaults](https://bugzilla.redhat.com/page.cgi?id=non_defaults.html)
* [Product Dashboard](page.cgi?id=productdashboard.html)

- Help
  * [Page Help!](docs/en/html/using/understanding.html)
  * [Bug Writing Guidelines](page.cgi?id=bug-writing.html)
  * [What's new](page.cgi?id=whats-new.html)
  * [Browser Support Policy](https://access.redhat.com/help/browsers)
  * [5.0.4.rh103 Release notes](page.cgi?id=release-notes.html)
  * [FAQ](page.cgi?id=faq.html)
  * [Guides index](docs/en/html/index.html)
  * [User guide](docs/en/html/using/index.html)
  * [Web Services](docs/en/html/integrating/api/Bugzilla/WebService/Bug.html)
  * [Contact](page.cgi?id=redhat/contact.html)
  * [Legal](page.cgi?id=terms-conditions.html)
- [[?]](page.cgi?id=quicksearch.html "Quicksearch Help")

This site requires JavaScript to be enabled to function correctly, please enable it.

[**BugÂ 2038940**](show_bug.cgi?id=2038940)
(CVE-2022-0171)
- [CVE-2022-0171](https://access.redhat.com/security/cve/CVE-2022-0171) kernel: KVM: cache incoherence issue in SEV API may lead to kernel crash

[Summary:](page.cgi?id=fields.html#short_desc "The bug summary is a short sentence which succinctly describes what the bug is about.")
CVE-2022-0171 kernel: KVM: cache incoherence issue in SEV API may lead to ker...

| | [Keywords](describekeywords.cgi): | Security | | --- | --- | | [Status](page.cgi?id=fields.html#bug_status): | NEW | | [Alias:](page.cgi?id=fields.html#alias "A short, unique name assigned to a bug in order to assist with looking it up and referring to it in other places in Bugzilla.") | CVE-2022-0171 | | [Product:](describecomponents.cgi "Bugs are categorised into Products and Components. Select a Classification to narrow down this list.") | Security Response | | [Classification:](page.cgi?id=fields.html#classification "Bugs are categorised into Classifications, Products and Components. classifications is the top-level categorisation.") | Other | | [Component:](describecomponents.cgi?product=Security Response "Components are second-level categories; each belongs to a particular Product. Select a Product to narrow down this list.") | vulnerability | | [Sub Component:](page.cgi?id=fields.html#rh_sub_components "The sub component of a specific component") | --- | | [Version:](page.cgi?id=fields.html#version "The version field defines the version of the software the bug was found in.") | unspecified | | [Hardware:](page.cgi?id=fields.html#rep_platform "The hardware platform the bug was observed on. Note: When searching, selecting the option \"All\" only finds bugs whose value for this field is literally the word \"All\".") | All | | [OS:](page.cgi?id=fields.html#op_sys "The operating system the bug was observed on. Note: When searching, selecting the option \"All\" only finds bugs whose value for this field is literally the word \"All\".") | Linux | | [Priority:](page.cgi?id=fields.html#priority) | medium | | [Severity:](page.cgi?id=fields.html#bug_severity) | medium | | [Target Milestone:](page.cgi?id=fields.html#target_milestone "The Target Milestone field is used to define when the engineer the bug is assigned to expects to fix it.") | --- | | [Assignee:](page.cgi?id=fields.html#assigned_to "The person in charge of resolving the bug.") | Nobody | | [QA Contact:](page.cgi?id=fields.html#qa_contact "The person responsible for confirming this bug if it is unconfirmed, and for verifying the fix once the bug has been resolved.") |  | | [Docs Contact:](page.cgi?id=fields.html#docs_contact "The person responsible for documenting once the bug has been resolved.") |  | | [URL:](page.cgi?id=fields.html#bug_file_loc "Bugs can have a URL associated with them - for example, a pointer to a web site where the problem is seen.") |  | | [Whiteboard:](page.cgi?id=fields.html#status_whiteboard "Each bug has a free-form single line text entry box for adding tags and status information.") |  | | [Depends On:](page.cgi?id=fields.html#dependson "The bugs listed here must be resolved before this bug can be resolved.") | [2040353](show_bug.cgi?id=2040353) [2040354](show_bug.cgi?id=2040354) [2040355](show_bug.cgi?id=2040355) [2040356](show_bug.cgi?id=2040356) [2084659](show_bug.cgi?id=2084659 "CLOSED ERRATA - CVE-2022-0171 kernel: KVM: cache incoherence issue in SEV API may lead to kernel crash [fedora-all]") | | [Blocks:](page.cgi?id=fields.html#blocked "This bug must be resolved before the bugs listed in this field can be resolved.") | [2038941](show_bug.cgi?id=2038941) [2038943](show_bug.cgi?id=2038943) | | TreeView+ | [depends on](buglist.cgi?bug_id=2038940&bug_id_type=anddependson&format=tvp) / [blocked](buglist.cgi?bug_id=2038940&bug_id_type=andblocked&format=tvp&tvp_dir=blocked) |  | |  | | [Reported:](page.cgi?id=fields.html#reporter) | 2022-01-10 15:25 UTC by Pedro Sampaio | | --- | --- | | [Modified:](page.cgi?id=fields.html#modified) | 2023-09-19 14:13 UTC ([History](show_activity.cgi?id=2038940)) | | [CC List:](page.cgi?id=fields.html#cclist) | 46 users (show)  acaringi adscvr airlied alciregi bhu blc chwhite crwood ddepaula dvlasenk hdegoede hkrzesin hpa jarod jarodwilson jburrell jfaracco jferlan jforbes jglisse jlelli joe.lawrence jonathan josef jshortt jstancek jwboyer jwyatt kcarcia kernel-maint kernel-mgr lgoncalv linville lzampier masami256 mchehab mlangsdo nmurray ptalbert qzhao rvrbovsk scweaver steved vkumar walters williams | | Fixed In Version: | kernel 5.18-rc4 | | | Doc Type: | If docs needed, set a value | | | Doc Text: | A flaw was found in the Linux kernel. The existing KVM SEV API has a vulnerability that allows a non-root (host) user-level application to crash the host kernel by creating a confidential guest VM instance in AMD CPU that supports Secure Encrypted Virtualization (SEV). | | | Clone Of: |  | | | Environment: |  | | | Last Closed: |  | | | Embargoed: |  | | |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| --- | | |

| | Attachments | [(Terms of Use)](page.cgi?id=terms-conditions.html) | | | --- | --- | --- | |  | | | |  |
| --- | --- | --- | --- | --- | --- | --- | --- |

| [Description](show_bug.cgi?id=2038940#c0)  Pedro Sampaio    2022-01-10 15:25:11 UTC  ``` The existing KVM SEV API has a vulnerability that allows a non-root (host) user-level application to crash the host kernel by creating a confidential guest VM instance in AMD CPU that supports SEV.  Upstream fix:  <https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91>   ```  [Comment 2](show_bug.cgi?id=2038940#c2)  juneau    2022-01-19 15:50:50 UTC  ``` OSD notaffected.   ```  [Comment 3](show_bug.cgi?id=2038940#c3)  Mauro Matteo Cascella    2022-05-12 15:27:32 UTC  ``` Created kernel tracking bugs for this issue:  Affects: fedora-all [[bug 2084659](show_bug.cgi?id=2084659 "CLOSED ERRATA - CVE-2022-0171 kernel: KVM: cache incoherence issue in SEV API may lead to kernel crash [fedora-all]")]   ```  [Comment 4](show_bug.cgi?id=2038940#c4)  Mauro Matteo Cascella    2022-05-13 08:33:27 UTC  ``` In reply to [comment #0](show_bug.cgi?id=2038940#c0): > Upstream fix: >  > <https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/> > ?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91  More specific commit: <https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=683412ccf61294d727ead4a73d97397396e69a6b>   ```  [Comment 5](show_bug.cgi?id=2038940#c5)  Mauro Matteo Cascella    2022-05-13 08:40:18 UTC  ``` AMD SEV-ES support was introduced in upstream kernel v5.10:  <http://lkml.iu.edu/hypermail/linux/kernel/2010.1/05072.html>  RHEL-6 and RHEL-7 kernels are not affected by this flaw as they did not include support for SEV-ES (not even SEV, FWIW).   ```  [Comment 7](show_bug.cgi?id=2038940#c7)  Justin M. Forbes    2022-06-29 16:20:24 UTC  ``` This was fixed for Fedora with the 5.18.4 stable kernel rebases.   ``` |  |
| --- | --- |

---

| Note You need to [log in](show_bug.cgi?id=2038940&GoAheadAndLogIn=1) before you can comment on or make changes to this bug. |
| --- |

---

[Privacy](page.cgi?id=redhat/privacy.html)
[Contact](page.cgi?id=redhat/contact.html)
[FAQ](page.cgi?id=faq.html)
[Legal](page.cgi?id=terms-conditions.html)



=== Content from git.kernel.org_7349ee1a_20250108_151248.html ===


| [cgit logo](/) | [index](/) : [kernel/git/torvalds/linux.git](/pub/scm/linux/kernel/git/torvalds/linux.git/) | for-next master vsnprintf |
| --- | --- | --- |
| Linux kernel source tree | Linus Torvalds |

| [about](/pub/scm/linux/kernel/git/torvalds/linux.git/about/)[summary](/pub/scm/linux/kernel/git/torvalds/linux.git/)[refs](/pub/scm/linux/kernel/git/torvalds/linux.git/refs/)[log](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)[tree](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/)[commit](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/)[diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/)[stats](/pub/scm/linux/kernel/git/torvalds/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Linus Torvalds <torvalds@linux-foundation.org> | 2025-01-07 14:49:48 -0800 |
| --- | --- | --- |
| committer | Linus Torvalds <torvalds@linux-foundation.org> | 2025-01-07 14:49:48 -0800 |
| commit | [09a0fa92e5b45e99cf435b2fbf5ebcf889cf8780](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=09a0fa92e5b45e99cf435b2fbf5ebcf889cf8780) ([patch](/pub/scm/linux/kernel/git/torvalds/linux.git/patch/?id=09a0fa92e5b45e99cf435b2fbf5ebcf889cf8780)) | |
| tree | [866799422fa168b12f2626ece483b0ccd08ead39](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/) | |
| parent | [fbfd64d25c7af3b8695201ebc85efe90be28c5a3](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=fbfd64d25c7af3b8695201ebc85efe90be28c5a3) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id2=fbfd64d25c7af3b8695201ebc85efe90be28c5a3)) | |
| parent | [5e7f0efd23238039bcd4fc72ff28d94f364ec26b](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=5e7f0efd23238039bcd4fc72ff28d94f364ec26b) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id2=5e7f0efd23238039bcd4fc72ff28d94f364ec26b)) | |
| download | [linux-master.tar.gz](/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-master.tar.gz) | |

Merge tag 'selinux-pr-20250107' of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/selinux[HEAD](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=09a0fa92e5b45e99cf435b2fbf5ebcf889cf8780)[master](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)Pull selinux fix from Paul Moore:
"A single SELinux patch to address a problem with a single domain using
multiple xperm classes"
\* tag 'selinux-pr-20250107' of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/selinux:
selinux: match extended permissions to their base permissions
[Diffstat](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/)

| -rw-r--r-- | [security/selinux/avc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/security/selinux/avc.c) | 61 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [security/selinux/hooks.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/security/selinux/hooks.c) | 6 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/selinux/include/avc.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/security/selinux/include/avc.h) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/selinux/include/security.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/security/selinux/include/security.h) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/selinux/ss/services.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/security/selinux/ss/services.c) | 28 | |  |  |  | | --- | --- | --- | |

5 files changed, 65 insertions, 38 deletions

| diff --git a/security/selinux/avc.c b/security/selinux/avc.cindex cc0b0af2029617..1f2680bcc43a42 100644--- a/[security/selinux/avc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/selinux/avc.c?id=fbfd64d25c7af3b8695201ebc85efe90be28c5a3)+++ b/[security/selinux/avc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/selinux/avc.c?id=09a0fa92e5b45e99cf435b2fbf5ebcf889cf8780)@@ -174,13 +174,15 @@ int avc\_get\_hash\_stats(char \*page) \* using a linked list for extended\_perms\_decision lookup because the list is \* always small. i.e. less than 5, typically 1 \*/-static struct extended\_perms\_decision \*avc\_xperms\_decision\_lookup(u8 driver,- struct avc\_xperms\_node \*xp\_node)+static struct extended\_perms\_decision \*+avc\_xperms\_decision\_lookup(u8 driver, u8 base\_perm,+ struct avc\_xperms\_node \*xp\_node) { struct avc\_xperms\_decision\_node \*xpd\_node;  list\_for\_each\_entry(xpd\_node, &xp\_node->xpd\_head, xpd\_list) {- if (xpd\_node->xpd.driver == driver)+ if (xpd\_node->xpd.driver == driver &&+ xpd\_node->xpd.base\_perm == base\_perm) return &xpd\_node->xpd; } return NULL;@@ -205,11 +207,12 @@ avc\_xperms\_has\_perm(struct extended\_perms\_decision \*xpd, }  static void avc\_xperms\_allow\_perm(struct avc\_xperms\_node \*xp\_node,- u8 driver, u8 perm)+ u8 driver, u8 base\_perm, u8 perm) { struct extended\_perms\_decision \*xpd; security\_xperm\_set(xp\_node->xp.drivers.p, driver);- xpd = avc\_xperms\_decision\_lookup(driver, xp\_node);+ xp\_node->xp.base\_perms |= base\_perm;+ xpd = avc\_xperms\_decision\_lookup(driver, base\_perm, xp\_node); if (xpd && xpd->allowed) security\_xperm\_set(xpd->allowed->p, perm); }@@ -245,6 +248,7 @@ static void avc\_xperms\_free(struct avc\_xperms\_node \*xp\_node) static void avc\_copy\_xperms\_decision(struct extended\_perms\_decision \*dest, struct extended\_perms\_decision \*src) {+ dest->base\_perm = src->base\_perm; dest->driver = src->driver; dest->used = src->used; if (dest->used & XPERMS\_ALLOWED)@@ -272,6 +276,7 @@ static inline void avc\_quick\_copy\_xperms\_decision(u8 perm, \*/ u8 i = perm >> 5; + dest->base\_perm = src->base\_perm; dest->used = src->used; if (dest->used & XPERMS\_ALLOWED) dest->allowed->p[i] = src->allowed->p[i];@@ -357,6 +362,7 @@ static int avc\_xperms\_populate(struct avc\_node \*node,  memcpy(dest->xp.drivers.p, src->xp.drivers.p, sizeof(dest->xp.drivers.p)); dest->xp.len = src->xp.len;+ dest->xp.base\_perms = src->xp.base\_perms;  /\* for each source xpd allocate a destination xpd and copy \*/ list\_for\_each\_entry(src\_xpd, &src->xpd\_head, xpd\_list) {@@ -807,6 +813,7 @@ out: \* @event : Updating event \* @perms : Permission mask bits \* @driver: xperm driver information+ \* @base\_perm: the base permission associated with the extended permission \* @xperm: xperm permissions \* @ssid: AVC entry source sid \* @tsid: AVC entry target sid@@ -820,10 +827,9 @@ out: \* otherwise, this function updates the AVC entry. The original AVC-entry object \* will release later by RCU. \*/-static int avc\_update\_node(u32 event, u32 perms, u8 driver, u8 xperm, u32 ssid,- u32 tsid, u16 tclass, u32 seqno,- struct extended\_perms\_decision \*xpd,- u32 flags)+static int avc\_update\_node(u32 event, u32 perms, u8 driver, u8 base\_perm,+ u8 xperm, u32 ssid, u32 tsid, u16 tclass, u32 seqno,+ struct extended\_perms\_decision \*xpd, u32 flags) { u32 hvalue; int rc = 0;@@ -880,7 +886,7 @@ static int avc\_update\_node(u32 event, u32 perms, u8 driver, u8 xperm, u32 ssid, case AVC\_CALLBACK\_GRANT: node->ae.avd.allowed |= perms; if (node->ae.xp\_node && (flags & AVC\_EXTENDED\_PERMS))- avc\_xperms\_allow\_perm(node->ae.xp\_node, driver, xperm);+ avc\_xperms\_allow\_perm(node->ae.xp\_node, driver, base\_perm, xperm); break; case AVC\_CALLBACK\_TRY\_REVOKE: case AVC\_CALLBACK\_REVOKE:@@ -987,10 +993,9 @@ static noinline void avc\_compute\_av(u32 ssid, u32 tsid, u16 tclass, avc\_insert(ssid, tsid, tclass, avd, xp\_node); } -static noinline int avc\_denied(u32 ssid, u32 tsid,- u16 tclass, u32 requested,- u8 driver, u8 xperm, unsigned int flags,- struct av\_decision \*avd)+static noinline int avc\_denied(u32 ssid, u32 tsid, u16 tclass, u32 requested,+ u8 driver, u8 base\_perm, u8 xperm,+ unsigned int flags, struct av\_decision \*avd) { if (flags & AVC\_STRICT) return -EACCES;@@ -999,7 +1004,7 @@ static noinline int avc\_denied(u32 ssid, u32 tsid, !(avd->flags & AVD\_FLAGS\_PERMISSIVE)) return -EACCES; - avc\_update\_node(AVC\_CALLBACK\_GRANT, requested, driver,+ avc\_update\_node(AVC\_CALLBACK\_GRANT, requested, driver, base\_perm, xperm, ssid, tsid, tclass, avd->seqno, NULL, flags); return 0; }@@ -1012,7 +1017,8 @@ static noinline int avc\_denied(u32 ssid, u32 tsid, \* driver field is used to specify which set contains the permission. \*/ int avc\_has\_extended\_perms(u32 ssid, u32 tsid, u16 tclass, u32 requested,- u8 driver, u8 xperm, struct common\_audit\_data \*ad)+ u8 driver, u8 base\_perm, u8 xperm,+ struct common\_audit\_data \*ad) { struct avc\_node \*node; struct av\_decision avd;@@ -1047,22 +1053,23 @@ int avc\_has\_extended\_perms(u32 ssid, u32 tsid, u16 tclass, u32 requested, local\_xpd.auditallow = &auditallow; local\_xpd.dontaudit = &dontaudit; - xpd = avc\_xperms\_decision\_lookup(driver, xp\_node);+ xpd = avc\_xperms\_decision\_lookup(driver, base\_perm, xp\_node); if (unlikely(!xpd)) { /\* \* Compute the extended\_perms\_decision only if the driver- \* is flagged+ \* is flagged and the base permission is known. \*/- if (!security\_xperm\_test(xp\_node->xp.drivers.p, driver)) {+ if (!security\_xperm\_test(xp\_node->xp.drivers.p, driver) ||+ !(xp\_node->xp.base\_perms & base\_perm)) { avd.allowed &= ~requested; goto decision; } rcu\_read\_unlock();- security\_compute\_xperms\_decision(ssid, tsid, tclass,- driver, &local\_xpd);+ security\_compute\_xperms\_decision(ssid, tsid, tclass, driver,+ base\_perm, &local\_xpd); rcu\_read\_lock();- avc\_update\_node(AVC\_CALLBACK\_ADD\_XPERMS, requested,- driver, xperm, ssid, tsid, tclass, avd.seqno,+ avc\_update\_node(AVC\_CALLBACK\_ADD\_XPERMS, requested, driver,+ base\_perm, xperm, ssid, tsid, tclass, avd.seqno, &local\_xpd, 0); } else { avc\_quick\_copy\_xperms\_decision(xperm, &local\_xpd, xpd);@@ -1075,8 +1082,8 @@ int avc\_has\_extended\_perms(u32 ssid, u32 tsid, u16 tclass, u32 requested, decision: denied = requested & ~(avd.allowed); if (unlikely(denied))- rc = avc\_denied(ssid, tsid, tclass, requested,- driver, xperm, AVC\_EXTENDED\_PERMS, &avd);+ rc = avc\_denied(ssid, tsid, tclass, requested, driver,+ base\_perm, xperm, AVC\_EXTENDED\_PERMS, &avd);  rcu\_read\_unlock(); @@ -1110,7 +1117,7 @@ static noinline int avc\_perm\_nonode(u32 ssid, u32 tsid, u16 tclass, avc\_compute\_av(ssid, tsid, tclass, avd, &xp\_node); denied = requested & ~(avd->allowed); if (unlikely(denied))- return avc\_denied(ssid, tsid, tclass, requested, 0, 0,+ return avc\_denied(ssid, tsid, tclass, requested, 0, 0, 0, flags, avd); return 0; }@@ -1158,7 +1165,7 @@ inline int avc\_has\_perm\_noaudit(u32 ssid, u32 tsid, rcu\_read\_unlock();  if (unlikely(denied))- return avc\_denied(ssid, tsid, tclass, requested, 0, 0,+ return avc\_denied(ssid, tsid, tclass, requested, 0, 0, 0, flags, avd); return 0; }diff --git a/security/selinux/hooks.c b/security/selinux/hooks.cindex 366c87a40bd157..171dd7fceac540 100644--- a/[security/selinux/hooks.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/selinux/hooks.c?id=fbfd64d25c7af3b8695201ebc85efe90be28c5a3)+++ b/[security/selinux/hooks.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/selinux/hooks.c?id=09a0fa92e5b45e99cf435b2fbf5ebcf889cf8780)@@ -3688,8 +3688,8 @@ static int ioctl\_has\_perm(const struct cred \*cred, struct file \*file, return 0;  isec = inode\_security(inode);- rc = avc\_has\_extended\_perms(ssid, isec->sid, isec->sclass,- requested, driver, xperm, &ad);+ rc = avc\_has\_extended\_perms(ssid, isec->sid, isec->sclass, requested,+ driver, AVC\_EXT\_IOCTL, xperm, &ad); out: return rc; }@@ -5952,7 +5952,7 @@ static int nlmsg\_sock\_has\_extended\_perms(struct sock \*sk, u32 perms, u16 nlmsg\_t xperm = nlmsg\_type & 0xff;  return avc\_has\_extended\_perms(current\_sid(), sksec->sid, sksec->sclass,- perms, driver, xperm, &ad);+ perms, driver, AVC\_EXT\_NLMSG, xperm, &ad); }  static int selinux\_netlink\_send(struct sock \*sk, struct sk\_buff \*skb)diff --git a/security/selinux/include/avc.h b/security/selinux/include/avc.hindex 96a614d47df8d1..281f4010366336 100644--- a/[security/selinux/include/avc.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/selinux/include/avc.h?id=fbfd64d25c7af3b8695201ebc85efe90be28c5a3)+++ b/[security/selinux/include/avc.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/selinux/include/avc.h?id=09a0fa92e5b45e99cf435b2fbf5ebcf889cf8780)@@ -136,8 +136,11 @@ int avc\_has\_perm\_noaudit(u32 ssid, u32 tsid, u16 tclass, u32 requested, int avc\_has\_perm(u32 ssid, u32 tsid, u16 tclass, u32 requested, struct common\_audit\_data \*auditdata); +#define AVC\_EXT\_IOCTL (1 << 0) /\* Cache entry for an ioctl extended permission \*/+#define AVC\_EXT\_NLMSG (1 << 1) /\* Cache entry for an nlmsg extended permission \*/ int avc\_has\_extended\_perms(u32 ssid, u32 tsid, u16 tclass, u32 requested,- u8 driver, u8 perm, struct common\_audit\_data \*ad);+ u8 driver, u8 base\_perm, u8 perm,+ struct common\_audit\_data \*ad);  u32 avc\_policy\_seqno(void); diff --git a/security/selinux/include/security.h b/security/selinux/include/security.hindex c7f2731abd03e8..700bd6c8bb3865 100644--- a/[security/selinux/include/security.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/selinux/include/security.h?id=fbfd64d25c7af3b8695201ebc85efe90be28c5a3)+++ b/[security/selinux/include/security.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/selinux/include/security.h?id=09a0fa92e5b45e99cf435b2fbf5ebcf889cf8780)@@ -239,6 +239,7 @@ struct extended\_perms\_data { struct extended\_perms\_decision { u8 used; u8 driver;+ u8 base\_perm; struct extended\_perms\_data \*allowed; struct extended\_perms\_data \*auditallow; struct extended\_perms\_data \*dontaudit;@@ -246,6 +247,7 @@ struct extended\_perms\_decision {  struct extended\_perms { u16 len; /\* length associated decision chain \*/+ u8 base\_perms; /\* which base permissions are covered \*/ struct extended\_perms\_data drivers; /\* flag drivers that are used \*/ }; @@ -257,6 +259,7 @@ void security\_compute\_av(u32 ssid, u32 tsid, u16 tclass, struct extended\_perms \*xperms);  void security\_compute\_xperms\_decision(u32 ssid, u32 tsid, u16 tclass, u8 driver,+ u8 base\_perm, struct extended\_perms\_decision \*xpermd);  void security\_compute\_av\_user(u32 ssid, u32 tsid, u16 tclass,diff --git a/security/selinux/ss/services.c b/security/selinux/ss/services.cindex 3d5c563cfc4c86..d9f58b5d0f49f0 100644--- a/[security/selinux/ss/services.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/selinux/ss/services.c?id=fbfd64d25c7af3b8695201ebc85efe90be28c5a3)+++ b/[security/selinux/ss/services.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/selinux/ss/services.c?id=09a0fa92e5b45e99cf435b2fbf5ebcf889cf8780)@@ -582,7 +582,7 @@ static void type\_attribute\_bounds\_av(struct policydb \*policydb, }  /\*- \* Flag which drivers have permissions.+ \* Flag which drivers have permissions and which base permissions are covered. \*/ void services\_compute\_xperms\_drivers( struct extended\_perms \*xperms,@@ -592,12 +592,19 @@ void services\_compute\_xperms\_drivers(  switch (node->datum.u.xperms->specified) { case AVTAB\_XPERMS\_IOCTLDRIVER:+ xperms->base\_perms |= AVC\_EXT\_IOCTL; /\* if one or more driver has all permissions allowed \*/ for (i = 0; i < ARRAY\_SIZE(xperms->drivers.p); i++) xperms->drivers.p[i] |= node->datum.u.xperms->perms.p[i]; break; case AVTAB\_XPERMS\_IOCTLFUNCTION:+ xperms->base\_perms |= AVC\_EXT\_IOCTL;+ /\* if allowing permissions within a driver \*/+ security\_xperm\_set(xperms->drivers.p,+ node->datum.u.xperms->driver);+ break; case AVTAB\_XPERMS\_NLMSG:+ xperms->base\_perms |= AVC\_EXT\_NLMSG; /\* if allowing permissions within a driver \*/ security\_xperm\_set(xperms->drivers.p, node->datum.u.xperms->driver);@@ -631,8 +638,7 @@ static void context\_struct\_compute\_av(struct policydb \*policydb, avd->auditallow = 0; avd->auditdeny = 0xffffffff; if (xperms) {- memset(&xperms->drivers, 0, sizeof(xperms->drivers));- xperms->len = 0;+ memset(xperms, 0, sizeof(\*xperms)); }  if (unlikely(!tclass || tclass > policydb->p\_classes.nprim)) {@@ -969,13 +975,19 @@ void services\_compute\_xperms\_decision(struct extended\_perms\_decision \*xpermd, { switch (node->datum.u.xperms->specified) { case AVTAB\_XPERMS\_IOCTLFUNCTION:- case AVTAB\_XPERMS\_NLMSG:- if (xpermd->driver != node->datum.u.xperms->driver)+ if (xpermd->base\_perm != AVC\_EXT\_IOCTL ||+ xpermd->driver != node->datum.u.xperms->driver) return; break; case AVTAB\_XPERMS\_IOCTLDRIVER:- if (!security\_xperm\_test(node->datum.u.xperms->perms.p,- xpermd->driver))+ if (xpermd->base\_perm != AVC\_EXT\_IOCTL ||+ !security\_xperm\_test(node->datum.u.xperms->perms.p,+ xpermd->driver))+ return;+ break;+ case AVTAB\_XPERMS\_NLMSG:+ if (xpermd->base\_perm != AVC\_EXT\_NLMSG ||+ xpermd->driver != node->datum.u.xperms->driver) return; break; default:@@ -1010,6 +1022,7 @@ void security\_compute\_xperms\_decision(u32 ssid, u32 tsid, u16 orig\_tclass, u8 driver,+ u8 base\_perm, struct extended\_perms\_decision \*xpermd) { struct selinux\_policy \*policy;@@ -1023,6 +1036,7 @@ void security\_compute\_xperms\_decision(u32 ssid, struct ebitmap\_node \*snode, \*tnode; unsigned int i, j; + xpermd->base\_perm = base\_perm; xpermd->driver = driver; xpermd->used = 0; memset(xpermd->allowed->p, 0, sizeof(xpermd->allowed->p)); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-08 15:11:25 +0000


