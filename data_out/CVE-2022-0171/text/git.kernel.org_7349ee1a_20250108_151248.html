

| [cgit logo](/) | [index](/) : [kernel/git/torvalds/linux.git](/pub/scm/linux/kernel/git/torvalds/linux.git/) | for-next master vsnprintf |
| --- | --- | --- |
| Linux kernel source tree | Linus Torvalds |

| [about](/pub/scm/linux/kernel/git/torvalds/linux.git/about/)[summary](/pub/scm/linux/kernel/git/torvalds/linux.git/)[refs](/pub/scm/linux/kernel/git/torvalds/linux.git/refs/)[log](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)[tree](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/)[commit](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/)[diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/)[stats](/pub/scm/linux/kernel/git/torvalds/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Linus Torvalds <torvalds@linux-foundation.org> | 2025-01-07 14:49:48 -0800 |
| --- | --- | --- |
| committer | Linus Torvalds <torvalds@linux-foundation.org> | 2025-01-07 14:49:48 -0800 |
| commit | [09a0fa92e5b45e99cf435b2fbf5ebcf889cf8780](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=09a0fa92e5b45e99cf435b2fbf5ebcf889cf8780) ([patch](/pub/scm/linux/kernel/git/torvalds/linux.git/patch/?id=09a0fa92e5b45e99cf435b2fbf5ebcf889cf8780)) | |
| tree | [866799422fa168b12f2626ece483b0ccd08ead39](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/) | |
| parent | [fbfd64d25c7af3b8695201ebc85efe90be28c5a3](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=fbfd64d25c7af3b8695201ebc85efe90be28c5a3) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id2=fbfd64d25c7af3b8695201ebc85efe90be28c5a3)) | |
| parent | [5e7f0efd23238039bcd4fc72ff28d94f364ec26b](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=5e7f0efd23238039bcd4fc72ff28d94f364ec26b) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id2=5e7f0efd23238039bcd4fc72ff28d94f364ec26b)) | |
| download | [linux-master.tar.gz](/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-master.tar.gz) | |

Merge tag 'selinux-pr-20250107' of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/selinux[HEAD](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=09a0fa92e5b45e99cf435b2fbf5ebcf889cf8780)[master](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)Pull selinux fix from Paul Moore:
"A single SELinux patch to address a problem with a single domain using
multiple xperm classes"
\* tag 'selinux-pr-20250107' of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/selinux:
selinux: match extended permissions to their base permissions
[Diffstat](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/)

| -rw-r--r-- | [security/selinux/avc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/security/selinux/avc.c) | 61 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [security/selinux/hooks.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/security/selinux/hooks.c) | 6 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/selinux/include/avc.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/security/selinux/include/avc.h) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/selinux/include/security.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/security/selinux/include/security.h) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/selinux/ss/services.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/security/selinux/ss/services.c) | 28 | |  |  |  | | --- | --- | --- | |

5 files changed, 65 insertions, 38 deletions

| diff --git a/security/selinux/avc.c b/security/selinux/avc.cindex cc0b0af2029617..1f2680bcc43a42 100644--- a/[security/selinux/avc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/selinux/avc.c?id=fbfd64d25c7af3b8695201ebc85efe90be28c5a3)+++ b/[security/selinux/avc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/selinux/avc.c?id=09a0fa92e5b45e99cf435b2fbf5ebcf889cf8780)@@ -174,13 +174,15 @@ int avc\_get\_hash\_stats(char \*page) \* using a linked list for extended\_perms\_decision lookup because the list is \* always small. i.e. less than 5, typically 1 \*/-static struct extended\_perms\_decision \*avc\_xperms\_decision\_lookup(u8 driver,- struct avc\_xperms\_node \*xp\_node)+static struct extended\_perms\_decision \*+avc\_xperms\_decision\_lookup(u8 driver, u8 base\_perm,+ struct avc\_xperms\_node \*xp\_node) { struct avc\_xperms\_decision\_node \*xpd\_node;  list\_for\_each\_entry(xpd\_node, &xp\_node->xpd\_head, xpd\_list) {- if (xpd\_node->xpd.driver == driver)+ if (xpd\_node->xpd.driver == driver &&+ xpd\_node->xpd.base\_perm == base\_perm) return &xpd\_node->xpd; } return NULL;@@ -205,11 +207,12 @@ avc\_xperms\_has\_perm(struct extended\_perms\_decision \*xpd, }  static void avc\_xperms\_allow\_perm(struct avc\_xperms\_node \*xp\_node,- u8 driver, u8 perm)+ u8 driver, u8 base\_perm, u8 perm) { struct extended\_perms\_decision \*xpd; security\_xperm\_set(xp\_node->xp.drivers.p, driver);- xpd = avc\_xperms\_decision\_lookup(driver, xp\_node);+ xp\_node->xp.base\_perms |= base\_perm;+ xpd = avc\_xperms\_decision\_lookup(driver, base\_perm, xp\_node); if (xpd && xpd->allowed) security\_xperm\_set(xpd->allowed->p, perm); }@@ -245,6 +248,7 @@ static void avc\_xperms\_free(struct avc\_xperms\_node \*xp\_node) static void avc\_copy\_xperms\_decision(struct extended\_perms\_decision \*dest, struct extended\_perms\_decision \*src) {+ dest->base\_perm = src->base\_perm; dest->driver = src->driver; dest->used = src->used; if (dest->used & XPERMS\_ALLOWED)@@ -272,6 +276,7 @@ static inline void avc\_quick\_copy\_xperms\_decision(u8 perm, \*/ u8 i = perm >> 5; + dest->base\_perm = src->base\_perm; dest->used = src->used; if (dest->used & XPERMS\_ALLOWED) dest->allowed->p[i] = src->allowed->p[i];@@ -357,6 +362,7 @@ static int avc\_xperms\_populate(struct avc\_node \*node,  memcpy(dest->xp.drivers.p, src->xp.drivers.p, sizeof(dest->xp.drivers.p)); dest->xp.len = src->xp.len;+ dest->xp.base\_perms = src->xp.base\_perms;  /\* for each source xpd allocate a destination xpd and copy \*/ list\_for\_each\_entry(src\_xpd, &src->xpd\_head, xpd\_list) {@@ -807,6 +813,7 @@ out: \* @event : Updating event \* @perms : Permission mask bits \* @driver: xperm driver information+ \* @base\_perm: the base permission associated with the extended permission \* @xperm: xperm permissions \* @ssid: AVC entry source sid \* @tsid: AVC entry target sid@@ -820,10 +827,9 @@ out: \* otherwise, this function updates the AVC entry. The original AVC-entry object \* will release later by RCU. \*/-static int avc\_update\_node(u32 event, u32 perms, u8 driver, u8 xperm, u32 ssid,- u32 tsid, u16 tclass, u32 seqno,- struct extended\_perms\_decision \*xpd,- u32 flags)+static int avc\_update\_node(u32 event, u32 perms, u8 driver, u8 base\_perm,+ u8 xperm, u32 ssid, u32 tsid, u16 tclass, u32 seqno,+ struct extended\_perms\_decision \*xpd, u32 flags) { u32 hvalue; int rc = 0;@@ -880,7 +886,7 @@ static int avc\_update\_node(u32 event, u32 perms, u8 driver, u8 xperm, u32 ssid, case AVC\_CALLBACK\_GRANT: node->ae.avd.allowed |= perms; if (node->ae.xp\_node && (flags & AVC\_EXTENDED\_PERMS))- avc\_xperms\_allow\_perm(node->ae.xp\_node, driver, xperm);+ avc\_xperms\_allow\_perm(node->ae.xp\_node, driver, base\_perm, xperm); break; case AVC\_CALLBACK\_TRY\_REVOKE: case AVC\_CALLBACK\_REVOKE:@@ -987,10 +993,9 @@ static noinline void avc\_compute\_av(u32 ssid, u32 tsid, u16 tclass, avc\_insert(ssid, tsid, tclass, avd, xp\_node); } -static noinline int avc\_denied(u32 ssid, u32 tsid,- u16 tclass, u32 requested,- u8 driver, u8 xperm, unsigned int flags,- struct av\_decision \*avd)+static noinline int avc\_denied(u32 ssid, u32 tsid, u16 tclass, u32 requested,+ u8 driver, u8 base\_perm, u8 xperm,+ unsigned int flags, struct av\_decision \*avd) { if (flags & AVC\_STRICT) return -EACCES;@@ -999,7 +1004,7 @@ static noinline int avc\_denied(u32 ssid, u32 tsid, !(avd->flags & AVD\_FLAGS\_PERMISSIVE)) return -EACCES; - avc\_update\_node(AVC\_CALLBACK\_GRANT, requested, driver,+ avc\_update\_node(AVC\_CALLBACK\_GRANT, requested, driver, base\_perm, xperm, ssid, tsid, tclass, avd->seqno, NULL, flags); return 0; }@@ -1012,7 +1017,8 @@ static noinline int avc\_denied(u32 ssid, u32 tsid, \* driver field is used to specify which set contains the permission. \*/ int avc\_has\_extended\_perms(u32 ssid, u32 tsid, u16 tclass, u32 requested,- u8 driver, u8 xperm, struct common\_audit\_data \*ad)+ u8 driver, u8 base\_perm, u8 xperm,+ struct common\_audit\_data \*ad) { struct avc\_node \*node; struct av\_decision avd;@@ -1047,22 +1053,23 @@ int avc\_has\_extended\_perms(u32 ssid, u32 tsid, u16 tclass, u32 requested, local\_xpd.auditallow = &auditallow; local\_xpd.dontaudit = &dontaudit; - xpd = avc\_xperms\_decision\_lookup(driver, xp\_node);+ xpd = avc\_xperms\_decision\_lookup(driver, base\_perm, xp\_node); if (unlikely(!xpd)) { /\* \* Compute the extended\_perms\_decision only if the driver- \* is flagged+ \* is flagged and the base permission is known. \*/- if (!security\_xperm\_test(xp\_node->xp.drivers.p, driver)) {+ if (!security\_xperm\_test(xp\_node->xp.drivers.p, driver) ||+ !(xp\_node->xp.base\_perms & base\_perm)) { avd.allowed &= ~requested; goto decision; } rcu\_read\_unlock();- security\_compute\_xperms\_decision(ssid, tsid, tclass,- driver, &local\_xpd);+ security\_compute\_xperms\_decision(ssid, tsid, tclass, driver,+ base\_perm, &local\_xpd); rcu\_read\_lock();- avc\_update\_node(AVC\_CALLBACK\_ADD\_XPERMS, requested,- driver, xperm, ssid, tsid, tclass, avd.seqno,+ avc\_update\_node(AVC\_CALLBACK\_ADD\_XPERMS, requested, driver,+ base\_perm, xperm, ssid, tsid, tclass, avd.seqno, &local\_xpd, 0); } else { avc\_quick\_copy\_xperms\_decision(xperm, &local\_xpd, xpd);@@ -1075,8 +1082,8 @@ int avc\_has\_extended\_perms(u32 ssid, u32 tsid, u16 tclass, u32 requested, decision: denied = requested & ~(avd.allowed); if (unlikely(denied))- rc = avc\_denied(ssid, tsid, tclass, requested,- driver, xperm, AVC\_EXTENDED\_PERMS, &avd);+ rc = avc\_denied(ssid, tsid, tclass, requested, driver,+ base\_perm, xperm, AVC\_EXTENDED\_PERMS, &avd);  rcu\_read\_unlock(); @@ -1110,7 +1117,7 @@ static noinline int avc\_perm\_nonode(u32 ssid, u32 tsid, u16 tclass, avc\_compute\_av(ssid, tsid, tclass, avd, &xp\_node); denied = requested & ~(avd->allowed); if (unlikely(denied))- return avc\_denied(ssid, tsid, tclass, requested, 0, 0,+ return avc\_denied(ssid, tsid, tclass, requested, 0, 0, 0, flags, avd); return 0; }@@ -1158,7 +1165,7 @@ inline int avc\_has\_perm\_noaudit(u32 ssid, u32 tsid, rcu\_read\_unlock();  if (unlikely(denied))- return avc\_denied(ssid, tsid, tclass, requested, 0, 0,+ return avc\_denied(ssid, tsid, tclass, requested, 0, 0, 0, flags, avd); return 0; }diff --git a/security/selinux/hooks.c b/security/selinux/hooks.cindex 366c87a40bd157..171dd7fceac540 100644--- a/[security/selinux/hooks.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/selinux/hooks.c?id=fbfd64d25c7af3b8695201ebc85efe90be28c5a3)+++ b/[security/selinux/hooks.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/selinux/hooks.c?id=09a0fa92e5b45e99cf435b2fbf5ebcf889cf8780)@@ -3688,8 +3688,8 @@ static int ioctl\_has\_perm(const struct cred \*cred, struct file \*file, return 0;  isec = inode\_security(inode);- rc = avc\_has\_extended\_perms(ssid, isec->sid, isec->sclass,- requested, driver, xperm, &ad);+ rc = avc\_has\_extended\_perms(ssid, isec->sid, isec->sclass, requested,+ driver, AVC\_EXT\_IOCTL, xperm, &ad); out: return rc; }@@ -5952,7 +5952,7 @@ static int nlmsg\_sock\_has\_extended\_perms(struct sock \*sk, u32 perms, u16 nlmsg\_t xperm = nlmsg\_type & 0xff;  return avc\_has\_extended\_perms(current\_sid(), sksec->sid, sksec->sclass,- perms, driver, xperm, &ad);+ perms, driver, AVC\_EXT\_NLMSG, xperm, &ad); }  static int selinux\_netlink\_send(struct sock \*sk, struct sk\_buff \*skb)diff --git a/security/selinux/include/avc.h b/security/selinux/include/avc.hindex 96a614d47df8d1..281f4010366336 100644--- a/[security/selinux/include/avc.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/selinux/include/avc.h?id=fbfd64d25c7af3b8695201ebc85efe90be28c5a3)+++ b/[security/selinux/include/avc.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/selinux/include/avc.h?id=09a0fa92e5b45e99cf435b2fbf5ebcf889cf8780)@@ -136,8 +136,11 @@ int avc\_has\_perm\_noaudit(u32 ssid, u32 tsid, u16 tclass, u32 requested, int avc\_has\_perm(u32 ssid, u32 tsid, u16 tclass, u32 requested, struct common\_audit\_data \*auditdata); +#define AVC\_EXT\_IOCTL (1 << 0) /\* Cache entry for an ioctl extended permission \*/+#define AVC\_EXT\_NLMSG (1 << 1) /\* Cache entry for an nlmsg extended permission \*/ int avc\_has\_extended\_perms(u32 ssid, u32 tsid, u16 tclass, u32 requested,- u8 driver, u8 perm, struct common\_audit\_data \*ad);+ u8 driver, u8 base\_perm, u8 perm,+ struct common\_audit\_data \*ad);  u32 avc\_policy\_seqno(void); diff --git a/security/selinux/include/security.h b/security/selinux/include/security.hindex c7f2731abd03e8..700bd6c8bb3865 100644--- a/[security/selinux/include/security.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/selinux/include/security.h?id=fbfd64d25c7af3b8695201ebc85efe90be28c5a3)+++ b/[security/selinux/include/security.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/selinux/include/security.h?id=09a0fa92e5b45e99cf435b2fbf5ebcf889cf8780)@@ -239,6 +239,7 @@ struct extended\_perms\_data { struct extended\_perms\_decision { u8 used; u8 driver;+ u8 base\_perm; struct extended\_perms\_data \*allowed; struct extended\_perms\_data \*auditallow; struct extended\_perms\_data \*dontaudit;@@ -246,6 +247,7 @@ struct extended\_perms\_decision {  struct extended\_perms { u16 len; /\* length associated decision chain \*/+ u8 base\_perms; /\* which base permissions are covered \*/ struct extended\_perms\_data drivers; /\* flag drivers that are used \*/ }; @@ -257,6 +259,7 @@ void security\_compute\_av(u32 ssid, u32 tsid, u16 tclass, struct extended\_perms \*xperms);  void security\_compute\_xperms\_decision(u32 ssid, u32 tsid, u16 tclass, u8 driver,+ u8 base\_perm, struct extended\_perms\_decision \*xpermd);  void security\_compute\_av\_user(u32 ssid, u32 tsid, u16 tclass,diff --git a/security/selinux/ss/services.c b/security/selinux/ss/services.cindex 3d5c563cfc4c86..d9f58b5d0f49f0 100644--- a/[security/selinux/ss/services.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/selinux/ss/services.c?id=fbfd64d25c7af3b8695201ebc85efe90be28c5a3)+++ b/[security/selinux/ss/services.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/selinux/ss/services.c?id=09a0fa92e5b45e99cf435b2fbf5ebcf889cf8780)@@ -582,7 +582,7 @@ static void type\_attribute\_bounds\_av(struct policydb \*policydb, }  /\*- \* Flag which drivers have permissions.+ \* Flag which drivers have permissions and which base permissions are covered. \*/ void services\_compute\_xperms\_drivers( struct extended\_perms \*xperms,@@ -592,12 +592,19 @@ void services\_compute\_xperms\_drivers(  switch (node->datum.u.xperms->specified) { case AVTAB\_XPERMS\_IOCTLDRIVER:+ xperms->base\_perms |= AVC\_EXT\_IOCTL; /\* if one or more driver has all permissions allowed \*/ for (i = 0; i < ARRAY\_SIZE(xperms->drivers.p); i++) xperms->drivers.p[i] |= node->datum.u.xperms->perms.p[i]; break; case AVTAB\_XPERMS\_IOCTLFUNCTION:+ xperms->base\_perms |= AVC\_EXT\_IOCTL;+ /\* if allowing permissions within a driver \*/+ security\_xperm\_set(xperms->drivers.p,+ node->datum.u.xperms->driver);+ break; case AVTAB\_XPERMS\_NLMSG:+ xperms->base\_perms |= AVC\_EXT\_NLMSG; /\* if allowing permissions within a driver \*/ security\_xperm\_set(xperms->drivers.p, node->datum.u.xperms->driver);@@ -631,8 +638,7 @@ static void context\_struct\_compute\_av(struct policydb \*policydb, avd->auditallow = 0; avd->auditdeny = 0xffffffff; if (xperms) {- memset(&xperms->drivers, 0, sizeof(xperms->drivers));- xperms->len = 0;+ memset(xperms, 0, sizeof(\*xperms)); }  if (unlikely(!tclass || tclass > policydb->p\_classes.nprim)) {@@ -969,13 +975,19 @@ void services\_compute\_xperms\_decision(struct extended\_perms\_decision \*xpermd, { switch (node->datum.u.xperms->specified) { case AVTAB\_XPERMS\_IOCTLFUNCTION:- case AVTAB\_XPERMS\_NLMSG:- if (xpermd->driver != node->datum.u.xperms->driver)+ if (xpermd->base\_perm != AVC\_EXT\_IOCTL ||+ xpermd->driver != node->datum.u.xperms->driver) return; break; case AVTAB\_XPERMS\_IOCTLDRIVER:- if (!security\_xperm\_test(node->datum.u.xperms->perms.p,- xpermd->driver))+ if (xpermd->base\_perm != AVC\_EXT\_IOCTL ||+ !security\_xperm\_test(node->datum.u.xperms->perms.p,+ xpermd->driver))+ return;+ break;+ case AVTAB\_XPERMS\_NLMSG:+ if (xpermd->base\_perm != AVC\_EXT\_NLMSG ||+ xpermd->driver != node->datum.u.xperms->driver) return; break; default:@@ -1010,6 +1022,7 @@ void security\_compute\_xperms\_decision(u32 ssid, u32 tsid, u16 orig\_tclass, u8 driver,+ u8 base\_perm, struct extended\_perms\_decision \*xpermd) { struct selinux\_policy \*policy;@@ -1023,6 +1036,7 @@ void security\_compute\_xperms\_decision(u32 ssid, struct ebitmap\_node \*snode, \*tnode; unsigned int i, j; + xpermd->base\_perm = base\_perm; xpermd->driver = driver; xpermd->used = 0; memset(xpermd->allowed->p, 0, sizeof(xpermd->allowed->p)); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-08 15:11:25 +0000

