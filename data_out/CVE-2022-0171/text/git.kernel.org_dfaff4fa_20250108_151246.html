

| [cgit logo](/) | [index](/) : [kernel/git/torvalds/linux.git](/pub/scm/linux/kernel/git/torvalds/linux.git/) | for-next master vsnprintf |
| --- | --- | --- |
| Linux kernel source tree | Linus Torvalds |

| [about](/pub/scm/linux/kernel/git/torvalds/linux.git/about/)[summary](/pub/scm/linux/kernel/git/torvalds/linux.git/)[refs](/pub/scm/linux/kernel/git/torvalds/linux.git/refs/?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)[log](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)[tree](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)[commit](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)[diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)[stats](/pub/scm/linux/kernel/git/torvalds/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Linus Torvalds <torvalds@linux-foundation.org> | 2022-04-22 17:58:36 -0700 |
| --- | --- | --- |
| committer | Linus Torvalds <torvalds@linux-foundation.org> | 2022-04-22 17:58:36 -0700 |
| commit | [bb4ce2c65881a2b9bdcd384f54a260a12a89dd91](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) ([patch](/pub/scm/linux/kernel/git/torvalds/linux.git/patch/?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)) | |
| tree | [ec4d74f4a0097bc661059b4b35261024b3a3fde2](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | |
| parent | [06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91&id2=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)) | |
| parent | [e852be8b148e117e25be1c98cf72ee489b05919e](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e852be8b148e117e25be1c98cf72ee489b05919e) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91&id2=e852be8b148e117e25be1c98cf72ee489b05919e)) | |
| download | [linux-bb4ce2c65881a2b9bdcd384f54a260a12a89dd91.tar.gz](/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-bb4ce2c65881a2b9bdcd384f54a260a12a89dd91.tar.gz) | |

Merge tag 'for-linus' of git://git.kernel.org/pub/scm/virt/kvm/kvmPull kvm fixes from Paolo Bonzini:
"The main and larger change here is a workaround for AMD's lack of
cache coherency for encrypted-memory guests.
I have another patch pending, but it's waiting for review from the
architecture maintainers.
RISC-V:
- Remove 's' & 'u' as valid ISA extension
- Do not allow disabling the base extensions 'i'/'m'/'a'/'c'
x86:
- Fix NMI watchdog in guests on AMD
- Fix for SEV cache incoherency issues
- Don't re-acquire SRCU lock in complete\_emulated\_io()
- Avoid NULL pointer deref if VM creation fails
- Fix race conditions between APICv disabling and vCPU creation
- Bugfixes for disabling of APICv
- Preserve BSP MSR\_KVM\_POLL\_CONTROL across suspend/resume
selftests:
- Do not use bitfields larger than 32-bits, they differ between GCC
and clang"
\* tag 'for-linus' of git://git.kernel.org/pub/scm/virt/kvm/kvm:
kvm: selftests: introduce and use more page size-related constants
kvm: selftests: do not use bitfields larger than 32-bits for PTEs
KVM: SEV: add cache flush to solve SEV cache incoherency issues
KVM: SVM: Flush when freeing encrypted pages even on SME\_COHERENT CPUs
KVM: SVM: Simplify and harden helper to flush SEV guest page(s)
KVM: selftests: Silence compiler warning in the kvm\_page\_table\_test
KVM: x86/pmu: Update AMD PMC sample period to fix guest NMI-watchdog
x86/kvm: Preserve BSP MSR\_KVM\_POLL\_CONTROL across suspend/resume
KVM: SPDX style and spelling fixes
KVM: x86: Skip KVM\_GUESTDBG\_BLOCKIRQ APICv update if APICv is disabled
KVM: x86: Pend KVM\_REQ\_APICV\_UPDATE during vCPU creation to fix a race
KVM: nVMX: Defer APICv updates while L2 is active until L1 is active
KVM: x86: Tag APICv DISABLE inhibit, not ABSENT, if APICv is disabled
KVM: Initialize debugfs\_dentry when a VM is created to avoid NULL deref
KVM: Add helpers to wrap vcpu->srcu\_idx and yell if it's abused
KVM: RISC-V: Use kvm\_vcpu.srcu\_idx, drop RISC-V's unnecessary copy
KVM: x86: Don't re-acquire SRCU lock in complete\_emulated\_io()
RISC-V: KVM: Restrict the extensions that can be disabled
RISC-V: KVM: Remove 's' & 'u' as valid ISA extension
[Diffstat](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)

| -rw-r--r-- | [arch/powerpc/kvm/book3s\_64\_mmu\_radix.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/powerpc/kvm/book3s_64_mmu_radix.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 9 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [arch/powerpc/kvm/book3s\_hv\_nested.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/powerpc/kvm/book3s_hv_nested.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 16 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/powerpc/kvm/book3s\_rtas.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/powerpc/kvm/book3s_rtas.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/powerpc/kvm/powerpc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/powerpc/kvm/powerpc.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/riscv/include/asm/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/riscv/include/asm/kvm_host.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/riscv/kvm/vcpu.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/riscv/kvm/vcpu.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 37 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/riscv/kvm/vcpu\_exit.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/riscv/kvm/vcpu_exit.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/s390/kvm/interrupt.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/s390/kvm/interrupt.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/s390/kvm/kvm-s390.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/s390/kvm/kvm-s390.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/s390/kvm/vsie.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/s390/kvm/vsie.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/include/asm/kvm-x86-ops.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/include/asm/kvm-x86-ops.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/include/asm/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/include/asm/kvm_host.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kernel/kvm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kernel/kvm.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 13 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/pmu.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kvm/pmu.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 9 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/svm/pmu.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kvm/svm/pmu.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/svm/sev.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kvm/svm/sev.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 67 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/svm/svm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kvm/svm/svm.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/svm/svm.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kvm/svm/svm.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/vmx/nested.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kvm/vmx/nested.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/vmx/pmu\_intel.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kvm/vmx/pmu_intel.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/vmx/vmx.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kvm/vmx/vmx.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/vmx/vmx.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kvm/vmx/vmx.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/x86/kvm/x86.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/x86/kvm/x86.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 60 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/linux/kvm_host.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 26 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/kvm/include/x86\_64/processor.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/tools/testing/selftests/kvm/include/x86_64/processor.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 17 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/kvm/kvm\_page\_table\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/tools/testing/selftests/kvm/kvm_page_table_test.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/kvm/lib/x86\_64/processor.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/tools/testing/selftests/kvm/lib/x86_64/processor.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 202 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/kvm/x86\_64/amx\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/tools/testing/selftests/kvm/x86_64/amx_test.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/kvm/x86\_64/emulator\_error\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/tools/testing/selftests/kvm/x86_64/emulator_error_test.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/kvm/x86\_64/smm\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/tools/testing/selftests/kvm/x86_64/smm_test.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/kvm/x86\_64/vmx\_tsc\_adjust\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/tools/testing/selftests/kvm/x86_64/vmx_tsc_adjust_test.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/kvm/x86\_64/xen\_shinfo\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/tools/testing/selftests/kvm/x86_64/xen_shinfo_test.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/kvm/x86\_64/xen\_vmcall\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/tools/testing/selftests/kvm/x86_64/xen_vmcall_test.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [virt/kvm/dirty\_ring.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/virt/kvm/dirty_ring.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [virt/kvm/kvm\_main.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/virt/kvm/kvm_main.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 43 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [virt/kvm/kvm\_mm.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/virt/kvm/kvm_mm.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91) | 2 | |  |  |  | | --- | --- | --- | |

36 files changed, 316 insertions, 252 deletions

| diff --git a/arch/powerpc/kvm/book3s\_64\_mmu\_radix.c b/arch/powerpc/kvm/book3s\_64\_mmu\_radix.cindex e4ce2a35483f6f..42851c32ff3bee 100644--- a/[arch/powerpc/kvm/book3s\_64\_mmu\_radix.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/powerpc/kvm/book3s_64_mmu_radix.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/powerpc/kvm/book3s\_64\_mmu\_radix.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/powerpc/kvm/book3s_64_mmu_radix.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -168,9 +168,10 @@ int kvmppc\_mmu\_walk\_radix\_tree(struct kvm\_vcpu \*vcpu, gva\_t eaddr, return -EINVAL; /\* Read the entry from guest memory \*/ addr = base + (index \* sizeof(rpte));- vcpu->srcu\_idx = srcu\_read\_lock(&kvm->srcu);++ kvm\_vcpu\_srcu\_read\_lock(vcpu); ret = kvm\_read\_guest(kvm, addr, &rpte, sizeof(rpte));- srcu\_read\_unlock(&kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); if (ret) { if (pte\_ret\_p) \*pte\_ret\_p = addr;@@ -246,9 +247,9 @@ int kvmppc\_mmu\_radix\_translate\_table(struct kvm\_vcpu \*vcpu, gva\_t eaddr,  /\* Read the table to find the root of the radix tree \*/ ptbl = (table & PRTB\_MASK) + (table\_index \* sizeof(entry));- vcpu->srcu\_idx = srcu\_read\_lock(&kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu); ret = kvm\_read\_guest(kvm, ptbl, &entry, sizeof(entry));- srcu\_read\_unlock(&kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); if (ret) return ret; diff --git a/arch/powerpc/kvm/book3s\_hv\_nested.c b/arch/powerpc/kvm/book3s\_hv\_nested.cindex 9d373f8963ee98..c943a051c6e700 100644--- a/[arch/powerpc/kvm/book3s\_hv\_nested.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/powerpc/kvm/book3s_hv_nested.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/powerpc/kvm/book3s\_hv\_nested.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/powerpc/kvm/book3s_hv_nested.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -306,10 +306,10 @@ long kvmhv\_enter\_nested\_guest(struct kvm\_vcpu \*vcpu) /\* copy parameters in \*/ hv\_ptr = kvmppc\_get\_gpr(vcpu, 4); regs\_ptr = kvmppc\_get\_gpr(vcpu, 5);- vcpu->srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu); err = kvmhv\_read\_guest\_state\_and\_regs(vcpu, &l2\_hv, &l2\_regs, hv\_ptr, regs\_ptr);- srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); if (err) return H\_PARAMETER; @@ -410,10 +410,10 @@ long kvmhv\_enter\_nested\_guest(struct kvm\_vcpu \*vcpu) byteswap\_hv\_regs(&l2\_hv); byteswap\_pt\_regs(&l2\_regs); }- vcpu->srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu); err = kvmhv\_write\_guest\_state\_and\_regs(vcpu, &l2\_hv, &l2\_regs, hv\_ptr, regs\_ptr);- srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); if (err) return H\_AUTHORITY; @@ -600,16 +600,16 @@ long kvmhv\_copy\_tofrom\_guest\_nested(struct kvm\_vcpu \*vcpu) goto not\_found;  /\* Write what was loaded into our buffer back to the L1 guest \*/- vcpu->srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu); rc = kvm\_vcpu\_write\_guest(vcpu, gp\_to, buf, n);- srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); if (rc) goto not\_found; } else { /\* Load the data to be stored from the L1 guest into our buf \*/- vcpu->srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu); rc = kvm\_vcpu\_read\_guest(vcpu, gp\_from, buf, n);- srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); if (rc) goto not\_found; diff --git a/arch/powerpc/kvm/book3s\_rtas.c b/arch/powerpc/kvm/book3s\_rtas.cindex 0f847f1e5ddd0b..6808bda0dbc10c 100644--- a/[arch/powerpc/kvm/book3s\_rtas.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/powerpc/kvm/book3s_rtas.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/powerpc/kvm/book3s\_rtas.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/powerpc/kvm/book3s_rtas.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -229,9 +229,9 @@ int kvmppc\_rtas\_hcall(struct kvm\_vcpu \*vcpu) \*/ args\_phys = kvmppc\_get\_gpr(vcpu, 4) & KVM\_PAM; - vcpu->srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu); rc = kvm\_read\_guest(vcpu->kvm, args\_phys, &args, sizeof(args));- srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); if (rc) goto fail; diff --git a/arch/powerpc/kvm/powerpc.c b/arch/powerpc/kvm/powerpc.cindex 875c30c12db046..533c4232e5abfd 100644--- a/[arch/powerpc/kvm/powerpc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/powerpc/kvm/powerpc.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/powerpc/kvm/powerpc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/powerpc/kvm/powerpc.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -425,9 +425,9 @@ int kvmppc\_ld(struct kvm\_vcpu \*vcpu, ulong \*eaddr, int size, void \*ptr, return EMULATE\_DONE; } - vcpu->srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu); rc = kvm\_read\_guest(vcpu->kvm, pte.raddr, ptr, size);- srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); if (rc) return EMULATE\_DO\_MMIO; diff --git a/arch/riscv/include/asm/kvm\_host.h b/arch/riscv/include/asm/kvm\_host.hindex 78da839657e524..cd4bbcecb0fbf0 100644--- a/[arch/riscv/include/asm/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/riscv/include/asm/kvm_host.h?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/riscv/include/asm/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/riscv/include/asm/kvm_host.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -193,9 +193,6 @@ struct kvm\_vcpu\_arch {  /\* Don't run the VCPU (blocked) \*/ bool pause;-- /\* SRCU lock index for in-kernel run loop \*/- int srcu\_idx; };  static inline void kvm\_arch\_hardware\_unsetup(void) {}diff --git a/arch/riscv/kvm/vcpu.c b/arch/riscv/kvm/vcpu.cindex 6785aef4cbd46e..7461f964d20a92 100644--- a/[arch/riscv/kvm/vcpu.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/riscv/kvm/vcpu.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/riscv/kvm/vcpu.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/riscv/kvm/vcpu.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -38,14 +38,16 @@ const struct kvm\_stats\_header kvm\_vcpu\_stats\_header = { sizeof(kvm\_vcpu\_stats\_desc), }; -#define KVM\_RISCV\_ISA\_ALLOWED (riscv\_isa\_extension\_mask(a) | \- riscv\_isa\_extension\_mask(c) | \- riscv\_isa\_extension\_mask(d) | \- riscv\_isa\_extension\_mask(f) | \- riscv\_isa\_extension\_mask(i) | \- riscv\_isa\_extension\_mask(m) | \- riscv\_isa\_extension\_mask(s) | \- riscv\_isa\_extension\_mask(u))+#define KVM\_RISCV\_ISA\_DISABLE\_ALLOWED (riscv\_isa\_extension\_mask(d) | \+ riscv\_isa\_extension\_mask(f))++#define KVM\_RISCV\_ISA\_DISABLE\_NOT\_ALLOWED (riscv\_isa\_extension\_mask(a) | \+ riscv\_isa\_extension\_mask(c) | \+ riscv\_isa\_extension\_mask(i) | \+ riscv\_isa\_extension\_mask(m))++#define KVM\_RISCV\_ISA\_ALLOWED (KVM\_RISCV\_ISA\_DISABLE\_ALLOWED | \+ KVM\_RISCV\_ISA\_DISABLE\_NOT\_ALLOWED)  static void kvm\_riscv\_reset\_vcpu(struct kvm\_vcpu \*vcpu) {@@ -219,7 +221,8 @@ static int kvm\_riscv\_vcpu\_set\_reg\_config(struct kvm\_vcpu \*vcpu, switch (reg\_num) { case KVM\_REG\_RISCV\_CONFIG\_REG(isa): if (!vcpu->arch.ran\_atleast\_once) {- vcpu->arch.isa = reg\_val;+ /\* Ignore the disable request for these extensions \*/+ vcpu->arch.isa = reg\_val | KVM\_RISCV\_ISA\_DISABLE\_NOT\_ALLOWED; vcpu->arch.isa &= riscv\_isa\_extension\_base(NULL); vcpu->arch.isa &= KVM\_RISCV\_ISA\_ALLOWED; kvm\_riscv\_vcpu\_fp\_reset(vcpu);@@ -724,13 +727,13 @@ int kvm\_arch\_vcpu\_ioctl\_run(struct kvm\_vcpu \*vcpu) /\* Mark this VCPU ran at least once \*/ vcpu->arch.ran\_atleast\_once = true; - vcpu->arch.srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu);  /\* Process MMIO value returned from user-space \*/ if (run->exit\_reason == KVM\_EXIT\_MMIO) { ret = kvm\_riscv\_vcpu\_mmio\_return(vcpu, vcpu->run); if (ret) {- srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->arch.srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); return ret; } }@@ -739,13 +742,13 @@ int kvm\_arch\_vcpu\_ioctl\_run(struct kvm\_vcpu \*vcpu) if (run->exit\_reason == KVM\_EXIT\_RISCV\_SBI) { ret = kvm\_riscv\_vcpu\_sbi\_return(vcpu, vcpu->run); if (ret) {- srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->arch.srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); return ret; } }  if (run->immediate\_exit) {- srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->arch.srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); return -EINTR; } @@ -784,7 +787,7 @@ int kvm\_arch\_vcpu\_ioctl\_run(struct kvm\_vcpu \*vcpu) \*/ vcpu->mode = IN\_GUEST\_MODE; - srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->arch.srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); smp\_mb\_\_after\_srcu\_read\_unlock();  /\*@@ -802,7 +805,7 @@ int kvm\_arch\_vcpu\_ioctl\_run(struct kvm\_vcpu \*vcpu) vcpu->mode = OUTSIDE\_GUEST\_MODE; local\_irq\_enable(); preempt\_enable();- vcpu->arch.srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu); continue; } @@ -846,7 +849,7 @@ int kvm\_arch\_vcpu\_ioctl\_run(struct kvm\_vcpu \*vcpu)  preempt\_enable(); - vcpu->arch.srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu);  ret = kvm\_riscv\_vcpu\_exit(vcpu, run, &trap); }@@ -855,7 +858,7 @@ int kvm\_arch\_vcpu\_ioctl\_run(struct kvm\_vcpu \*vcpu)  vcpu\_put(vcpu); - srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->arch.srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu);  return ret; }diff --git a/arch/riscv/kvm/vcpu\_exit.c b/arch/riscv/kvm/vcpu\_exit.cindex aa8af129e4bb93..a72c15d4b42a59 100644--- a/[arch/riscv/kvm/vcpu\_exit.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/riscv/kvm/vcpu_exit.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/riscv/kvm/vcpu\_exit.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/riscv/kvm/vcpu_exit.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -456,9 +456,9 @@ static int stage2\_page\_fault(struct kvm\_vcpu \*vcpu, struct kvm\_run \*run, void kvm\_riscv\_vcpu\_wfi(struct kvm\_vcpu \*vcpu) { if (!kvm\_arch\_vcpu\_runnable(vcpu)) {- srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->arch.srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); kvm\_vcpu\_halt(vcpu);- vcpu->arch.srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu); kvm\_clear\_request(KVM\_REQ\_UNHALT, vcpu); } }diff --git a/arch/s390/kvm/interrupt.c b/arch/s390/kvm/interrupt.cindex 9b30beac904db8..af96dc0549a4b5 100644--- a/[arch/s390/kvm/interrupt.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/s390/kvm/interrupt.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/s390/kvm/interrupt.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/s390/kvm/interrupt.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -1334,11 +1334,11 @@ int kvm\_s390\_handle\_wait(struct kvm\_vcpu \*vcpu) hrtimer\_start(&vcpu->arch.ckc\_timer, sltime, HRTIMER\_MODE\_REL); VCPU\_EVENT(vcpu, 4, "enabled wait: %llu ns", sltime); no\_timer:- srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); kvm\_vcpu\_halt(vcpu); vcpu->valid\_wakeup = false; \_\_unset\_cpu\_idle(vcpu);- vcpu->srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu);  hrtimer\_cancel(&vcpu->arch.ckc\_timer); return 0;diff --git a/arch/s390/kvm/kvm-s390.c b/arch/s390/kvm/kvm-s390.cindex 156d1c25a3c1ec..da3dabda1a1262 100644--- a/[arch/s390/kvm/kvm-s390.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/s390/kvm/kvm-s390.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/s390/kvm/kvm-s390.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/s390/kvm/kvm-s390.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -4237,14 +4237,14 @@ static int \_\_vcpu\_run(struct kvm\_vcpu \*vcpu) \* We try to hold kvm->srcu during most of vcpu\_run (except when run- \* ning the guest), so that memslots (and other stuff) are protected \*/- vcpu->srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu);  do { rc = vcpu\_pre\_run(vcpu); if (rc) break; - srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); /\* \* As PF\_VCPU will be used in fault handler, between \* guest\_enter and guest\_exit should be no uaccess.@@ -4281,12 +4281,12 @@ static int \_\_vcpu\_run(struct kvm\_vcpu \*vcpu) \_\_enable\_cpu\_timer\_accounting(vcpu); guest\_exit\_irqoff(); local\_irq\_enable();- vcpu->srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu);  rc = vcpu\_post\_run(vcpu, exit\_reason); } while (!signal\_pending(current) && !guestdbg\_exit\_pending(vcpu) && !rc); - srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); return rc; } diff --git a/arch/s390/kvm/vsie.c b/arch/s390/kvm/vsie.cindex acda4b6fc85182..dada78b92691fa 100644--- a/[arch/s390/kvm/vsie.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/s390/kvm/vsie.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/s390/kvm/vsie.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/s390/kvm/vsie.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -1091,7 +1091,7 @@ static int do\_vsie\_run(struct kvm\_vcpu \*vcpu, struct vsie\_page \*vsie\_page)  handle\_last\_fault(vcpu, vsie\_page); - srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu);  /\* save current guest state of bp isolation override \*/ guest\_bp\_isolation = test\_thread\_flag(TIF\_ISOLATE\_BP\_GUEST);@@ -1133,7 +1133,7 @@ static int do\_vsie\_run(struct kvm\_vcpu \*vcpu, struct vsie\_page \*vsie\_page) if (!guest\_bp\_isolation) clear\_thread\_flag(TIF\_ISOLATE\_BP\_GUEST); - vcpu->srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu);  if (rc == -EINTR) { VCPU\_EVENT(vcpu, 3, "%s", "machine check");diff --git a/arch/x86/include/asm/kvm-x86-ops.h b/arch/x86/include/asm/kvm-x86-ops.hindex 3c368b639c0462..1a6d7e3f6c32c7 100644--- a/[arch/x86/include/asm/kvm-x86-ops.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/include/asm/kvm-x86-ops.h?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/x86/include/asm/kvm-x86-ops.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/include/asm/kvm-x86-ops.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -118,6 +118,7 @@ KVM\_X86\_OP\_OPTIONAL(mem\_enc\_register\_region) KVM\_X86\_OP\_OPTIONAL(mem\_enc\_unregister\_region) KVM\_X86\_OP\_OPTIONAL(vm\_copy\_enc\_context\_from) KVM\_X86\_OP\_OPTIONAL(vm\_move\_enc\_context\_from)+KVM\_X86\_OP\_OPTIONAL(guest\_memory\_reclaimed) KVM\_X86\_OP(get\_msr\_feature) KVM\_X86\_OP(can\_emulate\_instruction) KVM\_X86\_OP(apic\_init\_signal\_blocked)diff --git a/arch/x86/include/asm/kvm\_host.h b/arch/x86/include/asm/kvm\_host.hindex e0c0f0e1f754c1..4ff36610af6ab5 100644--- a/[arch/x86/include/asm/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/include/asm/kvm_host.h?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/x86/include/asm/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/include/asm/kvm_host.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -1484,6 +1484,7 @@ struct kvm\_x86\_ops { int (\*mem\_enc\_unregister\_region)(struct kvm \*kvm, struct kvm\_enc\_region \*argp); int (\*vm\_copy\_enc\_context\_from)(struct kvm \*kvm, unsigned int source\_fd); int (\*vm\_move\_enc\_context\_from)(struct kvm \*kvm, unsigned int source\_fd);+ void (\*guest\_memory\_reclaimed)(struct kvm \*kvm);  int (\*get\_msr\_feature)(struct kvm\_msr\_entry \*entry); diff --git a/arch/x86/kernel/kvm.c b/arch/x86/kernel/kvm.cindex a22deb58f86d2e..8b1c45c9cda877 100644--- a/[arch/x86/kernel/kvm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kernel/kvm.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/x86/kernel/kvm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kernel/kvm.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -69,6 +69,7 @@ static DEFINE\_PER\_CPU\_DECRYPTED(struct kvm\_vcpu\_pv\_apf\_data, apf\_reason) \_\_align DEFINE\_PER\_CPU\_DECRYPTED(struct kvm\_steal\_time, steal\_time) \_\_aligned(64) \_\_visible; static int has\_steal\_clock = 0; +static int has\_guest\_poll = 0; /\* \* No need for any "IO delay" on KVM \*/@@ -706,14 +707,26 @@ static int kvm\_cpu\_down\_prepare(unsigned int cpu)  static int kvm\_suspend(void) {+ u64 val = 0;+ kvm\_guest\_cpu\_offline(false); +#ifdef CONFIG\_ARCH\_CPUIDLE\_HALTPOLL+ if (kvm\_para\_has\_feature(KVM\_FEATURE\_POLL\_CONTROL))+ rdmsrl(MSR\_KVM\_POLL\_CONTROL, val);+ has\_guest\_poll = !(val & 1);+#endif return 0; }  static void kvm\_resume(void) { kvm\_cpu\_online(raw\_smp\_processor\_id());++#ifdef CONFIG\_ARCH\_CPUIDLE\_HALTPOLL+ if (kvm\_para\_has\_feature(KVM\_FEATURE\_POLL\_CONTROL) && has\_guest\_poll)+ wrmsrl(MSR\_KVM\_POLL\_CONTROL, 0);+#endif }  static struct syscore\_ops kvm\_syscore\_ops = {diff --git a/arch/x86/kvm/pmu.h b/arch/x86/kvm/pmu.hindex 9e66fba1d6a37d..22992b049d380f 100644--- a/[arch/x86/kvm/pmu.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/pmu.h?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/x86/kvm/pmu.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/pmu.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -138,6 +138,15 @@ static inline u64 get\_sample\_period(struct kvm\_pmc \*pmc, u64 counter\_value) return sample\_period; } +static inline void pmc\_update\_sample\_period(struct kvm\_pmc \*pmc)+{+ if (!pmc->perf\_event || pmc->is\_paused)+ return;++ perf\_event\_period(pmc->perf\_event,+ get\_sample\_period(pmc, pmc->counter));+}+ void reprogram\_gp\_counter(struct kvm\_pmc \*pmc, u64 eventsel); void reprogram\_fixed\_counter(struct kvm\_pmc \*pmc, u8 ctrl, int fixed\_idx); void reprogram\_counter(struct kvm\_pmu \*pmu, int pmc\_idx);diff --git a/arch/x86/kvm/svm/pmu.c b/arch/x86/kvm/svm/pmu.cindex 24eb935b6f85c3..b14860863c3941 100644--- a/[arch/x86/kvm/svm/pmu.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/svm/pmu.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/x86/kvm/svm/pmu.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/svm/pmu.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -257,6 +257,7 @@ static int amd\_pmu\_set\_msr(struct kvm\_vcpu \*vcpu, struct msr\_data \*msr\_info) pmc = get\_gp\_pmc\_amd(pmu, msr, PMU\_TYPE\_COUNTER); if (pmc) { pmc->counter += data - pmc\_read\_counter(pmc);+ pmc\_update\_sample\_period(pmc); return 0; } /\* MSR\_EVNTSELn \*/diff --git a/arch/x86/kvm/svm/sev.c b/arch/x86/kvm/svm/sev.cindex 537aaddc852fc4..0ad70c12c7c311 100644--- a/[arch/x86/kvm/svm/sev.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/svm/sev.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/x86/kvm/svm/sev.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/svm/sev.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -2226,51 +2226,47 @@ int sev\_cpu\_init(struct svm\_cpu\_data \*sd) \* Pages used by hardware to hold guest encrypted state must be flushed before \* returning them to the system. \*/-static void sev\_flush\_guest\_memory(struct vcpu\_svm \*svm, void \*va,- unsigned long len)+static void sev\_flush\_encrypted\_page(struct kvm\_vcpu \*vcpu, void \*va) {+ int asid = to\_kvm\_svm(vcpu->kvm)->sev\_info.asid;+ /\*- \* If hardware enforced cache coherency for encrypted mappings of the- \* same physical page is supported, nothing to do.+ \* Note! The address must be a kernel address, as regular page walk+ \* checks are performed by VM\_PAGE\_FLUSH, i.e. operating on a user+ \* address is non-deterministic and unsafe. This function deliberately+ \* takes a pointer to deter passing in a user address. \*/- if (boot\_cpu\_has(X86\_FEATURE\_SME\_COHERENT))- return;+ unsigned long addr = (unsigned long)va;  /\*- \* If the VM Page Flush MSR is supported, use it to flush the page- \* (using the page virtual address and the guest ASID).+ \* If CPU enforced cache coherency for encrypted mappings of the+ \* same physical page is supported, use CLFLUSHOPT instead. NOTE: cache+ \* flush is still needed in order to work properly with DMA devices. \*/- if (boot\_cpu\_has(X86\_FEATURE\_VM\_PAGE\_FLUSH)) {- struct kvm\_sev\_info \*sev;- unsigned long va\_start;- u64 start, stop;-- /\* Align start and stop to page boundaries. \*/- va\_start = (unsigned long)va;- start = (u64)va\_start & PAGE\_MASK;- stop = PAGE\_ALIGN((u64)va\_start + len);-- if (start < stop) {- sev = &to\_kvm\_svm(svm->vcpu.kvm)->sev\_info;+ if (boot\_cpu\_has(X86\_FEATURE\_SME\_COHERENT)) {+ clflush\_cache\_range(va, PAGE\_SIZE);+ return;+ } - while (start < stop) {- wrmsrl(MSR\_AMD64\_VM\_PAGE\_FLUSH,- start | sev->asid);+ /\*+ \* VM Page Flush takes a host virtual address and a guest ASID. Fall+ \* back to WBINVD if this faults so as not to make any problems worse+ \* by leaving stale encrypted data in the cache.+ \*/+ if (WARN\_ON\_ONCE(wrmsrl\_safe(MSR\_AMD64\_VM\_PAGE\_FLUSH, addr | asid)))+ goto do\_wbinvd; - start += PAGE\_SIZE;- }+ return; - return;- }+do\_wbinvd:+ wbinvd\_on\_all\_cpus();+} - WARN(1, "Address overflow, using WBINVD\n");- }+void sev\_guest\_memory\_reclaimed(struct kvm \*kvm)+{+ if (!sev\_guest(kvm))+ return; - /\*- \* Hardware should always have one of the above features,- \* but if not, use WBINVD and issue a warning.- \*/- WARN\_ONCE(1, "Using WBINVD to flush guest memory\n"); wbinvd\_on\_all\_cpus(); } @@ -2284,7 +2280,8 @@ void sev\_free\_vcpu(struct kvm\_vcpu \*vcpu) svm = to\_svm(vcpu);  if (vcpu->arch.guest\_state\_protected)- sev\_flush\_guest\_memory(svm, svm->sev\_es.vmsa, PAGE\_SIZE);+ sev\_flush\_encrypted\_page(vcpu, svm->sev\_es.vmsa);+ \_\_free\_page(virt\_to\_page(svm->sev\_es.vmsa));  if (svm->sev\_es.ghcb\_sa\_free)diff --git a/arch/x86/kvm/svm/svm.c b/arch/x86/kvm/svm/svm.cindex bd4c64b362d24a..7e45d03cd018a5 100644--- a/[arch/x86/kvm/svm/svm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/svm/svm.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/x86/kvm/svm/svm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/svm/svm.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -4620,6 +4620,7 @@ static struct kvm\_x86\_ops svm\_x86\_ops \_\_initdata = { .mem\_enc\_ioctl = sev\_mem\_enc\_ioctl, .mem\_enc\_register\_region = sev\_mem\_enc\_register\_region, .mem\_enc\_unregister\_region = sev\_mem\_enc\_unregister\_region,+ .guest\_memory\_reclaimed = sev\_guest\_memory\_reclaimed,  .vm\_copy\_enc\_context\_from = sev\_vm\_copy\_enc\_context\_from, .vm\_move\_enc\_context\_from = sev\_vm\_move\_enc\_context\_from,diff --git a/arch/x86/kvm/svm/svm.h b/arch/x86/kvm/svm/svm.hindex f77a7d2d39dd6d..f76deff71002cb 100644--- a/[arch/x86/kvm/svm/svm.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/svm/svm.h?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/x86/kvm/svm/svm.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/svm/svm.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -609,6 +609,8 @@ int sev\_mem\_enc\_unregister\_region(struct kvm \*kvm, struct kvm\_enc\_region \*range); int sev\_vm\_copy\_enc\_context\_from(struct kvm \*kvm, unsigned int source\_fd); int sev\_vm\_move\_enc\_context\_from(struct kvm \*kvm, unsigned int source\_fd);+void sev\_guest\_memory\_reclaimed(struct kvm \*kvm);+ void pre\_sev\_run(struct vcpu\_svm \*svm, int cpu); void \_\_init sev\_set\_cpu\_caps(void); void \_\_init sev\_hardware\_setup(void);diff --git a/arch/x86/kvm/vmx/nested.c b/arch/x86/kvm/vmx/nested.cindex f18744f7ff82c9..856c8756388330 100644--- a/[arch/x86/kvm/vmx/nested.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/vmx/nested.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/x86/kvm/vmx/nested.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/vmx/nested.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -4618,6 +4618,11 @@ void nested\_vmx\_vmexit(struct kvm\_vcpu \*vcpu, u32 vm\_exit\_reason, kvm\_make\_request(KVM\_REQ\_APIC\_PAGE\_RELOAD, vcpu); } + if (vmx->nested.update\_vmcs01\_apicv\_status) {+ vmx->nested.update\_vmcs01\_apicv\_status = false;+ kvm\_make\_request(KVM\_REQ\_APICV\_UPDATE, vcpu);+ }+ if ((vm\_exit\_reason != -1) && (enable\_shadow\_vmcs || evmptr\_is\_valid(vmx->nested.hv\_evmcs\_vmptr))) vmx->nested.need\_vmcs12\_to\_shadow\_sync = true;diff --git a/arch/x86/kvm/vmx/pmu\_intel.c b/arch/x86/kvm/vmx/pmu\_intel.cindex bc3f8512bb646d..b82b6709d7a819 100644--- a/[arch/x86/kvm/vmx/pmu\_intel.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/vmx/pmu_intel.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/x86/kvm/vmx/pmu\_intel.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/vmx/pmu_intel.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -431,15 +431,11 @@ static int intel\_pmu\_set\_msr(struct kvm\_vcpu \*vcpu, struct msr\_data \*msr\_info) !(msr & MSR\_PMC\_FULL\_WIDTH\_BIT)) data = (s64)(s32)data; pmc->counter += data - pmc\_read\_counter(pmc);- if (pmc->perf\_event && !pmc->is\_paused)- perf\_event\_period(pmc->perf\_event,- get\_sample\_period(pmc, data));+ pmc\_update\_sample\_period(pmc); return 0; } else if ((pmc = get\_fixed\_pmc(pmu, msr))) { pmc->counter += data - pmc\_read\_counter(pmc);- if (pmc->perf\_event && !pmc->is\_paused)- perf\_event\_period(pmc->perf\_event,- get\_sample\_period(pmc, data));+ pmc\_update\_sample\_period(pmc); return 0; } else if ((pmc = get\_gp\_pmc(pmu, msr, MSR\_P6\_EVNTSEL0))) { if (data == pmc->eventsel)diff --git a/arch/x86/kvm/vmx/vmx.c b/arch/x86/kvm/vmx/vmx.cindex 04d170c4b61eb4..d58b763df855f6 100644--- a/[arch/x86/kvm/vmx/vmx.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/vmx/vmx.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/x86/kvm/vmx/vmx.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/vmx/vmx.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -4174,6 +4174,11 @@ static void vmx\_refresh\_apicv\_exec\_ctrl(struct kvm\_vcpu \*vcpu) { struct vcpu\_vmx \*vmx = to\_vmx(vcpu); + if (is\_guest\_mode(vcpu)) {+ vmx->nested.update\_vmcs01\_apicv\_status = true;+ return;+ }+ pin\_controls\_set(vmx, vmx\_pin\_based\_exec\_ctrl(vmx)); if (cpu\_has\_secondary\_exec\_ctrls()) { if (kvm\_vcpu\_apicv\_active(vcpu))diff --git a/arch/x86/kvm/vmx/vmx.h b/arch/x86/kvm/vmx/vmx.hindex 9c6bfcd84008be..b98c7e96697a9a 100644--- a/[arch/x86/kvm/vmx/vmx.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/vmx/vmx.h?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/x86/kvm/vmx/vmx.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/vmx/vmx.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -183,6 +183,7 @@ struct nested\_vmx { bool change\_vmcs01\_virtual\_apic\_mode; bool reload\_vmcs01\_apic\_access\_page; bool update\_vmcs01\_cpu\_dirty\_logging;+ bool update\_vmcs01\_apicv\_status;  /\* \* Enlightened VMCS has been enabled. It does not mean that L1 has todiff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.cindex 547ba00ef64fc3..a6ab19afc638b2 100644--- a/[arch/x86/kvm/x86.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/x86.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[arch/x86/kvm/x86.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kvm/x86.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -9111,7 +9111,7 @@ static void kvm\_apicv\_init(struct kvm \*kvm)  if (!enable\_apicv) set\_or\_clear\_apicv\_inhibit(inhibits,- APICV\_INHIBIT\_REASON\_ABSENT, true);+ APICV\_INHIBIT\_REASON\_DISABLE, true); }  static void kvm\_sched\_yield(struct kvm\_vcpu \*vcpu, unsigned long dest\_id)@@ -9889,6 +9889,11 @@ void kvm\_arch\_mmu\_notifier\_invalidate\_range(struct kvm \*kvm, kvm\_make\_all\_cpus\_request(kvm, KVM\_REQ\_APIC\_PAGE\_RELOAD); } +void kvm\_arch\_guest\_memory\_reclaimed(struct kvm \*kvm)+{+ static\_call\_cond(kvm\_x86\_guest\_memory\_reclaimed)(kvm);+}+ static void kvm\_vcpu\_reload\_apic\_access\_page(struct kvm\_vcpu \*vcpu) { if (!lapic\_in\_kernel(vcpu))@@ -10097,7 +10102,7 @@ static int vcpu\_enter\_guest(struct kvm\_vcpu \*vcpu) /\* Store vcpu->apicv\_active before vcpu->mode. \*/ smp\_store\_release(&vcpu->mode, IN\_GUEST\_MODE); - srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu);  /\* \* 1) We should set ->mode before checking ->requests. Please see@@ -10128,7 +10133,7 @@ static int vcpu\_enter\_guest(struct kvm\_vcpu \*vcpu) smp\_wmb(); local\_irq\_enable(); preempt\_enable();- vcpu->srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu); r = 1; goto cancel\_injection; }@@ -10254,7 +10259,7 @@ static int vcpu\_enter\_guest(struct kvm\_vcpu \*vcpu) local\_irq\_enable(); preempt\_enable(); - vcpu->srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu);  /\* \* Profile KVM exit RIPs:@@ -10284,7 +10289,7 @@ out: }  /\* Called within kvm->srcu read side. \*/-static inline int vcpu\_block(struct kvm \*kvm, struct kvm\_vcpu \*vcpu)+static inline int vcpu\_block(struct kvm\_vcpu \*vcpu) { bool hv\_timer; @@ -10300,12 +10305,12 @@ static inline int vcpu\_block(struct kvm \*kvm, struct kvm\_vcpu \*vcpu) if (hv\_timer) kvm\_lapic\_switch\_to\_sw\_timer(vcpu); - srcu\_read\_unlock(&kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); if (vcpu->arch.mp\_state == KVM\_MP\_STATE\_HALTED) kvm\_vcpu\_halt(vcpu); else kvm\_vcpu\_block(vcpu);- vcpu->srcu\_idx = srcu\_read\_lock(&kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu);  if (hv\_timer) kvm\_lapic\_switch\_to\_hv\_timer(vcpu);@@ -10347,7 +10352,6 @@ static inline bool kvm\_vcpu\_running(struct kvm\_vcpu \*vcpu) static int vcpu\_run(struct kvm\_vcpu \*vcpu) { int r;- struct kvm \*kvm = vcpu->kvm;  vcpu->arch.l1tf\_flush\_l1d = true; @@ -10355,7 +10359,7 @@ static int vcpu\_run(struct kvm\_vcpu \*vcpu) if (kvm\_vcpu\_running(vcpu)) { r = vcpu\_enter\_guest(vcpu); } else {- r = vcpu\_block(kvm, vcpu);+ r = vcpu\_block(vcpu); }  if (r <= 0)@@ -10374,9 +10378,9 @@ static int vcpu\_run(struct kvm\_vcpu \*vcpu) }  if (\_\_xfer\_to\_guest\_mode\_work\_pending()) {- srcu\_read\_unlock(&kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); r = xfer\_to\_guest\_mode\_handle\_work(vcpu);- vcpu->srcu\_idx = srcu\_read\_lock(&kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu); if (r) return r; }@@ -10387,12 +10391,7 @@ static int vcpu\_run(struct kvm\_vcpu \*vcpu)  static inline int complete\_emulated\_io(struct kvm\_vcpu \*vcpu) {- int r;-- vcpu->srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);- r = kvm\_emulate\_instruction(vcpu, EMULTYPE\_NO\_DECODE);- srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->srcu\_idx);- return r;+ return kvm\_emulate\_instruction(vcpu, EMULTYPE\_NO\_DECODE); }  static int complete\_emulated\_pio(struct kvm\_vcpu \*vcpu)@@ -10484,7 +10483,6 @@ static void kvm\_put\_guest\_fpu(struct kvm\_vcpu \*vcpu) int kvm\_arch\_vcpu\_ioctl\_run(struct kvm\_vcpu \*vcpu) { struct kvm\_run \*kvm\_run = vcpu->run;- struct kvm \*kvm = vcpu->kvm; int r;  vcpu\_load(vcpu);@@ -10492,7 +10490,7 @@ int kvm\_arch\_vcpu\_ioctl\_run(struct kvm\_vcpu \*vcpu) kvm\_run->flags = 0; kvm\_load\_guest\_fpu(vcpu); - vcpu->srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu); if (unlikely(vcpu->arch.mp\_state == KVM\_MP\_STATE\_UNINITIALIZED)) { if (kvm\_run->immediate\_exit) { r = -EINTR;@@ -10504,9 +10502,9 @@ int kvm\_arch\_vcpu\_ioctl\_run(struct kvm\_vcpu \*vcpu) \*/ WARN\_ON\_ONCE(kvm\_lapic\_hv\_timer\_in\_use(vcpu)); - srcu\_read\_unlock(&kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu); kvm\_vcpu\_block(vcpu);- vcpu->srcu\_idx = srcu\_read\_lock(&kvm->srcu);+ kvm\_vcpu\_srcu\_read\_lock(vcpu);  if (kvm\_apic\_accept\_events(vcpu) < 0) { r = 0;@@ -10567,7 +10565,7 @@ out: if (kvm\_run->kvm\_valid\_regs) store\_regs(vcpu); post\_kvm\_run\_save(vcpu);- srcu\_read\_unlock(&kvm->srcu, vcpu->srcu\_idx);+ kvm\_vcpu\_srcu\_read\_unlock(vcpu);  kvm\_sigset\_deactivate(vcpu); vcpu\_put(vcpu);@@ -10985,6 +10983,9 @@ static void kvm\_arch\_vcpu\_guestdbg\_update\_apicv\_inhibit(struct kvm \*kvm) struct kvm\_vcpu \*vcpu; unsigned long i; + if (!enable\_apicv)+ return;+ down\_write(&kvm->arch.apicv\_update\_lock);  kvm\_for\_each\_vcpu(i, vcpu, kvm) {@@ -11196,8 +11197,21 @@ int kvm\_arch\_vcpu\_create(struct kvm\_vcpu \*vcpu) r = kvm\_create\_lapic(vcpu, lapic\_timer\_advance\_ns); if (r < 0) goto fail\_mmu\_destroy;- if (kvm\_apicv\_activated(vcpu->kvm))++ /\*+ \* Defer evaluating inhibits until the vCPU is first run, as+ \* this vCPU will not get notified of any changes until this+ \* vCPU is visible to other vCPUs (marked online and added to+ \* the set of vCPUs). Opportunistically mark APICv active as+ \* VMX in particularly is highly unlikely to have inhibits.+ \* Ignore the current per-VM APICv state so that vCPU creation+ \* is guaranteed to run with a deterministic value, the request+ \* will ensure the vCPU gets the correct state before VM-Entry.+ \*/+ if (enable\_apicv) { vcpu->arch.apicv\_active = true;+ kvm\_make\_request(KVM\_REQ\_APICV\_UPDATE, vcpu);+ } } else static\_branch\_inc(&kvm\_has\_noapic\_vcpu); diff --git a/include/linux/kvm\_host.h b/include/linux/kvm\_host.hindex 3f9b22c4983a85..34eed5f85ed607 100644--- a/[include/linux/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/kvm_host.h?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[include/linux/kvm\_host.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/kvm_host.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -315,7 +315,10 @@ struct kvm\_vcpu { int cpu; int vcpu\_id; /\* id given by userspace at creation \*/ int vcpu\_idx; /\* index in kvm->vcpus array \*/- int srcu\_idx;+ int \_\_\_\_srcu\_idx; /\* Don't use this directly. You've been warned. \*/+#ifdef CONFIG\_PROVE\_RCU+ int srcu\_depth;+#endif int mode; u64 requests; unsigned long guest\_debug;@@ -840,6 +843,25 @@ static inline void kvm\_vm\_bugged(struct kvm \*kvm) unlikely(\_\_ret); \ }) +static inline void kvm\_vcpu\_srcu\_read\_lock(struct kvm\_vcpu \*vcpu)+{+#ifdef CONFIG\_PROVE\_RCU+ WARN\_ONCE(vcpu->srcu\_depth++,+ "KVM: Illegal vCPU srcu\_idx LOCK, depth=%d", vcpu->srcu\_depth - 1);+#endif+ vcpu->\_\_\_\_srcu\_idx = srcu\_read\_lock(&vcpu->kvm->srcu);+}++static inline void kvm\_vcpu\_srcu\_read\_unlock(struct kvm\_vcpu \*vcpu)+{+ srcu\_read\_unlock(&vcpu->kvm->srcu, vcpu->\_\_\_\_srcu\_idx);++#ifdef CONFIG\_PROVE\_RCU+ WARN\_ONCE(--vcpu->srcu\_depth,+ "KVM: Illegal vCPU srcu\_idx UNLOCK, depth=%d", vcpu->srcu\_depth);+#endif+}+ static inline bool kvm\_dirty\_log\_manual\_protect\_and\_init\_set(struct kvm \*kvm) { return !!(kvm->manual\_dirty\_log\_protect & KVM\_DIRTY\_LOG\_INITIALLY\_SET);@@ -2197,6 +2219,8 @@ static inline long kvm\_arch\_vcpu\_async\_ioctl(struct file \*filp, void kvm\_arch\_mmu\_notifier\_invalidate\_range(struct kvm \*kvm, unsigned long start, unsigned long end); +void kvm\_arch\_guest\_memory\_reclaimed(struct kvm \*kvm);+ #ifdef CONFIG\_HAVE\_KVM\_VCPU\_RUN\_PID\_CHANGE int kvm\_arch\_vcpu\_run\_pid\_change(struct kvm\_vcpu \*vcpu); #elsediff --git a/tools/testing/selftests/kvm/include/x86\_64/processor.h b/tools/testing/selftests/kvm/include/x86\_64/processor.hindex 37db341d4cc5c9..d0d51adec76eb8 100644--- a/[tools/testing/selftests/kvm/include/x86\_64/processor.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/include/x86_64/processor.h?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[tools/testing/selftests/kvm/include/x86\_64/processor.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/include/x86_64/processor.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -60,6 +60,23 @@ /\* CPUID.0x8000\_0001.EDX \*/ #define CPUID\_GBPAGES (1ul << 26) +/\* Page table bitfield declarations \*/+#define PTE\_PRESENT\_MASK BIT\_ULL(0)+#define PTE\_WRITABLE\_MASK BIT\_ULL(1)+#define PTE\_USER\_MASK BIT\_ULL(2)+#define PTE\_ACCESSED\_MASK BIT\_ULL(5)+#define PTE\_DIRTY\_MASK BIT\_ULL(6)+#define PTE\_LARGE\_MASK BIT\_ULL(7)+#define PTE\_GLOBAL\_MASK BIT\_ULL(8)+#define PTE\_NX\_MASK BIT\_ULL(63)++#define PAGE\_SHIFT 12+#define PAGE\_SIZE (1ULL << PAGE\_SHIFT)+#define PAGE\_MASK (~(PAGE\_SIZE-1))++#define PHYSICAL\_PAGE\_MASK GENMASK\_ULL(51, 12)+#define PTE\_GET\_PFN(pte) (((pte) & PHYSICAL\_PAGE\_MASK) >> PAGE\_SHIFT)+ /\* General Registers in 64-Bit Mode \*/ struct gpr64\_regs { u64 rax;diff --git a/tools/testing/selftests/kvm/kvm\_page\_table\_test.c b/tools/testing/selftests/kvm/kvm\_page\_table\_test.cindex ba1fdc3dcf4a90..2c4a7563a4f8ad 100644--- a/[tools/testing/selftests/kvm/kvm\_page\_table\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/kvm_page_table_test.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[tools/testing/selftests/kvm/kvm\_page\_table\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/kvm_page_table_test.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -278,7 +278,7 @@ static struct kvm\_vm \*pre\_init\_before\_test(enum vm\_guest\_mode mode, void \*arg) else guest\_test\_phys\_mem = p->phys\_offset; #ifdef \_\_s390x\_\_- alignment = max(0x100000, alignment);+ alignment = max(0x100000UL, alignment); #endif guest\_test\_phys\_mem = align\_down(guest\_test\_phys\_mem, alignment); diff --git a/tools/testing/selftests/kvm/lib/x86\_64/processor.c b/tools/testing/selftests/kvm/lib/x86\_64/processor.cindex 9f000dfb55949d..33ea5e9955d9bd 100644--- a/[tools/testing/selftests/kvm/lib/x86\_64/processor.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/lib/x86_64/processor.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[tools/testing/selftests/kvm/lib/x86\_64/processor.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/lib/x86_64/processor.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -19,38 +19,6 @@  vm\_vaddr\_t exception\_handlers; -/\* Virtual translation table structure declarations \*/-struct pageUpperEntry {- uint64\_t present:1;- uint64\_t writable:1;- uint64\_t user:1;- uint64\_t write\_through:1;- uint64\_t cache\_disable:1;- uint64\_t accessed:1;- uint64\_t ignored\_06:1;- uint64\_t page\_size:1;- uint64\_t ignored\_11\_08:4;- uint64\_t pfn:40;- uint64\_t ignored\_62\_52:11;- uint64\_t execute\_disable:1;-};--struct pageTableEntry {- uint64\_t present:1;- uint64\_t writable:1;- uint64\_t user:1;- uint64\_t write\_through:1;- uint64\_t cache\_disable:1;- uint64\_t accessed:1;- uint64\_t dirty:1;- uint64\_t reserved\_07:1;- uint64\_t global:1;- uint64\_t ignored\_11\_09:3;- uint64\_t pfn:40;- uint64\_t ignored\_62\_52:11;- uint64\_t execute\_disable:1;-};- void regs\_dump(FILE \*stream, struct kvm\_regs \*regs, uint8\_t indent) {@@ -195,23 +163,21 @@ static void \*virt\_get\_pte(struct kvm\_vm \*vm, uint64\_t pt\_pfn, uint64\_t vaddr, return &page\_table[index]; } -static struct pageUpperEntry \*virt\_create\_upper\_pte(struct kvm\_vm \*vm,- uint64\_t pt\_pfn,- uint64\_t vaddr,- uint64\_t paddr,- int level,- enum x86\_page\_size page\_size)+static uint64\_t \*virt\_create\_upper\_pte(struct kvm\_vm \*vm,+ uint64\_t pt\_pfn,+ uint64\_t vaddr,+ uint64\_t paddr,+ int level,+ enum x86\_page\_size page\_size) {- struct pageUpperEntry \*pte = virt\_get\_pte(vm, pt\_pfn, vaddr, level);-- if (!pte->present) {- pte->writable = true;- pte->present = true;- pte->page\_size = (level == page\_size);- if (pte->page\_size)- pte->pfn = paddr >> vm->page\_shift;+ uint64\_t \*pte = virt\_get\_pte(vm, pt\_pfn, vaddr, level);++ if (!(\*pte & PTE\_PRESENT\_MASK)) {+ \*pte = PTE\_PRESENT\_MASK | PTE\_WRITABLE\_MASK;+ if (level == page\_size)+ \*pte |= PTE\_LARGE\_MASK | (paddr & PHYSICAL\_PAGE\_MASK); else- pte->pfn = vm\_alloc\_page\_table(vm) >> vm->page\_shift;+ \*pte |= vm\_alloc\_page\_table(vm) & PHYSICAL\_PAGE\_MASK; } else { /\* \* Entry already present. Assert that the caller doesn't want@@ -221,7 +187,7 @@ static struct pageUpperEntry \*virt\_create\_upper\_pte(struct kvm\_vm \*vm, TEST\_ASSERT(level != page\_size, "Cannot create hugepage at level: %u, vaddr: 0x%lx\n", page\_size, vaddr);- TEST\_ASSERT(!pte->page\_size,+ TEST\_ASSERT(!(\*pte & PTE\_LARGE\_MASK), "Cannot create page table at level: %u, vaddr: 0x%lx\n", level, vaddr); }@@ -232,8 +198,8 @@ void \_\_virt\_pg\_map(struct kvm\_vm \*vm, uint64\_t vaddr, uint64\_t paddr, enum x86\_page\_size page\_size) { const uint64\_t pg\_size = 1ull << ((page\_size \* 9) + 12);- struct pageUpperEntry \*pml4e, \*pdpe, \*pde;- struct pageTableEntry \*pte;+ uint64\_t \*pml4e, \*pdpe, \*pde;+ uint64\_t \*pte;  TEST\_ASSERT(vm->mode == VM\_MODE\_PXXV48\_4K, "Unknown or unsupported guest mode, mode: 0x%x", vm->mode);@@ -257,24 +223,22 @@ void \_\_virt\_pg\_map(struct kvm\_vm \*vm, uint64\_t vaddr, uint64\_t paddr, \*/ pml4e = virt\_create\_upper\_pte(vm, vm->pgd >> vm->page\_shift, vaddr, paddr, 3, page\_size);- if (pml4e->page\_size)+ if (\*pml4e & PTE\_LARGE\_MASK) return; - pdpe = virt\_create\_upper\_pte(vm, pml4e->pfn, vaddr, paddr, 2, page\_size);- if (pdpe->page\_size)+ pdpe = virt\_create\_upper\_pte(vm, PTE\_GET\_PFN(\*pml4e), vaddr, paddr, 2, page\_size);+ if (\*pdpe & PTE\_LARGE\_MASK) return; - pde = virt\_create\_upper\_pte(vm, pdpe->pfn, vaddr, paddr, 1, page\_size);- if (pde->page\_size)+ pde = virt\_create\_upper\_pte(vm, PTE\_GET\_PFN(\*pdpe), vaddr, paddr, 1, page\_size);+ if (\*pde & PTE\_LARGE\_MASK) return;  /\* Fill in page table entry. \*/- pte = virt\_get\_pte(vm, pde->pfn, vaddr, 0);- TEST\_ASSERT(!pte->present,+ pte = virt\_get\_pte(vm, PTE\_GET\_PFN(\*pde), vaddr, 0);+ TEST\_ASSERT(!(\*pte & PTE\_PRESENT\_MASK), "PTE already present for 4k page at vaddr: 0x%lx\n", vaddr);- pte->pfn = paddr >> vm->page\_shift;- pte->writable = true;- pte->present = 1;+ \*pte = PTE\_PRESENT\_MASK | PTE\_WRITABLE\_MASK | (paddr & PHYSICAL\_PAGE\_MASK); }  void virt\_pg\_map(struct kvm\_vm \*vm, uint64\_t vaddr, uint64\_t paddr)@@ -282,22 +246,22 @@ void virt\_pg\_map(struct kvm\_vm \*vm, uint64\_t vaddr, uint64\_t paddr) \_\_virt\_pg\_map(vm, vaddr, paddr, X86\_PAGE\_SIZE\_4K); } -static struct pageTableEntry \*\_vm\_get\_page\_table\_entry(struct kvm\_vm \*vm, int vcpuid,+static uint64\_t \*\_vm\_get\_page\_table\_entry(struct kvm\_vm \*vm, int vcpuid, uint64\_t vaddr) { uint16\_t index[4];- struct pageUpperEntry \*pml4e, \*pdpe, \*pde;- struct pageTableEntry \*pte;+ uint64\_t \*pml4e, \*pdpe, \*pde;+ uint64\_t \*pte; struct kvm\_cpuid\_entry2 \*entry; struct kvm\_sregs sregs; int max\_phy\_addr;- /\* Set the bottom 52 bits. \*/- uint64\_t rsvd\_mask = 0x000fffffffffffff;+ uint64\_t rsvd\_mask = 0;  entry = kvm\_get\_supported\_cpuid\_index(0x80000008, 0); max\_phy\_addr = entry->eax & 0x000000ff;- /\* Clear the bottom bits of the reserved mask. \*/- rsvd\_mask = (rsvd\_mask >> max\_phy\_addr) << max\_phy\_addr;+ /\* Set the high bits in the reserved mask. \*/+ if (max\_phy\_addr < 52)+ rsvd\_mask = GENMASK\_ULL(51, max\_phy\_addr);  /\* \* SDM vol 3, fig 4-11 "Formats of CR3 and Paging-Structure Entries@@ -307,7 +271,7 @@ static struct pageTableEntry \*\_vm\_get\_page\_table\_entry(struct kvm\_vm \*vm, int vc \*/ vcpu\_sregs\_get(vm, vcpuid, &sregs); if ((sregs.efer & EFER\_NX) == 0) {- rsvd\_mask |= (1ull << 63);+ rsvd\_mask |= PTE\_NX\_MASK; }  TEST\_ASSERT(vm->mode == VM\_MODE\_PXXV48\_4K, "Attempt to use "@@ -329,30 +293,29 @@ static struct pageTableEntry \*\_vm\_get\_page\_table\_entry(struct kvm\_vm \*vm, int vc index[3] = (vaddr >> 39) & 0x1ffu;  pml4e = addr\_gpa2hva(vm, vm->pgd);- TEST\_ASSERT(pml4e[index[3]].present,+ TEST\_ASSERT(pml4e[index[3]] & PTE\_PRESENT\_MASK, "Expected pml4e to be present for gva: 0x%08lx", vaddr);- TEST\_ASSERT((\*(uint64\_t\*)(&pml4e[index[3]]) &- (rsvd\_mask | (1ull << 7))) == 0,+ TEST\_ASSERT((pml4e[index[3]] & (rsvd\_mask | PTE\_LARGE\_MASK)) == 0, "Unexpected reserved bits set."); - pdpe = addr\_gpa2hva(vm, pml4e[index[3]].pfn \* vm->page\_size);- TEST\_ASSERT(pdpe[index[2]].present,+ pdpe = addr\_gpa2hva(vm, PTE\_GET\_PFN(pml4e[index[3]]) \* vm->page\_size);+ TEST\_ASSERT(pdpe[index[2]] & PTE\_PRESENT\_MASK, "Expected pdpe to be present for gva: 0x%08lx", vaddr);- TEST\_ASSERT(pdpe[index[2]].page\_size == 0,+ TEST\_ASSERT(!(pdpe[index[2]] & PTE\_LARGE\_MASK), "Expected pdpe to map a pde not a 1-GByte page.");- TEST\_ASSERT((\*(uint64\_t\*)(&pdpe[index[2]]) & rsvd\_mask) == 0,+ TEST\_ASSERT((pdpe[index[2]] & rsvd\_mask) == 0, "Unexpected reserved bits set."); - pde = addr\_gpa2hva(vm, pdpe[index[2]].pfn \* vm->page\_size);- TEST\_ASSERT(pde[index[1]].present,+ pde = addr\_gpa2hva(vm, PTE\_GET\_PFN(pdpe[index[2]]) \* vm->page\_size);+ TEST\_ASSERT(pde[index[1]] & PTE\_PRESENT\_MASK, "Expected pde to be present for gva: 0x%08lx", vaddr);- TEST\_ASSERT(pde[index[1]].page\_size == 0,+ TEST\_ASSERT(!(pde[index[1]] & PTE\_LARGE\_MASK), "Expected pde to map a pte not a 2-MByte page.");- TEST\_ASSERT((\*(uint64\_t\*)(&pde[index[1]]) & rsvd\_mask) == 0,+ TEST\_ASSERT((pde[index[1]] & rsvd\_mask) == 0, "Unexpected reserved bits set."); - pte = addr\_gpa2hva(vm, pde[index[1]].pfn \* vm->page\_size);- TEST\_ASSERT(pte[index[0]].present,+ pte = addr\_gpa2hva(vm, PTE\_GET\_PFN(pde[index[1]]) \* vm->page\_size);+ TEST\_ASSERT(pte[index[0]] & PTE\_PRESENT\_MASK, "Expected pte to be present for gva: 0x%08lx", vaddr);  return &pte[index[0]];@@ -360,7 +323,7 @@ static struct pageTableEntry \*\_vm\_get\_page\_table\_entry(struct kvm\_vm \*vm, int vc  uint64\_t vm\_get\_page\_table\_entry(struct kvm\_vm \*vm, int vcpuid, uint64\_t vaddr) {- struct pageTableEntry \*pte = \_vm\_get\_page\_table\_entry(vm, vcpuid, vaddr);+ uint64\_t \*pte = \_vm\_get\_page\_table\_entry(vm, vcpuid, vaddr);  return \*(uint64\_t \*)pte; }@@ -368,18 +331,17 @@ uint64\_t vm\_get\_page\_table\_entry(struct kvm\_vm \*vm, int vcpuid, uint64\_t vaddr) void vm\_set\_page\_table\_entry(struct kvm\_vm \*vm, int vcpuid, uint64\_t vaddr, uint64\_t pte) {- struct pageTableEntry \*new\_pte = \_vm\_get\_page\_table\_entry(vm, vcpuid,- vaddr);+ uint64\_t \*new\_pte = \_vm\_get\_page\_table\_entry(vm, vcpuid, vaddr);  \*(uint64\_t \*)new\_pte = pte; }  void virt\_dump(FILE \*stream, struct kvm\_vm \*vm, uint8\_t indent) {- struct pageUpperEntry \*pml4e, \*pml4e\_start;- struct pageUpperEntry \*pdpe, \*pdpe\_start;- struct pageUpperEntry \*pde, \*pde\_start;- struct pageTableEntry \*pte, \*pte\_start;+ uint64\_t \*pml4e, \*pml4e\_start;+ uint64\_t \*pdpe, \*pdpe\_start;+ uint64\_t \*pde, \*pde\_start;+ uint64\_t \*pte, \*pte\_start;  if (!vm->pgd\_created) return;@@ -389,58 +351,58 @@ void virt\_dump(FILE \*stream, struct kvm\_vm \*vm, uint8\_t indent) fprintf(stream, "%\*s index hvaddr gpaddr " "addr w exec dirty\n", indent, "");- pml4e\_start = (struct pageUpperEntry \*) addr\_gpa2hva(vm, vm->pgd);+ pml4e\_start = (uint64\_t \*) addr\_gpa2hva(vm, vm->pgd); for (uint16\_t n1 = 0; n1 <= 0x1ffu; n1++) { pml4e = &pml4e\_start[n1];- if (!pml4e->present)+ if (!(\*pml4e & PTE\_PRESENT\_MASK)) continue;- fprintf(stream, "%\*spml4e 0x%-3zx %p 0x%-12lx 0x%-10lx %u "+ fprintf(stream, "%\*spml4e 0x%-3zx %p 0x%-12lx 0x%-10llx %u " " %u\n", indent, "", pml4e - pml4e\_start, pml4e,- addr\_hva2gpa(vm, pml4e), (uint64\_t) pml4e->pfn,- pml4e->writable, pml4e->execute\_disable);+ addr\_hva2gpa(vm, pml4e), PTE\_GET\_PFN(\*pml4e),+ !!(\*pml4e & PTE\_WRITABLE\_MASK), !!(\*pml4e & PTE\_NX\_MASK)); - pdpe\_start = addr\_gpa2hva(vm, pml4e->pfn \* vm->page\_size);+ pdpe\_start = addr\_gpa2hva(vm, \*pml4e & PHYSICAL\_PAGE\_MASK); for (uint16\_t n2 = 0; n2 <= 0x1ffu; n2++) { pdpe = &pdpe\_start[n2];- if (!pdpe->present)+ if (!(\*pdpe & PTE\_PRESENT\_MASK)) continue;- fprintf(stream, "%\*spdpe 0x%-3zx %p 0x%-12lx 0x%-10lx "+ fprintf(stream, "%\*spdpe 0x%-3zx %p 0x%-12lx 0x%-10llx " "%u %u\n", indent, "", pdpe - pdpe\_start, pdpe, addr\_hva2gpa(vm, pdpe),- (uint64\_t) pdpe->pfn, pdpe->writable,- pdpe->execute\_disable);+ PTE\_GET\_PFN(\*pdpe), !!(\*pdpe & PTE\_WRITABLE\_MASK),+ !!(\*pdpe & PTE\_NX\_MASK)); - pde\_start = addr\_gpa2hva(vm, pdpe->pfn \* vm->page\_size);+ pde\_start = addr\_gpa2hva(vm, \*pdpe & PHYSICAL\_PAGE\_MASK); for (uint16\_t n3 = 0; n3 <= 0x1ffu; n3++) { pde = &pde\_start[n3];- if (!pde->present)+ if (!(\*pde & PTE\_PRESENT\_MASK)) continue; fprintf(stream, "%\*spde 0x%-3zx %p "- "0x%-12lx 0x%-10lx %u %u\n",+ "0x%-12lx 0x%-10llx %u %u\n", indent, "", pde - pde\_start, pde, addr\_hva2gpa(vm, pde),- (uint64\_t) pde->pfn, pde->writable,- pde->execute\_disable);+ PTE\_GET\_PFN(\*pde), !!(\*pde & PTE\_WRITABLE\_MASK),+ !!(\*pde & PTE\_NX\_MASK)); - pte\_start = addr\_gpa2hva(vm, pde->pfn \* vm->page\_size);+ pte\_start = addr\_gpa2hva(vm, \*pde & PHYSICAL\_PAGE\_MASK); for (uint16\_t n4 = 0; n4 <= 0x1ffu; n4++) { pte = &pte\_start[n4];- if (!pte->present)+ if (!(\*pte & PTE\_PRESENT\_MASK)) continue; fprintf(stream, "%\*spte 0x%-3zx %p "- "0x%-12lx 0x%-10lx %u %u "+ "0x%-12lx 0x%-10llx %u %u " " %u 0x%-10lx\n", indent, "", pte - pte\_start, pte, addr\_hva2gpa(vm, pte),- (uint64\_t) pte->pfn,- pte->writable,- pte->execute\_disable,- pte->dirty,+ PTE\_GET\_PFN(\*pte),+ !!(\*pte & PTE\_WRITABLE\_MASK),+ !!(\*pte & PTE\_NX\_MASK),+ !!(\*pte & PTE\_DIRTY\_MASK), ((uint64\_t) n1 << 27) | ((uint64\_t) n2 << 18) | ((uint64\_t) n3 << 9)@@ -558,8 +520,8 @@ static void kvm\_seg\_set\_kernel\_data\_64bit(struct kvm\_vm \*vm, uint16\_t selector, vm\_paddr\_t addr\_gva2gpa(struct kvm\_vm \*vm, vm\_vaddr\_t gva) { uint16\_t index[4];- struct pageUpperEntry \*pml4e, \*pdpe, \*pde;- struct pageTableEntry \*pte;+ uint64\_t \*pml4e, \*pdpe, \*pde;+ uint64\_t \*pte;  TEST\_ASSERT(vm->mode == VM\_MODE\_PXXV48\_4K, "Attempt to use " "unknown or unsupported guest mode, mode: 0x%x", vm->mode);@@ -572,22 +534,22 @@ vm\_paddr\_t addr\_gva2gpa(struct kvm\_vm \*vm, vm\_vaddr\_t gva) if (!vm->pgd\_created) goto unmapped\_gva; pml4e = addr\_gpa2hva(vm, vm->pgd);- if (!pml4e[index[3]].present)+ if (!(pml4e[index[3]] & PTE\_PRESENT\_MASK)) goto unmapped\_gva; - pdpe = addr\_gpa2hva(vm, pml4e[index[3]].pfn \* vm->page\_size);- if (!pdpe[index[2]].present)+ pdpe = addr\_gpa2hva(vm, PTE\_GET\_PFN(pml4e[index[3]]) \* vm->page\_size);+ if (!(pdpe[index[2]] & PTE\_PRESENT\_MASK)) goto unmapped\_gva; - pde = addr\_gpa2hva(vm, pdpe[index[2]].pfn \* vm->page\_size);- if (!pde[index[1]].present)+ pde = addr\_gpa2hva(vm, PTE\_GET\_PFN(pdpe[index[2]]) \* vm->page\_size);+ if (!(pde[index[1]] & PTE\_PRESENT\_MASK)) goto unmapped\_gva; - pte = addr\_gpa2hva(vm, pde[index[1]].pfn \* vm->page\_size);- if (!pte[index[0]].present)+ pte = addr\_gpa2hva(vm, PTE\_GET\_PFN(pde[index[1]]) \* vm->page\_size);+ if (!(pte[index[0]] & PTE\_PRESENT\_MASK)) goto unmapped\_gva; - return (pte[index[0]].pfn \* vm->page\_size) + (gva & 0xfffu);+ return (PTE\_GET\_PFN(pte[index[0]]) \* vm->page\_size) + (gva & ~PAGE\_MASK);  unmapped\_gva: TEST\_FAIL("No mapping for vm virtual address, gva: 0x%lx", gva);diff --git a/tools/testing/selftests/kvm/x86\_64/amx\_test.c b/tools/testing/selftests/kvm/x86\_64/amx\_test.cindex 52a3ef6629e806..76f65c22796f2e 100644--- a/[tools/testing/selftests/kvm/x86\_64/amx\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/x86_64/amx_test.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[tools/testing/selftests/kvm/x86\_64/amx\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/x86_64/amx_test.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -29,7 +29,6 @@ #define X86\_FEATURE\_XSAVE (1 << 26) #define X86\_FEATURE\_OSXSAVE (1 << 27) -#define PAGE\_SIZE (1 << 12) #define NUM\_TILES 8 #define TILE\_SIZE 1024 #define XSAVE\_SIZE ((NUM\_TILES \* TILE\_SIZE) + PAGE\_SIZE)diff --git a/tools/testing/selftests/kvm/x86\_64/emulator\_error\_test.c b/tools/testing/selftests/kvm/x86\_64/emulator\_error\_test.cindex f070ff0224fa3f..aeb3850f81bd10 100644--- a/[tools/testing/selftests/kvm/x86\_64/emulator\_error\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/x86_64/emulator_error_test.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[tools/testing/selftests/kvm/x86\_64/emulator\_error\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/x86_64/emulator_error_test.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -12,7 +12,6 @@ #include "vmx.h"  #define VCPU\_ID 1-#define PAGE\_SIZE 4096 #define MAXPHYADDR 36  #define MEM\_REGION\_GVA 0x0000123456789000diff --git a/tools/testing/selftests/kvm/x86\_64/smm\_test.c b/tools/testing/selftests/kvm/x86\_64/smm\_test.cindex a626d40fdb4894..b4e0c860769e45 100644--- a/[tools/testing/selftests/kvm/x86\_64/smm\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/x86_64/smm_test.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[tools/testing/selftests/kvm/x86\_64/smm\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/x86_64/smm_test.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -21,8 +21,6 @@  #define VCPU\_ID 1 -#define PAGE\_SIZE 4096- #define SMRAM\_SIZE 65536 #define SMRAM\_MEMSLOT ((1 << 16) | 1) #define SMRAM\_PAGES (SMRAM\_SIZE / PAGE\_SIZE)diff --git a/tools/testing/selftests/kvm/x86\_64/vmx\_tsc\_adjust\_test.c b/tools/testing/selftests/kvm/x86\_64/vmx\_tsc\_adjust\_test.cindex e683d0ac3e45e1..19b35c607dc66c 100644--- a/[tools/testing/selftests/kvm/x86\_64/vmx\_tsc\_adjust\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/x86_64/vmx_tsc_adjust_test.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[tools/testing/selftests/kvm/x86\_64/vmx\_tsc\_adjust\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/x86_64/vmx_tsc_adjust_test.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -32,7 +32,6 @@ #define MSR\_IA32\_TSC\_ADJUST 0x3b #endif -#define PAGE\_SIZE 4096 #define VCPU\_ID 5  #define TSC\_ADJUST\_VALUE (1ll << 32)diff --git a/tools/testing/selftests/kvm/x86\_64/xen\_shinfo\_test.c b/tools/testing/selftests/kvm/x86\_64/xen\_shinfo\_test.cindex 865e17146815a6..bcd3708278593d 100644--- a/[tools/testing/selftests/kvm/x86\_64/xen\_shinfo\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/x86_64/xen_shinfo_test.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[tools/testing/selftests/kvm/x86\_64/xen\_shinfo\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/x86_64/xen_shinfo_test.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -23,7 +23,6 @@ #define SHINFO\_REGION\_GVA 0xc0000000ULL #define SHINFO\_REGION\_GPA 0xc0000000ULL #define SHINFO\_REGION\_SLOT 10-#define PAGE\_SIZE 4096  #define DUMMY\_REGION\_GPA (SHINFO\_REGION\_GPA + (2 \* PAGE\_SIZE)) #define DUMMY\_REGION\_SLOT 11diff --git a/tools/testing/selftests/kvm/x86\_64/xen\_vmcall\_test.c b/tools/testing/selftests/kvm/x86\_64/xen\_vmcall\_test.cindex adc94452b57c6c..b30fe9de1d4f6a 100644--- a/[tools/testing/selftests/kvm/x86\_64/xen\_vmcall\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/x86_64/xen_vmcall_test.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[tools/testing/selftests/kvm/x86\_64/xen\_vmcall\_test.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/kvm/x86_64/xen_vmcall_test.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -15,7 +15,6 @@  #define HCALL\_REGION\_GPA 0xc0000000ULL #define HCALL\_REGION\_SLOT 10-#define PAGE\_SIZE 4096  static struct kvm\_vm \*vm; diff --git a/virt/kvm/dirty\_ring.c b/virt/kvm/dirty\_ring.cindex 222ecc81d7df2d..f4c2a6eb1666b9 100644--- a/[virt/kvm/dirty\_ring.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/virt/kvm/dirty_ring.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[virt/kvm/dirty\_ring.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/virt/kvm/dirty_ring.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -1,4 +1,4 @@-/\* SPDX-License-Identifier: GPL-2.0-only \*/+// SPDX-License-Identifier: GPL-2.0-only /\* \* KVM dirty ring implementation \*diff --git a/virt/kvm/kvm\_main.c b/virt/kvm/kvm\_main.cindex dfb7dabdbc63de..f30bb8c16f2659 100644--- a/[virt/kvm/kvm\_main.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/virt/kvm/kvm_main.c?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[virt/kvm/kvm\_main.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/virt/kvm/kvm_main.c?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -164,6 +164,10 @@ \_\_weak void kvm\_arch\_mmu\_notifier\_invalidate\_range(struct kvm \*kvm, { } +\_\_weak void kvm\_arch\_guest\_memory\_reclaimed(struct kvm \*kvm)+{+}+ bool kvm\_is\_zone\_device\_pfn(kvm\_pfn\_t pfn) { /\*@@ -357,6 +361,12 @@ void kvm\_flush\_remote\_tlbs(struct kvm \*kvm) EXPORT\_SYMBOL\_GPL(kvm\_flush\_remote\_tlbs); #endif +static void kvm\_flush\_shadow\_all(struct kvm \*kvm)+{+ kvm\_arch\_flush\_shadow\_all(kvm);+ kvm\_arch\_guest\_memory\_reclaimed(kvm);+}+ #ifdef KVM\_ARCH\_NR\_OBJS\_PER\_MEMORY\_CACHE static inline void \*mmu\_memory\_cache\_alloc\_obj(struct kvm\_mmu\_memory\_cache \*mc, gfp\_t gfp\_flags)@@ -485,12 +495,15 @@ typedef bool (\*hva\_handler\_t)(struct kvm \*kvm, struct kvm\_gfn\_range \*range); typedef void (\*on\_lock\_fn\_t)(struct kvm \*kvm, unsigned long start, unsigned long end); +typedef void (\*on\_unlock\_fn\_t)(struct kvm \*kvm);+ struct kvm\_hva\_range { unsigned long start; unsigned long end; pte\_t pte; hva\_handler\_t handler; on\_lock\_fn\_t on\_lock;+ on\_unlock\_fn\_t on\_unlock; bool flush\_on\_ret; bool may\_block; };@@ -578,8 +591,11 @@ static \_\_always\_inline int \_\_kvm\_handle\_hva\_range(struct kvm \*kvm, if (range->flush\_on\_ret && ret) kvm\_flush\_remote\_tlbs(kvm); - if (locked)+ if (locked) { KVM\_MMU\_UNLOCK(kvm);+ if (!IS\_KVM\_NULL\_FN(range->on\_unlock))+ range->on\_unlock(kvm);+ }  srcu\_read\_unlock(&kvm->srcu, idx); @@ -600,6 +616,7 @@ static \_\_always\_inline int kvm\_handle\_hva\_range(struct mmu\_notifier \*mn, .pte = pte, .handler = handler, .on\_lock = (void \*)kvm\_null\_fn,+ .on\_unlock = (void \*)kvm\_null\_fn, .flush\_on\_ret = true, .may\_block = false, };@@ -619,6 +636,7 @@ static \_\_always\_inline int kvm\_handle\_hva\_range\_no\_flush(struct mmu\_notifier \*mn .pte = \_\_pte(0), .handler = handler, .on\_lock = (void \*)kvm\_null\_fn,+ .on\_unlock = (void \*)kvm\_null\_fn, .flush\_on\_ret = false, .may\_block = false, };@@ -662,7 +680,7 @@ void kvm\_inc\_notifier\_count(struct kvm \*kvm, unsigned long start, kvm->mmu\_notifier\_range\_end = end; } else { /\*- \* Fully tracking multiple concurrent ranges has dimishing+ \* Fully tracking multiple concurrent ranges has diminishing \* returns. Keep things simple and just find the minimal range \* which includes the current and new ranges. As there won't be \* enough information to subtract a range after its invalidate@@ -687,6 +705,7 @@ static int kvm\_mmu\_notifier\_invalidate\_range\_start(struct mmu\_notifier \*mn, .pte = \_\_pte(0), .handler = kvm\_unmap\_gfn\_range, .on\_lock = kvm\_inc\_notifier\_count,+ .on\_unlock = kvm\_arch\_guest\_memory\_reclaimed, .flush\_on\_ret = true, .may\_block = mmu\_notifier\_range\_blockable(range), };@@ -741,6 +760,7 @@ static void kvm\_mmu\_notifier\_invalidate\_range\_end(struct mmu\_notifier \*mn, .pte = \_\_pte(0), .handler = (void \*)kvm\_null\_fn, .on\_lock = kvm\_dec\_notifier\_count,+ .on\_unlock = (void \*)kvm\_null\_fn, .flush\_on\_ret = false, .may\_block = mmu\_notifier\_range\_blockable(range), };@@ -813,7 +833,7 @@ static void kvm\_mmu\_notifier\_release(struct mmu\_notifier \*mn, int idx;  idx = srcu\_read\_lock(&kvm->srcu);- kvm\_arch\_flush\_shadow\_all(kvm);+ kvm\_flush\_shadow\_all(kvm); srcu\_read\_unlock(&kvm->srcu, idx); } @@ -955,12 +975,6 @@ static int kvm\_create\_vm\_debugfs(struct kvm \*kvm, int fd) int kvm\_debugfs\_num\_entries = kvm\_vm\_stats\_header.num\_desc + kvm\_vcpu\_stats\_header.num\_desc; - /\*- \* Force subsequent debugfs file creations to fail if the VM directory- \* is not created.- \*/- kvm->debugfs\_dentry = ERR\_PTR(-ENOENT);- if (!debugfs\_initialized()) return 0; @@ -1081,6 +1095,12 @@ static struct kvm \*kvm\_create\_vm(unsigned long type)  BUILD\_BUG\_ON(KVM\_MEM\_SLOTS\_NUM > SHRT\_MAX); + /\*+ \* Force subsequent debugfs file creations to fail if the VM directory+ \* is not created (by kvm\_create\_vm\_debugfs()).+ \*/+ kvm->debugfs\_dentry = ERR\_PTR(-ENOENT);+ if (init\_srcu\_struct(&kvm->srcu)) goto out\_err\_no\_srcu; if (init\_srcu\_struct(&kvm->irq\_srcu))@@ -1225,7 +1245,7 @@ static void kvm\_destroy\_vm(struct kvm \*kvm) WARN\_ON(rcuwait\_active(&kvm->mn\_memslots\_update\_rcuwait)); kvm->mn\_active\_invalidate\_count = 0; #else- kvm\_arch\_flush\_shadow\_all(kvm);+ kvm\_flush\_shadow\_all(kvm); #endif kvm\_arch\_destroy\_vm(kvm); kvm\_destroy\_devices(kvm);@@ -1652,6 +1672,7 @@ static void kvm\_invalidate\_memslot(struct kvm \*kvm, \* - kvm\_is\_visible\_gfn (mmu\_check\_root) \*/ kvm\_arch\_flush\_shadow\_memslot(kvm, old);+ kvm\_arch\_guest\_memory\_reclaimed(kvm);  /\* Was released by kvm\_swap\_active\_memslots, reacquire. \*/ mutex\_lock(&kvm->slots\_arch\_lock);@@ -1799,7 +1820,7 @@ static int kvm\_set\_memslot(struct kvm \*kvm,  /\* \* No need to refresh new->arch, changes after dropping slots\_arch\_lock- \* will directly hit the final, active memsot. Architectures are+ \* will directly hit the final, active memslot. Architectures are \* responsible for knowing that new->arch may be stale. \*/ kvm\_commit\_memory\_region(kvm, old, new, change);diff --git a/virt/kvm/kvm\_mm.h b/virt/kvm/kvm\_mm.hindex 34ca40823260da..41da467d99c95e 100644--- a/[virt/kvm/kvm\_mm.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/virt/kvm/kvm_mm.h?id=06fb4ecfeac7e00d6704fa5ed19299f2fefb3cc9)+++ b/[virt/kvm/kvm\_mm.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/virt/kvm/kvm_mm.h?id=bb4ce2c65881a2b9bdcd384f54a260a12a89dd91)@@ -1,4 +1,4 @@-// SPDX-License-Identifier: GPL-2.0-only+/\* SPDX-License-Identifier: GPL-2.0-only \*/  #ifndef \_\_KVM\_MM\_H\_\_ #define \_\_KVM\_MM\_H\_\_ 1 |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-08 15:11:23 +0000

