

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=cb734975b0ffa688ff6cc0eed463865bf07b6c01)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=cb734975b0ffa688ff6cc0eed463865bf07b6c01)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=cb734975b0ffa688ff6cc0eed463865bf07b6c01)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=cb734975b0ffa688ff6cc0eed463865bf07b6c01)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Florian Westphal <fw@strlen.de> | 2024-02-27 16:17:51 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-03-06 14:53:51 +0000 |
| commit | [cb734975b0ffa688ff6cc0eed463865bf07b6c01](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=cb734975b0ffa688ff6cc0eed463865bf07b6c01) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=cb734975b0ffa688ff6cc0eed463865bf07b6c01)) | |
| tree | [59f7e72bbaa67f9c5000c496cb6ecf5a3b4feb74](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=cb734975b0ffa688ff6cc0eed463865bf07b6c01) | |
| parent | [779b10b29f45939b61b72ec2fae470696d2eac1f](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=779b10b29f45939b61b72ec2fae470696d2eac1f) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=cb734975b0ffa688ff6cc0eed463865bf07b6c01&id2=779b10b29f45939b61b72ec2fae470696d2eac1f)) | |
| download | [linux-cb734975b0ffa688ff6cc0eed463865bf07b6c01.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-cb734975b0ffa688ff6cc0eed463865bf07b6c01.tar.gz) | |

netfilter: bridge: confirm multicast packets before passing them up the stack[ Upstream commit 62e7151ae3eb465e0ab52a20c941ff33bb6332e9 ]
conntrack nf\_confirm logic cannot handle cloned skbs referencing
the same nf\_conn entry, which will happen for multicast (broadcast)
frames on bridges.
Example:
macvlan0
|
br0
/ \
ethX ethY
ethX (or Y) receives a L2 multicast or broadcast packet containing
an IP packet, flow is not yet in conntrack table.
1. skb passes through bridge and fake-ip (br\_netfilter)Prerouting.
-> skb->\_nfct now references a unconfirmed entry
2. skb is broad/mcast packet. bridge now passes clones out on each bridge
interface.
3. skb gets passed up the stack.
4. In macvlan case, macvlan driver retains clone(s) of the mcast skb
and schedules a work queue to send them out on the lower devices.
The clone skb->\_nfct is not a copy, it is the same entry as the
original skb. The macvlan rx handler then returns RX\_HANDLER\_PASS.
5. Normal conntrack hooks (in NF\_INET\_LOCAL\_IN) confirm the orig skb.
The Macvlan broadcast worker and normal confirm path will race.
This race will not happen if step 2 already confirmed a clone. In that
case later steps perform skb\_clone() with skb->\_nfct already confirmed (in
hash table). This works fine.
But such confirmation won't happen when eb/ip/nftables rules dropped the
packets before they reached the nf\_confirm step in postrouting.
Pablo points out that nf\_conntrack\_bridge doesn't allow use of stateful
nat, so we can safely discard the nf\_conn entry and let inet call
conntrack again.
This doesn't work for bridge netfilter: skb could have a nat
transformation. Also bridge nf prevents re-invocation of inet prerouting
via 'sabotage\_in' hook.
Work around this problem by explicit confirmation of the entry at LOCAL\_IN
time, before upper layer has a chance to clone the unconfirmed entry.
The downside is that this disables NAT and conntrack helpers.
Alternative fix would be to add locking to all code parts that deal with
unconfirmed packets, but even if that could be done in a sane way this
opens up other problems, for example:
-m physdev --physdev-out eth0 -j SNAT --snat-to 1.2.3.4
-m physdev --physdev-out eth1 -j SNAT --snat-to 1.2.3.5
For multicast case, only one of such conflicting mappings will be
created, conntrack only handles 1:1 NAT mappings.
Users should set create a setup that explicitly marks such traffic
NOTRACK (conntrack bypass) to avoid this, but we cannot auto-bypass
them, ruleset might have accept rules for untracked traffic already,
so user-visible behaviour would change.
Suggested-by: Pablo Neira Ayuso <pablo@netfilter.org>
Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
Closes: https://bugzilla.kernel.org/show\_bug.cgi?id=217777
Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=cb734975b0ffa688ff6cc0eed463865bf07b6c01)

| -rw-r--r-- | [include/linux/netfilter.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/netfilter.h?id=cb734975b0ffa688ff6cc0eed463865bf07b6c01) | 1 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/bridge/br\_netfilter\_hooks.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/bridge/br_netfilter_hooks.c?id=cb734975b0ffa688ff6cc0eed463865bf07b6c01) | 96 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/bridge/netfilter/nf\_conntrack\_bridge.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/bridge/netfilter/nf_conntrack_bridge.c?id=cb734975b0ffa688ff6cc0eed463865bf07b6c01) | 30 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/netfilter/nf\_conntrack\_core.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nf_conntrack_core.c?id=cb734975b0ffa688ff6cc0eed463865bf07b6c01) | 1 | |  |  |  | | --- | --- | --- | |

4 files changed, 128 insertions, 0 deletions

| diff --git a/include/linux/netfilter.h b/include/linux/netfilter.hindex 80900d9109920f..ce660d51549b46 100644--- a/[include/linux/netfilter.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/netfilter.h?id=779b10b29f45939b61b72ec2fae470696d2eac1f)+++ b/[include/linux/netfilter.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/netfilter.h?id=cb734975b0ffa688ff6cc0eed463865bf07b6c01)@@ -474,6 +474,7 @@ struct nf\_ct\_hook { const struct sk\_buff \*); void (\*attach)(struct sk\_buff \*nskb, const struct sk\_buff \*skb); void (\*set\_closing)(struct nf\_conntrack \*nfct);+ int (\*confirm)(struct sk\_buff \*skb); }; extern const struct nf\_ct\_hook \_\_rcu \*nf\_ct\_hook; diff --git a/net/bridge/br\_netfilter\_hooks.c b/net/bridge/br\_netfilter\_hooks.cindex ed17208907578a..35e10c5a766d55 100644--- a/[net/bridge/br\_netfilter\_hooks.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/bridge/br_netfilter_hooks.c?id=779b10b29f45939b61b72ec2fae470696d2eac1f)+++ b/[net/bridge/br\_netfilter\_hooks.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/bridge/br_netfilter_hooks.c?id=cb734975b0ffa688ff6cc0eed463865bf07b6c01)@@ -43,6 +43,10 @@ #include <linux/sysctl.h> #endif +#if IS\_ENABLED(CONFIG\_NF\_CONNTRACK)+#include <net/netfilter/nf\_conntrack\_core.h>+#endif+ static unsigned int brnf\_net\_id \_\_read\_mostly;  struct brnf\_net {@@ -553,6 +557,90 @@ static unsigned int br\_nf\_pre\_routing(void \*priv, return NF\_STOLEN; } +#if IS\_ENABLED(CONFIG\_NF\_CONNTRACK)+/\* conntracks' nf\_confirm logic cannot handle cloned skbs referencing+ \* the same nf\_conn entry, which will happen for multicast (broadcast)+ \* Frames on bridges.+ \*+ \* Example:+ \* macvlan0+ \* br0+ \* ethX ethY+ \*+ \* ethX (or Y) receives multicast or broadcast packet containing+ \* an IP packet, not yet in conntrack table.+ \*+ \* 1. skb passes through bridge and fake-ip (br\_netfilter)Prerouting.+ \* -> skb->\_nfct now references a unconfirmed entry+ \* 2. skb is broad/mcast packet. bridge now passes clones out on each bridge+ \* interface.+ \* 3. skb gets passed up the stack.+ \* 4. In macvlan case, macvlan driver retains clone(s) of the mcast skb+ \* and schedules a work queue to send them out on the lower devices.+ \*+ \* The clone skb->\_nfct is not a copy, it is the same entry as the+ \* original skb. The macvlan rx handler then returns RX\_HANDLER\_PASS.+ \* 5. Normal conntrack hooks (in NF\_INET\_LOCAL\_IN) confirm the orig skb.+ \*+ \* The Macvlan broadcast worker and normal confirm path will race.+ \*+ \* This race will not happen if step 2 already confirmed a clone. In that+ \* case later steps perform skb\_clone() with skb->\_nfct already confirmed (in+ \* hash table). This works fine.+ \*+ \* But such confirmation won't happen when eb/ip/nftables rules dropped the+ \* packets before they reached the nf\_confirm step in postrouting.+ \*+ \* Work around this problem by explicit confirmation of the entry at+ \* LOCAL\_IN time, before upper layer has a chance to clone the unconfirmed+ \* entry.+ \*+ \*/+static unsigned int br\_nf\_local\_in(void \*priv,+ struct sk\_buff \*skb,+ const struct nf\_hook\_state \*state)+{+ struct nf\_conntrack \*nfct = skb\_nfct(skb);+ const struct nf\_ct\_hook \*ct\_hook;+ struct nf\_conn \*ct;+ int ret;++ if (!nfct || skb->pkt\_type == PACKET\_HOST)+ return NF\_ACCEPT;++ ct = container\_of(nfct, struct nf\_conn, ct\_general);+ if (likely(nf\_ct\_is\_confirmed(ct)))+ return NF\_ACCEPT;++ WARN\_ON\_ONCE(skb\_shared(skb));+ WARN\_ON\_ONCE(refcount\_read(&nfct->use) != 1);++ /\* We can't call nf\_confirm here, it would create a dependency+ \* on nf\_conntrack module.+ \*/+ ct\_hook = rcu\_dereference(nf\_ct\_hook);+ if (!ct\_hook) {+ skb->\_nfct = 0ul;+ nf\_conntrack\_put(nfct);+ return NF\_ACCEPT;+ }++ nf\_bridge\_pull\_encap\_header(skb);+ ret = ct\_hook->confirm(skb);+ switch (ret & NF\_VERDICT\_MASK) {+ case NF\_STOLEN:+ return NF\_STOLEN;+ default:+ nf\_bridge\_push\_encap\_header(skb);+ break;+ }++ ct = container\_of(nfct, struct nf\_conn, ct\_general);+ WARN\_ON\_ONCE(!nf\_ct\_is\_confirmed(ct));++ return ret;+}+#endif  /\* PF\_BRIDGE/FORWARD \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/ static int br\_nf\_forward\_finish(struct net \*net, struct sock \*sk, struct sk\_buff \*skb)@@ -964,6 +1052,14 @@ static const struct nf\_hook\_ops br\_nf\_ops[] = { .hooknum = NF\_BR\_PRE\_ROUTING, .priority = NF\_BR\_PRI\_BRNF, },+#if IS\_ENABLED(CONFIG\_NF\_CONNTRACK)+ {+ .hook = br\_nf\_local\_in,+ .pf = NFPROTO\_BRIDGE,+ .hooknum = NF\_BR\_LOCAL\_IN,+ .priority = NF\_BR\_PRI\_LAST,+ },+#endif { .hook = br\_nf\_forward, .pf = NFPROTO\_BRIDGE,diff --git a/net/bridge/netfilter/nf\_conntrack\_bridge.c b/net/bridge/netfilter/nf\_conntrack\_bridge.cindex abb090f94ed260..6f877e31709bad 100644--- a/[net/bridge/netfilter/nf\_conntrack\_bridge.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/bridge/netfilter/nf_conntrack_bridge.c?id=779b10b29f45939b61b72ec2fae470696d2eac1f)+++ b/[net/bridge/netfilter/nf\_conntrack\_bridge.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/bridge/netfilter/nf_conntrack_bridge.c?id=cb734975b0ffa688ff6cc0eed463865bf07b6c01)@@ -291,6 +291,30 @@ static unsigned int nf\_ct\_bridge\_pre(void \*priv, struct sk\_buff \*skb, return nf\_conntrack\_in(skb, &bridge\_state); } +static unsigned int nf\_ct\_bridge\_in(void \*priv, struct sk\_buff \*skb,+ const struct nf\_hook\_state \*state)+{+ enum ip\_conntrack\_info ctinfo;+ struct nf\_conn \*ct;++ if (skb->pkt\_type == PACKET\_HOST)+ return NF\_ACCEPT;++ /\* nf\_conntrack\_confirm() cannot handle concurrent clones,+ \* this happens for broad/multicast frames with e.g. macvlan on top+ \* of the bridge device.+ \*/+ ct = nf\_ct\_get(skb, &ctinfo);+ if (!ct || nf\_ct\_is\_confirmed(ct) || nf\_ct\_is\_template(ct))+ return NF\_ACCEPT;++ /\* let inet prerouting call conntrack again \*/+ skb->\_nfct = 0;+ nf\_ct\_put(ct);++ return NF\_ACCEPT;+}+ static void nf\_ct\_bridge\_frag\_save(struct sk\_buff \*skb, struct nf\_bridge\_frag\_data \*data) {@@ -386,6 +410,12 @@ static struct nf\_hook\_ops nf\_ct\_bridge\_hook\_ops[] \_\_read\_mostly = { .priority = NF\_IP\_PRI\_CONNTRACK, }, {+ .hook = nf\_ct\_bridge\_in,+ .pf = NFPROTO\_BRIDGE,+ .hooknum = NF\_BR\_LOCAL\_IN,+ .priority = NF\_IP\_PRI\_CONNTRACK\_CONFIRM,+ },+ { .hook = nf\_ct\_bridge\_post, .pf = NFPROTO\_BRIDGE, .hooknum = NF\_BR\_POST\_ROUTING,diff --git a/net/netfilter/nf\_conntrack\_core.c b/net/netfilter/nf\_conntrack\_core.cindex 2e5f3864d353a3..5b876fa7f9af9e 100644--- a/[net/netfilter/nf\_conntrack\_core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nf_conntrack_core.c?id=779b10b29f45939b61b72ec2fae470696d2eac1f)+++ b/[net/netfilter/nf\_conntrack\_core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nf_conntrack_core.c?id=cb734975b0ffa688ff6cc0eed463865bf07b6c01)@@ -2756,6 +2756,7 @@ static const struct nf\_ct\_hook nf\_conntrack\_hook = { .get\_tuple\_skb = nf\_conntrack\_get\_tuple\_skb, .attach = nf\_conntrack\_attach, .set\_closing = nf\_conntrack\_set\_closing,+ .confirm = \_\_nf\_conntrack\_confirm, };  void nf\_conntrack\_init\_end(void) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 12:56:21 +0000

