

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=a8dd0cfa37792863b6c4bf9542975212a6715d49)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a8dd0cfa37792863b6c4bf9542975212a6715d49)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a8dd0cfa37792863b6c4bf9542975212a6715d49)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a8dd0cfa37792863b6c4bf9542975212a6715d49)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Yang Shi <shy828301@gmail.com> | 2022-02-11 16:32:26 -0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2022-02-23 12:03:02 +0100 |
| commit | [a8dd0cfa37792863b6c4bf9542975212a6715d49](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a8dd0cfa37792863b6c4bf9542975212a6715d49) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=a8dd0cfa37792863b6c4bf9542975212a6715d49)) | |
| tree | [c0174a85f572ce65dc227d17e0a649a5b2dba4bb](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a8dd0cfa37792863b6c4bf9542975212a6715d49) | |
| parent | [f0a60c7c4edee3f108ec435d457149175d0b0afa](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f0a60c7c4edee3f108ec435d457149175d0b0afa) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a8dd0cfa37792863b6c4bf9542975212a6715d49&id2=f0a60c7c4edee3f108ec435d457149175d0b0afa)) | |
| download | [linux-a8dd0cfa37792863b6c4bf9542975212a6715d49.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-a8dd0cfa37792863b6c4bf9542975212a6715d49.tar.gz) | |

fs/proc: task\_mmu.c: don't read mapcount for migration entrycommit 24d7275ce2791829953ed4e72f68277ceb2571c6 upstream.
The syzbot reported the below BUG:
kernel BUG at include/linux/page-flags.h:785!
invalid opcode: 0000 [#1] PREEMPT SMP KASAN
CPU: 1 PID: 4392 Comm: syz-executor560 Not tainted 5.16.0-rc6-syzkaller #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
RIP: 0010:PageDoubleMap include/linux/page-flags.h:785 [inline]
RIP: 0010:\_\_page\_mapcount+0x2d2/0x350 mm/util.c:744
Call Trace:
page\_mapcount include/linux/mm.h:837 [inline]
smaps\_account+0x470/0xb10 fs/proc/task\_mmu.c:466
smaps\_pte\_entry fs/proc/task\_mmu.c:538 [inline]
smaps\_pte\_range+0x611/0x1250 fs/proc/task\_mmu.c:601
walk\_pmd\_range mm/pagewalk.c:128 [inline]
walk\_pud\_range mm/pagewalk.c:205 [inline]
walk\_p4d\_range mm/pagewalk.c:240 [inline]
walk\_pgd\_range mm/pagewalk.c:277 [inline]
\_\_walk\_page\_range+0xe23/0x1ea0 mm/pagewalk.c:379
walk\_page\_vma+0x277/0x350 mm/pagewalk.c:530
smap\_gather\_stats.part.0+0x148/0x260 fs/proc/task\_mmu.c:768
smap\_gather\_stats fs/proc/task\_mmu.c:741 [inline]
show\_smap+0xc6/0x440 fs/proc/task\_mmu.c:822
seq\_read\_iter+0xbb0/0x1240 fs/seq\_file.c:272
seq\_read+0x3e0/0x5b0 fs/seq\_file.c:162
vfs\_read+0x1b5/0x600 fs/read\_write.c:479
ksys\_read+0x12d/0x250 fs/read\_write.c:619
do\_syscall\_x64 arch/x86/entry/common.c:50 [inline]
do\_syscall\_64+0x35/0xb0 arch/x86/entry/common.c:80
entry\_SYSCALL\_64\_after\_hwframe+0x44/0xae
The reproducer was trying to read /proc/$PID/smaps when calling
MADV\_FREE at the mean time. MADV\_FREE may split THPs if it is called
for partial THP. It may trigger the below race:
CPU A CPU B
----- -----
smaps walk: MADV\_FREE:
page\_mapcount()
PageCompound()
split\_huge\_page()
page = compound\_head(page)
PageDoubleMap(page)
When calling PageDoubleMap() this page is not a tail page of THP anymore
so the BUG is triggered.
This could be fixed by elevated refcount of the page before calling
mapcount, but that would prevent it from counting migration entries, and
it seems overkilling because the race just could happen when PMD is
split so all PTE entries of tail pages are actually migration entries,
and smaps\_account() does treat migration entries as mapcount == 1 as
Kirill pointed out.
Add a new parameter for smaps\_account() to tell this entry is migration
entry then skip calling page\_mapcount(). Don't skip getting mapcount
for device private entries since they do track references with mapcount.
Pagemap also has the similar issue although it was not reported. Fixed
it as well.
[shy828301@gmail.com: v4]
Link: https://lkml.kernel.org/r/20220203182641.824731-1-shy828301@gmail.com
[nathan@kernel.org: avoid unused variable warning in pagemap\_pmd\_range()]
Link: https://lkml.kernel.org/r/20220207171049.1102239-1-nathan@kernel.org
Link: [https://lkml.kernel.org/r/20220120202805.3369-1-shy828301@gmail.com](https://lkml.kernel.org/r/20220120202805.3369-1-shy828301%40gmail.com)
Fixes: e9b61f19858a ("thp: reintroduce split\_huge\_page()")
Signed-off-by: Yang Shi <shy828301@gmail.com>
Signed-off-by: Nathan Chancellor <nathan@kernel.org>
Reported-by: syzbot+1f52b3a18d5633fa7f82@syzkaller.appspotmail.com
Acked-by: David Hildenbrand <david@redhat.com>
Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
Cc: Jann Horn <jannh@google.com>
Cc: Matthew Wilcox <willy@infradead.org>
Cc: Alexey Dobriyan <adobriyan@gmail.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a8dd0cfa37792863b6c4bf9542975212a6715d49)

| -rw-r--r-- | [fs/proc/task\_mmu.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/proc/task_mmu.c?id=a8dd0cfa37792863b6c4bf9542975212a6715d49) | 40 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 31 insertions, 9 deletions

| diff --git a/fs/proc/task\_mmu.c b/fs/proc/task\_mmu.cindex cf25be3e032120..958fce7aee6357 100644--- a/[fs/proc/task\_mmu.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/proc/task_mmu.c?id=f0a60c7c4edee3f108ec435d457149175d0b0afa)+++ b/[fs/proc/task\_mmu.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/proc/task_mmu.c?id=a8dd0cfa37792863b6c4bf9542975212a6715d49)@@ -430,7 +430,8 @@ static void smaps\_page\_accumulate(struct mem\_size\_stats \*mss, }  static void smaps\_account(struct mem\_size\_stats \*mss, struct page \*page,- bool compound, bool young, bool dirty, bool locked)+ bool compound, bool young, bool dirty, bool locked,+ bool migration) { int i, nr = compound ? compound\_nr(page) : 1; unsigned long size = nr \* PAGE\_SIZE;@@ -457,8 +458,15 @@ static void smaps\_account(struct mem\_size\_stats \*mss, struct page \*page, \* page\_count(page) == 1 guarantees the page is mapped exactly once. \* If any subpage of the compound page mapped with PTE it would elevate \* page\_count().+ \*+ \* The page\_mapcount() is called to get a snapshot of the mapcount.+ \* Without holding the page lock this snapshot can be slightly wrong as+ \* we cannot always read the mapcount atomically. It is not safe to+ \* call page\_mapcount() even with PTL held if the page is not mapped,+ \* especially for migration entries. Treat regular migration entries+ \* as mapcount == 1. \*/- if (page\_count(page) == 1) {+ if ((page\_count(page) == 1) || migration) { smaps\_page\_accumulate(mss, page, size, size << PSS\_SHIFT, dirty, locked, true); return;@@ -495,6 +503,7 @@ static void smaps\_pte\_entry(pte\_t \*pte, unsigned long addr, struct vm\_area\_struct \*vma = walk->vma; bool locked = !!(vma->vm\_flags & VM\_LOCKED); struct page \*page = NULL;+ bool migration = false;  if (pte\_present(\*pte)) { page = vm\_normal\_page(vma, addr, \*pte);@@ -514,8 +523,11 @@ static void smaps\_pte\_entry(pte\_t \*pte, unsigned long addr, } else { mss->swap\_pss += (u64)PAGE\_SIZE << PSS\_SHIFT; }- } else if (is\_pfn\_swap\_entry(swpent))+ } else if (is\_pfn\_swap\_entry(swpent)) {+ if (is\_migration\_entry(swpent))+ migration = true; page = pfn\_swap\_entry\_to\_page(swpent);+ } } else if (unlikely(IS\_ENABLED(CONFIG\_SHMEM) && mss->check\_shmem\_swap && pte\_none(\*pte))) { page = xa\_load(&vma->vm\_file->f\_mapping->i\_pages,@@ -528,7 +540,8 @@ static void smaps\_pte\_entry(pte\_t \*pte, unsigned long addr, if (!page) return; - smaps\_account(mss, page, false, pte\_young(\*pte), pte\_dirty(\*pte), locked);+ smaps\_account(mss, page, false, pte\_young(\*pte), pte\_dirty(\*pte),+ locked, migration); }  #ifdef CONFIG\_TRANSPARENT\_HUGEPAGE@@ -539,6 +552,7 @@ static void smaps\_pmd\_entry(pmd\_t \*pmd, unsigned long addr, struct vm\_area\_struct \*vma = walk->vma; bool locked = !!(vma->vm\_flags & VM\_LOCKED); struct page \*page = NULL;+ bool migration = false;  if (pmd\_present(\*pmd)) { /\* FOLL\_DUMP will return -EFAULT on huge zero page \*/@@ -546,8 +560,10 @@ static void smaps\_pmd\_entry(pmd\_t \*pmd, unsigned long addr, } else if (unlikely(thp\_migration\_supported() && is\_swap\_pmd(\*pmd))) { swp\_entry\_t entry = pmd\_to\_swp\_entry(\*pmd); - if (is\_migration\_entry(entry))+ if (is\_migration\_entry(entry)) {+ migration = true; page = pfn\_swap\_entry\_to\_page(entry);+ } } if (IS\_ERR\_OR\_NULL(page)) return;@@ -559,7 +575,9 @@ static void smaps\_pmd\_entry(pmd\_t \*pmd, unsigned long addr, /\* pass \*/; else mss->file\_thp += HPAGE\_PMD\_SIZE;- smaps\_account(mss, page, true, pmd\_young(\*pmd), pmd\_dirty(\*pmd), locked);++ smaps\_account(mss, page, true, pmd\_young(\*pmd), pmd\_dirty(\*pmd),+ locked, migration); } #else static void smaps\_pmd\_entry(pmd\_t \*pmd, unsigned long addr,@@ -1363,6 +1381,7 @@ static pagemap\_entry\_t pte\_to\_pagemap\_entry(struct pagemapread \*pm, { u64 frame = 0, flags = 0; struct page \*page = NULL;+ bool migration = false;  if (pte\_present(pte)) { if (pm->show\_pfn)@@ -1384,13 +1403,14 @@ static pagemap\_entry\_t pte\_to\_pagemap\_entry(struct pagemapread \*pm, frame = swp\_type(entry) | (swp\_offset(entry) << MAX\_SWAPFILES\_SHIFT); flags |= PM\_SWAP;+ migration = is\_migration\_entry(entry); if (is\_pfn\_swap\_entry(entry)) page = pfn\_swap\_entry\_to\_page(entry); }  if (page && !PageAnon(page)) flags |= PM\_FILE;- if (page && page\_mapcount(page) == 1)+ if (page && !migration && page\_mapcount(page) == 1) flags |= PM\_MMAP\_EXCLUSIVE; if (vma->vm\_flags & VM\_SOFTDIRTY) flags |= PM\_SOFT\_DIRTY;@@ -1406,8 +1426,9 @@ static int pagemap\_pmd\_range(pmd\_t \*pmdp, unsigned long addr, unsigned long end, spinlock\_t \*ptl; pte\_t \*pte, \*orig\_pte; int err = 0;- #ifdef CONFIG\_TRANSPARENT\_HUGEPAGE+ bool migration = false;+ ptl = pmd\_trans\_huge\_lock(pmdp, vma); if (ptl) { u64 flags = 0, frame = 0;@@ -1446,11 +1467,12 @@ static int pagemap\_pmd\_range(pmd\_t \*pmdp, unsigned long addr, unsigned long end, if (pmd\_swp\_uffd\_wp(pmd)) flags |= PM\_UFFD\_WP; VM\_BUG\_ON(!is\_pmd\_migration\_entry(pmd));+ migration = is\_migration\_entry(entry); page = pfn\_swap\_entry\_to\_page(entry); } #endif - if (page && page\_mapcount(page) == 1)+ if (page && !migration && page\_mapcount(page) == 1) flags |= PM\_MMAP\_EXCLUSIVE;  for (; addr != end; addr += PAGE\_SIZE) { |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 07:58:06 +0000

