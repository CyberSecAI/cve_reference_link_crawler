

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=439fc1e569c57669dbb842d0a77c7ba0a82a9f5d)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=439fc1e569c57669dbb842d0a77c7ba0a82a9f5d)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=439fc1e569c57669dbb842d0a77c7ba0a82a9f5d)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=439fc1e569c57669dbb842d0a77c7ba0a82a9f5d)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Matthew Brost <matthew.brost@intel.com> | 2024-08-15 20:40:33 -0700 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-10-04 16:37:46 +0200 |
| commit | [439fc1e569c57669dbb842d0a77c7ba0a82a9f5d](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=439fc1e569c57669dbb842d0a77c7ba0a82a9f5d) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=439fc1e569c57669dbb842d0a77c7ba0a82a9f5d)) | |
| tree | [3d7b4dbeae9e2576da50bfc0dd8d2eb5382a7fc9](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=439fc1e569c57669dbb842d0a77c7ba0a82a9f5d) | |
| parent | [ab12bbe9233d91263151c95876539c9457bc45de](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ab12bbe9233d91263151c95876539c9457bc45de) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=439fc1e569c57669dbb842d0a77c7ba0a82a9f5d&id2=ab12bbe9233d91263151c95876539c9457bc45de)) | |
| download | [linux-439fc1e569c57669dbb842d0a77c7ba0a82a9f5d.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-439fc1e569c57669dbb842d0a77c7ba0a82a9f5d.tar.gz) | |

drm/xe: Use reserved copy engine for user binds on faulting devices[ Upstream commit 852856e3b6f679c694dd5ec41e5a3c11aa46640b ]
User binds map to engines with can fault, faults depend on user binds
completion, thus we can deadlock. Avoid this by using reserved copy
engine for user binds on faulting devices.
While we are here, normalize bind queue creation with a helper.
v2:
- Pass in extensions to bind queue creation (CI)
v3:
- s/resevered/reserved (Lucas)
- Fix NULL hwe check (Jonathan)
Fixes: dd08ebf6c352 ("drm/xe: Introduce a new DRM driver for Intel GPUs")
Cc: Thomas Hellstr√∂m <thomas.hellstrom@linux.intel.com>
Signed-off-by: Matthew Brost <matthew.brost@intel.com>
Reviewed-by: Jonathan Cavitt <jonathan.cavitt@intel.com>
Link: [https://patchwork.freedesktop.org/patch/msgid/20240816034033.53837-1-matthew.brost@intel.com](https://patchwork.freedesktop.org/patch/msgid/20240816034033.53837-1-matthew.brost%40intel.com)
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=439fc1e569c57669dbb842d0a77c7ba0a82a9f5d)

| -rw-r--r-- | [drivers/gpu/drm/xe/xe\_exec\_queue.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/gpu/drm/xe/xe_exec_queue.c?id=439fc1e569c57669dbb842d0a77c7ba0a82a9f5d) | 122 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/gpu/drm/xe/xe\_exec\_queue.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/gpu/drm/xe/xe_exec_queue.h?id=439fc1e569c57669dbb842d0a77c7ba0a82a9f5d) | 6 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/gpu/drm/xe/xe\_migrate.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/gpu/drm/xe/xe_migrate.c?id=439fc1e569c57669dbb842d0a77c7ba0a82a9f5d) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/gpu/drm/xe/xe\_vm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/gpu/drm/xe/xe_vm.c?id=439fc1e569c57669dbb842d0a77c7ba0a82a9f5d) | 8 | |  |  |  | | --- | --- | --- | |

4 files changed, 70 insertions, 68 deletions

| diff --git a/drivers/gpu/drm/xe/xe\_exec\_queue.c b/drivers/gpu/drm/xe/xe\_exec\_queue.cindex ddc22a8d9bf5fa..c2953ddbd16e13 100644--- a/[drivers/gpu/drm/xe/xe\_exec\_queue.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/gpu/drm/xe/xe_exec_queue.c?id=ab12bbe9233d91263151c95876539c9457bc45de)+++ b/[drivers/gpu/drm/xe/xe\_exec\_queue.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/gpu/drm/xe/xe_exec_queue.c?id=439fc1e569c57669dbb842d0a77c7ba0a82a9f5d)@@ -166,7 +166,8 @@ err\_post\_alloc:  struct xe\_exec\_queue \*xe\_exec\_queue\_create\_class(struct xe\_device \*xe, struct xe\_gt \*gt, struct xe\_vm \*vm,- enum xe\_engine\_class class, u32 flags)+ enum xe\_engine\_class class,+ u32 flags, u64 extensions) { struct xe\_hw\_engine \*hwe, \*hwe0 = NULL; enum xe\_hw\_engine\_id id;@@ -186,7 +187,54 @@ struct xe\_exec\_queue \*xe\_exec\_queue\_create\_class(struct xe\_device \*xe, struct xe if (!logical\_mask) return ERR\_PTR(-ENODEV); - return xe\_exec\_queue\_create(xe, vm, logical\_mask, 1, hwe0, flags, 0);+ return xe\_exec\_queue\_create(xe, vm, logical\_mask, 1, hwe0, flags, extensions);+}++/\*\*+ \* xe\_exec\_queue\_create\_bind() - Create bind exec queue.+ \* @xe: Xe device.+ \* @tile: tile which bind exec queue belongs to.+ \* @flags: exec queue creation flags+ \* @extensions: exec queue creation extensions+ \*+ \* Normalize bind exec queue creation. Bind exec queue is tied to migration VM+ \* for access to physical memory required for page table programming. On a+ \* faulting devices the reserved copy engine instance must be used to avoid+ \* deadlocking (user binds cannot get stuck behind faults as kernel binds which+ \* resolve faults depend on user binds). On non-faulting devices any copy engine+ \* can be used.+ \*+ \* Returns exec queue on success, ERR\_PTR on failure+ \*/+struct xe\_exec\_queue \*xe\_exec\_queue\_create\_bind(struct xe\_device \*xe,+ struct xe\_tile \*tile,+ u32 flags, u64 extensions)+{+ struct xe\_gt \*gt = tile->primary\_gt;+ struct xe\_exec\_queue \*q;+ struct xe\_vm \*migrate\_vm;++ migrate\_vm = xe\_migrate\_get\_vm(tile->migrate);+ if (xe->info.has\_usm) {+ struct xe\_hw\_engine \*hwe = xe\_gt\_hw\_engine(gt,+ XE\_ENGINE\_CLASS\_COPY,+ gt->usm.reserved\_bcs\_instance,+ false);++ if (!hwe)+ return ERR\_PTR(-EINVAL);++ q = xe\_exec\_queue\_create(xe, migrate\_vm,+ BIT(hwe->logical\_instance), 1, hwe,+ flags, extensions);+ } else {+ q = xe\_exec\_queue\_create\_class(xe, gt, migrate\_vm,+ XE\_ENGINE\_CLASS\_COPY, flags,+ extensions);+ }+ xe\_vm\_put(migrate\_vm);++ return q; }  void xe\_exec\_queue\_destroy(struct kref \*ref)@@ -418,34 +466,6 @@ static int exec\_queue\_user\_extensions(struct xe\_device \*xe, struct xe\_exec\_queue return 0; } -static u32 bind\_exec\_queue\_logical\_mask(struct xe\_device \*xe, struct xe\_gt \*gt,- struct drm\_xe\_engine\_class\_instance \*eci,- u16 width, u16 num\_placements)-{- struct xe\_hw\_engine \*hwe;- enum xe\_hw\_engine\_id id;- u32 logical\_mask = 0;-- if (XE\_IOCTL\_DBG(xe, width != 1))- return 0;- if (XE\_IOCTL\_DBG(xe, num\_placements != 1))- return 0;- if (XE\_IOCTL\_DBG(xe, eci[0].engine\_instance != 0))- return 0;-- eci[0].engine\_class = DRM\_XE\_ENGINE\_CLASS\_COPY;-- for\_each\_hw\_engine(hwe, gt, id) {- if (xe\_hw\_engine\_is\_reserved(hwe))- continue;-- if (hwe->class == XE\_ENGINE\_CLASS\_COPY)- logical\_mask |= BIT(hwe->logical\_instance);- }-- return logical\_mask;-}- static u32 calc\_validate\_logical\_mask(struct xe\_device \*xe, struct xe\_gt \*gt, struct drm\_xe\_engine\_class\_instance \*eci, u16 width, u16 num\_placements)@@ -507,8 +527,9 @@ int xe\_exec\_queue\_create\_ioctl(struct drm\_device \*dev, void \*data, struct drm\_xe\_engine\_class\_instance \_\_user \*user\_eci = u64\_to\_user\_ptr(args->instances); struct xe\_hw\_engine \*hwe;- struct xe\_vm \*vm, \*migrate\_vm;+ struct xe\_vm \*vm; struct xe\_gt \*gt;+ struct xe\_tile \*tile; struct xe\_exec\_queue \*q = NULL; u32 logical\_mask; u32 id;@@ -533,37 +554,20 @@ int xe\_exec\_queue\_create\_ioctl(struct drm\_device \*dev, void \*data, return -EINVAL;  if (eci[0].engine\_class == DRM\_XE\_ENGINE\_CLASS\_VM\_BIND) {- for\_each\_gt(gt, xe, id) {- struct xe\_exec\_queue \*new;- u32 flags;-- if (xe\_gt\_is\_media\_type(gt))- continue;-- eci[0].gt\_id = gt->info.id;- logical\_mask = bind\_exec\_queue\_logical\_mask(xe, gt, eci,- args->width,- args->num\_placements);- if (XE\_IOCTL\_DBG(xe, !logical\_mask))- return -EINVAL;-- hwe = xe\_hw\_engine\_lookup(xe, eci[0]);- if (XE\_IOCTL\_DBG(xe, !hwe))- return -EINVAL;-- /\* The migration vm doesn't hold rpm ref \*/- xe\_pm\_runtime\_get\_noresume(xe);-- flags = EXEC\_QUEUE\_FLAG\_VM | (id ? EXEC\_QUEUE\_FLAG\_BIND\_ENGINE\_CHILD : 0);+ if (XE\_IOCTL\_DBG(xe, args->width != 1) ||+ XE\_IOCTL\_DBG(xe, args->num\_placements != 1) ||+ XE\_IOCTL\_DBG(xe, eci[0].engine\_instance != 0))+ return -EINVAL; - migrate\_vm = xe\_migrate\_get\_vm(gt\_to\_tile(gt)->migrate);- new = xe\_exec\_queue\_create(xe, migrate\_vm, logical\_mask,- args->width, hwe, flags,- args->extensions);+ for\_each\_tile(tile, xe, id) {+ struct xe\_exec\_queue \*new;+ u32 flags = EXEC\_QUEUE\_FLAG\_VM; - xe\_pm\_runtime\_put(xe); /\* now held by engine \*/+ if (id)+ flags |= EXEC\_QUEUE\_FLAG\_BIND\_ENGINE\_CHILD; - xe\_vm\_put(migrate\_vm);+ new = xe\_exec\_queue\_create\_bind(xe, tile, flags,+ args->extensions); if (IS\_ERR(new)) { err = PTR\_ERR(new); if (q)diff --git a/drivers/gpu/drm/xe/xe\_exec\_queue.h b/drivers/gpu/drm/xe/xe\_exec\_queue.hindex 289a3a51d2a21b..f4ba8897763f8a 100644--- a/[drivers/gpu/drm/xe/xe\_exec\_queue.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/gpu/drm/xe/xe_exec_queue.h?id=ab12bbe9233d91263151c95876539c9457bc45de)+++ b/[drivers/gpu/drm/xe/xe\_exec\_queue.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/gpu/drm/xe/xe_exec_queue.h?id=439fc1e569c57669dbb842d0a77c7ba0a82a9f5d)@@ -20,7 +20,11 @@ struct xe\_exec\_queue \*xe\_exec\_queue\_create(struct xe\_device \*xe, struct xe\_vm \*v u64 extensions); struct xe\_exec\_queue \*xe\_exec\_queue\_create\_class(struct xe\_device \*xe, struct xe\_gt \*gt, struct xe\_vm \*vm,- enum xe\_engine\_class class, u32 flags);+ enum xe\_engine\_class class,+ u32 flags, u64 extensions);+struct xe\_exec\_queue \*xe\_exec\_queue\_create\_bind(struct xe\_device \*xe,+ struct xe\_tile \*tile,+ u32 flags, u64 extensions);  void xe\_exec\_queue\_fini(struct xe\_exec\_queue \*q); void xe\_exec\_queue\_destroy(struct kref \*ref);diff --git a/drivers/gpu/drm/xe/xe\_migrate.c b/drivers/gpu/drm/xe/xe\_migrate.cindex c9f5673353ee3e..a849c48d8ac90f 100644--- a/[drivers/gpu/drm/xe/xe\_migrate.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/gpu/drm/xe/xe_migrate.c?id=ab12bbe9233d91263151c95876539c9457bc45de)+++ b/[drivers/gpu/drm/xe/xe\_migrate.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/gpu/drm/xe/xe_migrate.c?id=439fc1e569c57669dbb842d0a77c7ba0a82a9f5d)@@ -404,7 +404,7 @@ struct xe\_migrate \*xe\_migrate\_init(struct xe\_tile \*tile) m->q = xe\_exec\_queue\_create\_class(xe, primary\_gt, vm, XE\_ENGINE\_CLASS\_COPY, EXEC\_QUEUE\_FLAG\_KERNEL |- EXEC\_QUEUE\_FLAG\_PERMANENT);+ EXEC\_QUEUE\_FLAG\_PERMANENT, 0); } if (IS\_ERR(m->q)) { xe\_vm\_close\_and\_put(vm);diff --git a/drivers/gpu/drm/xe/xe\_vm.c b/drivers/gpu/drm/xe/xe\_vm.cindex 50e8fc49ba6c15..b49bee0dfac5da 100644--- a/[drivers/gpu/drm/xe/xe\_vm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/gpu/drm/xe/xe_vm.c?id=ab12bbe9233d91263151c95876539c9457bc45de)+++ b/[drivers/gpu/drm/xe/xe\_vm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/gpu/drm/xe/xe_vm.c?id=439fc1e569c57669dbb842d0a77c7ba0a82a9f5d)@@ -1412,19 +1412,13 @@ struct xe\_vm \*xe\_vm\_create(struct xe\_device \*xe, u32 flags) /\* Kernel migration VM shouldn't have a circular loop.. \*/ if (!(flags & XE\_VM\_FLAG\_MIGRATION)) { for\_each\_tile(tile, xe, id) {- struct xe\_gt \*gt = tile->primary\_gt;- struct xe\_vm \*migrate\_vm; struct xe\_exec\_queue \*q; u32 create\_flags = EXEC\_QUEUE\_FLAG\_VM;  if (!vm->pt\_root[id]) continue; - migrate\_vm = xe\_migrate\_get\_vm(tile->migrate);- q = xe\_exec\_queue\_create\_class(xe, gt, migrate\_vm,- XE\_ENGINE\_CLASS\_COPY,- create\_flags);- xe\_vm\_put(migrate\_vm);+ q = xe\_exec\_queue\_create\_bind(xe, tile, create\_flags, 0); if (IS\_ERR(q)) { err = PTR\_ERR(q); goto err\_close; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 09:41:23 +0000

