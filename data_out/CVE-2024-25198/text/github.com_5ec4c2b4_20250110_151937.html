
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fros-navigation%2Fnavigation2%2Fblob%2Fmain%2Fnav2_amcl%2Fsrc%2Famcl_node.cpp)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fros-navigation%2Fnavigation2%2Fblob%2Fmain%2Fnav2_amcl%2Fsrc%2Famcl_node.cpp)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=ros-navigation%2Fnavigation2)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[ros-navigation](/ros-navigation)
/
**[navigation2](/ros-navigation/navigation2)**
Public

* [Notifications](/login?return_to=%2Fros-navigation%2Fnavigation2) You must be signed in to change notification settings
* [Fork
  1.3k](/login?return_to=%2Fros-navigation%2Fnavigation2)
* [Star
   2.7k](/login?return_to=%2Fros-navigation%2Fnavigation2)

* [Code](/ros-navigation/navigation2)
* [Issues
  75](/ros-navigation/navigation2/issues)
* [Pull requests
  31](/ros-navigation/navigation2/pulls)
* [Discussions](/ros-navigation/navigation2/discussions)
* [Actions](/ros-navigation/navigation2/actions)
* [Projects
  0](/ros-navigation/navigation2/projects)
* [Wiki](/ros-navigation/navigation2/wiki)
* [Security](/ros-navigation/navigation2/security)
* [Insights](/ros-navigation/navigation2/pulse)

Additional navigation options

* [Code](/ros-navigation/navigation2)
* [Issues](/ros-navigation/navigation2/issues)
* [Pull requests](/ros-navigation/navigation2/pulls)
* [Discussions](/ros-navigation/navigation2/discussions)
* [Actions](/ros-navigation/navigation2/actions)
* [Projects](/ros-navigation/navigation2/projects)
* [Wiki](/ros-navigation/navigation2/wiki)
* [Security](/ros-navigation/navigation2/security)
* [Insights](/ros-navigation/navigation2/pulse)

## Files

 main
## Breadcrumbs

1. [navigation2](/ros-navigation/navigation2/tree/main)
2. /[nav2\_amcl](/ros-navigation/navigation2/tree/main/nav2_amcl)
3. /[src](/ros-navigation/navigation2/tree/main/nav2_amcl/src)
/
# amcl\_node.cpp

 Blame  Blame
## Latest commit

## History

[History](/ros-navigation/navigation2/commits/main/nav2_amcl/src/amcl_node.cpp)1653 lines (1434 loc) · 54.8 KB main
## Breadcrumbs

1. [navigation2](/ros-navigation/navigation2/tree/main)
2. /[nav2\_amcl](/ros-navigation/navigation2/tree/main/nav2_amcl)
3. /[src](/ros-navigation/navigation2/tree/main/nav2_amcl/src)
/
# amcl\_node.cpp

Top
## File metadata and controls

* Code
* Blame

1653 lines (1434 loc) · 54.8 KB[Raw](https://github.com/ros-navigation/navigation2/raw/refs/heads/main/nav2_amcl/src/amcl_node.cpp)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\* \* Copyright (c) 2008, Willow Garage, Inc. \* All rights reserved. \* \* This library is free software; you can redistribute it and/or \* modify it under the terms of the GNU Lesser General Public \* License as published by the Free Software Foundation; either \* version 2.1 of the License, or (at your option) any later version. \* \* This library is distributed in the hope that it will be useful, \* but WITHOUT ANY WARRANTY; without even the implied warranty of \* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU \* Lesser General Public License for more details. \* \* You should have received a copy of the GNU Lesser General Public \* License along with this library; if not, write to the Free Software \* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA \* \*/
/\* Author: Brian Gerkey \*/
#include "nav2\_amcl/amcl\_node.hpp"
#include <algorithm>#include <memory>#include <string>#include <utility>#include <vector>
#include "message\_filters/subscriber.hpp"#include "nav2\_amcl/angleutils.hpp"#include "nav2\_util/geometry\_utils.hpp"#include "nav2\_amcl/pf/pf.hpp"#include "nav2\_util/string\_utils.hpp"#include "nav2\_amcl/sensors/laser/laser.hpp"#include "rclcpp/node\_options.hpp"#include "tf2/convert.hpp"#include "tf2/utils.hpp"#include "tf2\_geometry\_msgs/tf2\_geometry\_msgs.hpp"#include "tf2/LinearMath/Transform.hpp"#include "tf2\_ros/buffer.h"#include "tf2\_ros/message\_filter.h"#include "tf2\_ros/transform\_broadcaster.h"#include "tf2\_ros/transform\_listener.h"#include "tf2\_ros/create\_timer\_ros.h"
#include "nav2\_amcl/portable\_utils.hpp"#include "nav2\_util/validate\_messages.hpp"
using rcl\_interfaces::msg::ParameterType;using namespace std::chrono\_literals;
namespace nav2\_amcl{using nav2\_util::geometry\_utils::orientationAroundZAxis;
AmclNode::AmclNode(const rclcpp::NodeOptions & options): nav2\_util::LifecycleNode("amcl", "", options){ RCLCPP\_INFO(get\_logger(), "Creating");
 add\_parameter( "alpha1", rclcpp::ParameterValue(0.2), "This is the alpha1 parameter", "These are additional constraints for alpha1");
 add\_parameter( "alpha2", rclcpp::ParameterValue(0.2), "This is the alpha2 parameter", "These are additional constraints for alpha2");
 add\_parameter( "alpha3", rclcpp::ParameterValue(0.2), "This is the alpha3 parameter", "These are additional constraints for alpha3");
 add\_parameter( "alpha4", rclcpp::ParameterValue(0.2), "This is the alpha4 parameter", "These are additional constraints for alpha4");
 add\_parameter( "alpha5", rclcpp::ParameterValue(0.2), "This is the alpha5 parameter", "These are additional constraints for alpha5");
 add\_parameter( "base\_frame\_id", rclcpp::ParameterValue(std::string("base\_footprint")), "Which frame to use for the robot base");
 add\_parameter("beam\_skip\_distance", rclcpp::ParameterValue(0.5)); add\_parameter("beam\_skip\_error\_threshold", rclcpp::ParameterValue(0.9)); add\_parameter("beam\_skip\_threshold", rclcpp::ParameterValue(0.3)); add\_parameter("do\_beamskip", rclcpp::ParameterValue(false));
 add\_parameter( "global\_frame\_id", rclcpp::ParameterValue(std::string("map")), "The name of the coordinate frame published by the localization system");
 add\_parameter( "lambda\_short", rclcpp::ParameterValue(0.1), "Exponential decay parameter for z\_short part of model");
 add\_parameter( "laser\_likelihood\_max\_dist", rclcpp::ParameterValue(2.0), "Maximum distance to do obstacle inflation on map, for use in likelihood\_field model");
 add\_parameter( "laser\_max\_range", rclcpp::ParameterValue(100.0), "Maximum scan range to be considered", "-1.0 will cause the laser's reported maximum range to be used");
 add\_parameter( "laser\_min\_range", rclcpp::ParameterValue(-1.0), "Minimum scan range to be considered", "-1.0 will cause the laser's reported minimum range to be used");
 add\_parameter( "laser\_model\_type", rclcpp::ParameterValue(std::string("likelihood\_field")), "Which model to use, either beam, likelihood\_field, or likelihood\_field\_prob", "Same as likelihood\_field but incorporates the beamskip feature, if enabled");
 add\_parameter( "set\_initial\_pose", rclcpp::ParameterValue(false), "Causes AMCL to set initial pose from the initial\_pose\* parameters instead of " "waiting for the initial\_pose message");
 add\_parameter( "initial\_pose.x", rclcpp::ParameterValue(0.0), "X coordinate of the initial robot pose in the map frame");
 add\_parameter( "initial\_pose.y", rclcpp::ParameterValue(0.0), "Y coordinate of the initial robot pose in the map frame");
 add\_parameter( "initial\_pose.z", rclcpp::ParameterValue(0.0), "Z coordinate of the initial robot pose in the map frame");
 add\_parameter( "initial\_pose.yaw", rclcpp::ParameterValue(0.0), "Yaw of the initial robot pose in the map frame");
 add\_parameter( "max\_beams", rclcpp::ParameterValue(60), "How many evenly-spaced beams in each scan to be used when updating the filter");
 add\_parameter( "max\_particles", rclcpp::ParameterValue(2000), "Maximum allowed number of particles");
 add\_parameter( "min\_particles", rclcpp::ParameterValue(500), "Minimum allowed number of particles");
 add\_parameter( "odom\_frame\_id", rclcpp::ParameterValue(std::string("odom")), "Which frame to use for odometry");
 add\_parameter("pf\_err", rclcpp::ParameterValue(0.05)); add\_parameter("pf\_z", rclcpp::ParameterValue(0.99));
 add\_parameter( "recovery\_alpha\_fast", rclcpp::ParameterValue(0.0), "Exponential decay rate for the fast average weight filter, used in deciding when to recover " "by adding random poses", "A good value might be 0.1");
 add\_parameter( "recovery\_alpha\_slow", rclcpp::ParameterValue(0.0), "Exponential decay rate for the slow average weight filter, used in deciding when to recover " "by adding random poses", "A good value might be 0.001");
 add\_parameter( "resample\_interval", rclcpp::ParameterValue(1), "Number of filter updates required before resampling");
 add\_parameter("robot\_model\_type", rclcpp::ParameterValue("nav2\_amcl::DifferentialMotionModel"));
 add\_parameter( "save\_pose\_rate", rclcpp::ParameterValue(0.5), "Maximum rate (Hz) at which to store the last estimated pose and covariance to the parameter " "server, in the variables ~initial\_pose\_\* and ~initial\_cov\_\*. This saved pose will be used " "on subsequent runs to initialize the filter", "-1.0 to disable");
 add\_parameter("sigma\_hit", rclcpp::ParameterValue(0.2));
 add\_parameter( "tf\_broadcast", rclcpp::ParameterValue(true), "Set this to false to prevent amcl from publishing the transform between the global frame and " "the odometry frame");
 add\_parameter( "transform\_tolerance", rclcpp::ParameterValue(1.0), "Time with which to post-date the transform that is published, to indicate that this transform " "is valid into the future");
 add\_parameter( "update\_min\_a", rclcpp::ParameterValue(0.2), "Rotational movement required before performing a filter update");
 add\_parameter( "update\_min\_d", rclcpp::ParameterValue(0.25), "Translational movement required before performing a filter update");
 add\_parameter("z\_hit", rclcpp::ParameterValue(0.5)); add\_parameter("z\_max", rclcpp::ParameterValue(0.05)); add\_parameter("z\_rand", rclcpp::ParameterValue(0.5)); add\_parameter("z\_short", rclcpp::ParameterValue(0.05));
 add\_parameter( "always\_reset\_initial\_pose", rclcpp::ParameterValue(false), "Requires that AMCL is provided an initial pose either via topic or initial\_pose\* parameter " "(with parameter set\_initial\_pose: true) when reset. Otherwise, by default AMCL will use the" "last known pose to initialize");
 add\_parameter( "scan\_topic", rclcpp::ParameterValue("scan"), "Topic to subscribe to in order to receive the laser scan for localization");
 add\_parameter( "map\_topic", rclcpp::ParameterValue("map"), "Topic to subscribe to in order to receive the map to localize on");
 add\_parameter( "first\_map\_only", rclcpp::ParameterValue(false), "Set this to true, when you want to load a new map published from the map\_server");
 add\_parameter( "freespace\_downsampling", rclcpp::ParameterValue( false), "Downsample the free space used by the Pose Generator. Use it with large maps to save memory");}
AmclNode::~AmclNode(){}
nav2\_util::CallbackReturnAmclNode::on\_configure(const rclcpp\_lifecycle::State & /\*state\*/){ RCLCPP\_INFO(get\_logger(), "Configuring"); callback\_group\_ = create\_callback\_group( rclcpp::CallbackGroupType::MutuallyExclusive, false); initParameters(); initTransforms(); initParticleFilter(); initLaserScan(); initMessageFilters(); initPubSub(); initServices(); initOdometry(); executor\_ = std::make\_shared<rclcpp::executors::SingleThreadedExecutor>(); executor\_->add\_callback\_group(callback\_group\_, get\_node\_base\_interface()); executor\_thread\_ = std::make\_unique<nav2\_util::NodeThread>(executor\_); return nav2\_util::CallbackReturn::SUCCESS;}
nav2\_util::CallbackReturnAmclNode::on\_activate(const rclcpp\_lifecycle::State & /\*state\*/){ RCLCPP\_INFO(get\_logger(), "Activating");
 // Lifecycle publishers must be explicitly activated pose\_pub\_->on\_activate(); particle\_cloud\_pub\_->on\_activate();
 first\_pose\_sent\_ = false;
 // Keep track of whether we're in the active state. We won't // process incoming callbacks until we are active\_ = true;
 if (set\_initial\_pose\_) { auto msg = std::make\_shared<geometry\_msgs::msg::PoseWithCovarianceStamped>();
 msg->header.stamp = now(); msg->header.frame\_id = global\_frame\_id\_; msg->pose.pose.position.x = initial\_pose\_x\_; msg->pose.pose.position.y = initial\_pose\_y\_; msg->pose.pose.position.z = initial\_pose\_z\_; msg->pose.pose.orientation = orientationAroundZAxis(initial\_pose\_yaw\_);
 initialPoseReceived(msg); } else if (init\_pose\_received\_on\_inactive) { handleInitialPose(last\_published\_pose\_); }
 auto node = shared\_from\_this(); // Add callback for dynamic parameters dyn\_params\_handler\_ = node->add\_on\_set\_parameters\_callback( std::bind( &AmclNode::dynamicParametersCallback, this, std::placeholders::\_1));
 // create bond connection createBond();
 return nav2\_util::CallbackReturn::SUCCESS;}
nav2\_util::CallbackReturnAmclNode::on\_deactivate(const rclcpp\_lifecycle::State & /\*state\*/){ RCLCPP\_INFO(get\_logger(), "Deactivating");
 active\_ = false;
 // Lifecycle publishers must be explicitly deactivated pose\_pub\_->on\_deactivate(); particle\_cloud\_pub\_->on\_deactivate();
 // shutdown and reset dynamic parameter handler remove\_on\_set\_parameters\_callback(dyn\_params\_handler\_.get()); dyn\_params\_handler\_.reset();
 // destroy bond connection destroyBond();
 return nav2\_util::CallbackReturn::SUCCESS;}
nav2\_util::CallbackReturnAmclNode::on\_cleanup(const rclcpp\_lifecycle::State & /\*state\*/){ RCLCPP\_INFO(get\_logger(), "Cleaning up");
 executor\_thread\_.reset();
 // Get rid of the inputs first (services and message filter input), so we // don't continue to process incoming messages global\_loc\_srv\_.reset(); initial\_guess\_srv\_.reset(); nomotion\_update\_srv\_.reset(); initial\_pose\_sub\_.reset(); laser\_scan\_connection\_.disconnect(); tf\_listener\_.reset(); // listener may access lase\_scan\_filter\_, so it should be reset earlier laser\_scan\_filter\_.reset(); laser\_scan\_sub\_.reset();
 // Map map\_sub\_.reset(); // map\_sub\_ may access map\_, so it should be reset earlier if (map\_ != NULL) { map\_free(map\_); map\_ = nullptr; } first\_map\_received\_ = false; free\_space\_indices.resize(0);
 // Transforms tf\_broadcaster\_.reset(); tf\_buffer\_.reset();
 // PubSub pose\_pub\_.reset(); particle\_cloud\_pub\_.reset();
 // Odometry motion\_model\_.reset();
 // Particle Filter pf\_free(pf\_); pf\_ = nullptr;
 // Laser Scan lasers\_.clear(); lasers\_update\_.clear(); frame\_to\_laser\_.clear(); force\_update\_ = true;
 if (set\_initial\_pose\_) { set\_parameter( rclcpp::Parameter( "initial\_pose.x", rclcpp::ParameterValue(last\_published\_pose\_.pose.pose.position.x))); set\_parameter( rclcpp::Parameter( "initial\_pose.y", rclcpp::ParameterValue(last\_published\_pose\_.pose.pose.position.y))); set\_parameter( rclcpp::Parameter( "initial\_pose.z", rclcpp::ParameterValue(last\_published\_pose\_.pose.pose.position.z))); set\_parameter( rclcpp::Parameter( "initial\_pose.yaw", rclcpp::ParameterValue(tf2::getYaw(last\_published\_pose\_.pose.pose.orientation)))); }
 return nav2\_util::CallbackReturn::SUCCESS;}
nav2\_util::CallbackReturnAmclNode::on\_shutdown(const rclcpp\_lifecycle::State & /\*state\*/){ RCLCPP\_INFO(get\_logger(), "Shutting down"); return nav2\_util::CallbackReturn::SUCCESS;}
boolAmclNode::checkElapsedTime(std::chrono::seconds check\_interval, rclcpp::Time last\_time){ rclcpp::Duration elapsed\_time = now() - last\_time; if (elapsed\_time.nanoseconds() \* 1e-9 > check\_interval.count()) { return true; } return false;}
#if NEW\_UNIFORM\_SAMPLINGstd::vector<AmclNode::Point2D> AmclNode::free\_space\_indices;#endif
boolAmclNode::getOdomPose( geometry\_msgs::msg::PoseStamped & odom\_pose, double & x, double & y, double & yaw, const rclcpp::Time & sensor\_timestamp, const std::string & frame\_id){ // Get the robot's pose geometry\_msgs::msg::PoseStamped ident; ident.header.frame\_id = nav2\_util::strip\_leading\_slash(frame\_id); ident.header.stamp = sensor\_timestamp; tf2::toMsg(tf2::Transform::getIdentity(), ident.pose);
 try { tf\_buffer\_->transform(ident, odom\_pose, odom\_frame\_id\_); } catch (tf2::TransformException & e) { ++scan\_error\_count\_; if (scan\_error\_count\_ % 20 == 0) { RCLCPP\_ERROR( get\_logger(), "(%d) consecutive laser scan transforms failed: (%s)", scan\_error\_count\_, e.what()); } return false; }
 scan\_error\_count\_ = 0; // reset since we got a good transform x = odom\_pose.pose.position.x; y = odom\_pose.pose.position.y; yaw = tf2::getYaw(odom\_pose.pose.orientation);
 return true;}
pf\_vector\_tAmclNode::uniformPoseGenerator(void \* arg){ map\_t \* map = reinterpret\_cast<map\_t \*>(arg);
#if NEW\_UNIFORM\_SAMPLING unsigned int rand\_index = drand48() \* free\_space\_indices.size(); AmclNode::Point2D free\_point = free\_space\_indices[rand\_index]; pf\_vector\_t p; p.v[0] = MAP\_WXGX(map, free\_point.x); p.v[1] = MAP\_WYGY(map, free\_point.y); p.v[2] = drand48() \* 2 \* M\_PI - M\_PI;#else double min\_x, max\_x, min\_y, max\_y;
 min\_x = (map->size\_x \* map->scale) / 2.0 - map->origin\_x; max\_x = (map->size\_x \* map->scale) / 2.0 + map->origin\_x; min\_y = (map->size\_y \* map->scale) / 2.0 - map->origin\_y; max\_y = (map->size\_y \* map->scale) / 2.0 + map->origin\_y;
 pf\_vector\_t p;
 RCLCPP\_DEBUG(get\_logger(), "Generating new uniform sample"); for (;; ) { p.v[0] = min\_x + drand48() \* (max\_x - min\_x); p.v[1] = min\_y + drand48() \* (max\_y - min\_y); p.v[2] = drand48() \* 2 \* M\_PI - M\_PI; // Check that it's a free cell int i, j; i = MAP\_GXWX(map, p.v[0]); j = MAP\_GYWY(map, p.v[1]); if (MAP\_VALID(map, i, j) && (map->cells[MAP\_INDEX(map, i, j)].occ\_state == -1)) { break; } }#endif return p;}
voidAmclNode::globalLocalizationCallback( const std::shared\_ptr<rmw\_request\_id\_t>/\*request\_header\*/, const std::shared\_ptr<std\_srvs::srv::Empty::Request>/\*req\*/, std::shared\_ptr<std\_srvs::srv::Empty::Response>/\*res\*/){ std::lock\_guard<std::recursive\_mutex> cfl(mutex\_);
 RCLCPP\_INFO(get\_logger(), "Initializing with uniform distribution");
 pf\_init\_model( pf\_, (pf\_init\_model\_fn\_t)AmclNode::uniformPoseGenerator, reinterpret\_cast<void \*>(map\_)); RCLCPP\_INFO(get\_logger(), "Global initialisation done!"); initial\_pose\_is\_known\_ = true; pf\_init\_ = false;}
voidAmclNode::initialPoseReceivedSrv( const std::shared\_ptr<rmw\_request\_id\_t>/\*request\_header\*/, const std::shared\_ptr<nav2\_msgs::srv::SetInitialPose::Request> req, std::shared\_ptr<nav2\_msgs::srv::SetInitialPose::Response>/\*res\*/){ initialPoseReceived(std::make\_shared<geometry\_msgs::msg::PoseWithCovarianceStamped>(req->pose));}
// force nomotion updates (amcl updating without requiring motion)voidAmclNode::nomotionUpdateCallback( const std::shared\_ptr<rmw\_request\_id\_t>/\*request\_header\*/, const std::shared\_ptr<std\_srvs::srv::Empty::Request>/\*req\*/, std::shared\_ptr<std\_srvs::srv::Empty::Response>/\*res\*/){ RCLCPP\_INFO(get\_logger(), "Requesting no-motion update"); force\_update\_ = true;}
voidAmclNode::initialPoseReceived(geometry\_msgs::msg::PoseWithCovarianceStamped::SharedPtr msg){ std::lock\_guard<std::recursive\_mutex> cfl(mutex\_);
 RCLCPP\_INFO(get\_logger(), "initialPoseReceived");
 if (!nav2\_util::validateMsg(\*msg)) { RCLCPP\_ERROR(get\_logger(), "Received initialpose message is malformed. Rejecting."); return; } if (nav2\_util::strip\_leading\_slash(msg->header.frame\_id) != global\_frame\_id\_) { RCLCPP\_WARN( get\_logger(), "Ignoring initial pose in frame \"%s\"; initial poses must be in the global frame, \"%s\"", nav2\_util::strip\_leading\_slash(msg->header.frame\_id).c\_str(), global\_frame\_id\_.c\_str()); return; } if (first\_map\_received\_ && (abs(msg->pose.pose.position.x) > map\_->size\_x || abs(msg->pose.pose.position.y) > map\_->size\_y)) { RCLCPP\_ERROR( get\_logger(), "Received initialpose from message is out of the size of map. Rejecting."); return; }
 // Overriding last published pose to initial pose last\_published\_pose\_ = \*msg;
 if (!active\_) { init\_pose\_received\_on\_inactive = true; RCLCPP\_WARN( get\_logger(), "Received initial pose request, " "but AMCL is not yet in the active state"); return; } handleInitialPose(\*msg);}
voidAmclNode::handleInitialPose(geometry\_msgs::msg::PoseWithCovarianceStamped & msg){ std::lock\_guard<std::recursive\_mutex> cfl(mutex\_); // In case the client sent us a pose estimate in the past, integrate the // intervening odometric change. geometry\_msgs::msg::TransformStamped tx\_odom; try { rclcpp::Time rclcpp\_time = now(); tf2::TimePoint tf2\_time(std::chrono::nanoseconds(rclcpp\_time.nanoseconds()));
 // Check if the transform is available tx\_odom = tf\_buffer\_->lookupTransform( base\_frame\_id\_, tf2\_ros::fromMsg(msg.header.stamp), base\_frame\_id\_, tf2\_time, odom\_frame\_id\_); } catch (tf2::TransformException & e) { // If we've never sent a transform, then this is normal, because the // global\_frame\_id\_ frame doesn't exist. We only care about in-time // transformation for on-the-move pose-setting, so ignoring this // startup condition doesn't really cost us anything. if (sent\_first\_transform\_) { RCLCPP\_WARN(get\_logger(), "Failed to transform initial pose in time (%s)", e.what()); } tf2::impl::Converter<false, true>::convert(tf2::Transform::getIdentity(), tx\_odom.transform); }
 tf2::Transform tx\_odom\_tf2; tf2::impl::Converter<true, false>::convert(tx\_odom.transform, tx\_odom\_tf2);
 tf2::Transform pose\_old; tf2::impl::Converter<true, false>::convert(msg.pose.pose, pose\_old);
 tf2::Transform pose\_new = pose\_old \* tx\_odom\_tf2;
 // Transform into the global frame
 RCLCPP\_INFO( get\_logger(), "Setting pose (%.6f): %.3f %.3f %.3f", now().nanoseconds() \* 1e-9, pose\_new.getOrigin().x(), pose\_new.getOrigin().y(), tf2::getYaw(pose\_new.getRotation()));
 // Re-initialize the filter pf\_vector\_t pf\_init\_pose\_mean = pf\_vector\_zero(); pf\_init\_pose\_mean.v[0] = pose\_new.getOrigin().x(); pf\_init\_pose\_mean.v[1] = pose\_new.getOrigin().y(); pf\_init\_pose\_mean.v[2] = tf2::getYaw(pose\_new.getRotation());
 pf\_matrix\_t pf\_init\_pose\_cov = pf\_matrix\_zero(); // Copy in the covariance, converting from 6-D to 3-D for (int i = 0; i < 2; i++) { for (int j = 0; j < 2; j++) { pf\_init\_pose\_cov.m[i][j] = msg.pose.covariance[6 \* i + j]; } }
 pf\_init\_pose\_cov.m[2][2] = msg.pose.covariance[6 \* 5 + 5];
 pf\_init(pf\_, pf\_init\_pose\_mean, pf\_init\_pose\_cov); pf\_init\_ = false; init\_pose\_received\_on\_inactive = false; initial\_pose\_is\_known\_ = true;}
voidAmclNode::laserReceived(sensor\_msgs::msg::LaserScan::ConstSharedPtr laser\_scan){ std::lock\_guard<std::recursive\_mutex> cfl(mutex\_);
 // Since the sensor data is continually being published by the simulator or robot, // we don't want our callbacks to fire until we're in the active state if (!active\_) {return;} if (!first\_map\_received\_) { if (checkElapsedTime(2s, last\_time\_printed\_msg\_)) { RCLCPP\_WARN(get\_logger(), "Waiting for map...."); last\_time\_printed\_msg\_ = now(); } return; }
 std::string laser\_scan\_frame\_id = nav2\_util::strip\_leading\_slash(laser\_scan->header.frame\_id); last\_laser\_received\_ts\_ = now(); int laser\_index = -1; geometry\_msgs::msg::PoseStamped laser\_pose;
 // Do we have the base->base\_laser Tx yet? if (frame\_to\_laser\_.find(laser\_scan\_frame\_id) == frame\_to\_laser\_.end()) { if (!addNewScanner(laser\_index, laser\_scan, laser\_scan\_frame\_id, laser\_pose)) { return; // could not find transform } } else { // we have the laser pose, retrieve laser index laser\_index = frame\_to\_laser\_[laser\_scan->header.frame\_id]; }
 // Where was the robot when this scan was taken? pf\_vector\_t pose; if (!getOdomPose( latest\_odom\_pose\_, pose.v[0], pose.v[1], pose.v[2], laser\_scan->header.stamp, base\_frame\_id\_)) { RCLCPP\_ERROR(get\_logger(), "Couldn't determine robot's pose associated with laser scan"); return; }
 pf\_vector\_t delta = pf\_vector\_zero(); bool force\_publication = false; if (!pf\_init\_) { // Pose at last filter update pf\_odom\_pose\_ = pose; pf\_init\_ = true;
 for (unsigned int i = 0; i < lasers\_update\_.size(); i++) { lasers\_update\_[i] = true; }
 force\_publication = true; resample\_count\_ = 0; } else { // Set the laser update flags if (shouldUpdateFilter(pose, delta)) { for (unsigned int i = 0; i < lasers\_update\_.size(); i++) { lasers\_update\_[i] = true; } } if (lasers\_update\_[laser\_index]) { motion\_model\_->odometryUpdate(pf\_, pose, delta); } force\_update\_ = false; }
 bool resampled = false;
 // If the robot has moved, update the filter if (lasers\_update\_[laser\_index]) { updateFilter(laser\_index, laser\_scan, pose);
 // Resample the particles if (!(++resample\_count\_ % resample\_interval\_)) { pf\_update\_resample(pf\_, reinterpret\_cast<void \*>(map\_)); resampled = true; }
 pf\_sample\_set\_t \* set = pf\_->sets + pf\_->current\_set; RCLCPP\_DEBUG(get\_logger(), "Num samples: %d\n", set->sample\_count);
 if (!force\_update\_) { publishParticleCloud(set); } } if (resampled || force\_publication || !first\_pose\_sent\_) { amcl\_hyp\_t max\_weight\_hyps; std::vector<amcl\_hyp\_t> hyps; int max\_weight\_hyp = -1; if (getMaxWeightHyp(hyps, max\_weight\_hyps, max\_weight\_hyp)) { publishAmclPose(laser\_scan, hyps, max\_weight\_hyp); calculateMaptoOdomTransform(laser\_scan, hyps, max\_weight\_hyp);
 if (tf\_broadcast\_ == true) { // We want to send a transform that is good up until a // tolerance time so that odom can be used auto stamp = tf2\_ros::fromMsg(laser\_scan->header.stamp); tf2::TimePoint transform\_expiration = stamp + transform\_tolerance\_; sendMapToOdomTransform(transform\_expiration); sent\_first\_transform\_ = true; } } else { RCLCPP\_ERROR(get\_logger(), "No pose!"); } } else if (latest\_tf\_valid\_) { if (tf\_broadcast\_ == true) { // Nothing changed, so we'll just republish the last transform, to keep // everybody happy. tf2::TimePoint transform\_expiration = tf2\_ros::fromMsg(laser\_scan->header.stamp) + transform\_tolerance\_; sendMapToOdomTransform(transform\_expiration); } }}
bool AmclNode::addNewScanner( int & laser\_index, const sensor\_msgs::msg::LaserScan::ConstSharedPtr & laser\_scan, const std::string & laser\_scan\_frame\_id, geometry\_msgs::msg::PoseStamped & laser\_pose){ lasers\_.push\_back(createLaserObject()); lasers\_update\_.push\_back(true); laser\_index = frame\_to\_laser\_.size();
 geometry\_msgs::msg::PoseStamped ident; ident.header.frame\_id = laser\_scan\_frame\_id; ident.header.stamp = rclcpp::Time(); tf2::toMsg(tf2::Transform::getIdentity(), ident.pose); try { tf\_buffer\_->transform(ident, laser\_pose, base\_frame\_id\_, transform\_tolerance\_); } catch (tf2::TransformException & e) { RCLCPP\_ERROR( get\_logger(), "Couldn't transform from %s to %s, " "even though the message notifier is in use: (%s)", laser\_scan->header.frame\_id.c\_str(), base\_frame\_id\_.c\_str(), e.what()); return false; }
 pf\_vector\_t laser\_pose\_v; laser\_pose\_v.v[0] = laser\_pose.pose.position.x; laser\_pose\_v.v[1] = laser\_pose.pose.position.y; // laser mounting angle gets computed later -> set to 0 here! laser\_pose\_v.v[2] = 0; lasers\_[laser\_index]->SetLaserPose(laser\_pose\_v); frame\_to\_laser\_[laser\_scan->header.frame\_id] = laser\_index; return true;}
bool AmclNode::shouldUpdateFilter(const pf\_vector\_t pose, pf\_vector\_t & delta){ delta.v[0] = pose.v[0] - pf\_odom\_pose\_.v[0]; delta.v[1] = pose.v[1] - pf\_odom\_pose\_.v[1]; delta.v[2] = angleutils::angle\_diff(pose.v[2], pf\_odom\_pose\_.v[2]);
 // See if we should update the filter bool update = fabs(delta.v[0]) > d\_thresh\_ || fabs(delta.v[1]) > d\_thresh\_ || fabs(delta.v[2]) > a\_thresh\_; update = update || force\_update\_; return update;}
bool AmclNode::updateFilter( const int & laser\_index, const sensor\_msgs::msg::LaserScan::ConstSharedPtr & laser\_scan, const pf\_vector\_t & pose){ nav2\_amcl::LaserData ldata; ldata.laser = lasers\_[laser\_index]; ldata.range\_count = laser\_scan->ranges.size(); // To account for lasers that are mounted upside-down, we determine the // min, max, and increment angles of the laser in the base frame. // // Construct min and max angles of laser, in the base\_link frame. // Here we set the roll pich yaw of the lasers. We assume roll and pich are zero. geometry\_msgs::msg::QuaternionStamped min\_q, inc\_q; min\_q.header.stamp = laser\_scan->header.stamp; min\_q.header.frame\_id = nav2\_util::strip\_leading\_slash(laser\_scan->header.frame\_id); min\_q.quaternion = orientationAroundZAxis(laser\_scan->angle\_min);
 inc\_q.header = min\_q.header; inc\_q.quaternion = orientationAroundZAxis(laser\_scan->angle\_min + laser\_scan->angle\_increment); try { tf\_buffer\_->transform(min\_q, min\_q, base\_frame\_id\_); tf\_buffer\_->transform(inc\_q, inc\_q, base\_frame\_id\_); } catch (tf2::TransformException & e) { RCLCPP\_WARN( get\_logger(), "Unable to transform min/max laser angles into base frame: %s", e.what()); return false; } double angle\_min = tf2::getYaw(min\_q.quaternion); double angle\_increment = tf2::getYaw(inc\_q.quaternion) - angle\_min;
 // wrapping angle to [-pi .. pi] angle\_increment = fmod(angle\_increment + 5 \* M\_PI, 2 \* M\_PI) - M\_PI;
 RCLCPP\_DEBUG( get\_logger(), "Laser %d angles in base frame: min: %.3f inc: %.3f", laser\_index, angle\_min, angle\_increment);
 // Check the validity of range\_max, must > 0.0 if (laser\_scan->range\_max <= 0.0) { RCLCPP\_WARN( get\_logger(), "wrong range\_max of laser\_scan data: %f. The message could be malformed." " Ignore this message and stop updating.", laser\_scan->range\_max); return false; }
 // Apply range min/max thresholds, if the user supplied them if (laser\_max\_range\_ > 0.0) { ldata.range\_max = std::min(laser\_scan->range\_max, static\_cast<float>(laser\_max\_range\_)); } else { ldata.range\_max = laser\_scan->range\_max; } double range\_min; if (laser\_min\_range\_ > 0.0) { range\_min = std::max(laser\_scan->range\_min, static\_cast<float>(laser\_min\_range\_)); } else { range\_min = laser\_scan->range\_min; }
 // The LaserData destructor will free this memory ldata.ranges = new double[ldata.range\_count][2]; for (int i = 0; i < ldata.range\_count; i++) { // amcl doesn't (yet) have a concept of min range. So we'll map short // readings to max range. if (laser\_scan->ranges[i] <= range\_min) { ldata.ranges[i][0] = ldata.range\_max; } else { ldata.ranges[i][0] = laser\_scan->ranges[i]; } // Compute bearing ldata.ranges[i][1] = angle\_min + (i \* angle\_increment); } lasers\_[laser\_index]->sensorUpdate(pf\_, reinterpret\_cast<nav2\_amcl::LaserData \*>(&ldata)); lasers\_update\_[laser\_index] = false; pf\_odom\_pose\_ = pose; return true;}
voidAmclNode::publishParticleCloud(const pf\_sample\_set\_t \* set){ // If initial pose is not known, AMCL does not know the current pose if (!initial\_pose\_is\_known\_) {return;} auto cloud\_with\_weights\_msg = std::make\_unique<nav2\_msgs::msg::ParticleCloud>(); cloud\_with\_weights\_msg->header.stamp = this->now(); cloud\_with\_weights\_msg->header.frame\_id = global\_frame\_id\_; cloud\_with\_weights\_msg->particles.resize(set->sample\_count);
 for (int i = 0; i < set->sample\_count; i++) { cloud\_with\_weights\_msg->particles[i].pose.position.x = set->samples[i].pose.v[0]; cloud\_with\_weights\_msg->particles[i].pose.position.y = set->samples[i].pose.v[1]; cloud\_with\_weights\_msg->particles[i].pose.position.z = 0; cloud\_with\_weights\_msg->particles[i].pose.orientation = orientationAroundZAxis( set->samples[i].pose.v[2]); cloud\_with\_weights\_msg->particles[i].weight = set->samples[i].weight; }
 particle\_cloud\_pub\_->publish(std::move(cloud\_with\_weights\_msg));}
boolAmclNode::getMaxWeightHyp( std::vector<amcl\_hyp\_t> & hyps, amcl\_hyp\_t & max\_weight\_hyps, int & max\_weight\_hyp){ // Read out the current hypotheses double max\_weight = 0.0; hyps.resize(pf\_->sets[pf\_->current\_set].cluster\_count); for (int hyp\_count = 0; hyp\_count < pf\_->sets[pf\_->current\_set].cluster\_count; hyp\_count++) { double weight; pf\_vector\_t pose\_mean; pf\_matrix\_t pose\_cov; if (!pf\_get\_cluster\_stats(pf\_, hyp\_count, &weight, &pose\_mean, &pose\_cov)) { RCLCPP\_ERROR(get\_logger(), "Couldn't get stats on cluster %d", hyp\_count); return false; }
 hyps[hyp\_count].weight = weight; hyps[hyp\_count].pf\_pose\_mean = pose\_mean; hyps[hyp\_count].pf\_pose\_cov = pose\_cov;
 if (hyps[hyp\_count].weight > max\_weight) { max\_weight = hyps[hyp\_count].weight; max\_weight\_hyp = hyp\_count; } }
 if (max\_weight > 0.0) { RCLCPP\_DEBUG( get\_logger(), "Max weight pose: %.3f %.3f %.3f", hyps[max\_weight\_hyp].pf\_pose\_mean.v[0], hyps[max\_weight\_hyp].pf\_pose\_mean.v[1], hyps[max\_weight\_hyp].pf\_pose\_mean.v[2]);
 max\_weight\_hyps = hyps[max\_weight\_hyp]; return true; } return false;}
voidAmclNode::publishAmclPose( const sensor\_msgs::msg::LaserScan::ConstSharedPtr & laser\_scan, const std::vector<amcl\_hyp\_t> & hyps, const int & max\_weight\_hyp){ // If initial pose is not known, AMCL does not know the current pose if (!initial\_pose\_is\_known\_) { if (checkElapsedTime(2s, last\_time\_printed\_msg\_)) { RCLCPP\_WARN( get\_logger(), "AMCL cannot publish a pose or update the transform. " "Please set the initial pose..."); last\_time\_printed\_msg\_ = now(); } return; }
 auto p = std::make\_unique<geometry\_msgs::msg::PoseWithCovarianceStamped>(); // Fill in the header p->header.frame\_id = global\_frame\_id\_; p->header.stamp = laser\_scan->header.stamp; // Copy in the pose p->pose.pose.position.x = hyps[max\_weight\_hyp].pf\_pose\_mean.v[0]; p->pose.pose.position.y = hyps[max\_weight\_hyp].pf\_pose\_mean.v[1]; p->pose.pose.orientation = orientationAroundZAxis(hyps[max\_weight\_hyp].pf\_pose\_mean.v[2]); // Copy in the covariance, converting from 3-D to 6-D pf\_sample\_set\_t \* set = pf\_->sets + pf\_->current\_set; for (int i = 0; i < 2; i++) { for (int j = 0; j < 2; j++) { // Report the overall filter covariance, rather than the // covariance for the highest-weight cluster // p->covariance[6\*i+j] = hyps[max\_weight\_hyp].pf\_pose\_cov.m[i][j]; p->pose.covariance[6 \* i + j] = set->cov.m[i][j]; } } p->pose.covariance[6 \* 5 + 5] = set->cov.m[2][2]; float temp = 0.0; for (auto covariance\_value : p->pose.covariance) { temp += covariance\_value; } temp += p->pose.pose.position.x + p->pose.pose.position.y; if (!std::isnan(temp)) { RCLCPP\_DEBUG(get\_logger(), "Publishing pose"); last\_published\_pose\_ = \*p; first\_pose\_sent\_ = true; pose\_pub\_->publish(std::move(p)); } else { RCLCPP\_WARN( get\_logger(), "AMCL covariance or pose is NaN, likely due to an invalid " "configuration or faulty sensor measurements! Pose is not available!"); }
 RCLCPP\_DEBUG( get\_logger(), "New pose: %6.3f %6.3f %6.3f", hyps[max\_weight\_hyp].pf\_pose\_mean.v[0], hyps[max\_weight\_hyp].pf\_pose\_mean.v[1], hyps[max\_weight\_hyp].pf\_pose\_mean.v[2]);}
voidAmclNode::calculateMaptoOdomTransform( const sensor\_msgs::msg::LaserScan::ConstSharedPtr & laser\_scan, const std::vector<amcl\_hyp\_t> & hyps, const int & max\_weight\_hyp){ // subtracting base to odom from map to base and send map to odom instead geometry\_msgs::msg::PoseStamped odom\_to\_map;[View remainder of file in raw view](https://github.com/ros-navigation/navigation2/raw/refs/heads/main/nav2_amcl/src/amcl_node.cpp)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

