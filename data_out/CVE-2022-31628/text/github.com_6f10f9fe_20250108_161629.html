
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fphp%2Fphp-src%2Fblob%2F2f5295692fde289f99aa9701528dcde4c78b780f%2Fext%2Fphar%2Fphar.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fphp%2Fphp-src%2Fblob%2F2f5295692fde289f99aa9701528dcde4c78b780f%2Fext%2Fphar%2Fphar.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=php%2Fphp-src)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[php](/php)
/
**[php-src](/php/php-src)**
Public

* [Notifications](/login?return_to=%2Fphp%2Fphp-src) You must be signed in to change notification settings
* [Fork
  7.8k](/login?return_to=%2Fphp%2Fphp-src)
* [Star
   38.5k](/login?return_to=%2Fphp%2Fphp-src)

* [Code](/php/php-src)
* [Issues
  742](/php/php-src/issues)
* [Pull requests
  559](/php/php-src/pulls)
* [Actions](/php/php-src/actions)
* [Security](/php/php-src/security)
* [Insights](/php/php-src/pulse)

Additional navigation options

* [Code](/php/php-src)
* [Issues](/php/php-src/issues)
* [Pull requests](/php/php-src/pulls)
* [Actions](/php/php-src/actions)
* [Security](/php/php-src/security)
* [Insights](/php/php-src/pulse)

## Files

 2f52956
## Breadcrumbs

1. [php-src](/php/php-src/tree/2f5295692fde289f99aa9701528dcde4c78b780f)
2. /[ext](/php/php-src/tree/2f5295692fde289f99aa9701528dcde4c78b780f/ext)
3. /[phar](/php/php-src/tree/2f5295692fde289f99aa9701528dcde4c78b780f/ext/phar)
/
# phar.c

 Blame  Blame
## Latest commit

## History

[History](/php/php-src/commits/2f5295692fde289f99aa9701528dcde4c78b780f/ext/phar/phar.c)3637 lines (3139 loc) · 104 KB 2f52956
## Breadcrumbs

1. [php-src](/php/php-src/tree/2f5295692fde289f99aa9701528dcde4c78b780f)
2. /[ext](/php/php-src/tree/2f5295692fde289f99aa9701528dcde4c78b780f/ext)
3. /[phar](/php/php-src/tree/2f5295692fde289f99aa9701528dcde4c78b780f/ext/phar)
/
# phar.c

Top
## File metadata and controls

* Code
* Blame

3637 lines (3139 loc) · 104 KB[Raw](https://github.com/php/php-src/raw/2f5295692fde289f99aa9701528dcde4c78b780f/ext/phar/phar.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\* +----------------------------------------------------------------------+ | phar php single-file executable PHP extension | +----------------------------------------------------------------------+ | Copyright (c) The PHP Group | +----------------------------------------------------------------------+ | This source file is subject to version 3.01 of the PHP license, | | that is bundled with this package in the file LICENSE, and is | | available through the world-wide-web at the following url: | | https://www.php.net/license/3\_01.txt | | If you did not receive a copy of the PHP license and are unable to | | obtain it through the world-wide-web, please send a note to | | license@php.net so we can mail you a copy immediately. | +----------------------------------------------------------------------+ | Authors: Gregory Beaver <cellog@php.net> | | Marcus Boerger <helly@php.net> | +----------------------------------------------------------------------+\*/
#define PHAR\_MAIN 1#include "phar\_internal.h"#include "SAPI.h"#include "func\_interceptors.h"#include "ext/standard/php\_var.h"
static void destroy\_phar\_data(zval \*zv);
ZEND\_DECLARE\_MODULE\_GLOBALS(phar)static zend\_string \*(\*phar\_save\_resolve\_path)(zend\_string \*filename);
/\*\* \* set's phar->is\_writeable based on the current INI value \*/static int phar\_set\_writeable\_bit(zval \*zv, void \*argument) /\* {{{ \*/{ bool keep = \*(bool \*)argument; phar\_archive\_data \*phar = (phar\_archive\_data \*)Z\_PTR\_P(zv);
 if (!phar->is\_data) { phar->is\_writeable = !keep; }
 return ZEND\_HASH\_APPLY\_KEEP;}/\* }}} \*/
/\* if the original value is 0 (disabled), then allow setting/unsetting at will. Otherwise only allow 1 (enabled), and error on disabling \*/ZEND\_INI\_MH(phar\_ini\_modify\_handler) /\* {{{ \*/{ bool old, ini;
 if (ZSTR\_LEN(entry->name) == sizeof("phar.readonly")-1) { old = PHAR\_G(readonly\_orig); } else { old = PHAR\_G(require\_hash\_orig); }
 ini = zend\_ini\_parse\_bool(new\_value);
 /\* do not allow unsetting in runtime \*/ if (stage == ZEND\_INI\_STAGE\_STARTUP) { if (ZSTR\_LEN(entry->name) == sizeof("phar.readonly")-1) { PHAR\_G(readonly\_orig) = ini; } else { PHAR\_G(require\_hash\_orig) = ini; } } else if (old && !ini) { return FAILURE; }
 if (ZSTR\_LEN(entry->name) == sizeof("phar.readonly")-1) { PHAR\_G(readonly) = ini; if (PHAR\_G(request\_init) && HT\_IS\_INITIALIZED(&PHAR\_G(phar\_fname\_map))) { zend\_hash\_apply\_with\_argument(&(PHAR\_G(phar\_fname\_map)), phar\_set\_writeable\_bit, (void \*)&ini); } } else { PHAR\_G(require\_hash) = ini; }
 return SUCCESS;}/\* }}}\*/
/\* this global stores the global cached pre-parsed manifests \*/HashTable cached\_phars;HashTable cached\_alias;
static void phar\_split\_cache\_list(void) /\* {{{ \*/{ char \*tmp; char \*key, \*lasts, \*end; char ds[2]; phar\_archive\_data \*phar; uint32\_t i = 0;
 if (!PHAR\_G(cache\_list) || !(PHAR\_G(cache\_list)[0])) { return; }
 ds[0] = DEFAULT\_DIR\_SEPARATOR; ds[1] = '\0'; tmp = estrdup(PHAR\_G(cache\_list));
 /\* fake request startup \*/ PHAR\_G(request\_init) = 1; zend\_init\_rsrc\_list(); EG(regular\_list).nNextFreeElement=1; /\* we don't want resource id 0 \*/
 PHAR\_G(has\_bz2) = zend\_hash\_str\_exists(&module\_registry, "bz2", sizeof("bz2")-1); PHAR\_G(has\_zlib) = zend\_hash\_str\_exists(&module\_registry, "zlib", sizeof("zlib")-1); /\* these two are dummies and will be destroyed later \*/ zend\_hash\_init(&cached\_phars, sizeof(phar\_archive\_data\*), zend\_get\_hash\_value, destroy\_phar\_data, 1); zend\_hash\_init(&cached\_alias, sizeof(phar\_archive\_data\*), zend\_get\_hash\_value, NULL, 1); /\* these two are real and will be copied over cached\_phars/cached\_alias later \*/ zend\_hash\_init(&(PHAR\_G(phar\_fname\_map)), sizeof(phar\_archive\_data\*), zend\_get\_hash\_value, destroy\_phar\_data, 1); zend\_hash\_init(&(PHAR\_G(phar\_alias\_map)), sizeof(phar\_archive\_data\*), zend\_get\_hash\_value, NULL, 1); PHAR\_G(manifest\_cached) = 1; PHAR\_G(persist) = 1;
 for (key = php\_strtok\_r(tmp, ds, &lasts); key; key = php\_strtok\_r(NULL, ds, &lasts)) { size\_t len; end = strchr(key, DEFAULT\_DIR\_SEPARATOR); if (end) { len = end - key; } else { len = strlen(key); }
 if (SUCCESS == phar\_open\_from\_filename(key, len, NULL, 0, 0, &phar, NULL)) { phar->phar\_pos = i++; php\_stream\_close(phar->fp); phar->fp = NULL; } else { PHAR\_G(persist) = 0; PHAR\_G(manifest\_cached) = 0; efree(tmp); zend\_hash\_destroy(&(PHAR\_G(phar\_fname\_map))); HT\_INVALIDATE(&PHAR\_G(phar\_fname\_map)); zend\_hash\_destroy(&(PHAR\_G(phar\_alias\_map))); HT\_INVALIDATE(&PHAR\_G(phar\_alias\_map)); zend\_hash\_destroy(&cached\_phars); zend\_hash\_destroy(&cached\_alias); zend\_hash\_graceful\_reverse\_destroy(&EG(regular\_list)); memset(&EG(regular\_list), 0, sizeof(HashTable)); /\* free cached manifests \*/ PHAR\_G(request\_init) = 0; return; } }
 PHAR\_G(persist) = 0; PHAR\_G(request\_init) = 0; /\* destroy dummy values from before \*/ zend\_hash\_destroy(&cached\_phars); zend\_hash\_destroy(&cached\_alias); cached\_phars = PHAR\_G(phar\_fname\_map); cached\_alias = PHAR\_G(phar\_alias\_map); HT\_INVALIDATE(&PHAR\_G(phar\_fname\_map)); HT\_INVALIDATE(&PHAR\_G(phar\_alias\_map)); zend\_hash\_graceful\_reverse\_destroy(&EG(regular\_list)); memset(&EG(regular\_list), 0, sizeof(HashTable)); efree(tmp);}/\* }}} \*/
ZEND\_INI\_MH(phar\_ini\_cache\_list) /\* {{{ \*/{ PHAR\_G(cache\_list) = ZSTR\_VAL(new\_value);
 if (stage == ZEND\_INI\_STAGE\_STARTUP) { phar\_split\_cache\_list(); }
 return SUCCESS;}/\* }}} \*/
PHP\_INI\_BEGIN() STD\_PHP\_INI\_BOOLEAN("phar.readonly", "1", PHP\_INI\_ALL, phar\_ini\_modify\_handler, readonly, zend\_phar\_globals, phar\_globals) STD\_PHP\_INI\_BOOLEAN("phar.require\_hash", "1", PHP\_INI\_ALL, phar\_ini\_modify\_handler, require\_hash, zend\_phar\_globals, phar\_globals) STD\_PHP\_INI\_ENTRY("phar.cache\_list", "", PHP\_INI\_SYSTEM, phar\_ini\_cache\_list, cache\_list, zend\_phar\_globals, phar\_globals)PHP\_INI\_END()
/\*\* \* When all uses of a phar have been concluded, this frees the manifest \* and the phar slot \*/void phar\_destroy\_phar\_data(phar\_archive\_data \*phar) /\* {{{ \*/{ if (phar->alias && phar->alias != phar->fname) { pefree(phar->alias, phar->is\_persistent); phar->alias = NULL; }
 if (phar->fname) { pefree(phar->fname, phar->is\_persistent); phar->fname = NULL; }
 if (phar->signature) { pefree(phar->signature, phar->is\_persistent); phar->signature = NULL; }
 if (HT\_IS\_INITIALIZED(&phar->manifest)) { zend\_hash\_destroy(&phar->manifest); HT\_INVALIDATE(&phar->manifest); }
 if (HT\_IS\_INITIALIZED(&phar->mounted\_dirs)) { zend\_hash\_destroy(&phar->mounted\_dirs); HT\_INVALIDATE(&phar->mounted\_dirs); }
 if (HT\_IS\_INITIALIZED(&phar->virtual\_dirs)) { zend\_hash\_destroy(&phar->virtual\_dirs); HT\_INVALIDATE(&phar->virtual\_dirs); }
 phar\_metadata\_tracker\_free(&phar->metadata\_tracker, phar->is\_persistent);
 if (phar->fp) { php\_stream\_close(phar->fp); phar->fp = 0; }
 if (phar->ufp) { php\_stream\_close(phar->ufp); phar->ufp = 0; }
 pefree(phar, phar->is\_persistent);}/\* }}}\*/
/\*\* \* Delete refcount and destruct if needed. On destruct return 1 else 0. \*/int phar\_archive\_delref(phar\_archive\_data \*phar) /\* {{{ \*/{ if (phar->is\_persistent) { return 0; }
 if (--phar->refcount < 0) { if (PHAR\_G(request\_done) || zend\_hash\_str\_del(&(PHAR\_G(phar\_fname\_map)), phar->fname, phar->fname\_len) != SUCCESS) { phar\_destroy\_phar\_data(phar); } return 1; } else if (!phar->refcount) { /\* invalidate phar cache \*/ PHAR\_G(last\_phar) = NULL; PHAR\_G(last\_phar\_name) = PHAR\_G(last\_alias) = NULL;
 if (phar->fp && (!(phar->flags & PHAR\_FILE\_COMPRESSION\_MASK) || !phar->alias)) { /\* close open file handle - allows removal or rename of the file on windows, which has greedy locking only close if the archive was not already compressed. If it was compressed, then the fp does not refer to the original file. We're also closing compressed files to save resources, but only if the archive isn't aliased. \*/ php\_stream\_close(phar->fp); phar->fp = NULL; }
 if (!zend\_hash\_num\_elements(&phar->manifest)) { /\* this is a new phar that has perhaps had an alias/metadata set, but has never been flushed \*/ if (zend\_hash\_str\_del(&(PHAR\_G(phar\_fname\_map)), phar->fname, phar->fname\_len) != SUCCESS) { phar\_destroy\_phar\_data(phar); } return 1; } } return 0;}/\* }}}\*/
/\*\* \* Destroy phar's in shutdown, here we don't care about aliases \*/static void destroy\_phar\_data\_only(zval \*zv) /\* {{{ \*/{ phar\_archive\_data \*phar\_data = (phar\_archive\_data \*) Z\_PTR\_P(zv);
 if (EG(exception) || --phar\_data->refcount < 0) { phar\_destroy\_phar\_data(phar\_data); }}/\* }}}\*/
/\*\* \* Delete aliases to phar's that got kicked out of the global table \*/static int phar\_unalias\_apply(zval \*zv, void \*argument) /\* {{{ \*/{ return Z\_PTR\_P(zv) == argument ? ZEND\_HASH\_APPLY\_REMOVE : ZEND\_HASH\_APPLY\_KEEP;}/\* }}} \*/
/\*\* \* Delete aliases to phar's that got kicked out of the global table \*/static int phar\_tmpclose\_apply(zval \*zv) /\* {{{ \*/{ phar\_entry\_info \*entry = (phar\_entry\_info \*) Z\_PTR\_P(zv);
 if (entry->fp\_type != PHAR\_TMP) { return ZEND\_HASH\_APPLY\_KEEP; }
 if (entry->fp && !entry->fp\_refcount) { php\_stream\_close(entry->fp); entry->fp = NULL; }
 return ZEND\_HASH\_APPLY\_KEEP;}/\* }}} \*/
/\*\* \* Filename map destructor \*/static void destroy\_phar\_data(zval \*zv) /\* {{{ \*/{ phar\_archive\_data \*phar\_data = (phar\_archive\_data \*)Z\_PTR\_P(zv);
 if (PHAR\_G(request\_ends)) { /\* first, iterate over the manifest and close all PHAR\_TMP entry fp handles, this prevents unnecessary unfreed stream resources \*/ zend\_hash\_apply(&(phar\_data->manifest), phar\_tmpclose\_apply); destroy\_phar\_data\_only(zv); return; }
 zend\_hash\_apply\_with\_argument(&(PHAR\_G(phar\_alias\_map)), phar\_unalias\_apply, phar\_data);
 if (--phar\_data->refcount < 0) { phar\_destroy\_phar\_data(phar\_data); }}/\* }}}\*/
/\*\* \* destructor for the manifest hash, frees each file's entry \*/void destroy\_phar\_manifest\_entry\_int(phar\_entry\_info \*entry) /\* {{{ \*/{
 if (entry->cfp) { php\_stream\_close(entry->cfp); entry->cfp = 0; }
 if (entry->fp) { php\_stream\_close(entry->fp); entry->fp = 0; }
 phar\_metadata\_tracker\_free(&entry->metadata\_tracker, entry->is\_persistent);
 pefree(entry->filename, entry->is\_persistent);
 if (entry->link) { pefree(entry->link, entry->is\_persistent); entry->link = 0; }
 if (entry->tmp) { pefree(entry->tmp, entry->is\_persistent); entry->tmp = 0; }}/\* }}} \*/
void destroy\_phar\_manifest\_entry(zval \*zv) /\* {{{ \*/{ phar\_entry\_info \*entry = Z\_PTR\_P(zv); destroy\_phar\_manifest\_entry\_int(entry); pefree(entry, entry->is\_persistent);}/\* }}} \*/
int phar\_entry\_delref(phar\_entry\_data \*idata) /\* {{{ \*/{ int ret = 0;
 if (idata->internal\_file && !idata->internal\_file->is\_persistent) { if (--idata->internal\_file->fp\_refcount < 0) { idata->internal\_file->fp\_refcount = 0; }
 if (idata->fp && idata->fp != idata->phar->fp && idata->fp != idata->phar->ufp && idata->fp != idata->internal\_file->fp) { php\_stream\_close(idata->fp); } /\* if phar\_get\_or\_create\_entry\_data returns a sub-directory, we have to free it \*/ if (idata->internal\_file->is\_temp\_dir) { destroy\_phar\_manifest\_entry\_int(idata->internal\_file); efree(idata->internal\_file); } }
 phar\_archive\_delref(idata->phar); efree(idata); return ret;}/\* }}} \*/
/\*\* \* Removes an entry, either by actually removing it or by marking it. \*/void phar\_entry\_remove(phar\_entry\_data \*idata, char \*\*error) /\* {{{ \*/{ phar\_archive\_data \*phar;
 phar = idata->phar;
 if (idata->internal\_file->fp\_refcount < 2) { if (idata->fp && idata->fp != idata->phar->fp && idata->fp != idata->phar->ufp && idata->fp != idata->internal\_file->fp) { php\_stream\_close(idata->fp); } zend\_hash\_str\_del(&idata->phar->manifest, idata->internal\_file->filename, idata->internal\_file->filename\_len); idata->phar->refcount--; efree(idata); } else { idata->internal\_file->is\_deleted = 1; phar\_entry\_delref(idata); }
 if (!phar->donotflush) { phar\_flush(phar, 0, 0, 0, error); }}/\* }}} \*/
#define MAPPHAR\_ALLOC\_FAIL(msg) \ if (fp) {\ php\_stream\_close(fp);\ }\ if (error) {\ spprintf(error, 0, msg, fname);\ }\ return FAILURE;
#define MAPPHAR\_FAIL(msg) \ efree(savebuf);\ if (mydata) {\ phar\_destroy\_phar\_data(mydata);\ }\ if (signature) {\ pefree(signature, PHAR\_G(persist));\ }\ MAPPHAR\_ALLOC\_FAIL(msg)
#ifdef WORDS\_BIGENDIAN# define PHAR\_GET\_32(buffer, var) \ var = ((((unsigned char\*)(buffer))[3]) << 24) \ | ((((unsigned char\*)(buffer))[2]) << 16) \ | ((((unsigned char\*)(buffer))[1]) << 8) \ | (((unsigned char\*)(buffer))[0]); \ (buffer) += 4# define PHAR\_GET\_16(buffer, var) \ var = ((((unsigned char\*)(buffer))[1]) << 8) \ | (((unsigned char\*)(buffer))[0]); \ (buffer) += 2#else# define PHAR\_GET\_32(buffer, var) \ memcpy(&var, buffer, sizeof(var)); \ buffer += 4# define PHAR\_GET\_16(buffer, var) \ var = \*(uint16\_t\*)(buffer); \ buffer += 2#endif#define PHAR\_ZIP\_16(var) ((uint16\_t)((((uint16\_t)var[0]) & 0xff) | \ (((uint16\_t)var[1]) & 0xff) << 8))#define PHAR\_ZIP\_32(var) ((uint32\_t)((((uint32\_t)var[0]) & 0xff) | \ (((uint32\_t)var[1]) & 0xff) << 8 | \ (((uint32\_t)var[2]) & 0xff) << 16 | \ (((uint32\_t)var[3]) & 0xff) << 24))
/\*\* \* Open an already loaded phar \*/int phar\_open\_parsed\_phar(char \*fname, size\_t fname\_len, char \*alias, size\_t alias\_len, bool is\_data, uint32\_t options, phar\_archive\_data\*\* pphar, char \*\*error) /\* {{{ \*/{ phar\_archive\_data \*phar;#ifdef PHP\_WIN32 char \*save\_fname; ALLOCA\_FLAG(fname\_use\_heap)#endif
 if (error) { \*error = NULL; }#ifdef PHP\_WIN32 save\_fname = fname; if (memchr(fname, '\\', fname\_len)) { fname = do\_alloca(fname\_len + 1, fname\_use\_heap); memcpy(fname, save\_fname, fname\_len); fname[fname\_len] = '\0'; phar\_unixify\_path\_separators(fname, fname\_len); }#endif if (SUCCESS == phar\_get\_archive(&phar, fname, fname\_len, alias, alias\_len, error) && ((alias && fname\_len == phar->fname\_len && !strncmp(fname, phar->fname, fname\_len)) || !alias) ) { phar\_entry\_info \*stub;#ifdef PHP\_WIN32 if (fname != save\_fname) { free\_alloca(fname, fname\_use\_heap); fname = save\_fname; }#endif /\* logic above is as follows: If an explicit alias was requested, ensure the filename passed in matches the phar's filename. If no alias was passed in, then it can match either and be valid \*/
 if (!is\_data) { /\* prevent any ".phar" without a stub getting through \*/ if (!phar->halt\_offset && !phar->is\_brandnew && (phar->is\_tar || phar->is\_zip)) { if (PHAR\_G(readonly) && NULL == (stub = zend\_hash\_str\_find\_ptr(&(phar->manifest), ".phar/stub.php", sizeof(".phar/stub.php")-1))) { if (error) { spprintf(error, 0, "'%s' is not a phar archive. Use PharData::\_\_construct() for a standard zip or tar archive", fname); } return FAILURE; } } }
 if (pphar) { \*pphar = phar; }
 return SUCCESS; } else {#ifdef PHP\_WIN32 if (fname != save\_fname) { free\_alloca(fname, fname\_use\_heap); fname = save\_fname; }#endif if (pphar) { \*pphar = NULL; }
 if (phar && error && !(options & REPORT\_ERRORS)) { efree(error); }
 return FAILURE; }}/\* }}}\*/
/\*\* \* Attempt to serialize the data. \* Callers are responsible for handling EG(exception) if one occurs. \*/void phar\_metadata\_tracker\_try\_ensure\_has\_serialized\_data(phar\_metadata\_tracker \*tracker, int persistent) /\* {{{ \*/{ php\_serialize\_data\_t metadata\_hash; smart\_str metadata\_str = {0}; if (tracker->str || Z\_ISUNDEF(tracker->val)) { /\* Already has serialized the value or there is no value \*/ return; } /\* Assert it should not be possible to create raw zvals in a persistent phar (i.e. from cache\_list) \*/ ZEND\_ASSERT(!persistent);
 PHP\_VAR\_SERIALIZE\_INIT(metadata\_hash); php\_var\_serialize(&metadata\_str, &tracker->val, &metadata\_hash); PHP\_VAR\_SERIALIZE\_DESTROY(metadata\_hash); if (!metadata\_str.s) { return; } tracker->str = metadata\_str.s;}/\* }}} \*/
/\*\* \* Parse out metadata when phar\_metadata\_tracker\_has\_data is true. \* \* Precondition: phar\_metadata\_tracker\_has\_data is true \*/int phar\_metadata\_tracker\_unserialize\_or\_copy(phar\_metadata\_tracker \*tracker, zval \*metadata, int persistent, HashTable \*unserialize\_options, const char\* method\_name) /\* {{{ \*/{ const bool has\_unserialize\_options = unserialize\_options != NULL && zend\_hash\_num\_elements(unserialize\_options) > 0; /\* It should be impossible to create a zval in a persistent phar/entry. \*/ ZEND\_ASSERT(!persistent || Z\_ISUNDEF(tracker->val));
 if (Z\_ISUNDEF(tracker->val) || has\_unserialize\_options) { if (EG(exception)) { /\* Because other parts of the phar code haven't been updated to check for exceptions after doing something that may throw, \* check for exceptions before potentially serializing/unserializing instead. \*/ return FAILURE; } /\* Persistent phars should always be unserialized. \*/ const char \*start; /\* Assert it should not be possible to create raw data in a persistent phar (i.e. from cache\_list) \*/
 /\* Precondition: This has serialized data, either from setMetadata or the phar file. \*/ ZEND\_ASSERT(tracker->str != NULL); ZVAL\_NULL(metadata); start = ZSTR\_VAL(tracker->str);
 php\_unserialize\_with\_options(metadata, start, ZSTR\_LEN(tracker->str), unserialize\_options, method\_name); if (EG(exception)) { zval\_ptr\_dtor(metadata); ZVAL\_UNDEF(metadata); return FAILURE; } return SUCCESS; } else { /\* TODO: what is the current/expected behavior when fetching an object set with setMetadata then getting it \* with getMetadata() and modifying a property? Previously, it was underdefined, and probably unimportant to support. \*/ ZVAL\_COPY(metadata, &tracker->val); }
 return SUCCESS;}/\* }}}\*/
/\*\* \* Check if this has any data, serialized or as a raw value. \*/bool phar\_metadata\_tracker\_has\_data(const phar\_metadata\_tracker \*tracker, int persistent) /\* {{{ \*/{ ZEND\_ASSERT(!persistent || Z\_ISUNDEF(tracker->val)); return !Z\_ISUNDEF(tracker->val) || tracker->str != NULL;}/\* }}} \*/
/\*\* \* Free memory used to track the metadata and set all fields to be null/undef. \*/void phar\_metadata\_tracker\_free(phar\_metadata\_tracker \*tracker, int persistent) /\* {{{ \*/{ /\* Free the string before the zval in case the zval's destructor modifies the metadata \*/ if (tracker->str) { zend\_string\_release(tracker->str); tracker->str = NULL; } if (!Z\_ISUNDEF(tracker->val)) { /\* Here, copy the original zval to a different pointer without incrementing the refcount in case something uses the original while it's being freed. \*/ zval zval\_copy;
 ZEND\_ASSERT(!persistent); ZVAL\_COPY\_VALUE(&zval\_copy, &tracker->val); ZVAL\_UNDEF(&tracker->val); zval\_ptr\_dtor(&zval\_copy); }}/\* }}} \*/
/\*\* \* Free memory used to track the metadata and set all fields to be null/undef. \*/void phar\_metadata\_tracker\_copy(phar\_metadata\_tracker \*dest, const phar\_metadata\_tracker \*source, int persistent) /\* {{{ \*/{ ZEND\_ASSERT(dest != source); phar\_metadata\_tracker\_free(dest, persistent);
 if (!Z\_ISUNDEF(source->val)) { ZEND\_ASSERT(!persistent); ZVAL\_COPY(&dest->val, &source->val); } if (source->str) { dest->str = zend\_string\_copy(source->str); }}/\* }}} \*/
/\*\* \* Copy constructor for a non-persistent clone. \*/void phar\_metadata\_tracker\_clone(phar\_metadata\_tracker \*tracker) /\* {{{ \*/{ Z\_TRY\_ADDREF\_P(&tracker->val); if (tracker->str) { /\* Duplicate the string, as the original may have been persistent. \*/ tracker->str = zend\_string\_dup(tracker->str, false); }}/\* }}} \*/
/\*\* \* Parse out metadata from the manifest for a single file, saving it into a string. \* \* Meta-data is in this format: \* [len32][data...] \* \* data is the serialized zval \*/void phar\_parse\_metadata\_lazy(const char \*buffer, phar\_metadata\_tracker \*tracker, uint32\_t zip\_metadata\_len, int persistent) /\* {{{ \*/{ phar\_metadata\_tracker\_free(tracker, persistent); if (zip\_metadata\_len) { /\* lazy init metadata \*/ tracker->str = zend\_string\_init(buffer, zip\_metadata\_len, persistent); }}/\* }}}\*/
/\*\* \* Size of fixed fields in the manifest. \* See: http://php.net/manual/en/phar.fileformat.phar.php \*/#define MANIFEST\_FIXED\_LEN 18
#define SAFE\_PHAR\_GET\_32(buffer, endbuffer, var) \ if (UNEXPECTED(buffer + 4 > endbuffer)) { \ MAPPHAR\_FAIL("internal corruption of phar \"%s\" (truncated manifest header)"); \ } \ PHAR\_GET\_32(buffer, var);
/\*\* \* Does not check for a previously opened phar in the cache. \* \* Parse a new one and add it to the cache, returning either SUCCESS or \* FAILURE, and setting pphar to the pointer to the manifest entry \* \* This is used by phar\_open\_from\_filename to process the manifest, but can be called \* directly. \*/static int phar\_parse\_pharfile(php\_stream \*fp, char \*fname, size\_t fname\_len, char \*alias, size\_t alias\_len, zend\_long halt\_offset, phar\_archive\_data\*\* pphar, uint32\_t compression, char \*\*error) /\* {{{ \*/{ char b32[4], \*buffer, \*endbuffer, \*savebuf; phar\_archive\_data \*mydata = NULL; phar\_entry\_info entry; uint32\_t manifest\_len, manifest\_count, manifest\_flags, manifest\_index, tmp\_len, sig\_flags; uint16\_t manifest\_ver; uint32\_t len; zend\_long offset; size\_t sig\_len; int register\_alias = 0, temp\_alias = 0; char \*signature = NULL; zend\_string \*str;
 if (pphar) { \*pphar = NULL; }
 if (error) { \*error = NULL; }
 /\* check for ?>\n and increment accordingly \*/ if (-1 == php\_stream\_seek(fp, halt\_offset, SEEK\_SET)) { MAPPHAR\_ALLOC\_FAIL("cannot seek to \_\_HALT\_COMPILER(); location in phar \"%s\"") }
 buffer = b32;
 if (3 != php\_stream\_read(fp, buffer, 3)) { MAPPHAR\_ALLOC\_FAIL("internal corruption of phar \"%s\" (truncated manifest at stub end)") }
 if ((\*buffer == ' ' || \*buffer == '\n') && \*(buffer + 1) == '?' && \*(buffer + 2) == '>') { int nextchar; halt\_offset += 3; if (EOF == (nextchar = php\_stream\_getc(fp))) { MAPPHAR\_ALLOC\_FAIL("internal corruption of phar \"%s\" (truncated manifest at stub end)") }
 if ((char) nextchar == '\r') { /\* if we have an \r we require an \n as well \*/ if (EOF == (nextchar = php\_stream\_getc(fp)) || (char)nextchar != '\n') { MAPPHAR\_ALLOC\_FAIL("internal corruption of phar \"%s\" (truncated manifest at stub end)") } ++halt\_offset; }
 if ((char) nextchar == '\n') { ++halt\_offset; } }
 /\* make sure we are at the right location to read the manifest \*/ if (-1 == php\_stream\_seek(fp, halt\_offset, SEEK\_SET)) { MAPPHAR\_ALLOC\_FAIL("cannot seek to \_\_HALT\_COMPILER(); location in phar \"%s\"") }
 /\* read in manifest \*/ buffer = b32;
 if (4 != php\_stream\_read(fp, buffer, 4)) { MAPPHAR\_ALLOC\_FAIL("internal corruption of phar \"%s\" (truncated manifest at manifest length)") }
 PHAR\_GET\_32(buffer, manifest\_len);
 if (manifest\_len > 1048576 \* 100) { /\* prevent serious memory issues by limiting manifest to at most 100 MB in length \*/ MAPPHAR\_ALLOC\_FAIL("manifest cannot be larger than 100 MB in phar \"%s\"") }
 buffer = (char \*)emalloc(manifest\_len); savebuf = buffer; endbuffer = buffer + manifest\_len;
 if (manifest\_len < MANIFEST\_FIXED\_LEN || manifest\_len != php\_stream\_read(fp, buffer, manifest\_len)) { MAPPHAR\_FAIL("internal corruption of phar \"%s\" (truncated manifest header)") }
 /\* extract the number of entries \*/ SAFE\_PHAR\_GET\_32(buffer, endbuffer, manifest\_count);
 if (manifest\_count == 0) { MAPPHAR\_FAIL("in phar \"%s\", manifest claims to have zero entries. Phars must have at least 1 entry"); }
 /\* extract API version, lowest nibble currently unused \*/ manifest\_ver = (((unsigned char)buffer[0]) << 8) + ((unsigned char)buffer[1]); buffer += 2;
 if ((manifest\_ver & PHAR\_API\_VER\_MASK) < PHAR\_API\_MIN\_READ) { efree(savebuf); php\_stream\_close(fp); if (error) { spprintf(error, 0, "phar \"%s\" is API version %1.u.%1.u.%1.u, and cannot be processed", fname, manifest\_ver >> 12, (manifest\_ver >> 8) & 0xF, (manifest\_ver >> 4) & 0x0F); } return FAILURE; }
 SAFE\_PHAR\_GET\_32(buffer, endbuffer, manifest\_flags);
 manifest\_flags &= ~PHAR\_HDR\_COMPRESSION\_MASK; manifest\_flags &= ~PHAR\_FILE\_COMPRESSION\_MASK; /\* remember whether this entire phar was compressed with gz/bzip2 \*/ manifest\_flags |= compression;
 /\* The lowest nibble contains the phar wide flags. The compression flags can \*/ /\* be ignored on reading because it is being generated anyways. \*/ if (manifest\_flags & PHAR\_HDR\_SIGNATURE) { char sig\_buf[8], \*sig\_ptr = sig\_buf; zend\_off\_t read\_len; size\_t end\_of\_phar;
 if (-1 == php\_stream\_seek(fp, -8, SEEK\_END) || (read\_len = php\_stream\_tell(fp)) < 20 || 8 != php\_stream\_read(fp, sig\_buf, 8) || memcmp(sig\_buf+4, "GBMB", 4)) { efree(savebuf); php\_stream\_close(fp); if (error) { spprintf(error, 0, "phar \"%s\" has a broken signature", fname); } return FAILURE; }
 PHAR\_GET\_32(sig\_ptr, sig\_flags);
 switch(sig\_flags) { case PHAR\_SIG\_OPENSSL\_SHA512: case PHAR\_SIG\_OPENSSL\_SHA256: case PHAR\_SIG\_OPENSSL: { uint32\_t signature\_len; char \*sig; zend\_off\_t whence;
 /\* we store the signature followed by the signature length \*/ if (-1 == php\_stream\_seek(fp, -12, SEEK\_CUR) || 4 != php\_stream\_read(fp, sig\_buf, 4)) { efree(savebuf); php\_stream\_close(fp); if (error) { spprintf(error, 0, "phar \"%s\" openssl signature length could not be read", fname); } return FAILURE; }
 sig\_ptr = sig\_buf; PHAR\_GET\_32(sig\_ptr, signature\_len); sig = (char \*) emalloc(signature\_len); whence = signature\_len + 4; whence = -whence;
 if (-1 == php\_stream\_seek(fp, whence, SEEK\_CUR) || !(end\_of\_phar = php\_stream\_tell(fp)) || signature\_len != php\_stream\_read(fp, sig, signature\_len)) { efree(savebuf); efree(sig); php\_stream\_close(fp); if (error) { spprintf(error, 0, "phar \"%s\" openssl signature could not be read", fname); } return FAILURE; }
 if (FAILURE == phar\_verify\_signature(fp, end\_of\_phar, sig\_flags, sig, signature\_len, fname, &signature, &sig\_len, error)) { efree(savebuf); efree(sig); php\_stream\_close(fp); if (error) { char \*save = \*error; spprintf(error, 0, "phar \"%s\" openssl signature could not be verified: %s", fname, \*error); efree(save); } return FAILURE; } efree(sig); } break; case PHAR\_SIG\_SHA512: { unsigned char digest[64];
 php\_stream\_seek(fp, -(8 + 64), SEEK\_END); read\_len = php\_stream\_tell(fp);
 if (php\_stream\_read(fp, (char\*)digest, sizeof(digest)) != sizeof(digest)) { efree(savebuf); php\_stream\_close(fp); if (error) { spprintf(error, 0, "phar \"%s\" has a broken signature", fname); } return FAILURE; }
 if (FAILURE == phar\_verify\_signature(fp, read\_len, PHAR\_SIG\_SHA512, (char \*)digest, 64, fname, &signature, &sig\_len, error)) { efree(savebuf); php\_stream\_close(fp); if (error) { char \*save = \*error; spprintf(error, 0, "phar \"%s\" SHA512 signature could not be verified: %s", fname, \*error); efree(save); } return FAILURE; } break; } case PHAR\_SIG\_SHA256: { unsigned char digest[32];
 php\_stream\_seek(fp, -(8 + 32), SEEK\_END); read\_len = php\_stream\_tell(fp);
 if (php\_stream\_read(fp, (char\*)digest, sizeof(digest)) != sizeof(digest)) { efree(savebuf); php\_stream\_close(fp); if (error) { spprintf(error, 0, "phar \"%s\" has a broken signature", fname); } return FAILURE; }
 if (FAILURE == phar\_verify\_signature(fp, read\_len, PHAR\_SIG\_SHA256, (char \*)digest, 32, fname, &signature, &sig\_len, error)) { efree(savebuf); php\_stream\_close(fp); if (error) { char \*save = \*error; spprintf(error, 0, "phar \"%s\" SHA256 signature could not be verified: %s", fname, \*error); efree(save); } return FAILURE; } break; } case PHAR\_SIG\_SHA1: { unsigned char digest[20];
 php\_stream\_seek(fp, -(8 + 20), SEEK\_END); read\_len = php\_stream\_tell(fp);
 if (php\_stream\_read(fp, (char\*)digest, sizeof(digest)) != sizeof(digest)) { efree(savebuf); php\_stream\_close(fp); if (error) { spprintf(error, 0, "phar \"%s\" has a broken signature", fname); } return FAILURE; }
 if (FAILURE == phar\_verify\_signature(fp, read\_len, PHAR\_SIG\_SHA1, (char \*)digest, 20, fname, &signature, &sig\_len, error)) { efree(savebuf); php\_stream\_close(fp); if (error) { char \*save = \*error; spprintf(error, 0, "phar \"%s\" SHA1 signature could not be verified: %s", fname, \*error); efree(save); } return FAILURE; } break; } case PHAR\_SIG\_MD5: { unsigned char digest[16];
 php\_stream\_seek(fp, -(8 + 16), SEEK\_END); read\_len = php\_stream\_tell(fp);
 if (php\_stream\_read(fp, (char\*)digest, sizeof(digest)) != sizeof(digest)) { efree(savebuf); php\_stream\_close(fp);[View remainder of file in raw view](https://github.com/php/php-src/raw/2f5295692fde289f99aa9701528dcde4c78b780f/ext/phar/phar.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

