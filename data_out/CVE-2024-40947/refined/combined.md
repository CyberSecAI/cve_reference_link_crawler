=== Content from git.kernel.org_08610cd8_20250110_222043.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | GUO Zihua <guozihua@huawei.com> | 2024-05-07 01:25:41 +0000 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-07-11 12:49:18 +0200 |
| commit | [28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88)) | |
| tree | [56b5ffc56e5cde842e7547d8f3b04dc910affc82](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88) | |
| parent | [cecffd9e3c46c0e93917caa50286e2c57a5ece2a](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=cecffd9e3c46c0e93917caa50286e2c57a5ece2a) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88&id2=cecffd9e3c46c0e93917caa50286e2c57a5ece2a)) | |
| download | [linux-28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88.tar.gz) | |

ima: Avoid blocking in RCU read-side critical sectioncommit 9a95c5bfbf02a0a7f5983280fe284a0ff0836c34 upstream.
A panic happens in ima\_match\_policy:
BUG: unable to handle kernel NULL pointer dereference at 0000000000000010
PGD 42f873067 P4D 0
Oops: 0000 [#1] SMP NOPTI
CPU: 5 PID: 1286325 Comm: kubeletmonit.sh
Kdump: loaded Tainted: P
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996),
BIOS 0.0.0 02/06/2015
RIP: 0010:ima\_match\_policy+0x84/0x450
Code: 49 89 fc 41 89 cf 31 ed 89 44 24 14 eb 1c 44 39
7b 18 74 26 41 83 ff 05 74 20 48 8b 1b 48 3b 1d
f2 b9 f4 00 0f 84 9c 01 00 00 <44> 85 73 10 74 ea
44 8b 6b 14 41 f6 c5 01 75 d4 41 f6 c5 02 74 0f
RSP: 0018:ff71570009e07a80 EFLAGS: 00010207
RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000200
RDX: ffffffffad8dc7c0 RSI: 0000000024924925 RDI: ff3e27850dea2000
RBP: 0000000000000000 R08: 0000000000000000 R09: ffffffffabfce739
R10: ff3e27810cc42400 R11: 0000000000000000 R12: ff3e2781825ef970
R13: 00000000ff3e2785 R14: 000000000000000c R15: 0000000000000001
FS: 00007f5195b51740(0000)
GS:ff3e278b12d40000(0000) knlGS:0000000000000000
CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000000000000010 CR3: 0000000626d24002 CR4: 0000000000361ee0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
ima\_get\_action+0x22/0x30
process\_measurement+0xb0/0x830
? page\_add\_file\_rmap+0x15/0x170
? alloc\_set\_pte+0x269/0x4c0
? prep\_new\_page+0x81/0x140
? simple\_xattr\_get+0x75/0xa0
? selinux\_file\_open+0x9d/0xf0
ima\_file\_check+0x64/0x90
path\_openat+0x571/0x1720
do\_filp\_open+0x9b/0x110
? page\_counter\_try\_charge+0x57/0xc0
? files\_cgroup\_alloc\_fd+0x38/0x60
? \_\_alloc\_fd+0xd4/0x250
? do\_sys\_open+0x1bd/0x250
do\_sys\_open+0x1bd/0x250
do\_syscall\_64+0x5d/0x1d0
entry\_SYSCALL\_64\_after\_hwframe+0x65/0xca
Commit c7423dbdbc9e ("ima: Handle -ESTALE returned by
ima\_filter\_rule\_match()") introduced call to ima\_lsm\_copy\_rule within a
RCU read-side critical section which contains kmalloc with GFP\_KERNEL.
This implies a possible sleep and violates limitations of RCU read-side
critical sections on non-PREEMPT systems.
Sleeping within RCU read-side critical section might cause
synchronize\_rcu() returning early and break RCU protection, allowing a
UAF to happen.
The root cause of this issue could be described as follows:
| Thread A | Thread B |
| |ima\_match\_policy |
| | rcu\_read\_lock |
|ima\_lsm\_update\_rule | |
| synchronize\_rcu | |
| | kmalloc(GFP\_KERNEL)|
| | sleep |
==> synchronize\_rcu returns early
| kfree(entry) | |
| | entry = entry->next|
==> UAF happens and entry now becomes NULL (or could be anything).
| | entry->action |
==> Accessing entry might cause panic.
To fix this issue, we are converting all kmalloc that is called within
RCU read-side critical section to use GFP\_ATOMIC.
Fixes: c7423dbdbc9e ("ima: Handle -ESTALE returned by ima\_filter\_rule\_match()")
Cc: stable@vger.kernel.org
Signed-off-by: GUO Zihua <guozihua@huawei.com>
Acked-by: John Johansen <john.johansen@canonical.com>
Reviewed-by: Mimi Zohar <zohar@linux.ibm.com>
Reviewed-by: Casey Schaufler <casey@schaufler-ca.com>
[PM: fixed missing comment, long lines, !CONFIG\_IMA\_LSM\_RULES case]
Signed-off-by: Paul Moore <paul@paul-moore.com>
Signed-off-by: Mimi Zohar <zohar@linux.ibm.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88)

| -rw-r--r-- | [include/linux/lsm\_hook\_defs.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/lsm_hook_defs.h?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88) | 2 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/linux/security.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/security.h?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/auditfilter.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/auditfilter.c?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/apparmor/audit.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/apparmor/audit.c?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88) | 6 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/apparmor/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/apparmor/include/audit.h?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/integrity/ima/ima.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/integrity/ima/ima.h?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/integrity/ima/ima\_policy.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/integrity/ima/ima_policy.c?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88) | 15 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/security.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/security.c?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88) | 6 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/selinux/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/selinux/include/audit.h?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/selinux/ss/services.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/selinux/ss/services.c?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/smack/smack\_lsm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/smack/smack_lsm.c?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88) | 4 | |  |  |  | | --- | --- | --- | |

11 files changed, 34 insertions, 22 deletions

| diff --git a/include/linux/lsm\_hook\_defs.h b/include/linux/lsm\_hook\_defs.hindex 489362b0cd8578..2923754c13bce6 100644--- a/[include/linux/lsm\_hook\_defs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/lsm_hook_defs.h?id=cecffd9e3c46c0e93917caa50286e2c57a5ece2a)+++ b/[include/linux/lsm\_hook\_defs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/lsm_hook_defs.h?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88)@@ -390,7 +390,7 @@ LSM\_HOOK(int, 0, key\_getsecurity, struct key \*key, char \*\*buffer)  #ifdef CONFIG\_AUDIT LSM\_HOOK(int, 0, audit\_rule\_init, u32 field, u32 op, char \*rulestr,- void \*\*lsmrule)+ void \*\*lsmrule, gfp\_t gfp) LSM\_HOOK(int, 0, audit\_rule\_known, struct audit\_krule \*krule) LSM\_HOOK(int, 0, audit\_rule\_match, u32 secid, u32 field, u32 op, void \*lsmrule) LSM\_HOOK(void, LSM\_RET\_VOID, audit\_rule\_free, void \*lsmrule)diff --git a/include/linux/security.h b/include/linux/security.hindex b50c7f56618905..4bd0f6fc553e7b 100644--- a/[include/linux/security.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/security.h?id=cecffd9e3c46c0e93917caa50286e2c57a5ece2a)+++ b/[include/linux/security.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/security.h?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88)@@ -1953,7 +1953,8 @@ static inline int security\_key\_getsecurity(struct key \*key, char \*\*\_buffer)  #ifdef CONFIG\_AUDIT #ifdef CONFIG\_SECURITY-int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*lsmrule);+int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*lsmrule,+ gfp\_t gfp); int security\_audit\_rule\_known(struct audit\_krule \*krule); int security\_audit\_rule\_match(u32 secid, u32 field, u32 op, void \*lsmrule); void security\_audit\_rule\_free(void \*lsmrule);@@ -1961,7 +1962,7 @@ void security\_audit\_rule\_free(void \*lsmrule); #else  static inline int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr,- void \*\*lsmrule)+ void \*\*lsmrule, gfp\_t gfp) { return 0; }diff --git a/kernel/auditfilter.c b/kernel/auditfilter.cindex 8317a37dea0bbd..685bccb20b6f05 100644--- a/[kernel/auditfilter.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/auditfilter.c?id=cecffd9e3c46c0e93917caa50286e2c57a5ece2a)+++ b/[kernel/auditfilter.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/auditfilter.c?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88)@@ -529,7 +529,8 @@ static struct audit\_entry \*audit\_data\_to\_entry(struct audit\_rule\_data \*data, entry->rule.buflen += f\_val; f->lsm\_str = str; err = security\_audit\_rule\_init(f->type, f->op, str,- (void \*\*)&f->lsm\_rule);+ (void \*\*)&f->lsm\_rule,+ GFP\_KERNEL); /\* Keep currently invalid fields around in case they \* become valid after a policy reload. \*/ if (err == -EINVAL) {@@ -799,7 +800,7 @@ static inline int audit\_dupe\_lsm\_field(struct audit\_field \*df,  /\* our own (refreshed) copy of lsm\_rule \*/ ret = security\_audit\_rule\_init(df->type, df->op, df->lsm\_str,- (void \*\*)&df->lsm\_rule);+ (void \*\*)&df->lsm\_rule, GFP\_KERNEL); /\* Keep currently invalid fields around in case they \* become valid after a policy reload. \*/ if (ret == -EINVAL) {diff --git a/security/apparmor/audit.c b/security/apparmor/audit.cindex 6933cb2f679b0b..fa2d48250a4f58 100644--- a/[security/apparmor/audit.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/apparmor/audit.c?id=cecffd9e3c46c0e93917caa50286e2c57a5ece2a)+++ b/[security/apparmor/audit.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/apparmor/audit.c?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88)@@ -217,7 +217,7 @@ void aa\_audit\_rule\_free(void \*vrule) } } -int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule)+int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule, gfp\_t gfp) { struct aa\_audit\_rule \*rule; @@ -230,14 +230,14 @@ int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule) return -EINVAL; } - rule = kzalloc(sizeof(struct aa\_audit\_rule), GFP\_KERNEL);+ rule = kzalloc(sizeof(struct aa\_audit\_rule), gfp);  if (!rule) return -ENOMEM;  /\* Currently rules are treated as coming from the root ns \*/ rule->label = aa\_label\_parse(&root\_ns->unconfined->label, rulestr,- GFP\_KERNEL, true, false);+ gfp, true, false); if (IS\_ERR(rule->label)) { int err = PTR\_ERR(rule->label); aa\_audit\_rule\_free(rule);diff --git a/security/apparmor/include/audit.h b/security/apparmor/include/audit.hindex 42d701fec5a6d9..6e12ab5b30aed7 100644--- a/[security/apparmor/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/apparmor/include/audit.h?id=cecffd9e3c46c0e93917caa50286e2c57a5ece2a)+++ b/[security/apparmor/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/apparmor/include/audit.h?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88)@@ -193,7 +193,7 @@ static inline int complain\_error(int error) }  void aa\_audit\_rule\_free(void \*vrule);-int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule);+int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule, gfp\_t gfp); int aa\_audit\_rule\_known(struct audit\_krule \*rule); int aa\_audit\_rule\_match(u32 sid, u32 field, u32 op, void \*vrule); diff --git a/security/integrity/ima/ima.h b/security/integrity/ima/ima.hindex c29db699c996e5..07a4586e129c80 100644--- a/[security/integrity/ima/ima.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/integrity/ima/ima.h?id=cecffd9e3c46c0e93917caa50286e2c57a5ece2a)+++ b/[security/integrity/ima/ima.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/integrity/ima/ima.h?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88)@@ -430,7 +430,7 @@ static inline void ima\_free\_modsig(struct modsig \*modsig) #else  static inline int ima\_filter\_rule\_init(u32 field, u32 op, char \*rulestr,- void \*\*lsmrule)+ void \*\*lsmrule, gfp\_t gfp) { return -EINVAL; }diff --git a/security/integrity/ima/ima\_policy.c b/security/integrity/ima/ima\_policy.cindex f6906261775462..f3f46c6186c081 100644--- a/[security/integrity/ima/ima\_policy.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/integrity/ima/ima_policy.c?id=cecffd9e3c46c0e93917caa50286e2c57a5ece2a)+++ b/[security/integrity/ima/ima\_policy.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/integrity/ima/ima_policy.c?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88)@@ -401,7 +401,8 @@ static void ima\_free\_rule(struct ima\_rule\_entry \*entry) kfree(entry); } -static struct ima\_rule\_entry \*ima\_lsm\_copy\_rule(struct ima\_rule\_entry \*entry)+static struct ima\_rule\_entry \*ima\_lsm\_copy\_rule(struct ima\_rule\_entry \*entry,+ gfp\_t gfp) { struct ima\_rule\_entry \*nentry; int i;@@ -410,7 +411,7 @@ static struct ima\_rule\_entry \*ima\_lsm\_copy\_rule(struct ima\_rule\_entry \*entry) \* Immutable elements are copied over as pointers and data; only \* lsm rules can change \*/- nentry = kmemdup(entry, sizeof(\*nentry), GFP\_KERNEL);+ nentry = kmemdup(entry, sizeof(\*nentry), gfp); if (!nentry) return NULL; @@ -425,7 +426,8 @@ static struct ima\_rule\_entry \*ima\_lsm\_copy\_rule(struct ima\_rule\_entry \*entry)  ima\_filter\_rule\_init(nentry->lsm[i].type, Audit\_equal, nentry->lsm[i].args\_p,- &nentry->lsm[i].rule);+ &nentry->lsm[i].rule,+ gfp); if (!nentry->lsm[i].rule) pr\_warn("rule for LSM \'%s\' is undefined\n", nentry->lsm[i].args\_p);@@ -438,7 +440,7 @@ static int ima\_lsm\_update\_rule(struct ima\_rule\_entry \*entry) int i; struct ima\_rule\_entry \*nentry; - nentry = ima\_lsm\_copy\_rule(entry);+ nentry = ima\_lsm\_copy\_rule(entry, GFP\_KERNEL); if (!nentry) return -ENOMEM; @@ -664,7 +666,7 @@ retry: }  if (rc == -ESTALE && !rule\_reinitialized) {- lsm\_rule = ima\_lsm\_copy\_rule(rule);+ lsm\_rule = ima\_lsm\_copy\_rule(rule, GFP\_ATOMIC); if (lsm\_rule) { rule\_reinitialized = true; goto retry;@@ -1140,7 +1142,8 @@ static int ima\_lsm\_rule\_init(struct ima\_rule\_entry \*entry, entry->lsm[lsm\_rule].type = audit\_type; result = ima\_filter\_rule\_init(entry->lsm[lsm\_rule].type, Audit\_equal, entry->lsm[lsm\_rule].args\_p,- &entry->lsm[lsm\_rule].rule);+ &entry->lsm[lsm\_rule].rule,+ GFP\_KERNEL); if (!entry->lsm[lsm\_rule].rule) { pr\_warn("rule for LSM \'%s\' is undefined\n", entry->lsm[lsm\_rule].args\_p);diff --git a/security/security.c b/security/security.cindex 407b51719f7976..dd26f21b2244b4 100644--- a/[security/security.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/security.c?id=cecffd9e3c46c0e93917caa50286e2c57a5ece2a)+++ b/[security/security.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/security.c?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88)@@ -5116,15 +5116,17 @@ int security\_key\_getsecurity(struct key \*key, char \*\*buffer) \* @op: rule operator \* @rulestr: rule context \* @lsmrule: receive buffer for audit rule struct+ \* @gfp: GFP flag used for kmalloc \* \* Allocate and initialize an LSM audit rule structure. \* \* Return: Return 0 if @lsmrule has been successfully set, -EINVAL in case of \* an invalid rule. \*/-int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*lsmrule)+int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*lsmrule,+ gfp\_t gfp) {- return call\_int\_hook(audit\_rule\_init, 0, field, op, rulestr, lsmrule);+ return call\_int\_hook(audit\_rule\_init, 0, field, op, rulestr, lsmrule, gfp); }  /\*\*diff --git a/security/selinux/include/audit.h b/security/selinux/include/audit.hindex d5495134a5b9e8..1d3cf45d4550ed 100644--- a/[security/selinux/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/selinux/include/audit.h?id=cecffd9e3c46c0e93917caa50286e2c57a5ece2a)+++ b/[security/selinux/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/selinux/include/audit.h?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88)@@ -21,12 +21,14 @@ \* @op: the operator the rule uses \* @rulestr: the text "target" of the rule \* @rule: pointer to the new rule structure returned via this+ \* @gfp: GFP flag used for kmalloc \* \* Returns 0 if successful, -errno if not. On success, the rule structure \* will be allocated internally. The caller must free this structure with \* selinux\_audit\_rule\_free() after use. \*/-int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*rule);+int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*rule,+ gfp\_t gfp);  /\*\* \* selinux\_audit\_rule\_free - free an selinux audit rule structure.diff --git a/security/selinux/ss/services.c b/security/selinux/ss/services.cindex 1eeffc66ea7d7a..379ac7b5c7098c 100644--- a/[security/selinux/ss/services.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/selinux/ss/services.c?id=cecffd9e3c46c0e93917caa50286e2c57a5ece2a)+++ b/[security/selinux/ss/services.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/selinux/ss/services.c?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88)@@ -3497,7 +3497,8 @@ void selinux\_audit\_rule\_free(void \*vrule) } } -int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule)+int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule,+ gfp\_t gfp) { struct selinux\_state \*state = &selinux\_state; struct selinux\_policy \*policy;@@ -3538,7 +3539,7 @@ int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule) return -EINVAL; } - tmprule = kzalloc(sizeof(struct selinux\_audit\_rule), GFP\_KERNEL);+ tmprule = kzalloc(sizeof(struct selinux\_audit\_rule), gfp); if (!tmprule) return -ENOMEM; context\_init(&tmprule->au\_ctxt);diff --git a/security/smack/smack\_lsm.c b/security/smack/smack\_lsm.cindex e1e297deb02e6a..49d9da878ac61a 100644--- a/[security/smack/smack\_lsm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/smack/smack_lsm.c?id=cecffd9e3c46c0e93917caa50286e2c57a5ece2a)+++ b/[security/smack/smack\_lsm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/smack/smack_lsm.c?id=28d0ecc52f6c927d0e9ba70a4f2c1ea15453ee88)@@ -4616,11 +4616,13 @@ static int smack\_post\_notification(const struct cred \*w\_cred, \* @op: required testing operator (=, !=, >, <, ...) \* @rulestr: smack label to be audited \* @vrule: pointer to save our own audit rule representation+ \* @gfp: type of the memory for the allocation \* \* Prepare to audit cases where (@field @op @rulestr) is true. \* The label to be audited is created if necessay. \*/-static int smack\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule)+static int smack\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule,+ gfp\_t gfp) { struct smack\_known \*skp; char \*\*rule = (char \*\*)vrule; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 22:19:20 +0000



=== Content from git.kernel.org_bfff5373_20250110_222045.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=a38e02265c681b51997a264aaf743095e2ee400a)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a38e02265c681b51997a264aaf743095e2ee400a)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a38e02265c681b51997a264aaf743095e2ee400a)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a38e02265c681b51997a264aaf743095e2ee400a)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | GUO Zihua <guozihua@huawei.com> | 2024-05-07 01:25:41 +0000 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-07-18 13:07:34 +0200 |
| commit | [a38e02265c681b51997a264aaf743095e2ee400a](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a38e02265c681b51997a264aaf743095e2ee400a) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=a38e02265c681b51997a264aaf743095e2ee400a)) | |
| tree | [d37d321c7a88349282b564428f05fb79dc501cb8](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a38e02265c681b51997a264aaf743095e2ee400a) | |
| parent | [0edae06b4c227bcfaf3ce21208d49191e1009d3b](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=0edae06b4c227bcfaf3ce21208d49191e1009d3b) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a38e02265c681b51997a264aaf743095e2ee400a&id2=0edae06b4c227bcfaf3ce21208d49191e1009d3b)) | |
| download | [linux-a38e02265c681b51997a264aaf743095e2ee400a.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-a38e02265c681b51997a264aaf743095e2ee400a.tar.gz) | |

ima: Avoid blocking in RCU read-side critical sectioncommit 9a95c5bfbf02a0a7f5983280fe284a0ff0836c34 upstream.
A panic happens in ima\_match\_policy:
BUG: unable to handle kernel NULL pointer dereference at 0000000000000010
PGD 42f873067 P4D 0
Oops: 0000 [#1] SMP NOPTI
CPU: 5 PID: 1286325 Comm: kubeletmonit.sh
Kdump: loaded Tainted: P
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996),
BIOS 0.0.0 02/06/2015
RIP: 0010:ima\_match\_policy+0x84/0x450
Code: 49 89 fc 41 89 cf 31 ed 89 44 24 14 eb 1c 44 39
7b 18 74 26 41 83 ff 05 74 20 48 8b 1b 48 3b 1d
f2 b9 f4 00 0f 84 9c 01 00 00 <44> 85 73 10 74 ea
44 8b 6b 14 41 f6 c5 01 75 d4 41 f6 c5 02 74 0f
RSP: 0018:ff71570009e07a80 EFLAGS: 00010207
RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000200
RDX: ffffffffad8dc7c0 RSI: 0000000024924925 RDI: ff3e27850dea2000
RBP: 0000000000000000 R08: 0000000000000000 R09: ffffffffabfce739
R10: ff3e27810cc42400 R11: 0000000000000000 R12: ff3e2781825ef970
R13: 00000000ff3e2785 R14: 000000000000000c R15: 0000000000000001
FS: 00007f5195b51740(0000)
GS:ff3e278b12d40000(0000) knlGS:0000000000000000
CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000000000000010 CR3: 0000000626d24002 CR4: 0000000000361ee0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
ima\_get\_action+0x22/0x30
process\_measurement+0xb0/0x830
? page\_add\_file\_rmap+0x15/0x170
? alloc\_set\_pte+0x269/0x4c0
? prep\_new\_page+0x81/0x140
? simple\_xattr\_get+0x75/0xa0
? selinux\_file\_open+0x9d/0xf0
ima\_file\_check+0x64/0x90
path\_openat+0x571/0x1720
do\_filp\_open+0x9b/0x110
? page\_counter\_try\_charge+0x57/0xc0
? files\_cgroup\_alloc\_fd+0x38/0x60
? \_\_alloc\_fd+0xd4/0x250
? do\_sys\_open+0x1bd/0x250
do\_sys\_open+0x1bd/0x250
do\_syscall\_64+0x5d/0x1d0
entry\_SYSCALL\_64\_after\_hwframe+0x65/0xca
Commit c7423dbdbc9e ("ima: Handle -ESTALE returned by
ima\_filter\_rule\_match()") introduced call to ima\_lsm\_copy\_rule within a
RCU read-side critical section which contains kmalloc with GFP\_KERNEL.
This implies a possible sleep and violates limitations of RCU read-side
critical sections on non-PREEMPT systems.
Sleeping within RCU read-side critical section might cause
synchronize\_rcu() returning early and break RCU protection, allowing a
UAF to happen.
The root cause of this issue could be described as follows:
| Thread A | Thread B |
| |ima\_match\_policy |
| | rcu\_read\_lock |
|ima\_lsm\_update\_rule | |
| synchronize\_rcu | |
| | kmalloc(GFP\_KERNEL)|
| | sleep |
==> synchronize\_rcu returns early
| kfree(entry) | |
| | entry = entry->next|
==> UAF happens and entry now becomes NULL (or could be anything).
| | entry->action |
==> Accessing entry might cause panic.
To fix this issue, we are converting all kmalloc that is called within
RCU read-side critical section to use GFP\_ATOMIC.
Fixes: c7423dbdbc9e ("ima: Handle -ESTALE returned by ima\_filter\_rule\_match()")
Cc: stable@vger.kernel.org
Signed-off-by: GUO Zihua <guozihua@huawei.com>
Acked-by: John Johansen <john.johansen@canonical.com>
Reviewed-by: Mimi Zohar <zohar@linux.ibm.com>
Reviewed-by: Casey Schaufler <casey@schaufler-ca.com>
[PM: fixed missing comment, long lines, !CONFIG\_IMA\_LSM\_RULES case]
Signed-off-by: Paul Moore <paul@paul-moore.com>
Signed-off-by: Roberto Sassu <roberto.sassu@huawei.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a38e02265c681b51997a264aaf743095e2ee400a)

| -rw-r--r-- | [include/linux/lsm\_hook\_defs.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/lsm_hook_defs.h?id=a38e02265c681b51997a264aaf743095e2ee400a) | 2 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/linux/security.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/security.h?id=a38e02265c681b51997a264aaf743095e2ee400a) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/auditfilter.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/auditfilter.c?id=a38e02265c681b51997a264aaf743095e2ee400a) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/apparmor/audit.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/apparmor/audit.c?id=a38e02265c681b51997a264aaf743095e2ee400a) | 6 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/apparmor/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/apparmor/include/audit.h?id=a38e02265c681b51997a264aaf743095e2ee400a) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/integrity/ima/ima.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/integrity/ima/ima.h?id=a38e02265c681b51997a264aaf743095e2ee400a) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/integrity/ima/ima\_policy.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/integrity/ima/ima_policy.c?id=a38e02265c681b51997a264aaf743095e2ee400a) | 15 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/security.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/security.c?id=a38e02265c681b51997a264aaf743095e2ee400a) | 6 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/selinux/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/selinux/include/audit.h?id=a38e02265c681b51997a264aaf743095e2ee400a) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/selinux/ss/services.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/selinux/ss/services.c?id=a38e02265c681b51997a264aaf743095e2ee400a) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/smack/smack\_lsm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/smack/smack_lsm.c?id=a38e02265c681b51997a264aaf743095e2ee400a) | 4 | |  |  |  | | --- | --- | --- | |

11 files changed, 34 insertions, 22 deletions

| diff --git a/include/linux/lsm\_hook\_defs.h b/include/linux/lsm\_hook\_defs.hindex af2fa1134b506b..2ef89b872716e0 100644--- a/[include/linux/lsm\_hook\_defs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/lsm_hook_defs.h?id=0edae06b4c227bcfaf3ce21208d49191e1009d3b)+++ b/[include/linux/lsm\_hook\_defs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/lsm_hook_defs.h?id=a38e02265c681b51997a264aaf743095e2ee400a)@@ -379,7 +379,7 @@ LSM\_HOOK(int, 0, key\_getsecurity, struct key \*key, char \*\*\_buffer)  #ifdef CONFIG\_AUDIT LSM\_HOOK(int, 0, audit\_rule\_init, u32 field, u32 op, char \*rulestr,- void \*\*lsmrule)+ void \*\*lsmrule, gfp\_t gfp) LSM\_HOOK(int, 0, audit\_rule\_known, struct audit\_krule \*krule) LSM\_HOOK(int, 0, audit\_rule\_match, u32 secid, u32 field, u32 op, void \*lsmrule) LSM\_HOOK(void, LSM\_RET\_VOID, audit\_rule\_free, void \*lsmrule)diff --git a/include/linux/security.h b/include/linux/security.hindex e844834db69867..946fa58eb05a47 100644--- a/[include/linux/security.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/security.h?id=0edae06b4c227bcfaf3ce21208d49191e1009d3b)+++ b/[include/linux/security.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/security.h?id=a38e02265c681b51997a264aaf743095e2ee400a)@@ -1896,7 +1896,8 @@ static inline int security\_key\_getsecurity(struct key \*key, char \*\*\_buffer)  #ifdef CONFIG\_AUDIT #ifdef CONFIG\_SECURITY-int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*lsmrule);+int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*lsmrule,+ gfp\_t gfp); int security\_audit\_rule\_known(struct audit\_krule \*krule); int security\_audit\_rule\_match(u32 secid, u32 field, u32 op, void \*lsmrule); void security\_audit\_rule\_free(void \*lsmrule);@@ -1904,7 +1905,7 @@ void security\_audit\_rule\_free(void \*lsmrule); #else  static inline int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr,- void \*\*lsmrule)+ void \*\*lsmrule, gfp\_t gfp) { return 0; }diff --git a/kernel/auditfilter.c b/kernel/auditfilter.cindex db2c6b59dfc336..9d0e63b64ef88d 100644--- a/[kernel/auditfilter.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/auditfilter.c?id=0edae06b4c227bcfaf3ce21208d49191e1009d3b)+++ b/[kernel/auditfilter.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/auditfilter.c?id=a38e02265c681b51997a264aaf743095e2ee400a)@@ -521,7 +521,8 @@ static struct audit\_entry \*audit\_data\_to\_entry(struct audit\_rule\_data \*data, entry->rule.buflen += f\_val; f->lsm\_str = str; err = security\_audit\_rule\_init(f->type, f->op, str,- (void \*\*)&f->lsm\_rule);+ (void \*\*)&f->lsm\_rule,+ GFP\_KERNEL); /\* Keep currently invalid fields around in case they \* become valid after a policy reload. \*/ if (err == -EINVAL) {@@ -790,7 +791,7 @@ static inline int audit\_dupe\_lsm\_field(struct audit\_field \*df,  /\* our own (refreshed) copy of lsm\_rule \*/ ret = security\_audit\_rule\_init(df->type, df->op, df->lsm\_str,- (void \*\*)&df->lsm\_rule);+ (void \*\*)&df->lsm\_rule, GFP\_KERNEL); /\* Keep currently invalid fields around in case they \* become valid after a policy reload. \*/ if (ret == -EINVAL) {diff --git a/security/apparmor/audit.c b/security/apparmor/audit.cindex 704b0c895605a7..963df28584eed7 100644--- a/[security/apparmor/audit.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/apparmor/audit.c?id=0edae06b4c227bcfaf3ce21208d49191e1009d3b)+++ b/[security/apparmor/audit.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/apparmor/audit.c?id=a38e02265c681b51997a264aaf743095e2ee400a)@@ -173,7 +173,7 @@ void aa\_audit\_rule\_free(void \*vrule) } } -int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule)+int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule, gfp\_t gfp) { struct aa\_audit\_rule \*rule; @@ -186,14 +186,14 @@ int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule) return -EINVAL; } - rule = kzalloc(sizeof(struct aa\_audit\_rule), GFP\_KERNEL);+ rule = kzalloc(sizeof(struct aa\_audit\_rule), gfp);  if (!rule) return -ENOMEM;  /\* Currently rules are treated as coming from the root ns \*/ rule->label = aa\_label\_parse(&root\_ns->unconfined->label, rulestr,- GFP\_KERNEL, true, false);+ gfp, true, false); if (IS\_ERR(rule->label)) { int err = PTR\_ERR(rule->label); aa\_audit\_rule\_free(rule);diff --git a/security/apparmor/include/audit.h b/security/apparmor/include/audit.hindex 18519a4eb67e3c..f325f1bef8d6da 100644--- a/[security/apparmor/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/apparmor/include/audit.h?id=0edae06b4c227bcfaf3ce21208d49191e1009d3b)+++ b/[security/apparmor/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/apparmor/include/audit.h?id=a38e02265c681b51997a264aaf743095e2ee400a)@@ -186,7 +186,7 @@ static inline int complain\_error(int error) }  void aa\_audit\_rule\_free(void \*vrule);-int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule);+int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule, gfp\_t gfp); int aa\_audit\_rule\_known(struct audit\_krule \*rule); int aa\_audit\_rule\_match(u32 sid, u32 field, u32 op, void \*vrule); diff --git a/security/integrity/ima/ima.h b/security/integrity/ima/ima.hindex 0afe413dda683a..f9095e4f619902 100644--- a/[security/integrity/ima/ima.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/integrity/ima/ima.h?id=0edae06b4c227bcfaf3ce21208d49191e1009d3b)+++ b/[security/integrity/ima/ima.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/integrity/ima/ima.h?id=a38e02265c681b51997a264aaf743095e2ee400a)@@ -428,7 +428,7 @@ static inline void ima\_free\_modsig(struct modsig \*modsig) #else  static inline int ima\_filter\_rule\_init(u32 field, u32 op, char \*rulestr,- void \*\*lsmrule)+ void \*\*lsmrule, gfp\_t gfp) { return -EINVAL; }diff --git a/security/integrity/ima/ima\_policy.c b/security/integrity/ima/ima\_policy.cindex 7e41917e1f767a..6beef8ce311e08 100644--- a/[security/integrity/ima/ima\_policy.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/integrity/ima/ima_policy.c?id=0edae06b4c227bcfaf3ce21208d49191e1009d3b)+++ b/[security/integrity/ima/ima\_policy.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/integrity/ima/ima_policy.c?id=a38e02265c681b51997a264aaf743095e2ee400a)@@ -370,7 +370,8 @@ static void ima\_free\_rule(struct ima\_rule\_entry \*entry) kfree(entry); } -static struct ima\_rule\_entry \*ima\_lsm\_copy\_rule(struct ima\_rule\_entry \*entry)+static struct ima\_rule\_entry \*ima\_lsm\_copy\_rule(struct ima\_rule\_entry \*entry,+ gfp\_t gfp) { struct ima\_rule\_entry \*nentry; int i;@@ -379,7 +380,7 @@ static struct ima\_rule\_entry \*ima\_lsm\_copy\_rule(struct ima\_rule\_entry \*entry) \* Immutable elements are copied over as pointers and data; only \* lsm rules can change \*/- nentry = kmemdup(entry, sizeof(\*nentry), GFP\_KERNEL);+ nentry = kmemdup(entry, sizeof(\*nentry), gfp); if (!nentry) return NULL; @@ -394,7 +395,8 @@ static struct ima\_rule\_entry \*ima\_lsm\_copy\_rule(struct ima\_rule\_entry \*entry)  ima\_filter\_rule\_init(nentry->lsm[i].type, Audit\_equal, nentry->lsm[i].args\_p,- &nentry->lsm[i].rule);+ &nentry->lsm[i].rule,+ gfp); if (!nentry->lsm[i].rule) pr\_warn("rule for LSM \'%s\' is undefined\n", nentry->lsm[i].args\_p);@@ -407,7 +409,7 @@ static int ima\_lsm\_update\_rule(struct ima\_rule\_entry \*entry) int i; struct ima\_rule\_entry \*nentry; - nentry = ima\_lsm\_copy\_rule(entry);+ nentry = ima\_lsm\_copy\_rule(entry, GFP\_KERNEL); if (!nentry) return -ENOMEM; @@ -618,7 +620,7 @@ retry: }  if (rc == -ESTALE && !rule\_reinitialized) {- lsm\_rule = ima\_lsm\_copy\_rule(rule);+ lsm\_rule = ima\_lsm\_copy\_rule(rule, GFP\_ATOMIC); if (lsm\_rule) { rule\_reinitialized = true; goto retry;@@ -1080,7 +1082,8 @@ static int ima\_lsm\_rule\_init(struct ima\_rule\_entry \*entry, entry->lsm[lsm\_rule].type = audit\_type; result = ima\_filter\_rule\_init(entry->lsm[lsm\_rule].type, Audit\_equal, entry->lsm[lsm\_rule].args\_p,- &entry->lsm[lsm\_rule].rule);+ &entry->lsm[lsm\_rule].rule,+ GFP\_KERNEL); if (!entry->lsm[lsm\_rule].rule) { pr\_warn("rule for LSM \'%s\' is undefined\n", entry->lsm[lsm\_rule].args\_p);diff --git a/security/security.c b/security/security.cindex 33864d067f7e75..1ed387c4773018 100644--- a/[security/security.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/security.c?id=0edae06b4c227bcfaf3ce21208d49191e1009d3b)+++ b/[security/security.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/security.c?id=a38e02265c681b51997a264aaf743095e2ee400a)@@ -2587,9 +2587,11 @@ int security\_key\_getsecurity(struct key \*key, char \*\*\_buffer)  #ifdef CONFIG\_AUDIT -int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*lsmrule)+int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*lsmrule,+ gfp\_t gfp) {- return call\_int\_hook(audit\_rule\_init, 0, field, op, rulestr, lsmrule);+ return call\_int\_hook(audit\_rule\_init, 0, field, op, rulestr, lsmrule,+ gfp); }  int security\_audit\_rule\_known(struct audit\_krule \*krule)diff --git a/security/selinux/include/audit.h b/security/selinux/include/audit.hindex 073a3d34a0d217..72af85ff96a483 100644--- a/[security/selinux/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/selinux/include/audit.h?id=0edae06b4c227bcfaf3ce21208d49191e1009d3b)+++ b/[security/selinux/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/selinux/include/audit.h?id=a38e02265c681b51997a264aaf743095e2ee400a)@@ -18,12 +18,14 @@ \* @op: the operater the rule uses \* @rulestr: the text "target" of the rule \* @rule: pointer to the new rule structure returned via this+ \* @gfp: GFP flag used for kmalloc \* \* Returns 0 if successful, -errno if not. On success, the rule structure \* will be allocated internally. The caller must free this structure with \* selinux\_audit\_rule\_free() after use. \*/-int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*rule);+int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*rule,+ gfp\_t gfp);  /\*\* \* selinux\_audit\_rule\_free - free an selinux audit rule structure.diff --git a/security/selinux/ss/services.c b/security/selinux/ss/services.cindex 01716ed76592c8..92d4f93c59c7f4 100644--- a/[security/selinux/ss/services.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/selinux/ss/services.c?id=0edae06b4c227bcfaf3ce21208d49191e1009d3b)+++ b/[security/selinux/ss/services.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/selinux/ss/services.c?id=a38e02265c681b51997a264aaf743095e2ee400a)@@ -3560,7 +3560,8 @@ void selinux\_audit\_rule\_free(void \*vrule) } } -int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule)+int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule,+ gfp\_t gfp) { struct selinux\_state \*state = &selinux\_state; struct selinux\_policy \*policy;@@ -3601,7 +3602,7 @@ int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule) return -EINVAL; } - tmprule = kzalloc(sizeof(struct selinux\_audit\_rule), GFP\_KERNEL);+ tmprule = kzalloc(sizeof(struct selinux\_audit\_rule), gfp); if (!tmprule) return -ENOMEM; diff --git a/security/smack/smack\_lsm.c b/security/smack/smack\_lsm.cindex c6f211758f4e38..e9d2ef3deccd1e 100644--- a/[security/smack/smack\_lsm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/smack/smack_lsm.c?id=0edae06b4c227bcfaf3ce21208d49191e1009d3b)+++ b/[security/smack/smack\_lsm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/smack/smack_lsm.c?id=a38e02265c681b51997a264aaf743095e2ee400a)@@ -4487,11 +4487,13 @@ static int smack\_post\_notification(const struct cred \*w\_cred, \* @op: required testing operator (=, !=, >, <, ...) \* @rulestr: smack label to be audited \* @vrule: pointer to save our own audit rule representation+ \* @gfp: type of the memory for the allocation \* \* Prepare to audit cases where (@field @op @rulestr) is true. \* The label to be audited is created if necessay. \*/-static int smack\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule)+static int smack\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule,+ gfp\_t gfp) { struct smack\_known \*skp; char \*\*rule = (char \*\*)vrule; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 22:19:23 +0000



=== Content from git.kernel.org_c7497429_20250110_222046.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=a6176a802c4bfb83bf7524591aa75f44a639a853)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a6176a802c4bfb83bf7524591aa75f44a639a853)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a6176a802c4bfb83bf7524591aa75f44a639a853)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a6176a802c4bfb83bf7524591aa75f44a639a853)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | GUO Zihua <guozihua@huawei.com> | 2024-05-07 01:25:41 +0000 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-07-18 13:05:44 +0200 |
| commit | [a6176a802c4bfb83bf7524591aa75f44a639a853](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a6176a802c4bfb83bf7524591aa75f44a639a853) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=a6176a802c4bfb83bf7524591aa75f44a639a853)) | |
| tree | [846f00b2dfa4615c62a613135329a92a3a2d3d50](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a6176a802c4bfb83bf7524591aa75f44a639a853) | |
| parent | [37c59198bc3b869bb7fa848078f02e73f12c1cb5](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=37c59198bc3b869bb7fa848078f02e73f12c1cb5) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a6176a802c4bfb83bf7524591aa75f44a639a853&id2=37c59198bc3b869bb7fa848078f02e73f12c1cb5)) | |
| download | [linux-a6176a802c4bfb83bf7524591aa75f44a639a853.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-a6176a802c4bfb83bf7524591aa75f44a639a853.tar.gz) | |

ima: Avoid blocking in RCU read-side critical sectioncommit 9a95c5bfbf02a0a7f5983280fe284a0ff0836c34 upstream.
A panic happens in ima\_match\_policy:
BUG: unable to handle kernel NULL pointer dereference at 0000000000000010
PGD 42f873067 P4D 0
Oops: 0000 [#1] SMP NOPTI
CPU: 5 PID: 1286325 Comm: kubeletmonit.sh
Kdump: loaded Tainted: P
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996),
BIOS 0.0.0 02/06/2015
RIP: 0010:ima\_match\_policy+0x84/0x450
Code: 49 89 fc 41 89 cf 31 ed 89 44 24 14 eb 1c 44 39
7b 18 74 26 41 83 ff 05 74 20 48 8b 1b 48 3b 1d
f2 b9 f4 00 0f 84 9c 01 00 00 <44> 85 73 10 74 ea
44 8b 6b 14 41 f6 c5 01 75 d4 41 f6 c5 02 74 0f
RSP: 0018:ff71570009e07a80 EFLAGS: 00010207
RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000200
RDX: ffffffffad8dc7c0 RSI: 0000000024924925 RDI: ff3e27850dea2000
RBP: 0000000000000000 R08: 0000000000000000 R09: ffffffffabfce739
R10: ff3e27810cc42400 R11: 0000000000000000 R12: ff3e2781825ef970
R13: 00000000ff3e2785 R14: 000000000000000c R15: 0000000000000001
FS: 00007f5195b51740(0000)
GS:ff3e278b12d40000(0000) knlGS:0000000000000000
CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000000000000010 CR3: 0000000626d24002 CR4: 0000000000361ee0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
ima\_get\_action+0x22/0x30
process\_measurement+0xb0/0x830
? page\_add\_file\_rmap+0x15/0x170
? alloc\_set\_pte+0x269/0x4c0
? prep\_new\_page+0x81/0x140
? simple\_xattr\_get+0x75/0xa0
? selinux\_file\_open+0x9d/0xf0
ima\_file\_check+0x64/0x90
path\_openat+0x571/0x1720
do\_filp\_open+0x9b/0x110
? page\_counter\_try\_charge+0x57/0xc0
? files\_cgroup\_alloc\_fd+0x38/0x60
? \_\_alloc\_fd+0xd4/0x250
? do\_sys\_open+0x1bd/0x250
do\_sys\_open+0x1bd/0x250
do\_syscall\_64+0x5d/0x1d0
entry\_SYSCALL\_64\_after\_hwframe+0x65/0xca
Commit c7423dbdbc9e ("ima: Handle -ESTALE returned by
ima\_filter\_rule\_match()") introduced call to ima\_lsm\_copy\_rule within a
RCU read-side critical section which contains kmalloc with GFP\_KERNEL.
This implies a possible sleep and violates limitations of RCU read-side
critical sections on non-PREEMPT systems.
Sleeping within RCU read-side critical section might cause
synchronize\_rcu() returning early and break RCU protection, allowing a
UAF to happen.
The root cause of this issue could be described as follows:
| Thread A | Thread B |
| |ima\_match\_policy |
| | rcu\_read\_lock |
|ima\_lsm\_update\_rule | |
| synchronize\_rcu | |
| | kmalloc(GFP\_KERNEL)|
| | sleep |
==> synchronize\_rcu returns early
| kfree(entry) | |
| | entry = entry->next|
==> UAF happens and entry now becomes NULL (or could be anything).
| | entry->action |
==> Accessing entry might cause panic.
To fix this issue, we are converting all kmalloc that is called within
RCU read-side critical section to use GFP\_ATOMIC.
Fixes: c7423dbdbc9e ("ima: Handle -ESTALE returned by ima\_filter\_rule\_match()")
Cc: stable@vger.kernel.org
Signed-off-by: GUO Zihua <guozihua@huawei.com>
Acked-by: John Johansen <john.johansen@canonical.com>
Reviewed-by: Mimi Zohar <zohar@linux.ibm.com>
Reviewed-by: Casey Schaufler <casey@schaufler-ca.com>
[PM: fixed missing comment, long lines, !CONFIG\_IMA\_LSM\_RULES case]
Signed-off-by: Paul Moore <paul@paul-moore.com>
Signed-off-by: Roberto Sassu <roberto.sassu@huawei.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a6176a802c4bfb83bf7524591aa75f44a639a853)

| -rw-r--r-- | [include/linux/lsm\_hook\_defs.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/lsm_hook_defs.h?id=a6176a802c4bfb83bf7524591aa75f44a639a853) | 2 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/linux/security.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/security.h?id=a6176a802c4bfb83bf7524591aa75f44a639a853) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/auditfilter.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/auditfilter.c?id=a6176a802c4bfb83bf7524591aa75f44a639a853) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/apparmor/audit.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/apparmor/audit.c?id=a6176a802c4bfb83bf7524591aa75f44a639a853) | 6 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/apparmor/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/apparmor/include/audit.h?id=a6176a802c4bfb83bf7524591aa75f44a639a853) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/integrity/ima/ima.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/integrity/ima/ima.h?id=a6176a802c4bfb83bf7524591aa75f44a639a853) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/integrity/ima/ima\_policy.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/integrity/ima/ima_policy.c?id=a6176a802c4bfb83bf7524591aa75f44a639a853) | 15 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/security.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/security.c?id=a6176a802c4bfb83bf7524591aa75f44a639a853) | 6 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/selinux/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/selinux/include/audit.h?id=a6176a802c4bfb83bf7524591aa75f44a639a853) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/selinux/ss/services.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/selinux/ss/services.c?id=a6176a802c4bfb83bf7524591aa75f44a639a853) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/smack/smack\_lsm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/smack/smack_lsm.c?id=a6176a802c4bfb83bf7524591aa75f44a639a853) | 4 | |  |  |  | | --- | --- | --- | |

11 files changed, 34 insertions, 22 deletions

| diff --git a/include/linux/lsm\_hook\_defs.h b/include/linux/lsm\_hook\_defs.hindex 07abcd384975bb..35bb13ce1faf9d 100644--- a/[include/linux/lsm\_hook\_defs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/lsm_hook_defs.h?id=37c59198bc3b869bb7fa848078f02e73f12c1cb5)+++ b/[include/linux/lsm\_hook\_defs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/lsm_hook_defs.h?id=a6176a802c4bfb83bf7524591aa75f44a639a853)@@ -370,7 +370,7 @@ LSM\_HOOK(int, 0, key\_getsecurity, struct key \*key, char \*\*\_buffer)  #ifdef CONFIG\_AUDIT LSM\_HOOK(int, 0, audit\_rule\_init, u32 field, u32 op, char \*rulestr,- void \*\*lsmrule)+ void \*\*lsmrule, gfp\_t gfp) LSM\_HOOK(int, 0, audit\_rule\_known, struct audit\_krule \*krule) LSM\_HOOK(int, 0, audit\_rule\_match, u32 secid, u32 field, u32 op, void \*lsmrule) LSM\_HOOK(void, LSM\_RET\_VOID, audit\_rule\_free, void \*lsmrule)diff --git a/include/linux/security.h b/include/linux/security.hindex 5b61aa19fac660..e32e040f094c2f 100644--- a/[include/linux/security.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/security.h?id=37c59198bc3b869bb7fa848078f02e73f12c1cb5)+++ b/[include/linux/security.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/security.h?id=a6176a802c4bfb83bf7524591aa75f44a639a853)@@ -1856,7 +1856,8 @@ static inline int security\_key\_getsecurity(struct key \*key, char \*\*\_buffer)  #ifdef CONFIG\_AUDIT #ifdef CONFIG\_SECURITY-int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*lsmrule);+int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*lsmrule,+ gfp\_t gfp); int security\_audit\_rule\_known(struct audit\_krule \*krule); int security\_audit\_rule\_match(u32 secid, u32 field, u32 op, void \*lsmrule); void security\_audit\_rule\_free(void \*lsmrule);@@ -1864,7 +1865,7 @@ void security\_audit\_rule\_free(void \*lsmrule); #else  static inline int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr,- void \*\*lsmrule)+ void \*\*lsmrule, gfp\_t gfp) { return 0; }diff --git a/kernel/auditfilter.c b/kernel/auditfilter.cindex 333b3bcfc5458f..a5b43f25609e06 100644--- a/[kernel/auditfilter.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/auditfilter.c?id=37c59198bc3b869bb7fa848078f02e73f12c1cb5)+++ b/[kernel/auditfilter.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/auditfilter.c?id=a6176a802c4bfb83bf7524591aa75f44a639a853)@@ -521,7 +521,8 @@ static struct audit\_entry \*audit\_data\_to\_entry(struct audit\_rule\_data \*data, entry->rule.buflen += f\_val; f->lsm\_str = str; err = security\_audit\_rule\_init(f->type, f->op, str,- (void \*\*)&f->lsm\_rule);+ (void \*\*)&f->lsm\_rule,+ GFP\_KERNEL); /\* Keep currently invalid fields around in case they \* become valid after a policy reload. \*/ if (err == -EINVAL) {@@ -790,7 +791,7 @@ static inline int audit\_dupe\_lsm\_field(struct audit\_field \*df,  /\* our own (refreshed) copy of lsm\_rule \*/ ret = security\_audit\_rule\_init(df->type, df->op, df->lsm\_str,- (void \*\*)&df->lsm\_rule);+ (void \*\*)&df->lsm\_rule, GFP\_KERNEL); /\* Keep currently invalid fields around in case they \* become valid after a policy reload. \*/ if (ret == -EINVAL) {diff --git a/security/apparmor/audit.c b/security/apparmor/audit.cindex 704b0c895605a7..963df28584eed7 100644--- a/[security/apparmor/audit.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/apparmor/audit.c?id=37c59198bc3b869bb7fa848078f02e73f12c1cb5)+++ b/[security/apparmor/audit.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/apparmor/audit.c?id=a6176a802c4bfb83bf7524591aa75f44a639a853)@@ -173,7 +173,7 @@ void aa\_audit\_rule\_free(void \*vrule) } } -int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule)+int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule, gfp\_t gfp) { struct aa\_audit\_rule \*rule; @@ -186,14 +186,14 @@ int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule) return -EINVAL; } - rule = kzalloc(sizeof(struct aa\_audit\_rule), GFP\_KERNEL);+ rule = kzalloc(sizeof(struct aa\_audit\_rule), gfp);  if (!rule) return -ENOMEM;  /\* Currently rules are treated as coming from the root ns \*/ rule->label = aa\_label\_parse(&root\_ns->unconfined->label, rulestr,- GFP\_KERNEL, true, false);+ gfp, true, false); if (IS\_ERR(rule->label)) { int err = PTR\_ERR(rule->label); aa\_audit\_rule\_free(rule);diff --git a/security/apparmor/include/audit.h b/security/apparmor/include/audit.hindex 18519a4eb67e3c..f325f1bef8d6da 100644--- a/[security/apparmor/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/apparmor/include/audit.h?id=37c59198bc3b869bb7fa848078f02e73f12c1cb5)+++ b/[security/apparmor/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/apparmor/include/audit.h?id=a6176a802c4bfb83bf7524591aa75f44a639a853)@@ -186,7 +186,7 @@ static inline int complain\_error(int error) }  void aa\_audit\_rule\_free(void \*vrule);-int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule);+int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule, gfp\_t gfp); int aa\_audit\_rule\_known(struct audit\_krule \*rule); int aa\_audit\_rule\_match(u32 sid, u32 field, u32 op, void \*vrule); diff --git a/security/integrity/ima/ima.h b/security/integrity/ima/ima.hindex 6ebefec616e442..14b77a71c16c6c 100644--- a/[security/integrity/ima/ima.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/integrity/ima/ima.h?id=37c59198bc3b869bb7fa848078f02e73f12c1cb5)+++ b/[security/integrity/ima/ima.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/integrity/ima/ima.h?id=a6176a802c4bfb83bf7524591aa75f44a639a853)@@ -420,7 +420,7 @@ static inline void ima\_free\_modsig(struct modsig \*modsig) #else  static inline int ima\_filter\_rule\_init(u32 field, u32 op, char \*rulestr,- void \*\*lsmrule)+ void \*\*lsmrule, gfp\_t gfp) { return -EINVAL; }diff --git a/security/integrity/ima/ima\_policy.c b/security/integrity/ima/ima\_policy.cindex 4f5d44037081b2..8d69b2e27936a9 100644--- a/[security/integrity/ima/ima\_policy.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/integrity/ima/ima_policy.c?id=37c59198bc3b869bb7fa848078f02e73f12c1cb5)+++ b/[security/integrity/ima/ima\_policy.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/integrity/ima/ima_policy.c?id=a6176a802c4bfb83bf7524591aa75f44a639a853)@@ -349,7 +349,8 @@ static void ima\_free\_rule(struct ima\_rule\_entry \*entry) kfree(entry); } -static struct ima\_rule\_entry \*ima\_lsm\_copy\_rule(struct ima\_rule\_entry \*entry)+static struct ima\_rule\_entry \*ima\_lsm\_copy\_rule(struct ima\_rule\_entry \*entry,+ gfp\_t gfp) { struct ima\_rule\_entry \*nentry; int i;@@ -358,7 +359,7 @@ static struct ima\_rule\_entry \*ima\_lsm\_copy\_rule(struct ima\_rule\_entry \*entry) \* Immutable elements are copied over as pointers and data; only \* lsm rules can change \*/- nentry = kmemdup(entry, sizeof(\*nentry), GFP\_KERNEL);+ nentry = kmemdup(entry, sizeof(\*nentry), gfp); if (!nentry) return NULL; @@ -373,7 +374,8 @@ static struct ima\_rule\_entry \*ima\_lsm\_copy\_rule(struct ima\_rule\_entry \*entry)  ima\_filter\_rule\_init(nentry->lsm[i].type, Audit\_equal, nentry->lsm[i].args\_p,- &nentry->lsm[i].rule);+ &nentry->lsm[i].rule,+ gfp); if (!nentry->lsm[i].rule) pr\_warn("rule for LSM \'%s\' is undefined\n", nentry->lsm[i].args\_p);@@ -386,7 +388,7 @@ static int ima\_lsm\_update\_rule(struct ima\_rule\_entry \*entry) int i; struct ima\_rule\_entry \*nentry; - nentry = ima\_lsm\_copy\_rule(entry);+ nentry = ima\_lsm\_copy\_rule(entry, GFP\_KERNEL); if (!nentry) return -ENOMEM; @@ -573,7 +575,7 @@ retry: }  if (rc == -ESTALE && !rule\_reinitialized) {- lsm\_rule = ima\_lsm\_copy\_rule(rule);+ lsm\_rule = ima\_lsm\_copy\_rule(rule, GFP\_ATOMIC); if (lsm\_rule) { rule\_reinitialized = true; goto retry;@@ -990,7 +992,8 @@ static int ima\_lsm\_rule\_init(struct ima\_rule\_entry \*entry, entry->lsm[lsm\_rule].type = audit\_type; result = ima\_filter\_rule\_init(entry->lsm[lsm\_rule].type, Audit\_equal, entry->lsm[lsm\_rule].args\_p,- &entry->lsm[lsm\_rule].rule);+ &entry->lsm[lsm\_rule].rule,+ GFP\_KERNEL); if (!entry->lsm[lsm\_rule].rule) { pr\_warn("rule for LSM \'%s\' is undefined\n", entry->lsm[lsm\_rule].args\_p);diff --git a/security/security.c b/security/security.cindex 0bbcb100ba8e94..f836f292ea16c3 100644--- a/[security/security.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/security.c?id=37c59198bc3b869bb7fa848078f02e73f12c1cb5)+++ b/[security/security.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/security.c?id=a6176a802c4bfb83bf7524591aa75f44a639a853)@@ -2545,9 +2545,11 @@ int security\_key\_getsecurity(struct key \*key, char \*\*\_buffer)  #ifdef CONFIG\_AUDIT -int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*lsmrule)+int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*lsmrule,+ gfp\_t gfp) {- return call\_int\_hook(audit\_rule\_init, 0, field, op, rulestr, lsmrule);+ return call\_int\_hook(audit\_rule\_init, 0, field, op, rulestr, lsmrule,+ gfp); }  int security\_audit\_rule\_known(struct audit\_krule \*krule)diff --git a/security/selinux/include/audit.h b/security/selinux/include/audit.hindex 073a3d34a0d217..72af85ff96a483 100644--- a/[security/selinux/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/selinux/include/audit.h?id=37c59198bc3b869bb7fa848078f02e73f12c1cb5)+++ b/[security/selinux/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/selinux/include/audit.h?id=a6176a802c4bfb83bf7524591aa75f44a639a853)@@ -18,12 +18,14 @@ \* @op: the operater the rule uses \* @rulestr: the text "target" of the rule \* @rule: pointer to the new rule structure returned via this+ \* @gfp: GFP flag used for kmalloc \* \* Returns 0 if successful, -errno if not. On success, the rule structure \* will be allocated internally. The caller must free this structure with \* selinux\_audit\_rule\_free() after use. \*/-int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*rule);+int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*rule,+ gfp\_t gfp);  /\*\* \* selinux\_audit\_rule\_free - free an selinux audit rule structure.diff --git a/security/selinux/ss/services.c b/security/selinux/ss/services.cindex 3db8bd2158d9b6..a01e768337cd4d 100644--- a/[security/selinux/ss/services.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/selinux/ss/services.c?id=37c59198bc3b869bb7fa848078f02e73f12c1cb5)+++ b/[security/selinux/ss/services.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/selinux/ss/services.c?id=a6176a802c4bfb83bf7524591aa75f44a639a853)@@ -3542,7 +3542,8 @@ void selinux\_audit\_rule\_free(void \*vrule) } } -int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule)+int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule,+ gfp\_t gfp) { struct selinux\_state \*state = &selinux\_state; struct selinux\_policy \*policy;@@ -3583,7 +3584,7 @@ int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule) return -EINVAL; } - tmprule = kzalloc(sizeof(struct selinux\_audit\_rule), GFP\_KERNEL);+ tmprule = kzalloc(sizeof(struct selinux\_audit\_rule), gfp); if (!tmprule) return -ENOMEM; diff --git a/security/smack/smack\_lsm.c b/security/smack/smack\_lsm.cindex 750f6007bbbb0b..8c790563b33acf 100644--- a/[security/smack/smack\_lsm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/smack/smack_lsm.c?id=37c59198bc3b869bb7fa848078f02e73f12c1cb5)+++ b/[security/smack/smack\_lsm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/smack/smack_lsm.c?id=a6176a802c4bfb83bf7524591aa75f44a639a853)@@ -4490,11 +4490,13 @@ static int smack\_post\_notification(const struct cred \*w\_cred, \* @op: required testing operator (=, !=, >, <, ...) \* @rulestr: smack label to be audited \* @vrule: pointer to save our own audit rule representation+ \* @gfp: type of the memory for the allocation \* \* Prepare to audit cases where (@field @op @rulestr) is true. \* The label to be audited is created if necessay. \*/-static int smack\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule)+static int smack\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule,+ gfp\_t gfp) { struct smack\_known \*skp; char \*\*rule = (char \*\*)vrule; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 22:19:23 +0000



=== Content from git.kernel.org_4a1a72b0_20250110_222044.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=58275455893066149e9f4df2223ab2fdbdc59f9c)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=58275455893066149e9f4df2223ab2fdbdc59f9c)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=58275455893066149e9f4df2223ab2fdbdc59f9c)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=58275455893066149e9f4df2223ab2fdbdc59f9c)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | GUO Zihua <guozihua@huawei.com> | 2024-05-07 01:25:41 +0000 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-06-27 13:52:30 +0200 |
| commit | [58275455893066149e9f4df2223ab2fdbdc59f9c](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=58275455893066149e9f4df2223ab2fdbdc59f9c) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=58275455893066149e9f4df2223ab2fdbdc59f9c)) | |
| tree | [ec7f166892fc3995cae4824b1e46992ad67b9bd4](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=58275455893066149e9f4df2223ab2fdbdc59f9c) | |
| parent | [dec2382247860d2134c8d41e103e26460c099629](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=dec2382247860d2134c8d41e103e26460c099629) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=58275455893066149e9f4df2223ab2fdbdc59f9c&id2=dec2382247860d2134c8d41e103e26460c099629)) | |
| download | [linux-58275455893066149e9f4df2223ab2fdbdc59f9c.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-58275455893066149e9f4df2223ab2fdbdc59f9c.tar.gz) | |

ima: Avoid blocking in RCU read-side critical sectioncommit 9a95c5bfbf02a0a7f5983280fe284a0ff0836c34 upstream.
A panic happens in ima\_match\_policy:
BUG: unable to handle kernel NULL pointer dereference at 0000000000000010
PGD 42f873067 P4D 0
Oops: 0000 [#1] SMP NOPTI
CPU: 5 PID: 1286325 Comm: kubeletmonit.sh
Kdump: loaded Tainted: P
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996),
BIOS 0.0.0 02/06/2015
RIP: 0010:ima\_match\_policy+0x84/0x450
Code: 49 89 fc 41 89 cf 31 ed 89 44 24 14 eb 1c 44 39
7b 18 74 26 41 83 ff 05 74 20 48 8b 1b 48 3b 1d
f2 b9 f4 00 0f 84 9c 01 00 00 <44> 85 73 10 74 ea
44 8b 6b 14 41 f6 c5 01 75 d4 41 f6 c5 02 74 0f
RSP: 0018:ff71570009e07a80 EFLAGS: 00010207
RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000200
RDX: ffffffffad8dc7c0 RSI: 0000000024924925 RDI: ff3e27850dea2000
RBP: 0000000000000000 R08: 0000000000000000 R09: ffffffffabfce739
R10: ff3e27810cc42400 R11: 0000000000000000 R12: ff3e2781825ef970
R13: 00000000ff3e2785 R14: 000000000000000c R15: 0000000000000001
FS: 00007f5195b51740(0000)
GS:ff3e278b12d40000(0000) knlGS:0000000000000000
CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000000000000010 CR3: 0000000626d24002 CR4: 0000000000361ee0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
ima\_get\_action+0x22/0x30
process\_measurement+0xb0/0x830
? page\_add\_file\_rmap+0x15/0x170
? alloc\_set\_pte+0x269/0x4c0
? prep\_new\_page+0x81/0x140
? simple\_xattr\_get+0x75/0xa0
? selinux\_file\_open+0x9d/0xf0
ima\_file\_check+0x64/0x90
path\_openat+0x571/0x1720
do\_filp\_open+0x9b/0x110
? page\_counter\_try\_charge+0x57/0xc0
? files\_cgroup\_alloc\_fd+0x38/0x60
? \_\_alloc\_fd+0xd4/0x250
? do\_sys\_open+0x1bd/0x250
do\_sys\_open+0x1bd/0x250
do\_syscall\_64+0x5d/0x1d0
entry\_SYSCALL\_64\_after\_hwframe+0x65/0xca
Commit c7423dbdbc9e ("ima: Handle -ESTALE returned by
ima\_filter\_rule\_match()") introduced call to ima\_lsm\_copy\_rule within a
RCU read-side critical section which contains kmalloc with GFP\_KERNEL.
This implies a possible sleep and violates limitations of RCU read-side
critical sections on non-PREEMPT systems.
Sleeping within RCU read-side critical section might cause
synchronize\_rcu() returning early and break RCU protection, allowing a
UAF to happen.
The root cause of this issue could be described as follows:
| Thread A | Thread B |
| |ima\_match\_policy |
| | rcu\_read\_lock |
|ima\_lsm\_update\_rule | |
| synchronize\_rcu | |
| | kmalloc(GFP\_KERNEL)|
| | sleep |
==> synchronize\_rcu returns early
| kfree(entry) | |
| | entry = entry->next|
==> UAF happens and entry now becomes NULL (or could be anything).
| | entry->action |
==> Accessing entry might cause panic.
To fix this issue, we are converting all kmalloc that is called within
RCU read-side critical section to use GFP\_ATOMIC.
Fixes: c7423dbdbc9e ("ima: Handle -ESTALE returned by ima\_filter\_rule\_match()")
Cc: stable@vger.kernel.org
Signed-off-by: GUO Zihua <guozihua@huawei.com>
Acked-by: John Johansen <john.johansen@canonical.com>
Reviewed-by: Mimi Zohar <zohar@linux.ibm.com>
Reviewed-by: Casey Schaufler <casey@schaufler-ca.com>
[PM: fixed missing comment, long lines, !CONFIG\_IMA\_LSM\_RULES case]
Signed-off-by: Paul Moore <paul@paul-moore.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=58275455893066149e9f4df2223ab2fdbdc59f9c)

| -rw-r--r-- | [include/linux/lsm\_hook\_defs.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/lsm_hook_defs.h?id=58275455893066149e9f4df2223ab2fdbdc59f9c) | 2 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/linux/security.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/security.h?id=58275455893066149e9f4df2223ab2fdbdc59f9c) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/auditfilter.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/auditfilter.c?id=58275455893066149e9f4df2223ab2fdbdc59f9c) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/apparmor/audit.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/apparmor/audit.c?id=58275455893066149e9f4df2223ab2fdbdc59f9c) | 6 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/apparmor/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/apparmor/include/audit.h?id=58275455893066149e9f4df2223ab2fdbdc59f9c) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/integrity/ima/ima.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/integrity/ima/ima.h?id=58275455893066149e9f4df2223ab2fdbdc59f9c) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/integrity/ima/ima\_policy.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/integrity/ima/ima_policy.c?id=58275455893066149e9f4df2223ab2fdbdc59f9c) | 15 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/security.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/security.c?id=58275455893066149e9f4df2223ab2fdbdc59f9c) | 6 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/selinux/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/selinux/include/audit.h?id=58275455893066149e9f4df2223ab2fdbdc59f9c) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/selinux/ss/services.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/selinux/ss/services.c?id=58275455893066149e9f4df2223ab2fdbdc59f9c) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/smack/smack\_lsm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/smack/smack_lsm.c?id=58275455893066149e9f4df2223ab2fdbdc59f9c) | 4 | |  |  |  | | --- | --- | --- | |

11 files changed, 34 insertions, 22 deletions

| diff --git a/include/linux/lsm\_hook\_defs.h b/include/linux/lsm\_hook\_defs.hindex 334e00efbde45a..7e539f6f8c674e 100644--- a/[include/linux/lsm\_hook\_defs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/lsm_hook_defs.h?id=dec2382247860d2134c8d41e103e26460c099629)+++ b/[include/linux/lsm\_hook\_defs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/lsm_hook_defs.h?id=58275455893066149e9f4df2223ab2fdbdc59f9c)@@ -412,7 +412,7 @@ LSM\_HOOK(void, LSM\_RET\_VOID, key\_post\_create\_or\_update, struct key \*keyring,  #ifdef CONFIG\_AUDIT LSM\_HOOK(int, 0, audit\_rule\_init, u32 field, u32 op, char \*rulestr,- void \*\*lsmrule)+ void \*\*lsmrule, gfp\_t gfp) LSM\_HOOK(int, 0, audit\_rule\_known, struct audit\_krule \*krule) LSM\_HOOK(int, 0, audit\_rule\_match, u32 secid, u32 field, u32 op, void \*lsmrule) LSM\_HOOK(void, LSM\_RET\_VOID, audit\_rule\_free, void \*lsmrule)diff --git a/include/linux/security.h b/include/linux/security.hindex 41a8f667bdfa0b..5122e3ad83b19a 100644--- a/[include/linux/security.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/security.h?id=dec2382247860d2134c8d41e103e26460c099629)+++ b/[include/linux/security.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/security.h?id=58275455893066149e9f4df2223ab2fdbdc59f9c)@@ -2048,7 +2048,8 @@ static inline void security\_key\_post\_create\_or\_update(struct key \*keyring,  #ifdef CONFIG\_AUDIT #ifdef CONFIG\_SECURITY-int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*lsmrule);+int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*lsmrule,+ gfp\_t gfp); int security\_audit\_rule\_known(struct audit\_krule \*krule); int security\_audit\_rule\_match(u32 secid, u32 field, u32 op, void \*lsmrule); void security\_audit\_rule\_free(void \*lsmrule);@@ -2056,7 +2057,7 @@ void security\_audit\_rule\_free(void \*lsmrule); #else  static inline int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr,- void \*\*lsmrule)+ void \*\*lsmrule, gfp\_t gfp) { return 0; }diff --git a/kernel/auditfilter.c b/kernel/auditfilter.cindex be8c680121e466..d6ef4f4f9cba50 100644--- a/[kernel/auditfilter.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/auditfilter.c?id=dec2382247860d2134c8d41e103e26460c099629)+++ b/[kernel/auditfilter.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/auditfilter.c?id=58275455893066149e9f4df2223ab2fdbdc59f9c)@@ -529,7 +529,8 @@ static struct audit\_entry \*audit\_data\_to\_entry(struct audit\_rule\_data \*data, entry->rule.buflen += f\_val; f->lsm\_str = str; err = security\_audit\_rule\_init(f->type, f->op, str,- (void \*\*)&f->lsm\_rule);+ (void \*\*)&f->lsm\_rule,+ GFP\_KERNEL); /\* Keep currently invalid fields around in case they \* become valid after a policy reload. \*/ if (err == -EINVAL) {@@ -799,7 +800,7 @@ static inline int audit\_dupe\_lsm\_field(struct audit\_field \*df,  /\* our own (refreshed) copy of lsm\_rule \*/ ret = security\_audit\_rule\_init(df->type, df->op, df->lsm\_str,- (void \*\*)&df->lsm\_rule);+ (void \*\*)&df->lsm\_rule, GFP\_KERNEL); /\* Keep currently invalid fields around in case they \* become valid after a policy reload. \*/ if (ret == -EINVAL) {diff --git a/security/apparmor/audit.c b/security/apparmor/audit.cindex 45beb1c5f747a8..6b5181c668b5b7 100644--- a/[security/apparmor/audit.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/apparmor/audit.c?id=dec2382247860d2134c8d41e103e26460c099629)+++ b/[security/apparmor/audit.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/apparmor/audit.c?id=58275455893066149e9f4df2223ab2fdbdc59f9c)@@ -217,7 +217,7 @@ void aa\_audit\_rule\_free(void \*vrule) } } -int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule)+int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule, gfp\_t gfp) { struct aa\_audit\_rule \*rule; @@ -230,14 +230,14 @@ int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule) return -EINVAL; } - rule = kzalloc(sizeof(struct aa\_audit\_rule), GFP\_KERNEL);+ rule = kzalloc(sizeof(struct aa\_audit\_rule), gfp);  if (!rule) return -ENOMEM;  /\* Currently rules are treated as coming from the root ns \*/ rule->label = aa\_label\_parse(&root\_ns->unconfined->label, rulestr,- GFP\_KERNEL, true, false);+ gfp, true, false); if (IS\_ERR(rule->label)) { int err = PTR\_ERR(rule->label); aa\_audit\_rule\_free(rule);diff --git a/security/apparmor/include/audit.h b/security/apparmor/include/audit.hindex acbb03b9bd25cc..0c8cc86b417b56 100644--- a/[security/apparmor/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/apparmor/include/audit.h?id=dec2382247860d2134c8d41e103e26460c099629)+++ b/[security/apparmor/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/apparmor/include/audit.h?id=58275455893066149e9f4df2223ab2fdbdc59f9c)@@ -200,7 +200,7 @@ static inline int complain\_error(int error) }  void aa\_audit\_rule\_free(void \*vrule);-int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule);+int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule, gfp\_t gfp); int aa\_audit\_rule\_known(struct audit\_krule \*rule); int aa\_audit\_rule\_match(u32 sid, u32 field, u32 op, void \*vrule); diff --git a/security/integrity/ima/ima.h b/security/integrity/ima/ima.hindex 11d7c033220700..0a4f274f77810d 100644--- a/[security/integrity/ima/ima.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/integrity/ima/ima.h?id=dec2382247860d2134c8d41e103e26460c099629)+++ b/[security/integrity/ima/ima.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/integrity/ima/ima.h?id=58275455893066149e9f4df2223ab2fdbdc59f9c)@@ -540,7 +540,7 @@ static inline void ima\_free\_modsig(struct modsig \*modsig) #else  static inline int ima\_filter\_rule\_init(u32 field, u32 op, char \*rulestr,- void \*\*lsmrule)+ void \*\*lsmrule, gfp\_t gfp) { return -EINVAL; }diff --git a/security/integrity/ima/ima\_policy.c b/security/integrity/ima/ima\_policy.cindex c0556907c2e67a..09da8e63923956 100644--- a/[security/integrity/ima/ima\_policy.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/integrity/ima/ima_policy.c?id=dec2382247860d2134c8d41e103e26460c099629)+++ b/[security/integrity/ima/ima\_policy.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/integrity/ima/ima_policy.c?id=58275455893066149e9f4df2223ab2fdbdc59f9c)@@ -401,7 +401,8 @@ static void ima\_free\_rule(struct ima\_rule\_entry \*entry) kfree(entry); } -static struct ima\_rule\_entry \*ima\_lsm\_copy\_rule(struct ima\_rule\_entry \*entry)+static struct ima\_rule\_entry \*ima\_lsm\_copy\_rule(struct ima\_rule\_entry \*entry,+ gfp\_t gfp) { struct ima\_rule\_entry \*nentry; int i;@@ -410,7 +411,7 @@ static struct ima\_rule\_entry \*ima\_lsm\_copy\_rule(struct ima\_rule\_entry \*entry) \* Immutable elements are copied over as pointers and data; only \* lsm rules can change \*/- nentry = kmemdup(entry, sizeof(\*nentry), GFP\_KERNEL);+ nentry = kmemdup(entry, sizeof(\*nentry), gfp); if (!nentry) return NULL; @@ -425,7 +426,8 @@ static struct ima\_rule\_entry \*ima\_lsm\_copy\_rule(struct ima\_rule\_entry \*entry)  ima\_filter\_rule\_init(nentry->lsm[i].type, Audit\_equal, nentry->lsm[i].args\_p,- &nentry->lsm[i].rule);+ &nentry->lsm[i].rule,+ gfp); if (!nentry->lsm[i].rule) pr\_warn("rule for LSM \'%s\' is undefined\n", nentry->lsm[i].args\_p);@@ -438,7 +440,7 @@ static int ima\_lsm\_update\_rule(struct ima\_rule\_entry \*entry) int i; struct ima\_rule\_entry \*nentry; - nentry = ima\_lsm\_copy\_rule(entry);+ nentry = ima\_lsm\_copy\_rule(entry, GFP\_KERNEL); if (!nentry) return -ENOMEM; @@ -664,7 +666,7 @@ retry: }  if (rc == -ESTALE && !rule\_reinitialized) {- lsm\_rule = ima\_lsm\_copy\_rule(rule);+ lsm\_rule = ima\_lsm\_copy\_rule(rule, GFP\_ATOMIC); if (lsm\_rule) { rule\_reinitialized = true; goto retry;@@ -1140,7 +1142,8 @@ static int ima\_lsm\_rule\_init(struct ima\_rule\_entry \*entry, entry->lsm[lsm\_rule].type = audit\_type; result = ima\_filter\_rule\_init(entry->lsm[lsm\_rule].type, Audit\_equal, entry->lsm[lsm\_rule].args\_p,- &entry->lsm[lsm\_rule].rule);+ &entry->lsm[lsm\_rule].rule,+ GFP\_KERNEL); if (!entry->lsm[lsm\_rule].rule) { pr\_warn("rule for LSM \'%s\' is undefined\n", entry->lsm[lsm\_rule].args\_p);diff --git a/security/security.c b/security/security.cindex 0a9a0ac3f26624..4fd3c839353ec2 100644--- a/[security/security.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/security.c?id=dec2382247860d2134c8d41e103e26460c099629)+++ b/[security/security.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/security.c?id=58275455893066149e9f4df2223ab2fdbdc59f9c)@@ -5331,15 +5331,17 @@ void security\_key\_post\_create\_or\_update(struct key \*keyring, struct key \*key, \* @op: rule operator \* @rulestr: rule context \* @lsmrule: receive buffer for audit rule struct+ \* @gfp: GFP flag used for kmalloc \* \* Allocate and initialize an LSM audit rule structure. \* \* Return: Return 0 if @lsmrule has been successfully set, -EINVAL in case of \* an invalid rule. \*/-int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*lsmrule)+int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*lsmrule,+ gfp\_t gfp) {- return call\_int\_hook(audit\_rule\_init, field, op, rulestr, lsmrule);+ return call\_int\_hook(audit\_rule\_init, field, op, rulestr, lsmrule, gfp); }  /\*\*diff --git a/security/selinux/include/audit.h b/security/selinux/include/audit.hindex 52aca71210b476..29c7d4c86f6d57 100644--- a/[security/selinux/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/selinux/include/audit.h?id=dec2382247860d2134c8d41e103e26460c099629)+++ b/[security/selinux/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/selinux/include/audit.h?id=58275455893066149e9f4df2223ab2fdbdc59f9c)@@ -21,12 +21,14 @@ \* @op: the operator the rule uses \* @rulestr: the text "target" of the rule \* @rule: pointer to the new rule structure returned via this+ \* @gfp: GFP flag used for kmalloc \* \* Returns 0 if successful, -errno if not. On success, the rule structure \* will be allocated internally. The caller must free this structure with \* selinux\_audit\_rule\_free() after use. \*/-int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*rule);+int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*rule,+ gfp\_t gfp);  /\*\* \* selinux\_audit\_rule\_free - free an selinux audit rule structure.diff --git a/security/selinux/ss/services.c b/security/selinux/ss/services.cindex e88b1b6c4adbb2..ded250e525e9c4 100644--- a/[security/selinux/ss/services.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/selinux/ss/services.c?id=dec2382247860d2134c8d41e103e26460c099629)+++ b/[security/selinux/ss/services.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/selinux/ss/services.c?id=58275455893066149e9f4df2223ab2fdbdc59f9c)@@ -3508,7 +3508,8 @@ void selinux\_audit\_rule\_free(void \*vrule) } } -int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule)+int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule,+ gfp\_t gfp) { struct selinux\_state \*state = &selinux\_state; struct selinux\_policy \*policy;@@ -3549,7 +3550,7 @@ int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule) return -EINVAL; } - tmprule = kzalloc(sizeof(struct selinux\_audit\_rule), GFP\_KERNEL);+ tmprule = kzalloc(sizeof(struct selinux\_audit\_rule), gfp); if (!tmprule) return -ENOMEM; context\_init(&tmprule->au\_ctxt);diff --git a/security/smack/smack\_lsm.c b/security/smack/smack\_lsm.cindex 146667937811bb..c6df5c00c7bab5 100644--- a/[security/smack/smack\_lsm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/smack/smack_lsm.c?id=dec2382247860d2134c8d41e103e26460c099629)+++ b/[security/smack/smack\_lsm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/smack/smack_lsm.c?id=58275455893066149e9f4df2223ab2fdbdc59f9c)@@ -4692,11 +4692,13 @@ static int smack\_post\_notification(const struct cred \*w\_cred, \* @op: required testing operator (=, !=, >, <, ...) \* @rulestr: smack label to be audited \* @vrule: pointer to save our own audit rule representation+ \* @gfp: type of the memory for the allocation \* \* Prepare to audit cases where (@field @op @rulestr) is true. \* The label to be audited is created if necessay. \*/-static int smack\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule)+static int smack\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule,+ gfp\_t gfp) { struct smack\_known \*skp; char \*\*rule = (char \*\*)vrule; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 22:19:21 +0000



=== Content from git.kernel.org_d4c53b6c_20250110_222044.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | GUO Zihua <guozihua@huawei.com> | 2024-05-07 01:25:41 +0000 |
| --- | --- | --- |
| committer | Paul Moore <paul@paul-moore.com> | 2024-06-13 14:26:50 -0400 |
| commit | [9a95c5bfbf02a0a7f5983280fe284a0ff0836c34](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34)) | |
| tree | [46e2fe55b0b3cbd9baca7f77b15bb9378160c751](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34) | |
| parent | [83a7eefedc9b56fe7bfeff13b6c7356688ffa670](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=83a7eefedc9b56fe7bfeff13b6c7356688ffa670) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34&id2=83a7eefedc9b56fe7bfeff13b6c7356688ffa670)) | |
| download | [linux-9a95c5bfbf02a0a7f5983280fe284a0ff0836c34.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-9a95c5bfbf02a0a7f5983280fe284a0ff0836c34.tar.gz) | |

ima: Avoid blocking in RCU read-side critical sectionA panic happens in ima\_match\_policy:
BUG: unable to handle kernel NULL pointer dereference at 0000000000000010
PGD 42f873067 P4D 0
Oops: 0000 [#1] SMP NOPTI
CPU: 5 PID: 1286325 Comm: kubeletmonit.sh
Kdump: loaded Tainted: P
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996),
BIOS 0.0.0 02/06/2015
RIP: 0010:ima\_match\_policy+0x84/0x450
Code: 49 89 fc 41 89 cf 31 ed 89 44 24 14 eb 1c 44 39
7b 18 74 26 41 83 ff 05 74 20 48 8b 1b 48 3b 1d
f2 b9 f4 00 0f 84 9c 01 00 00 <44> 85 73 10 74 ea
44 8b 6b 14 41 f6 c5 01 75 d4 41 f6 c5 02 74 0f
RSP: 0018:ff71570009e07a80 EFLAGS: 00010207
RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000200
RDX: ffffffffad8dc7c0 RSI: 0000000024924925 RDI: ff3e27850dea2000
RBP: 0000000000000000 R08: 0000000000000000 R09: ffffffffabfce739
R10: ff3e27810cc42400 R11: 0000000000000000 R12: ff3e2781825ef970
R13: 00000000ff3e2785 R14: 000000000000000c R15: 0000000000000001
FS: 00007f5195b51740(0000)
GS:ff3e278b12d40000(0000) knlGS:0000000000000000
CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000000000000010 CR3: 0000000626d24002 CR4: 0000000000361ee0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
ima\_get\_action+0x22/0x30
process\_measurement+0xb0/0x830
? page\_add\_file\_rmap+0x15/0x170
? alloc\_set\_pte+0x269/0x4c0
? prep\_new\_page+0x81/0x140
? simple\_xattr\_get+0x75/0xa0
? selinux\_file\_open+0x9d/0xf0
ima\_file\_check+0x64/0x90
path\_openat+0x571/0x1720
do\_filp\_open+0x9b/0x110
? page\_counter\_try\_charge+0x57/0xc0
? files\_cgroup\_alloc\_fd+0x38/0x60
? \_\_alloc\_fd+0xd4/0x250
? do\_sys\_open+0x1bd/0x250
do\_sys\_open+0x1bd/0x250
do\_syscall\_64+0x5d/0x1d0
entry\_SYSCALL\_64\_after\_hwframe+0x65/0xca
Commit c7423dbdbc9e ("ima: Handle -ESTALE returned by
ima\_filter\_rule\_match()") introduced call to ima\_lsm\_copy\_rule within a
RCU read-side critical section which contains kmalloc with GFP\_KERNEL.
This implies a possible sleep and violates limitations of RCU read-side
critical sections on non-PREEMPT systems.
Sleeping within RCU read-side critical section might cause
synchronize\_rcu() returning early and break RCU protection, allowing a
UAF to happen.
The root cause of this issue could be described as follows:
| Thread A | Thread B |
| |ima\_match\_policy |
| | rcu\_read\_lock |
|ima\_lsm\_update\_rule | |
| synchronize\_rcu | |
| | kmalloc(GFP\_KERNEL)|
| | sleep |
==> synchronize\_rcu returns early
| kfree(entry) | |
| | entry = entry->next|
==> UAF happens and entry now becomes NULL (or could be anything).
| | entry->action |
==> Accessing entry might cause panic.
To fix this issue, we are converting all kmalloc that is called within
RCU read-side critical section to use GFP\_ATOMIC.
Fixes: c7423dbdbc9e ("ima: Handle -ESTALE returned by ima\_filter\_rule\_match()")
Cc: stable@vger.kernel.org
Signed-off-by: GUO Zihua <guozihua@huawei.com>
Acked-by: John Johansen <john.johansen@canonical.com>
Reviewed-by: Mimi Zohar <zohar@linux.ibm.com>
Reviewed-by: Casey Schaufler <casey@schaufler-ca.com>
[PM: fixed missing comment, long lines, !CONFIG\_IMA\_LSM\_RULES case]
Signed-off-by: Paul Moore <paul@paul-moore.com>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34)

| -rw-r--r-- | [include/linux/lsm\_hook\_defs.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/lsm_hook_defs.h?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34) | 2 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/linux/security.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/security.h?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/auditfilter.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/auditfilter.c?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/apparmor/audit.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/apparmor/audit.c?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34) | 6 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/apparmor/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/apparmor/include/audit.h?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/integrity/ima/ima.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/integrity/ima/ima.h?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/integrity/ima/ima\_policy.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/integrity/ima/ima_policy.c?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34) | 15 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/security.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/security.c?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34) | 6 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/selinux/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/selinux/include/audit.h?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/selinux/ss/services.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/selinux/ss/services.c?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/smack/smack\_lsm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/smack/smack_lsm.c?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34) | 4 | |  |  |  | | --- | --- | --- | |

11 files changed, 34 insertions, 22 deletions

| diff --git a/include/linux/lsm\_hook\_defs.h b/include/linux/lsm\_hook\_defs.hindex f804b76cde44ee..44488b1ab9a976 100644--- a/[include/linux/lsm\_hook\_defs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/lsm_hook_defs.h?id=83a7eefedc9b56fe7bfeff13b6c7356688ffa670)+++ b/[include/linux/lsm\_hook\_defs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/lsm_hook_defs.h?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34)@@ -413,7 +413,7 @@ LSM\_HOOK(void, LSM\_RET\_VOID, key\_post\_create\_or\_update, struct key \*keyring,  #ifdef CONFIG\_AUDIT LSM\_HOOK(int, 0, audit\_rule\_init, u32 field, u32 op, char \*rulestr,- void \*\*lsmrule)+ void \*\*lsmrule, gfp\_t gfp) LSM\_HOOK(int, 0, audit\_rule\_known, struct audit\_krule \*krule) LSM\_HOOK(int, 0, audit\_rule\_match, u32 secid, u32 field, u32 op, void \*lsmrule) LSM\_HOOK(void, LSM\_RET\_VOID, audit\_rule\_free, void \*lsmrule)diff --git a/include/linux/security.h b/include/linux/security.hindex 21cf70346b330e..de3af33e6ff502 100644--- a/[include/linux/security.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/security.h?id=83a7eefedc9b56fe7bfeff13b6c7356688ffa670)+++ b/[include/linux/security.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/security.h?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34)@@ -2048,7 +2048,8 @@ static inline void security\_key\_post\_create\_or\_update(struct key \*keyring,  #ifdef CONFIG\_AUDIT #ifdef CONFIG\_SECURITY-int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*lsmrule);+int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*lsmrule,+ gfp\_t gfp); int security\_audit\_rule\_known(struct audit\_krule \*krule); int security\_audit\_rule\_match(u32 secid, u32 field, u32 op, void \*lsmrule); void security\_audit\_rule\_free(void \*lsmrule);@@ -2056,7 +2057,7 @@ void security\_audit\_rule\_free(void \*lsmrule); #else  static inline int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr,- void \*\*lsmrule)+ void \*\*lsmrule, gfp\_t gfp) { return 0; }diff --git a/kernel/auditfilter.c b/kernel/auditfilter.cindex be8c680121e466..d6ef4f4f9cba50 100644--- a/[kernel/auditfilter.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/auditfilter.c?id=83a7eefedc9b56fe7bfeff13b6c7356688ffa670)+++ b/[kernel/auditfilter.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/auditfilter.c?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34)@@ -529,7 +529,8 @@ static struct audit\_entry \*audit\_data\_to\_entry(struct audit\_rule\_data \*data, entry->rule.buflen += f\_val; f->lsm\_str = str; err = security\_audit\_rule\_init(f->type, f->op, str,- (void \*\*)&f->lsm\_rule);+ (void \*\*)&f->lsm\_rule,+ GFP\_KERNEL); /\* Keep currently invalid fields around in case they \* become valid after a policy reload. \*/ if (err == -EINVAL) {@@ -799,7 +800,7 @@ static inline int audit\_dupe\_lsm\_field(struct audit\_field \*df,  /\* our own (refreshed) copy of lsm\_rule \*/ ret = security\_audit\_rule\_init(df->type, df->op, df->lsm\_str,- (void \*\*)&df->lsm\_rule);+ (void \*\*)&df->lsm\_rule, GFP\_KERNEL); /\* Keep currently invalid fields around in case they \* become valid after a policy reload. \*/ if (ret == -EINVAL) {diff --git a/security/apparmor/audit.c b/security/apparmor/audit.cindex 45beb1c5f747a8..6b5181c668b5b7 100644--- a/[security/apparmor/audit.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/apparmor/audit.c?id=83a7eefedc9b56fe7bfeff13b6c7356688ffa670)+++ b/[security/apparmor/audit.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/apparmor/audit.c?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34)@@ -217,7 +217,7 @@ void aa\_audit\_rule\_free(void \*vrule) } } -int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule)+int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule, gfp\_t gfp) { struct aa\_audit\_rule \*rule; @@ -230,14 +230,14 @@ int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule) return -EINVAL; } - rule = kzalloc(sizeof(struct aa\_audit\_rule), GFP\_KERNEL);+ rule = kzalloc(sizeof(struct aa\_audit\_rule), gfp);  if (!rule) return -ENOMEM;  /\* Currently rules are treated as coming from the root ns \*/ rule->label = aa\_label\_parse(&root\_ns->unconfined->label, rulestr,- GFP\_KERNEL, true, false);+ gfp, true, false); if (IS\_ERR(rule->label)) { int err = PTR\_ERR(rule->label); aa\_audit\_rule\_free(rule);diff --git a/security/apparmor/include/audit.h b/security/apparmor/include/audit.hindex acbb03b9bd25cc..0c8cc86b417b56 100644--- a/[security/apparmor/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/apparmor/include/audit.h?id=83a7eefedc9b56fe7bfeff13b6c7356688ffa670)+++ b/[security/apparmor/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/apparmor/include/audit.h?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34)@@ -200,7 +200,7 @@ static inline int complain\_error(int error) }  void aa\_audit\_rule\_free(void \*vrule);-int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule);+int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule, gfp\_t gfp); int aa\_audit\_rule\_known(struct audit\_krule \*rule); int aa\_audit\_rule\_match(u32 sid, u32 field, u32 op, void \*vrule); diff --git a/security/integrity/ima/ima.h b/security/integrity/ima/ima.hindex 3e568126cd4816..c51e24d24d1e9e 100644--- a/[security/integrity/ima/ima.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/integrity/ima/ima.h?id=83a7eefedc9b56fe7bfeff13b6c7356688ffa670)+++ b/[security/integrity/ima/ima.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/integrity/ima/ima.h?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34)@@ -546,7 +546,7 @@ static inline void ima\_free\_modsig(struct modsig \*modsig) #else  static inline int ima\_filter\_rule\_init(u32 field, u32 op, char \*rulestr,- void \*\*lsmrule)+ void \*\*lsmrule, gfp\_t gfp) { return -EINVAL; }diff --git a/security/integrity/ima/ima\_policy.c b/security/integrity/ima/ima\_policy.cindex c0556907c2e67a..09da8e63923956 100644--- a/[security/integrity/ima/ima\_policy.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/integrity/ima/ima_policy.c?id=83a7eefedc9b56fe7bfeff13b6c7356688ffa670)+++ b/[security/integrity/ima/ima\_policy.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/integrity/ima/ima_policy.c?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34)@@ -401,7 +401,8 @@ static void ima\_free\_rule(struct ima\_rule\_entry \*entry) kfree(entry); } -static struct ima\_rule\_entry \*ima\_lsm\_copy\_rule(struct ima\_rule\_entry \*entry)+static struct ima\_rule\_entry \*ima\_lsm\_copy\_rule(struct ima\_rule\_entry \*entry,+ gfp\_t gfp) { struct ima\_rule\_entry \*nentry; int i;@@ -410,7 +411,7 @@ static struct ima\_rule\_entry \*ima\_lsm\_copy\_rule(struct ima\_rule\_entry \*entry) \* Immutable elements are copied over as pointers and data; only \* lsm rules can change \*/- nentry = kmemdup(entry, sizeof(\*nentry), GFP\_KERNEL);+ nentry = kmemdup(entry, sizeof(\*nentry), gfp); if (!nentry) return NULL; @@ -425,7 +426,8 @@ static struct ima\_rule\_entry \*ima\_lsm\_copy\_rule(struct ima\_rule\_entry \*entry)  ima\_filter\_rule\_init(nentry->lsm[i].type, Audit\_equal, nentry->lsm[i].args\_p,- &nentry->lsm[i].rule);+ &nentry->lsm[i].rule,+ gfp); if (!nentry->lsm[i].rule) pr\_warn("rule for LSM \'%s\' is undefined\n", nentry->lsm[i].args\_p);@@ -438,7 +440,7 @@ static int ima\_lsm\_update\_rule(struct ima\_rule\_entry \*entry) int i; struct ima\_rule\_entry \*nentry; - nentry = ima\_lsm\_copy\_rule(entry);+ nentry = ima\_lsm\_copy\_rule(entry, GFP\_KERNEL); if (!nentry) return -ENOMEM; @@ -664,7 +666,7 @@ retry: }  if (rc == -ESTALE && !rule\_reinitialized) {- lsm\_rule = ima\_lsm\_copy\_rule(rule);+ lsm\_rule = ima\_lsm\_copy\_rule(rule, GFP\_ATOMIC); if (lsm\_rule) { rule\_reinitialized = true; goto retry;@@ -1140,7 +1142,8 @@ static int ima\_lsm\_rule\_init(struct ima\_rule\_entry \*entry, entry->lsm[lsm\_rule].type = audit\_type; result = ima\_filter\_rule\_init(entry->lsm[lsm\_rule].type, Audit\_equal, entry->lsm[lsm\_rule].args\_p,- &entry->lsm[lsm\_rule].rule);+ &entry->lsm[lsm\_rule].rule,+ GFP\_KERNEL); if (!entry->lsm[lsm\_rule].rule) { pr\_warn("rule for LSM \'%s\' is undefined\n", entry->lsm[lsm\_rule].args\_p);diff --git a/security/security.c b/security/security.cindex e5da848c50b915..e5ca08789f7418 100644--- a/[security/security.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/security.c?id=83a7eefedc9b56fe7bfeff13b6c7356688ffa670)+++ b/[security/security.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/security.c?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34)@@ -5332,15 +5332,17 @@ void security\_key\_post\_create\_or\_update(struct key \*keyring, struct key \*key, \* @op: rule operator \* @rulestr: rule context \* @lsmrule: receive buffer for audit rule struct+ \* @gfp: GFP flag used for kmalloc \* \* Allocate and initialize an LSM audit rule structure. \* \* Return: Return 0 if @lsmrule has been successfully set, -EINVAL in case of \* an invalid rule. \*/-int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*lsmrule)+int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*lsmrule,+ gfp\_t gfp) {- return call\_int\_hook(audit\_rule\_init, field, op, rulestr, lsmrule);+ return call\_int\_hook(audit\_rule\_init, field, op, rulestr, lsmrule, gfp); }  /\*\*diff --git a/security/selinux/include/audit.h b/security/selinux/include/audit.hindex 52aca71210b476..29c7d4c86f6d57 100644--- a/[security/selinux/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/selinux/include/audit.h?id=83a7eefedc9b56fe7bfeff13b6c7356688ffa670)+++ b/[security/selinux/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/selinux/include/audit.h?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34)@@ -21,12 +21,14 @@ \* @op: the operator the rule uses \* @rulestr: the text "target" of the rule \* @rule: pointer to the new rule structure returned via this+ \* @gfp: GFP flag used for kmalloc \* \* Returns 0 if successful, -errno if not. On success, the rule structure \* will be allocated internally. The caller must free this structure with \* selinux\_audit\_rule\_free() after use. \*/-int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*rule);+int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*rule,+ gfp\_t gfp);  /\*\* \* selinux\_audit\_rule\_free - free an selinux audit rule structure.diff --git a/security/selinux/ss/services.c b/security/selinux/ss/services.cindex f20e1968b7f7a8..e33e55384b75aa 100644--- a/[security/selinux/ss/services.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/selinux/ss/services.c?id=83a7eefedc9b56fe7bfeff13b6c7356688ffa670)+++ b/[security/selinux/ss/services.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/selinux/ss/services.c?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34)@@ -3507,7 +3507,8 @@ void selinux\_audit\_rule\_free(void \*vrule) } } -int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule)+int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule,+ gfp\_t gfp) { struct selinux\_state \*state = &selinux\_state; struct selinux\_policy \*policy;@@ -3548,7 +3549,7 @@ int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule) return -EINVAL; } - tmprule = kzalloc(sizeof(struct selinux\_audit\_rule), GFP\_KERNEL);+ tmprule = kzalloc(sizeof(struct selinux\_audit\_rule), gfp); if (!tmprule) return -ENOMEM; context\_init(&tmprule->au\_ctxt);diff --git a/security/smack/smack\_lsm.c b/security/smack/smack\_lsm.cindex 70ba2841e181d3..f5cbec1e6a9230 100644--- a/[security/smack/smack\_lsm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/smack/smack_lsm.c?id=83a7eefedc9b56fe7bfeff13b6c7356688ffa670)+++ b/[security/smack/smack\_lsm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/smack/smack_lsm.c?id=9a95c5bfbf02a0a7f5983280fe284a0ff0836c34)@@ -4693,11 +4693,13 @@ static int smack\_post\_notification(const struct cred \*w\_cred, \* @op: required testing operator (=, !=, >, <, ...) \* @rulestr: smack label to be audited \* @vrule: pointer to save our own audit rule representation+ \* @gfp: type of the memory for the allocation \* \* Prepare to audit cases where (@field @op @rulestr) is true. \* The label to be audited is created if necessay. \*/-static int smack\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule)+static int smack\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule,+ gfp\_t gfp) { struct smack\_known \*skp; char \*\*rule = (char \*\*)vrule; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 22:19:21 +0000



=== Content from git.kernel.org_c3eb3d21_20250110_222045.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | GUO Zihua <guozihua@huawei.com> | 2024-05-07 01:25:41 +0000 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-07-11 12:47:16 +0200 |
| commit | [9c3906c3738562b1fedc6f1cfc81756a7cfefff0](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0)) | |
| tree | [b679c1e9a5dfd0b1e4f950b21e7701ef51375617](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0) | |
| parent | [ee42c150831324b95412b34afcd2a0176cb0a942](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ee42c150831324b95412b34afcd2a0176cb0a942) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0&id2=ee42c150831324b95412b34afcd2a0176cb0a942)) | |
| download | [linux-9c3906c3738562b1fedc6f1cfc81756a7cfefff0.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-9c3906c3738562b1fedc6f1cfc81756a7cfefff0.tar.gz) | |

ima: Avoid blocking in RCU read-side critical sectioncommit 9a95c5bfbf02a0a7f5983280fe284a0ff0836c34 upstream.
A panic happens in ima\_match\_policy:
BUG: unable to handle kernel NULL pointer dereference at 0000000000000010
PGD 42f873067 P4D 0
Oops: 0000 [#1] SMP NOPTI
CPU: 5 PID: 1286325 Comm: kubeletmonit.sh
Kdump: loaded Tainted: P
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996),
BIOS 0.0.0 02/06/2015
RIP: 0010:ima\_match\_policy+0x84/0x450
Code: 49 89 fc 41 89 cf 31 ed 89 44 24 14 eb 1c 44 39
7b 18 74 26 41 83 ff 05 74 20 48 8b 1b 48 3b 1d
f2 b9 f4 00 0f 84 9c 01 00 00 <44> 85 73 10 74 ea
44 8b 6b 14 41 f6 c5 01 75 d4 41 f6 c5 02 74 0f
RSP: 0018:ff71570009e07a80 EFLAGS: 00010207
RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000200
RDX: ffffffffad8dc7c0 RSI: 0000000024924925 RDI: ff3e27850dea2000
RBP: 0000000000000000 R08: 0000000000000000 R09: ffffffffabfce739
R10: ff3e27810cc42400 R11: 0000000000000000 R12: ff3e2781825ef970
R13: 00000000ff3e2785 R14: 000000000000000c R15: 0000000000000001
FS: 00007f5195b51740(0000)
GS:ff3e278b12d40000(0000) knlGS:0000000000000000
CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000000000000010 CR3: 0000000626d24002 CR4: 0000000000361ee0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
ima\_get\_action+0x22/0x30
process\_measurement+0xb0/0x830
? page\_add\_file\_rmap+0x15/0x170
? alloc\_set\_pte+0x269/0x4c0
? prep\_new\_page+0x81/0x140
? simple\_xattr\_get+0x75/0xa0
? selinux\_file\_open+0x9d/0xf0
ima\_file\_check+0x64/0x90
path\_openat+0x571/0x1720
do\_filp\_open+0x9b/0x110
? page\_counter\_try\_charge+0x57/0xc0
? files\_cgroup\_alloc\_fd+0x38/0x60
? \_\_alloc\_fd+0xd4/0x250
? do\_sys\_open+0x1bd/0x250
do\_sys\_open+0x1bd/0x250
do\_syscall\_64+0x5d/0x1d0
entry\_SYSCALL\_64\_after\_hwframe+0x65/0xca
Commit c7423dbdbc9e ("ima: Handle -ESTALE returned by
ima\_filter\_rule\_match()") introduced call to ima\_lsm\_copy\_rule within a
RCU read-side critical section which contains kmalloc with GFP\_KERNEL.
This implies a possible sleep and violates limitations of RCU read-side
critical sections on non-PREEMPT systems.
Sleeping within RCU read-side critical section might cause
synchronize\_rcu() returning early and break RCU protection, allowing a
UAF to happen.
The root cause of this issue could be described as follows:
| Thread A | Thread B |
| |ima\_match\_policy |
| | rcu\_read\_lock |
|ima\_lsm\_update\_rule | |
| synchronize\_rcu | |
| | kmalloc(GFP\_KERNEL)|
| | sleep |
==> synchronize\_rcu returns early
| kfree(entry) | |
| | entry = entry->next|
==> UAF happens and entry now becomes NULL (or could be anything).
| | entry->action |
==> Accessing entry might cause panic.
To fix this issue, we are converting all kmalloc that is called within
RCU read-side critical section to use GFP\_ATOMIC.
Fixes: c7423dbdbc9e ("ima: Handle -ESTALE returned by ima\_filter\_rule\_match()")
Cc: stable@vger.kernel.org
Signed-off-by: GUO Zihua <guozihua@huawei.com>
Acked-by: John Johansen <john.johansen@canonical.com>
Reviewed-by: Mimi Zohar <zohar@linux.ibm.com>
Reviewed-by: Casey Schaufler <casey@schaufler-ca.com>
[PM: fixed missing comment, long lines, !CONFIG\_IMA\_LSM\_RULES case]
Signed-off-by: Paul Moore <paul@paul-moore.com>
Signed-off-by: Roberto Sassu <roberto.sassu@huawei.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0)

| -rw-r--r-- | [include/linux/lsm\_hook\_defs.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/lsm_hook_defs.h?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0) | 2 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/linux/security.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/security.h?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/auditfilter.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/auditfilter.c?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/apparmor/audit.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/apparmor/audit.c?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0) | 6 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/apparmor/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/apparmor/include/audit.h?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/integrity/ima/ima.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/integrity/ima/ima.h?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/integrity/ima/ima\_policy.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/integrity/ima/ima_policy.c?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0) | 15 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/security.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/security.c?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0) | 6 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/selinux/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/selinux/include/audit.h?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/selinux/ss/services.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/selinux/ss/services.c?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/smack/smack\_lsm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/security/smack/smack_lsm.c?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0) | 4 | |  |  |  | | --- | --- | --- | |

11 files changed, 34 insertions, 22 deletions

| diff --git a/include/linux/lsm\_hook\_defs.h b/include/linux/lsm\_hook\_defs.hindex 6239a378c0ea8b..0b4f7289951a45 100644--- a/[include/linux/lsm\_hook\_defs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/lsm_hook_defs.h?id=ee42c150831324b95412b34afcd2a0176cb0a942)+++ b/[include/linux/lsm\_hook\_defs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/lsm_hook_defs.h?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0)@@ -382,7 +382,7 @@ LSM\_HOOK(int, 0, key\_getsecurity, struct key \*key, char \*\*\_buffer)  #ifdef CONFIG\_AUDIT LSM\_HOOK(int, 0, audit\_rule\_init, u32 field, u32 op, char \*rulestr,- void \*\*lsmrule)+ void \*\*lsmrule, gfp\_t gfp) LSM\_HOOK(int, 0, audit\_rule\_known, struct audit\_krule \*krule) LSM\_HOOK(int, 0, audit\_rule\_match, u32 secid, u32 field, u32 op, void \*lsmrule) LSM\_HOOK(void, LSM\_RET\_VOID, audit\_rule\_free, void \*lsmrule)diff --git a/include/linux/security.h b/include/linux/security.hindex 2772f6375f1401..c33c95f409eb67 100644--- a/[include/linux/security.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/security.h?id=ee42c150831324b95412b34afcd2a0176cb0a942)+++ b/[include/linux/security.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/security.h?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0)@@ -1921,7 +1921,8 @@ static inline int security\_key\_getsecurity(struct key \*key, char \*\*\_buffer)  #ifdef CONFIG\_AUDIT #ifdef CONFIG\_SECURITY-int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*lsmrule);+int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*lsmrule,+ gfp\_t gfp); int security\_audit\_rule\_known(struct audit\_krule \*krule); int security\_audit\_rule\_match(u32 secid, u32 field, u32 op, void \*lsmrule); void security\_audit\_rule\_free(void \*lsmrule);@@ -1929,7 +1930,7 @@ void security\_audit\_rule\_free(void \*lsmrule); #else  static inline int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr,- void \*\*lsmrule)+ void \*\*lsmrule, gfp\_t gfp) { return 0; }diff --git a/kernel/auditfilter.c b/kernel/auditfilter.cindex 42d99896e7a6ec..6c9a4d322309f2 100644--- a/[kernel/auditfilter.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/auditfilter.c?id=ee42c150831324b95412b34afcd2a0176cb0a942)+++ b/[kernel/auditfilter.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/auditfilter.c?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0)@@ -529,7 +529,8 @@ static struct audit\_entry \*audit\_data\_to\_entry(struct audit\_rule\_data \*data, entry->rule.buflen += f\_val; f->lsm\_str = str; err = security\_audit\_rule\_init(f->type, f->op, str,- (void \*\*)&f->lsm\_rule);+ (void \*\*)&f->lsm\_rule,+ GFP\_KERNEL); /\* Keep currently invalid fields around in case they \* become valid after a policy reload. \*/ if (err == -EINVAL) {@@ -798,7 +799,7 @@ static inline int audit\_dupe\_lsm\_field(struct audit\_field \*df,  /\* our own (refreshed) copy of lsm\_rule \*/ ret = security\_audit\_rule\_init(df->type, df->op, df->lsm\_str,- (void \*\*)&df->lsm\_rule);+ (void \*\*)&df->lsm\_rule, GFP\_KERNEL); /\* Keep currently invalid fields around in case they \* become valid after a policy reload. \*/ if (ret == -EINVAL) {diff --git a/security/apparmor/audit.c b/security/apparmor/audit.cindex 704b0c895605a7..963df28584eed7 100644--- a/[security/apparmor/audit.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/apparmor/audit.c?id=ee42c150831324b95412b34afcd2a0176cb0a942)+++ b/[security/apparmor/audit.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/apparmor/audit.c?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0)@@ -173,7 +173,7 @@ void aa\_audit\_rule\_free(void \*vrule) } } -int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule)+int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule, gfp\_t gfp) { struct aa\_audit\_rule \*rule; @@ -186,14 +186,14 @@ int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule) return -EINVAL; } - rule = kzalloc(sizeof(struct aa\_audit\_rule), GFP\_KERNEL);+ rule = kzalloc(sizeof(struct aa\_audit\_rule), gfp);  if (!rule) return -ENOMEM;  /\* Currently rules are treated as coming from the root ns \*/ rule->label = aa\_label\_parse(&root\_ns->unconfined->label, rulestr,- GFP\_KERNEL, true, false);+ gfp, true, false); if (IS\_ERR(rule->label)) { int err = PTR\_ERR(rule->label); aa\_audit\_rule\_free(rule);diff --git a/security/apparmor/include/audit.h b/security/apparmor/include/audit.hindex 18519a4eb67e3c..f325f1bef8d6da 100644--- a/[security/apparmor/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/apparmor/include/audit.h?id=ee42c150831324b95412b34afcd2a0176cb0a942)+++ b/[security/apparmor/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/apparmor/include/audit.h?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0)@@ -186,7 +186,7 @@ static inline int complain\_error(int error) }  void aa\_audit\_rule\_free(void \*vrule);-int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule);+int aa\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule, gfp\_t gfp); int aa\_audit\_rule\_known(struct audit\_krule \*rule); int aa\_audit\_rule\_match(u32 sid, u32 field, u32 op, void \*vrule); diff --git a/security/integrity/ima/ima.h b/security/integrity/ima/ima.hindex be965a8715e4e2..c80bc15b4486ed 100644--- a/[security/integrity/ima/ima.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/integrity/ima/ima.h?id=ee42c150831324b95412b34afcd2a0176cb0a942)+++ b/[security/integrity/ima/ima.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/integrity/ima/ima.h?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0)@@ -428,7 +428,7 @@ static inline void ima\_free\_modsig(struct modsig \*modsig) #else  static inline int ima\_filter\_rule\_init(u32 field, u32 op, char \*rulestr,- void \*\*lsmrule)+ void \*\*lsmrule, gfp\_t gfp) { return -EINVAL; }diff --git a/security/integrity/ima/ima\_policy.c b/security/integrity/ima/ima\_policy.cindex bdc40535ff4891..1f930711db769c 100644--- a/[security/integrity/ima/ima\_policy.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/integrity/ima/ima_policy.c?id=ee42c150831324b95412b34afcd2a0176cb0a942)+++ b/[security/integrity/ima/ima\_policy.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/integrity/ima/ima_policy.c?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0)@@ -377,7 +377,8 @@ static void ima\_free\_rule(struct ima\_rule\_entry \*entry) kfree(entry); } -static struct ima\_rule\_entry \*ima\_lsm\_copy\_rule(struct ima\_rule\_entry \*entry)+static struct ima\_rule\_entry \*ima\_lsm\_copy\_rule(struct ima\_rule\_entry \*entry,+ gfp\_t gfp) { struct ima\_rule\_entry \*nentry; int i;@@ -386,7 +387,7 @@ static struct ima\_rule\_entry \*ima\_lsm\_copy\_rule(struct ima\_rule\_entry \*entry) \* Immutable elements are copied over as pointers and data; only \* lsm rules can change \*/- nentry = kmemdup(entry, sizeof(\*nentry), GFP\_KERNEL);+ nentry = kmemdup(entry, sizeof(\*nentry), gfp); if (!nentry) return NULL; @@ -401,7 +402,8 @@ static struct ima\_rule\_entry \*ima\_lsm\_copy\_rule(struct ima\_rule\_entry \*entry)  ima\_filter\_rule\_init(nentry->lsm[i].type, Audit\_equal, nentry->lsm[i].args\_p,- &nentry->lsm[i].rule);+ &nentry->lsm[i].rule,+ gfp); if (!nentry->lsm[i].rule) pr\_warn("rule for LSM \'%s\' is undefined\n", nentry->lsm[i].args\_p);@@ -414,7 +416,7 @@ static int ima\_lsm\_update\_rule(struct ima\_rule\_entry \*entry) int i; struct ima\_rule\_entry \*nentry; - nentry = ima\_lsm\_copy\_rule(entry);+ nentry = ima\_lsm\_copy\_rule(entry, GFP\_KERNEL); if (!nentry) return -ENOMEM; @@ -638,7 +640,7 @@ retry: }  if (rc == -ESTALE && !rule\_reinitialized) {- lsm\_rule = ima\_lsm\_copy\_rule(rule);+ lsm\_rule = ima\_lsm\_copy\_rule(rule, GFP\_ATOMIC); if (lsm\_rule) { rule\_reinitialized = true; goto retry;@@ -1113,7 +1115,8 @@ static int ima\_lsm\_rule\_init(struct ima\_rule\_entry \*entry, entry->lsm[lsm\_rule].type = audit\_type; result = ima\_filter\_rule\_init(entry->lsm[lsm\_rule].type, Audit\_equal, entry->lsm[lsm\_rule].args\_p,- &entry->lsm[lsm\_rule].rule);+ &entry->lsm[lsm\_rule].rule,+ GFP\_KERNEL); if (!entry->lsm[lsm\_rule].rule) { pr\_warn("rule for LSM \'%s\' is undefined\n", entry->lsm[lsm\_rule].args\_p);diff --git a/security/security.c b/security/security.cindex 1b504c296551cc..fb1692254851b2 100644--- a/[security/security.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/security.c?id=ee42c150831324b95412b34afcd2a0176cb0a942)+++ b/[security/security.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/security.c?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0)@@ -2617,9 +2617,11 @@ int security\_key\_getsecurity(struct key \*key, char \*\*\_buffer)  #ifdef CONFIG\_AUDIT -int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*lsmrule)+int security\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*lsmrule,+ gfp\_t gfp) {- return call\_int\_hook(audit\_rule\_init, 0, field, op, rulestr, lsmrule);+ return call\_int\_hook(audit\_rule\_init, 0, field, op, rulestr, lsmrule,+ gfp); }  int security\_audit\_rule\_known(struct audit\_krule \*krule)diff --git a/security/selinux/include/audit.h b/security/selinux/include/audit.hindex 406bceb90c6cde..ef54f61a306694 100644--- a/[security/selinux/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/selinux/include/audit.h?id=ee42c150831324b95412b34afcd2a0176cb0a942)+++ b/[security/selinux/include/audit.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/selinux/include/audit.h?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0)@@ -21,12 +21,14 @@ \* @op: the operator the rule uses \* @rulestr: the text "target" of the rule \* @rule: pointer to the new rule structure returned via this+ \* @gfp: GFP flag used for kmalloc \* \* Returns 0 if successful, -errno if not. On success, the rule structure \* will be allocated internally. The caller must free this structure with \* selinux\_audit\_rule\_free() after use. \*/-int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*rule);+int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*rule,+ gfp\_t gfp);  /\*\* \* selinux\_audit\_rule\_free - free an selinux audit rule structure.diff --git a/security/selinux/ss/services.c b/security/selinux/ss/services.cindex 64a6a37dc36d9a..2b8ebd390e3755 100644--- a/[security/selinux/ss/services.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/selinux/ss/services.c?id=ee42c150831324b95412b34afcd2a0176cb0a942)+++ b/[security/selinux/ss/services.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/selinux/ss/services.c?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0)@@ -3563,7 +3563,8 @@ void selinux\_audit\_rule\_free(void \*vrule) } } -int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule)+int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule,+ gfp\_t gfp) { struct selinux\_state \*state = &selinux\_state; struct selinux\_policy \*policy;@@ -3604,7 +3605,7 @@ int selinux\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule) return -EINVAL; } - tmprule = kzalloc(sizeof(struct selinux\_audit\_rule), GFP\_KERNEL);+ tmprule = kzalloc(sizeof(struct selinux\_audit\_rule), gfp); if (!tmprule) return -ENOMEM; diff --git a/security/smack/smack\_lsm.c b/security/smack/smack\_lsm.cindex feba69549d0865..b0a483e40c827a 100644--- a/[security/smack/smack\_lsm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/smack/smack_lsm.c?id=ee42c150831324b95412b34afcd2a0176cb0a942)+++ b/[security/smack/smack\_lsm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/security/smack/smack_lsm.c?id=9c3906c3738562b1fedc6f1cfc81756a7cfefff0)@@ -4552,11 +4552,13 @@ static int smack\_post\_notification(const struct cred \*w\_cred, \* @op: required testing operator (=, !=, >, <, ...) \* @rulestr: smack label to be audited \* @vrule: pointer to save our own audit rule representation+ \* @gfp: type of the memory for the allocation \* \* Prepare to audit cases where (@field @op @rulestr) is true. \* The label to be audited is created if necessay. \*/-static int smack\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule)+static int smack\_audit\_rule\_init(u32 field, u32 op, char \*rulestr, void \*\*vrule,+ gfp\_t gfp) { struct smack\_known \*skp; char \*\*rule = (char \*\*)vrule; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 22:19:22 +0000


