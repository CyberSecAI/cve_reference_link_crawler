
# The Marvin Attack

* [Paper](#paper)
* [Q&A](#question-answer)

The Marvin Attack is a return of a 25 year old vulnerability that
allows performing RSA decryption and signing operations as an attacker
with the ability to observe only the time of the decryption operation
performed with the private key.

In 1998, Daniel Bleichenbacher discovered that the error
messages given by SSL servers for errors in the PKCS #1 v1.5
padding allowed an adaptive-chosen ciphertext attack; this attack
fully breaks the confidentiality of TLS when used with RSA
encryption.
[In 2018](https://robotattack.org/),
Hanno Böck, Juraj Somorovsky, and Craig Young have
shown 19 years later that many internet servers were still vulnerable
to slight variations of the original attack.

We show that many implementations previously thought
immune, are vulnerable to the timing variant of the same attack.

While the main venue of attack are TLS servers, the core issues
that caused its wide spread are applicable to most
asymmetric cryptographic algorithms (Diffie-Hellman, ECDSA, etc.),
not just to RSA. Lessons learned are also applicable to testing
the majority of cryptographic algorithms that can be vulnerable to
side-channel attacks, not just public key cryptography.

### What can the attackers gain?

For a vulnerable implementation the attacker is able to decrypt
RSA ciphertexts and forge signatures.

For a TLS server that defaults to RSA encryption key exchanges, that
means the attacker can record a session and decrypt it later.

For TLS hosts that use forward secure ciphersuites, the attacker
would have to perform a massively parallel attack to forge a server
signature before a client would time out during the connection attempt.
That makes the attack hard, but not impossible.

The attack is also applicable to other interfaces that perform
RSA decryption in automated manner but don't provide the attacker
ability to perform
arbitrary operations with the private key. Examples include
S/MIME, JSON web tokens, or hardware tokens (HSMs, smartcards, etc.).

### Who is affected?

We have identified the vulnerability in multiple implementations
and confirmed fixes in few of them,
but belive that most of cryptographic implementations are vulnerable
in practice.

| .Net | [API for side-channel free decryption of RSA PKCS#1 v1.5 ciphertexts](https://github.com/dotnet/runtime/issues/97866) | *no CVE* |
| --- | --- | --- |
| Apple corecrypto | [An attacker may be able to decrypt legacy RSA PKCS#1 v1.5 ciphertexts without having the private key](https://support.apple.com/en-us/HT214061) | [CVE-2024-23218](https://nvd.nist.gov/vuln/detail/CVE-2024-23218) |
| BouncyCastle | [BouncyCastle vulnerable to a timing variant of Bleichenbacher called Marvin Attack](https://github.com/bcgit/bc-java/issues/1528) | [CVE-2024-30171](https://nvd.nist.gov/vuln/detail/CVE-2024-30171) |
| cjose | [Make RSA PKCS 1 optional](https://github.com/OpenIDC/cjose/pull/22) | *no CVE* |
| cryptlib | cryptlib RSA key exchange ciphersuites in TLS vulnerable to Marvin Attack | [CVE-2024-0202](https://nvd.nist.gov/vuln/detail/CVE-2024-0202) |
| Crypto++ | [Crypto++ vulnerable to the Marvin Attack](https://github.com/weidai11/cryptopp/issues/1247) | *no CVE* |
| Erlang/OTP | [Add warnings not to enable RSA-key exchange suites](https://github.com/erlang/otp/commit/67aa13de6a62848bbf8bbb8f251d07b138609eb7) | *no CVE* |
| GnuTLS (TLS level) | [A vulnerability was found that the response times to malformed RSA ciphertexts in ClientKeyExchange differ from response times of ciphertexts with correct PKCS#1 v1.5 padding.](https://gnutls.org/security-new.html#GNUTLS-SA-2020-07-14), [A vulnerability was found that the response times to malformed ciphertexts in RSA-PSK ClientKeyExchange differ from response times of ciphertexts with correct PKCS#1 v1.5 padding.](https://gnutls.org/security-new.html#GNUTLS-SA-2023-10-23), and [GnuTLS has incomplete fix for CVE-2023-5981](https://gnutls.org/security-new.html#GNUTLS-SA-2024-01-14) | [CVE-2023-0361](https://nvd.nist.gov/vuln/detail/CVE-2023-0361) [CVE-2023-5981](https://nvd.nist.gov/vuln/detail/CVE-2023-5981) [CVE-2024-0553](https://nvd.nist.gov/vuln/detail/CVE-2024-0553) |
| Go | [crypto/rsa now uses a new, safer, constant-time backend.](https://go.dev/doc/go1.20#cryptorsapkgcryptorsa) | [CVE-2023-45287](https://nvd.nist.gov/vuln/detail/CVE-2023-45287) |
| GSKit | [IBM GSKit information disclosure](https://exchange.xforce.ibmcloud.com/vulnerabilities/255828) | [CVE-2023-32342](https://nvd.nist.gov/vuln/detail/CVE-2023-32342) |
| Intel QuickAssist Technology Engine for OpenSSL | [INTEL-SA-01177 security advisory](https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-01177.html) | [CVE-2024-33617](https://nvd.nist.gov/vuln/detail/CVE-2024-33617) [CVE-2024-28885](https://nvd.nist.gov/vuln/detail/CVE-2024-28885) [CVE-2024-31074](https://nvd.nist.gov/vuln/detail/CVE-2024-31074) |
| iperf3 | [iperf-3.17](https://github.com/esnet/iperf/releases/tag/3.17) [RSA padding update for authentication feature](https://github.com/esnet/iperf/pull/1695) | [CVE-2024-26306](https://nvd.nist.gov/vuln/detail/CVE-2024-26306) |
| Java | [Critical Patch Update Advisory - January 2024](https://www.oracle.com/security-alerts/cpujan2024.html), [OpenJDK Vulnerability Advisory: 2024/01/16](https://openjdk.org/groups/vulnerability/advisories/2024-01-16) | [CVE-2024-20952](https://nvd.nist.gov/vuln/detail/CVE-2024-20952) |
| jsrsasign | [jsrsasign vulnerable to the Marvin Attack](https://github.com/kjur/jsrsasign/issues/598) | [CVE-2024-21484](https://nvd.nist.gov/vuln/detail/CVE-2024-21484) |
| libgcrypt | [Side-channel vulnerability in libgcrypt - the Marvin Attack](https://lists.gnupg.org/pipermail/gcrypt-devel/2024-March/005607.html) | [CVE-2024-2236](https://nvd.nist.gov/vuln/detail/CVE-2024-2236) |
| Linux Kernel | A Marvin vulnerability side-channel leakage was found in the RSA decryption operation in the Linux Kernel. | [CVE-2023-6240](https://nvd.nist.gov/vuln/detail/CVE-2023-6240) |
| M2Crypto | [Mitigate the Bleichenbacher timing attacks in the RSA decryption API (CVE-2020-25657)](https://gitlab.com/m2crypto/m2crypto/-/merge_requests/273); [verified ineffective](https://gitlab.com/m2crypto/m2crypto/-/issues/342), requires [OpenSSL level fix instead](https://github.com/openssl/openssl/pull/13817) | [CVE-2020-25657](https://nvd.nist.gov/vuln/detail/CVE-2020-25657) [CVE-2023-50781](https://nvd.nist.gov/vuln/detail/CVE-2023-50781) |
| Mbed TLS | [Timing side channel in private key RSA operations.](https://mbed-tls.readthedocs.io/en/latest/security-advisories/mbedtls-security-advisory-2024-01-1/) | [CVE-2024-23170](https://nvd.nist.gov/vuln/detail/CVE-2024-23170) |
| node-rsa | [node-rsa vulnerable to the Marvin Attack](https://github.com/rzcoder/node-rsa/issues/230) | *no CVE* |
| Node.js | [Node.js is vulnerable to the Marvin Attack (timing variant of the Bleichenbacher attack against PKCS#1 v1.5 padding)](https://nodejs.org/en/blog/vulnerability/february-2024-security-releases#nodejs-is-vulnerable-to-the-marvin-attack-timing-variant-of-the-bleichenbacher-attack-against-pkcs1-v15-padding-cve-2023-46809---medium) | [CVE-2023-46809](https://nvd.nist.gov/vuln/detail/CVE-2023-46809) |
| NSS (TLS level) | [Improve constant-timeness in RSA operations.](https://hg.mozilla.org/projects/nss/rev/fc05574c739947d615ab0b2b2b564f01c922eccd) released in 3.61; significant improvement, but not a complete fix, remains vulnerable (see CVE-2023-5388) | [CVE-2023-4421](https://nvd.nist.gov/vuln/detail/CVE-2023-4421) [CVE-2023-5388](https://nvd.nist.gov/vuln/detail/CVE-2023-5388) |
| opencryptoki | [opencryptoki vulnerable to the Marvin Attack](https://github.com/opencryptoki/opencryptoki/issues/731) | [CVE-2024-0914](https://nvd.nist.gov/vuln/detail/CVE-2024-0914) |
| OpenSC | [Marvin: Side-channel leaks while stripping encryption PKCS#1.5 padding in OpenSC](https://github.com/OpenSC/OpenSC/wiki/CVE-2023-5992) and a [pull request](https://github.com/OpenSC/OpenSC/pull/2948) | [CVE-2023-5992](https://nvd.nist.gov/vuln/detail/CVE-2023-5992) [CVE-2024-29995](https://nvd.nist.gov/vuln/detail/CVE-2024-29995) |
| OpenSSL (TLS level) | [Timing Oracle in RSA Decryption](https://www.openssl.org/news/secadv/20230207.txt) | [CVE-2022-4304](https://nvd.nist.gov/vuln/detail/CVE-2022-4304) |
| OpenSSL (API level) | [Make RSA decryption API safe to use with PKCS#1 v1.5 padding](https://github.com/openssl/openssl/pull/13817) | *no CVE* |
| OpenSSL-ibmca | [Constant-time fixes for RSA PKCS#1 v1.5 and OAEP padding](https://github.com/opencryptoki/openssl-ibmca/blob/master/ChangeLog) in version 2.4.0 | *no CVE* |
| @peculiar/webcrypto | [@peculiar/webcrypto is vulnerable to the Marvin Attack](https://github.com/PeculiarVentures/webcrypto/issues/66) | *no CVE* |
| perl Crypt-OpenSSL-RSA | [Crypt-OpenSSL-RSA vulnerable to the Marvin Attack](https://github.com/toddr/Crypt-OpenSSL-RSA/issues/42) | [CVE-2024-2467](https://nvd.nist.gov/vuln/detail/CVE-2024-2467) |
| pkcs11-provider | [Side-channel proofing PKCS#1 1.5 paths](https://github.com/latchset/pkcs11-provider/pull/308) | [CVE-2023-6258](https://nvd.nist.gov/vuln/detail/CVE-2023-6258) |
| pyca/cryptography | [Attempt to mitigate Bleichenbacher attacks on RSA decryption](https://github.com/pyca/cryptography/pull/5507); [verified ineffective](https://github.com/pyca/cryptography/issues/9785), requires [OpenSSL level fix instead](https://github.com/openssl/openssl/pull/13817) | [CVE-2020-25659](https://nvd.nist.gov/vuln/detail/CVE-2020-25659) [CVE-2023-50782](https://nvd.nist.gov/vuln/detail/CVE-2023-50782) |
| PyCryptodome | [Fixed a side-channel leakage with OAEP decryption that could be exploited to carry out a Manger attack](https://github.com/Legrandin/pycryptodome/commit/afb5e27a15efe59e33c2825d40ef44995c13b8bc), and a [changelog entry](https://github.com/Legrandin/pycryptodome/blob/master/Changelog.rst#3191-28-december-2023) | [CVE-2023-52323](https://nvd.nist.gov/vuln/detail/CVE-2023-52323) |
| python-rsa | [Fix #165: CVE-2020-25658 - Bleichenbacher-style timing oracle](https://github.com/sybrenstuvel/python-rsa/commit/dae8ce0d85478e16f2368b2341632775313d41ed); [verified ineffective](https://github.com/sybrenstuvel/python-rsa/issues/230), side-channel attacks declared out of scope for library | [CVE-2020-25658](https://nvd.nist.gov/vuln/detail/CVE-2020-25658) |
| Ruby | [ruby: openssl: Ruby Marvin Attack](https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2025-0306) | [CVE-2025-0306](https://nvd.nist.gov/vuln/detail/CVE-2025-0306) |
| RustCrypto RSA | [modpow implementation is not constant-time](https://github.com/RustCrypto/RSA/issues/19#issuecomment-1822995643) | [CVE-2023-49092](https://nvd.nist.gov/vuln/detail/CVE-2023-49092) |
| Rust OpenSSL | [rust-openssl is vulnerable to the Marvin Attack](https://github.com/sfackler/rust-openssl/issues/2171) | [CVE-2024-3296](https://nvd.nist.gov/vuln/detail/CVE-2024-3296) |
| s2n | [Potentially observable differences in RSA premaster secret handling](https://github.com/aws/s2n-tls/security/advisories/GHSA-52xf-5p2m-9wrv) | *no CVE* |
| WolfSSL | [RSA private exponentiation: multiply blinding invert in Mont](https://github.com/wolfSSL/wolfssl/pull/6955), [v5.6.6 release notes](https://github.com/wolfSSL/wolfssl/releases/tag/v5.6.6-stable) | [CVE-2023-6935](https://nvd.nist.gov/vuln/detail/CVE-2023-6935) |
| xmlsec | [Disable pkcs 1.5](https://github.com/lsh123/xmlsec/issues/775) | *no CVE* |

We also found few APIs that are handling errors or numbers in a way
that will be vulnerable to timing attacks.

| Go | [crypto/rsa DecryptPKCS1v15SessionKey](https://pkg.go.dev/crypto/rsa#DecryptPKCS1v15SessionKey) | limited leakage1 |
| --- | --- | --- |
| GNU MP | [mpz\_powm\_sec](https://gmplib.org/manual/Integer-Exponentiation) | leaks zero high order bits in result |

1. The API may be secure only if the returned data is used with a KDF that is fed also random, outside attacker's control, data, like in TLS

Finally, so far, we have verified just two implementations that
were not vulnerable
when tested in at least one environment:

| [BearSSL](https://www.bearssl.org/) 0.6 | Intel i9-12900KS @ 5.225 GHz, x86\_64, Friedman test negative (p-value=0.152, n=22.2M, k=36), 95% confidence interval for 25% trimmed mean of pairwise differences: ±466ps. |
| --- | --- |
| BoringSSL ([6 Sep 2023](https://github.com/google/boringssl/commit/be84aeed7), TLS) | Intel i9-12900KS @ 5.225 GHz, x86\_64, Friedman test negative (p-value=0.074, n=17.3M, k=36), 95% confidence interval for 45% trimmed mean of pairwise differences: ±574 ps. |
| [rustls](https://crates.io/crates/rustls) 0.21.9 (TLS) | no support for TLS\_RSA\_\* ciphersuites (inherently not vulnerable) |

Implementations not listed above have either not been tested
or have been verified as vulnerable, but the issues are still
embargoed.
We will continue updating the lists as we learn of new vulnerabilites
or once embargoes are lifted.

We have provided tools to detect the issue both on TLS server
level and help with testing on API level.

### What should I do?

If you use one of the affected implementations, you should install
the relevant updates. However we are reiterating the previous
recommendations:

#### Stop using RSA PKCS#1 v1.5 encryption!

On the TLS level, only servers that enable RSA encryption are
affected. Most modern clients support the use of Elliptic Curve Diffie
Hellman, thus disabling ciphersuites that use RSA encryption is
the recommended way to fix this vulnerability.

Older clients will be able to use Finite Field Diffie Hellman,
which will be secure as long as server uses fresh DHE key shares
for every connection (protection against the Raccoon attack) and
well known parameters (or safe primes in general) for the general
protection against cryptologic attacks. Both of those things
are trivial to check for and verify compared to testing, let alone
fixing, the issues in the RSA key exchange.

#### I depend on this legacy mode

While cryptographic protocols and formats allow, and have defaulted
to use of the
PKCS#1 v1.5 padding, they either don't need it any more for
interoperability (like TLS), or have been updated to support
RSA-OAEP (S/MIME, JWT, etc.). If your software or hardware doesn't
allow use of RSA-OAEP, pressure the vendor to fix it.

#### I'm a developer of a cryptographic library

Our recommendation is similar: deprecate and disable support for
PKCS#1 v1.5 padding for encryption. While we do provide a way to
handle errors in a way that should be compatible with any API
and not leak the information relevant to the Bleichenbacher attack
to the calling application **we recommend against its use**.

We have had 25 years of people trying to patch this fundamentally
broken padding mode. ROBOT have shown that the far easier workaround
was implemented incorrectly by a large number of implementations.
Implementing the
Marvin workaround *correctly* is much more tricky, as it must
include actually testing it for side channel leakage.

While we focus on PKCS#1 v1.5, the vulnerability is not limited
to just that mode, any RSA padding mode can be attacked if blinding is
not implemented using side-channel free code, or conversion from
numerical representation to a byte-string is not made using
side-channel free code. You should verify that the deblinding
operation and conversion to byte-string is side-channel free also
with RSA-OAEP and RSASVE interfaces. Only when you're able to
confidently verify that they are side-channel free, we would suggest
looking into making PKCS#1 v1.5 side-channel free.

Finally, we don't believe that this is limited to RSA itself,
any implementation that uses general purpose integer implementation
(like the default mode of OpenSSL's BIGNUM, NSS's MPI,
Java's BigInteger, Python's int, Rust's apint,
Gnu MP's mpz\_t, Go's math/big Int,
etc.) will suffer from the same issues. Given that there are attacks
that exploit high order bits being zero in other algorithms, like
[Minerva](https://minerva.crocs.fi.muni.cz/) against
ECDSA and [Raccoon attack](https://raccoon-attack.com/)
against FFDH (attack against ECDH works fundamentally the same way,
it just requires higher precision of the timing side-channel),
any cryptographic implementation that depends on general purpose
integer arithmetic library will be similarly vulnerable.
See the mpn interface of GNU MP for an example of an
[interface well suited for side-channel free programming](https://gmplib.org/manual/Low_002dlevel-Functions#Low_002dlevel-functions-for-cryptography).

### How do I test for it?

We have released a
[script](https://github.com/tlsfuzzer/tlsfuzzer/blob/master/scripts/test-bleichenbacher-timing-pregenerate.py)
for testing TLS servers as well as
[instructions](https://tlsfuzzer.readthedocs.io/en/latest/timing-analysis.html)
on how to execute it.
It's very reliable (i.e. if it reports a vulnerability, there's
by default a 1 in 100 thousand chance that it's a false positive)
unless it's executed with --static-enc option, or executed
against a server that implements a Marvin workaround.

In case the server implements the Marvin workaround
(implicit rejection), you can
verify that that code is implemented correctly using either the
TLS based [test script](https://github.com/tlsfuzzer/tlsfuzzer/blob/master/scripts/test-bleichenbacher-timing-marvin.py),
or, in case you're testing the API directly,
[a script to generate decryption inputs](https://github.com/tlsfuzzer/tlsfuzzer/blob/master/scripts/marvin-ciphertext-generator.py).

Upon execution the script reports the
[*p*-value](https://en.wikipedia.org/wiki/P-value)
of sign tests
and Friedman test. If they're consistently small or very small (smaller
than 10-9) then it's extremely likely that the tested
implementation is vulnerable.

For testing APIs, we've also prepared few scripts to make testing
them easier in the
[marvin-toolkit](https://github.com/tomato42/marvin-toolkit)
repo.

Please note that to *exclude* the possibility of a side channel
the test needs to report a 95% confidence interval for bootstrapped
differences of around a nanosecond and the statistical tests need
to still be negative (have *p*-values larger than
10-5). In practice that means collecting a data set
of at least few million connections.

### How do I fix it?

While we can't give general instructions, as any fixes depend on
where the leak happens and how the code is implemented, we wrote
a separate article about debugging the code with the use
of the tlsfuzzer tooling in the
[Debugging Timing Side-channel Leaks](https://securitypitfalls.wordpress.com/2023/09/29/debugging-timing-side-channel-leaks/) article.

## Full technical paper

[**Everlasting ROBOT:
the Marvin Attack.**](marvin-attack-paper.pdf) local [PDF]

Hubert Kario
(pre-print)
*28th European Symposium on Research in Computer Security*,
The Hague, Netherlands, September 25-29, 2023

## Supplementary paper

[**Out of the Box Testing**](out-of-the-box-testing.pdf)
[PDF]

Hubert Kario

More: [Cryptology ePrint Archive mirror](https://eprint.iacr.org/2023/1441)

## Q&A

* [Where does the Marvin name comes from?](#faq-name)
* [What are the technical details?](#faq-details)
* [Is there a CVE for the Marvin Attack?](#faq-cve)
* [How easy is it to carry out the attack? Is it practical?](#faq-practical)
* [The test reports a very small side-channel, it means I'm not vulnerable in practice?](#faq-small)
* [Is the vulnerability currently being exploited by attackers?](#faq-exploited)
* [RSA PKCS#1 v1.5 has been known to be insecure for 25 years. What’s the big deal?](#faq-whycare)
* [I don't use RSA with PKCS#1 v1.5 padding, only OAEP, does that mean I'm safe?"](#faq-oaep)
* [Does the Marvin Attack allow an attacker to steal the server’s private key?](#faq-privatekey)
* [Can the Marvin Attack be also used to perform MitM attacks?](#faq-mitm)
* [Do I need to get a new certificate for my server?](#faq-cert)
* [Do I need to update my browser?](#faq-update)
* [Can I detect if someone has exploited this against me?](#faq-detect)
* [My cryptographic module is FIPS certified, do I still have to take action?](#faq-fips)
* [SSLLabs says I have RSA disabled. That means I’m safe, right?](#faq-ssllabs)
* [Are you planning to release the code for your implementation of the attack?](#faq-code)
* [What factors contributed to the Marvin Attack?](#faq-factors)
* [Why did this research take so long?](#faq-time)
* [I'd like to learn about side-channel attacks, do you have some example code for that?](#faq-example)
* [How is this related to previous research?](#faq-previous)

#### Where does the Marvin name comes from?

The previous comprehensive attack against RSA was called ROBOT.
Given the
complexity and fragility of required fixes we don't believe that this
attack will generally go away. Thus we named it after an android
that lasted till the end of the universe in
*The Hitchhiker's Guide to the Galaxy*.

#### What are the technical details?

For the complete details, see
our [full technical
paper](marvin-attack-paper.pdf).

In technical terms, the Marvin Attack is not new, both
vulnerabilities
to timing side-channels and vulnerability of RSA PKCS#1 v1.5 padding
in general were known already in the 1990's.
The main contribution we bring is related to how to test for side
channel timing leakage in a way that provides high accuracy,
high precision (if provided with large data set), and thus very low
false positive rate.
Additionally, because we measure the whole end-to-end operation,
by performing a complete TLS handshake,
we're able to find issues in places other than the low level numerical
calls (e.g. the GnuTLS vulnerability was in code that was making a
decision about what kind of error message to print if debugging
mode was enabled) and able to test different implementations
relatively easily and quickly.

In other words, we got results because we were thorough, not
because we used novel techniques.

#### Is there a CVE for the Marvin Attack?

No. While it is a fundamental flaw in the RSA decryption, it
has been widely known that padding errors need to be handled in
constant time. But because of the complexity of implementing it in
practice, every implementation will likely have a slightly different
bug in the code.

#### How easy is it to carry out the attack? Is it practical?

Yes. We’ve been able to execute the attack against M2Crypto and
pyca/cryptography in just a couple of hours in a normal environment
on a mid-range laptop.
Estimating the practically of attacks on TLS servers is more complex as
it critically depends on the key sizes used, CPU model of the victim,
hardware and OS configuration, the RSA implementation in question, and
how closely to the server can the attacker
co-locate the probe measuring the response times.
For an attacker that can get access to a host connected to the
same network switch as the victim, a worst case scenario (for the
victim) would
require a few days to perform the attack against a vulnerable version
of OpenSSL and couple of hours to attack NSS.

#### The test script reports a very small side-channel, does it mean I'm not vulnerable in practice?

No. While previously the general consensus was that very small
side channels, on the order of a few hundred nanoseconds, were not
considered to be exploitable, that was based on flawed testing.

All statistical tests make some assumptions about tested data.
The most common assumption is that the compared samples are
[Independent and Identically Distributed](https://en.wikipedia.org/wiki/Independent_and_identically_distributed_random_variables) (IID).
That assumption is also central to the Box Test, Kolmogorov-Smirnov
test and Mann-Whitney U test.
In practice, we haven't found that the timing data was independent,
in fact, for many tests of independence, just a few hundred
observations were sufficient to absolutely exclude that possibility.
For context, to get precise measurements we commonly need thousands to
millions of measurements, so the lack of independence will affect
large samples only more.

Since the requirements of the test were not met, it gave incorrect
results and thus incorrect
conclusions from it were drawn.

In our approach to testing, we use
[paired difference tests](https://en.wikipedia.org/wiki/Paired_difference_test) which require idependence of the
*differences* within pairs of measurements, not measurements
themselves. That property is much easier to achieve if we have
complete control over the executed test (in which order the individual
connections are executed), and is met for the collected data.

By using this kind of tests (sign test, Wilcoxon signed-rank test,
bootstrapping of the median of paired differences, etc.) we were able
to both show no false positives for very large samples in practice
(hundreds of millions of observations) and the ability to detect very
small
differences in timing, in the order of a few CPU clock cycles, even
when measuring across a production network, a few kilometers away,
and 6 router hops between
victim and attacker.

In other words, the size of the side channel affects only **how
many** observations will the attacker need to perform, **not if**
they will be able to measure the difference at all.

Also, because the paired difference tests require consistent
environment only within each pair, parallelization of the attack
is trivial.

#### Is the vulnerability currently being exploited by attackers?

While we have no reason to believe that the Marvin Atttack has been
exploited
in the wild prior to this disclosure, the original ROBOT attack did
suggest that timing variants of the vulnerability may also be possible.
Since the details of the
vulnerability are now public, attackers may start exploiting
it at any time, and we recommend taking the
countermeasures [explained above](#mitigation) as
soon as possible.

#### RSA PKCS#1 v1.5 has been known to be insecure for 25 years. What’s the big deal?

Indeed, while problems with RSA PKCS#1 v1.5 padding have been
known for over 25 years, and just as long we had alternatives
in form of RSA-OAEP, protocol and format designers valued backwards
compatibility over inheritent security of better options.
While protocols like S/MIME (a.k.a CMS) also date from that era,
protocols like JSON Web Tokens have been concieved well after
RSA PKCS#1 v1.5 was known to be hard to implement correctly, yet
included it anyway. We need to go to standards as new as WebCrypto
to find standards that omit this bad padding completely.

The other is complacency of implementers and protocol designers
in considering that there are side channels that are "too small to be
detectable". Best illustrated by subsequent versions of TLS, that
included more and more complex workarounds for the attacks against
ciphersuites with CBC padding and RSA key exchange, only to finally
remove them completely in TLS 1.3.

#### I don't use RSA with PKCS#1 v1.5 padding, only OAEP, does that mean I'm safe?

No. At least, not universally. Both OpenSSL and NSS bugs were in
the numerical library, not in the padding or error reporting code.
That code is shared between all padding modes, be it PKCS#1 v1.5, OAEP,
or RSASVE. As such, any decryption operation will leak the same kind
of information, and thus can be used to attack messages encrypted
with any padding method.

Only RSA-OAEP implementations that use constant-time mathematical
library (specifically, constant-time code for deblinding and
converstion of the large precision integer to a byte string),
and ignore the value of the first byte of padding will not
be vulnerable to the Marvin attack.

#### Does the Marvin Attack allow an attacker to steal the server’s private key?

No. The Marvin Attacks allows an attacker to decrypt one ciphertext
(connection) or sign a message at a
time. The attacker does not learn the server’s private
key.

#### Can the Marvin Attack be also used to perform MitM attacks?

Yes, but not easily. If the server supports RSA key exchange
and is vulnerable to the Marvin Attack
it's possible to forge a signature on an arbitrary message,
including a ServerKeyExchange in TLS 1.2 or CertificateVerify in
TLS 1.3. The difficulty is that both of those signatures include
a random value selected by a client. Thus the signature needs to be
forged before the connection times out on the client side. In practice
that means that the attacker will need to attack multiple servers
at once, all of which will need to provide quite clear timing signal.

#### Do I need to get a new certificate for my server?

Probably not. As the attacker does not learn the server’s
private key, there’s no need to obtain new certificates.
While continued use of the same key is necessary for the attacker
to be able to decrypt previous sessions, if the server doesn't
enable RSA encryption ciphersuites the attack is impossible
either way.

#### Do I need to update my browser?

Yes. While there is nothing practical that web browsers or other
client software can do to prevent the Marvin Attack on TLS servers.
The WebCrypto in Firefox does support RSA-OEAP decryption operation
that is vulnerable (CVE-2023-5388), as such you should install
Firefox 124 or Firefox ESR 115.9.0 to fix that.

#### Can I detect if someone has exploited this against me?

Possibly. If you run a server and can be certain no one
made a large number of connections that attempted RSA key exchange
to any of your
servers (for example, by examining IDS or server logs), then
you weren’t attacked. Your logs may contain a small number of
RSA key exchange connections from the Internet-wide scans or
very old clients. In best case scenario an attack requires
tens of thousands of connections per decryption.

#### My cryptographic module is FIPS certified, do I still have to take action?

Yes. FIPS certification for cryptographic modules doesn't require
robust testing of side-channel protections.
Only on Level 4 certification are *protections* against
side-channel attacks mandatory.

#### SSLLabs says I have RSA disabled. That means I’m safe, right?

Unfortunately, no. Although [SSLLabs](https://www.ssllabs.com/ssltest/)
provides an invaluable suite of security tests, right now it
only checks whether your HTTPS server directly allows RSA key exchange.
You’re just as much at risk if your site’s certificate or key
is used anywhere else on a server that does support RSA.
Common examples include SMTP, IMAP, and POP mail servers, and
secondary HTTPS servers used for specific web
applications.

#### Are you planning to release the code for your implementation of the attack?

Sort of... while we have already released the tlsfuzzer scripts
to check if a server is vulnerable or not (i.e. tool to run a single
oracle call), and a toolkit to make testing APIs easier,
we do not plan to release a complete attack script.

#### What factors contributed to the Marvin Attack?

Testing for constant-timeness is *hard*.
While there exists a
[multitude of tools](https://neuromancer.sk/article/26)
to do that, their usability is not conducive to them
being used by
[developers](https://crocs.fi.muni.cz/_media/publications/pdf/2022-sp-jancar.pdf)
or [researchers](https://neuromancer.sk/article/29).

Any tool that requires code annotations to work is also
subject to user error.

The other factor is the disregard of small side-channels,
for example, in TLS 1.2 specification we read:
> This leaves a small timing channel, since MAC
> performance depends to some extent on the size of the data fragment,
> but it is not believed to be large enough to be exploitable, due to
> the large block size of existing MACs and the small size of the
> timing signal.

[RFC5246](https://www.rfc-editor.org/rfc/rfc5246#page-24)

#### Why did this research take so long?

While indeed the first CVEs were assigned in 2020, the last major
fixes were performed in 2023. This was caused by two problems:
first is that we were struggling with false positives caused by
the timing signal generated by the *harness* (test script),
and that caused the other issue. Because of unreliable results
it was hard to pinpoint the particular cause for the timing signal
and without that, it was hard to convince upstream developers to
work on the issue. Only when we created a constant-time test
harness were we able to move forward with fixes (and that happened
in the middle of 2022).

#### I'd like to learn about side-channel attacks, do you have some example code for that?

Yes. If you'd like to see if side-channel attacks are easy
to perform against particularly vulnerable services, or
how introduction of a network between the attacker and the
victim impacts the statistical tests, or even try to implement
simple password comparison using side-channel free code,
we have published a blog post with relevant resources:
[Experiment with side-channel attacks yourself!](https://securitypitfalls.wordpress.com/2023/10/16/experiment-with-side-channel-attacks-yourself/)

#### How is this related to previous research?

First practical timing attacks against DH, RSA, and DSA were presented
[by Paul Kocher in 1996.](https://paulkocher.com/doc/TimingAttacks.pdf).

Originally this type of attack was
[discovered by Daniel Bleichenbacher in 1998](http://archiv.infsec.ethz.ch/education/fs08/secsem/bleichenbacher98.pdf).

Klima, Pokorny and Rosa
[improved the attack and discovered the bad-version oracle in 2003](https://eprint.iacr.org/2003/052).

In 2012 Romain Bardou and others [developed a much more efficient Bleichenbacher attack algorithm](https://eprint.iacr.org/2012/417)
that reduces the number of needed connections.

In 2014
[Christopher Meyer and others discovered Bleichenbacher vulnerabilities in JSSE and other products](https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/meyer)
and describe the first practical timing attacks.

Tibor Jager and colleagues discovered that
[it is possible to use a cross-protocol Bleichenbacher attack against TLS 1.3 and QUIC](https://www.nds.rub.de/media/nds/veroeffentlichungen/2015/08/21/Tls13QuicAttacks.pdf).

The [DROWN attack](https://drownattack.com/) is a protocol
level Bleichenbacher vulnerability in SSL version 2. The DROWN research
also contains further insights on cross-protocol scenarios.

In 2018, Hanno Böck, Juraj Somorovsky, and Craig Young
[did show that a lot of HTTPS
hosts are still vulnerable against a slight variation of the original
Bleichenbacher attack](https://robotattack.org/).

In 2019, Eyal Ronen and others have
[shown that a
lot of cryptographic libraries can be attacked using cache timing
attacks](https://ieeexplore.ieee.org/document/8835216).

## Media, Blogs, and more

itnews: ["Marvin" breathes new life into Bleichenbacher's timing oracle attack](https://www.itnews.com.au/news/marvin-breathes-new-life-into-bleichenbachers-timing-oracle-attack-600636).

The Register: [ROBOT crypto attack on RSA is back as Marvin arrives](https://www.theregister.com/2023/09/26/robot_marvin_rsa/).

Bleeping Computer: [New Marvin attack revives 25-year-old decryption flaw in RSA](https://www.bleepingcomputer.com/news/security/new-marvin-attack-revives-25-year-old-decryption-flaw-in-rsa/).

Cyber Security News: [Marvin Attack: 25-year-old RSA Decryption Vulnerability Disclosed](https://cybersecuritynews.com/marvin-attack-rsa-decryption-vulnerability/).

OpenNET: [Атака Marvin для расшифровки RSA на основе измерения времени операций](https://www.opennet.ru/opennews/art.shtml?num=59848).

SecurityLab: [Новые уязвимости: 25 лет ложной безопасности протокола RSA](https://www.securitylab.ru/news/542181.php).

Bitdefender: [‘Marvin Attack’ Resurgence: 1998 ‘Resolved’ Vulnerability Makes a Comeback](https://www.bitdefender.com/blog/hotforsecurity/marvin-attack-resurgence-1998-resolved-vulnerability-makes-a-comeback/).

IT-Connect: [L’attaque Marvin, le retour d’une vulnérabilité vieille de 25 ans dans le RSA](https://www.it-connect.fr/lattaque-marvin-le-retour-dune-vulnerabilite-vieille-de-25-ans-dans-le-rsa/).

Sophos News: [Serious Security: GnuTLS follows OpenSSL, fixes timing attack bug](https://news.sophos.com/en-us/2023/02/13/serious-security-gnutls-follows-openssl-fixes-timing-attack-bug/).

Des Linux blog: [Marvin Attack, časově založený RSA cracking útok](https://blog.desdelinux.net/cs/marvin-%C3%BAtok-%C3%BAtok-na-crack-rsa-na-z%C3%A1klad%C4%9B-%C4%8Dasu/).

ComputerWeekly.com: [RSA and other crypto systems vulnerable to side-channel attack](https://www.computerweekly.com/news/366554113/RSA-and-other-crypto-systems-vulnerable-to-side-channel-attack).

CNews: [В шифровальных протоколах RSA и SSL жива и пригодна к использованию «дыра», которой 25 лет](https://www.cnews.ru/news/top/2023-10-19_chetvertvekovaya_uyazvimost).

Bulletproof TLS newsletter: [The Bleichenbacher timing side-channel attack strikes TLS again.](https://www.feistyduck.com/bulletproof-tls-newsletter/issue_106_encrypted_client_hello_and_the_last_network_privacy_gap).

Snyk Blog: [Understanding the RSA-based Marvin Attack](https://snyk.io/blog/understanding-rsa-based-marvin-attack/).

Last updated: 7th January 2025.
Adapted from the DROWN and ROBOT websites.
Logo, design and content of this website are under a
[CC0](https://creativecommons.org/publicdomain/zero/1.0/) license.

