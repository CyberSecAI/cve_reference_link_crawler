

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=3bd43374857103ba3cac751d6d4afa8d83b5d92a)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=3bd43374857103ba3cac751d6d4afa8d83b5d92a)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3bd43374857103ba3cac751d6d4afa8d83b5d92a)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3bd43374857103ba3cac751d6d4afa8d83b5d92a)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Filipe Manana <fdmanana@suse.com> | 2023-01-12 16:31:08 +0000 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2023-01-24 07:19:59 +0100 |
| commit | [3bd43374857103ba3cac751d6d4afa8d83b5d92a](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3bd43374857103ba3cac751d6d4afa8d83b5d92a) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=3bd43374857103ba3cac751d6d4afa8d83b5d92a)) | |
| tree | [ee4c41145f8a29c548ef1ce781590da7c16af86e](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=3bd43374857103ba3cac751d6d4afa8d83b5d92a) | |
| parent | [6ee8feca915009f0abaa4f109144bc946d2a1532](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6ee8feca915009f0abaa4f109144bc946d2a1532) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3bd43374857103ba3cac751d6d4afa8d83b5d92a&id2=6ee8feca915009f0abaa4f109144bc946d2a1532)) | |
| download | [linux-3bd43374857103ba3cac751d6d4afa8d83b5d92a.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-3bd43374857103ba3cac751d6d4afa8d83b5d92a.tar.gz) | |

btrfs: fix race between quota rescan and disable leading to NULL pointer derefcommit b7adbf9ada3513d2092362c8eac5cddc5b651f5c upstream.
If we have one task trying to start the quota rescan worker while another
one is trying to disable quotas, we can end up hitting a race that results
in the quota rescan worker doing a NULL pointer dereference. The steps for
this are the following:
1) Quotas are enabled;
2) Task A calls the quota rescan ioctl and enters btrfs\_qgroup\_rescan().
It calls qgroup\_rescan\_init() which returns 0 (success) and then joins a
transaction and commits it;
3) Task B calls the quota disable ioctl and enters btrfs\_quota\_disable().
It clears the bit BTRFS\_FS\_QUOTA\_ENABLED from fs\_info->flags and calls
btrfs\_qgroup\_wait\_for\_completion(), which returns immediately since the
rescan worker is not yet running.
Then it starts a transaction and locks fs\_info->qgroup\_ioctl\_lock;
4) Task A queues the rescan worker, by calling btrfs\_queue\_work();
5) The rescan worker starts, and calls rescan\_should\_stop() at the start
of its while loop, which results in 0 iterations of the loop, since
the flag BTRFS\_FS\_QUOTA\_ENABLED was cleared from fs\_info->flags by
task B at step 3);
6) Task B sets fs\_info->quota\_root to NULL;
7) The rescan worker tries to start a transaction and uses
fs\_info->quota\_root as the root argument for btrfs\_start\_transaction().
This results in a NULL pointer dereference down the call chain of
btrfs\_start\_transaction(). The stack trace is something like the one
reported in Link tag below:
general protection fault, probably for non-canonical address 0xdffffc0000000041: 0000 [#1] PREEMPT SMP KASAN
KASAN: null-ptr-deref in range [0x0000000000000208-0x000000000000020f]
CPU: 1 PID: 34 Comm: kworker/u4:2 Not tainted 6.1.0-syzkaller-13872-gb6bb9676f216 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/26/2022
Workqueue: btrfs-qgroup-rescan btrfs\_work\_helper
RIP: 0010:start\_transaction+0x48/0x10f0 fs/btrfs/transaction.c:564
Code: 48 89 fb 48 (...)
RSP: 0018:ffffc90000ab7ab0 EFLAGS: 00010206
RAX: 0000000000000041 RBX: 0000000000000208 RCX: ffff88801779ba80
RDX: 0000000000000000 RSI: 0000000000000001 RDI: 0000000000000000
RBP: dffffc0000000000 R08: 0000000000000001 R09: fffff52000156f5d
R10: fffff52000156f5d R11: 1ffff92000156f5c R12: 0000000000000000
R13: 0000000000000001 R14: 0000000000000001 R15: 0000000000000003
FS: 0000000000000000(0000) GS:ffff8880b9900000(0000) knlGS:0000000000000000
CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f2bea75b718 CR3: 000000001d0cc000 CR4: 00000000003506e0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
<TASK>
btrfs\_qgroup\_rescan\_worker+0x3bb/0x6a0 fs/btrfs/qgroup.c:3402
btrfs\_work\_helper+0x312/0x850 fs/btrfs/async-thread.c:280
process\_one\_work+0x877/0xdb0 kernel/workqueue.c:2289
worker\_thread+0xb14/0x1330 kernel/workqueue.c:2436
kthread+0x266/0x300 kernel/kthread.c:376
ret\_from\_fork+0x1f/0x30 arch/x86/entry/entry\_64.S:308
</TASK>
Modules linked in:
So fix this by having the rescan worker function not attempt to start a
transaction if it didn't do any rescan work.
Reported-by: syzbot+96977faa68092ad382c4@syzkaller.appspotmail.com
Link: [https://lore.kernel.org/linux-btrfs/000000000000e5454b05f065a803@google.com/](https://lore.kernel.org/linux-btrfs/000000000000e5454b05f065a803%40google.com/)
Fixes: e804861bd4e6 ("btrfs: fix deadlock between quota disable and qgroup rescan worker")
CC: stable@vger.kernel.org # 5.4+
Signed-off-by: Filipe Manana <fdmanana@suse.com>
Signed-off-by: David Sterba <dsterba@suse.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3bd43374857103ba3cac751d6d4afa8d83b5d92a)

| -rw-r--r-- | [fs/btrfs/qgroup.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/qgroup.c?id=3bd43374857103ba3cac751d6d4afa8d83b5d92a) | 25 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 17 insertions, 8 deletions

| diff --git a/fs/btrfs/qgroup.c b/fs/btrfs/qgroup.cindex 74cbbb5d8897f3..9fe6a01ea8b854 100644--- a/[fs/btrfs/qgroup.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/qgroup.c?id=6ee8feca915009f0abaa4f109144bc946d2a1532)+++ b/[fs/btrfs/qgroup.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/qgroup.c?id=3bd43374857103ba3cac751d6d4afa8d83b5d92a)@@ -3296,6 +3296,7 @@ static void btrfs\_qgroup\_rescan\_worker(struct btrfs\_work \*work) int err = -ENOMEM; int ret = 0; bool stopped = false;+ bool did\_leaf\_rescans = false;  path = btrfs\_alloc\_path(); if (!path)@@ -3316,6 +3317,7 @@ static void btrfs\_qgroup\_rescan\_worker(struct btrfs\_work \*work) }  err = qgroup\_rescan\_leaf(trans, path);+ did\_leaf\_rescans = true;  if (err > 0) btrfs\_commit\_transaction(trans);@@ -3336,16 +3338,23 @@ out: mutex\_unlock(&fs\_info->qgroup\_rescan\_lock);  /\*- \* only update status, since the previous part has already updated the- \* qgroup info.+ \* Only update status, since the previous part has already updated the+ \* qgroup info, and only if we did any actual work. This also prevents+ \* race with a concurrent quota disable, which has already set+ \* fs\_info->quota\_root to NULL and cleared BTRFS\_FS\_QUOTA\_ENABLED at+ \* btrfs\_quota\_disable(). \*/- trans = btrfs\_start\_transaction(fs\_info->quota\_root, 1);- if (IS\_ERR(trans)) {- err = PTR\_ERR(trans);+ if (did\_leaf\_rescans) {+ trans = btrfs\_start\_transaction(fs\_info->quota\_root, 1);+ if (IS\_ERR(trans)) {+ err = PTR\_ERR(trans);+ trans = NULL;+ btrfs\_err(fs\_info,+ "fail to start transaction for status update: %d",+ err);+ }+ } else { trans = NULL;- btrfs\_err(fs\_info,- "fail to start transaction for status update: %d",- err); }  mutex\_lock(&fs\_info->qgroup\_rescan\_lock); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 15:30:36 +0000

