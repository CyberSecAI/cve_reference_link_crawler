=== Content from lore.kernel.org_28ebbd9f_20250108_132749.html ===

```
[linux-kernel.vger.kernel.org archive mirror](../?t=20220915020848)
 [help](../_/text/help/) / [color](../_/text/color/) / [mirror](../_/text/mirror/) / [Atom feed](../new.atom)
```
```
From: Hyunwoo Kim <imv4bel@gmail.com>
To: Arnd Bergmann <arnd@arndb.de>,
	laforge@gnumonks.org, gregkh@linuxfoundation.org
Cc: "Ilpo JÃ¤rvinen" <ilpo.jarvinen@linux.intel.com>,
	[linux-kernel@vger.kernel.org](../../lkml/?t=20220915020848),
	"Dominik Brodowski" <linux@dominikbrodowski.net>,
	"Paul Fulghum" <paulkf@microgate.com>,
	akpm@osdl.org, imv4bel@gmail.com
Subject: [Re: [PATCH] pcmcia: synclink_cs: Fix use-after-free in mgslpc_ioctl()](#r)
Date: Wed, 14 Sep 2022 19:08:34 -0700	[[thread overview]](#r)
Message-ID: <20220915020834.GA110086@ubuntu> (<raw>)
In-Reply-To: <[a8a9fd74-4ee5-4619-8492-be7139e6d48e@www.fastmail.com](../a8a9fd74-4ee5-4619-8492-be7139e6d48e%40www.fastmail.com/)>

The previous mailing list is here:
[https://lore.kernel.org/lkml/20220913052020.GA85241@ubuntu/#r](https://lore.kernel.org/lkml/20220913052020.GA85241%40ubuntu/#r)

There are 3 other pcmica drivers in the path "drivers/char/pcmcia/synclink_cs.c",
the path of the "synclink_cs.c" driver I reported the UAF to.
A similar UAF occurs in the "cm4000_cs.c" and "cm4040_cs.c" drivers.
(this does not happen in scr24x_cs.c)

The flow of UAF occurrence in cm4040_cs.c driver is as follows:
```
                cpu0                                                cpu1
       1. open()
          cm4040_open()
                                                             2. reader_detach()
                                                                reader_release()
                                                                cm4040_reader_release()
                                                                while (link->open) { ...
       3. link->open = 1;
                                                             4. kfree(dev);
                                                                device_destroy()
       5. read()   <- device_destroy() was called, but read() can be called because fd is open
          cm4040_read()
          int iobase = dev->p_dev->resource[0]->start;   <- UAF
```
In cm4040_open() function, link->open is set to 1.
And in the .remove callback reader_detach() function, if link->open is 1,
cm4040_close() is called and wait()s until link->open becomes 0.
However, if the above race condition occurs in these two functions,
the link->open check in reader_detach() can be bypassed.
After that, you can call read() on the task that acquired fd to raise a
UAF for the kfree()d "dev".

The flow of UAF occurrence in cm4000_cs.c driver is as follows:

```
                cpu0                                                cpu1
       1. open()
          cmm_open()
                                                             2. cm4000_detach()
                                                                stop_monitor()
                                                                if (dev->monitor_running) { ...
       3. start_monitor()
          dev->monitor_running = 1;
                                                             4. cm4000_release()
                                                                cmm_cm4000_release()
                                                                while (link->open) { ...
       5. link->open = 1;
                                                             6. kfree(dev);
                                                                device_destroy()
       7. read()   <- device_destroy() was called, but read() can be called because fd is open
          cmm_read()
          unsigned int iobase = dev->p_dev->resource[0]->start;   <- UAF
```
In the cm4000_cs.c driver, the race condition flow is tricky because of
the start/stop_monitor() functions.

The overall flow is similar to cm4040_cs.c.
Added one race condition to bypass the "dev->monitor_running" check.

So, should the above two drivers be removed from the kernel like the synclink_cs.c driver?

Or should I submit a patch that fixes the UAF?

Best Regards,
Hyunwoo Kim.

```

---

```
[next](../f41c2765-80e0-48bc-b1e4-8cfd3230fd4a%40www.fastmail.com/) [prev](../20220913154344.GA92254%40ubuntu/) [parent](../a8a9fd74-4ee5-4619-8492-be7139e6d48e%40www.fastmail.com/) [reply](#R)other threads:[[~2022-09-15  2:08 UTC](../?t=20220915020848)|[newest](../)]

Thread overview: 10+ messages / expand[[flat](T/#u)|[nested](t/#u)]  [mbox.gz](t.mbox.gz)  [Atom feed](t.atom)  [top](#b)
2022-09-13  5:20 [[PATCH] pcmcia: synclink_cs: Fix use-after-free in mgslpc_ioctl()](../20220913052020.GA85241%40ubuntu/) Hyunwoo Kim
2022-09-13 14:59 ` [Arnd Bergmann](../a8a9fd74-4ee5-4619-8492-be7139e6d48e%40www.fastmail.com/)
2022-09-13 15:14   ` [Paul Fulghum](../5BBF8723-AF48-4380-B05B-CB3B552322BD%40microgate.com/)
2022-09-13 15:43     ` [Hyunwoo Kim](../20220913154344.GA92254%40ubuntu/)
2022-09-15  2:08   ` [Hyunwoo Kim [this message]](#t)
2022-09-15  7:35     ` [Arnd Bergmann](../f41c2765-80e0-48bc-b1e4-8cfd3230fd4a%40www.fastmail.com/)
2022-09-15  8:02       ` [Dominik Brodowski](../YyLcG1hG5d6D4zNN%40owl.dominikbrodowski.net/)
2022-09-15  9:00         ` [Hyunwoo Kim](../20220915090023.GA112572%40ubuntu/)
2022-09-16  5:03         ` [Hyunwoo Kim](../20220916050333.GA188358%40ubuntu/)
2022-09-15 14:05       ` [Harald Welte](../YyMxHRXUTft4bG28%40nataraja/)

```

---

```
Reply instructions:

You may reply publicly to [this message](#t) via plain-text email
using any one of the following methods:

* Save the following mbox file, import it into your mail client,
  and reply-to-all from there: [mbox](raw)

  Avoid top-posting and favor interleaved quoting:
  <https://en.wikipedia.org/wiki/Posting_style#Interleaved_style>

* Reply using the --to, --cc, and --in-reply-to
  switches of git-send-email(1):

  git send-email \
    --in-reply-to=20220915020834.GA110086@ubuntu \
    --to=imv4bel@gmail.com \
    --cc=akpm@osdl.org \
    --cc=arnd@arndb.de \
    --cc=gregkh@linuxfoundation.org \
    --cc=ilpo.jarvinen@linux.intel.com \
    --cc=laforge@gnumonks.org \
    --cc=linux-kernel@vger.kernel.org \
    --cc=linux@dominikbrodowski.net \
    --cc=paulkf@microgate.com \
    /path/to/YOUR_REPLY

  <https://kernel.org/pub/software/scm/git/docs/git-send-email.html>

* If your mail client supports setting the In-Reply-To header
  via mailto: links, try the mailto: link

```
Be sure your reply has a **Subject:** header at the top and a blank line
before the message body.

---

```
This is a public inbox, see [mirroring instructions](../_/text/mirror/)
for how to clone and mirror all data and code used for this inbox;
as well as URLs for NNTP newsgroup(s).
```


=== Content from lore.kernel.org_2a30c0b2_20250108_132749.html ===

```
[linux-kernel.vger.kernel.org archive mirror](../?t=20220919040714)
 [help](../_/text/help/) / [color](../_/text/color/) / [mirror](../_/text/mirror/) / [Atom feed](../new.atom)
```
```
From: Hyunwoo Kim <imv4bel@gmail.com>
To: laforge@gnumonks.org
Cc: [linux-kernel@vger.kernel.org](../../lkml/?t=20220919040714), imv4bel@gmail.com, arnd@arndb.de,
	gregkh@linuxfoundation.org, linux@dominikbrodowski.net
Subject: [[PATCH v3] char: pcmcia: cm4000_cs: Fix use-after-free in cm4000_fops](#r)
Date: Sun, 18 Sep 2022 21:07:01 -0700	[[thread overview]](#r)
Message-ID: <20220919040701.GA302806@ubuntu> (<raw>)

A race condition may occur if the user physically removes the pcmcia
device while calling open() for this char device node.

This is a race condition between the cmm_open() function and the
cm4000_detach() function, which may eventually result in UAF.

So, add a refcount check to cm4000_detach() to free the "dev" structure
after the char device node is close()d.

Signed-off-by: Hyunwoo Kim <imv4bel@gmail.com>
---
 [drivers/char/pcmcia/cm4000_cs.c](#Z31drivers:char:pcmcia:cm4000_cs.c) | 58 +++++++++++++++++++++++----------
 1 file [changed](#related), 41 insertions(+), 17 deletions(-)

[diff](#iZ31drivers:char:pcmcia:cm4000_cs.c) --git a/drivers/char/pcmcia/cm4000_cs.c b/drivers/char/pcmcia/cm4000_cs.c
index adaec8fd4b16..7103812b4019 100644
--- a/drivers/char/pcmcia/cm4000_cs.c
+++ b/drivers/char/pcmcia/cm4000_cs.c
@@ -55,6 +55,7 @@
 	} while (0)

 static DEFINE_MUTEX(cmm_mutex);
+static DEFINE_MUTEX(remove_mutex);

 #define	T_1SEC		(HZ)
 #define	T_10MSEC	msecs_to_jiffies(10)
@@ -103,7 +104,8 @@ static int major;		/* major number we get from the kernel */
 #define REG_STOPBITS(x)		(x + 7)

 struct cm4000_dev {
-	struct pcmcia_device *p_dev;
+	struct pcmcia_device	*p_dev;
+	struct kref		refcnt;

 	unsigned char atr[MAX_ATR];
 	unsigned char rbuf[512];
@@ -146,6 +148,9 @@ struct cm4000_dev {

 #define	ZERO_DEV(dev)	memset(&((dev)->init), 0, sizeof((dev)->init))

+static void stop_monitor(struct cm4000_dev *dev);
+static void cm4000_delete(struct kref *kref);
+
 static struct pcmcia_device *dev_table[CM4000_MAX_DEV];
 static struct class *cmm_class;

@@ -416,6 +421,30 @@ static struct card_fixup card_fixups[] = {
 	},
 };

+
+static void cm4000_delete(struct kref *kref)
+{
+	struct cm4000_dev *dev = container_of(kref, struct cm4000_dev, refcnt);
+	struct pcmcia_device *link = dev->p_dev;
+	int devno;
+
+	/* find device */
+	for (devno = 0; devno < CM4000_MAX_DEV; devno++)
+		if (dev_table[devno] == link)
+			break;
+	if (devno == CM4000_MAX_DEV)
+		return;
+
+	stop_monitor(dev);
+
+	cm4000_release(link);
+
+	dev_table[devno] = NULL;
+	kfree(dev);
+
+	device_destroy(cmm_class, MKDEV(major, devno));
+}
+
 static void set_cardparameter(struct cm4000_dev *dev)
 {
 	int i;
@@ -1629,6 +1658,7 @@ static int cmm_open(struct inode *inode, struct file *filp)
 	if (minor >= CM4000_MAX_DEV)
 		return -ENODEV;

+	mutex_lock(&remove_mutex);
 	mutex_lock(&cmm_mutex);
 	link = dev_table[minor];
 	if (link == NULL || !pcmcia_dev_present(link)) {
@@ -1673,8 +1703,12 @@ static int cmm_open(struct inode *inode, struct file *filp)

 	DEBUGP(2, dev, "<- cmm_open\n");
 	ret = stream_open(inode, filp);
+
+	kref_get(&dev->refcnt);
 out:
 	mutex_unlock(&cmm_mutex);
+	mutex_unlock(&remove_mutex);
+
 	return ret;
 }

@@ -1703,6 +1737,8 @@ static int cmm_close(struct inode *inode, struct file *filp)
 	link->open = 0;		/* only one open per device */
 	wake_up(&dev->devq);	/* socket removed? */

+	kref_put(&dev->refcnt, cm4000_delete);
+
 	DEBUGP(2, dev, "cmm_close\n");
 	return 0;
 }
@@ -1808,6 +1844,7 @@ static int cm4000_probe(struct pcmcia_device *link)
 	init_waitqueue_head(&dev->ioq);
 	init_waitqueue_head(&dev->atrq);
 	init_waitqueue_head(&dev->readq);
+	kref_init(&dev->refcnt);

 	ret = cm4000_config(link, i);
 	if (ret) {
@@ -1824,23 +1861,10 @@ static int cm4000_probe(struct pcmcia_device *link)
 static void cm4000_detach(struct pcmcia_device *link)
 {
 	struct cm4000_dev *dev = link->priv;
-	int devno;
-
-	/* find device */
-	for (devno = 0; devno < CM4000_MAX_DEV; devno++)
-		if (dev_table[devno] == link)
-			break;
-	if (devno == CM4000_MAX_DEV)
-		return;
-
-	stop_monitor(dev);
-
-	cm4000_release(link);

-	dev_table[devno] = NULL;
-	kfree(dev);
-
-	device_destroy(cmm_class, MKDEV(major, devno));
+	mutex_lock(&remove_mutex);
+	kref_put(&dev->refcnt, cm4000_delete);
+	mutex_unlock(&remove_mutex);

 	return;
 }
--
2.25.1

Dear,

I fixed the wrong patch referencing "dev" after kref_put() in the previous version of the patch.

Regards,
Hyunwoo Kim.

```

---

```
[next](../63030af8-5849-34b3-10e6-b6ce32c3a5bf%40kernel.org/)             [reply](#R)	other threads:[[~2022-09-19  4:07 UTC](../?t=20220919040714)|[newest](../)]

Thread overview: 5+ messages / expand[[flat](T/#u)|[nested](t/#u)]  [mbox.gz](t.mbox.gz)  [Atom feed](t.atom)  [top](#b)
2022-09-19  4:07 [Hyunwoo Kim [this message]](#t)
2023-02-21  6:51 ` [[PATCH v3] char: pcmcia: cm4000_cs: Fix use-after-free in cm4000_fops](../63030af8-5849-34b3-10e6-b6ce32c3a5bf%40kernel.org/) Jiri Slaby
2023-02-21 12:43   ` [Arnd Bergmann](../c5b39544-a4fb-4796-a046-0b9be9853787%40app.fastmail.com/)
2023-02-22  7:53     ` [Jiri Slaby](../b9d36537-bc94-71e5-a967-cd4cec50baf2%40kernel.org/)
2023-02-22  8:20       ` [Greg Kroah-Hartman](../Y/XQZieM6uFrQo8r%40kroah.com/)

```
```
find likely ancestor, descendant, or conflicting patches for [this message](#t):
( dfblob:adaec8fd4b1 dfblob:7103812b401 )
 OR (
bs:"[PATCH v3] char: pcmcia: cm4000_cs: Fix use-after-free in cm4000_fops" )
	([help](../_/text/help/#search))
```

---

```
Reply instructions:

You may reply publicly to [this message](#t) via plain-text email
using any one of the following methods:

* Save the following mbox file, import it into your mail client,
  and reply-to-all from there: [mbox](raw)

  Avoid top-posting and favor interleaved quoting:
  <https://en.wikipedia.org/wiki/Posting_style#Interleaved_style>

* Reply using the --to, --cc, and --in-reply-to
  switches of git-send-email(1):

  git send-email \
    --in-reply-to=20220919040701.GA302806@ubuntu \
    --to=imv4bel@gmail.com \
    --cc=arnd@arndb.de \
    --cc=gregkh@linuxfoundation.org \
    --cc=laforge@gnumonks.org \
    --cc=linux-kernel@vger.kernel.org \
    --cc=linux@dominikbrodowski.net \
    /path/to/YOUR_REPLY

  <https://kernel.org/pub/software/scm/git/docs/git-send-email.html>

* If your mail client supports setting the In-Reply-To header
  via mailto: links, try the mailto: link

```
Be sure your reply has a **Subject:** header at the top and a blank line
before the message body.

---

```
This is a public inbox, see [mirroring instructions](../_/text/mirror/)
for how to clone and mirror all data and code used for this inbox;
as well as URLs for NNTP newsgroup(s).
```


=== Content from git.kernel.org_986e1928_20250108_132749.html ===


| [cgit logo](/) | [index](/) : [kernel/git/torvalds/linux.git](/pub/scm/linux/kernel/git/torvalds/linux.git/) | for-next master vsnprintf |
| --- | --- | --- |
| Linux kernel source tree | Linus Torvalds |

| [about](/pub/scm/linux/kernel/git/torvalds/linux.git/about/)[summary](/pub/scm/linux/kernel/git/torvalds/linux.git/)[refs](/pub/scm/linux/kernel/git/torvalds/linux.git/refs/?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15)[log](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)[tree](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15)[commit](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15)[diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15)[stats](/pub/scm/linux/kernel/git/torvalds/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jiri Slaby <jirislaby@kernel.org> | 2023-02-22 10:23:02 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2023-03-09 17:30:27 +0100 |
| commit | [9b12f050c76f090cc6d0aebe0ef76fed79ec3f15](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15) ([patch](/pub/scm/linux/kernel/git/torvalds/linux.git/patch/?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15)) | |
| tree | [11a28c1deaadf23c600d83db8e89dc9a5d13b422](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15) | |
| parent | [3996954fa071aa20945c8ac7694684fa3c1fed68](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=3996954fa071aa20945c8ac7694684fa3c1fed68) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15&id2=3996954fa071aa20945c8ac7694684fa3c1fed68)) | |
| download | [linux-9b12f050c76f090cc6d0aebe0ef76fed79ec3f15.tar.gz](/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-9b12f050c76f090cc6d0aebe0ef76fed79ec3f15.tar.gz) | |

char: pcmcia: remove all the driversThese char PCMCIA drivers are buggy[1] and receive only minimal care. It
was concluded[2], that we should try to remove most pcmcia drivers
completely. Let's start with these char broken one.
Note that I also removed a UAPI header: include/uapi/linux/cm4000\_cs.h.
I found only coccinelle tests mentioning some ioctl constants from that
file. But they are not actually used. Anyway, should someone complain,
we may reintroduce the header (or its parts).
[1] https://lore.kernel.org/all/f41c2765-80e0-48bc-b1e4-8cfd3230fd4a@www.fastmail.com/
[2] https://lore.kernel.org/all/c5b39544-a4fb-4796-a046-0b9be9853787@app.fastmail.com/
Signed-off-by: Jiri Slaby (SUSE) <jirislaby@kernel.org>
Cc: "Hyunwoo Kim" <imv4bel@gmail.com>
Cc: Harald Welte <laforge@gnumonks.org>
Cc: Lubomir Rintel <lkundrak@v3.sk>
Cc: Arnd Bergmann <arnd@arndb.de>
Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Acked-by: Dominik Brodowski <linux@dominikbrodowski.net>
Reviewed-by: Arnd Bergmann <arnd@arndb.de>
Link: [https://lore.kernel.org/r/20230222092302.6348-2-jirislaby@kernel.org](https://lore.kernel.org/r/20230222092302.6348-2-jirislaby%40kernel.org)
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15)

| -rw-r--r-- | [Documentation/process/magic-number.rst](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/Documentation/process/magic-number.rst?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15) | 1 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [Documentation/translations/it\_IT/process/magic-number.rst](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/Documentation/translations/it_IT/process/magic-number.rst?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [Documentation/translations/sp\_SP/process/magic-number.rst](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/Documentation/translations/sp_SP/process/magic-number.rst?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [Documentation/translations/zh\_CN/process/magic-number.rst](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/Documentation/translations/zh_CN/process/magic-number.rst?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [Documentation/translations/zh\_TW/process/magic-number.rst](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/Documentation/translations/zh_TW/process/magic-number.rst?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [Documentation/userspace-api/ioctl/ioctl-number.rst](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/Documentation/userspace-api/ioctl/ioctl-number.rst?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [MAINTAINERS](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/MAINTAINERS?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15) | 17 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [arch/powerpc/configs/ppc6xx\_defconfig](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/powerpc/configs/ppc6xx_defconfig?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/char/Kconfig](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/char/Kconfig?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/char/Makefile](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/char/Makefile?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/char/pcmcia/Kconfig](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/char/pcmcia/Kconfig?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15) | 59 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/char/pcmcia/Makefile](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/char/pcmcia/Makefile?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15) | 11 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/char/pcmcia/cm4000\_cs.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/char/pcmcia/cm4000_cs.c?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15) | 1912 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/char/pcmcia/cm4040\_cs.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/char/pcmcia/cm4040_cs.c?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15) | 684 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/char/pcmcia/cm4040\_cs.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/char/pcmcia/cm4040_cs.h?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15) | 48 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/char/pcmcia/scr24x\_cs.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/char/pcmcia/scr24x_cs.c?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15) | 359 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/char/pcmcia/synclink\_cs.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/char/pcmcia/synclink_cs.c?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15) | 4290 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/cm4000\_cs.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/linux/cm4000_cs.h?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15) | 11 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/uapi/linux/cm4000\_cs.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/uapi/linux/cm4000_cs.h?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15) | 64 | |  |  |  | | --- | --- | --- | |

19 files changed, 0 insertions, 7466 deletions

| diff --git a/Documentation/process/magic-number.rst b/Documentation/process/magic-number.rstindex 64b5948fc1d49d..7029c3c084ee4d 100644--- a/[Documentation/process/magic-number.rst](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/process/magic-number.rst?id=3996954fa071aa20945c8ac7694684fa3c1fed68)+++ b/[Documentation/process/magic-number.rst](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/process/magic-number.rst?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15)@@ -72,7 +72,6 @@ PG\_MAGIC 'P' pg\_{read,write}\_hdr ``include/linux/ APM\_BIOS\_MAGIC 0x4101 apm\_user ``arch/x86/kernel/apm\_32.c`` FASYNC\_MAGIC 0x4601 fasync\_struct ``include/linux/fs.h`` SLIP\_MAGIC 0x5302 slip ``drivers/net/slip.h``-MGSLPC\_MAGIC 0x5402 mgslpc\_info ``drivers/char/pcmcia/synclink\_cs.c`` BAYCOM\_MAGIC 0x19730510 baycom\_state ``drivers/net/baycom\_epp.c`` HDLCDRV\_MAGIC 0x5ac6e778 hdlcdrv\_state ``include/linux/hdlcdrv.h`` KV\_MAGIC 0x5f4b565f kernel\_vars\_s ``arch/mips/include/asm/sn/klkernvars.h``diff --git a/Documentation/translations/it\_IT/process/magic-number.rst b/Documentation/translations/it\_IT/process/magic-number.rstindex 02eb7eb2448e77..ae92ab633c168b 100644--- a/[Documentation/translations/it\_IT/process/magic-number.rst](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/translations/it_IT/process/magic-number.rst?id=3996954fa071aa20945c8ac7694684fa3c1fed68)+++ b/[Documentation/translations/it\_IT/process/magic-number.rst](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/translations/it_IT/process/magic-number.rst?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15)@@ -78,7 +78,6 @@ PG\_MAGIC 'P' pg\_{read,write}\_hdr ``include/linux/ APM\_BIOS\_MAGIC 0x4101 apm\_user ``arch/x86/kernel/apm\_32.c`` FASYNC\_MAGIC 0x4601 fasync\_struct ``include/linux/fs.h`` SLIP\_MAGIC 0x5302 slip ``drivers/net/slip.h``-MGSLPC\_MAGIC 0x5402 mgslpc\_info ``drivers/char/pcmcia/synclink\_cs.c`` BAYCOM\_MAGIC 0x19730510 baycom\_state ``drivers/net/baycom\_epp.c`` HDLCDRV\_MAGIC 0x5ac6e778 hdlcdrv\_state ``include/linux/hdlcdrv.h`` KV\_MAGIC 0x5f4b565f kernel\_vars\_s ``arch/mips/include/asm/sn/klkernvars.h``diff --git a/Documentation/translations/sp\_SP/process/magic-number.rst b/Documentation/translations/sp\_SP/process/magic-number.rstindex 2b62cec34e8e28..7c7dfb4ba80bc2 100644--- a/[Documentation/translations/sp\_SP/process/magic-number.rst](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/translations/sp_SP/process/magic-number.rst?id=3996954fa071aa20945c8ac7694684fa3c1fed68)+++ b/[Documentation/translations/sp\_SP/process/magic-number.rst](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/translations/sp_SP/process/magic-number.rst?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15)@@ -77,7 +77,6 @@ PG\_MAGIC 'P' pg\_{read,write}\_hdr ``include/linux/ APM\_BIOS\_MAGIC 0x4101 apm\_user ``arch/x86/kernel/apm\_32.c`` FASYNC\_MAGIC 0x4601 fasync\_struct ``include/linux/fs.h`` SLIP\_MAGIC 0x5302 slip ``drivers/net/slip.h``-MGSLPC\_MAGIC 0x5402 mgslpc\_info ``drivers/char/pcmcia/synclink\_cs.c`` BAYCOM\_MAGIC 0x19730510 baycom\_state ``drivers/net/baycom\_epp.c`` HDLCDRV\_MAGIC 0x5ac6e778 hdlcdrv\_state ``include/linux/hdlcdrv.h`` KV\_MAGIC 0x5f4b565f kernel\_vars\_s ``arch/mips/include/asm/sn/klkernvars.h``diff --git a/Documentation/translations/zh\_CN/process/magic-number.rst b/Documentation/translations/zh\_CN/process/magic-number.rstindex 0617ce125e127b..37ed33034134d8 100644--- a/[Documentation/translations/zh\_CN/process/magic-number.rst](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/translations/zh_CN/process/magic-number.rst?id=3996954fa071aa20945c8ac7694684fa3c1fed68)+++ b/[Documentation/translations/zh\_CN/process/magic-number.rst](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/translations/zh_CN/process/magic-number.rst?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15)@@ -61,7 +61,6 @@ PG\_MAGIC 'P' pg\_{read,write}\_hdr ``include/linux/ APM\_BIOS\_MAGIC 0x4101 apm\_user ``arch/x86/kernel/apm\_32.c`` FASYNC\_MAGIC 0x4601 fasync\_struct ``include/linux/fs.h`` SLIP\_MAGIC 0x5302 slip ``drivers/net/slip.h``-MGSLPC\_MAGIC 0x5402 mgslpc\_info ``drivers/char/pcmcia/synclink\_cs.c`` BAYCOM\_MAGIC 0x19730510 baycom\_state ``drivers/net/baycom\_epp.c`` HDLCDRV\_MAGIC 0x5ac6e778 hdlcdrv\_state ``include/linux/hdlcdrv.h`` KV\_MAGIC 0x5f4b565f kernel\_vars\_s ``arch/mips/include/asm/sn/klkernvars.h``diff --git a/Documentation/translations/zh\_TW/process/magic-number.rst b/Documentation/translations/zh\_TW/process/magic-number.rstindex f3f7082e17c61e..1d48e1bbf5f266 100644--- a/[Documentation/translations/zh\_TW/process/magic-number.rst](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/translations/zh_TW/process/magic-number.rst?id=3996954fa071aa20945c8ac7694684fa3c1fed68)+++ b/[Documentation/translations/zh\_TW/process/magic-number.rst](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/translations/zh_TW/process/magic-number.rst?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15)@@ -64,7 +64,6 @@ PG\_MAGIC 'P' pg\_{read,write}\_hdr ``include/linux/ APM\_BIOS\_MAGIC 0x4101 apm\_user ``arch/x86/kernel/apm\_32.c`` FASYNC\_MAGIC 0x4601 fasync\_struct ``include/linux/fs.h`` SLIP\_MAGIC 0x5302 slip ``drivers/net/slip.h``-MGSLPC\_MAGIC 0x5402 mgslpc\_info ``drivers/char/pcmcia/synclink\_cs.c`` BAYCOM\_MAGIC 0x19730510 baycom\_state ``drivers/net/baycom\_epp.c`` HDLCDRV\_MAGIC 0x5ac6e778 hdlcdrv\_state ``include/linux/hdlcdrv.h`` KV\_MAGIC 0x5f4b565f kernel\_vars\_s ``arch/mips/include/asm/sn/klkernvars.h``diff --git a/Documentation/userspace-api/ioctl/ioctl-number.rst b/Documentation/userspace-api/ioctl/ioctl-number.rstindex 0a1882e296ae08..176e8fc3f31b93 100644--- a/[Documentation/userspace-api/ioctl/ioctl-number.rst](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/userspace-api/ioctl/ioctl-number.rst?id=3996954fa071aa20945c8ac7694684fa3c1fed68)+++ b/[Documentation/userspace-api/ioctl/ioctl-number.rst](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/userspace-api/ioctl/ioctl-number.rst?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15)@@ -222,7 +222,6 @@ Code Seq# Include File Comments 'b' 00-FF conflict! bit3 vme host bridge <mailto:natalia@nikhefk.nikhef.nl> 'b' 00-0F linux/dma-buf.h conflict!-'c' all linux/cm4000\_cs.h conflict! 'c' 00-7F linux/comstats.h conflict! 'c' 00-7F linux/coda.h conflict! 'c' 00-1F linux/chio.h conflict!diff --git a/MAINTAINERS b/MAINTAINERSindex 8d5bc223f3053b..64068a601e59ad 100644--- a/[MAINTAINERS](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/MAINTAINERS?id=3996954fa071aa20945c8ac7694684fa3c1fed68)+++ b/[MAINTAINERS](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/MAINTAINERS?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15)@@ -15322,18 +15322,6 @@ S: Maintained F: Documentation/filesystems/omfs.rst F: fs/omfs/ -OMNIKEY CARDMAN 4000 DRIVER-M: Harald Welte <laforge@gnumonks.org>-S: Maintained-F: drivers/char/pcmcia/cm4000\_cs.c-F: include/linux/cm4000\_cs.h-F: include/uapi/linux/cm4000\_cs.h--OMNIKEY CARDMAN 4040 DRIVER-M: Harald Welte <laforge@gnumonks.org>-S: Maintained-F: drivers/char/pcmcia/cm4040\_cs.\*- OMNIVISION OG01A1B SENSOR DRIVER M: Shawn Tu <shawnx.tu@intel.com> L: linux-media@vger.kernel.org@@ -18609,11 +18597,6 @@ F: include/linux/wait.h F: include/uapi/linux/sched.h F: kernel/sched/ -SCR24X CHIP CARD INTERFACE DRIVER-M: Lubomir Rintel <lkundrak@v3.sk>-S: Supported-F: drivers/char/pcmcia/scr24x\_cs.c- SCSI RDMA PROTOCOL (SRP) INITIATOR M: Bart Van Assche <bvanassche@acm.org> L: linux-rdma@vger.kernel.orgdiff --git a/arch/powerpc/configs/ppc6xx\_defconfig b/arch/powerpc/configs/ppc6xx\_defconfigindex 1102582779599b..d8729b94400efd 100644--- a/[arch/powerpc/configs/ppc6xx\_defconfig](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/powerpc/configs/ppc6xx_defconfig?id=3996954fa071aa20945c8ac7694684fa3c1fed68)+++ b/[arch/powerpc/configs/ppc6xx\_defconfig](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/powerpc/configs/ppc6xx_defconfig?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15)@@ -614,8 +614,6 @@ CONFIG\_HW\_RANDOM=y CONFIG\_HW\_RANDOM\_VIRTIO=m CONFIG\_NVRAM=y CONFIG\_DTLK=m-CONFIG\_CARDMAN\_4000=m-CONFIG\_CARDMAN\_4040=m CONFIG\_IPWIRELESS=m CONFIG\_I2C\_CHARDEV=m CONFIG\_I2C\_HYDRA=mdiff --git a/drivers/char/Kconfig b/drivers/char/Kconfigindex 30fe9848dac1c1..801d6c83f89616 100644--- a/[drivers/char/Kconfig](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/Kconfig?id=3996954fa071aa20945c8ac7694684fa3c1fed68)+++ b/[drivers/char/Kconfig](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/Kconfig?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15)@@ -247,8 +247,6 @@ config SONYPI To compile this driver as a module, choose M here: the module will be called sonypi. -source "drivers/char/pcmcia/Kconfig"- config MWAVE tristate "ACP Modem (Mwave) support" depends on X86 && TTYdiff --git a/drivers/char/Makefile b/drivers/char/Makefileindex 1b35d1724565eb..c5f532e412f1a4 100644--- a/[drivers/char/Makefile](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/Makefile?id=3996954fa071aa20945c8ac7694684fa3c1fed68)+++ b/[drivers/char/Makefile](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/Makefile?id=9b12f050c76f090cc6d0aebe0ef76fed79ec3f15)@@ -35,7 +35,6 @@ obj-$(CONFIG\_TELCLOCK) += tlclk.o  obj-$(CONFIG\_MWAVE) += mwave/ obj-y += agp/-obj-$(CONFIG\_PCMCIA) += pcmcia/  obj-$(CONFIG\_HANGCHECK\_TIMER) += hangcheck-timer.o obj-$(CONFIG\_TCG\_TPM) += tpm/diff --git a/drivers/char/pcmcia/Kconfig b/drivers/char/pcmcia/Kconfigdeleted file mode 100644index 26724990074c87..00000000000000--- a/[drivers/char/pcmcia/Kconfig](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/pcmcia/Kconfig?id=3996954fa071aa20945c8ac7694684fa3c1fed68)+++ /dev/null@@ -1,59 +0,0 @@-# SPDX-License-Identifier: GPL-2.0-only-#-# PCMCIA character device configuration-#--menu "PCMCIA character devices"- depends on PCMCIA!=n--config SYNCLINK\_CS- tristate "SyncLink PC Card support"- depends on PCMCIA && TTY- help- Enable support for the SyncLink PC Card serial adapter, running- asynchronous and HDLC communications up to 512Kbps. The port is- selectable for RS-232, V.35, RS-449, RS-530, and X.21-- This driver may be built as a module ( = code which can be- inserted in and removed from the running kernel whenever you want).- The module will be called synclink\_cs. If you want to do that, say M- here.--config CARDMAN\_4000- tristate "Omnikey Cardman 4000 support"- depends on PCMCIA- select BITREVERSE- help- Enable support for the Omnikey Cardman 4000 PCMCIA Smartcard- reader.-- This kernel driver requires additional userspace support, either- by the vendor-provided PC/SC ifd\_handler (http://www.omnikey.com/),- or via the cm4000 backend of OpenCT (http://www.opensc-project.org/opensc).--config CARDMAN\_4040- tristate "Omnikey CardMan 4040 support"- depends on PCMCIA- help- Enable support for the Omnikey CardMan 4040 PCMCIA Smartcard- reader.-- This card is basically a USB CCID device connected to a FIFO- in I/O space. To use the kernel driver, you will need either the- PC/SC ifdhandler provided from the Omnikey homepage- (http://www.omnikey.com/), or a current development version of OpenCT- (http://www.opensc-project.org/opensc).--config SCR24X- tristate "SCR24x Chip Card Interface support"- depends on PCMCIA- help- Enable support for the SCR24x PCMCIA Chip Card Interface.-- To compile this driver as a module, choose M here.- The module will be called scr24x\_cs..-- If unsure say N.--endmenu-diff --git a/drivers/char/pcmcia/Makefile b/drivers/char/pcmcia/Makefiledeleted file mode 100644index 024eed1c4ca555..00000000000000--- a/[drivers/char/pcmcia/Makefile](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/pcmcia/Makefile?id=3996954fa071aa20945c8ac7694684fa3c1fed68)+++ /dev/null@@ -1,11 +0,0 @@-# SPDX-License-Identifier: GPL-2.0-only-#-# drivers/char/pcmcia/Makefile-#-# Makefile for the Linux PCMCIA char device drivers.-#--obj-$(CONFIG\_SYNCLINK\_CS) += synclink\_cs.o-obj-$(CONFIG\_CARDMAN\_4000) += cm4000\_cs.o-obj-$(CONFIG\_CARDMAN\_4040) += cm4040\_cs.o-obj-$(CONFIG\_SCR24X) += scr24x\_cs.odiff --git a/drivers/char/pcmcia/cm4000\_cs.c b/drivers/char/pcmcia/cm4000\_cs.cdeleted file mode 100644index e656f42a28ac23..00000000000000--- a/[drivers/char/pcmcia/cm4000\_cs.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/pcmcia/cm4000_cs.c?id=3996954fa071aa20945c8ac7694684fa3c1fed68)+++ /dev/null@@ -1,1912 +0,0 @@- /\*- \* A driver for the PCMCIA Smartcard Reader "Omnikey CardMan Mobile 4000"- \*- \* cm4000\_cs.c support.linux@omnikey.com- \*- \* Tue Oct 23 11:32:43 GMT 2001 herp - cleaned up header files- \* Sun Jan 20 10:11:15 MET 2002 herp - added modversion header files- \* Thu Nov 14 16:34:11 GMT 2002 mh - added PPS functionality- \* Tue Nov 19 16:36:27 GMT 2002 mh - added SUSPEND/RESUME functionailty- \* Wed Jul 28 12:55:01 CEST 2004 mh - kernel 2.6 adjustments- \*- \* current version: 2.4.0gm4- \*- \* (C) 2000,2001,2002,2003,2004 Omnikey AG- \*- \* (C) 2005-2006 Harald Welte <laforge@gnumonks.org>- \* - Adhere to Kernel process/coding-style.rst- \* - Port to 2.6.13 "new" style PCMCIA- \* - Check for copy\_{from,to}\_user return values- \* - Use nonseekable\_open()- \* - add class interface for udev device creation- \*- \* All rights reserved. Licensed under dual BSD/GPL license.- \*/--#include <linux/kernel.h>-#include <linux/module.h>-#include <linux/slab.h>-#include <linux/init.h>-#include <linux/fs.h>-#include <linux/delay.h>-#include <linux/bitrev.h>-#include <linux/mutex.h>-#include <linux/uaccess.h>-#include <linux/io.h>--#include <pcmcia/cistpl.h>-#include <pcmcia/cisreg.h>-#include <pcmcia/ciscode.h>-#include <pcmcia/ds.h>--#include <linux/cm4000\_cs.h>--/\* #define ATR\_CSUM \*/--#define reader\_to\_dev(x) (&x->p\_dev->dev)--/\* n (debug level) is ignored \*/-/\* additional debug output may be enabled by re-compiling with- \* CM4000\_DEBUG set \*/-/\* #define CM4000\_DEBUG \*/-#define DEBUGP(n, rdr, x, args...) do { \- dev\_dbg(reader\_to\_dev(rdr), "%s:" x, \- \_\_func\_\_ , ## args); \- } while (0)--static DEFINE\_MUTEX(cmm\_mutex);--#define T\_1SEC (HZ)-#define T\_10MSEC msecs\_to\_jiffies(10)-#define T\_20MSEC msecs\_to\_jiffies(20)-#define T\_40MSEC msecs\_to\_jiffies(40)-#define T\_50MSEC msecs\_to\_jiffies(50)-#define T\_100MSEC msecs\_to\_jiffies(100)-#define T\_500MSEC msecs\_to\_jiffies(500)--static void cm4000\_release(struct pcmcia\_device \*link);--static int major; /\* major number we get from the kernel \*/--/\* note: the first state has to have number 0 always \*/--#define M\_FETCH\_ATR 0-#define M\_TIMEOUT\_WAIT 1-#define M\_READ\_ATR\_LEN 2-#define M\_READ\_ATR 3-#define M\_ATR\_PRESENT 4-#define M\_BAD\_CARD 5-#define M\_CARDOFF 6--#define LOCK\_IO 0-#define LOCK\_MONITOR 1--#define IS\_AUTOPPS\_ACT 6-#define IS\_PROCBYTE\_PRESENT 7-#define IS\_INVREV 8-#define IS\_ANY\_T0 9-#define IS\_ANY\_T1 10-#define IS\_ATR\_PRESENT 11-#define IS\_ATR\_VALID 12-#define IS\_CMM\_ABSENT 13-#define IS\_BAD\_LENGTH 14-#define IS\_BAD\_CSUM 15-#define IS\_BAD\_CARD 16--#define REG\_FLAGS0(x) (x + 0)-#define REG\_FLAGS1(x) (x + 1)-#define REG\_NUM\_BYTES(x) (x + 2)-#define REG\_BUF\_ADDR(x) (x + 3)-#define REG\_BUF\_DATA(x) (x + 4)-#define REG\_NUM\_SEND(x) (x + 5)-#define REG\_BAUDRATE(x) (x + 6)-#define REG\_STOPBITS(x) (x + 7)--struct cm4000\_dev {- struct pcmcia\_device \*p\_dev;-- unsigned char atr[MAX\_ATR];- unsigned char rbuf[512];- unsigned char sbuf[512];-- wait\_queue\_head\_t devq; /\* when removing cardman must not be- zeroed! \*/-- wait\_queue\_head\_t ioq; /\* if IO is locked, wait on this Q \*/- wait\_queue\_head\_t atrq; /\* wait for ATR valid \*/- wait\_queue\_head\_t readq; /\* used by write to wake blk.read \*/-- /\* warning: do not move this struct group.- \* initialising to zero depends on it - see ZERO\_DEV below. \*/- struct\_group(init,- unsigned char atr\_csum;- unsigned char atr\_len\_retry;- unsigned short atr\_len;- unsigned short rlen; /\* bytes avail. after write \*/- unsigned short rpos; /\* latest read pos. write zeroes \*/- unsigned char procbyte; /\* T=0 procedure byte \*/- unsigned char mstate; /\* state of card monitor \*/- unsigned char cwarn; /\* slow down warning \*/- unsigned char flags0; /\* cardman IO-flags 0 \*/- unsigned char flags1; /\* cardman IO-flags 1 \*/- unsigned int mdelay; /\* variable monitor speeds, in jiffies \*/-- unsigned int baudv; /\* baud value for speed \*/- unsigned char ta1;- unsigned char proto; /\* T=0, T=1, ... \*/- unsigned long flags; /\* lock+flags (MONITOR,IO,ATR) \* for concurrent- access \*/-- unsigned char pts[4];-- struct timer\_list timer; /\* used to keep monitor running \*/- int monitor\_running;- );-};--#define ZERO\_DEV(dev) memset(&((dev)->init), 0, sizeof((dev)->init))--static struct pcmcia\_device \*dev\_table[CM4000\_MAX\_DEV];-static struct class \*cmm\_class;--/\* This table doesn't use spaces after the comma between fields and thus- \* violates process/coding-style.rst. However, I don't really think wrapping it around will- \* make it any clearer to read -HW \*/-static unsigned char fi\_di\_table[10][14] = {-/\*FI 00 01 02 03 04 05 06 07 08 09 10 11 12 13 \*/-/\*DI \*/-/\* 0 \*/ {0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11},-/\* 1 \*/ {0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x91,0x11,0x11,0x11,0x11},-/\* 2 \*/ {0x02,0x12,0x22,0x32,0x11,0x11,0x11,0x11,0x11,0x92,0xA2,0xB2,0x11,0x11},-/\* 3 \*/ {0x03,0x13,0x23,0x33,0x43,0x53,0x63,0x11,0x11,0x93,0xA3,0xB3,0xC3,0xD3},-/\* 4 \*/ {0x04,0x14,0x24,0x34,0x44,0x54,0x64,0x11,0x11,0x94,0xA4,0xB4,0xC4,0xD4},-/\* 5 \*/ {0x00,0x15,0x25,0x35,0x45,0x55,0x65,0x11,0x11,0x95,0xA5,0xB5,0xC5,0xD5},-/\* 6 \*/ {0x06,0x16,0x26,0x36,0x46,0x56,0x66,0x11,0x11,0x96,0xA6,0xB6,0xC6,0xD6},-/\* 7 \*/ {0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11},-/\* 8 \*/ {0x08,0x11,0x28,0x38,0x48,0x58,0x68,0x11,0x11,0x98,0xA8,0xB8,0xC8,0xD8},-/\* 9 \*/ {0x09,0x19,0x29,0x39,0x49,0x59,0x69,0x11,0x11,0x99,0xA9,0xB9,0xC9,0xD9}-};--#ifndef CM4000\_DEBUG-#define xoutb outb-#define xinb inb-#else-static inline void xoutb(unsigned char val, unsigned short port)-{- pr\_debug("outb(val=%.2x,port=%.4x)\n", val, port);- outb(val, port);-}-static inline unsigned char xinb(unsigned short port)-{- unsigned char val;-- val = inb(port);- pr\_debug("%.2x=inb(%.4x)\n", val, port);-- return val;-}-#endif--static inline unsigned char invert\_revert(unsigned char ch)-{- return bitrev8(~ch);-}--static void str\_invert\_revert(unsigned char \*b, int len)-{- int i;-- for (i = 0; i < len; i++)- b[i] = invert\_revert(b[i]);-}--#define ATRLENCK(dev,pos) \- if (pos>=dev->atr\_len || pos>=MAX\_ATR) \- goto return\_0;--static unsigned int calc\_baudv(unsigned char fidi)-{- unsigned int wcrcf, wbrcf, fi\_rfu, di\_rfu;-- fi\_rfu = 372;- di\_rfu = 1;-- /\* FI \*/- switch ((fidi >> 4) & 0x0F) {- case 0x00:- wcrcf = 372;- break;- case 0x01:- wcrcf = 372;- break;- case 0x02:- wcrcf = 558;- break;- case 0x03:- wcrcf = 744;- break;- case 0x04:- wcrcf = 1116;- break;- case 0x05:- wcrcf = 1488;- break;- case 0x06:- wcrcf = 1860;- break;- case 0x07:- wcrcf = fi\_rfu;- break;- case 0x08:- wcrcf = fi\_rfu;- break;- case 0x09:- wcrcf = 512;- break;- case 0x0A:- wcrcf = 768;- break;- case 0x0B:- wcrcf = 1024;- break;- case 0x0C:- wcrcf = 1536;- break;- case 0x0D:- wcrcf = 2048;- break;- default:- wcrcf = fi\_rfu;- break;- }-- /\* DI \*/- switch (fidi & 0x0F) {- case 0x00:- wbrcf = di\_rfu;- break;- case 0x01:- wbrcf = 1;- break;- case 0x02:- wbrcf = 2;- break;- case 0x03:- wbrcf = 4;- break;- case 0x04:- wbrcf = 8;- break;- case 0x05:- wbrcf = 16;- break;- case 0x06:- wbrcf = 32;- break;- case 0x07:- wbrcf = di\_rfu;- break;- case 0x08:- wbrcf = 12;- break;- case 0x09:- wbrcf = 20;- break;- default:- wbrcf = di\_rfu;- break;- }-- return (wcrcf / wbrcf);-}--static unsigned short io\_read\_num\_rec\_bytes(unsigned int iobase,- unsigned short \*s)-{- unsigned short tmp;-- tmp = \*s = 0;- do {- \*s = tmp;- tmp = inb(REG\_NUM\_BYTES(iobase)) |- (inb(REG\_FLAGS0(iobase)) & 4 ? 0x100 : 0);- } while (tmp != \*s);-- return \*s;-}--static int parse\_atr(struct cm4000\_dev \*dev)-{- unsigned char any\_t1, any\_t0;- unsigned char ch, ifno;- int ix, done;-- DEBUGP(3, dev, "-> parse\_atr: dev->atr\_len = %i\n", dev->atr\_len);-- if (dev->atr\_len < 3) {- DEBUGP(5, dev, "parse\_atr: atr\_len < 3\n");- return 0;- }-- if (dev->atr[0] == 0x3f)- set\_bit(IS\_INVREV, &dev->flags);- else- clear\_bit(IS\_INVREV, &dev->flags);- ix = 1;- ifno = 1;- ch = dev->atr[1];- dev->proto = 0; /\* XXX PROTO \*/- any\_t1 = any\_t0 = done = 0;- dev->ta1 = 0x11; /\* defaults to 9600 baud \*/- do {- if (ifno == 1 && (ch & 0x10)) {- /\* read first interface byte and TA1 is present \*/- dev->ta1 = dev->atr[2];- DEBUGP(5, dev, "Card says FiDi is 0x%.2x\n", dev->ta1);- ifno++;- } else if ((ifno == 2) && (ch & 0x10)) { /\* TA(2) \*/- dev->ta1 = 0x11;- ifno++;- }-- DEBUGP(5, dev, "Yi=%.2x\n", ch & 0xf0);- ix += ((ch & 0x10) >> 4) /\* no of int.face chars \*/- +((ch & 0x20) >> 5)- + ((ch & 0x40) >> 6)- + ((ch & 0x80) >> 7);- /\* ATRLENCK(dev,ix); \*/- if (ch & 0x80) { /\* TDi \*/- ch = dev->atr[ix];- if ((ch & 0x0f)) {- any\_t1 = 1;- DEBUGP(5, dev, "card is capable of T=1\n");- } else {- any\_t0 = 1;- DEBUGP(5, dev, "card is capable of T=0\n");- }- } else- done = 1;- } while (!done);-- DEBUGP(5, dev, "ix=%d noHist=%d any\_t1=%d\n",- ix, dev->atr[1] & 15, any\_t1);- if (ix + 1 + (dev->atr[1] & 0x0f) + any\_t1 != dev->atr\_len) {- DEBUGP(5, dev, "length error\n");- return 0;- }- if (any\_t0)- set\_bit(IS\_ANY\_T0, &dev->flags);-- if (any\_t1) { /\* compute csum \*/- dev->atr\_csum = 0;-#ifdef ATR\_CSUM- for (i = 1; i < dev->atr\_len; i++)- dev->atr\_csum ^= dev->atr[i];- if (dev->atr\_csum) {- set\_bit(IS\_BAD\_CSUM, &dev->flags);- DEBUGP(5, dev, "bad checksum\n");- goto return\_0;- }-#endif- if (any\_t0 == 0)- dev->proto = 1; /\* XXX PROTO \*/- set\_bit(IS\_ANY\_T1, &dev->flags);- }-- return 1;-}--struct card\_fixup {- char atr[12];- u\_int8\_t atr\_len;- u\_int8\_t stopbits;-};--static struct card\_fixup card\_fixups[] = {- { /\* ACOS \*/- .atr = { 0x3b, 0xb3, 0x11, 0x00, 0x00, 0x41, 0x01 },- .atr\_len = 7,- .stopbits = 0x03,- },- { /\* Motorola \*/- .atr = {0x3b, 0x76, 0x13, 0x00, 0x00, 0x80, 0x62, 0x07,- 0x41, 0x81, 0x81 },- .atr\_len = 11,- .stopbits = 0x04,- },-};--static void set\_cardparameter(struct cm4000\_dev \*dev)-{- int i;- unsigned int iobase = dev->p\_dev->resource[0]->start;- u\_int8\_t stopbits = 0x02; /\* ISO default \*/-- DEBUGP(3, dev, "-> set\_cardparameter\n");-- dev->flags1 = dev->flags1 | (((dev->baudv - 1) & 0x0100) >> 8);- xoutb(dev->flags1, REG\_FLAGS1(iobase));- DEBUGP(5, dev, "flags1 = 0x%02x\n", dev->flags1);-- /\* set baudrate \*/- xoutb((unsigned char)((dev->baudv - 1) & 0xFF), REG\_BAUDRATE(iobase));-- DEBUGP(5, dev, "baudv = %i -> write 0x%02x\n", dev->baudv,- ((dev->baudv - 1) & 0xFF));-- /\* set stopbits \*/- for (i = 0; i < ARRAY\_SIZE(card\_fixups); i++) {- if (!memcmp(dev->atr, card\_fixups[i].atr,- card\_fixups[i].atr\_len))- stopbits = card\_fixups[i].stopbits;- }- xoutb(stopbits, REG\_STOPBITS(iobase));-- DEBUGP(3, dev, "<- set\_cardparameter\n");-}--static int set\_protocol(struct cm4000\_dev \*dev, struct ptsreq \*ptsreq)-{-- unsigned long tmp, i;- unsigned short num\_bytes\_read;- unsigned char pts\_reply[4];- ssize\_t rc;- unsigned int iobase = dev->p\_dev->resource[0]->start;-- rc = 0;-- DEBUGP(3, dev, "-> set\_protocol\n");- DEBUGP(5, dev, "ptsreq->Protocol = 0x%.8x, ptsreq->Flags=0x%.8x, "- "ptsreq->pts1=0x%.2x, ptsreq->pts2=0x%.2x, "- "ptsreq->pts3=0x%.2x\n", (unsigned int)ptsreq->protocol,- (unsigned int)ptsreq->flags, ptsreq->pts1, ptsreq->pts2,- ptsreq->pts3);-- /\* Fill PTS structure \*/- dev->pts[0] = 0xff;- dev->pts[1] = 0x00;- tmp = ptsreq->protocol;- while ((tmp = (tmp >> 1)) > 0)- dev->pts[1]++;- dev->proto = dev->pts[1]; /\* Set new protocol \*/- dev->pts[1] = (0x01 << 4) | (dev->pts[1]);-- /\* Correct Fi/Di according to CM4000 Fi/Di table \*/- DEBUGP(5, dev, "Ta(1) from ATR is 0x%.2x\n", dev->ta1);- /\* set Fi/Di according to ATR TA(1) \*/- dev->pts[2] = fi\_di\_table[dev->ta1 & 0x0F][(dev->ta1 >> 4) & 0x0F];-- /\* Calculate PCK character \*/- dev->pts[3] = dev->pts[0] ^ dev->pts[1] ^ dev->pts[2];-- DEBUGP(5, dev, "pts0=%.2x, pts1=%.2x, pts2=%.2x, pts3=%.2x\n",- dev->pts[0], dev->pts[1], dev->pts[2], dev->pts[3]);-- /\* check card convention \*/- if (test\_bit(IS\_INVREV, &dev->flags))- str\_invert\_revert(dev->pts, 4);-- /\* reset SM \*/- xoutb(0x80, REG\_FLAGS0(iobase));-- /\* Enable access to the message buffer \*/- DEBUGP(5, dev, "Enable access to the messages buffer\n");- dev->flags1 = 0x20 /\* T\_Active \*/- | (test\_bit(IS\_INVREV, &dev->flags) ? 0x02 : 0x00) /\* inv parity \*/- | ((dev->baudv >> 8) & 0x01); /\* MSB-baud \*/- xoutb(dev->flags1, REG\_FLAGS1(iobase));-- DEBUGP(5, dev, "Enable message buffer -> flags1 = 0x%.2x\n",- dev->flags1);-- /\* write challenge to the buffer \*/- DEBUGP(5, dev, "Write challenge to buffer: ");- for (i = 0; i < 4; i++) {- xoutb(i, REG\_BUF\_ADDR(iobase));- xoutb(dev->pts[i], REG\_BUF\_DATA(iobase)); /\* buf data \*/-#ifdef CM4000\_DEBUG- pr\_debug("0x%.2x ", dev->pts[i]);- }- pr\_debug("\n");-#else- }-#endif-- /\* set number of bytes to write \*/- DEBUGP(5, dev, "Set number of bytes to write\n");- xoutb(0x04, REG\_NUM\_SEND(iobase));-- /\* Trigger CARDMAN CONTROLLER \*/- xoutb(0x50, REG\_FLAGS0(iobase));-- /\* Monitor progress \*/- /\* wait for xmit done \*/- DEBUGP(5, dev, "Waiting for NumRecBytes getting valid\n");-- for (i = 0; i < 100; i++) {- if (inb(REG\_FLAGS0(iobase)) & 0x08) {- DEBUGP(5, dev, "NumRecBytes is valid\n");- break;- }- /\* can not sleep as this is in atomic context \*/- mdelay(10);- }- if (i == 100) {- DEBUGP(5, dev, "Timeout waiting for NumRecBytes getting "- "valid\n");- rc = -EIO;- goto exit\_setprotocol;- }-- DEBUGP(5, dev, "Reading NumRecBytes\n");- for (i = 0; i < 100; i++) {- io\_read\_num\_rec\_bytes(iobase, &num\_bytes\_read);- if (num\_bytes\_read >= 4) {- DEBUGP(2, dev, "NumRecBytes = %i\n", num\_bytes\_read);- if (num\_bytes\_read > 4) {- rc = -EIO;- goto exit\_setprotocol;- }- break;- }- /\* can not sleep as this is in atomic context \*/- mdelay(10);- }-- /\* check whether it is a short PTS reply? \*/- if (num\_bytes\_read == 3)- i = 0;-- if (i == 100) {- DEBUGP(5, dev, "Timeout reading num\_bytes\_read\n");- rc = -EIO;- goto exit\_setprotocol;- }-- DEBUGP(5, dev, "Reset the CARDMAN CONTROLLER\n");- xoutb(0x80, REG\_FLAGS0(iobase));-- /\* Read PPS reply \*/- DEBUGP(5, dev, "Read PPS reply\n");- for (i = 0; i < num\_bytes\_read; i++) {- xoutb(i, REG\_BUF\_ADDR(iobase));- pts\_reply[i] = inb(REG\_BUF\_DATA(iobase));- }--#ifdef CM4000\_DEBUG- DEBUGP(2, dev, "PTSreply: ");- for (i = 0; i < num\_bytes\_read; i++) {- pr\_debug("0x%.2x ", pts\_reply[i]);- }- pr\_debug("\n");-#endif /\* CM4000\_DEBUG \*/-- DEBUGP(5, dev, "Clear Tactive in Flags1\n");- xoutb(0x20, REG\_FLAGS1(iobase));-- /\* Compare ptsreq and ptsreply \*/- if ((dev->pts[0] == pts\_reply[0]) &&- (dev->pts[1] == pts\_reply[1]) &&- (dev->pts[2] == pts\_reply[2]) && (dev->pts[3] == pts\_reply[3])) {- /\* setcardparameter according to PPS \*/- dev->baudv = calc\_baudv(dev->pts[2]);- set\_cardparameter(dev);- } else if ((dev->pts[0] == pts\_reply[0]) &&- ((dev->pts[1] & 0xef) == pts\_reply[1]) &&- ((pts\_reply[0] ^ pts\_reply[1]) == pts\_reply[2])) {- /\* short PTS reply, set card parameter to default values \*/- dev->baudv = calc\_baudv(0x11);- set\_cardparameter(dev);- } else- rc = -EIO;--exit\_setprotocol:- DEBUGP(3, dev, "<- set\_protocol\n");- return rc;-}--static int io\_detect\_cm4000(unsigned int iobase, struct cm4000\_dev \*dev)-{-- /\* note: statemachine is assumed to be reset \*/- if (inb(REG\_FLAGS0(iobase)) & 8) {- clear\_bit(IS\_ATR\_VALID, &dev->flags);- set\_bit(IS\_CMM\_ABSENT, &dev->flags);- return 0; /\* detect CMM = 1 -> failure \*/- }- /\* xoutb(0x40, REG\_FLAGS1(iobase)); detectCMM \*/- xoutb(dev->flags1 | 0x40, REG\_FLAGS1(iobase));- if ((inb(REG\_FLAGS0(iobase)) & 8) == 0) {- clear\_bit(IS\_ATR\_VALID, &dev->flags);- set\_bit(IS\_CMM\_ABSENT, &dev->flags);- return 0; /\* detect CMM=0 -> failure \*/- }- /\* clear detectCMM again by restoring original flags1 \*/- xoutb(dev->flags1, REG\_FLAGS1(iobase));- return 1;-}--static void terminate\_monitor(struct cm4000\_dev \*dev)-{-- /\* tell the monitor to stop and wait until- \* it terminates.- \*/- DEBUGP(3, dev, "-> terminate\_monitor\n");- wait\_event\_interruptible(dev->devq,- test\_and\_set\_bit(LOCK\_MONITOR,- (void \*)&dev->flags));-- /\* now, LOCK\_MONITOR has been set.- \* allow a last cycle in the monitor.- \* the monitor will indicate that it has- \* finished by clearing this bit.- \*/- DEBUGP(5, dev, "Now allow last cycle of monitor!\n");- while (test\_bit(LOCK\_MONITOR, (void \*)&dev->flags))- msleep(25);-- DEBUGP(5, dev, "Delete timer\n");- del\_timer\_sync(&dev->timer);-#ifdef CM4000\_DEBUG- dev->monitor\_running = 0;-#endif-- DEBUGP(3, dev, "<- terminate\_monitor\n");-}--/\*- \* monitor the card every 50msec. as a side-effect, retrieve the- \* atr once a card is inserted. another side-effect of retrieving the- \* atr is that the card will be powered on, so there is no need to- \* power on the card explicitly from the application: the driver- \* is already doing that for you.- \*/--static void monitor\_card(struct timer\_list \*t)-{- struct cm4000\_dev \*dev = from\_timer(dev, t, timer);- unsigned int iobase = dev->p\_dev->resource[0]->start;- unsigned short s;- struct ptsreq ptsreq;- int i, atrc;-- DEBUGP(7, dev, "-> monitor\_card\n");-- /\* if someone has set the lock for us: we're done! \*/- if (test\_and\_set\_bit(LOCK\_MONITOR, &dev->flags)) {- DEBUGP(4, dev, "About to stop monitor\n");- /\* no \*/- dev->rlen =- dev->rpos =- dev->atr\_csum = dev->atr\_len\_retry = dev->cwarn = 0;- dev->mstate = M\_FETCH\_ATR;- clear\_bit(LOCK\_MONITOR, &dev->flags);- /\* close et al. are sleeping on devq, so wake it \*/- wake\_up\_interruptible(&dev->devq);- DEBUGP(2, dev, "<- monitor\_card (we are done now)\n");- return;- }-- /\* try to lock io: if it is already locked, just add another timer \*/- if (test\_and\_set\_bit(LOCK\_IO, (void \*)&dev->flags)) {- DEBUGP(4, dev, "Couldn't get IO lock\n");- goto return\_with\_timer;- }-- /\* is a card/a reader inserted at all ? \*/- dev->flags0 = xinb(REG\_FLAGS0(iobase));- DEBUGP(7, dev, "dev->flags0 = 0x%2x\n", dev->flags0);- DEBUGP(7, dev, "smartcard present: %s\n",- dev->flags0 & 1 ? "yes" : "no");- DEBUGP(7, dev, "cardman present: %s\n",- dev->flags0 == 0xff ? "no" : "yes");-- if ((dev->flags0 & 1) == 0 /\* no smartcard inserted \*/- || dev->flags0 == 0xff) { /\* no cardman inserted \*/- /\* no \*/- dev->rlen =- dev->rpos =- dev->atr\_csum = dev->atr\_len\_retry = dev->cwarn = 0;- dev->mstate = M\_FETCH\_ATR;-- dev->flags &= 0x000000ff; /\* only keep IO and MONITOR locks \*/-- if (dev->flags0 == 0xff) {- DEBUGP(4, dev, "set IS\_CMM\_ABSENT bit\n");- set\_bit(IS\_CMM\_ABSENT, &dev->flags);- } else if (test\_bit(IS\_CMM\_ABSENT, &dev->flags)) {- DEBUGP(4, dev, "clear IS\_CMM\_ABSENT bit "- "(card is removed)\n");- clear\_bit(IS\_CMM\_ABSENT, &dev->flags);- }-- goto release\_io;- } else if ((dev->flags0 & 1) && test\_bit(IS\_CMM\_ABSENT, &dev->flags)) {- /\* cardman and card present but cardman was absent before- \* (after suspend with inserted card) \*/- DEBUGP(4, dev, "clear IS\_CMM\_ABSENT bit (card is inserted)\n");- clear\_bit(IS\_CMM\_ABSENT, &dev->flags);- }-- if (test\_bit(IS\_ATR\_VALID, &dev->flags) == 1) {- DEBUGP(7, dev, "believe ATR is already valid (do nothing)\n");- goto release\_io;- }-- switch (dev->mstate) {- case M\_CARDOFF: {- unsigned char flags0;-- DEBUGP(4, dev, "M\_CARDOFF\n");- flags0 = inb(REG\_FLAGS0(iobase));- if (flags0 & 0x02) {- /\* wait until Flags0 indicate power is off \*/- dev->mdelay = T\_10MSEC;- } else {- /\* Flags0 indicate power off and no card inserted now;- \* Reset CARDMAN CONTROLLER \*/- xoutb(0x80, REG\_FLAGS0(iobase));-- /\* prepare for fetching ATR again: after card off ATR- \* is read again automatically \*/- dev->rlen =- dev->rpos =- dev->atr\_csum =- dev->atr\_len\_retry = dev->cwarn = 0;- dev->mstate = M\_FETCH\_ATR;-- /\* minimal gap between CARDOFF and read ATR is 50msec \*/- dev->mdelay = T\_50MSEC;- }- break;- }- case M\_FETCH\_ATR:- DEBUGP(4, dev, "M\_FETCH\_ATR\n");- xoutb(0x80, REG\_FLAGS0(iobase));- DEBUGP(4, dev, "Reset BAUDV to 9600\n");- dev->baudv = 0x173; /\* 9600 \*/- xoutb(0x02, REG\_STOPBITS(iobase)); /\* stopbits=2 \*/- xoutb(0x73, REG\_BAUDRATE(iobase)); /\* baud value \*/- xoutb(0x21, REG\_FLAGS1(iobase)); /\* T\_Active=1, baud- value \*/- /\* warm start vs. power on: \*/- xoutb(dev->flags0 & 2 ? 0x46 : 0x44, REG\_FLAGS0(iobase));- dev->mdelay = T\_40MSEC;- dev->mstate = M\_TIMEOUT\_WAIT;- break;- case M\_TIMEOUT\_WAIT:- DEBUGP(4, dev, "M\_TIMEOUT\_WAIT\n");- /\* numRecBytes \*/- io\_read\_num\_rec\_bytes(iobase, &dev->atr\_len);- dev->mdelay = T\_10MSEC;- dev->mstate = M\_READ\_ATR\_LEN;- break;- case M\_READ\_ATR\_LEN:- DEBUGP(4, dev, "M\_READ\_ATR\_LEN\n");- /\* infinite loop possible, since there is no timeout \*/--#define MAX\_ATR\_LEN\_RETRY 100-- if (dev->atr\_len == io\_read\_num\_rec\_bytes(iobase, &s)) {- if (dev->atr\_len\_retry++ >= MAX\_ATR\_LEN\_RETRY) { /\* + XX msec \*/- dev->mdelay = T\_10MSEC;- dev->mstate = M\_READ\_ATR;- }- } else {- dev->atr\_len = s;- dev->atr\_len\_retry = 0; /\* set new timeout \*/- }-- DEBUGP(4, dev, "Current ATR\_LEN = %i\n", dev->atr\_len);- break;- case M\_READ\_ATR:- DEBUGP(4, dev, "M\_READ\_ATR\n");- xoutb(0x80, REG\_FLAGS0(iobase)); /\* reset SM \*/- for (i = 0; i < dev->atr\_len; i++) {- xoutb(i, REG\_BUF\_ADDR(iobase));- dev->atr[i] = inb(REG\_BUF\_DATA(iobase));- }- /\* Deactivate T\_Active flags \*/- DEBUGP(4, dev, "Deactivate T\_Active flags\n");- dev->flags1 = 0x01;- xoutb(dev->flags1, REG\_FLAGS1(iobase));-- /\* atr is present (which doesn't mean it's valid) \*/- set\_bit(IS\_ATR\_PRESENT, &dev->flags);- if (dev->atr[0] == 0x03)- str\_invert\_revert(dev->atr, dev->atr\_len);- atrc = parse\_atr(dev);- if (atrc == 0) { /\* atr invalid \*/- dev->mdelay = 0;- dev->mstate = M\_BAD\_CARD;- } else {- dev->mdelay = T\_50MSEC;- dev->mstate = M\_ATR\_PRESENT;- set\_bit(IS\_ATR\_VALID, &dev->flags);- }-- if (test\_bit(IS\_ATR\_VALID, &dev->flags) == 1) {- DEBUGP(4, dev, "monitor\_card: ATR valid\n");- /\* if ta1 == 0x11, no PPS necessary (default values) \*/- /\* do not do PPS with multi protocol cards \*/- if ((test\_bit(IS\_AUTOPPS\_ACT, &dev->flags) == 0) &&- (dev->ta1 != 0x11) &&- !(test\_bit(IS\_ANY\_T0, &dev->flags) &&- test\_bit(IS\_ANY\_T1, &dev->flags))) {- DEBUGP(4, dev, "Perform AUTOPPS\n");- set\_bit(IS\_AUTOPPS\_ACT, &dev->flags);- ptsreq.protocol = (0x01 << dev->proto);- ptsreq.flags = 0x01;- ptsreq.pts1 = 0x00;- ptsreq.pts2 = 0x00;- ptsreq.pts3 = 0x00;- if (set\_protocol(dev, &ptsreq) == 0) {- DEBUGP(4, dev, "AUTOPPS ret SUCC\n");- clear\_bit(IS\_AUTOPPS\_ACT, &dev->flags);- wake\_up\_interruptible(&dev->atrq);- } else {- DEBUGP(4, dev, "AUTOPPS failed: "- "repower using defaults\n");- /\* prepare for repowering \*/- clear\_bit(IS\_ATR\_PRESENT, &dev->flags);- clear\_bit(IS\_ATR\_VALID, &dev->flags);- dev->rlen =- dev->rpos =- dev->atr\_csum =- dev->atr\_len\_retry = dev->cwarn = 0;- dev->mstate = M\_FETCH\_ATR;-- dev->mdelay = T\_50MSEC;- }- } else {- /\* for cards which use slightly different- \* params (extra guard time) \*/- set\_cardparameter(dev);- if (test\_bit(IS\_AUTOPPS\_ACT, &dev->flags) == 1)- DEBUGP(4, dev, "AUTOPPS already active "- "2nd try:use default values\n");- if (dev->ta1 == 0x11)- DEBUGP(4, dev, "No AUTOPPS necessary "- "TA(1)==0x11\n");- if (test\_bit(IS\_ANY\_T0, &dev->flags)- && test\_bit(IS\_ANY\_T1, &dev->flags))- DEBUGP(4, dev, "Do NOT perform AUTOPPS "- "with multiprotocol cards\n");- clear\_bit(IS\_AUTOPPS\_ACT, &dev->flags);- wake\_up\_interruptible(&dev->atrq);- }- } else {- DEBUGP(4, dev, "ATR invalid\n");- wake\_up\_interruptible(&dev->atrq);- }- break;- case M\_BAD\_CARD:- DEBUGP(4, dev, "M\_BAD\_CARD\n");- /\* slow down warning, but prompt immediately after insertion \*/- if (dev->cwarn == 0 || dev->cwarn == 10) {- set\_bit(IS\_BAD\_CARD, &dev->flags);- dev\_warn(&dev->p\_dev->dev, MODULE\_NAME ": ");- if (test\_bit(IS\_BAD\_CSUM, &dev->flags)) {- DEBUGP(4, dev, "ATR checksum (0x%.2x, should "- "be zero) failed\n", dev->atr\_csum);- }-#ifdef CM4000\_DEBUG- else if (test\_bit(IS\_BAD\_LENGTH, &dev->flags)) {- DEBUGP(4, dev, "ATR length error\n");- } else {- DEBUGP(4, dev, "card damaged or wrong way "- "inserted\n");- }-#endif- dev->cwarn = 0;- wake\_up\_interruptible(&dev->atrq); /\* wake open \*/- }- dev->cwarn++;- dev->mdelay = T\_100MSEC;- dev->mstate = M\_FETCH\_ATR;- break;- default:- DEBUGP(7, dev, "Unknown action\n");- break; /\* nothing \*/- }--release\_io:- DEBUGP(7, dev, "release\_io\n");- clear\_bit(LOCK\_IO, &dev->flags);- wake\_up\_interruptible(&dev->ioq); /\* whoever needs IO \*/--return\_with\_timer:- DEBUGP(7, dev, "<- monitor\_card (returns with timer)\n");- mod\_timer(&dev->timer, jiffies + dev->mdelay);- clear\_bit(LOCK\_MONITOR, &dev->flags);-}--/\* Interface to userland (file\_operations) \*/--static ssize\_t cmm\_read(struct file \*filp, \_\_user char \*buf, size\_t count,- loff\_t \*ppos)-{- struct cm4000\_dev \*dev = filp->private\_data;- unsigned int iobase = dev->p\_dev->resource[0]->start;- ssize\_t rc;- int i, j, k;-- DEBUGP(2, dev, "-> cmm\_read(%s,%d)\n", current->comm, current->pid);-- if (count == 0) /\* according to manpage \*/- return 0;-- if (!pcmcia\_dev\_present(dev->p\_dev) || /\* device removed \*/- test\_bit(IS\_CMM\_ABSENT, &dev->flags))- return -ENODEV;-- if (test\_bit(IS\_BAD\_CSUM, &dev->flags))- return -EIO;-- /\* also see the note about this in cmm\_write \*/- if (wait\_event\_interruptible- (dev->atrq,- ((filp->f\_flags & O\_NONBLOCK)- || (test\_bit(IS\_ATR\_PRESENT, (void \*)&dev->flags) != 0)))) {- if (filp->f\_flags & O\_NONBLOCK)- return -EAGAIN;- return -ERESTARTSYS;- }-- if (test\_bit(IS\_ATR\_VALID, &dev->flags) == 0)- return -EIO;-- /\* this one implements blocking IO \*/- if (wait\_event\_interruptible- (dev->readq,- ((filp->f\_flags & O\_NONBLOCK) || (dev->rpos < dev->rlen)))) {- if (filp->f\_flags & O\_NONBLOCK)- return -EAGAIN;- return -ERESTARTSYS;- }-- /\* lock io \*/- if (wait\_event\_interruptible- (dev->ioq,- ((filp->f\_flags & O\_NONBLOCK)- || (test\_and\_set\_bit(LOCK\_IO, (void \*)&dev->flags) == 0)))) {- if (filp->f\_flags & O\_NONBLOCK)- return -EAGAIN;- return -ERESTARTSYS;- }-- rc = 0;- dev->flags0 = inb(REG\_FLAGS0(iobase));- if ((dev->flags0 & 1) == 0 /\* no smartcard inserted \*/- || dev->flags0 == 0xff) { /\* no cardman inserted \*/- clear\_bit(IS\_ATR\_VALID, &dev->flags);- if (dev->flags0 & 1) {- set\_bit(IS\_CMM\_ABSENT, &dev->flags);- rc = -ENODEV;- } else {- rc = -EIO;- }- goto release\_io;- }-- DEBUGP(4, dev, "begin read answer\n");- j = min(count, (size\_t)(dev->rlen - dev->rpos));- k = dev->rpos;- if (k + j > 255)- j = 256 - k;- DEBUGP(4, dev, "read1 j=%d\n", j);- for (i = 0; i < j; i++) {- xoutb(k++, REG\_BUF\_ADDR(iobase));- dev->rbuf[i] = xinb(REG\_BUF\_DATA(iobase));- }- j = min(count, (size\_t)(dev->rlen - dev->rpos));- if (k + j > 255) {- DEBUGP(4, dev, "read2 j=%d\n", j);- dev->flags1 |= 0x10; /\* MSB buf addr set \*/- xoutb(dev->flags1, REG\_FLAGS1(iobase));- for (; i < j; i++) {- xoutb(k++, REG\_BUF\_ADDR(iobase));- dev->rbuf[i] = xinb(REG\_BUF\_DATA(iobase));- }- }-- if (dev->proto == 0 && count > dev->rlen - dev->rpos && i) {- DEBUGP(4, dev, "T=0 and count > buffer\n");- dev->rbuf[i] = dev->rbuf[i - 1];- dev->rbuf[i - 1] = dev->procbyte;- j++;- }- count = j;-- dev->rpos = dev->rlen + 1;-- /\* Clear T1Active \*/- DEBUGP(4, dev, "Clear T1Active\n");- dev->flags1 &= 0xdf;- xoutb(dev->flags1, REG\_FLAGS1(iobase));-- xoutb(0, REG\_FLAGS1(iobase)); /\* clear detectCMM \*/- /\* last check before exit \*/- if (!io\_detect\_cm4000(iobase, dev)) {- rc = -ENODEV;- goto release\_io;- }-- if (test\_bit(IS\_INVREV, &dev->flags) && count > 0)- str\_invert\_revert(dev->rbuf, count);-- if (copy\_to\_user(buf, dev->rbuf, count))- rc = -EFAULT;--release\_io:- clear\_bit(LOCK\_IO, &dev->flags);- wake\_up\_interruptible(&dev->ioq);-- DEBUGP(2, dev, "<- cmm\_read returns: rc = %zi\n",- (rc < 0 ? rc : count));- return rc < 0 ? rc : count;-}--static ssize\_t cmm\_write(struct file \*filp, const char \_\_user \*buf,- size\_t count, loff\_t \*ppos)-{- struct cm4000\_dev \*dev = filp->private\_data;- unsigned int iobase = dev->p\_dev->resource[0]->start;- unsigned short s;- unsigned char infolen;- unsigned char sendT0;- unsigned short nsend;- unsigned short nr;- ssize\_t rc;- int i;-- DEBUGP(2, dev, "-> cmm\_write(%s,%d)\n", current->comm, current->pid);-- if (count == 0) /\* according to manpage \*/- return 0;-- if (dev->proto == 0 && count < 4) {- /\* T0 must have at least 4 bytes \*/- DEBUGP(4, dev, "T0 short write\n");- return -EIO;- }-- nr = count & 0x1ff; /\* max bytes to write \*/-- sendT0 = dev->proto ? 0 : nr > 5 ? 0x08 : 0;-- if (!pcmcia\_dev\_present(dev->p\_dev) || /\* device removed \*/- test\_bit(IS\_CMM\_ABSENT, &dev->flags))- return -ENODEV;-- if (test\_bit(IS\_BAD\_CSUM, &dev->flags)) {- DEBUGP(4, dev, "bad csum\n");- return -EIO;- }-- /\*- \* wait for atr to become valid.- \* note: it is important to lock this code. if we dont, the monitor- \* could be run between test\_bit and the call to sleep on the- \* atr-queue. if \*then\* the monitor detects atr valid, it will wake up- \* any process on the atr-queue, \*but\* since we have been interrupted,- \* we do not yet sleep on this queue. this would result in a missed- \* wake\_up and the calling process would sleep forever (until- \* interrupted). also, do \*not\* restore\_flags before sleep\_on, because- \* this could result in the same situation!- \*/- if (wait\_event\_interruptible- (dev->atrq,- ((filp->f\_flags & O\_NONBLOCK)- || (test\_bit(IS\_ATR\_PRESENT, (void \*)&dev->flags) != 0)))) {- if (filp->f\_flags & O\_NONBLOCK)- return -EAGAIN;- return -ERESTARTSYS;- }-- if (test\_bit(IS\_ATR\_VALID, &dev->flags) == 0) { /\* invalid atr \*/- DEBUGP(4, dev, "invalid ATR\n");- return -EIO;- }-- /\* lock io \*/- if (wait\_event\_interruptible- (dev->ioq,- ((filp->f\_flags & O\_NONBLOCK)- || (test\_and\_set\_bit(LOCK\_IO, (void \*)&dev->flags) == 0)))) {- if (filp->f\_flags & O\_NONBLOCK)- return -EAGAIN;- return -ERESTARTSYS;- }-- if (copy\_from\_user(dev->sbuf, buf, ((count > 512) ? 512 : count)))- return -EFAULT;-- rc = 0;- dev->flags0 = inb(REG\_FLAGS0(iobase));- if ((dev->flags0 & 1) == 0 /\* no smartcard inserted \*/- || dev->flags0 == 0xff) { /\* no cardman inserted \*/- clear\_bit(IS\_ATR\_VALID, &dev->flags);- if (dev->flags0 & 1) {- set\_bit(IS\_CMM\_ABSENT, &dev->flags);- rc = -ENODEV;- } else {- DEBUGP(4, dev, "IO error\n");- rc = -EIO;- }- goto release\_io;- }-- xoutb(0x80, REG\_FLAGS0(iobase)); /\* reset SM \*/-- if (!io\_detect\_cm4000(iobase, dev)) {- rc = -ENODEV;- goto release\_io;- }-- /\* reflect T=0 send/read mode in flags1 \*/- dev->flags1 |= (sendT0);-- set\_cardparameter(dev);-- /\* dummy read, reset flag procedure received \*/- inb(REG\_FLAGS1(iobase));-- dev->flags1 = 0x20 /\* T\_Active \*/- | (sendT0)- | (test\_bit(IS\_INVREV, &dev->flags) ? 2 : 0)/\* inverse parity \*/- | (((dev->baudv - 1) & 0x0100) >> 8); /\* MSB-Baud \*/- DEBUGP(1, dev, "set dev->flags1 = 0x%.2x\n", dev->flags1);- xoutb(dev->flags1, REG\_FLAGS1(iobase));-- /\* xmit data \*/- DEBUGP(4, dev, "Xmit data\n");- for (i = 0; i < nr; i++) {- if (i >= 256) {- dev->flags1 = 0x20 /\* T\_Active \*/- | (sendT0) /\* SendT0 \*/- /\* inverse parity: \*/- | (test\_bit(IS\_INVREV, &dev->flags) ? 2 : 0)- | (((dev->baudv - 1) & 0x0100) >> 8) /\* MSB-Baud \*/- | 0x10; /\* set address high \*/- DEBUGP(4, dev, "dev->flags = 0x%.2x - set address "- "high\n", dev->flags1);- xoutb(dev->flags1, REG\_FLAGS1(iobase));- }- if (test\_bit(IS\_INVREV, &dev->flags)) {- DEBUGP(4, dev, "Apply inverse convention for 0x%.2x "- "-> 0x%.2x\n", (unsigned char)dev->sbuf[i],- invert\_revert(dev->sbuf[i]));- xoutb(i, REG\_BUF\_ADDR(iobase));- xoutb(invert\_revert(dev->sbuf[i]),- REG\_BUF\_DATA(iobase));- } else {- xoutb(i, REG\_BUF\_ADDR(iobase));- xoutb(dev->sbuf[i], REG\_BUF\_DATA(iobase));- }- }- DEBUGP(4, dev, "Xmit done\n");-- if (dev->proto == 0) {- /\* T=0 proto: 0 byte reply \*/- if (nr == 4) {- DEBUGP(4, dev, "T=0 assumes 0 byte reply\n");- xoutb(i, REG\_BUF\_ADDR(iobase));- if (test\_bit(IS\_INVREV, &dev->flags))- xoutb(0xff, REG\_BUF\_DATA(iobase));- else- xoutb(0x00, REG\_BUF\_DATA(iobase));- }-- /\* numSendBytes \*/- if (sendT0)- nsend = nr;- else {- if (nr == 4)- nsend = 5;- else {- nsend = 5 + (unsigned char)dev->sbuf[4];- if (dev->sbuf[4] == 0)- nsend += 0x100;- }- }- } else- nsend = nr;-- /\* T0: output procedure byte \*/- if (test\_bit(IS\_INVREV, &dev->flags)) {- DEBUGP(4, dev, "T=0 set Procedure byte (inverse-reverse) "- "0x%.2x\n", invert\_revert(dev->sbuf[1]));- xoutb(invert\_revert(dev->sbuf[1]), REG\_NUM\_BYTES(iobase));- } else {- DEBUGP(4, dev, "T=0 set Procedure byte 0x%.2x\n", dev->sbuf[1]);- xoutb(dev->sbuf[1], REG\_NUM\_BYTES(iobase));- }-- DEBUGP(1, dev, "set NumSendBytes = 0x%.2x\n",- (unsigned char)(nsend & 0xff));- xoutb((unsigned char)(nsend & 0xff), REG\_NUM\_SEND(iobase));-- DEBUGP(1, dev, "Trigger CARDMAN CONTROLLER (0x%.2x)\n",- 0x40 /\* SM\_Active \*/- | (dev->flags0 & 2 ? 0 : 4) /\* power on if needed \*/- |(dev->proto ? 0x10 : 0x08) /\* T=1/T=0 \*/- |(nsend & 0x100) >> 8 /\* MSB numSendBytes \*/ );- xoutb(0x40 /\* SM\_Active \*/- | (dev->flags0 & 2 ? 0 : 4) /\* power on if needed \*/- |(dev->proto ? 0x10 : 0x08) /\* T=1/T=0 \*/- |(nsend & 0x100) >> 8, /\* MSB numSendBytes \*/- REG\_FLAGS0(iobase));-- /\* wait for xmit done \*/- if (dev->proto == 1) {- DEBUGP(4, dev, "Wait for xmit done\n");- for (i = 0; i < 1000; i++) {- if (inb(REG\_FLAGS0(iobase)) & 0x08)- break;- msleep\_interruptible(10);- }- if (i == 1000) {- DEBUGP(4, dev, "timeout waiting for xmit done\n");- rc = -EIO;- goto release\_io;- }- }-- /\* T=1: wait for infoLen \*/-- infolen = 0;- if (dev->proto) {- /\* wait until infoLen is valid \*/- for (i = 0; i < 6000; i++) { /\* max waiting time of 1 min \*/- io\_read\_num\_rec\_bytes(iobase, &s);- if (s >= 3) {- infolen = inb(REG\_FLAGS1(iobase));- DEBUGP(4, dev, "infolen=%d\n", infolen);- break;- }- msleep\_interruptible(10);- }- if (i == 6000) {- DEBUGP(4, dev, "timeout waiting for infoLen\n");- rc = -EIO;- goto release\_io;- }- } else- clear\_bit(IS\_PROCBYTE\_PRESENT, &dev->flags);-- /\* numRecBytes | bit9 of numRecytes \*/- io\_read\_num\_rec\_bytes(iobase, &dev->rlen);- for (i = 0; i < 600; i++) { /\* max waiting time of 2 sec \*/- if (dev->proto) {- if (dev->rlen >= infolen + 4)- break;- }- msleep\_interruptible(10);- /\* numRecBytes | bit9 of numRecytes \*/- io\_read\_num\_rec\_bytes(iobase, &s);- if (s > dev->rlen) {- DEBUGP(1, dev, "NumRecBytes inc (reset timeout)\n");- i = 0; /\* reset timeout \*/- dev->rlen = s;- }- /\* T=0: we are done when numRecBytes doesn't- \* increment any more and NoProcedureByte- \* is set and numRecBytes == bytes sent + 6- \* (header bytes + data + 1 for sw2)- \* except when the card replies an error- \* which means, no data will be sent back.- \*/- else if (dev->proto == 0) {- if ((inb(REG\_BUF\_ADDR(iobase)) & 0x80)) {- /\* no procedure byte received since last read \*/- DEBUGP(1, dev, "NoProcedure byte set\n");- /\* i=0; \*/- } else {- /\* procedure byte received since last read \*/- DEBUGP(1, dev, "NoProcedure byte unset "- "(reset timeout)\n");- dev->procbyte = inb(REG\_FLAGS1(iobase));- DEBUGP(1, dev, "Read procedure byte 0x%.2x\n",- dev->procbyte);- i = 0; /\* resettimeout \*/- }- if (inb(REG\_FLAGS0(iobase)) & 0x08) {- DEBUGP(1, dev, "T0Done flag (read reply)\n");- break;- }- }- if (dev->proto)- infolen = inb(REG\_FLAGS1(iobase));- }- if (i == 600) {- DEBUGP(1, dev, "timeout waiting for numRecBytes\n");- rc = -EIO;- goto release\_io;- } else {- if (dev->proto == 0) {- DEBUGP(1, dev, "Wait for T0Done bit to be set\n");- for (i = 0; i < 1000; i++) {- if (inb(REG\_FLAGS0(iobase)) & 0x08)- break;- msleep\_interruptible(10);- }- if (i == 1000) {- DEBUGP(1, dev, "timeout waiting for T0Done\n");- rc = -EIO;- goto release\_io;- }-- dev->procbyte = inb(REG\_FLAGS1(iobase));- DEBUGP(4, dev, "Read procedure byte 0x%.2x\n",- dev->procbyte);-- io\_read\_num\_rec\_bytes(iobase, &dev->rlen);- DEBUGP(4, dev, "Read NumRecBytes = %i\n", dev->rlen);-- }- }- /\* T=1: read offset=zero, T=0: read offset=after challenge \*/- dev->rpos = dev->proto ? 0 : nr == 4 ? 5 : nr > dev->rlen ? 5 : nr;- DEBUGP(4, dev, "dev->rlen = %i, dev->rpos = %i, nr = %i\n",- dev->rlen, dev->rpos, nr);--release\_io:- DEBUGP(4, dev, "Reset SM\n");- xoutb(0x80, REG\_FLAGS0(iobase)); /\* reset SM \*/-- if (rc < 0) {- DEBUGP(4, dev, "Write failed but clear T\_Active\n");- dev->flags1 &= 0xdf;- xoutb(dev->flags1, REG\_FLAGS1(iobase));- }-- clear\_bit(LOCK\_IO, &dev->flags);- wake\_up\_interruptible(&dev->ioq);- wake\_up\_interruptible(&dev->readq); /\* tell read we have data \*/-- /\* ITSEC E2: clear write buffer \*/- memset((char \*)dev->sbuf, 0, 512);-- /\* return error or actually written bytes \*/- DEBUGP(2, dev, "<- cmm\_write\n");- return rc < 0 ? rc : nr;-}--static void start\_monitor(struct cm4000\_dev \*dev)-{- DEBUGP(3, dev, "-> start\_monitor\n");- if (!dev->monitor\_running) {- DEBUGP(5, dev, "create, init and add timer\n");- timer\_setup(&dev->timer, monitor\_card, 0);- dev->monitor\_running = 1;- mod\_timer(&dev->timer, jiffies);- } else- DEBUGP(5, dev, "monitor already running\n");- DEBUGP(3, dev, "<- start\_monitor\n");-}--static void stop\_monitor(struct cm4000\_dev \*dev)-{- DEBUGP(3, dev, "-> stop\_monitor\n");- if (dev->monitor\_running) {- DEBUGP(5, dev, "stopping monitor\n");- terminate\_monitor(dev);- /\* reset monitor SM \*/- clear\_bit(IS\_ATR\_VALID, &dev->flags);- clear\_bit(IS\_ATR\_PRESENT, &dev->flags);- } else- DEBUGP(5, dev, "monitor already stopped\n");- DEBUGP(3, dev, "<- stop\_monitor\n");-}--static long cmm\_ioctl(struct file \*filp, unsigned int cmd, unsigned long arg)-{- struct cm4000\_dev \*dev = filp->private\_data;- unsigned int iobase = dev->p\_dev->resource[0]->start;- struct inode \*inode = file\_inode(filp);- struct pcmcia\_device \*link;- int rc;- void \_\_user \*argp = (void \_\_user \*)arg;-#ifdef CM4000\_DEBUG- char \*ioctl\_names[CM\_IOC\_MAXNR + 1] = {- [\_IOC\_NR(CM\_IOCGSTATUS)] "CM\_IOCGSTATUS",- [\_IOC\_NR(CM\_IOCGATR)] "CM\_IOCGATR",- [\_IOC\_NR(CM\_IOCARDOFF)] "CM\_IOCARDOFF",- [\_IOC\_NR(CM\_IOCSPTS)] "CM\_IOCSPTS",- [\_IOC\_NR(CM\_IOSDBGLVL)] "CM4000\_DBGLVL",- };- DEBUGP(3, dev, "cmm\_ioctl(device=%d.%d) %s\n", imajor(inode),- iminor(inode), ioctl\_names[\_IOC\_NR(cmd)]);-#endif-- mutex\_lock(&cmm\_mutex);- rc = -ENODEV;- link = dev\_table[iminor(inode)];- if (!pcmcia\_dev\_present(link)) {- DEBUGP(4, dev, "DEV\_OK false\n");- goto out;- }-- if (test\_bit(IS\_CMM\_ABSENT, &dev->flags)) {- DEBUGP(4, dev, "CMM\_ABSENT flag set\n");- goto out;- }- rc = -EINVAL;-- if (\_IOC\_TYPE(cmd) != CM\_IOC\_MAGIC) {- DEBUGP(4, dev, "ioctype mismatch\n");- goto out;- }- if (\_IOC\_NR(cmd) > CM\_IOC\_MAXNR) {- DEBUGP(4, dev, "iocnr mismatch\n");- goto out;- }- rc = 0;-- switch (cmd) {- case CM\_IOCGSTATUS:- DEBUGP(4, dev, " ... in CM\_IOCGSTATUS\n");- {- int status;-- /\* clear other bits, but leave inserted & powered as- \* they are \*/- status = dev->flags0 & 3;- if (test\_bit(IS\_ATR\_PRESENT, &dev->flags))- status |= CM\_ATR\_PRESENT;- if (test\_bit(IS\_ATR\_VALID, &dev->flags))- status |= CM\_ATR\_VALID;- if (test\_bit(IS\_CMM\_ABSENT, &dev->flags))- status |= CM\_NO\_READER;- if (test\_bit(IS\_BAD\_CARD, &dev->flags))- status |= CM\_BAD\_CARD;- if (copy\_to\_user(argp, &status, sizeof(int)))- rc = -EFAULT;- }- break;- case CM\_IOCGATR:- DEBUGP(4, dev, "... in CM\_IOCGATR\n");- {- struct atreq \_\_user \*atreq = argp;- int tmp;- /\* allow nonblocking io and being interrupted \*/- if (wait\_event\_interruptible- (dev->atrq,- ((filp->f\_flags & O\_NONBLOCK)- || (test\_bit(IS\_ATR\_PRESENT, (void \*)&dev->flags)- != 0)))) {- if (filp->f\_flags & O\_NONBLOCK)- rc = -EAGAIN;- else- rc = -ERESTARTSYS;- break;- }-- rc = -EFAULT;- if (test\_bit(IS\_ATR\_VALID, &dev->flags) == 0) {- tmp = -1;- if (copy\_to\_user(&(atreq->atr\_len), &tmp,- sizeof(int)))- break;- } else {- if (copy\_to\_user(atreq->atr, dev->atr,- dev->atr\_len))- break;-- tmp = dev->atr\_len;- if (copy\_to\_user(&(atreq->atr\_len), &tmp, sizeof(int)))- break;- }- rc = 0;- break;- }- case CM\_IOCARDOFF:--#ifdef CM4000\_DEBUG- DEBUGP(4, dev, "... in CM\_IOCARDOFF\n");- if (dev->flags0 & 0x01) {- DEBUGP(4, dev, " Card inserted\n");- } else {- DEBUGP(2, dev, " No card inserted\n");- }- if (dev->flags0 & 0x02) {- DEBUGP(4, dev, " Card powered\n");- } else {- DEBUGP(2, dev, " Card not powered\n");- }-#endif-- /\* is a card inserted and powered? \*/- if ((dev->flags0 & 0x01) && (dev->flags0 & 0x02)) {-- /\* get IO lock \*/- if (wait\_event\_interruptible- (dev->ioq,- ((filp->f\_flags & O\_NONBLOCK)- || (test\_and\_set\_bit(LOCK\_IO, (void \*)&dev->flags)- == 0)))) {- if (filp->f\_flags & O\_NONBLOCK)- rc = -EAGAIN;- else- rc = -ERESTARTSYS;- break;- }- /\* Set Flags0 = 0x42 \*/- DEBUGP(4, dev, "Set Flags0=0x42 \n");- xoutb(0x42, REG\_FLAGS0(iobase));- clear\_bit(IS\_ATR\_PRESENT, &dev->flags);- clear\_bit(IS\_ATR\_VALID, &dev->flags);- dev->mstate = M\_CARDOFF;- clear\_bit(LOCK\_IO, &dev->flags);- if (wait\_event\_interruptible- (dev->atrq,- ((filp->f\_flags & O\_NONBLOCK)- || (test\_bit(IS\_ATR\_VALID, (void \*)&dev->flags) !=- 0)))) {- if (filp->f\_flags & O\_NONBLOCK)- rc = -EAGAIN;- else- rc = -ERESTARTSYS;- break;- }- }- /\* release lock \*/- clear\_bit(LOCK\_IO, &dev->flags);- wake\_up\_interruptible(&dev->ioq);-- rc = 0;- break;- case CM\_IOCSPTS:- {- struct ptsreq krnptsreq;-- if (copy\_from\_user(&krnptsreq, argp,- sizeof(struct ptsreq))) {- rc = -EFAULT;- break;- }-- rc = 0;- DEBUGP(4, dev, "... in CM\_IOCSPTS\n");- /\* wait for ATR to get valid \*/- if (wait\_event\_interruptible- (dev->atrq,- ((filp->f\_flags & O\_NONBLOCK)- || (test\_bit(IS\_ATR\_PRESENT, (void \*)&dev->flags)- != 0)))) {- if (filp->f\_flags & O\_NONBLOCK)- rc = -EAGAIN;- else- rc = -ERESTARTSYS;- break;- }- /\* get IO lock \*/- if (wait\_event\_interruptible- (dev->ioq,- ((filp->f\_flags & O\_NONBLOCK)- || (test\_and\_set\_bit(LOCK\_IO, (void \*)&dev->flags)- == 0)))) {- if (filp->f\_flags & O\_NONBLOCK)- rc = -EAGAIN;- else- rc = -ERESTARTSYS;- break;- }-- if ((rc = set\_protocol(dev, &krnptsreq)) != 0) {- /\* auto power\_on again \*/- dev->mstate = M\_FETCH\_ATR;- clear\_bit(IS\_ATR\_VALID, &dev->flags);- }- /\* release lock \*/- clear\_bit(LOCK\_IO, &dev->flags);- wake\_up\_interruptible(&dev->ioq);-- }- break;-#ifdef CM4000\_DEBUG- case CM\_IOSDBGLVL:- rc = -ENOTTY;- break;-#endif- default:- DEBUGP(4, dev, "... in default (unknown IOCTL code)\n");- rc = -ENOTTY;- }-out:- mutex\_unlock(&cmm\_mutex);- return rc;-}--static int cmm\_open(struct inode \*inode, struct file \*filp)-{- struct cm4000\_dev \*dev;- struct pcmcia\_device \*link;- int minor = iminor(inode);- int ret;-- if (minor >= CM4000\_MAX\_DEV)- return -ENODEV;-- mutex\_lock(&cmm\_mutex);- link = dev\_table[minor];- if (link == NULL || !pcmcia\_dev\_present(link)) {- ret = -ENODEV;- goto out;- }-- if (link->open) {- ret = -EBUSY;- goto out;- }-- dev = link->priv;- filp->private\_data = dev;-- DEBUGP(2, dev, "-> cmm\_open(device=%d.%d process=%s,%d)\n",- imajor(inode), minor, current->comm, current->pid);-- /\* init device variables, they may be "polluted" after close- \* or, the device may never have been closed (i.e. open failed)- \*/-- ZERO\_DEV(dev);-- /\* opening will always block since the- \* monitor will be started by open, which- \* means we have to wait for ATR becoming- \* valid = block until valid (or card- \* inserted)- \*/- if (filp->f\_flags & O\_NONBLOCK) {- ret = -EAGAIN;- goto out;- }-- dev->mdelay = T\_50MSEC;-- /\* start monitoring the cardstatus \*/- start\_monitor(dev);-- link->open = 1; /\* only one open per device \*/-- DEBUGP(2, dev, "<- cmm\_open\n");- ret = stream\_open(inode, filp);-out:- mutex\_unlock(&cmm\_mutex);- return ret;-}--static int cmm\_close(struct inode \*inode, struct file \*filp)-{- struct cm4000\_dev \*dev;- struct pcmcia\_device \*link;- int minor = iminor(inode);-- if (minor >= CM4000\_MAX\_DEV)- return -ENODEV;-- link = dev\_table[minor];- if (link == NULL)- return -ENODEV;-- dev = link->priv;-- DEBUGP(2, dev, "-> cmm\_close(maj/min=%d.%d)\n",- imajor(inode), minor);-- stop\_monitor(dev);-- ZERO\_DEV(dev);-- link->open = 0; /\* only one open per device \*/- wake\_up(&dev->devq); /\* socket removed? \*/-- DEBUGP(2, dev, "cmm\_close\n");- return 0;-}--static void cmm\_cm4000\_release(struct pcmcia\_device \* link)-{- struct cm4000\_dev \*dev = link->priv;-- /\* dont terminate the monitor, rather rely on- \* close doing that for us.- \*/- DEBUGP(3, dev, "-> cmm\_cm4000\_release\n");- while (link->open) {- printk(KERN\_INFO MODULE\_NAME ": delaying release until "- "process has terminated\n");- /\* note: don't interrupt us:- \* close the applications which own- \* the devices \_first\_ !- \*/- wait\_event(dev->devq, (link->open == 0));- }- /\* dev->devq=NULL; this cannot be zeroed earlier \*/- DEBUGP(3, dev, "<- cmm\_cm4000\_release\n");- return;-}--/\*==== Interface to PCMCIA Layer =======================================\*/--static int cm4000\_config\_check(struct pcmcia\_device \*p\_dev, void \*priv\_data)-{- return pcmcia\_request\_io(p\_dev);-}--static int cm4000\_config(struct pcmcia\_device \* link, int devno)-{- link->config\_flags |= CONF\_AUTO\_SET\_IO;-- /\* read the config-tuples \*/- if (pcmcia\_loop\_config(link, cm4000\_config\_check, NULL))- goto cs\_release;-- if (pcmcia\_enable\_device(link))- goto cs\_release;-- return 0;--cs\_release:- cm4000\_release(link);- return -ENODEV;-}--static int cm4000\_suspend(struct pcmcia\_device \*link)-{- struct cm4000\_dev \*dev;-- dev = link->priv;- stop\_monitor(dev);-- return 0;-}--static int cm4000\_resume(struct pcmcia\_device \*link)-{- struct cm4000\_dev \*dev;-- dev = link->priv;- if (link->open)- start\_monitor(dev);-- return 0;-}--static void cm4000\_release(struct pcmcia\_device \*link)-{- cmm\_cm4000\_release(link); /\* delay release until device closed \*/- pcmcia\_disable\_device(link);-}--static int cm4000\_probe(struct pcmcia\_device \*link)-{- struct cm4000\_dev \*dev;- int i, ret;-- for (i = 0; i < CM4000\_MAX\_DEV; i++)- if (dev\_table[i] == NULL)- break;-- if (i == CM4000\_MAX\_DEV) {- printk(KERN\_NOTICE MODULE\_NAME ": all devices in use\n");- return -ENODEV;- }-- /\* create a new cm4000\_cs device \*/- dev = kzalloc(sizeof(struct cm4000\_dev), GFP\_KERNEL);- if (dev == NULL)- return -ENOMEM;-- dev->p\_dev = link;- link->priv = dev;- dev\_table[i] = link;-- init\_waitqueue\_head(&dev->devq);- init\_waitqueue\_head(&dev->ioq);- init\_waitqueue\_head(&dev->atrq);- init\_waitqueue\_head(&dev->readq);-- ret = cm4000\_config(link, i);- if (ret) {- dev\_table[i] = NULL;- kfree(dev);- return ret;- }-- device\_create(cmm\_class, NULL, MKDEV(major, i), NULL, "cmm%d", i);-- return 0;-}--static void cm4000\_detach(struct pcmcia\_device \*link)-{- struct cm4000\_dev \*dev = link->priv;- int devno;-- /\* find device \*/- for (devno = 0; devno < CM4000\_MAX\_DEV; devno++)- if (dev\_table[devno] == link)- break;- if (devno == CM4000\_MAX\_DEV)- return;-- stop\_monitor(dev);-- cm4000\_release(link);-- dev\_table[devno] = NULL;- kfree(dev);-- device\_destroy(cmm\_class, MKDEV(major, devno));-- return;-}--static const struct file\_operations cm4000\_fops = {- .owner = THIS\_MODULE,- .read = cmm\_read,- .write = cmm\_write,- .unlocked\_ioctl = cmm\_ioctl,- .open = cmm\_open,- .release= cmm\_close,- .llseek = no\_llseek,-};--static const struct pcmcia\_device\_id cm4000\_ids[] = {- PCMCIA\_DEVICE\_MANF\_CARD(0x0223, 0x0002),- PCMCIA\_DEVICE\_PROD\_ID12("CardMan", "4000", 0x2FB368CA, 0xA2BD8C39),- PCMCIA\_DEVICE\_NULL,-};-MODULE\_DEVICE\_TABLE(pcmcia, cm4000\_ids);--static struct pcmcia\_driver cm4000\_driver = {- .owner = THIS\_MODULE,- .name = "cm4000\_cs",- .probe = cm4000\_probe,- .remove = cm4000\_detach,- .suspend = cm4000\_suspend,- .resume = cm4000\_resume,- .id\_table = cm4000\_ids,-};--static int \_\_init cmm\_init(void)-{- int rc;-- cmm\_class = class\_create(THIS\_MODULE, "cardman\_4000");- if (IS\_ERR(cmm\_class))- return PTR\_ERR(cmm\_class);-- major = register\_chrdev(0, DEVICE\_NAME, &cm4000\_fops);- if (major < 0) {- printk(KERN\_WARNING MODULE\_NAME- ": could not get major number\n");- class\_destroy(cmm\_class);- return major;- }-- rc = pcmcia\_register\_driver(&cm4000\_driver);- if (rc < 0) {- unregister\_chrdev(major, DEVICE\_NAME);- class\_destroy(cmm\_class);- return rc;- }-- return 0;-}--static void \_\_exit cmm\_exit(void)-{- pcmcia\_unregister\_driver(&cm4000\_driver);- unregister\_chrdev(major, DEVICE\_NAME);- class\_destroy(cmm\_class);-};--module\_init(cmm\_init);-module\_exit(cmm\_exit);-MODULE\_LICENSE("Dual BSD/GPL");diff --git a/drivers/char/pcmcia/cm4040\_cs.c b/drivers/char/pcmcia/cm4040\_cs.cdeleted file mode 100644index 827711911da410..00000000000000--- a/[drivers/char/pcmcia/cm4040\_cs.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/pcmcia/cm4040_cs.c?id=3996954fa071aa20945c8ac7694684fa3c1fed68)+++ /dev/null@@ -1,684 +0,0 @@-/\*- \* A driver for the Omnikey PCMCIA smartcard reader CardMan 4040- \*- \* (c) 2000-2004 Omnikey AG (http://www.omnikey.com/)- \*- \* (C) 2005-2006 Harald Welte <laforge@gnumonks.org>- \* - add support for poll()- \* - driver cleanup- \* - add waitqueues- \* - adhere to linux kernel coding style and policies- \* - support 2.6.13 "new style" pcmcia interface- \* - add class interface for udev device creation- \*- \* The device basically is a USB CCID compliant device that has been- \* attached to an I/O-Mapped FIFO.- \*- \* All rights reserved, Dual BSD/GPL Licensed.- \*/--#include <linux/kernel.h>-#include <linux/module.h>-#include <linux/slab.h>-#include <linux/init.h>-#include <linux/fs.h>-#include <linux/delay.h>-#include <linux/poll.h>-#include <linux/mutex.h>-#include <linux/wait.h>-#include <linux/uaccess.h>-#include <asm/io.h>--#include <pcmcia/cistpl.h>-#include <pcmcia/cisreg.h>-#include <pcmcia/ciscode.h>-#include <pcmcia/ds.h>--#include "cm4040\_cs.h"---#define reader\_to\_dev(x) (&x->p\_dev->dev)--/\* n (debug level) is ignored \*/-/\* additional debug output may be enabled by re-compiling with- \* CM4040\_DEBUG set \*/-/\* #define CM4040\_DEBUG \*/-#define DEBUGP(n, rdr, x, args...) do { \- dev\_dbg(reader\_to\_dev(rdr), "%s:" x, \- \_\_func\_\_ , ## args); \- } while (0)--static DEFINE\_MUTEX(cm4040\_mutex);--#define CCID\_DRIVER\_BULK\_DEFAULT\_TIMEOUT (150\*HZ)-#define CCID\_DRIVER\_ASYNC\_POWERUP\_TIMEOUT (35\*HZ)-#define CCID\_DRIVER\_MINIMUM\_TIMEOUT (3\*HZ)-#define READ\_WRITE\_BUFFER\_SIZE 512-#define POLL\_LOOP\_COUNT 1000--/\* how often to poll for fifo status change \*/-#define POLL\_PERIOD msecs\_to\_jiffies(10)--static void reader\_release(struct pcmcia\_device \*link);--static int major;-static struct class \*cmx\_class;--#define BS\_READABLE 0x01-#define BS\_WRITABLE 0x02--struct reader\_dev {- struct pcmcia\_device \*p\_dev;- wait\_queue\_head\_t devq;- wait\_queue\_head\_t poll\_wait;- wait\_queue\_head\_t read\_wait;- wait\_queue\_head\_t write\_wait;- unsigned long buffer\_status;- unsigned long timeout;- unsigned char s\_buf[READ\_WRITE\_BUFFER\_SIZE];- unsigned char r\_buf[READ\_WRITE\_BUFFER\_SIZE];- struct timer\_list poll\_timer;-};--static struct pcmcia\_device \*dev\_table[CM\_MAX\_DEV];--#ifndef CM4040\_DEBUG-#define xoutb outb-#define xinb inb-#else-static inline void xoutb(unsigned char val, unsigned short port)-{- pr\_debug("outb(val=%.2x,port=%.4x)\n", val, port);- outb(val, port);-}--static inline unsigned char xinb(unsigned short port)-{- unsigned char val;-- val = inb(port);- pr\_debug("%.2x=inb(%.4x)\n", val, port);- return val;-}-#endif--/\* poll the device fifo status register. not to be confused with- \* the poll syscall. \*/-static void cm4040\_do\_poll(struct timer\_list \*t)-{- struct reader\_dev \*dev = from\_timer(dev, t, poll\_timer);- unsigned int obs = xinb(dev->p\_dev->resource[0]->start- + REG\_OFFSET\_BUFFER\_STATUS);-- if ((obs & BSR\_BULK\_IN\_FULL)) {- set\_bit(BS\_READABLE, &dev->buffer\_status);- DEBUGP(4, dev, "waking up read\_wait\n");- wake\_up\_interruptible(&dev->read\_wait);- } else- clear\_bit(BS\_READABLE, &dev->buffer\_status);-- if (!(obs & BSR\_BULK\_OUT\_FULL)) {- set\_bit(BS\_WRITABLE, &dev->buffer\_status);- DEBUGP(4, dev, "waking up write\_wait\n");- wake\_up\_interruptible(&dev->write\_wait);- } else- clear\_bit(BS\_WRITABLE, &dev->buffer\_status);-- if (dev->buffer\_status)- wake\_up\_interruptible(&dev->poll\_wait);-- mod\_timer(&dev->poll\_timer, jiffies + POLL\_PERIOD);-}--static void cm4040\_stop\_poll(struct reader\_dev \*dev)-{- del\_timer\_sync(&dev->poll\_timer);-}--static int wait\_for\_bulk\_out\_ready(struct reader\_dev \*dev)-{- int i, rc;- int iobase = dev->p\_dev->resource[0]->start;-- for (i = 0; i < POLL\_LOOP\_COUNT; i++) {- if ((xinb(iobase + REG\_OFFSET\_BUFFER\_STATUS)- & BSR\_BULK\_OUT\_FULL) == 0) {- DEBUGP(4, dev, "BulkOut empty (i=%d)\n", i);- return 1;- }- }-- DEBUGP(4, dev, "wait\_event\_interruptible\_timeout(timeout=%ld\n",- dev->timeout);- rc = wait\_event\_interruptible\_timeout(dev->write\_wait,- test\_and\_clear\_bit(BS\_WRITABLE,- &dev->buffer\_status),- dev->timeout);-- if (rc > 0)- DEBUGP(4, dev, "woke up: BulkOut empty\n");- else if (rc == 0)- DEBUGP(4, dev, "woke up: BulkOut full, returning 0 :(\n");- else if (rc < 0)- DEBUGP(4, dev, "woke up: signal arrived\n");-- return rc;-}--/\* Write to Sync Control Register \*/-static int write\_sync\_reg(unsigned char val, struct reader\_dev \*dev)-{- int iobase = dev->p\_dev->resource[0]->start;- int rc;-- rc = wait\_for\_bulk\_out\_ready(dev);- if (rc <= 0)- return rc;-- xoutb(val, iobase + REG\_OFFSET\_SYNC\_CONTROL);- rc = wait\_for\_bulk\_out\_ready(dev);- if (rc <= 0)- return rc;-- return 1;-}--static int wait\_for\_bulk\_in\_ready(struct reader\_dev \*dev)-{- int i, rc;- int iobase = dev->p\_dev->resource[0]->start;-- for (i = 0; i < POLL\_LOOP\_COUNT; i++) {- if ((xinb(iobase + REG\_OFFSET\_BUFFER\_STATUS)- & BSR\_BULK\_IN\_FULL) == BSR\_BULK\_IN\_FULL) {- DEBUGP(3, dev, "BulkIn full (i=%d)\n", i);- return 1;- }- }-- DEBUGP(4, dev, "wait\_event\_interruptible\_timeout(timeout=%ld\n",- dev->timeout);- rc = wait\_event\_interruptible\_timeout(dev->read\_wait,- test\_and\_clear\_bit(BS\_READABLE,- &dev->buffer\_status),- dev->timeout);- if (rc > 0)- DEBUGP(4, dev, "woke up: BulkIn full\n");- else if (rc == 0)- DEBUGP(4, dev, "woke up: BulkIn not full, returning 0 :(\n");- else if (rc < 0)- DEBUGP(4, dev, "woke up: signal arrived\n");-- return rc;-}--static ssize\_t cm4040\_read(struct file \*filp, char \_\_user \*buf,- size\_t count, loff\_t \*ppos)-{- struct reader\_dev \*dev = filp->private\_data;- int iobase = dev->p\_dev->resource[0]->start;- size\_t bytes\_to\_read;- unsigned long i;- size\_t min\_bytes\_to\_read;- int rc;-- DEBUGP(2, dev, "-> cm4040\_read(%s,%d)\n", current->comm, current->pid);-- if (count == 0)- return 0;-- if (count < 10)- return -EFAULT;-- if (filp->f\_flags & O\_NONBLOCK) {- DEBUGP(4, dev, "filep->f\_flags O\_NONBLOCK set\n");- DEBUGP(2, dev, "<- cm4040\_read (failure)\n");- return -EAGAIN;- }-- if (!pcmcia\_dev\_present(dev->p\_dev))- return -ENODEV;-- for (i = 0; i < 5; i++) {- rc = wait\_for\_bulk\_in\_ready(dev);- if (rc <= 0) {- DEBUGP(5, dev, "wait\_for\_bulk\_in\_ready rc=%.2x\n", rc);- DEBUGP(2, dev, "<- cm4040\_read (failed)\n");- if (rc == -ERESTARTSYS)- return rc;- return -EIO;- }- dev->r\_buf[i] = xinb(iobase + REG\_OFFSET\_BULK\_IN);-#ifdef CM4040\_DEBUG- pr\_debug("%lu:%2x ", i, dev->r\_buf[i]);- }- pr\_debug("\n");-#else- }-#endif-- bytes\_to\_read = 5 + le32\_to\_cpu(\*(\_\_le32 \*)&dev->r\_buf[1]);-- DEBUGP(6, dev, "BytesToRead=%zu\n", bytes\_to\_read);-- min\_bytes\_to\_read = min(count, bytes\_to\_read + 5);- min\_bytes\_to\_read = min\_t(size\_t, min\_bytes\_to\_read, READ\_WRITE\_BUFFER\_SIZE);-- DEBUGP(6, dev, "Min=%zu\n", min\_bytes\_to\_read);-- for (i = 0; i < (min\_bytes\_to\_read-5); i++) {- rc = wait\_for\_bulk\_in\_ready(dev);- if (rc <= 0) {- DEBUGP(5, dev, "wait\_for\_bulk\_in\_ready rc=%.2x\n", rc);- DEBUGP(2, dev, "<- cm4040\_read (failed)\n");- if (rc == -ERESTARTSYS)- return rc;- return -EIO;- }- dev->r\_buf[i+5] = xinb(iobase + REG\_OFFSET\_BULK\_IN);-#ifdef CM4040\_DEBUG- pr\_debug("%lu:%2x ", i, dev->r\_buf[i]);- }- pr\_debug("\n");-#else- }-#endif-- \*ppos = min\_bytes\_to\_read;- if (copy\_to\_user(buf, dev->r\_buf, min\_bytes\_to\_read))- return -EFAULT;-- rc = wait\_for\_bulk\_in\_ready(dev);- if (rc <= 0) {- DEBUGP(5, dev, "wait\_for\_bulk\_in\_ready rc=%.2x\n", rc);- DEBUGP(2, dev, "<- cm4040\_read (failed)\n");- if (rc == -ERESTARTSYS)- return rc;- return -EIO;- }-- rc = write\_sync\_reg(SCR\_READER\_TO\_HOST\_DONE, dev);- if (rc <= 0) {- DEBUGP(5, dev, "write\_sync\_reg c=%.2x\n", rc);- DEBUGP(2, dev, "<- cm4040\_read (failed)\n");- if (rc == -ERESTARTSYS)- return rc;- else- return -EIO;- }-- xinb(iobase + REG\_OFFSET\_BULK\_IN);-- DEBUGP(2, dev, "<- cm4040\_read (successfully)\n");- return min\_bytes\_to\_read;-}--static ssize\_t cm4040\_write(struct file \*filp, const char \_\_user \*buf,- size\_t count, loff\_t \*ppos)-{- struct reader\_dev \*dev = filp->private\_data;- int iobase = dev->p\_dev->resource[0]->start;- ssize\_t rc;- int i;- unsigned int bytes\_to\_write;-- DEBUGP(2, dev, "-> cm4040\_write(%s,%d)\n", current->comm, current->pid);-- if (count == 0) {- DEBUGP(2, dev, "<- cm4040\_write empty read (successfully)\n");- return 0;- }-- if ((count < 5) || (count > READ\_WRITE\_BUFFER\_SIZE)) {- DEBUGP(2, dev, "<- cm4040\_write buffersize=%zd < 5\n", count);- return -EIO;- }-- if (filp->f\_flags & O\_NONBLOCK) {- DEBUGP(4, dev, "filep->f\_flags O\_NONBLOCK set\n");- DEBUGP(4, dev, "<- cm4040\_write (failure)\n");- return -EAGAIN;- }-- if (!pcmcia\_dev\_present(dev->p\_dev))- return -ENODEV;-- bytes\_to\_write = count;- if (copy\_from\_user(dev->s\_buf, buf, bytes\_to\_write))- return -EFAULT;-- switch (dev->s\_buf[0]) {- case CMD\_PC\_TO\_RDR\_XFRBLOCK:- case CMD\_PC\_TO\_RDR\_SECURE:- case CMD\_PC\_TO\_RDR\_TEST\_SECURE:- case CMD\_PC\_TO\_RDR\_OK\_SECURE:- dev->timeout = CCID\_DRIVER\_BULK\_DEFAULT\_TIMEOUT;- break;-- case CMD\_PC\_TO\_RDR\_ICCPOWERON:- dev->timeout = CCID\_DRIVER\_ASYNC\_POWERUP\_TIMEOUT;- break;-- case CMD\_PC\_TO\_RDR\_GETSLOTSTATUS:- case CMD\_PC\_TO\_RDR\_ICCPOWEROFF:- case CMD\_PC\_TO\_RDR\_GETPARAMETERS:- case CMD\_PC\_TO\_RDR\_RESETPARAMETERS:- case CMD\_PC\_TO\_RDR\_SETPARAMETERS:- case CMD\_PC\_TO\_RDR\_ESCAPE:- case CMD\_PC\_TO\_RDR\_ICCCLOCK:- default:- dev->timeout = CCID\_DRIVER\_MINIMUM\_TIMEOUT;- break;- }-- rc = write\_sync\_reg(SCR\_HOST\_TO\_READER\_START, dev);- if (rc <= 0) {- DEBUGP(5, dev, "write\_sync\_reg c=%.2zx\n", rc);- DEBUGP(2, dev, "<- cm4040\_write (failed)\n");- if (rc == -ERESTARTSYS)- return rc;- else- return -EIO;- }-- DEBUGP(4, dev, "start \n");-- for (i = 0; i < bytes\_to\_write; i++) {- rc = wait\_for\_bulk\_out\_ready(dev);- if (rc <= 0) {- DEBUGP(5, dev, "wait\_for\_bulk\_out\_ready rc=%.2zx\n",- rc);- DEBUGP(2, dev, "<- cm4040\_write (failed)\n");- if (rc == -ERESTARTSYS)- return rc;- else- return -EIO;- }-- xoutb(dev->s\_buf[i],iobase + REG\_OFFSET\_BULK\_OUT);- }- DEBUGP(4, dev, "end\n");-- rc = write\_sync\_reg(SCR\_HOST\_TO\_READER\_DONE, dev);-- if (rc <= 0) {- DEBUGP(5, dev, "write\_sync\_reg c=%.2zx\n", rc);- DEBUGP(2, dev, "<- cm4040\_write (failed)\n");- if (rc == -ERESTARTSYS)- return rc;- else- return -EIO;- }-- DEBUGP(2, dev, "<- cm4040\_write (successfully)\n");- return count;-}--static \_\_poll\_t cm4040\_poll(struct file \*filp, poll\_table \*wait)-{- struct reader\_dev \*dev = filp->private\_data;- \_\_poll\_t mask = 0;-- poll\_wait(filp, &dev->poll\_wait, wait);-- if (test\_and\_clear\_bit(BS\_READABLE, &dev->buffer\_status))- mask |= EPOLLIN | EPOLLRDNORM;- if (test\_and\_clear\_bit(BS\_WRITABLE, &dev->buffer\_status))- mask |= EPOLLOUT | EPOLLWRNORM;-- DEBUGP(2, dev, "<- cm4040\_poll(%u)\n", mask);-- return mask;-}--static int cm4040\_open(struct inode \*inode, struct file \*filp)-{- struct reader\_dev \*dev;- struct pcmcia\_device \*link;- int minor = iminor(inode);- int ret;-- if (minor >= CM\_MAX\_DEV)- return -ENODEV;-- mutex\_lock(&cm4040\_mutex);- link = dev\_table[minor];- if (link == NULL || !pcmcia\_dev\_present(link)) {- ret = -ENODEV;- goto out;- }-- if (link->open) {- ret = -EBUSY;- goto out;- }-- dev = link->priv;- filp->private\_data = dev;-- if (filp->f\_flags & O\_NONBLOCK) {- DEBUGP(4, dev, "filep->f\_flags O\_NONBLOCK set\n");- ret = -EAGAIN;- goto out;- }-- link->open = 1;-- mod\_timer(&dev->poll\_timer, jiffies + POLL\_PERIOD);-- DEBUGP(2, dev, "<- cm4040\_open (successfully)\n");- ret = nonseekable\_open(inode, filp);-out:- mutex\_unlock(&cm4040\_mutex);- return ret;-}--static int cm4040\_close(struct inode \*inode, struct file \*filp)-{- struct reader\_dev \*dev = filp->private\_data;- struct pcmcia\_device \*link;- int minor = iminor(inode);-- DEBUGP(2, dev, "-> cm4040\_close(maj/min=%d.%d)\n", imajor(inode),- iminor(inode));-- if (minor >= CM\_MAX\_DEV)- return -ENODEV;-- link = dev\_table[minor];- if (link == NULL)- return -ENODEV;-- cm4040\_stop\_poll(dev);-- link->open = 0;- wake\_up(&dev->devq);-- DEBUGP(2, dev, "<- cm4040\_close\n");- return 0;-}--static void cm4040\_reader\_release(struct pcmcia\_device \*link)-{- struct reader\_dev \*dev = link->priv;-- DEBUGP(3, dev, "-> cm4040\_reader\_release\n");- while (link->open) {- DEBUGP(3, dev, MODULE\_NAME ": delaying release "- "until process has terminated\n");- wait\_event(dev->devq, (link->open == 0));- }- DEBUGP(3, dev, "<- cm4040\_reader\_release\n");- return;-}--static int cm4040\_config\_check(struct pcmcia\_device \*p\_dev, void \*priv\_data)-{- return pcmcia\_request\_io(p\_dev);-}---static int reader\_config(struct pcmcia\_device \*link, int devno)-{- struct reader\_dev \*dev;- int fail\_rc;-- link->config\_flags |= CONF\_AUTO\_SET\_IO;-- if (pcmcia\_loop\_config(link, cm4040\_config\_check, NULL))- goto cs\_release;-- fail\_rc = pcmcia\_enable\_device(link);- if (fail\_rc != 0) {- dev\_info(&link->dev, "pcmcia\_enable\_device failed 0x%x\n",- fail\_rc);- goto cs\_release;- }-- dev = link->priv;-- DEBUGP(2, dev, "device " DEVICE\_NAME "%d at %pR\n", devno,- link->resource[0]);- DEBUGP(2, dev, "<- reader\_config (succ)\n");-- return 0;--cs\_release:- reader\_release(link);- return -ENODEV;-}--static void reader\_release(struct pcmcia\_device \*link)-{- cm4040\_reader\_release(link);- pcmcia\_disable\_device(link);-}--static int reader\_probe(struct pcmcia\_device \*link)-{- struct reader\_dev \*dev;- int i, ret;-- for (i = 0; i < CM\_MAX\_DEV; i++) {- if (dev\_table[i] == NULL)- break;- }-- if (i == CM\_MAX\_DEV)- return -ENODEV;-- dev = kzalloc(sizeof(struct reader\_dev), GFP\_KERNEL);- if (dev == NULL)- return -ENOMEM;-- dev->timeout = CCID\_DRIVER\_MINIMUM\_TIMEOUT;- dev->buffer\_status = 0;-- link->priv = dev;- dev->p\_dev = link;-- dev\_table[i] = link;-- init\_waitqueue\_head(&dev->devq);- init\_waitqueue\_head(&dev->poll\_wait);- init\_waitqueue\_head(&dev->read\_wait);- init\_waitqueue\_head(&dev->write\_wait);- timer\_setup(&dev->poll\_timer, cm4040\_do\_poll, 0);-- ret = reader\_config(link, i);- if (ret) {- dev\_table[i] = NULL;- kfree(dev);- return ret;- }-- device\_create(cmx\_class, NULL, MKDEV(major, i), NULL, "cmx%d", i);-- return 0;-}--static void reader\_detach(struct pcmcia\_device \*link)-{- struct reader\_dev \*dev = link->priv;- int devno;-- /\* find device \*/- for (devno = 0; devno < CM\_MAX\_DEV; devno++) {- if (dev\_table[devno] == link)- break;- }- if (devno == CM\_MAX\_DEV)- return;-- reader\_release(link);-- dev\_table[devno] = NULL;- kfree(dev);-- device\_destroy(cmx\_class, MKDEV(major, devno));-- return;-}--static const struct file\_operations reader\_fops = {- .owner = THIS\_MODULE,- .read = cm4040\_read,- .write = cm4040\_write,- .open = cm4040\_open,- .release = cm4040\_close,- .poll = cm4040\_poll,- .llseek = no\_llseek,-};--static const struct pcmcia\_device\_id cm4040\_ids[] = {- PCMCIA\_DEVICE\_MANF\_CARD(0x0223, 0x0200),- PCMCIA\_DEVICE\_PROD\_ID12("OMNIKEY", "CardMan 4040",- 0xE32CDD8C, 0x8F23318B),- PCMCIA\_DEVICE\_NULL,-};-MODULE\_DEVICE\_TABLE(pcmcia, cm4040\_ids);--static struct pcmcia\_driver reader\_driver = {- .owner = THIS\_MODULE,- .name = "cm4040\_cs",- .probe = reader\_probe,- .remove = reader\_detach,- .id\_table = cm4040\_ids,-};--static int \_\_init cm4040\_init(void)-{- int rc;-- cmx\_class = class\_create(THIS\_MODULE, "cardman\_4040");- if (IS\_ERR(cmx\_class))- return PTR\_ERR(cmx\_class);-- major = register\_chrdev(0, DEVICE\_NAME, &reader\_fops);- if (major < 0) {- printk(KERN\_WARNING MODULE\_NAME- ": could not get major number\n");- class\_destroy(cmx\_class);- return major;- }-- rc = pcmcia\_register\_driver(&reader\_driver);- if (rc < 0) {- unregister\_chrdev(major, DEVICE\_NAME);- class\_destroy(cmx\_class);- return rc;- }-- return 0;-}--static void \_\_exit cm4040\_exit(void)-{- pcmcia\_unregister\_driver(&reader\_driver);- unregister\_chrdev(major, DEVICE\_NAME);- class\_destroy(cmx\_class);-}--module\_init(cm4040\_init);-module\_exit(cm4040\_exit);-MODULE\_LICENSE("Dual BSD/GPL");diff --git a/drivers/char/pcmcia/cm4040\_cs.h b/drivers/char/pcmcia/cm4040\_cs.hdeleted file mode 100644index e2ffff995d512a..00000000000000--- a/[drivers/char/pcmcia/cm4040\_cs.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/pcmcia/cm4040_cs.h?id=3996954fa071aa20945c8ac7694684fa3c1fed68)+++ /dev/null@@ -1,48 +0,0 @@-/\* SPDX-License-Identifier: GPL-2.0 \*/-#ifndef \_CM4040\_H\_-#define \_CM4040\_H\_--#define CM\_MAX\_DEV 4--#define DEVICE\_NAME "cmx"-#define MODULE\_NAME "cm4040\_cs"--#define REG\_OFFSET\_BULK\_OUT 0-#define REG\_OFFSET\_BULK\_IN 0-#define REG\_OFFSET\_BUFFER\_STATUS 1-#define REG\_OFFSET\_SYNC\_CONTROL 2--#define BSR\_BULK\_IN\_FULL 0x02-#define BSR\_BULK\_OUT\_FULL 0x01--#define SCR\_HOST\_TO\_READER\_START 0x80-#define SCR\_ABORT 0x40-#define SCR\_EN\_NOTIFY 0x20-#define SCR\_ACK\_NOTIFY 0x10-#define SCR\_READER\_TO\_HOST\_DONE 0x08-#define SCR\_HOST\_TO\_READER\_DONE 0x04-#define SCR\_PULSE\_INTERRUPT 0x02-#define SCR\_POWER\_DOWN 0x01---#define CMD\_PC\_TO\_RDR\_ICCPOWERON 0x62-#define CMD\_PC\_TO\_RDR\_GETSLOTSTATUS 0x65-#define CMD\_PC\_TO\_RDR\_ICCPOWEROFF 0x63-#define CMD\_PC\_TO\_RDR\_SECURE 0x69-#define CMD\_PC\_TO\_RDR\_GETPARAMETERS 0x6C-#define CMD\_PC\_TO\_RDR\_RESETPARAMETERS 0x6D-#define CMD\_PC\_TO\_RDR\_SETPARAMETERS 0x61-#define CMD\_PC\_TO\_RDR\_XFRBLOCK 0x6F-#define CMD\_PC\_TO\_RDR\_ESCAPE 0x6B-#define CMD\_PC\_TO\_RDR\_ICCCLOCK 0x6E-#define CMD\_PC\_TO\_RDR\_TEST\_SECURE 0x74-#define CMD\_PC\_TO\_RDR\_OK\_SECURE 0x89---#define CMD\_RDR\_TO\_PC\_SLOTSTATUS 0x81-#define CMD\_RDR\_TO\_PC\_DATABLOCK 0x80-#define CMD\_RDR\_TO\_PC\_PARAMETERS 0x82-#define CMD\_RDR\_TO\_PC\_ESCAPE 0x83-#define CMD\_RDR\_TO\_PC\_OK\_SECURE 0x89--#endif /\* \_CM4040\_H\_ \*/diff --git a/drivers/char/pcmcia/scr24x\_cs.c b/drivers/char/pcmcia/scr24x\_cs.cdeleted file mode 100644index 1bdce08fae3db5..00000000000000--- a/[drivers/char/pcmcia/scr24x\_cs.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/pcmcia/scr24x_cs.c?id=3996954fa071aa20945c8ac7694684fa3c1fed68)+++ /dev/null@@ -1,359 +0,0 @@-// SPDX-License-Identifier: GPL-2.0-or-later-/\*- \* SCR24x PCMCIA Smart Card Reader Driver- \*- \* Copyright (C) 2005-2006 TL Sudheendran- \* Copyright (C) 2016 Lubomir Rintel- \*- \* Derived from "scr24x\_v4.2.6\_Release.tar.gz" driver by TL Sudheendran.- \*/--#include <linux/device.h>-#include <linux/module.h>-#include <linux/delay.h>-#include <linux/cdev.h>-#include <linux/slab.h>-#include <linux/fs.h>-#include <linux/io.h>-#include <linux/uaccess.h>--#include <pcmcia/cistpl.h>-#include <pcmcia/ds.h>--#define CCID\_HEADER\_SIZE 10-#define CCID\_LENGTH\_OFFSET 1-#define CCID\_MAX\_LEN 271--#define SCR24X\_DATA(n) (1 + n)-#define SCR24X\_CMD\_STATUS 7-#define CMD\_START 0x40-#define CMD\_WRITE\_BYTE 0x41-#define CMD\_READ\_BYTE 0x42-#define STATUS\_BUSY 0x80--struct scr24x\_dev {- struct device \*dev;- struct cdev c\_dev;- unsigned char buf[CCID\_MAX\_LEN];- int devno;- struct mutex lock;- struct kref refcnt;- u8 \_\_iomem \*regs;-};--#define SCR24X\_DEVS 8-static DECLARE\_BITMAP(scr24x\_minors, SCR24X\_DEVS);--static struct class \*scr24x\_class;-static dev\_t scr24x\_devt;--static void scr24x\_delete(struct kref \*kref)-{- struct scr24x\_dev \*dev = container\_of(kref, struct scr24x\_dev,- refcnt);-- kfree(dev);-}--static int scr24x\_wait\_ready(struct scr24x\_dev \*dev)-{- u\_char status;- int timeout = 100;-- do {- status = ioread8(dev->regs + SCR24X\_CMD\_STATUS);- if (!(status & STATUS\_BUSY))- return 0;-- msleep(20);- } while (--timeout);-- return -EIO;-}--static int scr24x\_open(struct inode \*inode, struct file \*filp)-{- struct scr24x\_dev \*dev = container\_of(inode->i\_cdev,- struct scr24x\_dev, c\_dev);-- kref\_get(&dev->refcnt);- filp->private\_data = dev;-- return stream\_open(inode, filp);-}--static int scr24x\_release(struct inode \*inode, struct file \*filp)-{- struct scr24x\_dev \*dev = filp->private\_data;-- /\* We must not take the dev->lock here as scr24x\_delete()- \* might be called to remove the dev structure altogether.- \* We don't need the lock anyway, since after the reference- \* acquired in probe() is released in remove() the chrdev- \* is already unregistered and noone can possibly acquire- \* a reference via open() anymore. \*/- kref\_put(&dev->refcnt, scr24x\_delete);- return 0;-}--static int read\_chunk(struct scr24x\_dev \*dev, size\_t offset, size\_t limit)-{- size\_t i, y;- int ret;-- for (i = offset; i < limit; i += 5) {- iowrite8(CMD\_READ\_BYTE, dev->regs + SCR24X\_CMD\_STATUS);- ret = scr24x\_wait\_ready(dev);- if (ret < 0)- return ret;-- for (y = 0; y < 5 && i + y < limit; y++)- dev->buf[i + y] = ioread8(dev->regs + SCR24X\_DATA(y));- }-- return 0;-}--static ssize\_t scr24x\_read(struct file \*filp, char \_\_user \*buf, size\_t count,- loff\_t \*ppos)-{- struct scr24x\_dev \*dev = filp->private\_data;- int ret;- int len;-- if (count < CCID\_HEADER\_SIZE)- return -EINVAL;-- if (mutex\_lock\_interruptible(&dev->lock))- return -ERESTARTSYS;-- if (!dev->dev) {- ret = -ENODEV;- goto out;- }-- ret = scr24x\_wait\_ready(dev);- if (ret < 0)- goto out;- len = CCID\_HEADER\_SIZE;- ret = read\_chunk(dev, 0, len);- if (ret < 0)- goto out;-- len += le32\_to\_cpu(\*(\_\_le32 \*)(&dev->buf[CCID\_LENGTH\_OFFSET]));- if (len > sizeof(dev->buf)) {- ret = -EIO;- goto out;- }- ret = read\_chunk(dev, CCID\_HEADER\_SIZE, len);- if (ret < 0)- goto out;-- if (len < count)- count = len;-- if (copy\_to\_user(buf, dev->buf, count)) {- ret = -EFAULT;- goto out;- }-- ret = count;-out:- mutex\_unlock(&dev->lock);- return ret;-}--static ssize\_t scr24x\_write(struct file \*filp, const char \_\_user \*buf,- size\_t count, loff\_t \*ppos)-{- struct scr24x\_dev \*dev = filp->private\_data;- size\_t i, y;- int ret;-- if (mutex\_lock\_interruptible(&dev->lock))- return -ERESTARTSYS;-- if (!dev->dev) {- ret = -ENODEV;- goto out;- }-- if (count > sizeof(dev->buf)) {- ret = -EINVAL;- goto out;- }-- if (copy\_from\_user(dev->buf, buf, count)) {- ret = -EFAULT;- goto out;- }-- ret = scr24x\_wait\_ready(dev);- if (ret < 0)- goto out;-- iowrite8(CMD\_START, dev->regs + SCR24X\_CMD\_STATUS);- ret = scr24x\_wait\_ready(dev);- if (ret < 0)- goto out;-- for (i = 0; i < count; i += 5) {- for (y = 0; y < 5 && i + y < count; y++)- iowrite8(dev->buf[i + y], dev->regs + SCR24X\_DATA(y));-- iowrite8(CMD\_WRITE\_BYTE, dev->regs + SCR24X\_CMD\_STATUS);- ret = scr24x\_wait\_ready(dev);- if (ret < 0)- goto out;- }-- ret = count;-out:- mutex\_unlock(&dev->lock);- return ret;-}--static const struct file\_operations scr24x\_fops = {- .owner = THIS\_MODULE,- .read = scr24x\_read,- .write = scr24x\_write,- .open = scr24x\_open,- .release = scr24x\_release,- .llseek = no\_llseek,-};--static int scr24x\_config\_check(struct pcmcia\_device \*link, void \*priv\_data)-{- if (resource\_size(link->resource[PCMCIA\_IOPORT\_0]) != 0x11)- return -ENODEV;- return pcmcia\_request\_io(link);-}--static int scr24x\_probe(struct pcmcia\_device \*link)-{- struct scr24x\_dev \*dev;- int ret;-- dev = kzalloc(sizeof(\*dev), GFP\_KERNEL);- if (!dev)- return -ENOMEM;-- dev->devno = find\_first\_zero\_bit(scr24x\_minors, SCR24X\_DEVS);- if (dev->devno >= SCR24X\_DEVS) {- ret = -EBUSY;- goto err;- }-- mutex\_init(&dev->lock);- kref\_init(&dev->refcnt);-- link->priv = dev;- link->config\_flags |= CONF\_ENABLE\_IRQ | CONF\_AUTO\_SET\_IO;-- ret = pcmcia\_loop\_config(link, scr24x\_config\_check, NULL);- if (ret < 0)- goto err;-- dev->dev = &link->dev;- dev->regs = devm\_ioport\_map(&link->dev,- link->resource[PCMCIA\_IOPORT\_0]->start,- resource\_size(link->resource[PCMCIA\_IOPORT\_0]));- if (!dev->regs) {- ret = -EIO;- goto err;- }-- cdev\_init(&dev->c\_dev, &scr24x\_fops);- dev->c\_dev.owner = THIS\_MODULE;- ret = cdev\_add(&dev->c\_dev, MKDEV(MAJOR(scr24x\_devt), dev->devno), 1);- if (ret < 0)- goto err;-- ret = pcmcia\_enable\_device(link);- if (ret < 0) {- pcmcia\_disable\_device(link);- goto err;- }-- device\_create(scr24x\_class, NULL, MKDEV(MAJOR(scr24x\_devt), dev->devno),- NULL, "scr24x%d", dev->devno);-- dev\_info(&link->dev, "SCR24x Chip Card Interface\n");- return 0;--err:- if (dev->devno < SCR24X\_DEVS)- clear\_bit(dev->devno, scr24x\_minors);- kfree (dev);- return ret;-}--static void scr24x\_remove(struct pcmcia\_device \*link)-{- struct scr24x\_dev \*dev = (struct scr24x\_dev \*)link->priv;-- device\_destroy(scr24x\_class, MKDEV(MAJOR(scr24x\_devt), dev->devno));- mutex\_lock(&dev->lock);- pcmcia\_disable\_device(link);- cdev\_del(&dev->c\_dev);- clear\_bit(dev->devno, scr24x\_minors);- dev->dev = NULL;- mutex\_unlock(&dev->lock);-- kref\_put(&dev->refcnt, scr24x\_delete);-}--static const struct pcmcia\_device\_id scr24x\_ids[] = {- PCMCIA\_DEVICE\_PROD\_ID12("HP", "PC Card Smart Card Reader",- 0x53cb94f9, 0xbfdf89a5),- PCMCIA\_DEVICE\_PROD\_ID1("SCR241 PCMCIA", 0x6271efa3),- PCMCIA\_DEVICE\_PROD\_ID1("SCR243 PCMCIA", 0x2054e8de),- PCMCIA\_DEVICE\_PROD\_ID1("SCR24x PCMCIA", 0x54a33665),- PCMCIA\_DEVICE\_NULL-};-MODULE\_DEVICE\_TABLE(pcmcia, scr24x\_ids);--static struct pcmcia\_driver scr24x\_driver = {- .owner = THIS\_MODULE,- .name = "scr24x\_cs",- .probe = scr24x\_probe,- .remove = scr24x\_remove,- .id\_table = scr24x\_ids,-};--static int \_\_init scr24x\_init(void)-{- int ret;-- scr24x\_class = class\_create(THIS\_MODULE, "scr24x");- if (IS\_ERR(scr24x\_class))- return PTR\_ERR(scr24x\_class);-- ret = alloc\_chrdev\_region(&scr24x\_devt, 0, SCR24X\_DEVS, "scr24x");- if (ret < 0) {- class\_destroy(scr24x\_class);- return ret;- }-- ret = pcmcia\_register\_driver(&scr24x\_driver);- if (ret < 0) {- unregister\_chrdev\_region(scr24x\_devt, SCR24X\_DEVS);- class\_destroy(scr24x\_class);- }-- return ret;-}--static void \_\_exit scr24x\_exit(void)-{- pcmcia\_unregister\_driver(&scr24x\_driver);- unregister\_chrdev\_region(scr24x\_devt, SCR24X\_DEVS);- class\_destroy(scr24x\_class);-}--module\_init(scr24x\_init);-module\_exit(scr24x\_exit);--MODULE\_AUTHOR("Lubomir Rintel");-MODULE\_DESCRIPTION("SCR24x PCMCIA Smart Card Reader Driver");-MODULE\_LICENSE("GPL");diff --git a/drivers/char/pcmcia/synclink\_cs.c b/drivers/char/pcmcia/synclink\_cs.cdeleted file mode 100644index 6ddfeb2fe98f07..00000000000000--- a/[drivers/char/pcmcia/synclink\_cs.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/pcmcia/synclink_cs.c?id=3996954fa071aa20945c8ac7694684fa3c1fed68)+++ /dev/null@@ -1,4290 +0,0 @@-/\*- \* linux/drivers/char/pcmcia/synclink\_cs.c- \*- \* $Id: synclink\_cs.c,v 4.34 2005/09/08 13:20:54 paulkf Exp $- \*- \* Device driver for Microgate SyncLink PC Card- \* multiprotocol serial adapter.- \*- \* written by Paul Fulghum for Microgate Corporation- \* paulkf@microgate.com- \*- \* Microgate and SyncLink are trademarks of Microgate Corporation- \*- \* This code is released under the GNU General Public License (GPL)- \*- \* THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED- \* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES- \* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE- \* DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,- \* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES- \* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR- \* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)- \* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,- \* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)- \* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED- \* OF THE POSSIBILITY OF SUCH DAMAGE.- \*/--#define VERSION(ver,rel,seq) (((ver)<<16) | ((rel)<<8) | (seq))-#if defined(\_\_i386\_\_)-# define BREAKPOINT() asm(" int $3");-#else-# define BREAKPOINT() { }-#endif--#define MAX\_DEVICE\_COUNT 4--#include <linux/module.h>-#include <linux/errno.h>-#include <linux/signal.h>-#include <linux/sched.h>-#include <linux/timer.h>-#include <linux/time.h>-#include <linux/interrupt.h>-#include <linux/tty.h>-#include <linux/tty\_flip.h>-#include <linux/serial.h>-#include <linux/major.h>-#include <linux/string.h>-#include <linux/fcntl.h>-#include <linux/ptrace.h>-#include <linux/ioport.h>-#include <linux/mm.h>-#include <linux/seq\_file.h>-#include <linux/slab.h>-#include <linux/netdevice.h>-#include <linux/vmalloc.h>-#include <linux/init.h>-#include <linux/delay.h>-#include <linux/ioctl.h>-#include <linux/synclink.h>--#include <asm/io.h>-#include <asm/irq.h>-#include <asm/dma.h>-#include <linux/bitops.h>-#include <asm/types.h>-#include <linux/termios.h>-#include <linux/workqueue.h>-#include <linux/hdlc.h>--#include <pcmcia/cistpl.h>-#include <pcmcia/cisreg.h>-#include <pcmcia/ds.h>--#if defined(CONFIG\_HDLC) || (defined(CONFIG\_HDLC\_MODULE) && defined(CONFIG\_SYNCLINK\_CS\_MODULE))-#define SYNCLINK\_GENERIC\_HDLC 1-#else-#define SYNCLINK\_GENERIC\_HDLC 0-#endif--#define GET\_USER(error,value,addr) error = get\_user(value,addr)-#define COPY\_FROM\_USER(error,dest,src,size) error = copy\_from\_user(dest,src,size) ? -EFAULT : 0-#define PUT\_USER(error,value,addr) error = put\_user(value,addr)-#define COPY\_TO\_USER(error,dest,src,size) error = copy\_to\_user(dest,src,size) ? -EFAULT : 0--#include <linux/uaccess.h>--static MGSL\_PARAMS default\_params = {- MGSL\_MODE\_HDLC, /\* unsigned long mode \*/- 0, /\* unsigned char loopback; \*/- HDLC\_FLAG\_UNDERRUN\_ABORT15, /\* unsigned short flags; \*/- HDLC\_ENCODING\_NRZI\_SPACE, /\* unsigned char encoding; \*/- 0, /\* unsigned long clock\_speed; \*/- 0xff, /\* unsigned char addr\_filter; \*/- HDLC\_CRC\_16\_CCITT, /\* unsigned short crc\_type; \*/- HDLC\_PREAMBLE\_LENGTH\_8BITS, /\* unsigned char preamble\_length; \*/- HDLC\_PREAMBLE\_PATTERN\_NONE, /\* unsigned char preamble; \*/- 9600, /\* unsigned long data\_rate; \*/- 8, /\* unsigned char data\_bits; \*/- 1, /\* unsigned char stop\_bits; \*/- ASYNC\_PARITY\_NONE /\* unsigned char parity; \*/-};--typedef struct {- int count;- unsigned char status;- char data[1];-} RXBUF;--/\* The queue of BH actions to be performed \*/--#define BH\_RECEIVE 1-#define BH\_TRANSMIT 2-#define BH\_STATUS 4--#define IO\_PIN\_SHUTDOWN\_LIMIT 100--#define RELEVANT\_IFLAG(iflag) (iflag & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))--struct \_input\_signal\_events {- int ri\_up;- int ri\_down;- int dsr\_up;- int dsr\_down;- int dcd\_up;- int dcd\_down;- int cts\_up;- int cts\_down;-};---/\*- \* Device instance data structure- \*/--typedef struct \_mgslpc\_info {- struct tty\_port port;- void \*if\_ptr; /\* General purpose pointer (used by SPPP) \*/- int magic;- int line;-- struct mgsl\_icount icount;-- int timeout;- int x\_char; /\* xon/xoff character \*/- unsigned char read\_status\_mask;- unsigned char ignore\_status\_mask;-- unsigned char \*tx\_buf;- int tx\_put;- int tx\_get;- int tx\_count;-- /\* circular list of fixed length rx buffers \*/-- unsigned char \*rx\_buf; /\* memory allocated for all rx buffers \*/- int rx\_buf\_total\_size; /\* size of memory allocated for rx buffers \*/- int rx\_put; /\* index of next empty rx buffer \*/- int rx\_get; /\* index of next full rx buffer \*/- int rx\_buf\_size; /\* size in bytes of single rx buffer \*/- int rx\_buf\_count; /\* total number of rx buffers \*/- int rx\_frame\_count; /\* number of full rx buffers \*/-- wait\_queue\_head\_t status\_event\_wait\_q;- wait\_queue\_head\_t event\_wait\_q;- struct timer\_list tx\_timer; /\* HDLC transmit timeout timer \*/- struct \_mgslpc\_info \*next\_device; /\* device list link \*/-- unsigned short imra\_value;- unsigned short imrb\_value;- unsigned char pim\_value;-- spinlock\_t lock;- struct work\_struct task; /\* task structure for scheduling bh \*/-- u32 max\_frame\_size;-- u32 pending\_bh;-- bool bh\_running;- bool bh\_requested;-- int dcd\_chkcount; /\* check counts to prevent \*/- int cts\_chkcount; /\* too many IRQs if a signal \*/- int dsr\_chkcount; /\* is floating \*/- int ri\_chkcount;-- bool rx\_enabled;- bool rx\_overflow;-- bool tx\_enabled;- bool tx\_active;- bool tx\_aborting;- u32 idle\_mode;-- int if\_mode; /\* serial interface selection (RS-232, v.35 etc) \*/-- char device\_name[25]; /\* device instance name \*/-- unsigned int io\_base; /\* base I/O address of adapter \*/- unsigned int irq\_level;-- MGSL\_PARAMS params; /\* communications parameters \*/-- unsigned char serial\_signals; /\* current serial signal states \*/-- bool irq\_occurred; /\* for diagnostics use \*/- char testing\_irq;- unsigned int init\_error; /\* startup error (DIAGS) \*/-- char \*flag\_buf;- bool drop\_rts\_on\_tx\_done;-- struct \_input\_signal\_events input\_signal\_events;-- /\* PCMCIA support \*/- struct pcmcia\_device \*p\_dev;- int stop;-- /\* SPPP/Cisco HDLC device parts \*/- int netcount;- spinlock\_t netlock;--#if SYNCLINK\_GENERIC\_HDLC- struct net\_device \*netdev;-#endif--} MGSLPC\_INFO;--#define MGSLPC\_MAGIC 0x5402--/\*- \* The size of the serial xmit buffer is 1 page, or 4096 bytes- \*/-#define TXBUFSIZE 4096---#define CHA 0x00 /\* channel A offset \*/-#define CHB 0x40 /\* channel B offset \*/--/\*- \* FIXME: PPC has PVR defined in asm/reg.h. For now we just undef it.- \*/-#undef PVR--#define RXFIFO 0-#define TXFIFO 0-#define STAR 0x20-#define CMDR 0x20-#define RSTA 0x21-#define PRE 0x21-#define MODE 0x22-#define TIMR 0x23-#define XAD1 0x24-#define XAD2 0x25-#define RAH1 0x26-#define RAH2 0x27-#define DAFO 0x27-#define RAL1 0x28-#define RFC 0x28-#define RHCR 0x29-#define RAL2 0x29-#define RBCL 0x2a-#define XBCL 0x2a-#define RBCH 0x2b-#define XBCH 0x2b-#define CCR0 0x2c-#define CCR1 0x2d-#define CCR2 0x2e-#define CCR3 0x2f-#define VSTR 0x34-#define BGR 0x34-#define RLCR 0x35-#define AML 0x36-#define AMH 0x37-#define GIS 0x38-#define IVA 0x38-#define IPC 0x39-#define ISR 0x3a-#define IMR 0x3a-#define PVR 0x3c-#define PIS 0x3d-#define PIM 0x3d-#define PCR 0x3e-#define CCR4 0x3f--// IMR/ISR--#define IRQ\_BREAK\_ON BIT15 // rx break detected-#define IRQ\_DATAOVERRUN BIT14 // receive data overflow-#define IRQ\_ALLSENT BIT13 // all sent-#define IRQ\_UNDERRUN BIT12 // transmit data underrun-#define IRQ\_TIMER BIT11 // timer interrupt-#define IRQ\_CTS BIT10 // CTS status change-#define IRQ\_TXREPEAT BIT9 // tx message repeat-#define IRQ\_TXFIFO BIT8 // transmit pool ready-#define IRQ\_RXEOM BIT7 // receive message end-#define IRQ\_EXITHUNT BIT6 // receive frame start-#define IRQ\_RXTIME BIT6 // rx char timeout-#define IRQ\_DCD BIT2 // carrier detect status change-#define IRQ\_OVERRUN BIT1 // receive frame overflow-#define IRQ\_RXFIFO BIT0 // receive pool full--// STAR--#define XFW BIT6 // transmit FIFO write enable-#define CEC BIT2 // command executing-#define CTS BIT1 // CTS state--#define PVR\_DTR BIT0-#define PVR\_DSR BIT1-#define PVR\_RI BIT2-#define PVR\_AUTOCTS BIT3-#define PVR\_RS232 0x20 /\* 0010b \*/-#define PVR\_V35 0xe0 /\* 1110b \*/-#define PVR\_RS422 0x40 /\* 0100b \*/--/\* Register access functions \*/--#define write\_reg(info, reg, val) outb((val),(info)->io\_base + (reg))-#define read\_reg(info, reg) inb((info)->io\_base + (reg))--#define read\_reg16(info, reg) inw((info)->io\_base + (reg))-#define write\_reg16(info, reg, val) outw((val), (info)->io\_base + (reg))--#define set\_reg\_bits(info, reg, mask) \- write\_reg(info, (reg), \- (unsigned char) (read\_reg(info, (reg)) | (mask)))-#define clear\_reg\_bits(info, reg, mask) \- write\_reg(info, (reg), \- (unsigned char) (read\_reg(info, (reg)) & ~(mask)))-/\*- \* interrupt enable/disable routines- \*/-static void irq\_disable(MGSLPC\_INFO \*info, unsigned char channel, unsigned short mask)-{- if (channel == CHA) {- info->imra\_value |= mask;- write\_reg16(info, CHA + IMR, info->imra\_value);- } else {- info->imrb\_value |= mask;- write\_reg16(info, CHB + IMR, info->imrb\_value);- }-}-static void irq\_enable(MGSLPC\_INFO \*info, unsigned char channel, unsigned short mask)-{- if (channel == CHA) {- info->imra\_value &= ~mask;- write\_reg16(info, CHA + IMR, info->imra\_value);- } else {- info->imrb\_value &= ~mask;- write\_reg16(info, CHB + IMR, info->imrb\_value);- }-}--#define port\_irq\_disable(info, mask) \- { info->pim\_value |= (mask); write\_reg(info, PIM, info->pim\_value); }--#define port\_irq\_enable(info, mask) \- { info->pim\_value &= ~(mask); write\_reg(info, PIM, info->pim\_value); }--static void rx\_start(MGSLPC\_INFO \*info);-static void rx\_stop(MGSLPC\_INFO \*info);--static void tx\_start(MGSLPC\_INFO \*info, struct tty\_struct \*tty);-static void tx\_stop(MGSLPC\_INFO \*info);-static void tx\_set\_idle(MGSLPC\_INFO \*info);--static void get\_signals(MGSLPC\_INFO \*info);-static void set\_signals(MGSLPC\_INFO \*info);--static void reset\_device(MGSLPC\_INFO \*info);--static void hdlc\_mode(MGSLPC\_INFO \*info);-static void async\_mode(MGSLPC\_INFO \*info);--static void tx\_timeout(struct timer\_list \*t);--static bool carrier\_raised(struct tty\_port \*port);-static void dtr\_rts(struct tty\_port \*port, bool active);--#if SYNCLINK\_GENERIC\_HDLC-#define dev\_to\_port(D) (dev\_to\_hdlc(D)->priv)-static void hdlcdev\_tx\_done(MGSLPC\_INFO \*info);-static void hdlcdev\_rx(MGSLPC\_INFO \*info, char \*buf, int size);-static int hdlcdev\_init(MGSLPC\_INFO \*info);-static void hdlcdev\_exit(MGSLPC\_INFO \*info);-#endif--static void trace\_block(MGSLPC\_INFO \*info,const char\* data, int count, int xmit);--static bool register\_test(MGSLPC\_INFO \*info);-static bool irq\_test(MGSLPC\_INFO \*info);-static int adapter\_test(MGSLPC\_INFO \*info);--static int claim\_resources(MGSLPC\_INFO \*info);-static void release\_resources(MGSLPC\_INFO \*info);-static int mgslpc\_add\_device(MGSLPC\_INFO \*info);-static void mgslpc\_remove\_device(MGSLPC\_INFO \*info);--static bool rx\_get\_frame(MGSLPC\_INFO \*info, struct tty\_struct \*tty);-static void rx\_reset\_buffers(MGSLPC\_INFO \*info);-static int rx\_alloc\_buffers(MGSLPC\_INFO \*info);-static void rx\_free\_buffers(MGSLPC\_INFO \*info);--static irqreturn\_t mgslpc\_isr(int irq, void \*dev\_id);--/\*- \* Bottom half interrupt handlers- \*/-static void bh\_handler(struct work\_struct \*work);-static void bh\_transmit(MGSLPC\_INFO \*info, struct tty\_struct \*tty);-static void bh\_status(MGSLPC\_INFO \*info);--/\*- \* ioctl handlers- \*/-static int tiocmget(struct tty\_struct \*tty);-static int tiocmset(struct tty\_struct \*tty,- unsigned int set, unsigned int clear);-static int get\_stats(MGSLPC\_INFO \*info, struct mgsl\_icount \_\_user \*user\_icount);-static int get\_params(MGSLPC\_INFO \*info, MGSL\_PARAMS \_\_user \*user\_params);-static int set\_params(MGSLPC\_INFO \*info, MGSL\_PARAMS \_\_user \*new\_params, struct tty\_struct \*tty);-static int get\_txidle(MGSLPC\_INFO \*info, int \_\_user \*idle\_mode);-static int set\_txidle(MGSLPC\_INFO \*info, int idle\_mode);-static int set\_txenable(MGSLPC\_INFO \*info, int enable, struct tty\_struct \*tty);-static int tx\_abort(MGSLPC\_INFO \*info);-static int set\_rxenable(MGSLPC\_INFO \*info, int enable);-static int wait\_events(MGSLPC\_INFO \*info, int \_\_user \*mask);--static MGSLPC\_INFO \*mgslpc\_device\_list = NULL;-static int mgslpc\_device\_count = 0;--/\*- \* Set this param to non-zero to load eax with the- \* .text section address and breakpoint on module load.- \* This is useful for use with gdb and add-symbol-file command.- \*/-static bool break\_on\_load;--/\*- \* Driver major number, defaults to zero to get auto- \* assigned major number. May be forced as module parameter.- \*/-static int ttymajor=0;--static int debug\_level = 0;-static int maxframe[MAX\_DEVICE\_COUNT] = {0,};--module\_param(break\_on\_load, bool, 0);-module\_param(ttymajor, int, 0);-module\_param(debug\_level, int, 0);-module\_param\_array(maxframe, int, NULL, 0);--MODULE\_LICENSE("GPL");--static char \*driver\_name = "SyncLink PC Card driver";-static char \*driver\_version = "$Revision: 4.34 $";--static struct tty\_driver \*serial\_driver;--/\* number of characters left in xmit buffer before we ask for more \*/-#define WAKEUP\_CHARS 256--static void mgslpc\_change\_params(MGSLPC\_INFO \*info, struct tty\_struct \*tty);-static void mgslpc\_wait\_until\_sent(struct tty\_struct \*tty, int timeout);--/\* PCMCIA prototypes \*/--static int mgslpc\_config(struct pcmcia\_device \*link);-static void mgslpc\_release(u\_long arg);-static void mgslpc\_detach(struct pcmcia\_device \*p\_dev);--/\*- \* 1st function defined in .text section. Calling this function in- \* init\_module() followed by a breakpoint allows a remote debugger- \* (gdb) to get the .text address for the add-symbol-file command.- \* This allows remote debugging of dynamically loadable modules.- \*/-static void\* mgslpc\_get\_text\_ptr(void)-{- return mgslpc\_get\_text\_ptr;-}--/\*- \* line discipline callback wrappers- \*- \* The wrappers maintain line discipline references- \* while calling into the line discipline.- \*- \* ldisc\_receive\_buf - pass receive data to line discipline- \*/--static void ldisc\_receive\_buf(struct tty\_struct \*tty,- const \_\_u8 \*data, char \*flags, int count)-{- struct tty\_ldisc \*ld;- if (!tty)- return;- ld = tty\_ldisc\_ref(tty);- if (ld) {- if (ld->ops->receive\_buf)- ld->ops->receive\_buf(tty, data, flags, count);- tty\_ldisc\_deref(ld);- }-}--static const struct tty\_port\_operations mgslpc\_port\_ops = {- .carrier\_raised = carrier\_raised,- .dtr\_rts = dtr\_rts-};--static int mgslpc\_probe(struct pcmcia\_device \*link)-{- MGSLPC\_INFO \*info;- int ret;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("mgslpc\_attach\n");-- info = kzalloc(sizeof(MGSLPC\_INFO), GFP\_KERNEL);- if (!info) {- printk("Error can't allocate device instance data\n");- return -ENOMEM;- }-- info->magic = MGSLPC\_MAGIC;- tty\_port\_init(&info->port);- info->port.ops = &mgslpc\_port\_ops;- INIT\_WORK(&info->task, bh\_handler);- info->max\_frame\_size = 4096;- init\_waitqueue\_head(&info->status\_event\_wait\_q);- init\_waitqueue\_head(&info->event\_wait\_q);- spin\_lock\_init(&info->lock);- spin\_lock\_init(&info->netlock);- memcpy(&info->params,&default\_params,sizeof(MGSL\_PARAMS));- info->idle\_mode = HDLC\_TXIDLE\_FLAGS;- info->imra\_value = 0xffff;- info->imrb\_value = 0xffff;- info->pim\_value = 0xff;-- info->p\_dev = link;- link->priv = info;-- /\* Initialize the struct pcmcia\_device structure \*/-- ret = mgslpc\_config(link);- if (ret != 0)- goto failed;-- ret = mgslpc\_add\_device(info);- if (ret != 0)- goto failed\_release;-- return 0;--failed\_release:- mgslpc\_release((u\_long)link);-failed:- tty\_port\_destroy(&info->port);- kfree(info);- return ret;-}--/\* Card has been inserted.- \*/--static int mgslpc\_ioprobe(struct pcmcia\_device \*p\_dev, void \*priv\_data)-{- return pcmcia\_request\_io(p\_dev);-}--static int mgslpc\_config(struct pcmcia\_device \*link)-{- MGSLPC\_INFO \*info = link->priv;- int ret;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("mgslpc\_config(0x%p)\n", link);-- link->config\_flags |= CONF\_ENABLE\_IRQ | CONF\_AUTO\_SET\_IO;-- ret = pcmcia\_loop\_config(link, mgslpc\_ioprobe, NULL);- if (ret != 0)- goto failed;-- link->config\_index = 8;- link->config\_regs = PRESENT\_OPTION;-- ret = pcmcia\_request\_irq(link, mgslpc\_isr);- if (ret)- goto failed;- ret = pcmcia\_enable\_device(link);- if (ret)- goto failed;-- info->io\_base = link->resource[0]->start;- info->irq\_level = link->irq;- return 0;--failed:- mgslpc\_release((u\_long)link);- return -ENODEV;-}--/\* Card has been removed.- \* Unregister device and release PCMCIA configuration.- \* If device is open, postpone until it is closed.- \*/-static void mgslpc\_release(u\_long arg)-{- struct pcmcia\_device \*link = (struct pcmcia\_device \*)arg;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("mgslpc\_release(0x%p)\n", link);-- pcmcia\_disable\_device(link);-}--static void mgslpc\_detach(struct pcmcia\_device \*link)-{- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("mgslpc\_detach(0x%p)\n", link);-- ((MGSLPC\_INFO \*)link->priv)->stop = 1;- mgslpc\_release((u\_long)link);-- mgslpc\_remove\_device((MGSLPC\_INFO \*)link->priv);-}--static int mgslpc\_suspend(struct pcmcia\_device \*link)-{- MGSLPC\_INFO \*info = link->priv;-- info->stop = 1;-- return 0;-}--static int mgslpc\_resume(struct pcmcia\_device \*link)-{- MGSLPC\_INFO \*info = link->priv;-- info->stop = 0;-- return 0;-}---static inline bool mgslpc\_paranoia\_check(MGSLPC\_INFO \*info,- char \*name, const char \*routine)-{-#ifdef MGSLPC\_PARANOIA\_CHECK- static const char \*badmagic =- "Warning: bad magic number for mgsl struct (%s) in %s\n";- static const char \*badinfo =- "Warning: null mgslpc\_info for (%s) in %s\n";-- if (!info) {- printk(badinfo, name, routine);- return true;- }- if (info->magic != MGSLPC\_MAGIC) {- printk(badmagic, name, routine);- return true;- }-#else- if (!info)- return true;-#endif- return false;-}---#define CMD\_RXFIFO BIT7 // release current rx FIFO-#define CMD\_RXRESET BIT6 // receiver reset-#define CMD\_RXFIFO\_READ BIT5-#define CMD\_START\_TIMER BIT4-#define CMD\_TXFIFO BIT3 // release current tx FIFO-#define CMD\_TXEOM BIT1 // transmit end message-#define CMD\_TXRESET BIT0 // transmit reset--static bool wait\_command\_complete(MGSLPC\_INFO \*info, unsigned char channel)-{- int i = 0;- /\* wait for command completion \*/- while (read\_reg(info, (unsigned char)(channel+STAR)) & BIT2) {- udelay(1);- if (i++ == 1000)- return false;- }- return true;-}--static void issue\_command(MGSLPC\_INFO \*info, unsigned char channel, unsigned char cmd)-{- wait\_command\_complete(info, channel);- write\_reg(info, (unsigned char) (channel + CMDR), cmd);-}--static void tx\_pause(struct tty\_struct \*tty)-{- MGSLPC\_INFO \*info = (MGSLPC\_INFO \*)tty->driver\_data;- unsigned long flags;-- if (mgslpc\_paranoia\_check(info, tty->name, "tx\_pause"))- return;- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("tx\_pause(%s)\n", info->device\_name);-- spin\_lock\_irqsave(&info->lock, flags);- if (info->tx\_enabled)- tx\_stop(info);- spin\_unlock\_irqrestore(&info->lock, flags);-}--static void tx\_release(struct tty\_struct \*tty)-{- MGSLPC\_INFO \*info = (MGSLPC\_INFO \*)tty->driver\_data;- unsigned long flags;-- if (mgslpc\_paranoia\_check(info, tty->name, "tx\_release"))- return;- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("tx\_release(%s)\n", info->device\_name);-- spin\_lock\_irqsave(&info->lock, flags);- if (!info->tx\_enabled)- tx\_start(info, tty);- spin\_unlock\_irqrestore(&info->lock, flags);-}--/\* Return next bottom half action to perform.- \* or 0 if nothing to do.- \*/-static int bh\_action(MGSLPC\_INFO \*info)-{- unsigned long flags;- int rc = 0;-- spin\_lock\_irqsave(&info->lock, flags);-- if (info->pending\_bh & BH\_RECEIVE) {- info->pending\_bh &= ~BH\_RECEIVE;- rc = BH\_RECEIVE;- } else if (info->pending\_bh & BH\_TRANSMIT) {- info->pending\_bh &= ~BH\_TRANSMIT;- rc = BH\_TRANSMIT;- } else if (info->pending\_bh & BH\_STATUS) {- info->pending\_bh &= ~BH\_STATUS;- rc = BH\_STATUS;- }-- if (!rc) {- /\* Mark BH routine as complete \*/- info->bh\_running = false;- info->bh\_requested = false;- }-- spin\_unlock\_irqrestore(&info->lock, flags);-- return rc;-}--static void bh\_handler(struct work\_struct \*work)-{- MGSLPC\_INFO \*info = container\_of(work, MGSLPC\_INFO, task);- struct tty\_struct \*tty;- int action;-- if (debug\_level >= DEBUG\_LEVEL\_BH)- printk("%s(%d):bh\_handler(%s) entry\n",- \_\_FILE\_\_,\_\_LINE\_\_,info->device\_name);-- info->bh\_running = true;- tty = tty\_port\_tty\_get(&info->port);-- while((action = bh\_action(info)) != 0) {-- /\* Process work item \*/- if (debug\_level >= DEBUG\_LEVEL\_BH)- printk("%s(%d):bh\_handler() work item action=%d\n",- \_\_FILE\_\_,\_\_LINE\_\_,action);-- switch (action) {-- case BH\_RECEIVE:- while(rx\_get\_frame(info, tty));- break;- case BH\_TRANSMIT:- bh\_transmit(info, tty);- break;- case BH\_STATUS:- bh\_status(info);- break;- default:- /\* unknown work item ID \*/- printk("Unknown work item ID=%08X!\n", action);- break;- }- }-- tty\_kref\_put(tty);- if (debug\_level >= DEBUG\_LEVEL\_BH)- printk("%s(%d):bh\_handler(%s) exit\n",- \_\_FILE\_\_,\_\_LINE\_\_,info->device\_name);-}--static void bh\_transmit(MGSLPC\_INFO \*info, struct tty\_struct \*tty)-{- if (debug\_level >= DEBUG\_LEVEL\_BH)- printk("bh\_transmit() entry on %s\n", info->device\_name);-- if (tty)- tty\_wakeup(tty);-}--static void bh\_status(MGSLPC\_INFO \*info)-{- info->ri\_chkcount = 0;- info->dsr\_chkcount = 0;- info->dcd\_chkcount = 0;- info->cts\_chkcount = 0;-}--/\* eom: non-zero = end of frame \*/-static void rx\_ready\_hdlc(MGSLPC\_INFO \*info, int eom)-{- unsigned char data[2];- unsigned char fifo\_count, read\_count, i;- RXBUF \*buf = (RXBUF\*)(info->rx\_buf + (info->rx\_put \* info->rx\_buf\_size));-- if (debug\_level >= DEBUG\_LEVEL\_ISR)- printk("%s(%d):rx\_ready\_hdlc(eom=%d)\n", \_\_FILE\_\_, \_\_LINE\_\_, eom);-- if (!info->rx\_enabled)- return;-- if (info->rx\_frame\_count >= info->rx\_buf\_count) {- /\* no more free buffers \*/- issue\_command(info, CHA, CMD\_RXRESET);- info->pending\_bh |= BH\_RECEIVE;- info->rx\_overflow = true;- info->icount.buf\_overrun++;- return;- }-- if (eom) {- /\* end of frame, get FIFO count from RBCL register \*/- fifo\_count = (unsigned char)(read\_reg(info, CHA+RBCL) & 0x1f);- if (fifo\_count == 0)- fifo\_count = 32;- } else- fifo\_count = 32;-- do {- if (fifo\_count == 1) {- read\_count = 1;- data[0] = read\_reg(info, CHA + RXFIFO);- } else {- read\_count = 2;- \*((unsigned short \*) data) = read\_reg16(info, CHA + RXFIFO);- }- fifo\_count -= read\_count;- if (!fifo\_count && eom)- buf->status = data[--read\_count];-- for (i = 0; i < read\_count; i++) {- if (buf->count >= info->max\_frame\_size) {- /\* frame too large, reset receiver and reset current buffer \*/- issue\_command(info, CHA, CMD\_RXRESET);- buf->count = 0;- return;- }- \*(buf->data + buf->count) = data[i];- buf->count++;- }- } while (fifo\_count);-- if (eom) {- info->pending\_bh |= BH\_RECEIVE;- info->rx\_frame\_count++;- info->rx\_put++;- if (info->rx\_put >= info->rx\_buf\_count)- info->rx\_put = 0;- }- issue\_command(info, CHA, CMD\_RXFIFO);-}--static void rx\_ready\_async(MGSLPC\_INFO \*info, int tcd)-{- struct tty\_port \*port = &info->port;- unsigned char data, status, flag;- int fifo\_count;- int work = 0;- struct mgsl\_icount \*icount = &info->icount;-- if (tcd) {- /\* early termination, get FIFO count from RBCL register \*/- fifo\_count = (unsigned char)(read\_reg(info, CHA+RBCL) & 0x1f);-- /\* Zero fifo count could mean 0 or 32 bytes available.- \* If BIT5 of STAR is set then at least 1 byte is available.- \*/- if (!fifo\_count && (read\_reg(info,CHA+STAR) & BIT5))- fifo\_count = 32;- } else- fifo\_count = 32;-- tty\_buffer\_request\_room(port, fifo\_count);- /\* Flush received async data to receive data buffer. \*/- while (fifo\_count) {- data = read\_reg(info, CHA + RXFIFO);- status = read\_reg(info, CHA + RXFIFO);- fifo\_count -= 2;-- icount->rx++;- flag = TTY\_NORMAL;-- // if no frameing/crc error then save data- // BIT7:parity error- // BIT6:framing error-- if (status & (BIT7 | BIT6)) {- if (status & BIT7)- icount->parity++;- else- icount->frame++;-- /\* discard char if tty control flags say so \*/- if (status & info->ignore\_status\_mask)- continue;-- status &= info->read\_status\_mask;-- if (status & BIT7)- flag = TTY\_PARITY;- else if (status & BIT6)- flag = TTY\_FRAME;- }- work += tty\_insert\_flip\_char(port, data, flag);- }- issue\_command(info, CHA, CMD\_RXFIFO);-- if (debug\_level >= DEBUG\_LEVEL\_ISR) {- printk("%s(%d):rx\_ready\_async",- \_\_FILE\_\_,\_\_LINE\_\_);- printk("%s(%d):rx=%d brk=%d parity=%d frame=%d overrun=%d\n",- \_\_FILE\_\_,\_\_LINE\_\_,icount->rx,icount->brk,- icount->parity,icount->frame,icount->overrun);- }-- if (work)- tty\_flip\_buffer\_push(port);-}---static void tx\_done(MGSLPC\_INFO \*info, struct tty\_struct \*tty)-{- if (!info->tx\_active)- return;-- info->tx\_active = false;- info->tx\_aborting = false;-- if (info->params.mode == MGSL\_MODE\_ASYNC)- return;-- info->tx\_count = info->tx\_put = info->tx\_get = 0;- del\_timer(&info->tx\_timer);-- if (info->drop\_rts\_on\_tx\_done) {- get\_signals(info);- if (info->serial\_signals & SerialSignal\_RTS) {- info->serial\_signals &= ~SerialSignal\_RTS;- set\_signals(info);- }- info->drop\_rts\_on\_tx\_done = false;- }--#if SYNCLINK\_GENERIC\_HDLC- if (info->netcount)- hdlcdev\_tx\_done(info);- else-#endif- {- if (tty && (tty->flow.stopped || tty->hw\_stopped)) {- tx\_stop(info);- return;- }- info->pending\_bh |= BH\_TRANSMIT;- }-}--static void tx\_ready(MGSLPC\_INFO \*info, struct tty\_struct \*tty)-{- unsigned char fifo\_count = 32;- int c;-- if (debug\_level >= DEBUG\_LEVEL\_ISR)- printk("%s(%d):tx\_ready(%s)\n", \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name);-- if (info->params.mode == MGSL\_MODE\_HDLC) {- if (!info->tx\_active)- return;- } else {- if (tty && (tty->flow.stopped || tty->hw\_stopped)) {- tx\_stop(info);- return;- }- if (!info->tx\_count)- info->tx\_active = false;- }-- if (!info->tx\_count)- return;-- while (info->tx\_count && fifo\_count) {- c = min(2, min\_t(int, fifo\_count, min(info->tx\_count, TXBUFSIZE - info->tx\_get)));-- if (c == 1) {- write\_reg(info, CHA + TXFIFO, \*(info->tx\_buf + info->tx\_get));- } else {- write\_reg16(info, CHA + TXFIFO,- \*((unsigned short\*)(info->tx\_buf + info->tx\_get)));- }- info->tx\_count -= c;- info->tx\_get = (info->tx\_get + c) & (TXBUFSIZE - 1);- fifo\_count -= c;- }-- if (info->params.mode == MGSL\_MODE\_ASYNC) {- if (info->tx\_count < WAKEUP\_CHARS)- info->pending\_bh |= BH\_TRANSMIT;- issue\_command(info, CHA, CMD\_TXFIFO);- } else {- if (info->tx\_count)- issue\_command(info, CHA, CMD\_TXFIFO);- else- issue\_command(info, CHA, CMD\_TXFIFO + CMD\_TXEOM);- }-}--static void cts\_change(MGSLPC\_INFO \*info, struct tty\_struct \*tty)-{- get\_signals(info);- if ((info->cts\_chkcount)++ >= IO\_PIN\_SHUTDOWN\_LIMIT)- irq\_disable(info, CHB, IRQ\_CTS);- info->icount.cts++;- if (info->serial\_signals & SerialSignal\_CTS)- info->input\_signal\_events.cts\_up++;- else- info->input\_signal\_events.cts\_down++;- wake\_up\_interruptible(&info->status\_event\_wait\_q);- wake\_up\_interruptible(&info->event\_wait\_q);-- if (tty && tty\_port\_cts\_enabled(&info->port)) {- if (tty->hw\_stopped) {- if (info->serial\_signals & SerialSignal\_CTS) {- if (debug\_level >= DEBUG\_LEVEL\_ISR)- printk("CTS tx start...");- tty->hw\_stopped = 0;- tx\_start(info, tty);- info->pending\_bh |= BH\_TRANSMIT;- return;- }- } else {- if (!(info->serial\_signals & SerialSignal\_CTS)) {- if (debug\_level >= DEBUG\_LEVEL\_ISR)- printk("CTS tx stop...");- tty->hw\_stopped = 1;- tx\_stop(info);- }- }- }- info->pending\_bh |= BH\_STATUS;-}--static void dcd\_change(MGSLPC\_INFO \*info, struct tty\_struct \*tty)-{- get\_signals(info);- if ((info->dcd\_chkcount)++ >= IO\_PIN\_SHUTDOWN\_LIMIT)- irq\_disable(info, CHB, IRQ\_DCD);- info->icount.dcd++;- if (info->serial\_signals & SerialSignal\_DCD) {- info->input\_signal\_events.dcd\_up++;- }- else- info->input\_signal\_events.dcd\_down++;-#if SYNCLINK\_GENERIC\_HDLC- if (info->netcount) {- if (info->serial\_signals & SerialSignal\_DCD)- netif\_carrier\_on(info->netdev);- else- netif\_carrier\_off(info->netdev);- }-#endif- wake\_up\_interruptible(&info->status\_event\_wait\_q);- wake\_up\_interruptible(&info->event\_wait\_q);-- if (tty\_port\_check\_carrier(&info->port)) {- if (debug\_level >= DEBUG\_LEVEL\_ISR)- printk("%s CD now %s...", info->device\_name,- (info->serial\_signals & SerialSignal\_DCD) ? "on" : "off");- if (info->serial\_signals & SerialSignal\_DCD)- wake\_up\_interruptible(&info->port.open\_wait);- else {- if (debug\_level >= DEBUG\_LEVEL\_ISR)- printk("doing serial hangup...");- if (tty)- tty\_hangup(tty);- }- }- info->pending\_bh |= BH\_STATUS;-}--static void dsr\_change(MGSLPC\_INFO \*info)-{- get\_signals(info);- if ((info->dsr\_chkcount)++ >= IO\_PIN\_SHUTDOWN\_LIMIT)- port\_irq\_disable(info, PVR\_DSR);- info->icount.dsr++;- if (info->serial\_signals & SerialSignal\_DSR)- info->input\_signal\_events.dsr\_up++;- else- info->input\_signal\_events.dsr\_down++;- wake\_up\_interruptible(&info->status\_event\_wait\_q);- wake\_up\_interruptible(&info->event\_wait\_q);- info->pending\_bh |= BH\_STATUS;-}--static void ri\_change(MGSLPC\_INFO \*info)-{- get\_signals(info);- if ((info->ri\_chkcount)++ >= IO\_PIN\_SHUTDOWN\_LIMIT)- port\_irq\_disable(info, PVR\_RI);- info->icount.rng++;- if (info->serial\_signals & SerialSignal\_RI)- info->input\_signal\_events.ri\_up++;- else- info->input\_signal\_events.ri\_down++;- wake\_up\_interruptible(&info->status\_event\_wait\_q);- wake\_up\_interruptible(&info->event\_wait\_q);- info->pending\_bh |= BH\_STATUS;-}--/\* Interrupt service routine entry point.- \*- \* Arguments:- \*- \* irq interrupt number that caused interrupt- \* dev\_id device ID supplied during interrupt registration- \*/-static irqreturn\_t mgslpc\_isr(int dummy, void \*dev\_id)-{- MGSLPC\_INFO \*info = dev\_id;- struct tty\_struct \*tty;- unsigned short isr;- unsigned char gis, pis;- int count=0;-- if (debug\_level >= DEBUG\_LEVEL\_ISR)- printk("mgslpc\_isr(%d) entry.\n", info->irq\_level);-- if (!(info->p\_dev->\_locked))- return IRQ\_HANDLED;-- tty = tty\_port\_tty\_get(&info->port);-- spin\_lock(&info->lock);-- while ((gis = read\_reg(info, CHA + GIS))) {- if (debug\_level >= DEBUG\_LEVEL\_ISR)- printk("mgslpc\_isr %s gis=%04X\n", info->device\_name,gis);-- if ((gis & 0x70) || count > 1000) {- printk("synclink\_cs:hardware failed or ejected\n");- break;- }- count++;-- if (gis & (BIT1 | BIT0)) {- isr = read\_reg16(info, CHB + ISR);- if (isr & IRQ\_DCD)- dcd\_change(info, tty);- if (isr & IRQ\_CTS)- cts\_change(info, tty);- }- if (gis & (BIT3 | BIT2))- {- isr = read\_reg16(info, CHA + ISR);- if (isr & IRQ\_TIMER) {- info->irq\_occurred = true;- irq\_disable(info, CHA, IRQ\_TIMER);- }-- /\* receive IRQs \*/- if (isr & IRQ\_EXITHUNT) {- info->icount.exithunt++;- wake\_up\_interruptible(&info->event\_wait\_q);- }- if (isr & IRQ\_BREAK\_ON) {- info->icount.brk++;- if (info->port.flags & ASYNC\_SAK)- do\_SAK(tty);- }- if (isr & IRQ\_RXTIME) {- issue\_command(info, CHA, CMD\_RXFIFO\_READ);- }- if (isr & (IRQ\_RXEOM | IRQ\_RXFIFO)) {- if (info->params.mode == MGSL\_MODE\_HDLC)- rx\_ready\_hdlc(info, isr & IRQ\_RXEOM);- else- rx\_ready\_async(info, isr & IRQ\_RXEOM);- }-- /\* transmit IRQs \*/- if (isr & IRQ\_UNDERRUN) {- if (info->tx\_aborting)- info->icount.txabort++;- else- info->icount.txunder++;- tx\_done(info, tty);- }- else if (isr & IRQ\_ALLSENT) {- info->icount.txok++;- tx\_done(info, tty);- }- else if (isr & IRQ\_TXFIFO)- tx\_ready(info, tty);- }- if (gis & BIT7) {- pis = read\_reg(info, CHA + PIS);- if (pis & BIT1)- dsr\_change(info);- if (pis & BIT2)- ri\_change(info);- }- }-- /\* Request bottom half processing if there's something- \* for it to do and the bh is not already running- \*/-- if (info->pending\_bh && !info->bh\_running && !info->bh\_requested) {- if (debug\_level >= DEBUG\_LEVEL\_ISR)- printk("%s(%d):%s queueing bh task.\n",- \_\_FILE\_\_,\_\_LINE\_\_,info->device\_name);- schedule\_work(&info->task);- info->bh\_requested = true;- }-- spin\_unlock(&info->lock);- tty\_kref\_put(tty);-- if (debug\_level >= DEBUG\_LEVEL\_ISR)- printk("%s(%d):mgslpc\_isr(%d)exit.\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->irq\_level);-- return IRQ\_HANDLED;-}--/\* Initialize and start device.- \*/-static int startup(MGSLPC\_INFO \* info, struct tty\_struct \*tty)-{- int retval = 0;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):startup(%s)\n", \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name);-- if (tty\_port\_initialized(&info->port))- return 0;-- if (!info->tx\_buf) {- /\* allocate a page of memory for a transmit buffer \*/- info->tx\_buf = (unsigned char \*)get\_zeroed\_page(GFP\_KERNEL);- if (!info->tx\_buf) {- printk(KERN\_ERR"%s(%d):%s can't allocate transmit buffer\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name);- return -ENOMEM;- }- }-- info->pending\_bh = 0;-- memset(&info->icount, 0, sizeof(info->icount));-- timer\_setup(&info->tx\_timer, tx\_timeout, 0);-- /\* Allocate and claim adapter resources \*/- retval = claim\_resources(info);-- /\* perform existence check and diagnostics \*/- if (!retval)- retval = adapter\_test(info);-- if (retval) {- if (capable(CAP\_SYS\_ADMIN) && tty)- set\_bit(TTY\_IO\_ERROR, &tty->flags);- release\_resources(info);- return retval;- }-- /\* program hardware for current parameters \*/- mgslpc\_change\_params(info, tty);-- if (tty)- clear\_bit(TTY\_IO\_ERROR, &tty->flags);-- tty\_port\_set\_initialized(&info->port, true);-- return 0;-}--/\* Called by mgslpc\_close() and mgslpc\_hangup() to shutdown hardware- \*/-static void shutdown(MGSLPC\_INFO \* info, struct tty\_struct \*tty)-{- unsigned long flags;-- if (!tty\_port\_initialized(&info->port))- return;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):mgslpc\_shutdown(%s)\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name);-- /\* clear status wait queue because status changes \*/- /\* can't happen after shutting down the hardware \*/- wake\_up\_interruptible(&info->status\_event\_wait\_q);- wake\_up\_interruptible(&info->event\_wait\_q);-- del\_timer\_sync(&info->tx\_timer);-- if (info->tx\_buf) {- free\_page((unsigned long) info->tx\_buf);- info->tx\_buf = NULL;- }-- spin\_lock\_irqsave(&info->lock, flags);-- rx\_stop(info);- tx\_stop(info);-- /\* TODO:disable interrupts instead of reset to preserve signal states \*/- reset\_device(info);-- if (!tty || C\_HUPCL(tty)) {- info->serial\_signals &= ~(SerialSignal\_RTS | SerialSignal\_DTR);- set\_signals(info);- }-- spin\_unlock\_irqrestore(&info->lock, flags);-- release\_resources(info);-- if (tty)- set\_bit(TTY\_IO\_ERROR, &tty->flags);-- tty\_port\_set\_initialized(&info->port, false);-}--static void mgslpc\_program\_hw(MGSLPC\_INFO \*info, struct tty\_struct \*tty)-{- unsigned long flags;-- spin\_lock\_irqsave(&info->lock, flags);-- rx\_stop(info);- tx\_stop(info);- info->tx\_count = info->tx\_put = info->tx\_get = 0;-- if (info->params.mode == MGSL\_MODE\_HDLC || info->netcount)- hdlc\_mode(info);- else- async\_mode(info);-- set\_signals(info);-- info->dcd\_chkcount = 0;- info->cts\_chkcount = 0;- info->ri\_chkcount = 0;- info->dsr\_chkcount = 0;-- irq\_enable(info, CHB, IRQ\_DCD | IRQ\_CTS);- port\_irq\_enable(info, (unsigned char) PVR\_DSR | PVR\_RI);- get\_signals(info);-- if (info->netcount || (tty && C\_CREAD(tty)))- rx\_start(info);-- spin\_unlock\_irqrestore(&info->lock, flags);-}--/\* Reconfigure adapter based on new parameters- \*/-static void mgslpc\_change\_params(MGSLPC\_INFO \*info, struct tty\_struct \*tty)-{- unsigned cflag;- int bits\_per\_char;-- if (!tty)- return;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):mgslpc\_change\_params(%s)\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name);-- cflag = tty->termios.c\_cflag;-- /\* if B0 rate (hangup) specified then negate RTS and DTR \*/- /\* otherwise assert RTS and DTR \*/- if (cflag & CBAUD)- info->serial\_signals |= SerialSignal\_RTS | SerialSignal\_DTR;- else- info->serial\_signals &= ~(SerialSignal\_RTS | SerialSignal\_DTR);-- /\* byte size and parity \*/- if ((cflag & CSIZE) != CS8) {- cflag &= ~CSIZE;- cflag |= CS7;- tty->termios.c\_cflag = cflag;- }- info->params.data\_bits = tty\_get\_char\_size(cflag);-- if (cflag & CSTOPB)- info->params.stop\_bits = 2;- else- info->params.stop\_bits = 1;-- info->params.parity = ASYNC\_PARITY\_NONE;- if (cflag & PARENB) {- if (cflag & PARODD)- info->params.parity = ASYNC\_PARITY\_ODD;- else- info->params.parity = ASYNC\_PARITY\_EVEN;- if (cflag & CMSPAR)- info->params.parity = ASYNC\_PARITY\_SPACE;- }-- /\* calculate number of jiffies to transmit a full- \* FIFO (32 bytes) at specified data rate- \*/- bits\_per\_char = info->params.data\_bits +- info->params.stop\_bits + 1;-- /\* if port data rate is set to 460800 or less then- \* allow tty settings to override, otherwise keep the- \* current data rate.- \*/- if (info->params.data\_rate <= 460800) {- info->params.data\_rate = tty\_get\_baud\_rate(tty);- }-- if (info->params.data\_rate) {- info->timeout = (32\*HZ\*bits\_per\_char) /- info->params.data\_rate;- }- info->timeout += HZ/50; /\* Add .02 seconds of slop \*/-- tty\_port\_set\_cts\_flow(&info->port, cflag & CRTSCTS);- tty\_port\_set\_check\_carrier(&info->port, ~cflag & CLOCAL);-- /\* process tty input control flags \*/-- info->read\_status\_mask = 0;- if (I\_INPCK(tty))- info->read\_status\_mask |= BIT7 | BIT6;- if (I\_IGNPAR(tty))- info->ignore\_status\_mask |= BIT7 | BIT6;-- mgslpc\_program\_hw(info, tty);-}--/\* Add a character to the transmit buffer- \*/-static int mgslpc\_put\_char(struct tty\_struct \*tty, unsigned char ch)-{- MGSLPC\_INFO \*info = (MGSLPC\_INFO \*)tty->driver\_data;- unsigned long flags;-- if (debug\_level >= DEBUG\_LEVEL\_INFO) {- printk("%s(%d):mgslpc\_put\_char(%d) on %s\n",- \_\_FILE\_\_, \_\_LINE\_\_, ch, info->device\_name);- }-- if (mgslpc\_paranoia\_check(info, tty->name, "mgslpc\_put\_char"))- return 0;-- if (!info->tx\_buf)- return 0;-- spin\_lock\_irqsave(&info->lock, flags);-- if (info->params.mode == MGSL\_MODE\_ASYNC || !info->tx\_active) {- if (info->tx\_count < TXBUFSIZE - 1) {- info->tx\_buf[info->tx\_put++] = ch;- info->tx\_put &= TXBUFSIZE-1;- info->tx\_count++;- }- }-- spin\_unlock\_irqrestore(&info->lock, flags);- return 1;-}--/\* Enable transmitter so remaining characters in the- \* transmit buffer are sent.- \*/-static void mgslpc\_flush\_chars(struct tty\_struct \*tty)-{- MGSLPC\_INFO \*info = (MGSLPC\_INFO \*)tty->driver\_data;- unsigned long flags;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):mgslpc\_flush\_chars() entry on %s tx\_count=%d\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name, info->tx\_count);-- if (mgslpc\_paranoia\_check(info, tty->name, "mgslpc\_flush\_chars"))- return;-- if (info->tx\_count <= 0 || tty->flow.stopped ||- tty->hw\_stopped || !info->tx\_buf)- return;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):mgslpc\_flush\_chars() entry on %s starting transmitter\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name);-- spin\_lock\_irqsave(&info->lock, flags);- if (!info->tx\_active)- tx\_start(info, tty);- spin\_unlock\_irqrestore(&info->lock, flags);-}--/\* Send a block of data- \*- \* Arguments:- \*- \* tty pointer to tty information structure- \* buf pointer to buffer containing send data- \* count size of send data in bytes- \*- \* Returns: number of characters written- \*/-static int mgslpc\_write(struct tty\_struct \* tty,- const unsigned char \*buf, int count)-{- int c, ret = 0;- MGSLPC\_INFO \*info = (MGSLPC\_INFO \*)tty->driver\_data;- unsigned long flags;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):mgslpc\_write(%s) count=%d\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name, count);-- if (mgslpc\_paranoia\_check(info, tty->name, "mgslpc\_write") ||- !info->tx\_buf)- goto cleanup;-- if (info->params.mode == MGSL\_MODE\_HDLC) {- if (count > TXBUFSIZE) {- ret = -EIO;- goto cleanup;- }- if (info->tx\_active)- goto cleanup;- else if (info->tx\_count)- goto start;- }-- for (;;) {- c = min(count,- min(TXBUFSIZE - info->tx\_count - 1,- TXBUFSIZE - info->tx\_put));- if (c <= 0)- break;-- memcpy(info->tx\_buf + info->tx\_put, buf, c);-- spin\_lock\_irqsave(&info->lock, flags);- info->tx\_put = (info->tx\_put + c) & (TXBUFSIZE-1);- info->tx\_count += c;- spin\_unlock\_irqrestore(&info->lock, flags);-- buf += c;- count -= c;- ret += c;- }-start:- if (info->tx\_count && !tty->flow.stopped && !tty->hw\_stopped) {- spin\_lock\_irqsave(&info->lock, flags);- if (!info->tx\_active)- tx\_start(info, tty);- spin\_unlock\_irqrestore(&info->lock, flags);- }-cleanup:- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):mgslpc\_write(%s) returning=%d\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name, ret);- return ret;-}--/\* Return the count of free bytes in transmit buffer- \*/-static unsigned int mgslpc\_write\_room(struct tty\_struct \*tty)-{- MGSLPC\_INFO \*info = (MGSLPC\_INFO \*)tty->driver\_data;- int ret;-- if (mgslpc\_paranoia\_check(info, tty->name, "mgslpc\_write\_room"))- return 0;-- if (info->params.mode == MGSL\_MODE\_HDLC) {- /\* HDLC (frame oriented) mode \*/- if (info->tx\_active)- return 0;- else- return HDLC\_MAX\_FRAME\_SIZE;- } else {- ret = TXBUFSIZE - info->tx\_count - 1;- if (ret < 0)- ret = 0;- }-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):mgslpc\_write\_room(%s)=%d\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name, ret);- return ret;-}--/\* Return the count of bytes in transmit buffer- \*/-static unsigned int mgslpc\_chars\_in\_buffer(struct tty\_struct \*tty)-{- MGSLPC\_INFO \*info = (MGSLPC\_INFO \*)tty->driver\_data;- unsigned int rc;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):mgslpc\_chars\_in\_buffer(%s)\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name);-- if (mgslpc\_paranoia\_check(info, tty->name, "mgslpc\_chars\_in\_buffer"))- return 0;-- if (info->params.mode == MGSL\_MODE\_HDLC)- rc = info->tx\_active ? info->max\_frame\_size : 0;- else- rc = info->tx\_count;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):mgslpc\_chars\_in\_buffer(%s)=%u\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name, rc);-- return rc;-}--/\* Discard all data in the send buffer- \*/-static void mgslpc\_flush\_buffer(struct tty\_struct \*tty)-{- MGSLPC\_INFO \*info = (MGSLPC\_INFO \*)tty->driver\_data;- unsigned long flags;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):mgslpc\_flush\_buffer(%s) entry\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name);-- if (mgslpc\_paranoia\_check(info, tty->name, "mgslpc\_flush\_buffer"))- return;-- spin\_lock\_irqsave(&info->lock, flags);- info->tx\_count = info->tx\_put = info->tx\_get = 0;- del\_timer(&info->tx\_timer);- spin\_unlock\_irqrestore(&info->lock, flags);-- wake\_up\_interruptible(&tty->write\_wait);- tty\_wakeup(tty);-}--/\* Send a high-priority XON/XOFF character- \*/-static void mgslpc\_send\_xchar(struct tty\_struct \*tty, char ch)-{- MGSLPC\_INFO \*info = (MGSLPC\_INFO \*)tty->driver\_data;- unsigned long flags;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):mgslpc\_send\_xchar(%s,%d)\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name, ch);-- if (mgslpc\_paranoia\_check(info, tty->name, "mgslpc\_send\_xchar"))- return;-- info->x\_char = ch;- if (ch) {- spin\_lock\_irqsave(&info->lock, flags);- if (!info->tx\_enabled)- tx\_start(info, tty);- spin\_unlock\_irqrestore(&info->lock, flags);- }-}--/\* Signal remote device to throttle send data (our receive data)- \*/-static void mgslpc\_throttle(struct tty\_struct \* tty)-{- MGSLPC\_INFO \*info = (MGSLPC\_INFO \*)tty->driver\_data;- unsigned long flags;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):mgslpc\_throttle(%s) entry\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name);-- if (mgslpc\_paranoia\_check(info, tty->name, "mgslpc\_throttle"))- return;-- if (I\_IXOFF(tty))- mgslpc\_send\_xchar(tty, STOP\_CHAR(tty));-- if (C\_CRTSCTS(tty)) {- spin\_lock\_irqsave(&info->lock, flags);- info->serial\_signals &= ~SerialSignal\_RTS;- set\_signals(info);- spin\_unlock\_irqrestore(&info->lock, flags);- }-}--/\* Signal remote device to stop throttling send data (our receive data)- \*/-static void mgslpc\_unthrottle(struct tty\_struct \* tty)-{- MGSLPC\_INFO \*info = (MGSLPC\_INFO \*)tty->driver\_data;- unsigned long flags;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):mgslpc\_unthrottle(%s) entry\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name);-- if (mgslpc\_paranoia\_check(info, tty->name, "mgslpc\_unthrottle"))- return;-- if (I\_IXOFF(tty)) {- if (info->x\_char)- info->x\_char = 0;- else- mgslpc\_send\_xchar(tty, START\_CHAR(tty));- }-- if (C\_CRTSCTS(tty)) {- spin\_lock\_irqsave(&info->lock, flags);- info->serial\_signals |= SerialSignal\_RTS;- set\_signals(info);- spin\_unlock\_irqrestore(&info->lock, flags);- }-}--/\* get the current serial statistics- \*/-static int get\_stats(MGSLPC\_INFO \* info, struct mgsl\_icount \_\_user \*user\_icount)-{- int err;- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("get\_params(%s)\n", info->device\_name);- if (!user\_icount) {- memset(&info->icount, 0, sizeof(info->icount));- } else {- COPY\_TO\_USER(err, user\_icount, &info->icount, sizeof(struct mgsl\_icount));- if (err)- return -EFAULT;- }- return 0;-}--/\* get the current serial parameters- \*/-static int get\_params(MGSLPC\_INFO \* info, MGSL\_PARAMS \_\_user \*user\_params)-{- int err;- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("get\_params(%s)\n", info->device\_name);- COPY\_TO\_USER(err,user\_params, &info->params, sizeof(MGSL\_PARAMS));- if (err)- return -EFAULT;- return 0;-}--/\* set the serial parameters- \*- \* Arguments:- \*- \* info pointer to device instance data- \* new\_params user buffer containing new serial params- \*- \* Returns: 0 if success, otherwise error code- \*/-static int set\_params(MGSLPC\_INFO \* info, MGSL\_PARAMS \_\_user \*new\_params, struct tty\_struct \*tty)-{- unsigned long flags;- MGSL\_PARAMS tmp\_params;- int err;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):set\_params %s\n", \_\_FILE\_\_,\_\_LINE\_\_,- info->device\_name);- COPY\_FROM\_USER(err,&tmp\_params, new\_params, sizeof(MGSL\_PARAMS));- if (err) {- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):set\_params(%s) user buffer copy failed\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name);- return -EFAULT;- }-- spin\_lock\_irqsave(&info->lock, flags);- memcpy(&info->params,&tmp\_params,sizeof(MGSL\_PARAMS));- spin\_unlock\_irqrestore(&info->lock, flags);-- mgslpc\_change\_params(info, tty);-- return 0;-}--static int get\_txidle(MGSLPC\_INFO \* info, int \_\_user \*idle\_mode)-{- int err;- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("get\_txidle(%s)=%d\n", info->device\_name, info->idle\_mode);- COPY\_TO\_USER(err,idle\_mode, &info->idle\_mode, sizeof(int));- if (err)- return -EFAULT;- return 0;-}--static int set\_txidle(MGSLPC\_INFO \* info, int idle\_mode)-{- unsigned long flags;- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("set\_txidle(%s,%d)\n", info->device\_name, idle\_mode);- spin\_lock\_irqsave(&info->lock, flags);- info->idle\_mode = idle\_mode;- tx\_set\_idle(info);- spin\_unlock\_irqrestore(&info->lock, flags);- return 0;-}--static int get\_interface(MGSLPC\_INFO \* info, int \_\_user \*if\_mode)-{- int err;- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("get\_interface(%s)=%d\n", info->device\_name, info->if\_mode);- COPY\_TO\_USER(err,if\_mode, &info->if\_mode, sizeof(int));- if (err)- return -EFAULT;- return 0;-}--static int set\_interface(MGSLPC\_INFO \* info, int if\_mode)-{- unsigned long flags;- unsigned char val;- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("set\_interface(%s,%d)\n", info->device\_name, if\_mode);- spin\_lock\_irqsave(&info->lock, flags);- info->if\_mode = if\_mode;-- val = read\_reg(info, PVR) & 0x0f;- switch (info->if\_mode)- {- case MGSL\_INTERFACE\_RS232: val |= PVR\_RS232; break;- case MGSL\_INTERFACE\_V35: val |= PVR\_V35; break;- case MGSL\_INTERFACE\_RS422: val |= PVR\_RS422; break;- }- write\_reg(info, PVR, val);-- spin\_unlock\_irqrestore(&info->lock, flags);- return 0;-}--static int set\_txenable(MGSLPC\_INFO \* info, int enable, struct tty\_struct \*tty)-{- unsigned long flags;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("set\_txenable(%s,%d)\n", info->device\_name, enable);-- spin\_lock\_irqsave(&info->lock, flags);- if (enable) {- if (!info->tx\_enabled)- tx\_start(info, tty);- } else {- if (info->tx\_enabled)- tx\_stop(info);- }- spin\_unlock\_irqrestore(&info->lock, flags);- return 0;-}--static int tx\_abort(MGSLPC\_INFO \* info)-{- unsigned long flags;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("tx\_abort(%s)\n", info->device\_name);-- spin\_lock\_irqsave(&info->lock, flags);- if (info->tx\_active && info->tx\_count &&- info->params.mode == MGSL\_MODE\_HDLC) {- /\* clear data count so FIFO is not filled on next IRQ.- \* This results in underrun and abort transmission.- \*/- info->tx\_count = info->tx\_put = info->tx\_get = 0;- info->tx\_aborting = true;- }- spin\_unlock\_irqrestore(&info->lock, flags);- return 0;-}--static int set\_rxenable(MGSLPC\_INFO \* info, int enable)-{- unsigned long flags;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("set\_rxenable(%s,%d)\n", info->device\_name, enable);-- spin\_lock\_irqsave(&info->lock, flags);- if (enable) {- if (!info->rx\_enabled)- rx\_start(info);- } else {- if (info->rx\_enabled)- rx\_stop(info);- }- spin\_unlock\_irqrestore(&info->lock, flags);- return 0;-}--/\* wait for specified event to occur- \*- \* Arguments: info pointer to device instance data- \* mask pointer to bitmask of events to wait for- \* Return Value: 0 if successful and bit mask updated with- \* of events triggerred,- \* otherwise error code- \*/-static int wait\_events(MGSLPC\_INFO \* info, int \_\_user \*mask\_ptr)-{- unsigned long flags;- int s;- int rc=0;- struct mgsl\_icount cprev, cnow;- int events;- int mask;- struct \_input\_signal\_events oldsigs, newsigs;- DECLARE\_WAITQUEUE(wait, current);-- COPY\_FROM\_USER(rc,&mask, mask\_ptr, sizeof(int));- if (rc)- return -EFAULT;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("wait\_events(%s,%d)\n", info->device\_name, mask);-- spin\_lock\_irqsave(&info->lock, flags);-- /\* return immediately if state matches requested events \*/- get\_signals(info);- s = info->serial\_signals;- events = mask &- ( ((s & SerialSignal\_DSR) ? MgslEvent\_DsrActive:MgslEvent\_DsrInactive) +- ((s & SerialSignal\_DCD) ? MgslEvent\_DcdActive:MgslEvent\_DcdInactive) +- ((s & SerialSignal\_CTS) ? MgslEvent\_CtsActive:MgslEvent\_CtsInactive) +- ((s & SerialSignal\_RI) ? MgslEvent\_RiActive :MgslEvent\_RiInactive) );- if (events) {- spin\_unlock\_irqrestore(&info->lock, flags);- goto exit;- }-- /\* save current irq counts \*/- cprev = info->icount;- oldsigs = info->input\_signal\_events;-- if ((info->params.mode == MGSL\_MODE\_HDLC) &&- (mask & MgslEvent\_ExitHuntMode))- irq\_enable(info, CHA, IRQ\_EXITHUNT);-- set\_current\_state(TASK\_INTERRUPTIBLE);- add\_wait\_queue(&info->event\_wait\_q, &wait);-- spin\_unlock\_irqrestore(&info->lock, flags);--- for(;;) {- schedule();- if (signal\_pending(current)) {- rc = -ERESTARTSYS;- break;- }-- /\* get current irq counts \*/- spin\_lock\_irqsave(&info->lock, flags);- cnow = info->icount;- newsigs = info->input\_signal\_events;- set\_current\_state(TASK\_INTERRUPTIBLE);- spin\_unlock\_irqrestore(&info->lock, flags);-- /\* if no change, wait aborted for some reason \*/- if (newsigs.dsr\_up == oldsigs.dsr\_up &&- newsigs.dsr\_down == oldsigs.dsr\_down &&- newsigs.dcd\_up == oldsigs.dcd\_up &&- newsigs.dcd\_down == oldsigs.dcd\_down &&- newsigs.cts\_up == oldsigs.cts\_up &&- newsigs.cts\_down == oldsigs.cts\_down &&- newsigs.ri\_up == oldsigs.ri\_up &&- newsigs.ri\_down == oldsigs.ri\_down &&- cnow.exithunt == cprev.exithunt &&- cnow.rxidle == cprev.rxidle) {- rc = -EIO;- break;- }-- events = mask &- ( (newsigs.dsr\_up != oldsigs.dsr\_up ? MgslEvent\_DsrActive:0) +- (newsigs.dsr\_down != oldsigs.dsr\_down ? MgslEvent\_DsrInactive:0) +- (newsigs.dcd\_up != oldsigs.dcd\_up ? MgslEvent\_DcdActive:0) +- (newsigs.dcd\_down != oldsigs.dcd\_down ? MgslEvent\_DcdInactive:0) +- (newsigs.cts\_up != oldsigs.cts\_up ? MgslEvent\_CtsActive:0) +- (newsigs.cts\_down != oldsigs.cts\_down ? MgslEvent\_CtsInactive:0) +- (newsigs.ri\_up != oldsigs.ri\_up ? MgslEvent\_RiActive:0) +- (newsigs.ri\_down != oldsigs.ri\_down ? MgslEvent\_RiInactive:0) +- (cnow.exithunt != cprev.exithunt ? MgslEvent\_ExitHuntMode:0) +- (cnow.rxidle != cprev.rxidle ? MgslEvent\_IdleReceived:0) );- if (events)- break;-- cprev = cnow;- oldsigs = newsigs;- }-- remove\_wait\_queue(&info->event\_wait\_q, &wait);- set\_current\_state(TASK\_RUNNING);-- if (mask & MgslEvent\_ExitHuntMode) {- spin\_lock\_irqsave(&info->lock, flags);- if (!waitqueue\_active(&info->event\_wait\_q))- irq\_disable(info, CHA, IRQ\_EXITHUNT);- spin\_unlock\_irqrestore(&info->lock, flags);- }-exit:- if (rc == 0)- PUT\_USER(rc, events, mask\_ptr);- return rc;-}--static int modem\_input\_wait(MGSLPC\_INFO \*info,int arg)-{- unsigned long flags;- int rc;- struct mgsl\_icount cprev, cnow;- DECLARE\_WAITQUEUE(wait, current);-- /\* save current irq counts \*/- spin\_lock\_irqsave(&info->lock, flags);- cprev = info->icount;- add\_wait\_queue(&info->status\_event\_wait\_q, &wait);- set\_current\_state(TASK\_INTERRUPTIBLE);- spin\_unlock\_irqrestore(&info->lock, flags);-- for(;;) {- schedule();- if (signal\_pending(current)) {- rc = -ERESTARTSYS;- break;- }-- /\* get new irq counts \*/- spin\_lock\_irqsave(&info->lock, flags);- cnow = info->icount;- set\_current\_state(TASK\_INTERRUPTIBLE);- spin\_unlock\_irqrestore(&info->lock, flags);-- /\* if no change, wait aborted for some reason \*/- if (cnow.rng == cprev.rng && cnow.dsr == cprev.dsr &&- cnow.dcd == cprev.dcd && cnow.cts == cprev.cts) {- rc = -EIO;- break;- }-- /\* check for change in caller specified modem input \*/- if ((arg & TIOCM\_RNG && cnow.rng != cprev.rng) ||- (arg & TIOCM\_DSR && cnow.dsr != cprev.dsr) ||- (arg & TIOCM\_CD && cnow.dcd != cprev.dcd) ||- (arg & TIOCM\_CTS && cnow.cts != cprev.cts)) {- rc = 0;- break;- }-- cprev = cnow;- }- remove\_wait\_queue(&info->status\_event\_wait\_q, &wait);- set\_current\_state(TASK\_RUNNING);- return rc;-}--/\* return the state of the serial control and status signals- \*/-static int tiocmget(struct tty\_struct \*tty)-{- MGSLPC\_INFO \*info = (MGSLPC\_INFO \*)tty->driver\_data;- unsigned int result;- unsigned long flags;-- spin\_lock\_irqsave(&info->lock, flags);- get\_signals(info);- spin\_unlock\_irqrestore(&info->lock, flags);-- result = ((info->serial\_signals & SerialSignal\_RTS) ? TIOCM\_RTS:0) +- ((info->serial\_signals & SerialSignal\_DTR) ? TIOCM\_DTR:0) +- ((info->serial\_signals & SerialSignal\_DCD) ? TIOCM\_CAR:0) +- ((info->serial\_signals & SerialSignal\_RI) ? TIOCM\_RNG:0) +- ((info->serial\_signals & SerialSignal\_DSR) ? TIOCM\_DSR:0) +- ((info->serial\_signals & SerialSignal\_CTS) ? TIOCM\_CTS:0);-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):%s tiocmget() value=%08X\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name, result);- return result;-}--/\* set modem control signals (DTR/RTS)- \*/-static int tiocmset(struct tty\_struct \*tty,- unsigned int set, unsigned int clear)-{- MGSLPC\_INFO \*info = (MGSLPC\_INFO \*)tty->driver\_data;- unsigned long flags;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):%s tiocmset(%x,%x)\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name, set, clear);-- if (set & TIOCM\_RTS)- info->serial\_signals |= SerialSignal\_RTS;- if (set & TIOCM\_DTR)- info->serial\_signals |= SerialSignal\_DTR;- if (clear & TIOCM\_RTS)- info->serial\_signals &= ~SerialSignal\_RTS;- if (clear & TIOCM\_DTR)- info->serial\_signals &= ~SerialSignal\_DTR;-- spin\_lock\_irqsave(&info->lock, flags);- set\_signals(info);- spin\_unlock\_irqrestore(&info->lock, flags);-- return 0;-}--/\* Set or clear transmit break condition- \*- \* Arguments: tty pointer to tty instance data- \* break\_state -1=set break condition, 0=clear- \*/-static int mgslpc\_break(struct tty\_struct \*tty, int break\_state)-{- MGSLPC\_INFO \* info = (MGSLPC\_INFO \*)tty->driver\_data;- unsigned long flags;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):mgslpc\_break(%s,%d)\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name, break\_state);-- if (mgslpc\_paranoia\_check(info, tty->name, "mgslpc\_break"))- return -EINVAL;-- spin\_lock\_irqsave(&info->lock, flags);- if (break\_state == -1)- set\_reg\_bits(info, CHA+DAFO, BIT6);- else- clear\_reg\_bits(info, CHA+DAFO, BIT6);- spin\_unlock\_irqrestore(&info->lock, flags);- return 0;-}--static int mgslpc\_get\_icount(struct tty\_struct \*tty,- struct serial\_icounter\_struct \*icount)-{- MGSLPC\_INFO \* info = (MGSLPC\_INFO \*)tty->driver\_data;- struct mgsl\_icount cnow; /\* kernel counter temps \*/- unsigned long flags;-- spin\_lock\_irqsave(&info->lock, flags);- cnow = info->icount;- spin\_unlock\_irqrestore(&info->lock, flags);-- icount->cts = cnow.cts;- icount->dsr = cnow.dsr;- icount->rng = cnow.rng;- icount->dcd = cnow.dcd;- icount->rx = cnow.rx;- icount->tx = cnow.tx;- icount->frame = cnow.frame;- icount->overrun = cnow.overrun;- icount->parity = cnow.parity;- icount->brk = cnow.brk;- icount->buf\_overrun = cnow.buf\_overrun;-- return 0;-}--/\* Service an IOCTL request- \*- \* Arguments:- \*- \* tty pointer to tty instance data- \* cmd IOCTL command code- \* arg command argument/context- \*- \* Return Value: 0 if success, otherwise error code- \*/-static int mgslpc\_ioctl(struct tty\_struct \*tty,- unsigned int cmd, unsigned long arg)-{- MGSLPC\_INFO \* info = (MGSLPC\_INFO \*)tty->driver\_data;- void \_\_user \*argp = (void \_\_user \*)arg;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):mgslpc\_ioctl %s cmd=%08X\n", \_\_FILE\_\_, \_\_LINE\_\_,- info->device\_name, cmd);-- if (mgslpc\_paranoia\_check(info, tty->name, "mgslpc\_ioctl"))- return -ENODEV;-- if (cmd != TIOCMIWAIT) {- if (tty\_io\_error(tty))- return -EIO;- }-- switch (cmd) {- case MGSL\_IOCGPARAMS:- return get\_params(info, argp);- case MGSL\_IOCSPARAMS:- return set\_params(info, argp, tty);- case MGSL\_IOCGTXIDLE:- return get\_txidle(info, argp);- case MGSL\_IOCSTXIDLE:- return set\_txidle(info, (int)arg);- case MGSL\_IOCGIF:- return get\_interface(info, argp);- case MGSL\_IOCSIF:- return set\_interface(info,(int)arg);- case MGSL\_IOCTXENABLE:- return set\_txenable(info,(int)arg, tty);- case MGSL\_IOCRXENABLE:- return set\_rxenable(info,(int)arg);- case MGSL\_IOCTXABORT:- return tx\_abort(info);- case MGSL\_IOCGSTATS:- return get\_stats(info, argp);- case MGSL\_IOCWAITEVENT:- return wait\_events(info, argp);- case TIOCMIWAIT:- return modem\_input\_wait(info,(int)arg);- default:- return -ENOIOCTLCMD;- }- return 0;-}--/\* Set new termios settings- \*- \* Arguments:- \*- \* tty pointer to tty structure- \* termios pointer to buffer to hold returned old termios- \*/-static void mgslpc\_set\_termios(struct tty\_struct \*tty,- const struct ktermios \*old\_termios)-{- MGSLPC\_INFO \*info = (MGSLPC\_INFO \*)tty->driver\_data;- unsigned long flags;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):mgslpc\_set\_termios %s\n", \_\_FILE\_\_, \_\_LINE\_\_,- tty->driver->name);-- /\* just return if nothing has changed \*/- if ((tty->termios.c\_cflag == old\_termios->c\_cflag)- && (RELEVANT\_IFLAG(tty->termios.c\_iflag)- == RELEVANT\_IFLAG(old\_termios->c\_iflag)))- return;-- mgslpc\_change\_params(info, tty);-- /\* Handle transition to B0 status \*/- if ((old\_termios->c\_cflag & CBAUD) && !C\_BAUD(tty)) {- info->serial\_signals &= ~(SerialSignal\_RTS | SerialSignal\_DTR);- spin\_lock\_irqsave(&info->lock, flags);- set\_signals(info);- spin\_unlock\_irqrestore(&info->lock, flags);- }-- /\* Handle transition away from B0 status \*/- if (!(old\_termios->c\_cflag & CBAUD) && C\_BAUD(tty)) {- info->serial\_signals |= SerialSignal\_DTR;- if (!C\_CRTSCTS(tty) || !tty\_throttled(tty))- info->serial\_signals |= SerialSignal\_RTS;- spin\_lock\_irqsave(&info->lock, flags);- set\_signals(info);- spin\_unlock\_irqrestore(&info->lock, flags);- }-- /\* Handle turning off CRTSCTS \*/- if (old\_termios->c\_cflag & CRTSCTS && !C\_CRTSCTS(tty)) {- tty->hw\_stopped = 0;- tx\_release(tty);- }-}--static void mgslpc\_close(struct tty\_struct \*tty, struct file \* filp)-{- MGSLPC\_INFO \* info = (MGSLPC\_INFO \*)tty->driver\_data;- struct tty\_port \*port = &info->port;-- if (mgslpc\_paranoia\_check(info, tty->name, "mgslpc\_close"))- return;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):mgslpc\_close(%s) entry, count=%d\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name, port->count);-- if (tty\_port\_close\_start(port, tty, filp) == 0)- goto cleanup;-- if (tty\_port\_initialized(port))- mgslpc\_wait\_until\_sent(tty, info->timeout);-- mgslpc\_flush\_buffer(tty);-- tty\_ldisc\_flush(tty);- shutdown(info, tty);- - tty\_port\_close\_end(port, tty);- tty\_port\_tty\_set(port, NULL);-cleanup:- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):mgslpc\_close(%s) exit, count=%d\n", \_\_FILE\_\_, \_\_LINE\_\_,- tty->driver->name, port->count);-}--/\* Wait until the transmitter is empty.- \*/-static void mgslpc\_wait\_until\_sent(struct tty\_struct \*tty, int timeout)-{- MGSLPC\_INFO \* info = (MGSLPC\_INFO \*)tty->driver\_data;- unsigned long orig\_jiffies, char\_time;-- if (!info)- return;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):mgslpc\_wait\_until\_sent(%s) entry\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name);-- if (mgslpc\_paranoia\_check(info, tty->name, "mgslpc\_wait\_until\_sent"))- return;-- if (!tty\_port\_initialized(&info->port))- goto exit;-- orig\_jiffies = jiffies;-- /\* Set check interval to 1/5 of estimated time to- \* send a character, and make it at least 1. The check- \* interval should also be less than the timeout.- \* Note: use tight timings here to satisfy the NIST-PCTS.- \*/-- if (info->params.data\_rate) {- char\_time = info->timeout/(32 \* 5);- if (!char\_time)- char\_time++;- } else- char\_time = 1;-- if (timeout)- char\_time = min\_t(unsigned long, char\_time, timeout);-- if (info->params.mode == MGSL\_MODE\_HDLC) {- while (info->tx\_active) {- msleep\_interruptible(jiffies\_to\_msecs(char\_time));- if (signal\_pending(current))- break;- if (timeout && time\_after(jiffies, orig\_jiffies + timeout))- break;- }- } else {- while ((info->tx\_count || info->tx\_active) &&- info->tx\_enabled) {- msleep\_interruptible(jiffies\_to\_msecs(char\_time));- if (signal\_pending(current))- break;- if (timeout && time\_after(jiffies, orig\_jiffies + timeout))- break;- }- }--exit:- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):mgslpc\_wait\_until\_sent(%s) exit\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name);-}--/\* Called by tty\_hangup() when a hangup is signaled.- \* This is the same as closing all open files for the port.- \*/-static void mgslpc\_hangup(struct tty\_struct \*tty)-{- MGSLPC\_INFO \* info = (MGSLPC\_INFO \*)tty->driver\_data;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):mgslpc\_hangup(%s)\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name);-- if (mgslpc\_paranoia\_check(info, tty->name, "mgslpc\_hangup"))- return;-- mgslpc\_flush\_buffer(tty);- shutdown(info, tty);- tty\_port\_hangup(&info->port);-}--static bool carrier\_raised(struct tty\_port \*port)-{- MGSLPC\_INFO \*info = container\_of(port, MGSLPC\_INFO, port);- unsigned long flags;-- spin\_lock\_irqsave(&info->lock, flags);- get\_signals(info);- spin\_unlock\_irqrestore(&info->lock, flags);-- return info->serial\_signals & SerialSignal\_DCD;-}--static void dtr\_rts(struct tty\_port \*port, bool active)-{- MGSLPC\_INFO \*info = container\_of(port, MGSLPC\_INFO, port);- unsigned long flags;-- spin\_lock\_irqsave(&info->lock, flags);- if (active)- info->serial\_signals |= SerialSignal\_RTS | SerialSignal\_DTR;- else- info->serial\_signals &= ~(SerialSignal\_RTS | SerialSignal\_DTR);- set\_signals(info);- spin\_unlock\_irqrestore(&info->lock, flags);-}---static int mgslpc\_open(struct tty\_struct \*tty, struct file \* filp)-{- MGSLPC\_INFO \*info;- struct tty\_port \*port;- int retval, line;- unsigned long flags;-- /\* verify range of specified line number \*/- line = tty->index;- if (line >= mgslpc\_device\_count) {- printk("%s(%d):mgslpc\_open with invalid line #%d.\n",- \_\_FILE\_\_, \_\_LINE\_\_, line);- return -ENODEV;- }-- /\* find the info structure for the specified line \*/- info = mgslpc\_device\_list;- while(info && info->line != line)- info = info->next\_device;- if (mgslpc\_paranoia\_check(info, tty->name, "mgslpc\_open"))- return -ENODEV;-- port = &info->port;- tty->driver\_data = info;- tty\_port\_tty\_set(port, tty);-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):mgslpc\_open(%s), old ref count = %d\n",- \_\_FILE\_\_, \_\_LINE\_\_, tty->driver->name, port->count);-- spin\_lock\_irqsave(&info->netlock, flags);- if (info->netcount) {- retval = -EBUSY;- spin\_unlock\_irqrestore(&info->netlock, flags);- goto cleanup;- }- spin\_lock(&port->lock);- port->count++;- spin\_unlock(&port->lock);- spin\_unlock\_irqrestore(&info->netlock, flags);-- if (port->count == 1) {- /\* 1st open on this device, init hardware \*/- retval = startup(info, tty);- if (retval < 0)- goto cleanup;- }-- retval = tty\_port\_block\_til\_ready(&info->port, tty, filp);- if (retval) {- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):block\_til\_ready(%s) returned %d\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name, retval);- goto cleanup;- }-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):mgslpc\_open(%s) success\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name);- retval = 0;--cleanup:- return retval;-}--/\*- \* /proc fs routines....- \*/--static inline void line\_info(struct seq\_file \*m, MGSLPC\_INFO \*info)-{- char stat\_buf[30];- unsigned long flags;-- seq\_printf(m, "%s:io:%04X irq:%d",- info->device\_name, info->io\_base, info->irq\_level);-- /\* output current serial signal states \*/- spin\_lock\_irqsave(&info->lock, flags);- get\_signals(info);- spin\_unlock\_irqrestore(&info->lock, flags);-- stat\_buf[0] = 0;- stat\_buf[1] = 0;- if (info->serial\_signals & SerialSignal\_RTS)- strcat(stat\_buf, "|RTS");- if (info->serial\_signals & SerialSignal\_CTS)- strcat(stat\_buf, "|CTS");- if (info->serial\_signals & SerialSignal\_DTR)- strcat(stat\_buf, "|DTR");- if (info->serial\_signals & SerialSignal\_DSR)- strcat(stat\_buf, "|DSR");- if (info->serial\_signals & SerialSignal\_DCD)- strcat(stat\_buf, "|CD");- if (info->serial\_signals & SerialSignal\_RI)- strcat(stat\_buf, "|RI");-- if (info->params.mode == MGSL\_MODE\_HDLC) {- seq\_printf(m, " HDLC txok:%d rxok:%d",- info->icount.txok, info->icount.rxok);- if (info->icount.txunder)- seq\_printf(m, " txunder:%d", info->icount.txunder);- if (info->icount.txabort)- seq\_printf(m, " txabort:%d", info->icount.txabort);- if (info->icount.rxshort)- seq\_printf(m, " rxshort:%d", info->icount.rxshort);- if (info->icount.rxlong)- seq\_printf(m, " rxlong:%d", info->icount.rxlong);- if (info->icount.rxover)- seq\_printf(m, " rxover:%d", info->icount.rxover);- if (info->icount.rxcrc)- seq\_printf(m, " rxcrc:%d", info->icount.rxcrc);- } else {- seq\_printf(m, " ASYNC tx:%d rx:%d",- info->icount.tx, info->icount.rx);- if (info->icount.frame)- seq\_printf(m, " fe:%d", info->icount.frame);- if (info->icount.parity)- seq\_printf(m, " pe:%d", info->icount.parity);- if (info->icount.brk)- seq\_printf(m, " brk:%d", info->icount.brk);- if (info->icount.overrun)- seq\_printf(m, " oe:%d", info->icount.overrun);- }-- /\* Append serial signal status to end \*/- seq\_printf(m, " %s\n", stat\_buf+1);-- seq\_printf(m, "txactive=%d bh\_req=%d bh\_run=%d pending\_bh=%x\n",- info->tx\_active,info->bh\_requested,info->bh\_running,- info->pending\_bh);-}--/\* Called to print information about devices- \*/-static int mgslpc\_proc\_show(struct seq\_file \*m, void \*v)-{- MGSLPC\_INFO \*info;-- seq\_printf(m, "synclink driver:%s\n", driver\_version);-- info = mgslpc\_device\_list;- while (info) {- line\_info(m, info);- info = info->next\_device;- }- return 0;-}--static int rx\_alloc\_buffers(MGSLPC\_INFO \*info)-{- /\* each buffer has header and data \*/- info->rx\_buf\_size = sizeof(RXBUF) + info->max\_frame\_size;-- /\* calculate total allocation size for 8 buffers \*/- info->rx\_buf\_total\_size = info->rx\_buf\_size \* 8;-- /\* limit total allocated memory \*/- if (info->rx\_buf\_total\_size > 0x10000)- info->rx\_buf\_total\_size = 0x10000;-- /\* calculate number of buffers \*/- info->rx\_buf\_count = info->rx\_buf\_total\_size / info->rx\_buf\_size;-- info->rx\_buf = kmalloc(info->rx\_buf\_total\_size, GFP\_KERNEL);- if (info->rx\_buf == NULL)- return -ENOMEM;-- /\* unused flag buffer to satisfy receive\_buf calling interface \*/- info->flag\_buf = kzalloc(info->max\_frame\_size, GFP\_KERNEL);- if (!info->flag\_buf) {- kfree(info->rx\_buf);- info->rx\_buf = NULL;- return -ENOMEM;- }- - rx\_reset\_buffers(info);- return 0;-}--static void rx\_free\_buffers(MGSLPC\_INFO \*info)-{- kfree(info->rx\_buf);- info->rx\_buf = NULL;- kfree(info->flag\_buf);- info->flag\_buf = NULL;-}--static int claim\_resources(MGSLPC\_INFO \*info)-{- if (rx\_alloc\_buffers(info) < 0) {- printk("Can't allocate rx buffer %s\n", info->device\_name);- release\_resources(info);- return -ENODEV;- }- return 0;-}--static void release\_resources(MGSLPC\_INFO \*info)-{- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("release\_resources(%s)\n", info->device\_name);- rx\_free\_buffers(info);-}--/\* Add the specified device instance data structure to the- \* global linked list of devices and increment the device count.- \*- \* Arguments: info pointer to device instance data- \*/-static int mgslpc\_add\_device(MGSLPC\_INFO \*info)-{- MGSLPC\_INFO \*current\_dev = NULL;- struct device \*tty\_dev;- int ret;-- info->next\_device = NULL;- info->line = mgslpc\_device\_count;- sprintf(info->device\_name,"ttySLP%d",info->line);-- if (info->line < MAX\_DEVICE\_COUNT) {- if (maxframe[info->line])- info->max\_frame\_size = maxframe[info->line];- }-- mgslpc\_device\_count++;-- if (!mgslpc\_device\_list)- mgslpc\_device\_list = info;- else {- current\_dev = mgslpc\_device\_list;- while (current\_dev->next\_device)- current\_dev = current\_dev->next\_device;- current\_dev->next\_device = info;- }-- if (info->max\_frame\_size < 4096)- info->max\_frame\_size = 4096;- else if (info->max\_frame\_size > 65535)- info->max\_frame\_size = 65535;-- printk("SyncLink PC Card %s:IO=%04X IRQ=%d\n",- info->device\_name, info->io\_base, info->irq\_level);--#if SYNCLINK\_GENERIC\_HDLC- ret = hdlcdev\_init(info);- if (ret != 0)- goto failed;-#endif-- tty\_dev = tty\_port\_register\_device(&info->port, serial\_driver, info->line,- &info->p\_dev->dev);- if (IS\_ERR(tty\_dev)) {- ret = PTR\_ERR(tty\_dev);-#if SYNCLINK\_GENERIC\_HDLC- hdlcdev\_exit(info);-#endif- goto failed;- }-- return 0;--failed:- if (current\_dev)- current\_dev->next\_device = NULL;- else- mgslpc\_device\_list = NULL;- mgslpc\_device\_count--;- return ret;-}--static void mgslpc\_remove\_device(MGSLPC\_INFO \*remove\_info)-{- MGSLPC\_INFO \*info = mgslpc\_device\_list;- MGSLPC\_INFO \*last = NULL;-- while(info) {- if (info == remove\_info) {- if (last)- last->next\_device = info->next\_device;- else- mgslpc\_device\_list = info->next\_device;- tty\_unregister\_device(serial\_driver, info->line);-#if SYNCLINK\_GENERIC\_HDLC- hdlcdev\_exit(info);-#endif- release\_resources(info);- tty\_port\_destroy(&info->port);- kfree(info);- mgslpc\_device\_count--;- return;- }- last = info;- info = info->next\_device;- }-}--static const struct pcmcia\_device\_id mgslpc\_ids[] = {- PCMCIA\_DEVICE\_MANF\_CARD(0x02c5, 0x0050),- PCMCIA\_DEVICE\_NULL-};-MODULE\_DEVICE\_TABLE(pcmcia, mgslpc\_ids);--static struct pcmcia\_driver mgslpc\_driver = {- .owner = THIS\_MODULE,- .name = "synclink\_cs",- .probe = mgslpc\_probe,- .remove = mgslpc\_detach,- .id\_table = mgslpc\_ids,- .suspend = mgslpc\_suspend,- .resume = mgslpc\_resume,-};--static const struct tty\_operations mgslpc\_ops = {- .open = mgslpc\_open,- .close = mgslpc\_close,- .write = mgslpc\_write,- .put\_char = mgslpc\_put\_char,- .flush\_chars = mgslpc\_flush\_chars,- .write\_room = mgslpc\_write\_room,- .chars\_in\_buffer = mgslpc\_chars\_in\_buffer,- .flush\_buffer = mgslpc\_flush\_buffer,- .ioctl = mgslpc\_ioctl,- .throttle = mgslpc\_throttle,- .unthrottle = mgslpc\_unthrottle,- .send\_xchar = mgslpc\_send\_xchar,- .break\_ctl = mgslpc\_break,- .wait\_until\_sent = mgslpc\_wait\_until\_sent,- .set\_termios = mgslpc\_set\_termios,- .stop = tx\_pause,- .start = tx\_release,- .hangup = mgslpc\_hangup,- .tiocmget = tiocmget,- .tiocmset = tiocmset,- .get\_icount = mgslpc\_get\_icount,- .proc\_show = mgslpc\_proc\_show,-};--static int \_\_init synclink\_cs\_init(void)-{- int rc;-- if (break\_on\_load) {- mgslpc\_get\_text\_ptr();- BREAKPOINT();- }-- serial\_driver = tty\_alloc\_driver(MAX\_DEVICE\_COUNT,- TTY\_DRIVER\_REAL\_RAW |- TTY\_DRIVER\_DYNAMIC\_DEV);- if (IS\_ERR(serial\_driver)) {- rc = PTR\_ERR(serial\_driver);- goto err;- }-- /\* Initialize the tty\_driver structure \*/- serial\_driver->driver\_name = "synclink\_cs";- serial\_driver->name = "ttySLP";- serial\_driver->major = ttymajor;- serial\_driver->minor\_start = 64;- serial\_driver->type = TTY\_DRIVER\_TYPE\_SERIAL;- serial\_driver->subtype = SERIAL\_TYPE\_NORMAL;- serial\_driver->init\_termios = tty\_std\_termios;- serial\_driver->init\_termios.c\_cflag =- B9600 | CS8 | CREAD | HUPCL | CLOCAL;- tty\_set\_operations(serial\_driver, &mgslpc\_ops);-- rc = tty\_register\_driver(serial\_driver);- if (rc < 0) {- printk(KERN\_ERR "%s(%d):Couldn't register serial driver\n",- \_\_FILE\_\_, \_\_LINE\_\_);- goto err\_put\_tty;- }-- rc = pcmcia\_register\_driver(&mgslpc\_driver);- if (rc < 0)- goto err\_unreg\_tty;-- printk(KERN\_INFO "%s %s, tty major#%d\n", driver\_name, driver\_version,- serial\_driver->major);-- return 0;-err\_unreg\_tty:- tty\_unregister\_driver(serial\_driver);-err\_put\_tty:- tty\_driver\_kref\_put(serial\_driver);-err:- return rc;-}--static void \_\_exit synclink\_cs\_exit(void)-{- pcmcia\_unregister\_driver(&mgslpc\_driver);- tty\_unregister\_driver(serial\_driver);- tty\_driver\_kref\_put(serial\_driver);-}--module\_init(synclink\_cs\_init);-module\_exit(synclink\_cs\_exit);--static void mgslpc\_set\_rate(MGSLPC\_INFO \*info, unsigned char channel, unsigned int rate)-{- unsigned int M, N;- unsigned char val;-- /\* note:standard BRG mode is broken in V3.2 chip- \* so enhanced mode is always used- \*/-- if (rate) {- N = 3686400 / rate;- if (!N)- N = 1;- N >>= 1;- for (M = 1; N > 64 && M < 16; M++)- N >>= 1;- N--;-- /\* BGR[5..0] = N- \* BGR[9..6] = M- \* BGR[7..0] contained in BGR register- \* BGR[9..8] contained in CCR2[7..6]- \* divisor = (N+1)\*2^M- \*- \* Note: M \*must\* not be zero (causes asymetric duty cycle)- \*/- write\_reg(info, (unsigned char) (channel + BGR),- (unsigned char) ((M << 6) + N));- val = read\_reg(info, (unsigned char) (channel + CCR2)) & 0x3f;- val |= ((M << 4) & 0xc0);- write\_reg(info, (unsigned char) (channel + CCR2), val);- }-}--/\* Enabled the AUX clock output at the specified frequency.- \*/-static void enable\_auxclk(MGSLPC\_INFO \*info)-{- unsigned char val;-- /\* MODE- \*- \* 07..06 MDS[1..0] 10 = transparent HDLC mode- \* 05 ADM Address Mode, 0 = no addr recognition- \* 04 TMD Timer Mode, 0 = external- \* 03 RAC Receiver Active, 0 = inactive- \* 02 RTS 0=RTS active during xmit, 1=RTS always active- \* 01 TRS Timer Resolution, 1=512- \* 00 TLP Test Loop, 0 = no loop- \*- \* 1000 0010- \*/- val = 0x82;-- /\* channel B RTS is used to enable AUXCLK driver on SP505 \*/- if (info->params.mode == MGSL\_MODE\_HDLC && info->params.clock\_speed)- val |= BIT2;- write\_reg(info, CHB + MODE, val);-- /\* CCR0- \*- \* 07 PU Power Up, 1=active, 0=power down- \* 06 MCE Master Clock Enable, 1=enabled- \* 05 Reserved, 0- \* 04..02 SC[2..0] Encoding- \* 01..00 SM[1..0] Serial Mode, 00=HDLC- \*- \* 11000000- \*/- write\_reg(info, CHB + CCR0, 0xc0);-- /\* CCR1- \*- \* 07 SFLG Shared Flag, 0 = disable shared flags- \* 06 GALP Go Active On Loop, 0 = not used- \* 05 GLP Go On Loop, 0 = not used- \* 04 ODS Output Driver Select, 1=TxD is push-pull output- \* 03 ITF Interframe Time Fill, 0=mark, 1=flag- \* 02..00 CM[2..0] Clock Mode- \*- \* 0001 0111- \*/- write\_reg(info, CHB + CCR1, 0x17);-- /\* CCR2 (Channel B)- \*- \* 07..06 BGR[9..8] Baud rate bits 9..8- \* 05 BDF Baud rate divisor factor, 0=1, 1=BGR value- \* 04 SSEL Clock source select, 1=submode b- \* 03 TOE 0=TxCLK is input, 1=TxCLK is output- \* 02 RWX Read/Write Exchange 0=disabled- \* 01 C32, CRC select, 0=CRC-16, 1=CRC-32- \* 00 DIV, data inversion 0=disabled, 1=enabled- \*- \* 0011 1000- \*/- if (info->params.mode == MGSL\_MODE\_HDLC && info->params.clock\_speed)- write\_reg(info, CHB + CCR2, 0x38);- else- write\_reg(info, CHB + CCR2, 0x30);-- /\* CCR4- \*- \* 07 MCK4 Master Clock Divide by 4, 1=enabled- \* 06 EBRG Enhanced Baud Rate Generator Mode, 1=enabled- \* 05 TST1 Test Pin, 0=normal operation- \* 04 ICD Ivert Carrier Detect, 1=enabled (active low)- \* 03..02 Reserved, must be 0- \* 01..00 RFT[1..0] RxFIFO Threshold 00=32 bytes- \*- \* 0101 0000- \*/- write\_reg(info, CHB + CCR4, 0x50);-- /\* if auxclk not enabled, set internal BRG so- \* CTS transitions can be detected (requires TxC)- \*/- if (info->params.mode == MGSL\_MODE\_HDLC && info->params.clock\_speed)- mgslpc\_set\_rate(info, CHB, info->params.clock\_speed);- else- mgslpc\_set\_rate(info, CHB, 921600);-}--static void loopback\_enable(MGSLPC\_INFO \*info)-{- unsigned char val;-- /\* CCR1:02..00 CM[2..0] Clock Mode = 111 (clock mode 7) \*/- val = read\_reg(info, CHA + CCR1) | (BIT2 | BIT1 | BIT0);- write\_reg(info, CHA + CCR1, val);-- /\* CCR2:04 SSEL Clock source select, 1=submode b \*/- val = read\_reg(info, CHA + CCR2) | (BIT4 | BIT5);- write\_reg(info, CHA + CCR2, val);-- /\* set LinkSpeed if available, otherwise default to 2Mbps \*/- if (info->params.clock\_speed)- mgslpc\_set\_rate(info, CHA, info->params.clock\_speed);- else- mgslpc\_set\_rate(info, CHA, 1843200);-- /\* MODE:00 TLP Test Loop, 1=loopback enabled \*/- val = read\_reg(info, CHA + MODE) | BIT0;- write\_reg(info, CHA + MODE, val);-}--static void hdlc\_mode(MGSLPC\_INFO \*info)-{- unsigned char val;- unsigned char clkmode, clksubmode;-- /\* disable all interrupts \*/- irq\_disable(info, CHA, 0xffff);- irq\_disable(info, CHB, 0xffff);- port\_irq\_disable(info, 0xff);-- /\* assume clock mode 0a, rcv=RxC xmt=TxC \*/- clkmode = clksubmode = 0;- if (info->params.flags & HDLC\_FLAG\_RXC\_DPLL- && info->params.flags & HDLC\_FLAG\_TXC\_DPLL) {- /\* clock mode 7a, rcv = DPLL, xmt = DPLL \*/- clkmode = 7;- } else if (info->params.flags & HDLC\_FLAG\_RXC\_BRG- && info->params.flags & HDLC\_FLAG\_TXC\_BRG) {- /\* clock mode 7b, rcv = BRG, xmt = BRG \*/- clkmode = 7;- clksubmode = 1;- } else if (info->params.flags & HDLC\_FLAG\_RXC\_DPLL) {- if (info->params.flags & HDLC\_FLAG\_TXC\_BRG) {- /\* clock mode 6b, rcv = DPLL, xmt = BRG/16 \*/- clkmode = 6;- clksubmode = 1;- } else {- /\* clock mode 6a, rcv = DPLL, xmt = TxC \*/- clkmode = 6;- }- } else if (info->params.flags & HDLC\_FLAG\_TXC\_BRG) {- /\* clock mode 0b, rcv = RxC, xmt = BRG \*/- clksubmode = 1;- }-- /\* MODE- \*- \* 07..06 MDS[1..0] 10 = transparent HDLC mode- \* 05 ADM Address Mode, 0 = no addr recognition- \* 04 TMD Timer Mode, 0 = external- \* 03 RAC Receiver Active, 0 = inactive- \* 02 RTS 0=RTS active during xmit, 1=RTS always active- \* 01 TRS Timer Resolution, 1=512- \* 00 TLP Test Loop, 0 = no loop- \*- \* 1000 0010- \*/- val = 0x82;- if (info->params.loopback)- val |= BIT0;-- /\* preserve RTS state \*/- if (info->serial\_signals & SerialSignal\_RTS)- val |= BIT2;- write\_reg(info, CHA + MODE, val);-- /\* CCR0- \*- \* 07 PU Power Up, 1=active, 0=power down- \* 06 MCE Master Clock Enable, 1=enabled- \* 05 Reserved, 0- \* 04..02 SC[2..0] Encoding- \* 01..00 SM[1..0] Serial Mode, 00=HDLC- \*- \* 11000000- \*/- val = 0xc0;- switch (info->params.encoding)- {- case HDLC\_ENCODING\_NRZI:- val |= BIT3;- break;- case HDLC\_ENCODING\_BIPHASE\_SPACE:- val |= BIT4;- break; // FM0- case HDLC\_ENCODING\_BIPHASE\_MARK:- val |= BIT4 | BIT2;- break; // FM1- case HDLC\_ENCODING\_BIPHASE\_LEVEL:- val |= BIT4 | BIT3;- break; // Manchester- }- write\_reg(info, CHA + CCR0, val);-- /\* CCR1- \*- \* 07 SFLG Shared Flag, 0 = disable shared flags- \* 06 GALP Go Active On Loop, 0 = not used- \* 05 GLP Go On Loop, 0 = not used- \* 04 ODS Output Driver Select, 1=TxD is push-pull output- \* 03 ITF Interframe Time Fill, 0=mark, 1=flag- \* 02..00 CM[2..0] Clock Mode- \*- \* 0001 0000- \*/- val = 0x10 + clkmode;- write\_reg(info, CHA + CCR1, val);-- /\* CCR2- \*- \* 07..06 BGR[9..8] Baud rate bits 9..8- \* 05 BDF Baud rate divisor factor, 0=1, 1=BGR value- \* 04 SSEL Clock source select, 1=submode b- \* 03 TOE 0=TxCLK is input, 0=TxCLK is input- \* 02 RWX Read/Write Exchange 0=disabled- \* 01 C32, CRC select, 0=CRC-16, 1=CRC-32- \* 00 DIV, data inversion 0=disabled, 1=enabled- \*- \* 0000 0000- \*/- val = 0x00;- if (clkmode == 2 || clkmode == 3 || clkmode == 6- || clkmode == 7 || (clkmode == 0 && clksubmode == 1))- val |= BIT5;- if (clksubmode)- val |= BIT4;- if (info->params.crc\_type == HDLC\_CRC\_32\_CCITT)- val |= BIT1;- if (info->params.encoding == HDLC\_ENCODING\_NRZB)- val |= BIT0;- write\_reg(info, CHA + CCR2, val);-- /\* CCR3- \*- \* 07..06 PRE[1..0] Preamble count 00=1, 01=2, 10=4, 11=8- \* 05 EPT Enable preamble transmission, 1=enabled- \* 04 RADD Receive address pushed to FIFO, 0=disabled- \* 03 CRL CRC Reset Level, 0=FFFF- \* 02 RCRC Rx CRC 0=On 1=Off- \* 01 TCRC Tx CRC 0=On 1=Off- \* 00 PSD DPLL Phase Shift Disable- \*- \* 0000 0000- \*/- val = 0x00;- if (info->params.crc\_type == HDLC\_CRC\_NONE)- val |= BIT2 | BIT1;- if (info->params.preamble != HDLC\_PREAMBLE\_PATTERN\_NONE)- val |= BIT5;- switch (info->params.preamble\_length)- {- case HDLC\_PREAMBLE\_LENGTH\_16BITS:- val |= BIT6;- break;- case HDLC\_PREAMBLE\_LENGTH\_32BITS:- val |= BIT6;- break;- case HDLC\_PREAMBLE\_LENGTH\_64BITS:- val |= BIT7 | BIT6;- break;- }- write\_reg(info, CHA + CCR3, val);-- /\* PRE - Preamble pattern \*/- val = 0;- switch (info->params.preamble)- {- case HDLC\_PREAMBLE\_PATTERN\_FLAGS: val = 0x7e; break;- case HDLC\_PREAMBLE\_PATTERN\_10: val = 0xaa; break;- case HDLC\_PREAMBLE\_PATTERN\_01: val = 0x55; break;- case HDLC\_PREAMBLE\_PATTERN\_ONES: val = 0xff; break;- }- write\_reg(info, CHA + PRE, val);-- /\* CCR4- \*- \* 07 MCK4 Master Clock Divide by 4, 1=enabled- \* 06 EBRG Enhanced Baud Rate Generator Mode, 1=enabled- \* 05 TST1 Test Pin, 0=normal operation- \* 04 ICD Ivert Carrier Detect, 1=enabled (active low)- \* 03..02 Reserved, must be 0- \* 01..00 RFT[1..0] RxFIFO Threshold 00=32 bytes- \*- \* 0101 0000- \*/- val = 0x50;- write\_reg(info, CHA + CCR4, val);- if (info->params.flags & HDLC\_FLAG\_RXC\_DPLL)- mgslpc\_set\_rate(info, CHA, info->params.clock\_speed \* 16);- else- mgslpc\_set\_rate(info, CHA, info->params.clock\_speed);-- /\* RLCR Receive length check register- \*- \* 7 1=enable receive length check- \* 6..0 Max frame length = (RL + 1) \* 32- \*/- write\_reg(info, CHA + RLCR, 0);-- /\* XBCH Transmit Byte Count High- \*- \* 07 DMA mode, 0 = interrupt driven- \* 06 NRM, 0=ABM (ignored)- \* 05 CAS Carrier Auto Start- \* 04 XC Transmit Continuously (ignored)- \* 03..00 XBC[10..8] Transmit byte count bits 10..8- \*- \* 0000 0000- \*/- val = 0x00;- if (info->params.flags & HDLC\_FLAG\_AUTO\_DCD)- val |= BIT5;- write\_reg(info, CHA + XBCH, val);- enable\_auxclk(info);- if (info->params.loopback || info->testing\_irq)- loopback\_enable(info);- if (info->params.flags & HDLC\_FLAG\_AUTO\_CTS)- {- irq\_enable(info, CHB, IRQ\_CTS);- /\* PVR[3] 1=AUTO CTS active \*/- set\_reg\_bits(info, CHA + PVR, BIT3);- } else- clear\_reg\_bits(info, CHA + PVR, BIT3);-- irq\_enable(info, CHA,- IRQ\_RXEOM | IRQ\_RXFIFO | IRQ\_ALLSENT |- IRQ\_UNDERRUN | IRQ\_TXFIFO);- issue\_command(info, CHA, CMD\_TXRESET + CMD\_RXRESET);- wait\_command\_complete(info, CHA);- read\_reg16(info, CHA + ISR); /\* clear pending IRQs \*/-- /\* Master clock mode enabled above to allow reset commands- \* to complete even if no data clocks are present.- \*- \* Disable master clock mode for normal communications because- \* V3.2 of the ESCC2 has a bug that prevents the transmit all sent- \* IRQ when in master clock mode.- \*- \* Leave master clock mode enabled for IRQ test because the- \* timer IRQ used by the test can only happen in master clock mode.- \*/- if (!info->testing\_irq)- clear\_reg\_bits(info, CHA + CCR0, BIT6);-- tx\_set\_idle(info);-- tx\_stop(info);- rx\_stop(info);-}--static void rx\_stop(MGSLPC\_INFO \*info)-{- if (debug\_level >= DEBUG\_LEVEL\_ISR)- printk("%s(%d):rx\_stop(%s)\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name);-- /\* MODE:03 RAC Receiver Active, 0=inactive \*/- clear\_reg\_bits(info, CHA + MODE, BIT3);-- info->rx\_enabled = false;- info->rx\_overflow = false;-}--static void rx\_start(MGSLPC\_INFO \*info)-{- if (debug\_level >= DEBUG\_LEVEL\_ISR)- printk("%s(%d):rx\_start(%s)\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name);-- rx\_reset\_buffers(info);- info->rx\_enabled = false;- info->rx\_overflow = false;-- /\* MODE:03 RAC Receiver Active, 1=active \*/- set\_reg\_bits(info, CHA + MODE, BIT3);-- info->rx\_enabled = true;-}--static void tx\_start(MGSLPC\_INFO \*info, struct tty\_struct \*tty)-{- if (debug\_level >= DEBUG\_LEVEL\_ISR)- printk("%s(%d):tx\_start(%s)\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name);-- if (info->tx\_count) {- /\* If auto RTS enabled and RTS is inactive, then assert \*/- /\* RTS and set a flag indicating that the driver should \*/- /\* negate RTS when the transmission completes. \*/- info->drop\_rts\_on\_tx\_done = false;-- if (info->params.flags & HDLC\_FLAG\_AUTO\_RTS) {- get\_signals(info);- if (!(info->serial\_signals & SerialSignal\_RTS)) {- info->serial\_signals |= SerialSignal\_RTS;- set\_signals(info);- info->drop\_rts\_on\_tx\_done = true;- }- }-- if (info->params.mode == MGSL\_MODE\_ASYNC) {- if (!info->tx\_active) {- info->tx\_active = true;- tx\_ready(info, tty);- }- } else {- info->tx\_active = true;- tx\_ready(info, tty);- mod\_timer(&info->tx\_timer, jiffies +- msecs\_to\_jiffies(5000));- }- }-- if (!info->tx\_enabled)- info->tx\_enabled = true;-}--static void tx\_stop(MGSLPC\_INFO \*info)-{- if (debug\_level >= DEBUG\_LEVEL\_ISR)- printk("%s(%d):tx\_stop(%s)\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name);-- del\_timer(&info->tx\_timer);-- info->tx\_enabled = false;- info->tx\_active = false;-}--/\* Reset the adapter to a known state and prepare it for further use.- \*/-static void reset\_device(MGSLPC\_INFO \*info)-{- /\* power up both channels (set BIT7) \*/- write\_reg(info, CHA + CCR0, 0x80);- write\_reg(info, CHB + CCR0, 0x80);- write\_reg(info, CHA + MODE, 0);- write\_reg(info, CHB + MODE, 0);-- /\* disable all interrupts \*/- irq\_disable(info, CHA, 0xffff);- irq\_disable(info, CHB, 0xffff);- port\_irq\_disable(info, 0xff);-- /\* PCR Port Configuration Register- \*- \* 07..04 DEC[3..0] Serial I/F select outputs- \* 03 output, 1=AUTO CTS control enabled- \* 02 RI Ring Indicator input 0=active- \* 01 DSR input 0=active- \* 00 DTR output 0=active- \*- \* 0000 0110- \*/- write\_reg(info, PCR, 0x06);-- /\* PVR Port Value Register- \*- \* 07..04 DEC[3..0] Serial I/F select (0000=disabled)- \* 03 AUTO CTS output 1=enabled- \* 02 RI Ring Indicator input- \* 01 DSR input- \* 00 DTR output (1=inactive)- \*- \* 0000 0001- \*/-// write\_reg(info, PVR, PVR\_DTR);-- /\* IPC Interrupt Port Configuration- \*- \* 07 VIS 1=Masked interrupts visible- \* 06..05 Reserved, 0- \* 04..03 SLA Slave address, 00 ignored- \* 02 CASM Cascading Mode, 1=daisy chain- \* 01..00 IC[1..0] Interrupt Config, 01=push-pull output, active low- \*- \* 0000 0101- \*/- write\_reg(info, IPC, 0x05);-}--static void async\_mode(MGSLPC\_INFO \*info)-{- unsigned char val;-- /\* disable all interrupts \*/- irq\_disable(info, CHA, 0xffff);- irq\_disable(info, CHB, 0xffff);- port\_irq\_disable(info, 0xff);-- /\* MODE- \*- \* 07 Reserved, 0- \* 06 FRTS RTS State, 0=active- \* 05 FCTS Flow Control on CTS- \* 04 FLON Flow Control Enable- \* 03 RAC Receiver Active, 0 = inactive- \* 02 RTS 0=Auto RTS, 1=manual RTS- \* 01 TRS Timer Resolution, 1=512- \* 00 TLP Test Loop, 0 = no loop- \*- \* 0000 0110- \*/- val = 0x06;- if (info->params.loopback)- val |= BIT0;-- /\* preserve RTS state \*/- if (!(info->serial\_signals & SerialSignal\_RTS))- val |= BIT6;- write\_reg(info, CHA + MODE, val);-- /\* CCR0- \*- \* 07 PU Power Up, 1=active, 0=power down- \* 06 MCE Master Clock Enable, 1=enabled- \* 05 Reserved, 0- \* 04..02 SC[2..0] Encoding, 000=NRZ- \* 01..00 SM[1..0] Serial Mode, 11=Async- \*- \* 1000 0011- \*/- write\_reg(info, CHA + CCR0, 0x83);-- /\* CCR1- \*- \* 07..05 Reserved, 0- \* 04 ODS Output Driver Select, 1=TxD is push-pull output- \* 03 BCR Bit Clock Rate, 1=16x- \* 02..00 CM[2..0] Clock Mode, 111=BRG- \*- \* 0001 1111- \*/- write\_reg(info, CHA + CCR1, 0x1f);-- /\* CCR2 (channel A)- \*- \* 07..06 BGR[9..8] Baud rate bits 9..8- \* 05 BDF Baud rate divisor factor, 0=1, 1=BGR value- \* 04 SSEL Clock source select, 1=submode b- \* 03 TOE 0=TxCLK is input, 0=TxCLK is input- \* 02 RWX Read/Write Exchange 0=disabled- \* 01 Reserved, 0- \* 00 DIV, data inversion 0=disabled, 1=enabled- \*- \* 0001 0000- \*/- write\_reg(info, CHA + CCR2, 0x10);-- /\* CCR3- \*- \* 07..01 Reserved, 0- \* 00 PSD DPLL Phase Shift Disable- \*- \* 0000 0000- \*/- write\_reg(info, CHA + CCR3, 0);-- /\* CCR4- \*- \* 07 MCK4 Master Clock Divide by 4, 1=enabled- \* 06 EBRG Enhanced Baud Rate Generator Mode, 1=enabled- \* 05 TST1 Test Pin, 0=normal operation- \* 04 ICD Ivert Carrier Detect, 1=enabled (active low)- \* 03..00 Reserved, must be 0- \*- \* 0101 0000- \*/- write\_reg(info, CHA + CCR4, 0x50);- mgslpc\_set\_rate(info, CHA, info->params.data\_rate \* 16);-- /\* DAFO Data Format- \*- \* 07 Reserved, 0- \* 06 XBRK transmit break, 0=normal operation- \* 05 Stop bits (0=1, 1=2)- \* 04..03 PAR[1..0] Parity (01=odd, 10=even)- \* 02 PAREN Parity Enable- \* 01..00 CHL[1..0] Character Length (00=8, 01=7)- \*- \*/- val = 0x00;- if (info->params.data\_bits != 8)- val |= BIT0; /\* 7 bits \*/- if (info->params.stop\_bits != 1)- val |= BIT5;- if (info->params.parity != ASYNC\_PARITY\_NONE)- {- val |= BIT2; /\* Parity enable \*/- if (info->params.parity == ASYNC\_PARITY\_ODD)- val |= BIT3;- else- val |= BIT4;- }- write\_reg(info, CHA + DAFO, val);-- /\* RFC Rx FIFO Control- \*- \* 07 Reserved, 0- \* 06 DPS, 1=parity bit not stored in data byte- \* 05 DXS, 0=all data stored in FIFO (including XON/XOFF)- \* 04 RFDF Rx FIFO Data Format, 1=status byte stored in FIFO- \* 03..02 RFTH[1..0], rx threshold, 11=16 status + 16 data byte- \* 01 Reserved, 0- \* 00 TCDE Terminate Char Detect Enable, 0=disabled- \*- \* 0101 1100- \*/- write\_reg(info, CHA + RFC, 0x5c);-- /\* RLCR Receive length check register- \*- \* Max frame length = (RL + 1) \* 32- \*/- write\_reg(info, CHA + RLCR, 0);-- /\* XBCH Transmit Byte Count High- \*- \* 07 DMA mode, 0 = interrupt driven- \* 06 NRM, 0=ABM (ignored)- \* 05 CAS Carrier Auto Start- \* 04 XC Transmit Continuously (ignored)- \* 03..00 XBC[10..8] Transmit byte count bits 10..8- \*- \* 0000 0000- \*/- val = 0x00;- if (info->params.flags & HDLC\_FLAG\_AUTO\_DCD)- val |= BIT5;- write\_reg(info, CHA + XBCH, val);- if (info->params.flags & HDLC\_FLAG\_AUTO\_CTS)- irq\_enable(info, CHA, IRQ\_CTS);-- /\* MODE:03 RAC Receiver Active, 1=active \*/- set\_reg\_bits(info, CHA + MODE, BIT3);- enable\_auxclk(info);- if (info->params.flags & HDLC\_FLAG\_AUTO\_CTS) {- irq\_enable(info, CHB, IRQ\_CTS);- /\* PVR[3] 1=AUTO CTS active \*/- set\_reg\_bits(info, CHA + PVR, BIT3);- } else- clear\_reg\_bits(info, CHA + PVR, BIT3);- irq\_enable(info, CHA,- IRQ\_RXEOM | IRQ\_RXFIFO | IRQ\_BREAK\_ON | IRQ\_RXTIME |- IRQ\_ALLSENT | IRQ\_TXFIFO);- issue\_command(info, CHA, CMD\_TXRESET + CMD\_RXRESET);- wait\_command\_complete(info, CHA);- read\_reg16(info, CHA + ISR); /\* clear pending IRQs \*/-}--/\* Set the HDLC idle mode for the transmitter.- \*/-static void tx\_set\_idle(MGSLPC\_INFO \*info)-{- /\* Note: ESCC2 only supports flags and one idle modes \*/- if (info->idle\_mode == HDLC\_TXIDLE\_FLAGS)- set\_reg\_bits(info, CHA + CCR1, BIT3);- else- clear\_reg\_bits(info, CHA + CCR1, BIT3);-}--/\* get state of the V24 status (input) signals.- \*/-static void get\_signals(MGSLPC\_INFO \*info)-{- unsigned char status = 0;-- /\* preserve RTS and DTR \*/- info->serial\_signals &= SerialSignal\_RTS | SerialSignal\_DTR;-- if (read\_reg(info, CHB + VSTR) & BIT7)- info->serial\_signals |= SerialSignal\_DCD;- if (read\_reg(info, CHB + STAR) & BIT1)- info->serial\_signals |= SerialSignal\_CTS;-- status = read\_reg(info, CHA + PVR);- if (!(status & PVR\_RI))- info->serial\_signals |= SerialSignal\_RI;- if (!(status & PVR\_DSR))- info->serial\_signals |= SerialSignal\_DSR;-}--/\* Set the state of RTS and DTR based on contents of- \* serial\_signals member of device extension.- \*/-static void set\_signals(MGSLPC\_INFO \*info)-{- unsigned char val;-- val = read\_reg(info, CHA + MODE);- if (info->params.mode == MGSL\_MODE\_ASYNC) {- if (info->serial\_signals & SerialSignal\_RTS)- val &= ~BIT6;- else- val |= BIT6;- } else {- if (info->serial\_signals & SerialSignal\_RTS)- val |= BIT2;- else- val &= ~BIT2;- }- write\_reg(info, CHA + MODE, val);-- if (info->serial\_signals & SerialSignal\_DTR)- clear\_reg\_bits(info, CHA + PVR, PVR\_DTR);- else- set\_reg\_bits(info, CHA + PVR, PVR\_DTR);-}--static void rx\_reset\_buffers(MGSLPC\_INFO \*info)-{- RXBUF \*buf;- int i;-- info->rx\_put = 0;- info->rx\_get = 0;- info->rx\_frame\_count = 0;- for (i=0 ; i < info->rx\_buf\_count ; i++) {- buf = (RXBUF\*)(info->rx\_buf + (i \* info->rx\_buf\_size));- buf->status = buf->count = 0;- }-}--/\* Attempt to return a received HDLC frame- \* Only frames received without errors are returned.- \*- \* Returns true if frame returned, otherwise false- \*/-static bool rx\_get\_frame(MGSLPC\_INFO \*info, struct tty\_struct \*tty)-{- unsigned short status;- RXBUF \*buf;- unsigned int framesize = 0;- unsigned long flags;- bool return\_frame = false;-- if (info->rx\_frame\_count == 0)- return false;-- buf = (RXBUF\*)(info->rx\_buf + (info->rx\_get \* info->rx\_buf\_size));-- status = buf->status;-- /\* 07 VFR 1=valid frame- \* 06 RDO 1=data overrun- \* 05 CRC 1=OK, 0=error- \* 04 RAB 1=frame aborted- \*/- if ((status & 0xf0) != 0xA0) {- if (!(status & BIT7) || (status & BIT4))- info->icount.rxabort++;- else if (status & BIT6)- info->icount.rxover++;- else if (!(status & BIT5)) {- info->icount.rxcrc++;- if (info->params.crc\_type & HDLC\_CRC\_RETURN\_EX)- return\_frame = true;- }- framesize = 0;-#if SYNCLINK\_GENERIC\_HDLC- {- info->netdev->stats.rx\_errors++;- info->netdev->stats.rx\_frame\_errors++;- }-#endif- } else- return\_frame = true;-- if (return\_frame)- framesize = buf->count;-- if (debug\_level >= DEBUG\_LEVEL\_BH)- printk("%s(%d):rx\_get\_frame(%s) status=%04X size=%d\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name, status, framesize);-- if (debug\_level >= DEBUG\_LEVEL\_DATA)- trace\_block(info, buf->data, framesize, 0);-- if (framesize) {- if ((info->params.crc\_type & HDLC\_CRC\_RETURN\_EX &&- framesize+1 > info->max\_frame\_size) ||- framesize > info->max\_frame\_size)- info->icount.rxlong++;- else {- if (status & BIT5)- info->icount.rxok++;-- if (info->params.crc\_type & HDLC\_CRC\_RETURN\_EX) {- \*(buf->data + framesize) = status & BIT5 ? RX\_OK:RX\_CRC\_ERROR;- ++framesize;- }--#if SYNCLINK\_GENERIC\_HDLC- if (info->netcount)- hdlcdev\_rx(info, buf->data, framesize);- else-#endif- ldisc\_receive\_buf(tty, buf->data, info->flag\_buf, framesize);- }- }-- spin\_lock\_irqsave(&info->lock, flags);- buf->status = buf->count = 0;- info->rx\_frame\_count--;- info->rx\_get++;- if (info->rx\_get >= info->rx\_buf\_count)- info->rx\_get = 0;- spin\_unlock\_irqrestore(&info->lock, flags);-- return true;-}--static bool register\_test(MGSLPC\_INFO \*info)-{- static unsigned char patterns[] =- { 0x00, 0xff, 0xaa, 0x55, 0x69, 0x96, 0x0f };- static unsigned int count = ARRAY\_SIZE(patterns);- unsigned int i;- bool rc = true;- unsigned long flags;-- spin\_lock\_irqsave(&info->lock, flags);- reset\_device(info);-- for (i = 0; i < count; i++) {- write\_reg(info, XAD1, patterns[i]);- write\_reg(info, XAD2, patterns[(i + 1) % count]);- if ((read\_reg(info, XAD1) != patterns[i]) ||- (read\_reg(info, XAD2) != patterns[(i + 1) % count])) {- rc = false;- break;- }- }-- spin\_unlock\_irqrestore(&info->lock, flags);- return rc;-}--static bool irq\_test(MGSLPC\_INFO \*info)-{- unsigned long end\_time;- unsigned long flags;-- spin\_lock\_irqsave(&info->lock, flags);- reset\_device(info);-- info->testing\_irq = true;- hdlc\_mode(info);-- info->irq\_occurred = false;-- /\* init hdlc mode \*/-- irq\_enable(info, CHA, IRQ\_TIMER);- write\_reg(info, CHA + TIMR, 0); /\* 512 cycles \*/- issue\_command(info, CHA, CMD\_START\_TIMER);-- spin\_unlock\_irqrestore(&info->lock, flags);-- end\_time=100;- while(end\_time-- && !info->irq\_occurred) {- msleep\_interruptible(10);- }-- info->testing\_irq = false;-- spin\_lock\_irqsave(&info->lock, flags);- reset\_device(info);- spin\_unlock\_irqrestore(&info->lock, flags);-- return info->irq\_occurred;-}--static int adapter\_test(MGSLPC\_INFO \*info)-{- if (!register\_test(info)) {- info->init\_error = DiagStatus\_AddressFailure;- printk("%s(%d):Register test failure for device %s Addr=%04X\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name, (unsigned short)(info->io\_base));- return -ENODEV;- }-- if (!irq\_test(info)) {- info->init\_error = DiagStatus\_IrqFailure;- printk("%s(%d):Interrupt test failure for device %s IRQ=%d\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name, (unsigned short)(info->irq\_level));- return -ENODEV;- }-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):device %s passed diagnostics\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name);- return 0;-}--static void trace\_block(MGSLPC\_INFO \*info,const char\* data, int count, int xmit)-{- int i;- int linecount;- if (xmit)- printk("%s tx data:\n", info->device\_name);- else- printk("%s rx data:\n", info->device\_name);-- while(count) {- if (count > 16)- linecount = 16;- else- linecount = count;-- for(i=0;i<linecount;i++)- printk("%02X ", (unsigned char)data[i]);- for(;i<17;i++)- printk(" ");- for(i=0;i<linecount;i++) {- if (data[i]>=040 && data[i]<=0176)- printk("%c", data[i]);- else- printk(".");- }- printk("\n");-- data += linecount;- count -= linecount;- }-}--/\* HDLC frame time out- \* update stats and do tx completion processing- \*/-static void tx\_timeout(struct timer\_list \*t)-{- MGSLPC\_INFO \*info = from\_timer(info, t, tx\_timer);- unsigned long flags;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s(%d):tx\_timeout(%s)\n",- \_\_FILE\_\_, \_\_LINE\_\_, info->device\_name);- if (info->tx\_active &&- info->params.mode == MGSL\_MODE\_HDLC) {- info->icount.txtimeout++;- }- spin\_lock\_irqsave(&info->lock, flags);- info->tx\_active = false;- info->tx\_count = info->tx\_put = info->tx\_get = 0;-- spin\_unlock\_irqrestore(&info->lock, flags);--#if SYNCLINK\_GENERIC\_HDLC- if (info->netcount)- hdlcdev\_tx\_done(info);- else-#endif- {- struct tty\_struct \*tty = tty\_port\_tty\_get(&info->port);- bh\_transmit(info, tty);- tty\_kref\_put(tty);- }-}--#if SYNCLINK\_GENERIC\_HDLC--/\*- \* called by generic HDLC layer when protocol selected (PPP, frame relay, etc.)- \* set encoding and frame check sequence (FCS) options- \*- \* dev pointer to network device structure- \* encoding serial encoding setting- \* parity FCS setting- \*- \* returns 0 if success, otherwise error code- \*/-static int hdlcdev\_attach(struct net\_device \*dev, unsigned short encoding,- unsigned short parity)-{- MGSLPC\_INFO \*info = dev\_to\_port(dev);- struct tty\_struct \*tty;- unsigned char new\_encoding;- unsigned short new\_crctype;-- /\* return error if TTY interface open \*/- if (info->port.count)- return -EBUSY;-- switch (encoding)- {- case ENCODING\_NRZ: new\_encoding = HDLC\_ENCODING\_NRZ; break;- case ENCODING\_NRZI: new\_encoding = HDLC\_ENCODING\_NRZI\_SPACE; break;- case ENCODING\_FM\_MARK: new\_encoding = HDLC\_ENCODING\_BIPHASE\_MARK; break;- case ENCODING\_FM\_SPACE: new\_encoding = HDLC\_ENCODING\_BIPHASE\_SPACE; break;- case ENCODING\_MANCHESTER: new\_encoding = HDLC\_ENCODING\_BIPHASE\_LEVEL; break;- default: return -EINVAL;- }-- switch (parity)- {- case PARITY\_NONE: new\_crctype = HDLC\_CRC\_NONE; break;- case PARITY\_CRC16\_PR1\_CCITT: new\_crctype = HDLC\_CRC\_16\_CCITT; break;- case PARITY\_CRC32\_PR1\_CCITT: new\_crctype = HDLC\_CRC\_32\_CCITT; break;- default: return -EINVAL;- }-- info->params.encoding = new\_encoding;- info->params.crc\_type = new\_crctype;-- /\* if network interface up, reprogram hardware \*/- if (info->netcount) {- tty = tty\_port\_tty\_get(&info->port);- mgslpc\_program\_hw(info, tty);- tty\_kref\_put(tty);- }-- return 0;-}--/\*- \* called by generic HDLC layer to send frame- \*- \* skb socket buffer containing HDLC frame- \* dev pointer to network device structure- \*/-static netdev\_tx\_t hdlcdev\_xmit(struct sk\_buff \*skb,- struct net\_device \*dev)-{- MGSLPC\_INFO \*info = dev\_to\_port(dev);- unsigned long flags;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk(KERN\_INFO "%s:hdlc\_xmit(%s)\n", \_\_FILE\_\_, dev->name);-- /\* stop sending until this frame completes \*/- netif\_stop\_queue(dev);-- /\* copy data to device buffers \*/- skb\_copy\_from\_linear\_data(skb, info->tx\_buf, skb->len);- info->tx\_get = 0;- info->tx\_put = info->tx\_count = skb->len;-- /\* update network statistics \*/- dev->stats.tx\_packets++;- dev->stats.tx\_bytes += skb->len;-- /\* done with socket buffer, so free it \*/- dev\_kfree\_skb(skb);-- /\* save start time for transmit timeout detection \*/- netif\_trans\_update(dev);-- /\* start hardware transmitter if necessary \*/- spin\_lock\_irqsave(&info->lock, flags);- if (!info->tx\_active) {- struct tty\_struct \*tty = tty\_port\_tty\_get(&info->port);- tx\_start(info, tty);- tty\_kref\_put(tty);- }- spin\_unlock\_irqrestore(&info->lock, flags);-- return NETDEV\_TX\_OK;-}--/\*- \* called by network layer when interface enabled- \* claim resources and initialize hardware- \*- \* dev pointer to network device structure- \*- \* returns 0 if success, otherwise error code- \*/-static int hdlcdev\_open(struct net\_device \*dev)-{- MGSLPC\_INFO \*info = dev\_to\_port(dev);- struct tty\_struct \*tty;- int rc;- unsigned long flags;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s:hdlcdev\_open(%s)\n", \_\_FILE\_\_, dev->name);-- /\* generic HDLC layer open processing \*/- rc = hdlc\_open(dev);- if (rc != 0)- return rc;-- /\* arbitrate between network and tty opens \*/- spin\_lock\_irqsave(&info->netlock, flags);- if (info->port.count != 0 || info->netcount != 0) {- printk(KERN\_WARNING "%s: hdlc\_open returning busy\n", dev->name);- spin\_unlock\_irqrestore(&info->netlock, flags);- return -EBUSY;- }- info->netcount=1;- spin\_unlock\_irqrestore(&info->netlock, flags);-- tty = tty\_port\_tty\_get(&info->port);- /\* claim resources and init adapter \*/- rc = startup(info, tty);- if (rc != 0) {- tty\_kref\_put(tty);- spin\_lock\_irqsave(&info->netlock, flags);- info->netcount=0;- spin\_unlock\_irqrestore(&info->netlock, flags);- return rc;- }- /\* assert RTS and DTR, apply hardware settings \*/- info->serial\_signals |= SerialSignal\_RTS | SerialSignal\_DTR;- mgslpc\_program\_hw(info, tty);- tty\_kref\_put(tty);-- /\* enable network layer transmit \*/- netif\_trans\_update(dev);- netif\_start\_queue(dev);-- /\* inform generic HDLC layer of current DCD status \*/- spin\_lock\_irqsave(&info->lock, flags);- get\_signals(info);- spin\_unlock\_irqrestore(&info->lock, flags);- if (info->serial\_signals & SerialSignal\_DCD)- netif\_carrier\_on(dev);- else- netif\_carrier\_off(dev);- return 0;-}--/\*- \* called by network layer when interface is disabled- \* shutdown hardware and release resources- \*- \* dev pointer to network device structure- \*- \* returns 0 if success, otherwise error code- \*/-static int hdlcdev\_close(struct net\_device \*dev)-{- MGSLPC\_INFO \*info = dev\_to\_port(dev);- struct tty\_struct \*tty = tty\_port\_tty\_get(&info->port);- unsigned long flags;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s:hdlcdev\_close(%s)\n", \_\_FILE\_\_, dev->name);-- netif\_stop\_queue(dev);-- /\* shutdown adapter and release resources \*/- shutdown(info, tty);- tty\_kref\_put(tty);- hdlc\_close(dev);-- spin\_lock\_irqsave(&info->netlock, flags);- info->netcount=0;- spin\_unlock\_irqrestore(&info->netlock, flags);-- return 0;-}--/\*- \* called by network layer to process IOCTL call to network device- \*- \* dev pointer to network device structure- \* ifs pointer to network interface settings structure- \*- \* returns 0 if success, otherwise error code- \*/-static int hdlcdev\_wan\_ioctl(struct net\_device \*dev, struct if\_settings \*ifs)-{- const size\_t size = sizeof(sync\_serial\_settings);- sync\_serial\_settings new\_line;- sync\_serial\_settings \_\_user \*line = ifs->ifs\_ifsu.sync;- MGSLPC\_INFO \*info = dev\_to\_port(dev);- unsigned int flags;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("%s:hdlcdev\_ioctl(%s)\n", \_\_FILE\_\_, dev->name);-- /\* return error if TTY interface open \*/- if (info->port.count)- return -EBUSY;-- memset(&new\_line, 0, size);-- switch (ifs->type) {- case IF\_GET\_IFACE: /\* return current sync\_serial\_settings \*/-- ifs->type = IF\_IFACE\_SYNC\_SERIAL;- if (ifs->size < size) {- ifs->size = size; /\* data size wanted \*/- return -ENOBUFS;- }-- flags = info->params.flags & (HDLC\_FLAG\_RXC\_RXCPIN | HDLC\_FLAG\_RXC\_DPLL |- HDLC\_FLAG\_RXC\_BRG | HDLC\_FLAG\_RXC\_TXCPIN |- HDLC\_FLAG\_TXC\_TXCPIN | HDLC\_FLAG\_TXC\_DPLL |- HDLC\_FLAG\_TXC\_BRG | HDLC\_FLAG\_TXC\_RXCPIN);-- switch (flags){- case (HDLC\_FLAG\_RXC\_RXCPIN | HDLC\_FLAG\_TXC\_TXCPIN): new\_line.clock\_type = CLOCK\_EXT; break;- case (HDLC\_FLAG\_RXC\_BRG | HDLC\_FLAG\_TXC\_BRG): new\_line.clock\_type = CLOCK\_INT; break;- case (HDLC\_FLAG\_RXC\_RXCPIN | HDLC\_FLAG\_TXC\_BRG): new\_line.clock\_type = CLOCK\_TXINT; break;- case (HDLC\_FLAG\_RXC\_RXCPIN | HDLC\_FLAG\_TXC\_RXCPIN): new\_line.clock\_type = CLOCK\_TXFROMRX; break;- default: new\_line.clock\_type = CLOCK\_DEFAULT;- }-- new\_line.clock\_rate = info->params.clock\_speed;- new\_line.loopback = info->params.loopback ? 1:0;-- if (copy\_to\_user(line, &new\_line, size))- return -EFAULT;- return 0;-- case IF\_IFACE\_SYNC\_SERIAL: /\* set sync\_serial\_settings \*/-- if(!capable(CAP\_NET\_ADMIN))- return -EPERM;- if (copy\_from\_user(&new\_line, line, size))- return -EFAULT;-- switch (new\_line.clock\_type)- {- case CLOCK\_EXT: flags = HDLC\_FLAG\_RXC\_RXCPIN | HDLC\_FLAG\_TXC\_TXCPIN; break;- case CLOCK\_TXFROMRX: flags = HDLC\_FLAG\_RXC\_RXCPIN | HDLC\_FLAG\_TXC\_RXCPIN; break;- case CLOCK\_INT: flags = HDLC\_FLAG\_RXC\_BRG | HDLC\_FLAG\_TXC\_BRG; break;- case CLOCK\_TXINT: flags = HDLC\_FLAG\_RXC\_RXCPIN | HDLC\_FLAG\_TXC\_BRG; break;- case CLOCK\_DEFAULT: flags = info->params.flags &- (HDLC\_FLAG\_RXC\_RXCPIN | HDLC\_FLAG\_RXC\_DPLL |- HDLC\_FLAG\_RXC\_BRG | HDLC\_FLAG\_RXC\_TXCPIN |- HDLC\_FLAG\_TXC\_TXCPIN | HDLC\_FLAG\_TXC\_DPLL |- HDLC\_FLAG\_TXC\_BRG | HDLC\_FLAG\_TXC\_RXCPIN); break;- default: return -EINVAL;- }-- if (new\_line.loopback != 0 && new\_line.loopback != 1)- return -EINVAL;-- info->params.flags &= ~(HDLC\_FLAG\_RXC\_RXCPIN | HDLC\_FLAG\_RXC\_DPLL |- HDLC\_FLAG\_RXC\_BRG | HDLC\_FLAG\_RXC\_TXCPIN |- HDLC\_FLAG\_TXC\_TXCPIN | HDLC\_FLAG\_TXC\_DPLL |- HDLC\_FLAG\_TXC\_BRG | HDLC\_FLAG\_TXC\_RXCPIN);- info->params.flags |= flags;-- info->params.loopback = new\_line.loopback;-- if (flags & (HDLC\_FLAG\_RXC\_BRG | HDLC\_FLAG\_TXC\_BRG))- info->params.clock\_speed = new\_line.clock\_rate;- else- info->params.clock\_speed = 0;-- /\* if network interface up, reprogram hardware \*/- if (info->netcount) {- struct tty\_struct \*tty = tty\_port\_tty\_get(&info->port);- mgslpc\_program\_hw(info, tty);- tty\_kref\_put(tty);- }- return 0;- default:- return hdlc\_ioctl(dev, ifs);- }-}--/\*- \* called by network layer when transmit timeout is detected- \*- \* dev pointer to network device structure- \*/-static void hdlcdev\_tx\_timeout(struct net\_device \*dev, unsigned int txqueue)-{- MGSLPC\_INFO \*info = dev\_to\_port(dev);- unsigned long flags;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("hdlcdev\_tx\_timeout(%s)\n", dev->name);-- dev->stats.tx\_errors++;- dev->stats.tx\_aborted\_errors++;-- spin\_lock\_irqsave(&info->lock, flags);- tx\_stop(info);- spin\_unlock\_irqrestore(&info->lock, flags);-- netif\_wake\_queue(dev);-}--/\*- \* called by device driver when transmit completes- \* reenable network layer transmit if stopped- \*- \* info pointer to device instance information- \*/-static void hdlcdev\_tx\_done(MGSLPC\_INFO \*info)-{- if (netif\_queue\_stopped(info->netdev))- netif\_wake\_queue(info->netdev);-}--/\*- \* called by device driver when frame received- \* pass frame to network layer- \*- \* info pointer to device instance information- \* buf pointer to buffer contianing frame data- \* size count of data bytes in buf- \*/-static void hdlcdev\_rx(MGSLPC\_INFO \*info, char \*buf, int size)-{- struct sk\_buff \*skb = dev\_alloc\_skb(size);- struct net\_device \*dev = info->netdev;-- if (debug\_level >= DEBUG\_LEVEL\_INFO)- printk("hdlcdev\_rx(%s)\n", dev->name);-- if (skb == NULL) {- printk(KERN\_NOTICE "%s: can't alloc skb, dropping packet\n", dev->name);- dev->stats.rx\_dropped++;- return;- }-- skb\_put\_data(skb, buf, size);-- skb->protocol = hdlc\_type\_trans(skb, dev);-- dev->stats.rx\_packets++;- dev->stats.rx\_bytes += size;-- netif\_rx(skb);-}--static const struct net\_device\_ops hdlcdev\_ops = {- .ndo\_open = hdlcdev\_open,- .ndo\_stop = hdlcdev\_close,- .ndo\_start\_xmit = hdlc\_start\_xmit,- .ndo\_siocwandev = hdlcdev\_wan\_ioctl,- .ndo\_tx\_timeout = hdlcdev\_tx\_timeout,-};--/\*- \* called by device driver when adding device instance- \* do generic HDLC initialization- \*- \* info pointer to device instance information- \*- \* returns 0 if success, otherwise error code- \*/-static int hdlcdev\_init(MGSLPC\_INFO \*info)-{- int rc;- struct net\_device \*dev;- hdlc\_device \*hdlc;-- /\* allocate and initialize network and HDLC layer objects \*/-- dev = alloc\_hdlcdev(info);- if (dev == NULL) {- printk(KERN\_ERR "%s:hdlc device allocation failure\n", \_\_FILE\_\_);- return -ENOMEM;- }-- /\* for network layer reporting purposes only \*/- dev->base\_addr = info->io\_base;- dev->irq = info->irq\_level;-- /\* network layer callbacks and settings \*/- dev->netdev\_ops = &hdlcdev\_ops;- dev->watchdog\_timeo = 10 \* HZ;- dev->tx\_queue\_len = 50;-- /\* generic HDLC layer callbacks and settings \*/- hdlc = dev\_to\_hdlc(dev);- hdlc->attach = hdlcdev\_attach;- hdlc->xmit = hdlcdev\_xmit;-- /\* register objects with HDLC layer \*/- rc = register\_hdlc\_device(dev);- if (rc) {- printk(KERN\_WARNING "%s:unable to register hdlc device\n", \_\_FILE\_\_);- free\_netdev(dev);- return rc;- }-- info->netdev = dev;- return 0;-}--/\*- \* called by device driver when removing device instance- \* do generic HDLC cleanup- \*- \* info pointer to device instance information- \*/-static void hdlcdev\_exit(MGSLPC\_INFO \*info)-{- unregister\_hdlc\_device(info->netdev);- free\_netdev(info->netdev);- info->netdev = NULL;-}--#endif /\* CONFIG\_HDLC \*/-diff --git a/include/linux/cm4000\_cs.h b/include/linux/cm4000\_cs.hdeleted file mode 100644index ea4958e07a14a0..00000000000000--- a/[include/linux/cm4000\_cs.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/cm4000_cs.h?id=3996954fa071aa20945c8ac7694684fa3c1fed68)+++ /dev/null@@ -1,11 +0,0 @@-/\* SPDX-License-Identifier: GPL-2.0 \*/-#ifndef \_CM4000\_H\_-#define \_CM4000\_H\_--#include <uapi/linux/cm4000\_cs.h>---#define DEVICE\_NAME "cmm"-#define MODULE\_NAME "cm4000\_cs"--#endif /\* \_CM4000\_H\_ \*/diff --git a/include/uapi/linux/cm4000\_cs.h b/include/uapi/linux/cm4000\_cs.hdeleted file mode 100644index c70a62ec8a49ac..00000000000000--- a/[include/uapi/linux/cm4000\_cs.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/cm4000_cs.h?id=3996954fa071aa20945c8ac7694684fa3c1fed68)+++ /dev/null@@ -1,64 +0,0 @@-/\* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note \*/-#ifndef \_UAPI\_CM4000\_H\_-#define \_UAPI\_CM4000\_H\_--#include <linux/types.h>-#include <linux/ioctl.h>--#define MAX\_ATR 33--#define CM4000\_MAX\_DEV 4--/\* those two structures are passed via ioctl() from/to userspace. They are- \* used by existing userspace programs, so I kepth the awkward "bIFSD" naming- \* not to break compilation of userspace apps. -HW \*/--typedef struct atreq {- \_\_s32 atr\_len;- unsigned char atr[64];- \_\_s32 power\_act;- unsigned char bIFSD;- unsigned char bIFSC;-} atreq\_t;---/\* what is particularly stupid in the original driver is the arch-dependent- \* member sizes. This leads to CONFIG\_COMPAT breakage, since 32bit userspace- \* will lay out the structure members differently than the 64bit kernel.- \*- \* I've changed "ptsreq.protocol" from "unsigned long" to "\_\_u32".- \* On 32bit this will make no difference. With 64bit kernels, it will make- \* 32bit apps work, too.- \*/--typedef struct ptsreq {- \_\_u32 protocol; /\*T=0: 2^0, T=1: 2^1\*/- unsigned char flags;- unsigned char pts1;- unsigned char pts2;- unsigned char pts3;-} ptsreq\_t;--#define CM\_IOC\_MAGIC 'c'-#define CM\_IOC\_MAXNR 255--#define CM\_IOCGSTATUS \_IOR (CM\_IOC\_MAGIC, 0, unsigned char \*)-#define CM\_IOCGATR \_IOWR(CM\_IOC\_MAGIC, 1, atreq\_t \*)-#define CM\_IOCSPTS \_IOW (CM\_IOC\_MAGIC, 2, ptsreq\_t \*)-#define CM\_IOCSRDR \_IO (CM\_IOC\_MAGIC, 3)-#define CM\_IOCARDOFF \_IO (CM\_IOC\_MAGIC, 4)--#define CM\_IOSDBGLVL \_IOW(CM\_IOC\_MAGIC, 250, int\*)--/\* card and device states \*/-#define CM\_CARD\_INSERTED 0x01-#define CM\_CARD\_POWERED 0x02-#define CM\_ATR\_PRESENT 0x04-#define CM\_ATR\_VALID 0x08-#define CM\_STATE\_VALID 0x0f-/\* extra info only from CM4000 \*/-#define CM\_NO\_READER 0x10-#define CM\_BAD\_CARD 0x20---#endif /\* \_UAPI\_CM4000\_H\_ \*/ |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-08 13:26:25 +0000


