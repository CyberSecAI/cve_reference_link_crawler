```
{
  "vulnerability": {
    "root_cause": "In (e)poll mode, threads using the binder driver may not be properly woken up when they enqueue their own work, leading to indefinite waiting.",
    "weaknesses": [
      "The binder driver does not signal epoll-based threads when they queue their own work."
    ],
    "impact": "Threads can wait indefinitely, causing work to remain unhandled. Subsequent commands may also not trigger wakeups as the thread has pending work, resulting in a denial-of-service condition.",
     "attack_vectors": [
      "A thread initiates a command using BINDER_WRITE_READ without a read buffer and then uses epoll_wait() to consume responses. If this thread queues its own work, it will not be woken up, leading to the vulnerability."
    ],
    "required_capabilities": "The attacker must be able to trigger a thread to initiate a command via BINDER_WRITE_READ without a read buffer and then make use of epoll_wait() to consume responses. They must also be able to cause the thread to queue its own work."
  },
  "fixes": [
    {
      "commit": "97830f3c3088638ff90b20dfba2eb4d487bf14d7",
      "description": "The fix adds a wakeup signal for epoll-based threads when they queue their own work to ensure they process their work and don't wait indefinitely.  The fix introduces a conditional wakeup call to `wake_up_interruptible_sync(&thread->wait)` which is triggered if the thread is in `BINDER_LOOPER_STATE_POLL` mode, the thread's pid matches the current pid, and the thread does not have pending work (`!thread->process_todo`). It also sets `thread->process_todo = true` after enqueuing work."
    },
        {
      "commit": "a7ae586f6f6024f490b8546c8c84670f96bb9b68",
      "description": "The fix adds a wakeup signal for epoll-based threads when they queue their own work to ensure they process their work and don't wait indefinitely.  The fix introduces a conditional wakeup call to `wake_up_interruptible_sync(&thread->wait)` which is triggered if the thread is in `BINDER_LOOPER_STATE_POLL` mode, the thread's pid matches the current pid, and the thread does not have pending work (`!thread->process_todo`). It also sets `thread->process_todo = true` after enqueuing work."
    },
    {
      "commit": "dd64bb8329ce0ea27bc557e4160c2688835402ac",
      "description": "The fix adds a wakeup signal for epoll-based threads when they queue their own work to ensure they process their work and don't wait indefinitely.  The fix introduces a conditional wakeup call to `wake_up_interruptible_sync(&thread->wait)` which is triggered if the thread is in `BINDER_LOOPER_STATE_POLL` mode, the thread's pid matches the current pid, and the thread does not have pending work (`!thread->process_todo`). It also sets `thread->process_todo = true` after enqueuing work."
    },
        {
      "commit": "90e09c016d72b91e76de25f71c7b93d94cc3c769",
      "description": "The fix adds a wakeup signal for epoll-based threads when they queue their own work to ensure they process their work and don't wait indefinitely.  The fix introduces a conditional wakeup call to `wake_up_interruptible_sync(&thread->wait)` which is triggered if the thread is in `BINDER_LOOPER_STATE_POLL` mode, the thread's pid matches the current pid, and the thread does not have pending work (`!thread->process_todo`). It also sets `thread->process_todo = true` after enqueuing work."
    },
    {
     "commit": "63664ca09602326b167866968829f6187b682a2a",
     "description": "The fix adds a wakeup signal for epoll-based threads when they queue their own work to ensure they process their work and don't wait indefinitely.  The fix introduces a conditional wakeup call to `wake_up_interruptible_sync(&thread->wait)` which is triggered if the thread is in `BINDER_LOOPER_STATE_POLL` mode, the thread's pid matches the current pid, and the thread does not have pending work (`!thread->process_todo`). It also sets `thread->process_todo = true` after enqueuing work."
    },
    {
     "commit":"7dfa18d5699077577a60d0e41333f8e49f6ff4a3",
     "description": "The fix adds a wakeup signal for epoll-based threads when they queue their own work to ensure they process their work and don't wait indefinitely.  The fix introduces a conditional wakeup call to `wake_up_interruptible_sync(&thread->wait)` which is triggered if the thread is in `BINDER_LOOPER_STATE_POLL` mode, the thread's pid matches the current pid, and the thread does not have pending work (`!thread->process_todo`). It also sets `thread->process_todo = true` after enqueuing work."
    },
{
     "commit":"82722b453dc2f967b172603e389ee7dc1b3137cc",
      "description": "The fix adds a wakeup signal for epoll-based threads when they queue their own work to ensure they process their work and don't wait indefinitely.  The fix introduces a conditional wakeup call to `wake_up_interruptible_sync(&thread->wait)` which is triggered if the thread is in `BINDER_LOOPER_STATE_POLL` mode, the thread's pid matches the current pid, and the thread does not have pending work (`!thread->process_todo`). It also sets `thread->process_todo = true` after enqueuing work."
    },
    {
      "commit":"a423042052ec2bdbf1e552e621e6a768922363cc",
      "description":"The fix adds a wakeup signal for epoll-based threads when they queue their own work to ensure they process their work and don't wait indefinitely.  The fix introduces a conditional wakeup call to `wake_up_interruptible_sync(&thread->wait)` which is triggered if the thread is in `BINDER_LOOPER_STATE_POLL` mode, the thread's pid matches the current pid, and the thread does not have pending work (`!thread->process_todo`). It also sets `thread->process_todo = true` after enqueuing work."
    },
        {
      "commit": "63811a4e084804c447769d67c8800e45b29f5207",
      "description":"The fix adds a wakeup signal for epoll-based threads when they queue their own work to ensure they process their work and don't wait indefinitely.  The fix introduces a conditional wakeup call to `wake_up_interruptible_sync(&thread->wait)` which is triggered if the thread is in `BINDER_LOOPER_STATE_POLL` mode, the thread's pid matches the current pid, and the thread does not have pending work (`!thread->process_todo`). It also sets `thread->process_todo = true` after enqueuing work."
    }
  ]
}
```