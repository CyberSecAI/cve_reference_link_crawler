=== Content from git.kernel.org_b0079d95_20250110_150305.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=e66b7920aa5ac5b1a1997a454004ba9246a3c005)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=e66b7920aa5ac5b1a1997a454004ba9246a3c005)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e66b7920aa5ac5b1a1997a454004ba9246a3c005)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e66b7920aa5ac5b1a1997a454004ba9246a3c005)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Felix Fietkau <nbd@nbd.name> | 2022-12-30 21:07:47 +0100 |
| --- | --- | --- |
| committer | Johannes Berg <johannes.berg@intel.com> | 2023-01-10 13:24:11 +0100 |
| commit | [e66b7920aa5ac5b1a1997a454004ba9246a3c005](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e66b7920aa5ac5b1a1997a454004ba9246a3c005) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=e66b7920aa5ac5b1a1997a454004ba9246a3c005)) | |
| tree | [959603144b3acde9ee9c2a7bd012c3e8cf68da46](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=e66b7920aa5ac5b1a1997a454004ba9246a3c005) | |
| parent | [7d6ceeb1875cc08dc3d1e558e191434d94840cd5](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7d6ceeb1875cc08dc3d1e558e191434d94840cd5) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e66b7920aa5ac5b1a1997a454004ba9246a3c005&id2=7d6ceeb1875cc08dc3d1e558e191434d94840cd5)) | |
| download | [linux-e66b7920aa5ac5b1a1997a454004ba9246a3c005.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-e66b7920aa5ac5b1a1997a454004ba9246a3c005.tar.gz) | |

wifi: mac80211: fix initialization of rx->link and rx->link\_staThere are some codepaths that do not initialize rx->link\_sta properly. This
causes a crash in places which assume that rx->link\_sta is valid if rx->sta
is valid.
One known instance is triggered by \_\_ieee80211\_rx\_h\_amsdu being called from
fast-rx. It results in a crash like this one:
BUG: kernel NULL pointer dereference, address: 00000000000000a8
#PF: supervisor write access in kernel mode
#PF: error\_code(0x0002) - not-present page PGD 0 P4D 0
Oops: 0002 [#1] PREEMPT SMP PTI
CPU: 1 PID: 506 Comm: mt76-usb-rx phy Tainted: G E 6.1.0-debian64x+1.7 #3
Hardware name: ZOTAC ZBOX-ID92/ZBOX-IQ01/ZBOX-ID92/ZBOX-IQ01, BIOS B220P007 05/21/2014
RIP: 0010:ieee80211\_deliver\_skb+0x62/0x1f0 [mac80211]
Code: 00 48 89 04 24 e8 9e a7 c3 df 89 c0 48 03 1c c5 a0 ea 39 a1 4c 01 6b 08 48 ff 03 48
83 7d 28 00 74 11 48 8b 45 30 48 63 55 44 <48> 83 84 d0 a8 00 00 00 01 41 8b 86 c0
11 00 00 8d 50 fd 83 fa 01
RSP: 0018:ffff999040803b10 EFLAGS: 00010286
RAX: 0000000000000000 RBX: ffffb9903f496480 RCX: 0000000000000000
RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000
RBP: ffff999040803ce0 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000000 R12: ffff8d21828ac900
R13: 000000000000004a R14: ffff8d2198ed89c0 R15: ffff8d2198ed8000
FS: 0000000000000000(0000) GS:ffff8d24afe80000(0000) knlGS:0000000000000000
CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00000000000000a8 CR3: 0000000429810002 CR4: 00000000001706e0
Call Trace:
<TASK>
\_\_ieee80211\_rx\_h\_amsdu+0x1b5/0x240 [mac80211]
? ieee80211\_prepare\_and\_rx\_handle+0xcdd/0x1320 [mac80211]
? \_\_local\_bh\_enable\_ip+0x3b/0xa0
ieee80211\_prepare\_and\_rx\_handle+0xcdd/0x1320 [mac80211]
? prepare\_transfer+0x109/0x1a0 [xhci\_hcd]
ieee80211\_rx\_list+0xa80/0xda0 [mac80211]
mt76\_rx\_complete+0x207/0x2e0 [mt76]
mt76\_rx\_poll\_complete+0x357/0x5a0 [mt76]
mt76u\_rx\_worker+0x4f5/0x600 [mt76\_usb]
? mt76\_get\_min\_avg\_rssi+0x140/0x140 [mt76]
\_\_mt76\_worker\_fn+0x50/0x80 [mt76]
kthread+0xed/0x120
? kthread\_complete\_and\_exit+0x20/0x20
ret\_from\_fork+0x22/0x30
Since the initialization of rx->link and rx->link\_sta is rather convoluted
and duplicated in many places, clean it up by using a helper function to
set it.
Fixes: ccdde7c74ffd ("wifi: mac80211: properly implement MLO key handling")
Fixes: b320d6c456ff ("wifi: mac80211: use correct rx link\_sta instead of default")
Signed-off-by: Felix Fietkau <nbd@nbd.name>
Link: [https://lore.kernel.org/r/20221230200747.19040-1-nbd@nbd.name](https://lore.kernel.org/r/20221230200747.19040-1-nbd%40nbd.name)
[remove unnecessary rx->sta->sta.mlo check]
Cc: stable@vger.kernel.org
Signed-off-by: Johannes Berg <johannes.berg@intel.com>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e66b7920aa5ac5b1a1997a454004ba9246a3c005)

| -rw-r--r-- | [net/mac80211/rx.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/mac80211/rx.c?id=e66b7920aa5ac5b1a1997a454004ba9246a3c005) | 222 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 99 insertions, 123 deletions

| diff --git a/net/mac80211/rx.c b/net/mac80211/rx.cindex 7e3ab6e1b28f3d..c518287b2356bd 100644--- a/[net/mac80211/rx.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/mac80211/rx.c?id=7d6ceeb1875cc08dc3d1e558e191434d94840cd5)+++ b/[net/mac80211/rx.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/mac80211/rx.c?id=e66b7920aa5ac5b1a1997a454004ba9246a3c005)@@ -4049,6 +4049,58 @@ static void ieee80211\_invoke\_rx\_handlers(struct ieee80211\_rx\_data \*rx) #undef CALL\_RXH } +static bool+ieee80211\_rx\_is\_valid\_sta\_link\_id(struct ieee80211\_sta \*sta, u8 link\_id)+{+ if (!sta->mlo)+ return false;++ return !!(sta->valid\_links & BIT(link\_id));+}++static bool ieee80211\_rx\_data\_set\_link(struct ieee80211\_rx\_data \*rx,+ u8 link\_id)+{+ rx->link\_id = link\_id;+ rx->link = rcu\_dereference(rx->sdata->link[link\_id]);++ if (!rx->sta)+ return rx->link;++ if (!ieee80211\_rx\_is\_valid\_sta\_link\_id(&rx->sta->sta, link\_id))+ return false;++ rx->link\_sta = rcu\_dereference(rx->sta->link[link\_id]);++ return rx->link && rx->link\_sta;+}++static bool ieee80211\_rx\_data\_set\_sta(struct ieee80211\_rx\_data \*rx,+ struct ieee80211\_sta \*pubsta,+ int link\_id)+{+ struct sta\_info \*sta;++ sta = container\_of(pubsta, struct sta\_info, sta);++ rx->link\_id = link\_id;+ rx->sta = sta;++ if (sta) {+ rx->local = sta->sdata->local;+ if (!rx->sdata)+ rx->sdata = sta->sdata;+ rx->link\_sta = &sta->deflink;+ }++ if (link\_id < 0)+ rx->link = &rx->sdata->deflink;+ else if (!ieee80211\_rx\_data\_set\_link(rx, link\_id))+ return false;++ return true;+}+ /\* \* This function makes calls into the RX path, therefore \* it has to be invoked under RCU read lock.@@ -4057,16 +4109,19 @@ void ieee80211\_release\_reorder\_timeout(struct sta\_info \*sta, int tid) { struct sk\_buff\_head frames; struct ieee80211\_rx\_data rx = {- .sta = sta,- .sdata = sta->sdata,- .local = sta->local, /\* This is OK -- must be QoS data frame \*/ .security\_idx = tid, .seqno\_idx = tid,- .link\_id = -1, }; struct tid\_ampdu\_rx \*tid\_agg\_rx;- u8 link\_id;+ int link\_id = -1;++ /\* FIXME: statistics won't be right with this \*/+ if (sta->sta.valid\_links)+ link\_id = ffs(sta->sta.valid\_links) - 1;++ if (!ieee80211\_rx\_data\_set\_sta(&rx, &sta->sta, link\_id))+ return;  tid\_agg\_rx = rcu\_dereference(sta->ampdu\_mlme.tid\_rx[tid]); if (!tid\_agg\_rx)@@ -4086,10 +4141,6 @@ void ieee80211\_release\_reorder\_timeout(struct sta\_info \*sta, int tid) }; drv\_event\_callback(rx.local, rx.sdata, &event); }- /\* FIXME: statistics won't be right with this \*/- link\_id = sta->sta.valid\_links ? ffs(sta->sta.valid\_links) - 1 : 0;- rx.link = rcu\_dereference(sta->sdata->link[link\_id]);- rx.link\_sta = rcu\_dereference(sta->link[link\_id]);  ieee80211\_rx\_handlers(&rx, &frames); }@@ -4105,7 +4156,6 @@ void ieee80211\_mark\_rx\_ba\_filtered\_frames(struct ieee80211\_sta \*pubsta, u8 tid, /\* This is OK -- must be QoS data frame \*/ .security\_idx = tid, .seqno\_idx = tid,- .link\_id = -1, }; int i, diff; @@ -4116,10 +4166,8 @@ void ieee80211\_mark\_rx\_ba\_filtered\_frames(struct ieee80211\_sta \*pubsta, u8 tid,  sta = container\_of(pubsta, struct sta\_info, sta); - rx.sta = sta;- rx.sdata = sta->sdata;- rx.link = &rx.sdata->deflink;- rx.local = sta->local;+ if (!ieee80211\_rx\_data\_set\_sta(&rx, pubsta, -1))+ return;  rcu\_read\_lock(); tid\_agg\_rx = rcu\_dereference(sta->ampdu\_mlme.tid\_rx[tid]);@@ -4506,15 +4554,6 @@ void ieee80211\_check\_fast\_rx\_iface(struct ieee80211\_sub\_if\_data \*sdata) mutex\_unlock(&local->sta\_mtx); } -static bool-ieee80211\_rx\_is\_valid\_sta\_link\_id(struct ieee80211\_sta \*sta, u8 link\_id)-{- if (!sta->mlo)- return false;-- return !!(sta->valid\_links & BIT(link\_id));-}- static void ieee80211\_rx\_8023(struct ieee80211\_rx\_data \*rx, struct ieee80211\_fast\_rx \*fast\_rx, int orig\_len)@@ -4625,7 +4664,6 @@ static bool ieee80211\_invoke\_fast\_rx(struct ieee80211\_rx\_data \*rx, struct sk\_buff \*skb = rx->skb; struct ieee80211\_hdr \*hdr = (void \*)skb->data; struct ieee80211\_rx\_status \*status = IEEE80211\_SKB\_RXCB(skb);- struct sta\_info \*sta = rx->sta; int orig\_len = skb->len; int hdrlen = ieee80211\_hdrlen(hdr->frame\_control); int snap\_offs = hdrlen;@@ -4637,7 +4675,6 @@ static bool ieee80211\_invoke\_fast\_rx(struct ieee80211\_rx\_data \*rx, u8 da[ETH\_ALEN]; u8 sa[ETH\_ALEN]; } addrs \_\_aligned(2);- struct link\_sta\_info \*link\_sta; struct ieee80211\_sta\_rx\_stats \*stats;  /\* for parallel-rx, we need to have DUP\_VALIDATED, otherwise we write@@ -4740,18 +4777,10 @@ static bool ieee80211\_invoke\_fast\_rx(struct ieee80211\_rx\_data \*rx, drop: dev\_kfree\_skb(skb); - if (rx->link\_id >= 0) {- link\_sta = rcu\_dereference(sta->link[rx->link\_id]);- if (!link\_sta)- return true;- } else {- link\_sta = &sta->deflink;- }- if (fast\_rx->uses\_rss)- stats = this\_cpu\_ptr(link\_sta->pcpu\_rx\_stats);+ stats = this\_cpu\_ptr(rx->link\_sta->pcpu\_rx\_stats); else- stats = &link\_sta->rx\_stats;+ stats = &rx->link\_sta->rx\_stats;  stats->dropped++; return true;@@ -4769,8 +4798,8 @@ static bool ieee80211\_prepare\_and\_rx\_handle(struct ieee80211\_rx\_data \*rx, struct ieee80211\_local \*local = rx->local; struct ieee80211\_sub\_if\_data \*sdata = rx->sdata; struct ieee80211\_hdr \*hdr = (void \*)skb->data;- struct link\_sta\_info \*link\_sta = NULL;- struct ieee80211\_link\_data \*link;+ struct link\_sta\_info \*link\_sta = rx->link\_sta;+ struct ieee80211\_link\_data \*link = rx->link;  rx->skb = skb; @@ -4792,35 +4821,6 @@ static bool ieee80211\_prepare\_and\_rx\_handle(struct ieee80211\_rx\_data \*rx, if (!ieee80211\_accept\_frame(rx)) return false; - if (rx->link\_id >= 0) {- link = rcu\_dereference(rx->sdata->link[rx->link\_id]);-- /\* we might race link removal \*/- if (!link)- return true;- rx->link = link;-- if (rx->sta) {- rx->link\_sta =- rcu\_dereference(rx->sta->link[rx->link\_id]);- if (!rx->link\_sta)- return true;- }- } else {- if (rx->sta)- rx->link\_sta = &rx->sta->deflink;-- rx->link = &sdata->deflink;- }-- if (unlikely(!is\_multicast\_ether\_addr(hdr->addr1) &&- rx->link\_id >= 0 && rx->sta && rx->sta->sta.mlo)) {- link\_sta = rcu\_dereference(rx->sta->link[rx->link\_id]);-- if (WARN\_ON\_ONCE(!link\_sta))- return true;- }- if (!consume) { struct skb\_shared\_hwtstamps \*shwt; @@ -4840,7 +4840,7 @@ static bool ieee80211\_prepare\_and\_rx\_handle(struct ieee80211\_rx\_data \*rx, shwt->hwtstamp = skb\_hwtstamps(skb)->hwtstamp; } - if (unlikely(link\_sta)) {+ if (unlikely(rx->sta && rx->sta->sta.mlo)) { /\* translate to MLD addresses \*/ if (ether\_addr\_equal(link->conf->addr, hdr->addr1)) ether\_addr\_copy(hdr->addr1, rx->sdata->vif.addr);@@ -4870,6 +4870,7 @@ static void \_\_ieee80211\_rx\_handle\_8023(struct ieee80211\_hw \*hw, struct ieee80211\_rx\_status \*status = IEEE80211\_SKB\_RXCB(skb); struct ieee80211\_fast\_rx \*fast\_rx; struct ieee80211\_rx\_data rx;+ int link\_id = -1;  memset(&rx, 0, sizeof(rx)); rx.skb = skb;@@ -4886,12 +4887,8 @@ static void \_\_ieee80211\_rx\_handle\_8023(struct ieee80211\_hw \*hw, if (!pubsta) goto drop; - rx.sta = container\_of(pubsta, struct sta\_info, sta);- rx.sdata = rx.sta->sdata;-- if (status->link\_valid &&- !ieee80211\_rx\_is\_valid\_sta\_link\_id(pubsta, status->link\_id))- goto drop;+ if (status->link\_valid)+ link\_id = status->link\_id;  /\* \* TODO: Should the frame be dropped if the right link\_id is not@@ -4900,19 +4897,8 @@ static void \_\_ieee80211\_rx\_handle\_8023(struct ieee80211\_hw \*hw, \* link\_id is used only for stats purpose and updating the stats on \* the deflink is fine? \*/- if (status->link\_valid)- rx.link\_id = status->link\_id;-- if (rx.link\_id >= 0) {- struct ieee80211\_link\_data \*link;-- link = rcu\_dereference(rx.sdata->link[rx.link\_id]);- if (!link)- goto drop;- rx.link = link;- } else {- rx.link = &rx.sdata->deflink;- }+ if (!ieee80211\_rx\_data\_set\_sta(&rx, pubsta, link\_id))+ goto drop;  fast\_rx = rcu\_dereference(rx.sta->fast\_rx); if (!fast\_rx)@@ -4930,6 +4916,8 @@ static bool ieee80211\_rx\_for\_interface(struct ieee80211\_rx\_data \*rx, { struct link\_sta\_info \*link\_sta; struct ieee80211\_hdr \*hdr = (void \*)skb->data;+ struct sta\_info \*sta;+ int link\_id = -1;  /\* \* Look up link station first, in case there's a@@ -4939,24 +4927,19 @@ static bool ieee80211\_rx\_for\_interface(struct ieee80211\_rx\_data \*rx, \*/ link\_sta = link\_sta\_info\_get\_bss(rx->sdata, hdr->addr2); if (link\_sta) {- rx->sta = link\_sta->sta;- rx->link\_id = link\_sta->link\_id;+ sta = link\_sta->sta;+ link\_id = link\_sta->link\_id; } else { struct ieee80211\_rx\_status \*status = IEEE80211\_SKB\_RXCB(skb); - rx->sta = sta\_info\_get\_bss(rx->sdata, hdr->addr2);- if (rx->sta) {- if (status->link\_valid &&- !ieee80211\_rx\_is\_valid\_sta\_link\_id(&rx->sta->sta,- status->link\_id))- return false;-- rx->link\_id = status->link\_valid ? status->link\_id : -1;- } else {- rx->link\_id = -1;- }+ sta = sta\_info\_get\_bss(rx->sdata, hdr->addr2);+ if (status->link\_valid)+ link\_id = status->link\_id; } + if (!ieee80211\_rx\_data\_set\_sta(rx, &sta->sta, link\_id))+ return false;+ return ieee80211\_prepare\_and\_rx\_handle(rx, skb, consume); } @@ -5015,19 +4998,15 @@ static void \_\_ieee80211\_rx\_handle\_packet(struct ieee80211\_hw \*hw,  if (ieee80211\_is\_data(fc)) { struct sta\_info \*sta, \*prev\_sta;- u8 link\_id = status->link\_id;+ int link\_id = -1; - if (pubsta) {- rx.sta = container\_of(pubsta, struct sta\_info, sta);- rx.sdata = rx.sta->sdata;+ if (status->link\_valid)+ link\_id = status->link\_id; - if (status->link\_valid &&- !ieee80211\_rx\_is\_valid\_sta\_link\_id(pubsta, link\_id))+ if (pubsta) {+ if (!ieee80211\_rx\_data\_set\_sta(&rx, pubsta, link\_id)) goto out; - if (status->link\_valid)- rx.link\_id = status->link\_id;- /\* \* In MLO connection, fetch the link\_id using addr2 \* when the driver does not pass link\_id in status.@@ -5045,7 +5024,7 @@ static void \_\_ieee80211\_rx\_handle\_packet(struct ieee80211\_hw \*hw, if (!link\_sta) goto out; - rx.link\_id = link\_sta->link\_id;+ ieee80211\_rx\_data\_set\_link(&rx, link\_sta->link\_id); }  if (ieee80211\_prepare\_and\_rx\_handle(&rx, skb, true))@@ -5061,30 +5040,27 @@ static void \_\_ieee80211\_rx\_handle\_packet(struct ieee80211\_hw \*hw, continue; } - if ((status->link\_valid &&- !ieee80211\_rx\_is\_valid\_sta\_link\_id(&prev\_sta->sta,- link\_id)) ||- (!status->link\_valid && prev\_sta->sta.mlo))+ rx.sdata = prev\_sta->sdata;+ if (!ieee80211\_rx\_data\_set\_sta(&rx, &prev\_sta->sta,+ link\_id))+ goto out;++ if (!status->link\_valid && prev\_sta->sta.mlo) continue; - rx.link\_id = status->link\_valid ? link\_id : -1;- rx.sta = prev\_sta;- rx.sdata = prev\_sta->sdata; ieee80211\_prepare\_and\_rx\_handle(&rx, skb, false);  prev\_sta = sta; }  if (prev\_sta) {- if ((status->link\_valid &&- !ieee80211\_rx\_is\_valid\_sta\_link\_id(&prev\_sta->sta,- link\_id)) ||- (!status->link\_valid && prev\_sta->sta.mlo))+ rx.sdata = prev\_sta->sdata;+ if (!ieee80211\_rx\_data\_set\_sta(&rx, &prev\_sta->sta,+ link\_id)) goto out; - rx.link\_id = status->link\_valid ? link\_id : -1;- rx.sta = prev\_sta;- rx.sdata = prev\_sta->sdata;+ if (!status->link\_valid && prev\_sta->sta.mlo)+ goto out;  if (ieee80211\_prepare\_and\_rx\_handle(&rx, skb, true)) return; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 15:01:42 +0000



=== Content from git.kernel.org_5cfc9095_20250110_150304.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=a57c981d9f24d2bd89eaa76dc477e8ca252e22e8)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a57c981d9f24d2bd89eaa76dc477e8ca252e22e8)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a57c981d9f24d2bd89eaa76dc477e8ca252e22e8)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a57c981d9f24d2bd89eaa76dc477e8ca252e22e8)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Felix Fietkau <nbd@nbd.name> | 2022-12-30 21:07:47 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2023-01-24 07:24:33 +0100 |
| commit | [a57c981d9f24d2bd89eaa76dc477e8ca252e22e8](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a57c981d9f24d2bd89eaa76dc477e8ca252e22e8) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=a57c981d9f24d2bd89eaa76dc477e8ca252e22e8)) | |
| tree | [ac92bc3852eaeeb1343b127f5c01be505629cd1e](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a57c981d9f24d2bd89eaa76dc477e8ca252e22e8) | |
| parent | [c838df8461a601b20dc1b9fb1834d2aad8e2f949](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=c838df8461a601b20dc1b9fb1834d2aad8e2f949) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a57c981d9f24d2bd89eaa76dc477e8ca252e22e8&id2=c838df8461a601b20dc1b9fb1834d2aad8e2f949)) | |
| download | [linux-a57c981d9f24d2bd89eaa76dc477e8ca252e22e8.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-a57c981d9f24d2bd89eaa76dc477e8ca252e22e8.tar.gz) | |

wifi: mac80211: fix initialization of rx->link and rx->link\_stacommit e66b7920aa5ac5b1a1997a454004ba9246a3c005 upstream.
There are some codepaths that do not initialize rx->link\_sta properly. This
causes a crash in places which assume that rx->link\_sta is valid if rx->sta
is valid.
One known instance is triggered by \_\_ieee80211\_rx\_h\_amsdu being called from
fast-rx. It results in a crash like this one:
BUG: kernel NULL pointer dereference, address: 00000000000000a8
#PF: supervisor write access in kernel mode
#PF: error\_code(0x0002) - not-present page PGD 0 P4D 0
Oops: 0002 [#1] PREEMPT SMP PTI
CPU: 1 PID: 506 Comm: mt76-usb-rx phy Tainted: G E 6.1.0-debian64x+1.7 #3
Hardware name: ZOTAC ZBOX-ID92/ZBOX-IQ01/ZBOX-ID92/ZBOX-IQ01, BIOS B220P007 05/21/2014
RIP: 0010:ieee80211\_deliver\_skb+0x62/0x1f0 [mac80211]
Code: 00 48 89 04 24 e8 9e a7 c3 df 89 c0 48 03 1c c5 a0 ea 39 a1 4c 01 6b 08 48 ff 03 48
83 7d 28 00 74 11 48 8b 45 30 48 63 55 44 <48> 83 84 d0 a8 00 00 00 01 41 8b 86 c0
11 00 00 8d 50 fd 83 fa 01
RSP: 0018:ffff999040803b10 EFLAGS: 00010286
RAX: 0000000000000000 RBX: ffffb9903f496480 RCX: 0000000000000000
RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000
RBP: ffff999040803ce0 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000000 R12: ffff8d21828ac900
R13: 000000000000004a R14: ffff8d2198ed89c0 R15: ffff8d2198ed8000
FS: 0000000000000000(0000) GS:ffff8d24afe80000(0000) knlGS:0000000000000000
CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00000000000000a8 CR3: 0000000429810002 CR4: 00000000001706e0
Call Trace:
<TASK>
\_\_ieee80211\_rx\_h\_amsdu+0x1b5/0x240 [mac80211]
? ieee80211\_prepare\_and\_rx\_handle+0xcdd/0x1320 [mac80211]
? \_\_local\_bh\_enable\_ip+0x3b/0xa0
ieee80211\_prepare\_and\_rx\_handle+0xcdd/0x1320 [mac80211]
? prepare\_transfer+0x109/0x1a0 [xhci\_hcd]
ieee80211\_rx\_list+0xa80/0xda0 [mac80211]
mt76\_rx\_complete+0x207/0x2e0 [mt76]
mt76\_rx\_poll\_complete+0x357/0x5a0 [mt76]
mt76u\_rx\_worker+0x4f5/0x600 [mt76\_usb]
? mt76\_get\_min\_avg\_rssi+0x140/0x140 [mt76]
\_\_mt76\_worker\_fn+0x50/0x80 [mt76]
kthread+0xed/0x120
? kthread\_complete\_and\_exit+0x20/0x20
ret\_from\_fork+0x22/0x30
Since the initialization of rx->link and rx->link\_sta is rather convoluted
and duplicated in many places, clean it up by using a helper function to
set it.
Fixes: ccdde7c74ffd ("wifi: mac80211: properly implement MLO key handling")
Fixes: b320d6c456ff ("wifi: mac80211: use correct rx link\_sta instead of default")
Signed-off-by: Felix Fietkau <nbd@nbd.name>
Link: [https://lore.kernel.org/r/20221230200747.19040-1-nbd@nbd.name](https://lore.kernel.org/r/20221230200747.19040-1-nbd%40nbd.name)
[remove unnecessary rx->sta->sta.mlo check]
Cc: stable@vger.kernel.org
Signed-off-by: Johannes Berg <johannes.berg@intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a57c981d9f24d2bd89eaa76dc477e8ca252e22e8)

| -rw-r--r-- | [net/mac80211/rx.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/mac80211/rx.c?id=a57c981d9f24d2bd89eaa76dc477e8ca252e22e8) | 222 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 99 insertions, 123 deletions

| diff --git a/net/mac80211/rx.c b/net/mac80211/rx.cindex f99416d2e14417..3262ebb240926c 100644--- a/[net/mac80211/rx.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/mac80211/rx.c?id=c838df8461a601b20dc1b9fb1834d2aad8e2f949)+++ b/[net/mac80211/rx.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/mac80211/rx.c?id=a57c981d9f24d2bd89eaa76dc477e8ca252e22e8)@@ -4070,6 +4070,58 @@ static void ieee80211\_invoke\_rx\_handlers(struct ieee80211\_rx\_data \*rx) #undef CALL\_RXH } +static bool+ieee80211\_rx\_is\_valid\_sta\_link\_id(struct ieee80211\_sta \*sta, u8 link\_id)+{+ if (!sta->mlo)+ return false;++ return !!(sta->valid\_links & BIT(link\_id));+}++static bool ieee80211\_rx\_data\_set\_link(struct ieee80211\_rx\_data \*rx,+ u8 link\_id)+{+ rx->link\_id = link\_id;+ rx->link = rcu\_dereference(rx->sdata->link[link\_id]);++ if (!rx->sta)+ return rx->link;++ if (!ieee80211\_rx\_is\_valid\_sta\_link\_id(&rx->sta->sta, link\_id))+ return false;++ rx->link\_sta = rcu\_dereference(rx->sta->link[link\_id]);++ return rx->link && rx->link\_sta;+}++static bool ieee80211\_rx\_data\_set\_sta(struct ieee80211\_rx\_data \*rx,+ struct ieee80211\_sta \*pubsta,+ int link\_id)+{+ struct sta\_info \*sta;++ sta = container\_of(pubsta, struct sta\_info, sta);++ rx->link\_id = link\_id;+ rx->sta = sta;++ if (sta) {+ rx->local = sta->sdata->local;+ if (!rx->sdata)+ rx->sdata = sta->sdata;+ rx->link\_sta = &sta->deflink;+ }++ if (link\_id < 0)+ rx->link = &rx->sdata->deflink;+ else if (!ieee80211\_rx\_data\_set\_link(rx, link\_id))+ return false;++ return true;+}+ /\* \* This function makes calls into the RX path, therefore \* it has to be invoked under RCU read lock.@@ -4078,16 +4130,19 @@ void ieee80211\_release\_reorder\_timeout(struct sta\_info \*sta, int tid) { struct sk\_buff\_head frames; struct ieee80211\_rx\_data rx = {- .sta = sta,- .sdata = sta->sdata,- .local = sta->local, /\* This is OK -- must be QoS data frame \*/ .security\_idx = tid, .seqno\_idx = tid,- .link\_id = -1, }; struct tid\_ampdu\_rx \*tid\_agg\_rx;- u8 link\_id;+ int link\_id = -1;++ /\* FIXME: statistics won't be right with this \*/+ if (sta->sta.valid\_links)+ link\_id = ffs(sta->sta.valid\_links) - 1;++ if (!ieee80211\_rx\_data\_set\_sta(&rx, &sta->sta, link\_id))+ return;  tid\_agg\_rx = rcu\_dereference(sta->ampdu\_mlme.tid\_rx[tid]); if (!tid\_agg\_rx)@@ -4107,10 +4162,6 @@ void ieee80211\_release\_reorder\_timeout(struct sta\_info \*sta, int tid) }; drv\_event\_callback(rx.local, rx.sdata, &event); }- /\* FIXME: statistics won't be right with this \*/- link\_id = sta->sta.valid\_links ? ffs(sta->sta.valid\_links) - 1 : 0;- rx.link = rcu\_dereference(sta->sdata->link[link\_id]);- rx.link\_sta = rcu\_dereference(sta->link[link\_id]);  ieee80211\_rx\_handlers(&rx, &frames); }@@ -4126,7 +4177,6 @@ void ieee80211\_mark\_rx\_ba\_filtered\_frames(struct ieee80211\_sta \*pubsta, u8 tid, /\* This is OK -- must be QoS data frame \*/ .security\_idx = tid, .seqno\_idx = tid,- .link\_id = -1, }; int i, diff; @@ -4137,10 +4187,8 @@ void ieee80211\_mark\_rx\_ba\_filtered\_frames(struct ieee80211\_sta \*pubsta, u8 tid,  sta = container\_of(pubsta, struct sta\_info, sta); - rx.sta = sta;- rx.sdata = sta->sdata;- rx.link = &rx.sdata->deflink;- rx.local = sta->local;+ if (!ieee80211\_rx\_data\_set\_sta(&rx, pubsta, -1))+ return;  rcu\_read\_lock(); tid\_agg\_rx = rcu\_dereference(sta->ampdu\_mlme.tid\_rx[tid]);@@ -4527,15 +4575,6 @@ void ieee80211\_check\_fast\_rx\_iface(struct ieee80211\_sub\_if\_data \*sdata) mutex\_unlock(&local->sta\_mtx); } -static bool-ieee80211\_rx\_is\_valid\_sta\_link\_id(struct ieee80211\_sta \*sta, u8 link\_id)-{- if (!sta->mlo)- return false;-- return !!(sta->valid\_links & BIT(link\_id));-}- static void ieee80211\_rx\_8023(struct ieee80211\_rx\_data \*rx, struct ieee80211\_fast\_rx \*fast\_rx, int orig\_len)@@ -4646,7 +4685,6 @@ static bool ieee80211\_invoke\_fast\_rx(struct ieee80211\_rx\_data \*rx, struct sk\_buff \*skb = rx->skb; struct ieee80211\_hdr \*hdr = (void \*)skb->data; struct ieee80211\_rx\_status \*status = IEEE80211\_SKB\_RXCB(skb);- struct sta\_info \*sta = rx->sta; int orig\_len = skb->len; int hdrlen = ieee80211\_hdrlen(hdr->frame\_control); int snap\_offs = hdrlen;@@ -4658,7 +4696,6 @@ static bool ieee80211\_invoke\_fast\_rx(struct ieee80211\_rx\_data \*rx, u8 da[ETH\_ALEN]; u8 sa[ETH\_ALEN]; } addrs \_\_aligned(2);- struct link\_sta\_info \*link\_sta; struct ieee80211\_sta\_rx\_stats \*stats;  /\* for parallel-rx, we need to have DUP\_VALIDATED, otherwise we write@@ -4761,18 +4798,10 @@ static bool ieee80211\_invoke\_fast\_rx(struct ieee80211\_rx\_data \*rx, drop: dev\_kfree\_skb(skb); - if (rx->link\_id >= 0) {- link\_sta = rcu\_dereference(sta->link[rx->link\_id]);- if (!link\_sta)- return true;- } else {- link\_sta = &sta->deflink;- }- if (fast\_rx->uses\_rss)- stats = this\_cpu\_ptr(link\_sta->pcpu\_rx\_stats);+ stats = this\_cpu\_ptr(rx->link\_sta->pcpu\_rx\_stats); else- stats = &link\_sta->rx\_stats;+ stats = &rx->link\_sta->rx\_stats;  stats->dropped++; return true;@@ -4790,8 +4819,8 @@ static bool ieee80211\_prepare\_and\_rx\_handle(struct ieee80211\_rx\_data \*rx, struct ieee80211\_local \*local = rx->local; struct ieee80211\_sub\_if\_data \*sdata = rx->sdata; struct ieee80211\_hdr \*hdr = (void \*)skb->data;- struct link\_sta\_info \*link\_sta = NULL;- struct ieee80211\_link\_data \*link;+ struct link\_sta\_info \*link\_sta = rx->link\_sta;+ struct ieee80211\_link\_data \*link = rx->link;  rx->skb = skb; @@ -4813,35 +4842,6 @@ static bool ieee80211\_prepare\_and\_rx\_handle(struct ieee80211\_rx\_data \*rx, if (!ieee80211\_accept\_frame(rx)) return false; - if (rx->link\_id >= 0) {- link = rcu\_dereference(rx->sdata->link[rx->link\_id]);-- /\* we might race link removal \*/- if (!link)- return true;- rx->link = link;-- if (rx->sta) {- rx->link\_sta =- rcu\_dereference(rx->sta->link[rx->link\_id]);- if (!rx->link\_sta)- return true;- }- } else {- if (rx->sta)- rx->link\_sta = &rx->sta->deflink;-- rx->link = &sdata->deflink;- }-- if (unlikely(!is\_multicast\_ether\_addr(hdr->addr1) &&- rx->link\_id >= 0 && rx->sta && rx->sta->sta.mlo)) {- link\_sta = rcu\_dereference(rx->sta->link[rx->link\_id]);-- if (WARN\_ON\_ONCE(!link\_sta))- return true;- }- if (!consume) { struct skb\_shared\_hwtstamps \*shwt; @@ -4861,7 +4861,7 @@ static bool ieee80211\_prepare\_and\_rx\_handle(struct ieee80211\_rx\_data \*rx, shwt->hwtstamp = skb\_hwtstamps(skb)->hwtstamp; } - if (unlikely(link\_sta)) {+ if (unlikely(rx->sta && rx->sta->sta.mlo)) { /\* translate to MLD addresses \*/ if (ether\_addr\_equal(link->conf->addr, hdr->addr1)) ether\_addr\_copy(hdr->addr1, rx->sdata->vif.addr);@@ -4891,6 +4891,7 @@ static void \_\_ieee80211\_rx\_handle\_8023(struct ieee80211\_hw \*hw, struct ieee80211\_rx\_status \*status = IEEE80211\_SKB\_RXCB(skb); struct ieee80211\_fast\_rx \*fast\_rx; struct ieee80211\_rx\_data rx;+ int link\_id = -1;  memset(&rx, 0, sizeof(rx)); rx.skb = skb;@@ -4907,12 +4908,8 @@ static void \_\_ieee80211\_rx\_handle\_8023(struct ieee80211\_hw \*hw, if (!pubsta) goto drop; - rx.sta = container\_of(pubsta, struct sta\_info, sta);- rx.sdata = rx.sta->sdata;-- if (status->link\_valid &&- !ieee80211\_rx\_is\_valid\_sta\_link\_id(pubsta, status->link\_id))- goto drop;+ if (status->link\_valid)+ link\_id = status->link\_id;  /\* \* TODO: Should the frame be dropped if the right link\_id is not@@ -4921,19 +4918,8 @@ static void \_\_ieee80211\_rx\_handle\_8023(struct ieee80211\_hw \*hw, \* link\_id is used only for stats purpose and updating the stats on \* the deflink is fine? \*/- if (status->link\_valid)- rx.link\_id = status->link\_id;-- if (rx.link\_id >= 0) {- struct ieee80211\_link\_data \*link;-- link = rcu\_dereference(rx.sdata->link[rx.link\_id]);- if (!link)- goto drop;- rx.link = link;- } else {- rx.link = &rx.sdata->deflink;- }+ if (!ieee80211\_rx\_data\_set\_sta(&rx, pubsta, link\_id))+ goto drop;  fast\_rx = rcu\_dereference(rx.sta->fast\_rx); if (!fast\_rx)@@ -4951,6 +4937,8 @@ static bool ieee80211\_rx\_for\_interface(struct ieee80211\_rx\_data \*rx, { struct link\_sta\_info \*link\_sta; struct ieee80211\_hdr \*hdr = (void \*)skb->data;+ struct sta\_info \*sta;+ int link\_id = -1;  /\* \* Look up link station first, in case there's a@@ -4960,24 +4948,19 @@ static bool ieee80211\_rx\_for\_interface(struct ieee80211\_rx\_data \*rx, \*/ link\_sta = link\_sta\_info\_get\_bss(rx->sdata, hdr->addr2); if (link\_sta) {- rx->sta = link\_sta->sta;- rx->link\_id = link\_sta->link\_id;+ sta = link\_sta->sta;+ link\_id = link\_sta->link\_id; } else { struct ieee80211\_rx\_status \*status = IEEE80211\_SKB\_RXCB(skb); - rx->sta = sta\_info\_get\_bss(rx->sdata, hdr->addr2);- if (rx->sta) {- if (status->link\_valid &&- !ieee80211\_rx\_is\_valid\_sta\_link\_id(&rx->sta->sta,- status->link\_id))- return false;-- rx->link\_id = status->link\_valid ? status->link\_id : -1;- } else {- rx->link\_id = -1;- }+ sta = sta\_info\_get\_bss(rx->sdata, hdr->addr2);+ if (status->link\_valid)+ link\_id = status->link\_id; } + if (!ieee80211\_rx\_data\_set\_sta(rx, &sta->sta, link\_id))+ return false;+ return ieee80211\_prepare\_and\_rx\_handle(rx, skb, consume); } @@ -5036,19 +5019,15 @@ static void \_\_ieee80211\_rx\_handle\_packet(struct ieee80211\_hw \*hw,  if (ieee80211\_is\_data(fc)) { struct sta\_info \*sta, \*prev\_sta;- u8 link\_id = status->link\_id;+ int link\_id = -1; - if (pubsta) {- rx.sta = container\_of(pubsta, struct sta\_info, sta);- rx.sdata = rx.sta->sdata;+ if (status->link\_valid)+ link\_id = status->link\_id; - if (status->link\_valid &&- !ieee80211\_rx\_is\_valid\_sta\_link\_id(pubsta, link\_id))+ if (pubsta) {+ if (!ieee80211\_rx\_data\_set\_sta(&rx, pubsta, link\_id)) goto out; - if (status->link\_valid)- rx.link\_id = status->link\_id;- /\* \* In MLO connection, fetch the link\_id using addr2 \* when the driver does not pass link\_id in status.@@ -5066,7 +5045,7 @@ static void \_\_ieee80211\_rx\_handle\_packet(struct ieee80211\_hw \*hw, if (!link\_sta) goto out; - rx.link\_id = link\_sta->link\_id;+ ieee80211\_rx\_data\_set\_link(&rx, link\_sta->link\_id); }  if (ieee80211\_prepare\_and\_rx\_handle(&rx, skb, true))@@ -5082,30 +5061,27 @@ static void \_\_ieee80211\_rx\_handle\_packet(struct ieee80211\_hw \*hw, continue; } - if ((status->link\_valid &&- !ieee80211\_rx\_is\_valid\_sta\_link\_id(&prev\_sta->sta,- link\_id)) ||- (!status->link\_valid && prev\_sta->sta.mlo))+ rx.sdata = prev\_sta->sdata;+ if (!ieee80211\_rx\_data\_set\_sta(&rx, &prev\_sta->sta,+ link\_id))+ goto out;++ if (!status->link\_valid && prev\_sta->sta.mlo) continue; - rx.link\_id = status->link\_valid ? link\_id : -1;- rx.sta = prev\_sta;- rx.sdata = prev\_sta->sdata; ieee80211\_prepare\_and\_rx\_handle(&rx, skb, false);  prev\_sta = sta; }  if (prev\_sta) {- if ((status->link\_valid &&- !ieee80211\_rx\_is\_valid\_sta\_link\_id(&prev\_sta->sta,- link\_id)) ||- (!status->link\_valid && prev\_sta->sta.mlo))+ rx.sdata = prev\_sta->sdata;+ if (!ieee80211\_rx\_data\_set\_sta(&rx, &prev\_sta->sta,+ link\_id)) goto out; - rx.link\_id = status->link\_valid ? link\_id : -1;- rx.sta = prev\_sta;- rx.sdata = prev\_sta->sdata;+ if (!status->link\_valid && prev\_sta->sta.mlo)+ goto out;  if (ieee80211\_prepare\_and\_rx\_handle(&rx, skb, true)) return; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 15:01:41 +0000


