
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ffadeevab%2Fcocoon%2Fcommit%2F1b6392173ce35db4736a94b62b2d2973f9a71441)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ffadeevab%2Fcocoon%2Fcommit%2F1b6392173ce35db4736a94b62b2d2973f9a71441)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fcommit_fragments%2Frepo_layout&source=header-repo&source_repo=fadeevab%2Fcocoon)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[fadeevab](/fadeevab)
/
**[cocoon](/fadeevab/cocoon)**
Public

* [Notifications](/login?return_to=%2Ffadeevab%2Fcocoon) You must be signed in to change notification settings
* [Fork
  13](/login?return_to=%2Ffadeevab%2Fcocoon)
* [Star
   71](/login?return_to=%2Ffadeevab%2Fcocoon)

* [Code](/fadeevab/cocoon)
* [Issues
  0](/fadeevab/cocoon/issues)
* [Pull requests
  0](/fadeevab/cocoon/pulls)
* [Discussions](/fadeevab/cocoon/discussions)
* [Actions](/fadeevab/cocoon/actions)
* [Projects
  0](/fadeevab/cocoon/projects)
* [Security](/fadeevab/cocoon/security)
* [Insights](/fadeevab/cocoon/pulse)

Additional navigation options

* [Code](/fadeevab/cocoon)
* [Issues](/fadeevab/cocoon/issues)
* [Pull requests](/fadeevab/cocoon/pulls)
* [Discussions](/fadeevab/cocoon/discussions)
* [Actions](/fadeevab/cocoon/actions)
* [Projects](/fadeevab/cocoon/projects)
* [Security](/fadeevab/cocoon/security)
* [Insights](/fadeevab/cocoon/pulse)

## Commit

[Permalink](/fadeevab/cocoon/commit/1b6392173ce35db4736a94b62b2d2973f9a71441)

This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.

Support sequential calls of encryption API ([#23](https://github.com/fadeevab/cocoon/pull/23))

[Browse files](/fadeevab/cocoon/tree/1b6392173ce35db4736a94b62b2d2973f9a71441)
Browse the repository at this point in the history

```

* Removing 'self.rng.clone()' as cloning resets the seed is insecure.
- by removing the clone, cocoon has to be mutable now
- all tests pass
- this introduces a potential breaking change, but addresses a pretty big security risk.
* Affected API: `encrypt`, `wrap`, `dump`.

Some `mut`'s are not necessary, they will be cleaned up in the following commit.
```

* Loading branch information

[![@ProjectInitiative](https://avatars.githubusercontent.com/u/6314611?s=40&v=4)](/ProjectInitiative)

[ProjectInitiative](/fadeevab/cocoon/commits?author=ProjectInitiative "View all commits by ProjectInitiative")
authored
Oct 17, 2023

1 parent
[680b68c](/fadeevab/cocoon/commit/680b68c2126f7bc7e05e2b3968fcb0a5bd202976)

commit 1b63921

 Show file tree

 Hide file tree

Showing
**2 changed files**
with
**110 additions**
and
**71 deletions**.

* Whitespace
* Ignore whitespace

* Split
* Unified

* src

  + src/lib.rs
    [lib.rs](#diff-b1a35a68f14e696205874893c07fd24fdb88882b47c23cc0e0c80a30c7d53759)
  + src/mini.rs
    [mini.rs](#diff-c7aa46bcc08a9a49a868602949ba5897ee57ad5cc79a3e2571aae50d26f5a371)

## There are no files selected for viewing

109 changes: 64 additions & 45 deletions

109
[src/lib.rs](#diff-b1a35a68f14e696205874893c07fd24fdb88882b47c23cc0e0c80a30c7d53759 "src/lib.rs")

Show comments

[View file](/fadeevab/cocoon/blob/1b6392173ce35db4736a94b62b2d2973f9a71441/src/lib.rs)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -43,7 +43,7 @@ |
|  |  | //! # use cocoon::{MiniCocoon, Error}; |
|  |  | //! # |
|  |  | //! # fn main() -> Result<(), Error> { |
|  |  | //! let cocoon = MiniCocoon::from\_key(b"0123456789abcdef0123456789abcdef", &[0; 32]); |
|  |  | //! let mut cocoon = MiniCocoon::from\_key(b"0123456789abcdef0123456789abcdef", &[0; 32]); |
|  |  | //! |
|  |  | //! let wrapped = cocoon.wrap(b"my secret data")?; |
|  |  | //! assert\_ne!(&wrapped, b"my secret data"); |
| Expand All | | @@ -69,8 +69,8 @@ |
|  |  | //! # |
|  |  | //! # fn main() -> Result<(), Error> { |
|  |  | //! let mut data = b"my secret data".to\_vec(); |
|  |  | //! let cocoon = Cocoon::new(b"password"); |
|  |  | //! # let cocoon = cocoon.with\_weak\_kdf(); // Speed up doc tests. |
|  |  | //! let mut cocoon = Cocoon::new(b"password"); |
|  |  | //! # let mut cocoon = cocoon.with\_weak\_kdf(); // Speed up doc tests. |
|  |  | //! # let mut file = Cursor::new(vec![0; 150]); |
|  |  | //! |
|  |  | //! cocoon.dump(data, &mut file)?; |
| Expand Down  Expand Up | | @@ -101,7 +101,7 @@ |
|  |  | //! # |
|  |  | //! # fn main() -> Result<(), Error> { |
|  |  | //! let mut data = "my secret data".to\_owned().into\_bytes(); |
|  |  | //! let cocoon = MiniCocoon::from\_key(b"0123456789abcdef0123456789abcdef", &[0; 32]); |
|  |  | //! let mut cocoon = MiniCocoon::from\_key(b"0123456789abcdef0123456789abcdef", &[0; 32]); |
|  |  | //! |
|  |  | //! let detached\_prefix = cocoon.encrypt(&mut data)?; |
|  |  | //! assert\_ne!(data, b"my secret data"); |
| Expand Down  Expand Up | | @@ -149,7 +149,7 @@ |
|  |  | //! // Supply some password to Cocoon: it can be any byte array, basically. |
|  |  | //! // Don't use a hard-coded password in real life! |
|  |  | //! // It could be a user-supplied password. |
|  |  | //! let cocoon = Cocoon::new(b"secret password"); |
|  |  | //! let mut cocoon = Cocoon::new(b"secret password"); |
|  |  | //! |
|  |  | //! // Dump the serialized database into a file as an encrypted container. |
|  |  | //! let container = cocoon.dump(encoded, &mut file)?; |
| Expand Down  Expand Up | | @@ -322,8 +322,8 @@ pub use mini::\*; |
|  |  | /// # use cocoon::{Cocoon, Error}; |
|  |  | /// # |
|  |  | /// # fn main() -> Result<(), Error> { |
|  |  | /// let cocoon = Cocoon::new(b"password"); |
|  |  | /// # let cocoon = cocoon.with\_weak\_kdf(); // Speed up doc tests. |
|  |  | /// let mut cocoon = Cocoon::new(b"password"); |
|  |  | /// # let mut cocoon = cocoon.with\_weak\_kdf(); // Speed up doc tests. |
|  |  | /// |
|  |  | /// let wrapped = cocoon.wrap(b"my secret data")?; |
|  |  | /// assert\_ne!(&wrapped, b"my secret data"); |
| Expand Down  Expand Up | | @@ -435,7 +435,7 @@ impl<'a> Cocoon<'a, Creation> { |
|  |  | /// ``` |
|  |  | /// use cocoon::Cocoon; |
|  |  | /// |
|  |  | /// let cocoon = Cocoon::new(b"my secret password"); |
|  |  | /// let mut cocoon = Cocoon::new(b"my secret password"); |
|  |  | /// ``` |
|  |  | pub fn new(password: &'a [u8]) -> Self { |
|  |  | Cocoon { |
| Expand Down  Expand Up | | @@ -464,7 +464,7 @@ impl<'a> Cocoon<'a, Creation> { |
|  |  | /// // ThreadRng is used just for example. |
|  |  | /// let seed = rand::thread\_rng().gen::<[u8; 32]>(); |
|  |  | /// |
|  |  | /// let cocoon = Cocoon::from\_seed(b"password", seed); |
|  |  | /// let mut cocoon = Cocoon::from\_seed(b"password", seed); |
|  |  | /// ``` |
|  |  | /// |
|  |  | /// \*\*WARNING\*\*: Use this method carefully, don't feed it with a static seed unless testing! |
| Expand Down  Expand Up | | @@ -493,7 +493,7 @@ impl<'a> Cocoon<'a, Creation> { |
|  |  | /// # // [`ThreadRng`] is used here just as an example. It is supposed to apply some other |
|  |  | /// # // cryptographically secure RNG when [`ThreadRng`] is not accessible. |
|  |  | /// # let mut good\_rng = rand::rngs::ThreadRng::default(); |
|  |  | /// let cocoon = Cocoon::from\_rng(b"password", good\_rng).unwrap(); |
|  |  | /// let mut cocoon = Cocoon::from\_rng(b"password", good\_rng).unwrap(); |
|  |  | /// ``` |
|  |  | pub fn from\_rng<R: RngCore>(password: &'a [u8], rng: R) -> Result<Self, rand::Error> { |
|  |  | Ok(Cocoon { |
| Expand All | | @@ -516,7 +516,7 @@ impl<'a> Cocoon<'a, Creation> { |
|  |  | /// ``` |
|  |  | /// use cocoon::Cocoon; |
|  |  | /// |
|  |  | /// let cocoon = Cocoon::from\_entropy(b"password"); |
|  |  | /// let mut cocoon = Cocoon::from\_entropy(b"password"); |
|  |  | /// ``` |
|  |  | #[cfg(any(feature = "getrandom", test))] |
|  |  | #[cfg\_attr(docs\_rs, doc(cfg(feature = "getrandom")))] |
| Expand Down  Expand Up | | @@ -546,7 +546,7 @@ impl<'a> Cocoon<'a, Parsing> { |
|  |  | /// ```compile\_fail |
|  |  | /// use cocoon::Cocoon; |
|  |  | /// |
|  |  | /// let cocoon = Cocoon::parse\_only(b"password"); |
|  |  | /// let mut cocoon = Cocoon::parse\_only(b"password"); |
|  |  | /// |
|  |  | /// // The compilation process fails here denying to use any encryption method. |
|  |  | /// cocoon.wrap(b"my data"); |
| Expand All | | @@ -557,7 +557,7 @@ impl<'a> Cocoon<'a, Parsing> { |
|  |  | /// use cocoon::{Cocoon, Error}; |
|  |  | /// |
|  |  | /// # fn main() -> Result<(), Error> { |
|  |  | /// let cocoon = Cocoon::parse\_only(b"password"); |
|  |  | /// let mut cocoon = Cocoon::parse\_only(b"password"); |
|  |  | /// |
|  |  | /// # let mut data = [ |
|  |  | /// # 244, 85, 222, 144, 119, 169, 144, 11, 178, 216, 4, 57, 17, 47, 0, |
| Expand Down  Expand Up | | @@ -591,7 +591,7 @@ impl<'a> Cocoon<'a, Creation> { |
|  |  | /// ``` |
|  |  | /// use cocoon::{Cocoon, CocoonCipher}; |
|  |  | /// |
|  |  | /// let cocoon = Cocoon::new(b"password").with\_cipher(CocoonCipher::Aes256Gcm); |
|  |  | /// let mut cocoon = Cocoon::new(b"password").with\_cipher(CocoonCipher::Aes256Gcm); |
|  |  | /// cocoon.wrap(b"my secret data"); |
|  |  | /// ``` |
|  |  | pub fn with\_cipher(mut self, cipher: CocoonCipher) -> Self { |
| Expand All | | @@ -608,7 +608,7 @@ impl<'a> Cocoon<'a, Creation> { |
|  |  | /// ``` |
|  |  | /// use cocoon::Cocoon; |
|  |  | /// |
|  |  | /// let cocoon = Cocoon::new(b"password").with\_weak\_kdf(); |
|  |  | /// let mut cocoon = Cocoon::new(b"password").with\_weak\_kdf(); |
|  |  | /// cocoon.wrap(b"my secret data").expect("New container"); |
|  |  | /// ``` |
|  |  | pub fn with\_weak\_kdf(mut self) -> Self { |
| Expand All | | @@ -625,8 +625,8 @@ impl<'a> Cocoon<'a, Creation> { |
|  |  | /// # use cocoon::{Cocoon, Error}; |
|  |  | /// # |
|  |  | /// # fn main() -> Result<(), Error> { |
|  |  | /// let cocoon = Cocoon::new(b"password"); |
|  |  | /// # let cocoon = cocoon.with\_weak\_kdf(); // Speed up doc tests. |
|  |  | /// let mut cocoon = Cocoon::new(b"password"); |
|  |  | /// # let mut cocoon = cocoon.with\_weak\_kdf(); // Speed up doc tests. |
|  |  | /// |
|  |  | /// let wrapped = cocoon.wrap(b"my secret data")?; |
|  |  | /// assert\_ne!(&wrapped, b"my secret data"); |
| Expand All | | @@ -636,7 +636,7 @@ impl<'a> Cocoon<'a, Creation> { |
|  |  | /// ``` |
|  |  | #[cfg(feature = "alloc")] |
|  |  | #[cfg\_attr(docs\_rs, doc(cfg(any(feature = "alloc", feature = "std"))))] |
|  |  | pub fn wrap(&self, data: &[u8]) -> Result<Vec<u8>, Error> { |
|  |  | pub fn wrap(&mut self, data: &[u8]) -> Result<Vec<u8>, Error> { |
|  |  | // Allocation is needed because there is no way to prefix encrypted |
|  |  | // data with a header without an allocation. It means that we need |
|  |  | // to copy data at least once. It's necessary to avoid any further copying. |
| Expand Down  Expand Up | | @@ -669,8 +669,8 @@ impl<'a> Cocoon<'a, Creation> { |
|  |  | /// # |
|  |  | /// # fn main() -> Result<(), Error> { |
|  |  | /// let mut data = b"my secret data".to\_vec(); |
|  |  | /// let cocoon = Cocoon::new(b"password"); |
|  |  | /// # let cocoon = cocoon.with\_weak\_kdf(); // Speed up doc tests. |
|  |  | /// let mut cocoon = Cocoon::new(b"password"); |
|  |  | /// # let mut cocoon = cocoon.with\_weak\_kdf(); // Speed up doc tests. |
|  |  | /// # let mut file = Cursor::new(vec![0; 150]); |
|  |  | /// |
|  |  | /// cocoon.dump(data, &mut file)?; |
| Expand All | | @@ -680,7 +680,7 @@ impl<'a> Cocoon<'a, Creation> { |
|  |  | /// # } |
|  |  | #[cfg(feature = "std")] |
|  |  | #[cfg\_attr(docs\_rs, doc(cfg(feature = "std")))] |
|  |  | pub fn dump(&self, mut data: Vec<u8>, writer: &mut impl Write) -> Result<(), Error> { |
|  |  | pub fn dump(&mut self, mut data: Vec<u8>, writer: &mut impl Write) -> Result<(), Error> { |
|  |  | let detached\_prefix = self.encrypt(&mut data)?; |
|  |  |  |
|  |  | writer.write\_all(&detached\_prefix)?; |
| Expand All | | @@ -706,27 +706,25 @@ impl<'a> Cocoon<'a, Creation> { |
|  |  | /// # // cryptographically secure RNG when [`ThreadRng`] is not accessible. |
|  |  | /// # let mut good\_rng = rand::rngs::ThreadRng::default(); |
|  |  | /// let mut data = "my secret data".to\_owned().into\_bytes(); |
|  |  | /// let cocoon = Cocoon::from\_rng(b"password", good\_rng).unwrap(); |
|  |  | /// # let cocoon = cocoon.with\_weak\_kdf(); // Speed up doc tests. |
|  |  | /// let mut cocoon = Cocoon::from\_rng(b"password", good\_rng).unwrap(); |
|  |  | /// # let mut cocoon = cocoon.with\_weak\_kdf(); // Speed up doc tests. |
|  |  | /// |
|  |  | /// let detached\_prefix = cocoon.encrypt(&mut data)?; |
|  |  | /// assert\_ne!(data, b"my secret data"); |
|  |  | /// # Ok(()) |
|  |  | /// # } |
|  |  | /// ``` |
|  |  | pub fn encrypt(&self, data: &mut [u8]) -> Result<[u8; PREFIX\_SIZE], Error> { |
|  |  | pub fn encrypt(&mut self, data: &mut [u8]) -> Result<[u8; PREFIX\_SIZE], Error> { |
|  |  | let mut salt = [0u8; 16]; |
|  |  | let mut nonce = [0u8; 12]; |
|  |  |  |
|  |  | match &self.rng { |
|  |  | match self.rng { |
|  |  | #[cfg(feature = "std")] |
|  |  | RngVariant::Thread(rng) => { |
|  |  | let mut rng = rng.clone(); |
|  |  | RngVariant::Thread(ref mut rng) => { |
|  |  | rng.fill\_bytes(&mut salt); |
|  |  | rng.fill\_bytes(&mut nonce); |
|  |  | } |
|  |  | RngVariant::Std(rng) => { |
|  |  | let mut rng = rng.clone(); |
|  |  | RngVariant::Std(ref mut rng) => { |
|  |  | rng.fill\_bytes(&mut salt); |
|  |  | rng.fill\_bytes(&mut nonce); |
|  |  | } |
| Expand Down  Expand Up | | @@ -771,8 +769,8 @@ impl<'a, M> Cocoon<'a, M> { |
|  |  | /// # use cocoon::{Cocoon, Error}; |
|  |  | /// # |
|  |  | /// # fn main() -> Result<(), Error> { |
|  |  | /// let cocoon = Cocoon::new(b"password"); |
|  |  | /// # let cocoon = cocoon.with\_weak\_kdf(); // Speed up doc tests. |
|  |  | /// let mut cocoon = Cocoon::new(b"password"); |
|  |  | /// # let mut cocoon = cocoon.with\_weak\_kdf(); // Speed up doc tests. |
|  |  | /// |
|  |  | /// # let wrapped = cocoon.wrap(b"my secret data")?; |
|  |  | /// # assert\_ne!(&wrapped, b"my secret data"); |
| Expand Down  Expand Up | | @@ -813,8 +811,8 @@ impl<'a, M> Cocoon<'a, M> { |
|  |  | /// # |
|  |  | /// # fn main() -> Result<(), Error> { |
|  |  | /// let mut data = b"my secret data".to\_vec(); |
|  |  | /// let cocoon = Cocoon::new(b"password"); |
|  |  | /// # let cocoon = cocoon.with\_weak\_kdf(); // Speed up doc tests. |
|  |  | /// let mut cocoon = Cocoon::new(b"password"); |
|  |  | /// # let mut cocoon = cocoon.with\_weak\_kdf(); // Speed up doc tests. |
|  |  | /// # let mut file = Cursor::new(vec![0; 150]); |
|  |  | /// |
|  |  | /// # cocoon.dump(data, &mut file)?; |
| Expand Down  Expand Up | | @@ -855,8 +853,8 @@ impl<'a, M> Cocoon<'a, M> { |
|  |  | /// # // cryptographically secure RNG when [`ThreadRng`] is not accessible. |
|  |  | /// # let mut good\_rng = rand::rngs::ThreadRng::default(); |
|  |  | /// let mut data = "my secret data".to\_owned().into\_bytes(); |
|  |  | /// let cocoon = Cocoon::from\_rng(b"password", good\_rng).unwrap(); |
|  |  | /// # let cocoon = cocoon.with\_weak\_kdf(); // Speed up doc tests. |
|  |  | /// let mut cocoon = Cocoon::from\_rng(b"password", good\_rng).unwrap(); |
|  |  | /// # let mut cocoon = cocoon.with\_weak\_kdf(); // Speed up doc tests. |
|  |  | /// |
|  |  | /// let detached\_prefix = cocoon.encrypt(&mut data)?; |
|  |  | /// assert\_ne!(data, b"my secret data"); |
| Expand Down  Expand Up | | @@ -932,10 +930,10 @@ mod test { |
|  |  |  |
|  |  | #[test] |
|  |  | fn cocoon\_encrypt() { |
|  |  | let cocoon = Cocoon::from\_seed(b"password", [0; 32]).with\_weak\_kdf(); |
|  |  | let mut cocoon = Cocoon::from\_seed(b"password", [0; 32]).with\_weak\_kdf(); |
|  |  | let mut data = "my secret data".to\_owned().into\_bytes(); |
|  |  |  |
|  |  | let detached\_prefix = cocoon.encrypt(&mut data).unwrap(); |
|  |  | let detached\_prefix = &cocoon.encrypt(&mut data).unwrap(); |
|  |  |  |
|  |  | assert\_eq!( |
|  |  | &[ |
| Expand All | | @@ -951,11 +949,22 @@ mod test { |
|  |  | &[186, 240, 214, 29, 4, 147, 205, 72, 210, 7, 167, 234, 199, 53], |
|  |  | &data[..] |
|  |  | ); |
|  |  |  |
|  |  | let mut cipher\_data: Vec<Vec<u8>> = Vec::new(); |
|  |  | cipher\_data.push(data.to\_vec()); |
|  |  | for \_ in 0..10 { |
|  |  | data = "my secret data".to\_owned().into\_bytes(); |
|  |  | let \_ = cocoon.encrypt(&mut data).unwrap(); |
|  |  | cipher\_data.push(data.to\_vec()); |
|  |  | for i in 0..cipher\_data.len() - 2 { |
|  |  | assert\_ne!(&cipher\_data.last().unwrap(), &cipher\_data.get(i).unwrap()) |
|  |  | } |
|  |  | } |
|  |  | } |
|  |  |  |
|  |  | #[test] |
|  |  | fn cocoon\_encrypt\_aes() { |
|  |  | let cocoon = Cocoon::from\_seed(b"password", [0; 32]) |
|  |  | let mut cocoon = Cocoon::from\_seed(b"password", [0; 32]) |
|  |  | .with\_weak\_kdf() |
|  |  | .with\_cipher(CocoonCipher::Aes256Gcm); |
|  |  | let mut data = "my secret data".to\_owned().into\_bytes(); |
| Expand All | | @@ -976,6 +985,16 @@ mod test { |
|  |  | &[88, 183, 11, 7, 192, 224, 203, 107, 144, 162, 48, 78, 61, 223], |
|  |  | &data[..] |
|  |  | ); |
|  |  | let mut cipher\_data: Vec<Vec<u8>> = Vec::new(); |
|  |  | cipher\_data.push(data.to\_vec()); |
|  |  | for \_ in 0..10 { |
|  |  | data = "my secret data".to\_owned().into\_bytes(); |
|  |  | let \_ = cocoon.encrypt(&mut data).unwrap(); |
|  |  | cipher\_data.push(data.to\_vec()); |
|  |  | for i in 0..cipher\_data.len() - 2 { |
|  |  | assert\_ne!(&cipher\_data.last().unwrap(), &cipher\_data.get(i).unwrap()) |
|  |  | } |
|  |  | } |
|  |  | } |
|  |  |  |
|  |  | #[test] |
| Expand Down  Expand Up | | @@ -1018,15 +1037,15 @@ mod test { |
|  |  |  |
|  |  | #[test] |
|  |  | fn cocoon\_wrap() { |
|  |  | let cocoon = Cocoon::from\_seed(b"password", [0; 32]); |
|  |  | let mut cocoon = Cocoon::from\_seed(b"password", [0; 32]); |
|  |  | let wrapped = cocoon.wrap(b"data").expect("Wrapped container"); |
|  |  |  |
|  |  | assert\_eq!(wrapped[wrapped.len() - 4..], [27, 107, 178, 181]); |
|  |  | } |
|  |  |  |
|  |  | #[test] |
|  |  | fn cocoon\_wrap\_unwrap() { |
|  |  | let cocoon = Cocoon::from\_seed(b"password", [0; 32]); |
|  |  | let mut cocoon = Cocoon::from\_seed(b"password", [0; 32]); |
|  |  | let wrapped = cocoon.wrap(b"data").expect("Wrapped container"); |
|  |  | let original = cocoon.unwrap(&wrapped).expect("Unwrapped container"); |
|  |  |  |
| Expand All | | @@ -1035,7 +1054,7 @@ mod test { |
|  |  |  |
|  |  | #[test] |
|  |  | fn cocoon\_wrap\_unwrap\_corrupted() { |
|  |  | let cocoon = Cocoon::from\_seed(b"password", [0; 32]); |
|  |  | let mut cocoon = Cocoon::from\_seed(b"password", [0; 32]); |
|  |  | let mut wrapped = cocoon.wrap(b"data").expect("Wrapped container"); |
|  |  |  |
|  |  | let last = wrapped.len() - 1; |
| Expand All | | @@ -1045,7 +1064,7 @@ mod test { |
|  |  |  |
|  |  | #[test] |
|  |  | fn cocoon\_unwrap\_larger\_is\_ok() { |
|  |  | let cocoon = Cocoon::from\_seed(b"password", [0; 32]); |
|  |  | let mut cocoon = Cocoon::from\_seed(b"password", [0; 32]); |
|  |  | let mut wrapped = cocoon.wrap(b"data").expect("Wrapped container"); |
|  |  |  |
|  |  | wrapped.push(0); |
| Expand All | | @@ -1056,7 +1075,7 @@ mod test { |
|  |  |  |
|  |  | #[test] |
|  |  | fn cocoon\_unwrap\_too\_short() { |
|  |  | let cocoon = Cocoon::from\_seed(b"password", [0; 32]); |
|  |  | let mut cocoon = Cocoon::from\_seed(b"password", [0; 32]); |
|  |  | let mut wrapped = cocoon.wrap(b"data").expect("Wrapped container"); |
|  |  |  |
|  |  | wrapped.pop(); |
| Expand Down  Expand Up | | @@ -1090,7 +1109,7 @@ mod test { |
|  |  | fn cocoon\_dump\_parse() { |
|  |  | let buf = vec![0; 100]; |
|  |  | let mut file = Cursor::new(buf); |
|  |  | let cocoon = Cocoon::from\_seed(b"password", [0; 32]).with\_weak\_kdf(); |
|  |  | let mut cocoon = Cocoon::from\_seed(b"password", [0; 32]).with\_weak\_kdf(); |
|  |  |  |
|  |  | // Prepare data inside of `Vec` container. |
|  |  | let data = b"my data".to\_vec(); |
| Expand All | | @@ -1113,7 +1132,7 @@ mod test { |
|  |  | File::create(read\_only\_file.clone()).expect("Test file"); |
|  |  | let mut file = File::open(read\_only\_file).expect("Test file"); |
|  |  |  |
|  |  | let cocoon = Cocoon::from\_seed(b"password", [0; 32]).with\_weak\_kdf(); |
|  |  | let mut cocoon = Cocoon::from\_seed(b"password", [0; 32]).with\_weak\_kdf(); |
|  |  |  |
|  |  | // Prepare data inside of `Vec` container. |
|  |  | let data = b"my data".to\_vec(); |
| Expand Down | |  |

 Loading

Oops, something went wrong.
 Retry

Toggle all file notes
Toggle all file annotations

### 0 comments on commit `1b63921`

Please
[sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ffadeevab%2Fcocoon%2Fcommit%2F1b6392173ce35db4736a94b62b2d2973f9a71441) to comment.

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

