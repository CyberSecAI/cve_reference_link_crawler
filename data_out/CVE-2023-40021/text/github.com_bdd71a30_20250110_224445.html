
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Foppia%2Foppia%2Fblob%2F3a05c3558a292f3db9e658e60e708c266c003fd0%2Fcore%2Fcontrollers%2Fbase.py)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Foppia%2Foppia%2Fblob%2F3a05c3558a292f3db9e658e60e708c266c003fd0%2Fcore%2Fcontrollers%2Fbase.py)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=oppia%2Foppia)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[oppia](/oppia)
/
**[oppia](/oppia/oppia)**
Public

* [Notifications](/login?return_to=%2Foppia%2Foppia) You must be signed in to change notification settings
* [Fork
  4.3k](/login?return_to=%2Foppia%2Foppia)
* [Star
   5.9k](/login?return_to=%2Foppia%2Foppia)

* [Code](/oppia/oppia)
* [Issues
  1.4k](/oppia/oppia/issues)
* [Pull requests
  38](/oppia/oppia/pulls)
* [Discussions](/oppia/oppia/discussions)
* [Actions](/oppia/oppia/actions)
* [Projects
  6](/oppia/oppia/projects)
* [Wiki](/oppia/oppia/wiki)
* [Security](/oppia/oppia/security)
* [Insights](/oppia/oppia/pulse)

Additional navigation options

* [Code](/oppia/oppia)
* [Issues](/oppia/oppia/issues)
* [Pull requests](/oppia/oppia/pulls)
* [Discussions](/oppia/oppia/discussions)
* [Actions](/oppia/oppia/actions)
* [Projects](/oppia/oppia/projects)
* [Wiki](/oppia/oppia/wiki)
* [Security](/oppia/oppia/security)
* [Insights](/oppia/oppia/pulse)

## Files

 3a05c35
## Breadcrumbs

1. [oppia](/oppia/oppia/tree/3a05c3558a292f3db9e658e60e708c266c003fd0)
2. /[core](/oppia/oppia/tree/3a05c3558a292f3db9e658e60e708c266c003fd0/core)
3. /[controllers](/oppia/oppia/tree/3a05c3558a292f3db9e658e60e708c266c003fd0/core/controllers)
/
# base.py

Copy path Blame  Blame
## Latest commit

## History

[History](/oppia/oppia/commits/3a05c3558a292f3db9e658e60e708c266c003fd0/core/controllers/base.py)executable file·1045 lines (876 loc) · 40.4 KB 3a05c35
## Breadcrumbs

1. [oppia](/oppia/oppia/tree/3a05c3558a292f3db9e658e60e708c266c003fd0)
2. /[core](/oppia/oppia/tree/3a05c3558a292f3db9e658e60e708c266c003fd0/core)
3. /[controllers](/oppia/oppia/tree/3a05c3558a292f3db9e658e60e708c266c003fd0/core/controllers)
/
# base.py

Top
## File metadata and controls

* Code
* Blame

executable file·1045 lines (876 loc) · 40.4 KB[Raw](https://github.com/oppia/oppia/raw/3a05c3558a292f3db9e658e60e708c266c003fd0/core/controllers/base.py)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000# Copyright 2014 The Oppia Authors. All Rights Reserved.## Licensed under the Apache License, Version 2.0 (the "License");# you may not use this file except in compliance with the License.# You may obtain a copy of the License at## http://www.apache.org/licenses/LICENSE-2.0## Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an "AS-IS" BASIS,# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.# See the License for the specific language governing permissions and# limitations under the License.
"""Base constants and handlers."""
from \_\_future\_\_ import annotations
import abcimport base64import datetimeimport functoolsimport hmacimport ioimport jsonimport loggingimport osimport reimport timeimport urllib
from core import feconffrom core import handler\_schema\_constantsfrom core import utilsfrom core.controllers import payload\_validatorfrom core.domain import auth\_domainfrom core.domain import auth\_servicesfrom core.domain import classifier\_domainfrom core.domain import config\_domainfrom core.domain import config\_servicesfrom core.domain import user\_services
from typing import ( Any, Dict, Final, Generic, Mapping, Optional, Sequence, TypedDict, TypeVar, Union)
import webapp2
# Note: These private type variables are only defined to implement the Generic# typing structure of BaseHandler. So, do not make them public in the future.\_NormalizedRequestDictType = TypeVar('\_NormalizedRequestDictType')\_NormalizedPayloadDictType = TypeVar('\_NormalizedPayloadDictType')
ONE\_DAY\_AGO\_IN\_SECS: Final = -24 \* 60 \* 60DEFAULT\_CSRF\_SECRET: Final = 'oppia csrf secret'CSRF\_SECRET: Final = config\_domain.ConfigProperty( 'oppia\_csrf\_secret', {'type': 'unicode'}, 'Text used to encrypt CSRF tokens.', DEFAULT\_CSRF\_SECRET)
# NOTE: These handlers manage user sessions and serve auth pages. Thus, we# should never reject or replace them when running in maintenance mode;# otherwise admins will be unable to access the site.AUTH\_HANDLER\_PATHS: Final = ( '/csrfhandler', '/login', '/session\_begin', '/session\_end',)
class ResponseValueDict(TypedDict): """Dict representation of key-value pairs that will be included in the response. """
 error: str status\_code: int
@functools.lru\_cache(maxsize=128)def load\_template( filename: str, \*, template\_is\_aot\_compiled: bool) -> str: """Return the HTML file contents at filepath.
 Args: filename: str. Name of the requested HTML file. template\_is\_aot\_compiled: bool. Used to determine which bundle to use.
 Returns: str. The HTML file content. """ filepath = os.path.join( ( feconf.FRONTEND\_AOT\_DIR if template\_is\_aot\_compiled else feconf.FRONTEND\_TEMPLATES\_DIR ), filename ) with utils.open\_file(filepath, 'r') as f: html\_text = f.read() return html\_text
class SessionBeginHandler(webapp2.RequestHandler): """Handler for creating new authentication sessions."""
 def get(self) -> None: """Establishes a new auth session.""" auth\_services.establish\_auth\_session(self.request, self.response)
class SessionEndHandler(webapp2.RequestHandler): """Handler for destroying existing authentication sessions."""
 def get(self) -> None: """Destroys an existing auth session.""" auth\_services.destroy\_auth\_session(self.response)
class UserFacingExceptions: """This class contains all the exception class definitions used."""
 class NotLoggedInException(Exception): """Error class for users that are not logged in (error code 401)."""
 pass
 class InvalidInputException(Exception): """Error class for invalid input on the user side (error code 400)."""
 pass
 class UnauthorizedUserException(Exception): """Error class for unauthorized access."""
 pass
 class PageNotFoundException(Exception): """Error class for a page not found error (error code 404)."""
 pass
 class InternalErrorException(Exception): """Error class for an internal server side error (error code 500)."""
 pass
class BaseHandler( webapp2.RequestHandler, Generic[\_NormalizedPayloadDictType, \_NormalizedRequestDictType]): """Base class for all Oppia handlers."""
 # Whether to check POST and PUT payloads for CSRF tokens prior to # processing them. Can be overridden by subclasses if this check is # not necessary. REQUIRE\_PAYLOAD\_CSRF\_CHECK = True # Whether to redirect requests corresponding to a logged-in user who has # not completed signup in to the signup page. This ensures that logged-in # users have agreed to the latest terms. REDIRECT\_UNFINISHED\_SIGNUPS = True
 # What format the get method returns when exception raised, json or html. GET\_HANDLER\_ERROR\_RETURN\_TYPE = feconf.HANDLER\_TYPE\_HTML POST\_HANDLER\_ERROR\_RETURN\_TYPE = feconf.HANDLER\_TYPE\_JSON PUT\_HANDLER\_ERROR\_RETURN\_TYPE = feconf.HANDLER\_TYPE\_JSON DELETE\_HANDLER\_ERROR\_RETURN\_TYPE = feconf.HANDLER\_TYPE\_JSON
 # Here we use type Any because the sub-classes of BaseHandler can contain # different schemas with different types of values, like str, complex Dicts # and etc. URL\_PATH\_ARGS\_SCHEMAS: Optional[Dict[str, Any]] = None # Here we use type Any because the sub-classes of BaseHandler can contain # different schemas with different types of values, like str, complex Dicts # and etc. HANDLER\_ARGS\_SCHEMAS: Optional[Dict[str, Any]] = None
 def \_\_init\_\_( # pylint: disable=super-init-not-called self, request: webapp2.Request, response: webapp2.Response ) -> None: # Set self.request, self.response and self.app. self.initialize(request, response)
 self.start\_time = datetime.datetime.utcnow()
 # Here we use type Any because dict 'self.values' is a return dict # for the handlers, and different handlers can return different # key-value pairs. So, to allow every type of key-value pair, we # used Any type here. self.values: Dict[str, Any] = {}
 # This try-catch block is intended to log cases where getting the # request payload errors with ValueError: Invalid boundary in multipart # form: b''. This is done to gather sufficient data to help debug the # error if it arises in the future. try: payload\_json\_string = self.request.get('payload') except ValueError as e: logging.error('%s: request %s', e, self.request) raise e # TODO(#13155): Remove the if-else part once all the handlers have had # schema validation implemented. if payload\_json\_string: self.payload = json.loads(payload\_json\_string) else: self.payload = None self.iframed = False
 self.user\_id = None self.username = None self.email = None self.partially\_logged\_in = False self.user\_is\_scheduled\_for\_deletion = False self.current\_user\_is\_super\_admin = False self.normalized\_request: Optional[\_NormalizedRequestDictType] = None self.normalized\_payload: Optional[\_NormalizedPayloadDictType] = None
 try: auth\_claims = auth\_services.get\_auth\_claims\_from\_request(request) except auth\_domain.StaleAuthSessionError: auth\_services.destroy\_auth\_session(self.response) self.redirect(user\_services.create\_login\_url(self.request.uri)) return except auth\_domain.UserDisabledError: auth\_services.destroy\_auth\_session(self.response) self.redirect( '/logout?redirect\_url=%s' % feconf.PENDING\_ACCOUNT\_DELETION\_URL) return except auth\_domain.InvalidAuthSessionError: logging.exception('User session is invalid!') auth\_services.destroy\_auth\_session(self.response) self.redirect(user\_services.create\_login\_url(self.request.uri)) return else: self.current\_user\_is\_super\_admin = ( auth\_claims is not None and auth\_claims.role\_is\_super\_admin)
 if auth\_claims: auth\_id = auth\_claims.auth\_id user\_settings = user\_services.get\_user\_settings\_by\_auth\_id(auth\_id) if user\_settings is None: # If the user settings are not yet created and the request leads # to signup page create a new user settings. Otherwise logout # the not-fully registered user. email = auth\_claims.email if email is None: logging.exception( 'No email address was found for the user.' ) auth\_services.destroy\_auth\_session(self.response) return if 'signup?' in self.request.uri: user\_settings = ( user\_services.create\_new\_user(auth\_id, email)) else: logging.error( 'Cannot find user %s with email %s on page %s' % ( auth\_id, email, self.request.uri)) auth\_services.destroy\_auth\_session(self.response) return
 self.email = user\_settings.email self.values['user\_email'] = user\_settings.email self.user\_id = user\_settings.user\_id
 if user\_settings.deleted: self.user\_is\_scheduled\_for\_deletion = user\_settings.deleted elif (self.REDIRECT\_UNFINISHED\_SIGNUPS and not user\_services.has\_fully\_registered\_account(self.user\_id)): self.partially\_logged\_in = True else: self.username = user\_settings.username self.values['username'] = self.username # In order to avoid too many datastore writes, we do not bother # recording a log-in if the current time is sufficiently close # to the last log-in time. if (user\_settings.last\_logged\_in is None or not utils.are\_datetimes\_close( datetime.datetime.utcnow(), user\_settings.last\_logged\_in)): user\_services.record\_user\_logged\_in(self.user\_id)
 self.roles = user\_settings.roles
 if self.user\_id is None: self.roles = [feconf.ROLE\_ID\_GUEST]
 self.user = user\_services.get\_user\_actions\_info(self.user\_id)
 if not self.\_is\_requested\_path\_currently\_accessible\_to\_user(): auth\_services.destroy\_auth\_session(self.response) return
 self.values['is\_super\_admin'] = self.current\_user\_is\_super\_admin
 def dispatch(self) -> None: """Overrides dispatch method in webapp2 superclass.
 Raises: Exception. The CSRF token is missing. UnauthorizedUserException. The CSRF token is invalid. """ request\_split = urllib.parse.urlsplit(self.request.uri) # If the request is to the old demo server, redirect it permanently to # the new demo server. (Unless it is a cron job or tasks request, # because cron job and tasks destination URLs are generated by # App Engine and we can't change their destination.) if ( request\_split.netloc == 'oppiaserver.appspot.com' and not request\_split.path.startswith(('/cron/', '/task/')) ): self.redirect('https://oppiatestserver.appspot.com', permanent=True) return
 if not self.\_is\_requested\_path\_currently\_accessible\_to\_user(): self.render\_template('maintenance-page.mainpage.html') return
 if self.user\_is\_scheduled\_for\_deletion: self.redirect( '/logout?redirect\_url=%s' % feconf.PENDING\_ACCOUNT\_DELETION\_URL) return
 if self.partially\_logged\_in and request\_split.path != '/logout': self.redirect('/logout?redirect\_url=%s' % request\_split.path) return
 if self.payload is not None and self.REQUIRE\_PAYLOAD\_CSRF\_CHECK: try: # If user opens a new tab during signup process, the user\_id # parameter is set to None and this causes the signup session # to expire. The code here checks if user is on the signup # page and the user\_id is None, if that is the case an exception # is raised which is handled by the frontend by showing a # continue to registration modal. if 'signup' in self.request.uri and not self.user\_id: raise self.UnauthorizedUserException( 'Registration session expired.') csrf\_token = self.request.get('csrf\_token') if not csrf\_token: raise self.UnauthorizedUserException( 'Missing CSRF token. Changes were not saved. ' 'Please report this bug.')
 is\_csrf\_token\_valid = CsrfTokenManager.is\_csrf\_token\_valid( self.user\_id, csrf\_token)
 if not is\_csrf\_token\_valid: raise self.UnauthorizedUserException( 'Your session has expired, and unfortunately your ' 'changes cannot be saved. Please refresh the page.') except Exception as e: logging.exception('%s: payload %s', e, self.payload)
 self.handle\_exception(e, self.app.debug) return
 schema\_validation\_succeeded = True try: self.validate\_and\_normalize\_args()
 # TODO(#13155): Remove NotImplementedError once all the handlers # have had schema validation implemented. except ( NotImplementedError, self.InternalErrorException, self.InvalidInputException ) as e: self.handle\_exception(e, self.app.debug) schema\_validation\_succeeded = False if not schema\_validation\_succeeded: return
 super().dispatch()
 def validate\_and\_normalize\_args(self) -> None: """Validates schema for controller layer handler class arguments.
 Raises: InvalidInputException. Schema validation failed. NotImplementedError. Schema is not provided in handler class. """ handler\_class\_name = self.\_\_class\_\_.\_\_name\_\_ request\_method = self.request.environ['REQUEST\_METHOD']
 # For HEAD requests, we use the schema of GET handler, # because HEAD returns just the handlers of the GET request. if request\_method == 'HEAD': request\_method = 'GET'
 url\_path\_args = self.request.route\_kwargs
 if ( handler\_class\_name in handler\_schema\_constants.HANDLER\_CLASS\_NAMES\_WITH\_NO\_SCHEMA ): # TODO(#13155): Remove this clause once all the handlers have had # schema validation implemented. if self.URL\_PATH\_ARGS\_SCHEMAS or self.HANDLER\_ARGS\_SCHEMAS: raise self.InternalErrorException( 'Remove handler class name from ' 'HANDLER\_CLASS\_NAMES\_WHICH\_STILL\_NEED\_SCHEMAS') return
 handler\_args = {} payload\_arg\_keys = [] request\_arg\_keys = [] for arg in self.request.arguments(): if arg == 'csrf\_token': # 'csrf\_token' has been already validated in the # dispatch method. pass elif arg == 'source': source\_url = self.request.get('source') regex\_pattern = ( r'http[s]?://(?:[a-zA-Z]|[0-9]|[!\*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+' # pylint: disable=line-too-long ) regex\_verified\_url = re.findall(regex\_pattern, source\_url) if not regex\_verified\_url: raise self.InvalidInputException( 'Not a valid source url.') elif arg == 'payload': payload\_args = self.payload if payload\_args is not None: payload\_arg\_keys = list(payload\_args.keys()) handler\_args.update(payload\_args) else: request\_arg\_keys.append(arg) handler\_args[arg] = self.request.get(arg)
 # For html handlers, extra args are allowed (to accommodate # e.g. utm parameters which are not used by the backend but # needed for analytics). extra\_args\_are\_allowed = ( self.GET\_HANDLER\_ERROR\_RETURN\_TYPE == feconf.HANDLER\_TYPE\_HTML and request\_method == 'GET')
 if self.URL\_PATH\_ARGS\_SCHEMAS is None: raise NotImplementedError( 'Missing schema for url path args in %s handler class.' % ( handler\_class\_name))
 schema\_for\_url\_path\_args = self.URL\_PATH\_ARGS\_SCHEMAS self.request.route\_kwargs, errors = ( payload\_validator.validate\_arguments\_against\_schema( url\_path\_args, schema\_for\_url\_path\_args, extra\_args\_are\_allowed) )
 if errors: raise self.InvalidInputException( 'At \'%s\' these errors are happening:\n%s' % ( self.request.uri, '\n'.join(errors) ) )
 # This check ensures that if a request method is not defined # in the handler class then schema validation will not raise # NotImplementedError for that corresponding request method. if request\_method in ['GET', 'POST', 'PUT', 'DELETE'] and ( getattr(self.\_\_class\_\_, request\_method.lower()) == getattr(BaseHandler, request\_method.lower())): return
 try: if self.HANDLER\_ARGS\_SCHEMAS is None: raise Exception( 'No \'HANDLER\_ARGS\_SCHEMAS\' Found for the ' 'handler class: %s' % handler\_class\_name ) schema\_for\_request\_method = self.HANDLER\_ARGS\_SCHEMAS[ request\_method] except Exception as e: raise NotImplementedError( 'Missing schema for %s method in %s handler class.' % ( request\_method, handler\_class\_name)) from e
 allow\_string\_to\_bool\_conversion = request\_method in ['GET', 'DELETE'] normalized\_arg\_values, errors = ( payload\_validator.validate\_arguments\_against\_schema( handler\_args, schema\_for\_request\_method, extra\_args\_are\_allowed, allow\_string\_to\_bool\_conversion) )
 normalized\_payload = { arg: normalized\_arg\_values.get(arg) for arg in payload\_arg\_keys } normalized\_request = { arg: normalized\_arg\_values.get(arg) for arg in request\_arg\_keys }
 # The following keys are absent in request/payload but present in # normalized\_arg\_values because these args are populated from their # default\_value provided in the schema. keys\_that\_correspond\_to\_default\_values = list( set(normalized\_arg\_values.keys()) - set(payload\_arg\_keys + request\_arg\_keys) ) # Populate the payload/request with the default args before passing # execution onwards to the handler. for arg in keys\_that\_correspond\_to\_default\_values: if request\_method in ['GET', 'DELETE']: normalized\_request[arg] = normalized\_arg\_values.get(arg) else: normalized\_payload[arg] = normalized\_arg\_values.get(arg)
 # Here we use MyPy ignore because 'normalized\_payload' is of # Dict[str, Any] type, whereas 'self.normalized\_payload' is a Generic # type whose type can be decided while defining sub-classes. So, Due # to this mismatch in types MyPy throws an error. Thus, to silence the # error, we used type ignore here. self.normalized\_payload = normalized\_payload # type: ignore[assignment] # Here we use MyPy ignore because 'normalized\_request' is of # Dict[str, Any] type, whereas 'self.normalized\_request' is a Generic # type whose type can be decided while defining sub-classes. So, Due # to this mismatch in types MyPy throws an error. Thus, to silence the # error, we used type ignore here. self.normalized\_request = normalized\_request # type: ignore[assignment]
 # Here we use MyPy ignore because here we assigning RaiseErrorOnGet's # instance to a 'get' method, and according to MyPy assignment to a # method is not allowed. self.request.get = RaiseErrorOnGet( # type: ignore[assignment] 'Use self.normalized\_request instead of self.request.').get self.payload = RaiseErrorOnGet( 'Use self.normalized\_payload instead of self.payload.')
 if errors: raise self.InvalidInputException('\n'.join(errors))
 @property def current\_user\_is\_site\_maintainer(self) -> bool: """Returns whether the current user is a site maintainer.
 A super admin or release coordinator is also a site maintainer.
 Returns: bool. Whether the current user is a site maintainer. """ return ( self.current\_user\_is\_super\_admin or feconf.ROLE\_ID\_RELEASE\_COORDINATOR in self.roles)
 def \_is\_requested\_path\_currently\_accessible\_to\_user(self) -> bool: """Checks whether the requested path is currently accessible to user.
 Returns: bool. Whether the requested path is currently accessible to user. """ return ( self.request.path in AUTH\_HANDLER\_PATHS or not feconf.ENABLE\_MAINTENANCE\_MODE or self.current\_user\_is\_site\_maintainer)
 # Here we use type Any because the sub-classes of 'Basehandler' can have # 'get' method with different number of arguments and types. def get(self, \*args: Any, \*\*kwargs: Any) -> None: # pylint: disable=unused-argument """Base method to handle GET requests.""" logging.warning('Invalid URL requested: %s', self.request.uri) self.error(404) values: ResponseValueDict = { 'error': 'Could not find the page %s.' % self.request.uri, 'status\_code': 404 } self.\_render\_exception(values)
 # Here we use type Any because the sub-classes of 'Basehandler' can have # 'post' method with different number of arguments and types. def post(self, \*args: Any) -> None: # pylint: disable=unused-argument """Base method to handle POST requests.
 Raises: PageNotFoundException. Page not found error (error code 404). """ raise self.PageNotFoundException
 # Here we use type Any because the sub-classes of 'Basehandler' can have # 'put' method with different number of arguments and types. def put(self, \*args: Any) -> None: # pylint: disable=unused-argument """Base method to handle PUT requests.
 Raises: PageNotFoundException. Page not found error (error code 404). """ raise self.PageNotFoundException
 # Here we use type Any because the sub-classes of 'Basehandler' can have # 'delete' method with different number of arguments and types. def delete(self, \*args: Any) -> None: # pylint: disable=unused-argument """Base method to handle DELETE requests.
 Raises: PageNotFoundException. Page not found error (error code 404). """ raise self.PageNotFoundException
 # Here we use type Any because the sub-classes of 'Basehandler' can have # 'head' method with different number of arguments and types. def head(self, \*args: Any, \*\*kwargs: Any) -> None: """Method to handle HEAD requests. The webapp library automatically makes sure that HEAD only returns the headers of GET request. """ return self.get(\*args, \*\*kwargs)
 # TODO(#16539): Once all the places are fixed with the type of value # that is rendered to JSON, then please remove Sequence[Mapping[str, Any]] # from render\_json's argument type. # Here we use type Any because the argument 'values' can accept various # kinds of dictionaries that needs to be sent as a JSON response. def render\_json( self, values: Union[str, Sequence[Mapping[str, Any]], Mapping[str, Any]] ) -> None: """Prepares JSON response to be sent to the client.
 Args: values: str|dict. The key-value pairs to encode in the JSON response. """ self.response.content\_type = 'application/json; charset=utf-8' self.response.headers['Content-Disposition'] = ( 'attachment; filename="oppia-attachment.txt"') self.response.headers['Strict-Transport-Security'] = ( 'max-age=31536000; includeSubDomains') self.response.headers['X-Content-Type-Options'] = 'nosniff' self.response.headers['X-Xss-Protection'] = '1; mode=block'
 json\_output = json.dumps(values, cls=utils.JSONEncoderForHTML) # Write expects bytes, thus we need to encode the JSON output. self.response.write( b'%s%s' % (feconf.XSSI\_PREFIX, json\_output.encode('utf-8')))
 def render\_downloadable\_file( self, file: io.BytesIO, filename: str, content\_type: str ) -> None: """Prepares downloadable content to be sent to the client.
 Args: file: BytesIO. The data of the downloadable file. filename: str. The name of the file to be rendered. content\_type: str. The type of file to be rendered. """ self.response.headers['Content-Type'] = content\_type self.response.headers['Content-Disposition'] = ( 'attachment; filename=%s' % filename) self.response.charset = 'utf-8' # Here we use MyPy ignore because according to MyPy super can # accept 'super class and self' as arguments but here we are passing # 'webapp2.Response, and self.response' which confuses MyPy about the # typing of super, and due to this MyPy is unable to recognize the # 'write' method and throws an error. This change in arguments is # done because we use 'super' method in order to bypass the write # method in webapp2.Response, since webapp2.Response doesn't support # writing bytes. super(webapp2.Response, self.response).write(file.getvalue()) # type: ignore[misc] # pylint: disable=bad-super-call
 def render\_template( self, filepath: str, iframe\_restriction: Optional[str] = 'DENY', \*, template\_is\_aot\_compiled: bool = False ) -> None: """Prepares an HTML response to be sent to the client.
 Args: filepath: str. The template filepath. iframe\_restriction: str or None. Possible values are 'DENY' and 'SAMEORIGIN':
 DENY: Strictly prevents the template to load in an iframe. SAMEORIGIN: The template can only be displayed in a frame on the same origin as the page itself. template\_is\_aot\_compiled: bool. False by default. Use True when the template is compiled by angular AoT compiler.
 Raises: Exception. Invalid X-Frame-Options. """
 # The 'no-store' must be used to properly invalidate the cache when we # deploy a new version, using only 'no-cache' doesn't work properly. self.response.cache\_control.no\_store = True self.response.cache\_control.must\_revalidate = True self.response.headers['Strict-Transport-Security'] = ( 'max-age=31536000; includeSubDomains') self.response.headers['X-Content-Type-Options'] = 'nosniff' self.response.headers['X-Xss-Protection'] = '1; mode=block'
 if iframe\_restriction is not None: if iframe\_restriction in ['SAMEORIGIN', 'DENY']: self.response.headers['X-Frame-Options'] = ( str(iframe\_restriction)) else: raise Exception( 'Invalid X-Frame-Options: %s' % iframe\_restriction)
 self.response.expires = 'Mon, 01 Jan 1990 00:00:00 GMT' self.response.pragma = 'no-cache' self.response.write(load\_template( filepath, template\_is\_aot\_compiled=template\_is\_aot\_compiled ))
 def \_render\_exception\_json\_or\_html( self, return\_type: str, values: ResponseValueDict ) -> None: """Renders an error page, or an error JSON response.
 Args: return\_type: str. Indicator to return JSON or HTML. values: dict. The key-value pairs to include in the response. """
 method = self.request.environ['REQUEST\_METHOD']
 if return\_type == feconf.HANDLER\_TYPE\_HTML and method == 'GET': self.values.update(values) if self.iframed: self.render\_template( 'error-iframed.mainpage.html', iframe\_restriction=None) elif values['status\_code'] == 404: # Only 404 routes can be handled with angular router as it only # has access to the path, not to the status code. # That's why 404 status code is treated differently. self.render\_template('oppia-root.mainpage.html') else: self.render\_template( 'error-page-%s.mainpage.html' % values['status\_code']) else: if return\_type not in ( feconf.HANDLER\_TYPE\_JSON, feconf.HANDLER\_TYPE\_DOWNLOADABLE): logging.warning( 'Not a recognized return type: defaulting to render JSON.') self.render\_json(values)
 def \_render\_exception( self, values: ResponseValueDict ) -> None: """Renders an error page, or an error JSON response.
 Args: values: dict. The key-value pairs to include in the response. """ # The error codes here should be in sync with the error pages # generated via webpack.common.config.ts. assert values['status\_code'] in [400, 401, 404, 500] method = self.request.environ['REQUEST\_METHOD']
 if method == 'GET': self.\_render\_exception\_json\_or\_html( self.GET\_HANDLER\_ERROR\_RETURN\_TYPE, values) elif method == 'POST': self.\_render\_exception\_json\_or\_html( self.POST\_HANDLER\_ERROR\_RETURN\_TYPE, values) elif method == 'PUT': self.\_render\_exception\_json\_or\_html( self.PUT\_HANDLER\_ERROR\_RETURN\_TYPE, values) elif method == 'DELETE': self.\_render\_exception\_json\_or\_html( self.DELETE\_HANDLER\_ERROR\_RETURN\_TYPE, values) else: logging.warning('Not a recognized request method.') self.\_render\_exception\_json\_or\_html( feconf.HANDLER\_TYPE\_JSON, values )
 def handle\_exception( self, exception: BaseException, unused\_debug\_mode: bool ) -> None: """Overwrites the default exception handler.
 Args: exception: Exception. The exception that was thrown. unused\_debug\_mode: bool. True if the web application is running in debug mode. """ if isinstance(exception, self.NotLoggedInException): # This checks if the response should be JSON or HTML. # For GET requests, there is no payload, so we check against # GET\_HANDLER\_ERROR\_RETURN\_TYPE. # Otherwise, we check whether self.payload exists.
 # This check is to avoid throwing of 401 when payload doesn't # exists and self.payload is replaced by RaiseErrorOnGet object. # TODO(#13155): Change this to self.normalized\_payload # once schema is implemented for all handlers. payload\_exists = ( self.payload is not None and not isinstance(self.payload, RaiseErrorOnGet) ) if ( payload\_exists or self.GET\_HANDLER\_ERROR\_RETURN\_TYPE == feconf.HANDLER\_TYPE\_JSON ): self.error(401) values: ResponseValueDict = { 'error': 'You must be logged in to access this resource.', 'status\_code': 401 } self.\_render\_exception(values) else: self.redirect(user\_services.create\_login\_url(self.request.uri)) return
 logging.exception( 'Exception raised at %s: %s', self.request.uri, exception)
 if isinstance(exception, self.PageNotFoundException): logging.warning('Invalid URL requested: %s', self.request.uri) self.error(404) values = { 'error': 'Could not find the page %s.' % self.request.uri, 'status\_code': 404 } self.\_render\_exception(values) return
 logging.exception('Exception raised: %s', exception)
 if isinstance(exception, self.UnauthorizedUserException): self.error(401) values = { 'error': str(exception), 'status\_code': 401 } self.\_render\_exception(values) return
 if isinstance(exception, self.InvalidInputException): self.error(400) values = { 'error': str(exception), 'status\_code': 400 } self.\_render\_exception(values) return
 if isinstance(exception, self.InternalErrorException): self.error(500) values = { 'error': str(exception), 'status\_code': 500 } self.\_render\_exception(values) return
 self.error(500) values = { 'error': str(exception), 'status\_code': 500 } self.\_render\_exception(values)
 InternalErrorException = UserFacingExceptions.InternalErrorException InvalidInputException = UserFacingExceptions.InvalidInputException NotLoggedInException = UserFacingExceptions.NotLoggedInException PageNotFoundException = UserFacingExceptions.PageNotFoundException UnauthorizedUserException = UserFacingExceptions.UnauthorizedUserException
class Error404Handler(BaseHandler[Dict[str, str], Dict[str, str]]): """Handles 404 errors."""
 pass
class RaiseErrorOnGet: """Class that will throw a ValueError when the get function is invoked."""
 def \_\_init\_\_(self, message: str) -> None: self.error\_message = message
 # Here we use type Any because the 'get' method can accept arbitrary number # of arguments with different types. def get(self, \*args: Any, \*\*kwargs: Any) -> None: """Raises an error when invoked.""" raise ValueError(self.error\_message)
class CsrfTokenManager: """Manages page/user tokens in memcache to protect against CSRF."""
 # Max age of the token (48 hours). \_CSRF\_TOKEN\_AGE\_SECS: Final = 60 \* 60 \* 48 # Default user id for non-logged-in users. \_USER\_ID\_DEFAULT: Final = 'non\_logged\_in\_user'
 @classmethod def init\_csrf\_secret(cls) -> None: """Verify that non-default CSRF secret exists; creates one if not."""
 # Any non-default value is fine. if CSRF\_SECRET.value and CSRF\_SECRET.value != DEFAULT\_CSRF\_SECRET: return
 # Initialize to random value. config\_services.set\_property( feconf.SYSTEM\_COMMITTER\_ID, CSRF\_SECRET.name, base64.urlsafe\_b64encode(os.urandom(20)))
 @classmethod def \_create\_token(cls, user\_id: Optional[str], issued\_on: float) -> str: """Creates a new CSRF token.
 Args: user\_id: str|None. The user\_id for which the token is generated. issued\_on: float. The timestamp at which the token was issued.
 Returns: str. The generated CSRF token. """ cls.init\_csrf\_secret()
 # The token has 4 parts: hash of the actor user id, hash of the page # name, hash of the time issued and plain text of the time issued.
 if user\_id is None: user\_id = cls.\_USER\_ID\_DEFAULT
 # Round time to seconds. issued\_on\_str = str(int(issued\_on))
 digester = hmac.new( key=CSRF\_SECRET.value.encode('utf-8'), digestmod='md5' ) digester.update(user\_id.encode('utf-8')) digester.update(b':') digester.update(issued\_on\_str.encode('utf-8'))
 digest = digester.digest() # The b64encode returns bytes, so we first need to decode the returned # bytes to string. token = '%s/%s' % ( issued\_on\_str, base64.urlsafe\_b64encode(digest).decode('utf-8'))
 return token
 @classmethod def \_get\_current\_time(cls) -> float: """Returns the current server time.
 Returns: float. The time in seconds as floating point number. """ return time.time()
 @classmethod def create\_csrf\_token(cls, user\_id: Optional[str]) -> str: """Creates a CSRF token for the given user\_id.
 Args: user\_id: str|None. The user\_id for whom the token is generated.
 Returns: str. The generated CSRF token. """ return cls.\_create\_token(user\_id, cls.\_get\_current\_time())
 @classmethod def is\_csrf\_token\_valid(cls, user\_id: Optional[str], token: str) -> bool: """Validates a given CSRF token.
 Args: user\_id: str|None. The user\_id to validate the CSRF token against. token: str. The CSRF token to validate.
 Returns: bool. Whether the given CSRF token is valid. """ try: parts = token.split('/') if len(parts) != 2: return False
 issued\_on = int(parts[0]) age = cls.\_get\_current\_time() - issued\_on if age > cls.\_CSRF\_TOKEN\_AGE\_SECS: return False
 authentic\_token = cls.\_create\_token(user\_id, issued\_on) if authentic\_token == token: return True
 return False except Exception: return False
class CsrfTokenHandler(BaseHandler[Dict[str, str], Dict[str, str]]): """Handles sending CSRF tokens to the frontend."""
 GET\_HANDLER\_ERROR\_RETURN\_TYPE = feconf.HANDLER\_TYPE\_JSON REDIRECT\_UNFINISHED\_SIGNUPS = False URL\_PATH\_ARGS\_SCHEMAS: Dict[str, str] = {} HANDLER\_ARGS\_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}
[View remainder of file in raw view](https://github.com/oppia/oppia/raw/3a05c3558a292f3db9e658e60e708c266c003fd0/core/controllers/base.py)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

