<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="alternate" href="http://localhost:3000/rss.xml" type="application/rss+xml" title="Blake Embrey"/><title>ReDoS the web<!-- --> â€¢ Blake Embrey</title><link rel="canonical" href="http://localhost:3000/posts/2024-09-web-redos"/><meta name="og:type" content="article"/><meta name="og:title" content="ReDoS the web"/><meta name="og:site_name" content="Blake Embrey"/><meta name="og:url" content="http://localhost:3000/posts/2024-09-web-redos"/><meta name="description"/><meta name="og:description"/><meta name="article:published_time" content="2024-09-04T12:00:00.000Z"/><meta name="twitter:site" content="@blakeembrey"/><meta name="next-head-count" content="13"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-ee7e63bc15b31913.js" defer=""></script><script src="/_next/static/chunks/framework-ecc4130bc7a58a64.js" defer=""></script><script src="/_next/static/chunks/main-96fd2a911a0ae7b2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c9aeeb66aca0ca01.js" defer=""></script><script src="/_next/static/chunks/664-fe029c8b38e64ec1.js" defer=""></script><script src="/_next/static/chunks/522-893558dba8494fae.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-1e8003419dfdfe98.js" defer=""></script><script src="/_next/static/keLb_cR8bmtKg0vE7Ohio/_buildManifest.js" defer=""></script><script src="/_next/static/keLb_cR8bmtKg0vE7Ohio/_ssgManifest.js" defer=""></script><style>.f1ctgeyj{border-top:4px solid var(--brand-color)}.f119bqlh{margin:0 auto;max-width:700px;padding:20px}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}[hidden],template{display:none}[type="checkbox"],[type="radio"]{box-sizing:border-box;padding:0}[type="number"]::-webkit-inner-spin-button,[type="number"]::-webkit-outer-spin-button{height:auto}[type="search"]{-webkit-appearance:textfield;outline-offset:-2px}[type="search"]::-webkit-search-decoration{-webkit-appearance:none}a{background-color:transparent}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:bolder}body{margin:0}button,[type="button"],[type="reset"],[type="submit"]{-webkit-appearance:button}button,input{overflow:visible}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,select{text-transform:none}button:-moz-focusring,[type="button"]:-moz-focusring,[type="reset"]:-moz-focusring,[type="submit"]:-moz-focusring{outline:1px dotted ButtonText}button::-moz-focus-inner,[type="button"]::-moz-focus-inner,[type="reset"]::-moz-focus-inner,[type="submit"]::-moz-focus-inner{border-style:none;padding:0}code,kbd,samp,pre{font-family:monospace, monospace;font-size:1em}details,main{display:block}fieldset{padding:0.35em 0.75em 0.625em}h1{font-size:2em;margin:0.67em 0}hr{box-sizing:content-box;height:0;overflow:visible}html{-webkit-text-size-adjust:100%;line-height:1.15}img{border-style:none}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{vertical-align:baseline}small{font-size:80%}sub{bottom:-0.25em}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}summary{display:list-item}sup{top:-0.5em}textarea{overflow:auto}:root{--background-color:#eee;--background-color-shift:#fff;--border-color:#ccc;--border-color-shift:#bbb;--border-color-subtle:#fff;--brand-color:#f20;--text-color:#111;--text-color-shift:#222;--text-color-subtle:#777}html{background-color:var(--background-color);color:var(--text-color);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif,BlinkMacSystemFont,Helvetica Neue,Arial,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-weight:300;line-height:1.625}@media (prefers-color-scheme: dark){:root{--background-color:#111;--background-color-shift:#222;--border-color:#333;--border-color-shift:#444;--border-color-subtle:#000;--text-color:#eee;--text-color-shift:#fff;--text-color-subtle:#999}}.f1siofw3{display:flex;flex-wrap:wrap;font-size:1.2em;justify-content:space-between;margin:0;padding:1.5em 0}.f13vslg{font-weight:bold}.f1hbxpzi{border-bottom:2px solid transparent;color:inherit;text-decoration:none}.f1hbxpzi:hover,.f1hbxpzi.active{border-bottom-color:var(--brand-color)}.fdt76j6{font-size:1.125em}.fdt76j6 h1, h2, h3, h4, h5, h6{font-weight:bolder;margin-bottom:1em;margin-top:0}.fdt76j6 h1{font-size:2em}.fdt76j6 h2{font-size:1.5em}.fdt76j6 h3{font-size:1.3em}.fdt76j6 h4{font-size:1.1em}.fdt76j6 hr{border:1px dashed var(--border-color);border-bottom-color:var(--border-color-subtle);border-left-width:0;border-right-width:0;display:block;margin:1.5em 0}.fdt76j6 p{margin:0 0 1em 0}.fdt76j6 a{border-bottom:2px solid var(--border-color);color:inherit;text-decoration:none}.fdt76j6 a:hover{border-bottom-color:var(--brand-color)}.fdt76j6 blockquote{border-left:4px solid var(--brand-color);margin:1em 0;padding-left:1em}.fdt76j6 img,audio,embed,video,object{height:auto;max-width:100%}.fdt76j6 code, pre{background-color:var(--background-color-shift);border:1px solid var(--border-color-shift);color:var(--text-color-shift);font-family:monospace;font-size:0.9em}.fdt76j6 pre{border-radius:2px;line-height:1.3;overflow-x:auto;padding:0.6em 0.8em}.fdt76j6 code{border-color:var(--border-color-shift);border-radius:2px;display:inline;padding:0.2em 0.3em;white-space:pre-line;word-wrap:break-word}.fdt76j6 pre > code{background-color:transparent;border:none;border-radius:0;font-size:100%;padding:0;white-space:pre;word-wrap:normal}.fdt76j6 a > code{border-bottom-width:2px}.fdt76j6 a:hover > code{border-color:var(--brand-color)}.fdt76j6 .hljs-header,.hljs-comment,.hljs-javadoc{color:#969896}.fdt76j6 .hljs-keyword,.hljs-winutils,.hljs-subst,.hljs-request,.hljs-status{color:#a71d5d}.fdt76j6 .hljs-number,.hljs-hexcolor,.hljs-constant,.fdt76j6 .hljs-built_in{color:#0086b3}.fdt76j6 .hljs-string,.hljs-tag .hljs-value,.hljs-phpdoc,.hljs-dartdoc,.hljs-formula{color:#df5000}.fdt76j6 .hljs-title,.hljs-id,.hljs-preprocessor{color:#795da3}.fdt76j6 .hljs-class .hljs-title,.hljs-type,.hljs-literal,.hljs-command{color:#458;font-weight:bolder}.fdt76j6 .hljs-tag,.hljs-tag .hljs-title,.hljs-rules .hljs-property{color:#000080}.fdt76j6 .hljs-attribute,.hljs-variable,.hljs-body{color:#008080}.fdt76j6 .hljs-regexp{color:#009926}.fdt76j6 .hljs-symbol,.hljs-symbol .hljs-string,.hljs-special,.hljs-prompt{color:#990073}.fdt76j6 .hljs-preprocessor,.hljs-pragma,.hljs-pi,.hljs-doctype,.hljs-shebang,.hljs-cdata{color:#999;font-weight:bolder}.fdt76j6 .hljs-deletion{background:#fdd}.fdt76j6 .hljs-addition{background:#dfd}.fdt76j6 .hljs-change{background:#0086b3}.fdt76j6 .hljs-chunk{color:#aaa}.fcrqv53{color:var(--text-color-subtle);font-size:0.85em;margin:0 0 2em 0;padding:0}.fcrqv53 > li > a{color:var(--text-color-subtle)}.fcrqv53 > li{display:inline-block;list-style:none;padding-right:20px}</style></head><body><div id="__next"><div class=""><div class="f1ctgeyj"></div><div class="f119bqlh f15ot0o9 fbpcz3v"><ul class="f1siofw3"><a class="f13vslg f1hbxpzi" href="/">Writing</a></ul><div class="fdt76j6"><h1>ReDoS the web</h1><ul class="fcrqv53"><li>Written<!-- --> <time dateTime="2024-09-04T12:00:00.000Z">4 September 2024</time></li></ul><div><h2>Background</h2>
<p>Ten years ago I took over <code>path-to-regexp</code> with the release of <code>v0.1.0</code>, used in Express.js 4. Between then and now I've released 8 major versions adding, removing, and refining features. If I knew what I knew today, none of those 8 major versions would have been released. That's story for another day.</p>
<p>This story begins with Express 5. As part of reviving Express we're conducting a security audit, and I woke up on day to the revelation that users of <code>path-to-regexp</code> (including Express.js, Next.js, and others) may contain vulnerable regular expressions. It has never been reported, but once you know you know.</p>
<p>Any route using two or more parameters between slashes, where the second parameter does not start with <code>/</code> or <code>.</code>, is currently vulnerable to ReDoS. Express.js uses a vulnerable example in the <a href="https://expressjs.com/en/guide/routing.html">routing guide</a>: <code>/flights/:from-:to</code>. The design flaw goes undetected all the way back to the initial commit. Let's look at the regular expression generated for this route:</p>
<pre><code class="language-js">/^\/flights\/([^\/]+?)-([^\/]+?)\/?$/i</code></pre>
<p>This looks reasonable, but if you match against a path like <code>'/flights/' + '-'.repeat(16_000) + '/x'</code> it takes 300ms. Holy crap! This <em>should</em> take less than a millisecond. If we tweak it slightly, changing the second parameter from <code>([^\/]+?)</code> to <code>([^\/-]+?)</code>, it takes just 0.07ms. What's gone wrong?</p>
<p><a href="https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS">OWASP</a> has a clear explanation. When the <code>/x</code> is added to the end of the path, it can no longer be matched (due to <code>$</code>, end of string), so it backtracks and tries every possible match of <code>:from-:to</code>. The more possible matches, the longer it takes.</p>
<h2>Scope</h2>
<p>Thankfully the pattern of using more than one parameter within slashes is extremely rare or non-existent. APIs with multiple inputs usually rely on query parameters or operate in the context of a single object ID. That should limit the impact of this exploit and explains why it hasn't been reported before.</p>
<h3>Across JavaScript</h3>
<p>The vulnerability exists in every library using regular expressions with multiple parameters in a segment without backtracking prevention. A quick review shows the problem is exploitable in other JavaScript libraries and specifications. Fortunately this is an uncommon pattern to start with, and some libraries avoid the problem by prohibiting multiple parameters in a segment or avoiding regexes.</p>
<h3>Beyond JavaScript</h3>
<p>It's possible this vulnerability exists in any other language with regular expressions that backtrack. Libraries such as <a href="https://github.com/google/re2/wiki/WhyRE2">RE2</a> can be used to guarantee linear time matches and mitigate the problem, but most default regular expression engines are not linear time. Fortunately the fix is easy: restrict backtracking, remove regex from matching, or limit parameters to safe locations.</p>
<h2>Mitigation</h2>
<p>For v0.1, I've released a patch that includes automatic backtracking prevention for these exploitable parameters. It will automatically generate <code>((?!\-|\/).)+?</code> for the second parameter above (not <code>-</code> or <code>/</code>). Due to the loose nature of the v0 "parser" this isn't perfect, and will break some routes that use edge cases in the way the regular expression generates.</p>
<p>For version 8, I've removed regex features. I know this is a huge pain for users of the library and apologize in advance. In discussions with the Express TC we decided that any output of <code>path-to-regexp</code> that's exploitable is a vulnerability. Since versions &#x3C; 8 allowed custom regular expressions to be defined using <code>(...)</code> and these can combine together to produce ReDoS vectors, the feature has been removed.</p>
<p>All other versions remain vulnerable, and can be mitigated by manually defining the parameters regular expression when two or more parameters exist in a single segment. For example, <code>/flights/:from-:to(\\w+)</code>. As long as the first or second parameter does not include <code>-</code> in the match, it is safe.</p>
<p>Lastly, feel free to contact me on how to mitigate the vulnerability in versions where users cannot upgrade. My contact information can be found on <a href="https://github.com/blakeembrey">GitHub</a>. The changes necessary in any version will break <em>something</em> for some users and is a trade-off between compatibility and exploitability.</p>
<h2>Other mitigation attempts</h2>
<h3>Restrict URL length</h3>
<p>Since this exploit gets worse when the URL is longer, restricting the path to some length and throwing a 413 when it exceeds the length would be the simplest mitigation. However, even at 2000 characters in length it's 20x worse than the safe regex. Making matches much shorter than this is bound to break other users.</p>
<h3>Restrict parameter length</h3>
<p>Instead of an open ended <code>+</code>, use <code>{1,1000}</code>. This limits the performance impact (~1ms locally) but could break some users expecting long parameters. It also performs worse than the safe regex.</p>
<h3>RE2</h3>
<p>We tried <a href="https://github.com/le0pard/re2js">re2js</a> and performance was better (~4X) for the long ReDoS URLs, but much worse in every other case. Native bindings would probably be faster but we needed to maintain compatibility as best as possible in Express 4 which is still running node 0.10!</p>
<h3>Rewrite to JavaScript</h3>
<p>This was the most promising avenue and provided good performance in limited tests, but I didn't finish. Providing a working mitigation and unblocking Express 5 was higher priority. The one major downside of this is that reintroducing safe regex features in version 8 becomes a lot harder.</p>
<h2>Resources</h2>
<ul>
<li><a href="https://makenowjust-labs.github.io/recheck/playground/">Recheck playground</a> to check for vulnerabilities</li>
</ul>
</div><hr/><p><strong>Questions?</strong> Find me on<!-- --> <a href="https://twitter.com/blakeembrey">Twitter</a> or<!-- --> <a href="https://github.com/blakeembrey/writing">open an issue</a>.</p></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"data":{"title":"ReDoS the web","date":"2024-09-04 12:00"},"html":"\u003ch2\u003eBackground\u003c/h2\u003e\n\u003cp\u003eTen years ago I took over \u003ccode\u003epath-to-regexp\u003c/code\u003e with the release of \u003ccode\u003ev0.1.0\u003c/code\u003e, used in Express.js 4. Between then and now I've released 8 major versions adding, removing, and refining features. If I knew what I knew today, none of those 8 major versions would have been released. That's story for another day.\u003c/p\u003e\n\u003cp\u003eThis story begins with Express 5. As part of reviving Express we're conducting a security audit, and I woke up on day to the revelation that users of \u003ccode\u003epath-to-regexp\u003c/code\u003e (including Express.js, Next.js, and others) may contain vulnerable regular expressions. It has never been reported, but once you know you know.\u003c/p\u003e\n\u003cp\u003eAny route using two or more parameters between slashes, where the second parameter does not start with \u003ccode\u003e/\u003c/code\u003e or \u003ccode\u003e.\u003c/code\u003e, is currently vulnerable to ReDoS. Express.js uses a vulnerable example in the \u003ca href=\"https://expressjs.com/en/guide/routing.html\"\u003erouting guide\u003c/a\u003e: \u003ccode\u003e/flights/:from-:to\u003c/code\u003e. The design flaw goes undetected all the way back to the initial commit. Let's look at the regular expression generated for this route:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e/^\\/flights\\/([^\\/]+?)-([^\\/]+?)\\/?$/i\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis looks reasonable, but if you match against a path like \u003ccode\u003e'/flights/' + '-'.repeat(16_000) + '/x'\u003c/code\u003e it takes 300ms. Holy crap! This \u003cem\u003eshould\u003c/em\u003e take less than a millisecond. If we tweak it slightly, changing the second parameter from \u003ccode\u003e([^\\/]+?)\u003c/code\u003e to \u003ccode\u003e([^\\/-]+?)\u003c/code\u003e, it takes just 0.07ms. What's gone wrong?\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\"\u003eOWASP\u003c/a\u003e has a clear explanation. When the \u003ccode\u003e/x\u003c/code\u003e is added to the end of the path, it can no longer be matched (due to \u003ccode\u003e$\u003c/code\u003e, end of string), so it backtracks and tries every possible match of \u003ccode\u003e:from-:to\u003c/code\u003e. The more possible matches, the longer it takes.\u003c/p\u003e\n\u003ch2\u003eScope\u003c/h2\u003e\n\u003cp\u003eThankfully the pattern of using more than one parameter within slashes is extremely rare or non-existent. APIs with multiple inputs usually rely on query parameters or operate in the context of a single object ID. That should limit the impact of this exploit and explains why it hasn't been reported before.\u003c/p\u003e\n\u003ch3\u003eAcross JavaScript\u003c/h3\u003e\n\u003cp\u003eThe vulnerability exists in every library using regular expressions with multiple parameters in a segment without backtracking prevention. A quick review shows the problem is exploitable in other JavaScript libraries and specifications. Fortunately this is an uncommon pattern to start with, and some libraries avoid the problem by prohibiting multiple parameters in a segment or avoiding regexes.\u003c/p\u003e\n\u003ch3\u003eBeyond JavaScript\u003c/h3\u003e\n\u003cp\u003eIt's possible this vulnerability exists in any other language with regular expressions that backtrack. Libraries such as \u003ca href=\"https://github.com/google/re2/wiki/WhyRE2\"\u003eRE2\u003c/a\u003e can be used to guarantee linear time matches and mitigate the problem, but most default regular expression engines are not linear time. Fortunately the fix is easy: restrict backtracking, remove regex from matching, or limit parameters to safe locations.\u003c/p\u003e\n\u003ch2\u003eMitigation\u003c/h2\u003e\n\u003cp\u003eFor v0.1, I've released a patch that includes automatic backtracking prevention for these exploitable parameters. It will automatically generate \u003ccode\u003e((?!\\-|\\/).)+?\u003c/code\u003e for the second parameter above (not \u003ccode\u003e-\u003c/code\u003e or \u003ccode\u003e/\u003c/code\u003e). Due to the loose nature of the v0 \"parser\" this isn't perfect, and will break some routes that use edge cases in the way the regular expression generates.\u003c/p\u003e\n\u003cp\u003eFor version 8, I've removed regex features. I know this is a huge pain for users of the library and apologize in advance. In discussions with the Express TC we decided that any output of \u003ccode\u003epath-to-regexp\u003c/code\u003e that's exploitable is a vulnerability. Since versions \u0026#x3C; 8 allowed custom regular expressions to be defined using \u003ccode\u003e(...)\u003c/code\u003e and these can combine together to produce ReDoS vectors, the feature has been removed.\u003c/p\u003e\n\u003cp\u003eAll other versions remain vulnerable, and can be mitigated by manually defining the parameters regular expression when two or more parameters exist in a single segment. For example, \u003ccode\u003e/flights/:from-:to(\\\\w+)\u003c/code\u003e. As long as the first or second parameter does not include \u003ccode\u003e-\u003c/code\u003e in the match, it is safe.\u003c/p\u003e\n\u003cp\u003eLastly, feel free to contact me on how to mitigate the vulnerability in versions where users cannot upgrade. My contact information can be found on \u003ca href=\"https://github.com/blakeembrey\"\u003eGitHub\u003c/a\u003e. The changes necessary in any version will break \u003cem\u003esomething\u003c/em\u003e for some users and is a trade-off between compatibility and exploitability.\u003c/p\u003e\n\u003ch2\u003eOther mitigation attempts\u003c/h2\u003e\n\u003ch3\u003eRestrict URL length\u003c/h3\u003e\n\u003cp\u003eSince this exploit gets worse when the URL is longer, restricting the path to some length and throwing a 413 when it exceeds the length would be the simplest mitigation. However, even at 2000 characters in length it's 20x worse than the safe regex. Making matches much shorter than this is bound to break other users.\u003c/p\u003e\n\u003ch3\u003eRestrict parameter length\u003c/h3\u003e\n\u003cp\u003eInstead of an open ended \u003ccode\u003e+\u003c/code\u003e, use \u003ccode\u003e{1,1000}\u003c/code\u003e. This limits the performance impact (~1ms locally) but could break some users expecting long parameters. It also performs worse than the safe regex.\u003c/p\u003e\n\u003ch3\u003eRE2\u003c/h3\u003e\n\u003cp\u003eWe tried \u003ca href=\"https://github.com/le0pard/re2js\"\u003ere2js\u003c/a\u003e and performance was better (~4X) for the long ReDoS URLs, but much worse in every other case. Native bindings would probably be faster but we needed to maintain compatibility as best as possible in Express 4 which is still running node 0.10!\u003c/p\u003e\n\u003ch3\u003eRewrite to JavaScript\u003c/h3\u003e\n\u003cp\u003eThis was the most promising avenue and provided good performance in limited tests, but I didn't finish. Providing a working mitigation and unblocking Express 5 was higher priority. The one major downside of this is that reintroducing safe regex features in version 8 becomes a lot harder.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://makenowjust-labs.github.io/recheck/playground/\"\u003eRecheck playground\u003c/a\u003e to check for vulnerabilities\u003c/li\u003e\n\u003c/ul\u003e\n","path":"2024-09-web-redos.md","url":"/posts/2024-09-web-redos"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"2024-09-web-redos"},"buildId":"keLb_cR8bmtKg0vE7Ohio","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>