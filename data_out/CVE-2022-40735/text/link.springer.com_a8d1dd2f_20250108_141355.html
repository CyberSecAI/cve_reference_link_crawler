On Diffie-Hellman Key Agreement
with Short  Exponents

Paul  C. van  Oorschot

Michael J .  Wiener

Bell-Northern  Research,  Box  3511 Station  C
Ottawa, Ontario  KIY 4H7, Canada
{paulv, uiener)Qbnr. ca

A b s t r a c t .   T h e   difficulty  of  computing  discrete  logarithms  known  to
be  “short”  is  examined,  motivated  by  recent  practical  interest  in  using
Diffie-Hellman  key  agreement  with  short  exponents  (e.g.  over  Z,  with
160-bit  exponents  and  1024-bit primes p ) .  A  new  divide-and-conquer  al-
gorithm for discrete logarithms is  presented,  combining  Pollard’s lambda
method with  a partial  Pohlig-Hellman decomposition.  For  random  Diffie-
Hellman  primes  p ,  examination  reveals this  partial  decomposition  itself
allows recovery of short exponents in many cases, while the new technique
dramatically  extends  the  range.  Use  of  subgroups of  large prime  order
precludes  the  attack  at essentially  no cost,  and  is  t h e  recommended  so-
lution.  Using safe primes  also  precludes this particular  attack and allows
improved  exponentiation  performance,  although  parameter  generation
cos;bs are dramatically  higher.

1

Introduction

Diffie-Hellman  key  agreement  [3] allows two  parties  A  and  B  to derive a com-
m o n   secret  by  communications  over  a n   unsecured  channel,  while  sharing  n o
user-specific  keying  material  a  priori.  A  prime p  a n d   element  g  E  2;  of  large
multiplicative order  are  fixed.  A  chooses  a random  integer  z, 1  5  z  5 p  - 2,
a n d  sends to E  the value gz mod p  (hereafter, reduction mod p  is not explicitly
noted).  B  responds by  choosing  a random  y,  1  5 y 5 p  - 2,  and sending to A
t.he  value gy. A  and  B  may then  respect.ively  compute a common secret  key  K
as  K  = (gy)“ and  ii’ = (g2)Y.  Due t.0 t.he intractability of  the discrete logarithm
problem [lo] for appropriate p ,  a n  eavesdropper  is unable to compute z or y from
observation  of  g2 a n d  gy,  and  thus unable to compute  K  in the same manner
as A  or  B .  I t  is  widely  believed  t h a t  computing discrete  logs is  required  for any
party  other than A  or B  to compute K ,  although this remains an open question
[12]. For  protection  from  active adversaries,  the technique must be  augmented;
various authenticated key  agreement protocols  a r e  available  [17].

Regarding appropriate choice of the prime p ,  two issues are size and structure.
Regarding bitsize, taking current  algorithms into account and depending on the
security  requirement,  512  bits  is  typically  specified  as a  minimum,  a n d   1024
bits (or more) is commonly recommended  and generally considered safe for most
applications. Regarding st.ruct.ure, it. is well-known  t h a t  p  m u s t  b e  such t h a t  p -   1

U. Maurer (Ed.): Advances in Cryptology - EUROCRYPT ’96, LNCS 1070, pp. 332-343, 1996.
0 Springer-Verlag Berlin Heidelberg  1996

333

contains a large prime factor, t o  preclude feasibility of the discrete log algorithm
of  Pohlig and  Hellman  [14].

Efficient  implementation  of  Diffie-Hellman  key  agreement  entails  efficient.
modular exponentiation, which  requires  efficient  modular multiplication. For  a
modulus p  of bit,length m ,  mod p  exponentiation with m-bit  exponents using the
basic square-and-multiply method  [7]  requires  about  m  modular squarings and
c  m  (m-bit)  modular  multiplies, where  naively, c = 0.5  (on  average); improvc-
ments  are  possible. Standard  techniques  [2]  for  each  of  (m-bit)  multiplication
mod p and modular reduction  require O ( m 2 )  bit operations.

Diffie-Hellman  is a preferred mechanism for generating ephemeral keys.  Per-
formance issues arise as security considerations demand moduli well beyond 512
bits in some applications. Since the cost of computing gx depends linearly on the
bitlength of  2 ,  ensuing real-time costs have motivated  use of  exponents z of less
than full  (m-bit) length, e.g. for  l g z  as small as 128 o r   160. This  is  somewhat
analogous to the widespread  use  of  short  public  exponents  such  LS  e  = 216 + 1
in  the  RSA  [ZS]  public-key  operation.  Care  is  necessary  to  e n s u r e   such  opti-
mizations do  not  introduce  security  weaknesses.  For  example, precaut.ions are
necessary  in  some applications when  using  e  = 3  in  RSA  [4]: and  using  a  short
RSA private exponent  is  known  to be  insecure  [21].

This paper  examines the security implications of  using short  Diffie-Hellman
exponents.  The major  conclusions are  that  use  of  random  primes p  combined
with short exponents is generally insecure, and t h a t  the use of  large prime-order
subgroups is highly recommended. $2 reviews standard techniques for computing
discrete logs in cyclic groups, including the case of short exponents. 53 presents a
new  method combining Pollard’s lambda method with partial recovery of a secret
exponent  by  a  (partial)  Pohlig-Hellman decomposition, allowing an  alarmingly
effective  attack  when  short  exponents  are  used  and  the  group  in  question  h a s
order n of  arbitrary factorization (e.g.  R = p - 1 for random prime moduli p ) .  $ 4
examines the use  of  short  exponents with  safe primes, while  $5 examines use  of
short exponents  when  computations are  restricted  to  large subgroups  of  prime
order.  Both  techniques, when  used  appropriately, preclude  the  known  at.t.acks:
each  offers  different  advantages.  Safe  primes  may  allow  further  computational
savings during exponentiation if  a generator such  as g  = 2  is used,  while use  of
prime-order  subgroups are dramatically (e.g. more t h a n  an order of  magnitude)
less costly with respect t o  parameter generation (namely p ) .  Much of the discus-
sion  applies t o  exponentiation-based  systems  beyond  Diffie-Hellman, i.e.  more
general discrete logarithm problems.

2  Background  on  Discrete Logarithm Techniques

In  this section,  the  basic  methods  for  cornputsing discrete  logs  i n   cyclic  groiip‘i
are  reviewed:  Shanks’ method,  and  Pollard’s  more  practical  rho  and  lambda
methods.  The  Pohlig-Hellman  decomposition  technique,  of  use  in  conjunction
with  any of  these, is  also reviewed.  Advanced readers  may omit this section.

334

The discrete logarithm problem for cyclic groups is as follows: given  a cyclic
group G of  order n (i.e. having n elements), generator g  E G, and element y  E G,
find z such t.hat. y  = gz. One such group is the multiplicativegroup 2;  of integers
modulo a  prime p: this group  has order  n = p - 1.

Shanks’ method.  Aside from exhaust.ive search, the simplest idea for  solving
this problem  is Shanks’ “baby-st.ep giant-step’’ method 181 (p.9 and 575-576). It
requires  O(n’I2) steps and the same order  of  space,  where  a step is one group
operation.  Define  t  =  [n1/2 1. Compute  ( g * ) i   for  1  5  i  5  t ,  and  store  the
ordered  pair  ( ( s t y ,  i) in  a  table, sorted  by  first  component  (in  constant  time
using  conventional  hashing).  To  find  the  logarithm x, compute y  . gj(=  g ” + j )
for  j  2  0. Stop when  finding  a  j  yielding  a value  stored  in  the  table; this  is
guaranteed for  some j  5 t  - 1. At  this  point, g“  = g z + j ,   implying ti  t + j
(mod n). Then  I = ti - j mod n  is  t.he desired  log. The running  time  is  O ( t )
steps  where  1  =  nr  and  r  =  1/2.  The  algorithm  may  be  generalized  using
CI  5  T  5  1 ,  requiring  a  one-time  precomputation  of  O(nr) time and space, and
a per-logarithm  computation  of  O ( n l + )   time;  r = 0  is exhaustive search, while
T  = 1 is  table  lookup.  For example, T  = 1/3  uses  less  space  and  more time. As
overall time cannot  be reduced  below n1I2 and space is typically more expensive,
T  > 1/2 is not  interesting unless computing  a very  large number of  logarithms.

Pollard rho. In  practice,  Pollard’s  rho  method  for  discrete  logarithms  [15]  is
preferable  t o  Shanks. It has similar square-root  running time (heuristic, whereas
Shanks is  deterministic), but ent,irely avoids the large space  requirement. While
further details are omitted here (as the main focus is the lambda method), it is
noted  t.hat. this  rriemoryless rho  met.hod can  be  parallelized  with  perfect  linear
speedup [20]; that. is, essentially  an r-fold speedup is possible  using  r  processors.

Pollard lambda.  A  lesser-known algorithm due to Pollard, the lambda  method
[15],  more  affectionately  called t.he method  f o r   catching  kangaroos, can  be  used
when  the  pursued  logarithm  x is  known  to  lie  within  a  restricted  interval  of
width  w .  Given  a group  G of  order  n and  known  integers b  and w ,  it finds the
logarithm z of  an element  y  = g“  E G in time O ( W ’ / ~ )  and space for  O(1ogw)
group elements,  provided  it  is guaranteed  that b  < x < b + w .  If x is  not found
on  the  first  iteration,  the  probability  of  which  can  be  controlled,  subsequent
iterations may be  run  as required. The technique  is as follows.

The  method  involves computing  two  sequences  (trails) of  points  T  and  W
(represent,ing paths  travelled  by  t,arne and  wild  kangaroos).  T  computes  the
sequence  do, Y;,  . . . , y;Y ,  where  d+l =
. g f ( Y : )   using  the  “random” function
f(y,!)  whose  output  takes  values  from  a  set  R.  At  the  point  dN, T halts  and
“sets  a trap”  hoping  to  cat.ch W  should  W  land  at  this  point  during its  own
[.rail y  = yo, y1,. . . , Y N ;  t.his will  occur  if  W’s t.rail  hits any  point d .  T h e  tame
trail  begins  at do = g b + w ,   and  proceeds t o  dN. Note  log,(y”)  = log,(y&) 4-  dk,
where  d;Y  = Ciz0 f ( y i )   mod n. The wild trail  begins  a t  yo  = y,  and concludes

”-1

335

when  y~  = y" for some point  YM in  W's trail, at which  point  the logarithm x
of  y is  computed  as x = b + w + d h  - dM  mod n .  If  no collision  y~  = yb occurs
before  dM  exceeds  w + d h ,  t h e  h u n t  is terminated  with  failure (W has  travelled
beyond  the trap). The failure probability  for  a single  iteration  is  controlled  by
parameter  0  (see  below), which  should  be  set  to minimize  the expected  overall
work  (balancing  expected  number  of  iterations and  work  per  iteration).

The  sequences

and  yi  can  be  viewed  as deterministic  paths  which  are
stepped  by  random  values  from  an  integer  set  R of  mean  rn; by  rough  analysis,
each of the N  points in T's trail provides an independent chance with probability
l / m   of  catching  W .  For  0  = N / m  and  m  large,  the  probability  of  success  is
ps  = 1 - (1 - m-l)em zz 1 - e-'.  For optimum performance,  set m = N .  wl/'  for
Q  as optimized below. Then for example, for  6'  = 4, p s  = 0.98  (0 = 1 gives ps =
0.63) and the total  expected  work,  N  + M ,  minimized  by  cy  = 1/4,  is  O ( w ' / ' )
steps. More generally, 2
is the expected  work  given 8, when  minimized  using
Q  = J/(2&)  [15]. Pollard  suggests  computing and storing g 3  for all  s  E  R. used.
and  therefore  choosing  IR,I  <<  wl/'.  R = {2*,  2 l ,  2 2 , .  . , , 2 L - 1 }  is  one suggestion
(for  an appropriate bound  L ) ,  with  f(yi)  = 23  where  j = yi mod  L.

6

Pohlig-Hellman decomposition. Given  the  prime  power  factorization  of  n
(with  q,,  the  largest  prime  divisor),  a divide-and-conquer  technique  known  as
Pohlig-Hellman  decomposition  [14]  can  be  used  to reduce  the  running  time for
each  of the Shanks, rho and lambda methods, by  decomposing  the original  large
discrete  log  problem  into  a number  of  smaller  such  sub-problems.  For  Shanks.
the  reduction  results  in  overall  time  and  space  O ( m ;  for  rho  and  lambda:
the  reduction  is  to  such  time  and  negligible  space.  The original  problem  is  to
find  x ,  given  a group  G  of  order  n (e.g. G  = Z;, R = p  - l ) ,  g, and y  where
y = g z .  This is reduced  to one of finding  c;  discrete  logs  in  a subgroup of  order
q;  for  each  prime  power  qf'  dividing  n. Let  n  = fly=,  qf'  where  q;  < q i + l l   q,
prime.  For simplicit,y, consider  the case  ci  = 1 for  all i (distinct  prime factors);
the technique  is easily generalized.  For  a fixed  i, compute y"/q*  = ( g " / " ) " .   The
result  takes on one of  pi  values,  defining the simpler sub-problem of finding the
discrete logarithm x i   (= x  mod p i )  in a group of  pi  elements generated by  g"/q*.
Once ti is found for all i, the Chinese Remainder Theorem allows solution of the
simultaneous congruences  x  G x i  mod qi , yielding x  mod fl p i ,  which  is z mod  R
as originally desired. The overall complexity is dominated  by  the cost of  finding
2,'  the logarithm for the largest  prime factor q,,  .

C o m p u t i n g  Discrete Logs of Restricted Form.  While sub-exponential  time
index-calculus  techniques  (see  [9])  for  computing  discrete  logarithms in  groups
with additional structure are in general  more powerful  than those of Shanks and
Pollard,  the  latter  are  typically  more  effective  when  the  order  n  of  the  group
factors such that a Pohlig-Hellman decomposition  is  possible, or when the expo-
nent  is small. This paper  restricts  attention  to methods  applicable to arbitrary
cyclic  groups.  For  a cyclic group  G of  order  n  (e.g. n  = p  - 1 for  Z;), it follows
from the discussion  above that:

336

(i)  discrete  logs can  be found in  O(n1I2) time and negligible space; and
( i i )   tirile can  be  reduced  to O ( q ’ / 2 )  if  q  is  t,he largest  prime divisor of  n.

For  an  appropriate bound  B, call  a prime factor  q;  of  n  small  if  q;  < B ,  and
call  R  smooth  (more specifically:  B-smooth)  if  all of its prime factors are small
in  this  sense.  To  be  of  interest,  B  is  chosen  depending  on  the  computational
resourceS  available, and  for  the  present  purposes,  defined  such  t h a t  when  n is
B-smooth,  discrete  logarithms may feasibly be  computed  using  Pohlig-Hellman
decomposition.  For  non-smooth  n, finding  I (given  y  where  y = gz)  appears
difficult for random x of approximate bitlength lgp.’ In the sections listed below,
the following approaches for  constraining the size of exponents  are examined:

$3: restricting  exponents  to random integers z  in the range  [l,w];
$4: using  a safe prime p  = 29 + 1 ( q  prime) along with  the first  option; and
$5: rtrst.rict.iiig computations t.o a subgroup  of  prime order  q  where  q  x  w .

3  Restricting Exponents t o  t h e  Range  [I, w]

Pollard’s lambda met.hod allows exhaction  of  logs with  running  time about, t h e
square-root  of  the  size  of  the  interval  in  question.  The  requirement  of  a  fixed
level  of  security, say  2‘  (i.e.  t  bits), defines  a  (not  necessarily  greatest)  lower
bound  on  the size  of  Diffie-Hellman  exponents.  More  specifically,  if  exponents
are  limited  t o  random  integers  I of  bitlength  w,  this  imposes  the  constraint,
w  2  2 2 1 .  However, if  attacks  better  than  the  basic  square-root  methods exist,
this  bound  on  w  fails to provide  t  bits  of  security.  Indeed,  Lemma2 implies  a
great,er lower bound, resulting  from such  an  improved  attack.

To  explore  the  security  impact of  short  exponents,  consider  the amount of
information  which  may  be  obtained  from  a  Pohlig-Hellman  decomposition  in
this  case  of  short  exponents,  for  a  group  G  of  order  n  (e.g.  n  = p  - 1 for

G = 2;). As previously, assume n = ny=, q;  where q;  < q;+l.  T h e  t a s k  is t o  find
c  given  y  (= gz). For  each  B-smooth prime  factor q i ,  it  is  feasible to  compute
zi = 2 mod q,.  Suppose there  are  r  5 u  such small q;,  Combine these xi using
the  Chinese  Remainder  Theorem to recover  z mod B,  where  B,  = n:=‘=, Qi. If
Br  >  2 ,  this  yields  I itself,  while  for  B,  5  2:  it  yields  k  =  lg(Br)  bits  of
information about  x. T h e  bitlength  of  the product  of  all small prime factors of
n  is  k, and  each  q;  essentially  leaks  lgq;  bits  of  I.  This  raises  two  important
questions.  Let  l g z  = u .

Q l :   For  a raridorn  prime p ,  what  is the expected  number  of  bits k of  3: leaked?
Q2:  1s t.here an attack finding  t,he remaining  u - k bits of  z  in  O ( e )
 time?
( I f  p  leaks k bits  of  x, t  bits of  security  would then  require  l g z  2 2t + k.)
Related to Q1 and of  more direct  practical  interest  is the question: for a random
prime y, with  what  probability  is  z fully  revealed  ( B ,  > z)? Both  this and  & I
depend  on  the size  of  I relative  to the  smoothness  bound  B .  The expectation

1  I (

lg”  is  used  to denote base-2 logarithms;  “ln”  denotes n a t u r a l   logarithms.

337

is  that  k  z 1gB (see  §3.1), and  thus one  may  expect  full  compromise when
lg B, although there  is  considerable variation. Perhaps  more significant  is
Igz
the affirmative answer  to Q 2 ,  using a new  t.echnique  (see  $3.2).

Expected  Size of Product of  Short Factors of p  - 1

3.1
Again  let  B  be  an  upper  bound such that  computing discrete logs is  computa-
tionally  feasible  in  groups  of  prime  order  q  5 B. Consider  first, for  a random
prime modulus p, the expected  bitlength of the product  B,  of  all  “sma11” primes
pi  <  B  which  divide  p - 1. (More  generally, the  question  relates  t o   divisors
of  a group  order  n.) Each  such  prime  contribut.es lgp,  bits  to  k  = Ig B,.!  and
pi  divides a random  number  with  probability  l/p, (refined  further  below). The
expected  bitlength  of  B,  can  thus be  approximated as:

This sum may be further approximated by summing, rather  than over all primes
p;, over  all  integers  i  2 2  weighted  by  the probability  i is  prime  (estimated  as
11 l n i  by the Prime Number Theorem). Then, since C;”=, i-’  z In B ,

A  slight.ly more precise  estimate results by  replxing l/pi  by  l / ( p t  - l ) ,  justified
as follows. Of  interest. is whet.her p%Ip-- 1. Since pi  does not. divide p, p mod p; #
0  and  thus p  - 1 mod pi  #  -1,
leaving  only  p i   - 1 (not  pi) possible  residue
classes. Moreover,  l / ( p i  - 1) may itself  be refined  to pi/(p; - 1)’.  to account  for
divisors p ;  of  higher multiplicity. Numerical summation of t.his refinement. given
in  Lemma 1, supports  the estimate above.  (While such  a result  is  known, and
may be derived rigourously using advanced number theory, a heuristic derivation
from first principles as given  above is considered  appealing.)
Lemma 1.  For a  random prime p and  a fixed  bound  B  (see  above),  the  expected
bitlength k = lg(B,)  of the product  of all prime  divisors p i   5 B  of p  - 1 is

where  C1  x 0.94,  and  C1  < 1.0 f o r  B > 2”.
This answers Q1 (but see also Table 2); note that. k is independent of lgp. Tahle  1
provides supporting  results  for  a small sample of  random  primes  p .  indicating
the average, minimum, and maximum bitlengths of  the product  of  all B-smooth
prime divisors of p -   1. Note the large deviation from the mean, and that values
B in Table 1 are relatively small.

The cryptographic significance of  Lemma 1 is  as follows. An  adversary with
sufficient computational  resources  t o  compute discrete  logs  in  cyclic groups  of
order up to 2s implies B  =: 2’.  One then expects about Ic  = s bits of  a n  exponent
z are leaked  by  a “random” prime  modulus p (revealing  2: entirely  if  l g z  < s).

338

Ig(B,)  for  100 primes p  z 2Io2*

min

max

16.4

B  mean

-
216
232 1  31.3
I  52.1
2"
1 2"
I  65.0

1.0
1 .o
I  2.6
I  2.6
Table  1. Smoothness of p  - 1 relative  to B. B,  = n qr'  where q,  5 B ,  q?lp  - 1.

194.4
I 243.1

112.2

1

47.2

I

3.2  L a m b d a  Method  Restricted  t o  a Strategic Interval

A  new  technique for  cornputing discret,e logs is now presented, which is computa-
t.ionally feasible when  exponents E  are bounded t,o x a 2"  for (in)appropriat,e u .
The t.echnique first. recovers  what  information about. x  may  be obtained  from a
part.ial Pohlig-Hellman decomposition (say I;  bits), and then employs the lambda
method  t o   recover  the  remaining  bits.  The  combined  technique  runs  in  time
0(2("-')/2).  This answers Q2  in  the affirmative.

Let  y  = gz be  a n  element  of  a group  G  of  order  n ,  with  the  usual  task  t o
determine  x. Isolate  the smooth factors of  n and  write  n = zQ  where  z  = B,
(see  33)  is  the  product  of  smooth factors,  and  has  bitlength  approximately  k.
C0mput.e V  where  V  = 2: mod z,  by  a  partial  Pohlig-Hellman decomposition
(see  $ 2 ) .  Write  x = A z  + V ,  where  0  5  V  <  2 wit.h  A  as yet  unknown. Then
y  = gz = g A z + " .   N o w   A  5 x / z  implies sl E  [0,2'],  where  c  x u - k bits  of  z:
remain unknowii after finding V .  Compute 9"  and y*  = y/gv  = g A z   = hA where
h = gz is  known. Consider  the new  problem of  finding the discrete logarithm A
(relative  to  h )  of  y*,  given  y*  and  the base  h  (in  place  of  9 ) .  Use  the lambda
algorit.hm (see 52) to find A .  Using h in place of g here restricts the trail points t o
a subset. of cardinality about 2'.  As required in the lambda method, the log to be
found (here A  in  place of x) is known to lie in a restricted range [b, b+w] = [0,2"]
of width w  = 2'.  The expected  running time t o  find  A  is thus 0").
z  and  V ,  this allows computation of  x = Az + V .

Knowing

An  example  with  concrete  parameters is  given for  clarity.  Let  G = 2;  and
R  = p - 1 with a 1024-bit prime p  and 160-bit 3: (so ec = 160). Suppose E  = 100
hits  of  L  are  recovered  using  Pohlig-Hellnian  (so I g r   z 100). Then  IgA  sz  60
( c   = 60),  and  ahhough h  generabes  a  subgroup of  order  z  21024-100, recovery
of  A  by  the  lambda method  is  feasible, in  0(230) steps, because  A  is  known  to
lie  in  the  interval  A  E  [0,260] of  width  w  = 260. Note  that  while  the  Shanks
met,hod is also easily adapted  to restricted  intervals, it is much more costly t h a n
t.he lambda due to  memory  requirements.  Furt,hermore, t,he rho  method  is  not
feasible - direct use  results  in  running time which  is  square-root  but in  a group
of  cardinality 2924, and adaptations remain far inferior to the lambda method.
In  summary, the technique  allows  an  at.tack on  Diffie-Hellman  (and  similar
exponentiation-based systems) which  has running t.ime (in number of group op-
erat,ions) significantly better  than  square  root  of  the exponent  space size  (e.g.

339

= 2”).  Instead, it is the larger of the square root after this is first. rediirpd
to account  for  leaked  bits recoverable  by  partial  Pohlig-Hellman  decomposition
 = 230), and the square root of the largest  prime factor of  n used
(e.g. d
in  this decomposition. This establishes the following result.

v

Lemma2.  T h e  security  of  discrete  exponentiation in  a  group  of order n uszng

exponents x  w 2u is at  most a . max(u - k ,  Ig(q,))  bits,  where k is the n u m b e r  of
bits  of x  feasibly recoverable  by  a partial  Pohlig-Hellman decomposition  (using a
partial factorization  of  n),  and  qr  i s  t h e   largest  p r i m e  f a c t o r  of R used  therein.

In  other  words, the  running  time  is  O ( m a x ( G ,  6)).
By  Lemrnal. for
G = 2;  with random primes p ,  one expects k = lg B  for a smoothness boiind  B .
At, present, it, seems dangerous t o  assume other  than that an analogous gcn-
era1 result  holds, when  the exponent space is restricted  t o  any arhit.rary set  S  of
cardinality 2”. Related to this, the rho algorithm is adaptable t o  the case  where
exponents  3: are const,rained by  bounding their  Hamming weight. For  example.
Heiman [5] describes how to do so using Shanks’ method  (t,he rho met.hod woiilrl
furthermore remove  memory  requirements).  We  are  aware  of  no  “faster  than
square-root”  method  on  S in  this  case; the  above  combined  method  does  riot.
appear  t o  apply  directly.  Of  related  interest,  Yacobi  [22]  has sketched  a tech-
nique for improving exponentiation performance (saving multiplications but not
squarings) based  on use of  exponents which  are compressible in  the Ziv-Lempel
sense.

Table 2  provides insight  into the  practical  implicat.ions of  Lemma 2. It  waq
constructed  by  generating  100 random  1024-bit primes p  (as per  Table l ) ,  and
partially factoring each  using  an implementation  of  the elliptic curve  factoriza-
tion  method, specifically  tuned  and  run  t o  find prime  factors  up  t,o 85  bits  i n
length  (thus  with  high  probability  extracting  all  80-bit  fackrs). This allowed
determination  of k for  use  in  the attack of  Lemma 2.

Table2  gives  empirical  values  for  the  percentage  of  cases  this  attack  suc-
ceeds  for  exponents  z = 2”,  assuming  attackers  capable  of  2c  total  modular
multiplications (roughly corresponding t o  an ability to take logs in groups of or-
der = 22c).  For  example, for 32% of these 1024-bit  primes, an adversary capable
of  Z40  multiplications mod p  would find  a 160-bit logarithm x .  An  ideal method
accelerating exponentiation  via short  exponents  would have, in  Table 2, for the
best attack, the entry “100%” only for (roughly) u 5 2c,  and  “0%”  for all u > 2c:
this appears t o  be the case for safe primes ($4) and  prime-order subgroups ($5).

adversary
power zc

224

232

2‘0

64

96

81%

100%

100%

45%
68%
84%

exponent  bitlength  u
192

160

128

18%

38%

55%

10%

25%
32%

1%

12%
22%

224

256

0%

2%
7%

0%

1%

2%

Table  2. Sample  success  rate of  discrete log  attack in  2“ steps, for  1024-bit primes

340

Prior  t.o  this  result,  it.  h a s   been  suggest.ed  that, using  a  160-bit exponent  x
provide dO  bits of  security, for  primes p  which  are not  “Pohlig-Hellman weak”.
1 t  IS now  seen  t.hat. even  “partial”  Pohlig-Hellrnan weakness  may  significantly
reduce  at.t-ack tirnes.  Note  the  power  of  the  divide-and-conquer  nature  of  the
attack: if  n  = p - 1  contains, for example, divisors whose bitlengths sum t o  u/2,
a u-bit. logarithm  can  be  recovered  by  determining  u/2  bits  through  a partial
Pohlig-Hellman  decomposition  in 0 ( 2 ” / 4 )  (and  typically  less t h a n  2”14) steps,
and  u / 2  bits through subsequent use of the lambda method  on the appropriate
subproblem  in  a further  O ( 2 ” l 4 )  steps, giving an  overall cost of  0(2”/4)  steps.
Previously, the best  attack would require the minimum of the time to run either
Pohlig-Hellrnan or  a square-root method on the entire problem, i.e. 0 ( 2 ” / ‘ ) .

4  Use  of  Short  Exponents with  Safe  Primes

Prior uncert,aint,y about the securit.y implications of using arbitrary prime moduli
p  with  short  exponents  T has  motivated  (e.g. [6,  11)  the use  of  sale  p r i m e s  p ,
of  t.he  form  p  =  2q + 1  where  q  is  also  prime.  This  precludes  the  attack  of
Lemma 2  because  a partial  Pohlig-Hellman  decomposition yields  only  a single
bit, of  information about an exponent  x. Against this  attack, it  appears safe to
use  exponents  x zz  2”,  with  u = 2t  determined  such  that  0(2$) operations  are
cornputationally infeasible (perhaps t = 80 for commercial security).

It, should  be  emphasized,  however, that, when  using  short  exponents,  it  is
n o t   f h c  s z n g l p   v e r y  large prame  q  that  provides protection  against  L e m m a   2, but,
rat.her that, t.he t.ot,al bit.lengt,h of smooth factors is k = 1; t,his differs significantly
fronr  t,he sit,uat,ion for  an  ordinary  Pohlig-Hellman att.ack  against  a full-length
exporient.. For  example, p  = Rq + 1 with q  very  large and  R relatively small, e.g.
Ig R = T  = 20  bits, nonetheless  leaks 20  bits of  information about a n  exponent
T  (of bitlengbh  2t  say). This reduces  securit.y from t  t,o t - ( r / 2 )  bits, which  for
short. exponents  (t small) may bring an  attack  per  Lemma 2 within  range.

An advantage of using safe primes p  = 2 q  + 1 is that all group elements of Z;
other  than f l  are then  known t o  have order  either q  or 2q. Consequently g = 2
is known  to be a generator  for the full group of  29  elements if  2  is  a quadratic
non-residue mod p  (in this case one bit of a logarithm z is available by  a partial
Pohlig-Hellman decomposition), and a generator for the subgroup of q  elements
when 2  is  a quadratic residue (in this case, g  = 2 does not leak even one bit).2 In
modular exponentiation using base g = 2, the cost. of the modular multiplies (but
not. squarings) effectively  disappears. Ordinarily, multiplies are more costly than
squatings,  ahhough  the  number  of  multiplies is  substantially  less.  In  efficient
implement.at.ions, this number is reduced further. All points considered, one may
expect  use  of  g  = 2  to result, in  modular exponentiation performance improved
by  20% overall, vs.  an arbitrary  generator  9 .  As the main motivation for  use  of
short exponents  i s  improved performance, this is significant.

A  more important  point  is  t h a t   use  of  a generator  for  the subgroup of  order  p corre-
sponds  to a  prime-order  subgroup as per  $ 5  (albeit  t h e  maximal  proper  subgroup),
which  avoids t h e  attack detailed  in  the last  paragraph  of  54.

341

One drawback, however, is the computational cost of finding safe primes. A n
obvious (but inefficient.) method to find an n - b i t  safe prime p  is  t c i   generat.e a n d
search some space of candidate primes q  = p i  of m -   1 bits, verify t.hat. q is prime,
and  then  verify  the candidate p ;   = 2qi + 1 is  also  prime.  While  the  densit.y  of
primes  in  search  sequences  2q, + 1 differs  somewhat  from  that. of  the  density
of  primes  among  all  integers,  the  latter  is  1/ l n p  (e.g.  1 in  710  zz  In 2'"?4 for
1024-bit  integers).  A  standard  optimization is  to filter  candidate  primes  using
small-prime sieve techniques.  But  even  advanced  techniques  require some form
of  double search,  generating many primes  pi  before  a safe prime p  emerges.  In
contrast,  the  cost  of  parameter  generation  in  t h e   alternative  of  using  prime-
order subgroups ($5) is essentially that of generating a single candidate 1024-bit
prime. Use  of  safe primes thus appears t o  introduce a substantial penalty, with
parameter generation t.ime increased by  a factor roughly equal t.0 t.he number of
trials  required  t.o generat,e an  m - 1 bit  prime qi.

A  drawback  of  more  general  concern  for  basic  forms of  Difie-Hellman  key
agreement  is  a  potentially  fatal  protocol  attack  (rather  than  an  algorithmic
at,tack on  exponent.iation  itself)  which,  although  observed  by  others  (includ-
ing  S. Vanstone),  appears  to  not  yet  be  widely  recognized. T h e  at.tack  applies
also  for  safe  primes,  except  when  the  large  prime-order  subgroup  thereof  is
used  (as  noted  above).  Note  that  if  (Y  generates  2,.  where  p  = 2q + 1,  then
/3  = crQ = crb-1)/2 = -1  is  an  element of  order  2. If  A  and  B  respectively send
each  other  unauthenticated  ephemeral  exponentials  az and  cry  (as in  §1), a n
active intruder may substitute (a")Q for the first, and ( ( Y Y ) ~  for the second. The
shared key computed by both parties is then  K = a z Y q   = /Y, which  is +1  or  -1
depending on the parity of zy. (The attack generalizes directly for p  = Rq+  1 .  in
which  case  Ii'  takes on  one of  R values from t,he group of  order  R. generatd  hy
p = aq; for  appropriately small R, Ii' may thus be  easily  found  by  the  intruder
by exhaustive trial.) This again motivates the use of prime-order subgroups ( i 5 ) .

5  Restricting Computations to  Prime-order Subgroups

To meet the objective of improved running time through use of short exponents,
the recommended  alternative is  t o  employ  an idea  used  in  Schnorr's  signature
scheme [18] and in DSA [19], to guarantee t h a t  computations are carried out in a
large subgroup of cardinality q x  2"  where q  is prime ( a  prime-order  subgroup).
For  t  bits  of  security, set  u  = 2t  (e.g.  u = 160  is  used  in  DSA).  If  g  E  Z i   is
a  generator,  and  q  divides  p  - 1,  then  = g(P-')/q  generates  a subgroup  of
order  q .  Using /3  in  place of g as a base for exponentiation, all exponents I may
be  reduced  modulo q .   Such  an  element /3  of  order  q  may  be  found  as  follows.
Select  a random  element h E  Zp'  and  compute /3  = h ( p - l ) / q ;   repeat  until  /3  #  1 .
(While it suffices  to first  find  a generator g  and  then  use  g  = h  w i t h   guarantwd
success, finding such  a g  is  not  mandatory, and moreover  requires knowledge  of
the factorization  of p  - 1 .)

T h e  expected number of repetitions to find @  # 1 is q / ( q -   1) z 1, established
as follows. A  trial fails if the order of  h divides Q = ( p  - l ) / q ;   otherwise h(P-')/q

342

h a s  order  q  (success).  Since exactly Q elements  have order  which  divides Q ,  the
proportioil  of  eler1rent.s h  which  fails is Q / ( p  - 1) = l / q .
The  use of prime-order  subgroups is by  far preferable  t o  using random primes
($3) and  at,ternpt.ing to  increase  the  exponent.  bitlength  from  2t  to  25  + i!’
t o
compensate  for  divisors  of  p  - 1. The  latter  not  only  increases  exponentiation
t.iiire? but. arr  appropriate  value  of  1’  varies  with  p ,  can  only  be  determined  with
cert.ainty  by  factoring y - 1, and  with  small  probability  may  be  quite  large.
The use of prime-order  subgroups has the advantage over safe primes that prime
generation does not require guaranteeing a large prime divisor q = (p- 1)/2; only
a prime  divisor  q  x  221 is  required.  Since typically 25  <( l g p  (e.g.  160 vs.  1024),
t.he cost. of constructing, by  well-known techniques  [13], a primep such t h a t  p -  1
has a 2t-bit prime divisor  q  is little more than for finding a random prime p .  In
addition, the use of  prime-order  subgroups  precludes  the att,ack discussed  in  the
lajt  paragraph  of  $4.

6  Concluding  Remarks

,411 houglr  the  details differ,  Pollard’s lambda method  can  be  parallelized  analo-
gously  t,o t,he rho  method  (201.  Thus all  aspects  of  the short-exponent  discrete
log attack of  Lemma 2 can be parallelized, and the task  can  be distributed  over
large collections  of  computing platforms (111 , with small memory requirements.
For  a security  requirement  o f t  bits when  using secret  exponents  x in  Diffie-
Hellman  exponentiation  (mod p )  and  similar  systems, use  of  random  primes  p
t,oget,her with  Igz = u  is  clearly  insecure  for  u  = 2t  (and even  larger).  Suscep-
t.ibi1it.y 60  at,t.acks based  on  a partial  Pohlig-Hellman  decomposition  (stemming
from divisors of p - 1) is significant, when  using short exponents 2. In  this case,
random  primes  y  should  not  be  used.

The resulk  herein  firmly  establish that some measure  must  be  taken  to en-
sure securit,y is  preserved  when  using  short  exponents  for  Diffie-Hellman  expo-
irent.iat.ion. Aside  from  precluding  strict  Pohlig-Hellman  attacks,  this  require-
ment  was  hitherto  folklore,  which  has  nonetheless  apparently  helped  motivate
the  use  of  safe  primes  in  practical  protocols  such  as Photuris  [S]  and  SKIP
[l]. We  are  aware  of  no  effective  attacks  against  the  combined  use  of  (appro-
priately)  short  exponents  with  computations restricted  t o   (sufficiently)  large
prime-order  subgroups.  Use of  prime-order  subgroups  allows more efficient gen-
eration  of  ephemeral  Diffie-Hellman  parameters. In  contrast, finding safe primes
p  irit.roduces considerable  expense,  although pre-computing  a safe prime off-line
and  using  g  = 2  as a base  allows  improved  real-time  performance.  However,  in
this case, it, is recomirrerided t,hat the safe prime be one for which g = 2 generates
a large  prinie-order  subgroup  as well.

References

1 .   A .  Aziz,  “Simple  Key  Management  for Internet  Protocols  (SKIP)”, Internet  Draft

(work in  progress), draft-ietf-ipsec-skipO-i.txt, November  1995.

343

2.  A.  Bosselaers,  R. Govaerts,  J. Vandewalle,  “Comparison  of  three  modular  reduc-

tion  functions”,  Crypto’93, Springer-Verlag  LNCS  773, pp.175-176.

3.  W.  Diffie,  M.  Hellman,  “New  directions  in  cryptography”,  IEEE  IT-22  (1976)

pp.644-654.

4.  J.  Hastad,  “On using  RSA with  low exponent in  a public-key  network”.  Crypfn’X.5.

Springer-Verlag  LNCS 218,  pp.403-408.

5.  R.  Heiman,  “A  note on discrete  logarithms with  special  structure“,  Eurocrypl‘S1,

Springer-Verlag  LNCS 658, pp.454-457.

6.  P. Karn, W.A.  Simpson,  “The Photuris session  key  management. prot.ocol”. Inter-

net  Draft  (work in  progress),  draft-ietf-ipsec-photuris-06.txt., Oct,obrr 1995.

7.  D.E.  Knuth,  The A r t  of  Computer Programming, vo1.2: Seminumerical Algorithms,

2nd  edition,  Addison-Wesley,  1981.

8.  D.E.  Knuth,  The  A r t   of  Computer  Programming,  ~01.3: Sorting  and  Searching,

Addison-Wesley,  1973.

9.  B.A.  LaMacchia,  A.M.  Odlyzko,  “Computation  of  discrete  logarithms  in  prime

fields”,  Designs,  Codes  and  Cryptography, vol.1  no.]  (May  1991), pp.47-62.

10.  K.S.  McCurley,  “The  discrete  logarithm  problem”,  pp.49-74  in:  Cryptology  and
Computational Number  Theory - Proc.  Symp. Applied Math., vol. 42  (1990). A M S .
11.  A.K.  Lenstra,  M.S.  Manasse,  “Factoring  by  electronic  mail”,  Eurocrypf ’89.

Springer-Verlag  LNCS 434,  pp.355-371.

12.  U.M.  Maurer,  “Towards  the  equivalence  of  breaking  th e  Diffie-Hellman  proto-
col  and  computing  discrete  logarithms”.  Crypto ’94, Springer-VFrlag  LYCS  839.
pp.271-281.

13.  U.M.  Maurer,  “Fast Generation  of  Prime  Numbers and  Secure  Public-Key  Cryp-

tographic  Parameters”,  J. Cryptology, vo1.8  no.3  (1995),  123-156.

14.  S.C. Pohlig, M.E.  Hellman,  “An improved algorithm for computing logarithms over
G F ( p )  and  its cryptographic significance”, IEEE  Trans. Information Theory, vol.
IT-24, no.1  (Jan. 1978), pp.106-110.

15.  J.M.  Pollard,  “Monte  Carlo  methods  for  index  computation  (mod  p)”:  Math.

Comp., vo1.32  no.143  (July  1978) pp.918-924.

16. R.L.  Rivest,  A.  Shamir, L.  Adleman,  “A  method  for  obtaining  digital  signatures
and  public  key cryptosystems”,  C.ACM, v01.21  no.2  (Feb.  1978), pp.120-126.
17.  R.  Rueppel,  P.C.  van  Oorschot,  “Modern  key  agreement  techniques”,  Computer

Communications, vo1.17  no.7  (July  1994), pp.458-465.

18.  C.P. Schnorr,  “Efficient  signature generation  by  sma rt cards”,  J .   Cryptology ~ 0 1 . 4

(1991), pp.161-174.

19.  U.S. Department of  Commerce / N.I.S.T., Digital  Signature  Standard,  FIPS  186,

National Technical  Information  Service,  Springfield,  Virginia,  May  1994.

20.  P.C.  van Oorschot,  M.J.  Wiener,  “Parallel collision  search with application to  hash
functions  and discrete logarithms”,  Proc.  2nd ACM  Conference on  Computer and
Communications Security (Nov.  1994), Fairfax, VA,  pp.210-218.

21.  M.J. Wiener,  “Cryptanalysis  of short RSA secret exponents”, IEEE Trans. on Info.

Theory, voI.36  no.3  (May  1990), pp.553-558.

22.  Y.  Yacobi,  “Discrete-log with  compressible  exponents”,  Crypto ’90, Springer-Verlag

LNCS  537,  pp.639-643.

