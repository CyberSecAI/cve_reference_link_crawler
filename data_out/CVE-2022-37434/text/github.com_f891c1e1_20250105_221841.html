
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fmadler%2Fzlib%2Fblob%2F21767c654d31d2dccdde4330529775c6c5fd5389%2Fzlib.h)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fmadler%2Fzlib%2Fblob%2F21767c654d31d2dccdde4330529775c6c5fd5389%2Fzlib.h)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=madler%2Fzlib)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[madler](/madler)
/
**[zlib](/madler/zlib)**
Public

* [Notifications](/login?return_to=%2Fmadler%2Fzlib) You must be signed in to change notification settings
* [Fork
  2.5k](/login?return_to=%2Fmadler%2Fzlib)
* [Star
   5.9k](/login?return_to=%2Fmadler%2Fzlib)

* [Code](/madler/zlib)
* [Issues
  140](/madler/zlib/issues)
* [Pull requests
  173](/madler/zlib/pulls)
* [Discussions](/madler/zlib/discussions)
* [Actions](/madler/zlib/actions)
* [Projects
  0](/madler/zlib/projects)
* [Wiki](/madler/zlib/wiki)
* [Security](/madler/zlib/security)
* [Insights](/madler/zlib/pulse)

Additional navigation options

* [Code](/madler/zlib)
* [Issues](/madler/zlib/issues)
* [Pull requests](/madler/zlib/pulls)
* [Discussions](/madler/zlib/discussions)
* [Actions](/madler/zlib/actions)
* [Projects](/madler/zlib/projects)
* [Wiki](/madler/zlib/wiki)
* [Security](/madler/zlib/security)
* [Insights](/madler/zlib/pulse)

## Files

 21767c6
## Breadcrumbs

1. [zlib](/madler/zlib/tree/21767c654d31d2dccdde4330529775c6c5fd5389)
/
# zlib.h

 Blame  Blame
## Latest commit

## History

[History](/madler/zlib/commits/21767c654d31d2dccdde4330529775c6c5fd5389/zlib.h)1935 lines (1643 loc) · 95 KB 21767c6
## Breadcrumbs

1. [zlib](/madler/zlib/tree/21767c654d31d2dccdde4330529775c6c5fd5389)
/
# zlib.h

Top
## File metadata and controls

* Code
* Blame

1935 lines (1643 loc) · 95 KB[Raw](https://github.com/madler/zlib/raw/21767c654d31d2dccdde4330529775c6c5fd5389/zlib.h)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\* zlib.h -- interface of the 'zlib' general purpose compression library version 1.2.12, March 11th, 2022
 Copyright (C) 1995-2022 Jean-loup Gailly and Mark Adler
 This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.
 Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:
 1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required. 2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software. 3. This notice may not be removed or altered from any source distribution.
 Jean-loup Gailly Mark Adler jloup@gzip.org madler@alumni.caltech.edu
 The data format used by the zlib library is described by RFCs (Request for Comments) 1950 to 1952 in the files http://tools.ietf.org/html/rfc1950 (zlib format), rfc1951 (deflate format) and rfc1952 (gzip format).\*/
#ifndef ZLIB\_H#define ZLIB\_H
#include "zconf.h"
#ifdef \_\_cplusplusextern "C" {#endif
#define ZLIB\_VERSION "1.2.12"#define ZLIB\_VERNUM 0x12c0#define ZLIB\_VER\_MAJOR 1#define ZLIB\_VER\_MINOR 2#define ZLIB\_VER\_REVISION 12#define ZLIB\_VER\_SUBREVISION 0
/\* The 'zlib' compression library provides in-memory compression and decompression functions, including integrity checks of the uncompressed data. This version of the library supports only one compression method (deflation) but other algorithms will be added later and will have the same stream interface.
 Compression can be done in a single step if the buffers are large enough, or can be done by repeated calls of the compression function. In the latter case, the application must provide more input and/or consume the output (providing more output space) before each call.
 The compressed data format used by default by the in-memory functions is the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped around a deflate stream, which is itself documented in RFC 1951.
 The library also supports reading and writing files in gzip (.gz) format with an interface similar to that of stdio using the functions that start with "gz". The gzip format is different from the zlib format. gzip is a gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
 This library can optionally read and write gzip and raw deflate streams in memory as well.
 The zlib format was designed to be compact and fast for use in memory and on communications channels. The gzip format was designed for single- file compression on file systems, has a larger header than zlib to maintain directory information, and uses a different, slower check method than zlib.
 The library does not install any signal handler. The decoder checks the consistency of the compressed data, so the library should never crash even in the case of corrupted input.\*/
typedef voidpf (\*alloc\_func) OF((voidpf opaque, uInt items, uInt size));typedef void (\*free\_func) OF((voidpf opaque, voidpf address));
struct internal\_state;
typedef struct z\_stream\_s { z\_const Bytef \*next\_in; /\* next input byte \*/ uInt avail\_in; /\* number of bytes available at next\_in \*/ uLong total\_in; /\* total number of input bytes read so far \*/
 Bytef \*next\_out; /\* next output byte will go here \*/ uInt avail\_out; /\* remaining free space at next\_out \*/ uLong total\_out; /\* total number of bytes output so far \*/
 z\_const char \*msg; /\* last error message, NULL if no error \*/ struct internal\_state FAR \*state; /\* not visible by applications \*/
 alloc\_func zalloc; /\* used to allocate the internal state \*/ free\_func zfree; /\* used to free the internal state \*/ voidpf opaque; /\* private data object passed to zalloc and zfree \*/
 int data\_type; /\* best guess about the data type: binary or text for deflate, or the decoding state for inflate \*/ uLong adler; /\* Adler-32 or CRC-32 value of the uncompressed data \*/ uLong reserved; /\* reserved for future use \*/} z\_stream;
typedef z\_stream FAR \*z\_streamp;
/\* gzip header information passed to and from zlib routines. See RFC 1952 for more details on the meanings of these fields.\*/typedef struct gz\_header\_s { int text; /\* true if compressed data believed to be text \*/ uLong time; /\* modification time \*/ int xflags; /\* extra flags (not used when writing a gzip file) \*/ int os; /\* operating system \*/ Bytef \*extra; /\* pointer to extra field or Z\_NULL if none \*/ uInt extra\_len; /\* extra field length (valid if extra != Z\_NULL) \*/ uInt extra\_max; /\* space at extra (only when reading header) \*/ Bytef \*name; /\* pointer to zero-terminated file name or Z\_NULL \*/ uInt name\_max; /\* space at name (only when reading header) \*/ Bytef \*comment; /\* pointer to zero-terminated comment or Z\_NULL \*/ uInt comm\_max; /\* space at comment (only when reading header) \*/ int hcrc; /\* true if there was or will be a header crc \*/ int done; /\* true when done reading gzip header (not used when writing a gzip file) \*/} gz\_header;
typedef gz\_header FAR \*gz\_headerp;
/\* The application must update next\_in and avail\_in when avail\_in has dropped to zero. It must update next\_out and avail\_out when avail\_out has dropped to zero. The application must initialize zalloc, zfree and opaque before calling the init function. All other fields are set by the compression library and must not be updated by the application.
 The opaque value provided by the application will be passed as the first parameter for calls of zalloc and zfree. This can be useful for custom memory management. The compression library attaches no meaning to the opaque value.
 zalloc must return Z\_NULL if there is not enough memory for the object. If zlib is used in a multi-threaded application, zalloc and zfree must be thread safe. In that case, zlib is thread-safe. When zalloc and zfree are Z\_NULL on entry to the initialization function, they are set to internal routines that use the standard library functions malloc() and free().
 On 16-bit systems, the functions zalloc and zfree must be able to allocate exactly 65536 bytes, but will not be required to allocate more than this if the symbol MAXSEG\_64K is defined (see zconf.h). WARNING: On MSDOS, pointers returned by zalloc for objects of exactly 65536 bytes \*must\* have their offset normalized to zero. The default allocation function provided by this library ensures this (see zutil.c). To reduce memory requirements and avoid any allocation of 64K objects, at the expense of compression ratio, compile the library with -DMAX\_WBITS=14 (see zconf.h).
 The fields total\_in and total\_out can be used for statistics or progress reports. After compression, total\_in holds the total size of the uncompressed data and may be saved for use by the decompressor (particularly if the decompressor wants to decompress everything in a single step).\*/
 /\* constants \*/
#define Z\_NO\_FLUSH 0#define Z\_PARTIAL\_FLUSH 1#define Z\_SYNC\_FLUSH 2#define Z\_FULL\_FLUSH 3#define Z\_FINISH 4#define Z\_BLOCK 5#define Z\_TREES 6/\* Allowed flush values; see deflate() and inflate() below for details \*/
#define Z\_OK 0#define Z\_STREAM\_END 1#define Z\_NEED\_DICT 2#define Z\_ERRNO (-1)#define Z\_STREAM\_ERROR (-2)#define Z\_DATA\_ERROR (-3)#define Z\_MEM\_ERROR (-4)#define Z\_BUF\_ERROR (-5)#define Z\_VERSION\_ERROR (-6)/\* Return codes for the compression/decompression functions. Negative values \* are errors, positive values are used for special but normal events. \*/
#define Z\_NO\_COMPRESSION 0#define Z\_BEST\_SPEED 1#define Z\_BEST\_COMPRESSION 9#define Z\_DEFAULT\_COMPRESSION (-1)/\* compression levels \*/
#define Z\_FILTERED 1#define Z\_HUFFMAN\_ONLY 2#define Z\_RLE 3#define Z\_FIXED 4#define Z\_DEFAULT\_STRATEGY 0/\* compression strategy; see deflateInit2() below for details \*/
#define Z\_BINARY 0#define Z\_TEXT 1#define Z\_ASCII Z\_TEXT /\* for compatibility with 1.2.2 and earlier \*/#define Z\_UNKNOWN 2/\* Possible values of the data\_type field for deflate() \*/
#define Z\_DEFLATED 8/\* The deflate compression method (the only one supported in this version) \*/
#define Z\_NULL 0 /\* for initializing zalloc, zfree, opaque \*/
#define zlib\_version zlibVersion()/\* for compatibility with versions < 1.0.2 \*/
 /\* basic functions \*/
ZEXTERN const char \* ZEXPORT zlibVersion OF((void));/\* The application can compare zlibVersion and ZLIB\_VERSION for consistency. If the first character differs, the library code actually used is not compatible with the zlib.h header file used by the application. This check is automatically made by deflateInit and inflateInit. \*/
/\*ZEXTERN int ZEXPORT deflateInit OF((z\_streamp strm, int level));
 Initializes the internal stream state for compression. The fields zalloc, zfree and opaque must be initialized before by the caller. If zalloc and zfree are set to Z\_NULL, deflateInit updates them to use default allocation functions.
 The compression level must be Z\_DEFAULT\_COMPRESSION, or between 0 and 9: 1 gives best speed, 9 gives best compression, 0 gives no compression at all (the input data is simply copied a block at a time). Z\_DEFAULT\_COMPRESSION requests a default compromise between speed and compression (currently equivalent to level 6).
 deflateInit returns Z\_OK if success, Z\_MEM\_ERROR if there was not enough memory, Z\_STREAM\_ERROR if level is not a valid compression level, or Z\_VERSION\_ERROR if the zlib library version (zlib\_version) is incompatible with the version assumed by the caller (ZLIB\_VERSION). msg is set to null if there is no error message. deflateInit does not perform any compression: this will be done by deflate().\*/
ZEXTERN int ZEXPORT deflate OF((z\_streamp strm, int flush));/\* deflate compresses as much data as possible, and stops when the input buffer becomes empty or the output buffer becomes full. It may introduce some output latency (reading input without producing any output) except when forced to flush.
 The detailed semantics are as follows. deflate performs one or both of the following actions:
 - Compress more input starting at next\_in and update next\_in and avail\_in accordingly. If not all input can be processed (because there is not enough room in the output buffer), next\_in and avail\_in are updated and processing will resume at this point for the next call of deflate().
 - Generate more output starting at next\_out and update next\_out and avail\_out accordingly. This action is forced if the parameter flush is non zero. Forcing flush frequently degrades the compression ratio, so this parameter should be set only when necessary. Some output may be provided even if flush is zero.
 Before the call of deflate(), the application should ensure that at least one of the actions is possible, by providing more input and/or consuming more output, and updating avail\_in or avail\_out accordingly; avail\_out should never be zero before the call. The application can consume the compressed output when it wants, for example when the output buffer is full (avail\_out == 0), or after each call of deflate(). If deflate returns Z\_OK and with zero avail\_out, it must be called again after making room in the output buffer because there might be more output pending. See deflatePending(), which can be used if desired to determine whether or not there is more ouput in that case.
 Normally the parameter flush is set to Z\_NO\_FLUSH, which allows deflate to decide how much data to accumulate before producing output, in order to maximize compression.
 If the parameter flush is set to Z\_SYNC\_FLUSH, all pending output is flushed to the output buffer and the output is aligned on a byte boundary, so that the decompressor can get all input data available so far. (In particular avail\_in is zero after the call if enough output space has been provided before the call.) Flushing may degrade compression for some compression algorithms and so it should be used only when necessary. This completes the current deflate block and follows it with an empty stored block that is three bits plus filler bits to the next byte, followed by four bytes (00 00 ff ff).
 If flush is set to Z\_PARTIAL\_FLUSH, all pending output is flushed to the output buffer, but the output is not aligned to a byte boundary. All of the input data so far will be available to the decompressor, as for Z\_SYNC\_FLUSH. This completes the current deflate block and follows it with an empty fixed codes block that is 10 bits long. This assures that enough bytes are output in order for the decompressor to finish the block before the empty fixed codes block.
 If flush is set to Z\_BLOCK, a deflate block is completed and emitted, as for Z\_SYNC\_FLUSH, but the output is not aligned on a byte boundary, and up to seven bits of the current block are held to be written as the next byte after the next deflate block is completed. In this case, the decompressor may not be provided enough bits at this point in order to complete decompression of the data provided so far to the compressor. It may need to wait for the next block to be emitted. This is for advanced applications that need to control the emission of deflate blocks.
 If flush is set to Z\_FULL\_FLUSH, all output is flushed as with Z\_SYNC\_FLUSH, and the compression state is reset so that decompression can restart from this point if previous compressed data has been damaged or if random access is desired. Using Z\_FULL\_FLUSH too often can seriously degrade compression.
 If deflate returns with avail\_out == 0, this function must be called again with the same value of the flush parameter and more output space (updated avail\_out), until the flush is complete (deflate returns with non-zero avail\_out). In the case of a Z\_FULL\_FLUSH or Z\_SYNC\_FLUSH, make sure that avail\_out is greater than six to avoid repeated flush markers due to avail\_out == 0 on return.
 If the parameter flush is set to Z\_FINISH, pending input is processed, pending output is flushed and deflate returns with Z\_STREAM\_END if there was enough output space. If deflate returns with Z\_OK or Z\_BUF\_ERROR, this function must be called again with Z\_FINISH and more output space (updated avail\_out) but no more input data, until it returns with Z\_STREAM\_END or an error. After deflate has returned Z\_STREAM\_END, the only possible operations on the stream are deflateReset or deflateEnd.
 Z\_FINISH can be used in the first deflate call after deflateInit if all the compression is to be done in a single step. In order to complete in one call, avail\_out must be at least the value returned by deflateBound (see below). Then deflate is guaranteed to return Z\_STREAM\_END. If not enough output space is provided, deflate will not return Z\_STREAM\_END, and it must be called again as described above.
 deflate() sets strm->adler to the Adler-32 checksum of all input read so far (that is, total\_in bytes). If a gzip stream is being generated, then strm->adler will be the CRC-32 checksum of the input read so far. (See deflateInit2 below.)
 deflate() may update strm->data\_type if it can make a good guess about the input data type (Z\_BINARY or Z\_TEXT). If in doubt, the data is considered binary. This field is only for information purposes and does not affect the compression algorithm in any manner.
 deflate() returns Z\_OK if some progress has been made (more input processed or more output produced), Z\_STREAM\_END if all input has been consumed and all output has been produced (only when flush is set to Z\_FINISH), Z\_STREAM\_ERROR if the stream state was inconsistent (for example if next\_in or next\_out was Z\_NULL or the state was inadvertently written over by the application), or Z\_BUF\_ERROR if no progress is possible (for example avail\_in or avail\_out was zero). Note that Z\_BUF\_ERROR is not fatal, and deflate() can be called again with more input and more output space to continue compressing.\*/
ZEXTERN int ZEXPORT deflateEnd OF((z\_streamp strm));/\* All dynamically allocated data structures for this stream are freed. This function discards any unprocessed input and does not flush any pending output.
 deflateEnd returns Z\_OK if success, Z\_STREAM\_ERROR if the stream state was inconsistent, Z\_DATA\_ERROR if the stream was freed prematurely (some input or output was discarded). In the error case, msg may be set but then points to a static string (which must not be deallocated).\*/
/\*ZEXTERN int ZEXPORT inflateInit OF((z\_streamp strm));
 Initializes the internal stream state for decompression. The fields next\_in, avail\_in, zalloc, zfree and opaque must be initialized before by the caller. In the current version of inflate, the provided input is not read or consumed. The allocation of a sliding window will be deferred to the first call of inflate (if the decompression does not complete on the first call). If zalloc and zfree are set to Z\_NULL, inflateInit updates them to use default allocation functions.
 inflateInit returns Z\_OK if success, Z\_MEM\_ERROR if there was not enough memory, Z\_VERSION\_ERROR if the zlib library version is incompatible with the version assumed by the caller, or Z\_STREAM\_ERROR if the parameters are invalid, such as a null pointer to the structure. msg is set to null if there is no error message. inflateInit does not perform any decompression. Actual decompression will be done by inflate(). So next\_in, and avail\_in, next\_out, and avail\_out are unused and unchanged. The current implementation of inflateInit() does not process any header information -- that is deferred until inflate() is called.\*/
ZEXTERN int ZEXPORT inflate OF((z\_streamp strm, int flush));/\* inflate decompresses as much data as possible, and stops when the input buffer becomes empty or the output buffer becomes full. It may introduce some output latency (reading input without producing any output) except when forced to flush.
 The detailed semantics are as follows. inflate performs one or both of the following actions:
 - Decompress more input starting at next\_in and update next\_in and avail\_in accordingly. If not all input can be processed (because there is not enough room in the output buffer), then next\_in and avail\_in are updated accordingly, and processing will resume at this point for the next call of inflate().
 - Generate more output starting at next\_out and update next\_out and avail\_out accordingly. inflate() provides as much output as possible, until there is no more input data or no more space in the output buffer (see below about the flush parameter).
 Before the call of inflate(), the application should ensure that at least one of the actions is possible, by providing more input and/or consuming more output, and updating the next\_\* and avail\_\* values accordingly. If the caller of inflate() does not provide both available input and available output space, it is possible that there will be no progress made. The application can consume the uncompressed output when it wants, for example when the output buffer is full (avail\_out == 0), or after each call of inflate(). If inflate returns Z\_OK and with zero avail\_out, it must be called again after making room in the output buffer because there might be more output pending.
 The flush parameter of inflate() can be Z\_NO\_FLUSH, Z\_SYNC\_FLUSH, Z\_FINISH, Z\_BLOCK, or Z\_TREES. Z\_SYNC\_FLUSH requests that inflate() flush as much output as possible to the output buffer. Z\_BLOCK requests that inflate() stop if and when it gets to the next deflate block boundary. When decoding the zlib or gzip format, this will cause inflate() to return immediately after the header and before the first block. When doing a raw inflate, inflate() will go ahead and process the first block, and will return when it gets to the end of that block, or when it runs out of data.
 The Z\_BLOCK option assists in appending to or combining deflate streams. To assist in this, on return inflate() always sets strm->data\_type to the number of unused bits in the last byte taken from strm->next\_in, plus 64 if inflate() is currently decoding the last block in the deflate stream, plus 128 if inflate() returned immediately after decoding an end-of-block code or decoding the complete header up to just before the first byte of the deflate stream. The end-of-block will not be indicated until all of the uncompressed data from that block has been written to strm->next\_out. The number of unused bits may in general be greater than seven, except when bit 7 of data\_type is set, in which case the number of unused bits will be less than eight. data\_type is set as noted here every time inflate() returns for all flush options, and so can be used to determine the amount of currently consumed input in bits.
 The Z\_TREES option behaves as Z\_BLOCK does, but it also returns when the end of each deflate block header is reached, before any actual data in that block is decoded. This allows the caller to determine the length of the deflate block header for later use in random access within a deflate block. 256 is added to the value of strm->data\_type when inflate() returns immediately after reaching the end of the deflate block header.
 inflate() should normally be called until it returns Z\_STREAM\_END or an error. However if all decompression is to be performed in a single step (a single call of inflate), the parameter flush should be set to Z\_FINISH. In this case all pending input is processed and all pending output is flushed; avail\_out must be large enough to hold all of the uncompressed data for the operation to complete. (The size of the uncompressed data may have been saved by the compressor for this purpose.) The use of Z\_FINISH is not required to perform an inflation in one step. However it may be used to inform inflate that a faster approach can be used for the single inflate() call. Z\_FINISH also informs inflate to not maintain a sliding window if the stream completes, which reduces inflate's memory footprint. If the stream does not complete, either because not all of the stream is provided or not enough output space is provided, then a sliding window will be allocated and inflate() can be called again to continue the operation as if Z\_NO\_FLUSH had been used.
 In this implementation, inflate() always flushes as much output as possible to the output buffer, and always uses the faster approach on the first call. So the effects of the flush parameter in this implementation are on the return value of inflate() as noted below, when inflate() returns early when Z\_BLOCK or Z\_TREES is used, and when inflate() avoids the allocation of memory for a sliding window when Z\_FINISH is used.
 If a preset dictionary is needed after this call (see inflateSetDictionary below), inflate sets strm->adler to the Adler-32 checksum of the dictionary chosen by the compressor and returns Z\_NEED\_DICT; otherwise it sets strm->adler to the Adler-32 checksum of all output produced so far (that is, total\_out bytes) and returns Z\_OK, Z\_STREAM\_END or an error code as described below. At the end of the stream, inflate() checks that its computed Adler-32 checksum is equal to that saved by the compressor and returns Z\_STREAM\_END only if the checksum is correct.
 inflate() can decompress and check either zlib-wrapped or gzip-wrapped deflate data. The header type is detected automatically, if requested when initializing with inflateInit2(). Any information contained in the gzip header is not retained unless inflateGetHeader() is used. When processing gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output produced so far. The CRC-32 is checked against the gzip trailer, as is the uncompressed length, modulo 2^32.
 inflate() returns Z\_OK if some progress has been made (more input processed or more output produced), Z\_STREAM\_END if the end of the compressed data has been reached and all uncompressed output has been produced, Z\_NEED\_DICT if a preset dictionary is needed at this point, Z\_DATA\_ERROR if the input data was corrupted (input stream not conforming to the zlib format or incorrect check value, in which case strm->msg points to a string with a more specific error), Z\_STREAM\_ERROR if the stream structure was inconsistent (for example next\_in or next\_out was Z\_NULL, or the state was inadvertently written over by the application), Z\_MEM\_ERROR if there was not enough memory, Z\_BUF\_ERROR if no progress was possible or if there was not enough room in the output buffer when Z\_FINISH is used. Note that Z\_BUF\_ERROR is not fatal, and inflate() can be called again with more input and more output space to continue decompressing. If Z\_DATA\_ERROR is returned, the application may then call inflateSync() to look for a good compression block if a partial recovery of the data is to be attempted.\*/
ZEXTERN int ZEXPORT inflateEnd OF((z\_streamp strm));/\* All dynamically allocated data structures for this stream are freed. This function discards any unprocessed input and does not flush any pending output.
 inflateEnd returns Z\_OK if success, or Z\_STREAM\_ERROR if the stream state was inconsistent.\*/
 /\* Advanced functions \*/
/\* The following functions are needed only in some special applications.\*/
/\*ZEXTERN int ZEXPORT deflateInit2 OF((z\_streamp strm, int level, int method, int windowBits, int memLevel, int strategy));
 This is another version of deflateInit with more compression options. The fields zalloc, zfree and opaque must be initialized before by the caller.
 The method parameter is the compression method. It must be Z\_DEFLATED in this version of the library.
 The windowBits parameter is the base two logarithm of the window size (the size of the history buffer). It should be in the range 8..15 for this version of the library. Larger values of this parameter result in better compression at the expense of memory usage. The default value is 15 if deflateInit is used instead.
 For the current implementation of deflate(), a windowBits value of 8 (a window size of 256 bytes) is not supported. As a result, a request for 8 will result in 9 (a 512-byte window). In that case, providing 8 to inflateInit2() will result in an error when the zlib header with 9 is checked against the initialization of inflate(). The remedy is to not use 8 with deflateInit2() with this initialization, or at least in that case use 9 with inflateInit2().
 windowBits can also be -8..-15 for raw deflate. In this case, -windowBits determines the window size. deflate() will then generate raw deflate data with no zlib header or trailer, and will not compute a check value.
 windowBits can also be greater than 15 for optional gzip encoding. Add 16 to windowBits to write a simple gzip header and trailer around the compressed data instead of a zlib wrapper. The gzip header will have no file name, no extra data, no comment, no modification time (set to zero), no header crc, and the operating system will be set to the appropriate value, if the operating system was determined at compile time. If a gzip stream is being written, strm->adler is a CRC-32 instead of an Adler-32.
 For raw deflate or gzip encoding, a request for a 256-byte window is rejected as invalid, since only the zlib header provides a means of transmitting the window size to the decompressor.
 The memLevel parameter specifies how much memory should be allocated for the internal compression state. memLevel=1 uses minimum memory but is slow and reduces compression ratio; memLevel=9 uses maximum memory for optimal speed. The default value is 8. See zconf.h for total memory usage as a function of windowBits and memLevel.
 The strategy parameter is used to tune the compression algorithm. Use the value Z\_DEFAULT\_STRATEGY for normal data, Z\_FILTERED for data produced by a filter (or predictor), Z\_HUFFMAN\_ONLY to force Huffman encoding only (no string match), or Z\_RLE to limit match distances to one (run-length encoding). Filtered data consists mostly of small values with a somewhat random distribution. In this case, the compression algorithm is tuned to compress them better. The effect of Z\_FILTERED is to force more Huffman coding and less string matching; it is somewhat intermediate between Z\_DEFAULT\_STRATEGY and Z\_HUFFMAN\_ONLY. Z\_RLE is designed to be almost as fast as Z\_HUFFMAN\_ONLY, but give better compression for PNG image data. The strategy parameter only affects the compression ratio but not the correctness of the compressed output even if it is not set appropriately. Z\_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler decoder for special applications.
 deflateInit2 returns Z\_OK if success, Z\_MEM\_ERROR if there was not enough memory, Z\_STREAM\_ERROR if any parameter is invalid (such as an invalid method), or Z\_VERSION\_ERROR if the zlib library version (zlib\_version) is incompatible with the version assumed by the caller (ZLIB\_VERSION). msg is set to null if there is no error message. deflateInit2 does not perform any compression: this will be done by deflate().\*/
ZEXTERN int ZEXPORT deflateSetDictionary OF((z\_streamp strm, const Bytef \*dictionary, uInt dictLength));/\* Initializes the compression dictionary from the given byte sequence without producing any compressed output. When using the zlib format, this function must be called immediately after deflateInit, deflateInit2 or deflateReset, and before any call of deflate. When doing raw deflate, this function must be called either before any call of deflate, or immediately after the completion of a deflate block, i.e. after all input has been consumed and all output has been delivered when using any of the flush options Z\_BLOCK, Z\_PARTIAL\_FLUSH, Z\_SYNC\_FLUSH, or Z\_FULL\_FLUSH. The compressor and decompressor must use exactly the same dictionary (see inflateSetDictionary).
 The dictionary should consist of strings (byte sequences) that are likely to be encountered later in the data to be compressed, with the most commonly used strings preferably put towards the end of the dictionary. Using a dictionary is most useful when the data to be compressed is short and can be predicted with good accuracy; the data can then be compressed better than with the default empty dictionary.
 Depending on the size of the compression data structures selected by deflateInit or deflateInit2, a part of the dictionary may in effect be discarded, for example if the dictionary is larger than the window size provided in deflateInit or deflateInit2. Thus the strings most likely to be useful should be put at the end of the dictionary, not at the front. In addition, the current implementation of deflate will use at most the window size minus 262 bytes of the provided dictionary.
 Upon return of this function, strm->adler is set to the Adler-32 value of the dictionary; the decompressor may later use this value to determine which dictionary has been used by the compressor. (The Adler-32 value applies to the whole dictionary even if only a subset of the dictionary is actually used by the compressor.) If a raw deflate was requested, then the Adler-32 value is not computed and strm->adler is not set.
 deflateSetDictionary returns Z\_OK if success, or Z\_STREAM\_ERROR if a parameter is invalid (e.g. dictionary being Z\_NULL) or the stream state is inconsistent (for example if deflate has already been called for this stream or if not at a block boundary for raw deflate). deflateSetDictionary does not perform any compression: this will be done by deflate().\*/
ZEXTERN int ZEXPORT deflateGetDictionary OF((z\_streamp strm, Bytef \*dictionary, uInt \*dictLength));/\* Returns the sliding dictionary being maintained by deflate. dictLength is set to the number of bytes in the dictionary, and that many bytes are copied to dictionary. dictionary must have enough space, where 32768 bytes is always enough. If deflateGetDictionary() is called with dictionary equal to Z\_NULL, then only the dictionary length is returned, and nothing is copied. Similary, if dictLength is Z\_NULL, then it is not set.
 deflateGetDictionary() may return a length less than the window size, even when more than the window size in input has been provided. It may return up to 258 bytes less in that case, due to how zlib's implementation of deflate manages the sliding window and lookahead for matches, where matches can be up to 258 bytes long. If the application needs the last window-size bytes of input, then that would need to be saved by the application outside of zlib.
 deflateGetDictionary returns Z\_OK on success, or Z\_STREAM\_ERROR if the stream state is inconsistent.\*/
ZEXTERN int ZEXPORT deflateCopy OF((z\_streamp dest, z\_streamp source));/\* Sets the destination stream as a complete copy of the source stream.
 This function can be useful when several compression strategies will be tried, for example when there are several ways of pre-processing the input data with a filter. The streams that will be discarded should then be freed by calling deflateEnd. Note that deflateCopy duplicates the internal compression state which can be quite large, so this strategy is slow and can consume lots of memory.
 deflateCopy returns Z\_OK if success, Z\_MEM\_ERROR if there was not enough memory, Z\_STREAM\_ERROR if the source stream state was inconsistent (such as zalloc being Z\_NULL). msg is left unchanged in both source and destination.\*/
ZEXTERN int ZEXPORT deflateReset OF((z\_streamp strm));/\* This function is equivalent to deflateEnd followed by deflateInit, but does not free and reallocate the internal compression state. The stream will leave the compression level and any other attributes that may have been set unchanged.
 deflateReset returns Z\_OK if success, or Z\_STREAM\_ERROR if the source stream state was inconsistent (such as zalloc or state being Z\_NULL).\*/
ZEXTERN int ZEXPORT deflateParams OF((z\_streamp strm, int level, int strategy));/\* Dynamically update the compression level and compression strategy. The interpretation of level and strategy is as in deflateInit2(). This can be used to switch between compression and straight copy of the input data, or to switch to a different kind of input data requiring a different strategy. If the compression approach (which is a function of the level) or the strategy is changed, and if there have been any deflate() calls since the state was initialized or reset, then the input available so far is compressed with the old level and strategy using deflate(strm, Z\_BLOCK). There are three approaches for the compression levels 0, 1..3, and 4..9 respectively. The new level and strategy will take effect at the next call of deflate().
 If a deflate(strm, Z\_BLOCK) is performed by deflateParams(), and it does not have enough output space to complete, then the parameter change will not take effect. In this case, deflateParams() can be called again with the same parameters and more output space to try again.
 In order to assure a change in the parameters on the first try, the deflate stream should be flushed using deflate() with Z\_BLOCK or other flush request until strm.avail\_out is not zero, before calling deflateParams(). Then no more input data should be provided before the deflateParams() call. If this is done, the old level and strategy will be applied to the data compressed before deflateParams(), and the new level and strategy will be applied to the the data compressed after deflateParams().
 deflateParams returns Z\_OK on success, Z\_STREAM\_ERROR if the source stream state was inconsistent or if a parameter was invalid, or Z\_BUF\_ERROR if there was not enough output space to complete the compression of the available input data before a change in the strategy or approach. Note that in the case of a Z\_BUF\_ERROR, the parameters are not changed. A return value of Z\_BUF\_ERROR is not fatal, in which case deflateParams() can be retried with more output space.\*/
ZEXTERN int ZEXPORT deflateTune OF((z\_streamp strm, int good\_length, int max\_lazy, int nice\_length, int max\_chain));/\* Fine tune deflate's internal compression parameters. This should only be used by someone who understands the algorithm used by zlib's deflate for searching for the best matching string, and even then only by the most fanatic optimizer trying to squeeze out the last compressed bit for their specific input data. Read the deflate.c source code for the meaning of the max\_lazy, good\_length, nice\_length, and max\_chain parameters.
 deflateTune() can be called after deflateInit() or deflateInit2(), and returns Z\_OK on success, or Z\_STREAM\_ERROR for an invalid deflate stream. \*/
ZEXTERN uLong ZEXPORT deflateBound OF((z\_streamp strm, uLong sourceLen));/\* deflateBound() returns an upper bound on the compressed size after deflation of sourceLen bytes. It must be called after deflateInit() or deflateInit2(), and after deflateSetHeader(), if used. This would be used to allocate an output buffer for deflation in a single pass, and so would be called before deflate(). If that first deflate() call is provided the sourceLen input bytes, an output buffer allocated to the size returned by deflateBound(), and the flush value Z\_FINISH, then deflate() is guaranteed to return Z\_STREAM\_END. Note that it is possible for the compressed size to be larger than the value returned by deflateBound() if flush options other than Z\_FINISH or Z\_NO\_FLUSH are used.\*/
ZEXTERN int ZEXPORT deflatePending OF((z\_streamp strm, unsigned \*pending, int \*bits));/\* deflatePending() returns the number of bytes and bits of output that have been generated, but not yet provided in the available output. The bytes not provided would be due to the available output space having being consumed. The number of bits of output not provided are between 0 and 7, where they await more bits to join them in order to fill out a full byte. If pending or bits are Z\_NULL, then those values are not set.
 deflatePending returns Z\_OK if success, or Z\_STREAM\_ERROR if the source stream state was inconsistent. \*/
ZEXTERN int ZEXPORT deflatePrime OF((z\_streamp strm, int bits, int value));/\* deflatePrime() inserts bits in the deflate output stream. The intent is that this function is used to start off the deflate output with the bits leftover from a previous deflate stream when appending to it. As such, this function can only be used for raw deflate, and must be used before the first deflate() call after a deflateInit2() or deflateReset(). bits must be less than or equal to 16, and that many of the least significant bits of value will be inserted in the output.
 deflatePrime returns Z\_OK if success, Z\_BUF\_ERROR if there was not enough room in the internal buffer to insert the bits, or Z\_STREAM\_ERROR if the source stream state was inconsistent.\*/
ZEXTERN int ZEXPORT deflateSetHeader OF((z\_streamp strm, gz\_headerp head));/\* deflateSetHeader() provides gzip header information for when a gzip stream is requested by deflateInit2(). deflateSetHeader() may be called after deflateInit2() or deflateReset() and before the first call of deflate(). The text, time, os, extra field, name, and comment information in the provided gz\_header structure are written to the gzip header (xflag is ignored -- the extra flags are set according to the compression level). The caller must assure that, if not Z\_NULL, name and comment are terminated with a zero byte, and that if extra is not Z\_NULL, that extra\_len bytes are available there. If hcrc is true, a gzip header crc is included. Note that the current versions of the command-line version of gzip (up through version 1.3.x) do not support header crc's, and will report that it is a "multi-part gzip file" and give up.
 If deflateSetHeader is not used, the default gzip header has text false, the time set to zero, and os set to 255, with no extra, name, or comment fields. The gzip header is returned to the default state by deflateReset().
 deflateSetHeader returns Z\_OK if success, or Z\_STREAM\_ERROR if the source stream state was inconsistent.\*/
/\*ZEXTERN int ZEXPORT inflateInit2 OF((z\_streamp strm, int windowBits));
 This is another version of inflateInit with an extra parameter. The fields next\_in, avail\_in, zalloc, zfree and opaque must be initialized before by the caller.
 The windowBits parameter is the base two logarithm of the maximum window size (the size of the history buffer). It should be in the range 8..15 for this version of the library. The default value is 15 if inflateInit is used instead. windowBits must be greater than or equal to the windowBits value provided to deflateInit2() while compressing, or it must be equal to 15 if deflateInit2() was not used. If a compressed stream with a larger window size is given as input, inflate() will return with the error code Z\_DATA\_ERROR instead of trying to allocate a larger window.
 windowBits can also be zero to request that inflate use the window size in the zlib header of the compressed stream.
 windowBits can also be -8..-15 for raw inflate. In this case, -windowBits determines the window size. inflate() will then process raw deflate data, not looking for a zlib or gzip header, not generating a check value, and not looking for any check values for comparison at the end of the stream. This is for use with other formats that use the deflate compressed data format such as zip. Those formats provide their own check values. If a custom format is developed using the raw deflate format for compressed data, it is recommended that a check value such as an Adler-32 or a CRC-32 be applied to the uncompressed data as is done in the zlib, gzip, and zip formats. For most applications, the zlib format should be used as is. Note that comments above on the use in deflateInit2() applies to the magnitude of windowBits.
 windowBits can also be greater than 15 for optional gzip decoding. Add 32 to windowBits to enable zlib and gzip decoding with automatic header detection, or add 16 to decode only the gzip format (the zlib format will return a Z\_DATA\_ERROR). If a gzip stream is being decoded, strm->adler is a CRC-32 instead of an Adler-32. Unlike the gunzip utility and gzread() (see below), inflate() will \*not\* automatically decode concatenated gzip members. inflate() will return Z\_STREAM\_END at the end of the gzip member. The state would need to be reset to continue decoding a subsequent gzip member. This \*must\* be done if there is more data after a gzip member, in order for the decompression to be compliant with the gzip standard (RFC 1952).
 inflateInit2 returns Z\_OK if success, Z\_MEM\_ERROR if there was not enough memory, Z\_VERSION\_ERROR if the zlib library version is incompatible with the version assumed by the caller, or Z\_STREAM\_ERROR if the parameters are invalid, such as a null pointer to the structure. msg is set to null if there is no error message. inflateInit2 does not perform any decompression apart from possibly reading the zlib header if present: actual decompression will be done by inflate(). (So next\_in and avail\_in may be modified, but next\_out and avail\_out are unused and unchanged.) The current implementation of inflateInit2() does not process any header information -- that is deferred until inflate() is called.\*/
ZEXTERN int ZEXPORT inflateSetDictionary OF((z\_streamp strm, const Bytef \*dictionary, uInt dictLength));/\* Initializes the decompression dictionary from the given uncompressed byte sequence. This function must be called immediately after a call of inflate, if that call returned Z\_NEED\_DICT. The dictionary chosen by the compressor can be determined from the Adler-32 value returned by that call of inflate. The compressor and decompressor must use exactly the same dictionary (see deflateSetDictionary). For raw inflate, this function can be called at any time to set the dictionary. If the provided dictionary is smaller than the window and there is already data in the window, then the provided dictionary will amend what's there. The application must insure that the dictionary that was used for compression is provided.
 inflateSetDictionary returns Z\_OK if success, Z\_STREAM\_ERROR if a parameter is invalid (e.g. dictionary being Z\_NULL) or the stream state is inconsistent, Z\_DATA\_ERROR if the given dictionary doesn't match the expected one (incorrect Adler-32 value). inflateSetDictionary does not perform any decompression: this will be done by subsequent calls of inflate().\*/
ZEXTERN int ZEXPORT inflateGetDictionary OF((z\_streamp strm, Bytef \*dictionary, uInt \*dictLength));/\* Returns the sliding dictionary being maintained by inflate. dictLength is set to the number of bytes in the dictionary, and that many bytes are copied to dictionary. dictionary must have enough space, where 32768 bytes is always enough. If inflateGetDictionary() is called with dictionary equal to Z\_NULL, then only the dictionary length is returned, and nothing is copied. Similary, if dictLength is Z\_NULL, then it is not set.
 inflateGetDictionary returns Z\_OK on success, or Z\_STREAM\_ERROR if the stream state is inconsistent.\*/
ZEXTERN int ZEXPORT inflateSync OF((z\_streamp strm));/\* Skips invalid compressed data until a possible full flush point (see above for the description of deflate with Z\_FULL\_FLUSH) can be found, or until all available input is skipped. No output is provided.
 inflateSync searches for a 00 00 FF FF pattern in the compressed data. All full flush points have this pattern, but not all occurrences of this pattern are full flush points.
 inflateSync returns Z\_OK if a possible full flush point has been found, Z\_BUF\_ERROR if no more input was provided, Z\_DATA\_ERROR if no flush point has been found, or Z\_STREAM\_ERROR if the stream structure was inconsistent. In the success case, the application may save the current current value of total\_in which indicates where valid compressed data was found. In the error case, the application may repeatedly call inflateSync, providing more input each time, until success or end of the input data.\*/
ZEXTERN int ZEXPORT inflateCopy OF((z\_streamp dest, z\_streamp source));/\* Sets the destination stream as a complete copy of the source stream.
 This function can be useful when randomly accessing a large stream. The first pass through the stream can periodically record the inflate state, allowing restarting inflate at those points when randomly accessing the stream.
 inflateCopy returns Z\_OK if success, Z\_MEM\_ERROR if there was not enough memory, Z\_STREAM\_ERROR if the source stream state was inconsistent (such as zalloc being Z\_NULL). msg is left unchanged in both source and destination.\*/
ZEXTERN int ZEXPORT inflateReset OF((z\_streamp strm));/\* This function is equivalent to inflateEnd followed by inflateInit, but does not free and reallocate the internal decompression state. The stream will keep attributes that may have been set by inflateInit2.
 inflateReset returns Z\_OK if success, or Z\_STREAM\_ERROR if the source stream state was inconsistent (such as zalloc or state being Z\_NULL).\*/
ZEXTERN int ZEXPORT inflateReset2 OF((z\_streamp strm, int windowBits));/\* This function is the same as inflateReset, but it also permits changing the wrap and window size requests. The windowBits parameter is interpreted the same as it is for inflateInit2. If the window size is changed, then the memory allocated for the window is freed, and the window will be reallocated by inflate() if needed.
 inflateReset2 returns Z\_OK if success, or Z\_STREAM\_ERROR if the source stream state was inconsistent (such as zalloc or state being Z\_NULL), or if the windowBits parameter is invalid.\*/
ZEXTERN int ZEXPORT inflatePrime OF((z\_streamp strm, int bits, int value));/\* This function inserts bits in the inflate input stream. The intent is that this function is used to start inflating at a bit position in the middle of a byte. The provided bits will be used before any bytes are used from next\_in. This function should only be used with raw inflate, and should be used before the first inflate() call after inflateInit2() or inflateReset(). bits must be less than or equal to 16, and that many of the least significant bits of value will be inserted in the input.
 If bits is negative, then the input stream bit buffer is emptied. Then inflatePrime() can be called again to put bits in the buffer. This is used to clear out bits leftover after feeding inflate a block description prior to feeding inflate codes.
 inflatePrime returns Z\_OK if success, or Z\_STREAM\_ERROR if the source[View remainder of file in raw view](https://github.com/madler/zlib/raw/21767c654d31d2dccdde4330529775c6c5fd5389/zlib.h)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

