--- a/src/plugins/sqldrivers/odbc/qsql\_odbc.cpp
+++ b/src/plugins/sqldrivers/odbc/qsql\_odbc.cpp
@@ -92,23 +92,39 @@ inline static QString fromSQLTCHAR(const QVarLengthArray& input, int s
return result;
}
+template
+void toSQLTCHARImpl(QVarLengthArray &result, const QString &input); // primary template undefined
+
+template
+void do\_append(QVarLengthArray &result, const Container &c)
+{
+ result.append(reinterpret\_cast(c.data()), c.size());
+}
+
+template <>
+void toSQLTCHARImpl<1>(QVarLengthArray &result, const QString &input)
+{
+ const auto u8 = input.toUtf8();
+ do\_append(result, u8);
+}
+
+template <>
+void toSQLTCHARImpl<2>(QVarLengthArray &result, const QString &input)
+{
+ do\_append(result, input);
+}
+
+template <>
+void toSQLTCHARImpl<4>(QVarLengthArray &result, const QString &input)
+{
+ const auto u32 = input.toUcs4();
+ do\_append(result, u32);
+}
+
inline static QVarLengthArray toSQLTCHAR(const QString &input)
{
QVarLengthArray result;
- result.resize(input.size());
- switch(sizeof(SQLTCHAR)) {
- case 1:
- memcpy(result.data(), input.toUtf8().data(), input.size());
- break;
- case 2:
- memcpy(result.data(), input.unicode(), input.size() \* 2);
- break;
- case 4:
- memcpy(result.data(), input.toUcs4().data(), input.size() \* 4);
- break;
- default:
- qCritical("sizeof(SQLTCHAR) is %d. Don't know how to handle this.", int(sizeof(SQLTCHAR)));
- }
+ toSQLTCHARImpl(result, input);
result.append(0); // make sure it's null terminated, doesn't matter if it already is, it does if it isn't.
return result;
}
--- a/src/plugins/sqldrivers/odbc/qsql\_odbc.cpp
+++ b/src/plugins/sqldrivers/odbc/qsql\_odbc.cpp
@@ -1732,10 +1732,11 @@ bool QODBCResult::exec()
case QVariant::String:
if (d->unicode) {
if (bindValueType(i) & QSql::Out) {
- const QByteArray &first = tmpStorage.at(i);
- QVarLengthArray array;
- array.append((const SQLTCHAR \*)first.constData(), first.size());
- values[i] = fromSQLTCHAR(array, first.size()/sizeof(SQLTCHAR));
+ const QByteArray &bytes = tmpStorage.at(i);
+ const auto strSize = bytes.size() / int(sizeof(SQLTCHAR));
+ QVarLengthArray string(strSize);
+ memcpy(string.data(), bytes.data(), strSize \* sizeof(SQLTCHAR));
+ values[i] = fromSQLTCHAR(string);
}
break;
}
--- a/src/plugins/sqldrivers/odbc/qsql\_odbc.cpp
+++ b/src/plugins/sqldrivers/odbc/qsql\_odbc.cpp
@@ -779,6 +779,14 @@ QChar QODBCDriverPrivate::quoteChar()
return quote;
}
+static SQLRETURN qt\_string\_SQLSetConnectAttr(SQLHDBC handle, SQLINTEGER attr, const QString &val)
+{
+ auto encoded = toSQLTCHAR(val);
+ return SQLSetConnectAttr(handle, attr,
+ encoded.data(),
+ SQLINTEGER(encoded.size() \* sizeof(SQLTCHAR))); // size in bytes
+}
+
bool QODBCDriverPrivate::setConnectionOptions(const QString& connOpts)
{
@@ -814,10 +822,7 @@ bool QODBCDriverPrivate::setConnectionOptions(const QString& connOpts)
v = val.toUInt();
r = SQLSetConnectAttr(hDbc, SQL\_ATTR\_LOGIN\_TIMEOUT, (SQLPOINTER) size\_t(v), 0);
} else if (opt.toUpper() == QLatin1String("SQL\_ATTR\_CURRENT\_CATALOG")) {
- val.utf16(); // 0 terminate
- r = SQLSetConnectAttr(hDbc, SQL\_ATTR\_CURRENT\_CATALOG,
- toSQLTCHAR(val).data(),
- val.length()\*sizeof(SQLTCHAR));
+ r = qt\_string\_SQLSetConnectAttr(hDbc, SQL\_ATTR\_CURRENT\_CATALOG, val);
} else if (opt.toUpper() == QLatin1String("SQL\_ATTR\_METADATA\_ID")) {
if (val.toUpper() == QLatin1String("SQL\_TRUE")) {
v = SQL\_TRUE;
@@ -832,10 +837,7 @@ bool QODBCDriverPrivate::setConnectionOptions(const QString& connOpts)
v = val.toUInt();
r = SQLSetConnectAttr(hDbc, SQL\_ATTR\_PACKET\_SIZE, (SQLPOINTER) size\_t(v), 0);
} else if (opt.toUpper() == QLatin1String("SQL\_ATTR\_TRACEFILE")) {
- val.utf16(); // 0 terminate
- r = SQLSetConnectAttr(hDbc, SQL\_ATTR\_TRACEFILE,
- toSQLTCHAR(val).data(),
- val.length()\*sizeof(SQLTCHAR));
+ r = qt\_string\_SQLSetConnectAttr(hDbc, SQL\_ATTR\_TRACEFILE, val);
} else if (opt.toUpper() == QLatin1String("SQL\_ATTR\_TRACE")) {
if (val.toUpper() == QLatin1String("SQL\_OPT\_TRACE\_OFF")) {
v = SQL\_OPT\_TRACE\_OFF;
@@ -1038,9 +1040,12 @@ bool QODBCResult::reset (const QString& query)
return false;
}
- r = SQLExecDirect(d->hStmt,
- toSQLTCHAR(query).data(),
- (SQLINTEGER) query.length());
+ {
+ auto encoded = toSQLTCHAR(query);
+ r = SQLExecDirect(d->hStmt,
+ encoded.data(),
+ SQLINTEGER(encoded.size()));
+ }
if (r != SQL\_SUCCESS && r != SQL\_SUCCESS\_WITH\_INFO && r!= SQL\_NO\_DATA) {
setLastError(qMakeError(QCoreApplication::translate("QODBCResult",
"Unable to execute statement"), QSqlError::StatementError, d));
@@ -1387,9 +1392,12 @@ bool QODBCResult::prepare(const QString& query)
return false;
}
- r = SQLPrepare(d->hStmt,
- toSQLTCHAR(query).data(),
- (SQLINTEGER) query.length());
+ {
+ auto encoded = toSQLTCHAR(query);
+ r = SQLPrepare(d->hStmt,
+ encoded.data(),
+ SQLINTEGER(encoded.size()));
+ }
if (r != SQL\_SUCCESS) {
setLastError(qMakeError(QCoreApplication::translate("QODBCResult",
@@ -1417,7 +1425,7 @@ bool QODBCResult::exec()
SQLCloseCursor(d->hStmt);
QVector& values = boundValues();
- QVector tmpStorage(values.count(), QByteArray()); // holds temporary buffers
+ QVector tmpStorage(values.count(), QByteArray()); // targets for SQLBindParameter()
QVarLengthArray indicators(values.count());
memset(indicators.data(), 0, indicators.size() \* sizeof(SQLLEN));
@@ -1596,35 +1604,36 @@ bool QODBCResult::exec()
case QVariant::String:
if (d->unicode) {
QByteArray &ba = tmpStorage[i];
- QString str = val.toString();
+ {
+ const auto encoded = toSQLTCHAR(val.toString());
+ ba = QByteArray(reinterpret\_cast(encoded.data()),
+ encoded.size() \* sizeof(SQLTCHAR));
+ }
+
if (\*ind != SQL\_NULL\_DATA)
- \*ind = str.length() \* sizeof(SQLTCHAR);
- int strSize = str.length() \* sizeof(SQLTCHAR);
+ \*ind = ba.size();
if (bindValueType(i) & QSql::Out) {
- const QVarLengthArray a(toSQLTCHAR(str));
- ba = QByteArray((const char \*)a.constData(), a.size() \* sizeof(SQLTCHAR));
r = SQLBindParameter(d->hStmt,
i + 1,
qParamType[bindValueType(i) & QSql::InOut],
SQL\_C\_TCHAR,
- strSize > 254 ? SQL\_WLONGVARCHAR : SQL\_WVARCHAR,
+ ba.size() > 254 ? SQL\_WLONGVARCHAR : SQL\_WVARCHAR,
0, // god knows... don't change this!
0,
- ba.data(),
+ const\_cast(ba.constData()), // don't detach
ba.size(),
ind);
break;
}
- ba = QByteArray ((const char \*)toSQLTCHAR(str).constData(), str.size()\*sizeof(SQLTCHAR));
r = SQLBindParameter(d->hStmt,
i + 1,
qParamType[bindValueType(i) & QSql::InOut],
SQL\_C\_TCHAR,
- strSize > 254 ? SQL\_WLONGVARCHAR : SQL\_WVARCHAR,
- strSize,
+ ba.size() > 254 ? SQL\_WLONGVARCHAR : SQL\_WVARCHAR,
+ ba.size(),
0,
- const\_cast(ba.constData()),
+ const\_cast(ba.constData()), // don't detach
ba.size(),
ind);
break;
@@ -1982,14 +1991,16 @@ bool QODBCDriver::open(const QString & db,
SQLSMALLINT cb;
QVarLengthArray connOut(1024);
memset(connOut.data(), 0, connOut.size() \* sizeof(SQLTCHAR));
- r = SQLDriverConnect(d->hDbc,
- NULL,
- toSQLTCHAR(connQStr).data(),
- (SQLSMALLINT)connQStr.length(),
- connOut.data(),
- 1024,
- &cb,
- /\*SQL\_DRIVER\_NOPROMPT\*/0);
+ {
+ auto encoded = toSQLTCHAR(connQStr);
+ r = SQLDriverConnect(d->hDbc,
+ nullptr,
+ encoded.data(), SQLSMALLINT(encoded.size()),
+ connOut.data(),
+ 1024,
+ &cb,
+ /\*SQL\_DRIVER\_NOPROMPT\*/0);
+ }
if (r != SQL\_SUCCESS && r != SQL\_SUCCESS\_WITH\_INFO) {
setLastError(qMakeError(tr("Unable to connect"), QSqlError::ConnectionError, d));
@@ -2368,17 +2379,15 @@ QStringList QODBCDriver::tables(QSql::TableType type) const
if (tableType.isEmpty())
return tl;
- QString joinedTableTypeString = tableType.join(QLatin1Char(','));
+ {
+ auto joinedTableTypeString = toSQLTCHAR(tableType.join(u','));
- r = SQLTables(hStmt,
- NULL,
- 0,
- NULL,
- 0,
- NULL,
- 0,
- toSQLTCHAR(joinedTableTypeString).data(),
- joinedTableTypeString.length() /\* characters, not bytes \*/);
+ r = SQLTables(hStmt,
+ nullptr, 0,
+ nullptr, 0,
+ nullptr, 0,
+ joinedTableTypeString.data(), joinedTableTypeString.size());
+ }
if (r != SQL\_SUCCESS)
qSqlWarning(QLatin1String("QODBCDriver::tables Unable to execute table list"), d);
@@ -2452,28 +2461,30 @@ QSqlIndex QODBCDriver::primaryIndex(const QString& tablename) const
SQL\_ATTR\_CURSOR\_TYPE,
(SQLPOINTER)SQL\_CURSOR\_FORWARD\_ONLY,
SQL\_IS\_UINTEGER);
- r = SQLPrimaryKeys(hStmt,
- catalog.length() == 0 ? NULL : toSQLTCHAR(catalog).data(),
- catalog.length(),
- schema.length() == 0 ? NULL : toSQLTCHAR(schema).data(),
- schema.length(),
- toSQLTCHAR(table).data(),
- table.length() /\* in characters, not in bytes \*/);
+ {
+ auto c = toSQLTCHAR(catalog);
+ auto s = toSQLTCHAR(schema);
+ auto t = toSQLTCHAR(table);
+ r = SQLPrimaryKeys(hStmt,
+ catalog.isEmpty() ? nullptr : c.data(), c.size(),
+ schema.isEmpty() ? nullptr : s.data(), s.size(),
+ t.data(), t.size());
+ }
// if the SQLPrimaryKeys() call does not succeed (e.g the driver
// does not support it) - try an alternative method to get hold of
// the primary index (e.g MS Access and FoxPro)
if (r != SQL\_SUCCESS) {
- r = SQLSpecialColumns(hStmt,
- SQL\_BEST\_ROWID,
- catalog.length() == 0 ? NULL : toSQLTCHAR(catalog).data(),
- catalog.length(),
- schema.length() == 0 ? NULL : toSQLTCHAR(schema).data(),
- schema.length(),
- toSQLTCHAR(table).data(),
- table.length(),
- SQL\_SCOPE\_CURROW,
- SQL\_NULLABLE);
+ auto c = toSQLTCHAR(catalog);
+ auto s = toSQLTCHAR(schema);
+ auto t = toSQLTCHAR(table);
+ r = SQLSpecialColumns(hStmt,
+ SQL\_BEST\_ROWID,
+ catalog.isEmpty() ? nullptr : c.data(), c.size(),
+ schema.isEmpty() ? nullptr : s.data(), s.size(),
+ t.data(), t.size(),
+ SQL\_SCOPE\_CURROW,
+ SQL\_NULLABLE);
if (r != SQL\_SUCCESS) {
qSqlWarning(QLatin1String("QODBCDriver::primaryIndex: Unable to execute primary key list"), d);
@@ -2554,15 +2565,17 @@ QSqlRecord QODBCDriver::record(const QString& tablename) const
SQL\_ATTR\_CURSOR\_TYPE,
(SQLPOINTER)SQL\_CURSOR\_FORWARD\_ONLY,
SQL\_IS\_UINTEGER);
- r = SQLColumns(hStmt,
- catalog.length() == 0 ? NULL : toSQLTCHAR(catalog).data(),
- catalog.length(),
- schema.length() == 0 ? NULL : toSQLTCHAR(schema).data(),
- schema.length(),
- toSQLTCHAR(table).data(),
- table.length(),
- NULL,
- 0);
+ {
+ auto c = toSQLTCHAR(catalog);
+ auto s = toSQLTCHAR(schema);
+ auto t = toSQLTCHAR(table);
+ r = SQLColumns(hStmt,
+ catalog.isEmpty() ? nullptr : c.data(), c.size(),
+ schema.isEmpty() ? nullptr : s.data(), s.size(),
+ t.data(), t.size(),
+ nullptr,
+ 0);
+ }
if (r != SQL\_SUCCESS)
qSqlWarning(QLatin1String("QODBCDriver::record: Unable to execute column list"), d);
