
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Flibp2p%2Frust-yamux%2Fblob%2Fyamux-v0.13.1%2Fyamux%2Fsrc%2Fconnection.rs)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Flibp2p%2Frust-yamux%2Fblob%2Fyamux-v0.13.1%2Fyamux%2Fsrc%2Fconnection.rs)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=libp2p%2Frust-yamux)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[libp2p](/libp2p)
/
**[rust-yamux](/libp2p/rust-yamux)**
Public

* [Notifications](/login?return_to=%2Flibp2p%2Frust-yamux) You must be signed in to change notification settings
* [Fork
  43](/login?return_to=%2Flibp2p%2Frust-yamux)
* [Star
   188](/login?return_to=%2Flibp2p%2Frust-yamux)

* [Code](/libp2p/rust-yamux/tree/yamux-v0.13.1)
* [Issues
  10](/libp2p/rust-yamux/issues)
* [Pull requests
  2](/libp2p/rust-yamux/pulls)
* [Actions](/libp2p/rust-yamux/actions)
* [Projects
  0](/libp2p/rust-yamux/projects)
* [Security](/libp2p/rust-yamux/security)
* [Insights](/libp2p/rust-yamux/pulse)

Additional navigation options

* [Code](/libp2p/rust-yamux/tree/yamux-v0.13.1)
* [Issues](/libp2p/rust-yamux/issues)
* [Pull requests](/libp2p/rust-yamux/pulls)
* [Actions](/libp2p/rust-yamux/actions)
* [Projects](/libp2p/rust-yamux/projects)
* [Security](/libp2p/rust-yamux/security)
* [Insights](/libp2p/rust-yamux/pulse)

## Files

 yamux-v0.13.1
## Breadcrumbs

1. [rust-yamux](/libp2p/rust-yamux/tree/yamux-v0.13.1)
2. /[yamux](/libp2p/rust-yamux/tree/yamux-v0.13.1/yamux)
3. /[src](/libp2p/rust-yamux/tree/yamux-v0.13.1/yamux/src)
/
# connection.rs

Copy path Blame  Blame
## Latest commit

## History

[History](/libp2p/rust-yamux/commits/yamux-v0.13.1/yamux/src/connection.rs)872 lines (797 loc) · 32.5 KB yamux-v0.13.1
## Breadcrumbs

1. [rust-yamux](/libp2p/rust-yamux/tree/yamux-v0.13.1)
2. /[yamux](/libp2p/rust-yamux/tree/yamux-v0.13.1/yamux)
3. /[src](/libp2p/rust-yamux/tree/yamux-v0.13.1/yamux/src)
/
# connection.rs

Top
## File metadata and controls

* Code
* Blame

872 lines (797 loc) · 32.5 KB[Raw](https://github.com/libp2p/rust-yamux/raw/refs/tags/yamux-v0.13.1/yamux/src/connection.rs)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872// Copyright (c) 2018-2019 Parity Technologies (UK) Ltd.//// Licensed under the Apache License, Version 2.0 or MIT license, at your option.//// A copy of the Apache License, Version 2.0 is included in the software as// LICENSE-APACHE and a copy of the MIT license is included in the software// as LICENSE-MIT. You may also obtain a copy of the Apache License, Version 2.0// at https://www.apache.org/licenses/LICENSE-2.0 and a copy of the MIT license// at https://opensource.org/licenses/MIT.
//! This module contains the `Connection` type and associated helpers.//! A `Connection` wraps an underlying (async) I/O resource and multiplexes//! `Stream`s over it.
mod cleanup;mod closing;mod rtt;mod stream;
use crate::tagged\_stream::TaggedStream;use crate::{ error::ConnectionError, frame::header::{self, Data, GoAway, Header, Ping, StreamId, Tag, WindowUpdate, CONNECTION\_ID}, frame::{self, Frame}, Config, DEFAULT\_CREDIT,};use crate::{Result, MAX\_ACK\_BACKLOG};use cleanup::Cleanup;use closing::Closing;use futures::stream::SelectAll;use futures::{channel::mpsc, future::Either, prelude::\*, sink::SinkExt, stream::Fuse};use nohash\_hasher::IntMap;use parking\_lot::Mutex;use std::collections::VecDeque;use std::task::{Context, Waker};use std::{fmt, sync::Arc, task::Poll};
pub use stream::{Packet, State, Stream};
/// How the connection is used.#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]pub enum Mode { /// Client to server connection. Client, /// Server to client connection. Server,}
/// The connection identifier.////// Randomly generated, this is mainly intended to improve log output.#[derive(Clone, Copy)]pub(crate) struct Id(u32);
impl Id { /// Create a random connection ID. pub(crate) fn random() -> Self { Id(rand::random()) }}
impl fmt::Debug for Id { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { write!(f, "{:08x}", self.0) }}
impl fmt::Display for Id { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { write!(f, "{:08x}", self.0) }}
/// A Yamux connection object.////// Wraps the underlying I/O resource and makes progress via its/// [`Connection::poll\_next\_inbound`] method which must be called repeatedly/// until `Ok(None)` signals EOF or an error is encountered.#[derive(Debug)]pub struct Connection<T> { inner: ConnectionState<T>,}
impl<T: AsyncRead + AsyncWrite + Unpin> Connection<T> { pub fn new(socket: T, cfg: Config, mode: Mode) -> Self { Self { inner: ConnectionState::Active(Active::new(socket, cfg, mode)), } }
 /// Poll for a new outbound stream. /// /// This function will fail if the current state does not allow opening new outbound streams. pub fn poll\_new\_outbound(&mut self, cx: &mut Context<'\_>) -> Poll<Result<Stream>> { loop { match std::mem::replace(&mut self.inner, ConnectionState::Poisoned) { ConnectionState::Active(mut active) => match active.poll\_new\_outbound(cx) { Poll::Ready(Ok(stream)) => { self.inner = ConnectionState::Active(active); return Poll::Ready(Ok(stream)); } Poll::Pending => { self.inner = ConnectionState::Active(active); return Poll::Pending; } Poll::Ready(Err(e)) => { self.inner = ConnectionState::Cleanup(active.cleanup(e)); continue; } }, ConnectionState::Closing(mut inner) => match inner.poll\_unpin(cx) { Poll::Ready(Ok(())) => { self.inner = ConnectionState::Closed; return Poll::Ready(Err(ConnectionError::Closed)); } Poll::Ready(Err(e)) => { self.inner = ConnectionState::Closed; return Poll::Ready(Err(e)); } Poll::Pending => { self.inner = ConnectionState::Closing(inner); return Poll::Pending; } }, ConnectionState::Cleanup(mut inner) => match inner.poll\_unpin(cx) { Poll::Ready(e) => { self.inner = ConnectionState::Closed; return Poll::Ready(Err(e)); } Poll::Pending => { self.inner = ConnectionState::Cleanup(inner); return Poll::Pending; } }, ConnectionState::Closed => { self.inner = ConnectionState::Closed; return Poll::Ready(Err(ConnectionError::Closed)); } ConnectionState::Poisoned => unreachable!(), } } }
 /// Poll for the next inbound stream. /// /// If this function returns `None`, the underlying connection is closed. pub fn poll\_next\_inbound(&mut self, cx: &mut Context<'\_>) -> Poll<Option<Result<Stream>>> { loop { match std::mem::replace(&mut self.inner, ConnectionState::Poisoned) { ConnectionState::Active(mut active) => match active.poll(cx) { Poll::Ready(Ok(stream)) => { self.inner = ConnectionState::Active(active); return Poll::Ready(Some(Ok(stream))); } Poll::Ready(Err(e)) => { self.inner = ConnectionState::Cleanup(active.cleanup(e)); continue; } Poll::Pending => { self.inner = ConnectionState::Active(active); return Poll::Pending; } }, ConnectionState::Closing(mut closing) => match closing.poll\_unpin(cx) { Poll::Ready(Ok(())) => { self.inner = ConnectionState::Closed; return Poll::Ready(None); } Poll::Ready(Err(e)) => { self.inner = ConnectionState::Closed; return Poll::Ready(Some(Err(e))); } Poll::Pending => { self.inner = ConnectionState::Closing(closing); return Poll::Pending; } }, ConnectionState::Cleanup(mut cleanup) => match cleanup.poll\_unpin(cx) { Poll::Ready(ConnectionError::Closed) => { self.inner = ConnectionState::Closed; return Poll::Ready(None); } Poll::Ready(other) => { self.inner = ConnectionState::Closed; return Poll::Ready(Some(Err(other))); } Poll::Pending => { self.inner = ConnectionState::Cleanup(cleanup); return Poll::Pending; } }, ConnectionState::Closed => { self.inner = ConnectionState::Closed; return Poll::Ready(None); } ConnectionState::Poisoned => unreachable!(), } } }
 /// Close the connection. pub fn poll\_close(&mut self, cx: &mut Context<'\_>) -> Poll<Result<()>> { loop { match std::mem::replace(&mut self.inner, ConnectionState::Poisoned) { ConnectionState::Active(active) => { self.inner = ConnectionState::Closing(active.close()); } ConnectionState::Closing(mut inner) => match inner.poll\_unpin(cx)? { Poll::Ready(()) => { self.inner = ConnectionState::Closed; } Poll::Pending => { self.inner = ConnectionState::Closing(inner); return Poll::Pending; } }, ConnectionState::Cleanup(mut cleanup) => match cleanup.poll\_unpin(cx) { Poll::Ready(reason) => { log::warn!("Failure while closing connection: {}", reason); self.inner = ConnectionState::Closed; return Poll::Ready(Ok(())); } Poll::Pending => { self.inner = ConnectionState::Cleanup(cleanup); return Poll::Pending; } }, ConnectionState::Closed => { self.inner = ConnectionState::Closed; return Poll::Ready(Ok(())); } ConnectionState::Poisoned => { unreachable!() } } } }}
impl<T> Drop for Connection<T> { fn drop(&mut self) { match &mut self.inner { ConnectionState::Active(active) => active.drop\_all\_streams(), ConnectionState::Closing(\_) => {} ConnectionState::Cleanup(\_) => {} ConnectionState::Closed => {} ConnectionState::Poisoned => {} } }}
enum ConnectionState<T> { /// The connection is alive and healthy. Active(Active<T>), /// Our user requested to shutdown the connection, we are working on it. Closing(Closing<T>), /// An error occurred and we are cleaning up our resources. Cleanup(Cleanup), /// The connection is closed. Closed, /// Something went wrong during our state transitions. Should never happen unless there is a bug. Poisoned,}
impl<T> fmt::Debug for ConnectionState<T> { fn fmt(&self, f: &mut fmt::Formatter<'\_>) -> fmt::Result { match self { ConnectionState::Active(\_) => write!(f, "Active"), ConnectionState::Closing(\_) => write!(f, "Closing"), ConnectionState::Cleanup(\_) => write!(f, "Cleanup"), ConnectionState::Closed => write!(f, "Closed"), ConnectionState::Poisoned => write!(f, "Poisoned"), } }}
/// The active state of [`Connection`].struct Active<T> { id: Id, mode: Mode, config: Arc<Config>, socket: Fuse<frame::Io<T>>, next\_id: u32,
 streams: IntMap<StreamId, Arc<Mutex<stream::Shared>>>, stream\_receivers: SelectAll<TaggedStream<StreamId, mpsc::Receiver<StreamCommand>>>, no\_streams\_waker: Option<Waker>,
 pending\_frames: VecDeque<Frame<()>>, new\_outbound\_stream\_waker: Option<Waker>,
 rtt: rtt::Rtt,
 /// A stream's `max\_stream\_receive\_window` can grow beyond [`DEFAULT\_CREDIT`], see /// [`Stream::next\_window\_update`]. This field is the sum of the bytes by which all streams' /// `max\_stream\_receive\_window` have each exceeded [`DEFAULT\_CREDIT`]. Used to enforce /// [`Config::max\_connection\_receive\_window`]. accumulated\_max\_stream\_windows: Arc<Mutex<usize>>,}/// `Stream` to `Connection` commands.#[derive(Debug)]pub(crate) enum StreamCommand { /// A new frame should be sent to the remote. SendFrame(Frame<Either<Data, WindowUpdate>>), /// Close a stream. CloseStream { ack: bool },}
/// Possible actions as a result of incoming frame handling.#[derive(Debug)]pub(crate) enum Action { /// Nothing to be done. None, /// A new stream has been opened by the remote. New(Stream), /// A ping should be answered. Ping(Frame<Ping>), /// The connection should be terminated. Terminate(Frame<GoAway>),}
impl<T> fmt::Debug for Active<T> { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { f.debug\_struct("Connection") .field("id", &self.id) .field("mode", &self.mode) .field("streams", &self.streams.len()) .field("next\_id", &self.next\_id) .finish() }}
impl<T> fmt::Display for Active<T> { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { write!( f, "(Connection {} {:?} (streams {}))", self.id, self.mode, self.streams.len() ) }}
impl<T: AsyncRead + AsyncWrite + Unpin> Active<T> { /// Create a new `Connection` from the given I/O resource. fn new(socket: T, cfg: Config, mode: Mode) -> Self { let id = Id::random(); log::debug!("new connection: {} ({:?})", id, mode); let socket = frame::Io::new(id, socket).fuse(); Active { id, mode, config: Arc::new(cfg), socket, streams: IntMap::default(), stream\_receivers: SelectAll::default(), no\_streams\_waker: None, next\_id: match mode { Mode::Client => 1, Mode::Server => 2, }, pending\_frames: VecDeque::default(), new\_outbound\_stream\_waker: None, rtt: rtt::Rtt::new(), accumulated\_max\_stream\_windows: Default::default(), } }
 /// Gracefully close the connection to the remote. fn close(self) -> Closing<T> { Closing::new(self.stream\_receivers, self.pending\_frames, self.socket) }
 /// Cleanup all our resources. /// /// This should be called in the context of an unrecoverable error on the connection. fn cleanup(mut self, error: ConnectionError) -> Cleanup { self.drop\_all\_streams();
 Cleanup::new(self.stream\_receivers, error) }
 fn poll(&mut self, cx: &mut Context<'\_>) -> Poll<Result<Stream>> { loop { if self.socket.poll\_ready\_unpin(cx).is\_ready() { // Note `next\_ping` does not register a waker and thus if not called regularly (idle // connection) no ping is sent. This is deliberate as an idle connection does not // need RTT measurements to increase its stream receive window. if let Some(frame) = self.rtt.next\_ping() { self.socket.start\_send\_unpin(frame.into())?; continue; }
 if let Some(frame) = self.pending\_frames.pop\_front() { self.socket.start\_send\_unpin(frame)?; continue; } }
 match self.socket.poll\_flush\_unpin(cx)? { Poll::Ready(()) => {} Poll::Pending => {} }
 match self.stream\_receivers.poll\_next\_unpin(cx) { Poll::Ready(Some((\_, Some(StreamCommand::SendFrame(frame))))) => { self.on\_send\_frame(frame); continue; } Poll::Ready(Some((id, Some(StreamCommand::CloseStream { ack })))) => { self.on\_close\_stream(id, ack); continue; } Poll::Ready(Some((id, None))) => { self.on\_drop\_stream(id); continue; } Poll::Ready(None) => { self.no\_streams\_waker = Some(cx.waker().clone()); } Poll::Pending => {} }
 match self.socket.poll\_next\_unpin(cx) { Poll::Ready(Some(frame)) => { if let Some(stream) = self.on\_frame(frame?)? { return Poll::Ready(Ok(stream)); } continue; } Poll::Ready(None) => { return Poll::Ready(Err(ConnectionError::Closed)); } Poll::Pending => {} }
 // If we make it this far, at least one of the above must have registered a waker. return Poll::Pending; } }
 fn poll\_new\_outbound(&mut self, cx: &mut Context<'\_>) -> Poll<Result<Stream>> { if self.streams.len() >= self.config.max\_num\_streams { log::error!("{}: maximum number of streams reached", self.id); return Poll::Ready(Err(ConnectionError::TooManyStreams)); }
 if self.ack\_backlog() >= MAX\_ACK\_BACKLOG { log::debug!("{MAX\_ACK\_BACKLOG} streams waiting for ACK, registering task for wake-up until remote acknowledges at least one stream"); self.new\_outbound\_stream\_waker = Some(cx.waker().clone()); return Poll::Pending; }
 log::trace!("{}: creating new outbound stream", self.id);
 let id = self.next\_stream\_id()?; let stream = self.make\_new\_outbound\_stream(id);
 log::debug!("{}: new outbound {} of {}", self.id, stream, self); self.streams.insert(id, stream.clone\_shared());
 Poll::Ready(Ok(stream)) }
 fn on\_send\_frame(&mut self, frame: Frame<Either<Data, WindowUpdate>>) { log::trace!( "{}/{}: sending: {}", self.id, frame.header().stream\_id(), frame.header() ); self.pending\_frames.push\_back(frame.into()); }
 fn on\_close\_stream(&mut self, id: StreamId, ack: bool) { log::trace!("{}/{}: sending close", self.id, id); self.pending\_frames .push\_back(Frame::close\_stream(id, ack).into()); }
 fn on\_drop\_stream(&mut self, stream\_id: StreamId) { let s = self.streams.remove(&stream\_id).expect("stream not found");
 log::trace!("{}: removing dropped stream {}", self.id, stream\_id); let frame = { let mut shared = s.lock(); let frame = match shared.update\_state(self.id, stream\_id, State::Closed) { // The stream was dropped without calling `poll\_close`. // We reset the stream to inform the remote of the closure. State::Open { .. } => { let mut header = Header::data(stream\_id, 0); header.rst(); Some(Frame::new(header)) } // The stream was dropped without calling `poll\_close`. // We have already received a FIN from remote and send one // back which closes the stream for good. State::RecvClosed => { let mut header = Header::data(stream\_id, 0); header.fin(); Some(Frame::new(header)) } // The stream was properly closed. We already sent our FIN frame. // The remote may be out of credit though and blocked on // writing more data. We may need to reset the stream. State::SendClosed => { // The remote has either still credit or will be given more // due to an enqueued window update or we already have // inbound frames in the socket buffer which will be // processed later. In any case we will reply with an RST in // `Connection::on\_data` because the stream will no longer // be known. None } // The stream was properly closed. We already have sent our FIN frame. The // remote end has already done so in the past. State::Closed => None, }; if let Some(w) = shared.reader.take() { w.wake() } if let Some(w) = shared.writer.take() { w.wake() } frame }; if let Some(f) = frame { log::trace!("{}/{}: sending: {}", self.id, stream\_id, f.header()); self.pending\_frames.push\_back(f.into()); } }
 /// Process the result of reading from the socket. /// /// Unless `frame` is `Ok(Some(\_))` we will assume the connection got closed /// and return a corresponding error, which terminates the connection. /// Otherwise we process the frame and potentially return a new `Stream` /// if one was opened by the remote. fn on\_frame(&mut self, frame: Frame<()>) -> Result<Option<Stream>> { log::trace!("{}: received: {}", self.id, frame.header());
 if frame.header().flags().contains(header::ACK) && matches!(frame.header().tag(), Tag::Data | Tag::WindowUpdate) { let id = frame.header().stream\_id(); if let Some(stream) = self.streams.get(&id) { stream .lock() .update\_state(self.id, id, State::Open { acknowledged: true }); } if let Some(waker) = self.new\_outbound\_stream\_waker.take() { waker.wake(); } }
 let action = match frame.header().tag() { Tag::Data => self.on\_data(frame.into\_data()), Tag::WindowUpdate => self.on\_window\_update(&frame.into\_window\_update()), Tag::Ping => self.on\_ping(&frame.into\_ping()), Tag::GoAway => return Err(ConnectionError::Closed), }; match action { Action::None => {} Action::New(stream) => { log::trace!("{}: new inbound {} of {}", self.id, stream, self); return Ok(Some(stream)); } Action::Ping(f) => { log::trace!("{}/{}: pong", self.id, f.header().stream\_id()); self.pending\_frames.push\_back(f.into()); } Action::Terminate(f) => { log::trace!("{}: sending term", self.id); self.pending\_frames.push\_back(f.into()); } }
 Ok(None) }
 fn on\_data(&mut self, frame: Frame<Data>) -> Action { let stream\_id = frame.header().stream\_id();
 if frame.header().flags().contains(header::RST) { // stream reset if let Some(s) = self.streams.get\_mut(&stream\_id) { let mut shared = s.lock(); shared.update\_state(self.id, stream\_id, State::Closed); if let Some(w) = shared.reader.take() { w.wake() } if let Some(w) = shared.writer.take() { w.wake() } } return Action::None; }
 let is\_finish = frame.header().flags().contains(header::FIN); // half-close
 if frame.header().flags().contains(header::SYN) { // new stream if !self.is\_valid\_remote\_id(stream\_id, Tag::Data) { log::error!("{}: invalid stream id {}", self.id, stream\_id); return Action::Terminate(Frame::protocol\_error()); } if frame.body().len() > DEFAULT\_CREDIT as usize { log::error!( "{}/{}: 1st body of stream exceeds default credit", self.id, stream\_id ); return Action::Terminate(Frame::protocol\_error()); } if self.streams.contains\_key(&stream\_id) { log::error!("{}/{}: stream already exists", self.id, stream\_id); return Action::Terminate(Frame::protocol\_error()); } if self.streams.len() == self.config.max\_num\_streams { log::error!("{}: maximum number of streams reached", self.id); return Action::Terminate(Frame::internal\_error()); } let stream = self.make\_new\_inbound\_stream(stream\_id, DEFAULT\_CREDIT); { let mut shared = stream.shared(); if is\_finish { shared.update\_state(self.id, stream\_id, State::RecvClosed); } shared.consume\_receive\_window(frame.body\_len()); shared.buffer.push(frame.into\_body()); } self.streams.insert(stream\_id, stream.clone\_shared()); return Action::New(stream); }
 if let Some(s) = self.streams.get\_mut(&stream\_id) { let mut shared = s.lock(); if frame.body\_len() > shared.receive\_window() { log::error!( "{}/{}: frame body larger than window of stream", self.id, stream\_id ); return Action::Terminate(Frame::protocol\_error()); } if is\_finish { shared.update\_state(self.id, stream\_id, State::RecvClosed); } shared.consume\_receive\_window(frame.body\_len()); shared.buffer.push(frame.into\_body()); if let Some(w) = shared.reader.take() { w.wake() } } else { log::trace!( "{}/{}: data frame for unknown stream, possibly dropped earlier: {:?}", self.id, stream\_id, frame ); // We do not consider this a protocol violation and thus do not send a stream reset // because we may still be processing pending `StreamCommand`s of this stream that were // sent before it has been dropped and "garbage collected". Such a stream reset would // interfere with the frames that still need to be sent, causing premature stream // termination for the remote. // // See https://github.com/paritytech/yamux/issues/110 for details. }
 Action::None }
 fn on\_window\_update(&mut self, frame: &Frame<WindowUpdate>) -> Action { let stream\_id = frame.header().stream\_id();
 if frame.header().flags().contains(header::RST) { // stream reset if let Some(s) = self.streams.get\_mut(&stream\_id) { let mut shared = s.lock(); shared.update\_state(self.id, stream\_id, State::Closed); if let Some(w) = shared.reader.take() { w.wake() } if let Some(w) = shared.writer.take() { w.wake() } } return Action::None; }
 let is\_finish = frame.header().flags().contains(header::FIN); // half-close
 if frame.header().flags().contains(header::SYN) { // new stream if !self.is\_valid\_remote\_id(stream\_id, Tag::WindowUpdate) { log::error!("{}: invalid stream id {}", self.id, stream\_id); return Action::Terminate(Frame::protocol\_error()); } if self.streams.contains\_key(&stream\_id) { log::error!("{}/{}: stream already exists", self.id, stream\_id); return Action::Terminate(Frame::protocol\_error()); } if self.streams.len() == self.config.max\_num\_streams { log::error!("{}: maximum number of streams reached", self.id); return Action::Terminate(Frame::protocol\_error()); }
 let credit = frame.header().credit() + DEFAULT\_CREDIT; let stream = self.make\_new\_inbound\_stream(stream\_id, credit);
 if is\_finish { stream .shared() .update\_state(self.id, stream\_id, State::RecvClosed); } self.streams.insert(stream\_id, stream.clone\_shared()); return Action::New(stream); }
 if let Some(s) = self.streams.get\_mut(&stream\_id) { let mut shared = s.lock(); shared.increase\_send\_window\_by(frame.header().credit()); if is\_finish { shared.update\_state(self.id, stream\_id, State::RecvClosed); } if let Some(w) = shared.writer.take() { w.wake() } } else { log::trace!( "{}/{}: window update for unknown stream, possibly dropped earlier: {:?}", self.id, stream\_id, frame ); // We do not consider this a protocol violation and thus do not send a stream reset // because we may still be processing pending `StreamCommand`s of this stream that were // sent before it has been dropped and "garbage collected". Such a stream reset would // interfere with the frames that still need to be sent, causing premature stream // termination for the remote. // // See https://github.com/paritytech/yamux/issues/110 for details. }
 Action::None }
 fn on\_ping(&mut self, frame: &Frame<Ping>) -> Action { let stream\_id = frame.header().stream\_id(); if frame.header().flags().contains(header::ACK) { return self.rtt.handle\_pong(frame.nonce()); } if stream\_id == CONNECTION\_ID || self.streams.contains\_key(&stream\_id) { let mut hdr = Header::ping(frame.header().nonce()); hdr.ack(); return Action::Ping(Frame::new(hdr)); } log::debug!( "{}/{}: ping for unknown stream, possibly dropped earlier: {:?}", self.id, stream\_id, frame ); // We do not consider this a protocol violation and thus do not send a stream reset because // we may still be processing pending `StreamCommand`s of this stream that were sent before // it has been dropped and "garbage collected". Such a stream reset would interfere with the // frames that still need to be sent, causing premature stream termination for the remote. // // See https://github.com/paritytech/yamux/issues/110 for details.
 Action::None }
 fn make\_new\_inbound\_stream(&mut self, id: StreamId, credit: u32) -> Stream { let config = self.config.clone();
 let (sender, receiver) = mpsc::channel(10); // 10 is an arbitrary number. self.stream\_receivers.push(TaggedStream::new(id, receiver)); if let Some(waker) = self.no\_streams\_waker.take() { waker.wake(); }
 Stream::new\_inbound( id, self.id, config, credit, sender, self.rtt.clone(), self.accumulated\_max\_stream\_windows.clone(), ) }
 fn make\_new\_outbound\_stream(&mut self, id: StreamId) -> Stream { let config = self.config.clone();
 let (sender, receiver) = mpsc::channel(10); // 10 is an arbitrary number. self.stream\_receivers.push(TaggedStream::new(id, receiver)); if let Some(waker) = self.no\_streams\_waker.take() { waker.wake(); }
 Stream::new\_outbound( id, self.id, config, sender, self.rtt.clone(), self.accumulated\_max\_stream\_windows.clone(), ) }
 fn next\_stream\_id(&mut self) -> Result<StreamId> { let proposed = StreamId::new(self.next\_id); self.next\_id = self .next\_id .checked\_add(2) .ok\_or(ConnectionError::NoMoreStreamIds)?; match self.mode { Mode::Client => assert!(proposed.is\_client()), Mode::Server => assert!(proposed.is\_server()), } Ok(proposed) }
 /// The ACK backlog is defined as the number of outbound streams that have not yet been acknowledged. fn ack\_backlog(&mut self) -> usize { self.streams .iter() // Whether this is an outbound stream. // // Clients use odd IDs and servers use even IDs. // A stream is outbound if: // // - Its ID is odd and we are the client. // - Its ID is even and we are the server. .filter(|(id, \_)| match self.mode { Mode::Client => id.is\_client(), Mode::Server => id.is\_server(), }) .filter(|(\_, s)| s.lock().is\_pending\_ack()) .count() }
 // Check if the given stream ID is valid w.r.t. the provided tag and our connection mode. fn is\_valid\_remote\_id(&self, id: StreamId, tag: Tag) -> bool { if tag == Tag::Ping || tag == Tag::GoAway { return id.is\_session(); } match self.mode { Mode::Client => id.is\_server(), Mode::Server => id.is\_client(), } }}
impl<T> Active<T> { /// Close and drop all `Stream`s and wake any pending `Waker`s. fn drop\_all\_streams(&mut self) { for (id, s) in self.streams.drain() { let mut shared = s.lock(); shared.update\_state(self.id, id, State::Closed); if let Some(w) = shared.reader.take() { w.wake() } if let Some(w) = shared.writer.take() { w.wake() } } }}

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

