

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=105155a8146ddb54c119d8318964eef3859d109d)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=105155a8146ddb54c119d8318964eef3859d109d)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=105155a8146ddb54c119d8318964eef3859d109d)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=105155a8146ddb54c119d8318964eef3859d109d)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Chao Yu <yuchao0@huawei.com> | 2021-03-24 11:18:28 +0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2021-05-19 10:13:02 +0200 |
| commit | [105155a8146ddb54c119d8318964eef3859d109d](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=105155a8146ddb54c119d8318964eef3859d109d) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=105155a8146ddb54c119d8318964eef3859d109d)) | |
| tree | [8710c28e31066bf4543a9439491b3a44f7d398b4](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=105155a8146ddb54c119d8318964eef3859d109d) | |
| parent | [bbed83d7060e07a5d309104d25a00f0a24441428](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=bbed83d7060e07a5d309104d25a00f0a24441428) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=105155a8146ddb54c119d8318964eef3859d109d&id2=bbed83d7060e07a5d309104d25a00f0a24441428)) | |
| download | [linux-105155a8146ddb54c119d8318964eef3859d109d.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-105155a8146ddb54c119d8318964eef3859d109d.tar.gz) | |

f2fs: fix to avoid touching checkpointed data in get\_victim()[ Upstream commit 61461fc921b756ae16e64243f72af2bfc2e620db ]
In CP disabling mode, there are two issues when using LFS or SSR | AT\_SSR
mode to select victim:
1. LFS is set to find source section during GC, the victim should have
no checkpointed data, since after GC, section could not be set free for
reuse.
Previously, we only check valid chpt blocks in current segment rather
than section, fix it.
2. SSR | AT\_SSR are set to find target segment for writes which can be
fully filled by checkpointed and newly written blocks, we should never
select such segment, otherwise it can cause panic or data corruption
during allocation, potential case is described as below:
a) target segment has 'n' (n < 512) ckpt valid blocks
b) GC migrates 'n' valid blocks to other segment (segment is still
in dirty list)
c) GC migrates '512 - n' blocks to target segment (segment has 'n'
cp\_vblocks and '512 - n' vblocks)
d) If GC selects target segment via {AT,}SSR allocator, however there
is no free space in targe segment.
Fixes: 4354994f097d ("f2fs: checkpoint disabling")
Fixes: 093749e296e2 ("f2fs: support age threshold based garbage collection")
Signed-off-by: Chao Yu <yuchao0@huawei.com>
Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=105155a8146ddb54c119d8318964eef3859d109d)

| -rw-r--r-- | [fs/f2fs/f2fs.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/f2fs/f2fs.h?id=105155a8146ddb54c119d8318964eef3859d109d) | 1 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/f2fs/gc.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/f2fs/gc.c?id=105155a8146ddb54c119d8318964eef3859d109d) | 28 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/f2fs/segment.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/f2fs/segment.c?id=105155a8146ddb54c119d8318964eef3859d109d) | 36 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/f2fs/segment.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/f2fs/segment.h?id=105155a8146ddb54c119d8318964eef3859d109d) | 14 | |  |  |  | | --- | --- | --- | |

4 files changed, 55 insertions, 24 deletions

| diff --git a/fs/f2fs/f2fs.h b/fs/f2fs/f2fs.hindex c2973a1dead685..036d2a3a2f4148 100644--- a/[fs/f2fs/f2fs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/f2fs.h?id=bbed83d7060e07a5d309104d25a00f0a24441428)+++ b/[fs/f2fs/f2fs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/f2fs.h?id=105155a8146ddb54c119d8318964eef3859d109d)@@ -3282,6 +3282,7 @@ block\_t f2fs\_get\_unusable\_blocks(struct f2fs\_sb\_info \*sbi); int f2fs\_disable\_cp\_again(struct f2fs\_sb\_info \*sbi, block\_t unusable); void f2fs\_release\_discard\_addrs(struct f2fs\_sb\_info \*sbi); int f2fs\_npages\_for\_summary\_flush(struct f2fs\_sb\_info \*sbi, bool for\_ra);+bool f2fs\_segment\_has\_free\_slot(struct f2fs\_sb\_info \*sbi, int segno); void f2fs\_init\_inmem\_curseg(struct f2fs\_sb\_info \*sbi); void f2fs\_save\_inmem\_curseg(struct f2fs\_sb\_info \*sbi); void f2fs\_restore\_inmem\_curseg(struct f2fs\_sb\_info \*sbi);diff --git a/fs/f2fs/gc.c b/fs/f2fs/gc.cindex e4e8c725745496..9b38cef4d50fe4 100644--- a/[fs/f2fs/gc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/gc.c?id=bbed83d7060e07a5d309104d25a00f0a24441428)+++ b/[fs/f2fs/gc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/gc.c?id=105155a8146ddb54c119d8318964eef3859d109d)@@ -392,10 +392,6 @@ static void add\_victim\_entry(struct f2fs\_sb\_info \*sbi, if (p->gc\_mode == GC\_AT && get\_valid\_blocks(sbi, segno, true) == 0) return;-- if (p->alloc\_mode == AT\_SSR &&- get\_seg\_entry(sbi, segno)->ckpt\_valid\_blocks == 0)- return; }  for (i = 0; i < sbi->segs\_per\_sec; i++)@@ -728,11 +724,27 @@ retry:  if (sec\_usage\_check(sbi, secno)) goto next;+ /\* Don't touch checkpointed data \*/- if (unlikely(is\_sbi\_flag\_set(sbi, SBI\_CP\_DISABLED) &&- get\_ckpt\_valid\_blocks(sbi, segno) &&- p.alloc\_mode == LFS))- goto next;+ if (unlikely(is\_sbi\_flag\_set(sbi, SBI\_CP\_DISABLED))) {+ if (p.alloc\_mode == LFS) {+ /\*+ \* LFS is set to find source section during GC.+ \* The victim should have no checkpointed data.+ \*/+ if (get\_ckpt\_valid\_blocks(sbi, segno, true))+ goto next;+ } else {+ /\*+ \* SSR | AT\_SSR are set to find target segment+ \* for writes which can be full by checkpointed+ \* and newly written blocks.+ \*/+ if (!f2fs\_segment\_has\_free\_slot(sbi, segno))+ goto next;+ }+ }+ if (gc\_type == BG\_GC && test\_bit(secno, dirty\_i->victim\_secmap)) goto next; diff --git a/fs/f2fs/segment.c b/fs/f2fs/segment.cindex d696d4713333c3..661b891aa1caa2 100644--- a/[fs/f2fs/segment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/segment.c?id=bbed83d7060e07a5d309104d25a00f0a24441428)+++ b/[fs/f2fs/segment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/segment.c?id=105155a8146ddb54c119d8318964eef3859d109d)@@ -871,7 +871,7 @@ static void locate\_dirty\_segment(struct f2fs\_sb\_info \*sbi, unsigned int segno) mutex\_lock(&dirty\_i->seglist\_lock);  valid\_blocks = get\_valid\_blocks(sbi, segno, false);- ckpt\_valid\_blocks = get\_ckpt\_valid\_blocks(sbi, segno);+ ckpt\_valid\_blocks = get\_ckpt\_valid\_blocks(sbi, segno, false);  if (valid\_blocks == 0 && (!is\_sbi\_flag\_set(sbi, SBI\_CP\_DISABLED) || ckpt\_valid\_blocks == usable\_blocks)) {@@ -956,7 +956,7 @@ static unsigned int get\_free\_segment(struct f2fs\_sb\_info \*sbi) for\_each\_set\_bit(segno, dirty\_i->dirty\_segmap[DIRTY], MAIN\_SEGS(sbi)) { if (get\_valid\_blocks(sbi, segno, false)) continue;- if (get\_ckpt\_valid\_blocks(sbi, segno))+ if (get\_ckpt\_valid\_blocks(sbi, segno, false)) continue; mutex\_unlock(&dirty\_i->seglist\_lock); return segno;@@ -2646,6 +2646,23 @@ static void \_\_refresh\_next\_blkoff(struct f2fs\_sb\_info \*sbi, seg->next\_blkoff++; } +bool f2fs\_segment\_has\_free\_slot(struct f2fs\_sb\_info \*sbi, int segno)+{+ struct seg\_entry \*se = get\_seg\_entry(sbi, segno);+ int entries = SIT\_VBLOCK\_MAP\_SIZE / sizeof(unsigned long);+ unsigned long \*target\_map = SIT\_I(sbi)->tmp\_map;+ unsigned long \*ckpt\_map = (unsigned long \*)se->ckpt\_valid\_map;+ unsigned long \*cur\_map = (unsigned long \*)se->cur\_valid\_map;+ int i, pos;++ for (i = 0; i < entries; i++)+ target\_map[i] = ckpt\_map[i] | cur\_map[i];++ pos = \_\_find\_rev\_next\_zero\_bit(target\_map, sbi->blocks\_per\_seg, 0);++ return pos < sbi->blocks\_per\_seg;+}+ /\* \* This function always allocates a used segment(from dirty seglist) by SSR \* manner, so it should recover the existing segment information of valid blocks@@ -2916,19 +2933,8 @@ static void \_\_allocate\_new\_segment(struct f2fs\_sb\_info \*sbi, int type, get\_valid\_blocks(sbi, curseg->segno, new\_sec)) goto alloc; - if (new\_sec) {- unsigned int segno = START\_SEGNO(curseg->segno);- int i;-- for (i = 0; i < sbi->segs\_per\_sec; i++, segno++) {- if (get\_ckpt\_valid\_blocks(sbi, segno))- goto alloc;- }- } else {- if (!get\_ckpt\_valid\_blocks(sbi, curseg->segno))- return;- }-+ if (!get\_ckpt\_valid\_blocks(sbi, curseg->segno, new\_sec))+ return; alloc: old\_segno = curseg->segno; SIT\_I(sbi)->s\_ops->allocate\_segment(sbi, type, true);diff --git a/fs/f2fs/segment.h b/fs/f2fs/segment.hindex 229814b4f4a6cc..1bf33fc27b8f83 100644--- a/[fs/f2fs/segment.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/segment.h?id=bbed83d7060e07a5d309104d25a00f0a24441428)+++ b/[fs/f2fs/segment.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/segment.h?id=105155a8146ddb54c119d8318964eef3859d109d)@@ -361,8 +361,20 @@ static inline unsigned int get\_valid\_blocks(struct f2fs\_sb\_info \*sbi, }  static inline unsigned int get\_ckpt\_valid\_blocks(struct f2fs\_sb\_info \*sbi,- unsigned int segno)+ unsigned int segno, bool use\_section) {+ if (use\_section && \_\_is\_large\_section(sbi)) {+ unsigned int start\_segno = START\_SEGNO(segno);+ unsigned int blocks = 0;+ int i;++ for (i = 0; i < sbi->segs\_per\_sec; i++, start\_segno++) {+ struct seg\_entry \*se = get\_seg\_entry(sbi, start\_segno);++ blocks += se->ckpt\_valid\_blocks;+ }+ return blocks;+ } return get\_seg\_entry(sbi, segno)->ckpt\_valid\_blocks; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 04:50:24 +0000

