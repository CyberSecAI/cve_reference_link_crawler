

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=61461fc921b756ae16e64243f72af2bfc2e620db)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=61461fc921b756ae16e64243f72af2bfc2e620db)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=61461fc921b756ae16e64243f72af2bfc2e620db)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=61461fc921b756ae16e64243f72af2bfc2e620db)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Chao Yu <yuchao0@huawei.com> | 2021-03-24 11:18:28 +0800 |
| --- | --- | --- |
| committer | Jaegeuk Kim <jaegeuk@kernel.org> | 2021-03-26 10:27:01 -0700 |
| commit | [61461fc921b756ae16e64243f72af2bfc2e620db](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=61461fc921b756ae16e64243f72af2bfc2e620db) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=61461fc921b756ae16e64243f72af2bfc2e620db)) | |
| tree | [b9db9f5471ba68730cf3e03f9cf6af0dbfe5b0ca](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=61461fc921b756ae16e64243f72af2bfc2e620db) | |
| parent | [88f2cfc5fa90326edb569b4a81bb38ed4dcd3108](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=88f2cfc5fa90326edb569b4a81bb38ed4dcd3108) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=61461fc921b756ae16e64243f72af2bfc2e620db&id2=88f2cfc5fa90326edb569b4a81bb38ed4dcd3108)) | |
| download | [linux-61461fc921b756ae16e64243f72af2bfc2e620db.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-61461fc921b756ae16e64243f72af2bfc2e620db.tar.gz) | |

f2fs: fix to avoid touching checkpointed data in get\_victim()In CP disabling mode, there are two issues when using LFS or SSR | AT\_SSR
mode to select victim:
1. LFS is set to find source section during GC, the victim should have
no checkpointed data, since after GC, section could not be set free for
reuse.
Previously, we only check valid chpt blocks in current segment rather
than section, fix it.
2. SSR | AT\_SSR are set to find target segment for writes which can be
fully filled by checkpointed and newly written blocks, we should never
select such segment, otherwise it can cause panic or data corruption
during allocation, potential case is described as below:
a) target segment has 'n' (n < 512) ckpt valid blocks
b) GC migrates 'n' valid blocks to other segment (segment is still
in dirty list)
c) GC migrates '512 - n' blocks to target segment (segment has 'n'
cp\_vblocks and '512 - n' vblocks)
d) If GC selects target segment via {AT,}SSR allocator, however there
is no free space in targe segment.
Fixes: 4354994f097d ("f2fs: checkpoint disabling")
Fixes: 093749e296e2 ("f2fs: support age threshold based garbage collection")
Signed-off-by: Chao Yu <yuchao0@huawei.com>
Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=61461fc921b756ae16e64243f72af2bfc2e620db)

| -rw-r--r-- | [fs/f2fs/f2fs.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/f2fs/f2fs.h?id=61461fc921b756ae16e64243f72af2bfc2e620db) | 1 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/f2fs/gc.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/f2fs/gc.c?id=61461fc921b756ae16e64243f72af2bfc2e620db) | 28 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/f2fs/segment.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/f2fs/segment.c?id=61461fc921b756ae16e64243f72af2bfc2e620db) | 36 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/f2fs/segment.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/f2fs/segment.h?id=61461fc921b756ae16e64243f72af2bfc2e620db) | 14 | |  |  |  | | --- | --- | --- | |

4 files changed, 55 insertions, 24 deletions

| diff --git a/fs/f2fs/f2fs.h b/fs/f2fs/f2fs.hindex eb154d9cb063c0..fe380bcf8d4df9 100644--- a/[fs/f2fs/f2fs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/f2fs.h?id=88f2cfc5fa90326edb569b4a81bb38ed4dcd3108)+++ b/[fs/f2fs/f2fs.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/f2fs.h?id=61461fc921b756ae16e64243f72af2bfc2e620db)@@ -3387,6 +3387,7 @@ block\_t f2fs\_get\_unusable\_blocks(struct f2fs\_sb\_info \*sbi); int f2fs\_disable\_cp\_again(struct f2fs\_sb\_info \*sbi, block\_t unusable); void f2fs\_release\_discard\_addrs(struct f2fs\_sb\_info \*sbi); int f2fs\_npages\_for\_summary\_flush(struct f2fs\_sb\_info \*sbi, bool for\_ra);+bool f2fs\_segment\_has\_free\_slot(struct f2fs\_sb\_info \*sbi, int segno); void f2fs\_init\_inmem\_curseg(struct f2fs\_sb\_info \*sbi); void f2fs\_save\_inmem\_curseg(struct f2fs\_sb\_info \*sbi); void f2fs\_restore\_inmem\_curseg(struct f2fs\_sb\_info \*sbi);diff --git a/fs/f2fs/gc.c b/fs/f2fs/gc.cindex d96acc6531f2a0..a2ca483f985540 100644--- a/[fs/f2fs/gc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/gc.c?id=88f2cfc5fa90326edb569b4a81bb38ed4dcd3108)+++ b/[fs/f2fs/gc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/gc.c?id=61461fc921b756ae16e64243f72af2bfc2e620db)@@ -392,10 +392,6 @@ static void add\_victim\_entry(struct f2fs\_sb\_info \*sbi, if (p->gc\_mode == GC\_AT && get\_valid\_blocks(sbi, segno, true) == 0) return;-- if (p->alloc\_mode == AT\_SSR &&- get\_seg\_entry(sbi, segno)->ckpt\_valid\_blocks == 0)- return; }  for (i = 0; i < sbi->segs\_per\_sec; i++)@@ -728,11 +724,27 @@ retry:  if (sec\_usage\_check(sbi, secno)) goto next;+ /\* Don't touch checkpointed data \*/- if (unlikely(is\_sbi\_flag\_set(sbi, SBI\_CP\_DISABLED) &&- get\_ckpt\_valid\_blocks(sbi, segno) &&- p.alloc\_mode == LFS))- goto next;+ if (unlikely(is\_sbi\_flag\_set(sbi, SBI\_CP\_DISABLED))) {+ if (p.alloc\_mode == LFS) {+ /\*+ \* LFS is set to find source section during GC.+ \* The victim should have no checkpointed data.+ \*/+ if (get\_ckpt\_valid\_blocks(sbi, segno, true))+ goto next;+ } else {+ /\*+ \* SSR | AT\_SSR are set to find target segment+ \* for writes which can be full by checkpointed+ \* and newly written blocks.+ \*/+ if (!f2fs\_segment\_has\_free\_slot(sbi, segno))+ goto next;+ }+ }+ if (gc\_type == BG\_GC && test\_bit(secno, dirty\_i->victim\_secmap)) goto next; diff --git a/fs/f2fs/segment.c b/fs/f2fs/segment.cindex b6f19518afd19a..33cb8aa5ec8fdc 100644--- a/[fs/f2fs/segment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/segment.c?id=88f2cfc5fa90326edb569b4a81bb38ed4dcd3108)+++ b/[fs/f2fs/segment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/segment.c?id=61461fc921b756ae16e64243f72af2bfc2e620db)@@ -865,7 +865,7 @@ static void locate\_dirty\_segment(struct f2fs\_sb\_info \*sbi, unsigned int segno) mutex\_lock(&dirty\_i->seglist\_lock);  valid\_blocks = get\_valid\_blocks(sbi, segno, false);- ckpt\_valid\_blocks = get\_ckpt\_valid\_blocks(sbi, segno);+ ckpt\_valid\_blocks = get\_ckpt\_valid\_blocks(sbi, segno, false);  if (valid\_blocks == 0 && (!is\_sbi\_flag\_set(sbi, SBI\_CP\_DISABLED) || ckpt\_valid\_blocks == usable\_blocks)) {@@ -950,7 +950,7 @@ static unsigned int get\_free\_segment(struct f2fs\_sb\_info \*sbi) for\_each\_set\_bit(segno, dirty\_i->dirty\_segmap[DIRTY], MAIN\_SEGS(sbi)) { if (get\_valid\_blocks(sbi, segno, false)) continue;- if (get\_ckpt\_valid\_blocks(sbi, segno))+ if (get\_ckpt\_valid\_blocks(sbi, segno, false)) continue; mutex\_unlock(&dirty\_i->seglist\_lock); return segno;@@ -2642,6 +2642,23 @@ static void \_\_refresh\_next\_blkoff(struct f2fs\_sb\_info \*sbi, seg->next\_blkoff++; } +bool f2fs\_segment\_has\_free\_slot(struct f2fs\_sb\_info \*sbi, int segno)+{+ struct seg\_entry \*se = get\_seg\_entry(sbi, segno);+ int entries = SIT\_VBLOCK\_MAP\_SIZE / sizeof(unsigned long);+ unsigned long \*target\_map = SIT\_I(sbi)->tmp\_map;+ unsigned long \*ckpt\_map = (unsigned long \*)se->ckpt\_valid\_map;+ unsigned long \*cur\_map = (unsigned long \*)se->cur\_valid\_map;+ int i, pos;++ for (i = 0; i < entries; i++)+ target\_map[i] = ckpt\_map[i] | cur\_map[i];++ pos = \_\_find\_rev\_next\_zero\_bit(target\_map, sbi->blocks\_per\_seg, 0);++ return pos < sbi->blocks\_per\_seg;+}+ /\* \* This function always allocates a used segment(from dirty seglist) by SSR \* manner, so it should recover the existing segment information of valid blocks@@ -2912,19 +2929,8 @@ static void \_\_allocate\_new\_segment(struct f2fs\_sb\_info \*sbi, int type, get\_valid\_blocks(sbi, curseg->segno, new\_sec)) goto alloc; - if (new\_sec) {- unsigned int segno = START\_SEGNO(curseg->segno);- int i;-- for (i = 0; i < sbi->segs\_per\_sec; i++, segno++) {- if (get\_ckpt\_valid\_blocks(sbi, segno))- goto alloc;- }- } else {- if (!get\_ckpt\_valid\_blocks(sbi, curseg->segno))- return;- }-+ if (!get\_ckpt\_valid\_blocks(sbi, curseg->segno, new\_sec))+ return; alloc: old\_segno = curseg->segno; SIT\_I(sbi)->s\_ops->allocate\_segment(sbi, type, true);diff --git a/fs/f2fs/segment.h b/fs/f2fs/segment.hindex 144980b62f9e61..dab87ecba2b587 100644--- a/[fs/f2fs/segment.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/segment.h?id=88f2cfc5fa90326edb569b4a81bb38ed4dcd3108)+++ b/[fs/f2fs/segment.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/segment.h?id=61461fc921b756ae16e64243f72af2bfc2e620db)@@ -359,8 +359,20 @@ static inline unsigned int get\_valid\_blocks(struct f2fs\_sb\_info \*sbi, }  static inline unsigned int get\_ckpt\_valid\_blocks(struct f2fs\_sb\_info \*sbi,- unsigned int segno)+ unsigned int segno, bool use\_section) {+ if (use\_section && \_\_is\_large\_section(sbi)) {+ unsigned int start\_segno = START\_SEGNO(segno);+ unsigned int blocks = 0;+ int i;++ for (i = 0; i < sbi->segs\_per\_sec; i++, start\_segno++) {+ struct seg\_entry \*se = get\_seg\_entry(sbi, start\_segno);++ blocks += se->ckpt\_valid\_blocks;+ }+ return blocks;+ } return get\_seg\_entry(sbi, segno)->ckpt\_valid\_blocks; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 04:50:29 +0000

