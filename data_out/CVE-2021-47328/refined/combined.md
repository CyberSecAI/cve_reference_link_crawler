=== Content from git.kernel.org_3ffdab7d_20250110_141101.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=f0a031f7c55ffd944fead1ddaf2aa94df9a158c1)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f0a031f7c55ffd944fead1ddaf2aa94df9a158c1)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f0a031f7c55ffd944fead1ddaf2aa94df9a158c1)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f0a031f7c55ffd944fead1ddaf2aa94df9a158c1)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Mike Christie <michael.christie@oracle.com> | 2021-05-25 13:18:06 -0500 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2021-07-20 16:02:07 +0200 |
| commit | [f0a031f7c55ffd944fead1ddaf2aa94df9a158c1](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f0a031f7c55ffd944fead1ddaf2aa94df9a158c1) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=f0a031f7c55ffd944fead1ddaf2aa94df9a158c1)) | |
| tree | [cfde660376d11cfbaba91f7019f27617bcc4bbb0](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f0a031f7c55ffd944fead1ddaf2aa94df9a158c1) | |
| parent | [69139793ea54eb2b62592cb7776613b6eab7c322](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=69139793ea54eb2b62592cb7776613b6eab7c322) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f0a031f7c55ffd944fead1ddaf2aa94df9a158c1&id2=69139793ea54eb2b62592cb7776613b6eab7c322)) | |
| download | [linux-f0a031f7c55ffd944fead1ddaf2aa94df9a158c1.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-f0a031f7c55ffd944fead1ddaf2aa94df9a158c1.tar.gz) | |

scsi: iscsi: Fix conn use after free during resets[ Upstream commit ec29d0ac29be366450a7faffbcf8cba3a6a3b506 ]
If we haven't done a unbind target call we can race where
iscsi\_conn\_teardown wakes up the EH thread and then frees the conn while
those threads are still accessing the conn ehwait.
We can only do one TMF per session so this just moves the TMF fields from
the conn to the session. We can then rely on the
iscsi\_session\_teardown->iscsi\_remove\_session->\_\_iscsi\_unbind\_session call
to remove the target and it's devices, and know after that point there is
no device or scsi-ml callout trying to access the session.
Link: [https://lore.kernel.org/r/20210525181821.7617-14-michael.christie@oracle.com](https://lore.kernel.org/r/20210525181821.7617-14-michael.christie%40oracle.com)
Reviewed-by: Lee Duncan <lduncan@suse.com>
Signed-off-by: Mike Christie <michael.christie@oracle.com>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f0a031f7c55ffd944fead1ddaf2aa94df9a158c1)

| -rw-r--r-- | [drivers/scsi/libiscsi.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/scsi/libiscsi.c?id=f0a031f7c55ffd944fead1ddaf2aa94df9a158c1) | 115 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/scsi/libiscsi.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/scsi/libiscsi.h?id=f0a031f7c55ffd944fead1ddaf2aa94df9a158c1) | 11 | |  |  |  | | --- | --- | --- | |

2 files changed, 60 insertions, 66 deletions

| diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.cindex ab39d7f65bbb09..dfe906307e55d5 100644--- a/[drivers/scsi/libiscsi.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/scsi/libiscsi.c?id=69139793ea54eb2b62592cb7776613b6eab7c322)+++ b/[drivers/scsi/libiscsi.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/scsi/libiscsi.c?id=f0a031f7c55ffd944fead1ddaf2aa94df9a158c1)@@ -230,11 +230,11 @@ static int iscsi\_prep\_ecdb\_ahs(struct iscsi\_task \*task) \*/ static int iscsi\_check\_tmf\_restrictions(struct iscsi\_task \*task, int opcode) {- struct iscsi\_conn \*conn = task->conn;- struct iscsi\_tm \*tmf = &conn->tmhdr;+ struct iscsi\_session \*session = task->conn->session;+ struct iscsi\_tm \*tmf = &session->tmhdr; u64 hdr\_lun; - if (conn->tmf\_state == TMF\_INITIAL)+ if (session->tmf\_state == TMF\_INITIAL) return 0;  if ((tmf->opcode & ISCSI\_OPCODE\_MASK) != ISCSI\_OP\_SCSI\_TMFUNC)@@ -254,24 +254,19 @@ static int iscsi\_check\_tmf\_restrictions(struct iscsi\_task \*task, int opcode) \* Fail all SCSI cmd PDUs \*/ if (opcode != ISCSI\_OP\_SCSI\_DATA\_OUT) {- iscsi\_conn\_printk(KERN\_INFO, conn,- "task [op %x itt "- "0x%x/0x%x] "- "rejected.\n",- opcode, task->itt,- task->hdr\_itt);+ iscsi\_session\_printk(KERN\_INFO, session,+ "task [op %x itt 0x%x/0x%x] rejected.\n",+ opcode, task->itt, task->hdr\_itt); return -EACCES; } /\* \* And also all data-out PDUs in response to R2T \* if fast\_abort is set. \*/- if (conn->session->fast\_abort) {- iscsi\_conn\_printk(KERN\_INFO, conn,- "task [op %x itt "- "0x%x/0x%x] fast abort.\n",- opcode, task->itt,- task->hdr\_itt);+ if (session->fast\_abort) {+ iscsi\_session\_printk(KERN\_INFO, session,+ "task [op %x itt 0x%x/0x%x] fast abort.\n",+ opcode, task->itt, task->hdr\_itt); return -EACCES; } break;@@ -284,7 +279,7 @@ static int iscsi\_check\_tmf\_restrictions(struct iscsi\_task \*task, int opcode) \*/ if (opcode == ISCSI\_OP\_SCSI\_DATA\_OUT && task->hdr\_itt == tmf->rtt) {- ISCSI\_DBG\_SESSION(conn->session,+ ISCSI\_DBG\_SESSION(session, "Preventing task %x/%x from sending " "data-out due to abort task in " "progress\n", task->itt,@@ -936,20 +931,21 @@ iscsi\_data\_in\_rsp(struct iscsi\_conn \*conn, struct iscsi\_hdr \*hdr, static void iscsi\_tmf\_rsp(struct iscsi\_conn \*conn, struct iscsi\_hdr \*hdr) { struct iscsi\_tm\_rsp \*tmf = (struct iscsi\_tm\_rsp \*)hdr;+ struct iscsi\_session \*session = conn->session;  conn->exp\_statsn = be32\_to\_cpu(hdr->statsn) + 1; conn->tmfrsp\_pdus\_cnt++; - if (conn->tmf\_state != TMF\_QUEUED)+ if (session->tmf\_state != TMF\_QUEUED) return;  if (tmf->response == ISCSI\_TMF\_RSP\_COMPLETE)- conn->tmf\_state = TMF\_SUCCESS;+ session->tmf\_state = TMF\_SUCCESS; else if (tmf->response == ISCSI\_TMF\_RSP\_NO\_TASK)- conn->tmf\_state = TMF\_NOT\_FOUND;+ session->tmf\_state = TMF\_NOT\_FOUND; else- conn->tmf\_state = TMF\_FAILED;- wake\_up(&conn->ehwait);+ session->tmf\_state = TMF\_FAILED;+ wake\_up(&session->ehwait); }  static int iscsi\_send\_nopout(struct iscsi\_conn \*conn, struct iscsi\_nopin \*rhdr)@@ -1826,15 +1822,14 @@ EXPORT\_SYMBOL\_GPL(iscsi\_target\_alloc);  static void iscsi\_tmf\_timedout(struct timer\_list \*t) {- struct iscsi\_conn \*conn = from\_timer(conn, t, tmf\_timer);- struct iscsi\_session \*session = conn->session;+ struct iscsi\_session \*session = from\_timer(session, t, tmf\_timer);  spin\_lock(&session->frwd\_lock);- if (conn->tmf\_state == TMF\_QUEUED) {- conn->tmf\_state = TMF\_TIMEDOUT;+ if (session->tmf\_state == TMF\_QUEUED) {+ session->tmf\_state = TMF\_TIMEDOUT; ISCSI\_DBG\_EH(session, "tmf timedout\n"); /\* unblock eh\_abort() \*/- wake\_up(&conn->ehwait);+ wake\_up(&session->ehwait); } spin\_unlock(&session->frwd\_lock); }@@ -1857,8 +1852,8 @@ static int iscsi\_exec\_task\_mgmt\_fn(struct iscsi\_conn \*conn, return -EPERM; } conn->tmfcmd\_pdus\_cnt++;- conn->tmf\_timer.expires = timeout \* HZ + jiffies;- add\_timer(&conn->tmf\_timer);+ session->tmf\_timer.expires = timeout \* HZ + jiffies;+ add\_timer(&session->tmf\_timer); ISCSI\_DBG\_EH(session, "tmf set timeout\n");  spin\_unlock\_bh(&session->frwd\_lock);@@ -1872,12 +1867,12 @@ static int iscsi\_exec\_task\_mgmt\_fn(struct iscsi\_conn \*conn, \* 3) session is terminated or restarted or userspace has \* given up on recovery \*/- wait\_event\_interruptible(conn->ehwait, age != session->age ||+ wait\_event\_interruptible(session->ehwait, age != session->age || session->state != ISCSI\_STATE\_LOGGED\_IN ||- conn->tmf\_state != TMF\_QUEUED);+ session->tmf\_state != TMF\_QUEUED); if (signal\_pending(current)) flush\_signals(current);- del\_timer\_sync(&conn->tmf\_timer);+ del\_timer\_sync(&session->tmf\_timer);  mutex\_lock(&session->eh\_mutex); spin\_lock\_bh(&session->frwd\_lock);@@ -2309,17 +2304,17 @@ int iscsi\_eh\_abort(struct scsi\_cmnd \*sc) }  /\* only have one tmf outstanding at a time \*/- if (conn->tmf\_state != TMF\_INITIAL)+ if (session->tmf\_state != TMF\_INITIAL) goto failed;- conn->tmf\_state = TMF\_QUEUED;+ session->tmf\_state = TMF\_QUEUED; - hdr = &conn->tmhdr;+ hdr = &session->tmhdr; iscsi\_prep\_abort\_task\_pdu(task, hdr);  if (iscsi\_exec\_task\_mgmt\_fn(conn, hdr, age, session->abort\_timeout)) goto failed; - switch (conn->tmf\_state) {+ switch (session->tmf\_state) { case TMF\_SUCCESS: spin\_unlock\_bh(&session->frwd\_lock); /\*@@ -2334,7 +2329,7 @@ int iscsi\_eh\_abort(struct scsi\_cmnd \*sc) \*/ spin\_lock\_bh(&session->frwd\_lock); fail\_scsi\_task(task, DID\_ABORT);- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; memset(hdr, 0, sizeof(\*hdr)); spin\_unlock\_bh(&session->frwd\_lock); iscsi\_start\_tx(conn);@@ -2345,7 +2340,7 @@ int iscsi\_eh\_abort(struct scsi\_cmnd \*sc) goto failed\_unlocked; case TMF\_NOT\_FOUND: if (!sc->SCp.ptr) {- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; memset(hdr, 0, sizeof(\*hdr)); /\* task completed before tmf abort response \*/ ISCSI\_DBG\_EH(session, "sc completed while abort in "@@ -2354,7 +2349,7 @@ int iscsi\_eh\_abort(struct scsi\_cmnd \*sc) } fallthrough; default:- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; goto failed; } @@ -2413,11 +2408,11 @@ int iscsi\_eh\_device\_reset(struct scsi\_cmnd \*sc) conn = session->leadconn;  /\* only have one tmf outstanding at a time \*/- if (conn->tmf\_state != TMF\_INITIAL)+ if (session->tmf\_state != TMF\_INITIAL) goto unlock;- conn->tmf\_state = TMF\_QUEUED;+ session->tmf\_state = TMF\_QUEUED; - hdr = &conn->tmhdr;+ hdr = &session->tmhdr; iscsi\_prep\_lun\_reset\_pdu(sc, hdr);  if (iscsi\_exec\_task\_mgmt\_fn(conn, hdr, session->age,@@ -2426,7 +2421,7 @@ int iscsi\_eh\_device\_reset(struct scsi\_cmnd \*sc) goto unlock; } - switch (conn->tmf\_state) {+ switch (session->tmf\_state) { case TMF\_SUCCESS: break; case TMF\_TIMEDOUT:@@ -2434,7 +2429,7 @@ int iscsi\_eh\_device\_reset(struct scsi\_cmnd \*sc) iscsi\_conn\_failure(conn, ISCSI\_ERR\_SCSI\_EH\_SESSION\_RST); goto done; default:- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; goto unlock; } @@ -2446,7 +2441,7 @@ int iscsi\_eh\_device\_reset(struct scsi\_cmnd \*sc) spin\_lock\_bh(&session->frwd\_lock); memset(hdr, 0, sizeof(\*hdr)); fail\_scsi\_tasks(conn, sc->device->lun, DID\_ERROR);- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; spin\_unlock\_bh(&session->frwd\_lock);  iscsi\_start\_tx(conn);@@ -2469,8 +2464,7 @@ void iscsi\_session\_recovery\_timedout(struct iscsi\_cls\_session \*cls\_session) spin\_lock\_bh(&session->frwd\_lock); if (session->state != ISCSI\_STATE\_LOGGED\_IN) { session->state = ISCSI\_STATE\_RECOVERY\_FAILED;- if (session->leadconn)- wake\_up(&session->leadconn->ehwait);+ wake\_up(&session->ehwait); } spin\_unlock\_bh(&session->frwd\_lock); }@@ -2515,7 +2509,7 @@ failed: iscsi\_conn\_failure(conn, ISCSI\_ERR\_SCSI\_EH\_SESSION\_RST);  ISCSI\_DBG\_EH(session, "wait for relogin\n");- wait\_event\_interruptible(conn->ehwait,+ wait\_event\_interruptible(session->ehwait, session->state == ISCSI\_STATE\_TERMINATE || session->state == ISCSI\_STATE\_LOGGED\_IN || session->state == ISCSI\_STATE\_RECOVERY\_FAILED);@@ -2576,11 +2570,11 @@ static int iscsi\_eh\_target\_reset(struct scsi\_cmnd \*sc) conn = session->leadconn;  /\* only have one tmf outstanding at a time \*/- if (conn->tmf\_state != TMF\_INITIAL)+ if (session->tmf\_state != TMF\_INITIAL) goto unlock;- conn->tmf\_state = TMF\_QUEUED;+ session->tmf\_state = TMF\_QUEUED; - hdr = &conn->tmhdr;+ hdr = &session->tmhdr; iscsi\_prep\_tgt\_reset\_pdu(sc, hdr);  if (iscsi\_exec\_task\_mgmt\_fn(conn, hdr, session->age,@@ -2589,7 +2583,7 @@ static int iscsi\_eh\_target\_reset(struct scsi\_cmnd \*sc) goto unlock; } - switch (conn->tmf\_state) {+ switch (session->tmf\_state) { case TMF\_SUCCESS: break; case TMF\_TIMEDOUT:@@ -2597,7 +2591,7 @@ static int iscsi\_eh\_target\_reset(struct scsi\_cmnd \*sc) iscsi\_conn\_failure(conn, ISCSI\_ERR\_SCSI\_EH\_SESSION\_RST); goto done; default:- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; goto unlock; } @@ -2609,7 +2603,7 @@ static int iscsi\_eh\_target\_reset(struct scsi\_cmnd \*sc) spin\_lock\_bh(&session->frwd\_lock); memset(hdr, 0, sizeof(\*hdr)); fail\_scsi\_tasks(conn, -1, DID\_ERROR);- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; spin\_unlock\_bh(&session->frwd\_lock);  iscsi\_start\_tx(conn);@@ -2939,7 +2933,10 @@ iscsi\_session\_setup(struct iscsi\_transport \*iscsit, struct Scsi\_Host \*shost, session->tt = iscsit; session->dd\_data = cls\_session->dd\_data + sizeof(\*session); + session->tmf\_state = TMF\_INITIAL;+ timer\_setup(&session->tmf\_timer, iscsi\_tmf\_timedout, 0); mutex\_init(&session->eh\_mutex);+ spin\_lock\_init(&session->frwd\_lock); spin\_lock\_init(&session->back\_lock); @@ -3043,7 +3040,6 @@ iscsi\_conn\_setup(struct iscsi\_cls\_session \*cls\_session, int dd\_size, conn->c\_stage = ISCSI\_CONN\_INITIAL\_STAGE; conn->id = conn\_idx; conn->exp\_statsn = 0;- conn->tmf\_state = TMF\_INITIAL;  timer\_setup(&conn->transport\_timer, iscsi\_check\_transport\_timeouts, 0); @@ -3068,8 +3064,7 @@ iscsi\_conn\_setup(struct iscsi\_cls\_session \*cls\_session, int dd\_size, goto login\_task\_data\_alloc\_fail; conn->login\_task->data = conn->data = data; - timer\_setup(&conn->tmf\_timer, iscsi\_tmf\_timedout, 0);- init\_waitqueue\_head(&conn->ehwait);+ init\_waitqueue\_head(&session->ehwait);  return cls\_conn; @@ -3104,7 +3099,7 @@ void iscsi\_conn\_teardown(struct iscsi\_cls\_conn \*cls\_conn) \* leading connection? then give up on recovery. \*/ session->state = ISCSI\_STATE\_TERMINATE;- wake\_up(&conn->ehwait);+ wake\_up(&session->ehwait); } spin\_unlock\_bh(&session->frwd\_lock); @@ -3179,7 +3174,7 @@ int iscsi\_conn\_start(struct iscsi\_cls\_conn \*cls\_conn) \* commands after successful recovery \*/ conn->stop\_stage = 0;- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; session->age++; if (session->age == 16) session->age = 0;@@ -3193,7 +3188,7 @@ int iscsi\_conn\_start(struct iscsi\_cls\_conn \*cls\_conn) spin\_unlock\_bh(&session->frwd\_lock);  iscsi\_unblock\_session(session->cls\_session);- wake\_up(&conn->ehwait);+ wake\_up(&session->ehwait); return 0; } EXPORT\_SYMBOL\_GPL(iscsi\_conn\_start);@@ -3287,7 +3282,7 @@ void iscsi\_conn\_stop(struct iscsi\_cls\_conn \*cls\_conn, int flag) spin\_lock\_bh(&session->frwd\_lock); fail\_scsi\_tasks(conn, -1, DID\_TRANSPORT\_DISRUPTED); fail\_mgmt\_tasks(session, conn);- memset(&conn->tmhdr, 0, sizeof(conn->tmhdr));+ memset(&session->tmhdr, 0, sizeof(session->tmhdr)); spin\_unlock\_bh(&session->frwd\_lock); mutex\_unlock(&session->eh\_mutex); }diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.hindex 091f284bd6e93d..2bb452a8f134c7 100644--- a/[include/scsi/libiscsi.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/scsi/libiscsi.h?id=69139793ea54eb2b62592cb7776613b6eab7c322)+++ b/[include/scsi/libiscsi.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/scsi/libiscsi.h?id=f0a031f7c55ffd944fead1ddaf2aa94df9a158c1)@@ -195,12 +195,6 @@ struct iscsi\_conn { unsigned long suspend\_tx; /\* suspend Tx \*/ unsigned long suspend\_rx; /\* suspend Rx \*/ - /\* abort \*/- wait\_queue\_head\_t ehwait; /\* used in eh\_abort() \*/- struct iscsi\_tm tmhdr;- struct timer\_list tmf\_timer;- int tmf\_state; /\* see TMF\_INITIAL, etc.\*/- /\* negotiated params \*/ unsigned max\_recv\_dlength; /\* initiator\_max\_recv\_dsl\*/ unsigned max\_xmit\_dlength; /\* target\_max\_recv\_dsl \*/@@ -270,6 +264,11 @@ struct iscsi\_session { \* and recv lock. \*/ struct mutex eh\_mutex;+ /\* abort \*/+ wait\_queue\_head\_t ehwait; /\* used in eh\_abort() \*/+ struct iscsi\_tm tmhdr;+ struct timer\_list tmf\_timer;+ int tmf\_state; /\* see TMF\_INITIAL, etc.\*/  /\* iSCSI session-wide sequencing \*/ uint32\_t cmdsn; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 14:09:38 +0000



=== Content from git.kernel.org_be0a0f5e_20250110_141100.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=ec29d0ac29be366450a7faffbcf8cba3a6a3b506)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=ec29d0ac29be366450a7faffbcf8cba3a6a3b506)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ec29d0ac29be366450a7faffbcf8cba3a6a3b506)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=ec29d0ac29be366450a7faffbcf8cba3a6a3b506)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Mike Christie <michael.christie@oracle.com> | 2021-05-25 13:18:06 -0500 |
| --- | --- | --- |
| committer | Martin K. Petersen <martin.petersen@oracle.com> | 2021-06-02 01:28:21 -0400 |
| commit | [ec29d0ac29be366450a7faffbcf8cba3a6a3b506](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ec29d0ac29be366450a7faffbcf8cba3a6a3b506) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=ec29d0ac29be366450a7faffbcf8cba3a6a3b506)) | |
| tree | [7b363b26e9e235c989aac6751f5c691009d458bc](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=ec29d0ac29be366450a7faffbcf8cba3a6a3b506) | |
| parent | [fda290c5ae98b591797c96e55a2cfbd30d46a706](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=fda290c5ae98b591797c96e55a2cfbd30d46a706) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=ec29d0ac29be366450a7faffbcf8cba3a6a3b506&id2=fda290c5ae98b591797c96e55a2cfbd30d46a706)) | |
| download | [linux-ec29d0ac29be366450a7faffbcf8cba3a6a3b506.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-ec29d0ac29be366450a7faffbcf8cba3a6a3b506.tar.gz) | |

scsi: iscsi: Fix conn use after free during resetsIf we haven't done a unbind target call we can race where
iscsi\_conn\_teardown wakes up the EH thread and then frees the conn while
those threads are still accessing the conn ehwait.
We can only do one TMF per session so this just moves the TMF fields from
the conn to the session. We can then rely on the
iscsi\_session\_teardown->iscsi\_remove\_session->\_\_iscsi\_unbind\_session call
to remove the target and it's devices, and know after that point there is
no device or scsi-ml callout trying to access the session.
Link: [https://lore.kernel.org/r/20210525181821.7617-14-michael.christie@oracle.com](https://lore.kernel.org/r/20210525181821.7617-14-michael.christie%40oracle.com)
Reviewed-by: Lee Duncan <lduncan@suse.com>
Signed-off-by: Mike Christie <michael.christie@oracle.com>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=ec29d0ac29be366450a7faffbcf8cba3a6a3b506)

| -rw-r--r-- | [drivers/scsi/libiscsi.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/scsi/libiscsi.c?id=ec29d0ac29be366450a7faffbcf8cba3a6a3b506) | 115 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/scsi/libiscsi.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/scsi/libiscsi.h?id=ec29d0ac29be366450a7faffbcf8cba3a6a3b506) | 11 | |  |  |  | | --- | --- | --- | |

2 files changed, 60 insertions, 66 deletions

| diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.cindex b7445d9e99d675..94abb093098d23 100644--- a/[drivers/scsi/libiscsi.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/scsi/libiscsi.c?id=fda290c5ae98b591797c96e55a2cfbd30d46a706)+++ b/[drivers/scsi/libiscsi.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/scsi/libiscsi.c?id=ec29d0ac29be366450a7faffbcf8cba3a6a3b506)@@ -230,11 +230,11 @@ static int iscsi\_prep\_ecdb\_ahs(struct iscsi\_task \*task) \*/ static int iscsi\_check\_tmf\_restrictions(struct iscsi\_task \*task, int opcode) {- struct iscsi\_conn \*conn = task->conn;- struct iscsi\_tm \*tmf = &conn->tmhdr;+ struct iscsi\_session \*session = task->conn->session;+ struct iscsi\_tm \*tmf = &session->tmhdr; u64 hdr\_lun; - if (conn->tmf\_state == TMF\_INITIAL)+ if (session->tmf\_state == TMF\_INITIAL) return 0;  if ((tmf->opcode & ISCSI\_OPCODE\_MASK) != ISCSI\_OP\_SCSI\_TMFUNC)@@ -254,24 +254,19 @@ static int iscsi\_check\_tmf\_restrictions(struct iscsi\_task \*task, int opcode) \* Fail all SCSI cmd PDUs \*/ if (opcode != ISCSI\_OP\_SCSI\_DATA\_OUT) {- iscsi\_conn\_printk(KERN\_INFO, conn,- "task [op %x itt "- "0x%x/0x%x] "- "rejected.\n",- opcode, task->itt,- task->hdr\_itt);+ iscsi\_session\_printk(KERN\_INFO, session,+ "task [op %x itt 0x%x/0x%x] rejected.\n",+ opcode, task->itt, task->hdr\_itt); return -EACCES; } /\* \* And also all data-out PDUs in response to R2T \* if fast\_abort is set. \*/- if (conn->session->fast\_abort) {- iscsi\_conn\_printk(KERN\_INFO, conn,- "task [op %x itt "- "0x%x/0x%x] fast abort.\n",- opcode, task->itt,- task->hdr\_itt);+ if (session->fast\_abort) {+ iscsi\_session\_printk(KERN\_INFO, session,+ "task [op %x itt 0x%x/0x%x] fast abort.\n",+ opcode, task->itt, task->hdr\_itt); return -EACCES; } break;@@ -284,7 +279,7 @@ static int iscsi\_check\_tmf\_restrictions(struct iscsi\_task \*task, int opcode) \*/ if (opcode == ISCSI\_OP\_SCSI\_DATA\_OUT && task->hdr\_itt == tmf->rtt) {- ISCSI\_DBG\_SESSION(conn->session,+ ISCSI\_DBG\_SESSION(session, "Preventing task %x/%x from sending " "data-out due to abort task in " "progress\n", task->itt,@@ -936,20 +931,21 @@ iscsi\_data\_in\_rsp(struct iscsi\_conn \*conn, struct iscsi\_hdr \*hdr, static void iscsi\_tmf\_rsp(struct iscsi\_conn \*conn, struct iscsi\_hdr \*hdr) { struct iscsi\_tm\_rsp \*tmf = (struct iscsi\_tm\_rsp \*)hdr;+ struct iscsi\_session \*session = conn->session;  conn->exp\_statsn = be32\_to\_cpu(hdr->statsn) + 1; conn->tmfrsp\_pdus\_cnt++; - if (conn->tmf\_state != TMF\_QUEUED)+ if (session->tmf\_state != TMF\_QUEUED) return;  if (tmf->response == ISCSI\_TMF\_RSP\_COMPLETE)- conn->tmf\_state = TMF\_SUCCESS;+ session->tmf\_state = TMF\_SUCCESS; else if (tmf->response == ISCSI\_TMF\_RSP\_NO\_TASK)- conn->tmf\_state = TMF\_NOT\_FOUND;+ session->tmf\_state = TMF\_NOT\_FOUND; else- conn->tmf\_state = TMF\_FAILED;- wake\_up(&conn->ehwait);+ session->tmf\_state = TMF\_FAILED;+ wake\_up(&session->ehwait); }  static int iscsi\_send\_nopout(struct iscsi\_conn \*conn, struct iscsi\_nopin \*rhdr)@@ -1826,15 +1822,14 @@ EXPORT\_SYMBOL\_GPL(iscsi\_target\_alloc);  static void iscsi\_tmf\_timedout(struct timer\_list \*t) {- struct iscsi\_conn \*conn = from\_timer(conn, t, tmf\_timer);- struct iscsi\_session \*session = conn->session;+ struct iscsi\_session \*session = from\_timer(session, t, tmf\_timer);  spin\_lock(&session->frwd\_lock);- if (conn->tmf\_state == TMF\_QUEUED) {- conn->tmf\_state = TMF\_TIMEDOUT;+ if (session->tmf\_state == TMF\_QUEUED) {+ session->tmf\_state = TMF\_TIMEDOUT; ISCSI\_DBG\_EH(session, "tmf timedout\n"); /\* unblock eh\_abort() \*/- wake\_up(&conn->ehwait);+ wake\_up(&session->ehwait); } spin\_unlock(&session->frwd\_lock); }@@ -1857,8 +1852,8 @@ static int iscsi\_exec\_task\_mgmt\_fn(struct iscsi\_conn \*conn, return -EPERM; } conn->tmfcmd\_pdus\_cnt++;- conn->tmf\_timer.expires = timeout \* HZ + jiffies;- add\_timer(&conn->tmf\_timer);+ session->tmf\_timer.expires = timeout \* HZ + jiffies;+ add\_timer(&session->tmf\_timer); ISCSI\_DBG\_EH(session, "tmf set timeout\n");  spin\_unlock\_bh(&session->frwd\_lock);@@ -1872,12 +1867,12 @@ static int iscsi\_exec\_task\_mgmt\_fn(struct iscsi\_conn \*conn, \* 3) session is terminated or restarted or userspace has \* given up on recovery \*/- wait\_event\_interruptible(conn->ehwait, age != session->age ||+ wait\_event\_interruptible(session->ehwait, age != session->age || session->state != ISCSI\_STATE\_LOGGED\_IN ||- conn->tmf\_state != TMF\_QUEUED);+ session->tmf\_state != TMF\_QUEUED); if (signal\_pending(current)) flush\_signals(current);- del\_timer\_sync(&conn->tmf\_timer);+ del\_timer\_sync(&session->tmf\_timer);  mutex\_lock(&session->eh\_mutex); spin\_lock\_bh(&session->frwd\_lock);@@ -2308,17 +2303,17 @@ int iscsi\_eh\_abort(struct scsi\_cmnd \*sc) }  /\* only have one tmf outstanding at a time \*/- if (conn->tmf\_state != TMF\_INITIAL)+ if (session->tmf\_state != TMF\_INITIAL) goto failed;- conn->tmf\_state = TMF\_QUEUED;+ session->tmf\_state = TMF\_QUEUED; - hdr = &conn->tmhdr;+ hdr = &session->tmhdr; iscsi\_prep\_abort\_task\_pdu(task, hdr);  if (iscsi\_exec\_task\_mgmt\_fn(conn, hdr, age, session->abort\_timeout)) goto failed; - switch (conn->tmf\_state) {+ switch (session->tmf\_state) { case TMF\_SUCCESS: spin\_unlock\_bh(&session->frwd\_lock); /\*@@ -2333,7 +2328,7 @@ int iscsi\_eh\_abort(struct scsi\_cmnd \*sc) \*/ spin\_lock\_bh(&session->frwd\_lock); fail\_scsi\_task(task, DID\_ABORT);- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; memset(hdr, 0, sizeof(\*hdr)); spin\_unlock\_bh(&session->frwd\_lock); iscsi\_start\_tx(conn);@@ -2344,7 +2339,7 @@ int iscsi\_eh\_abort(struct scsi\_cmnd \*sc) goto failed\_unlocked; case TMF\_NOT\_FOUND: if (!sc->SCp.ptr) {- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; memset(hdr, 0, sizeof(\*hdr)); /\* task completed before tmf abort response \*/ ISCSI\_DBG\_EH(session, "sc completed while abort in "@@ -2353,7 +2348,7 @@ int iscsi\_eh\_abort(struct scsi\_cmnd \*sc) } fallthrough; default:- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; goto failed; } @@ -2414,11 +2409,11 @@ int iscsi\_eh\_device\_reset(struct scsi\_cmnd \*sc) conn = session->leadconn;  /\* only have one tmf outstanding at a time \*/- if (conn->tmf\_state != TMF\_INITIAL)+ if (session->tmf\_state != TMF\_INITIAL) goto unlock;- conn->tmf\_state = TMF\_QUEUED;+ session->tmf\_state = TMF\_QUEUED; - hdr = &conn->tmhdr;+ hdr = &session->tmhdr; iscsi\_prep\_lun\_reset\_pdu(sc, hdr);  if (iscsi\_exec\_task\_mgmt\_fn(conn, hdr, session->age,@@ -2427,7 +2422,7 @@ int iscsi\_eh\_device\_reset(struct scsi\_cmnd \*sc) goto unlock; } - switch (conn->tmf\_state) {+ switch (session->tmf\_state) { case TMF\_SUCCESS: break; case TMF\_TIMEDOUT:@@ -2435,7 +2430,7 @@ int iscsi\_eh\_device\_reset(struct scsi\_cmnd \*sc) iscsi\_conn\_failure(conn, ISCSI\_ERR\_SCSI\_EH\_SESSION\_RST); goto done; default:- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; goto unlock; } @@ -2447,7 +2442,7 @@ int iscsi\_eh\_device\_reset(struct scsi\_cmnd \*sc) spin\_lock\_bh(&session->frwd\_lock); memset(hdr, 0, sizeof(\*hdr)); fail\_scsi\_tasks(conn, sc->device->lun, DID\_ERROR);- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; spin\_unlock\_bh(&session->frwd\_lock);  iscsi\_start\_tx(conn);@@ -2470,8 +2465,7 @@ void iscsi\_session\_recovery\_timedout(struct iscsi\_cls\_session \*cls\_session) spin\_lock\_bh(&session->frwd\_lock); if (session->state != ISCSI\_STATE\_LOGGED\_IN) { session->state = ISCSI\_STATE\_RECOVERY\_FAILED;- if (session->leadconn)- wake\_up(&session->leadconn->ehwait);+ wake\_up(&session->ehwait); } spin\_unlock\_bh(&session->frwd\_lock); }@@ -2516,7 +2510,7 @@ failed: iscsi\_put\_conn(conn->cls\_conn);  ISCSI\_DBG\_EH(session, "wait for relogin\n");- wait\_event\_interruptible(conn->ehwait,+ wait\_event\_interruptible(session->ehwait, session->state == ISCSI\_STATE\_TERMINATE || session->state == ISCSI\_STATE\_LOGGED\_IN || session->state == ISCSI\_STATE\_RECOVERY\_FAILED);@@ -2577,11 +2571,11 @@ static int iscsi\_eh\_target\_reset(struct scsi\_cmnd \*sc) conn = session->leadconn;  /\* only have one tmf outstanding at a time \*/- if (conn->tmf\_state != TMF\_INITIAL)+ if (session->tmf\_state != TMF\_INITIAL) goto unlock;- conn->tmf\_state = TMF\_QUEUED;+ session->tmf\_state = TMF\_QUEUED; - hdr = &conn->tmhdr;+ hdr = &session->tmhdr; iscsi\_prep\_tgt\_reset\_pdu(sc, hdr);  if (iscsi\_exec\_task\_mgmt\_fn(conn, hdr, session->age,@@ -2590,7 +2584,7 @@ static int iscsi\_eh\_target\_reset(struct scsi\_cmnd \*sc) goto unlock; } - switch (conn->tmf\_state) {+ switch (session->tmf\_state) { case TMF\_SUCCESS: break; case TMF\_TIMEDOUT:@@ -2598,7 +2592,7 @@ static int iscsi\_eh\_target\_reset(struct scsi\_cmnd \*sc) iscsi\_conn\_failure(conn, ISCSI\_ERR\_SCSI\_EH\_SESSION\_RST); goto done; default:- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; goto unlock; } @@ -2610,7 +2604,7 @@ static int iscsi\_eh\_target\_reset(struct scsi\_cmnd \*sc) spin\_lock\_bh(&session->frwd\_lock); memset(hdr, 0, sizeof(\*hdr)); fail\_scsi\_tasks(conn, -1, DID\_ERROR);- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; spin\_unlock\_bh(&session->frwd\_lock);  iscsi\_start\_tx(conn);@@ -2940,7 +2934,10 @@ iscsi\_session\_setup(struct iscsi\_transport \*iscsit, struct Scsi\_Host \*shost, session->tt = iscsit; session->dd\_data = cls\_session->dd\_data + sizeof(\*session); + session->tmf\_state = TMF\_INITIAL;+ timer\_setup(&session->tmf\_timer, iscsi\_tmf\_timedout, 0); mutex\_init(&session->eh\_mutex);+ spin\_lock\_init(&session->frwd\_lock); spin\_lock\_init(&session->back\_lock); @@ -3044,7 +3041,6 @@ iscsi\_conn\_setup(struct iscsi\_cls\_session \*cls\_session, int dd\_size, conn->c\_stage = ISCSI\_CONN\_INITIAL\_STAGE; conn->id = conn\_idx; conn->exp\_statsn = 0;- conn->tmf\_state = TMF\_INITIAL;  timer\_setup(&conn->transport\_timer, iscsi\_check\_transport\_timeouts, 0); @@ -3069,8 +3065,7 @@ iscsi\_conn\_setup(struct iscsi\_cls\_session \*cls\_session, int dd\_size, goto login\_task\_data\_alloc\_fail; conn->login\_task->data = conn->data = data; - timer\_setup(&conn->tmf\_timer, iscsi\_tmf\_timedout, 0);- init\_waitqueue\_head(&conn->ehwait);+ init\_waitqueue\_head(&session->ehwait);  return cls\_conn; @@ -3105,7 +3100,7 @@ void iscsi\_conn\_teardown(struct iscsi\_cls\_conn \*cls\_conn) \* leading connection? then give up on recovery. \*/ session->state = ISCSI\_STATE\_TERMINATE;- wake\_up(&conn->ehwait);+ wake\_up(&session->ehwait); } spin\_unlock\_bh(&session->frwd\_lock); @@ -3180,7 +3175,7 @@ int iscsi\_conn\_start(struct iscsi\_cls\_conn \*cls\_conn) \* commands after successful recovery \*/ conn->stop\_stage = 0;- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; session->age++; if (session->age == 16) session->age = 0;@@ -3194,7 +3189,7 @@ int iscsi\_conn\_start(struct iscsi\_cls\_conn \*cls\_conn) spin\_unlock\_bh(&session->frwd\_lock);  iscsi\_unblock\_session(session->cls\_session);- wake\_up(&conn->ehwait);+ wake\_up(&session->ehwait); return 0; } EXPORT\_SYMBOL\_GPL(iscsi\_conn\_start);@@ -3288,7 +3283,7 @@ void iscsi\_conn\_stop(struct iscsi\_cls\_conn \*cls\_conn, int flag) spin\_lock\_bh(&session->frwd\_lock); fail\_scsi\_tasks(conn, -1, DID\_TRANSPORT\_DISRUPTED); fail\_mgmt\_tasks(session, conn);- memset(&conn->tmhdr, 0, sizeof(conn->tmhdr));+ memset(&session->tmhdr, 0, sizeof(session->tmhdr)); spin\_unlock\_bh(&session->frwd\_lock); mutex\_unlock(&session->eh\_mutex); }diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.hindex 13d413a0b8b62a..9d7908265afea1 100644--- a/[include/scsi/libiscsi.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/scsi/libiscsi.h?id=fda290c5ae98b591797c96e55a2cfbd30d46a706)+++ b/[include/scsi/libiscsi.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/scsi/libiscsi.h?id=ec29d0ac29be366450a7faffbcf8cba3a6a3b506)@@ -202,12 +202,6 @@ struct iscsi\_conn { unsigned long suspend\_tx; /\* suspend Tx \*/ unsigned long suspend\_rx; /\* suspend Rx \*/ - /\* abort \*/- wait\_queue\_head\_t ehwait; /\* used in eh\_abort() \*/- struct iscsi\_tm tmhdr;- struct timer\_list tmf\_timer;- int tmf\_state; /\* see TMF\_INITIAL, etc.\*/- /\* negotiated params \*/ unsigned max\_recv\_dlength; /\* initiator\_max\_recv\_dsl\*/ unsigned max\_xmit\_dlength; /\* target\_max\_recv\_dsl \*/@@ -277,6 +271,11 @@ struct iscsi\_session { \* and recv lock. \*/ struct mutex eh\_mutex;+ /\* abort \*/+ wait\_queue\_head\_t ehwait; /\* used in eh\_abort() \*/+ struct iscsi\_tm tmhdr;+ struct timer\_list tmf\_timer;+ int tmf\_state; /\* see TMF\_INITIAL, etc.\*/  /\* iSCSI session-wide sequencing \*/ uint32\_t cmdsn; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 14:09:37 +0000



=== Content from git.kernel.org_a3846596_20250110_141059.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=d04958a348e560938410e04a12fb99da9c7e6a00)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d04958a348e560938410e04a12fb99da9c7e6a00)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d04958a348e560938410e04a12fb99da9c7e6a00)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d04958a348e560938410e04a12fb99da9c7e6a00)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Mike Christie <michael.christie@oracle.com> | 2021-05-25 13:18:06 -0500 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2021-07-20 16:10:43 +0200 |
| commit | [d04958a348e560938410e04a12fb99da9c7e6a00](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d04958a348e560938410e04a12fb99da9c7e6a00) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=d04958a348e560938410e04a12fb99da9c7e6a00)) | |
| tree | [74218bbf7773d102de65e31196174b929105ca16](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d04958a348e560938410e04a12fb99da9c7e6a00) | |
| parent | [173fdf1497d964940facca507a876bc2d3834893](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=173fdf1497d964940facca507a876bc2d3834893) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d04958a348e560938410e04a12fb99da9c7e6a00&id2=173fdf1497d964940facca507a876bc2d3834893)) | |
| download | [linux-d04958a348e560938410e04a12fb99da9c7e6a00.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-d04958a348e560938410e04a12fb99da9c7e6a00.tar.gz) | |

scsi: iscsi: Fix conn use after free during resets[ Upstream commit ec29d0ac29be366450a7faffbcf8cba3a6a3b506 ]
If we haven't done a unbind target call we can race where
iscsi\_conn\_teardown wakes up the EH thread and then frees the conn while
those threads are still accessing the conn ehwait.
We can only do one TMF per session so this just moves the TMF fields from
the conn to the session. We can then rely on the
iscsi\_session\_teardown->iscsi\_remove\_session->\_\_iscsi\_unbind\_session call
to remove the target and it's devices, and know after that point there is
no device or scsi-ml callout trying to access the session.
Link: [https://lore.kernel.org/r/20210525181821.7617-14-michael.christie@oracle.com](https://lore.kernel.org/r/20210525181821.7617-14-michael.christie%40oracle.com)
Reviewed-by: Lee Duncan <lduncan@suse.com>
Signed-off-by: Mike Christie <michael.christie@oracle.com>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d04958a348e560938410e04a12fb99da9c7e6a00)

| -rw-r--r-- | [drivers/scsi/libiscsi.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/scsi/libiscsi.c?id=d04958a348e560938410e04a12fb99da9c7e6a00) | 115 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/scsi/libiscsi.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/scsi/libiscsi.h?id=d04958a348e560938410e04a12fb99da9c7e6a00) | 11 | |  |  |  | | --- | --- | --- | |

2 files changed, 60 insertions, 66 deletions

| diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.cindex b9981078375df1..eeba6180711cd3 100644--- a/[drivers/scsi/libiscsi.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/scsi/libiscsi.c?id=173fdf1497d964940facca507a876bc2d3834893)+++ b/[drivers/scsi/libiscsi.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/scsi/libiscsi.c?id=d04958a348e560938410e04a12fb99da9c7e6a00)@@ -230,11 +230,11 @@ static int iscsi\_prep\_ecdb\_ahs(struct iscsi\_task \*task) \*/ static int iscsi\_check\_tmf\_restrictions(struct iscsi\_task \*task, int opcode) {- struct iscsi\_conn \*conn = task->conn;- struct iscsi\_tm \*tmf = &conn->tmhdr;+ struct iscsi\_session \*session = task->conn->session;+ struct iscsi\_tm \*tmf = &session->tmhdr; u64 hdr\_lun; - if (conn->tmf\_state == TMF\_INITIAL)+ if (session->tmf\_state == TMF\_INITIAL) return 0;  if ((tmf->opcode & ISCSI\_OPCODE\_MASK) != ISCSI\_OP\_SCSI\_TMFUNC)@@ -254,24 +254,19 @@ static int iscsi\_check\_tmf\_restrictions(struct iscsi\_task \*task, int opcode) \* Fail all SCSI cmd PDUs \*/ if (opcode != ISCSI\_OP\_SCSI\_DATA\_OUT) {- iscsi\_conn\_printk(KERN\_INFO, conn,- "task [op %x itt "- "0x%x/0x%x] "- "rejected.\n",- opcode, task->itt,- task->hdr\_itt);+ iscsi\_session\_printk(KERN\_INFO, session,+ "task [op %x itt 0x%x/0x%x] rejected.\n",+ opcode, task->itt, task->hdr\_itt); return -EACCES; } /\* \* And also all data-out PDUs in response to R2T \* if fast\_abort is set. \*/- if (conn->session->fast\_abort) {- iscsi\_conn\_printk(KERN\_INFO, conn,- "task [op %x itt "- "0x%x/0x%x] fast abort.\n",- opcode, task->itt,- task->hdr\_itt);+ if (session->fast\_abort) {+ iscsi\_session\_printk(KERN\_INFO, session,+ "task [op %x itt 0x%x/0x%x] fast abort.\n",+ opcode, task->itt, task->hdr\_itt); return -EACCES; } break;@@ -284,7 +279,7 @@ static int iscsi\_check\_tmf\_restrictions(struct iscsi\_task \*task, int opcode) \*/ if (opcode == ISCSI\_OP\_SCSI\_DATA\_OUT && task->hdr\_itt == tmf->rtt) {- ISCSI\_DBG\_SESSION(conn->session,+ ISCSI\_DBG\_SESSION(session, "Preventing task %x/%x from sending " "data-out due to abort task in " "progress\n", task->itt,@@ -923,20 +918,21 @@ iscsi\_data\_in\_rsp(struct iscsi\_conn \*conn, struct iscsi\_hdr \*hdr, static void iscsi\_tmf\_rsp(struct iscsi\_conn \*conn, struct iscsi\_hdr \*hdr) { struct iscsi\_tm\_rsp \*tmf = (struct iscsi\_tm\_rsp \*)hdr;+ struct iscsi\_session \*session = conn->session;  conn->exp\_statsn = be32\_to\_cpu(hdr->statsn) + 1; conn->tmfrsp\_pdus\_cnt++; - if (conn->tmf\_state != TMF\_QUEUED)+ if (session->tmf\_state != TMF\_QUEUED) return;  if (tmf->response == ISCSI\_TMF\_RSP\_COMPLETE)- conn->tmf\_state = TMF\_SUCCESS;+ session->tmf\_state = TMF\_SUCCESS; else if (tmf->response == ISCSI\_TMF\_RSP\_NO\_TASK)- conn->tmf\_state = TMF\_NOT\_FOUND;+ session->tmf\_state = TMF\_NOT\_FOUND; else- conn->tmf\_state = TMF\_FAILED;- wake\_up(&conn->ehwait);+ session->tmf\_state = TMF\_FAILED;+ wake\_up(&session->ehwait); }  static int iscsi\_send\_nopout(struct iscsi\_conn \*conn, struct iscsi\_nopin \*rhdr)@@ -1784,15 +1780,14 @@ EXPORT\_SYMBOL\_GPL(iscsi\_target\_alloc);  static void iscsi\_tmf\_timedout(struct timer\_list \*t) {- struct iscsi\_conn \*conn = from\_timer(conn, t, tmf\_timer);- struct iscsi\_session \*session = conn->session;+ struct iscsi\_session \*session = from\_timer(session, t, tmf\_timer);  spin\_lock(&session->frwd\_lock);- if (conn->tmf\_state == TMF\_QUEUED) {- conn->tmf\_state = TMF\_TIMEDOUT;+ if (session->tmf\_state == TMF\_QUEUED) {+ session->tmf\_state = TMF\_TIMEDOUT; ISCSI\_DBG\_EH(session, "tmf timedout\n"); /\* unblock eh\_abort() \*/- wake\_up(&conn->ehwait);+ wake\_up(&session->ehwait); } spin\_unlock(&session->frwd\_lock); }@@ -1815,8 +1810,8 @@ static int iscsi\_exec\_task\_mgmt\_fn(struct iscsi\_conn \*conn, return -EPERM; } conn->tmfcmd\_pdus\_cnt++;- conn->tmf\_timer.expires = timeout \* HZ + jiffies;- add\_timer(&conn->tmf\_timer);+ session->tmf\_timer.expires = timeout \* HZ + jiffies;+ add\_timer(&session->tmf\_timer); ISCSI\_DBG\_EH(session, "tmf set timeout\n");  spin\_unlock\_bh(&session->frwd\_lock);@@ -1830,12 +1825,12 @@ static int iscsi\_exec\_task\_mgmt\_fn(struct iscsi\_conn \*conn, \* 3) session is terminated or restarted or userspace has \* given up on recovery \*/- wait\_event\_interruptible(conn->ehwait, age != session->age ||+ wait\_event\_interruptible(session->ehwait, age != session->age || session->state != ISCSI\_STATE\_LOGGED\_IN ||- conn->tmf\_state != TMF\_QUEUED);+ session->tmf\_state != TMF\_QUEUED); if (signal\_pending(current)) flush\_signals(current);- del\_timer\_sync(&conn->tmf\_timer);+ del\_timer\_sync(&session->tmf\_timer);  mutex\_lock(&session->eh\_mutex); spin\_lock\_bh(&session->frwd\_lock);@@ -2195,17 +2190,17 @@ int iscsi\_eh\_abort(struct scsi\_cmnd \*sc) }  /\* only have one tmf outstanding at a time \*/- if (conn->tmf\_state != TMF\_INITIAL)+ if (session->tmf\_state != TMF\_INITIAL) goto failed;- conn->tmf\_state = TMF\_QUEUED;+ session->tmf\_state = TMF\_QUEUED; - hdr = &conn->tmhdr;+ hdr = &session->tmhdr; iscsi\_prep\_abort\_task\_pdu(task, hdr);  if (iscsi\_exec\_task\_mgmt\_fn(conn, hdr, age, session->abort\_timeout)) goto failed; - switch (conn->tmf\_state) {+ switch (session->tmf\_state) { case TMF\_SUCCESS: spin\_unlock\_bh(&session->frwd\_lock); /\*@@ -2220,7 +2215,7 @@ int iscsi\_eh\_abort(struct scsi\_cmnd \*sc) \*/ spin\_lock\_bh(&session->frwd\_lock); fail\_scsi\_task(task, DID\_ABORT);- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; memset(hdr, 0, sizeof(\*hdr)); spin\_unlock\_bh(&session->frwd\_lock); iscsi\_start\_tx(conn);@@ -2231,7 +2226,7 @@ int iscsi\_eh\_abort(struct scsi\_cmnd \*sc) goto failed\_unlocked; case TMF\_NOT\_FOUND: if (!sc->SCp.ptr) {- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; memset(hdr, 0, sizeof(\*hdr)); /\* task completed before tmf abort response \*/ ISCSI\_DBG\_EH(session, "sc completed while abort in "@@ -2240,7 +2235,7 @@ int iscsi\_eh\_abort(struct scsi\_cmnd \*sc) } /\* fall through \*/ default:- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; goto failed; } @@ -2297,11 +2292,11 @@ int iscsi\_eh\_device\_reset(struct scsi\_cmnd \*sc) conn = session->leadconn;  /\* only have one tmf outstanding at a time \*/- if (conn->tmf\_state != TMF\_INITIAL)+ if (session->tmf\_state != TMF\_INITIAL) goto unlock;- conn->tmf\_state = TMF\_QUEUED;+ session->tmf\_state = TMF\_QUEUED; - hdr = &conn->tmhdr;+ hdr = &session->tmhdr; iscsi\_prep\_lun\_reset\_pdu(sc, hdr);  if (iscsi\_exec\_task\_mgmt\_fn(conn, hdr, session->age,@@ -2310,7 +2305,7 @@ int iscsi\_eh\_device\_reset(struct scsi\_cmnd \*sc) goto unlock; } - switch (conn->tmf\_state) {+ switch (session->tmf\_state) { case TMF\_SUCCESS: break; case TMF\_TIMEDOUT:@@ -2318,7 +2313,7 @@ int iscsi\_eh\_device\_reset(struct scsi\_cmnd \*sc) iscsi\_conn\_failure(conn, ISCSI\_ERR\_SCSI\_EH\_SESSION\_RST); goto done; default:- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; goto unlock; } @@ -2330,7 +2325,7 @@ int iscsi\_eh\_device\_reset(struct scsi\_cmnd \*sc) spin\_lock\_bh(&session->frwd\_lock); memset(hdr, 0, sizeof(\*hdr)); fail\_scsi\_tasks(conn, sc->device->lun, DID\_ERROR);- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; spin\_unlock\_bh(&session->frwd\_lock);  iscsi\_start\_tx(conn);@@ -2353,8 +2348,7 @@ void iscsi\_session\_recovery\_timedout(struct iscsi\_cls\_session \*cls\_session) spin\_lock\_bh(&session->frwd\_lock); if (session->state != ISCSI\_STATE\_LOGGED\_IN) { session->state = ISCSI\_STATE\_RECOVERY\_FAILED;- if (session->leadconn)- wake\_up(&session->leadconn->ehwait);+ wake\_up(&session->ehwait); } spin\_unlock\_bh(&session->frwd\_lock); }@@ -2399,7 +2393,7 @@ failed: iscsi\_conn\_failure(conn, ISCSI\_ERR\_SCSI\_EH\_SESSION\_RST);  ISCSI\_DBG\_EH(session, "wait for relogin\n");- wait\_event\_interruptible(conn->ehwait,+ wait\_event\_interruptible(session->ehwait, session->state == ISCSI\_STATE\_TERMINATE || session->state == ISCSI\_STATE\_LOGGED\_IN || session->state == ISCSI\_STATE\_RECOVERY\_FAILED);@@ -2460,11 +2454,11 @@ static int iscsi\_eh\_target\_reset(struct scsi\_cmnd \*sc) conn = session->leadconn;  /\* only have one tmf outstanding at a time \*/- if (conn->tmf\_state != TMF\_INITIAL)+ if (session->tmf\_state != TMF\_INITIAL) goto unlock;- conn->tmf\_state = TMF\_QUEUED;+ session->tmf\_state = TMF\_QUEUED; - hdr = &conn->tmhdr;+ hdr = &session->tmhdr; iscsi\_prep\_tgt\_reset\_pdu(sc, hdr);  if (iscsi\_exec\_task\_mgmt\_fn(conn, hdr, session->age,@@ -2473,7 +2467,7 @@ static int iscsi\_eh\_target\_reset(struct scsi\_cmnd \*sc) goto unlock; } - switch (conn->tmf\_state) {+ switch (session->tmf\_state) { case TMF\_SUCCESS: break; case TMF\_TIMEDOUT:@@ -2481,7 +2475,7 @@ static int iscsi\_eh\_target\_reset(struct scsi\_cmnd \*sc) iscsi\_conn\_failure(conn, ISCSI\_ERR\_SCSI\_EH\_SESSION\_RST); goto done; default:- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; goto unlock; } @@ -2493,7 +2487,7 @@ static int iscsi\_eh\_target\_reset(struct scsi\_cmnd \*sc) spin\_lock\_bh(&session->frwd\_lock); memset(hdr, 0, sizeof(\*hdr)); fail\_scsi\_tasks(conn, -1, DID\_ERROR);- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; spin\_unlock\_bh(&session->frwd\_lock);  iscsi\_start\_tx(conn);@@ -2798,7 +2792,10 @@ iscsi\_session\_setup(struct iscsi\_transport \*iscsit, struct Scsi\_Host \*shost, session->tt = iscsit; session->dd\_data = cls\_session->dd\_data + sizeof(\*session); + session->tmf\_state = TMF\_INITIAL;+ timer\_setup(&session->tmf\_timer, iscsi\_tmf\_timedout, 0); mutex\_init(&session->eh\_mutex);+ spin\_lock\_init(&session->frwd\_lock); spin\_lock\_init(&session->back\_lock); @@ -2902,7 +2899,6 @@ iscsi\_conn\_setup(struct iscsi\_cls\_session \*cls\_session, int dd\_size, conn->c\_stage = ISCSI\_CONN\_INITIAL\_STAGE; conn->id = conn\_idx; conn->exp\_statsn = 0;- conn->tmf\_state = TMF\_INITIAL;  timer\_setup(&conn->transport\_timer, iscsi\_check\_transport\_timeouts, 0); @@ -2928,8 +2924,7 @@ iscsi\_conn\_setup(struct iscsi\_cls\_session \*cls\_session, int dd\_size, goto login\_task\_data\_alloc\_fail; conn->login\_task->data = conn->data = data; - timer\_setup(&conn->tmf\_timer, iscsi\_tmf\_timedout, 0);- init\_waitqueue\_head(&conn->ehwait);+ init\_waitqueue\_head(&session->ehwait);  return cls\_conn; @@ -2964,7 +2959,7 @@ void iscsi\_conn\_teardown(struct iscsi\_cls\_conn \*cls\_conn) \* leading connection? then give up on recovery. \*/ session->state = ISCSI\_STATE\_TERMINATE;- wake\_up(&conn->ehwait);+ wake\_up(&session->ehwait); } spin\_unlock\_bh(&session->frwd\_lock); @@ -3039,7 +3034,7 @@ int iscsi\_conn\_start(struct iscsi\_cls\_conn \*cls\_conn) \* commands after successful recovery \*/ conn->stop\_stage = 0;- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; session->age++; if (session->age == 16) session->age = 0;@@ -3053,7 +3048,7 @@ int iscsi\_conn\_start(struct iscsi\_cls\_conn \*cls\_conn) spin\_unlock\_bh(&session->frwd\_lock);  iscsi\_unblock\_session(session->cls\_session);- wake\_up(&conn->ehwait);+ wake\_up(&session->ehwait); return 0; } EXPORT\_SYMBOL\_GPL(iscsi\_conn\_start);@@ -3140,7 +3135,7 @@ static void iscsi\_start\_session\_recovery(struct iscsi\_session \*session, spin\_lock\_bh(&session->frwd\_lock); fail\_scsi\_tasks(conn, -1, DID\_TRANSPORT\_DISRUPTED); fail\_mgmt\_tasks(session, conn);- memset(&conn->tmhdr, 0, sizeof(conn->tmhdr));+ memset(&session->tmhdr, 0, sizeof(session->tmhdr)); spin\_unlock\_bh(&session->frwd\_lock); mutex\_unlock(&session->eh\_mutex); }diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.hindex b3bbd10eb3f079..2b5f97224f6936 100644--- a/[include/scsi/libiscsi.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/scsi/libiscsi.h?id=173fdf1497d964940facca507a876bc2d3834893)+++ b/[include/scsi/libiscsi.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/scsi/libiscsi.h?id=d04958a348e560938410e04a12fb99da9c7e6a00)@@ -195,12 +195,6 @@ struct iscsi\_conn { unsigned long suspend\_tx; /\* suspend Tx \*/ unsigned long suspend\_rx; /\* suspend Rx \*/ - /\* abort \*/- wait\_queue\_head\_t ehwait; /\* used in eh\_abort() \*/- struct iscsi\_tm tmhdr;- struct timer\_list tmf\_timer;- int tmf\_state; /\* see TMF\_INITIAL, etc.\*/- /\* negotiated params \*/ unsigned max\_recv\_dlength; /\* initiator\_max\_recv\_dsl\*/ unsigned max\_xmit\_dlength; /\* target\_max\_recv\_dsl \*/@@ -270,6 +264,11 @@ struct iscsi\_session { \* and recv lock. \*/ struct mutex eh\_mutex;+ /\* abort \*/+ wait\_queue\_head\_t ehwait; /\* used in eh\_abort() \*/+ struct iscsi\_tm tmhdr;+ struct timer\_list tmf\_timer;+ int tmf\_state; /\* see TMF\_INITIAL, etc.\*/  /\* iSCSI session-wide sequencing \*/ uint32\_t cmdsn; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 14:09:36 +0000



=== Content from git.kernel.org_46b7da65_20250110_141056.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=89812e7957ab0746eab66ed6fc49d52bb4dca250)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=89812e7957ab0746eab66ed6fc49d52bb4dca250)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=89812e7957ab0746eab66ed6fc49d52bb4dca250)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=89812e7957ab0746eab66ed6fc49d52bb4dca250)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Mike Christie <michael.christie@oracle.com> | 2021-05-25 13:18:06 -0500 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2021-07-20 16:05:41 +0200 |
| commit | [89812e7957ab0746eab66ed6fc49d52bb4dca250](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=89812e7957ab0746eab66ed6fc49d52bb4dca250) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=89812e7957ab0746eab66ed6fc49d52bb4dca250)) | |
| tree | [f54ffe1c9cd33d8565c78fd9bdeb04748b05af0c](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=89812e7957ab0746eab66ed6fc49d52bb4dca250) | |
| parent | [21962a5dd6b4021567a12f7b431217a0ee8323d8](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=21962a5dd6b4021567a12f7b431217a0ee8323d8) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=89812e7957ab0746eab66ed6fc49d52bb4dca250&id2=21962a5dd6b4021567a12f7b431217a0ee8323d8)) | |
| download | [linux-89812e7957ab0746eab66ed6fc49d52bb4dca250.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-89812e7957ab0746eab66ed6fc49d52bb4dca250.tar.gz) | |

scsi: iscsi: Fix conn use after free during resets[ Upstream commit ec29d0ac29be366450a7faffbcf8cba3a6a3b506 ]
If we haven't done a unbind target call we can race where
iscsi\_conn\_teardown wakes up the EH thread and then frees the conn while
those threads are still accessing the conn ehwait.
We can only do one TMF per session so this just moves the TMF fields from
the conn to the session. We can then rely on the
iscsi\_session\_teardown->iscsi\_remove\_session->\_\_iscsi\_unbind\_session call
to remove the target and it's devices, and know after that point there is
no device or scsi-ml callout trying to access the session.
Link: [https://lore.kernel.org/r/20210525181821.7617-14-michael.christie@oracle.com](https://lore.kernel.org/r/20210525181821.7617-14-michael.christie%40oracle.com)
Reviewed-by: Lee Duncan <lduncan@suse.com>
Signed-off-by: Mike Christie <michael.christie@oracle.com>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=89812e7957ab0746eab66ed6fc49d52bb4dca250)

| -rw-r--r-- | [drivers/scsi/libiscsi.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/scsi/libiscsi.c?id=89812e7957ab0746eab66ed6fc49d52bb4dca250) | 115 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/scsi/libiscsi.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/scsi/libiscsi.h?id=89812e7957ab0746eab66ed6fc49d52bb4dca250) | 11 | |  |  |  | | --- | --- | --- | |

2 files changed, 60 insertions, 66 deletions

| diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.cindex 8c65fc268a4072..30d27b67067464 100644--- a/[drivers/scsi/libiscsi.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/scsi/libiscsi.c?id=21962a5dd6b4021567a12f7b431217a0ee8323d8)+++ b/[drivers/scsi/libiscsi.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/scsi/libiscsi.c?id=89812e7957ab0746eab66ed6fc49d52bb4dca250)@@ -230,11 +230,11 @@ static int iscsi\_prep\_ecdb\_ahs(struct iscsi\_task \*task) \*/ static int iscsi\_check\_tmf\_restrictions(struct iscsi\_task \*task, int opcode) {- struct iscsi\_conn \*conn = task->conn;- struct iscsi\_tm \*tmf = &conn->tmhdr;+ struct iscsi\_session \*session = task->conn->session;+ struct iscsi\_tm \*tmf = &session->tmhdr; u64 hdr\_lun; - if (conn->tmf\_state == TMF\_INITIAL)+ if (session->tmf\_state == TMF\_INITIAL) return 0;  if ((tmf->opcode & ISCSI\_OPCODE\_MASK) != ISCSI\_OP\_SCSI\_TMFUNC)@@ -254,24 +254,19 @@ static int iscsi\_check\_tmf\_restrictions(struct iscsi\_task \*task, int opcode) \* Fail all SCSI cmd PDUs \*/ if (opcode != ISCSI\_OP\_SCSI\_DATA\_OUT) {- iscsi\_conn\_printk(KERN\_INFO, conn,- "task [op %x itt "- "0x%x/0x%x] "- "rejected.\n",- opcode, task->itt,- task->hdr\_itt);+ iscsi\_session\_printk(KERN\_INFO, session,+ "task [op %x itt 0x%x/0x%x] rejected.\n",+ opcode, task->itt, task->hdr\_itt); return -EACCES; } /\* \* And also all data-out PDUs in response to R2T \* if fast\_abort is set. \*/- if (conn->session->fast\_abort) {- iscsi\_conn\_printk(KERN\_INFO, conn,- "task [op %x itt "- "0x%x/0x%x] fast abort.\n",- opcode, task->itt,- task->hdr\_itt);+ if (session->fast\_abort) {+ iscsi\_session\_printk(KERN\_INFO, session,+ "task [op %x itt 0x%x/0x%x] fast abort.\n",+ opcode, task->itt, task->hdr\_itt); return -EACCES; } break;@@ -284,7 +279,7 @@ static int iscsi\_check\_tmf\_restrictions(struct iscsi\_task \*task, int opcode) \*/ if (opcode == ISCSI\_OP\_SCSI\_DATA\_OUT && task->hdr\_itt == tmf->rtt) {- ISCSI\_DBG\_SESSION(conn->session,+ ISCSI\_DBG\_SESSION(session, "Preventing task %x/%x from sending " "data-out due to abort task in " "progress\n", task->itt,@@ -923,20 +918,21 @@ iscsi\_data\_in\_rsp(struct iscsi\_conn \*conn, struct iscsi\_hdr \*hdr, static void iscsi\_tmf\_rsp(struct iscsi\_conn \*conn, struct iscsi\_hdr \*hdr) { struct iscsi\_tm\_rsp \*tmf = (struct iscsi\_tm\_rsp \*)hdr;+ struct iscsi\_session \*session = conn->session;  conn->exp\_statsn = be32\_to\_cpu(hdr->statsn) + 1; conn->tmfrsp\_pdus\_cnt++; - if (conn->tmf\_state != TMF\_QUEUED)+ if (session->tmf\_state != TMF\_QUEUED) return;  if (tmf->response == ISCSI\_TMF\_RSP\_COMPLETE)- conn->tmf\_state = TMF\_SUCCESS;+ session->tmf\_state = TMF\_SUCCESS; else if (tmf->response == ISCSI\_TMF\_RSP\_NO\_TASK)- conn->tmf\_state = TMF\_NOT\_FOUND;+ session->tmf\_state = TMF\_NOT\_FOUND; else- conn->tmf\_state = TMF\_FAILED;- wake\_up(&conn->ehwait);+ session->tmf\_state = TMF\_FAILED;+ wake\_up(&session->ehwait); }  static int iscsi\_send\_nopout(struct iscsi\_conn \*conn, struct iscsi\_nopin \*rhdr)@@ -1784,15 +1780,14 @@ EXPORT\_SYMBOL\_GPL(iscsi\_target\_alloc);  static void iscsi\_tmf\_timedout(struct timer\_list \*t) {- struct iscsi\_conn \*conn = from\_timer(conn, t, tmf\_timer);- struct iscsi\_session \*session = conn->session;+ struct iscsi\_session \*session = from\_timer(session, t, tmf\_timer);  spin\_lock(&session->frwd\_lock);- if (conn->tmf\_state == TMF\_QUEUED) {- conn->tmf\_state = TMF\_TIMEDOUT;+ if (session->tmf\_state == TMF\_QUEUED) {+ session->tmf\_state = TMF\_TIMEDOUT; ISCSI\_DBG\_EH(session, "tmf timedout\n"); /\* unblock eh\_abort() \*/- wake\_up(&conn->ehwait);+ wake\_up(&session->ehwait); } spin\_unlock(&session->frwd\_lock); }@@ -1815,8 +1810,8 @@ static int iscsi\_exec\_task\_mgmt\_fn(struct iscsi\_conn \*conn, return -EPERM; } conn->tmfcmd\_pdus\_cnt++;- conn->tmf\_timer.expires = timeout \* HZ + jiffies;- add\_timer(&conn->tmf\_timer);+ session->tmf\_timer.expires = timeout \* HZ + jiffies;+ add\_timer(&session->tmf\_timer); ISCSI\_DBG\_EH(session, "tmf set timeout\n");  spin\_unlock\_bh(&session->frwd\_lock);@@ -1830,12 +1825,12 @@ static int iscsi\_exec\_task\_mgmt\_fn(struct iscsi\_conn \*conn, \* 3) session is terminated or restarted or userspace has \* given up on recovery \*/- wait\_event\_interruptible(conn->ehwait, age != session->age ||+ wait\_event\_interruptible(session->ehwait, age != session->age || session->state != ISCSI\_STATE\_LOGGED\_IN ||- conn->tmf\_state != TMF\_QUEUED);+ session->tmf\_state != TMF\_QUEUED); if (signal\_pending(current)) flush\_signals(current);- del\_timer\_sync(&conn->tmf\_timer);+ del\_timer\_sync(&session->tmf\_timer);  mutex\_lock(&session->eh\_mutex); spin\_lock\_bh(&session->frwd\_lock);@@ -2195,17 +2190,17 @@ int iscsi\_eh\_abort(struct scsi\_cmnd \*sc) }  /\* only have one tmf outstanding at a time \*/- if (conn->tmf\_state != TMF\_INITIAL)+ if (session->tmf\_state != TMF\_INITIAL) goto failed;- conn->tmf\_state = TMF\_QUEUED;+ session->tmf\_state = TMF\_QUEUED; - hdr = &conn->tmhdr;+ hdr = &session->tmhdr; iscsi\_prep\_abort\_task\_pdu(task, hdr);  if (iscsi\_exec\_task\_mgmt\_fn(conn, hdr, age, session->abort\_timeout)) goto failed; - switch (conn->tmf\_state) {+ switch (session->tmf\_state) { case TMF\_SUCCESS: spin\_unlock\_bh(&session->frwd\_lock); /\*@@ -2220,7 +2215,7 @@ int iscsi\_eh\_abort(struct scsi\_cmnd \*sc) \*/ spin\_lock\_bh(&session->frwd\_lock); fail\_scsi\_task(task, DID\_ABORT);- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; memset(hdr, 0, sizeof(\*hdr)); spin\_unlock\_bh(&session->frwd\_lock); iscsi\_start\_tx(conn);@@ -2231,7 +2226,7 @@ int iscsi\_eh\_abort(struct scsi\_cmnd \*sc) goto failed\_unlocked; case TMF\_NOT\_FOUND: if (!sc->SCp.ptr) {- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; memset(hdr, 0, sizeof(\*hdr)); /\* task completed before tmf abort response \*/ ISCSI\_DBG\_EH(session, "sc completed while abort in "@@ -2240,7 +2235,7 @@ int iscsi\_eh\_abort(struct scsi\_cmnd \*sc) } fallthrough; default:- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; goto failed; } @@ -2297,11 +2292,11 @@ int iscsi\_eh\_device\_reset(struct scsi\_cmnd \*sc) conn = session->leadconn;  /\* only have one tmf outstanding at a time \*/- if (conn->tmf\_state != TMF\_INITIAL)+ if (session->tmf\_state != TMF\_INITIAL) goto unlock;- conn->tmf\_state = TMF\_QUEUED;+ session->tmf\_state = TMF\_QUEUED; - hdr = &conn->tmhdr;+ hdr = &session->tmhdr; iscsi\_prep\_lun\_reset\_pdu(sc, hdr);  if (iscsi\_exec\_task\_mgmt\_fn(conn, hdr, session->age,@@ -2310,7 +2305,7 @@ int iscsi\_eh\_device\_reset(struct scsi\_cmnd \*sc) goto unlock; } - switch (conn->tmf\_state) {+ switch (session->tmf\_state) { case TMF\_SUCCESS: break; case TMF\_TIMEDOUT:@@ -2318,7 +2313,7 @@ int iscsi\_eh\_device\_reset(struct scsi\_cmnd \*sc) iscsi\_conn\_failure(conn, ISCSI\_ERR\_SCSI\_EH\_SESSION\_RST); goto done; default:- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; goto unlock; } @@ -2330,7 +2325,7 @@ int iscsi\_eh\_device\_reset(struct scsi\_cmnd \*sc) spin\_lock\_bh(&session->frwd\_lock); memset(hdr, 0, sizeof(\*hdr)); fail\_scsi\_tasks(conn, sc->device->lun, DID\_ERROR);- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; spin\_unlock\_bh(&session->frwd\_lock);  iscsi\_start\_tx(conn);@@ -2353,8 +2348,7 @@ void iscsi\_session\_recovery\_timedout(struct iscsi\_cls\_session \*cls\_session) spin\_lock\_bh(&session->frwd\_lock); if (session->state != ISCSI\_STATE\_LOGGED\_IN) { session->state = ISCSI\_STATE\_RECOVERY\_FAILED;- if (session->leadconn)- wake\_up(&session->leadconn->ehwait);+ wake\_up(&session->ehwait); } spin\_unlock\_bh(&session->frwd\_lock); }@@ -2399,7 +2393,7 @@ failed: iscsi\_conn\_failure(conn, ISCSI\_ERR\_SCSI\_EH\_SESSION\_RST);  ISCSI\_DBG\_EH(session, "wait for relogin\n");- wait\_event\_interruptible(conn->ehwait,+ wait\_event\_interruptible(session->ehwait, session->state == ISCSI\_STATE\_TERMINATE || session->state == ISCSI\_STATE\_LOGGED\_IN || session->state == ISCSI\_STATE\_RECOVERY\_FAILED);@@ -2460,11 +2454,11 @@ static int iscsi\_eh\_target\_reset(struct scsi\_cmnd \*sc) conn = session->leadconn;  /\* only have one tmf outstanding at a time \*/- if (conn->tmf\_state != TMF\_INITIAL)+ if (session->tmf\_state != TMF\_INITIAL) goto unlock;- conn->tmf\_state = TMF\_QUEUED;+ session->tmf\_state = TMF\_QUEUED; - hdr = &conn->tmhdr;+ hdr = &session->tmhdr; iscsi\_prep\_tgt\_reset\_pdu(sc, hdr);  if (iscsi\_exec\_task\_mgmt\_fn(conn, hdr, session->age,@@ -2473,7 +2467,7 @@ static int iscsi\_eh\_target\_reset(struct scsi\_cmnd \*sc) goto unlock; } - switch (conn->tmf\_state) {+ switch (session->tmf\_state) { case TMF\_SUCCESS: break; case TMF\_TIMEDOUT:@@ -2481,7 +2475,7 @@ static int iscsi\_eh\_target\_reset(struct scsi\_cmnd \*sc) iscsi\_conn\_failure(conn, ISCSI\_ERR\_SCSI\_EH\_SESSION\_RST); goto done; default:- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; goto unlock; } @@ -2493,7 +2487,7 @@ static int iscsi\_eh\_target\_reset(struct scsi\_cmnd \*sc) spin\_lock\_bh(&session->frwd\_lock); memset(hdr, 0, sizeof(\*hdr)); fail\_scsi\_tasks(conn, -1, DID\_ERROR);- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; spin\_unlock\_bh(&session->frwd\_lock);  iscsi\_start\_tx(conn);@@ -2800,7 +2794,10 @@ iscsi\_session\_setup(struct iscsi\_transport \*iscsit, struct Scsi\_Host \*shost, session->tt = iscsit; session->dd\_data = cls\_session->dd\_data + sizeof(\*session); + session->tmf\_state = TMF\_INITIAL;+ timer\_setup(&session->tmf\_timer, iscsi\_tmf\_timedout, 0); mutex\_init(&session->eh\_mutex);+ spin\_lock\_init(&session->frwd\_lock); spin\_lock\_init(&session->back\_lock); @@ -2904,7 +2901,6 @@ iscsi\_conn\_setup(struct iscsi\_cls\_session \*cls\_session, int dd\_size, conn->c\_stage = ISCSI\_CONN\_INITIAL\_STAGE; conn->id = conn\_idx; conn->exp\_statsn = 0;- conn->tmf\_state = TMF\_INITIAL;  timer\_setup(&conn->transport\_timer, iscsi\_check\_transport\_timeouts, 0); @@ -2930,8 +2926,7 @@ iscsi\_conn\_setup(struct iscsi\_cls\_session \*cls\_session, int dd\_size, goto login\_task\_data\_alloc\_fail; conn->login\_task->data = conn->data = data; - timer\_setup(&conn->tmf\_timer, iscsi\_tmf\_timedout, 0);- init\_waitqueue\_head(&conn->ehwait);+ init\_waitqueue\_head(&session->ehwait);  return cls\_conn; @@ -2966,7 +2961,7 @@ void iscsi\_conn\_teardown(struct iscsi\_cls\_conn \*cls\_conn) \* leading connection? then give up on recovery. \*/ session->state = ISCSI\_STATE\_TERMINATE;- wake\_up(&conn->ehwait);+ wake\_up(&session->ehwait); } spin\_unlock\_bh(&session->frwd\_lock); @@ -3041,7 +3036,7 @@ int iscsi\_conn\_start(struct iscsi\_cls\_conn \*cls\_conn) \* commands after successful recovery \*/ conn->stop\_stage = 0;- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; session->age++; if (session->age == 16) session->age = 0;@@ -3055,7 +3050,7 @@ int iscsi\_conn\_start(struct iscsi\_cls\_conn \*cls\_conn) spin\_unlock\_bh(&session->frwd\_lock);  iscsi\_unblock\_session(session->cls\_session);- wake\_up(&conn->ehwait);+ wake\_up(&session->ehwait); return 0; } EXPORT\_SYMBOL\_GPL(iscsi\_conn\_start);@@ -3143,7 +3138,7 @@ void iscsi\_conn\_stop(struct iscsi\_cls\_conn \*cls\_conn, int flag) spin\_lock\_bh(&session->frwd\_lock); fail\_scsi\_tasks(conn, -1, DID\_TRANSPORT\_DISRUPTED); fail\_mgmt\_tasks(session, conn);- memset(&conn->tmhdr, 0, sizeof(conn->tmhdr));+ memset(&session->tmhdr, 0, sizeof(session->tmhdr)); spin\_unlock\_bh(&session->frwd\_lock); mutex\_unlock(&session->eh\_mutex); }diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.hindex b3bbd10eb3f079..2b5f97224f6936 100644--- a/[include/scsi/libiscsi.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/scsi/libiscsi.h?id=21962a5dd6b4021567a12f7b431217a0ee8323d8)+++ b/[include/scsi/libiscsi.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/scsi/libiscsi.h?id=89812e7957ab0746eab66ed6fc49d52bb4dca250)@@ -195,12 +195,6 @@ struct iscsi\_conn { unsigned long suspend\_tx; /\* suspend Tx \*/ unsigned long suspend\_rx; /\* suspend Rx \*/ - /\* abort \*/- wait\_queue\_head\_t ehwait; /\* used in eh\_abort() \*/- struct iscsi\_tm tmhdr;- struct timer\_list tmf\_timer;- int tmf\_state; /\* see TMF\_INITIAL, etc.\*/- /\* negotiated params \*/ unsigned max\_recv\_dlength; /\* initiator\_max\_recv\_dsl\*/ unsigned max\_xmit\_dlength; /\* target\_max\_recv\_dsl \*/@@ -270,6 +264,11 @@ struct iscsi\_session { \* and recv lock. \*/ struct mutex eh\_mutex;+ /\* abort \*/+ wait\_queue\_head\_t ehwait; /\* used in eh\_abort() \*/+ struct iscsi\_tm tmhdr;+ struct timer\_list tmf\_timer;+ int tmf\_state; /\* see TMF\_INITIAL, etc.\*/  /\* iSCSI session-wide sequencing \*/ uint32\_t cmdsn; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 14:09:33 +0000



=== Content from git.kernel.org_3d8c894a_20250110_141057.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=bf20d85a88384574fabb3d53ad62a8af57e7ab11)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=bf20d85a88384574fabb3d53ad62a8af57e7ab11)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=bf20d85a88384574fabb3d53ad62a8af57e7ab11)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=bf20d85a88384574fabb3d53ad62a8af57e7ab11)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Mike Christie <michael.christie@oracle.com> | 2021-05-25 13:18:06 -0500 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2021-07-20 16:16:08 +0200 |
| commit | [bf20d85a88384574fabb3d53ad62a8af57e7ab11](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=bf20d85a88384574fabb3d53ad62a8af57e7ab11) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=bf20d85a88384574fabb3d53ad62a8af57e7ab11)) | |
| tree | [ed727a953efcec99b5be952a51a0f844f4cfca17](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=bf20d85a88384574fabb3d53ad62a8af57e7ab11) | |
| parent | [8d3f5e3b4ebe1e4cdc9f6d79dd24e77aa8007efb](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=8d3f5e3b4ebe1e4cdc9f6d79dd24e77aa8007efb) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=bf20d85a88384574fabb3d53ad62a8af57e7ab11&id2=8d3f5e3b4ebe1e4cdc9f6d79dd24e77aa8007efb)) | |
| download | [linux-bf20d85a88384574fabb3d53ad62a8af57e7ab11.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-bf20d85a88384574fabb3d53ad62a8af57e7ab11.tar.gz) | |

scsi: iscsi: Fix conn use after free during resets[ Upstream commit ec29d0ac29be366450a7faffbcf8cba3a6a3b506 ]
If we haven't done a unbind target call we can race where
iscsi\_conn\_teardown wakes up the EH thread and then frees the conn while
those threads are still accessing the conn ehwait.
We can only do one TMF per session so this just moves the TMF fields from
the conn to the session. We can then rely on the
iscsi\_session\_teardown->iscsi\_remove\_session->\_\_iscsi\_unbind\_session call
to remove the target and it's devices, and know after that point there is
no device or scsi-ml callout trying to access the session.
Link: [https://lore.kernel.org/r/20210525181821.7617-14-michael.christie@oracle.com](https://lore.kernel.org/r/20210525181821.7617-14-michael.christie%40oracle.com)
Reviewed-by: Lee Duncan <lduncan@suse.com>
Signed-off-by: Mike Christie <michael.christie@oracle.com>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=bf20d85a88384574fabb3d53ad62a8af57e7ab11)

| -rw-r--r-- | [drivers/scsi/libiscsi.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/scsi/libiscsi.c?id=bf20d85a88384574fabb3d53ad62a8af57e7ab11) | 115 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/scsi/libiscsi.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/scsi/libiscsi.h?id=bf20d85a88384574fabb3d53ad62a8af57e7ab11) | 11 | |  |  |  | | --- | --- | --- | |

2 files changed, 60 insertions, 66 deletions

| diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.cindex 52521b68f0a7e2..5607fe8541c3ad 100644--- a/[drivers/scsi/libiscsi.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/scsi/libiscsi.c?id=8d3f5e3b4ebe1e4cdc9f6d79dd24e77aa8007efb)+++ b/[drivers/scsi/libiscsi.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/scsi/libiscsi.c?id=bf20d85a88384574fabb3d53ad62a8af57e7ab11)@@ -259,11 +259,11 @@ static int iscsi\_prep\_bidi\_ahs(struct iscsi\_task \*task) \*/ static int iscsi\_check\_tmf\_restrictions(struct iscsi\_task \*task, int opcode) {- struct iscsi\_conn \*conn = task->conn;- struct iscsi\_tm \*tmf = &conn->tmhdr;+ struct iscsi\_session \*session = task->conn->session;+ struct iscsi\_tm \*tmf = &session->tmhdr; u64 hdr\_lun; - if (conn->tmf\_state == TMF\_INITIAL)+ if (session->tmf\_state == TMF\_INITIAL) return 0;  if ((tmf->opcode & ISCSI\_OPCODE\_MASK) != ISCSI\_OP\_SCSI\_TMFUNC)@@ -283,24 +283,19 @@ static int iscsi\_check\_tmf\_restrictions(struct iscsi\_task \*task, int opcode) \* Fail all SCSI cmd PDUs \*/ if (opcode != ISCSI\_OP\_SCSI\_DATA\_OUT) {- iscsi\_conn\_printk(KERN\_INFO, conn,- "task [op %x itt "- "0x%x/0x%x] "- "rejected.\n",- opcode, task->itt,- task->hdr\_itt);+ iscsi\_session\_printk(KERN\_INFO, session,+ "task [op %x itt 0x%x/0x%x] rejected.\n",+ opcode, task->itt, task->hdr\_itt); return -EACCES; } /\* \* And also all data-out PDUs in response to R2T \* if fast\_abort is set. \*/- if (conn->session->fast\_abort) {- iscsi\_conn\_printk(KERN\_INFO, conn,- "task [op %x itt "- "0x%x/0x%x] fast abort.\n",- opcode, task->itt,- task->hdr\_itt);+ if (session->fast\_abort) {+ iscsi\_session\_printk(KERN\_INFO, session,+ "task [op %x itt 0x%x/0x%x] fast abort.\n",+ opcode, task->itt, task->hdr\_itt); return -EACCES; } break;@@ -313,7 +308,7 @@ static int iscsi\_check\_tmf\_restrictions(struct iscsi\_task \*task, int opcode) \*/ if (opcode == ISCSI\_OP\_SCSI\_DATA\_OUT && task->hdr\_itt == tmf->rtt) {- ISCSI\_DBG\_SESSION(conn->session,+ ISCSI\_DBG\_SESSION(session, "Preventing task %x/%x from sending " "data-out due to abort task in " "progress\n", task->itt,@@ -970,20 +965,21 @@ iscsi\_data\_in\_rsp(struct iscsi\_conn \*conn, struct iscsi\_hdr \*hdr, static void iscsi\_tmf\_rsp(struct iscsi\_conn \*conn, struct iscsi\_hdr \*hdr) { struct iscsi\_tm\_rsp \*tmf = (struct iscsi\_tm\_rsp \*)hdr;+ struct iscsi\_session \*session = conn->session;  conn->exp\_statsn = be32\_to\_cpu(hdr->statsn) + 1; conn->tmfrsp\_pdus\_cnt++; - if (conn->tmf\_state != TMF\_QUEUED)+ if (session->tmf\_state != TMF\_QUEUED) return;  if (tmf->response == ISCSI\_TMF\_RSP\_COMPLETE)- conn->tmf\_state = TMF\_SUCCESS;+ session->tmf\_state = TMF\_SUCCESS; else if (tmf->response == ISCSI\_TMF\_RSP\_NO\_TASK)- conn->tmf\_state = TMF\_NOT\_FOUND;+ session->tmf\_state = TMF\_NOT\_FOUND; else- conn->tmf\_state = TMF\_FAILED;- wake\_up(&conn->ehwait);+ session->tmf\_state = TMF\_FAILED;+ wake\_up(&session->ehwait); }  static int iscsi\_send\_nopout(struct iscsi\_conn \*conn, struct iscsi\_nopin \*rhdr)@@ -1822,15 +1818,14 @@ EXPORT\_SYMBOL\_GPL(iscsi\_target\_alloc);  static void iscsi\_tmf\_timedout(struct timer\_list \*t) {- struct iscsi\_conn \*conn = from\_timer(conn, t, tmf\_timer);- struct iscsi\_session \*session = conn->session;+ struct iscsi\_session \*session = from\_timer(session, t, tmf\_timer);  spin\_lock(&session->frwd\_lock);- if (conn->tmf\_state == TMF\_QUEUED) {- conn->tmf\_state = TMF\_TIMEDOUT;+ if (session->tmf\_state == TMF\_QUEUED) {+ session->tmf\_state = TMF\_TIMEDOUT; ISCSI\_DBG\_EH(session, "tmf timedout\n"); /\* unblock eh\_abort() \*/- wake\_up(&conn->ehwait);+ wake\_up(&session->ehwait); } spin\_unlock(&session->frwd\_lock); }@@ -1853,8 +1848,8 @@ static int iscsi\_exec\_task\_mgmt\_fn(struct iscsi\_conn \*conn, return -EPERM; } conn->tmfcmd\_pdus\_cnt++;- conn->tmf\_timer.expires = timeout \* HZ + jiffies;- add\_timer(&conn->tmf\_timer);+ session->tmf\_timer.expires = timeout \* HZ + jiffies;+ add\_timer(&session->tmf\_timer); ISCSI\_DBG\_EH(session, "tmf set timeout\n");  spin\_unlock\_bh(&session->frwd\_lock);@@ -1868,12 +1863,12 @@ static int iscsi\_exec\_task\_mgmt\_fn(struct iscsi\_conn \*conn, \* 3) session is terminated or restarted or userspace has \* given up on recovery \*/- wait\_event\_interruptible(conn->ehwait, age != session->age ||+ wait\_event\_interruptible(session->ehwait, age != session->age || session->state != ISCSI\_STATE\_LOGGED\_IN ||- conn->tmf\_state != TMF\_QUEUED);+ session->tmf\_state != TMF\_QUEUED); if (signal\_pending(current)) flush\_signals(current);- del\_timer\_sync(&conn->tmf\_timer);+ del\_timer\_sync(&session->tmf\_timer);  mutex\_lock(&session->eh\_mutex); spin\_lock\_bh(&session->frwd\_lock);@@ -2233,17 +2228,17 @@ int iscsi\_eh\_abort(struct scsi\_cmnd \*sc) }  /\* only have one tmf outstanding at a time \*/- if (conn->tmf\_state != TMF\_INITIAL)+ if (session->tmf\_state != TMF\_INITIAL) goto failed;- conn->tmf\_state = TMF\_QUEUED;+ session->tmf\_state = TMF\_QUEUED; - hdr = &conn->tmhdr;+ hdr = &session->tmhdr; iscsi\_prep\_abort\_task\_pdu(task, hdr);  if (iscsi\_exec\_task\_mgmt\_fn(conn, hdr, age, session->abort\_timeout)) goto failed; - switch (conn->tmf\_state) {+ switch (session->tmf\_state) { case TMF\_SUCCESS: spin\_unlock\_bh(&session->frwd\_lock); /\*@@ -2258,7 +2253,7 @@ int iscsi\_eh\_abort(struct scsi\_cmnd \*sc) \*/ spin\_lock\_bh(&session->frwd\_lock); fail\_scsi\_task(task, DID\_ABORT);- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; memset(hdr, 0, sizeof(\*hdr)); spin\_unlock\_bh(&session->frwd\_lock); iscsi\_start\_tx(conn);@@ -2269,7 +2264,7 @@ int iscsi\_eh\_abort(struct scsi\_cmnd \*sc) goto failed\_unlocked; case TMF\_NOT\_FOUND: if (!sc->SCp.ptr) {- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; memset(hdr, 0, sizeof(\*hdr)); /\* task completed before tmf abort response \*/ ISCSI\_DBG\_EH(session, "sc completed while abort in "@@ -2278,7 +2273,7 @@ int iscsi\_eh\_abort(struct scsi\_cmnd \*sc) } /\* fall through \*/ default:- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; goto failed; } @@ -2335,11 +2330,11 @@ int iscsi\_eh\_device\_reset(struct scsi\_cmnd \*sc) conn = session->leadconn;  /\* only have one tmf outstanding at a time \*/- if (conn->tmf\_state != TMF\_INITIAL)+ if (session->tmf\_state != TMF\_INITIAL) goto unlock;- conn->tmf\_state = TMF\_QUEUED;+ session->tmf\_state = TMF\_QUEUED; - hdr = &conn->tmhdr;+ hdr = &session->tmhdr; iscsi\_prep\_lun\_reset\_pdu(sc, hdr);  if (iscsi\_exec\_task\_mgmt\_fn(conn, hdr, session->age,@@ -2348,7 +2343,7 @@ int iscsi\_eh\_device\_reset(struct scsi\_cmnd \*sc) goto unlock; } - switch (conn->tmf\_state) {+ switch (session->tmf\_state) { case TMF\_SUCCESS: break; case TMF\_TIMEDOUT:@@ -2356,7 +2351,7 @@ int iscsi\_eh\_device\_reset(struct scsi\_cmnd \*sc) iscsi\_conn\_failure(conn, ISCSI\_ERR\_SCSI\_EH\_SESSION\_RST); goto done; default:- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; goto unlock; } @@ -2368,7 +2363,7 @@ int iscsi\_eh\_device\_reset(struct scsi\_cmnd \*sc) spin\_lock\_bh(&session->frwd\_lock); memset(hdr, 0, sizeof(\*hdr)); fail\_scsi\_tasks(conn, sc->device->lun, DID\_ERROR);- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; spin\_unlock\_bh(&session->frwd\_lock);  iscsi\_start\_tx(conn);@@ -2391,8 +2386,7 @@ void iscsi\_session\_recovery\_timedout(struct iscsi\_cls\_session \*cls\_session) spin\_lock\_bh(&session->frwd\_lock); if (session->state != ISCSI\_STATE\_LOGGED\_IN) { session->state = ISCSI\_STATE\_RECOVERY\_FAILED;- if (session->leadconn)- wake\_up(&session->leadconn->ehwait);+ wake\_up(&session->ehwait); } spin\_unlock\_bh(&session->frwd\_lock); }@@ -2437,7 +2431,7 @@ failed: iscsi\_conn\_failure(conn, ISCSI\_ERR\_SCSI\_EH\_SESSION\_RST);  ISCSI\_DBG\_EH(session, "wait for relogin\n");- wait\_event\_interruptible(conn->ehwait,+ wait\_event\_interruptible(session->ehwait, session->state == ISCSI\_STATE\_TERMINATE || session->state == ISCSI\_STATE\_LOGGED\_IN || session->state == ISCSI\_STATE\_RECOVERY\_FAILED);@@ -2498,11 +2492,11 @@ static int iscsi\_eh\_target\_reset(struct scsi\_cmnd \*sc) conn = session->leadconn;  /\* only have one tmf outstanding at a time \*/- if (conn->tmf\_state != TMF\_INITIAL)+ if (session->tmf\_state != TMF\_INITIAL) goto unlock;- conn->tmf\_state = TMF\_QUEUED;+ session->tmf\_state = TMF\_QUEUED; - hdr = &conn->tmhdr;+ hdr = &session->tmhdr; iscsi\_prep\_tgt\_reset\_pdu(sc, hdr);  if (iscsi\_exec\_task\_mgmt\_fn(conn, hdr, session->age,@@ -2511,7 +2505,7 @@ static int iscsi\_eh\_target\_reset(struct scsi\_cmnd \*sc) goto unlock; } - switch (conn->tmf\_state) {+ switch (session->tmf\_state) { case TMF\_SUCCESS: break; case TMF\_TIMEDOUT:@@ -2519,7 +2513,7 @@ static int iscsi\_eh\_target\_reset(struct scsi\_cmnd \*sc) iscsi\_conn\_failure(conn, ISCSI\_ERR\_SCSI\_EH\_SESSION\_RST); goto done; default:- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; goto unlock; } @@ -2531,7 +2525,7 @@ static int iscsi\_eh\_target\_reset(struct scsi\_cmnd \*sc) spin\_lock\_bh(&session->frwd\_lock); memset(hdr, 0, sizeof(\*hdr)); fail\_scsi\_tasks(conn, -1, DID\_ERROR);- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; spin\_unlock\_bh(&session->frwd\_lock);  iscsi\_start\_tx(conn);@@ -2836,7 +2830,10 @@ iscsi\_session\_setup(struct iscsi\_transport \*iscsit, struct Scsi\_Host \*shost, session->tt = iscsit; session->dd\_data = cls\_session->dd\_data + sizeof(\*session); + session->tmf\_state = TMF\_INITIAL;+ timer\_setup(&session->tmf\_timer, iscsi\_tmf\_timedout, 0); mutex\_init(&session->eh\_mutex);+ spin\_lock\_init(&session->frwd\_lock); spin\_lock\_init(&session->back\_lock); @@ -2940,7 +2937,6 @@ iscsi\_conn\_setup(struct iscsi\_cls\_session \*cls\_session, int dd\_size, conn->c\_stage = ISCSI\_CONN\_INITIAL\_STAGE; conn->id = conn\_idx; conn->exp\_statsn = 0;- conn->tmf\_state = TMF\_INITIAL;  timer\_setup(&conn->transport\_timer, iscsi\_check\_transport\_timeouts, 0); @@ -2966,8 +2962,7 @@ iscsi\_conn\_setup(struct iscsi\_cls\_session \*cls\_session, int dd\_size, goto login\_task\_data\_alloc\_fail; conn->login\_task->data = conn->data = data; - timer\_setup(&conn->tmf\_timer, iscsi\_tmf\_timedout, 0);- init\_waitqueue\_head(&conn->ehwait);+ init\_waitqueue\_head(&session->ehwait);  return cls\_conn; @@ -3002,7 +2997,7 @@ void iscsi\_conn\_teardown(struct iscsi\_cls\_conn \*cls\_conn) \* leading connection? then give up on recovery. \*/ session->state = ISCSI\_STATE\_TERMINATE;- wake\_up(&conn->ehwait);+ wake\_up(&session->ehwait); } spin\_unlock\_bh(&session->frwd\_lock); @@ -3077,7 +3072,7 @@ int iscsi\_conn\_start(struct iscsi\_cls\_conn \*cls\_conn) \* commands after successful recovery \*/ conn->stop\_stage = 0;- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; session->age++; if (session->age == 16) session->age = 0;@@ -3091,7 +3086,7 @@ int iscsi\_conn\_start(struct iscsi\_cls\_conn \*cls\_conn) spin\_unlock\_bh(&session->frwd\_lock);  iscsi\_unblock\_session(session->cls\_session);- wake\_up(&conn->ehwait);+ wake\_up(&session->ehwait); return 0; } EXPORT\_SYMBOL\_GPL(iscsi\_conn\_start);@@ -3177,7 +3172,7 @@ static void iscsi\_start\_session\_recovery(struct iscsi\_session \*session, spin\_lock\_bh(&session->frwd\_lock); fail\_scsi\_tasks(conn, -1, DID\_TRANSPORT\_DISRUPTED); fail\_mgmt\_tasks(session, conn);- memset(&conn->tmhdr, 0, sizeof(conn->tmhdr));+ memset(&session->tmhdr, 0, sizeof(session->tmhdr)); spin\_unlock\_bh(&session->frwd\_lock); mutex\_unlock(&session->eh\_mutex); }diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.hindex 1ee0f30ae190b8..647f1e0e726c9a 100644--- a/[include/scsi/libiscsi.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/scsi/libiscsi.h?id=8d3f5e3b4ebe1e4cdc9f6d79dd24e77aa8007efb)+++ b/[include/scsi/libiscsi.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/scsi/libiscsi.h?id=bf20d85a88384574fabb3d53ad62a8af57e7ab11)@@ -208,12 +208,6 @@ struct iscsi\_conn { unsigned long suspend\_tx; /\* suspend Tx \*/ unsigned long suspend\_rx; /\* suspend Rx \*/ - /\* abort \*/- wait\_queue\_head\_t ehwait; /\* used in eh\_abort() \*/- struct iscsi\_tm tmhdr;- struct timer\_list tmf\_timer;- int tmf\_state; /\* see TMF\_INITIAL, etc.\*/- /\* negotiated params \*/ unsigned max\_recv\_dlength; /\* initiator\_max\_recv\_dsl\*/ unsigned max\_xmit\_dlength; /\* target\_max\_recv\_dsl \*/@@ -283,6 +277,11 @@ struct iscsi\_session { \* and recv lock. \*/ struct mutex eh\_mutex;+ /\* abort \*/+ wait\_queue\_head\_t ehwait; /\* used in eh\_abort() \*/+ struct iscsi\_tm tmhdr;+ struct timer\_list tmf\_timer;+ int tmf\_state; /\* see TMF\_INITIAL, etc.\*/  /\* iSCSI session-wide sequencing \*/ uint32\_t cmdsn; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 14:09:35 +0000



=== Content from git.kernel.org_ba8c78d3_20250110_141103.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=fa9542b35ceb4202e8f8d65f440529a63524dca9)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=fa9542b35ceb4202e8f8d65f440529a63524dca9)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=fa9542b35ceb4202e8f8d65f440529a63524dca9)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=fa9542b35ceb4202e8f8d65f440529a63524dca9)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Mike Christie <michael.christie@oracle.com> | 2021-05-25 13:18:06 -0500 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2021-07-20 16:00:15 +0200 |
| commit | [fa9542b35ceb4202e8f8d65f440529a63524dca9](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=fa9542b35ceb4202e8f8d65f440529a63524dca9) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=fa9542b35ceb4202e8f8d65f440529a63524dca9)) | |
| tree | [c269430fb46baef5ab017ecf26fd2e66982867ee](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=fa9542b35ceb4202e8f8d65f440529a63524dca9) | |
| parent | [bf3ce567db5639aab2010a49b4e522830e0887a0](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=bf3ce567db5639aab2010a49b4e522830e0887a0) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=fa9542b35ceb4202e8f8d65f440529a63524dca9&id2=bf3ce567db5639aab2010a49b4e522830e0887a0)) | |
| download | [linux-fa9542b35ceb4202e8f8d65f440529a63524dca9.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-fa9542b35ceb4202e8f8d65f440529a63524dca9.tar.gz) | |

scsi: iscsi: Fix conn use after free during resets[ Upstream commit ec29d0ac29be366450a7faffbcf8cba3a6a3b506 ]
If we haven't done a unbind target call we can race where
iscsi\_conn\_teardown wakes up the EH thread and then frees the conn while
those threads are still accessing the conn ehwait.
We can only do one TMF per session so this just moves the TMF fields from
the conn to the session. We can then rely on the
iscsi\_session\_teardown->iscsi\_remove\_session->\_\_iscsi\_unbind\_session call
to remove the target and it's devices, and know after that point there is
no device or scsi-ml callout trying to access the session.
Link: [https://lore.kernel.org/r/20210525181821.7617-14-michael.christie@oracle.com](https://lore.kernel.org/r/20210525181821.7617-14-michael.christie%40oracle.com)
Reviewed-by: Lee Duncan <lduncan@suse.com>
Signed-off-by: Mike Christie <michael.christie@oracle.com>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=fa9542b35ceb4202e8f8d65f440529a63524dca9)

| -rw-r--r-- | [drivers/scsi/libiscsi.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/scsi/libiscsi.c?id=fa9542b35ceb4202e8f8d65f440529a63524dca9) | 115 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/scsi/libiscsi.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/scsi/libiscsi.h?id=fa9542b35ceb4202e8f8d65f440529a63524dca9) | 11 | |  |  |  | | --- | --- | --- | |

2 files changed, 60 insertions, 66 deletions

| diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.cindex ab39d7f65bbb09..dfe906307e55d5 100644--- a/[drivers/scsi/libiscsi.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/scsi/libiscsi.c?id=bf3ce567db5639aab2010a49b4e522830e0887a0)+++ b/[drivers/scsi/libiscsi.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/scsi/libiscsi.c?id=fa9542b35ceb4202e8f8d65f440529a63524dca9)@@ -230,11 +230,11 @@ static int iscsi\_prep\_ecdb\_ahs(struct iscsi\_task \*task) \*/ static int iscsi\_check\_tmf\_restrictions(struct iscsi\_task \*task, int opcode) {- struct iscsi\_conn \*conn = task->conn;- struct iscsi\_tm \*tmf = &conn->tmhdr;+ struct iscsi\_session \*session = task->conn->session;+ struct iscsi\_tm \*tmf = &session->tmhdr; u64 hdr\_lun; - if (conn->tmf\_state == TMF\_INITIAL)+ if (session->tmf\_state == TMF\_INITIAL) return 0;  if ((tmf->opcode & ISCSI\_OPCODE\_MASK) != ISCSI\_OP\_SCSI\_TMFUNC)@@ -254,24 +254,19 @@ static int iscsi\_check\_tmf\_restrictions(struct iscsi\_task \*task, int opcode) \* Fail all SCSI cmd PDUs \*/ if (opcode != ISCSI\_OP\_SCSI\_DATA\_OUT) {- iscsi\_conn\_printk(KERN\_INFO, conn,- "task [op %x itt "- "0x%x/0x%x] "- "rejected.\n",- opcode, task->itt,- task->hdr\_itt);+ iscsi\_session\_printk(KERN\_INFO, session,+ "task [op %x itt 0x%x/0x%x] rejected.\n",+ opcode, task->itt, task->hdr\_itt); return -EACCES; } /\* \* And also all data-out PDUs in response to R2T \* if fast\_abort is set. \*/- if (conn->session->fast\_abort) {- iscsi\_conn\_printk(KERN\_INFO, conn,- "task [op %x itt "- "0x%x/0x%x] fast abort.\n",- opcode, task->itt,- task->hdr\_itt);+ if (session->fast\_abort) {+ iscsi\_session\_printk(KERN\_INFO, session,+ "task [op %x itt 0x%x/0x%x] fast abort.\n",+ opcode, task->itt, task->hdr\_itt); return -EACCES; } break;@@ -284,7 +279,7 @@ static int iscsi\_check\_tmf\_restrictions(struct iscsi\_task \*task, int opcode) \*/ if (opcode == ISCSI\_OP\_SCSI\_DATA\_OUT && task->hdr\_itt == tmf->rtt) {- ISCSI\_DBG\_SESSION(conn->session,+ ISCSI\_DBG\_SESSION(session, "Preventing task %x/%x from sending " "data-out due to abort task in " "progress\n", task->itt,@@ -936,20 +931,21 @@ iscsi\_data\_in\_rsp(struct iscsi\_conn \*conn, struct iscsi\_hdr \*hdr, static void iscsi\_tmf\_rsp(struct iscsi\_conn \*conn, struct iscsi\_hdr \*hdr) { struct iscsi\_tm\_rsp \*tmf = (struct iscsi\_tm\_rsp \*)hdr;+ struct iscsi\_session \*session = conn->session;  conn->exp\_statsn = be32\_to\_cpu(hdr->statsn) + 1; conn->tmfrsp\_pdus\_cnt++; - if (conn->tmf\_state != TMF\_QUEUED)+ if (session->tmf\_state != TMF\_QUEUED) return;  if (tmf->response == ISCSI\_TMF\_RSP\_COMPLETE)- conn->tmf\_state = TMF\_SUCCESS;+ session->tmf\_state = TMF\_SUCCESS; else if (tmf->response == ISCSI\_TMF\_RSP\_NO\_TASK)- conn->tmf\_state = TMF\_NOT\_FOUND;+ session->tmf\_state = TMF\_NOT\_FOUND; else- conn->tmf\_state = TMF\_FAILED;- wake\_up(&conn->ehwait);+ session->tmf\_state = TMF\_FAILED;+ wake\_up(&session->ehwait); }  static int iscsi\_send\_nopout(struct iscsi\_conn \*conn, struct iscsi\_nopin \*rhdr)@@ -1826,15 +1822,14 @@ EXPORT\_SYMBOL\_GPL(iscsi\_target\_alloc);  static void iscsi\_tmf\_timedout(struct timer\_list \*t) {- struct iscsi\_conn \*conn = from\_timer(conn, t, tmf\_timer);- struct iscsi\_session \*session = conn->session;+ struct iscsi\_session \*session = from\_timer(session, t, tmf\_timer);  spin\_lock(&session->frwd\_lock);- if (conn->tmf\_state == TMF\_QUEUED) {- conn->tmf\_state = TMF\_TIMEDOUT;+ if (session->tmf\_state == TMF\_QUEUED) {+ session->tmf\_state = TMF\_TIMEDOUT; ISCSI\_DBG\_EH(session, "tmf timedout\n"); /\* unblock eh\_abort() \*/- wake\_up(&conn->ehwait);+ wake\_up(&session->ehwait); } spin\_unlock(&session->frwd\_lock); }@@ -1857,8 +1852,8 @@ static int iscsi\_exec\_task\_mgmt\_fn(struct iscsi\_conn \*conn, return -EPERM; } conn->tmfcmd\_pdus\_cnt++;- conn->tmf\_timer.expires = timeout \* HZ + jiffies;- add\_timer(&conn->tmf\_timer);+ session->tmf\_timer.expires = timeout \* HZ + jiffies;+ add\_timer(&session->tmf\_timer); ISCSI\_DBG\_EH(session, "tmf set timeout\n");  spin\_unlock\_bh(&session->frwd\_lock);@@ -1872,12 +1867,12 @@ static int iscsi\_exec\_task\_mgmt\_fn(struct iscsi\_conn \*conn, \* 3) session is terminated or restarted or userspace has \* given up on recovery \*/- wait\_event\_interruptible(conn->ehwait, age != session->age ||+ wait\_event\_interruptible(session->ehwait, age != session->age || session->state != ISCSI\_STATE\_LOGGED\_IN ||- conn->tmf\_state != TMF\_QUEUED);+ session->tmf\_state != TMF\_QUEUED); if (signal\_pending(current)) flush\_signals(current);- del\_timer\_sync(&conn->tmf\_timer);+ del\_timer\_sync(&session->tmf\_timer);  mutex\_lock(&session->eh\_mutex); spin\_lock\_bh(&session->frwd\_lock);@@ -2309,17 +2304,17 @@ int iscsi\_eh\_abort(struct scsi\_cmnd \*sc) }  /\* only have one tmf outstanding at a time \*/- if (conn->tmf\_state != TMF\_INITIAL)+ if (session->tmf\_state != TMF\_INITIAL) goto failed;- conn->tmf\_state = TMF\_QUEUED;+ session->tmf\_state = TMF\_QUEUED; - hdr = &conn->tmhdr;+ hdr = &session->tmhdr; iscsi\_prep\_abort\_task\_pdu(task, hdr);  if (iscsi\_exec\_task\_mgmt\_fn(conn, hdr, age, session->abort\_timeout)) goto failed; - switch (conn->tmf\_state) {+ switch (session->tmf\_state) { case TMF\_SUCCESS: spin\_unlock\_bh(&session->frwd\_lock); /\*@@ -2334,7 +2329,7 @@ int iscsi\_eh\_abort(struct scsi\_cmnd \*sc) \*/ spin\_lock\_bh(&session->frwd\_lock); fail\_scsi\_task(task, DID\_ABORT);- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; memset(hdr, 0, sizeof(\*hdr)); spin\_unlock\_bh(&session->frwd\_lock); iscsi\_start\_tx(conn);@@ -2345,7 +2340,7 @@ int iscsi\_eh\_abort(struct scsi\_cmnd \*sc) goto failed\_unlocked; case TMF\_NOT\_FOUND: if (!sc->SCp.ptr) {- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; memset(hdr, 0, sizeof(\*hdr)); /\* task completed before tmf abort response \*/ ISCSI\_DBG\_EH(session, "sc completed while abort in "@@ -2354,7 +2349,7 @@ int iscsi\_eh\_abort(struct scsi\_cmnd \*sc) } fallthrough; default:- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; goto failed; } @@ -2413,11 +2408,11 @@ int iscsi\_eh\_device\_reset(struct scsi\_cmnd \*sc) conn = session->leadconn;  /\* only have one tmf outstanding at a time \*/- if (conn->tmf\_state != TMF\_INITIAL)+ if (session->tmf\_state != TMF\_INITIAL) goto unlock;- conn->tmf\_state = TMF\_QUEUED;+ session->tmf\_state = TMF\_QUEUED; - hdr = &conn->tmhdr;+ hdr = &session->tmhdr; iscsi\_prep\_lun\_reset\_pdu(sc, hdr);  if (iscsi\_exec\_task\_mgmt\_fn(conn, hdr, session->age,@@ -2426,7 +2421,7 @@ int iscsi\_eh\_device\_reset(struct scsi\_cmnd \*sc) goto unlock; } - switch (conn->tmf\_state) {+ switch (session->tmf\_state) { case TMF\_SUCCESS: break; case TMF\_TIMEDOUT:@@ -2434,7 +2429,7 @@ int iscsi\_eh\_device\_reset(struct scsi\_cmnd \*sc) iscsi\_conn\_failure(conn, ISCSI\_ERR\_SCSI\_EH\_SESSION\_RST); goto done; default:- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; goto unlock; } @@ -2446,7 +2441,7 @@ int iscsi\_eh\_device\_reset(struct scsi\_cmnd \*sc) spin\_lock\_bh(&session->frwd\_lock); memset(hdr, 0, sizeof(\*hdr)); fail\_scsi\_tasks(conn, sc->device->lun, DID\_ERROR);- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; spin\_unlock\_bh(&session->frwd\_lock);  iscsi\_start\_tx(conn);@@ -2469,8 +2464,7 @@ void iscsi\_session\_recovery\_timedout(struct iscsi\_cls\_session \*cls\_session) spin\_lock\_bh(&session->frwd\_lock); if (session->state != ISCSI\_STATE\_LOGGED\_IN) { session->state = ISCSI\_STATE\_RECOVERY\_FAILED;- if (session->leadconn)- wake\_up(&session->leadconn->ehwait);+ wake\_up(&session->ehwait); } spin\_unlock\_bh(&session->frwd\_lock); }@@ -2515,7 +2509,7 @@ failed: iscsi\_conn\_failure(conn, ISCSI\_ERR\_SCSI\_EH\_SESSION\_RST);  ISCSI\_DBG\_EH(session, "wait for relogin\n");- wait\_event\_interruptible(conn->ehwait,+ wait\_event\_interruptible(session->ehwait, session->state == ISCSI\_STATE\_TERMINATE || session->state == ISCSI\_STATE\_LOGGED\_IN || session->state == ISCSI\_STATE\_RECOVERY\_FAILED);@@ -2576,11 +2570,11 @@ static int iscsi\_eh\_target\_reset(struct scsi\_cmnd \*sc) conn = session->leadconn;  /\* only have one tmf outstanding at a time \*/- if (conn->tmf\_state != TMF\_INITIAL)+ if (session->tmf\_state != TMF\_INITIAL) goto unlock;- conn->tmf\_state = TMF\_QUEUED;+ session->tmf\_state = TMF\_QUEUED; - hdr = &conn->tmhdr;+ hdr = &session->tmhdr; iscsi\_prep\_tgt\_reset\_pdu(sc, hdr);  if (iscsi\_exec\_task\_mgmt\_fn(conn, hdr, session->age,@@ -2589,7 +2583,7 @@ static int iscsi\_eh\_target\_reset(struct scsi\_cmnd \*sc) goto unlock; } - switch (conn->tmf\_state) {+ switch (session->tmf\_state) { case TMF\_SUCCESS: break; case TMF\_TIMEDOUT:@@ -2597,7 +2591,7 @@ static int iscsi\_eh\_target\_reset(struct scsi\_cmnd \*sc) iscsi\_conn\_failure(conn, ISCSI\_ERR\_SCSI\_EH\_SESSION\_RST); goto done; default:- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; goto unlock; } @@ -2609,7 +2603,7 @@ static int iscsi\_eh\_target\_reset(struct scsi\_cmnd \*sc) spin\_lock\_bh(&session->frwd\_lock); memset(hdr, 0, sizeof(\*hdr)); fail\_scsi\_tasks(conn, -1, DID\_ERROR);- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; spin\_unlock\_bh(&session->frwd\_lock);  iscsi\_start\_tx(conn);@@ -2939,7 +2933,10 @@ iscsi\_session\_setup(struct iscsi\_transport \*iscsit, struct Scsi\_Host \*shost, session->tt = iscsit; session->dd\_data = cls\_session->dd\_data + sizeof(\*session); + session->tmf\_state = TMF\_INITIAL;+ timer\_setup(&session->tmf\_timer, iscsi\_tmf\_timedout, 0); mutex\_init(&session->eh\_mutex);+ spin\_lock\_init(&session->frwd\_lock); spin\_lock\_init(&session->back\_lock); @@ -3043,7 +3040,6 @@ iscsi\_conn\_setup(struct iscsi\_cls\_session \*cls\_session, int dd\_size, conn->c\_stage = ISCSI\_CONN\_INITIAL\_STAGE; conn->id = conn\_idx; conn->exp\_statsn = 0;- conn->tmf\_state = TMF\_INITIAL;  timer\_setup(&conn->transport\_timer, iscsi\_check\_transport\_timeouts, 0); @@ -3068,8 +3064,7 @@ iscsi\_conn\_setup(struct iscsi\_cls\_session \*cls\_session, int dd\_size, goto login\_task\_data\_alloc\_fail; conn->login\_task->data = conn->data = data; - timer\_setup(&conn->tmf\_timer, iscsi\_tmf\_timedout, 0);- init\_waitqueue\_head(&conn->ehwait);+ init\_waitqueue\_head(&session->ehwait);  return cls\_conn; @@ -3104,7 +3099,7 @@ void iscsi\_conn\_teardown(struct iscsi\_cls\_conn \*cls\_conn) \* leading connection? then give up on recovery. \*/ session->state = ISCSI\_STATE\_TERMINATE;- wake\_up(&conn->ehwait);+ wake\_up(&session->ehwait); } spin\_unlock\_bh(&session->frwd\_lock); @@ -3179,7 +3174,7 @@ int iscsi\_conn\_start(struct iscsi\_cls\_conn \*cls\_conn) \* commands after successful recovery \*/ conn->stop\_stage = 0;- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; session->age++; if (session->age == 16) session->age = 0;@@ -3193,7 +3188,7 @@ int iscsi\_conn\_start(struct iscsi\_cls\_conn \*cls\_conn) spin\_unlock\_bh(&session->frwd\_lock);  iscsi\_unblock\_session(session->cls\_session);- wake\_up(&conn->ehwait);+ wake\_up(&session->ehwait); return 0; } EXPORT\_SYMBOL\_GPL(iscsi\_conn\_start);@@ -3287,7 +3282,7 @@ void iscsi\_conn\_stop(struct iscsi\_cls\_conn \*cls\_conn, int flag) spin\_lock\_bh(&session->frwd\_lock); fail\_scsi\_tasks(conn, -1, DID\_TRANSPORT\_DISRUPTED); fail\_mgmt\_tasks(session, conn);- memset(&conn->tmhdr, 0, sizeof(conn->tmhdr));+ memset(&session->tmhdr, 0, sizeof(session->tmhdr)); spin\_unlock\_bh(&session->frwd\_lock); mutex\_unlock(&session->eh\_mutex); }diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.hindex 091f284bd6e93d..2bb452a8f134c7 100644--- a/[include/scsi/libiscsi.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/scsi/libiscsi.h?id=bf3ce567db5639aab2010a49b4e522830e0887a0)+++ b/[include/scsi/libiscsi.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/scsi/libiscsi.h?id=fa9542b35ceb4202e8f8d65f440529a63524dca9)@@ -195,12 +195,6 @@ struct iscsi\_conn { unsigned long suspend\_tx; /\* suspend Tx \*/ unsigned long suspend\_rx; /\* suspend Rx \*/ - /\* abort \*/- wait\_queue\_head\_t ehwait; /\* used in eh\_abort() \*/- struct iscsi\_tm tmhdr;- struct timer\_list tmf\_timer;- int tmf\_state; /\* see TMF\_INITIAL, etc.\*/- /\* negotiated params \*/ unsigned max\_recv\_dlength; /\* initiator\_max\_recv\_dsl\*/ unsigned max\_xmit\_dlength; /\* target\_max\_recv\_dsl \*/@@ -270,6 +264,11 @@ struct iscsi\_session { \* and recv lock. \*/ struct mutex eh\_mutex;+ /\* abort \*/+ wait\_queue\_head\_t ehwait; /\* used in eh\_abort() \*/+ struct iscsi\_tm tmhdr;+ struct timer\_list tmf\_timer;+ int tmf\_state; /\* see TMF\_INITIAL, etc.\*/  /\* iSCSI session-wide sequencing \*/ uint32\_t cmdsn; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 14:09:40 +0000


