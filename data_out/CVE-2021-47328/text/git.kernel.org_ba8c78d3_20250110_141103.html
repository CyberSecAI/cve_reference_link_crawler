

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=fa9542b35ceb4202e8f8d65f440529a63524dca9)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=fa9542b35ceb4202e8f8d65f440529a63524dca9)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=fa9542b35ceb4202e8f8d65f440529a63524dca9)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=fa9542b35ceb4202e8f8d65f440529a63524dca9)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Mike Christie <michael.christie@oracle.com> | 2021-05-25 13:18:06 -0500 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2021-07-20 16:00:15 +0200 |
| commit | [fa9542b35ceb4202e8f8d65f440529a63524dca9](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=fa9542b35ceb4202e8f8d65f440529a63524dca9) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=fa9542b35ceb4202e8f8d65f440529a63524dca9)) | |
| tree | [c269430fb46baef5ab017ecf26fd2e66982867ee](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=fa9542b35ceb4202e8f8d65f440529a63524dca9) | |
| parent | [bf3ce567db5639aab2010a49b4e522830e0887a0](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=bf3ce567db5639aab2010a49b4e522830e0887a0) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=fa9542b35ceb4202e8f8d65f440529a63524dca9&id2=bf3ce567db5639aab2010a49b4e522830e0887a0)) | |
| download | [linux-fa9542b35ceb4202e8f8d65f440529a63524dca9.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-fa9542b35ceb4202e8f8d65f440529a63524dca9.tar.gz) | |

scsi: iscsi: Fix conn use after free during resets[ Upstream commit ec29d0ac29be366450a7faffbcf8cba3a6a3b506 ]
If we haven't done a unbind target call we can race where
iscsi\_conn\_teardown wakes up the EH thread and then frees the conn while
those threads are still accessing the conn ehwait.
We can only do one TMF per session so this just moves the TMF fields from
the conn to the session. We can then rely on the
iscsi\_session\_teardown->iscsi\_remove\_session->\_\_iscsi\_unbind\_session call
to remove the target and it's devices, and know after that point there is
no device or scsi-ml callout trying to access the session.
Link: [https://lore.kernel.org/r/20210525181821.7617-14-michael.christie@oracle.com](https://lore.kernel.org/r/20210525181821.7617-14-michael.christie%40oracle.com)
Reviewed-by: Lee Duncan <lduncan@suse.com>
Signed-off-by: Mike Christie <michael.christie@oracle.com>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=fa9542b35ceb4202e8f8d65f440529a63524dca9)

| -rw-r--r-- | [drivers/scsi/libiscsi.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/scsi/libiscsi.c?id=fa9542b35ceb4202e8f8d65f440529a63524dca9) | 115 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/scsi/libiscsi.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/scsi/libiscsi.h?id=fa9542b35ceb4202e8f8d65f440529a63524dca9) | 11 | |  |  |  | | --- | --- | --- | |

2 files changed, 60 insertions, 66 deletions

| diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.cindex ab39d7f65bbb09..dfe906307e55d5 100644--- a/[drivers/scsi/libiscsi.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/scsi/libiscsi.c?id=bf3ce567db5639aab2010a49b4e522830e0887a0)+++ b/[drivers/scsi/libiscsi.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/scsi/libiscsi.c?id=fa9542b35ceb4202e8f8d65f440529a63524dca9)@@ -230,11 +230,11 @@ static int iscsi\_prep\_ecdb\_ahs(struct iscsi\_task \*task) \*/ static int iscsi\_check\_tmf\_restrictions(struct iscsi\_task \*task, int opcode) {- struct iscsi\_conn \*conn = task->conn;- struct iscsi\_tm \*tmf = &conn->tmhdr;+ struct iscsi\_session \*session = task->conn->session;+ struct iscsi\_tm \*tmf = &session->tmhdr; u64 hdr\_lun; - if (conn->tmf\_state == TMF\_INITIAL)+ if (session->tmf\_state == TMF\_INITIAL) return 0;  if ((tmf->opcode & ISCSI\_OPCODE\_MASK) != ISCSI\_OP\_SCSI\_TMFUNC)@@ -254,24 +254,19 @@ static int iscsi\_check\_tmf\_restrictions(struct iscsi\_task \*task, int opcode) \* Fail all SCSI cmd PDUs \*/ if (opcode != ISCSI\_OP\_SCSI\_DATA\_OUT) {- iscsi\_conn\_printk(KERN\_INFO, conn,- "task [op %x itt "- "0x%x/0x%x] "- "rejected.\n",- opcode, task->itt,- task->hdr\_itt);+ iscsi\_session\_printk(KERN\_INFO, session,+ "task [op %x itt 0x%x/0x%x] rejected.\n",+ opcode, task->itt, task->hdr\_itt); return -EACCES; } /\* \* And also all data-out PDUs in response to R2T \* if fast\_abort is set. \*/- if (conn->session->fast\_abort) {- iscsi\_conn\_printk(KERN\_INFO, conn,- "task [op %x itt "- "0x%x/0x%x] fast abort.\n",- opcode, task->itt,- task->hdr\_itt);+ if (session->fast\_abort) {+ iscsi\_session\_printk(KERN\_INFO, session,+ "task [op %x itt 0x%x/0x%x] fast abort.\n",+ opcode, task->itt, task->hdr\_itt); return -EACCES; } break;@@ -284,7 +279,7 @@ static int iscsi\_check\_tmf\_restrictions(struct iscsi\_task \*task, int opcode) \*/ if (opcode == ISCSI\_OP\_SCSI\_DATA\_OUT && task->hdr\_itt == tmf->rtt) {- ISCSI\_DBG\_SESSION(conn->session,+ ISCSI\_DBG\_SESSION(session, "Preventing task %x/%x from sending " "data-out due to abort task in " "progress\n", task->itt,@@ -936,20 +931,21 @@ iscsi\_data\_in\_rsp(struct iscsi\_conn \*conn, struct iscsi\_hdr \*hdr, static void iscsi\_tmf\_rsp(struct iscsi\_conn \*conn, struct iscsi\_hdr \*hdr) { struct iscsi\_tm\_rsp \*tmf = (struct iscsi\_tm\_rsp \*)hdr;+ struct iscsi\_session \*session = conn->session;  conn->exp\_statsn = be32\_to\_cpu(hdr->statsn) + 1; conn->tmfrsp\_pdus\_cnt++; - if (conn->tmf\_state != TMF\_QUEUED)+ if (session->tmf\_state != TMF\_QUEUED) return;  if (tmf->response == ISCSI\_TMF\_RSP\_COMPLETE)- conn->tmf\_state = TMF\_SUCCESS;+ session->tmf\_state = TMF\_SUCCESS; else if (tmf->response == ISCSI\_TMF\_RSP\_NO\_TASK)- conn->tmf\_state = TMF\_NOT\_FOUND;+ session->tmf\_state = TMF\_NOT\_FOUND; else- conn->tmf\_state = TMF\_FAILED;- wake\_up(&conn->ehwait);+ session->tmf\_state = TMF\_FAILED;+ wake\_up(&session->ehwait); }  static int iscsi\_send\_nopout(struct iscsi\_conn \*conn, struct iscsi\_nopin \*rhdr)@@ -1826,15 +1822,14 @@ EXPORT\_SYMBOL\_GPL(iscsi\_target\_alloc);  static void iscsi\_tmf\_timedout(struct timer\_list \*t) {- struct iscsi\_conn \*conn = from\_timer(conn, t, tmf\_timer);- struct iscsi\_session \*session = conn->session;+ struct iscsi\_session \*session = from\_timer(session, t, tmf\_timer);  spin\_lock(&session->frwd\_lock);- if (conn->tmf\_state == TMF\_QUEUED) {- conn->tmf\_state = TMF\_TIMEDOUT;+ if (session->tmf\_state == TMF\_QUEUED) {+ session->tmf\_state = TMF\_TIMEDOUT; ISCSI\_DBG\_EH(session, "tmf timedout\n"); /\* unblock eh\_abort() \*/- wake\_up(&conn->ehwait);+ wake\_up(&session->ehwait); } spin\_unlock(&session->frwd\_lock); }@@ -1857,8 +1852,8 @@ static int iscsi\_exec\_task\_mgmt\_fn(struct iscsi\_conn \*conn, return -EPERM; } conn->tmfcmd\_pdus\_cnt++;- conn->tmf\_timer.expires = timeout \* HZ + jiffies;- add\_timer(&conn->tmf\_timer);+ session->tmf\_timer.expires = timeout \* HZ + jiffies;+ add\_timer(&session->tmf\_timer); ISCSI\_DBG\_EH(session, "tmf set timeout\n");  spin\_unlock\_bh(&session->frwd\_lock);@@ -1872,12 +1867,12 @@ static int iscsi\_exec\_task\_mgmt\_fn(struct iscsi\_conn \*conn, \* 3) session is terminated or restarted or userspace has \* given up on recovery \*/- wait\_event\_interruptible(conn->ehwait, age != session->age ||+ wait\_event\_interruptible(session->ehwait, age != session->age || session->state != ISCSI\_STATE\_LOGGED\_IN ||- conn->tmf\_state != TMF\_QUEUED);+ session->tmf\_state != TMF\_QUEUED); if (signal\_pending(current)) flush\_signals(current);- del\_timer\_sync(&conn->tmf\_timer);+ del\_timer\_sync(&session->tmf\_timer);  mutex\_lock(&session->eh\_mutex); spin\_lock\_bh(&session->frwd\_lock);@@ -2309,17 +2304,17 @@ int iscsi\_eh\_abort(struct scsi\_cmnd \*sc) }  /\* only have one tmf outstanding at a time \*/- if (conn->tmf\_state != TMF\_INITIAL)+ if (session->tmf\_state != TMF\_INITIAL) goto failed;- conn->tmf\_state = TMF\_QUEUED;+ session->tmf\_state = TMF\_QUEUED; - hdr = &conn->tmhdr;+ hdr = &session->tmhdr; iscsi\_prep\_abort\_task\_pdu(task, hdr);  if (iscsi\_exec\_task\_mgmt\_fn(conn, hdr, age, session->abort\_timeout)) goto failed; - switch (conn->tmf\_state) {+ switch (session->tmf\_state) { case TMF\_SUCCESS: spin\_unlock\_bh(&session->frwd\_lock); /\*@@ -2334,7 +2329,7 @@ int iscsi\_eh\_abort(struct scsi\_cmnd \*sc) \*/ spin\_lock\_bh(&session->frwd\_lock); fail\_scsi\_task(task, DID\_ABORT);- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; memset(hdr, 0, sizeof(\*hdr)); spin\_unlock\_bh(&session->frwd\_lock); iscsi\_start\_tx(conn);@@ -2345,7 +2340,7 @@ int iscsi\_eh\_abort(struct scsi\_cmnd \*sc) goto failed\_unlocked; case TMF\_NOT\_FOUND: if (!sc->SCp.ptr) {- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; memset(hdr, 0, sizeof(\*hdr)); /\* task completed before tmf abort response \*/ ISCSI\_DBG\_EH(session, "sc completed while abort in "@@ -2354,7 +2349,7 @@ int iscsi\_eh\_abort(struct scsi\_cmnd \*sc) } fallthrough; default:- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; goto failed; } @@ -2413,11 +2408,11 @@ int iscsi\_eh\_device\_reset(struct scsi\_cmnd \*sc) conn = session->leadconn;  /\* only have one tmf outstanding at a time \*/- if (conn->tmf\_state != TMF\_INITIAL)+ if (session->tmf\_state != TMF\_INITIAL) goto unlock;- conn->tmf\_state = TMF\_QUEUED;+ session->tmf\_state = TMF\_QUEUED; - hdr = &conn->tmhdr;+ hdr = &session->tmhdr; iscsi\_prep\_lun\_reset\_pdu(sc, hdr);  if (iscsi\_exec\_task\_mgmt\_fn(conn, hdr, session->age,@@ -2426,7 +2421,7 @@ int iscsi\_eh\_device\_reset(struct scsi\_cmnd \*sc) goto unlock; } - switch (conn->tmf\_state) {+ switch (session->tmf\_state) { case TMF\_SUCCESS: break; case TMF\_TIMEDOUT:@@ -2434,7 +2429,7 @@ int iscsi\_eh\_device\_reset(struct scsi\_cmnd \*sc) iscsi\_conn\_failure(conn, ISCSI\_ERR\_SCSI\_EH\_SESSION\_RST); goto done; default:- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; goto unlock; } @@ -2446,7 +2441,7 @@ int iscsi\_eh\_device\_reset(struct scsi\_cmnd \*sc) spin\_lock\_bh(&session->frwd\_lock); memset(hdr, 0, sizeof(\*hdr)); fail\_scsi\_tasks(conn, sc->device->lun, DID\_ERROR);- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; spin\_unlock\_bh(&session->frwd\_lock);  iscsi\_start\_tx(conn);@@ -2469,8 +2464,7 @@ void iscsi\_session\_recovery\_timedout(struct iscsi\_cls\_session \*cls\_session) spin\_lock\_bh(&session->frwd\_lock); if (session->state != ISCSI\_STATE\_LOGGED\_IN) { session->state = ISCSI\_STATE\_RECOVERY\_FAILED;- if (session->leadconn)- wake\_up(&session->leadconn->ehwait);+ wake\_up(&session->ehwait); } spin\_unlock\_bh(&session->frwd\_lock); }@@ -2515,7 +2509,7 @@ failed: iscsi\_conn\_failure(conn, ISCSI\_ERR\_SCSI\_EH\_SESSION\_RST);  ISCSI\_DBG\_EH(session, "wait for relogin\n");- wait\_event\_interruptible(conn->ehwait,+ wait\_event\_interruptible(session->ehwait, session->state == ISCSI\_STATE\_TERMINATE || session->state == ISCSI\_STATE\_LOGGED\_IN || session->state == ISCSI\_STATE\_RECOVERY\_FAILED);@@ -2576,11 +2570,11 @@ static int iscsi\_eh\_target\_reset(struct scsi\_cmnd \*sc) conn = session->leadconn;  /\* only have one tmf outstanding at a time \*/- if (conn->tmf\_state != TMF\_INITIAL)+ if (session->tmf\_state != TMF\_INITIAL) goto unlock;- conn->tmf\_state = TMF\_QUEUED;+ session->tmf\_state = TMF\_QUEUED; - hdr = &conn->tmhdr;+ hdr = &session->tmhdr; iscsi\_prep\_tgt\_reset\_pdu(sc, hdr);  if (iscsi\_exec\_task\_mgmt\_fn(conn, hdr, session->age,@@ -2589,7 +2583,7 @@ static int iscsi\_eh\_target\_reset(struct scsi\_cmnd \*sc) goto unlock; } - switch (conn->tmf\_state) {+ switch (session->tmf\_state) { case TMF\_SUCCESS: break; case TMF\_TIMEDOUT:@@ -2597,7 +2591,7 @@ static int iscsi\_eh\_target\_reset(struct scsi\_cmnd \*sc) iscsi\_conn\_failure(conn, ISCSI\_ERR\_SCSI\_EH\_SESSION\_RST); goto done; default:- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; goto unlock; } @@ -2609,7 +2603,7 @@ static int iscsi\_eh\_target\_reset(struct scsi\_cmnd \*sc) spin\_lock\_bh(&session->frwd\_lock); memset(hdr, 0, sizeof(\*hdr)); fail\_scsi\_tasks(conn, -1, DID\_ERROR);- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; spin\_unlock\_bh(&session->frwd\_lock);  iscsi\_start\_tx(conn);@@ -2939,7 +2933,10 @@ iscsi\_session\_setup(struct iscsi\_transport \*iscsit, struct Scsi\_Host \*shost, session->tt = iscsit; session->dd\_data = cls\_session->dd\_data + sizeof(\*session); + session->tmf\_state = TMF\_INITIAL;+ timer\_setup(&session->tmf\_timer, iscsi\_tmf\_timedout, 0); mutex\_init(&session->eh\_mutex);+ spin\_lock\_init(&session->frwd\_lock); spin\_lock\_init(&session->back\_lock); @@ -3043,7 +3040,6 @@ iscsi\_conn\_setup(struct iscsi\_cls\_session \*cls\_session, int dd\_size, conn->c\_stage = ISCSI\_CONN\_INITIAL\_STAGE; conn->id = conn\_idx; conn->exp\_statsn = 0;- conn->tmf\_state = TMF\_INITIAL;  timer\_setup(&conn->transport\_timer, iscsi\_check\_transport\_timeouts, 0); @@ -3068,8 +3064,7 @@ iscsi\_conn\_setup(struct iscsi\_cls\_session \*cls\_session, int dd\_size, goto login\_task\_data\_alloc\_fail; conn->login\_task->data = conn->data = data; - timer\_setup(&conn->tmf\_timer, iscsi\_tmf\_timedout, 0);- init\_waitqueue\_head(&conn->ehwait);+ init\_waitqueue\_head(&session->ehwait);  return cls\_conn; @@ -3104,7 +3099,7 @@ void iscsi\_conn\_teardown(struct iscsi\_cls\_conn \*cls\_conn) \* leading connection? then give up on recovery. \*/ session->state = ISCSI\_STATE\_TERMINATE;- wake\_up(&conn->ehwait);+ wake\_up(&session->ehwait); } spin\_unlock\_bh(&session->frwd\_lock); @@ -3179,7 +3174,7 @@ int iscsi\_conn\_start(struct iscsi\_cls\_conn \*cls\_conn) \* commands after successful recovery \*/ conn->stop\_stage = 0;- conn->tmf\_state = TMF\_INITIAL;+ session->tmf\_state = TMF\_INITIAL; session->age++; if (session->age == 16) session->age = 0;@@ -3193,7 +3188,7 @@ int iscsi\_conn\_start(struct iscsi\_cls\_conn \*cls\_conn) spin\_unlock\_bh(&session->frwd\_lock);  iscsi\_unblock\_session(session->cls\_session);- wake\_up(&conn->ehwait);+ wake\_up(&session->ehwait); return 0; } EXPORT\_SYMBOL\_GPL(iscsi\_conn\_start);@@ -3287,7 +3282,7 @@ void iscsi\_conn\_stop(struct iscsi\_cls\_conn \*cls\_conn, int flag) spin\_lock\_bh(&session->frwd\_lock); fail\_scsi\_tasks(conn, -1, DID\_TRANSPORT\_DISRUPTED); fail\_mgmt\_tasks(session, conn);- memset(&conn->tmhdr, 0, sizeof(conn->tmhdr));+ memset(&session->tmhdr, 0, sizeof(session->tmhdr)); spin\_unlock\_bh(&session->frwd\_lock); mutex\_unlock(&session->eh\_mutex); }diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.hindex 091f284bd6e93d..2bb452a8f134c7 100644--- a/[include/scsi/libiscsi.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/scsi/libiscsi.h?id=bf3ce567db5639aab2010a49b4e522830e0887a0)+++ b/[include/scsi/libiscsi.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/scsi/libiscsi.h?id=fa9542b35ceb4202e8f8d65f440529a63524dca9)@@ -195,12 +195,6 @@ struct iscsi\_conn { unsigned long suspend\_tx; /\* suspend Tx \*/ unsigned long suspend\_rx; /\* suspend Rx \*/ - /\* abort \*/- wait\_queue\_head\_t ehwait; /\* used in eh\_abort() \*/- struct iscsi\_tm tmhdr;- struct timer\_list tmf\_timer;- int tmf\_state; /\* see TMF\_INITIAL, etc.\*/- /\* negotiated params \*/ unsigned max\_recv\_dlength; /\* initiator\_max\_recv\_dsl\*/ unsigned max\_xmit\_dlength; /\* target\_max\_recv\_dsl \*/@@ -270,6 +264,11 @@ struct iscsi\_session { \* and recv lock. \*/ struct mutex eh\_mutex;+ /\* abort \*/+ wait\_queue\_head\_t ehwait; /\* used in eh\_abort() \*/+ struct iscsi\_tm tmhdr;+ struct timer\_list tmf\_timer;+ int tmf\_state; /\* see TMF\_INITIAL, etc.\*/  /\* iSCSI session-wide sequencing \*/ uint32\_t cmdsn; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 14:09:40 +0000

