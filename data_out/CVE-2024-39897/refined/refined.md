```
{
  "vulnerability": {
    "root_cause": "The cache driver's `GetBlob()` method allowed read access to any blob without access control checks. This was due to the global cache being searched when a blob was requested for a repository and that blob existing in the cache from another repository, effectively bypassing access control policies.",
    "weaknesses": [
      "CWE-639",
      "Improper Authorization"
    ],
    "impact": "An attacker could read images that the `accessControl` policy denied if they had read access to any other second repository. This allowed accessing blobs (both config and layers) by digest, but not manifests.",
    "attack_vectors": "An attacker needs to know the name of a private image and its layer digests, possibly obtained through public CI build logs that publish to a private repository. The attacker needs read access to a different repository than the one containing the target image. They would then make a `HEAD` request to the `/v2/<name>/blobs/<digest>` endpoint, which will fetch the blob from the cache if it exists, even if they lack permissions on the original repo. Subsequently, a `GET` request to `/v2/<name>/blobs/<digest>` will read the blob.",
    "required_capabilities": "The attacker needs: \n 1. Knowledge of a private image name and its layer digests.\n 2. Read access to at least one repository.\n 3. The target image must exist in the global cache.",
      "additional_details": "The vulnerability occurs because the `ImageStore.CheckBlob()` function calls `checkCacheBlob()` to find a blob, and if found, copies it to the user's requested repository, bypassing access control checks. Additionally, `RouteHandler.CheckBlob()` also uses the global cache, potentially returning a result from an incorrect repository and storing it for the requested repository. While `RouteHandler.GetBlob()` is not directly vulnerable, an attacker could use `CheckBlob()` first and then `GetBlob()`."
  }
}
```