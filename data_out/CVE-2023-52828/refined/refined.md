```
{
  "vulnerability_details": {
    "root_cause": "The BPF verifier's dead code elimination, combined with the `bpf_throw` kfunc's noreturn semantics, can lead to the final instruction of a BPF program being a call instruction to a throwing function. In such cases, the return address (which the JIT emits as int3 on x86) will lie outside the program's jited_len, leading to unreliable stack unwinding.",
    "weaknesses": [
      "Incorrect handling of program boundaries during stack unwinding when the final instruction is a call to a function with noreturn semantics.",
       "Dead code elimination in the BPF verifier causing instructions after a `bpf_throw` call to be marked as unseen."
    ],
    "impact": "Unreliable stack unwinding of BPF programs which can result in a kernel panic due to the inability to discover the correct return address, or other undefined behavior when unwinding fails.",
    "attack_vectors": "A malicious BPF program can trigger this vulnerability. The program must be crafted such that the last instruction before a throw is a call, which is not marked as seen by the verifier.",
    "required_capabilities": "The attacker needs the ability to load and execute BPF programs. This typically requires root or elevated privileges."
  },
  "affected_component": "BPF core in the Linux kernel",
   "fix_details": "The fix modifies `bpf_prog_ksym_find` to consider `IP == ksym.end` as part of the BPF program. Specifically, the comparison `val >= ksym->end` is changed to `val > ksym->end` in `bpf_tree_comp` within `kernel/bpf/core.c`. This adjustment ensures `is_bpf_text_address` returns true when the instruction pointer equals the end of the ksymbol, which enables reliable unwinding even when the final instruction is a call instruction.",
  "additional_notes": "The vulnerability is triggered when a BPF program ends with a call instruction to a function with noreturn semantics, such as `bpf_throw`, and the stack unwinding process doesn't treat the return address emitted after the call as part of the program, leading to kernel panic due to incorrect stack unwinding."
}
```