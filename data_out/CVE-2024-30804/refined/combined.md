=== Content from github.com_8e03b0dc_20250111_073842.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FDriverHunter%2FWin-Driver-EXP%2Ftree%2Fmain%2FCVE-2024-30804)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FDriverHunter%2FWin-Driver-EXP%2Ftree%2Fmain%2FCVE-2024-30804)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Ffiles%2Fdisambiguate&source=header-repo&source_repo=DriverHunter%2FWin-Driver-EXP)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[DriverHunter](/DriverHunter)
/
**[Win-Driver-EXP](/DriverHunter/Win-Driver-EXP)**
Public

* [Notifications](/login?return_to=%2FDriverHunter%2FWin-Driver-EXP) You must be signed in to change notification settings
* [Fork
  4](/login?return_to=%2FDriverHunter%2FWin-Driver-EXP)
* [Star
   20](/login?return_to=%2FDriverHunter%2FWin-Driver-EXP)

* [Code](/DriverHunter/Win-Driver-EXP)
* [Issues
  0](/DriverHunter/Win-Driver-EXP/issues)
* [Pull requests
  0](/DriverHunter/Win-Driver-EXP/pulls)
* [Actions](/DriverHunter/Win-Driver-EXP/actions)
* [Projects
  0](/DriverHunter/Win-Driver-EXP/projects)
* [Security](/DriverHunter/Win-Driver-EXP/security)
* [Insights](/DriverHunter/Win-Driver-EXP/pulse)

Additional navigation options

* [Code](/DriverHunter/Win-Driver-EXP)
* [Issues](/DriverHunter/Win-Driver-EXP/issues)
* [Pull requests](/DriverHunter/Win-Driver-EXP/pulls)
* [Actions](/DriverHunter/Win-Driver-EXP/actions)
* [Projects](/DriverHunter/Win-Driver-EXP/projects)
* [Security](/DriverHunter/Win-Driver-EXP/security)
* [Insights](/DriverHunter/Win-Driver-EXP/pulse)

## Files

 main
## Breadcrumbs

1. [Win-Driver-EXP](/DriverHunter/Win-Driver-EXP/tree/main)
/
# CVE-2024-30804

/Copy path
## Directory actions

## More options

## Directory actions

## More options

## Latest commit

## History

[History](/DriverHunter/Win-Driver-EXP/commits/main/CVE-2024-30804) main
## Breadcrumbs

1. [Win-Driver-EXP](/DriverHunter/Win-Driver-EXP/tree/main)
/
# CVE-2024-30804

/Top
## Folders and files

| Name | | Name | Last commit message | Last commit date |
| --- | --- | --- | --- | --- |
| parent directory[..](/DriverHunter/Win-Driver-EXP/tree/main) | | |
| [AsInsHelp32.sys](/DriverHunter/Win-Driver-EXP/blob/main/CVE-2024-30804/AsInsHelp32.sys "AsInsHelp32.sys") | | [AsInsHelp32.sys](/DriverHunter/Win-Driver-EXP/blob/main/CVE-2024-30804/AsInsHelp32.sys "AsInsHelp32.sys") |  |  |
| [AsInsHelp64.sys](/DriverHunter/Win-Driver-EXP/blob/main/CVE-2024-30804/AsInsHelp64.sys "AsInsHelp64.sys") | | [AsInsHelp64.sys](/DriverHunter/Win-Driver-EXP/blob/main/CVE-2024-30804/AsInsHelp64.sys "AsInsHelp64.sys") |  |  |
| [CVE-2024-30804.exe](/DriverHunter/Win-Driver-EXP/blob/main/CVE-2024-30804/CVE-2024-30804.exe "CVE-2024-30804.exe") | | [CVE-2024-30804.exe](/DriverHunter/Win-Driver-EXP/blob/main/CVE-2024-30804/CVE-2024-30804.exe "CVE-2024-30804.exe") |  |  |
| [README.md](/DriverHunter/Win-Driver-EXP/blob/main/CVE-2024-30804/README.md "README.md") | | [README.md](/DriverHunter/Win-Driver-EXP/blob/main/CVE-2024-30804/README.md "README.md") |  |  |
| [result.png](/DriverHunter/Win-Driver-EXP/blob/main/CVE-2024-30804/result.png "result.png") | | [result.png](/DriverHunter/Win-Driver-EXP/blob/main/CVE-2024-30804/result.png "result.png") |  |  |
| View all files | | |

## [README.md](#readme)

# Vulnerable Driver AsInsHelp64.sys in ASUS Fan\_Xpert

---

ASUS Fan\_Xper is used to control the fan speed. Many vulnerability exits in it's driver AsInsHelp64.sys Before version 10013, which allows low-privileged users to map arbitrary physical memory, read and write arbitary i/o port via specially crafted IOCTL requests. This can be exploited for privilege escalation, code execution under high privileges, and information disclosure. These signed drivers can also be used to bypass the Microsoft driver-signing policy to deploy malicious code.

Using AsInsHelp64.sys as example, AsInsHelp32.sys is also similar.

## version

10013

## Vulnerability causes

AsInsHelp64.sys provides the functionality of mapping physical memory and In/Out I/O ports, but it does not restrict the privileges of the caller, resulting in low-privileged users being able to call the driver and execute corresponding functions through DeviceIoControl.

```
__int64 __fastcall sub_116F0(__int64 a1, __int64 a2) // ioctler
{
  char is32bitprocess; // si
  __int64 v5; // rdx
  int v6; // ebx
  char v7; // al
  unsigned int v8; // eax
  void *v9; // rdx
  __int64 v10; // rax

  is32bitprocess = IoIs32bitProcess((PIRP)a2);
  *(_QWORD *)(a2 + 56) = 0i64;
  v5 = *(_QWORD *)(a2 + 184);
  v6 = -1073741822;
  v7 = *(_BYTE *)v5;
  if ( !*(_BYTE *)v5 || v7 == 2 )
  {
    v6 = 0;
    goto LABEL_28;
  }
  if ( v7 != 14 )
    goto LABEL_28;
  v8 = *(_DWORD *)(v5 + 24);
  if ( v8 > 0xA0406408 )
  {
    if ( v8 == 0xA040A440 || v8 == 0xA040A444 || v8 == 0xA040A448 )
      v6 = sub_11110(a2, v5, is32bitprocess);   // out arbitary I/O port
    goto LABEL_28;
  }
  switch ( v8 )
  {
    case 0xA0406408:
LABEL_10:
      v6 = sub_11000(a2, v5);                   // in arbitary I/O port
      break;
    case 0xA040244C:
      v6 = sub_112F0(a1, a2, *(_QWORD *)(a2 + 184), is32bitprocess);// map physical address
      if ( v6 < 0 )
      {
        *(_DWORD *)(a2 + 48) = -1073741811;
      }
      else
      {
        v10 = 8i64;
        if ( is32bitprocess )
          v10 = 4i64;
        *(_QWORD *)(a2 + 56) = v10;
      }
      break;
    case 0xA0402450:
      if ( is32bitprocess )
      {
        if ( *(_DWORD *)(v5 + 16) >= 4u )
        {
          v9 = (void *)**(unsigned int **)(a2 + 24);
LABEL_14:
          v6 = ZwUnmapViewOfSection((HANDLE)0xFFFFFFFFFFFFFFFFi64, v9);
          break;
        }
      }
      else if ( *(_DWORD *)(v5 + 16) >= 8u )
      {
        v9 = **(void ***)(a2 + 24);
        goto LABEL_14;
      }
      v6 = -1073741670;
      break;
    case 0xA0406400:
    case 0xA0406404:
      goto LABEL_10;
  }
LABEL_28:
  *(_DWORD *)(a2 + 48) = v6;
  IofCompleteRequest((PIRP)a2, 0);
  return (unsigned int)v6;
}
```

### IOCTL 0xA040244C

This IOCTL code triggers the mapping of physical memory. The composition of the input buffer is as follows.

```
#pragma pack (1)
typedef struct {
	ULONG64	junk1;
	ULONG64 section_offset; // The physical address you want to map.
	DWORD junk2;
	DWORD view_size;		// How many bytes
} AsInsHelp64_Map_Inputbuffer;
#pragma pack()
```

The memory mapping is eventually completed by calling ZwMapViewOfSection.

```
__int64 __fastcall sub_112F0(__int64 a1, __int64 a2, __int64 a3, bool is32bitprocess)
{
  PHYSICAL_ADDRESS *v5; // rdi
  _DWORD *v6; // r13
  NTSTATUS v7; // ebx
  HANDLE v8; // rcx
  _DWORD *v9; // r14
  DWORD v10; // ecx
  DWORD LowPart; // eax
  void *SectionHandle; // [rsp+50h] [rbp-D8h] BYREF
  ULONG AddressSpace; // [rsp+58h] [rbp-D0h] BYREF
  LARGE_INTEGER TranslatedAddress; // [rsp+60h] [rbp-C8h] BYREF
  union _LARGE_INTEGER SectionOffset; // [rsp+68h] [rbp-C0h] BYREF
  HANDLE Handle; // [rsp+70h] [rbp-B8h] BYREF
  ULONG_PTR ViewSize; // [rsp+78h] [rbp-B0h] BYREF
  PHYSICAL_ADDRESS BusAddress; // [rsp+80h] [rbp-A8h] BYREF
  PVOID Object; // [rsp+88h] [rbp-A0h] BYREF
  PVOID v21; // [rsp+90h] [rbp-98h] BYREF
  ULONG v22; // [rsp+98h] [rbp-90h] BYREF
  PVOID BaseAddress; // [rsp+A0h] [rbp-88h] BYREF
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+A8h] [rbp-80h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+D8h] [rbp-50h] BYREF

  v5 = *(PHYSICAL_ADDRESS **)(a2 + 24);
  AddressSpace = v5[2].LowPart;
  v22 = AddressSpace;
  Handle = 0i64;
  v21 = 0i64;
  LODWORD(SectionHandle) = 0;
  LODWORD(Object) = 0;
  if ( is32bitprocess )
  {
    v6 = v5;
    if ( *(_DWORD *)(a3 + 16) < 0x18u || *(_DWORD *)(a3 + 8) < 4u )
    {
      v7 = 0xC000009A;
      goto LABEL_5;
    }
    v9 = v21;
  }
  else
  {
    v9 = v5;
    if ( *(_DWORD *)(a3 + 16) < 0x18u || *(_DWORD *)(a3 + 8) < 8u )
      return (unsigned int)-1073741670;
    v6 = v21;
  }
  RtlInitUnicodeString(&DestinationString, L"\\Device\\PhysicalMemory");
  ObjectAttributes.Length = 48;
  ObjectAttributes.RootDirectory = 0i64;
  ObjectAttributes.Attributes = 64;
  ObjectAttributes.ObjectName = &DestinationString;
  ObjectAttributes.SecurityDescriptor = 0i64;
  ObjectAttributes.SecurityQualityOfService = 0i64;
  if ( is32bitprocess )
  {
    v7 = ZwOpenSection(&SectionHandle, 0xF001Fu, &ObjectAttributes);
    if ( v7 < 0 )
      goto LABEL_5;
    v7 = ObReferenceObjectByHandle((HANDLE)(int)SectionHandle, 0xF001Fu, 0i64, 0, &Object, 0i64);
    if ( v7 < 0 )
      goto LABEL_5;
  }
  else
  {
    v7 = ZwOpenSection(&Handle, 0xF001Fu, &ObjectAttributes);
    if ( v7 < 0 )
      goto LABEL_32;
    v7 = ObReferenceObjectByHandle(Handle, 0xF001Fu, 0i64, 0, &v21, 0i64);
    if ( v7 < 0 )
      goto LABEL_32;
  }
  BusAddress.QuadPart = v5[1].QuadPart + v5[2].HighPart + (unsigned int)(unsigned __int16)v5[1].LowPart;
  if ( !HalTranslateBusAddress((INTERFACE_TYPE)v5->LowPart, v5->HighPart, v5[1], &AddressSpace, &TranslatedAddress)
    || !HalTranslateBusAddress((INTERFACE_TYPE)v5->LowPart, v5->HighPart, BusAddress, &v22, &BusAddress)
    || (v10 = BusAddress.LowPart - TranslatedAddress.LowPart,
        ViewSize = BusAddress.QuadPart - TranslatedAddress.QuadPart,
        BusAddress.LowPart == TranslatedAddress.LowPart) )
  {
    v7 = 0xC0000001;
    goto LABEL_5;
  }
  if ( AddressSpace )
  {
    LowPart = TranslatedAddress.LowPart;
    if ( is32bitprocess )
    {
      *v6 = TranslatedAddress.LowPart;
      v7 = 0;
      goto LABEL_5;
    }
    goto LABEL_30;
  }
  SectionOffset = TranslatedAddress;
  if ( !is32bitprocess )
  {
    BaseAddress = 0i64;
    v7 = ZwMapViewOfSection(
           Handle,                              // rcx
           (HANDLE)0xFFFFFFFFFFFFFFFFi64,       // rdx
           &BaseAddress,                        // r8
           0i64,                                // r9
           v10,                                 // commitsize==viewsize rsp+20
           &SectionOffset,                      // sectionoffset = inputbuffer 0x8-0xf
           &ViewSize,                           // rsp+30
           ViewShare,                           // rsp+38
           0,                                   // rsp+40
           0x204u);                             // rsp+48
    if ( v7 >= 0 )
    {
      LowPart = TranslatedAddress.LowPart + (_DWORD)BaseAddress - SectionOffset.LowPart;
LABEL_30:
      *v9 = LowPart;
      v7 = 0;
      goto LABEL_5;
    }
LABEL_32:
    v8 = Handle;
    if ( Handle )
      goto LABEL_33;
    return (unsigned int)v7;
  }
  HIDWORD(SectionHandle) = 0;
  v7 = ZwMapViewOfSection(
         (HANDLE)(int)SectionHandle,
         (HANDLE)0xFFFFFFFFFFFFFFFFi64,
         (void **)((char *)&SectionHandle + 4),
         0i64,
         v10,
         &SectionOffset,
         &ViewSize,
         ViewShare,
         0,
         0x204u);
  if ( v7 >= 0 )
  {
    HIDWORD(SectionHandle) += TranslatedAddress.LowPart - SectionOffset.LowPart;
    *v6 = HIDWORD(SectionHandle);
    v7 = 0;
  }
LABEL_5:
  if ( !is32bitprocess )
    goto LABEL_32;
  if ( (_DWORD)SectionHandle )
  {
    v8 = (HANDLE)(int)SectionHandle;
LABEL_33:
    ZwClose(v8);
  }
  return (unsigned int)v7;
}
```

### IOCTL 0xA0406400(in byte), 0xA0406404(in word), 0xA0406408(in dword)

This code triggers reading from an I/O port. The composition of the input buffer is as follows.

```
#pragma pack (1)
typedef struct {
	DWORD port // target port
} AsInsHelp64_In_Inputbuffer;
#pragma pack()
```

The I/O port reading is eventually completed in function below.

```
__int64 __fastcall sub_11000(__int64 a1, __int64 a2)
{
  int v3; // ebx
  _WORD *v4; // rdi
  ULONG v5; // esi
  unsigned __int32 v6; // eax
  unsigned __int16 v7; // ax
  unsigned __int8 v8; // al
  ULONG AddressSpace; // [rsp+30h] [rbp-48h] BYREF
  PHYSICAL_ADDRESS BusAddress; // [rsp+38h] [rbp-40h] BYREF

  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(_WORD **)(a1 + 24);
  switch ( v3 )
  {
    case 0xA0406400:
      v5 = 1;
      break;
    case 0xA0406404:
      v5 = 2;
      break;
    case 0xA0406408:
      v5 = 4;
      break;
    default:
      v5 = AddressSpace;
      break;
  }
  BusAddress.QuadPart = *(unsigned int *)v4;
  AddressSpace = 1;
  HalTranslateBusAddress(Isa, 0, BusAddress, &AddressSpace, &BusAddress);
  if ( AddressSpace == 1 )
  {
    if ( v3 != 0xA0406400 )
    {
      if ( v3 == 0xA0406404 )
      {
        v7 = __inword(BusAddress.LowPart);
        *v4 = v7;
      }
      else if ( v3 == 0xA0406408 )
      {
        v6 = __indword(BusAddress.LowPart);
        *(_DWORD *)v4 = v6;
      }
      goto LABEL_22;
    }
    v8 = __inbyte(BusAddress.LowPart);
LABEL_21:
    *(_BYTE *)v4 = v8;
    goto LABEL_22;
  }
  switch ( v3 )
  {
    case 0xA0406400:
      v8 = *(_BYTE *)BusAddress.LowPart;
      goto LABEL_21;
    case 0xA0406404:
      *v4 = *(_WORD *)BusAddress.LowPart;
      break;
    case 0xA0406408:
      *(_DWORD *)v4 = *(_DWORD *)BusAddress.LowPart;
      break;
  }
LABEL_22:
  *(_QWORD *)(a1 + 56) = v5;
  return 0i64;
}
```

### IOCTL 0xA040A440 (out byte), 0xA040A444(out word) , 0xA040A448 (out dword)

This code triggers reading from an I/O port. The composition of the input buffer is as follows.

```
DWORDLONG inputbuffer= (DWORD64)data << 32 | port;
```

The I/O port reading is eventually completed in function below.

```
__int64 __fastcall sub_11110(__int64 a1, __int64 a2, char is32bitprocess)
{
  int v4; // r12d
  _DWORD *v5; // rdi
  unsigned int v6; // eax
  unsigned __int8 *v7; // rdi
  DWORD *QuadPart; // rbx
  unsigned int *v9; // rbx
  ULONG AddressSpace; // [rsp+30h] [rbp-38h] BYREF
  PHYSICAL_ADDRESS BusAddress; // [rsp+38h] [rbp-30h] BYREF

  v4 = *(_DWORD *)(a2 + 24);
  if ( is32bitprocess )
  {
    v5 = *(_DWORD **)(a1 + 24);
    v6 = *v5;
    v7 = (unsigned __int8 *)(v5 + 1);
    QuadPart = (DWORD *)BusAddress.QuadPart;
  }
  else
  {
    v9 = *(unsigned int **)(a1 + 24);
    v6 = *v9;
    QuadPart = v9 + 1;
    v7 = (unsigned __int8 *)BusAddress.QuadPart;
  }
  BusAddress.QuadPart = v6;
  AddressSpace = 1;
  HalTranslateBusAddress(Isa, 0, (PHYSICAL_ADDRESS)v6, &AddressSpace, &BusAddress);
  if ( AddressSpace != 1 )
  {
    switch ( v4 )
    {
      case 0xA040A440:
        if ( is32bitprocess )
        {
          *(_BYTE *)BusAddress.LowPart = *v7;
          _mm_sfence();
          return 0i64;
        }
        LOBYTE(BusAddress.LowPart) = *(_BYTE *)QuadPart;
        _mm_sfence();
        return 0i64;
      case 0xA040A444:
        if ( is32bitprocess )
          *(_WORD *)BusAddress.LowPart = *(_WORD *)v7;
        else
          LOWORD(BusAddress.LowPart) = *(_WORD *)QuadPart;
        break;
      case 0xA040A448:
        if ( is32bitprocess )
          *(_DWORD *)BusAddress.LowPart = *(_DWORD *)v7;
        else
          BusAddress.LowPart = *QuadPart;
        break;
      default:
        return 0i64;
    }
    _mm_sfence();
    return 0i64;
  }
  switch ( v4 )
  {
    case 0xA040A440:
      if ( is32bitprocess )
        __outbyte(BusAddress.LowPart, *v7);
      else
        __outbyte((unsigned __int16)&BusAddress, *(_BYTE *)QuadPart);
      return 0i64;
    case 0xA040A444:
      if ( is32bitprocess )
        __outword(BusAddress.LowPart, *(_WORD *)v7);
      else
        __outword((unsigned __int16)&BusAddress, *(_WORD *)QuadPart);
      return 0i64;
    case 0xA040A448:
      if ( is32bitprocess )
        __outdword(BusAddress.LowPart, *(_DWORD *)v7);
      else
        __outdword((unsigned __int16)&BusAddress, *QuadPart);
      return 0i64;
    default:
      return 0i64;
  }
}
```

## Vulnerability reproduce

Load AsInsHelp64.sys and run CVE-2024-30804.exe

[![image-result](/DriverHunter/Win-Driver-EXP/raw/main/CVE-2024-30804/result.png)](/DriverHunter/Win-Driver-EXP/blob/main/CVE-2024-30804/result.png)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


