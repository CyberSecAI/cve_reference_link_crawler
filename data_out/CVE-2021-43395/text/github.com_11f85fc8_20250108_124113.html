
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fillumos%2Fillumos-gate%2Fblob%2Fb3403853e80914bd0aade9b5b605da4878078173%2Fusr%2Fsrc%2Futs%2Fcommon%2Ffs%2Ftmpfs%2Ftmp_dir.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fillumos%2Fillumos-gate%2Fblob%2Fb3403853e80914bd0aade9b5b605da4878078173%2Fusr%2Fsrc%2Futs%2Fcommon%2Ffs%2Ftmpfs%2Ftmp_dir.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=illumos%2Fillumos-gate)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[illumos](/illumos)
/
**[illumos-gate](/illumos/illumos-gate)**
Public

* [Notifications](/login?return_to=%2Fillumos%2Fillumos-gate) You must be signed in to change notification settings
* [Fork
  768](/login?return_to=%2Fillumos%2Fillumos-gate)
* [Star
   1.7k](/login?return_to=%2Fillumos%2Fillumos-gate)

* [Code](/illumos/illumos-gate)
* [Pull requests
  8](/illumos/illumos-gate/pulls)
* [Actions](/illumos/illumos-gate/actions)
* [Security](/illumos/illumos-gate/security)
* [Insights](/illumos/illumos-gate/pulse)

Additional navigation options

* [Code](/illumos/illumos-gate)
* [Pull requests](/illumos/illumos-gate/pulls)
* [Actions](/illumos/illumos-gate/actions)
* [Security](/illumos/illumos-gate/security)
* [Insights](/illumos/illumos-gate/pulse)

## Files

 b340385
## Breadcrumbs

1. [illumos-gate](/illumos/illumos-gate/tree/b3403853e80914bd0aade9b5b605da4878078173)
2. /[usr](/illumos/illumos-gate/tree/b3403853e80914bd0aade9b5b605da4878078173/usr)
3. /[src](/illumos/illumos-gate/tree/b3403853e80914bd0aade9b5b605da4878078173/usr/src)
4. /[uts](/illumos/illumos-gate/tree/b3403853e80914bd0aade9b5b605da4878078173/usr/src/uts)
5. /[common](/illumos/illumos-gate/tree/b3403853e80914bd0aade9b5b605da4878078173/usr/src/uts/common)
6. /[fs](/illumos/illumos-gate/tree/b3403853e80914bd0aade9b5b605da4878078173/usr/src/uts/common/fs)
7. /[tmpfs](/illumos/illumos-gate/tree/b3403853e80914bd0aade9b5b605da4878078173/usr/src/uts/common/fs/tmpfs)
/
# tmp\_dir.c

 Blame  Blame
## Latest commit

## History

[History](/illumos/illumos-gate/commits/b3403853e80914bd0aade9b5b605da4878078173/usr/src/uts/common/fs/tmpfs/tmp_dir.c)1095 lines (971 loc) · 26.4 KB b340385
## Breadcrumbs

1. [illumos-gate](/illumos/illumos-gate/tree/b3403853e80914bd0aade9b5b605da4878078173)
2. /[usr](/illumos/illumos-gate/tree/b3403853e80914bd0aade9b5b605da4878078173/usr)
3. /[src](/illumos/illumos-gate/tree/b3403853e80914bd0aade9b5b605da4878078173/usr/src)
4. /[uts](/illumos/illumos-gate/tree/b3403853e80914bd0aade9b5b605da4878078173/usr/src/uts)
5. /[common](/illumos/illumos-gate/tree/b3403853e80914bd0aade9b5b605da4878078173/usr/src/uts/common)
6. /[fs](/illumos/illumos-gate/tree/b3403853e80914bd0aade9b5b605da4878078173/usr/src/uts/common/fs)
7. /[tmpfs](/illumos/illumos-gate/tree/b3403853e80914bd0aade9b5b605da4878078173/usr/src/uts/common/fs/tmpfs)
/
# tmp\_dir.c

Top
## File metadata and controls

* Code
* Blame

1095 lines (971 loc) · 26.4 KB[Raw](https://github.com/illumos/illumos-gate/raw/b3403853e80914bd0aade9b5b605da4878078173/usr/src/uts/common/fs/tmpfs/tmp_dir.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\* \* CDDL HEADER START \* \* The contents of this file are subject to the terms of the \* Common Development and Distribution License (the "License"). \* You may not use this file except in compliance with the License. \* \* You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE \* or http://www.opensolaris.org/os/licensing. \* See the License for the specific language governing permissions \* and limitations under the License. \* \* When distributing Covered Code, include this CDDL HEADER in each \* file and include the License file at usr/src/OPENSOLARIS.LICENSE. \* If applicable, add the following below this CDDL HEADER, with the \* fields enclosed by brackets "[]" replaced with your own identifying \* information: Portions Copyright [yyyy] [name of copyright owner] \* \* CDDL HEADER END \*//\* \* Copyright 2007 Sun Microsystems, Inc. All rights reserved. \* Use is subject to license terms. \*/
#pragma ident "%Z%%M% %I% %E% SMI"
#include <sys/types.h>#include <sys/param.h>#include <sys/sysmacros.h>#include <sys/systm.h>#include <sys/time.h>#include <sys/vfs.h>#include <sys/vnode.h>#include <sys/errno.h>#include <sys/cmn\_err.h>#include <sys/cred.h>#include <sys/stat.h>#include <sys/debug.h>#include <sys/policy.h>#include <sys/fs/tmpnode.h>#include <sys/fs/tmp.h>#include <sys/vtrace.h>
static int tdircheckpath(struct tmpnode \*, struct tmpnode \*, struct cred \*);static int tdirrename(struct tmpnode \*, struct tmpnode \*, struct tmpnode \*, char \*, struct tmpnode \*, struct tdirent \*, struct cred \*);static void tdirfixdotdot(struct tmpnode \*, struct tmpnode \*, struct tmpnode \*);static int tdirmaketnode(struct tmpnode \*, struct tmount \*, struct vattr \*, enum de\_op, struct tmpnode \*\*, struct cred \*);static int tdiraddentry(struct tmpnode \*, struct tmpnode \*, char \*, enum de\_op, struct tmpnode \*);
#define T\_HASH\_SIZE 8192 /\* must be power of 2 \*/#define T\_MUTEX\_SIZE 64
static struct tdirent \*t\_hashtable[T\_HASH\_SIZE];static kmutex\_t t\_hashmutex[T\_MUTEX\_SIZE];
#define T\_HASH\_INDEX(a) ((a) & (T\_HASH\_SIZE-1))#define T\_MUTEX\_INDEX(a) ((a) & (T\_MUTEX\_SIZE-1))
#define TMPFS\_HASH(tp, name, hash) \ { \ char Xc, \*Xcp; \ hash = (uint\_t)(uintptr\_t)(tp) >> 8; \ for (Xcp = (name); (Xc = \*Xcp) != 0; Xcp++) \ hash = (hash << 4) + hash + (uint\_t)Xc; \ }
voidtmpfs\_hash\_init(void){ int ix;
 for (ix = 0; ix < T\_MUTEX\_SIZE; ix++) mutex\_init(&t\_hashmutex[ix], NULL, MUTEX\_DEFAULT, NULL);}
/\* \* This routine is where the rubber meets the road for identities. \*/static voidtmpfs\_hash\_in(struct tdirent \*t){ uint\_t hash; struct tdirent \*\*prevpp; kmutex\_t \*t\_hmtx;
 TMPFS\_HASH(t->td\_parent, t->td\_name, hash); t->td\_hash = hash; prevpp = &t\_hashtable[T\_HASH\_INDEX(hash)]; t\_hmtx = &t\_hashmutex[T\_MUTEX\_INDEX(hash)]; mutex\_enter(t\_hmtx); t->td\_link = \*prevpp; \*prevpp = t; mutex\_exit(t\_hmtx);}
/\* \* Remove tdirent \*t from the hash list. \*/static voidtmpfs\_hash\_out(struct tdirent \*t){ uint\_t hash; struct tdirent \*\*prevpp; kmutex\_t \*t\_hmtx;
 hash = t->td\_hash; prevpp = &t\_hashtable[T\_HASH\_INDEX(hash)]; t\_hmtx = &t\_hashmutex[T\_MUTEX\_INDEX(hash)]; mutex\_enter(t\_hmtx); while (\*prevpp != t) prevpp = &(\*prevpp)->td\_link; \*prevpp = t->td\_link; mutex\_exit(t\_hmtx);}
/\* \* Currently called by tdirrename() only. \* rename operation needs to be done with lock held, to ensure that \* no other operations can access the tmpnode at the same instance. \*/static voidtmpfs\_hash\_change(struct tdirent \*tdp, struct tmpnode \*fromtp){ uint\_t hash; kmutex\_t \*t\_hmtx;
 hash = tdp->td\_hash; t\_hmtx = &t\_hashmutex[T\_MUTEX\_INDEX(hash)]; mutex\_enter(t\_hmtx); tdp->td\_tmpnode = fromtp; mutex\_exit(t\_hmtx);}
static struct tdirent \*tmpfs\_hash\_lookup(char \*name, struct tmpnode \*parent, uint\_t hold, struct tmpnode \*\*found){ struct tdirent \*l; uint\_t hash; kmutex\_t \*t\_hmtx; struct tmpnode \*tnp;
 TMPFS\_HASH(parent, name, hash); t\_hmtx = &t\_hashmutex[T\_MUTEX\_INDEX(hash)]; mutex\_enter(t\_hmtx); l = t\_hashtable[T\_HASH\_INDEX(hash)]; while (l) { if ((l->td\_hash == hash) && (l->td\_parent == parent) && (strcmp(l->td\_name, name) == 0)) { /\* \* We need to make sure that the tmpnode that \* we put a hold on is the same one that we pass back. \* Hence, temporary variable tnp is necessary. \*/ tnp = l->td\_tmpnode; if (hold) { ASSERT(tnp); tmpnode\_hold(tnp); } if (found) \*found = tnp; mutex\_exit(t\_hmtx); return (l); } else { l = l->td\_link; } } mutex\_exit(t\_hmtx); return (NULL);}
/\* \* Search directory 'parent' for entry 'name'. \* \* The calling thread can't hold the write version \* of the rwlock for the directory being searched \* \* 0 is returned on success and \*foundtp points \* to the found tmpnode with its vnode held. \*/inttdirlookup( struct tmpnode \*parent, char \*name, struct tmpnode \*\*foundtp, struct cred \*cred){ int error;
 \*foundtp = NULL; if (parent->tn\_type != VDIR) return (ENOTDIR);
 if ((error = tmp\_taccess(parent, VEXEC, cred))) return (error);
 if (\*name == '\0') { tmpnode\_hold(parent); \*foundtp = parent; return (0); }
 /\* \* Search the directory for the matching name \* We need the lock protecting the tn\_dir list \* so that it doesn't change out from underneath us. \* tmpfs\_hash\_lookup() will pass back the tmpnode \* with a hold on it. \*/
 if (tmpfs\_hash\_lookup(name, parent, 1, foundtp) != NULL) { ASSERT(\*foundtp); return (0); }
 return (ENOENT);}
/\* \* Enter a directory entry for 'name' and 'tp' into directory 'dir' \* \* Returns 0 on success. \*/inttdirenter( struct tmount \*tm, struct tmpnode \*dir, /\* target directory to make entry in \*/ char \*name, /\* name of entry \*/ enum de\_op op, /\* entry operation \*/ struct tmpnode \*fromparent, /\* source directory if rename \*/ struct tmpnode \*tp, /\* source tmpnode, if link/rename \*/ struct vattr \*va, struct tmpnode \*\*tpp, /\* return tmpnode, if create/mkdir \*/ struct cred \*cred, caller\_context\_t \*ctp){ struct tdirent \*tdp; struct tmpnode \*found = NULL; int error = 0; char \*s;
 /\* \* tn\_rwlock is held to serialize direnter and dirdeletes \*/ ASSERT(RW\_WRITE\_HELD(&dir->tn\_rwlock)); ASSERT(dir->tn\_type == VDIR);
 /\* \* Don't allow '/' characters in pathname component \* (thus in ufs\_direnter()). \*/ for (s = name; \*s; s++) if (\*s == '/') return (EACCES);
 if (name[0] == '\0') panic("tdirenter: NULL name");
 /\* \* For link and rename lock the source entry and check the link count \* to see if it has been removed while it was unlocked. \*/ if (op == DE\_LINK || op == DE\_RENAME) { if (tp != dir) rw\_enter(&tp->tn\_rwlock, RW\_WRITER); mutex\_enter(&tp->tn\_tlock); if (tp->tn\_nlink == 0) { mutex\_exit(&tp->tn\_tlock); if (tp != dir) rw\_exit(&tp->tn\_rwlock); return (ENOENT); }
 if (tp->tn\_nlink == MAXLINK) { mutex\_exit(&tp->tn\_tlock); if (tp != dir) rw\_exit(&tp->tn\_rwlock); return (EMLINK); } tp->tn\_nlink++; gethrestime(&tp->tn\_ctime); mutex\_exit(&tp->tn\_tlock); if (tp != dir) rw\_exit(&tp->tn\_rwlock); }
 /\* \* This might be a "dangling detached directory". \* it could have been removed, but a reference \* to it kept in u\_cwd. don't bother searching \* it, and with any luck the user will get tired \* of dealing with us and cd to some absolute \* pathway. \*sigh\*, thus in ufs, too. \*/ if (dir->tn\_nlink == 0) { error = ENOENT; goto out; }
 /\* \* If this is a rename of a directory and the parent is \* different (".." must be changed), then the source \* directory must not be in the directory hierarchy \* above the target, as this would orphan everything \* below the source directory. \*/ if (op == DE\_RENAME) { if (tp == dir) { error = EINVAL; goto out; } if (tp->tn\_type == VDIR) { if ((fromparent != dir) && (error = tdircheckpath(tp, dir, cred))) { goto out; } } }
 /\* \* Search for the entry. Return "found" if it exists. \*/ tdp = tmpfs\_hash\_lookup(name, dir, 1, &found);
 if (tdp) { ASSERT(found); switch (op) { case DE\_CREATE: case DE\_MKDIR: if (tpp) { \*tpp = found; error = EEXIST; } else { tmpnode\_rele(found); } break;
 case DE\_RENAME: error = tdirrename(fromparent, tp, dir, name, found, tdp, cred); if (error == 0) { if (found != NULL) { vnevent\_rename\_dest(TNTOV(found), TNTOV(dir), name, ctp); } }
 tmpnode\_rele(found); break;
 case DE\_LINK: /\* \* Can't link to an existing file. \*/ error = EEXIST; tmpnode\_rele(found); break; } } else {
 /\* \* The entry does not exist. Check write permission in \* directory to see if entry can be created. \*/ if (error = tmp\_taccess(dir, VWRITE, cred)) goto out; if (op == DE\_CREATE || op == DE\_MKDIR) { /\* \* Make new tmpnode and directory entry as required. \*/ error = tdirmaketnode(dir, tm, va, op, &tp, cred); if (error) goto out; } if (error = tdiraddentry(dir, tp, name, op, fromparent)) { if (op == DE\_CREATE || op == DE\_MKDIR) { /\* \* Unmake the inode we just made. \*/ rw\_enter(&tp->tn\_rwlock, RW\_WRITER); if ((tp->tn\_type) == VDIR) { ASSERT(tdp == NULL); /\* \* cleanup allocs made by tdirinit() \*/ tdirtrunc(tp); } mutex\_enter(&tp->tn\_tlock); tp->tn\_nlink = 0; mutex\_exit(&tp->tn\_tlock); gethrestime(&tp->tn\_ctime); rw\_exit(&tp->tn\_rwlock); tmpnode\_rele(tp); tp = NULL; } } else if (tpp) { \*tpp = tp; } else if (op == DE\_CREATE || op == DE\_MKDIR) { tmpnode\_rele(tp); } }
out: if (error && (op == DE\_LINK || op == DE\_RENAME)) { /\* \* Undo bumped link count. \*/ DECR\_COUNT(&tp->tn\_nlink, &tp->tn\_tlock); gethrestime(&tp->tn\_ctime); } return (error);}
/\* \* Delete entry tp of name "nm" from dir. \* Free dir entry space and decrement link count on tmpnode(s). \* \* Return 0 on success. \*/inttdirdelete( struct tmpnode \*dir, struct tmpnode \*tp, char \*nm, enum dr\_op op, struct cred \*cred){ struct tdirent \*tpdp; int error; size\_t namelen; struct tmpnode \*tnp; timestruc\_t now;
 ASSERT(RW\_WRITE\_HELD(&dir->tn\_rwlock)); ASSERT(RW\_WRITE\_HELD(&tp->tn\_rwlock)); ASSERT(dir->tn\_type == VDIR);
 if (nm[0] == '\0') panic("tdirdelete: NULL name for %p", (void \*)tp);
 /\* \* return error when removing . and .. \*/ if (nm[0] == '.') { if (nm[1] == '\0') return (EINVAL); if (nm[1] == '.' && nm[2] == '\0') return (EEXIST); /\* thus in ufs \*/ }
 if (error = tmp\_taccess(dir, VEXEC|VWRITE, cred)) return (error);
 /\* \* If the parent directory is "sticky", then the user must \* own the parent directory or the file in it, or else must \* have permission to write the file. Otherwise it may not \* be deleted (except by privileged users). \* Same as ufs\_dirremove. \*/ if ((error = tmp\_sticky\_remove\_access(dir, tp, cred)) != 0) return (error);
 if (dir->tn\_dir == NULL) return (ENOENT);
 tpdp = tmpfs\_hash\_lookup(nm, dir, 0, &tnp); if (tpdp == NULL) { /\* \* If it is gone, some other thread got here first! \* Return error ENOENT. \*/ return (ENOENT); }
 /\* \* If the tmpnode in the tdirent changed, we were probably \* the victim of a concurrent rename operation. The original \* is gone, so return that status (same as UFS). \*/ if (tp != tnp) return (ENOENT);
 tmpfs\_hash\_out(tpdp);
 /\* \* Take tpdp out of the directory list. \*/ ASSERT(tpdp->td\_next != tpdp); ASSERT(tpdp->td\_prev != tpdp); if (tpdp->td\_prev) { tpdp->td\_prev->td\_next = tpdp->td\_next; } if (tpdp->td\_next) { tpdp->td\_next->td\_prev = tpdp->td\_prev; }
 /\* \* If the roving slot pointer happens to match tpdp, \* point it at the previous dirent. \*/ if (dir->tn\_dir->td\_prev == tpdp) { dir->tn\_dir->td\_prev = tpdp->td\_prev; } ASSERT(tpdp->td\_next != tpdp); ASSERT(tpdp->td\_prev != tpdp);
 /\* \* tpdp points to the correct directory entry \*/ namelen = strlen(tpdp->td\_name) + 1;
 tmp\_memfree(tpdp, sizeof (struct tdirent) + namelen); dir->tn\_size -= (sizeof (struct tdirent) + namelen); dir->tn\_dirents--;
 gethrestime(&now); dir->tn\_mtime = now; dir->tn\_ctime = now; tp->tn\_ctime = now;
 ASSERT(tp->tn\_nlink > 0); DECR\_COUNT(&tp->tn\_nlink, &tp->tn\_tlock); if (op == DR\_RMDIR && tp->tn\_type == VDIR) { tdirtrunc(tp); ASSERT(tp->tn\_nlink == 0); } return (0);}
/\* \* tdirinit is used internally to initialize a directory (dir) \* with '.' and '..' entries without checking permissions and locking \*/voidtdirinit( struct tmpnode \*parent, /\* parent of directory to initialize \*/ struct tmpnode \*dir) /\* the new directory \*/{ struct tdirent \*dot, \*dotdot; timestruc\_t now;
 ASSERT(RW\_WRITE\_HELD(&parent->tn\_rwlock)); ASSERT(dir->tn\_type == VDIR);
 dot = tmp\_memalloc(sizeof (struct tdirent) + 2, TMP\_MUSTHAVE); dotdot = tmp\_memalloc(sizeof (struct tdirent) + 3, TMP\_MUSTHAVE);
 /\* \* Initialize the entries \*/ dot->td\_tmpnode = dir; dot->td\_offset = 0; dot->td\_name = (char \*)dot + sizeof (struct tdirent); dot->td\_name[0] = '.'; dot->td\_parent = dir; tmpfs\_hash\_in(dot);
 dotdot->td\_tmpnode = parent; dotdot->td\_offset = 1; dotdot->td\_name = (char \*)dotdot + sizeof (struct tdirent); dotdot->td\_name[0] = '.'; dotdot->td\_name[1] = '.'; dotdot->td\_parent = dir; tmpfs\_hash\_in(dotdot);
 /\* \* Initialize directory entry list. \*/ dot->td\_next = dotdot; dot->td\_prev = dotdot; /\* dot's td\_prev holds roving slot pointer \*/ dotdot->td\_next = NULL; dotdot->td\_prev = dot;
 gethrestime(&now); dir->tn\_mtime = now; dir->tn\_ctime = now;
 /\* \* Link counts are special for the hidden attribute directory. \* The only explicit reference in the name space is "." and \* the reference through ".." is not counted on the parent \* file. The attrdir is created as a side effect to lookup, \* so don't change the ctime of the parent. \* Since tdirinit is called with both dir and parent being the \* same for the root vnode, we need to increment this before we set \* tn\_nlink = 2 below. \*/ if (!(dir->tn\_vnode->v\_flag & V\_XATTRDIR)) { INCR\_COUNT(&parent->tn\_nlink, &parent->tn\_tlock); parent->tn\_ctime = now; }
 dir->tn\_dir = dot; dir->tn\_size = 2 \* sizeof (struct tdirent) + 5; /\* dot and dotdot \*/ dir->tn\_dirents = 2; dir->tn\_nlink = 2;}
/\* \* tdirtrunc is called to remove all directory entries under this directory. \*/voidtdirtrunc(struct tmpnode \*dir){ struct tdirent \*tdp; struct tmpnode \*tp; size\_t namelen; timestruc\_t now; int isvattrdir, isdotdot, skip\_decr;
 ASSERT(RW\_WRITE\_HELD(&dir->tn\_rwlock)); ASSERT(dir->tn\_type == VDIR);
 isvattrdir = (dir->tn\_vnode->v\_flag & V\_XATTRDIR) ? 1 : 0; for (tdp = dir->tn\_dir; tdp; tdp = dir->tn\_dir) { ASSERT(tdp->td\_next != tdp); ASSERT(tdp->td\_prev != tdp); ASSERT(tdp->td\_tmpnode);
 dir->tn\_dir = tdp->td\_next; namelen = strlen(tdp->td\_name) + 1;
 /\* \* Adjust the link counts to account for this directory \* entry removal. Hidden attribute directories may \* not be empty as they may be truncated as a side- \* effect of removing the parent. We do hold/rele \* operations to free up these tmpnodes. \* \* Skip the link count adjustment for parents of \* attribute directories as those link counts \* do not include the ".." reference in the hidden \* directories. \*/ tp = tdp->td\_tmpnode; isdotdot = (strcmp("..", tdp->td\_name) == 0); skip\_decr = (isvattrdir && isdotdot); if (!skip\_decr) { ASSERT(tp->tn\_nlink > 0); DECR\_COUNT(&tp->tn\_nlink, &tp->tn\_tlock); }
 tmpfs\_hash\_out(tdp);
 tmp\_memfree(tdp, sizeof (struct tdirent) + namelen); dir->tn\_size -= (sizeof (struct tdirent) + namelen); dir->tn\_dirents--; }
 gethrestime(&now); dir->tn\_mtime = now; dir->tn\_ctime = now;
 ASSERT(dir->tn\_dir == NULL); ASSERT(dir->tn\_size == 0); ASSERT(dir->tn\_dirents == 0);}
/\* \* Check if the source directory is in the path of the target directory. \* The target directory is locked by the caller. \* \* XXX - The source and target's should be different upon entry. \*/static inttdircheckpath( struct tmpnode \*fromtp, struct tmpnode \*toparent, struct cred \*cred){ int error = 0; struct tmpnode \*dir, \*dotdot; struct tdirent \*tdp;
 ASSERT(RW\_WRITE\_HELD(&toparent->tn\_rwlock));
 tdp = tmpfs\_hash\_lookup("..", toparent, 1, &dotdot); if (tdp == NULL) return (ENOENT);
 ASSERT(dotdot);
 if (dotdot == toparent) { /\* root of fs. search trivially satisfied. \*/ tmpnode\_rele(dotdot); return (0); } for (;;) { /\* \* Return error for cases like "mv c c/d", \* "mv c c/d/e" and so on. \*/ if (dotdot == fromtp) { tmpnode\_rele(dotdot); error = EINVAL; break; } dir = dotdot; error = tdirlookup(dir, "..", &dotdot, cred); if (error) { tmpnode\_rele(dir); break; } /\* \* We're okay if we traverse the directory tree up to \* the root directory and don't run into the \* parent directory. \*/ if (dir == dotdot) { tmpnode\_rele(dir); tmpnode\_rele(dotdot); break; } tmpnode\_rele(dir); } return (error);}
static inttdirrename( struct tmpnode \*fromparent, /\* parent directory of source \*/ struct tmpnode \*fromtp, /\* source tmpnode \*/ struct tmpnode \*toparent, /\* parent directory of target \*/ char \*nm, /\* entry we are trying to change \*/ struct tmpnode \*to, /\* target tmpnode \*/ struct tdirent \*where, /\* target tmpnode directory entry \*/ struct cred \*cred) /\* credentials \*/{ int error = 0; int doingdirectory; timestruc\_t now;
#if defined(lint) nm = nm;#endif ASSERT(RW\_WRITE\_HELD(&toparent->tn\_rwlock));
 /\* \* Short circuit rename of something to itself. \*/ if (fromtp == to) return (ESAME); /\* special KLUDGE error code \*/
 rw\_enter(&fromtp->tn\_rwlock, RW\_READER); rw\_enter(&to->tn\_rwlock, RW\_READER);
 /\* \* Check that everything is on the same filesystem. \*/ if (to->tn\_vnode->v\_vfsp != toparent->tn\_vnode->v\_vfsp || to->tn\_vnode->v\_vfsp != fromtp->tn\_vnode->v\_vfsp) { error = EXDEV; goto out; }
 /\* \* Must have write permission to rewrite target entry. \* Check for stickyness. \*/ if ((error = tmp\_taccess(toparent, VWRITE, cred)) != 0 || (error = tmp\_sticky\_remove\_access(toparent, to, cred)) != 0) goto out;
 /\* \* Ensure source and target are compatible (both directories \* or both not directories). If target is a directory it must \* be empty and have no links to it; in addition it must not \* be a mount point, and both the source and target must be \* writable. \*/ doingdirectory = (fromtp->tn\_type == VDIR); if (to->tn\_type == VDIR) { if (!doingdirectory) { error = EISDIR; goto out; } /\* \* vn\_vfswlock will prevent mounts from using the directory \* until we are done. \*/ if (vn\_vfswlock(TNTOV(to))) { error = EBUSY; goto out; } if (vn\_mountedvfs(TNTOV(to)) != NULL) { vn\_vfsunlock(TNTOV(to)); error = EBUSY; goto out; }
 mutex\_enter(&to->tn\_tlock); if (to->tn\_dirents > 2 || to->tn\_nlink > 2) { mutex\_exit(&to->tn\_tlock); vn\_vfsunlock(TNTOV(to)); error = EEXIST; /\* SIGH should be ENOTEMPTY \*/ /\* \* Update atime because checking tn\_dirents is \* logically equivalent to reading the directory \*/ gethrestime(&to->tn\_atime); goto out; } mutex\_exit(&to->tn\_tlock); } else if (doingdirectory) { error = ENOTDIR; goto out; }
 tmpfs\_hash\_change(where, fromtp); gethrestime(&now); toparent->tn\_mtime = now; toparent->tn\_ctime = now;
 /\* \* Upgrade to write lock on "to" (i.e., the target tmpnode). \*/ rw\_exit(&to->tn\_rwlock); rw\_enter(&to->tn\_rwlock, RW\_WRITER);
 /\* \* Decrement the link count of the target tmpnode. \*/ DECR\_COUNT(&to->tn\_nlink, &to->tn\_tlock); to->tn\_ctime = now;
 if (doingdirectory) { /\* \* The entry for "to" no longer exists so release the vfslock. \*/ vn\_vfsunlock(TNTOV(to));
 /\* \* Decrement the target link count and delete all entires. \*/ tdirtrunc(to); ASSERT(to->tn\_nlink == 0);
 /\* \* Renaming a directory with the parent different \* requires that ".." be rewritten. The window is \* still there for ".." to be inconsistent, but this \* is unavoidable, and a lot shorter than when it was \* done in a user process. \*/ if (fromparent != toparent) tdirfixdotdot(fromtp, fromparent, toparent); }out: rw\_exit(&to->tn\_rwlock); rw\_exit(&fromtp->tn\_rwlock); return (error);}
static voidtdirfixdotdot( struct tmpnode \*fromtp, /\* child directory \*/ struct tmpnode \*fromparent, /\* old parent directory \*/ struct tmpnode \*toparent) /\* new parent directory \*/{ struct tdirent \*dotdot;
 ASSERT(RW\_LOCK\_HELD(&toparent->tn\_rwlock));
 /\* \* Increment the link count in the new parent tmpnode \*/ INCR\_COUNT(&toparent->tn\_nlink, &toparent->tn\_tlock); gethrestime(&toparent->tn\_ctime);
 dotdot = tmpfs\_hash\_lookup("..", fromtp, 0, NULL);
 ASSERT(dotdot->td\_tmpnode == fromparent); dotdot->td\_tmpnode = toparent;
 /\* \* Decrement the link count of the old parent tmpnode. \* If fromparent is NULL, then this is a new directory link; \* it has no parent, so we need not do anything. \*/ if (fromparent != NULL) { mutex\_enter(&fromparent->tn\_tlock); if (fromparent->tn\_nlink != 0) { fromparent->tn\_nlink--; gethrestime(&fromparent->tn\_ctime); } mutex\_exit(&fromparent->tn\_tlock); }}
static inttdiraddentry( struct tmpnode \*dir, /\* target directory to make entry in \*/ struct tmpnode \*tp, /\* new tmpnode \*/ char \*name, enum de\_op op, struct tmpnode \*fromtp){ struct tdirent \*tdp, \*tpdp; size\_t namelen, alloc\_size; timestruc\_t now;
 /\* \* Make sure the parent directory wasn't removed from \* underneath the caller. \*/ if (dir->tn\_dir == NULL) return (ENOENT);
 /\* \* Check that everything is on the same filesystem. \*/ if (tp->tn\_vnode->v\_vfsp != dir->tn\_vnode->v\_vfsp) return (EXDEV);
 /\* \* Allocate and initialize directory entry \*/ namelen = strlen(name) + 1; alloc\_size = namelen + sizeof (struct tdirent); tdp = tmp\_memalloc(alloc\_size, 0); if (tdp == NULL) return (ENOSPC);
 if ((op == DE\_RENAME) && (tp->tn\_type == VDIR)) tdirfixdotdot(tp, fromtp, dir);
 dir->tn\_size += alloc\_size; dir->tn\_dirents++; tdp->td\_tmpnode = tp; tdp->td\_parent = dir;
 /\* \* The directory entry and its name were allocated sequentially. \*/ tdp->td\_name = (char \*)tdp + sizeof (struct tdirent); (void) strcpy(tdp->td\_name, name);
 tmpfs\_hash\_in(tdp);
 /\* \* Some utilities expect the size of a directory to remain \* somewhat static. For example, a routine which unlinks \* files between calls to readdir(); the size of the \* directory changes from underneath it and so the real \* directory offset in bytes is invalid. To circumvent \* this problem, we initialize a directory entry with an \* phony offset, and use this offset to determine end of \* file in tmp\_readdir. \*/ tpdp = dir->tn\_dir->td\_prev; /\* \* Install at first empty "slot" in directory list. \*/ while (tpdp->td\_next != NULL && (tpdp->td\_next->td\_offset - tpdp->td\_offset) <= 1) { ASSERT(tpdp->td\_next != tpdp); ASSERT(tpdp->td\_prev != tpdp); ASSERT(tpdp->td\_next->td\_offset > tpdp->td\_offset); tpdp = tpdp->td\_next; } tdp->td\_offset = tpdp->td\_offset + 1;
 /\* \* If we're at the end of the dirent list and the offset (which \* is necessarily the largest offset in this directory) is more \* than twice the number of dirents, that means the directory is \* 50% holes. At this point we reset the slot pointer back to \* the beginning of the directory so we start using the holes. \* The idea is that if there are N dirents, there must also be \* N holes, so we can satisfy the next N creates by walking at \* most 2N entries; thus the average cost of a create is constant. \* Note that we use the first dirent's td\_prev as the roving \* slot pointer; it's ugly, but it saves a word in every dirent. \*/ if (tpdp->td\_next == NULL && tpdp->td\_offset > 2 \* dir->tn\_dirents) dir->tn\_dir->td\_prev = dir->tn\_dir->td\_next; else dir->tn\_dir->td\_prev = tdp;
 ASSERT(tpdp->td\_next != tpdp); ASSERT(tpdp->td\_prev != tpdp);
 tdp->td\_next = tpdp->td\_next; if (tdp->td\_next) { tdp->td\_next->td\_prev = tdp; } tdp->td\_prev = tpdp; tpdp->td\_next = tdp;
 ASSERT(tdp->td\_next != tdp); ASSERT(tdp->td\_prev != tdp); ASSERT(tpdp->td\_next != tpdp);[View remainder of file in raw view](https://github.com/illumos/illumos-gate/raw/b3403853e80914bd0aade9b5b605da4878078173/usr/src/uts/common/fs/tmpfs/tmp_dir.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

