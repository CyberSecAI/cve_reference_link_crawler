
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fillumos%2Fillumos-gate%2Fblob%2F069654420de4aade43c63c43cd2896e66945fc8a%2Fusr%2Fsrc%2Futs%2Fcommon%2Ffs%2Ftmpfs%2Ftmp_vnops.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fillumos%2Fillumos-gate%2Fblob%2F069654420de4aade43c63c43cd2896e66945fc8a%2Fusr%2Fsrc%2Futs%2Fcommon%2Ffs%2Ftmpfs%2Ftmp_vnops.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=illumos%2Fillumos-gate)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[illumos](/illumos)
/
**[illumos-gate](/illumos/illumos-gate)**
Public

* [Notifications](/login?return_to=%2Fillumos%2Fillumos-gate) You must be signed in to change notification settings
* [Fork
  768](/login?return_to=%2Fillumos%2Fillumos-gate)
* [Star
   1.7k](/login?return_to=%2Fillumos%2Fillumos-gate)

* [Code](/illumos/illumos-gate)
* [Pull requests
  8](/illumos/illumos-gate/pulls)
* [Actions](/illumos/illumos-gate/actions)
* [Security](/illumos/illumos-gate/security)
* [Insights](/illumos/illumos-gate/pulse)

Additional navigation options

* [Code](/illumos/illumos-gate)
* [Pull requests](/illumos/illumos-gate/pulls)
* [Actions](/illumos/illumos-gate/actions)
* [Security](/illumos/illumos-gate/security)
* [Insights](/illumos/illumos-gate/pulse)

## Files

 0696544
## Breadcrumbs

1. [illumos-gate](/illumos/illumos-gate/tree/069654420de4aade43c63c43cd2896e66945fc8a)
2. /[usr](/illumos/illumos-gate/tree/069654420de4aade43c63c43cd2896e66945fc8a/usr)
3. /[src](/illumos/illumos-gate/tree/069654420de4aade43c63c43cd2896e66945fc8a/usr/src)
4. /[uts](/illumos/illumos-gate/tree/069654420de4aade43c63c43cd2896e66945fc8a/usr/src/uts)
5. /[common](/illumos/illumos-gate/tree/069654420de4aade43c63c43cd2896e66945fc8a/usr/src/uts/common)
6. /[fs](/illumos/illumos-gate/tree/069654420de4aade43c63c43cd2896e66945fc8a/usr/src/uts/common/fs)
7. /[tmpfs](/illumos/illumos-gate/tree/069654420de4aade43c63c43cd2896e66945fc8a/usr/src/uts/common/fs/tmpfs)
/
# tmp\_vnops.c

 Blame  Blame
## Latest commit

## History

[History](/illumos/illumos-gate/commits/069654420de4aade43c63c43cd2896e66945fc8a/usr/src/uts/common/fs/tmpfs/tmp_vnops.c)2469 lines (2188 loc) · 56.4 KB 0696544
## Breadcrumbs

1. [illumos-gate](/illumos/illumos-gate/tree/069654420de4aade43c63c43cd2896e66945fc8a)
2. /[usr](/illumos/illumos-gate/tree/069654420de4aade43c63c43cd2896e66945fc8a/usr)
3. /[src](/illumos/illumos-gate/tree/069654420de4aade43c63c43cd2896e66945fc8a/usr/src)
4. /[uts](/illumos/illumos-gate/tree/069654420de4aade43c63c43cd2896e66945fc8a/usr/src/uts)
5. /[common](/illumos/illumos-gate/tree/069654420de4aade43c63c43cd2896e66945fc8a/usr/src/uts/common)
6. /[fs](/illumos/illumos-gate/tree/069654420de4aade43c63c43cd2896e66945fc8a/usr/src/uts/common/fs)
7. /[tmpfs](/illumos/illumos-gate/tree/069654420de4aade43c63c43cd2896e66945fc8a/usr/src/uts/common/fs/tmpfs)
/
# tmp\_vnops.c

Top
## File metadata and controls

* Code
* Blame

2469 lines (2188 loc) · 56.4 KB[Raw](https://github.com/illumos/illumos-gate/raw/069654420de4aade43c63c43cd2896e66945fc8a/usr/src/uts/common/fs/tmpfs/tmp_vnops.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\* \* CDDL HEADER START \* \* The contents of this file are subject to the terms of the \* Common Development and Distribution License (the "License"). \* You may not use this file except in compliance with the License. \* \* You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE \* or http://www.opensolaris.org/os/licensing. \* See the License for the specific language governing permissions \* and limitations under the License. \* \* When distributing Covered Code, include this CDDL HEADER in each \* file and include the License file at usr/src/OPENSOLARIS.LICENSE. \* If applicable, add the following below this CDDL HEADER, with the \* fields enclosed by brackets "[]" replaced with your own identifying \* information: Portions Copyright [yyyy] [name of copyright owner] \* \* CDDL HEADER END \*/
/\* \* Copyright 2009 Sun Microsystems, Inc. All rights reserved. \* Use is subject to license terms. \*/
/\* \* Copyright (c) 2015, Joyent, Inc. All rights reserved. \* Copyright 2015 Nexenta Systems, Inc. All rights reserved. \* Copyright 2016 RackTop Systems. \* Copyright (c) 2017 by Delphix. All rights reserved. \*/
#include <sys/types.h>#include <sys/param.h>#include <sys/t\_lock.h>#include <sys/systm.h>#include <sys/sysmacros.h>#include <sys/user.h>#include <sys/time.h>#include <sys/vfs.h>#include <sys/vfs\_opreg.h>#include <sys/vnode.h>#include <sys/file.h>#include <sys/fcntl.h>#include <sys/flock.h>#include <sys/kmem.h>#include <sys/uio.h>#include <sys/errno.h>#include <sys/stat.h>#include <sys/cred.h>#include <sys/dirent.h>#include <sys/pathname.h>#include <sys/vmsystm.h>#include <sys/fs/tmp.h>#include <sys/fs/tmpnode.h>#include <sys/mman.h>#include <vm/hat.h>#include <vm/seg\_vn.h>#include <vm/seg\_map.h>#include <vm/seg.h>#include <vm/anon.h>#include <vm/as.h>#include <vm/page.h>#include <vm/pvn.h>#include <sys/cmn\_err.h>#include <sys/debug.h>#include <sys/swap.h>#include <sys/buf.h>#include <sys/vm.h>#include <sys/vtrace.h>#include <sys/policy.h>#include <fs/fs\_subr.h>
static int tmp\_getapage(struct vnode \*, u\_offset\_t, size\_t, uint\_t \*, page\_t \*\*, size\_t, struct seg \*, caddr\_t, enum seg\_rw, struct cred \*);static int tmp\_putapage(struct vnode \*, page\_t \*, u\_offset\_t \*, size\_t \*, int, struct cred \*);
/\* ARGSUSED1 \*/static inttmp\_open(struct vnode \*\*vpp, int flag, struct cred \*cred, caller\_context\_t \*ct){ /\* \* swapon to a tmpfs file is not supported so access \* is denied on open if VISSWAP is set. \*/ if ((\*vpp)->v\_flag & VISSWAP) return (EINVAL); return (0);}
/\* ARGSUSED1 \*/static inttmp\_close( struct vnode \*vp, int flag, int count, offset\_t offset, struct cred \*cred, caller\_context\_t \*ct){ cleanlocks(vp, ttoproc(curthread)->p\_pid, 0); cleanshares(vp, ttoproc(curthread)->p\_pid); return (0);}
/\* \* wrtmp does the real work of write requests for tmpfs. \*/static intwrtmp( struct tmount \*tm, struct tmpnode \*tp, struct uio \*uio, struct cred \*cr, struct caller\_context \*ct){ pgcnt\_t pageoffset; /\* offset in pages \*/ ulong\_t segmap\_offset; /\* pagesize byte offset into segmap \*/ caddr\_t base; /\* base of segmap \*/ ssize\_t bytes; /\* bytes to uiomove \*/ pfn\_t pagenumber; /\* offset in pages into tmp file \*/ struct vnode \*vp; int error = 0; int pagecreate; /\* == 1 if we allocated a page \*/ int newpage; rlim64\_t limit = uio->uio\_llimit; long oresid = uio->uio\_resid; timestruc\_t now;
 long tn\_size\_changed = 0; long old\_tn\_size; long new\_tn\_size;
 vp = TNTOV(tp); ASSERT(vp->v\_type == VREG);
 TRACE\_1(TR\_FAC\_TMPFS, TR\_TMPFS\_RWTMP\_START, "tmp\_wrtmp\_start:vp %p", vp);
 ASSERT(RW\_WRITE\_HELD(&tp->tn\_contents)); ASSERT(RW\_WRITE\_HELD(&tp->tn\_rwlock));
 if (MANDLOCK(vp, tp->tn\_mode)) { rw\_exit(&tp->tn\_contents); /\* \* tmp\_getattr ends up being called by chklock \*/ error = chklock(vp, FWRITE, uio->uio\_loffset, uio->uio\_resid, uio->uio\_fmode, ct); rw\_enter(&tp->tn\_contents, RW\_WRITER); if (error != 0) { TRACE\_2(TR\_FAC\_TMPFS, TR\_TMPFS\_RWTMP\_END, "tmp\_wrtmp\_end:vp %p error %d", vp, error); return (error); } }
 if (uio->uio\_loffset < 0) return (EINVAL);
 if (limit == RLIM64\_INFINITY || limit > MAXOFFSET\_T) limit = MAXOFFSET\_T;
 if (uio->uio\_loffset >= limit) { proc\_t \*p = ttoproc(curthread);
 mutex\_enter(&p->p\_lock); (void) rctl\_action(rctlproc\_legacy[RLIMIT\_FSIZE], p->p\_rctls, p, RCA\_UNSAFE\_SIGINFO); mutex\_exit(&p->p\_lock); return (EFBIG); }
 if (uio->uio\_loffset >= MAXOFF\_T) { TRACE\_2(TR\_FAC\_TMPFS, TR\_TMPFS\_RWTMP\_END, "tmp\_wrtmp\_end:vp %p error %d", vp, EINVAL); return (EFBIG); }
 if (uio->uio\_resid == 0) { TRACE\_2(TR\_FAC\_TMPFS, TR\_TMPFS\_RWTMP\_END, "tmp\_wrtmp\_end:vp %p error %d", vp, 0); return (0); }
 if (limit > MAXOFF\_T) limit = MAXOFF\_T;
 do { long offset; long delta;
 offset = (long)uio->uio\_offset; pageoffset = offset & PAGEOFFSET; /\* \* A maximum of PAGESIZE bytes of data is transferred \* each pass through this loop \*/ bytes = MIN(PAGESIZE - pageoffset, uio->uio\_resid);
 if (offset + bytes >= limit) { if (offset >= limit) { error = EFBIG; goto out; } bytes = limit - offset; } pagenumber = btop(offset);
 /\* \* delta is the amount of anonymous memory \* to reserve for the file. \* We always reserve in pagesize increments so \* unless we're extending the file into a new page, \* we don't need to call tmp\_resv. \*/ delta = offset + bytes - P2ROUNDUP\_TYPED(tp->tn\_size, PAGESIZE, u\_offset\_t); if (delta > 0) { pagecreate = 1; if (tmp\_resv(tm, tp, delta, pagecreate)) { /\* \* Log file system full in the zone that owns \* the tmpfs mount, as well as in the global \* zone if necessary. \*/ zcmn\_err(tm->tm\_vfsp->vfs\_zone->zone\_id, CE\_WARN, "%s: File system full, " "swap space limit exceeded", tm->tm\_mntpath);
 if (tm->tm\_vfsp->vfs\_zone->zone\_id != GLOBAL\_ZONEID) {
 vfs\_t \*vfs = tm->tm\_vfsp;
 zcmn\_err(GLOBAL\_ZONEID, CE\_WARN, "%s: File system full, " "swap space limit exceeded", vfs->vfs\_vnodecovered->v\_path); } error = ENOSPC; break; } tmpnode\_growmap(tp, (ulong\_t)offset + bytes); } /\* grow the file to the new length \*/ if (offset + bytes > tp->tn\_size) { tn\_size\_changed = 1; old\_tn\_size = tp->tn\_size; /\* \* Postpone updating tp->tn\_size until uiomove() is \* done. \*/ new\_tn\_size = offset + bytes; } if (bytes == PAGESIZE) { /\* \* Writing whole page so reading from disk \* is a waste \*/ pagecreate = 1; } else { pagecreate = 0; } /\* \* If writing past EOF or filling in a hole \* we need to allocate an anon slot. \*/ if (anon\_get\_ptr(tp->tn\_anon, pagenumber) == NULL) { (void) anon\_set\_ptr(tp->tn\_anon, pagenumber, anon\_alloc(vp, ptob(pagenumber)), ANON\_SLEEP); pagecreate = 1; tp->tn\_nblocks++; }
 /\* \* We have to drop the contents lock to allow the VM \* system to reacquire it in tmp\_getpage() \*/ rw\_exit(&tp->tn\_contents);
 /\* \* Touch the page and fault it in if it is not in core \* before segmap\_getmapflt or vpm\_data\_copy can lock it. \* This is to avoid the deadlock if the buffer is mapped \* to the same file through mmap which we want to write. \*/ uio\_prefaultpages((long)bytes, uio);
 newpage = 0; if (vpm\_enable) { /\* \* Copy data. If new pages are created, part of \* the page that is not written will be initizliazed \* with zeros. \*/ error = vpm\_data\_copy(vp, offset, bytes, uio, !pagecreate, &newpage, 1, S\_WRITE); } else { /\* Get offset within the segmap mapping \*/ segmap\_offset = (offset & PAGEMASK) & MAXBOFFSET; base = segmap\_getmapflt(segkmap, vp, (offset & MAXBMASK), PAGESIZE, !pagecreate, S\_WRITE); }
 if (!vpm\_enable && pagecreate) { /\* \* segmap\_pagecreate() returns 1 if it calls \* page\_create\_va() to allocate any pages. \*/ newpage = segmap\_pagecreate(segkmap, base + segmap\_offset, (size\_t)PAGESIZE, 0); /\* \* Clear from the beginning of the page to the starting \* offset of the data. \*/ if (pageoffset != 0) (void) kzero(base + segmap\_offset, (size\_t)pageoffset); }
 if (!vpm\_enable) { error = uiomove(base + segmap\_offset + pageoffset, (long)bytes, UIO\_WRITE, uio); }
 if (!vpm\_enable && pagecreate && uio->uio\_offset < P2ROUNDUP(offset + bytes, PAGESIZE)) { long zoffset; /\* zero from offset into page \*/ /\* \* We created pages w/o initializing them completely, \* thus we need to zero the part that wasn't set up. \* This happens on most EOF write cases and if \* we had some sort of error during the uiomove. \*/ long nmoved;
 nmoved = uio->uio\_offset - offset; ASSERT((nmoved + pageoffset) <= PAGESIZE);
 /\* \* Zero from the end of data in the page to the \* end of the page. \*/ if ((zoffset = pageoffset + nmoved) < PAGESIZE) (void) kzero(base + segmap\_offset + zoffset, (size\_t)PAGESIZE - zoffset); }
 /\* \* Unlock the pages which have been allocated by \* page\_create\_va() in segmap\_pagecreate() \*/ if (!vpm\_enable && newpage) { segmap\_pageunlock(segkmap, base + segmap\_offset, (size\_t)PAGESIZE, S\_WRITE); }
 if (error) { /\* \* If we failed on a write, we must \* be sure to invalidate any pages that may have \* been allocated. \*/ if (vpm\_enable) { (void) vpm\_sync\_pages(vp, offset, PAGESIZE, SM\_INVAL); } else { (void) segmap\_release(segkmap, base, SM\_INVAL); } } else { if (vpm\_enable) { error = vpm\_sync\_pages(vp, offset, PAGESIZE, 0); } else { error = segmap\_release(segkmap, base, 0); } }
 /\* \* Re-acquire contents lock. \*/ rw\_enter(&tp->tn\_contents, RW\_WRITER);
 /\* \* Update tn\_size. \*/ if (tn\_size\_changed) tp->tn\_size = new\_tn\_size;
 /\* \* If the uiomove failed, fix up tn\_size. \*/ if (error) { if (tn\_size\_changed) { /\* \* The uiomove failed, and we \* allocated blocks,so get rid \* of them. \*/ (void) tmpnode\_trunc(tm, tp, (ulong\_t)old\_tn\_size); } } else { /\* \* XXX - Can this be out of the loop? \*/ if ((tp->tn\_mode & (S\_IXUSR | S\_IXGRP | S\_IXOTH)) && (tp->tn\_mode & (S\_ISUID | S\_ISGID)) && secpolicy\_vnode\_setid\_retain(cr, (tp->tn\_mode & S\_ISUID) != 0 && tp->tn\_uid == 0)) { /\* \* Clear Set-UID & Set-GID bits on \* successful write if not privileged \* and at least one of the execute bits \* is set. If we always clear Set-GID, \* mandatory file and record locking is \* unuseable. \*/ tp->tn\_mode &= ~(S\_ISUID | S\_ISGID); } gethrestime(&now); tp->tn\_mtime = now; tp->tn\_ctime = now; } } while (error == 0 && uio->uio\_resid > 0 && bytes != 0);
out: /\* \* If we've already done a partial-write, terminate \* the write but return no error. \*/ if (oresid != uio->uio\_resid) error = 0; TRACE\_2(TR\_FAC\_TMPFS, TR\_TMPFS\_RWTMP\_END, "tmp\_wrtmp\_end:vp %p error %d", vp, error); return (error);}
/\* \* rdtmp does the real work of read requests for tmpfs. \*/static intrdtmp( struct tmount \*tm, struct tmpnode \*tp, struct uio \*uio, struct caller\_context \*ct){ ulong\_t pageoffset; /\* offset in tmpfs file (uio\_offset) \*/ ulong\_t segmap\_offset; /\* pagesize byte offset into segmap \*/ caddr\_t base; /\* base of segmap \*/ ssize\_t bytes; /\* bytes to uiomove \*/ struct vnode \*vp; int error; long oresid = uio->uio\_resid;
#if defined(lint) tm = tm;#endif vp = TNTOV(tp);
 TRACE\_1(TR\_FAC\_TMPFS, TR\_TMPFS\_RWTMP\_START, "tmp\_rdtmp\_start:vp %p", vp);
 ASSERT(RW\_LOCK\_HELD(&tp->tn\_contents));
 if (MANDLOCK(vp, tp->tn\_mode)) { rw\_exit(&tp->tn\_contents); /\* \* tmp\_getattr ends up being called by chklock \*/ error = chklock(vp, FREAD, uio->uio\_loffset, uio->uio\_resid, uio->uio\_fmode, ct); rw\_enter(&tp->tn\_contents, RW\_READER); if (error != 0) { TRACE\_2(TR\_FAC\_TMPFS, TR\_TMPFS\_RWTMP\_END, "tmp\_rdtmp\_end:vp %p error %d", vp, error); return (error); } } ASSERT(tp->tn\_type == VREG);
 if (uio->uio\_loffset >= MAXOFF\_T) { TRACE\_2(TR\_FAC\_TMPFS, TR\_TMPFS\_RWTMP\_END, "tmp\_rdtmp\_end:vp %p error %d", vp, EINVAL); return (0); } if (uio->uio\_loffset < 0) return (EINVAL); if (uio->uio\_resid == 0) { TRACE\_2(TR\_FAC\_TMPFS, TR\_TMPFS\_RWTMP\_END, "tmp\_rdtmp\_end:vp %p error %d", vp, 0); return (0); }
 vp = TNTOV(tp);
 do { long diff; long offset;
 offset = uio->uio\_offset; pageoffset = offset & PAGEOFFSET; bytes = MIN(PAGESIZE - pageoffset, uio->uio\_resid);
 diff = tp->tn\_size - offset;
 if (diff <= 0) { error = 0; goto out; } if (diff < bytes) bytes = diff;
 /\* \* We have to drop the contents lock to allow the VM system \* to reacquire it in tmp\_getpage() should the uiomove cause a \* pagefault. \*/ rw\_exit(&tp->tn\_contents);
 if (vpm\_enable) { /\* \* Copy data. \*/ error = vpm\_data\_copy(vp, offset, bytes, uio, 1, NULL, 0, S\_READ); } else { segmap\_offset = (offset & PAGEMASK) & MAXBOFFSET; base = segmap\_getmapflt(segkmap, vp, offset & MAXBMASK, bytes, 1, S\_READ);
 error = uiomove(base + segmap\_offset + pageoffset, (long)bytes, UIO\_READ, uio); }
 if (error) { if (vpm\_enable) { (void) vpm\_sync\_pages(vp, offset, PAGESIZE, 0); } else { (void) segmap\_release(segkmap, base, 0); } } else { if (vpm\_enable) { error = vpm\_sync\_pages(vp, offset, PAGESIZE, 0); } else { error = segmap\_release(segkmap, base, 0); } }
 /\* \* Re-acquire contents lock. \*/ rw\_enter(&tp->tn\_contents, RW\_READER);
 } while (error == 0 && uio->uio\_resid > 0);
out: gethrestime(&tp->tn\_atime);
 /\* \* If we've already done a partial read, terminate \* the read but return no error. \*/ if (oresid != uio->uio\_resid) error = 0;
 TRACE\_2(TR\_FAC\_TMPFS, TR\_TMPFS\_RWTMP\_END, "tmp\_rdtmp\_end:vp %x error %d", vp, error); return (error);}
/\* ARGSUSED2 \*/static inttmp\_read(struct vnode \*vp, struct uio \*uiop, int ioflag, cred\_t \*cred, struct caller\_context \*ct){ struct tmpnode \*tp = (struct tmpnode \*)VTOTN(vp); struct tmount \*tm = (struct tmount \*)VTOTM(vp); int error;
 /\* \* We don't currently support reading non-regular files \*/ if (vp->v\_type == VDIR) return (EISDIR); if (vp->v\_type != VREG) return (EINVAL); /\* \* tmp\_rwlock should have already been called from layers above \*/ ASSERT(RW\_READ\_HELD(&tp->tn\_rwlock));
 rw\_enter(&tp->tn\_contents, RW\_READER);
 error = rdtmp(tm, tp, uiop, ct);
 rw\_exit(&tp->tn\_contents);
 return (error);}
static inttmp\_write(struct vnode \*vp, struct uio \*uiop, int ioflag, struct cred \*cred, struct caller\_context \*ct){ struct tmpnode \*tp = (struct tmpnode \*)VTOTN(vp); struct tmount \*tm = (struct tmount \*)VTOTM(vp); int error;
 /\* \* We don't currently support writing to non-regular files \*/ if (vp->v\_type != VREG) return (EINVAL); /\* XXX EISDIR? \*/
 /\* \* tmp\_rwlock should have already been called from layers above \*/ ASSERT(RW\_WRITE\_HELD(&tp->tn\_rwlock));
 rw\_enter(&tp->tn\_contents, RW\_WRITER);
 if (ioflag & FAPPEND) { /\* \* In append mode start at end of file. \*/ uiop->uio\_loffset = tp->tn\_size; }
 error = wrtmp(tm, tp, uiop, cred, ct);
 rw\_exit(&tp->tn\_contents);
 return (error);}
/\* ARGSUSED \*/static inttmp\_ioctl( struct vnode \*vp, int com, intptr\_t data, int flag, struct cred \*cred, int \*rvalp, caller\_context\_t \*ct){ return (ENOTTY);}
/\* ARGSUSED2 \*/static inttmp\_getattr( struct vnode \*vp, struct vattr \*vap, int flags, struct cred \*cred, caller\_context\_t \*ct){ struct tmpnode \*tp = (struct tmpnode \*)VTOTN(vp); struct vnode \*mvp; struct vattr va; int attrs = 1;
 /\* \* A special case to handle the root tnode on a diskless nfs \* client who may have had its uid and gid inherited \* from an nfs vnode with nobody ownership. Likely the \* root filesystem. After nfs is fully functional the uid/gid \* may be mapable so ask again. \* vfsp can't get unmounted because we hold vp. \*/ if (vp->v\_flag & VROOT && (mvp = vp->v\_vfsp->vfs\_vnodecovered) != NULL) { mutex\_enter(&tp->tn\_tlock); if (tp->tn\_uid == UID\_NOBODY || tp->tn\_gid == GID\_NOBODY) { mutex\_exit(&tp->tn\_tlock); bzero(&va, sizeof (struct vattr)); va.va\_mask = AT\_UID|AT\_GID; attrs = VOP\_GETATTR(mvp, &va, 0, cred, ct); } else { mutex\_exit(&tp->tn\_tlock); } } mutex\_enter(&tp->tn\_tlock); if (attrs == 0) { tp->tn\_uid = va.va\_uid; tp->tn\_gid = va.va\_gid; } vap->va\_type = vp->v\_type; vap->va\_mode = tp->tn\_mode & MODEMASK; vap->va\_uid = tp->tn\_uid; vap->va\_gid = tp->tn\_gid; vap->va\_fsid = tp->tn\_fsid; vap->va\_nodeid = (ino64\_t)tp->tn\_nodeid; vap->va\_nlink = tp->tn\_nlink; vap->va\_size = (u\_offset\_t)tp->tn\_size; vap->va\_atime = tp->tn\_atime; vap->va\_mtime = tp->tn\_mtime; vap->va\_ctime = tp->tn\_ctime; vap->va\_blksize = PAGESIZE; vap->va\_rdev = tp->tn\_rdev; vap->va\_seq = tp->tn\_seq;
 /\* \* XXX Holes are not taken into account. We could take the time to \* run through the anon array looking for allocated slots... \*/ vap->va\_nblocks = (fsblkcnt64\_t)btodb(ptob(btopr(vap->va\_size))); mutex\_exit(&tp->tn\_tlock); return (0);}
/\*ARGSUSED4\*/static inttmp\_setattr( struct vnode \*vp, struct vattr \*vap, int flags, struct cred \*cred, caller\_context\_t \*ct){ struct tmount \*tm = (struct tmount \*)VTOTM(vp); struct tmpnode \*tp = (struct tmpnode \*)VTOTN(vp); int error = 0; struct vattr \*get; long mask;
 /\* \* Cannot set these attributes \*/ if ((vap->va\_mask & AT\_NOSET) || (vap->va\_mask & AT\_XVATTR)) return (EINVAL);
 mutex\_enter(&tp->tn\_tlock);
 get = &tp->tn\_attr; /\* \* Change file access modes. Must be owner or have sufficient \* privileges. \*/ error = secpolicy\_vnode\_setattr(cred, vp, vap, get, flags, tmp\_taccess, tp);
 if (error) goto out;
 mask = vap->va\_mask;
 if (mask & AT\_MODE) { get->va\_mode &= S\_IFMT; get->va\_mode |= vap->va\_mode & ~S\_IFMT; }
 if (mask & AT\_UID) get->va\_uid = vap->va\_uid; if (mask & AT\_GID) get->va\_gid = vap->va\_gid; if (mask & AT\_ATIME) get->va\_atime = vap->va\_atime; if (mask & AT\_MTIME) get->va\_mtime = vap->va\_mtime;
 if (mask & (AT\_UID | AT\_GID | AT\_MODE | AT\_MTIME)) gethrestime(&tp->tn\_ctime);
 if (mask & AT\_SIZE) { ASSERT(vp->v\_type != VDIR);
 /\* Don't support large files. \*/ if (vap->va\_size > MAXOFF\_T) { error = EFBIG; goto out; } mutex\_exit(&tp->tn\_tlock);
 rw\_enter(&tp->tn\_rwlock, RW\_WRITER); rw\_enter(&tp->tn\_contents, RW\_WRITER); error = tmpnode\_trunc(tm, tp, (ulong\_t)vap->va\_size); rw\_exit(&tp->tn\_contents); rw\_exit(&tp->tn\_rwlock);
 if (error == 0 && vap->va\_size == 0) vnevent\_truncate(vp, ct);
 goto out1; }out: mutex\_exit(&tp->tn\_tlock);out1: return (error);}
/\* ARGSUSED2 \*/static inttmp\_access( struct vnode \*vp, int mode, int flags, struct cred \*cred, caller\_context\_t \*ct){ struct tmpnode \*tp = (struct tmpnode \*)VTOTN(vp); int error;
 mutex\_enter(&tp->tn\_tlock); error = tmp\_taccess(tp, mode, cred); mutex\_exit(&tp->tn\_tlock); return (error);}
/\* ARGSUSED3 \*/static inttmp\_lookup( struct vnode \*dvp, char \*nm, struct vnode \*\*vpp, struct pathname \*pnp, int flags, struct vnode \*rdir, struct cred \*cred, caller\_context\_t \*ct, int \*direntflags, pathname\_t \*realpnp){ struct tmpnode \*tp = (struct tmpnode \*)VTOTN(dvp); struct tmpnode \*ntp = NULL; int error;
 /\* allow cd into @ dir \*/ if (flags & LOOKUP\_XATTR) { struct tmpnode \*xdp; struct tmount \*tm;
 /\* \* don't allow attributes if not mounted XATTR support \*/ if (!(dvp->v\_vfsp->vfs\_flag & VFS\_XATTR)) return (EINVAL);
 if (tp->tn\_flags & ISXATTR) /\* No attributes on attributes \*/ return (EINVAL);
 rw\_enter(&tp->tn\_rwlock, RW\_WRITER); if (tp->tn\_xattrdp == NULL) { if (!(flags & CREATE\_XATTR\_DIR)) { rw\_exit(&tp->tn\_rwlock); return (ENOENT); }
 /\* \* No attribute directory exists for this \* node - create the attr dir as a side effect \* of this lookup. \*/
 /\* \* Make sure we have adequate permission... \*/
 if ((error = tmp\_taccess(tp, VWRITE, cred)) != 0) { rw\_exit(&tp->tn\_rwlock); return (error); }
 xdp = tmp\_memalloc(sizeof (struct tmpnode), TMP\_MUSTHAVE); tm = VTOTM(dvp); tmpnode\_init(tm, xdp, &tp->tn\_attr, NULL); /\* \* Fix-up fields unique to attribute directories. \*/ xdp->tn\_flags = ISXATTR; xdp->tn\_type = VDIR; if (tp->tn\_type == VDIR) { xdp->tn\_mode = tp->tn\_attr.va\_mode; } else { xdp->tn\_mode = 0700; if (tp->tn\_attr.va\_mode & 0040) xdp->tn\_mode |= 0750; if (tp->tn\_attr.va\_mode & 0004) xdp->tn\_mode |= 0705; } xdp->tn\_vnode->v\_type = VDIR; xdp->tn\_vnode->v\_flag |= V\_XATTRDIR; tdirinit(tp, xdp); tp->tn\_xattrdp = xdp; } else { VN\_HOLD(tp->tn\_xattrdp->tn\_vnode); } \*vpp = TNTOV(tp->tn\_xattrdp); rw\_exit(&tp->tn\_rwlock); return (0); }
 /\* \* Null component name is a synonym for directory being searched. \*/ if (\*nm == '\0') { VN\_HOLD(dvp); \*vpp = dvp; return (0); } ASSERT(tp);
 error = tdirlookup(tp, nm, &ntp, cred);
 if (error == 0) { ASSERT(ntp); \*vpp = TNTOV(ntp); /\* \* If vnode is a device return special vnode instead \*/ if (IS\_DEVVP(\*vpp)) { struct vnode \*newvp;
 newvp = specvp(\*vpp, (\*vpp)->v\_rdev, (\*vpp)->v\_type, cred); VN\_RELE(\*vpp); \*vpp = newvp; } } TRACE\_4(TR\_FAC\_TMPFS, TR\_TMPFS\_LOOKUP, "tmpfs lookup:vp %p name %s vpp %p error %d", dvp, nm, vpp, error); return (error);}
/\*ARGSUSED7\*/static inttmp\_create( struct vnode \*dvp, char \*nm, struct vattr \*vap, enum vcexcl exclusive, int mode, struct vnode \*\*vpp, struct cred \*cred, int flag, caller\_context\_t \*ct, vsecattr\_t \*vsecp){ struct tmpnode \*parent; struct tmount \*tm; struct tmpnode \*self; int error; struct tmpnode \*oldtp;
again: parent = (struct tmpnode \*)VTOTN(dvp); tm = (struct tmount \*)VTOTM(dvp); self = NULL; error = 0; oldtp = NULL;
 /\* device files not allowed in ext. attr dirs \*/ if ((parent->tn\_flags & ISXATTR) && (vap->va\_type == VBLK || vap->va\_type == VCHR || vap->va\_type == VFIFO || vap->va\_type == VDOOR || vap->va\_type == VSOCK || vap->va\_type == VPORT)) return (EINVAL);
 if (vap->va\_type == VREG && (vap->va\_mode & VSVTX)) { /\* Must be privileged to set sticky bit \*/ if (secpolicy\_vnode\_stky\_modify(cred)) vap->va\_mode &= ~VSVTX; } else if (vap->va\_type == VNON) { return (EINVAL); }
 /\* \* Null component name is a synonym for directory being searched. \*/ if (\*nm == '\0') { VN\_HOLD(dvp); oldtp = parent; } else { error = tdirlookup(parent, nm, &oldtp, cred); }
 if (error == 0) { /\* name found \*/ boolean\_t trunc = B\_FALSE;
 ASSERT(oldtp);
 rw\_enter(&oldtp->tn\_rwlock, RW\_WRITER);
 /\* \* if create/read-only an existing \* directory, allow it[View remainder of file in raw view](https://github.com/illumos/illumos-gate/raw/069654420de4aade43c63c43cd2896e66945fc8a/usr/src/uts/common/fs/tmpfs/tmp_vnops.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

