=== Content from git.kernel.org_f0cd873b_20250110_233315.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=519b7e13b5ae8dd38da1e52275705343be6bb508)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=519b7e13b5ae8dd38da1e52275705343be6bb508)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=519b7e13b5ae8dd38da1e52275705343be6bb508)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=519b7e13b5ae8dd38da1e52275705343be6bb508)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Filipe Manana <fdmanana@suse.com> | 2023-01-23 16:54:46 +0000 |
| --- | --- | --- |
| committer | David Sterba <dsterba@suse.com> | 2023-02-09 17:02:27 +0100 |
| commit | [519b7e13b5ae8dd38da1e52275705343be6bb508](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=519b7e13b5ae8dd38da1e52275705343be6bb508) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=519b7e13b5ae8dd38da1e52275705343be6bb508)) | |
| tree | [b3c2b39b16fbd2edb714a537aac9fe39c6c4ad60](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=519b7e13b5ae8dd38da1e52275705343be6bb508) | |
| parent | [6afaed53cc9adde69d8a76ff5b4d740d5efbc54c](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6afaed53cc9adde69d8a76ff5b4d740d5efbc54c) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=519b7e13b5ae8dd38da1e52275705343be6bb508&id2=6afaed53cc9adde69d8a76ff5b4d740d5efbc54c)) | |
| download | [linux-519b7e13b5ae8dd38da1e52275705343be6bb508.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-519b7e13b5ae8dd38da1e52275705343be6bb508.tar.gz) | |

btrfs: lock the inode in shared mode before starting fiemapCurrently fiemap does not take the inode's lock (VFS lock), it only locks
a file range in the inode's io tree. This however can lead to a deadlock
if we have a concurrent fsync on the file and fiemap code triggers a fault
when accessing the user space buffer with fiemap\_fill\_next\_extent(). The
deadlock happens on the inode's i\_mmap\_lock semaphore, which is taken both
by fsync and btrfs\_page\_mkwrite(). This deadlock was recently reported by
syzbot and triggers a trace like the following:
task:syz-executor361 state:D stack:20264 pid:5668 ppid:5119 flags:0x00004004
Call Trace:
<TASK>
context\_switch kernel/sched/core.c:5293 [inline]
\_\_schedule+0x995/0xe20 kernel/sched/core.c:6606
schedule+0xcb/0x190 kernel/sched/core.c:6682
wait\_on\_state fs/btrfs/extent-io-tree.c:707 [inline]
wait\_extent\_bit+0x577/0x6f0 fs/btrfs/extent-io-tree.c:751
lock\_extent+0x1c2/0x280 fs/btrfs/extent-io-tree.c:1742
find\_lock\_delalloc\_range+0x4e6/0x9c0 fs/btrfs/extent\_io.c:488
writepage\_delalloc+0x1ef/0x540 fs/btrfs/extent\_io.c:1863
\_\_extent\_writepage+0x736/0x14e0 fs/btrfs/extent\_io.c:2174
extent\_write\_cache\_pages+0x983/0x1220 fs/btrfs/extent\_io.c:3091
extent\_writepages+0x219/0x540 fs/btrfs/extent\_io.c:3211
do\_writepages+0x3c3/0x680 mm/page-writeback.c:2581
filemap\_fdatawrite\_wbc+0x11e/0x170 mm/filemap.c:388
\_\_filemap\_fdatawrite\_range mm/filemap.c:421 [inline]
filemap\_fdatawrite\_range+0x175/0x200 mm/filemap.c:439
btrfs\_fdatawrite\_range fs/btrfs/file.c:3850 [inline]
start\_ordered\_ops fs/btrfs/file.c:1737 [inline]
btrfs\_sync\_file+0x4ff/0x1190 fs/btrfs/file.c:1839
generic\_write\_sync include/linux/fs.h:2885 [inline]
btrfs\_do\_write\_iter+0xcd3/0x1280 fs/btrfs/file.c:1684
call\_write\_iter include/linux/fs.h:2189 [inline]
new\_sync\_write fs/read\_write.c:491 [inline]
vfs\_write+0x7dc/0xc50 fs/read\_write.c:584
ksys\_write+0x177/0x2a0 fs/read\_write.c:637
do\_syscall\_x64 arch/x86/entry/common.c:50 [inline]
do\_syscall\_64+0x3d/0xb0 arch/x86/entry/common.c:80
entry\_SYSCALL\_64\_after\_hwframe+0x63/0xcd
RIP: 0033:0x7f7d4054e9b9
RSP: 002b:00007f7d404fa2f8 EFLAGS: 00000246 ORIG\_RAX: 0000000000000001
RAX: ffffffffffffffda RBX: 00007f7d405d87a0 RCX: 00007f7d4054e9b9
RDX: 0000000000000090 RSI: 0000000020000000 RDI: 0000000000000006
RBP: 00007f7d405a51d0 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000246 R12: 61635f65646f6e69
R13: 65646f7475616f6e R14: 7261637369646f6e R15: 00007f7d405d87a8
</TASK>
INFO: task syz-executor361:5697 blocked for more than 145 seconds.
Not tainted 6.2.0-rc3-syzkaller-00376-g7c6984405241 #0
"echo 0 > /proc/sys/kernel/hung\_task\_timeout\_secs" disables this message.
task:syz-executor361 state:D stack:21216 pid:5697 ppid:5119 flags:0x00004004
Call Trace:
<TASK>
context\_switch kernel/sched/core.c:5293 [inline]
\_\_schedule+0x995/0xe20 kernel/sched/core.c:6606
schedule+0xcb/0x190 kernel/sched/core.c:6682
rwsem\_down\_read\_slowpath+0x5f9/0x930 kernel/locking/rwsem.c:1095
\_\_down\_read\_common+0x54/0x2a0 kernel/locking/rwsem.c:1260
btrfs\_page\_mkwrite+0x417/0xc80 fs/btrfs/inode.c:8526
do\_page\_mkwrite+0x19e/0x5e0 mm/memory.c:2947
wp\_page\_shared+0x15e/0x380 mm/memory.c:3295
handle\_pte\_fault mm/memory.c:4949 [inline]
\_\_handle\_mm\_fault mm/memory.c:5073 [inline]
handle\_mm\_fault+0x1b79/0x26b0 mm/memory.c:5219
do\_user\_addr\_fault+0x69b/0xcb0 arch/x86/mm/fault.c:1428
handle\_page\_fault arch/x86/mm/fault.c:1519 [inline]
exc\_page\_fault+0x7a/0x110 arch/x86/mm/fault.c:1575
asm\_exc\_page\_fault+0x22/0x30 arch/x86/include/asm/idtentry.h:570
RIP: 0010:copy\_user\_short\_string+0xd/0x40 arch/x86/lib/copy\_user\_64.S:233
Code: 74 0a 89 (...)
RSP: 0018:ffffc9000570f330 EFLAGS: 00050202
RAX: ffffffff843e6601 RBX: 00007fffffffefc8 RCX: 0000000000000007
RDX: 0000000000000000 RSI: ffffc9000570f3e0 RDI: 0000000020000120
RBP: ffffc9000570f490 R08: 0000000000000000 R09: fffff52000ae1e83
R10: fffff52000ae1e83 R11: 1ffff92000ae1e7c R12: 0000000000000038
R13: ffffc9000570f3e0 R14: 0000000020000120 R15: ffffc9000570f3e0
copy\_user\_generic arch/x86/include/asm/uaccess\_64.h:37 [inline]
raw\_copy\_to\_user arch/x86/include/asm/uaccess\_64.h:58 [inline]
\_copy\_to\_user+0xe9/0x130 lib/usercopy.c:34
copy\_to\_user include/linux/uaccess.h:169 [inline]
fiemap\_fill\_next\_extent+0x22e/0x410 fs/ioctl.c:144
emit\_fiemap\_extent+0x22d/0x3c0 fs/btrfs/extent\_io.c:3458
fiemap\_process\_hole+0xa00/0xad0 fs/btrfs/extent\_io.c:3716
extent\_fiemap+0xe27/0x2100 fs/btrfs/extent\_io.c:3922
btrfs\_fiemap+0x172/0x1e0 fs/btrfs/inode.c:8209
ioctl\_fiemap fs/ioctl.c:219 [inline]
do\_vfs\_ioctl+0x185b/0x2980 fs/ioctl.c:810
\_\_do\_sys\_ioctl fs/ioctl.c:868 [inline]
\_\_se\_sys\_ioctl+0x83/0x170 fs/ioctl.c:856
do\_syscall\_x64 arch/x86/entry/common.c:50 [inline]
do\_syscall\_64+0x3d/0xb0 arch/x86/entry/common.c:80
entry\_SYSCALL\_64\_after\_hwframe+0x63/0xcd
RIP: 0033:0x7f7d4054e9b9
RSP: 002b:00007f7d390d92f8 EFLAGS: 00000246 ORIG\_RAX: 0000000000000010
RAX: ffffffffffffffda RBX: 00007f7d405d87b0 RCX: 00007f7d4054e9b9
RDX: 0000000020000100 RSI: 00000000c020660b RDI: 0000000000000005
RBP: 00007f7d405a51d0 R08: 00007f7d390d9700 R09: 0000000000000000
R10: 00007f7d390d9700 R11: 0000000000000246 R12: 61635f65646f6e69
R13: 65646f7475616f6e R14: 7261637369646f6e R15: 00007f7d405d87b8
</TASK>
What happens is the following:
1) Task A is doing an fsync, enters btrfs\_sync\_file() and flushes delalloc
before locking the inode and the i\_mmap\_lock semaphore, that is, before
calling btrfs\_inode\_lock();
2) After task A flushes delalloc and before it calls btrfs\_inode\_lock(),
another task dirties a page;
3) Task B starts a fiemap without FIEMAP\_FLAG\_SYNC, so the page dirtied
at step 2 remains dirty and unflushed. Then when it enters
extent\_fiemap() and it locks a file range that includes the range of
the page dirtied in step 2;
4) Task A calls btrfs\_inode\_lock() and locks the inode (VFS lock) and the
inode's i\_mmap\_lock semaphore in write mode. Then it tries to flush
delalloc by calling start\_ordered\_ops(), which will block, at
find\_lock\_delalloc\_range(), when trying to lock the range of the page
dirtied at step 2, since this range was locked by the fiemap task (at
step 3);
5) Task B generates a page fault when accessing the user space fiemap
buffer with a call to fiemap\_fill\_next\_extent().
The fault handler needs to call btrfs\_page\_mkwrite() for some other
page of our inode, and there we deadlock when trying to lock the
inode's i\_mmap\_lock semaphore in read mode, since the fsync task locked
it in write mode (step 4) and the fsync task can not progress because
it's waiting to lock a file range that is currently locked by us (the
fiemap task, step 3).
Fix this by taking the inode's lock (VFS lock) in shared mode when
entering fiemap. This effectively serializes fiemap with fsync (except the
most expensive part of fsync, the log sync), preventing this deadlock.
Reported-by: syzbot+cc35f55c41e34c30dcb5@syzkaller.appspotmail.com
Link: [https://lore.kernel.org/linux-btrfs/00000000000032dc7305f2a66f46@google.com/](https://lore.kernel.org/linux-btrfs/00000000000032dc7305f2a66f46%40google.com/)
CC: stable@vger.kernel.org # 6.1+
Reviewed-by: Josef Bacik <josef@toxicpanda.com>
Signed-off-by: Filipe Manana <fdmanana@suse.com>
Signed-off-by: David Sterba <dsterba@suse.com>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=519b7e13b5ae8dd38da1e52275705343be6bb508)

| -rw-r--r-- | [fs/btrfs/extent\_io.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/extent_io.c?id=519b7e13b5ae8dd38da1e52275705343be6bb508) | 2 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 2 insertions, 0 deletions

| diff --git a/fs/btrfs/extent\_io.c b/fs/btrfs/extent\_io.cindex 9bd32daa9b9a6f..3bbf8703db2a8f 100644--- a/[fs/btrfs/extent\_io.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/extent_io.c?id=6afaed53cc9adde69d8a76ff5b4d740d5efbc54c)+++ b/[fs/btrfs/extent\_io.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/extent_io.c?id=519b7e13b5ae8dd38da1e52275705343be6bb508)@@ -3826,6 +3826,7 @@ int extent\_fiemap(struct btrfs\_inode \*inode, struct fiemap\_extent\_info \*fieinfo, lockend = round\_up(start + len, inode->root->fs\_info->sectorsize); prev\_extent\_end = lockstart; + btrfs\_inode\_lock(inode, BTRFS\_ILOCK\_SHARED); lock\_extent(&inode->io\_tree, lockstart, lockend, &cached\_state);  ret = fiemap\_find\_last\_extent\_offset(inode, path, &last\_extent\_end);@@ -4019,6 +4020,7 @@ check\_eof\_delalloc:  out\_unlock: unlock\_extent(&inode->io\_tree, lockstart, lockend, &cached\_state);+ btrfs\_inode\_unlock(inode, BTRFS\_ILOCK\_SHARED); out: free\_extent\_state(delalloc\_cached\_state); btrfs\_free\_backref\_share\_ctx(backref\_ctx); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 23:31:52 +0000



=== Content from git.kernel.org_1a32bfba_20250110_233316.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=d8c594da79bc0244e610a70594e824a401802be1)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d8c594da79bc0244e610a70594e824a401802be1)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d8c594da79bc0244e610a70594e824a401802be1)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d8c594da79bc0244e610a70594e824a401802be1)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Filipe Manana <fdmanana@suse.com> | 2023-01-23 16:54:46 +0000 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2023-02-22 12:59:40 +0100 |
| commit | [d8c594da79bc0244e610a70594e824a401802be1](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d8c594da79bc0244e610a70594e824a401802be1) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=d8c594da79bc0244e610a70594e824a401802be1)) | |
| tree | [3ae4c6d1a070369c009af05841868ed9ce9e1f99](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d8c594da79bc0244e610a70594e824a401802be1) | |
| parent | [f2e0134b43be591c4e60091a8c9c61762ea4b337](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f2e0134b43be591c4e60091a8c9c61762ea4b337) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d8c594da79bc0244e610a70594e824a401802be1&id2=f2e0134b43be591c4e60091a8c9c61762ea4b337)) | |
| download | [linux-d8c594da79bc0244e610a70594e824a401802be1.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-d8c594da79bc0244e610a70594e824a401802be1.tar.gz) | |

btrfs: lock the inode in shared mode before starting fiemap[ Upstream commit 519b7e13b5ae8dd38da1e52275705343be6bb508 ]
Currently fiemap does not take the inode's lock (VFS lock), it only locks
a file range in the inode's io tree. This however can lead to a deadlock
if we have a concurrent fsync on the file and fiemap code triggers a fault
when accessing the user space buffer with fiemap\_fill\_next\_extent(). The
deadlock happens on the inode's i\_mmap\_lock semaphore, which is taken both
by fsync and btrfs\_page\_mkwrite(). This deadlock was recently reported by
syzbot and triggers a trace like the following:
task:syz-executor361 state:D stack:20264 pid:5668 ppid:5119 flags:0x00004004
Call Trace:
<TASK>
context\_switch kernel/sched/core.c:5293 [inline]
\_\_schedule+0x995/0xe20 kernel/sched/core.c:6606
schedule+0xcb/0x190 kernel/sched/core.c:6682
wait\_on\_state fs/btrfs/extent-io-tree.c:707 [inline]
wait\_extent\_bit+0x577/0x6f0 fs/btrfs/extent-io-tree.c:751
lock\_extent+0x1c2/0x280 fs/btrfs/extent-io-tree.c:1742
find\_lock\_delalloc\_range+0x4e6/0x9c0 fs/btrfs/extent\_io.c:488
writepage\_delalloc+0x1ef/0x540 fs/btrfs/extent\_io.c:1863
\_\_extent\_writepage+0x736/0x14e0 fs/btrfs/extent\_io.c:2174
extent\_write\_cache\_pages+0x983/0x1220 fs/btrfs/extent\_io.c:3091
extent\_writepages+0x219/0x540 fs/btrfs/extent\_io.c:3211
do\_writepages+0x3c3/0x680 mm/page-writeback.c:2581
filemap\_fdatawrite\_wbc+0x11e/0x170 mm/filemap.c:388
\_\_filemap\_fdatawrite\_range mm/filemap.c:421 [inline]
filemap\_fdatawrite\_range+0x175/0x200 mm/filemap.c:439
btrfs\_fdatawrite\_range fs/btrfs/file.c:3850 [inline]
start\_ordered\_ops fs/btrfs/file.c:1737 [inline]
btrfs\_sync\_file+0x4ff/0x1190 fs/btrfs/file.c:1839
generic\_write\_sync include/linux/fs.h:2885 [inline]
btrfs\_do\_write\_iter+0xcd3/0x1280 fs/btrfs/file.c:1684
call\_write\_iter include/linux/fs.h:2189 [inline]
new\_sync\_write fs/read\_write.c:491 [inline]
vfs\_write+0x7dc/0xc50 fs/read\_write.c:584
ksys\_write+0x177/0x2a0 fs/read\_write.c:637
do\_syscall\_x64 arch/x86/entry/common.c:50 [inline]
do\_syscall\_64+0x3d/0xb0 arch/x86/entry/common.c:80
entry\_SYSCALL\_64\_after\_hwframe+0x63/0xcd
RIP: 0033:0x7f7d4054e9b9
RSP: 002b:00007f7d404fa2f8 EFLAGS: 00000246 ORIG\_RAX: 0000000000000001
RAX: ffffffffffffffda RBX: 00007f7d405d87a0 RCX: 00007f7d4054e9b9
RDX: 0000000000000090 RSI: 0000000020000000 RDI: 0000000000000006
RBP: 00007f7d405a51d0 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000246 R12: 61635f65646f6e69
R13: 65646f7475616f6e R14: 7261637369646f6e R15: 00007f7d405d87a8
</TASK>
INFO: task syz-executor361:5697 blocked for more than 145 seconds.
Not tainted 6.2.0-rc3-syzkaller-00376-g7c6984405241 #0
"echo 0 > /proc/sys/kernel/hung\_task\_timeout\_secs" disables this message.
task:syz-executor361 state:D stack:21216 pid:5697 ppid:5119 flags:0x00004004
Call Trace:
<TASK>
context\_switch kernel/sched/core.c:5293 [inline]
\_\_schedule+0x995/0xe20 kernel/sched/core.c:6606
schedule+0xcb/0x190 kernel/sched/core.c:6682
rwsem\_down\_read\_slowpath+0x5f9/0x930 kernel/locking/rwsem.c:1095
\_\_down\_read\_common+0x54/0x2a0 kernel/locking/rwsem.c:1260
btrfs\_page\_mkwrite+0x417/0xc80 fs/btrfs/inode.c:8526
do\_page\_mkwrite+0x19e/0x5e0 mm/memory.c:2947
wp\_page\_shared+0x15e/0x380 mm/memory.c:3295
handle\_pte\_fault mm/memory.c:4949 [inline]
\_\_handle\_mm\_fault mm/memory.c:5073 [inline]
handle\_mm\_fault+0x1b79/0x26b0 mm/memory.c:5219
do\_user\_addr\_fault+0x69b/0xcb0 arch/x86/mm/fault.c:1428
handle\_page\_fault arch/x86/mm/fault.c:1519 [inline]
exc\_page\_fault+0x7a/0x110 arch/x86/mm/fault.c:1575
asm\_exc\_page\_fault+0x22/0x30 arch/x86/include/asm/idtentry.h:570
RIP: 0010:copy\_user\_short\_string+0xd/0x40 arch/x86/lib/copy\_user\_64.S:233
Code: 74 0a 89 (...)
RSP: 0018:ffffc9000570f330 EFLAGS: 00050202
RAX: ffffffff843e6601 RBX: 00007fffffffefc8 RCX: 0000000000000007
RDX: 0000000000000000 RSI: ffffc9000570f3e0 RDI: 0000000020000120
RBP: ffffc9000570f490 R08: 0000000000000000 R09: fffff52000ae1e83
R10: fffff52000ae1e83 R11: 1ffff92000ae1e7c R12: 0000000000000038
R13: ffffc9000570f3e0 R14: 0000000020000120 R15: ffffc9000570f3e0
copy\_user\_generic arch/x86/include/asm/uaccess\_64.h:37 [inline]
raw\_copy\_to\_user arch/x86/include/asm/uaccess\_64.h:58 [inline]
\_copy\_to\_user+0xe9/0x130 lib/usercopy.c:34
copy\_to\_user include/linux/uaccess.h:169 [inline]
fiemap\_fill\_next\_extent+0x22e/0x410 fs/ioctl.c:144
emit\_fiemap\_extent+0x22d/0x3c0 fs/btrfs/extent\_io.c:3458
fiemap\_process\_hole+0xa00/0xad0 fs/btrfs/extent\_io.c:3716
extent\_fiemap+0xe27/0x2100 fs/btrfs/extent\_io.c:3922
btrfs\_fiemap+0x172/0x1e0 fs/btrfs/inode.c:8209
ioctl\_fiemap fs/ioctl.c:219 [inline]
do\_vfs\_ioctl+0x185b/0x2980 fs/ioctl.c:810
\_\_do\_sys\_ioctl fs/ioctl.c:868 [inline]
\_\_se\_sys\_ioctl+0x83/0x170 fs/ioctl.c:856
do\_syscall\_x64 arch/x86/entry/common.c:50 [inline]
do\_syscall\_64+0x3d/0xb0 arch/x86/entry/common.c:80
entry\_SYSCALL\_64\_after\_hwframe+0x63/0xcd
RIP: 0033:0x7f7d4054e9b9
RSP: 002b:00007f7d390d92f8 EFLAGS: 00000246 ORIG\_RAX: 0000000000000010
RAX: ffffffffffffffda RBX: 00007f7d405d87b0 RCX: 00007f7d4054e9b9
RDX: 0000000020000100 RSI: 00000000c020660b RDI: 0000000000000005
RBP: 00007f7d405a51d0 R08: 00007f7d390d9700 R09: 0000000000000000
R10: 00007f7d390d9700 R11: 0000000000000246 R12: 61635f65646f6e69
R13: 65646f7475616f6e R14: 7261637369646f6e R15: 00007f7d405d87b8
</TASK>
What happens is the following:
1) Task A is doing an fsync, enters btrfs\_sync\_file() and flushes delalloc
before locking the inode and the i\_mmap\_lock semaphore, that is, before
calling btrfs\_inode\_lock();
2) After task A flushes delalloc and before it calls btrfs\_inode\_lock(),
another task dirties a page;
3) Task B starts a fiemap without FIEMAP\_FLAG\_SYNC, so the page dirtied
at step 2 remains dirty and unflushed. Then when it enters
extent\_fiemap() and it locks a file range that includes the range of
the page dirtied in step 2;
4) Task A calls btrfs\_inode\_lock() and locks the inode (VFS lock) and the
inode's i\_mmap\_lock semaphore in write mode. Then it tries to flush
delalloc by calling start\_ordered\_ops(), which will block, at
find\_lock\_delalloc\_range(), when trying to lock the range of the page
dirtied at step 2, since this range was locked by the fiemap task (at
step 3);
5) Task B generates a page fault when accessing the user space fiemap
buffer with a call to fiemap\_fill\_next\_extent().
The fault handler needs to call btrfs\_page\_mkwrite() for some other
page of our inode, and there we deadlock when trying to lock the
inode's i\_mmap\_lock semaphore in read mode, since the fsync task locked
it in write mode (step 4) and the fsync task can not progress because
it's waiting to lock a file range that is currently locked by us (the
fiemap task, step 3).
Fix this by taking the inode's lock (VFS lock) in shared mode when
entering fiemap. This effectively serializes fiemap with fsync (except the
most expensive part of fsync, the log sync), preventing this deadlock.
Reported-by: syzbot+cc35f55c41e34c30dcb5@syzkaller.appspotmail.com
Link: [https://lore.kernel.org/linux-btrfs/00000000000032dc7305f2a66f46@google.com/](https://lore.kernel.org/linux-btrfs/00000000000032dc7305f2a66f46%40google.com/)
CC: stable@vger.kernel.org # 6.1+
Reviewed-by: Josef Bacik <josef@toxicpanda.com>
Signed-off-by: Filipe Manana <fdmanana@suse.com>
Signed-off-by: David Sterba <dsterba@suse.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d8c594da79bc0244e610a70594e824a401802be1)

| -rw-r--r-- | [fs/btrfs/extent\_io.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/extent_io.c?id=d8c594da79bc0244e610a70594e824a401802be1) | 2 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 2 insertions, 0 deletions

| diff --git a/fs/btrfs/extent\_io.c b/fs/btrfs/extent\_io.cindex acb3c5c3b02517..58785dc7080ad7 100644--- a/[fs/btrfs/extent\_io.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/extent_io.c?id=f2e0134b43be591c4e60091a8c9c61762ea4b337)+++ b/[fs/btrfs/extent\_io.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/extent_io.c?id=d8c594da79bc0244e610a70594e824a401802be1)@@ -3938,6 +3938,7 @@ int extent\_fiemap(struct btrfs\_inode \*inode, struct fiemap\_extent\_info \*fieinfo, lockend = round\_up(start + len, root->fs\_info->sectorsize); prev\_extent\_end = lockstart; + btrfs\_inode\_lock(&inode->vfs\_inode, BTRFS\_ILOCK\_SHARED); lock\_extent(&inode->io\_tree, lockstart, lockend, &cached\_state);  ret = fiemap\_find\_last\_extent\_offset(inode, path, &last\_extent\_end);@@ -4129,6 +4130,7 @@ check\_eof\_delalloc:  out\_unlock: unlock\_extent(&inode->io\_tree, lockstart, lockend, &cached\_state);+ btrfs\_inode\_unlock(&inode->vfs\_inode, BTRFS\_ILOCK\_SHARED); out: kfree(backref\_cache); btrfs\_free\_path(path); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 23:31:53 +0000


