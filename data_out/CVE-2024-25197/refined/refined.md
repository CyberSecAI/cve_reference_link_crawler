```
{
  "cveId": "CVE-2024-25197",
  "source": "github.com_d54fdc57_20250111_152506.html",
  "vulnerability": {
    "description": "The provided content discusses a bug in the ros-navigation/navigation2 project, specifically related to the costmap_ros_ node and its interaction with lifecycle nodes during shutdown. The core issue is that costmap_ros_, as a LifecycleNode, may react to rcl_preshutdown signals (like Ctrl+C) randomly, potentially closing down earlier than its parent nodes (e.g., planner/controller). This premature shutdown leads to null pointer access in the parent nodes, resulting in crashes and residual processes.",
    "rootCause": "The root cause of the vulnerability lies in the asynchronous and unpredictable shutdown behavior of lifecycle nodes in ROS2. Specifically, the costmap_ros_ node, a child-thread of planner/controller, responds to the rcl_preshutdown signal independently and randomly, potentially before the planner/controller has completed its own shutdown sequence. This leads to a race condition where the planner/controller might attempt to access costmap_ros_ after it has already been deactivated and its resources released.",
    "weaknesses": [
      "Concurrency issues",
      "Use-after-free (UAF) condition",
       "Lack of synchronization during shutdown",
      "Incorrect assumptions about lifecycle event ordering"
    ],
    "impact": "Exploitation of this vulnerability leads to program crashes during shutdown, possibly resulting in residual processes. The system could shut down in an unplanned manner, affecting robot's operation.",
     "attackVector": "The attack vector is triggered by initiating a shutdown of the system, usually by a user interrupt such as Ctrl+C. The vulnerability manifests due to how the system handles the shutdown process when multiple nodes are involved.",
     "attackerCapabilities": "The attacker needs to have the ability to trigger a shutdown sequence of the system either directly (e.g., using system commands) or indirectly by exploiting a different program that results in program termination."
   }
},
{
  "cveId": "CVE-2024-25197",
  "source": "github.com_fb1ff5ac_20250111_152506.html",
   "vulnerability": {
    "description": "The content discusses a bug in the nav2_costmap_2d package within the ros-navigation/navigation2 project. It specifically addresses a null pointer dereference issue during costmap resets. The problem occurs because the `layered_costmap` pointer can be freed by one thread while another thread is trying to access its `isCurrent()` method. This leads to program crashes and an unstable system.",
     "rootCause": "The root cause of the vulnerability is a race condition caused by multi-threaded access to the `layered_costmap_` pointer. The `clearEntirely()` method in the `ClearCostmapService`, which resets the costmap layers, can be called by one thread, while the `isCurrent()` method in `Costmap2DROS` can be invoked by other threads (typically when other packages want to use costmap), creating the possibility for a use-after-free (UAF) condition if these overlap. This also was happening in the shutdown process.",
    "weaknesses": [
      "Race condition",
      "Use-after-free (UAF)",
       "Lack of proper synchronization",
      "Incorrect assumptions about multi-threaded code execution"
    ],
    "impact": "Exploitation results in a program crash due to a null pointer dereference or use-after-free, leading to unstable robot operation and potential system downtime.",
     "attackVector": "The primary attack vector is when an external change in the environment (e.g frequent obstacle movements) triggers a reset of costmap layers through  `ClearCostmapService::clearEntirely()`, meanwhile, the planner or controller attempts to access costmap data with `isCurrent()` method.",
    "attackerCapabilities": "An attacker needs to trigger a scenario that causes frequent costmap resets while the system is simultaneously using costmaps."
   }
},
{
  "cveId": "CVE-2024-25197",
  "source": "github.com_ddccc746_20250111_152511.html",
   "vulnerability": {
    "description": "This content focuses on a fix for a bug in the ros-navigation/navigation2 project, involving a null pointer dereference during the shutdown process of the `costmap_ros_` node. The primary issue is that the `costmap_ros_` node, a lifecycle node, reacts to shutdown signals (like Ctrl+C) independently of its parent nodes (e.g., planner or controller), potentially leading to access of freed memory.",
     "rootCause": "The root cause is the asynchronous shutdown behavior of lifecycle nodes within ROS2. The `costmap_ros_` node, being a lifecycle node, can respond to rcl_preshutdown signals independently of the planner or controller nodes. This can lead to `costmap_ros_` deactivating and cleaning up before the planner/controller, leaving dangling pointers in the parent nodes.",
    "weaknesses": [
      "Asynchronous shutdown",
       "Null pointer dereference",
      "Race condition during shutdown",
       "Improper handling of lifecycle node dependencies"
    ],
    "impact": "The impact is program crashes due to null pointer dereferences during shutdown, which can lead to unexpected termination and potential loss of progress or data.",
     "attackVector": "The vulnerability is triggered when a shutdown sequence of the system begins, usually with a signal such as Ctrl+C, which can lead to an unsynchronized shutdown of the costmap and planner/controller nodes.",
    "attackerCapabilities": "An attacker would need the capability to trigger a system-wide shutdown, which would then expose the vulnerability."
    }
  },
  {
  "cveId": "CVE-2024-25197",
  "source": "github.com_a7839bb9_20250111_152502.html",
   "vulnerability": {
    "description": "The content describes a bug report for a null pointer dereference issue in the ros-navigation/navigation2 project during communication between the nav2_planner and nav2_costmap_2d packages. The core problem lies in accessing invalid memory locations due to concurrent multithreading, leading to program crashes. The specific error occurs when the `nav2_planner` node tries to use a pointer from `nav2_costmap_2d`, that might have been released before planner node accesses it.",
    "rootCause": "The root cause is a race condition where the `nav2_costmap_2d` node might be undergoing recalculation or lifecycle changes due to sensor inputs or shutdown events. During this state, the planner node continues its operations and attempts to access the `costmap_ros_` pointer, which may already have been freed or invalidated due to operations like `clear entirely`  by the other thread.",
    "weaknesses": [
      "Null pointer dereference",
      "Multi-threading race condition",
      "Lack of synchronization on shared memory",
       "Inadequate checks before accessing pointers"
     ],
     "impact": "The bug causes the program to crash due to memory access violations, leading to unstable or failed robotic operations during the execution of a `nav2_goal` action, especially when the `nav2_costmap_2d` node is clearing or recalculating.",
     "attackVector": "The attack vector is by manipulating the environment (sensor data) to cause frequent costmap resets or shutdown actions, or trigger a concurrent situation with the nav2_goal action to invoke the race condition. Specifically, user send a `nav2_goal` action and in the same time cause interference sensor messages, which could lead to frequent costmap clearing.",
      "attackerCapabilities": "An attacker needs to have the ability to send goals and sensor messages that would induce frequent operations on the `nav2_costmap_2d` node and also initiate actions in planner."
    }
}
```