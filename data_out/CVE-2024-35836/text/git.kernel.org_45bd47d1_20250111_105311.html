

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=5050a5b9d8b4d3c6f7e376e07670e437db7ccf9c)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=5050a5b9d8b4d3c6f7e376e07670e437db7ccf9c)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=5050a5b9d8b4d3c6f7e376e07670e437db7ccf9c)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5050a5b9d8b4d3c6f7e376e07670e437db7ccf9c)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Arkadiusz Kubalewski <arkadiusz.kubalewski@intel.com> | 2024-01-19 14:43:02 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-01-31 16:21:06 -0800 |
| commit | [5050a5b9d8b4d3c6f7e376e07670e437db7ccf9c](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=5050a5b9d8b4d3c6f7e376e07670e437db7ccf9c) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=5050a5b9d8b4d3c6f7e376e07670e437db7ccf9c)) | |
| tree | [19b8f091a17d48a7df397882650b055374ab02e0](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=5050a5b9d8b4d3c6f7e376e07670e437db7ccf9c) | |
| parent | [79fc259dca8689150c30869e3c667fb635d543c8](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=79fc259dca8689150c30869e3c667fb635d543c8) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5050a5b9d8b4d3c6f7e376e07670e437db7ccf9c&id2=79fc259dca8689150c30869e3c667fb635d543c8)) | |
| download | [linux-5050a5b9d8b4d3c6f7e376e07670e437db7ccf9c.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-5050a5b9d8b4d3c6f7e376e07670e437db7ccf9c.tar.gz) | |

dpll: fix pin dump crash for rebound module[ Upstream commit 830ead5fb0c5855ce4d70ba2ed4a673b5f1e7d9b ]
When a kernel module is unbound but the pin resources were not entirely
freed (other kernel module instance of the same PCI device have had kept
the reference to that pin), and kernel module is again bound, the pin
properties would not be updated (the properties are only assigned when
memory for the pin is allocated), prop pointer still points to the
kernel module memory of the kernel module which was deallocated on the
unbind.
If the pin dump is invoked in this state, the result is a kernel crash.
Prevent the crash by storing persistent pin properties in dpll subsystem,
copy the content from the kernel module when pin is allocated, instead of
using memory of the kernel module.
Fixes: 9431063ad323 ("dpll: core: Add DPLL framework base functions")
Fixes: 9d71b54b65b1 ("dpll: netlink: Add DPLL framework base functions")
Reviewed-by: Jan Glaza <jan.glaza@intel.com>
Reviewed-by: Przemek Kitszel <przemyslaw.kitszel@intel.com>
Signed-off-by: Arkadiusz Kubalewski <arkadiusz.kubalewski@intel.com>
Reviewed-by: Jiri Pirko <jiri@nvidia.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5050a5b9d8b4d3c6f7e376e07670e437db7ccf9c)

| -rw-r--r-- | [drivers/dpll/dpll\_core.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/dpll/dpll_core.c?id=5050a5b9d8b4d3c6f7e376e07670e437db7ccf9c) | 55 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/dpll/dpll\_core.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/dpll/dpll_core.h?id=5050a5b9d8b4d3c6f7e376e07670e437db7ccf9c) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/dpll/dpll\_netlink.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/dpll/dpll_netlink.c?id=5050a5b9d8b4d3c6f7e376e07670e437db7ccf9c) | 28 | |  |  |  | | --- | --- | --- | |

3 files changed, 69 insertions, 18 deletions

| diff --git a/drivers/dpll/dpll\_core.c b/drivers/dpll/dpll\_core.cindex 36f5c0eaf60484..5e3b9b5679f927 100644--- a/[drivers/dpll/dpll\_core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/dpll/dpll_core.c?id=79fc259dca8689150c30869e3c667fb635d543c8)+++ b/[drivers/dpll/dpll\_core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/dpll/dpll_core.c?id=5050a5b9d8b4d3c6f7e376e07670e437db7ccf9c)@@ -424,6 +424,53 @@ void dpll\_device\_unregister(struct dpll\_device \*dpll, } EXPORT\_SYMBOL\_GPL(dpll\_device\_unregister); +static void dpll\_pin\_prop\_free(struct dpll\_pin\_properties \*prop)+{+ kfree(prop->package\_label);+ kfree(prop->panel\_label);+ kfree(prop->board\_label);+ kfree(prop->freq\_supported);+}++static int dpll\_pin\_prop\_dup(const struct dpll\_pin\_properties \*src,+ struct dpll\_pin\_properties \*dst)+{+ memcpy(dst, src, sizeof(\*dst));+ if (src->freq\_supported && src->freq\_supported\_num) {+ size\_t freq\_size = src->freq\_supported\_num \*+ sizeof(\*src->freq\_supported);+ dst->freq\_supported = kmemdup(src->freq\_supported,+ freq\_size, GFP\_KERNEL);+ if (!src->freq\_supported)+ return -ENOMEM;+ }+ if (src->board\_label) {+ dst->board\_label = kstrdup(src->board\_label, GFP\_KERNEL);+ if (!dst->board\_label)+ goto err\_board\_label;+ }+ if (src->panel\_label) {+ dst->panel\_label = kstrdup(src->panel\_label, GFP\_KERNEL);+ if (!dst->panel\_label)+ goto err\_panel\_label;+ }+ if (src->package\_label) {+ dst->package\_label = kstrdup(src->package\_label, GFP\_KERNEL);+ if (!dst->package\_label)+ goto err\_package\_label;+ }++ return 0;++err\_package\_label:+ kfree(dst->panel\_label);+err\_panel\_label:+ kfree(dst->board\_label);+err\_board\_label:+ kfree(dst->freq\_supported);+ return -ENOMEM;+}+ static struct dpll\_pin \* dpll\_pin\_alloc(u64 clock\_id, u32 pin\_idx, struct module \*module, const struct dpll\_pin\_properties \*prop)@@ -442,7 +489,9 @@ dpll\_pin\_alloc(u64 clock\_id, u32 pin\_idx, struct module \*module, ret = -EINVAL; goto err\_pin\_prop; }- pin->prop = prop;+ ret = dpll\_pin\_prop\_dup(prop, &pin->prop);+ if (ret)+ goto err\_pin\_prop; refcount\_set(&pin->refcount, 1); xa\_init\_flags(&pin->dpll\_refs, XA\_FLAGS\_ALLOC); xa\_init\_flags(&pin->parent\_refs, XA\_FLAGS\_ALLOC);@@ -453,6 +502,7 @@ dpll\_pin\_alloc(u64 clock\_id, u32 pin\_idx, struct module \*module, err\_xa\_alloc: xa\_destroy(&pin->dpll\_refs); xa\_destroy(&pin->parent\_refs);+ dpll\_pin\_prop\_free(&pin->prop); err\_pin\_prop: kfree(pin); return ERR\_PTR(ret);@@ -513,6 +563,7 @@ void dpll\_pin\_put(struct dpll\_pin \*pin) xa\_destroy(&pin->dpll\_refs); xa\_destroy(&pin->parent\_refs); xa\_erase(&dpll\_pin\_xa, pin->id);+ dpll\_pin\_prop\_free(&pin->prop); kfree(pin); } mutex\_unlock(&dpll\_lock);@@ -635,7 +686,7 @@ int dpll\_pin\_on\_pin\_register(struct dpll\_pin \*parent, struct dpll\_pin \*pin, unsigned long i, stop; int ret; - if (WARN\_ON(parent->prop->type != DPLL\_PIN\_TYPE\_MUX))+ if (WARN\_ON(parent->prop.type != DPLL\_PIN\_TYPE\_MUX)) return -EINVAL;  if (WARN\_ON(!ops) ||diff --git a/drivers/dpll/dpll\_core.h b/drivers/dpll/dpll\_core.hindex 5585873c5c1b02..717f715015c742 100644--- a/[drivers/dpll/dpll\_core.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/dpll/dpll_core.h?id=79fc259dca8689150c30869e3c667fb635d543c8)+++ b/[drivers/dpll/dpll\_core.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/dpll/dpll_core.h?id=5050a5b9d8b4d3c6f7e376e07670e437db7ccf9c)@@ -44,7 +44,7 @@ struct dpll\_device { \* @module: module of creator \* @dpll\_refs: hold referencees to dplls pin was registered with \* @parent\_refs: hold references to parent pins pin was registered with- \* @prop: pointer to pin properties given by registerer+ \* @prop: pin properties copied from the registerer \* @rclk\_dev\_name: holds name of device when pin can recover clock from it \* @refcount: refcount \*\*/@@ -55,7 +55,7 @@ struct dpll\_pin { struct module \*module; struct xarray dpll\_refs; struct xarray parent\_refs;- const struct dpll\_pin\_properties \*prop;+ struct dpll\_pin\_properties prop; refcount\_t refcount; }; diff --git a/drivers/dpll/dpll\_netlink.c b/drivers/dpll/dpll\_netlink.cindex ce7cf736f02084..4c64611d32ac66 100644--- a/[drivers/dpll/dpll\_netlink.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/dpll/dpll_netlink.c?id=79fc259dca8689150c30869e3c667fb635d543c8)+++ b/[drivers/dpll/dpll\_netlink.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/dpll/dpll_netlink.c?id=5050a5b9d8b4d3c6f7e376e07670e437db7ccf9c)@@ -278,17 +278,17 @@ dpll\_msg\_add\_pin\_freq(struct sk\_buff \*msg, struct dpll\_pin \*pin, if (nla\_put\_64bit(msg, DPLL\_A\_PIN\_FREQUENCY, sizeof(freq), &freq, DPLL\_A\_PIN\_PAD)) return -EMSGSIZE;- for (fs = 0; fs < pin->prop->freq\_supported\_num; fs++) {+ for (fs = 0; fs < pin->prop.freq\_supported\_num; fs++) { nest = nla\_nest\_start(msg, DPLL\_A\_PIN\_FREQUENCY\_SUPPORTED); if (!nest) return -EMSGSIZE;- freq = pin->prop->freq\_supported[fs].min;+ freq = pin->prop.freq\_supported[fs].min; if (nla\_put\_64bit(msg, DPLL\_A\_PIN\_FREQUENCY\_MIN, sizeof(freq), &freq, DPLL\_A\_PIN\_PAD)) { nla\_nest\_cancel(msg, nest); return -EMSGSIZE; }- freq = pin->prop->freq\_supported[fs].max;+ freq = pin->prop.freq\_supported[fs].max; if (nla\_put\_64bit(msg, DPLL\_A\_PIN\_FREQUENCY\_MAX, sizeof(freq), &freq, DPLL\_A\_PIN\_PAD)) { nla\_nest\_cancel(msg, nest);@@ -304,9 +304,9 @@ static bool dpll\_pin\_is\_freq\_supported(struct dpll\_pin \*pin, u32 freq) { int fs; - for (fs = 0; fs < pin->prop->freq\_supported\_num; fs++)- if (freq >= pin->prop->freq\_supported[fs].min &&- freq <= pin->prop->freq\_supported[fs].max)+ for (fs = 0; fs < pin->prop.freq\_supported\_num; fs++)+ if (freq >= pin->prop.freq\_supported[fs].min &&+ freq <= pin->prop.freq\_supported[fs].max) return true; return false; }@@ -396,7 +396,7 @@ static int dpll\_cmd\_pin\_get\_one(struct sk\_buff \*msg, struct dpll\_pin \*pin, struct netlink\_ext\_ack \*extack) {- const struct dpll\_pin\_properties \*prop = pin->prop;+ const struct dpll\_pin\_properties \*prop = &pin->prop; struct dpll\_pin\_ref \*ref; int ret; @@ -689,7 +689,7 @@ dpll\_pin\_on\_pin\_state\_set(struct dpll\_pin \*pin, u32 parent\_idx, int ret;  if (!(DPLL\_PIN\_CAPABILITIES\_STATE\_CAN\_CHANGE &- pin->prop->capabilities)) {+ pin->prop.capabilities)) { NL\_SET\_ERR\_MSG(extack, "state changing is not allowed"); return -EOPNOTSUPP; }@@ -725,7 +725,7 @@ dpll\_pin\_state\_set(struct dpll\_device \*dpll, struct dpll\_pin \*pin, int ret;  if (!(DPLL\_PIN\_CAPABILITIES\_STATE\_CAN\_CHANGE &- pin->prop->capabilities)) {+ pin->prop.capabilities)) { NL\_SET\_ERR\_MSG(extack, "state changing is not allowed"); return -EOPNOTSUPP; }@@ -752,7 +752,7 @@ dpll\_pin\_prio\_set(struct dpll\_device \*dpll, struct dpll\_pin \*pin, int ret;  if (!(DPLL\_PIN\_CAPABILITIES\_PRIORITY\_CAN\_CHANGE &- pin->prop->capabilities)) {+ pin->prop.capabilities)) { NL\_SET\_ERR\_MSG(extack, "prio changing is not allowed"); return -EOPNOTSUPP; }@@ -780,7 +780,7 @@ dpll\_pin\_direction\_set(struct dpll\_pin \*pin, struct dpll\_device \*dpll, int ret;  if (!(DPLL\_PIN\_CAPABILITIES\_DIRECTION\_CAN\_CHANGE &- pin->prop->capabilities)) {+ pin->prop.capabilities)) { NL\_SET\_ERR\_MSG(extack, "direction changing is not allowed"); return -EOPNOTSUPP; }@@ -810,8 +810,8 @@ dpll\_pin\_phase\_adj\_set(struct dpll\_pin \*pin, struct nlattr \*phase\_adj\_attr, int ret;  phase\_adj = nla\_get\_s32(phase\_adj\_attr);- if (phase\_adj > pin->prop->phase\_range.max ||- phase\_adj < pin->prop->phase\_range.min) {+ if (phase\_adj > pin->prop.phase\_range.max ||+ phase\_adj < pin->prop.phase\_range.min) { NL\_SET\_ERR\_MSG\_ATTR(extack, phase\_adj\_attr, "phase adjust value not supported"); return -EINVAL;@@ -995,7 +995,7 @@ dpll\_pin\_find(u64 clock\_id, struct nlattr \*mod\_name\_attr, unsigned long i;  xa\_for\_each\_marked(&dpll\_pin\_xa, i, pin, DPLL\_REGISTERED) {- prop = pin->prop;+ prop = &pin->prop; cid\_match = clock\_id ? pin->clock\_id == clock\_id : true; mod\_match = mod\_name\_attr && module\_name(pin->module) ? !nla\_strcmp(mod\_name\_attr, |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 10:51:48 +0000

