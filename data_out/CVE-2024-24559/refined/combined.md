=== Content from github.com_0cc352a1_20250111_075456.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fblob%2Fc150fc49ee9375a930d177044559b83cb95f7963%2Fvyper%2Fir%2Fcompile_ir.py)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fblob%2Fc150fc49ee9375a930d177044559b83cb95f7963%2Fvyper%2Fir%2Fcompile_ir.py)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=vyperlang%2Fvyper)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[vyperlang](/vyperlang)
/
**[vyper](/vyperlang/vyper)**
Public

* [Notifications](/login?return_to=%2Fvyperlang%2Fvyper) You must be signed in to change notification settings
* [Fork
  815](/login?return_to=%2Fvyperlang%2Fvyper)
* [Star
   4.9k](/login?return_to=%2Fvyperlang%2Fvyper)

* [Code](/vyperlang/vyper)
* [Issues
  413](/vyperlang/vyper/issues)
* [Pull requests
  84](/vyperlang/vyper/pulls)
* [Discussions](/vyperlang/vyper/discussions)
* [Actions](/vyperlang/vyper/actions)
* [Projects
  0](/vyperlang/vyper/projects)
* [Wiki](/vyperlang/vyper/wiki)
* [Security](/vyperlang/vyper/security)
* [Insights](/vyperlang/vyper/pulse)

Additional navigation options

* [Code](/vyperlang/vyper)
* [Issues](/vyperlang/vyper/issues)
* [Pull requests](/vyperlang/vyper/pulls)
* [Discussions](/vyperlang/vyper/discussions)
* [Actions](/vyperlang/vyper/actions)
* [Projects](/vyperlang/vyper/projects)
* [Wiki](/vyperlang/vyper/wiki)
* [Security](/vyperlang/vyper/security)
* [Insights](/vyperlang/vyper/pulse)

## Files

 c150fc4
## Breadcrumbs

1. [vyper](/vyperlang/vyper/tree/c150fc49ee9375a930d177044559b83cb95f7963)
2. /[vyper](/vyperlang/vyper/tree/c150fc49ee9375a930d177044559b83cb95f7963/vyper)
3. /[ir](/vyperlang/vyper/tree/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir)
/
# compile\_ir.py

Copy path Blame  Blame
## Latest commit

## History

[History](/vyperlang/vyper/commits/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py)1347 lines (1115 loc) · 44.4 KB c150fc4
## Breadcrumbs

1. [vyper](/vyperlang/vyper/tree/c150fc49ee9375a930d177044559b83cb95f7963)
2. /[vyper](/vyperlang/vyper/tree/c150fc49ee9375a930d177044559b83cb95f7963/vyper)
3. /[ir](/vyperlang/vyper/tree/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir)
/
# compile\_ir.py

Top
## File metadata and controls

* Code
* Blame

1347 lines (1115 loc) · 44.4 KB[Raw](https://github.com/vyperlang/vyper/raw/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000import copyimport functoolsimport mathfrom dataclasses import dataclass
import cbor2
from vyper.codegen.ir\_node import IRnodefrom vyper.compiler.settings import OptimizationLevelfrom vyper.evm.opcodes import get\_opcodes, version\_checkfrom vyper.exceptions import CodegenPanic, CompilerPanicfrom vyper.ir.optimizer import COMMUTATIVE\_OPSfrom vyper.utils import MemoryPositionsfrom vyper.version import version\_tuple
PUSH\_OFFSET = 0x5FDUP\_OFFSET = 0x7FSWAP\_OFFSET = 0x8F
def num\_to\_bytearray(x): o = [] while x > 0: o.insert(0, x % 256) x //= 256 return o
def PUSH(x): bs = num\_to\_bytearray(x) # starting in shanghai, can do push0 directly with no immediates if len(bs) == 0 and not version\_check(begin="shanghai"): bs = [0] return [f"PUSH{len(bs)}"] + bs
# push an exact number of bytesdef PUSH\_N(x, n): o = [] for \_i in range(n): o.insert(0, x % 256) x //= 256 assert x == 0 return [f"PUSH{len(o)}"] + o
\_next\_symbol = 0
def mksymbol(name=""): global \_next\_symbol \_next\_symbol += 1
 return f"\_sym\_{name}{\_next\_symbol}"
def mkdebug(pc\_debugger, source\_pos): i = Instruction("DEBUG", source\_pos) i.pc\_debugger = pc\_debugger return [i]
def is\_symbol(i): return isinstance(i, str) and i.startswith("\_sym\_")
# basically something like a symbol which gets resolved# during assembly, but requires 4 bytes of space.# (should only happen in deploy code)def is\_mem\_sym(i): return isinstance(i, str) and i.startswith("\_mem\_")
def is\_ofst(sym): return isinstance(sym, str) and sym == "\_OFST"
def \_runtime\_code\_offsets(ctor\_mem\_size, runtime\_codelen): # we need two numbers to calculate where the runtime code # should be copied to in memory (and making sure we don't # trample immutables, which are written to during the ctor # code): the memory allocated for the ctor and the length # of the runtime code. # after the ctor has run but before copying runtime code to # memory, the layout is # <ctor memory variables> ... | data section # and after copying runtime code to memory (immediately before # returning the runtime code): # <runtime code> ... | data section # since the ctor memory variables and runtime code overlap, # we start allocating the data section from # `max(ctor\_mem\_size, runtime\_code\_size)`
 runtime\_code\_end = max(ctor\_mem\_size, runtime\_codelen) runtime\_code\_start = runtime\_code\_end - runtime\_codelen
 return runtime\_code\_start, runtime\_code\_end
# Calculate the size of PUSH instruction we need to handle all# mem offsets in the code. For instance, if we only see mem symbols# up to size 256, we can use PUSH1.def calc\_mem\_ofst\_size(ctor\_mem\_size): return math.ceil(math.log(ctor\_mem\_size + 1, 256))
# temporary optimization to handle stack items for return sequences# like `return return\_ofst return\_len`. this is kind of brittle because# it assumes the arguments are already on the stack, to be replaced# by better liveness analysis.# NOTE: modifies input in-placedef \_rewrite\_return\_sequences(ir\_node, label\_params=None): args = ir\_node.args
 if ir\_node.value == "return": if args[0].value == "ret\_ofst" and args[1].value == "ret\_len": ir\_node.args[0].value = "pass" ir\_node.args[1].value = "pass" if ir\_node.value == "exit\_to": # handle exit from private function if args[0].value == "return\_pc": ir\_node.value = "jump" args[0].value = "pass" else: # handle jump to cleanup ir\_node.value = "seq"
 \_t = ["seq"] if "return\_buffer" in label\_params: \_t.append(["pop", "pass"])
 dest = args[0].value # works for both internal and external exit\_to more\_args = ["pass" if t.value == "return\_pc" else t for t in args[1:]] \_t.append(["goto", dest] + more\_args) ir\_node.args = IRnode.from\_list(\_t, source\_pos=ir\_node.source\_pos).args
 if ir\_node.value == "label": label\_params = set(t.value for t in ir\_node.args[1].args)
 for t in args: \_rewrite\_return\_sequences(t, label\_params)
def \_assert\_false(): global \_revert\_label # use a shared failure block for common case of assert(x). # in the future we might want to change the code # at \_sym\_revert0 to: INVALID return [\_revert\_label, "JUMPI"]
def \_add\_postambles(asm\_ops): to\_append = []
 global \_revert\_label
 \_revert\_string = [\_revert\_label, "JUMPDEST", \*PUSH(0), "DUP1", "REVERT"]
 if \_revert\_label in asm\_ops: # shared failure block to\_append.extend(\_revert\_string)
 if len(to\_append) > 0: # insert the postambles \*before\* runtime code # so the data section of the runtime code can't bork the postambles. runtime = None if isinstance(asm\_ops[-1], list) and isinstance(asm\_ops[-1][0], RuntimeHeader): runtime = asm\_ops.pop()
 # for some reason there might not be a STOP at the end of asm\_ops. # (generally vyper programs will have it but raw IR might not). asm\_ops.append("STOP") asm\_ops.extend(to\_append)
 if runtime: asm\_ops.append(runtime)
 # need to do this recursively since every sublist is basically # treated as its own program (there are no global labels.) for t in asm\_ops: if isinstance(t, list): \_add\_postambles(t)
class Instruction(str): def \_\_new\_\_(cls, sstr, \*args, \*\*kwargs): return super().\_\_new\_\_(cls, sstr)
 def \_\_init\_\_(self, sstr, source\_pos=None, error\_msg=None): self.error\_msg = error\_msg self.pc\_debugger = False
 if source\_pos is not None: self.lineno, self.col\_offset, self.end\_lineno, self.end\_col\_offset = source\_pos else: self.lineno, self.col\_offset, self.end\_lineno, self.end\_col\_offset = [None] \* 4
def apply\_line\_numbers(func): @functools.wraps(func) def apply\_line\_no\_wrapper(\*args, \*\*kwargs): code = args[0] ret = func(\*args, \*\*kwargs)
 new\_ret = [ Instruction(i, code.source\_pos, code.error\_msg) if isinstance(i, str) and not isinstance(i, Instruction) else i for i in ret ] return new\_ret
 return apply\_line\_no\_wrapper
@apply\_line\_numbersdef compile\_to\_assembly(code, optimize=OptimizationLevel.GAS): global \_revert\_label \_revert\_label = mksymbol("revert")
 # don't overwrite ir since the original might need to be output, e.g. `-f ir,asm` code = copy.deepcopy(code) \_rewrite\_return\_sequences(code)
 res = \_compile\_to\_assembly(code)
 \_add\_postambles(res)
 \_relocate\_segments(res)
 if optimize != OptimizationLevel.NONE: optimize\_assembly(res) return res
# Compiles IR to assembly@apply\_line\_numbersdef \_compile\_to\_assembly(code, withargs=None, existing\_labels=None, break\_dest=None, height=0): if withargs is None: withargs = {} if not isinstance(withargs, dict): raise CompilerPanic(f"Incorrect type for withargs: {type(withargs)}")
 def \_data\_ofst\_of(sym, ofst, height\_): # e.g. \_OFST \_sym\_foo 32 assert is\_symbol(sym) or is\_mem\_sym(sym) if isinstance(ofst.value, int): # resolve at compile time using magic \_OFST op return ["\_OFST", sym, ofst.value] else: # if we can't resolve at compile time, resolve at runtime ofst = \_compile\_to\_assembly(ofst, withargs, existing\_labels, break\_dest, height\_) return ofst + [sym, "ADD"]
 def \_height\_of(witharg): ret = height - withargs[witharg] if ret > 16: raise Exception("With statement too deep") return ret
 if existing\_labels is None: existing\_labels = set() if not isinstance(existing\_labels, set): raise CompilerPanic(f"must be set(), but got {type(existing\_labels)}")
 # Opcodes if isinstance(code.value, str) and code.value.upper() in get\_opcodes(): o = [] for i, c in enumerate(code.args[::-1]): o.extend(\_compile\_to\_assembly(c, withargs, existing\_labels, break\_dest, height + i)) o.append(code.value.upper()) return o
 # Numbers elif isinstance(code.value, int): if code.value < -(2\*\*255): raise Exception(f"Value too low: {code.value}") elif code.value >= 2\*\*256: raise Exception(f"Value too high: {code.value}") return PUSH(code.value % 2\*\*256)
 # Variables connected to with statements elif isinstance(code.value, str) and code.value in withargs: return ["DUP" + str(\_height\_of(code.value))]
 # Setting variables connected to with statements elif code.value == "set": if len(code.args) != 2 or code.args[0].value not in withargs: raise Exception("Set expects two arguments, the first being a stack variable") if height - withargs[code.args[0].value] > 16: raise Exception("With statement too deep") return \_compile\_to\_assembly(code.args[1], withargs, existing\_labels, break\_dest, height) + [ "SWAP" + str(height - withargs[code.args[0].value]), "POP", ]
 # Pass statements # TODO remove "dummy"; no longer needed elif code.value in ("pass", "dummy"): return []
 # "mload" from data section of the currently executing code elif code.value == "dload": loc = code.args[0]
 o = [] # codecopy 32 bytes to FREE\_VAR\_SPACE, then mload from FREE\_VAR\_SPACE o.extend(PUSH(32)) o.extend(\_data\_ofst\_of("\_sym\_code\_end", loc, height + 1)) o.extend(PUSH(MemoryPositions.FREE\_VAR\_SPACE) + ["CODECOPY"]) o.extend(PUSH(MemoryPositions.FREE\_VAR\_SPACE) + ["MLOAD"]) return o
 # batch copy from data section of the currently executing code to memory # (probably should have named this dcopy but oh well) elif code.value == "dloadbytes": dst = code.args[0] src = code.args[1] len\_ = code.args[2]
 o = [] o.extend(\_compile\_to\_assembly(len\_, withargs, existing\_labels, break\_dest, height)) o.extend(\_data\_ofst\_of("\_sym\_code\_end", src, height + 1)) o.extend(\_compile\_to\_assembly(dst, withargs, existing\_labels, break\_dest, height + 2)) o.extend(["CODECOPY"]) return o
 # "mload" from the data section of (to-be-deployed) runtime code elif code.value == "iload": loc = code.args[0]
 o = [] o.extend(\_data\_ofst\_of("\_mem\_deploy\_end", loc, height)) o.append("MLOAD")
 return o
 # "mstore" to the data section of (to-be-deployed) runtime code elif code.value == "istore": loc = code.args[0] val = code.args[1]
 o = [] o.extend(\_compile\_to\_assembly(val, withargs, existing\_labels, break\_dest, height)) o.extend(\_data\_ofst\_of("\_mem\_deploy\_end", loc, height + 1)) o.append("MSTORE")
 return o
 # batch copy from memory to the data section of runtime code elif code.value == "istorebytes": raise Exception("unimplemented")
 # If statements (2 arguments, ie. if x: y) elif code.value == "if" and len(code.args) == 2: o = [] o.extend(\_compile\_to\_assembly(code.args[0], withargs, existing\_labels, break\_dest, height)) end\_symbol = mksymbol("join") o.extend(["ISZERO", end\_symbol, "JUMPI"]) o.extend(\_compile\_to\_assembly(code.args[1], withargs, existing\_labels, break\_dest, height)) o.extend([end\_symbol, "JUMPDEST"]) return o # If statements (3 arguments, ie. if x: y, else: z) elif code.value == "if" and len(code.args) == 3: o = [] o.extend(\_compile\_to\_assembly(code.args[0], withargs, existing\_labels, break\_dest, height)) mid\_symbol = mksymbol("else") end\_symbol = mksymbol("join") o.extend(["ISZERO", mid\_symbol, "JUMPI"]) o.extend(\_compile\_to\_assembly(code.args[1], withargs, existing\_labels, break\_dest, height)) o.extend([end\_symbol, "JUMP", mid\_symbol, "JUMPDEST"]) o.extend(\_compile\_to\_assembly(code.args[2], withargs, existing\_labels, break\_dest, height)) o.extend([end\_symbol, "JUMPDEST"]) return o
 # repeat(counter\_location, start, rounds, rounds\_bound, body) # basically a do-while loop: # # assert(rounds <= rounds\_bound) # if (rounds > 0) { # do { # body; # } while (++i != start + rounds) # } elif code.value == "repeat": o = [] if len(code.args) != 5: raise CompilerPanic("bad number of repeat args") # pragma: notest
 i\_name = code.args[0] start = code.args[1] rounds = code.args[2] rounds\_bound = code.args[3] body = code.args[4]
 entry\_dest, continue\_dest, exit\_dest = ( mksymbol("loop\_start"), mksymbol("loop\_continue"), mksymbol("loop\_exit"), )
 # stack: [] o.extend(\_compile\_to\_assembly(start, withargs, existing\_labels, break\_dest, height))
 o.extend(\_compile\_to\_assembly(rounds, withargs, existing\_labels, break\_dest, height + 1))
 # stack: i
 # assert rounds <= round\_bound if rounds != rounds\_bound: # stack: i, rounds o.extend( \_compile\_to\_assembly( rounds\_bound, withargs, existing\_labels, break\_dest, height + 2 ) ) # stack: i, rounds, rounds\_bound # assert 0 <= rounds <= rounds\_bound (for rounds\_bound < 2\*\*255) # TODO this runtime assertion shouldn't fail for # internally generated repeats. o.extend(["DUP2", "GT"] + \_assert\_false())
 # stack: i, rounds # if (0 == rounds) { goto end\_dest; } o.extend(["DUP1", "ISZERO", exit\_dest, "JUMPI"])
 # stack: start, rounds if start.value != 0: o.extend(["DUP2", "ADD"])
 # stack: i, exit\_i o.extend(["SWAP1"])
 if i\_name.value in withargs: raise CompilerPanic(f"shadowed loop variable {i\_name}") withargs[i\_name.value] = height + 1
 # stack: exit\_i, i o.extend([entry\_dest, "JUMPDEST"]) o.extend( \_compile\_to\_assembly( body, withargs, existing\_labels, (exit\_dest, continue\_dest, height + 2), height + 2 ) )
 del withargs[i\_name.value]
 # clean up any stack items left by body o.extend(["POP"] \* body.valency)
 # stack: exit\_i, i # increment i: o.extend([continue\_dest, "JUMPDEST", "PUSH1", 1, "ADD"])
 # stack: exit\_i, i+1 (new\_i) # if (exit\_i != new\_i) { goto entry\_dest } o.extend(["DUP2", "DUP2", "XOR", entry\_dest, "JUMPI"]) o.extend([exit\_dest, "JUMPDEST", "POP", "POP"])
 return o
 # Continue to the next iteration of the for loop elif code.value == "continue": if not break\_dest: raise CompilerPanic("Invalid break") dest, continue\_dest, break\_height = break\_dest return [continue\_dest, "JUMP"] # Break from inside a for loop elif code.value == "break": if not break\_dest: raise CompilerPanic("Invalid break") dest, continue\_dest, break\_height = break\_dest
 n\_local\_vars = height - break\_height # clean up any stack items declared in the loop body cleanup\_local\_vars = ["POP"] \* n\_local\_vars return cleanup\_local\_vars + [dest, "JUMP"] # Break from inside one or more for loops prior to a return statement inside the loop elif code.value == "cleanup\_repeat": if not break\_dest: raise CompilerPanic("Invalid break") # clean up local vars and internal loop vars \_, \_, break\_height = break\_dest # except don't pop label params if "return\_buffer" in withargs: break\_height -= 1 if "return\_pc" in withargs: break\_height -= 1 return ["POP"] \* break\_height # With statements elif code.value == "with": o = [] o.extend(\_compile\_to\_assembly(code.args[1], withargs, existing\_labels, break\_dest, height)) old = withargs.get(code.args[0].value, None) withargs[code.args[0].value] = height o.extend( \_compile\_to\_assembly(code.args[2], withargs, existing\_labels, break\_dest, height + 1) ) if code.args[2].valency: o.extend(["SWAP1", "POP"]) else: o.extend(["POP"]) if old is not None: withargs[code.args[0].value] = old else: del withargs[code.args[0].value] return o
 # runtime statement (used to deploy runtime code) elif code.value == "deploy": memsize = code.args[0].value # used later to calculate \_mem\_deploy\_start ir = code.args[1] immutables\_len = code.args[2].value assert isinstance(memsize, int), "non-int memsize" assert isinstance(immutables\_len, int), "non-int immutables\_len"
 runtime\_begin = mksymbol("runtime\_begin")
 subcode = \_compile\_to\_assembly(ir)
 o = []
 # COPY the code to memory for deploy o.extend(["\_sym\_subcode\_size", runtime\_begin, "\_mem\_deploy\_start", "CODECOPY"])
 # calculate the len of runtime code o.extend(["\_OFST", "\_sym\_subcode\_size", immutables\_len]) # stack: len o.extend(["\_mem\_deploy\_start"]) # stack: len mem\_ofst o.extend(["RETURN"])
 # since the asm data structures are very primitive, to make sure # assembly\_to\_evm is able to calculate data offsets correctly, # we pass the memsize via magic opcodes to the subcode subcode = [RuntimeHeader(runtime\_begin, memsize, immutables\_len)] + subcode
 # append the runtime code after the ctor code # `append(...)` call here is intentional. # each sublist is essentially its own program with its # own symbols. # in the later step when the "ir" block compiled to EVM, # symbols in subcode are resolved to position from start of # runtime-code (instead of position from start of bytecode). o.append(subcode)
 return o
 # Seq (used to piece together multiple statements) elif code.value == "seq": o = [] for arg in code.args: o.extend(\_compile\_to\_assembly(arg, withargs, existing\_labels, break\_dest, height)) if arg.valency == 1 and arg != code.args[-1]: o.append("POP") return o # Seq without popping. # unreachable keyword produces INVALID opcode elif code.value == "assert\_unreachable": o = \_compile\_to\_assembly(code.args[0], withargs, existing\_labels, break\_dest, height) end\_symbol = mksymbol("reachable") o.extend([end\_symbol, "JUMPI", "INVALID", end\_symbol, "JUMPDEST"]) return o # Assert (if false, exit) elif code.value == "assert": o = \_compile\_to\_assembly(code.args[0], withargs, existing\_labels, break\_dest, height) o.extend(["ISZERO"]) o.extend(\_assert\_false()) return o
 # SHA3 a single value elif code.value == "sha3\_32": o = \_compile\_to\_assembly(code.args[0], withargs, existing\_labels, break\_dest, height) o.extend( [ \*PUSH(MemoryPositions.FREE\_VAR\_SPACE), "MSTORE", \*PUSH(32), \*PUSH(MemoryPositions.FREE\_VAR\_SPACE), "SHA3", ] ) return o # SHA3 a 64 byte value elif code.value == "sha3\_64": o = \_compile\_to\_assembly(code.args[0], withargs, existing\_labels, break\_dest, height) o.extend(\_compile\_to\_assembly(code.args[1], withargs, existing\_labels, break\_dest, height)) o.extend( [ \*PUSH(MemoryPositions.FREE\_VAR\_SPACE2), "MSTORE", \*PUSH(MemoryPositions.FREE\_VAR\_SPACE), "MSTORE", \*PUSH(64), \*PUSH(MemoryPositions.FREE\_VAR\_SPACE), "SHA3", ] ) return o elif code.value == "select": # b ^ ((a ^ b) \* cond) where cond is 1 or 0 # let t = a ^ b cond = code.args[0] a = code.args[1] b = code.args[2]
 o = [] o.extend(\_compile\_to\_assembly(b, withargs, existing\_labels, break\_dest, height)) o.extend(\_compile\_to\_assembly(a, withargs, existing\_labels, break\_dest, height + 1)) # stack: b a o.extend(["DUP2", "XOR"]) # stack: b t o.extend(\_compile\_to\_assembly(cond, withargs, existing\_labels, break\_dest, height + 2)) # stack: b t cond o.extend(["MUL", "XOR"])
 # stack: b ^ (t \* cond) return o
 # <= operator elif code.value == "le": return \_compile\_to\_assembly( IRnode.from\_list(["iszero", ["gt", code.args[0], code.args[1]]]), withargs, existing\_labels, break\_dest, height, ) # >= operator elif code.value == "ge": return \_compile\_to\_assembly( IRnode.from\_list(["iszero", ["lt", code.args[0], code.args[1]]]), withargs, existing\_labels, break\_dest, height, ) # <= operator elif code.value == "sle": return \_compile\_to\_assembly( IRnode.from\_list(["iszero", ["sgt", code.args[0], code.args[1]]]), withargs, existing\_labels, break\_dest, height, ) # >= operator elif code.value == "sge": return \_compile\_to\_assembly( IRnode.from\_list(["iszero", ["slt", code.args[0], code.args[1]]]), withargs, existing\_labels, break\_dest, height, ) # != operator elif code.value == "ne": return \_compile\_to\_assembly( IRnode.from\_list(["iszero", ["eq", code.args[0], code.args[1]]]), withargs, existing\_labels, break\_dest, height, )
 # e.g. 95 -> 96, 96 -> 96, 97 -> 128 elif code.value == "ceil32": # floor32(x) = x - x % 32 == x & 0b11..100000 == x & (~31) # ceil32(x) = floor32(x + 31) == (x + 31) & (~31) x = code.args[0] return \_compile\_to\_assembly( IRnode.from\_list(["and", ["add", x, 31], ["not", 31]]), withargs, existing\_labels, break\_dest, height, )
 elif code.value == "data": data\_node = [DataHeader("\_sym\_" + code.args[0].value)]
 for c in code.args[1:]: if isinstance(c.value, int): assert 0 <= c < 256, f"invalid data byte {c}" data\_node.append(c.value) elif isinstance(c.value, bytes): data\_node.append(c.value) elif isinstance(c, IRnode): assert c.value == "symbol" data\_node.extend( \_compile\_to\_assembly(c, withargs, existing\_labels, break\_dest, height) ) else: raise ValueError(f"Invalid data: {type(c)} {c}")
 # intentionally return a sublist. return [data\_node]
 # jump to a symbol, and push variable # of arguments onto stack elif code.value == "goto": o = [] for i, c in enumerate(reversed(code.args[1:])): o.extend(\_compile\_to\_assembly(c, withargs, existing\_labels, break\_dest, height + i)) o.extend(["\_sym\_" + code.args[0].value, "JUMP"]) return o elif code.value == "djump": o = [] # "djump" compiles to a raw EVM jump instruction jump\_target = code.args[0] o.extend(\_compile\_to\_assembly(jump\_target, withargs, existing\_labels, break\_dest, height)) o.append("JUMP") return o # push a literal symbol elif code.value == "symbol": return ["\_sym\_" + code.args[0].value] # set a symbol as a location. elif code.value == "label": label\_name = code.args[0].value assert isinstance(label\_name, str)
 if label\_name in existing\_labels: raise Exception(f"Label with name {label\_name} already exists!") else: existing\_labels.add(label\_name)
 if code.args[1].value != "var\_list": raise CodegenPanic("2nd arg to label must be var\_list") var\_args = code.args[1].args
 body = code.args[2]
 # new scope height = 0 withargs = {}
 for arg in reversed(var\_args): assert isinstance( arg.value, str ) # already checked for higher up but only the paranoid survive withargs[arg.value] = height height += 1
 body\_asm = \_compile\_to\_assembly( body, withargs=withargs, existing\_labels=existing\_labels, height=height ) # pop\_scoped\_vars = ["POP"] \* height # for now, \_rewrite\_return\_sequences forces # label params to be consumed implicitly pop\_scoped\_vars = []
 return ["\_sym\_" + label\_name, "JUMPDEST"] + body\_asm + pop\_scoped\_vars
 elif code.value == "unique\_symbol": symbol = code.args[0].value assert isinstance(symbol, str)
 if symbol in existing\_labels: raise Exception(f"symbol {symbol} already exists!") else: existing\_labels.add(symbol)
 return []
 elif code.value == "exit\_to": raise CodegenPanic("exit\_to not implemented yet!")
 # inject debug opcode. elif code.value == "debugger": return mkdebug(pc\_debugger=False, source\_pos=code.source\_pos) # inject debug opcode. elif code.value == "pc\_debugger": return mkdebug(pc\_debugger=True, source\_pos=code.source\_pos) else: # pragma: no cover raise ValueError(f"Weird code element: {type(code)} {code}")
def note\_line\_num(line\_number\_map, item, pos): # Record line number attached to pos. if isinstance(item, Instruction): if item.lineno is not None: offsets = (item.lineno, item.col\_offset, item.end\_lineno, item.end\_col\_offset) else: offsets = None
 line\_number\_map["pc\_pos\_map"][pos] = offsets
 if item.error\_msg is not None: line\_number\_map["error\_map"][pos] = item.error\_msg
 added\_line\_breakpoint = note\_breakpoint(line\_number\_map, item, pos) return added\_line\_breakpoint
def note\_breakpoint(line\_number\_map, item, pos): # Record line number attached to pos. if item == "DEBUG": # Is PC debugger, create PC breakpoint. if item.pc\_debugger: line\_number\_map["pc\_breakpoints"].add(pos) # Create line number breakpoint. else: line\_number\_map["breakpoints"].add(item.lineno + 1)
\_TERMINAL\_OPS = ("JUMP", "RETURN", "REVERT", "STOP", "INVALID")
def \_prune\_unreachable\_code(assembly): # delete code between terminal ops and JUMPDESTS as those are # unreachable changed = False i = 0 while i < len(assembly) - 2: instr = assembly[i] if isinstance(instr, list): instr = assembly[i][-1]
 if assembly[i] in \_TERMINAL\_OPS and not ( is\_symbol(assembly[i + 1]) or isinstance(assembly[i + 1], list) ): changed = True del assembly[i + 1] else: i += 1
 return changed
def \_prune\_inefficient\_jumps(assembly): # prune sequences `\_sym\_x JUMP \_sym\_x JUMPDEST` to `\_sym\_x JUMPDEST` changed = False i = 0 while i < len(assembly) - 4: if ( is\_symbol(assembly[i]) and assembly[i + 1] == "JUMP" and assembly[i] == assembly[i + 2] and assembly[i + 3] == "JUMPDEST" ): # delete \_sym\_x JUMP changed = True del assembly[i : i + 2] else: i += 1
 return changed
def \_optimize\_inefficient\_jumps(assembly): # optimize sequences `\_sym\_common JUMPI \_sym\_x JUMP \_sym\_common JUMPDEST` # to `ISZERO \_sym\_x JUMPI \_sym\_common JUMPDEST` changed = False i = 0 while i < len(assembly) - 6: if ( is\_symbol(assembly[i]) and assembly[i + 1] == "JUMPI" and is\_symbol(assembly[i + 2]) and assembly[i + 3] == "JUMP" and assembly[i] == assembly[i + 4] and assembly[i + 5] == "JUMPDEST" ): changed = True assembly[i] = "ISZERO" assembly[i + 1] = assembly[i + 2] assembly[i + 2] = "JUMPI" del assembly[i + 3 : i + 4] else: i += 1
 return changed
def \_merge\_jumpdests(assembly): # When we have multiple JUMPDESTs in a row, or when a JUMPDEST # is immediately followed by another JUMP, we can skip the # intermediate jumps. # (Usually a chain of JUMPs is created by a nested block, # or some nested if statements.) changed = False i = 0 while i < len(assembly) - 3: if is\_symbol(assembly[i]) and assembly[i + 1] == "JUMPDEST": current\_symbol = assembly[i] if is\_symbol(assembly[i + 2]) and assembly[i + 3] == "JUMPDEST": # \_sym\_x JUMPDEST \_sym\_y JUMPDEST # replace all instances of \_sym\_x with \_sym\_y # (except for \_sym\_x JUMPDEST - don't want duplicate labels) new\_symbol = assembly[i + 2] for j in range(len(assembly)): if assembly[j] == current\_symbol and i != j: assembly[j] = new\_symbol changed = True elif is\_symbol(assembly[i + 2]) and assembly[i + 3] == "JUMP": # \_sym\_x JUMPDEST \_sym\_y JUMP # replace all instances of \_sym\_x with \_sym\_y # (except for \_sym\_x JUMPDEST - don't want duplicate labels) new\_symbol = assembly[i + 2] for j in range(len(assembly)): if assembly[j] == current\_symbol and i != j: assembly[j] = new\_symbol changed = True
 i += 1
 return changed
\_RETURNS\_ZERO\_OR\_ONE = { "LT", "GT", "SLT", "SGT", "EQ", "ISZERO", "CALL", "STATICCALL", "CALLCODE", "DELEGATECALL",}
def \_merge\_iszero(assembly): changed = False
 i = 0 # list of opcodes that return 0 or 1 while i < len(assembly) - 2: if ( isinstance(assembly[i], str) and assembly[i] in \_RETURNS\_ZERO\_OR\_ONE and assembly[i + 1 : i + 3] == ["ISZERO", "ISZERO"] ): changed = True # drop the extra iszeros del assembly[i + 1 : i + 3] else: i += 1 i = 0 while i < len(assembly) - 3: # ISZERO ISZERO could map truthy to 1, # but it could also just be a no-op before JUMPI. if ( assembly[i : i + 2] == ["ISZERO", "ISZERO"] and is\_symbol(assembly[i + 2]) and assembly[i + 3] == "JUMPI" ): changed = True del assembly[i : i + 2] else: i += 1
 return changed
# a symbol \_sym\_x in assembly can either mean to push \_sym\_x to the stack,# or it can precede a location in code which we want to add to symbol map.# this helper function tells us if we want to add the previous instruction# to the symbol map.def is\_symbol\_map\_indicator(asm\_node): return asm\_node == "JUMPDEST"
def \_prune\_unused\_jumpdests(assembly): changed = False
 used\_jumpdests = set()
 # find all used jumpdests for i in range(len(assembly) - 1): if is\_symbol(assembly[i]) and not is\_symbol\_map\_indicator(assembly[i + 1]): used\_jumpdests.add(assembly[i])
 for item in assembly: if isinstance(item, list) and isinstance(item[0], DataHeader): # add symbols used in data sections as they are likely # used for a jumptable. for t in item: if is\_symbol(t): used\_jumpdests.add(t)
 # delete jumpdests that aren't used i = 0 while i < len(assembly) - 2: if is\_symbol(assembly[i]) and assembly[i] not in used\_jumpdests: changed = True del assembly[i : i + 2] else: i += 1
 return changed
def \_stack\_peephole\_opts(assembly): changed = False i = 0 while i < len(assembly) - 2: if assembly[i : i + 3] == ["DUP1", "SWAP2", "SWAP1"]: changed = True del assembly[i + 2] assembly[i] = "SWAP1"[View remainder of file in raw view](https://github.com/vyperlang/vyper/raw/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_bdf7582c_20250111_075457.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fsecurity%2Fadvisories%2FGHSA-6845-xw22-ffxv)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fsecurity%2Fadvisories%2FGHSA-6845-xw22-ffxv)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Frepos%2Fadvisories%2Fshow&source=header-repo&source_repo=vyperlang%2Fvyper)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[vyperlang](/vyperlang)
/
**[vyper](/vyperlang/vyper)**
Public

* [Notifications](/login?return_to=%2Fvyperlang%2Fvyper) You must be signed in to change notification settings
* [Fork
  815](/login?return_to=%2Fvyperlang%2Fvyper)
* [Star
   4.9k](/login?return_to=%2Fvyperlang%2Fvyper)

* [Code](/vyperlang/vyper)
* [Issues
  413](/vyperlang/vyper/issues)
* [Pull requests
  84](/vyperlang/vyper/pulls)
* [Discussions](/vyperlang/vyper/discussions)
* [Actions](/vyperlang/vyper/actions)
* [Projects
  0](/vyperlang/vyper/projects)
* [Wiki](/vyperlang/vyper/wiki)
* [Security](/vyperlang/vyper/security)
* [Insights](/vyperlang/vyper/pulse)

Additional navigation options

* [Code](/vyperlang/vyper)
* [Issues](/vyperlang/vyper/issues)
* [Pull requests](/vyperlang/vyper/pulls)
* [Discussions](/vyperlang/vyper/discussions)
* [Actions](/vyperlang/vyper/actions)
* [Projects](/vyperlang/vyper/projects)
* [Wiki](/vyperlang/vyper/wiki)
* [Security](/vyperlang/vyper/security)
* [Insights](/vyperlang/vyper/pulse)

# sha3 codegen bug

Low

[charles-cooper](/charles-cooper)
published
GHSA-6845-xw22-ffxv
Feb 5, 2024

## Package

pip

vyper
([pip](/advisories?query=ecosystem%3Apip))

## Affected versions

<=0.3.10

## Patched versions

0.4.0

## Description

### Summary

There is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.

The vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).

### Details

To compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:

[vyper/vyper/ir/compile\_ir.py](https://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586)

Lines 585 to 586
in
[c150fc4](/vyperlang/vyper/commit/c150fc49ee9375a930d177044559b83cb95f7963)

|  | o = \_compile\_to\_assembly(code.args[0], withargs, existing\_labels, break\_dest, height) |
| --- | --- |
|  | o.extend(\_compile\_to\_assembly(code.args[1], withargs, existing\_labels, break\_dest, height)) |

As can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.

`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.

### PoC

Suppose the following hand-written IR:

```
(with _loc
	(with val 1
		(with key 2
			(sha3_64 val key)))
				(seq
					(sstore _loc
					(with x (sload _loc)
						(with ans (add x 1) (seq (assert (ge ans x)) ans))))))
```

after compilation:

```
the generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd

0000    60  PUSH1 0x01
0002    60  PUSH1 0x02
0004    81  DUP2
0005    80  DUP1       *********** bad code here!!!!!!
0006    60  PUSH1 0x20
0008    52  MSTORE

```

It can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.

### Patches

Patched in [#4063](https://github.com/vyperlang/vyper/pull/4063).

### Impact

Versions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.

### Severity

Low

### CVE ID

CVE-2024-24559

### Weaknesses

No CWEs

### Credits

* [![@cyberthirst](https://avatars.githubusercontent.com/u/16179769?s=40&v=4)](/cyberthirst)
  [cyberthirst](/cyberthirst)
  Coordinator
* [![@kuroi8](https://avatars.githubusercontent.com/u/146698017?s=40&v=4)](/kuroi8)
  [kuroi8](/kuroi8)
  Reporter

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


