```
{
  "vulnerability": {
    "root_cause": "A race condition exists in the fastrpc driver when handling map references. Specifically, between the call to `fastrpc_map_get()` and the acquisition of the `map->fl->lock` in `fastrpc_free_map()`, another thread could call `fastrpc_map_lookup()` and obtain a reference to a map that is in the process of being deleted. This can lead to use-after-free issues.",
    "weaknesses": [
      "Use-after-free",
      "Race condition"
    ],
    "impact": "A use-after-free vulnerability can lead to system crashes, denial of service, or potentially arbitrary code execution.",
    "attack_vectors": "A local attacker with the ability to create/use fastrpc maps could trigger the race condition by racing calls to map get/lookup and map free.",
    "required_capabilities": "Local access to the system with the ability to interact with fastrpc device driver."
  },
  "resolution": "The fix modifies `fastrpc_map_get()` to only increment the reference count if the map's reference count is non-zero. This is achieved by using `kref_get_unless_zero()`, and the return value is propagated to callers to indicate if the map is about to be deleted."
}
```