
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fhnsecurity%2Fvulns%2Fblob%2Fmain%2FHNS-2024-05-rt-thread.txt)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fhnsecurity%2Fvulns%2Fblob%2Fmain%2FHNS-2024-05-rt-thread.txt)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=hnsecurity%2Fvulns)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[hnsecurity](/hnsecurity)
/
**[vulns](/hnsecurity/vulns)**
Public

* [Notifications](/login?return_to=%2Fhnsecurity%2Fvulns) You must be signed in to change notification settings
* [Fork
  2](/login?return_to=%2Fhnsecurity%2Fvulns)
* [Star
   21](/login?return_to=%2Fhnsecurity%2Fvulns)

* [Code](/hnsecurity/vulns)
* [Issues
  0](/hnsecurity/vulns/issues)
* [Pull requests
  0](/hnsecurity/vulns/pulls)
* [Actions](/hnsecurity/vulns/actions)
* [Projects
  0](/hnsecurity/vulns/projects)
* [Security](/hnsecurity/vulns/security)
* [Insights](/hnsecurity/vulns/pulse)

Additional navigation options

* [Code](/hnsecurity/vulns)
* [Issues](/hnsecurity/vulns/issues)
* [Pull requests](/hnsecurity/vulns/pulls)
* [Actions](/hnsecurity/vulns/actions)
* [Projects](/hnsecurity/vulns/projects)
* [Security](/hnsecurity/vulns/security)
* [Insights](/hnsecurity/vulns/pulse)

## Files

 main
## Breadcrumbs

1. [vulns](/hnsecurity/vulns/tree/main)
/
# HNS-2024-05-rt-thread.txt

 Blame  Blame
## Latest commit

## History

[History](/hnsecurity/vulns/commits/main/HNS-2024-05-rt-thread.txt)1117 lines (924 loc) · 35.2 KB main
## Breadcrumbs

1. [vulns](/hnsecurity/vulns/tree/main)
/
# HNS-2024-05-rt-thread.txt

Top
## File metadata and controls

* Code
* Blame

1117 lines (924 loc) · 35.2 KB[Raw](https://github.com/hnsecurity/vulns/raw/refs/heads/main/HNS-2024-05-rt-thread.txt)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000--[ HNS-2024-05 - HN Security Advisory - https://security.humanativaspa.it/
\* Title: Multiple vulnerabilities in RT-Thread RTOS\* OS: RT-Thread <= 5.0.2\* Author: Marco Ivaldi <marco.ivaldi@hnsecurity.it>\* Date: 2024-03-05\* CVE IDs and advisory URLs: \* CVE-2024-24334 - https://github.com/RT-Thread/rt-thread/issues/8282 \* CVE-2024-24335 - https://github.com/RT-Thread/rt-thread/issues/8271 \* CVE-2024-25388 - https://github.com/RT-Thread/rt-thread/issues/8285 \* CVE-2024-25389 - https://github.com/RT-Thread/rt-thread/issues/8283 \* CVE-2024-25390 - https://github.com/RT-Thread/rt-thread/issues/8286 \* CVE-2024-25391 - https://github.com/RT-Thread/rt-thread/issues/8287 \* CVE-2024-25392 - https://github.com/RT-Thread/rt-thread/issues/8290 \* CVE-2024-25393 - https://github.com/RT-Thread/rt-thread/issues/8288 \* CVE-2024-25394 - https://github.com/RT-Thread/rt-thread/issues/8291 \* CVE-2024-25395 - https://github.com/RT-Thread/rt-thread/issues/8289 \* https://github.com/RT-Thread/rt-thread/issues/8292\* Vendor URL: https://www.rt-thread.io/
--[ 0 - Table of contents
1 - Summary2 - Background3 - Vulnerabilities 3.1 - CVE-2024-24335 - Buffer overflow in RT-Thread dfs\_v2 romfs filesystem 3.2 - CVE-2024-24334 - Heap buffer overflows in RT-Thread dfs\_v2 dfs\_file 3.3 - CVE-2024-25389 - Weak random source in RT-Thread rt\_random driver 3.4 - CVE-2024-25388 - Heap buffer overflow in RT-Thread wlan driver 3.5 - CVE-2024-25390 - Heap buffer overflows in RT-Thread finsh 3.6 - CVE-2024-25391 - Stack buffer overflow in RT-Thread IPC 3.7 - CVE-2024-25393 - Stack buffer overflow in RT-Thread AT server 3.8 - CVE-2024-25395 - Static buffer overflow in RT-Thread rt-link utility 3.9 - CVE-2024-25392 - Out-of-bounds static array access in RT-Thread var\_export utility 3.10 - CVE-2024-25394 - Multiple vulnerabilities in RT-Thread ymodem utility 3.11 - Use of outdated lwIP and TinyDir dependencies in RT-Thread4 - Affected products5 - Remediation6 - Disclosure timeline7 - Acknowledgments8 - References
--[ 1 - Summary
"Security is in the mind of the programmer and in the mind of the designer.Not so much in the code."  -- Alisa Esage
RT-Thread [1] is an open-source, community-based real-time operating system(RTOS). RT-Thread can be used in sensing nodes, wireless connection chips,and many other resource-constrained scenarios. It is also widely applied ingateways, IPC, smart speakers, and other high-performance IoT applications.
We reviewed RT-Thread's source code hosted on GitHub [2] and identifiedmultiple security vulnerabilities that may cause memory corruption andsecurity feature bypass. Their impacts range from denial of service topotential arbitrary code execution.
We also audited the lwIP [3] and TinyDir [4] codebases on which someRT-Thread functionalities depend, and found some additional vulnerabilitiesthat were subsequently fixed by the respective maintainers.
--[ 2 - Background
After our recent vulnerability disclosures [5] in the IoT space, we decidedto keep assisting open-source projects in finding and fixing securityvulnerabilities by reviewing their source code. RT-Thread was selected as atarget of interest. Other RTOSes will be featured in future advisories andwriteups.
During this review, we made use of our Semgrep C/C++ ruleset [6] toidentify hotspots in code on which to focus our attention. We also tookadvantage of this opportunity to improve and update the ruleset [7].
--[ 3 - Vulnerabilities
The vulnerabilities resulting from our source code review are brieflydescribed in the following sections.
--[ 3.1 - CVE-2024-24335 - Buffer overflow in RT-Thread dfs\_v2 romfs filesystem
We spotted a buffer overflow vulnerability at the following location in theRT-Thread dfs\_v2 romfs filesystem source code:
\* /components/dfs/dfs\_v2/filesystems/romfs/dfs\_romfs.c
Lack of length check in the `dfs\_romfs\_getdents()` function could lead to abuffer overflow at the marked line:```cstatic int dfs\_romfs\_getdents(struct dfs\_file \*file, struct dirent \*dirp, uint32\_t count){ rt\_size\_t index; const char \*name; struct dirent \*d; struct romfs\_dirent \*dirent, \*sub\_dirent;
 dirent = (struct romfs\_dirent \*)file->vnode->data; if (check\_dirent(dirent) != 0) { return -EIO; } RT\_ASSERT(dirent->type == ROMFS\_DIRENT\_DIR);
 /\* enter directory \*/ dirent = (struct romfs\_dirent \*)dirent->data;
 /\* make integer count \*/ count = (count / sizeof(struct dirent)); if (count == 0) { return -EINVAL; }
 index = 0; for (index = 0; index < count && file->fpos < file->vnode->size; index++) { d = dirp + index;
 sub\_dirent = &dirent[file->fpos]; name = sub\_dirent->name;
 /\* fill dirent \*/ if (sub\_dirent->type == ROMFS\_DIRENT\_DIR) d->d\_type = DT\_DIR; else d->d\_type = DT\_REG;
 d->d\_namlen = rt\_strlen(name); d->d\_reclen = (rt\_uint16\_t)sizeof(struct dirent); rt\_strncpy(d->d\_name, name, rt\_strlen(name) + 1); /\* VULN: buffer overflow if rt\_strlen(name) is larger than sizeof(d->d\_name) due to missing length check \*/
 /\* move to next position \*/ ++ file->fpos; }
 return index \* sizeof(struct dirent);}```
Note: dfs\_v1 romfs in /components/dfs/dfs\_v1/filesystems/romfs/dfs\_romfs.cis not affected, because the string copy operation is implementeddifferently:```c len = rt\_strlen(name); RT\_ASSERT(len <= RT\_UINT8\_MAX); d->d\_namlen = (rt\_uint8\_t)len; d->d\_reclen = (rt\_uint16\_t)sizeof(struct dirent); rt\_strncpy(d->d\_name, name, DFS\_PATH\_MAX);```
Even if the assertion is compiled-out in production code, `len` is not usedfor the copy operation anyway. Therefore, unless `DFS\_PATH\_MAX` is largerthan `sizeof(d->d\_name)`, this code should be safe.
Fixes:https://github.com/RT-Thread/rt-thread/pull/8278
See also:https://github.com/RT-Thread/rt-thread/issues/8271
--[ 3.2 - CVE-2024-24334 - Heap buffer overflows in RT-Thread dfs\_v2 dfs\_file
We spotted some heap buffer overflow vulnerabilities at the followinglocation in the RT-Thread dfs\_v2 dfs\_file source code:
\* /components/dfs/dfs\_v2/src/dfs\_file.c
Lack of length check in the the `dfs\_nolink\_path()` function could lead toheap buffer overflows at the marked lines:```cstatic char \*dfs\_nolink\_path(struct dfs\_mnt \*\*mnt, char \*fullpath, int mode){ int index = 0; char \*path = RT\_NULL; char link\_fn[DFS\_PATH\_MAX] = {0}; struct dfs\_dentry \*dentry = RT\_NULL;
 path = (char \*)rt\_malloc((DFS\_PATH\_MAX \* 2) + 1); // path + syslink + \0 if (!path) { return path; }
 if (\*mnt && fullpath) { int i = 0; char \*fp = fullpath;
 while (\*fp != '\0') { fp++; i++; if (\*fp == '/') { rt\_memcpy(path + index, fp - i, i); /\* VULN: if fullpath has components large enough so that i+index becomes larger than DFS\_PATH\_MAX\*2+1, we could overflow past the path buffer \*/ path[index + i] = '\0';
 dentry = dfs\_dentry\_lookup(\*mnt, path, 0); if (dentry && dentry->vnode->type == FT\_SYMLINK) { int ret = -1;
 if ((\*mnt)->fs\_ops->readlink) { if (dfs\_is\_mounted((\*mnt)) == 0) { ret = (\*mnt)->fs\_ops->readlink(dentry, link\_fn, DFS\_PATH\_MAX); } }
 if (ret > 0) { int len = rt\_strlen(link\_fn); if (link\_fn[0] == '/') { rt\_memcpy(path, link\_fn, len); index = len; } else { path[index] = '/'; index++; rt\_memcpy(path + index, link\_fn, len); /\* VULN: len can be DFS\_PATH\_MAX; if index can become larger than DFS\_PATH\_MAX+1, we can overflow past the path buffer \*/ index += len; } path[index] = '\0'; \*mnt = dfs\_mnt\_lookup(path); } else { rt\_kprintf("link error: %s\n", path); } } else { index += i; } dfs\_dentry\_unref(dentry); i = 0; } }
 if (i) { rt\_memcpy(path + index, fp - i, i); /\* VULN: if fullpath has components large enough so that i+index becomes larger than DFS\_PATH\_MAX\*2+1, we could overflow past the path buffer \*/ path[index + i] = '\0';
 if (mode) { dentry = dfs\_dentry\_lookup(\*mnt, path, 0); if (dentry && dentry->vnode->type == FT\_SYMLINK) { int ret = -1;
 if ((\*mnt)->fs\_ops->readlink) { if (dfs\_is\_mounted((\*mnt)) == 0) { ret = (\*mnt)->fs\_ops->readlink(dentry, link\_fn, DFS\_PATH\_MAX); } }
 if (ret > 0) { int len = rt\_strlen(link\_fn); if (link\_fn[0] == '/') { rt\_memcpy(path, link\_fn, len); index = len; } else { path[index] = '/'; index++; rt\_memcpy(path + index, link\_fn, len); /\* VULN: len can be DFS\_PATH\_MAX; if index can become larger than DFS\_PATH\_MAX+1, we can overflow past the path buffer \*/ index += len; } path[index] = '\0'; \*mnt = dfs\_mnt\_lookup(path); } else { rt\_kprintf("link error: %s\n", path); }
 char \*\_fullpath = dfs\_normalize\_path(RT\_NULL, path); if (\_fullpath) { strncpy(path, \_fullpath, DFS\_PATH\_MAX); rt\_free(\_fullpath); } } dfs\_dentry\_unref(dentry); } } } else { rt\_free(path); path = RT\_NULL; }
 //rt\_kprintf("%s: %s => %s\n", \_\_FUNCTION\_\_, fullpath, path);
 return path;}```
Fixes:https://github.com/RT-Thread/rt-thread/pull/8305
See also:https://github.com/RT-Thread/rt-thread/issues/8282
--[ 3.3 - CVE-2024-25389 - Weak random source in RT-Thread rt\_random driver
We noticed a weak random source at the following location in the RT-Threadrt\_random driver source code:
\* /components/drivers/misc/rt\_random.c
Weak random generator in the the `calc\_random()` function:```cstatic rt\_uint16\_t calc\_random(void){ seed = 214013L \* seed + 2531011L; return (seed >> 16) & 0x7FFF; /\* return bits 16~30 \*/}
static rt\_ssize\_t random\_read(rt\_device\_t dev, rt\_off\_t pos, void \*buffer, rt\_size\_t size){ rt\_uint16\_t rand = calc\_random(); /\* VULN: weak random source \*/ ssize\_t ret = sizeof(rand); rt\_memcpy(buffer, &rand, ret); return ret;}```
See also:https://github.com/RT-Thread/rt-thread/issues/8283
--[ 3.4 - CVE-2024-25388 - Heap buffer overflow in RT-Thread wlan driver
We spotted a heap buffer overflow vulnerability at the following locationin the RT-Thread wlan driver source code:
\* /components/drivers/wlan/wlan\_mgnt.c
Since `len` is a signed integer in the `rt\_wlan\_send\_to\_thread()` function,a small negative value could lead to a buffer overflow at the marked lines:```c#ifdef RT\_WLAN\_WORK\_THREAD\_ENABLE...static rt\_err\_t rt\_wlan\_send\_to\_thread(rt\_wlan\_event\_t event, void \*buff, int len){ struct rt\_wlan\_msg \*msg;
 RT\_WLAN\_LOG\_D("F:%s is run event:%d", \_\_FUNCTION\_\_, event);
 /\* Event packing \*/ msg = rt\_malloc(sizeof(struct rt\_wlan\_msg) + len); /\* VULN: if len is a small negative number, this would result in an under-allocation \*/ if (msg == RT\_NULL) { RT\_WLAN\_LOG\_E("wlan mgnt send msg err! No memory"); return -RT\_ENOMEM; } rt\_memset(msg, 0, sizeof(struct rt\_wlan\_msg) + len); msg->event = event; if (len != 0) { msg->buff = (void \*)&msg[1]; rt\_memcpy(msg->buff, buff, len); /\* VULN: the small negative number would become a large unsigned size, and we would have a wild memcpy and a heap buffer overflow \*/ msg->len = len; }
 /\* send event to wlan thread \*/ if (rt\_wlan\_workqueue\_dowork(rt\_wlan\_mgnt\_work, msg) != RT\_EOK) { rt\_free(msg); RT\_WLAN\_LOG\_E("wlan mgnt do work fail"); return -RT\_ERROR; } return RT\_EOK;}```
See also:https://github.com/RT-Thread/rt-thread/issues/8285
--[ 3.5 - CVE-2024-25390 - Heap buffer overflows in RT-Thread finsh
We spotted some heap buffer overflow vulnerabilities at the followinglocations in the RT-Thread finsh source code:
\* /components/finsh/msh\_file.c\* /components/finsh/msh.c
Unbounded `rt\_sprintf()` in the `directory\_delete\_for\_msh()` function couldlead to a heap buffer overflow at the marked line:```cstatic void directory\_delete\_for\_msh(const char \*pathname, char f, char v){ DIR \*dir = NULL; struct dirent \*dirent = NULL; char \*full\_path;
 if (pathname == RT\_NULL) return;
 full\_path = (char \*)rt\_malloc(DFS\_PATH\_MAX); if (full\_path == RT\_NULL) return;
 dir = opendir(pathname); if (dir == RT\_NULL) { if (f == 0) { rt\_kprintf("cannot remove '%s'\n", pathname); } rt\_free(full\_path); return; }
 while (1) { dirent = readdir(dir); if (dirent == RT\_NULL) break; if (rt\_strcmp(".", dirent->d\_name) != 0 && rt\_strcmp("..", dirent->d\_name) != 0) { rt\_sprintf(full\_path, "%s/%s", pathname, dirent->d\_name); /\* VULN: full\_path is DFS\_PATH\_MAX bytes (only 256 bytes), potentially not enough to accommodate pathname + dirent->d\_name \*/ if (dirent->d\_type != DT\_DIR) { if (unlink(full\_path) != 0) { if (f == 0) rt\_kprintf("cannot remove '%s'\n", full\_path); } else if (v) { rt\_kprintf("removed '%s'\n", full\_path); } } else { directory\_delete\_for\_msh(full\_path, f, v); } } } closedir(dir); rt\_free(full\_path); if (rmdir(pathname) != 0) { if (f == 0) rt\_kprintf("cannot remove '%s'\n", pathname); } else if (v) { rt\_kprintf("removed directory '%s'\n", pathname); }}```
Unbounded `rt\_sprintf()` in the `directory\_setattr()` function could leadto a heap buffer overflow at the marked line:```cstatic void directory\_setattr(const char \*pathname, struct dfs\_attr \*attr, char f, char v){ DIR \*dir = NULL; struct dirent \*dirent = NULL; char \*full\_path;
 if (pathname == RT\_NULL) return;
 full\_path = (char \*)rt\_malloc(DFS\_PATH\_MAX); if (full\_path == RT\_NULL) return;
 dir = opendir(pathname); if (dir == RT\_NULL) { if (f == 0) { rt\_kprintf("cannot open '%s'\n", pathname); } rt\_free(full\_path); return; }
 while (1) { dirent = readdir(dir); if (dirent == RT\_NULL) break; if (rt\_strcmp(".", dirent->d\_name) != 0 && rt\_strcmp("..", dirent->d\_name) != 0) { rt\_sprintf(full\_path, "%s/%s", pathname, dirent->d\_name); /\* VULN: full\_path is DFS\_PATH\_MAX bytes (only 256 bytes), potentially not enough to accommodate pathname + dirent->d\_name \*/ if (dirent->d\_type == DT\_REG) { if (dfs\_file\_setattr(full\_path, attr) != 0) { if (f == 0) { rt\_kprintf("'%s' setattr failed, no such file or directory\n", full\_path); } } else if (v) { rt\_kprintf("'%s' setattr 0x%X\n", full\_path, attr->st\_mode); } } else if (dirent->d\_type == DT\_DIR) { directory\_setattr(full\_path, attr, f, v); } } } closedir(dir); rt\_free(full\_path); if (dfs\_file\_setattr(pathname, attr) != 0) { if (f == 0) { rt\_kprintf("'%s' setattr failed, no such file or directory\n", pathname); } } else if (v) { rt\_kprintf("'%s' setattr 0x%X\n", pathname, attr->st\_mode); }}```
Unbounded `strcpy()` in the `msh\_auto\_complete\_path()` function could leadto a heap buffer overflow at the marked line:```c#ifdef DFS\_USING\_POSIXvoid msh\_auto\_complete\_path(char \*path){ DIR \*dir = RT\_NULL; struct dirent \*dirent = RT\_NULL; char \*full\_path, \*ptr, \*index;
 if (!path) return;
 full\_path = (char \*)rt\_malloc(256); if (full\_path == RT\_NULL) return; /\* out of memory \*/
 if (\*path != '/') { getcwd(full\_path, 256); if (full\_path[rt\_strlen(full\_path) - 1] != '/') strcat(full\_path, "/"); } else \*full\_path = '\0';
 index = RT\_NULL; ptr = path; for (;;) { if (\*ptr == '/') index = ptr + 1; if (!\*ptr) break;
 ptr ++; } if (index == RT\_NULL) index = path;
 if (index != RT\_NULL) { char \*dest = index;
 /\* fill the parent path \*/ ptr = full\_path; while (\*ptr) ptr ++;
 for (index = path; index != dest;) \*ptr++ = \*index++; \*ptr = '\0';
 dir = opendir(full\_path); if (dir == RT\_NULL) /\* open directory failed! \*/ { rt\_free(full\_path); return; }
 /\* restore the index position \*/ index = dest; }
 /\* auto complete the file or directory name \*/ if (\*index == '\0') /\* display all of files and directories \*/ { for (;;) { dirent = readdir(dir); if (dirent == RT\_NULL) break;
 rt\_kprintf("%s\n", dirent->d\_name); } } else { int multi = 0; rt\_size\_t length, min\_length;
 min\_length = 0; for (;;) { dirent = readdir(dir); if (dirent == RT\_NULL) break;
 /\* matched the prefix string \*/ if (strncmp(index, dirent->d\_name, rt\_strlen(index)) == 0) { multi ++; if (min\_length == 0) { min\_length = rt\_strlen(dirent->d\_name); /\* save dirent name \*/ strcpy(full\_path, dirent->d\_name); /\* VULN: if sizeof(dirent->d\_name) > 256, we could overflow past the full\_path buffer \*/ }
 length = str\_common(dirent->d\_name, full\_path);
 if (length < min\_length) { min\_length = length; } } }
 if (min\_length) { if (multi > 1) { /\* list the candidate \*/ rewinddir(dir);
 for (;;) { dirent = readdir(dir); if (dirent == RT\_NULL) break;
 if (strncmp(index, dirent->d\_name, rt\_strlen(index)) == 0) rt\_kprintf("%s\n", dirent->d\_name); } }
 length = index - path; rt\_memcpy(index, full\_path, min\_length); path[length + min\_length] = '\0';
 /\* try to locate folder \*/ if (multi == 1) { struct stat buffer = {0}; if ((stat(path, &buffer) == 0)) { if (S\_ISDIR(buffer.st\_mode)) { strcat(path, "/"); } else if (S\_ISLNK(buffer.st\_mode)) { DIR \*dir = opendir(path); if (dir) { closedir(dir); strcat(path, "/"); } } } } } }
 closedir(dir); rt\_free(full\_path);}#endif /\* DFS\_USING\_POSIX \*/```
Fixes:https://github.com/RT-Thread/rt-thread/pull/8305
See also:https://github.com/RT-Thread/rt-thread/issues/8286
--[ 3.6 - CVE-2024-25391 - Stack buffer overflow in RT-Thread IPC
We spotted a stack buffer overflow vulnerability at the following locationin the RT-Thread IPC source code:
\* /components/libc/posix/ipc/mqueue.c
Unbounded `rt\_sprintf()` in the `mq\_unlink()` function could lead to astack buffer overflow at the marked line:```cint mq\_unlink(const char \*name){ if(\*name == '/') { name++; } const char \*mq\_path = "/dev/mqueue/"; char mq\_name[RT\_NAME\_MAX + 12] = {0}; rt\_sprintf(mq\_name, "%s%s", mq\_path, name); /\* VULN: stack buffer overflow \*/ return unlink(mq\_name);}```
Note: the mq\_open() function in /components/libc/posix/ipc/mqueue.cimplements bound checking:```c int len = rt\_strlen(name); if (len > RT\_NAME\_MAX) { rt\_set\_errno(ENAMETOOLONG); return (mqd\_t)(-1); }```
See also:https://github.com/RT-Thread/rt-thread/issues/8287
--[ 3.7 - CVE-2024-25393 - Stack buffer overflow in RT-Thread AT server
We spotted a stack buffer overflow vulnerability at the following locationin the RT-Thread AT server source code:
\* /components/net/at/src/at\_server.c
Lack of length check in the `at\_cmd\_get\_name()` function could lead to astack buffer overflow at the marked line:```c#ifdef AT\_USING\_SERVER...static rt\_err\_t at\_cmd\_get\_name(const char \*cmd\_buffer, char \*cmd\_name){ rt\_size\_t cmd\_name\_len = 0, i = 0;
 RT\_ASSERT(cmd\_name); RT\_ASSERT(cmd\_buffer);
 for (i = 0; i < strlen(cmd\_buffer); i++) { if (\*(cmd\_buffer + i) == AT\_CMD\_QUESTION\_MARK || \*(cmd\_buffer + i) == AT\_CMD\_EQUAL\_MARK || \*(cmd\_buffer + i) == AT\_CMD\_CR || (\*(cmd\_buffer + i) >= AT\_CMD\_CHAR\_0 && \*(cmd\_buffer + i) <= AT\_CMD\_CHAR\_9)) { cmd\_name\_len = i; rt\_memcpy(cmd\_name, cmd\_buffer, cmd\_name\_len); /\* VULN: cmd\_buffer is AT\_SERVER\_RECV\_BUFF\_LEN bytes (256), while cmd\_name is only AT\_CMD\_NAME\_LEN bytes (16); therefore, it might be possible to overflow past the cmd\_name buffer with a carefully crafted cmd\_buffer \*/ \*(cmd\_name + cmd\_name\_len) = '\0';
 return RT\_EOK; } }
 return -RT\_ERROR;}```
Fixes:https://github.com/RT-Thread/rt-thread/commit/a8d5a645f2e26af67c8fe94e2c7f1726ae05cca7
See also:https://github.com/RT-Thread/rt-thread/issues/8288
--[ 3.8 - CVE-2024-25395 - Static buffer overflow in RT-Thread rt-link utility
We spotted a static buffer overflow vulnerability at the following locationin the RT-Thread rt-link utility source code:
\* /components/utilities/rt-link/src/rtlink.c
Lack of length check in the `frame\_send()` function could lead to a staticbuffer overflow at the marked line:```cstatic rt\_ssize\_t frame\_send(struct rt\_link\_frame \*frame){ rt\_size\_t length = 0; rt\_uint8\_t \*data = RT\_NULL;
 rt\_memset(rt\_link\_scb->sendbuffer, 0, sizeof(rt\_link\_scb->sendbuffer)); data = rt\_link\_scb->sendbuffer; length = RT\_LINK\_HEAD\_LENGTH; if (frame->head.crc) { length += RT\_LINK\_CRC\_LENGTH; } if (frame->head.extend) { length += RT\_LINK\_EXTEND\_LENGTH; }
 length += frame->data\_len; frame->head.length = frame->data\_len; rt\_memcpy(data, &frame->head, RT\_LINK\_HEAD\_LENGTH); data = data + RT\_LINK\_HEAD\_LENGTH; if (frame->head.extend) { rt\_memcpy(data, &frame->extend, RT\_LINK\_EXTEND\_LENGTH); data = data + RT\_LINK\_EXTEND\_LENGTH; } if (frame->attribute == RT\_LINK\_SHORT\_DATA\_FRAME || frame->attribute == RT\_LINK\_LONG\_DATA\_FRAME) { rt\_memcpy(data, frame->real\_data, frame->data\_len); /\* VULN: static buffer overflow, if frame->data\_len > 1024 - 4 (it's a rt\_uint16\_t so at least in theory can be up to 65535) \*/ data = data + frame->data\_len; } if (frame->head.crc) { frame->crc = rt\_link\_scb->calculate\_crc(RT\_FALSE, rt\_link\_scb->sendbuffer, length - RT\_LINK\_CRC\_LENGTH); rt\_memcpy(data, &frame->crc, RT\_LINK\_CRC\_LENGTH); }
 LOG\_D("frame send seq(%d) len(%d) attr:(%d), crc:(0x%08x).", frame->head.sequence, length, frame->attribute, frame->crc); return rt\_link\_hw\_send(rt\_link\_scb->sendbuffer, length);}```
See also:https://github.com/RT-Thread/rt-thread/issues/8289
--[ 3.9 - CVE-2024-25392 - Out-of-bounds static array access in RT-Thread var\_export utility
We spotted a potential out-of-bounds static array access at the followinglocation in the RT-Thread var\_export utility source code:
\* /components/utilities/var\_export/var\_export.c
Improper size check due to the use of `RT\_ASSERT()` in the`var\_export\_init()` function at the marked line, which if compiled out inproduction code could lead to multiple out-of-bounds `ve\_exporter\_tab`static array accesses in the next lines:```cint var\_export\_init(void){ /\* initialize the var export table.\*/#if defined(\_\_ARMCC\_VERSION) /\* for ARM C Compiler \*/ ve\_exporter\_table = &\_\_ve\_table\_start + 1; ve\_exporter\_num = &\_\_ve\_table\_end - &\_\_ve\_table\_start;#elif defined (\_\_IAR\_SYSTEMS\_ICC\_\_) /\* for IAR Compiler \*/ ve\_exporter\_table = &\_\_ve\_table\_start + 1; ve\_exporter\_num = &\_\_ve\_table\_end - &\_\_ve\_table\_start - 1;#elif defined (\_\_GNUC\_\_) /\* for GCC Compiler \*/ extern const int \_\_ve\_table\_start; extern const int \_\_ve\_table\_end; ve\_exporter\_table = (const ve\_exporter\_t \*)&\_\_ve\_table\_start; ve\_exporter\_num = (const ve\_exporter\_t \*)&\_\_ve\_table\_end - ve\_exporter\_table;#elif defined (\_MSC\_VER) /\* for MS VC++ compiler \*/ unsigned int \*ptr\_begin = (unsigned int \*)&\_\_ve\_table\_start; unsigned int \*ptr\_end = (unsigned int \*)&\_\_ve\_table\_end; static ve\_exporter\_t ve\_exporter\_tab[2048]; static char \_\_vexp\_strbuf1[1024]; static char \_\_vexp\_strbuf2[1024]; ve\_exporter\_t ve\_exporter\_temp; rt\_size\_t index\_i, index\_j;
 /\* past the three members in first ptr\_begin \*/ ptr\_begin += (sizeof(struct ve\_exporter) / sizeof(unsigned int)); while (\*ptr\_begin == 0) ptr\_begin++; do ptr\_end--; while (\*ptr\_end == 0);
 /\* Find var objects in custom segments to solve the problem of holes in objects in different files \*/ ve\_exporter\_num = ve\_init\_find\_obj(ptr\_begin, ptr\_end, ve\_exporter\_tab);
 /\* check if the ve\_exporter\_num is out of bounds \*/ RT\_ASSERT(ve\_exporter\_num < (sizeof(ve\_exporter\_tab) / sizeof(ve\_exporter\_t))); /\* VULN: size check is implemented via assertion \*/
 /\* bubble sort algorithms \*/ for (index\_i = 0; index\_i < (ve\_exporter\_num - 1); index\_i++) { for (index\_j = 0; index\_j < ((ve\_exporter\_num - 1) - index\_i); index\_j++) { /\* splice ve\_exporter's module and ve\_exporter's identifier into a complete string \*/ rt\_snprintf(\_\_vexp\_strbuf1, sizeof(\_\_vexp\_strbuf1), "%s%s", ve\_exporter\_tab[index\_j].module, ve\_exporter\_tab[index\_j].identifier); rt\_snprintf(\_\_vexp\_strbuf2, sizeof(\_\_vexp\_strbuf2), "%s%s", ve\_exporter\_tab[index\_j + 1].module, ve\_exporter\_tab[index\_j + 1].identifier); if (rt\_strcmp(\_\_vexp\_strbuf1, \_\_vexp\_strbuf2) > 0) { ve\_exporter\_temp = ve\_exporter\_tab[index\_j]; ve\_exporter\_tab[index\_j] = ve\_exporter\_tab[index\_j + 1]; ve\_exporter\_tab[index\_j + 1] = ve\_exporter\_temp; } } }
 ve\_exporter\_table = ve\_exporter\_tab;#endif /\* \_\_ARMCC\_VERSION \*/
 return ve\_exporter\_num;}```
See also:https://github.com/RT-Thread/rt-thread/issues/8290
--[ 3.10 - CVE-2024-25394 - Multiple vulnerabilities in RT-Thread ymodem utility
We spotted some potential vulnerabilities at the following location in theRT-Thread ymodem utility source code:
\* /components/utilities/ymodem/ry\_sy.c
Unbounded `rt\_sprintf()` in the `\_rym\_send\_begin()` function could lead toa buffer overflow at the marked line:```cstatic enum rym\_code \_rym\_send\_begin( struct rym\_ctx \*ctx, rt\_uint8\_t \*buf, rt\_size\_t len){ struct custom\_ctx \*cctx = (struct custom\_ctx \*)ctx; struct stat file\_buf; char insert\_0 = '\0'; rt\_err\_t err;
 cctx->fd = open(cctx->fpath, O\_RDONLY); if (cctx->fd < 0) { err = rt\_get\_errno(); rt\_kprintf("error open file: %d\n", err); return RYM\_ERR\_FILE; } rt\_memset(buf, 0, len); err = stat(cctx->fpath, &file\_buf); if (err != RT\_EOK) { rt\_kprintf("error open file.\n"); return RYM\_ERR\_FILE; }
 const char \*fdst = \_get\_path\_lastname(cctx->fpath); if(fdst != cctx->fpath) { fdst = dfs\_normalize\_path(RT\_NULL, fdst); if (fdst == RT\_NULL) { return RYM\_ERR\_FILE; } }
 rt\_sprintf((char \*)buf, "%s%c%d", fdst, insert\_0, file\_buf.st\_size); /\* VULN: if we can make fdst large enough, there's no bound checking \*/
 return RYM\_CODE\_SOH;}```
Lack of NUL-termination in the `rym\_download\_file()` function at the markedline:```cstatic rt\_err\_t rym\_download\_file(rt\_device\_t idev,const char \*file\_path){ rt\_err\_t res; struct custom\_ctx \*ctx = rt\_calloc(1, sizeof(\*ctx));
 if (!ctx) { rt\_kprintf("rt\_malloc failed\n"); return -RT\_ENOMEM; } ctx->fd = -1; rt\_strncpy(ctx->fpath, file\_path, DFS\_PATH\_MAX); /\* VULN: unterm if file\_path is at least DFS\_PATH\_MAX bytes (comes from argv); it might cause infoleak or memory corruption \*/ RT\_ASSERT(idev); res = rym\_recv\_on\_device(&ctx->parent, idev, RT\_DEVICE\_OFLAG\_RDWR | RT\_DEVICE\_FLAG\_INT\_RX, \_rym\_recv\_begin, \_rym\_recv\_data, \_rym\_recv\_end, 1000); rt\_free(ctx);
 return res;}```
Lack of NUL-termination in the `rym\_upload\_file()` function at the marked line:[View remainder of file in raw view](https://github.com/hnsecurity/vulns/raw/refs/heads/main/HNS-2024-05-rt-thread.txt)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

