=== Content from git.kernel.org_95801692_20250111_075150.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=b4be6aefa73c9a6899ef3ba9c5faaa8a66e333ef)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=b4be6aefa73c9a6899ef3ba9c5faaa8a66e333ef)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b4be6aefa73c9a6899ef3ba9c5faaa8a66e333ef)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b4be6aefa73c9a6899ef3ba9c5faaa8a66e333ef)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Josef Bacik <josef@toxicpanda.com> | 2022-02-18 14:56:10 -0500 |
| --- | --- | --- |
| committer | David Sterba <dsterba@suse.com> | 2022-03-02 16:52:39 +0100 |
| commit | [b4be6aefa73c9a6899ef3ba9c5faaa8a66e333ef](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b4be6aefa73c9a6899ef3ba9c5faaa8a66e333ef) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=b4be6aefa73c9a6899ef3ba9c5faaa8a66e333ef)) | |
| tree | [cd7c504a41d9bb730ff7b208ef6f632c0ea4c220](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=b4be6aefa73c9a6899ef3ba9c5faaa8a66e333ef) | |
| parent | [a6ab66eb8541d61b0a11d70980f07b4c2dfeddc5](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a6ab66eb8541d61b0a11d70980f07b4c2dfeddc5) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b4be6aefa73c9a6899ef3ba9c5faaa8a66e333ef&id2=a6ab66eb8541d61b0a11d70980f07b4c2dfeddc5)) | |
| download | [linux-b4be6aefa73c9a6899ef3ba9c5faaa8a66e333ef.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-b4be6aefa73c9a6899ef3ba9c5faaa8a66e333ef.tar.gz) | |

btrfs: do not start relocation until in progress drops are doneWe hit a bug with a recovering relocation on mount for one of our file
systems in production. I reproduced this locally by injecting errors
into snapshot delete with balance running at the same time. This
presented as an error while looking up an extent item
WARNING: CPU: 5 PID: 1501 at fs/btrfs/extent-tree.c:866 lookup\_inline\_extent\_backref+0x647/0x680
CPU: 5 PID: 1501 Comm: btrfs-balance Not tainted 5.16.0-rc8+ #8
RIP: 0010:lookup\_inline\_extent\_backref+0x647/0x680
RSP: 0018:ffffae0a023ab960 EFLAGS: 00010202
RAX: 0000000000000001 RBX: 0000000000000000 RCX: 0000000000000000
RDX: 0000000000000000 RSI: 000000000000000c RDI: 0000000000000000
RBP: ffff943fd2a39b60 R08: 0000000000000000 R09: 0000000000000001
R10: 0001434088152de0 R11: 0000000000000000 R12: 0000000001d05000
R13: ffff943fd2a39b60 R14: ffff943fdb96f2a0 R15: ffff9442fc923000
FS: 0000000000000000(0000) GS:ffff944e9eb40000(0000) knlGS:0000000000000000
CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f1157b1fca8 CR3: 000000010f092000 CR4: 0000000000350ee0
Call Trace:
<TASK>
insert\_inline\_extent\_backref+0x46/0xd0
\_\_btrfs\_inc\_extent\_ref.isra.0+0x5f/0x200
? btrfs\_merge\_delayed\_refs+0x164/0x190
\_\_btrfs\_run\_delayed\_refs+0x561/0xfa0
? btrfs\_search\_slot+0x7b4/0xb30
? btrfs\_update\_root+0x1a9/0x2c0
btrfs\_run\_delayed\_refs+0x73/0x1f0
? btrfs\_update\_root+0x1a9/0x2c0
btrfs\_commit\_transaction+0x50/0xa50
? btrfs\_update\_reloc\_root+0x122/0x220
prepare\_to\_merge+0x29f/0x320
relocate\_block\_group+0x2b8/0x550
btrfs\_relocate\_block\_group+0x1a6/0x350
btrfs\_relocate\_chunk+0x27/0xe0
btrfs\_balance+0x777/0xe60
balance\_kthread+0x35/0x50
? btrfs\_balance+0xe60/0xe60
kthread+0x16b/0x190
? set\_kthread\_struct+0x40/0x40
ret\_from\_fork+0x22/0x30
</TASK>
Normally snapshot deletion and relocation are excluded from running at
the same time by the fs\_info->cleaner\_mutex. However if we had a
pending balance waiting to get the ->cleaner\_mutex, and a snapshot
deletion was running, and then the box crashed, we would come up in a
state where we have a half deleted snapshot.
Again, in the normal case the snapshot deletion needs to complete before
relocation can start, but in this case relocation could very well start
before the snapshot deletion completes, as we simply add the root to the
dead roots list and wait for the next time the cleaner runs to clean up
the snapshot.
Fix this by setting a bit on the fs\_info if we have any DEAD\_ROOT's that
had a pending drop\_progress key. If they do then we know we were in the
middle of the drop operation and set a flag on the fs\_info. Then
balance can wait until this flag is cleared to start up again.
If there are DEAD\_ROOT's that don't have a drop\_progress set then we're
safe to start balance right away as we'll be properly protected by the
cleaner\_mutex.
CC: stable@vger.kernel.org # 5.10+
Reviewed-by: Filipe Manana <fdmanana@suse.com>
Signed-off-by: Josef Bacik <josef@toxicpanda.com>
Reviewed-by: David Sterba <dsterba@suse.com>
Signed-off-by: David Sterba <dsterba@suse.com>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b4be6aefa73c9a6899ef3ba9c5faaa8a66e333ef)

| -rw-r--r-- | [fs/btrfs/ctree.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/ctree.h?id=b4be6aefa73c9a6899ef3ba9c5faaa8a66e333ef) | 10 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/btrfs/disk-io.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/disk-io.c?id=b4be6aefa73c9a6899ef3ba9c5faaa8a66e333ef) | 10 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/extent-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/extent-tree.c?id=b4be6aefa73c9a6899ef3ba9c5faaa8a66e333ef) | 10 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/relocation.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/relocation.c?id=b4be6aefa73c9a6899ef3ba9c5faaa8a66e333ef) | 13 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/root-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/root-tree.c?id=b4be6aefa73c9a6899ef3ba9c5faaa8a66e333ef) | 15 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/transaction.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/transaction.c?id=b4be6aefa73c9a6899ef3ba9c5faaa8a66e333ef) | 33 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/transaction.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/transaction.h?id=b4be6aefa73c9a6899ef3ba9c5faaa8a66e333ef) | 1 | |  |  |  | | --- | --- | --- | |

7 files changed, 91 insertions, 1 deletions

| diff --git a/fs/btrfs/ctree.h b/fs/btrfs/ctree.hindex 947f04789389e9..ebb2d109e8bb2c 100644--- a/[fs/btrfs/ctree.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/ctree.h?id=a6ab66eb8541d61b0a11d70980f07b4c2dfeddc5)+++ b/[fs/btrfs/ctree.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/ctree.h?id=b4be6aefa73c9a6899ef3ba9c5faaa8a66e333ef)@@ -602,6 +602,9 @@ enum { /\* Indicate that we want the transaction kthread to commit right now. \*/ BTRFS\_FS\_COMMIT\_TRANS, + /\* Indicate we have half completed snapshot deletions pending. \*/+ BTRFS\_FS\_UNFINISHED\_DROPS,+ #if BITS\_PER\_LONG == 32 /\* Indicate if we have error/warn message printed on 32bit systems \*/ BTRFS\_FS\_32BIT\_ERROR,@@ -1106,8 +1109,15 @@ enum { BTRFS\_ROOT\_QGROUP\_FLUSHING, /\* We started the orphan cleanup for this root. \*/ BTRFS\_ROOT\_ORPHAN\_CLEANUP,+ /\* This root has a drop operation that was started previously. \*/+ BTRFS\_ROOT\_UNFINISHED\_DROP, }; +static inline void btrfs\_wake\_unfinished\_drop(struct btrfs\_fs\_info \*fs\_info)+{+ clear\_and\_wake\_up\_bit(BTRFS\_FS\_UNFINISHED\_DROPS, &fs\_info->flags);+}+ /\* \* Record swapped tree blocks of a subvolume tree for delayed subtree trace \* code. For detail check comment in fs/btrfs/qgroup.c.diff --git a/fs/btrfs/disk-io.c b/fs/btrfs/disk-io.cindex 87a5addbedf6d5..48590a3807621a 100644--- a/[fs/btrfs/disk-io.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/disk-io.c?id=a6ab66eb8541d61b0a11d70980f07b4c2dfeddc5)+++ b/[fs/btrfs/disk-io.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/disk-io.c?id=b4be6aefa73c9a6899ef3ba9c5faaa8a66e333ef)@@ -3813,6 +3813,10 @@ int \_\_cold open\_ctree(struct super\_block \*sb, struct btrfs\_fs\_devices \*fs\_device  set\_bit(BTRFS\_FS\_OPEN, &fs\_info->flags); + /\* Kick the cleaner thread so it'll start deleting snapshots. \*/+ if (test\_bit(BTRFS\_FS\_UNFINISHED\_DROPS, &fs\_info->flags))+ wake\_up\_process(fs\_info->cleaner\_kthread);+ clear\_oneshot: btrfs\_clear\_oneshot\_options(fs\_info); return 0;@@ -4538,6 +4542,12 @@ void \_\_cold close\_ctree(struct btrfs\_fs\_info \*fs\_info) \*/ kthread\_park(fs\_info->cleaner\_kthread); + /\*+ \* If we had UNFINISHED\_DROPS we could still be processing them, so+ \* clear that bit and wake up relocation so it can stop.+ \*/+ btrfs\_wake\_unfinished\_drop(fs\_info);+ /\* wait for the qgroup rescan worker to stop \*/ btrfs\_qgroup\_wait\_for\_completion(fs\_info, false); diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.cindex d89273c4b6b86e..96427b1ecac3ea 100644--- a/[fs/btrfs/extent-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/extent-tree.c?id=a6ab66eb8541d61b0a11d70980f07b4c2dfeddc5)+++ b/[fs/btrfs/extent-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/extent-tree.c?id=b4be6aefa73c9a6899ef3ba9c5faaa8a66e333ef)@@ -5622,6 +5622,7 @@ int btrfs\_drop\_snapshot(struct btrfs\_root \*root, int update\_ref, int for\_reloc) int ret; int level; bool root\_dropped = false;+ bool unfinished\_drop = false;  btrfs\_debug(fs\_info, "Drop subvolume %llu", root->root\_key.objectid); @@ -5664,6 +5665,8 @@ int btrfs\_drop\_snapshot(struct btrfs\_root \*root, int update\_ref, int for\_reloc) \* already dropped. \*/ set\_bit(BTRFS\_ROOT\_DELETING, &root->state);+ unfinished\_drop = test\_bit(BTRFS\_ROOT\_UNFINISHED\_DROP, &root->state);+ if (btrfs\_disk\_key\_objectid(&root\_item->drop\_progress) == 0) { level = btrfs\_header\_level(root->node); path->nodes[level] = btrfs\_lock\_root\_node(root);@@ -5839,6 +5842,13 @@ out\_free: btrfs\_free\_path(path); out: /\*+ \* We were an unfinished drop root, check to see if there are any+ \* pending, and if not clear and wake up any waiters.+ \*/+ if (!err && unfinished\_drop)+ btrfs\_maybe\_wake\_unfinished\_drop(fs\_info);++ /\* \* So if we need to stop dropping the snapshot for whatever reason we \* need to make sure to add it back to the dead root list so that we \* keep trying to do the work later. This also cleans up roots if wediff --git a/fs/btrfs/relocation.c b/fs/btrfs/relocation.cindex f5465197996dec..9d8054839782e2 100644--- a/[fs/btrfs/relocation.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/relocation.c?id=a6ab66eb8541d61b0a11d70980f07b4c2dfeddc5)+++ b/[fs/btrfs/relocation.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/relocation.c?id=b4be6aefa73c9a6899ef3ba9c5faaa8a66e333ef)@@ -3960,6 +3960,19 @@ int btrfs\_relocate\_block\_group(struct btrfs\_fs\_info \*fs\_info, u64 group\_start) int rw = 0; int err = 0; + /\*+ \* This only gets set if we had a half-deleted snapshot on mount. We+ \* cannot allow relocation to start while we're still trying to clean up+ \* these pending deletions.+ \*/+ ret = wait\_on\_bit(&fs\_info->flags, BTRFS\_FS\_UNFINISHED\_DROPS, TASK\_INTERRUPTIBLE);+ if (ret)+ return ret;++ /\* We may have been woken up by close\_ctree, so bail if we're closing. \*/+ if (btrfs\_fs\_closing(fs\_info))+ return -EINTR;+ bg = btrfs\_lookup\_block\_group(fs\_info, group\_start); if (!bg) return -ENOENT;diff --git a/fs/btrfs/root-tree.c b/fs/btrfs/root-tree.cindex 3d68d2dcd83e3e..ca7426ef61c8a1 100644--- a/[fs/btrfs/root-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/root-tree.c?id=a6ab66eb8541d61b0a11d70980f07b4c2dfeddc5)+++ b/[fs/btrfs/root-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/root-tree.c?id=b4be6aefa73c9a6899ef3ba9c5faaa8a66e333ef)@@ -278,6 +278,21 @@ int btrfs\_find\_orphan\_roots(struct btrfs\_fs\_info \*fs\_info)  WARN\_ON(!test\_bit(BTRFS\_ROOT\_ORPHAN\_ITEM\_INSERTED, &root->state)); if (btrfs\_root\_refs(&root->root\_item) == 0) {+ struct btrfs\_key drop\_key;++ btrfs\_disk\_key\_to\_cpu(&drop\_key, &root->root\_item.drop\_progress);+ /\*+ \* If we have a non-zero drop\_progress then we know we+ \* made it partly through deleting this snapshot, and+ \* thus we need to make sure we block any balance from+ \* happening until this snapshot is completely dropped.+ \*/+ if (drop\_key.objectid != 0 || drop\_key.type != 0 ||+ drop\_key.offset != 0) {+ set\_bit(BTRFS\_FS\_UNFINISHED\_DROPS, &fs\_info->flags);+ set\_bit(BTRFS\_ROOT\_UNFINISHED\_DROP, &root->state);+ }+ set\_bit(BTRFS\_ROOT\_DEAD\_TREE, &root->state); btrfs\_add\_dead\_root(root); }diff --git a/fs/btrfs/transaction.c b/fs/btrfs/transaction.cindex c3cfdfd8de9b2d..f17bf3764ce86c 100644--- a/[fs/btrfs/transaction.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/transaction.c?id=a6ab66eb8541d61b0a11d70980f07b4c2dfeddc5)+++ b/[fs/btrfs/transaction.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/transaction.c?id=b4be6aefa73c9a6899ef3ba9c5faaa8a66e333ef)@@ -1320,6 +1320,32 @@ again: }  /\*+ \* If we had a pending drop we need to see if there are any others left in our+ \* dead roots list, and if not clear our bit and wake any waiters.+ \*/+void btrfs\_maybe\_wake\_unfinished\_drop(struct btrfs\_fs\_info \*fs\_info)+{+ /\*+ \* We put the drop in progress roots at the front of the list, so if the+ \* first entry doesn't have UNFINISHED\_DROP set we can wake everybody+ \* up.+ \*/+ spin\_lock(&fs\_info->trans\_lock);+ if (!list\_empty(&fs\_info->dead\_roots)) {+ struct btrfs\_root \*root = list\_first\_entry(&fs\_info->dead\_roots,+ struct btrfs\_root,+ root\_list);+ if (test\_bit(BTRFS\_ROOT\_UNFINISHED\_DROP, &root->state)) {+ spin\_unlock(&fs\_info->trans\_lock);+ return;+ }+ }+ spin\_unlock(&fs\_info->trans\_lock);++ btrfs\_wake\_unfinished\_drop(fs\_info);+}++/\* \* dead roots are old snapshots that need to be deleted. This allocates \* a dirty root struct and adds it into the list of dead roots that need to \* be deleted@@ -1331,7 +1357,12 @@ void btrfs\_add\_dead\_root(struct btrfs\_root \*root) spin\_lock(&fs\_info->trans\_lock); if (list\_empty(&root->root\_list)) { btrfs\_grab\_root(root);- list\_add\_tail(&root->root\_list, &fs\_info->dead\_roots);++ /\* We want to process the partially complete drops first. \*/+ if (test\_bit(BTRFS\_ROOT\_UNFINISHED\_DROP, &root->state))+ list\_add(&root->root\_list, &fs\_info->dead\_roots);+ else+ list\_add\_tail(&root->root\_list, &fs\_info->dead\_roots); } spin\_unlock(&fs\_info->trans\_lock); }diff --git a/fs/btrfs/transaction.h b/fs/btrfs/transaction.hindex 9402d8d944846f..ba8a9826eb3756 100644--- a/[fs/btrfs/transaction.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/transaction.h?id=a6ab66eb8541d61b0a11d70980f07b4c2dfeddc5)+++ b/[fs/btrfs/transaction.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/transaction.h?id=b4be6aefa73c9a6899ef3ba9c5faaa8a66e333ef)@@ -216,6 +216,7 @@ int btrfs\_wait\_for\_commit(struct btrfs\_fs\_info \*fs\_info, u64 transid);  void btrfs\_add\_dead\_root(struct btrfs\_root \*root); int btrfs\_defrag\_root(struct btrfs\_root \*root);+void btrfs\_maybe\_wake\_unfinished\_drop(struct btrfs\_fs\_info \*fs\_info); int btrfs\_clean\_one\_deleted\_snapshot(struct btrfs\_root \*root); int btrfs\_commit\_transaction(struct btrfs\_trans\_handle \*trans); void btrfs\_commit\_transaction\_async(struct btrfs\_trans\_handle \*trans); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 07:50:27 +0000



=== Content from git.kernel.org_cf2640d1_20250111_075147.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=5e70bc827b563caf22e1203428cc3719643de5aa)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=5e70bc827b563caf22e1203428cc3719643de5aa)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=5e70bc827b563caf22e1203428cc3719643de5aa)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5e70bc827b563caf22e1203428cc3719643de5aa)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Josef Bacik <josef@toxicpanda.com> | 2022-02-18 14:56:10 -0500 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2022-03-08 19:14:19 +0100 |
| commit | [5e70bc827b563caf22e1203428cc3719643de5aa](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=5e70bc827b563caf22e1203428cc3719643de5aa) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=5e70bc827b563caf22e1203428cc3719643de5aa)) | |
| tree | [92a68fe1ead3676e83fa35ad67338f06e2181630](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=5e70bc827b563caf22e1203428cc3719643de5aa) | |
| parent | [91a5000bba81690cf92528f17577675a9c7cd185](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=91a5000bba81690cf92528f17577675a9c7cd185) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5e70bc827b563caf22e1203428cc3719643de5aa&id2=91a5000bba81690cf92528f17577675a9c7cd185)) | |
| download | [linux-5e70bc827b563caf22e1203428cc3719643de5aa.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-5e70bc827b563caf22e1203428cc3719643de5aa.tar.gz) | |

btrfs: do not start relocation until in progress drops are donecommit b4be6aefa73c9a6899ef3ba9c5faaa8a66e333ef upstream.
We hit a bug with a recovering relocation on mount for one of our file
systems in production. I reproduced this locally by injecting errors
into snapshot delete with balance running at the same time. This
presented as an error while looking up an extent item
WARNING: CPU: 5 PID: 1501 at fs/btrfs/extent-tree.c:866 lookup\_inline\_extent\_backref+0x647/0x680
CPU: 5 PID: 1501 Comm: btrfs-balance Not tainted 5.16.0-rc8+ #8
RIP: 0010:lookup\_inline\_extent\_backref+0x647/0x680
RSP: 0018:ffffae0a023ab960 EFLAGS: 00010202
RAX: 0000000000000001 RBX: 0000000000000000 RCX: 0000000000000000
RDX: 0000000000000000 RSI: 000000000000000c RDI: 0000000000000000
RBP: ffff943fd2a39b60 R08: 0000000000000000 R09: 0000000000000001
R10: 0001434088152de0 R11: 0000000000000000 R12: 0000000001d05000
R13: ffff943fd2a39b60 R14: ffff943fdb96f2a0 R15: ffff9442fc923000
FS: 0000000000000000(0000) GS:ffff944e9eb40000(0000) knlGS:0000000000000000
CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f1157b1fca8 CR3: 000000010f092000 CR4: 0000000000350ee0
Call Trace:
<TASK>
insert\_inline\_extent\_backref+0x46/0xd0
\_\_btrfs\_inc\_extent\_ref.isra.0+0x5f/0x200
? btrfs\_merge\_delayed\_refs+0x164/0x190
\_\_btrfs\_run\_delayed\_refs+0x561/0xfa0
? btrfs\_search\_slot+0x7b4/0xb30
? btrfs\_update\_root+0x1a9/0x2c0
btrfs\_run\_delayed\_refs+0x73/0x1f0
? btrfs\_update\_root+0x1a9/0x2c0
btrfs\_commit\_transaction+0x50/0xa50
? btrfs\_update\_reloc\_root+0x122/0x220
prepare\_to\_merge+0x29f/0x320
relocate\_block\_group+0x2b8/0x550
btrfs\_relocate\_block\_group+0x1a6/0x350
btrfs\_relocate\_chunk+0x27/0xe0
btrfs\_balance+0x777/0xe60
balance\_kthread+0x35/0x50
? btrfs\_balance+0xe60/0xe60
kthread+0x16b/0x190
? set\_kthread\_struct+0x40/0x40
ret\_from\_fork+0x22/0x30
</TASK>
Normally snapshot deletion and relocation are excluded from running at
the same time by the fs\_info->cleaner\_mutex. However if we had a
pending balance waiting to get the ->cleaner\_mutex, and a snapshot
deletion was running, and then the box crashed, we would come up in a
state where we have a half deleted snapshot.
Again, in the normal case the snapshot deletion needs to complete before
relocation can start, but in this case relocation could very well start
before the snapshot deletion completes, as we simply add the root to the
dead roots list and wait for the next time the cleaner runs to clean up
the snapshot.
Fix this by setting a bit on the fs\_info if we have any DEAD\_ROOT's that
had a pending drop\_progress key. If they do then we know we were in the
middle of the drop operation and set a flag on the fs\_info. Then
balance can wait until this flag is cleared to start up again.
If there are DEAD\_ROOT's that don't have a drop\_progress set then we're
safe to start balance right away as we'll be properly protected by the
cleaner\_mutex.
CC: stable@vger.kernel.org # 5.10+
Reviewed-by: Filipe Manana <fdmanana@suse.com>
Signed-off-by: Josef Bacik <josef@toxicpanda.com>
Reviewed-by: David Sterba <dsterba@suse.com>
Signed-off-by: David Sterba <dsterba@suse.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5e70bc827b563caf22e1203428cc3719643de5aa)

| -rw-r--r-- | [fs/btrfs/ctree.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/ctree.h?id=5e70bc827b563caf22e1203428cc3719643de5aa) | 10 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/btrfs/disk-io.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/disk-io.c?id=5e70bc827b563caf22e1203428cc3719643de5aa) | 10 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/extent-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/extent-tree.c?id=5e70bc827b563caf22e1203428cc3719643de5aa) | 10 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/relocation.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/relocation.c?id=5e70bc827b563caf22e1203428cc3719643de5aa) | 13 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/root-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/root-tree.c?id=5e70bc827b563caf22e1203428cc3719643de5aa) | 15 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/transaction.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/transaction.c?id=5e70bc827b563caf22e1203428cc3719643de5aa) | 33 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/transaction.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/transaction.h?id=5e70bc827b563caf22e1203428cc3719643de5aa) | 1 | |  |  |  | | --- | --- | --- | |

7 files changed, 91 insertions, 1 deletions

| diff --git a/fs/btrfs/ctree.h b/fs/btrfs/ctree.hindex 269094176b8b3a..fd77eca085b415 100644--- a/[fs/btrfs/ctree.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/ctree.h?id=91a5000bba81690cf92528f17577675a9c7cd185)+++ b/[fs/btrfs/ctree.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/ctree.h?id=5e70bc827b563caf22e1203428cc3719643de5aa)@@ -601,6 +601,9 @@ enum { /\* Indicate whether there are any tree modification log users \*/ BTRFS\_FS\_TREE\_MOD\_LOG\_USERS, + /\* Indicate we have half completed snapshot deletions pending. \*/+ BTRFS\_FS\_UNFINISHED\_DROPS,+ #if BITS\_PER\_LONG == 32 /\* Indicate if we have error/warn message printed on 32bit systems \*/ BTRFS\_FS\_32BIT\_ERROR,@@ -1110,8 +1113,15 @@ enum { BTRFS\_ROOT\_HAS\_LOG\_TREE, /\* Qgroup flushing is in progress \*/ BTRFS\_ROOT\_QGROUP\_FLUSHING,+ /\* This root has a drop operation that was started previously. \*/+ BTRFS\_ROOT\_UNFINISHED\_DROP, }; +static inline void btrfs\_wake\_unfinished\_drop(struct btrfs\_fs\_info \*fs\_info)+{+ clear\_and\_wake\_up\_bit(BTRFS\_FS\_UNFINISHED\_DROPS, &fs\_info->flags);+}+ /\* \* Record swapped tree blocks of a subvolume tree for delayed subtree trace \* code. For detail check comment in fs/btrfs/qgroup.c.diff --git a/fs/btrfs/disk-io.c b/fs/btrfs/disk-io.cindex 5f0a879c10436e..15ffb237a489f6 100644--- a/[fs/btrfs/disk-io.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/disk-io.c?id=91a5000bba81690cf92528f17577675a9c7cd185)+++ b/[fs/btrfs/disk-io.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/disk-io.c?id=5e70bc827b563caf22e1203428cc3719643de5aa)@@ -3665,6 +3665,10 @@ int \_\_cold open\_ctree(struct super\_block \*sb, struct btrfs\_fs\_devices \*fs\_device  set\_bit(BTRFS\_FS\_OPEN, &fs\_info->flags); + /\* Kick the cleaner thread so it'll start deleting snapshots. \*/+ if (test\_bit(BTRFS\_FS\_UNFINISHED\_DROPS, &fs\_info->flags))+ wake\_up\_process(fs\_info->cleaner\_kthread);+ clear\_oneshot: btrfs\_clear\_oneshot\_options(fs\_info); return 0;@@ -4348,6 +4352,12 @@ void \_\_cold close\_ctree(struct btrfs\_fs\_info \*fs\_info) \*/ kthread\_park(fs\_info->cleaner\_kthread); + /\*+ \* If we had UNFINISHED\_DROPS we could still be processing them, so+ \* clear that bit and wake up relocation so it can stop.+ \*/+ btrfs\_wake\_unfinished\_drop(fs\_info);+ /\* wait for the qgroup rescan worker to stop \*/ btrfs\_qgroup\_wait\_for\_completion(fs\_info, false); diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.cindex 7b4ee1b2d5d83c..852348189ecb1d 100644--- a/[fs/btrfs/extent-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/extent-tree.c?id=91a5000bba81690cf92528f17577675a9c7cd185)+++ b/[fs/btrfs/extent-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/extent-tree.c?id=5e70bc827b563caf22e1203428cc3719643de5aa)@@ -5604,6 +5604,7 @@ int btrfs\_drop\_snapshot(struct btrfs\_root \*root, int update\_ref, int for\_reloc) int ret; int level; bool root\_dropped = false;+ bool unfinished\_drop = false;  btrfs\_debug(fs\_info, "Drop subvolume %llu", root->root\_key.objectid); @@ -5646,6 +5647,8 @@ int btrfs\_drop\_snapshot(struct btrfs\_root \*root, int update\_ref, int for\_reloc) \* already dropped. \*/ set\_bit(BTRFS\_ROOT\_DELETING, &root->state);+ unfinished\_drop = test\_bit(BTRFS\_ROOT\_UNFINISHED\_DROP, &root->state);+ if (btrfs\_disk\_key\_objectid(&root\_item->drop\_progress) == 0) { level = btrfs\_header\_level(root->node); path->nodes[level] = btrfs\_lock\_root\_node(root);@@ -5821,6 +5824,13 @@ out\_free: btrfs\_free\_path(path); out: /\*+ \* We were an unfinished drop root, check to see if there are any+ \* pending, and if not clear and wake up any waiters.+ \*/+ if (!err && unfinished\_drop)+ btrfs\_maybe\_wake\_unfinished\_drop(fs\_info);++ /\* \* So if we need to stop dropping the snapshot for whatever reason we \* need to make sure to add it back to the dead root list so that we \* keep trying to do the work later. This also cleans up roots if wediff --git a/fs/btrfs/relocation.c b/fs/btrfs/relocation.cindex 33a0ee7ac59065..f129e0718b110f 100644--- a/[fs/btrfs/relocation.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/relocation.c?id=91a5000bba81690cf92528f17577675a9c7cd185)+++ b/[fs/btrfs/relocation.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/relocation.c?id=5e70bc827b563caf22e1203428cc3719643de5aa)@@ -3971,6 +3971,19 @@ int btrfs\_relocate\_block\_group(struct btrfs\_fs\_info \*fs\_info, u64 group\_start) int rw = 0; int err = 0; + /\*+ \* This only gets set if we had a half-deleted snapshot on mount. We+ \* cannot allow relocation to start while we're still trying to clean up+ \* these pending deletions.+ \*/+ ret = wait\_on\_bit(&fs\_info->flags, BTRFS\_FS\_UNFINISHED\_DROPS, TASK\_INTERRUPTIBLE);+ if (ret)+ return ret;++ /\* We may have been woken up by close\_ctree, so bail if we're closing. \*/+ if (btrfs\_fs\_closing(fs\_info))+ return -EINTR;+ bg = btrfs\_lookup\_block\_group(fs\_info, group\_start); if (!bg) return -ENOENT;diff --git a/fs/btrfs/root-tree.c b/fs/btrfs/root-tree.cindex d2016633655769..c6a173e81118ca 100644--- a/[fs/btrfs/root-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/root-tree.c?id=91a5000bba81690cf92528f17577675a9c7cd185)+++ b/[fs/btrfs/root-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/root-tree.c?id=5e70bc827b563caf22e1203428cc3719643de5aa)@@ -278,6 +278,21 @@ int btrfs\_find\_orphan\_roots(struct btrfs\_fs\_info \*fs\_info)  WARN\_ON(!test\_bit(BTRFS\_ROOT\_ORPHAN\_ITEM\_INSERTED, &root->state)); if (btrfs\_root\_refs(&root->root\_item) == 0) {+ struct btrfs\_key drop\_key;++ btrfs\_disk\_key\_to\_cpu(&drop\_key, &root->root\_item.drop\_progress);+ /\*+ \* If we have a non-zero drop\_progress then we know we+ \* made it partly through deleting this snapshot, and+ \* thus we need to make sure we block any balance from+ \* happening until this snapshot is completely dropped.+ \*/+ if (drop\_key.objectid != 0 || drop\_key.type != 0 ||+ drop\_key.offset != 0) {+ set\_bit(BTRFS\_FS\_UNFINISHED\_DROPS, &fs\_info->flags);+ set\_bit(BTRFS\_ROOT\_UNFINISHED\_DROP, &root->state);+ }+ set\_bit(BTRFS\_ROOT\_DEAD\_TREE, &root->state); btrfs\_add\_dead\_root(root); }diff --git a/fs/btrfs/transaction.c b/fs/btrfs/transaction.cindex 49a433a04518ce..a43c101c5525cb 100644--- a/[fs/btrfs/transaction.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/transaction.c?id=91a5000bba81690cf92528f17577675a9c7cd185)+++ b/[fs/btrfs/transaction.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/transaction.c?id=5e70bc827b563caf22e1203428cc3719643de5aa)@@ -1340,6 +1340,32 @@ again: }  /\*+ \* If we had a pending drop we need to see if there are any others left in our+ \* dead roots list, and if not clear our bit and wake any waiters.+ \*/+void btrfs\_maybe\_wake\_unfinished\_drop(struct btrfs\_fs\_info \*fs\_info)+{+ /\*+ \* We put the drop in progress roots at the front of the list, so if the+ \* first entry doesn't have UNFINISHED\_DROP set we can wake everybody+ \* up.+ \*/+ spin\_lock(&fs\_info->trans\_lock);+ if (!list\_empty(&fs\_info->dead\_roots)) {+ struct btrfs\_root \*root = list\_first\_entry(&fs\_info->dead\_roots,+ struct btrfs\_root,+ root\_list);+ if (test\_bit(BTRFS\_ROOT\_UNFINISHED\_DROP, &root->state)) {+ spin\_unlock(&fs\_info->trans\_lock);+ return;+ }+ }+ spin\_unlock(&fs\_info->trans\_lock);++ btrfs\_wake\_unfinished\_drop(fs\_info);+}++/\* \* dead roots are old snapshots that need to be deleted. This allocates \* a dirty root struct and adds it into the list of dead roots that need to \* be deleted@@ -1351,7 +1377,12 @@ void btrfs\_add\_dead\_root(struct btrfs\_root \*root) spin\_lock(&fs\_info->trans\_lock); if (list\_empty(&root->root\_list)) { btrfs\_grab\_root(root);- list\_add\_tail(&root->root\_list, &fs\_info->dead\_roots);++ /\* We want to process the partially complete drops first. \*/+ if (test\_bit(BTRFS\_ROOT\_UNFINISHED\_DROP, &root->state))+ list\_add(&root->root\_list, &fs\_info->dead\_roots);+ else+ list\_add\_tail(&root->root\_list, &fs\_info->dead\_roots); } spin\_unlock(&fs\_info->trans\_lock); }diff --git a/fs/btrfs/transaction.h b/fs/btrfs/transaction.hindex eba07b8119bbd7..0ded32bbd001ec 100644--- a/[fs/btrfs/transaction.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/transaction.h?id=91a5000bba81690cf92528f17577675a9c7cd185)+++ b/[fs/btrfs/transaction.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/transaction.h?id=5e70bc827b563caf22e1203428cc3719643de5aa)@@ -217,6 +217,7 @@ int btrfs\_wait\_for\_commit(struct btrfs\_fs\_info \*fs\_info, u64 transid);  void btrfs\_add\_dead\_root(struct btrfs\_root \*root); int btrfs\_defrag\_root(struct btrfs\_root \*root);+void btrfs\_maybe\_wake\_unfinished\_drop(struct btrfs\_fs\_info \*fs\_info); int btrfs\_clean\_one\_deleted\_snapshot(struct btrfs\_root \*root); int btrfs\_commit\_transaction(struct btrfs\_trans\_handle \*trans); int btrfs\_commit\_transaction\_async(struct btrfs\_trans\_handle \*trans); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 07:50:25 +0000



=== Content from git.kernel.org_a523dbc9_20250111_075149.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=6599d5e8bd758d897fd2ef4dc388ae50278b1f7e)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=6599d5e8bd758d897fd2ef4dc388ae50278b1f7e)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6599d5e8bd758d897fd2ef4dc388ae50278b1f7e)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=6599d5e8bd758d897fd2ef4dc388ae50278b1f7e)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Josef Bacik <josef@toxicpanda.com> | 2022-02-18 14:56:10 -0500 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2022-03-08 19:12:54 +0100 |
| commit | [6599d5e8bd758d897fd2ef4dc388ae50278b1f7e](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6599d5e8bd758d897fd2ef4dc388ae50278b1f7e) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=6599d5e8bd758d897fd2ef4dc388ae50278b1f7e)) | |
| tree | [8ef7fd6dbfb51b534553632eb87571886dfbe077](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=6599d5e8bd758d897fd2ef4dc388ae50278b1f7e) | |
| parent | [4aef4c9005974c063b5f6557da2ffa437dfdb3d3](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=4aef4c9005974c063b5f6557da2ffa437dfdb3d3) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=6599d5e8bd758d897fd2ef4dc388ae50278b1f7e&id2=4aef4c9005974c063b5f6557da2ffa437dfdb3d3)) | |
| download | [linux-6599d5e8bd758d897fd2ef4dc388ae50278b1f7e.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-6599d5e8bd758d897fd2ef4dc388ae50278b1f7e.tar.gz) | |

btrfs: do not start relocation until in progress drops are donecommit b4be6aefa73c9a6899ef3ba9c5faaa8a66e333ef upstream.
We hit a bug with a recovering relocation on mount for one of our file
systems in production. I reproduced this locally by injecting errors
into snapshot delete with balance running at the same time. This
presented as an error while looking up an extent item
WARNING: CPU: 5 PID: 1501 at fs/btrfs/extent-tree.c:866 lookup\_inline\_extent\_backref+0x647/0x680
CPU: 5 PID: 1501 Comm: btrfs-balance Not tainted 5.16.0-rc8+ #8
RIP: 0010:lookup\_inline\_extent\_backref+0x647/0x680
RSP: 0018:ffffae0a023ab960 EFLAGS: 00010202
RAX: 0000000000000001 RBX: 0000000000000000 RCX: 0000000000000000
RDX: 0000000000000000 RSI: 000000000000000c RDI: 0000000000000000
RBP: ffff943fd2a39b60 R08: 0000000000000000 R09: 0000000000000001
R10: 0001434088152de0 R11: 0000000000000000 R12: 0000000001d05000
R13: ffff943fd2a39b60 R14: ffff943fdb96f2a0 R15: ffff9442fc923000
FS: 0000000000000000(0000) GS:ffff944e9eb40000(0000) knlGS:0000000000000000
CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f1157b1fca8 CR3: 000000010f092000 CR4: 0000000000350ee0
Call Trace:
<TASK>
insert\_inline\_extent\_backref+0x46/0xd0
\_\_btrfs\_inc\_extent\_ref.isra.0+0x5f/0x200
? btrfs\_merge\_delayed\_refs+0x164/0x190
\_\_btrfs\_run\_delayed\_refs+0x561/0xfa0
? btrfs\_search\_slot+0x7b4/0xb30
? btrfs\_update\_root+0x1a9/0x2c0
btrfs\_run\_delayed\_refs+0x73/0x1f0
? btrfs\_update\_root+0x1a9/0x2c0
btrfs\_commit\_transaction+0x50/0xa50
? btrfs\_update\_reloc\_root+0x122/0x220
prepare\_to\_merge+0x29f/0x320
relocate\_block\_group+0x2b8/0x550
btrfs\_relocate\_block\_group+0x1a6/0x350
btrfs\_relocate\_chunk+0x27/0xe0
btrfs\_balance+0x777/0xe60
balance\_kthread+0x35/0x50
? btrfs\_balance+0xe60/0xe60
kthread+0x16b/0x190
? set\_kthread\_struct+0x40/0x40
ret\_from\_fork+0x22/0x30
</TASK>
Normally snapshot deletion and relocation are excluded from running at
the same time by the fs\_info->cleaner\_mutex. However if we had a
pending balance waiting to get the ->cleaner\_mutex, and a snapshot
deletion was running, and then the box crashed, we would come up in a
state where we have a half deleted snapshot.
Again, in the normal case the snapshot deletion needs to complete before
relocation can start, but in this case relocation could very well start
before the snapshot deletion completes, as we simply add the root to the
dead roots list and wait for the next time the cleaner runs to clean up
the snapshot.
Fix this by setting a bit on the fs\_info if we have any DEAD\_ROOT's that
had a pending drop\_progress key. If they do then we know we were in the
middle of the drop operation and set a flag on the fs\_info. Then
balance can wait until this flag is cleared to start up again.
If there are DEAD\_ROOT's that don't have a drop\_progress set then we're
safe to start balance right away as we'll be properly protected by the
cleaner\_mutex.
CC: stable@vger.kernel.org # 5.10+
Reviewed-by: Filipe Manana <fdmanana@suse.com>
Signed-off-by: Josef Bacik <josef@toxicpanda.com>
Reviewed-by: David Sterba <dsterba@suse.com>
Signed-off-by: David Sterba <dsterba@suse.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=6599d5e8bd758d897fd2ef4dc388ae50278b1f7e)

| -rw-r--r-- | [fs/btrfs/ctree.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/ctree.h?id=6599d5e8bd758d897fd2ef4dc388ae50278b1f7e) | 10 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/btrfs/disk-io.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/disk-io.c?id=6599d5e8bd758d897fd2ef4dc388ae50278b1f7e) | 10 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/extent-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/extent-tree.c?id=6599d5e8bd758d897fd2ef4dc388ae50278b1f7e) | 10 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/relocation.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/relocation.c?id=6599d5e8bd758d897fd2ef4dc388ae50278b1f7e) | 13 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/root-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/root-tree.c?id=6599d5e8bd758d897fd2ef4dc388ae50278b1f7e) | 15 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/transaction.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/transaction.c?id=6599d5e8bd758d897fd2ef4dc388ae50278b1f7e) | 33 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/transaction.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/transaction.h?id=6599d5e8bd758d897fd2ef4dc388ae50278b1f7e) | 1 | |  |  |  | | --- | --- | --- | |

7 files changed, 91 insertions, 1 deletions

| diff --git a/fs/btrfs/ctree.h b/fs/btrfs/ctree.hindex ae06ad5593535b..b46409801647b4 100644--- a/[fs/btrfs/ctree.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/ctree.h?id=4aef4c9005974c063b5f6557da2ffa437dfdb3d3)+++ b/[fs/btrfs/ctree.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/ctree.h?id=6599d5e8bd758d897fd2ef4dc388ae50278b1f7e)@@ -593,6 +593,9 @@ enum { /\* Indicate whether there are any tree modification log users \*/ BTRFS\_FS\_TREE\_MOD\_LOG\_USERS, + /\* Indicate we have half completed snapshot deletions pending. \*/+ BTRFS\_FS\_UNFINISHED\_DROPS,+ #if BITS\_PER\_LONG == 32 /\* Indicate if we have error/warn message printed on 32bit systems \*/ BTRFS\_FS\_32BIT\_ERROR,@@ -1098,8 +1101,15 @@ enum { BTRFS\_ROOT\_HAS\_LOG\_TREE, /\* Qgroup flushing is in progress \*/ BTRFS\_ROOT\_QGROUP\_FLUSHING,+ /\* This root has a drop operation that was started previously. \*/+ BTRFS\_ROOT\_UNFINISHED\_DROP, }; +static inline void btrfs\_wake\_unfinished\_drop(struct btrfs\_fs\_info \*fs\_info)+{+ clear\_and\_wake\_up\_bit(BTRFS\_FS\_UNFINISHED\_DROPS, &fs\_info->flags);+}+ /\* \* Record swapped tree blocks of a subvolume tree for delayed subtree trace \* code. For detail check comment in fs/btrfs/qgroup.c.diff --git a/fs/btrfs/disk-io.c b/fs/btrfs/disk-io.cindex 2c3e106a02704c..2180fcef56cabb 100644--- a/[fs/btrfs/disk-io.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/disk-io.c?id=4aef4c9005974c063b5f6557da2ffa437dfdb3d3)+++ b/[fs/btrfs/disk-io.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/disk-io.c?id=6599d5e8bd758d897fd2ef4dc388ae50278b1f7e)@@ -3659,6 +3659,10 @@ int \_\_cold open\_ctree(struct super\_block \*sb, struct btrfs\_fs\_devices \*fs\_device  set\_bit(BTRFS\_FS\_OPEN, &fs\_info->flags); + /\* Kick the cleaner thread so it'll start deleting snapshots. \*/+ if (test\_bit(BTRFS\_FS\_UNFINISHED\_DROPS, &fs\_info->flags))+ wake\_up\_process(fs\_info->cleaner\_kthread);+ clear\_oneshot: btrfs\_clear\_oneshot\_options(fs\_info); return 0;@@ -4340,6 +4344,12 @@ void \_\_cold close\_ctree(struct btrfs\_fs\_info \*fs\_info) \*/ kthread\_park(fs\_info->cleaner\_kthread); + /\*+ \* If we had UNFINISHED\_DROPS we could still be processing them, so+ \* clear that bit and wake up relocation so it can stop.+ \*/+ btrfs\_wake\_unfinished\_drop(fs\_info);+ /\* wait for the qgroup rescan worker to stop \*/ btrfs\_qgroup\_wait\_for\_completion(fs\_info, false); diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.cindex 87c23c5c0f26da..514adc83577f0f 100644--- a/[fs/btrfs/extent-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/extent-tree.c?id=4aef4c9005974c063b5f6557da2ffa437dfdb3d3)+++ b/[fs/btrfs/extent-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/extent-tree.c?id=6599d5e8bd758d897fd2ef4dc388ae50278b1f7e)@@ -5541,6 +5541,7 @@ int btrfs\_drop\_snapshot(struct btrfs\_root \*root, int update\_ref, int for\_reloc) int ret; int level; bool root\_dropped = false;+ bool unfinished\_drop = false;  btrfs\_debug(fs\_info, "Drop subvolume %llu", root->root\_key.objectid); @@ -5583,6 +5584,8 @@ int btrfs\_drop\_snapshot(struct btrfs\_root \*root, int update\_ref, int for\_reloc) \* already dropped. \*/ set\_bit(BTRFS\_ROOT\_DELETING, &root->state);+ unfinished\_drop = test\_bit(BTRFS\_ROOT\_UNFINISHED\_DROP, &root->state);+ if (btrfs\_disk\_key\_objectid(&root\_item->drop\_progress) == 0) { level = btrfs\_header\_level(root->node); path->nodes[level] = btrfs\_lock\_root\_node(root);@@ -5758,6 +5761,13 @@ out\_free: btrfs\_free\_path(path); out: /\*+ \* We were an unfinished drop root, check to see if there are any+ \* pending, and if not clear and wake up any waiters.+ \*/+ if (!err && unfinished\_drop)+ btrfs\_maybe\_wake\_unfinished\_drop(fs\_info);++ /\* \* So if we need to stop dropping the snapshot for whatever reason we \* need to make sure to add it back to the dead root list so that we \* keep trying to do the work later. This also cleans up roots if wediff --git a/fs/btrfs/relocation.c b/fs/btrfs/relocation.cindex d81bee621d3738..a050f9748fa7fc 100644--- a/[fs/btrfs/relocation.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/relocation.c?id=4aef4c9005974c063b5f6557da2ffa437dfdb3d3)+++ b/[fs/btrfs/relocation.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/relocation.c?id=6599d5e8bd758d897fd2ef4dc388ae50278b1f7e)@@ -3967,6 +3967,19 @@ int btrfs\_relocate\_block\_group(struct btrfs\_fs\_info \*fs\_info, u64 group\_start) int rw = 0; int err = 0; + /\*+ \* This only gets set if we had a half-deleted snapshot on mount. We+ \* cannot allow relocation to start while we're still trying to clean up+ \* these pending deletions.+ \*/+ ret = wait\_on\_bit(&fs\_info->flags, BTRFS\_FS\_UNFINISHED\_DROPS, TASK\_INTERRUPTIBLE);+ if (ret)+ return ret;++ /\* We may have been woken up by close\_ctree, so bail if we're closing. \*/+ if (btrfs\_fs\_closing(fs\_info))+ return -EINTR;+ bg = btrfs\_lookup\_block\_group(fs\_info, group\_start); if (!bg) return -ENOENT;diff --git a/fs/btrfs/root-tree.c b/fs/btrfs/root-tree.cindex db37a379964978..1fa0e5e2e3505e 100644--- a/[fs/btrfs/root-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/root-tree.c?id=4aef4c9005974c063b5f6557da2ffa437dfdb3d3)+++ b/[fs/btrfs/root-tree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/root-tree.c?id=6599d5e8bd758d897fd2ef4dc388ae50278b1f7e)@@ -280,6 +280,21 @@ int btrfs\_find\_orphan\_roots(struct btrfs\_fs\_info \*fs\_info)  WARN\_ON(!test\_bit(BTRFS\_ROOT\_ORPHAN\_ITEM\_INSERTED, &root->state)); if (btrfs\_root\_refs(&root->root\_item) == 0) {+ struct btrfs\_key drop\_key;++ btrfs\_disk\_key\_to\_cpu(&drop\_key, &root->root\_item.drop\_progress);+ /\*+ \* If we have a non-zero drop\_progress then we know we+ \* made it partly through deleting this snapshot, and+ \* thus we need to make sure we block any balance from+ \* happening until this snapshot is completely dropped.+ \*/+ if (drop\_key.objectid != 0 || drop\_key.type != 0 ||+ drop\_key.offset != 0) {+ set\_bit(BTRFS\_FS\_UNFINISHED\_DROPS, &fs\_info->flags);+ set\_bit(BTRFS\_ROOT\_UNFINISHED\_DROP, &root->state);+ }+ set\_bit(BTRFS\_ROOT\_DEAD\_TREE, &root->state); btrfs\_add\_dead\_root(root); }diff --git a/fs/btrfs/transaction.c b/fs/btrfs/transaction.cindex 3c5b1f72129acf..9a6009108ea559 100644--- a/[fs/btrfs/transaction.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/transaction.c?id=4aef4c9005974c063b5f6557da2ffa437dfdb3d3)+++ b/[fs/btrfs/transaction.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/transaction.c?id=6599d5e8bd758d897fd2ef4dc388ae50278b1f7e)@@ -1341,6 +1341,32 @@ again: }  /\*+ \* If we had a pending drop we need to see if there are any others left in our+ \* dead roots list, and if not clear our bit and wake any waiters.+ \*/+void btrfs\_maybe\_wake\_unfinished\_drop(struct btrfs\_fs\_info \*fs\_info)+{+ /\*+ \* We put the drop in progress roots at the front of the list, so if the+ \* first entry doesn't have UNFINISHED\_DROP set we can wake everybody+ \* up.+ \*/+ spin\_lock(&fs\_info->trans\_lock);+ if (!list\_empty(&fs\_info->dead\_roots)) {+ struct btrfs\_root \*root = list\_first\_entry(&fs\_info->dead\_roots,+ struct btrfs\_root,+ root\_list);+ if (test\_bit(BTRFS\_ROOT\_UNFINISHED\_DROP, &root->state)) {+ spin\_unlock(&fs\_info->trans\_lock);+ return;+ }+ }+ spin\_unlock(&fs\_info->trans\_lock);++ btrfs\_wake\_unfinished\_drop(fs\_info);+}++/\* \* dead roots are old snapshots that need to be deleted. This allocates \* a dirty root struct and adds it into the list of dead roots that need to \* be deleted@@ -1352,7 +1378,12 @@ void btrfs\_add\_dead\_root(struct btrfs\_root \*root) spin\_lock(&fs\_info->trans\_lock); if (list\_empty(&root->root\_list)) { btrfs\_grab\_root(root);- list\_add\_tail(&root->root\_list, &fs\_info->dead\_roots);++ /\* We want to process the partially complete drops first. \*/+ if (test\_bit(BTRFS\_ROOT\_UNFINISHED\_DROP, &root->state))+ list\_add(&root->root\_list, &fs\_info->dead\_roots);+ else+ list\_add\_tail(&root->root\_list, &fs\_info->dead\_roots); } spin\_unlock(&fs\_info->trans\_lock); }diff --git a/fs/btrfs/transaction.h b/fs/btrfs/transaction.hindex eba07b8119bbd7..0ded32bbd001ec 100644--- a/[fs/btrfs/transaction.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/transaction.h?id=4aef4c9005974c063b5f6557da2ffa437dfdb3d3)+++ b/[fs/btrfs/transaction.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/transaction.h?id=6599d5e8bd758d897fd2ef4dc388ae50278b1f7e)@@ -217,6 +217,7 @@ int btrfs\_wait\_for\_commit(struct btrfs\_fs\_info \*fs\_info, u64 transid);  void btrfs\_add\_dead\_root(struct btrfs\_root \*root); int btrfs\_defrag\_root(struct btrfs\_root \*root);+void btrfs\_maybe\_wake\_unfinished\_drop(struct btrfs\_fs\_info \*fs\_info); int btrfs\_clean\_one\_deleted\_snapshot(struct btrfs\_root \*root); int btrfs\_commit\_transaction(struct btrfs\_trans\_handle \*trans); int btrfs\_commit\_transaction\_async(struct btrfs\_trans\_handle \*trans); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 07:50:26 +0000


