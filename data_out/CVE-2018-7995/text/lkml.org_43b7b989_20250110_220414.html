

| [lkml.org](/) | Â | [[lkml]](/lkml) Â  [[2018]](/lkml/2018) Â  [[Mar]](/lkml/2018/3) Â  [[2]](/lkml/2018/3/2) Â  [[last100]](/lkml/last100) Â  [RSS Feed](/rss.php)Views: [wrap][no wrap] Â  [[headers]](/lkml/mheaders/2018/3/2/970)Â  [[forward]](/lkml/bounce/2018/3/2/970)Â | Â |
| --- | --- | --- | --- |
| Messages in this thread  * [First message in thread](/lkml/2018/3/2/970) * [Seunghun Han](/lkml/2018/3/6/219)   + [Borislav Petkov](/lkml/2018/3/6/219)     - [Greg Kroah-Hartman](/lkml/2018/3/6/235)       * [Borislav Petkov](/lkml/2018/3/6/237)         + [Greg Kroah-Hartman](/lkml/2018/3/6/270)   + [tip-bot for Seunghun Han](/lkml/2018/3/8/875)  Patch in this message  * [Get diff 1](/lkml/diff/2018/3/2/970/1) | / | | | From | Seunghun Han <> | | --- | --- | | Subject | [PATCH V3] x86: mce: fix kernel panic when check\_interval is changed | | Date | Sat, 3 Mar 2018 05:27:06 +0900 | |  | | --- | --- | --- | --- | --- | --- | --- | --- |  ``` I am Seunghun Han and a senior security researcher at National SecurityResearch Institute of South Korea.I found a security issue which can make kernel panic in userspace. Afteranalyzing the issue carefully, I found that MCE driver in the kernel has aproblem which can be occurred in SMP environment.The check_interval file in/sys/devices/system/machinecheck/machinecheck<cpu number> directory is aglobal timer value for MCE polling. If it is changed by one CPU, MCE driverin kernel calls mce_restart() function in store_int_with_restart() functionand broadcasts the event to other CPUs to delete and restart MCE pollingtimer.The __mcheck_cpu_init_timer() function which is called by mce_restart()function initializes the mce_timer variable, and the "lock" in mce_timer isalso reinitialized. If more than one CPU write a specific value tocheck_interval file concurrently, one can initialize the "lock" in mce_timerwhile the others are handling "lock" in mce_timer. This problem causes somesynchronization errors such as kernel panic and kernel hang. Other functionssuch as set_ignore_ce(), set_cmci_disabled(), and mce_enable_ce() alsohave synchronization problems.It could be a security problem because the attacker could make kernel panicby writing a value to the check_interval file in userspace, and it could beused for Denial-of-Service (DoS) attack.To fix this problem, I added a mce_sysfs_mutex to serialize requests fortimer and sysfs functions.Signed-off-by: Seunghun Han <kkamagui@gmail.com>---Changes since v2: add a mutex to sysfs functions according to reviewresult.Changes since v1: add mce_sysfs_mutex according to review result. arch/x86/kernel/cpu/mcheck/mce.c | 20 +++++++++++++++++++- 1 file changed, 19 insertions(+), 1 deletion(-)diff --git a/arch/x86/kernel/cpu/mcheck/mce.c b/arch/x86/kernel/cpu/mcheck/mce.cindex 706584681a4c..243f46a40efb 100644--- a/arch/x86/kernel/cpu/mcheck/mce.c+++ b/arch/x86/kernel/cpu/mcheck/mce.c@@ -55,6 +55,7 @@ #include "mce-internal.h"  static DEFINE_MUTEX(mce_log_mutex);+static DEFINE_MUTEX(mce_sysfs_mutex);  #define CREATE_TRACE_POINTS #include <trace/events/mce.h>@@ -2045,8 +2046,11 @@ static void mce_enable_ce(void *all) 		return; 	cmci_reenable(); 	cmci_recheck();-	if (all)+	if (all) {+		mutex_lock(&mce_sysfs_mutex); 		__mcheck_cpu_init_timer();+		mutex_unlock(&mce_sysfs_mutex);+	} }  static struct bus_type mce_subsys = {@@ -2090,6 +2094,7 @@ static ssize_t set_ignore_ce(struct device *s, 	if (kstrtou64(buf, 0, &new) < 0) 		return -EINVAL; +	mutex_lock(&mce_sysfs_mutex); 	if (mca_cfg.ignore_ce ^ !!new) { 		if (new) { 			/* disable ce features */@@ -2102,6 +2107,8 @@ static ssize_t set_ignore_ce(struct device *s, 			on_each_cpu(mce_enable_ce, (void *)1, 1); 		} 	}+	mutex_unlock(&mce_sysfs_mutex);+ 	return size; } @@ -2114,6 +2121,7 @@ static ssize_t set_cmci_disabled(struct device *s, 	if (kstrtou64(buf, 0, &new) < 0) 		return -EINVAL; +	mutex_lock(&mce_sysfs_mutex); 	if (mca_cfg.cmci_disabled ^ !!new) { 		if (new) { 			/* disable cmci */@@ -2125,6 +2133,8 @@ static ssize_t set_cmci_disabled(struct device *s, 			on_each_cpu(mce_enable_ce, NULL, 1); 		} 	}+	mutex_unlock(&mce_sysfs_mutex);+ 	return size; } @@ -2132,8 +2142,16 @@ static ssize_t store_int_with_restart(struct device *s, 				      struct device_attribute *attr, 				      const char *buf, size_t size) {+	unsigned long old_check_interval = check_interval; 	ssize_t ret = device_store_int(s, attr, buf, size);++	if (check_interval == old_check_interval)+		return ret;++	mutex_lock(&mce_sysfs_mutex); 	mce_restart();+	mutex_unlock(&mce_sysfs_mutex);+ 	return ret; } -- 2.16.2 ``` | \ |
| Â |
| Â | \ | Â | / |
| Â | | Last update: 2018-03-02 21:30 Â Â  [from the cache]Â©2003-2020 [Jasper Spaans](http://blog.jasper.es/)|hosted at [Digital Ocean](https://www.digitalocean.com/?refcode=9a8e99d24cf9) and my Meterkast|[Read the blog](http://blog.jasper.es/categories.html#lkml-ref) | Â |

