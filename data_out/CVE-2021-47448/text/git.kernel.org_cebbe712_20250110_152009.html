

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=612f71d7328c14369924384ad2170aae2a6abd92)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=612f71d7328c14369924384ad2170aae2a6abd92)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=612f71d7328c14369924384ad2170aae2a6abd92)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=612f71d7328c14369924384ad2170aae2a6abd92)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Paolo Abeni <pabeni@redhat.com> | 2021-10-07 15:05:00 -0700 |
| --- | --- | --- |
| committer | David S. Miller <davem@davemloft.net> | 2021-10-08 14:55:54 +0100 |
| commit | [612f71d7328c14369924384ad2170aae2a6abd92](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=612f71d7328c14369924384ad2170aae2a6abd92) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=612f71d7328c14369924384ad2170aae2a6abd92)) | |
| tree | [5c87d9f7ed4048e628eb71ab7b785b879ab1218e](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=612f71d7328c14369924384ad2170aae2a6abd92) | |
| parent | [1da38549dd64c7f5dd22427f12dfa8db3d8a722b](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=1da38549dd64c7f5dd22427f12dfa8db3d8a722b) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=612f71d7328c14369924384ad2170aae2a6abd92&id2=1da38549dd64c7f5dd22427f12dfa8db3d8a722b)) | |
| download | [linux-612f71d7328c14369924384ad2170aae2a6abd92.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-612f71d7328c14369924384ad2170aae2a6abd92.tar.gz) | |

mptcp: fix possible stall on recvmsg()recvmsg() can enter an infinite loop if the caller provides the
MSG\_WAITALL, the data present in the receive queue is not sufficient to
fulfill the request, and no more data is received by the peer.
When the above happens, mptcp\_wait\_data() will always return with
no wait, as the MPTCP\_DATA\_READY flag checked by such function is
set and never cleared in such code path.
Leveraging the above syzbot was able to trigger an RCU stall:
rcu: INFO: rcu\_preempt self-detected stall on CPU
rcu: 0-...!: (10499 ticks this GP) idle=0af/1/0x4000000000000000 softirq=10678/10678 fqs=1
(t=10500 jiffies g=13089 q=109)
rcu: rcu\_preempt kthread starved for 10497 jiffies! g13089 f0x0 RCU\_GP\_WAIT\_FQS(5) ->state=0x0 ->cpu=1
rcu: Unless rcu\_preempt kthread gets sufficient CPU time, OOM is now expected behavior.
rcu: RCU grace-period kthread stack dump:
task:rcu\_preempt state:R running task stack:28696 pid: 14 ppid: 2 flags:0x00004000
Call Trace:
context\_switch kernel/sched/core.c:4955 [inline]
\_\_schedule+0x940/0x26f0 kernel/sched/core.c:6236
schedule+0xd3/0x270 kernel/sched/core.c:6315
schedule\_timeout+0x14a/0x2a0 kernel/time/timer.c:1881
rcu\_gp\_fqs\_loop+0x186/0x810 kernel/rcu/tree.c:1955
rcu\_gp\_kthread+0x1de/0x320 kernel/rcu/tree.c:2128
kthread+0x405/0x4f0 kernel/kthread.c:327
ret\_from\_fork+0x1f/0x30 arch/x86/entry/entry\_64.S:295
rcu: Stack dump where RCU GP kthread last ran:
Sending NMI from CPU 0 to CPUs 1:
NMI backtrace for cpu 1
CPU: 1 PID: 8510 Comm: syz-executor827 Not tainted 5.15.0-rc2-next-20210920-syzkaller #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
RIP: 0010:bytes\_is\_nonzero mm/kasan/generic.c:84 [inline]
RIP: 0010:memory\_is\_nonzero mm/kasan/generic.c:102 [inline]
RIP: 0010:memory\_is\_poisoned\_n mm/kasan/generic.c:128 [inline]
RIP: 0010:memory\_is\_poisoned mm/kasan/generic.c:159 [inline]
RIP: 0010:check\_region\_inline mm/kasan/generic.c:180 [inline]
RIP: 0010:kasan\_check\_range+0xc8/0x180 mm/kasan/generic.c:189
Code: 38 00 74 ed 48 8d 50 08 eb 09 48 83 c0 01 48 39 d0 74 7a 80 38 00 74 f2 48 89 c2 b8 01 00 00 00 48 85 d2 75 56 5b 5d 41 5c c3 <48> 85 d2 74 5e 48 01 ea eb 09 48 83 c0 01 48 39 d0 74 50 80 38 00
RSP: 0018:ffffc9000cd676c8 EFLAGS: 00000283
RAX: ffffed100e9a110e RBX: ffffed100e9a110f RCX: ffffffff88ea062a
RDX: 0000000000000001 RSI: 0000000000000008 RDI: ffff888074d08870
RBP: ffffed100e9a110e R08: 0000000000000001 R09: ffff888074d08877
R10: ffffed100e9a110e R11: 0000000000000000 R12: ffff888074d08000
R13: ffff888074d08000 R14: ffff888074d08088 R15: ffff888074d08000
FS: 0000555556d8e300(0000) GS:ffff8880b9d00000(0000) knlGS:0000000000000000
S: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000000020000180 CR3: 0000000068909000 CR4: 00000000001506e0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
instrument\_atomic\_read\_write include/linux/instrumented.h:101 [inline]
test\_and\_clear\_bit include/asm-generic/bitops/instrumented-atomic.h:83 [inline]
mptcp\_release\_cb+0x14a/0x210 net/mptcp/protocol.c:3016
release\_sock+0xb4/0x1b0 net/core/sock.c:3204
mptcp\_wait\_data net/mptcp/protocol.c:1770 [inline]
mptcp\_recvmsg+0xfd1/0x27b0 net/mptcp/protocol.c:2080
inet6\_recvmsg+0x11b/0x5e0 net/ipv6/af\_inet6.c:659
sock\_recvmsg\_nosec net/socket.c:944 [inline]
\_\_\_\_sys\_recvmsg+0x527/0x600 net/socket.c:2626
\_\_\_sys\_recvmsg+0x127/0x200 net/socket.c:2670
do\_recvmmsg+0x24d/0x6d0 net/socket.c:2764
\_\_sys\_recvmmsg net/socket.c:2843 [inline]
\_\_do\_sys\_recvmmsg net/socket.c:2866 [inline]
\_\_se\_sys\_recvmmsg net/socket.c:2859 [inline]
\_\_x64\_sys\_recvmmsg+0x20b/0x260 net/socket.c:2859
do\_syscall\_x64 arch/x86/entry/common.c:50 [inline]
do\_syscall\_64+0x35/0xb0 arch/x86/entry/common.c:80
entry\_SYSCALL\_64\_after\_hwframe+0x44/0xae
RIP: 0033:0x7fc200d2dc39
Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 41 15 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 c0 ff ff ff f7 d8 64 89 01 48
RSP: 002b:00007ffc5758e5a8 EFLAGS: 00000246 ORIG\_RAX: 000000000000012b
RAX: ffffffffffffffda RBX: 0000000000000003 RCX: 00007fc200d2dc39
RDX: 0000000000000002 RSI: 00000000200017c0 RDI: 0000000000000003
RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000f0b5ff
R10: 0000000000000100 R11: 0000000000000246 R12: 0000000000000003
R13: 00007ffc5758e5d0 R14: 00007ffc5758e5c0 R15: 0000000000000003
Fix the issue by replacing the MPTCP\_DATA\_READY bit with direct
inspection of the msk receive queue.
Reported-and-tested-by: syzbot+3360da629681aa0d22fe@syzkaller.appspotmail.com
Fixes: 7a6a6cbc3e59 ("mptcp: recvmsg() can drain data from multiple subflow")
Signed-off-by: Paolo Abeni <pabeni@redhat.com>
Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=612f71d7328c14369924384ad2170aae2a6abd92)

| -rw-r--r-- | [net/mptcp/protocol.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/mptcp/protocol.c?id=612f71d7328c14369924384ad2170aae2a6abd92) | 55 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 15 insertions, 40 deletions

| diff --git a/net/mptcp/protocol.c b/net/mptcp/protocol.cindex e5df0b5971c86a..d073b211138287 100644--- a/[net/mptcp/protocol.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/mptcp/protocol.c?id=1da38549dd64c7f5dd22427f12dfa8db3d8a722b)+++ b/[net/mptcp/protocol.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/mptcp/protocol.c?id=612f71d7328c14369924384ad2170aae2a6abd92)@@ -528,7 +528,6 @@ static bool mptcp\_check\_data\_fin(struct sock \*sk)  sk->sk\_shutdown |= RCV\_SHUTDOWN; smp\_mb\_\_before\_atomic(); /\* SHUTDOWN must be visible first \*/- set\_bit(MPTCP\_DATA\_READY, &msk->flags);  switch (sk->sk\_state) { case TCP\_ESTABLISHED:@@ -742,10 +741,9 @@ void mptcp\_data\_ready(struct sock \*sk, struct sock \*ssk)  /\* Wake-up the reader only for in-sequence data \*/ mptcp\_data\_lock(sk);- if (move\_skbs\_to\_msk(msk, ssk)) {- set\_bit(MPTCP\_DATA\_READY, &msk->flags);+ if (move\_skbs\_to\_msk(msk, ssk)) sk->sk\_data\_ready(sk);- }+ mptcp\_data\_unlock(sk); } @@ -847,7 +845,6 @@ static void mptcp\_check\_for\_eof(struct mptcp\_sock \*msk) sk->sk\_shutdown |= RCV\_SHUTDOWN;  smp\_mb\_\_before\_atomic(); /\* SHUTDOWN must be visible first \*/- set\_bit(MPTCP\_DATA\_READY, &msk->flags); sk->sk\_data\_ready(sk); } @@ -1759,21 +1756,6 @@ out: return copied ? : ret; } -static void mptcp\_wait\_data(struct sock \*sk, long \*timeo)-{- DEFINE\_WAIT\_FUNC(wait, woken\_wake\_function);- struct mptcp\_sock \*msk = mptcp\_sk(sk);-- add\_wait\_queue(sk\_sleep(sk), &wait);- sk\_set\_bit(SOCKWQ\_ASYNC\_WAITDATA, sk);-- sk\_wait\_event(sk, timeo,- test\_bit(MPTCP\_DATA\_READY, &msk->flags), &wait);-- sk\_clear\_bit(SOCKWQ\_ASYNC\_WAITDATA, sk);- remove\_wait\_queue(sk\_sleep(sk), &wait);-}- static int \_\_mptcp\_recvmsg\_mskq(struct mptcp\_sock \*msk, struct msghdr \*msg, size\_t len, int flags,@@ -2077,19 +2059,7 @@ static int mptcp\_recvmsg(struct sock \*sk, struct msghdr \*msg, size\_t len, }  pr\_debug("block timeout %ld", timeo);- mptcp\_wait\_data(sk, &timeo);- }-- if (skb\_queue\_empty\_lockless(&sk->sk\_receive\_queue) &&- skb\_queue\_empty(&msk->receive\_queue)) {- /\* entire backlog drained, clear DATA\_READY. \*/- clear\_bit(MPTCP\_DATA\_READY, &msk->flags);-- /\* .. race-breaker: ssk might have gotten new data- \* after last \_\_mptcp\_move\_skbs() returned false.- \*/- if (unlikely(\_\_mptcp\_move\_skbs(msk)))- set\_bit(MPTCP\_DATA\_READY, &msk->flags);+ sk\_wait\_data(sk, &timeo, NULL); }  out\_err:@@ -2098,9 +2068,9 @@ out\_err: tcp\_recv\_timestamp(msg, sk, &tss); } - pr\_debug("msk=%p data\_ready=%d rx queue empty=%d copied=%d",- msk, test\_bit(MPTCP\_DATA\_READY, &msk->flags),- skb\_queue\_empty\_lockless(&sk->sk\_receive\_queue), copied);+ pr\_debug("msk=%p rx queue empty=%d:%d copied=%d",+ msk, skb\_queue\_empty\_lockless(&sk->sk\_receive\_queue),+ skb\_queue\_empty(&msk->receive\_queue), copied); if (!(flags & MSG\_PEEK)) mptcp\_rcv\_space\_adjust(msk, copied); @@ -2368,7 +2338,6 @@ static void mptcp\_check\_fastclose(struct mptcp\_sock \*msk) inet\_sk\_state\_store(sk, TCP\_CLOSE); sk->sk\_shutdown = SHUTDOWN\_MASK; smp\_mb\_\_before\_atomic(); /\* SHUTDOWN must be visible first \*/- set\_bit(MPTCP\_DATA\_READY, &msk->flags); set\_bit(MPTCP\_WORK\_CLOSE\_SUBFLOW, &msk->flags);  mptcp\_close\_wake\_up(sk);@@ -3385,8 +3354,14 @@ unlock\_fail:  static \_\_poll\_t mptcp\_check\_readable(struct mptcp\_sock \*msk) {- return test\_bit(MPTCP\_DATA\_READY, &msk->flags) ? EPOLLIN | EPOLLRDNORM :- 0;+ /\* Concurrent splices from sk\_receive\_queue into receive\_queue will+ \* always show at least one non-empty queue when checked in this order.+ \*/+ if (skb\_queue\_empty\_lockless(&((struct sock \*)msk)->sk\_receive\_queue) &&+ skb\_queue\_empty\_lockless(&msk->receive\_queue))+ return 0;++ return EPOLLIN | EPOLLRDNORM; }  static \_\_poll\_t mptcp\_check\_writeable(struct mptcp\_sock \*msk)@@ -3421,7 +3396,7 @@ static \_\_poll\_t mptcp\_poll(struct file \*file, struct socket \*sock, state = inet\_sk\_state\_load(sk); pr\_debug("msk=%p state=%d flags=%lx", msk, state, msk->flags); if (state == TCP\_LISTEN)- return mptcp\_check\_readable(msk);+ return test\_bit(MPTCP\_DATA\_READY, &msk->flags) ? EPOLLIN | EPOLLRDNORM : 0;  if (state != TCP\_SYN\_SENT && state != TCP\_SYN\_RECV) { mask |= mptcp\_check\_readable(msk); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 15:18:46 +0000

