The provided content relates to CVE-2021-47226.

**Root cause of vulnerability:**
The vulnerability arises from a potential race condition in the x86 FPU (Floating Point Unit) state restoration process when using XRSTOR instruction within the `__fpu__restore_sig()` function. Specifically, if XRSTOR fails (e.g., due to a page fault) after modifying the FPU registers, there is a window where the kernel could schedule out and the victim task schedule back in, without reloading its own FPU registers. This results in the FPU state intended for another task leaking into the victim task's user-visible state.

**Weaknesses/vulnerabilities present:**
- Incomplete FPU register state restoration: The `__fpu__restore_sig()` function can execute XRSTOR on behalf of a different task using `fpu_fpregs_owner_ctx`. A failed XRSTOR could modify the FPU registers without properly restoring the original state.
- Race condition: A scheduling window exists between the failed XRSTOR and the next task executing, where the FPU registers could contain incorrect values.
- Data leakage: The FPU state of a different task could leak into the user-visible state of the victim task.

**Impact of exploitation:**
- Information Disclosure: A malicious attacker might be able to leak sensitive FPU register data from other processes running on the same system. This information could be used to gain knowledge about other programs running or gain insights into the overall system state.
- Data Corruption:  The victim task's FPU state could be corrupted, leading to application crashes or unexpected program behavior.

**Attack vectors:**
-  Sibling Thread Manipulation: A malicious attacker could use a sibling thread to unmap a page and invalidate the shared TLB, while the targeted thread attempts to restore FPU registers using XRSTOR on the same page.
- Signal Handling Manipulation: The attacker might manipulate signal handlers in a way to trigger the vulnerable FPU restoration code.

**Required attacker capabilities/position:**
- The attacker needs to be able to execute code on the affected system.
-  The attacker needs a method to manipulate memory and scheduling to trigger the failure conditions of XRSTOR and exploit the resulting race condition.

The fix adds a check to see if the FPU registers being restored do not belong to the current thread, then invalidates the FPU register state to prevent data leakage and corruption upon failed restore.