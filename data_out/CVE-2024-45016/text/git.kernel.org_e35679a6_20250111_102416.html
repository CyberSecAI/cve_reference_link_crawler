

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=577d6c0619467fe90f7e8e57e45cb5bd9d936014)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=577d6c0619467fe90f7e8e57e45cb5bd9d936014)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=577d6c0619467fe90f7e8e57e45cb5bd9d936014)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=577d6c0619467fe90f7e8e57e45cb5bd9d936014)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Stephen Hemminger <stephen@networkplumber.org> | 2024-08-19 10:56:45 -0700 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-08-29 17:33:48 +0200 |
| commit | [577d6c0619467fe90f7e8e57e45cb5bd9d936014](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=577d6c0619467fe90f7e8e57e45cb5bd9d936014) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=577d6c0619467fe90f7e8e57e45cb5bd9d936014)) | |
| tree | [913a828f4c89e6176078087a37978d7d9a79fbb4](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=577d6c0619467fe90f7e8e57e45cb5bd9d936014) | |
| parent | [f7d8c2fabd39250cf2333fbf8eef67e837f90a5d](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f7d8c2fabd39250cf2333fbf8eef67e837f90a5d) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=577d6c0619467fe90f7e8e57e45cb5bd9d936014&id2=f7d8c2fabd39250cf2333fbf8eef67e837f90a5d)) | |
| download | [linux-577d6c0619467fe90f7e8e57e45cb5bd9d936014.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-577d6c0619467fe90f7e8e57e45cb5bd9d936014.tar.gz) | |

netem: fix return value if duplicate enqueue fails[ Upstream commit c07ff8592d57ed258afee5a5e04991a48dbaf382 ]
There is a bug in netem\_enqueue() introduced by
commit 5845f706388a ("net: netem: fix skb length BUG\_ON in \_\_skb\_to\_sgvec")
that can lead to a use-after-free.
This commit made netem\_enqueue() always return NET\_XMIT\_SUCCESS
when a packet is duplicated, which can cause the parent qdisc's q.qlen
to be mistakenly incremented. When this happens qlen\_notify() may be
skipped on the parent during destruction, leaving a dangling pointer
for some classful qdiscs like DRR.
There are two ways for the bug happen:
- If the duplicated packet is dropped by rootq->enqueue() and then
the original packet is also dropped.
- If rootq->enqueue() sends the duplicated packet to a different qdisc
and the original packet is dropped.
In both cases NET\_XMIT\_SUCCESS is returned even though no packets
are enqueued at the netem qdisc.
The fix is to defer the enqueue of the duplicate packet until after
the original packet has been guaranteed to return NET\_XMIT\_SUCCESS.
Fixes: 5845f706388a ("net: netem: fix skb length BUG\_ON in \_\_skb\_to\_sgvec")
Reported-by: Budimir Markovic <markovicbudimir@gmail.com>
Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
Reviewed-by: Simon Horman <horms@kernel.org>
Link: [https://patch.msgid.link/20240819175753.5151-1-stephen@networkplumber.org](https://patch.msgid.link/20240819175753.5151-1-stephen%40networkplumber.org)
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=577d6c0619467fe90f7e8e57e45cb5bd9d936014)

| -rw-r--r-- | [net/sched/sch\_netem.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/sched/sch_netem.c?id=577d6c0619467fe90f7e8e57e45cb5bd9d936014) | 47 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 29 insertions, 18 deletions

| diff --git a/net/sched/sch\_netem.c b/net/sched/sch\_netem.cindex 4ad39a4a3cf5bd..0224a92492453f 100644--- a/[net/sched/sch\_netem.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/sch_netem.c?id=f7d8c2fabd39250cf2333fbf8eef67e837f90a5d)+++ b/[net/sched/sch\_netem.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/sch_netem.c?id=577d6c0619467fe90f7e8e57e45cb5bd9d936014)@@ -446,12 +446,10 @@ static int netem\_enqueue(struct sk\_buff \*skb, struct Qdisc \*sch, struct netem\_sched\_data \*q = qdisc\_priv(sch); /\* We don't fill cb now as skb\_unshare() may invalidate it \*/ struct netem\_skb\_cb \*cb;- struct sk\_buff \*skb2;+ struct sk\_buff \*skb2 = NULL; struct sk\_buff \*segs = NULL; unsigned int prev\_len = qdisc\_pkt\_len(skb); int count = 1;- int rc = NET\_XMIT\_SUCCESS;- int rc\_drop = NET\_XMIT\_DROP;  /\* Do not fool qdisc\_drop\_all() \*/ skb->prev = NULL;@@ -480,19 +478,11 @@ static int netem\_enqueue(struct sk\_buff \*skb, struct Qdisc \*sch, skb\_orphan\_partial(skb);  /\*- \* If we need to duplicate packet, then re-insert at top of the- \* qdisc tree, since parent queuer expects that only one- \* skb will be queued.+ \* If we need to duplicate packet, then clone it before+ \* original is modified. \*/- if (count > 1 && (skb2 = skb\_clone(skb, GFP\_ATOMIC)) != NULL) {- struct Qdisc \*rootq = qdisc\_root\_bh(sch);- u32 dupsave = q->duplicate; /\* prevent duplicating a dup... \*/-- q->duplicate = 0;- rootq->enqueue(skb2, rootq, to\_free);- q->duplicate = dupsave;- rc\_drop = NET\_XMIT\_SUCCESS;- }+ if (count > 1)+ skb2 = skb\_clone(skb, GFP\_ATOMIC);  /\* \* Randomized packet corruption.@@ -504,7 +494,8 @@ static int netem\_enqueue(struct sk\_buff \*skb, struct Qdisc \*sch, if (skb\_is\_gso(skb)) { skb = netem\_segment(skb, sch, to\_free); if (!skb)- return rc\_drop;+ goto finish\_segs;+ segs = skb->next; skb\_mark\_not\_on\_list(skb); qdisc\_skb\_cb(skb)->pkt\_len = skb->len;@@ -530,7 +521,24 @@ static int netem\_enqueue(struct sk\_buff \*skb, struct Qdisc \*sch, /\* re-link segs, so that qdisc\_drop\_all() frees them all \*/ skb->next = segs; qdisc\_drop\_all(skb, sch, to\_free);- return rc\_drop;+ if (skb2)+ \_\_qdisc\_drop(skb2, to\_free);+ return NET\_XMIT\_DROP;+ }++ /\*+ \* If doing duplication then re-insert at top of the+ \* qdisc tree, since parent queuer expects that only one+ \* skb will be queued.+ \*/+ if (skb2) {+ struct Qdisc \*rootq = qdisc\_root\_bh(sch);+ u32 dupsave = q->duplicate; /\* prevent duplicating a dup... \*/++ q->duplicate = 0;+ rootq->enqueue(skb2, rootq, to\_free);+ q->duplicate = dupsave;+ skb2 = NULL; }  qdisc\_qstats\_backlog\_inc(sch, skb);@@ -601,9 +609,12 @@ static int netem\_enqueue(struct sk\_buff \*skb, struct Qdisc \*sch, }  finish\_segs:+ if (skb2)+ \_\_qdisc\_drop(skb2, to\_free);+ if (segs) { unsigned int len, last\_len;- int nb;+ int rc, nb;  len = skb ? skb->len : 0; nb = skb ? 1 : 0; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 10:22:54 +0000

