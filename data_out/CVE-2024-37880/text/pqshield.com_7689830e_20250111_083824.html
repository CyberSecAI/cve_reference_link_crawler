 ![](https://pqshield.com/wp-content/uploads/2024/05/Sub-Header-Option-2.jpg)![](data:image/svg+xml...) [![PQShield logo](https://pqshield.com/wp-content/themes/pqshield/images/PQ-Logo.svg)![PQShield logo](data:image/svg+xml...)](https://pqshield.com/ "PQShield")

* [Team PQShield](https://pqshield.com/team-pqshield/)
* [Products](https://pqshield.com/products/)
  ### Products

  + [PQSDK](https://pqshield.com/products/pqs-sw-sdk/)
  + [PQCryptoLib](https://pqshield.com/products/pqs-sw-clb/)
  + [PQCryptoLib – Embedded](https://pqshield.com/products/pqs-sw-cle/)
  + [PQPlatform – Hash](https://pqshield.com/products/pqp-hw-hbs/)
  + [PQPlatform – Lattice](https://pqshield.com/products/pqp-hw-lat/)
  + [PQPlatform – CoPro](https://pqshield.com/products/pqp-hw-cop/)
  + [PQPlatform – SubSys](https://pqshield.com/products/pqp-hw-sub/)
  + [PQPerform – Lattice](https://pqshield.com/products/pqf-hw-lat/)
  + [Product Security](https://pqshield.com/products/product-security/)
* [Markets](https://pqshield.com/markets/)
  ### Markets

  + [Semiconductors and Manufacturing](https://pqshield.com/markets/semiconductors-manufacturing/)
  + [Identity and Paymentech](https://pqshield.com/markets/identity-paymentech/)
  + [Military and Aerospace](https://pqshield.com/markets/military-aerospace/)
  + [System Integrators](https://pqshield.com/markets/system-integrators/)
  + [Automotive](https://pqshield.com/markets/automotive/)
  + [Industrial IoT](https://pqshield.com/markets/industrial-iot/)
  + [Network & Telecommunications](https://pqshield.com/markets/network-telecommunications/)
  + [Enterprise Platforms](https://pqshield.com/markets/enterprise-platforms/)
* [Publications](https://pqshield.com/publications/)
* [News](https://pqshield.com/news/)
* [Partners](https://pqshield.com/partners/)
* [Careers](https://pqshield.com/careers/)
* [Contact](https://pqshield.com/contact-us/)
[![Twitter](https://pqshield.com/wp-content/themes/pqshield/images/icons/Social-X.svg?v=1)![Twitter](data:image/svg+xml...)](https://twitter.com/PqShield)[![LinkedIn](https://pqshield.com/wp-content/themes/pqshield/images/icons/Social-LI.svg?v=1)![LinkedIn](data:image/svg+xml...)](https://www.linkedin.com/company/pqshield/)[![Youtube](https://pqshield.com/wp-content/themes/pqshield/images/icons/Social-YT.svg?v=1)![Youtube](data:image/svg+xml...)](https://www.youtube.com/channel/UCoiZ4TzLcBNpNtXyJI7-cOg) [![PQShield logo](https://pqshield.com/wp-content/themes/pqshield/images/PQ-Logo.svg)![PQShield logo](data:image/svg+xml...)](https://pqshield.com/ "PQShield")
##

* [Home](https://pqshield.com/)
* [Team PQShield](https://pqshield.com/team-pqshield/)
* [Products](https://pqshield.com/products/)
  + [PQSDK](https://pqshield.com/products/pqs-sw-sdk/)
  + [PQCryptoLib](https://pqshield.com/products/pqs-sw-clb/)
  + [PQCryptoLib – Embedded](https://pqshield.com/products/pqs-sw-cle/)
  + [PQPlatform – Hash](https://pqshield.com/products/pqp-hw-hbs/)
  + [PQPlatform – Lattice](https://pqshield.com/products/pqp-hw-lat/)
  + [PQPlatform – CoPro](https://pqshield.com/products/pqp-hw-cop/)
  + [PQPlatform – SubSys](https://pqshield.com/products/pqp-hw-sub/)
  + [PQPerform – Lattice](https://pqshield.com/products/pqf-hw-lat/)
  + [Product Security](https://pqshield.com/products/product-security/)
* [Markets](https://pqshield.com/markets/)
  + [Semiconductors and Manufacturing](https://pqshield.com/markets/semiconductors-manufacturing/)
  + [Identity and Paymentech](https://pqshield.com/markets/identity-paymentech/)
  + [Military and Aerospace](https://pqshield.com/markets/military-aerospace/)
  + [System Integrators](https://pqshield.com/markets/system-integrators/)
  + [Automotive](https://pqshield.com/markets/automotive/)
  + [Industrial IoT](https://pqshield.com/markets/industrial-iot/)
  + [Network & Telecommunications](https://pqshield.com/markets/network-telecommunications/)
  + [Enterprise Platforms](https://pqshield.com/markets/enterprise-platforms/)
* [Publications](https://pqshield.com/publications/)
* [News](https://pqshield.com/news/)
* [Partners](https://pqshield.com/partners/)
* [Careers](https://pqshield.com/careers/)
* [Contact](https://pqshield.com/contact-us/)
# PQShield plugs timing leaks in Kyber / ML-KEM to improve PQC implementation maturity

  Back Topics: Comment Date: 03/06/2024![](https://pqshield.com/wp-content/uploads/2024/06/PQS_News_Building-Securely.png)![](data:image/svg+xml...)

Compilers can suddenly and silently introduce implementation vulnerabilities in yesterday’s secure code. PQShield recently discovered an instance of this problem in the popular ML-KEM (Kyber) reference implementation, and it has been resolved with the help of Peter Schwabe and the Kyber team. In this article, we investigate the issue in detail, and take a deep-dive into its root cause, as well as explaining how the problem was resolved.

It’s about time

Even the most secure cryptographic algorithm can be rendered ineffective if its *implementation* contains vulnerabilities. A key part of implementation security is resistance against side-channel attacks, which exploit the physical side-effects of cryptographic computations to infer sensitive information.

To remain secure against side-channel attacks, cryptographic algorithms must be implemented such that no attacker-observable effect of their execution depends on the secrets they process. In this blog post, we’re concerned with a particular side channel that’s observable in almost all cryptographic deployment scenarios: *time*.

Constant time cryptography

Let’s assume we want to deploy a cryptographic algorithm across a wide range of platforms. How would a skilled cryptography engineer write portable code that doesn’t leak its secrets through timing?

Consider a toy example. Let’s say you have to write a function that expands a 256-bit string msg into an array r of 256 integers of 16 bits. In particular, r[j] needs to be populated with some constant if the j-th bit of msg is set, and zero otherwise.

A novice cryptography engineer might come up with a C routine that’s something like this:

![](https://pqshield.com/wp-content/uploads/2024/06/blog_01_insec_source.png)![](data:image/svg+xml...)

It’s good, but (regarding our earlier side-channel discussion) there is an issue with this piece of code. Its control flow (i.e, the sequence of operations it performs) depends on the bits of msg. The part of the code where the control flow diverges is marked in red.

Does that matter? Well, that depends on how this particular function is used: it *does* matter if msg is supposed to be secret, since it is effectively getting encoded, bit-by-bit, in the control flow of the program.

Let’s write a secure version of this function.

To take the secret bits into account without branching on them, let’s use a common trick in cryptography engineering: bit masks.  We can negate the message bit to produce a mask that is either all-zeros (bit j is zero) or all-ones (bit j is one). We can then use the mask to either zero out the constant (bit j is zero) or load it as-is (bit j is one). Here is the complete function:

![](https://pqshield.com/wp-content/uploads/2024/06/blog_02_sec_source.png)![](data:image/svg+xml...)

Notice that the control flow of **expand\_secure** is independent of the bits of msg. The assignment to r happens regardless of the message bit, and the mask ensures the correct data flow. So, all is well! Right?

Compiler woes

When a developer writes code in a portable high-level language like C, C++, or Rust, the source code is not executed directly on the machine. Instead, it is first compiled into assembly or machine code by a compiler, such as GCC or Clang for C/C++, so that it can run natively on the specific target machine.

Compilers not only perform this *transformation* to machine code, they also have several *optimization* passes. Well-known examples are loop unrolling and the removal of code that does not affect the program’s output. But there are many, [many](https://github.com/llvm/llvm-project/tree/main/llvm/lib/Target/X86) more. Modern compilers have become very proficient at performing optimizations to generate fast machine code from portable high-level source code.

Let’s take a look at a state-of-the-art mainstream compiler in action. Returning to our toy example, let’s compile the insecure **expand\_insecure** for x86 using the most recent version of Clang (v18), optimizing for code size (-Os):

![](https://pqshield.com/wp-content/uploads/2024/06/blog_03_insecure_assembly.png)

The vulnerability we identified before obviously hasn’t magically disappeared. It can be observed in the inner loop, and is marked in red. The move of 1665 (our choice of constant) into edx is either skipped or not skipped, depending on the relevant bit of msg.

Now let’s compile the secure **expand\_secure** implementation and see how it differs – showing only the inner loop for brevity:

![](https://pqshield.com/wp-content/uploads/2024/06/blog_04_secure_assembly.png)![](data:image/svg+xml...)

… there must have been a mix-up! Really? Isn’t it the same assembly? What happened?

It appears that Clang eagerly:

1. noticed that the mask is either all-zero or all-one,
2. inferred that the masked load is therefore either zero or CONSTANT,
3. emitted a branch, because it is heuristically the fastest on x86

So, we can see here that the compiler can *silently* undo measures taken by the skilled implementer. This behaviour is not limited to the configuration above (clang -Os). If you [play around](https://godbolt.org/#z:OYLghAFBqRAWIDGB7AJgUwKKoJYBdkAnAGhxAgDMcAbdAOwEMBbdEAcgEY3iLk68Ayoga0QHACw8%2BeAKoBndAAUAHuwAM3AFZji1BnVAB9Y4mILaiPDj7l6qAMLJqAVyZ0QAZg/E7AGRx06AByrgBG6IRikgAOyHL41nSOLm6e3rHxVnz%2BgSFM4ZESZugWWXQCeAyEeMmu7l7FpYkVVXg5wWERUWaV1bWpDXK9bQEd%2BV0SAJRmyM6EiKxsAKQATB4BiC4YANRLHvZDuPwAdHB7mEtqAIKXN2sYVIHbAgCSAFqY2ysArABst6sPA9Rtt7AB5IICAAqVyCUO2HF%2Bv2%2BAOuADdkDhUNt0MpovpUIYFIg5ugIAE8IjDHhtoQlt8AEKvD70gAixG2KDoQ22zgpAA5qdsmHJgPSGR4VmzJgCAOwM27bXncnDAQLYinbHDETR7BXXJUUqk0pgMOQAaz1qKuSt4hHJe1Zaj1OD29mZmAA9PyXasFSsGZNdvLFUrtnaILqPE69VH7D6PAzdQG/UGliGDWGlaaLbto9sALTk/jGyZQEVixmu76svMXDyfTQyla/DgyxOhrN0xn8gBUroDupredrOfNuxboIh0NhUKtmaV6dZoaXctZbGm1HY3247k43GQ7Hs2zks3m6AnHi4xDw6g3xHgSGQTGiNAipHIKBfb8iiE2%2BmAalCGcOhzR4Gg8AiORyFCO9iFCAIqgAT3Ya8EMYQgkLBUJNHQSxUO4L8WH4ME6GoFC2A0YgMFCZxgHsERqGg/dqPQU0DFESjuFwQg8KsNF0GYqjcTw5xIII0h%2BBKODqBwUJCGQxwMDgvBCBwJgJIEwhQjidBWTYgDZIMO9pgoPRgDkAA1HB0AAdzBaJ6Ak3h%2BCEERWCKFzZAUFQ4O0DhdAAkBjEMUxZNCaDIGmZBojKZiCzBOQDy0tSMEiiBpnxXJmEWbZlH5X4C1%2BcROT0AxtggVSQPNIMEqSxo%2BMSWw6AcJw6h0PxRjyAodAyBI%2BH6dwAr6sp2m6iYGssZphkGnRzEavgWmqMbOkKHpWlmgKhlaFbxkKaZTzmBYxE3bddzgw82DygqipK/9ysq4DQNqxLuFvLjpkfL9X1oEgyAgb6fyQe7AKq0DwOoSDCGgiBYK4%2BDEMwiT0OQ7DcPwliiPoPBSPIuCaLohjqCYiSMHY4BOKonjGoEoTuBEklxJYilpPh8KFMwpTFio1T1M0iIdIUfTyaM0APp4cyrJs%2BzHL3a8vLc0RPOkeQlFUeHtG8MqjBMXQ5PS6LYsSeKwWvZAUqxQTwAy4gsuCHL2GuwritKgCKrBmrtlN7h5qmmwIDsTafBa3aeuGuJ%2BqSNrUnDzJElDibfbKJaamjobJuT4YE7W7a%2BjTuas661aTpmI6PNOtgd2IPcqMup3btdh6PaDb2bxMh8EEB36PwB58fq6P9taA6qIahmG4aolGkZYqesJwviJKxkiyIoqn0Fo%2BjGOY68ycM7nuJwXiptpuCGbExZrxZrc2bkjmkK5lS1I0litMFvSDI4gIxY0UzJesuyHJORYgrYQStJBeVVr5DWIBZSBWMiFMK%2BtraGziuwBKKxCwUDoMgAsAlLBEBwAAL3QMlCIqUrZRVtvoe2LBHb5WdndbW7snqezBBg7BuC%2BIEOIT7EoC13ABxakHTquRi6x0jkHEa8ci57Tmnwv25QZr5y2vIzOO0ZFh3WnnFI6dc4jFEbItspdzwl2vlXGuB46E3RdiDZh1UW7sJwXgggakeFt3Fl9PuP4e5dwHiDYe4MqCQygjBOCs9kaIznujd614l44xXvjdehMt6kw/hTfe1FD40ytvDM%2BTNL5SWvlRdmik0AZN5s/a8r9dLC0Ml/duZkGAWX/jLIB8tpCKw8uAlWPl1ZUW0L8OBOtQp6wisg4gMVUFsASh4TBHDnHcJIRMi2aVxl2yCA7K69CG62MevYr2sz5lcNcUspOTVBGtR0R1EOGiJpSIGso22EdRq3Jzqo6aG1HlnMWoXAxmi9FBz0dnEuh0TFGLMedeGddtk2KYXs56BzthHPwSct6JlpjmjEGoNQuh2DiEhbXdgPsQA4vej/aYWl4g2HEEAA%3D%3D) with compilers and options, you’ll notice this compiler-induced security regression in **expand\_secure** for at least:

* Versions: x86 Clang 15, 16, 17 and 18
* Options: -Os, -O1,  -O2 -fno-vectorize and -O3 -fno-vectorize

In the past, some [other](https://www.cl.cam.ac.uk/~rja14/Papers/whatyouc.pdf) [secure](https://electricdusk.com/cmov-conversion.html) [source](https://leslyann-daniel.fr/ressources/papers/2020_SP_binsecrel.pdf) [patterns](https://core.ac.uk/download/pdf/148026376.pdf) have also been shown to be compiled into vulnerable machine code.

What about ML-KEM?

ML-KEM (Kyber) is the soon-to-be standard for post-quantum key encapsulation (FIPS-203). It turns out that the routine we described earlier isn’t just a toy example; it’s actually an important routine in ML-KEM, and it’s needed in both key encapsulation and decapsulation. In the reference implementation, this function is called poly\_frommsg. You can inspect it [here](https://github.com/pq-crystals/kyber/blob/b628ba78711bc28327dc7d2d5c074a00f061884e/ref/poly.c#L166). Looks good?

It does! However, having loaded ‘[Chekhov’s gun](https://en.wikipedia.org/wiki/Chekhov%27s_gun)’ with the previous section, it’s time to fire it.

The code pattern corresponds to the **expand\_secure** implementation. For the compiler options we mentioned, Clang emits a vulnerable secret-dependent branch in this part of the ML-KEM reference code.

So just how bad is this?

* On the one hand, the msg argument is a critical security parameter in both encapsulation and decapsulation.
* On the other hand, there’s *one* vulnerable branch. In decapsulation, poly\_frommsg is used *once*. The whole decapsulation takes *more than 100K cycles.* Surely the timing difference produced by this one branch is too small to matter?

Well, there are two answers. The first is that research shows that sophisticated local attackers can perform [high-resolution cache attacks](https://antoonpurnal.github.io/files/pdf/PrimeScope.pdf), target the [branch predictor](https://www.cs.ucr.edu/~nael/pubs/asplos18.pdf) to learn which branches are taken, or [slow down the library](https://eprint.iacr.org/2015/1141.pdf) to amplify the timing difference. So the prudent approach is to patch.

The second answer is that, *actually*, measuring the time it takes for a complete decapsulation is enough for an attacker to piece together the key.

**To back up this claim, we provide a** [practical demo](https://github.com/antoonpurnal/clangover) **that shows the role of the timing vulnerability in the recovery of an ML-KEM 512 secret key**. The demo terminates successfully in less than 10 minutes on the author’s laptop.

![](https://pqshield.com/wp-content/uploads/2024/06/blog_05_poc.png)![](data:image/svg+xml...)

Affected Libraries

In summary: while not all compilers, options and platforms are affected, *if a given binary is affected, the security impact may be critical*. Therefore, the conservative approach is to take this issue seriously, and look out for patches from your cryptography provider.

The [reference implementation](https://github.com/pq-crystals/kyber) has been patched by implementing the relevant conditional move as a function in a separate file. This change prevents Clang from recognizing the binary nature of the condition flag, and hence from applying the optimization.

We’ve been coordinating with libraries that integrate the reference implementation. We notified [liboqs](https://github.com/open-quantum-safe/liboqs), [aws-lc](https://github.com/aws/aws-lc), [pq-code-package](https://github.com/pq-code-package) and [WolfSSL](https://github.com/wolfSSL/wolfssl) in advance through their private vulnerability disclosure process. We also informed [PQClean](https://github.com/PQClean/PQClean) and [rustpq/pqcrypto](https://github.com/rustpq/pqcrypto), together with a public disclosure of the issue.

It’s important to note that this does not rule out the possibility that other libraries, which are based on the reference implementation but do not use the poly\_frommsg function verbatim, may be vulnerable – either now or in the future.

We’d like to thank Peter Schwabe (and the Kyber team) for their role in the swift and collaborative disclosure process, helping us coordinate with the wider PQC ecosystem.

Implementation Security Matters

PQShield cares about advancing PQC implementation maturity inside and outside of our products. Timing vulnerability testing is included in [all three PQShield security profiles](https://pqshield.com/wp-content/uploads/2024/03/PQS_Security_2pp-A4_Digital.pdf) – *Cloud*, *Edge*, and *Government* – and features several complementary **post-compilation** constant-time checks.

Our own quantum-safe [software products](https://pqshield.com/products/) (PQCryptoLib, PQCryptoLib Embedded, and PQSDK) were never affected by this issue. As providers of post-quantum solutions, our goal is to stay one step ahead of the attackers, and we hope that with our focus on research, development, and implementation, we can continue to contribute solutions to potential vulnerabilities.

 [## Sign up for our newsletter

![](https://pqshield.com/wp-content/themes/pqshield/images/any-icon.php?icon=Arrow-Down-Newsletter.svg&colour=DarkBlue&property=stroke)![](data:image/svg+xml...)](#newsletter-signup)    [![back-to-top](https://pqshield.com/wp-content/themes/pqshield/images/any-icon.php?icon=back-to-top-icon.svg&colour=Gold&color2=White)![back-to-top](data:image/svg+xml...)](#page) ![PQShield logo](https://pqshield.com/wp-content/uploads/2024/04/PQ-Logo.png)![PQShield logo](data:image/svg+xml...)PQShield comprises a world-class collaboration of post-quantum cryptographers, engineers, and operators. We’ve helped shape all of the first international PQC NIST standards, and we were the first cybersecurity company to develop quantum-safe cryptography on chips, in applications, and in the cloud.![](https://pqshield.com/wp-content/uploads/2024/10/ISOIEC-Footer-x2_Oct24.png)![](data:image/svg+xml...)
#### Links

* [Team PQShield](https://pqshield.com/team-pqshield/)
* [Products](https://pqshield.com/products/)
* [Markets](https://pqshield.com/markets/)
* [Publications](https://pqshield.com/publications/)
* [News](https://pqshield.com/news/)
* [Partners](https://pqshield.com/partners/)
* [Careers](https://pqshield.com/careers/)
* [Contact](https://pqshield.com/contact-us/)
* [Security, Quality & Legal](https://pqshield.com/security-quality-legal/)
* [Report a Bug or Vulnerability](https://content.pqshield.com/productreport)
#### Markets

* [Semiconductors and Manufacturing](https://pqshield.com/markets/)
* [Military and Aerospace](https://pqshield.com/markets/)
* [Identity and Paymentech](https://pqshield.com/markets/)
* [System Integrators](https://pqshield.com/markets/)
* [Network & Telecommunications](https://pqshield.com/markets/)
* [Automotive](https://pqshield.com/markets/)
* [Industrial IoT](https://pqshield.com/markets/)
* [Enterprise Platforms](https://pqshield.com/markets/)
#### Products

* [PQSDK](https://pqshield.com/products/pqs-sw-sdk/)
* [PQCryptoLib](https://pqshield.com/products/pqs-sw-clb/)
* [PQCryptoLib – Embedded](https://pqshield.com/products/pqs-sw-cle/)
* [PQPlatform – Hash](https://pqshield.com/products/pqp-hw-hbs/)
* [PQPlatform – Lattice](https://pqshield.com/products/pqp-hw-lat/)
* [PQPlatform – CoPro](https://pqshield.com/products/pqp-hw-cop/)
* [PQPlatform – SubSys](https://pqshield.com/products/pqp-hw-sub/)
* [PQPerform – Lattice](https://pqshield.com/products/pqf-hw-lat/)
* [Product Security](https://pqshield.com/products/product-security/)

* [Security, Quality & Legal](https://pqshield.com/security-quality-legal/)
© PQShield Ltd 2025 [![Twitter](https://pqshield.com/wp-content/themes/pqshield/images/icons/Social-X.svg?v=1)![Twitter](data:image/svg+xml...)](https://twitter.com/PqShield) [![LinkedIn](https://pqshield.com/wp-content/themes/pqshield/images/icons/Social-LI.svg?v=1)![LinkedIn](data:image/svg+xml...)](https://www.linkedin.com/company/pqshield/) [![Youtube](https://pqshield.com/wp-content/themes/pqshield/images/icons/Social-YT.svg?v=1)![Youtube](data:image/svg+xml...)](https://www.youtube.com/channel/UCoiZ4TzLcBNpNtXyJI7-cOg)[![Aubergine 262 ltd. Logo](https://pqshield.com/wp-content/themes/pqshield/images/aubergine-logo.svg)![Aubergine 262 ltd. Logo](data:image/svg+xml...)](https://www.aubergine262.com/)       ![](https://ws.zoominfo.com/pixel/622f77f9304c31001cf3636a)