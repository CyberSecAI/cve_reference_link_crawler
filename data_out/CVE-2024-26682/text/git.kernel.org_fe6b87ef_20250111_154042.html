

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=ea88bde8e3fefbe4268f6991375dd629895a090a)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=ea88bde8e3fefbe4268f6991375dd629895a090a)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ea88bde8e3fefbe4268f6991375dd629895a090a)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=ea88bde8e3fefbe4268f6991375dd629895a090a)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Johannes Berg <johannes.berg@intel.com> | 2024-01-29 13:14:14 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-02-16 19:14:19 +0100 |
| commit | [ea88bde8e3fefbe4268f6991375dd629895a090a](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ea88bde8e3fefbe4268f6991375dd629895a090a) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=ea88bde8e3fefbe4268f6991375dd629895a090a)) | |
| tree | [c07c33fd3fabcf45fba380be72b41abdc2ab084c](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=ea88bde8e3fefbe4268f6991375dd629895a090a) | |
| parent | [ce112c941c2b172afba3e913a90c380647d53975](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ce112c941c2b172afba3e913a90c380647d53975) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=ea88bde8e3fefbe4268f6991375dd629895a090a&id2=ce112c941c2b172afba3e913a90c380647d53975)) | |
| download | [linux-ea88bde8e3fefbe4268f6991375dd629895a090a.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-ea88bde8e3fefbe4268f6991375dd629895a090a.tar.gz) | |

wifi: mac80211: improve CSA/ECSA connection refusal[ Upstream commit 35e2385dbe787936c793d70755a5177d267a40aa ]
As mentioned in the previous commit, we pretty quickly found
that some APs have ECSA elements stuck in their probe response,
so using that to not attempt to connect while CSA is happening
we never connect to such an AP.
Improve this situation by checking more carefully and ignoring
the ECSA if cfg80211 has previously detected the ECSA element
being stuck in the probe response.
Additionally, allow connecting to an AP that's switching to a
channel it's already using, unless it's using quiet mode. In
this case, we may just have to adjust bandwidth later. If it's
actually switching channels, it's better not to try to connect
in the middle of that.
Reported-by: coldolt <andypalmadi@gmail.com>
Closes: https://lore.kernel.org/linux-wireless/CAJvGw+DQhBk\_mHXeu6RTOds5iramMW2FbMB01VbKRA4YbHHDTA@mail.gmail.com/
Fixes: c09c4f31998b ("wifi: mac80211: don't connect to an AP while it's in a CSA process")
Reviewed-by: Miriam Rachel Korenblit <miriam.rachel.korenblit@intel.com>
Link: [https://msgid.link/20240129131413.cc2d0a26226e.I682c016af76e35b6c47007db50e8554c5a426910@changeid](https://msgid.link/20240129131413.cc2d0a26226e.I682c016af76e35b6c47007db50e8554c5a426910%40changeid)
Signed-off-by: Johannes Berg <johannes.berg@intel.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=ea88bde8e3fefbe4268f6991375dd629895a090a)

| -rw-r--r-- | [net/mac80211/mlme.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/mac80211/mlme.c?id=ea88bde8e3fefbe4268f6991375dd629895a090a) | 103 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 76 insertions, 27 deletions

| diff --git a/net/mac80211/mlme.c b/net/mac80211/mlme.cindex dcdaab19efbd59..bbe36d87ac5939 100644--- a/[net/mac80211/mlme.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/mac80211/mlme.c?id=ce112c941c2b172afba3e913a90c380647d53975)+++ b/[net/mac80211/mlme.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/mac80211/mlme.c?id=ea88bde8e3fefbe4268f6991375dd629895a090a)@@ -7288,6 +7288,75 @@ out\_err: return err; } +static bool ieee80211\_mgd\_csa\_present(struct ieee80211\_sub\_if\_data \*sdata,+ const struct cfg80211\_bss\_ies \*ies,+ u8 cur\_channel, bool ignore\_ecsa)+{+ const struct element \*csa\_elem, \*ecsa\_elem;+ struct ieee80211\_channel\_sw\_ie \*csa = NULL;+ struct ieee80211\_ext\_chansw\_ie \*ecsa = NULL;++ if (!ies)+ return false;++ csa\_elem = cfg80211\_find\_elem(WLAN\_EID\_CHANNEL\_SWITCH,+ ies->data, ies->len);+ if (csa\_elem && csa\_elem->datalen == sizeof(\*csa))+ csa = (void \*)csa\_elem->data;++ ecsa\_elem = cfg80211\_find\_elem(WLAN\_EID\_EXT\_CHANSWITCH\_ANN,+ ies->data, ies->len);+ if (ecsa\_elem && ecsa\_elem->datalen == sizeof(\*ecsa))+ ecsa = (void \*)ecsa\_elem->data;++ if (csa && csa->count == 0)+ csa = NULL;+ if (csa && !csa->mode && csa->new\_ch\_num == cur\_channel)+ csa = NULL;++ if (ecsa && ecsa->count == 0)+ ecsa = NULL;+ if (ecsa && !ecsa->mode && ecsa->new\_ch\_num == cur\_channel)+ ecsa = NULL;++ if (ignore\_ecsa && ecsa) {+ sdata\_info(sdata,+ "Ignoring ECSA in probe response - was considered stuck!\n");+ return csa;+ }++ return csa || ecsa;+}++static bool ieee80211\_mgd\_csa\_in\_process(struct ieee80211\_sub\_if\_data \*sdata,+ struct cfg80211\_bss \*bss)+{+ u8 cur\_channel;+ bool ret;++ cur\_channel = ieee80211\_frequency\_to\_channel(bss->channel->center\_freq);++ rcu\_read\_lock();+ if (ieee80211\_mgd\_csa\_present(sdata,+ rcu\_dereference(bss->beacon\_ies),+ cur\_channel, false)) {+ ret = true;+ goto out;+ }++ if (ieee80211\_mgd\_csa\_present(sdata,+ rcu\_dereference(bss->proberesp\_ies),+ cur\_channel, bss->proberesp\_ecsa\_stuck)) {+ ret = true;+ goto out;+ }++ ret = false;+out:+ rcu\_read\_unlock();+ return ret;+}+ /\* config hooks \*/ int ieee80211\_mgd\_auth(struct ieee80211\_sub\_if\_data \*sdata, struct cfg80211\_auth\_request \*req)@@ -7296,7 +7365,6 @@ int ieee80211\_mgd\_auth(struct ieee80211\_sub\_if\_data \*sdata, struct ieee80211\_if\_managed \*ifmgd = &sdata->u.mgd; struct ieee80211\_mgd\_auth\_data \*auth\_data; struct ieee80211\_link\_data \*link;- const struct element \*csa\_elem, \*ecsa\_elem; u16 auth\_alg; int err; bool cont\_auth;@@ -7339,21 +7407,10 @@ int ieee80211\_mgd\_auth(struct ieee80211\_sub\_if\_data \*sdata, if (ifmgd->assoc\_data) return -EBUSY; - rcu\_read\_lock();- csa\_elem = ieee80211\_bss\_get\_elem(req->bss, WLAN\_EID\_CHANNEL\_SWITCH);- ecsa\_elem = ieee80211\_bss\_get\_elem(req->bss,- WLAN\_EID\_EXT\_CHANSWITCH\_ANN);- if ((csa\_elem &&- csa\_elem->datalen == sizeof(struct ieee80211\_channel\_sw\_ie) &&- ((struct ieee80211\_channel\_sw\_ie \*)csa\_elem->data)->count != 0) ||- (ecsa\_elem &&- ecsa\_elem->datalen == sizeof(struct ieee80211\_ext\_chansw\_ie) &&- ((struct ieee80211\_ext\_chansw\_ie \*)ecsa\_elem->data)->count != 0)) {- rcu\_read\_unlock();+ if (ieee80211\_mgd\_csa\_in\_process(sdata, req->bss)) { sdata\_info(sdata, "AP is in CSA process, reject auth\n"); return -EINVAL; }- rcu\_read\_unlock();  auth\_data = kzalloc(sizeof(\*auth\_data) + req->auth\_data\_len + req->ie\_len, GFP\_KERNEL);@@ -7662,7 +7719,7 @@ int ieee80211\_mgd\_assoc(struct ieee80211\_sub\_if\_data \*sdata, struct ieee80211\_local \*local = sdata->local; struct ieee80211\_if\_managed \*ifmgd = &sdata->u.mgd; struct ieee80211\_mgd\_assoc\_data \*assoc\_data;- const struct element \*ssid\_elem, \*csa\_elem, \*ecsa\_elem;+ const struct element \*ssid\_elem; struct ieee80211\_vif\_cfg \*vif\_cfg = &sdata->vif.cfg; ieee80211\_conn\_flags\_t conn\_flags = 0; struct ieee80211\_link\_data \*link;@@ -7685,23 +7742,15 @@ int ieee80211\_mgd\_assoc(struct ieee80211\_sub\_if\_data \*sdata,  cbss = req->link\_id < 0 ? req->bss : req->links[req->link\_id].bss; - rcu\_read\_lock();- ssid\_elem = ieee80211\_bss\_get\_elem(cbss, WLAN\_EID\_SSID);- if (!ssid\_elem || ssid\_elem->datalen > sizeof(assoc\_data->ssid)) {- rcu\_read\_unlock();+ if (ieee80211\_mgd\_csa\_in\_process(sdata, cbss)) {+ sdata\_info(sdata, "AP is in CSA process, reject assoc\n"); kfree(assoc\_data); return -EINVAL; } - csa\_elem = ieee80211\_bss\_get\_elem(cbss, WLAN\_EID\_CHANNEL\_SWITCH);- ecsa\_elem = ieee80211\_bss\_get\_elem(cbss, WLAN\_EID\_EXT\_CHANSWITCH\_ANN);- if ((csa\_elem &&- csa\_elem->datalen == sizeof(struct ieee80211\_channel\_sw\_ie) &&- ((struct ieee80211\_channel\_sw\_ie \*)csa\_elem->data)->count != 0) ||- (ecsa\_elem &&- ecsa\_elem->datalen == sizeof(struct ieee80211\_ext\_chansw\_ie) &&- ((struct ieee80211\_ext\_chansw\_ie \*)ecsa\_elem->data)->count != 0)) {- sdata\_info(sdata, "AP is in CSA process, reject assoc\n");+ rcu\_read\_lock();+ ssid\_elem = ieee80211\_bss\_get\_elem(cbss, WLAN\_EID\_SSID);+ if (!ssid\_elem || ssid\_elem->datalen > sizeof(assoc\_data->ssid)) { rcu\_read\_unlock(); kfree(assoc\_data); return -EINVAL; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 15:39:19 +0000

