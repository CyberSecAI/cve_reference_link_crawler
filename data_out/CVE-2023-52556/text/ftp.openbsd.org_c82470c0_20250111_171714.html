untrusted comment: verify with openbsd-74-base.pub
RWRoyQmAD08ajRQyxUXGRdaJIVDydrrfAmdidIDLmAQPKc4cUuKzIOkWvMCcWWS3LFJBN2JishP4g4qDbOiqlcRqvLU21Q1/vAs=
OpenBSD 7.4 errata 009, December 10, 2023:
A race condition between pf(4)'s processing of packets and expiration of
packet states may cause a kernel panic.
Apply by doing:
signify -Vep /etc/signify/openbsd-74-base.pub -x 009\_pf.patch.sig \
-m - | (cd /usr/src && patch -p0)
And then rebuild and install a new kernel:
KK=`sysctl -n kern.osversion | cut -d# -f1`
cd /usr/src/sys/arch/`machine`/compile/$KK
make obj
make config
make
make install
Index: sys/net/pf.c
===================================================================
RCS file: /cvs/src/sys/net/pf.c,v
retrieving revision 1.1186
diff -u -p -r1.1186 pf.c
--- sys/net/pf.c 8 Sep 2023 13:40:52 -0000 1.1186
+++ sys/net/pf.c 4 Dec 2023 21:04:47 -0000
@@ -469,6 +469,15 @@ pf\_state\_list\_remove(struct pf\_state\_lis
pf\_state\_unref(st); /\* list no longer references the state \*/
}
+void
+pf\_update\_state\_timeout(struct pf\_state \*st, int to)
+{
+ mtx\_enter(&st->mtx);
+ if (st->timeout != PFTM\_UNLINKED)
+ st->timeout = to;
+ mtx\_leave(&st->mtx);
+}
+
int
pf\_src\_connlimit(struct pf\_state \*\*stp)
{
@@ -549,7 +558,7 @@ pf\_src\_connlimit(struct pf\_state \*\*stp)
((\*stp)->rule.ptr->flush &
PF\_FLUSH\_GLOBAL ||
(\*stp)->rule.ptr == st->rule.ptr)) {
- st->timeout = PFTM\_PURGE;
+ pf\_update\_state\_timeout(st, PFTM\_PURGE);
pf\_set\_protostate(st, PF\_PEER\_BOTH,
TCPS\_CLOSED);
killed++;
@@ -563,7 +572,7 @@ pf\_src\_connlimit(struct pf\_state \*\*stp)
}
/\* kill this state \*/
- (\*stp)->timeout = PFTM\_PURGE;
+ pf\_update\_state\_timeout(\*stp, PFTM\_PURGE);
pf\_set\_protostate(\*stp, PF\_PEER\_BOTH, TCPS\_CLOSED);
return (1);
}
@@ -1758,10 +1767,13 @@ pf\_remove\_state(struct pf\_state \*st)
{
PF\_ASSERT\_LOCKED();
- if (st->timeout == PFTM\_UNLINKED)
+ mtx\_enter(&st->mtx);
+ if (st->timeout == PFTM\_UNLINKED) {
+ mtx\_leave(&st->mtx);
return;
-
+ }
st->timeout = PFTM\_UNLINKED;
+ mtx\_leave(&st->mtx);
/\* handle load balancing related tasks \*/
pf\_postprocess\_addr(st);
@@ -1816,7 +1828,8 @@ pf\_remove\_divert\_state(struct pf\_state\_k
sist->dst.state < TCPS\_FIN\_WAIT\_2) {
pf\_set\_protostate(sist, PF\_PEER\_BOTH,
TCPS\_TIME\_WAIT);
- sist->timeout = PFTM\_TCP\_CLOSED;
+ pf\_update\_state\_timeout(sist,
+ PFTM\_TCP\_CLOSED);
sist->expire = getuptime();
}
sist->state\_flags |= PFSTATE\_INP\_UNLINKED;
@@ -5036,18 +5049,18 @@ pf\_tcp\_track\_full(struct pf\_pdesc \*pd, s
(\*stp)->expire = getuptime();
if (src->state >= TCPS\_FIN\_WAIT\_2 &&
dst->state >= TCPS\_FIN\_WAIT\_2)
- (\*stp)->timeout = PFTM\_TCP\_CLOSED;
+ pf\_update\_state\_timeout(\*stp, PFTM\_TCP\_CLOSED);
else if (src->state >= TCPS\_CLOSING &&
dst->state >= TCPS\_CLOSING)
- (\*stp)->timeout = PFTM\_TCP\_FIN\_WAIT;
+ pf\_update\_state\_timeout(\*stp, PFTM\_TCP\_FIN\_WAIT);
else if (src->state < TCPS\_ESTABLISHED ||
dst->state < TCPS\_ESTABLISHED)
- (\*stp)->timeout = PFTM\_TCP\_OPENING;
+ pf\_update\_state\_timeout(\*stp, PFTM\_TCP\_OPENING);
else if (src->state >= TCPS\_CLOSING ||
dst->state >= TCPS\_CLOSING)
- (\*stp)->timeout = PFTM\_TCP\_CLOSING;
+ pf\_update\_state\_timeout(\*stp, PFTM\_TCP\_CLOSING);
else
- (\*stp)->timeout = PFTM\_TCP\_ESTABLISHED;
+ pf\_update\_state\_timeout(\*stp, PFTM\_TCP\_ESTABLISHED);
/\* Fall through to PASS packet \*/
} else if ((dst->state < TCPS\_SYN\_SENT ||
@@ -5229,18 +5242,18 @@ pf\_tcp\_track\_sloppy(struct pf\_pdesc \*pd,
(\*stp)->expire = getuptime();
if (src->state >= TCPS\_FIN\_WAIT\_2 &&
dst->state >= TCPS\_FIN\_WAIT\_2)
- (\*stp)->timeout = PFTM\_TCP\_CLOSED;
+ pf\_update\_state\_timeout(\*stp, PFTM\_TCP\_CLOSED);
else if (src->state >= TCPS\_CLOSING &&
dst->state >= TCPS\_CLOSING)
- (\*stp)->timeout = PFTM\_TCP\_FIN\_WAIT;
+ pf\_update\_state\_timeout(\*stp, PFTM\_TCP\_FIN\_WAIT);
else if (src->state < TCPS\_ESTABLISHED ||
dst->state < TCPS\_ESTABLISHED)
- (\*stp)->timeout = PFTM\_TCP\_OPENING;
+ pf\_update\_state\_timeout(\*stp, PFTM\_TCP\_OPENING);
else if (src->state >= TCPS\_CLOSING ||
dst->state >= TCPS\_CLOSING)
- (\*stp)->timeout = PFTM\_TCP\_CLOSING;
+ pf\_update\_state\_timeout(\*stp, PFTM\_TCP\_CLOSING);
else
- (\*stp)->timeout = PFTM\_TCP\_ESTABLISHED;
+ pf\_update\_state\_timeout(\*stp, PFTM\_TCP\_ESTABLISHED);
return (PF\_PASS);
}
@@ -5377,7 +5390,7 @@ pf\_test\_state(struct pf\_pdesc \*pd, struc
addlog("\n");
}
/\* XXX make sure it's the same direction ?? \*/
- (\*stp)->timeout = PFTM\_PURGE;
+ pf\_update\_state\_timeout(\*stp, PFTM\_PURGE);
pf\_state\_unref(\*stp);
\*stp = NULL;
pf\_mbuf\_link\_inpcb(pd->m, inp);
@@ -5417,9 +5430,9 @@ pf\_test\_state(struct pf\_pdesc \*pd, struc
(\*stp)->expire = getuptime();
if (src->state == PFUDPS\_MULTIPLE &&
dst->state == PFUDPS\_MULTIPLE)
- (\*stp)->timeout = PFTM\_UDP\_MULTIPLE;
+ pf\_update\_state\_timeout(\*stp, PFTM\_UDP\_MULTIPLE);
else
- (\*stp)->timeout = PFTM\_UDP\_SINGLE;
+ pf\_update\_state\_timeout(\*stp, PFTM\_UDP\_SINGLE);
break;
default:
/\* update states \*/
@@ -5432,9 +5445,9 @@ pf\_test\_state(struct pf\_pdesc \*pd, struc
(\*stp)->expire = getuptime();
if (src->state == PFOTHERS\_MULTIPLE &&
dst->state == PFOTHERS\_MULTIPLE)
- (\*stp)->timeout = PFTM\_OTHER\_MULTIPLE;
+ pf\_update\_state\_timeout(\*stp, PFTM\_OTHER\_MULTIPLE);
else
- (\*stp)->timeout = PFTM\_OTHER\_SINGLE;
+ pf\_update\_state\_timeout(\*stp, PFTM\_OTHER\_SINGLE);
break;
}
@@ -5585,7 +5598,7 @@ pf\_test\_state\_icmp(struct pf\_pdesc \*pd,
return (ret);
(\*stp)->expire = getuptime();
- (\*stp)->timeout = PFTM\_ICMP\_ERROR\_REPLY;
+ pf\_update\_state\_timeout(\*stp, PFTM\_ICMP\_ERROR\_REPLY);
/\* translate source/destination address, if necessary \*/
if ((\*stp)->key[PF\_SK\_WIRE] != (\*stp)->key[PF\_SK\_STACK]) {
