<!DOCTYPE html>
<html lang="en-US" data-themeable="true">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="csrf-token" content="wyPvAISH-yFf3F05-zdifOp5zxHIT3YRqPF8">
    
    
    <meta name="description" content="On the 30th of July, 2023, multiple Curve.Fi liquidity pools were exploited as a result of a latent vulnerability in the Vyper compiler, specifically in versions 0.2.15, 0.2.16, and 0.3.0. While bug was identified and patched by the v0.3.1 release, the impact to protocols using the vulnerable compilers was not realized at the time and they were not explicitly notified. The vulnerability itself was an improperly implemented re-entrancy guard that could be bypassed under certain conditions which we will delve into in this report.">
    
    <title>Vyper Nonreentrancy Lock Vulnerability Technical Post-Mortem Report - HackMD</title>
    <link rel="icon" type="image/png" href="https://hackmd.io/favicon.png">
	<link rel="apple-touch-icon" href="https://hackmd.io/apple-touch-icon.png">
	<!--  meta value for server side given sign in boolean -->
    <meta name="signin" content="false">

    
<script nonce="be53d6d7-03a0-4028-8ef3-71c7e83aa61d">
  window.domain = 'hackmd.io'
  window.urlpath = ''
  window.debug = false || window.localStorage.getItem('HMD_DEBUG_FLAG') === 'true'
  window.version = '1.3.0'
  window.brand = 'HackMD'

  
  window.NOTE_ID = 'rTDGAwPETnCgz8dfHu_CzA'
  

  window.GOOGLE_DRIVE_API_KEY = 'AIzaSyAHmcP5gL_64ZafuAYOvJruFAIaYgHQaY4'
  window.GOOGLE_DRIVE_CLIENT_ID = '65857506266-76uhhee8se8dgs1i0q8fhtj1prg0ar27.apps.googleusercontent.com'
  window.DROPBOX_APP_KEY = 'rdoizrlnkuha23r'
  
  window.PLANTUML_SERVER = 'https://ptuml.hackmd.io'

  window.ASSET_URL = 'https://assets.hackmd.io'

  window.USER_CAN_CREATE_TEAM = true
  window.USER_CAN_DELETE_ACCOUNT = true
  window.USER_DELETE_ACCOUNT_VIA_EMAIL = true
  window.PAYMENT_ENABLED = true
  window.PAYMENT_PROMOTION_BANNER_ENABLED = false
  window.GITHUB_SYNC_ENABLED = true
  window.GITLAB_SYNC_ENABLED = false
  window.GITLAB_SYNC_BASE_URL = ''
  window.VCS_SYNC_MODE = 'github'
  window.VCS_PROVIDER_NAME = 'GitHub'
  window.FREE_TEAM_NUM = 20
  window.FREE_TEAM_MEMBER_NUM = 3
  window.FREE_PUBLIC_TEAM_NUM = 10
  window.NEO_OVERVIEW_UI = true
  window.FOLDER_ENABLE = true
  
  window.EE_SITE_ENABLE = false
  window.EE_SITE_NAME = 'false'
  window.EE_SITE_LINK = 'false'
  window.EESITE_INFO = false
  window.ENTERPRISE_DISCOVERY_ENABLE = false
  window.ENTERPRISE_DISCOVERY_TEAM = true
  window.ENTERPRISE_DISCOVERY_NOTE = true
  window.ENTERPRISE_DISCOVERY_VIEW_PERMISSION = 'guest'
  
  window.ALLOW_ANONYMOUS = true
  window.ALLOW_ANONYMOUS_EDIT = false
  window.ALLOW_DOWNLOAD_PDF = true
  window.PUBLIC_OVERVIEW = false
  window.INTERNAL_PUBLIC_OVERVIEW = false
  window.FULL_TEXT_SEARCH_ENABLE = false
  window.ALGOLIA_SEARCH_ENABLE = true
  window.MARKETING_EMAIL_ENABLE = true
  window.OFFLINE_ACCESS = true
  
  
  
    window.WALLET_CONNECT_PROJECT_ID = '91d6fa182b725b5895a17a170a5878c1'
  
  window.API_MANAGEMENT_UI_ENABLE = true
  window.FEEDBACK_UI_ENABLE = true
  window.PUBLISH_ENABLE = true

  

  
  window.SHOW_HOT_NOTES = false
  

  
  window.HOT_NOTES_TIME_TYPE = 'week'
  

  
  window.SHOW_OVERVIEW = false
  

  
  window.MENTIONS = {}
  

  
  window.MENTION_ANCHORS = []
  

  
  window.COMMENT_ANCHORS = []
  

  
  window.IS_OWNER = false
  

  
  window.IS_TEAM_ADMIN = false
  

  
  window.IS_INVITEE_ADMIN = false
  

  
  window.USER_PROFILE = '%7B%22name%22%3A%22Guest%20Miles%22%7D'
  

  
  window.VERSION_TIME = '1691288254125'
  

  
  window.canEdit = false
  

  
  window.canWriteComment = false
  

  
  window.canHideComment = false
  

  window.TRASH_NOTE_DELETE_AFTER_FREE = 3
  window.TRASH_NOTE_DELETE_AFTER_PAID = 30

  
    window.ENABLED_PREVIEW_FEATURE = {}
  

  
    window.IS_OWNER_UPGRADED = false
  

  
    window.IMGUR_FALLBACK_CDN = 'https://imgur-backup.hackmd.io'
  

  
    window.CLOUD_META_UI = true
  
  
    window.CLOUD_META_API = true
  
  
    window.CLOUD_META_MIGRATION = false
  
  
    window.YAML_METADATA_ENABLED = false
  

  
    window.NOTE_CAPACITY_LIMIT = 50
  

  
    window.DOCUMENT_MAX_LENGTH = 100000
  

  
    window.SOCIAL_NETWORK_FEATURES_ENABLED = true
  

  
    window.PUBLISHMENT_MODERATION_ENABLED = true
  

  
    window.COMMENT_ENABLED = false
  

  window.SUGGEST_EDIT_ENABLED = true
  
    window.SUGGEST_EDIT_ENABLED = true
  

  
    window.REALTIME_CLIENT_WITH_CREDENTIALS = false
  

  
    window.COMMENT_ENABLED = false
  

  
    window.DEBUG_DISCONNECT_SOCKET_WHEN_OFFLINE = false
  

  

  

  

  
    window.CUSTOM_STYLE_ENABLED = "true"
  

  
    window.USE_NEW_LOGO = true
  

  
    window.ITERABLE_ENABLED = true
  
  
    window.ITERABLE_API_KEY = "c2c36a44c2614fb19aa3b46d660bbce2"
  

  
    window.TEXT_SELECTION_CHANGED = false
  

  
    window.CAN_VIEW_HISTORY_AT_REVISION = false
  
</script>


    
<!-- Google Tag Manager -->
<script nonce="be53d6d7-03a0-4028-8ef3-71c7e83aa61d">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KLW9Z3');</script>
<!-- End Google Tag Manager -->


    





    <meta property="fb:app_id" content="1436904003272070">



    <meta name="twitter:image:src" content="https://hackmd.io/images/media/HackMD-neo-og.jpg">
    <meta name="twitter:image:alt" content="Vyper Nonreentrancy Lock Vulnerability Technical Post-Mortem Report - HackMD">


<meta name="twitter:site" content="@hackmdio" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="Vyper Nonreentrancy Lock Vulnerability Technical Post-Mortem Report - HackMD" />


    <meta name="twitter:description" content="On the 30th of July, 2023, multiple Curve.Fi liquidity pools were exploited as a result of a latent vulnerability in the Vyper compiler, specifically in versions 0.2.15, 0.2.16, and 0.3.0. While bug was identified and patched by the v0.3.1 release, the impact to protocols using the vulnerable compilers was not realized at the time and they were not explicitly notified. The vulnerability itself was an improperly implemented re-entrancy guard that could be bypassed under certain conditions which we will delve into in this report." />



    <meta property="og:image" content="https://hackmd.io/images/media/HackMD-neo-og.jpg">
    <meta property="og:image:alt" content="Vyper Nonreentrancy Lock Vulnerability Technical Post-Mortem Report - HackMD">


<meta property="og:site_name" content="HackMD" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Vyper Nonreentrancy Lock Vulnerability Technical Post-Mortem Report - HackMD" />


    <meta property="og:description" content="On the 30th of July, 2023, multiple Curve.Fi liquidity pools were exploited as a result of a latent vulnerability in the Vyper compiler, specifically in versions 0.2.15, 0.2.16, and 0.3.0. While bug was identified and patched by the v0.3.1 release, the impact to protocols using the vulnerable compilers was not realized at the time and they were not explicitly notified. The vulnerability itself was an improperly implemented re-entrancy guard that could be bypassed under certain conditions which we will delve into in this report." />



    <link rel="canonical" href="https://hackmd.io/@vyperlang/HJUgNMhs2" />
    <meta property="og:url" content="https://hackmd.io/@vyperlang/HJUgNMhs2" />
    <meta property="twitter:url" content="https://hackmd.io/@vyperlang/HJUgNMhs2" />


     <link href="https://assets.hackmd.io/build/font-vendor.css" rel="stylesheet"><link href="https://assets.hackmd.io/build/font-vendor.ea8218d7d4f468b2c430.css" rel="stylesheet"><link href="https://assets.hackmd.io/build/common-vendor.css" rel="stylesheet"><link href="https://assets.hackmd.io/build/common-vendor.0a08ae20e14fefe857eb.css" rel="stylesheet"><link href="https://assets.hackmd.io/build/pretty-vendor.css" rel="stylesheet"><link href="https://assets.hackmd.io/build/pretty-vendor.db0e7b64c54d0a77290f.css" rel="stylesheet"><link href="https://assets.hackmd.io/build/pretty.css" rel="stylesheet"><link href="https://assets.hackmd.io/build/pretty.206c1db4aa617ea5aa67.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js" integrity="sha256-3Jy/GbSLrg0o9y5Z5n1uw0qxZECH7C6OQpVBgNFYa0g=" crossorigin="anonymous"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js" integrity="sha256-g6iAfvZp+nDQ2TdTR/VVKJf3bGro4ub5fvWSWVRi2NE=" crossorigin="anonymous"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.9/es5-shim.min.js" integrity="sha256-8E4Is26QH0bD52WoQpcB+R/tcWQtpzlCojrybUd7Mxo=" crossorigin="anonymous"></script>
<![endif]-->

    


    <script defer data-domain="hackmd.io" src="https://plausible.io/js/script.js"></script>
<script nonce="be53d6d7-03a0-4028-8ef3-71c7e83aa61d">
  window.plausible = window.plausible || function() { (window.plausible.q = window.plausible.q || []).push(arguments); }
  const keyboardWhiteList = ['a', 'span', 'button']

  function getTaggedEventAttributes (e) {
    const eventAttrs = { name: null, props: {} }
    if (!e || !e.classList) return eventAttrs
    const psEvent = /plausible-event-(.+)(=|--)(.+)/
    for (const className of [...e.classList]) {
      const [, key, , val] = className.match(psEvent) || []
      if (!key || !val) continue
      const value = val.replace(/\+/g, ' ')
      switch (key.toLowerCase()) {
        case 'name':
          eventAttrs.name = value
          break
        default:
          eventAttrs.props[key] = value
          break
      }
    }
    return eventAttrs
  }

  function isLocal () {
    return /^localhost$|^127(\.[0-9]+){0,2}\.[0-9]+$|^\[::1?\]$/.test(location.hostname) || location.protocol === 'file:'
  }

  function isAutomation () {
    return Boolean(window._phantom || window.__nightmare || window.navigator.webdriver || window.Cypress)
  }

  function shouldIgnore () {
    return isLocal() ||
      isAutomation() ||
      window.localStorage.getItem('plausible_ignore') === 'true'
  }

  function handler (e) {
    if (!window.plausible) return
    if (!e.target || !('className' in e.target)) return
    const ele = e.target

    const eventAttrs = getTaggedEventAttributes(ele)
    if (!eventAttrs.name) return
    if (ele?.href) eventAttrs.props.url = ele.href

    if (shouldIgnore()) {
      if (window.debug) logDebugEventMsg(eventAttrs)
      return
    }
    window.plausible(eventAttrs.name, { props: eventAttrs.props })
  }

  function logDebugEventMsg (eventAttrs) {
    console.warn(
      `Ignoring Event: "${eventAttrs.name}"`,
      eventAttrs,
    )
  }

  function keydownHandler (e) {
    if (e.key !== 'Enter') return
    if (e.target.nodeName.toLowerCase() === 'input') {
      switch (e.target.type.toLowerCase()) {
        case 'submit':
        case 'button':
        case 'reset':
        case 'checkbox':
        case 'radio':
        case 'file':
        case 'image':
        case 'color':
          break
        default:
          return
      }
    } else if (!keyboardWhiteList.includes(e.target.nodeName.toLowerCase())) {
      return
    }
    handler(e)
  }

  document.addEventListener('mousedown', handler)
  document.addEventListener('keydown', keydownHandler)
</script>

    
<script nonce="be53d6d7-03a0-4028-8ef3-71c7e83aa61d">
  window.publishProps = JSON.parse(`{"isOwnerAnonymous":false,"isOwnedByTeam":true,"ownerInfo":{"name":"Vyperlang","path":"vyperlang","avatarUrl":"https%3A%2F%2Fuploads-public.hackmd.io%2Fupload_7afa614e1b05e20844eec7273c227b33.png","description":"Vyper%20language"},"isPublished":true,"createTime":1691259886450,"updateTime":1691288254125,"vcsSyncMode":"github","vcsProviderName":"GitHub","canEdit":false,"hardBreaks":true,"onlyOwnerCanEdit":true,"isCommentEnabled":false,"likedCount":4,"isNotificationEnabled":true,"notificationType":"never","hasEmail":false,"canWriteComment":false,"viewCount":8923,"markdown":"%23%23%23%23%23%23%20Vyperlang%20team%20with%20special%20thanks%20to%20Omniscia%20team%5B%5Ebyline-note%5D%0A%0A%5B%5Ebyline-note%5D%3A%20Special%20thanks%20to%20the%20%5BOmniscia%5D(https%3A%2F%2Fomniscia.io%2F)%20team%2C%20which%2C%20while%20not%20directly%20affiliated%20with%20Vyper%2C%20contributed%20substantial%20co-authorship%2C%20feedback%20and%20review%20%20of%20this%20post-mortem%20report%0A%0AOn%20the%2030th%20of%20July%2C%202023%2C%20multiple%20Curve.Fi%20liquidity%20pools%20were%20exploited%20as%20a%20result%20of%20a%20latent%20vulnerability%20in%20the%20Vyper%20compiler%2C%20%5Bspecifically%20in%20versions%20%600.2.15%60%2C%20%600.2.16%60%2C%20and%20%600.3.0%60%5D(https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fsecurity%2Fadvisories%2FGHSA-5824-cm3x-3c38).%20While%20bug%20was%20identified%20and%20patched%20by%20the%20%5B%60v0.3.1%60%5D(https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Freleases%2Ftag%2Fv0.3.1)%20release%2C%20the%20impact%20to%20protocols%20using%20the%20vulnerable%20compilers%20was%20not%20realized%20at%20the%20time%20and%20they%20were%20not%20explicitly%20notified.%20The%20vulnerability%20itself%20was%20an%20improperly%20implemented%20re-entrancy%20guard%20that%20could%20be%20bypassed%20under%20certain%20conditions%20which%20we%20will%20delve%20into%20in%20this%20report.%0A%0AWhile%20the%20hacks%20themselves%20have%20been%20sufficiently%20covered%20in%20other%20post-mortems%20%5Bincluding%20the%20official%20one%20by%20Curve.Fi%5D(https%3A%2F%2Fhackmd.io%2F%40LlamaRisk%2FBJzSKHNjn)%2C%20we%20would%20like%20to%20take%20a%20deep-dive%20into%20what%20exactly%20went%20wrong%20with%20the%20Vyper%20compiler%20itself%2C%20why%20the%20vulnerability%20was%20hard%20to%20spot%2C%20and%20what%20the%20ecosystem%20as%20a%20whole%20can%20learn%20from%20these%20incidents.%0A%0AIf%20you%20are%20familiar%20with%20the%20blockchain%20space%20and%20why%20Vyper%20exists%2C%20**we%20recommend%20skipping%20the%20Background**%20section%20as%20it%20contains%20very%20basic%20information%20that%20you%20most%20likely%20are%20aware%20of.%0A%0A%23%20Background%0A%0A%23%23%20Vyper%0A%0AVyper%20is%20a%20contract-oriented%2C%20domain-specific%2C%20pythonic%20programming%20language%20which%20targets%20the%20Ethereum%20Virtual%20Machine%20(EVM).%20Its%20goals%20include%20simplicity%2C%20pythonicity%2C%20security%20and%20auditability.%0A%0A%23%23%20EVM%3A%20A%20Single-Threaded%20Non-Concurrent%20Machine%0A%0AA%20common%20problem%20that%20is%20a%20concern%20for%20code%20deployed%20on%20the%20EVM%20is%20the%20concept%20of%20*re-entrancy*.%20In%20contrast%20to%20traditional%20programs%2C%20the%20control%20flow%20of%20a%20%22blockchain%20program%22%20will%20be%20relinquished%20to%20the%20%22active%22%20program%20being%20executed%20at%20any%20given%20moment.%20From%20hereon%2C%20a%20%22blockchain%20program%22%20will%20be%20referred%20to%20as%20a%20contract.%0A%0ATo%20elaborate%2C%20we%20can%20think%20of%20all%20blockchain%20programs%20as%20operating%20on%20a%20single%20thread%20with%20no%20support%20for%20concurrency.%20Whenever%20a%20program%20invokes%20another%2C%20the%20entire%20control%20flow%20is%20passed%20on%20to%20the%20invoked%20program.%20%0A%0A%23%23%20Re-Entrancy%3A%20A%20Widespread%20Web%203.0%20Problem%0A%0AThis%20means%20that%20the%20original%20caller's%20execution%20is%20essentially%20frozen%20in%20time%20until%20the%20invoked%20program%20concludes%2C%20at%20which%20point%20the%20caller%20resumes%20at%20the%20exact%20point%20they%20were%20left%20in.%20While%20different%20types%20of%20vulnerabilities%20can%20arise%20from%20this%20behaviour%2C%20the%20most%20well-known%20one%20is%20a%20*re-entrancy*.%0A%0AAs%20the%20control%20flow%20is%20relinquished%20to%20the%20invoked%20contract%2C%20the%20invoked%20contract%20can%20*re-enter*%20the%20original%20caller%20while%20it%20is%20frozen.%20The%20contracts%20that%20are%20vulnerable%20to%20this%20type%20of%20attack%20will%20contain%20state%20updates%20after%20their%20external%20contract%20invocation%2C%20meaning%20that%20when%20they%20are%20frozen%20**their%20state%20is%20outdated%20and%20incorrect**.%0A%0A%23%23%20Solutions%0A%0AThe%20ecosystem%20has%20come%20up%20with%20two%20ways%20to%20combat%20re-entrancy%20attacks%20and%20essentially%20render%20them%20ineffectual%3B%20the%20Checks-Effects-Interactions%20pattern%20(CEI)%20and%20re-entrancy%20guards.%0A%0A%23%23%23%20Checks-Effects-Interactions%20(CEI)%20Pattern%0A%0AThe%20CEI%20pattern%20is%20a%20programming%20methodology%20which%20dictates%20that%20a%20function's%20code%20should%20execute%20its%20security%20checks%20first%2C%20perform%20any%20effects%20in%20its%20storage%20after%2C%20and%20finally%20perform%20interactions%20with%20external%20contracts%20at%20the%20end%20of%20the%20function.%20%0A%0AShould%20this%20pattern%20be%20followed%20strictly%2C%20the%20state%20of%20a%20contract%20during%20an%20%22interaction%22%20(i.e.%20control%20flow%20relinquishment)%20will%20be%20up-to-date%20and%20correct%20rendering%20any%20would-be%20exploitation%20impossible%20regardless%20of%20how%20the%20contract%20is%20re-entered.%20%0A%0A%23%23%23%20Re-Entrancy%20Guards%0A%0AIn%20most%20cases%20the%20CEI%20pattern%20is%20sufficient%2C%20however%2C%20the%20DeFi%20ecosystem%20is%20multi-faceted%20and%20oftentimes%20functions%20rely%20**on%20the%20result%20of%20an%20external%20call%20to%20proceed%20with%20their%20own%20execution**.%20In%20such%20cases%2C%20the%20CEI%20pattern%20is%20inapplicable%20and%20**a%20re-entrancy%20guard%20must%20be%20set%20in%20place**.%0A%0AAs%20one%20of%20the%20core%20principles%20in%20the%20Vyper%20language%20is%20*security*%2C%20Vyper%20decided%20to%20introduce%20a%20re-entrancy%20guard%20directly%20at%20the%20language-level%20via%20the%20special%20%60%40nonreentrant%60%20function%20decorator.%20The%20re-entrancy%20guard%20has%20been%20a%20core%20feature%20of%20the%20language%20ever%20since%20the%20%60v0.1.0-beta.9%60%20release%2C%20one%20of%20the%20earliest%20versions%20of%20Vyper.%0A%0AAt%20their%20core%2C%20both%20implementations%20function%20identically%3B%20they%20set%20a%20storage%20value%20between%20two%20states%20(activated%2C%20inactive).%20When%20a%20function%20that%20is%20marked%20as%20%60%40nonreentrant%60%20is%20invoked%2C%20the%20flag%20is%3A%0A%0A-%20Ensured%20to%20NOT%20be%20in%20its%20active%20state%20%0A-%20Set%20to%20its%20active%20state%0A%0AOnce%20the%20function's%20invocation%20concludes%2C%20the%20flag%20is%3A%0A%0A-%20Set%20to%20its%20inactive%20state%0A%0AWith%20this%20mechanism%2C%20%60%40nonreentrant%60%20users%20can%20ensure%20that%20the%20function%20can%20only%20be%20re-invoked%20**after%20it%20concludes**%2C%20meaning%20that%20**no%20re-entrancy%20can%20occur%20regardless%20of%20what%20external%20calls%20are%20performed**.%20More%20complex%20forms%20of%20re-entrancy%20attacks%20exist%20(i.e.%20%60view%60%20only%20re-entrancies%2C%20cross-contract%20re-entrancies)%20but%20for%20the%20purposes%20of%20this%20vulnerability%20the%20basic%20case%20is%20what%20matters.%0A%0A%23%20Vyper%20Vulnerability%20Historical%20Timeline%0A%0A%23%23%20%60%40nonreentrant%60%3A%20Tag-Based%20Re-Entrancy%20Guards%0A%0AEver%20since%20their%20introduction%2C%20%60%40nonreentrant%60%20decorators%20%5Balways%20supported%20a%20%60%3Ckey%3E%60%20to%20be%20set%5D(https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fpull%2F1264)%20offering%20more%20flexibility%20compared%20to%20a%20nonreentrancy%20lock%20which%20only%20applies%20globally%20at%20the%20contract%20level.%0A%0AA%20simple%20implementation%20could%20be%20to%20use%20a%20%60mapping%60%20that%20takes%20the%20%60key%60%20and%20sets%20the%20relevant%20re-entrancy%20flag%20on%20it%2C%20however%2C%20such%20an%20approach%20would%20invoke%20extra%20cost%20due%20to%20the%20%60keccak256%60%20gas%20cost%20of%20%60mapping%60%20lookups.%0A%0AAs%20Vyper%20is%20a%20language%20which%20does%20not%20provide%20raw%20storage%20access%20to%20users%2C%20it%20will%20be%20fully%20aware%20of%20all%20storage%20slots%20a%20contract%20uses%20when%20compiling%20it.%20As%20such%2C%20it%20takes%20on%20the%20job%20of%20allocating%20storage%20slots%2C%20which%20includes%20ensuring%20that%20slots%20for%20storage%20variables%20and%20re-entrancy%20key%20locks%20do%20not%20overlap%20with%20each%20other.%0A%0A%5BPR%231264%5D(https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fpull%2F1264)%20which%20introduced%20this%20feature%20in%20the%20%5B%60v0.1.0-beta.9%60%5D(https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Freleases%2Ftag%2Fv0.1.0-beta.9)%20release%20of%20Vyper%20used%20a%20simple%20approach%20to%20ensure%20no%20overlap%2C%20storing%20re-entrancy%20flags%20at%20a%20specific%20offset%20from%20the%20contract's%20original%20slots%20(%600xFFFFFF%60%20to%20be%20precise).%0A%0A%23%23%20Refactoring%20the%20Compiler%0A%0AIn%20tandem%20with%20new%20feature%20development%2C%20beginning%20in%202018%2C%20the%20Vyper%20compiler%20started%20a%20%5Bmulti-%5D(https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fissues%2F1024)%20%5Byear%5D(https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fissues%2F1806)%20%5Beffort%5D(https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fissues%2F2062)%20to%20refactor%20the%20then%20single-pass%20architecture%20into%20a%20multiple%20pass%20architecture%20which%20would%20separate%20the%20concerns%20of%20type%20checking%20and%20semantic%20analysis%20into%20a%20front-end%2C%20distinct%20from%20the%20code%20generating%20backend.%20As%20with%20most%20large%20refactoring%20projects%2C%20this%20effort%20was%20incremental%20and%20piecemeal%2C%20being%20worked%20on%20alongside%20other%20bugfixes%20and%20feature%20development%20until%20finally%20culminating%20in%202023%20with%20%5BPR%233390%5D(https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fpull%2F3390).%0A%0A%23%23%20Location%20Optimization%3A%20Smarter%20Allocation%20of%20Storage%20Slots%0A%0A%5BPR%232308%5D(https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fpull%2F2308)%20which%20was%20part%20of%20the%20Vyper%20%5B%60v0.2.9%60%5D(https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Freleases%2Ftag%2Fv0.2.9)%20release%20was%20meant%20to%20make%20storage%20allocation%20smarter%20by%20utilizing%20the%20first%20unallocated%20storage%20slot%20available%20after%20all%20slots%20for%20regular%20storage%20variables%20of%20a%20contract%20have%20been%20processed%2C%20instead%20of%20starting%20from%20the%20%600xFFFFFF%60%20constant.%20This%20would%20save%20bytecode%20space%2C%20because%20in%20the%20bytecode%2C%20the%20%60PUSH%60%20instructions%20which%20precede%20any%20load%20or%20store%20of%20a%20storage%20slot%20by%20pushing%20the%20location%20of%20the%20nonreentrancy%20key%20to%20the%20stack%20could%20use%20fewer%20bytes.%0A%0A%23%23%20Corruption%20Avoidance%3A%20Proper%20Offset%20Calculation%0A%0AThe%20above%20PR%20of%20the%20%60v0.2.9%60%20release%20worked%20well%20and%20would%20guarantee%20no%20overlap%20between%20re-entrancy%20flag%20slots%20and%20storage%20slots%20so%20long%20as%20the%20variables%20that%20are%20allocated%20sequentially%20in%20the%20(physical)%20front%20of%20the%20storage%20layout%20do%20not%20span%20multiple%20sequential%20slots.%20%0A%0AAs%20the%20Vyper%20language%20and%20codebase%20were%20undergoing%20significant%20refactoring%20at%20the%20time%2C%20%5BPR%232361%5D(https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fpull%2F2361)%20(part%20of%20the%20%60v0.2.13%60%20release)%20introduced%20a%20more%20efficient%20way%20to%20store%20variables%20that%20could%20span%20more%20than%201%20storage%20slot%20(32%20bytes)%20within%20a%20contract.%20As%20part%20of%20the%20larger%20refactoring%20effort%2C%20it%20also%20moved%20slot%20calculation%20for%20regular%20storage%20variables%20out%20of%20the%20existing%20code%20generation%20pass%20into%20the%20new%20front-end%20pass%2C%20but%20left%20slot%20calculation%20for%20re-entrancy%20keys%20as%20it%20was.%20Because%20the%20slot%20calculation%20for%20re-entrancy%20keys%20depended%20on%20the%20results%20of%20allocation%20for%20the%20regular%20storage%20variables%2C%20it%20ended%20up%20keeping%20two%20different%20allocator%20implementations%20for%20regular%20storage%20variable%20allocation%20between%20the%20front-end%20and%20codegen%20passes.%20This%20resulted%20in%20the%20offset%20calculations%20of%20%5BPR%232308%5D(https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fpull%2F2308)%20to%20be%20incorrect%20and%20require%20an%20update.%0A%0AThe%20update%20was%20introduced%20in%20%5BPR%232379%5D(https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fpull%2F2379)%20(part%20of%20the%20%60v0.2.14%60%20release)%2C%20and%20was%20meant%20to%20calculate%20the%20storage%20offsets%20for%20re-entrancy%20flags%20correctly%20by%20taking%20into%20account%20the%20correct%20size%20of%20variables%20declared%20in%20storage%20rather%20than%20assuming%20all%20of%20them%20occupy%20a%20single%20slot%20(which%20was%20true%20in%20earlier%20implementations).%20However%2C%20the%20second%20update%20still%20had%20a%20bug%20stemming%20from%20the%20differences%20between%20the%20front-end%20and%20codegen%20allocator%20implementations%2C%20which%20we%20will%20describe%20below.%0A%0ABecause%20of%20these%20bugs%2C%20both%20%60v0.2.13%60%20and%20%60v0.2.14%60%20releases%20were%20%22yanked%22%5B%5Eyank-explanation%5D%20shortly%20after%20release.%0A%0A%5B%5Eyank-explanation%5D%3A%20Briefly%20speaking%2C%20%22yanking%22%20means%20that%20the%20tags%20are%20available%20in%20the%20repository%20for%20historical%20purposes%2C%20but%20the%20releases%20are%20not%20published%20for%20download.%20For%20more%20information%2C%20please%20see%20%5BPEP-592%5D(https%3A%2F%2Fpeps.python.org%2Fpep-0592%2F).%0A%0A%23%23%20Decisive%20Event%3A%20Re-Entrancy%20Guard%20Corruption%20in%20%60v0.2.14%60%0A%0AShortly%20after%20%60v0.2.14%60%20was%20released%2C%20a%20Vyper%20user%20opened%20%5Bissue%20%232393%5D(https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fissues%2F2393)%20in%20the%20Vyper%20GitHub%20repository%20denoting%20that%20re-entrancy%20guard%20tests%20were%20failing%20when%20they%20were%20upgrading%20the%20Yearn%20vault%20code%20to%20%600.2.14%60.%0A%0ATaking%20a%20snapshot%20of%20%5Bthe%20latest%20available%20release%20of%20Yearn%5D(https%3A%2F%2Fgithub.com%2Fyearn%2Fyearn-vaults%2Ftree%2Fefb47d8a84fcb13ceebd3ceb11b126b323bcc05d)%20when%20the%20user%20opened%20their%20issue%2C%20proceeded%20to%20compile%20it%20with%20%60v0.2.14%60%2C%20and%20inspecting%20the%20**decompiled%20bytecode**%20using%20the%20%5BEtherVM%20Decompiler%5D(https%3A%2F%2Fethervm.io%2Fdecompile)%20will%20reveal%20that%20the%20pseudo-code%20storage%20offset%20%60storage%5B0x2e%5D%60%20is%20being%20utilized%20as%20the%20%22flag%22%20for%20the%20%60%40nonreentrant(%22withdraw%22)%60%20keyword%20in%20both%20the%20%60def%20deposit%60%20and%20%60def%20withdraw%60%20instances%20of%20the%20%60Vault.vy%60%20file.%0A%0AHowever%2C%20the%20same%20storage%20offset%20is%20utilized%20for%20the%20contract-level%20%60managementFee%60%20variable.%20This%20can%20be%20validated%20by%20evaluating%20the%20decompiled%20functions%20for%20the%20%60managementFee()%60%20getter%20function%20as%20well%20as%20the%20%60setManagementFee%60%20setter%20function%20which%20will%20re-use%20the%20same%20storage%20offset.%0A%0ACompiling%20the%20same%20codebase%20with%20%60v0.2.13%60%20shows%20that%20that%20the%20re-entrancy%20guards%20were%20working%20as%20expected%20and%20were%20not%20overlapping%20in%20storage.%20However%2C%20%5BPR%232379%5D(https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fpull%2F2379)%20of%20the%20%60v0.2.14%60%20release%20did%20not%20fully%20solve%20the%20issue%20of%20corruption.%0A%0AThe%20code%20of%20the%20%60v0.2.14%60%20release%20assigning%20storage%20slots%20for%20%60%40nonreentrant%60%20decorators%20still%20produced%20an%20incorrect%20interaction%20between%20the%20new%20front-end%20code%20and%20the%20existing%20codegen%20allocator.%20Re-entrancy%20slots%20still%20ended%20up%20overlapping%20with%20regular%20storage%20variables%20due%20to%20the%20different%20allocation%20strategies%20for%20mapping%20types%20between%20the%20front-end%20and%20codegen%20allocators.%20**The%20data-corruption%20code%20of%20%60v0.2.14%60%20is%20as%20follows**%3A%0A%0A%60%60%60python%20%0Adef%20get_nonrentrant_counter(self%2C%20key)%3A%0A%20%20%20%20%22%22%22%0A%20%20%20%20Nonrentrant%20locks%20use%20a%20prefix%20with%20a%20counter%20to%20minimise%20deployment%20cost%20of%20a%20contract.%0A%20%20%20%20We're%20able%20to%20set%20the%20initial%20re-entrant%20counter%20using%20the%20sum%20of%20the%20sizes%0A%20%20%20%20of%20all%20the%20storage%20slots%20because%20all%20storage%20slots%20are%20allocated%20while%20parsing%0A%20%20%20%20the%20module-scope%2C%20and%20re-entrancy%20locks%20aren't%20allocated%20until%20later%20when%20parsing%0A%20%20%20%20individual%20function%20scopes.%20This%20relies%20on%20the%20deprecated%20_globals%20attribute%0A%20%20%20%20because%20the%20new%20way%20of%20doing%20things%20(set_data_positions)%20doesn't%20expose%20the%0A%20%20%20%20next%20unallocated%20storage%20location.%0A%20%20%20%20%22%22%22%0A%20%20%20%20if%20key%20in%20self._nonrentrant_keys%3A%0A%20%20%20%20%20%20%20%20return%20self._nonrentrant_keys%5Bkey%5D%0A%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20counter%20%3D%20(%0A%20%20%20%20%20%20%20%20%20%20%20%20sum(v.size%20for%20v%20in%20self._globals.values()%20if%20not%20isinstance(v.typ%2C%20MappingType))%0A%20%20%20%20%20%20%20%20%20%20%20%20%2B%20self._nonrentrant_counter%0A%20%20%20%20%20%20%20%20)%0A%20%20%20%20%20%20%20%20self._nonrentrant_keys%5Bkey%5D%20%3D%20counter%0A%20%20%20%20%20%20%20%20self._nonrentrant_counter%20%2B%3D%201%0A%20%20%20%20%20%20%20%20return%20counter%0A%60%60%60%0A%0ACompare%20this%20to%20the%20front-end%20code%20at%20the%20time%20for%20calculating%20the%20storage%20layout%20for%20regular%20storage%20variables.%0A%0A%60%60%60python%0A%20%20%20%20available_slot%20%3D%200%0A%20%20%20%20for%20node%20in%20vyper_module.get_children(vy_ast.AnnAssign)%3A%0A%20%20%20%20%20%20%20%20type_%20%3D%20node.target._metadata%5B%22type%22%5D%0A%20%20%20%20%20%20%20%20type_.set_position(StorageSlot(available_slot))%0A%20%20%20%20%20%20%20%20available_slot%20%2B%3D%20math.ceil(type_.size_in_bytes%20%2F%2032)%0A%60%60%60%0A%0AWhile%20this%20code%20would%20correctly%20consume%20the%20%60key%60%20value%20and%20yield%20the%20same%20%60%40nonreentrant%60%20storage%20offset%20for%20the%20same%20%60key%60%20value%2C%20it%20improperly%20calculated%20the%20storage%20offset.%20%0A%0ASpecifically%2C%20the%20old%20allocator%20did%20not%20allocate%20a%20storage%20slot%20for%20%60MappingType%60%20entries%20(i.e.%20%60HashMap%60)%2C%20while%20the%20new%20allocator%20did.%20%60MappingType%60%20storage%20entries%20are%20never%20written%20to%20but%20are%20reserved%20regardless%20by%20the%20compiler%20(ref%3A%20%5BIssue%202436%5D(https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fissues%2F2436)).%20This%20resulted%20in%20an%20inconsistency%20between%20the%20non-reentrant%20key%20allocator%20and%20the%20front-end%20allocator%20which%20led%20to%20the%20reported%20storage%20corruption.%0A%0A%23%23%20Vulnerability%20Introduced%3A%20Malfunctioning%20Re-Entrancy%20Locks%20in%20%60v0.2.15%60%0A%0AAfter%20%60v0.2.14%60%20was%20yanked%2C%20in%20an%20effort%20to%20correct%20the%20%60v0.2.14%60%20release's%20corruption%20of%20re-entrancy%20guards%2C%20%5BPR%232391%5D(https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fpull%2F2391)%20included%20in%20the%20%60v0.2.15%60%20release%20was%20meant%20to%20fix%20the%20bug%20introduced%20in%20from%20the%20previously%20mentioned%20%5BPR%232379%5D(https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fpull%2F2379)%20by%20moving%20re-entrancy%20keys%20to%20be%20allocated%20physically%20in%20front%20of%20regular%20storage%20variables.%20In%20addition%2C%20in%20an%20effort%20to%20reduce%20the%20chance%20of%20these%20kinds%20of%20issues%20being%20introduced%20again%2C%20it%20completed%20the%20removal%20of%20the%20storage%20slot%20allocation%20logic%20from%20the%20codegen%20pass%20by%20moving%20the%20logic%20into%20the%20same%20function%20in%20the%20front-end%20as%20regular%20storage%20variable%20allocation.%20However%2C%20in%20doing%20so%2C%20it%20removed%20the%20old%20%60self._nonreentrant_keys%60%20data%20structure%20and%2C%20crucially%2C%20the%20accompanying%20logic%20which%20ensured%20only%20one%20lock%20was%20allocated%20per%20nonreentrant%20key%3A%0A%0A%60%60%60python%0A%20%20%20%20if%20key%20in%20self._nonrentrant_keys%3A%0A%20%20%20%20%20%20%20%20%23%20--%3E%20SAFE.%20only%20allocate%20one%20slot%20per%20key%20%3C--%0A%20%20%20%20%20%20%20%20return%20self._nonrentrant_keys%5Bkey%5D%0A%60%60%60%0A%0A**The%20actual%20vulnerability%20is%20introduced%20in%20the%20following%20code%20of%20%60v0.2.15%60**%3A%0A%0A%60%60%60python%20%0A%23%20Allocate%20storage%20slots%20from%200%0A%23%20note%20storage%20is%20word-addressable%2C%20not%20byte-addressable%0Astorage_slot%20%3D%200%0A%0Afor%20node%20in%20vyper_module.get_children(vy_ast.FunctionDef)%3A%0A%20%20%20%20type_%20%3D%20node._metadata%5B%22type%22%5D%0A%20%20%20%20if%20type_.nonreentrant%20is%20not%20None%3A%0A%20%20%20%20%20%20%20%20%23%20--%3E%20BUG!%20should%20check%20nonreentrant%20key%20not%20already%20allocated%20%3C--%0A%20%20%20%20%20%20%20%20type_.set_reentrancy_key_position(StorageSlot(storage_slot))%0A%20%20%20%20%20%20%20%20%23%20TODO%20use%20one%20byte%20-%20or%20bit%20-%20per%20reentrancy%20key%0A%20%20%20%20%20%20%20%20%23%20requires%20either%20an%20extra%20SLOAD%20or%20caching%20the%20value%20of%20the%0A%20%20%20%20%20%20%20%20%23%20location%20in%20memory%20at%20entrance%0A%20%20%20%20%20%20%20%20storage_slot%20%2B%3D%201%0A%60%60%60%0A%0AThe%20vulnerability%20arises%20from%20how%20the%20%60storage_slot%60%20offsets%20of%20re-entrancy%20keys%20were%20ignoring%20the%20actual%20%60%3Ckey%3E%60%20of%20the%20%60%40nonreentrant(%3Ckey%3E)%60%20decorator%20and%20were%20simply%20reserving%20a%20new%20slot%20for%20each%20seen%20%60%40nonreentrant%60%20decorator%20regardless%20of%20what%20%22key%22%20was%20utilized.%0A%0A%23%23%20Latent%20Period%3A%20%60v0.2.15%60%2C%20%60v0.2.16%60%20and%20%60v0.3.0%60%0A%0AThe%20vulnerability%20that%20was%20introduced%20in%20%60v0.2.15%60%20went%20undetected%20during%20the%20interim%20releases%20%60v0.2.16%60%20as%20well%20as%20%60v0.3.0%60%20due%20to%20insufficient%20tests%20in%20the%20Vyper%20codebase%20at%20the%20time%20to%20detect%20it%2C%20a%204-%20month%20period%20between%20Jul%2021%2C%202021%20and%20Nov%2030%2C%202021.%0A%0A**All%20Vyper%20contracts%20that%20have%20been%20compiled%20with%20versions%20%60v0.2.15%60%2C%20%60v0.2.16%60%2C%20and%20%60v0.3.0%60%20are%20vulnerable%20to%20the%20malfunctioning%20re-entrancy%20guard**.%0A%0A%23%23%20Remediation%3A%20%60v0.3.1%60%20Release%0A%0AThe%20%60v0.3.1%60%20release%20resolved%20this%20vulnerability%20by%20adjusting%20how%20the%20compiler%20was%20allocating%20data%20slots%20to%20each%20variable%20within%20a%20contract.%20The%20vulnerability%20was%20fixed%20in%20**two%20different%20PRs**.%0A%0A%23%23%23%20PR%232439%3A%20Fix%20unused%20storage%20slots%0A%0AThe%20first%20PR%20that%20partially%20fixed%20the%20vulnerability%20was%20%5BPR%232439%5D(https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fpull%2F2439)%20which%20contains%20the%20following%20description%3A%0A%0A%3E%20this%20is%20not%20a%20semantic%20bug%20but%20an%20optimization%20bug%20since%20we%20allocate%0Amore%20slots%20than%20we%20actually%20need%2C%20leading%20to%20%22holes%22%20in%20the%20slot%0Aallocator%20--%20slots%20which%20are%20allocated%20but%20unused.%0A%0AThis%20description%20does%20not%20actually%20clearly%20describe%20the%20issue.%20The%20description%20of%20%22holes%22%20arises%20from%20inspecting%20how%20the%20compilation%20output's%20%60layout%60%20was%20yielding%20a%20single%20%60slot%60%20value%20for%20each%20re-entrant%20key.%20To%20better%20understand%20what%20happened%2C%20let's%20look%20at%20the%20data%20allocation%20function%20in%20%60v0.3.0%60%3A%0A%0A%60%60%60python%20%0Afor%20node%20in%20vyper_module.get_children(vy_ast.FunctionDef)%3A%0A%20%20%20%20type_%20%3D%20node._metadata%5B%22type%22%5D%0A%20%20%20%20if%20type_.nonreentrant%20is%20not%20None%3A%0A%20%20%20%20%20%20%20%20type_.set_reentrancy_key_position(StorageSlot(storage_slot))%0A%0A%20%20%20%20%20%20%20%20%23%20TODO%20this%20could%20have%20better%20typing%20but%20leave%20it%20untyped%20until%0A%20%20%20%20%20%20%20%20%23%20we%20nail%20down%20the%20format%20better%0A%20%20%20%20%20%20%20%20variable_name%20%3D%20f%22nonreentrant.%7Btype_.nonreentrant%7D%22%0A%20%20%20%20%20%20%20%20ret%5Bvariable_name%5D%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%22type%22%3A%20%22nonreentrant%20lock%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%22location%22%3A%20%22storage%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%22slot%22%3A%20storage_slot%2C%0A%20%20%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20%20%20%23%20TODO%20use%20one%20byte%20-%20or%20bit%20-%20per%20reentrancy%20key%0A%20%20%20%20%20%20%20%20%23%20requires%20either%20an%20extra%20SLOAD%20or%20caching%20the%20value%20of%20the%0A%20%20%20%20%20%20%20%20%23%20location%20in%20memory%20at%20entrance%0A%20%20%20%20%20%20%20%20storage_slot%20%2B%3D%201%0A%60%60%60%0A%0AThe%20problem%20with%20this%20code%20is%20that%20it%20was%20setting%20the%20re-entrancy%20key%20position%20of%20each%20%60type_%60%20(i.e.%20individual%20%60%40nonreentrant%60%20key)%20to%20the%20latest%20value%20of%20%60storage_slot%60%2C%20incrementing%20on%20each%20iteration.%20This%20meant%20that%20the%20unique%20instances%20of%20%60%40nonreentrant(%3Ckey%3E)%60%20were%20all%20using%20a%20different%20%60storage_slot%60%20value%2C%20however%2C%20the%20%60ret%60%20entry%20of%20%60variable_name%60%20was%20being%20overwritten%20on%20each%20iteration.%0A%0AAs%20such%2C%20the%20%60layout%60%20output%20of%20the%20compiler%20contained%20a%20single%20%60nonreentrant.%3Ckey%3E%60%20entry%20and%20a%20single%20storage%20offset%2C%20meaning%20that%20inspecting%20the%20compiler's%20output%20would%20appear%20to%20simply%20be%20%22skipping%22%20the%20storage%20slots%20of%20consecutive%20%60%40nonreentrant(%3Ckey%3E)%60%20declarations%2C%20as%20per%20the%20%5BPR's%20original%20rationale%5D(https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fpull%2F2439).%0A%0A**The%20non-vulnerable%20code%20that%20*partially*%20patched%20the%20vulnerability%20in%20the%20%60v0.3.1%60%20release%20is%20as%20follows**%3A%0A%0A%60%60%60python%20%0Afor%20node%20in%20vyper_module.get_children(vy_ast.FunctionDef)%3A%0A%20%20%20%20type_%20%3D%20node._metadata%5B%22type%22%5D%0A%20%20%20%20if%20type_.nonreentrant%20is%20None%3A%0A%20%20%20%20%20%20%20%20continue%0A%0A%20%20%20%20variable_name%20%3D%20f%22nonreentrant.%7Btype_.nonreentrant%7D%22%0A%0A%20%20%20%20%23%20a%20nonreentrant%20key%20can%20appear%20many%20times%20in%20a%20module%20but%20it%0A%20%20%20%20%23%20only%20takes%20one%20slot.%20ignore%20it%20after%20the%20first%20time%20we%20see%20it.%0A%20%20%20%20if%20variable_name%20in%20ret%3A%0A%20%20%20%20%20%20%20%20continue%0A%0A%20%20%20%20type_.set_reentrancy_key_position(StorageSlot(storage_slot))%0A%0A%20%20%20%20%23%20TODO%20this%20could%20have%20better%20typing%20but%20leave%20it%20untyped%20until%0A%20%20%20%20%23%20we%20nail%20down%20the%20format%20better%0A%20%20%20%20ret%5Bvariable_name%5D%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%22type%22%3A%20%22nonreentrant%20lock%22%2C%0A%20%20%20%20%20%20%20%20%22location%22%3A%20%22storage%22%2C%0A%20%20%20%20%20%20%20%20%22slot%22%3A%20storage_slot%2C%0A%20%20%20%20%7D%0A%0A%20%20%20%20%23%20TODO%20use%20one%20byte%20-%20or%20bit%20-%20per%20reentrancy%20key%0A%20%20%20%20%23%20requires%20either%20an%20extra%20SLOAD%20or%20caching%20the%20value%20of%20the%0A%20%20%20%20%23%20location%20in%20memory%20at%20entrance%0A%20%20%20%20storage_slot%20%2B%3D%201%0A%60%60%60%0A%0AThe%20code%20will%20now%20properly%20allocate%20a%20single%20%60storage_slot%60%20the%20first%20time%20it%20identifies%20a%20duplicate%20re-entrancy%20key.%20However%2C%20it%20will%20not%20invoke%20the%20%60set_reentrancy_key_position%60%20function%20on%20each%20%60type_%60%20with%20the%20same%20offset%2C%20meaning%20that%20any%20%60%40nonreentrant(%3Ckey%3E)%60%20entries%20beyond%20the%20first%20would%20have%20an%20%22undefined%22%20storage%20offset%20to%20utilize.%0A%0AThis%20led%20to%20a%20compiler%20panic%5B%5Ecompiler-panic%5D%20when%20attempting%20to%20compile%20contracts%20with%20%60%40nonreentrant%60%20decorators.%20To%20rectify%20this%2C%20a%20further%20change%20was%20necessary%20to%20ensure%20that%20all%20%60%40nonreentrant%60%20decorators%20were%20properly%20aware%20of%20the%20storage%20slot%20they%20need%20to%20operate%20on.%0A%0A%5B%5Ecompiler-panic%5D%3A%20That%20is%2C%20the%20compiler%20would%20simply%20error%20out%20instead%20of%20producing%20any%20code%20at%20all.%20While%20annoying%20for%20the%20user%2C%20a%20compiler%20panic%20is%20considered%20a%20%22safe%22%20error%20because%20it%20will%20not%20emit%20code%20which%20makes%20it%20to%20production.%0A%0A%23%23%23%20PR%232514%3A%20fix%20codegen%20failure%20with%20nonreentrant%20keys%0A%0AThe%20final%20PR%20that%20completed%20the%20alleviation%20of%20the%20%60%40nonreentrant%60%20vulnerability%20was%20%5BPR%232514%5D(https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper%2Fpull%2F2514).%20In%20detail%2C%20it%20expanded%20the%20above%20code%20segment%20to%20ensure%20that%20the%20%60set_reentrancy_key_position%60%20function%20is%20properly%20invoked%20with%20the%20correct%20slot%20allocated%20for%20the%20given%20%60%40nonreentrant%60%20lock.%0A%0A**The%20final%20non-vulnerable%20code%20of%20the%20%60v0.3.1%60%20Vyper%20release%20is%20as%20follows**%3A%0A%0A%60%60%60python%0Afor%20node%20in%20vyper_module.get_children(vy_ast.FunctionDef)%3A%0A%20%20%20%20type_%20%3D%20node._metadata%5B%22type%22%5D%0A%20%20%20%20if%20type_.nonreentrant%20is%20None%3A%0A%20%20%20%20%20%20%20%20continue%0A%20%20%20%20variable_name%20%3D%20f%22nonreentrant.%7Btype_.nonreentrant%7D%22%0A%0A%20%20%20%20%23%20a%20nonreentrant%20key%20can%20appear%20many%20times%20in%20a%20module%20but%20it%0A%20%20%20%20%23%20only%20takes%20one%20slot.%20after%20the%20first%20time%20we%20see%20it%2C%20do%20not%0A%20%20%20%20%23%20increment%20the%20storage%20slot.%0A%20%20%20%20if%20variable_name%20in%20ret%3A%0A%20%20%20%20%20%20%20%20_slot%20%3D%20ret%5Bvariable_name%5D%5B%22slot%22%5D%0A%20%20%20%20%20%20%20%20type_.set_reentrancy_key_position(StorageSlot(_slot))%0A%20%20%20%20%20%20%20%20continue%0A%0A%20%20%20%20type_.set_reentrancy_key_position(StorageSlot(storage_slot))%0A%20%20%20%20%23%20TODO%20this%20could%20have%20better%20typing%20but%20leave%20it%20untyped%20until%0A%20%20%20%20%23%20we%20nail%20down%20the%20format%20better%0A%20%20%20%20ret%5Bvariable_name%5D%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%22type%22%3A%20%22nonreentrant%20lock%22%2C%0A%20%20%20%20%20%20%20%20%22location%22%3A%20%22storage%22%2C%0A%20%20%20%20%20%20%20%20%22slot%22%3A%20storage_slot%2C%0A%20%20%20%20%7D%0A%20%20%20%20%23%20TODO%20use%20one%20byte%20-%20or%20bit%20-%20per%20reentrancy%20key%0A%20%20%20%20%23%20requires%20either%20an%20extra%20SLOAD%20or%20caching%20the%20value%20of%20the%0A%20%20%20%20%23%20location%20in%20memory%20at%20entrance%0A%20%20%20%20storage_slot%20%2B%3D%201%0A%60%60%60%0A%0AAs%20one%20can%20observe%20in%20the%20above%20segment%2C%20the%20%60set_reentrancy_key_position%60%20is%20now%20properly%20invoked%20for%20each%20%60type_%60%20entry%20that%20is%20%60nonreentrant%60%20and%20will%20correctly%20utilize%20the%20same%20%60storage_slot%60%20whenever%20the%20same%20%60key%60%20is%20specified%20in%20a%20%60%40nonreentrant(%3Ckey%3E)%60%20%20decorator.%0A%0AFurthermore%2C%20alongside%20the%20above%20fix%2C%20the%20PR%20included%20**a%20much%20needed%20and%20missing%20test**%20from%20the%20Vyper%20repository%3B%20a%20dedicated%20unit%20test%20**that%20evaluates%20cross-function%20re-entrancy**%3A%0A%0A%60%60%60python%0A%40external%0A%40nonreentrant('protect_special_value')%0Adef%20protected_function(val%3A%20String%5B100%5D%2C%20do_callback%3A%20bool)%20-%3E%20uint256%3A%0A%20%20%20%20self.special_value%20%3D%20val%0A%0A%20%20%20%20if%20do_callback%3A%0A%20%20%20%20%20%20%20%20self.callback.updated_protected()%0A%20%20%20%20%20%20%20%20return%201%0A%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20return%202%0A%0A%40external%0A%40nonreentrant('protect_special_value')%0Adef%20protected_function2(val%3A%20String%5B100%5D%2C%20do_callback%3A%20bool)%20-%3E%20uint256%3A%0A%20%20%20%20self.special_value%20%3D%20val%0A%20%20%20%20if%20do_callback%3A%0A%20%20%20%20%20%20%20%20%23%20call%20other%20function%20with%20same%20nonreentrancy%20key%0A%20%20%20%20%20%20%20%20%23%20--%3E%20(revert%20expected%20here)%20%3C--%0A%20%20%20%20%20%20%20%20Self(self).protected_function(val%2C%20False)%0A%20%20%20%20%20%20%20%20return%201%0A%20%20%20%20return%202%0A%60%60%60%0A%0AHowever%2C%20while%20the%20bug%20was%20identified%2C%20fixed%20and%20tested%20for%20within%20the%20compiler%20codebase%2C%20the%20impact%20to%20production%20contracts%20was%20not%20realized%20at%20the%20time%2C%20and%20protocols%20potentially%20using%20the%20relevant%20compiler%20versions%20were%20not%20explicitly%20notified.%0A%0AThe%20notion%20of%20unique%20%60%3Ckey%3E%60%20values%20that%20can%20be%20re-used%20across%20%60%40nonreentrant%60%20decorators%20only%20exists%20for%20a%20single%20purpose%3B%20cross-function%20re-entrancy%20protection.%20The%20fact%20that%20such%20a%20test%20was%20missing%20from%20the%20Vyper%20repository%20until%20its%20%600.3.1%60%20release%20was%20one%20factor%20in%20contributing%20to%20the%20vulnerability%20being%20introduced%20in%20the%20first%20place%20and%20continuing%20to%20be%20undetected%20for%20as%20long%20as%20it%20did.%0A%0A%23%20Vulnerability%20in%20Summary%0A%0A-%20Versions%20Affected%3A%20%60v0.2.15%60%2C%20%60v0.2.16%60%2C%20%60v0.3.0%60%0A-%20Root%20Cause%3A%20Improper%20remediations%20to%20re-entrancy%20guard%20data%20corruption%20issues%20introduced%20in%20%60v0.2.13%60%0A-%20Vulnerability%20in%20Brief%3A%20All%20%60%40nonreentrant%60%20decorators%20within%20a%20Vyper%20contract%20will%20utilize%20a%20**unique%20storage%20offset%20regardless%20of%20their%20%60key%60**%2C%20meaning%20that%20cross-function%20re-entrancy%20is%20possible%20on%20all%20contracts%20compiled%20with%20the%20susceptible%20versions%0A%0A%23%23%20Conditions%20for%20a%20Profitable%20Vulnerability%0A%0AWhile%20the%20vulnerability%20itself%20is%20simple%20to%20identify%20and%20has%20been%20observed%20across%20a%20variety%20of%20live%20contracts%2C%20its%20profitability%20arises%20from%20a%20very%20specific%20set%20of%20conditions%20that%20need%20to%20be%20met.%20Specifically%3A%0A%0A-%20A%20%60.vy%60%20contract%20compiled%20with%20either%20of%20the%20following%20%60vyper%60%20versions%3A%20%600.2.15%60%2C%20%600.2.16%60%2C%20%600.3.0%60%0A-%20A%20primary%20function%20that%20utilizes%20the%20%60%40nonreentrant%60%20decorator%20with%20a%20specific%20%60key%60%20and%20does%20not%20strictly%20follow%20the%20CEI%20pattern%20(i.e.%20contains%20an%20external%20call%20to%20an%20untrusted%20party%20before%20storage%20updates)%0A-%20A%20secondary%20function%20that%20utilizes%20the%20same%20%60key%60%20and%20would%20be%20affected%20by%20the%20improper%20state%20caused%20by%20the%20primary%20function%0A%0AUnfortunately%2C%20these%20conditions%20are%20the%20exact%20ones%20that%20manifested%20in%20%5Bthe%20Curve.Fi%20liquidity%20pools%20that%20were%20exploited%5D(https%3A%2F%2Fhackmd.io%2F%40LlamaRisk%2FBJzSKHNjn)%20as%20they%20needed%20to%20perform%20an%20external%20distribution%20of%20native%20%60ETH%60%20(which%2C%20on%20the%20EVM%2C%20can%20only%20be%20done%20with%20an%20execution%20context-transferring%20CALL%5B%5Eether-transfers%5D)%20before%20sensitive%20storage%20updates%20were%20performed%20in%20functions%20that%20would%20otherwise%20be%20protected%20by%20a%20properly%20functioning%20%60%40nonreentrant%60%20guard.%0A%0A%5B%5Eether-transfers%5D%3A%20Technically%20there%20are%20other%20ways%20to%20transfer%20ether%2C%20but%20they%20are%20not%20applicable%20here%20at%20the%20time%20of%20this%20writing.%20%5BEIP-5920%5D(https%3A%2F%2Feips.ethereum.org%2FEIPS%2Feip-5920)%20may%20be%20a%20positive%20development%20here.%0A%0A%23%20Summary%20and%20Takeaways%0A%0ABugs%20are%20an%20unfortunate%20and%20stark%20reality%20of%20any%20large%2C%20production%20software%20project.%20What%20we%20can%20do%20is%20to%20try%20and%20mitigate%20bugs%20and%20their%20associated%20risks%20to%20the%20greatest%20extent%20possible.%0A%0AThere%20are%20several%2C%20practical%20steps%20we%20can%20take%20to%20improve%20correctness%20of%20smart%20contracts%20compiled%20with%20Vyper%20going%20forward%3A%0A%0A1.%20Improved%20testing%20of%20the%20compiler%2C%20including%20continuing%20to%20improve%20coverage%2C%20comparing%20compiler%20output%20with%20a%20language%20spec%2C%20and%20utilizing%20formal%20verification%20(FV)%20tools%20for%20compiler%20bytecode%20verification.%0A2.%20Providing%20developers%20with%20tools%20to%20make%20it%20easier%20to%20take%20a%20multi-faceted%20approach%20to%20testing%20their%20code%20--%20including%20source-%20and%20bytecode-%20level%20tests.%0A2.%20Tighter%2C%20two-way%20feedback%20with%20protocols%20using%20Vyper%0A%0ABut%20it%20is%20not%20enough%20to%20just%20focus%20on%20the%20correctness%20of%20the%20latest%20version%20of%20the%20compiler%3B%20due%20to%20the%20immutable%20nature%20of%20smart%20contracts%2C%20contracts%20compiled%20with%20past%20versions%20of%20Vyper%20could%20be%20securing%20a%20significant%20amount%20of%20funds.%0A%0ASecuring%20past%20releases%20of%20Vyper%20**is%20therefore%20another%20important%20new%20axis%20of%20focus%20which%20we%20will%20be%20dedicating%20significant%20resources%20to%20in%20the%20future**.%20It%20is%20just%20as%20important%20as%20introducing%20new%20features%2C%20providing%20bugfixes%20and%20refactoring%20for%20the%20latest%20release.%0A%0AUltimately%2C%20**going%20forward%20we%20want%20to%20take%20the%20lessons%20learned%20from%20recent%20events%20to%20make%20sure%20Vyper%20is%20the%20most%20rock-solid%20and%20secure%20smart%20contract%20language%20and%20compiler%20project%20in%20the%20world.**%20Therefore%2C%20these%20goals%20will%20be%20supported%20by%20a%20variety%20of%20new%20security-related%20initiatives%20within%20and%20beyond%20our%20team%20including%3A%0A%0A-%20**A%20short-term%2C%20competitive%20audit**%20which%20will%20focus%20on%20the%20most%20recent%20version%20of%20Vyper%20in%20partnership%20with%20%5BCodehawks%5D(https%3A%2F%2Fwww.codehawks.com%2F)%0A-%20**Short-term%20and%20long-term%20(open-ended)%20bug%20bounty%20programs**%20spanning%20all%20versions%20of%20the%20Vyper%20compiler%20in%20partnership%20with%20%5BImmunefi%5D(https%3A%2F%2Fimmunefi.com%2F)%0A-%20**The%20Vyper%20Security%20Alliance**%2C%20a%20coordinated%2C%20multi-protocol%20bounty%20program%20for%20helping%20discover%20present%20and%20past%20compiler%20bugs%20affecting%20versions%20of%20Vyper%20securing%20live%20TVL%0A-%20**Collaboration%20with%20multiple%20audit%20firms**%20including%20%5BChainSecurity%5D(https%3A%2F%2Fchainsecurity.com%2F)%2C%20%5BOtterSec%5D(https%3A%2F%2Fosec.io%2F)%2C%20%5BStatemind%5D(https%3A%2F%2Fstatemind.io)%20and%20%5BCertora%5D(https%3A%2F%2Fwww.certora.com%2F)%20to%20review%20past%20versions%20of%20Vyper%20which%20secure%20substantial%20live%20TVL%20and%20to%20help%20review%20the%20compiler%20on%20an%20ongoing%20basis%20going%20forward%0A-%20**Expansion%20of%20the%20team**%3B%20including%20a%20dedicated%20security%20engineering%20role%20meant%20to%20improve%20the%20security%20tooling%20of%20Vyper%20across%20the%20board%2C%20both%20internally%20and%20user-facing%0A-%20**Collaboration%20with%20existing%20security%20toolkits**%20that%20are%20offered%20for%20Solidity%20and%20would%20benefit%20the%20Vyper%20ecosystem%20greatly%0A-%20**Design%20of%20a%20language%20specification**%20which%20will%20contribute%20to%20efforts%20to%20formally%20verify%20and%20help%20testing%20efforts%20of%20the%20compiler%20itself%0A%0AWe%20hope%20to%20see%20you%20using%20Vyper%20soon%20%3A).%20Please%20stay%20tuned%20for%20more%20announcements%20about%20these%20initiatives%20in%20the%20coming%20weeks!%20To%20follow%20along%20with%20further%20announcements%2C%20please%20follow%20the%20%5Bofficial%20Vyper%20twitter%5D(https%3A%2F%2Ftwitter.com%2Fvyperlang).%20To%20help%20contribute%2C%20please%20see%20the%20%5BVyper%20Github%5D(https%3A%2F%2Fgithub.com%2Fvyperlang%2Fvyper)!%20If%20you%20are%20excited%20about%20Vyper%20and%20want%20to%20help%20with%20funding%20--%20or%20just%20want%20to%20chat%20--%20please%20reach%20out%20to%20us%20via%20the%20%5BVyper%20discord%5D(https%3A%2F%2Fdiscord.gg%2F6tw7PTM7C2)%20and%20we%20will%20always%20be%20happy%20to%20welcome%20you%20to%20the%20community.","viewMode":"publish","isOwner":false,"isSignIn":false,"isLiked":false,"isBookmarked":false,"publishType":"view","commentCount":0,"isNotesRecommendationsEnabled":true,"recommendedNotes":[],"lastChangeUserInfo":{"name":"big-tech-sux","path":"big-tech-sux","avatarUrl":"https%3A%2F%2Fwww.gravatar.com%2Favatar%2F03efb121c70a2254450d6ad21b480804%3Fs%3D96"}}`);
  (function () {
    const decodeStringProps = (props) => {
      for (const key in props) {
        if (typeof props[key] === 'string') {
          props[key] = decodeURIComponent(props[key])
        } else if (typeof props[key] === 'object') {
          decodeStringProps(props[key])
        }
      }
    }
    decodeStringProps(window.publishProps)
  })()
</script>

    <script src="https://tally.so/widgets/embed.js"></script>

    
</head>

<body style="display:none;">
    <div id="toasts-container" class="toasts-container z-[2000]"></div>
    <div id="publish-page">###### Vyperlang team with special thanks to Omniscia team[^byline-note]

[^byline-note]: Special thanks to the [Omniscia](https://omniscia.io/) team, which, while not directly affiliated with Vyper, contributed substantial co-authorship, feedback and review  of this post-mortem report

On the 30th of July, 2023, multiple Curve.Fi liquidity pools were exploited as a result of a latent vulnerability in the Vyper compiler, [specifically in versions `0.2.15`, `0.2.16`, and `0.3.0`](https://github.com/vyperlang/vyper/security/advisories/GHSA-5824-cm3x-3c38). While bug was identified and patched by the [`v0.3.1`](https://github.com/vyperlang/vyper/releases/tag/v0.3.1) release, the impact to protocols using the vulnerable compilers was not realized at the time and they were not explicitly notified. The vulnerability itself was an improperly implemented re-entrancy guard that could be bypassed under certain conditions which we will delve into in this report.

While the hacks themselves have been sufficiently covered in other post-mortems [including the official one by Curve.Fi](https://hackmd.io/@LlamaRisk/BJzSKHNjn), we would like to take a deep-dive into what exactly went wrong with the Vyper compiler itself, why the vulnerability was hard to spot, and what the ecosystem as a whole can learn from these incidents.

If you are familiar with the blockchain space and why Vyper exists, **we recommend skipping the Background** section as it contains very basic information that you most likely are aware of.

# Background

## Vyper

Vyper is a contract-oriented, domain-specific, pythonic programming language which targets the Ethereum Virtual Machine (EVM). Its goals include simplicity, pythonicity, security and auditability.

## EVM: A Single-Threaded Non-Concurrent Machine

A common problem that is a concern for code deployed on the EVM is the concept of *re-entrancy*. In contrast to traditional programs, the control flow of a &#34;blockchain program&#34; will be relinquished to the &#34;active&#34; program being executed at any given moment. From hereon, a &#34;blockchain program&#34; will be referred to as a contract.

To elaborate, we can think of all blockchain programs as operating on a single thread with no support for concurrency. Whenever a program invokes another, the entire control flow is passed on to the invoked program. 

## Re-Entrancy: A Widespread Web 3.0 Problem

This means that the original caller&#39;s execution is essentially frozen in time until the invoked program concludes, at which point the caller resumes at the exact point they were left in. While different types of vulnerabilities can arise from this behaviour, the most well-known one is a *re-entrancy*.

As the control flow is relinquished to the invoked contract, the invoked contract can *re-enter* the original caller while it is frozen. The contracts that are vulnerable to this type of attack will contain state updates after their external contract invocation, meaning that when they are frozen **their state is outdated and incorrect**.

## Solutions

The ecosystem has come up with two ways to combat re-entrancy attacks and essentially render them ineffectual; the Checks-Effects-Interactions pattern (CEI) and re-entrancy guards.

### Checks-Effects-Interactions (CEI) Pattern

The CEI pattern is a programming methodology which dictates that a function&#39;s code should execute its security checks first, perform any effects in its storage after, and finally perform interactions with external contracts at the end of the function. 

Should this pattern be followed strictly, the state of a contract during an &#34;interaction&#34; (i.e. control flow relinquishment) will be up-to-date and correct rendering any would-be exploitation impossible regardless of how the contract is re-entered. 

### Re-Entrancy Guards

In most cases the CEI pattern is sufficient, however, the DeFi ecosystem is multi-faceted and oftentimes functions rely **on the result of an external call to proceed with their own execution**. In such cases, the CEI pattern is inapplicable and **a re-entrancy guard must be set in place**.

As one of the core principles in the Vyper language is *security*, Vyper decided to introduce a re-entrancy guard directly at the language-level via the special `@nonreentrant` function decorator. The re-entrancy guard has been a core feature of the language ever since the `v0.1.0-beta.9` release, one of the earliest versions of Vyper.

At their core, both implementations function identically; they set a storage value between two states (activated, inactive). When a function that is marked as `@nonreentrant` is invoked, the flag is:

- Ensured to NOT be in its active state 
- Set to its active state

Once the function&#39;s invocation concludes, the flag is:

- Set to its inactive state

With this mechanism, `@nonreentrant` users can ensure that the function can only be re-invoked **after it concludes**, meaning that **no re-entrancy can occur regardless of what external calls are performed**. More complex forms of re-entrancy attacks exist (i.e. `view` only re-entrancies, cross-contract re-entrancies) but for the purposes of this vulnerability the basic case is what matters.

# Vyper Vulnerability Historical Timeline

## `@nonreentrant`: Tag-Based Re-Entrancy Guards

Ever since their introduction, `@nonreentrant` decorators [always supported a `&lt;key&gt;` to be set](https://github.com/vyperlang/vyper/pull/1264) offering more flexibility compared to a nonreentrancy lock which only applies globally at the contract level.

A simple implementation could be to use a `mapping` that takes the `key` and sets the relevant re-entrancy flag on it, however, such an approach would invoke extra cost due to the `keccak256` gas cost of `mapping` lookups.

As Vyper is a language which does not provide raw storage access to users, it will be fully aware of all storage slots a contract uses when compiling it. As such, it takes on the job of allocating storage slots, which includes ensuring that slots for storage variables and re-entrancy key locks do not overlap with each other.

[PR#1264](https://github.com/vyperlang/vyper/pull/1264) which introduced this feature in the [`v0.1.0-beta.9`](https://github.com/vyperlang/vyper/releases/tag/v0.1.0-beta.9) release of Vyper used a simple approach to ensure no overlap, storing re-entrancy flags at a specific offset from the contract&#39;s original slots (`0xFFFFFF` to be precise).

## Refactoring the Compiler

In tandem with new feature development, beginning in 2018, the Vyper compiler started a [multi-](https://github.com/vyperlang/vyper/issues/1024) [year](https://github.com/vyperlang/vyper/issues/1806) [effort](https://github.com/vyperlang/vyper/issues/2062) to refactor the then single-pass architecture into a multiple pass architecture which would separate the concerns of type checking and semantic analysis into a front-end, distinct from the code generating backend. As with most large refactoring projects, this effort was incremental and piecemeal, being worked on alongside other bugfixes and feature development until finally culminating in 2023 with [PR#3390](https://github.com/vyperlang/vyper/pull/3390).

## Location Optimization: Smarter Allocation of Storage Slots

[PR#2308](https://github.com/vyperlang/vyper/pull/2308) which was part of the Vyper [`v0.2.9`](https://github.com/vyperlang/vyper/releases/tag/v0.2.9) release was meant to make storage allocation smarter by utilizing the first unallocated storage slot available after all slots for regular storage variables of a contract have been processed, instead of starting from the `0xFFFFFF` constant. This would save bytecode space, because in the bytecode, the `PUSH` instructions which precede any load or store of a storage slot by pushing the location of the nonreentrancy key to the stack could use fewer bytes.

## Corruption Avoidance: Proper Offset Calculation

The above PR of the `v0.2.9` release worked well and would guarantee no overlap between re-entrancy flag slots and storage slots so long as the variables that are allocated sequentially in the (physical) front of the storage layout do not span multiple sequential slots. 

As the Vyper language and codebase were undergoing significant refactoring at the time, [PR#2361](https://github.com/vyperlang/vyper/pull/2361) (part of the `v0.2.13` release) introduced a more efficient way to store variables that could span more than 1 storage slot (32 bytes) within a contract. As part of the larger refactoring effort, it also moved slot calculation for regular storage variables out of the existing code generation pass into the new front-end pass, but left slot calculation for re-entrancy keys as it was. Because the slot calculation for re-entrancy keys depended on the results of allocation for the regular storage variables, it ended up keeping two different allocator implementations for regular storage variable allocation between the front-end and codegen passes. This resulted in the offset calculations of [PR#2308](https://github.com/vyperlang/vyper/pull/2308) to be incorrect and require an update.

The update was introduced in [PR#2379](https://github.com/vyperlang/vyper/pull/2379) (part of the `v0.2.14` release), and was meant to calculate the storage offsets for re-entrancy flags correctly by taking into account the correct size of variables declared in storage rather than assuming all of them occupy a single slot (which was true in earlier implementations). However, the second update still had a bug stemming from the differences between the front-end and codegen allocator implementations, which we will describe below.

Because of these bugs, both `v0.2.13` and `v0.2.14` releases were &#34;yanked&#34;[^yank-explanation] shortly after release.

[^yank-explanation]: Briefly speaking, &#34;yanking&#34; means that the tags are available in the repository for historical purposes, but the releases are not published for download. For more information, please see [PEP-592](https://peps.python.org/pep-0592/).

## Decisive Event: Re-Entrancy Guard Corruption in `v0.2.14`

Shortly after `v0.2.14` was released, a Vyper user opened [issue #2393](https://github.com/vyperlang/vyper/issues/2393) in the Vyper GitHub repository denoting that re-entrancy guard tests were failing when they were upgrading the Yearn vault code to `0.2.14`.

Taking a snapshot of [the latest available release of Yearn](https://github.com/yearn/yearn-vaults/tree/efb47d8a84fcb13ceebd3ceb11b126b323bcc05d) when the user opened their issue, proceeded to compile it with `v0.2.14`, and inspecting the **decompiled bytecode** using the [EtherVM Decompiler](https://ethervm.io/decompile) will reveal that the pseudo-code storage offset `storage[0x2e]` is being utilized as the &#34;flag&#34; for the `@nonreentrant(&#34;withdraw&#34;)` keyword in both the `def deposit` and `def withdraw` instances of the `Vault.vy` file.

However, the same storage offset is utilized for the contract-level `managementFee` variable. This can be validated by evaluating the decompiled functions for the `managementFee()` getter function as well as the `setManagementFee` setter function which will re-use the same storage offset.

Compiling the same codebase with `v0.2.13` shows that that the re-entrancy guards were working as expected and were not overlapping in storage. However, [PR#2379](https://github.com/vyperlang/vyper/pull/2379) of the `v0.2.14` release did not fully solve the issue of corruption.

The code of the `v0.2.14` release assigning storage slots for `@nonreentrant` decorators still produced an incorrect interaction between the new front-end code and the existing codegen allocator. Re-entrancy slots still ended up overlapping with regular storage variables due to the different allocation strategies for mapping types between the front-end and codegen allocators. **The data-corruption code of `v0.2.14` is as follows**:

```python 
def get_nonrentrant_counter(self, key):
    &#34;&#34;&#34;
    Nonrentrant locks use a prefix with a counter to minimise deployment cost of a contract.
    We&#39;re able to set the initial re-entrant counter using the sum of the sizes
    of all the storage slots because all storage slots are allocated while parsing
    the module-scope, and re-entrancy locks aren&#39;t allocated until later when parsing
    individual function scopes. This relies on the deprecated _globals attribute
    because the new way of doing things (set_data_positions) doesn&#39;t expose the
    next unallocated storage location.
    &#34;&#34;&#34;
    if key in self._nonrentrant_keys:
        return self._nonrentrant_keys[key]
    else:
        counter = (
            sum(v.size for v in self._globals.values() if not isinstance(v.typ, MappingType))
            + self._nonrentrant_counter
        )
        self._nonrentrant_keys[key] = counter
        self._nonrentrant_counter += 1
        return counter
```

Compare this to the front-end code at the time for calculating the storage layout for regular storage variables.

```python
    available_slot = 0
    for node in vyper_module.get_children(vy_ast.AnnAssign):
        type_ = node.target._metadata[&#34;type&#34;]
        type_.set_position(StorageSlot(available_slot))
        available_slot += math.ceil(type_.size_in_bytes / 32)
```

While this code would correctly consume the `key` value and yield the same `@nonreentrant` storage offset for the same `key` value, it improperly calculated the storage offset. 

Specifically, the old allocator did not allocate a storage slot for `MappingType` entries (i.e. `HashMap`), while the new allocator did. `MappingType` storage entries are never written to but are reserved regardless by the compiler (ref: [Issue 2436](https://github.com/vyperlang/vyper/issues/2436)). This resulted in an inconsistency between the non-reentrant key allocator and the front-end allocator which led to the reported storage corruption.

## Vulnerability Introduced: Malfunctioning Re-Entrancy Locks in `v0.2.15`

After `v0.2.14` was yanked, in an effort to correct the `v0.2.14` release&#39;s corruption of re-entrancy guards, [PR#2391](https://github.com/vyperlang/vyper/pull/2391) included in the `v0.2.15` release was meant to fix the bug introduced in from the previously mentioned [PR#2379](https://github.com/vyperlang/vyper/pull/2379) by moving re-entrancy keys to be allocated physically in front of regular storage variables. In addition, in an effort to reduce the chance of these kinds of issues being introduced again, it completed the removal of the storage slot allocation logic from the codegen pass by moving the logic into the same function in the front-end as regular storage variable allocation. However, in doing so, it removed the old `self._nonreentrant_keys` data structure and, crucially, the accompanying logic which ensured only one lock was allocated per nonreentrant key:

```python
    if key in self._nonrentrant_keys:
        # --&gt; SAFE. only allocate one slot per key &lt;--
        return self._nonrentrant_keys[key]
```

**The actual vulnerability is introduced in the following code of `v0.2.15`**:

```python 
# Allocate storage slots from 0
# note storage is word-addressable, not byte-addressable
storage_slot = 0

for node in vyper_module.get_children(vy_ast.FunctionDef):
    type_ = node._metadata[&#34;type&#34;]
    if type_.nonreentrant is not None:
        # --&gt; BUG! should check nonreentrant key not already allocated &lt;--
        type_.set_reentrancy_key_position(StorageSlot(storage_slot))
        # TODO use one byte - or bit - per reentrancy key
        # requires either an extra SLOAD or caching the value of the
        # location in memory at entrance
        storage_slot += 1
```

The vulnerability arises from how the `storage_slot` offsets of re-entrancy keys were ignoring the actual `&lt;key&gt;` of the `@nonreentrant(&lt;key&gt;)` decorator and were simply reserving a new slot for each seen `@nonreentrant` decorator regardless of what &#34;key&#34; was utilized.

## Latent Period: `v0.2.15`, `v0.2.16` and `v0.3.0`

The vulnerability that was introduced in `v0.2.15` went undetected during the interim releases `v0.2.16` as well as `v0.3.0` due to insufficient tests in the Vyper codebase at the time to detect it, a 4- month period between Jul 21, 2021 and Nov 30, 2021.

**All Vyper contracts that have been compiled with versions `v0.2.15`, `v0.2.16`, and `v0.3.0` are vulnerable to the malfunctioning re-entrancy guard**.

## Remediation: `v0.3.1` Release

The `v0.3.1` release resolved this vulnerability by adjusting how the compiler was allocating data slots to each variable within a contract. The vulnerability was fixed in **two different PRs**.

### PR#2439: Fix unused storage slots

The first PR that partially fixed the vulnerability was [PR#2439](https://github.com/vyperlang/vyper/pull/2439) which contains the following description:

&gt; this is not a semantic bug but an optimization bug since we allocate
more slots than we actually need, leading to &#34;holes&#34; in the slot
allocator -- slots which are allocated but unused.

This description does not actually clearly describe the issue. The description of &#34;holes&#34; arises from inspecting how the compilation output&#39;s `layout` was yielding a single `slot` value for each re-entrant key. To better understand what happened, let&#39;s look at the data allocation function in `v0.3.0`:

```python 
for node in vyper_module.get_children(vy_ast.FunctionDef):
    type_ = node._metadata[&#34;type&#34;]
    if type_.nonreentrant is not None:
        type_.set_reentrancy_key_position(StorageSlot(storage_slot))

        # TODO this could have better typing but leave it untyped until
        # we nail down the format better
        variable_name = f&#34;nonreentrant.{type_.nonreentrant}&#34;
        ret[variable_name] = {
            &#34;type&#34;: &#34;nonreentrant lock&#34;,
            &#34;location&#34;: &#34;storage&#34;,
            &#34;slot&#34;: storage_slot,
        }

        # TODO use one byte - or bit - per reentrancy key
        # requires either an extra SLOAD or caching the value of the
        # location in memory at entrance
        storage_slot += 1
```

The problem with this code is that it was setting the re-entrancy key position of each `type_` (i.e. individual `@nonreentrant` key) to the latest value of `storage_slot`, incrementing on each iteration. This meant that the unique instances of `@nonreentrant(&lt;key&gt;)` were all using a different `storage_slot` value, however, the `ret` entry of `variable_name` was being overwritten on each iteration.

As such, the `layout` output of the compiler contained a single `nonreentrant.&lt;key&gt;` entry and a single storage offset, meaning that inspecting the compiler&#39;s output would appear to simply be &#34;skipping&#34; the storage slots of consecutive `@nonreentrant(&lt;key&gt;)` declarations, as per the [PR&#39;s original rationale](https://github.com/vyperlang/vyper/pull/2439).

**The non-vulnerable code that *partially* patched the vulnerability in the `v0.3.1` release is as follows**:

```python 
for node in vyper_module.get_children(vy_ast.FunctionDef):
    type_ = node._metadata[&#34;type&#34;]
    if type_.nonreentrant is None:
        continue

    variable_name = f&#34;nonreentrant.{type_.nonreentrant}&#34;

    # a nonreentrant key can appear many times in a module but it
    # only takes one slot. ignore it after the first time we see it.
    if variable_name in ret:
        continue

    type_.set_reentrancy_key_position(StorageSlot(storage_slot))

    # TODO this could have better typing but leave it untyped until
    # we nail down the format better
    ret[variable_name] = {
        &#34;type&#34;: &#34;nonreentrant lock&#34;,
        &#34;location&#34;: &#34;storage&#34;,
        &#34;slot&#34;: storage_slot,
    }

    # TODO use one byte - or bit - per reentrancy key
    # requires either an extra SLOAD or caching the value of the
    # location in memory at entrance
    storage_slot += 1
```

The code will now properly allocate a single `storage_slot` the first time it identifies a duplicate re-entrancy key. However, it will not invoke the `set_reentrancy_key_position` function on each `type_` with the same offset, meaning that any `@nonreentrant(&lt;key&gt;)` entries beyond the first would have an &#34;undefined&#34; storage offset to utilize.

This led to a compiler panic[^compiler-panic] when attempting to compile contracts with `@nonreentrant` decorators. To rectify this, a further change was necessary to ensure that all `@nonreentrant` decorators were properly aware of the storage slot they need to operate on.

[^compiler-panic]: That is, the compiler would simply error out instead of producing any code at all. While annoying for the user, a compiler panic is considered a &#34;safe&#34; error because it will not emit code which makes it to production.

### PR#2514: fix codegen failure with nonreentrant keys

The final PR that completed the alleviation of the `@nonreentrant` vulnerability was [PR#2514](https://github.com/vyperlang/vyper/pull/2514). In detail, it expanded the above code segment to ensure that the `set_reentrancy_key_position` function is properly invoked with the correct slot allocated for the given `@nonreentrant` lock.

**The final non-vulnerable code of the `v0.3.1` Vyper release is as follows**:

```python
for node in vyper_module.get_children(vy_ast.FunctionDef):
    type_ = node._metadata[&#34;type&#34;]
    if type_.nonreentrant is None:
        continue
    variable_name = f&#34;nonreentrant.{type_.nonreentrant}&#34;

    # a nonreentrant key can appear many times in a module but it
    # only takes one slot. after the first time we see it, do not
    # increment the storage slot.
    if variable_name in ret:
        _slot = ret[variable_name][&#34;slot&#34;]
        type_.set_reentrancy_key_position(StorageSlot(_slot))
        continue

    type_.set_reentrancy_key_position(StorageSlot(storage_slot))
    # TODO this could have better typing but leave it untyped until
    # we nail down the format better
    ret[variable_name] = {
        &#34;type&#34;: &#34;nonreentrant lock&#34;,
        &#34;location&#34;: &#34;storage&#34;,
        &#34;slot&#34;: storage_slot,
    }
    # TODO use one byte - or bit - per reentrancy key
    # requires either an extra SLOAD or caching the value of the
    # location in memory at entrance
    storage_slot += 1
```

As one can observe in the above segment, the `set_reentrancy_key_position` is now properly invoked for each `type_` entry that is `nonreentrant` and will correctly utilize the same `storage_slot` whenever the same `key` is specified in a `@nonreentrant(&lt;key&gt;)`  decorator.

Furthermore, alongside the above fix, the PR included **a much needed and missing test** from the Vyper repository; a dedicated unit test **that evaluates cross-function re-entrancy**:

```python
@external
@nonreentrant(&#39;protect_special_value&#39;)
def protected_function(val: String[100], do_callback: bool) -&gt; uint256:
    self.special_value = val

    if do_callback:
        self.callback.updated_protected()
        return 1
    else:
        return 2

@external
@nonreentrant(&#39;protect_special_value&#39;)
def protected_function2(val: String[100], do_callback: bool) -&gt; uint256:
    self.special_value = val
    if do_callback:
        # call other function with same nonreentrancy key
        # --&gt; (revert expected here) &lt;--
        Self(self).protected_function(val, False)
        return 1
    return 2
```

However, while the bug was identified, fixed and tested for within the compiler codebase, the impact to production contracts was not realized at the time, and protocols potentially using the relevant compiler versions were not explicitly notified.

The notion of unique `&lt;key&gt;` values that can be re-used across `@nonreentrant` decorators only exists for a single purpose; cross-function re-entrancy protection. The fact that such a test was missing from the Vyper repository until its `0.3.1` release was one factor in contributing to the vulnerability being introduced in the first place and continuing to be undetected for as long as it did.

# Vulnerability in Summary

- Versions Affected: `v0.2.15`, `v0.2.16`, `v0.3.0`
- Root Cause: Improper remediations to re-entrancy guard data corruption issues introduced in `v0.2.13`
- Vulnerability in Brief: All `@nonreentrant` decorators within a Vyper contract will utilize a **unique storage offset regardless of their `key`**, meaning that cross-function re-entrancy is possible on all contracts compiled with the susceptible versions

## Conditions for a Profitable Vulnerability

While the vulnerability itself is simple to identify and has been observed across a variety of live contracts, its profitability arises from a very specific set of conditions that need to be met. Specifically:

- A `.vy` contract compiled with either of the following `vyper` versions: `0.2.15`, `0.2.16`, `0.3.0`
- A primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the CEI pattern (i.e. contains an external call to an untrusted party before storage updates)
- A secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function

Unfortunately, these conditions are the exact ones that manifested in [the Curve.Fi liquidity pools that were exploited](https://hackmd.io/@LlamaRisk/BJzSKHNjn) as they needed to perform an external distribution of native `ETH` (which, on the EVM, can only be done with an execution context-transferring CALL[^ether-transfers]) before sensitive storage updates were performed in functions that would otherwise be protected by a properly functioning `@nonreentrant` guard.

[^ether-transfers]: Technically there are other ways to transfer ether, but they are not applicable here at the time of this writing. [EIP-5920](https://eips.ethereum.org/EIPS/eip-5920) may be a positive development here.

# Summary and Takeaways

Bugs are an unfortunate and stark reality of any large, production software project. What we can do is to try and mitigate bugs and their associated risks to the greatest extent possible.

There are several, practical steps we can take to improve correctness of smart contracts compiled with Vyper going forward:

1. Improved testing of the compiler, including continuing to improve coverage, comparing compiler output with a language spec, and utilizing formal verification (FV) tools for compiler bytecode verification.
2. Providing developers with tools to make it easier to take a multi-faceted approach to testing their code -- including source- and bytecode- level tests.
2. Tighter, two-way feedback with protocols using Vyper

But it is not enough to just focus on the correctness of the latest version of the compiler; due to the immutable nature of smart contracts, contracts compiled with past versions of Vyper could be securing a significant amount of funds.

Securing past releases of Vyper **is therefore another important new axis of focus which we will be dedicating significant resources to in the future**. It is just as important as introducing new features, providing bugfixes and refactoring for the latest release.

Ultimately, **going forward we want to take the lessons learned from recent events to make sure Vyper is the most rock-solid and secure smart contract language and compiler project in the world.** Therefore, these goals will be supported by a variety of new security-related initiatives within and beyond our team including:

- **A short-term, competitive audit** which will focus on the most recent version of Vyper in partnership with [Codehawks](https://www.codehawks.com/)
- **Short-term and long-term (open-ended) bug bounty programs** spanning all versions of the Vyper compiler in partnership with [Immunefi](https://immunefi.com/)
- **The Vyper Security Alliance**, a coordinated, multi-protocol bounty program for helping discover present and past compiler bugs affecting versions of Vyper securing live TVL
- **Collaboration with multiple audit firms** including [ChainSecurity](https://chainsecurity.com/), [OtterSec](https://osec.io/), [Statemind](https://statemind.io) and [Certora](https://www.certora.com/) to review past versions of Vyper which secure substantial live TVL and to help review the compiler on an ongoing basis going forward
- **Expansion of the team**; including a dedicated security engineering role meant to improve the security tooling of Vyper across the board, both internally and user-facing
- **Collaboration with existing security toolkits** that are offered for Solidity and would benefit the Vyper ecosystem greatly
- **Design of a language specification** which will contribute to efforts to formally verify and help testing efforts of the compiler itself

We hope to see you using Vyper soon :). Please stay tuned for more announcements about these initiatives in the coming weeks! To follow along with further announcements, please follow the [official Vyper twitter](https://twitter.com/vyperlang). To help contribute, please see the [Vyper Github](https://github.com/vyperlang/vyper)! If you are excited about Vyper and want to help with funding -- or just want to chat -- please reach out to us via the [Vyper discord](https://discord.gg/6tw7PTM7C2) and we will always be happy to welcome you to the community.</div>
    <!-- signin modal -->

<div class="modal fade signin-modal" tabindex="-1" role="dialog" aria-labelledby="mySmallModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close" style="margin-top: 10px; right: 20px; position: absolute;"><span aria-hidden="true">&times;</span></button>
            






    









<h3>Sign in</h3>

<form data-toggle="validator" role="form" class="form-horizontal" method="post" enctype="application/x-www-form-urlencoded" id="signin-form">
    <div class="hmd-dn"><input type="hidden" name="_csrf" value="wyPvAISH-yFf3F05-zdifOp5zxHIT3YRqPF8"></div>
    <div class="hmd-dn"><input type="hidden" name="create_team" value="false"></div>
    <div class="hmd-dn"><input type="hidden" name="create_paid_team" value="false"></div>
    
    <div class="form-group  ">
        <label for="email" class="control-label">Email</label>
        <label for="inputEmail" class="control-label pull-right errors">
            
        </label>
        <span class="help-block control-label with-errors pull-right" style="margin-top: 14px"></span>
        <div class="input-block">
            
                <input type="email" class="form-control" name="email" placeholder="Your email" required autocomplete="email">
            
            <span class="error-sign"></span>
        </div>
    </div>
    <div class="form-group ">
        <label for="password" class="control-label">Password</label>
        <label for="inputPassword" class="control-label pull-right errors">
            
        </label>
        <span class="help-block control-label with-errors pull-right" style="margin-top: 14px"></span>
        <div class="input-block">
            <input type="password" class="form-control" name="password" placeholder="Your password" required autocomplete="current-password" maxlength="128">
            <span class="error-sign"></span>
            
                <span class="control-label pull-right !text-normal !leading-normal !font-normal !mt-1.5"><a href="https://hackmd.io/settings/forgotPassword" style="text-decoration: underline;">Forgot password</a></span>
            
        </div>
    </div>

    <div style="text-align: center; padding-top: 15px; margin-bottom: 0px;">
        <div
            hidden
            id="hmd-captcha"
            data-provider=""
            data-captcha-data=""
            class="flex justify-center"
        ></div>

        
            <input type="submit" class="neo-btn neo-btn-primary !justify-center !py-3.5 !mx-auto" formaction="https://hackmd.io/login" value="Sign in">
        

        
    </div>
</form>














    
        <p class="separator">or</p>
    

    
        <p>By clicking below, you agree to our <a href="https://hackmd.io/s/terms" target="_blank">terms of service</a>.</p>
    

    












<script id="gsi-client" src="https://accounts.google.com/gsi/client" async defer nonce="be53d6d7-03a0-4028-8ef3-71c7e83aa61d"></script>
<script nonce="be53d6d7-03a0-4028-8ef3-71c7e83aa61d">
    function handleCredentialResponse(response) {
        const form = document.getElementById('sign-in-with-google-form')
        form.children.credential.value = response.credential
        form.children.method.value = location.href.toLowerCase() === 'https://hackmd.io/settings#general' ? 'merge' : 'login'
        form.submit()
    }
    var GSI_READY = new Promise(function (resolve) {
        function initialize () {
            google.accounts.id.initialize({
                client_id: '911617723593-drikdibvvn63slfd6kbqigo8ql1no55s.apps.googleusercontent.com',
                callback: handleCredentialResponse
            })
            const loginPath = '/login'
            const joinPath = '/join'
            const renderButton = function () {
                google.accounts.id.renderButton(
                    document.getElementById('sign-in-with-google-button'),
                    { type: 'standard', width: 250 }
                )
            }
            if (location.pathname.toLowerCase() === loginPath || location.pathname.toLowerCase() === joinPath) {
                renderButton()
            } else {
                $('.signin-modal').one('shown.bs.modal', function () {
                    renderButton()
                })
            }
            resolve()
        }

        window.addEventListener('load', function () { initialize() })
    })
</script>
<form class="hidden" id="sign-in-with-google-form" action="/auth/google" method="post">
    <input type="hidden" name="credential">
    <input type="hidden" name="method">
</form>


<div class="social-buttons-container">
    
    <div id="sign-in-with-google-button"></div>
    
    
    <a href="https://hackmd.io/auth/facebook" class="btn btn-lg btn-block btn-social btn-facebook">
        <i class="fa fa-facebook"></i> Sign in via Facebook
    </a>
    
    
    <a href="https://hackmd.io/auth/twitter" class="btn btn-lg btn-block btn-social btn-twitter">
        <i class="fa fa-twitter"></i> Sign in via Twitter
    </a>
    
    
    <a href="https://hackmd.io/auth/github" class="btn btn-lg btn-block btn-social btn-github">
        <i class="fa fa-github"></i> Sign in via GitHub
    </a>
    
    
    <a href="https://hackmd.io/auth/dropbox" class="btn btn-lg btn-block btn-social btn-dropbox">
        <i class="fa fa-dropbox"></i> Sign in via Dropbox
    </a>
    
    
    
      <a href="#" class="bg-white btn btn-block btn-social btn-web3 bg-gray-800 hocus:bg-[#2b2b2b] text-white hocus:text-white">
          <img src="https://hackmd.io/images/wallet.svg" style="max-height: 20px; margin-top: 8px; margin-left: 6px; border: none;">
          <span class="sign-in-wallet-text">
              Sign in with Wallet
          </span>

          <div class="inline-flex items-center justify-between w-full hidden web3-wallet-info">
              <span>
                   Wallet
                   (
                    <span class="web3-wallet-address"></span>
                   )
              </span>

              <i class="fa fa-arrow-right" aria-hidden="true"></i>
          </div>
      </a>

      <small class="web3-wallet-info hidden text-left hocus:text-white underline hocus:underline block pt-2 ui-disconnect-connected-wallets text-gray-600 cursor-pointer">
          Connect another wallet
      </small>
    
</div>




    <div >
        <p>New to HackMD? <a href="https://hackmd.io/join" class="plausible-event-name=LoginModalSignUp">Sign up</a></p>
    </div>




        </div>
    </div>
</div>

    
    <script src="https://www.googletagmanager.com/gtag/js?id=G-NGVZMM6DR6"></script>
    <script nonce="be53d6d7-03a0-4028-8ef3-71c7e83aa61d">
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        let userid = (document.cookie.match('(^|; )userid=([^;]*)')||0)[2];
        gtag('config', 'G-NGVZMM6DR6', {'user_id': userid});
        
    </script>


    
<script src="https://browser.sentry-cdn.com/5.15.5/bundle.min.js" crossorigin="anonymous"></script>
<script nonce="be53d6d7-03a0-4028-8ef3-71c7e83aa61d">Sentry.init({ dsn: 'https://73410f1915d84abc8b2dd1f1aabd1c82@sentry.hackmd.dev/4', environment: 'production', integrations: function (intrus) { return intrus.filter(function (itr) { return itr.name !== 'TryCatch' }) } });</script>


    
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KLW9Z3"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->



    <script src="https://hackmd.io/api/i18n.js"></script>
     <script src="https://assets.hackmd.io/build/font-vendor.eaa8dd82d4e056021b8c.js" defer="defer"></script><script src="https://assets.hackmd.io/build/common-vendor.04da453a2a68f624f4d4.js" defer="defer"></script><script src="https://assets.hackmd.io/build/pretty-vendor.94ca39727118897623cd.js" defer="defer"></script><script src="https://assets.hackmd.io/build/pretty-common.e537850a918313f6b528.js" defer="defer"></script><script src="https://assets.hackmd.io/build/pretty.542e7daea665107a9e4b.js" defer="defer"></script>

    

</body>
</html>
