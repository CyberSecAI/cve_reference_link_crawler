=== Content from git.kernel.org_863656af_20250110_143109.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=0c31344e22dd8d6b1394c6e4c41d639015bdc671)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=0c31344e22dd8d6b1394c6e4c41d639015bdc671)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=0c31344e22dd8d6b1394c6e4c41d639015bdc671)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=0c31344e22dd8d6b1394c6e4c41d639015bdc671)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Matthew Mirvish <matthew@mm12.xyz> | 2024-05-09 09:11:17 +0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-06-16 13:50:55 +0200 |
| commit | [0c31344e22dd8d6b1394c6e4c41d639015bdc671](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=0c31344e22dd8d6b1394c6e4c41d639015bdc671) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=0c31344e22dd8d6b1394c6e4c41d639015bdc671)) | |
| tree | [feae04386b78949ed03823a4b67b431e2bc2df48](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=0c31344e22dd8d6b1394c6e4c41d639015bdc671) | |
| parent | [6b84900ebb91ef0945fd9969d1620ea66c4779ba](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6b84900ebb91ef0945fd9969d1620ea66c4779ba) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=0c31344e22dd8d6b1394c6e4c41d639015bdc671&id2=6b84900ebb91ef0945fd9969d1620ea66c4779ba)) | |
| download | [linux-0c31344e22dd8d6b1394c6e4c41d639015bdc671.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-0c31344e22dd8d6b1394c6e4c41d639015bdc671.tar.gz) | |

bcache: fix variable length array abuse in btree\_itercommit 3a861560ccb35f2a4f0a4b8207fa7c2a35fc7f31 upstream.
btree\_iter is used in two ways: either allocated on the stack with a
fixed size MAX\_BSETS, or from a mempool with a dynamic size based on the
specific cache set. Previously, the struct had a fixed-length array of
size MAX\_BSETS which was indexed out-of-bounds for the dynamically-sized
iterators, which causes UBSAN to complain.
This patch uses the same approach as in bcachefs's sort\_iter and splits
the iterator into a btree\_iter with a flexible array member and a
btree\_iter\_stack which embeds a btree\_iter as well as a fixed-length
data array.
Cc: stable@vger.kernel.org
Closes: https://bugs.launchpad.net/ubuntu/+source/linux/+bug/2039368
Signed-off-by: Matthew Mirvish <matthew@mm12.xyz>
Signed-off-by: Coly Li <colyli@suse.de>
Link: [https://lore.kernel.org/r/20240509011117.2697-3-colyli@suse.de](https://lore.kernel.org/r/20240509011117.2697-3-colyli%40suse.de)
Signed-off-by: Jens Axboe <axboe@kernel.dk>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=0c31344e22dd8d6b1394c6e4c41d639015bdc671)

| -rw-r--r-- | [drivers/md/bcache/bset.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/bset.c?id=0c31344e22dd8d6b1394c6e4c41d639015bdc671) | 44 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/md/bcache/bset.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/bset.h?id=0c31344e22dd8d6b1394c6e4c41d639015bdc671) | 28 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/md/bcache/btree.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/btree.c?id=0c31344e22dd8d6b1394c6e4c41d639015bdc671) | 40 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/md/bcache/super.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/super.c?id=0c31344e22dd8d6b1394c6e4c41d639015bdc671) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/md/bcache/sysfs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/sysfs.c?id=0c31344e22dd8d6b1394c6e4c41d639015bdc671) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/md/bcache/writeback.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/writeback.c?id=0c31344e22dd8d6b1394c6e4c41d639015bdc671) | 10 | |  |  |  | | --- | --- | --- | |

6 files changed, 70 insertions, 59 deletions

| diff --git a/drivers/md/bcache/bset.c b/drivers/md/bcache/bset.cindex 2bba4d6aaaa28c..463eb13bd0b2a7 100644--- a/[drivers/md/bcache/bset.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/bset.c?id=6b84900ebb91ef0945fd9969d1620ea66c4779ba)+++ b/[drivers/md/bcache/bset.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/bset.c?id=0c31344e22dd8d6b1394c6e4c41d639015bdc671)@@ -54,7 +54,7 @@ void bch\_dump\_bucket(struct btree\_keys \*b) int \_\_bch\_count\_data(struct btree\_keys \*b) { unsigned int ret = 0;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bkey \*k;  if (b->ops->is\_extents)@@ -67,7 +67,7 @@ void \_\_bch\_check\_keys(struct btree\_keys \*b, const char \*fmt, ...) { va\_list args; struct bkey \*k, \*p = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; const char \*err;  for\_each\_key(b, k, &iter) {@@ -879,7 +879,7 @@ unsigned int bch\_btree\_insert\_key(struct btree\_keys \*b, struct bkey \*k, unsigned int status = BTREE\_INSERT\_STATUS\_NO\_INSERT; struct bset \*i = bset\_tree\_last(b)->data; struct bkey \*m, \*prev = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bkey preceding\_key\_on\_stack = ZERO\_KEY; struct bkey \*preceding\_key\_p = &preceding\_key\_on\_stack; @@ -895,9 +895,9 @@ unsigned int bch\_btree\_insert\_key(struct btree\_keys \*b, struct bkey \*k, else preceding\_key(k, &preceding\_key\_p); - m = bch\_btree\_iter\_init(b, &iter, preceding\_key\_p);+ m = bch\_btree\_iter\_stack\_init(b, &iter, preceding\_key\_p); - if (b->ops->insert\_fixup(b, k, &iter, replace\_key))+ if (b->ops->insert\_fixup(b, k, &iter.iter, replace\_key)) return status;  status = BTREE\_INSERT\_STATUS\_INSERT;@@ -1100,33 +1100,33 @@ void bch\_btree\_iter\_push(struct btree\_iter \*iter, struct bkey \*k, btree\_iter\_cmp)); } -static struct bkey \*\_\_bch\_btree\_iter\_init(struct btree\_keys \*b,- struct btree\_iter \*iter,- struct bkey \*search,- struct bset\_tree \*start)+static struct bkey \*\_\_bch\_btree\_iter\_stack\_init(struct btree\_keys \*b,+ struct btree\_iter\_stack \*iter,+ struct bkey \*search,+ struct bset\_tree \*start) { struct bkey \*ret = NULL; - iter->size = ARRAY\_SIZE(iter->data);- iter->used = 0;+ iter->iter.size = ARRAY\_SIZE(iter->stack\_data);+ iter->iter.used = 0;  #ifdef CONFIG\_BCACHE\_DEBUG- iter->b = b;+ iter->iter.b = b; #endif  for (; start <= bset\_tree\_last(b); start++) { ret = bch\_bset\_search(b, start, search);- bch\_btree\_iter\_push(iter, ret, bset\_bkey\_last(start->data));+ bch\_btree\_iter\_push(&iter->iter, ret, bset\_bkey\_last(start->data)); }  return ret; } -struct bkey \*bch\_btree\_iter\_init(struct btree\_keys \*b,- struct btree\_iter \*iter,+struct bkey \*bch\_btree\_iter\_stack\_init(struct btree\_keys \*b,+ struct btree\_iter\_stack \*iter, struct bkey \*search) {- return \_\_bch\_btree\_iter\_init(b, iter, search, b->set);+ return \_\_bch\_btree\_iter\_stack\_init(b, iter, search, b->set); }  static inline struct bkey \*\_\_bch\_btree\_iter\_next(struct btree\_iter \*iter,@@ -1293,10 +1293,10 @@ void bch\_btree\_sort\_partial(struct btree\_keys \*b, unsigned int start, struct bset\_sort\_state \*state) { size\_t order = b->page\_order, keys = 0;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; int oldsize = bch\_count\_data(b); - \_\_bch\_btree\_iter\_init(b, &iter, NULL, &b->set[start]);+ \_\_bch\_btree\_iter\_stack\_init(b, &iter, NULL, &b->set[start]);  if (start) { unsigned int i;@@ -1307,7 +1307,7 @@ void bch\_btree\_sort\_partial(struct btree\_keys \*b, unsigned int start, order = get\_order(\_\_set\_bytes(b->set->data, keys)); } - \_\_btree\_sort(b, &iter, start, order, false, state);+ \_\_btree\_sort(b, &iter.iter, start, order, false, state);  EBUG\_ON(oldsize >= 0 && bch\_count\_data(b) != oldsize); }@@ -1323,11 +1323,11 @@ void bch\_btree\_sort\_into(struct btree\_keys \*b, struct btree\_keys \*new, struct bset\_sort\_state \*state) { uint64\_t start\_time = local\_clock();- struct btree\_iter iter;+ struct btree\_iter\_stack iter; - bch\_btree\_iter\_init(b, &iter, NULL);+ bch\_btree\_iter\_stack\_init(b, &iter, NULL); - btree\_mergesort(b, new->set->data, &iter, false, true);+ btree\_mergesort(b, new->set->data, &iter.iter, false, true);  bch\_time\_stats\_update(&state->time, start\_time); diff --git a/drivers/md/bcache/bset.h b/drivers/md/bcache/bset.hindex d795c84246b018..011f6062c4c04f 100644--- a/[drivers/md/bcache/bset.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/bset.h?id=6b84900ebb91ef0945fd9969d1620ea66c4779ba)+++ b/[drivers/md/bcache/bset.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/bset.h?id=0c31344e22dd8d6b1394c6e4c41d639015bdc671)@@ -321,7 +321,14 @@ struct btree\_iter { #endif struct btree\_iter\_set { struct bkey \*k, \*end;- } data[MAX\_BSETS];+ } data[];+};++/\* Fixed-size btree\_iter that can be allocated on the stack \*/++struct btree\_iter\_stack {+ struct btree\_iter iter;+ struct btree\_iter\_set stack\_data[MAX\_BSETS]; };  typedef bool (\*ptr\_filter\_fn)(struct btree\_keys \*b, const struct bkey \*k);@@ -333,9 +340,9 @@ struct bkey \*bch\_btree\_iter\_next\_filter(struct btree\_iter \*iter,  void bch\_btree\_iter\_push(struct btree\_iter \*iter, struct bkey \*k, struct bkey \*end);-struct bkey \*bch\_btree\_iter\_init(struct btree\_keys \*b,- struct btree\_iter \*iter,- struct bkey \*search);+struct bkey \*bch\_btree\_iter\_stack\_init(struct btree\_keys \*b,+ struct btree\_iter\_stack \*iter,+ struct bkey \*search);  struct bkey \*\_\_bch\_bset\_search(struct btree\_keys \*b, struct bset\_tree \*t, const struct bkey \*search);@@ -350,13 +357,14 @@ static inline struct bkey \*bch\_bset\_search(struct btree\_keys \*b, return search ? \_\_bch\_bset\_search(b, t, search) : t->data->start; } -#define for\_each\_key\_filter(b, k, iter, filter) \- for (bch\_btree\_iter\_init((b), (iter), NULL); \- ((k) = bch\_btree\_iter\_next\_filter((iter), (b), filter));)+#define for\_each\_key\_filter(b, k, stack\_iter, filter) \+ for (bch\_btree\_iter\_stack\_init((b), (stack\_iter), NULL); \+ ((k) = bch\_btree\_iter\_next\_filter(&((stack\_iter)->iter), (b), \+ filter));) -#define for\_each\_key(b, k, iter) \- for (bch\_btree\_iter\_init((b), (iter), NULL); \- ((k) = bch\_btree\_iter\_next(iter));)+#define for\_each\_key(b, k, stack\_iter) \+ for (bch\_btree\_iter\_stack\_init((b), (stack\_iter), NULL); \+ ((k) = bch\_btree\_iter\_next(&((stack\_iter)->iter)));)  /\* Sorting \*/ diff --git a/drivers/md/bcache/btree.c b/drivers/md/bcache/btree.cindex 196cdacce38f25..d011a7154d3304 100644--- a/[drivers/md/bcache/btree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/btree.c?id=6b84900ebb91ef0945fd9969d1620ea66c4779ba)+++ b/[drivers/md/bcache/btree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/btree.c?id=0c31344e22dd8d6b1394c6e4c41d639015bdc671)@@ -1309,7 +1309,7 @@ static bool btree\_gc\_mark\_node(struct btree \*b, struct gc\_stat \*gc) uint8\_t stale = 0; unsigned int keys = 0, good\_keys = 0; struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bset\_tree \*t;  gc->nodes++;@@ -1570,7 +1570,7 @@ static int btree\_gc\_rewrite\_node(struct btree \*b, struct btree\_op \*op, static unsigned int btree\_gc\_count\_keys(struct btree \*b) { struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; unsigned int ret = 0;  for\_each\_key\_filter(&b->keys, k, &iter, bch\_ptr\_bad)@@ -1611,17 +1611,18 @@ static int btree\_gc\_recurse(struct btree \*b, struct btree\_op \*op, int ret = 0; bool should\_rewrite; struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct gc\_merge\_info r[GC\_MERGE\_NODES]; struct gc\_merge\_info \*i, \*last = r + ARRAY\_SIZE(r) - 1; - bch\_btree\_iter\_init(&b->keys, &iter, &b->c->gc\_done);+ bch\_btree\_iter\_stack\_init(&b->keys, &iter, &b->c->gc\_done);  for (i = r; i < r + ARRAY\_SIZE(r); i++) i->b = ERR\_PTR(-EINTR);  while (1) {- k = bch\_btree\_iter\_next\_filter(&iter, &b->keys, bch\_ptr\_bad);+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &b->keys,+ bch\_ptr\_bad); if (k) { r->b = bch\_btree\_node\_get(b->c, op, k, b->level - 1, true, b);@@ -1911,7 +1912,7 @@ static int bch\_btree\_check\_recurse(struct btree \*b, struct btree\_op \*op) { int ret = 0; struct bkey \*k, \*p = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter;  for\_each\_key\_filter(&b->keys, k, &iter, bch\_ptr\_invalid) bch\_initial\_mark\_key(b->c, b->level, k);@@ -1919,10 +1920,10 @@ static int bch\_btree\_check\_recurse(struct btree \*b, struct btree\_op \*op) bch\_initial\_mark\_key(b->c, b->level + 1, &b->key);  if (b->level) {- bch\_btree\_iter\_init(&b->keys, &iter, NULL);+ bch\_btree\_iter\_stack\_init(&b->keys, &iter, NULL);  do {- k = bch\_btree\_iter\_next\_filter(&iter, &b->keys,+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &b->keys, bch\_ptr\_bad); if (k) { btree\_node\_prefetch(b, k);@@ -1950,7 +1951,7 @@ static int bch\_btree\_check\_thread(void \*arg) struct btree\_check\_info \*info = arg; struct btree\_check\_state \*check\_state = info->state; struct cache\_set \*c = check\_state->c;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bkey \*k, \*p; int cur\_idx, prev\_idx, skip\_nr; @@ -1959,8 +1960,8 @@ static int bch\_btree\_check\_thread(void \*arg) ret = 0;  /\* root node keys are checked before thread created \*/- bch\_btree\_iter\_init(&c->root->keys, &iter, NULL);- k = bch\_btree\_iter\_next\_filter(&iter, &c->root->keys, bch\_ptr\_bad);+ bch\_btree\_iter\_stack\_init(&c->root->keys, &iter, NULL);+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &c->root->keys, bch\_ptr\_bad); BUG\_ON(!k);  p = k;@@ -1978,7 +1979,7 @@ static int bch\_btree\_check\_thread(void \*arg) skip\_nr = cur\_idx - prev\_idx;  while (skip\_nr) {- k = bch\_btree\_iter\_next\_filter(&iter,+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &c->root->keys, bch\_ptr\_bad); if (k)@@ -2051,7 +2052,7 @@ int bch\_btree\_check(struct cache\_set \*c) int ret = 0; int i; struct bkey \*k = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct btree\_check\_state check\_state;  /\* check and mark root node keys \*/@@ -2547,11 +2548,11 @@ static int bch\_btree\_map\_nodes\_recurse(struct btree \*b, struct btree\_op \*op,  if (b->level) { struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; - bch\_btree\_iter\_init(&b->keys, &iter, from);+ bch\_btree\_iter\_stack\_init(&b->keys, &iter, from); - while ((k = bch\_btree\_iter\_next\_filter(&iter, &b->keys,+ while ((k = bch\_btree\_iter\_next\_filter(&iter.iter, &b->keys, bch\_ptr\_bad))) { ret = bcache\_btree(map\_nodes\_recurse, k, b, op, from, fn, flags);@@ -2580,11 +2581,12 @@ int bch\_btree\_map\_keys\_recurse(struct btree \*b, struct btree\_op \*op, { int ret = MAP\_CONTINUE; struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; - bch\_btree\_iter\_init(&b->keys, &iter, from);+ bch\_btree\_iter\_stack\_init(&b->keys, &iter, from); - while ((k = bch\_btree\_iter\_next\_filter(&iter, &b->keys, bch\_ptr\_bad))) {+ while ((k = bch\_btree\_iter\_next\_filter(&iter.iter, &b->keys,+ bch\_ptr\_bad))) { ret = !b->level ? fn(op, b, k) : bcache\_btree(map\_keys\_recurse, k,diff --git a/drivers/md/bcache/super.c b/drivers/md/bcache/super.cindex 330bcd9ea4a9cc..b0819be0486e63 100644--- a/[drivers/md/bcache/super.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/super.c?id=6b84900ebb91ef0945fd9969d1620ea66c4779ba)+++ b/[drivers/md/bcache/super.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/super.c?id=0c31344e22dd8d6b1394c6e4c41d639015bdc671)@@ -1914,8 +1914,9 @@ struct cache\_set \*bch\_cache\_set\_alloc(struct cache\_sb \*sb) INIT\_LIST\_HEAD(&c->btree\_cache\_freed); INIT\_LIST\_HEAD(&c->data\_buckets); - iter\_size = ((meta\_bucket\_pages(sb) \* PAGE\_SECTORS) / sb->block\_size + 1) \*- sizeof(struct btree\_iter\_set);+ iter\_size = sizeof(struct btree\_iter) ++ ((meta\_bucket\_pages(sb) \* PAGE\_SECTORS) / sb->block\_size) \*+ sizeof(struct btree\_iter\_set);  c->devices = kcalloc(c->nr\_uuids, sizeof(void \*), GFP\_KERNEL); if (!c->devices)diff --git a/drivers/md/bcache/sysfs.c b/drivers/md/bcache/sysfs.cindex 6956beb55326f5..826b14cae4e58e 100644--- a/[drivers/md/bcache/sysfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/sysfs.c?id=6b84900ebb91ef0945fd9969d1620ea66c4779ba)+++ b/[drivers/md/bcache/sysfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/sysfs.c?id=0c31344e22dd8d6b1394c6e4c41d639015bdc671)@@ -660,7 +660,7 @@ static unsigned int bch\_root\_usage(struct cache\_set \*c) unsigned int bytes = 0; struct bkey \*k; struct btree \*b;- struct btree\_iter iter;+ struct btree\_iter\_stack iter;  goto lock\_root; diff --git a/drivers/md/bcache/writeback.c b/drivers/md/bcache/writeback.cindex 8827a6f130ad7f..792e070ccf38ba 100644--- a/[drivers/md/bcache/writeback.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/writeback.c?id=6b84900ebb91ef0945fd9969d1620ea66c4779ba)+++ b/[drivers/md/bcache/writeback.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/writeback.c?id=0c31344e22dd8d6b1394c6e4c41d639015bdc671)@@ -908,15 +908,15 @@ static int bch\_dirty\_init\_thread(void \*arg) struct dirty\_init\_thrd\_info \*info = arg; struct bch\_dirty\_init\_state \*state = info->state; struct cache\_set \*c = state->c;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bkey \*k, \*p; int cur\_idx, prev\_idx, skip\_nr;  k = p = NULL; prev\_idx = 0; - bch\_btree\_iter\_init(&c->root->keys, &iter, NULL);- k = bch\_btree\_iter\_next\_filter(&iter, &c->root->keys, bch\_ptr\_bad);+ bch\_btree\_iter\_stack\_init(&c->root->keys, &iter, NULL);+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &c->root->keys, bch\_ptr\_bad); BUG\_ON(!k);  p = k;@@ -930,7 +930,7 @@ static int bch\_dirty\_init\_thread(void \*arg) skip\_nr = cur\_idx - prev\_idx;  while (skip\_nr) {- k = bch\_btree\_iter\_next\_filter(&iter,+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &c->root->keys, bch\_ptr\_bad); if (k)@@ -979,7 +979,7 @@ void bch\_sectors\_dirty\_init(struct bcache\_device \*d) int i; struct btree \*b = NULL; struct bkey \*k = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct sectors\_dirty\_init op; struct cache\_set \*c = d->c; struct bch\_dirty\_init\_state state; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 14:29:47 +0000



=== Content from git.kernel.org_356a0a3f_20250110_143112.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=6479b9f41583b013041943c4602e1ad61cec8148)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=6479b9f41583b013041943c4602e1ad61cec8148)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6479b9f41583b013041943c4602e1ad61cec8148)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=6479b9f41583b013041943c4602e1ad61cec8148)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Matthew Mirvish <matthew@mm12.xyz> | 2024-05-09 09:11:17 +0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-06-16 13:47:32 +0200 |
| commit | [6479b9f41583b013041943c4602e1ad61cec8148](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6479b9f41583b013041943c4602e1ad61cec8148) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=6479b9f41583b013041943c4602e1ad61cec8148)) | |
| tree | [6845efc6766d11133c7640dafdd13cb1599ca766](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=6479b9f41583b013041943c4602e1ad61cec8148) | |
| parent | [5b0a3dc3e87821acb80e841b464d335aff242691](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=5b0a3dc3e87821acb80e841b464d335aff242691) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=6479b9f41583b013041943c4602e1ad61cec8148&id2=5b0a3dc3e87821acb80e841b464d335aff242691)) | |
| download | [linux-6479b9f41583b013041943c4602e1ad61cec8148.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-6479b9f41583b013041943c4602e1ad61cec8148.tar.gz) | |

bcache: fix variable length array abuse in btree\_itercommit 3a861560ccb35f2a4f0a4b8207fa7c2a35fc7f31 upstream.
btree\_iter is used in two ways: either allocated on the stack with a
fixed size MAX\_BSETS, or from a mempool with a dynamic size based on the
specific cache set. Previously, the struct had a fixed-length array of
size MAX\_BSETS which was indexed out-of-bounds for the dynamically-sized
iterators, which causes UBSAN to complain.
This patch uses the same approach as in bcachefs's sort\_iter and splits
the iterator into a btree\_iter with a flexible array member and a
btree\_iter\_stack which embeds a btree\_iter as well as a fixed-length
data array.
Cc: stable@vger.kernel.org
Closes: https://bugs.launchpad.net/ubuntu/+source/linux/+bug/2039368
Signed-off-by: Matthew Mirvish <matthew@mm12.xyz>
Signed-off-by: Coly Li <colyli@suse.de>
Link: [https://lore.kernel.org/r/20240509011117.2697-3-colyli@suse.de](https://lore.kernel.org/r/20240509011117.2697-3-colyli%40suse.de)
Signed-off-by: Jens Axboe <axboe@kernel.dk>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=6479b9f41583b013041943c4602e1ad61cec8148)

| -rw-r--r-- | [drivers/md/bcache/bset.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/bset.c?id=6479b9f41583b013041943c4602e1ad61cec8148) | 44 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/md/bcache/bset.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/bset.h?id=6479b9f41583b013041943c4602e1ad61cec8148) | 28 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/md/bcache/btree.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/btree.c?id=6479b9f41583b013041943c4602e1ad61cec8148) | 40 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/md/bcache/super.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/super.c?id=6479b9f41583b013041943c4602e1ad61cec8148) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/md/bcache/sysfs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/sysfs.c?id=6479b9f41583b013041943c4602e1ad61cec8148) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/md/bcache/writeback.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/writeback.c?id=6479b9f41583b013041943c4602e1ad61cec8148) | 10 | |  |  |  | | --- | --- | --- | |

6 files changed, 70 insertions, 59 deletions

| diff --git a/drivers/md/bcache/bset.c b/drivers/md/bcache/bset.cindex 2bba4d6aaaa28c..463eb13bd0b2a7 100644--- a/[drivers/md/bcache/bset.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/bset.c?id=5b0a3dc3e87821acb80e841b464d335aff242691)+++ b/[drivers/md/bcache/bset.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/bset.c?id=6479b9f41583b013041943c4602e1ad61cec8148)@@ -54,7 +54,7 @@ void bch\_dump\_bucket(struct btree\_keys \*b) int \_\_bch\_count\_data(struct btree\_keys \*b) { unsigned int ret = 0;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bkey \*k;  if (b->ops->is\_extents)@@ -67,7 +67,7 @@ void \_\_bch\_check\_keys(struct btree\_keys \*b, const char \*fmt, ...) { va\_list args; struct bkey \*k, \*p = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; const char \*err;  for\_each\_key(b, k, &iter) {@@ -879,7 +879,7 @@ unsigned int bch\_btree\_insert\_key(struct btree\_keys \*b, struct bkey \*k, unsigned int status = BTREE\_INSERT\_STATUS\_NO\_INSERT; struct bset \*i = bset\_tree\_last(b)->data; struct bkey \*m, \*prev = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bkey preceding\_key\_on\_stack = ZERO\_KEY; struct bkey \*preceding\_key\_p = &preceding\_key\_on\_stack; @@ -895,9 +895,9 @@ unsigned int bch\_btree\_insert\_key(struct btree\_keys \*b, struct bkey \*k, else preceding\_key(k, &preceding\_key\_p); - m = bch\_btree\_iter\_init(b, &iter, preceding\_key\_p);+ m = bch\_btree\_iter\_stack\_init(b, &iter, preceding\_key\_p); - if (b->ops->insert\_fixup(b, k, &iter, replace\_key))+ if (b->ops->insert\_fixup(b, k, &iter.iter, replace\_key)) return status;  status = BTREE\_INSERT\_STATUS\_INSERT;@@ -1100,33 +1100,33 @@ void bch\_btree\_iter\_push(struct btree\_iter \*iter, struct bkey \*k, btree\_iter\_cmp)); } -static struct bkey \*\_\_bch\_btree\_iter\_init(struct btree\_keys \*b,- struct btree\_iter \*iter,- struct bkey \*search,- struct bset\_tree \*start)+static struct bkey \*\_\_bch\_btree\_iter\_stack\_init(struct btree\_keys \*b,+ struct btree\_iter\_stack \*iter,+ struct bkey \*search,+ struct bset\_tree \*start) { struct bkey \*ret = NULL; - iter->size = ARRAY\_SIZE(iter->data);- iter->used = 0;+ iter->iter.size = ARRAY\_SIZE(iter->stack\_data);+ iter->iter.used = 0;  #ifdef CONFIG\_BCACHE\_DEBUG- iter->b = b;+ iter->iter.b = b; #endif  for (; start <= bset\_tree\_last(b); start++) { ret = bch\_bset\_search(b, start, search);- bch\_btree\_iter\_push(iter, ret, bset\_bkey\_last(start->data));+ bch\_btree\_iter\_push(&iter->iter, ret, bset\_bkey\_last(start->data)); }  return ret; } -struct bkey \*bch\_btree\_iter\_init(struct btree\_keys \*b,- struct btree\_iter \*iter,+struct bkey \*bch\_btree\_iter\_stack\_init(struct btree\_keys \*b,+ struct btree\_iter\_stack \*iter, struct bkey \*search) {- return \_\_bch\_btree\_iter\_init(b, iter, search, b->set);+ return \_\_bch\_btree\_iter\_stack\_init(b, iter, search, b->set); }  static inline struct bkey \*\_\_bch\_btree\_iter\_next(struct btree\_iter \*iter,@@ -1293,10 +1293,10 @@ void bch\_btree\_sort\_partial(struct btree\_keys \*b, unsigned int start, struct bset\_sort\_state \*state) { size\_t order = b->page\_order, keys = 0;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; int oldsize = bch\_count\_data(b); - \_\_bch\_btree\_iter\_init(b, &iter, NULL, &b->set[start]);+ \_\_bch\_btree\_iter\_stack\_init(b, &iter, NULL, &b->set[start]);  if (start) { unsigned int i;@@ -1307,7 +1307,7 @@ void bch\_btree\_sort\_partial(struct btree\_keys \*b, unsigned int start, order = get\_order(\_\_set\_bytes(b->set->data, keys)); } - \_\_btree\_sort(b, &iter, start, order, false, state);+ \_\_btree\_sort(b, &iter.iter, start, order, false, state);  EBUG\_ON(oldsize >= 0 && bch\_count\_data(b) != oldsize); }@@ -1323,11 +1323,11 @@ void bch\_btree\_sort\_into(struct btree\_keys \*b, struct btree\_keys \*new, struct bset\_sort\_state \*state) { uint64\_t start\_time = local\_clock();- struct btree\_iter iter;+ struct btree\_iter\_stack iter; - bch\_btree\_iter\_init(b, &iter, NULL);+ bch\_btree\_iter\_stack\_init(b, &iter, NULL); - btree\_mergesort(b, new->set->data, &iter, false, true);+ btree\_mergesort(b, new->set->data, &iter.iter, false, true);  bch\_time\_stats\_update(&state->time, start\_time); diff --git a/drivers/md/bcache/bset.h b/drivers/md/bcache/bset.hindex d795c84246b018..011f6062c4c04f 100644--- a/[drivers/md/bcache/bset.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/bset.h?id=5b0a3dc3e87821acb80e841b464d335aff242691)+++ b/[drivers/md/bcache/bset.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/bset.h?id=6479b9f41583b013041943c4602e1ad61cec8148)@@ -321,7 +321,14 @@ struct btree\_iter { #endif struct btree\_iter\_set { struct bkey \*k, \*end;- } data[MAX\_BSETS];+ } data[];+};++/\* Fixed-size btree\_iter that can be allocated on the stack \*/++struct btree\_iter\_stack {+ struct btree\_iter iter;+ struct btree\_iter\_set stack\_data[MAX\_BSETS]; };  typedef bool (\*ptr\_filter\_fn)(struct btree\_keys \*b, const struct bkey \*k);@@ -333,9 +340,9 @@ struct bkey \*bch\_btree\_iter\_next\_filter(struct btree\_iter \*iter,  void bch\_btree\_iter\_push(struct btree\_iter \*iter, struct bkey \*k, struct bkey \*end);-struct bkey \*bch\_btree\_iter\_init(struct btree\_keys \*b,- struct btree\_iter \*iter,- struct bkey \*search);+struct bkey \*bch\_btree\_iter\_stack\_init(struct btree\_keys \*b,+ struct btree\_iter\_stack \*iter,+ struct bkey \*search);  struct bkey \*\_\_bch\_bset\_search(struct btree\_keys \*b, struct bset\_tree \*t, const struct bkey \*search);@@ -350,13 +357,14 @@ static inline struct bkey \*bch\_bset\_search(struct btree\_keys \*b, return search ? \_\_bch\_bset\_search(b, t, search) : t->data->start; } -#define for\_each\_key\_filter(b, k, iter, filter) \- for (bch\_btree\_iter\_init((b), (iter), NULL); \- ((k) = bch\_btree\_iter\_next\_filter((iter), (b), filter));)+#define for\_each\_key\_filter(b, k, stack\_iter, filter) \+ for (bch\_btree\_iter\_stack\_init((b), (stack\_iter), NULL); \+ ((k) = bch\_btree\_iter\_next\_filter(&((stack\_iter)->iter), (b), \+ filter));) -#define for\_each\_key(b, k, iter) \- for (bch\_btree\_iter\_init((b), (iter), NULL); \- ((k) = bch\_btree\_iter\_next(iter));)+#define for\_each\_key(b, k, stack\_iter) \+ for (bch\_btree\_iter\_stack\_init((b), (stack\_iter), NULL); \+ ((k) = bch\_btree\_iter\_next(&((stack\_iter)->iter)));)  /\* Sorting \*/ diff --git a/drivers/md/bcache/btree.c b/drivers/md/bcache/btree.cindex b709c2fde782a4..30d6973de258b8 100644--- a/[drivers/md/bcache/btree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/btree.c?id=5b0a3dc3e87821acb80e841b464d335aff242691)+++ b/[drivers/md/bcache/btree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/btree.c?id=6479b9f41583b013041943c4602e1ad61cec8148)@@ -1304,7 +1304,7 @@ static bool btree\_gc\_mark\_node(struct btree \*b, struct gc\_stat \*gc) uint8\_t stale = 0; unsigned int keys = 0, good\_keys = 0; struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bset\_tree \*t;  gc->nodes++;@@ -1565,7 +1565,7 @@ static int btree\_gc\_rewrite\_node(struct btree \*b, struct btree\_op \*op, static unsigned int btree\_gc\_count\_keys(struct btree \*b) { struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; unsigned int ret = 0;  for\_each\_key\_filter(&b->keys, k, &iter, bch\_ptr\_bad)@@ -1606,17 +1606,18 @@ static int btree\_gc\_recurse(struct btree \*b, struct btree\_op \*op, int ret = 0; bool should\_rewrite; struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct gc\_merge\_info r[GC\_MERGE\_NODES]; struct gc\_merge\_info \*i, \*last = r + ARRAY\_SIZE(r) - 1; - bch\_btree\_iter\_init(&b->keys, &iter, &b->c->gc\_done);+ bch\_btree\_iter\_stack\_init(&b->keys, &iter, &b->c->gc\_done);  for (i = r; i < r + ARRAY\_SIZE(r); i++) i->b = ERR\_PTR(-EINTR);  while (1) {- k = bch\_btree\_iter\_next\_filter(&iter, &b->keys, bch\_ptr\_bad);+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &b->keys,+ bch\_ptr\_bad); if (k) { r->b = bch\_btree\_node\_get(b->c, op, k, b->level - 1, true, b);@@ -1906,7 +1907,7 @@ static int bch\_btree\_check\_recurse(struct btree \*b, struct btree\_op \*op) { int ret = 0; struct bkey \*k, \*p = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter;  for\_each\_key\_filter(&b->keys, k, &iter, bch\_ptr\_invalid) bch\_initial\_mark\_key(b->c, b->level, k);@@ -1914,10 +1915,10 @@ static int bch\_btree\_check\_recurse(struct btree \*b, struct btree\_op \*op) bch\_initial\_mark\_key(b->c, b->level + 1, &b->key);  if (b->level) {- bch\_btree\_iter\_init(&b->keys, &iter, NULL);+ bch\_btree\_iter\_stack\_init(&b->keys, &iter, NULL);  do {- k = bch\_btree\_iter\_next\_filter(&iter, &b->keys,+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &b->keys, bch\_ptr\_bad); if (k) { btree\_node\_prefetch(b, k);@@ -1945,7 +1946,7 @@ static int bch\_btree\_check\_thread(void \*arg) struct btree\_check\_info \*info = arg; struct btree\_check\_state \*check\_state = info->state; struct cache\_set \*c = check\_state->c;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bkey \*k, \*p; int cur\_idx, prev\_idx, skip\_nr; @@ -1954,8 +1955,8 @@ static int bch\_btree\_check\_thread(void \*arg) ret = 0;  /\* root node keys are checked before thread created \*/- bch\_btree\_iter\_init(&c->root->keys, &iter, NULL);- k = bch\_btree\_iter\_next\_filter(&iter, &c->root->keys, bch\_ptr\_bad);+ bch\_btree\_iter\_stack\_init(&c->root->keys, &iter, NULL);+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &c->root->keys, bch\_ptr\_bad); BUG\_ON(!k);  p = k;@@ -1973,7 +1974,7 @@ static int bch\_btree\_check\_thread(void \*arg) skip\_nr = cur\_idx - prev\_idx;  while (skip\_nr) {- k = bch\_btree\_iter\_next\_filter(&iter,+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &c->root->keys, bch\_ptr\_bad); if (k)@@ -2046,7 +2047,7 @@ int bch\_btree\_check(struct cache\_set \*c) int ret = 0; int i; struct bkey \*k = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct btree\_check\_state check\_state;  /\* check and mark root node keys \*/@@ -2542,11 +2543,11 @@ static int bch\_btree\_map\_nodes\_recurse(struct btree \*b, struct btree\_op \*op,  if (b->level) { struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; - bch\_btree\_iter\_init(&b->keys, &iter, from);+ bch\_btree\_iter\_stack\_init(&b->keys, &iter, from); - while ((k = bch\_btree\_iter\_next\_filter(&iter, &b->keys,+ while ((k = bch\_btree\_iter\_next\_filter(&iter.iter, &b->keys, bch\_ptr\_bad))) { ret = bcache\_btree(map\_nodes\_recurse, k, b, op, from, fn, flags);@@ -2575,11 +2576,12 @@ int bch\_btree\_map\_keys\_recurse(struct btree \*b, struct btree\_op \*op, { int ret = MAP\_CONTINUE; struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; - bch\_btree\_iter\_init(&b->keys, &iter, from);+ bch\_btree\_iter\_stack\_init(&b->keys, &iter, from); - while ((k = bch\_btree\_iter\_next\_filter(&iter, &b->keys, bch\_ptr\_bad))) {+ while ((k = bch\_btree\_iter\_next\_filter(&iter.iter, &b->keys,+ bch\_ptr\_bad))) { ret = !b->level ? fn(op, b, k) : bcache\_btree(map\_keys\_recurse, k,diff --git a/drivers/md/bcache/super.c b/drivers/md/bcache/super.cindex 1e677af3852112..fa0c699515b7c9 100644--- a/[drivers/md/bcache/super.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/super.c?id=5b0a3dc3e87821acb80e841b464d335aff242691)+++ b/[drivers/md/bcache/super.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/super.c?id=6479b9f41583b013041943c4602e1ad61cec8148)@@ -1913,8 +1913,9 @@ struct cache\_set \*bch\_cache\_set\_alloc(struct cache\_sb \*sb) INIT\_LIST\_HEAD(&c->btree\_cache\_freed); INIT\_LIST\_HEAD(&c->data\_buckets); - iter\_size = ((meta\_bucket\_pages(sb) \* PAGE\_SECTORS) / sb->block\_size + 1) \*- sizeof(struct btree\_iter\_set);+ iter\_size = sizeof(struct btree\_iter) ++ ((meta\_bucket\_pages(sb) \* PAGE\_SECTORS) / sb->block\_size) \*+ sizeof(struct btree\_iter\_set);  c->devices = kcalloc(c->nr\_uuids, sizeof(void \*), GFP\_KERNEL); if (!c->devices)diff --git a/drivers/md/bcache/sysfs.c b/drivers/md/bcache/sysfs.cindex 18ac98dc892234..b3a34f3ac081c9 100644--- a/[drivers/md/bcache/sysfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/sysfs.c?id=5b0a3dc3e87821acb80e841b464d335aff242691)+++ b/[drivers/md/bcache/sysfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/sysfs.c?id=6479b9f41583b013041943c4602e1ad61cec8148)@@ -660,7 +660,7 @@ static unsigned int bch\_root\_usage(struct cache\_set \*c) unsigned int bytes = 0; struct bkey \*k; struct btree \*b;- struct btree\_iter iter;+ struct btree\_iter\_stack iter;  goto lock\_root; diff --git a/drivers/md/bcache/writeback.c b/drivers/md/bcache/writeback.cindex 3accfdaee6b192..39b498020d935b 100644--- a/[drivers/md/bcache/writeback.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/writeback.c?id=5b0a3dc3e87821acb80e841b464d335aff242691)+++ b/[drivers/md/bcache/writeback.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/writeback.c?id=6479b9f41583b013041943c4602e1ad61cec8148)@@ -908,15 +908,15 @@ static int bch\_dirty\_init\_thread(void \*arg) struct dirty\_init\_thrd\_info \*info = arg; struct bch\_dirty\_init\_state \*state = info->state; struct cache\_set \*c = state->c;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bkey \*k, \*p; int cur\_idx, prev\_idx, skip\_nr;  k = p = NULL; prev\_idx = 0; - bch\_btree\_iter\_init(&c->root->keys, &iter, NULL);- k = bch\_btree\_iter\_next\_filter(&iter, &c->root->keys, bch\_ptr\_bad);+ bch\_btree\_iter\_stack\_init(&c->root->keys, &iter, NULL);+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &c->root->keys, bch\_ptr\_bad); BUG\_ON(!k);  p = k;@@ -930,7 +930,7 @@ static int bch\_dirty\_init\_thread(void \*arg) skip\_nr = cur\_idx - prev\_idx;  while (skip\_nr) {- k = bch\_btree\_iter\_next\_filter(&iter,+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &c->root->keys, bch\_ptr\_bad); if (k)@@ -979,7 +979,7 @@ void bch\_sectors\_dirty\_init(struct bcache\_device \*d) int i; struct btree \*b = NULL; struct bkey \*k = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct sectors\_dirty\_init op; struct cache\_set \*c = d->c; struct bch\_dirty\_init\_state state; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 14:29:49 +0000



=== Content from git.kernel.org_971227aa_20250110_143111.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=5a1922adc5798b7ec894cd3f197afb6f9591b023)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=5a1922adc5798b7ec894cd3f197afb6f9591b023)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=5a1922adc5798b7ec894cd3f197afb6f9591b023)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5a1922adc5798b7ec894cd3f197afb6f9591b023)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Matthew Mirvish <matthew@mm12.xyz> | 2024-05-09 09:11:17 +0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-07-05 09:14:36 +0200 |
| commit | [5a1922adc5798b7ec894cd3f197afb6f9591b023](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=5a1922adc5798b7ec894cd3f197afb6f9591b023) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=5a1922adc5798b7ec894cd3f197afb6f9591b023)) | |
| tree | [1419536f05842591d8c8b89cea285de5a4afd61f](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=5a1922adc5798b7ec894cd3f197afb6f9591b023) | |
| parent | [d999d28e24d04635736be176175058c23a9254a7](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d999d28e24d04635736be176175058c23a9254a7) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5a1922adc5798b7ec894cd3f197afb6f9591b023&id2=d999d28e24d04635736be176175058c23a9254a7)) | |
| download | [linux-5a1922adc5798b7ec894cd3f197afb6f9591b023.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-5a1922adc5798b7ec894cd3f197afb6f9591b023.tar.gz) | |

bcache: fix variable length array abuse in btree\_iter[ Upstream commit 3a861560ccb35f2a4f0a4b8207fa7c2a35fc7f31 ]
btree\_iter is used in two ways: either allocated on the stack with a
fixed size MAX\_BSETS, or from a mempool with a dynamic size based on the
specific cache set. Previously, the struct had a fixed-length array of
size MAX\_BSETS which was indexed out-of-bounds for the dynamically-sized
iterators, which causes UBSAN to complain.
This patch uses the same approach as in bcachefs's sort\_iter and splits
the iterator into a btree\_iter with a flexible array member and a
btree\_iter\_stack which embeds a btree\_iter as well as a fixed-length
data array.
Cc: stable@vger.kernel.org
Closes: https://bugs.launchpad.net/ubuntu/+source/linux/+bug/2039368
Signed-off-by: Matthew Mirvish <matthew@mm12.xyz>
Signed-off-by: Coly Li <colyli@suse.de>
Link: [https://lore.kernel.org/r/20240509011117.2697-3-colyli@suse.de](https://lore.kernel.org/r/20240509011117.2697-3-colyli%40suse.de)
Signed-off-by: Jens Axboe <axboe@kernel.dk>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5a1922adc5798b7ec894cd3f197afb6f9591b023)

| -rw-r--r-- | [drivers/md/bcache/bset.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/bset.c?id=5a1922adc5798b7ec894cd3f197afb6f9591b023) | 44 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/md/bcache/bset.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/bset.h?id=5a1922adc5798b7ec894cd3f197afb6f9591b023) | 28 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/md/bcache/btree.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/btree.c?id=5a1922adc5798b7ec894cd3f197afb6f9591b023) | 40 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/md/bcache/super.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/super.c?id=5a1922adc5798b7ec894cd3f197afb6f9591b023) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/md/bcache/sysfs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/sysfs.c?id=5a1922adc5798b7ec894cd3f197afb6f9591b023) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/md/bcache/writeback.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/writeback.c?id=5a1922adc5798b7ec894cd3f197afb6f9591b023) | 10 | |  |  |  | | --- | --- | --- | |

6 files changed, 70 insertions, 59 deletions

| diff --git a/drivers/md/bcache/bset.c b/drivers/md/bcache/bset.cindex 94d38e8a59b323..cb544207427b11 100644--- a/[drivers/md/bcache/bset.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/bset.c?id=d999d28e24d04635736be176175058c23a9254a7)+++ b/[drivers/md/bcache/bset.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/bset.c?id=5a1922adc5798b7ec894cd3f197afb6f9591b023)@@ -54,7 +54,7 @@ void bch\_dump\_bucket(struct btree\_keys \*b) int \_\_bch\_count\_data(struct btree\_keys \*b) { unsigned int ret = 0;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bkey \*k;  if (b->ops->is\_extents)@@ -67,7 +67,7 @@ void \_\_bch\_check\_keys(struct btree\_keys \*b, const char \*fmt, ...) { va\_list args; struct bkey \*k, \*p = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; const char \*err;  for\_each\_key(b, k, &iter) {@@ -879,7 +879,7 @@ unsigned int bch\_btree\_insert\_key(struct btree\_keys \*b, struct bkey \*k, unsigned int status = BTREE\_INSERT\_STATUS\_NO\_INSERT; struct bset \*i = bset\_tree\_last(b)->data; struct bkey \*m, \*prev = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bkey preceding\_key\_on\_stack = ZERO\_KEY; struct bkey \*preceding\_key\_p = &preceding\_key\_on\_stack; @@ -895,9 +895,9 @@ unsigned int bch\_btree\_insert\_key(struct btree\_keys \*b, struct bkey \*k, else preceding\_key(k, &preceding\_key\_p); - m = bch\_btree\_iter\_init(b, &iter, preceding\_key\_p);+ m = bch\_btree\_iter\_stack\_init(b, &iter, preceding\_key\_p); - if (b->ops->insert\_fixup(b, k, &iter, replace\_key))+ if (b->ops->insert\_fixup(b, k, &iter.iter, replace\_key)) return status;  status = BTREE\_INSERT\_STATUS\_INSERT;@@ -1100,33 +1100,33 @@ void bch\_btree\_iter\_push(struct btree\_iter \*iter, struct bkey \*k, btree\_iter\_cmp)); } -static struct bkey \*\_\_bch\_btree\_iter\_init(struct btree\_keys \*b,- struct btree\_iter \*iter,- struct bkey \*search,- struct bset\_tree \*start)+static struct bkey \*\_\_bch\_btree\_iter\_stack\_init(struct btree\_keys \*b,+ struct btree\_iter\_stack \*iter,+ struct bkey \*search,+ struct bset\_tree \*start) { struct bkey \*ret = NULL; - iter->size = ARRAY\_SIZE(iter->data);- iter->used = 0;+ iter->iter.size = ARRAY\_SIZE(iter->stack\_data);+ iter->iter.used = 0;  #ifdef CONFIG\_BCACHE\_DEBUG- iter->b = b;+ iter->iter.b = b; #endif  for (; start <= bset\_tree\_last(b); start++) { ret = bch\_bset\_search(b, start, search);- bch\_btree\_iter\_push(iter, ret, bset\_bkey\_last(start->data));+ bch\_btree\_iter\_push(&iter->iter, ret, bset\_bkey\_last(start->data)); }  return ret; } -struct bkey \*bch\_btree\_iter\_init(struct btree\_keys \*b,- struct btree\_iter \*iter,+struct bkey \*bch\_btree\_iter\_stack\_init(struct btree\_keys \*b,+ struct btree\_iter\_stack \*iter, struct bkey \*search) {- return \_\_bch\_btree\_iter\_init(b, iter, search, b->set);+ return \_\_bch\_btree\_iter\_stack\_init(b, iter, search, b->set); }  static inline struct bkey \*\_\_bch\_btree\_iter\_next(struct btree\_iter \*iter,@@ -1293,10 +1293,10 @@ void bch\_btree\_sort\_partial(struct btree\_keys \*b, unsigned int start, struct bset\_sort\_state \*state) { size\_t order = b->page\_order, keys = 0;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; int oldsize = bch\_count\_data(b); - \_\_bch\_btree\_iter\_init(b, &iter, NULL, &b->set[start]);+ \_\_bch\_btree\_iter\_stack\_init(b, &iter, NULL, &b->set[start]);  if (start) { unsigned int i;@@ -1307,7 +1307,7 @@ void bch\_btree\_sort\_partial(struct btree\_keys \*b, unsigned int start, order = get\_order(\_\_set\_bytes(b->set->data, keys)); } - \_\_btree\_sort(b, &iter, start, order, false, state);+ \_\_btree\_sort(b, &iter.iter, start, order, false, state);  EBUG\_ON(oldsize >= 0 && bch\_count\_data(b) != oldsize); }@@ -1323,11 +1323,11 @@ void bch\_btree\_sort\_into(struct btree\_keys \*b, struct btree\_keys \*new, struct bset\_sort\_state \*state) { uint64\_t start\_time = local\_clock();- struct btree\_iter iter;+ struct btree\_iter\_stack iter; - bch\_btree\_iter\_init(b, &iter, NULL);+ bch\_btree\_iter\_stack\_init(b, &iter, NULL); - btree\_mergesort(b, new->set->data, &iter, false, true);+ btree\_mergesort(b, new->set->data, &iter.iter, false, true);  bch\_time\_stats\_update(&state->time, start\_time); diff --git a/drivers/md/bcache/bset.h b/drivers/md/bcache/bset.hindex a50dcfda656f5f..2ed6dbd35d6e5e 100644--- a/[drivers/md/bcache/bset.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/bset.h?id=d999d28e24d04635736be176175058c23a9254a7)+++ b/[drivers/md/bcache/bset.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/bset.h?id=5a1922adc5798b7ec894cd3f197afb6f9591b023)@@ -321,7 +321,14 @@ struct btree\_iter { #endif struct btree\_iter\_set { struct bkey \*k, \*end;- } data[MAX\_BSETS];+ } data[];+};++/\* Fixed-size btree\_iter that can be allocated on the stack \*/++struct btree\_iter\_stack {+ struct btree\_iter iter;+ struct btree\_iter\_set stack\_data[MAX\_BSETS]; };  typedef bool (\*ptr\_filter\_fn)(struct btree\_keys \*b, const struct bkey \*k);@@ -333,9 +340,9 @@ struct bkey \*bch\_btree\_iter\_next\_filter(struct btree\_iter \*iter,  void bch\_btree\_iter\_push(struct btree\_iter \*iter, struct bkey \*k, struct bkey \*end);-struct bkey \*bch\_btree\_iter\_init(struct btree\_keys \*b,- struct btree\_iter \*iter,- struct bkey \*search);+struct bkey \*bch\_btree\_iter\_stack\_init(struct btree\_keys \*b,+ struct btree\_iter\_stack \*iter,+ struct bkey \*search);  struct bkey \*\_\_bch\_bset\_search(struct btree\_keys \*b, struct bset\_tree \*t, const struct bkey \*search);@@ -350,13 +357,14 @@ static inline struct bkey \*bch\_bset\_search(struct btree\_keys \*b, return search ? \_\_bch\_bset\_search(b, t, search) : t->data->start; } -#define for\_each\_key\_filter(b, k, iter, filter) \- for (bch\_btree\_iter\_init((b), (iter), NULL); \- ((k) = bch\_btree\_iter\_next\_filter((iter), (b), filter));)+#define for\_each\_key\_filter(b, k, stack\_iter, filter) \+ for (bch\_btree\_iter\_stack\_init((b), (stack\_iter), NULL); \+ ((k) = bch\_btree\_iter\_next\_filter(&((stack\_iter)->iter), (b), \+ filter));) -#define for\_each\_key(b, k, iter) \- for (bch\_btree\_iter\_init((b), (iter), NULL); \- ((k) = bch\_btree\_iter\_next(iter));)+#define for\_each\_key(b, k, stack\_iter) \+ for (bch\_btree\_iter\_stack\_init((b), (stack\_iter), NULL); \+ ((k) = bch\_btree\_iter\_next(&((stack\_iter)->iter)));)  /\* Sorting \*/ diff --git a/drivers/md/bcache/btree.c b/drivers/md/bcache/btree.cindex e22dfcf1ed6d83..066b4aafd49e5a 100644--- a/[drivers/md/bcache/btree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/btree.c?id=d999d28e24d04635736be176175058c23a9254a7)+++ b/[drivers/md/bcache/btree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/btree.c?id=5a1922adc5798b7ec894cd3f197afb6f9591b023)@@ -1283,7 +1283,7 @@ static bool btree\_gc\_mark\_node(struct btree \*b, struct gc\_stat \*gc) uint8\_t stale = 0; unsigned int keys = 0, good\_keys = 0; struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bset\_tree \*t;  gc->nodes++;@@ -1544,7 +1544,7 @@ static int btree\_gc\_rewrite\_node(struct btree \*b, struct btree\_op \*op, static unsigned int btree\_gc\_count\_keys(struct btree \*b) { struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; unsigned int ret = 0;  for\_each\_key\_filter(&b->keys, k, &iter, bch\_ptr\_bad)@@ -1585,17 +1585,18 @@ static int btree\_gc\_recurse(struct btree \*b, struct btree\_op \*op, int ret = 0; bool should\_rewrite; struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct gc\_merge\_info r[GC\_MERGE\_NODES]; struct gc\_merge\_info \*i, \*last = r + ARRAY\_SIZE(r) - 1; - bch\_btree\_iter\_init(&b->keys, &iter, &b->c->gc\_done);+ bch\_btree\_iter\_stack\_init(&b->keys, &iter, &b->c->gc\_done);  for (i = r; i < r + ARRAY\_SIZE(r); i++) i->b = ERR\_PTR(-EINTR);  while (1) {- k = bch\_btree\_iter\_next\_filter(&iter, &b->keys, bch\_ptr\_bad);+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &b->keys,+ bch\_ptr\_bad); if (k) { r->b = bch\_btree\_node\_get(b->c, op, k, b->level - 1, true, b);@@ -1885,7 +1886,7 @@ static int bch\_btree\_check\_recurse(struct btree \*b, struct btree\_op \*op) { int ret = 0; struct bkey \*k, \*p = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter;  for\_each\_key\_filter(&b->keys, k, &iter, bch\_ptr\_invalid) bch\_initial\_mark\_key(b->c, b->level, k);@@ -1893,10 +1894,10 @@ static int bch\_btree\_check\_recurse(struct btree \*b, struct btree\_op \*op) bch\_initial\_mark\_key(b->c, b->level + 1, &b->key);  if (b->level) {- bch\_btree\_iter\_init(&b->keys, &iter, NULL);+ bch\_btree\_iter\_stack\_init(&b->keys, &iter, NULL);  do {- k = bch\_btree\_iter\_next\_filter(&iter, &b->keys,+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &b->keys, bch\_ptr\_bad); if (k) { btree\_node\_prefetch(b, k);@@ -1924,7 +1925,7 @@ static int bch\_btree\_check\_thread(void \*arg) struct btree\_check\_info \*info = arg; struct btree\_check\_state \*check\_state = info->state; struct cache\_set \*c = check\_state->c;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bkey \*k, \*p; int cur\_idx, prev\_idx, skip\_nr; @@ -1933,8 +1934,8 @@ static int bch\_btree\_check\_thread(void \*arg) ret = 0;  /\* root node keys are checked before thread created \*/- bch\_btree\_iter\_init(&c->root->keys, &iter, NULL);- k = bch\_btree\_iter\_next\_filter(&iter, &c->root->keys, bch\_ptr\_bad);+ bch\_btree\_iter\_stack\_init(&c->root->keys, &iter, NULL);+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &c->root->keys, bch\_ptr\_bad); BUG\_ON(!k);  p = k;@@ -1952,7 +1953,7 @@ static int bch\_btree\_check\_thread(void \*arg) skip\_nr = cur\_idx - prev\_idx;  while (skip\_nr) {- k = bch\_btree\_iter\_next\_filter(&iter,+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &c->root->keys, bch\_ptr\_bad); if (k)@@ -2025,7 +2026,7 @@ int bch\_btree\_check(struct cache\_set \*c) int ret = 0; int i; struct bkey \*k = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct btree\_check\_state check\_state;  /\* check and mark root node keys \*/@@ -2521,11 +2522,11 @@ static int bch\_btree\_map\_nodes\_recurse(struct btree \*b, struct btree\_op \*op,  if (b->level) { struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; - bch\_btree\_iter\_init(&b->keys, &iter, from);+ bch\_btree\_iter\_stack\_init(&b->keys, &iter, from); - while ((k = bch\_btree\_iter\_next\_filter(&iter, &b->keys,+ while ((k = bch\_btree\_iter\_next\_filter(&iter.iter, &b->keys, bch\_ptr\_bad))) { ret = bcache\_btree(map\_nodes\_recurse, k, b, op, from, fn, flags);@@ -2554,11 +2555,12 @@ int bch\_btree\_map\_keys\_recurse(struct btree \*b, struct btree\_op \*op, { int ret = MAP\_CONTINUE; struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; - bch\_btree\_iter\_init(&b->keys, &iter, from);+ bch\_btree\_iter\_stack\_init(&b->keys, &iter, from); - while ((k = bch\_btree\_iter\_next\_filter(&iter, &b->keys, bch\_ptr\_bad))) {+ while ((k = bch\_btree\_iter\_next\_filter(&iter.iter, &b->keys,+ bch\_ptr\_bad))) { ret = !b->level ? fn(op, b, k) : bcache\_btree(map\_keys\_recurse, k,diff --git a/drivers/md/bcache/super.c b/drivers/md/bcache/super.cindex 8ec48d8a5821c2..48624e6bf0d79e 100644--- a/[drivers/md/bcache/super.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/super.c?id=d999d28e24d04635736be176175058c23a9254a7)+++ b/[drivers/md/bcache/super.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/super.c?id=5a1922adc5798b7ec894cd3f197afb6f9591b023)@@ -1920,8 +1920,9 @@ struct cache\_set \*bch\_cache\_set\_alloc(struct cache\_sb \*sb) INIT\_LIST\_HEAD(&c->btree\_cache\_freed); INIT\_LIST\_HEAD(&c->data\_buckets); - iter\_size = ((meta\_bucket\_pages(sb) \* PAGE\_SECTORS) / sb->block\_size + 1) \*- sizeof(struct btree\_iter\_set);+ iter\_size = sizeof(struct btree\_iter) ++ ((meta\_bucket\_pages(sb) \* PAGE\_SECTORS) / sb->block\_size) \*+ sizeof(struct btree\_iter\_set);  c->devices = kcalloc(c->nr\_uuids, sizeof(void \*), GFP\_KERNEL); if (!c->devices)diff --git a/drivers/md/bcache/sysfs.c b/drivers/md/bcache/sysfs.cindex fa146012003df0..7024eaed8d486a 100644--- a/[drivers/md/bcache/sysfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/sysfs.c?id=d999d28e24d04635736be176175058c23a9254a7)+++ b/[drivers/md/bcache/sysfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/sysfs.c?id=5a1922adc5798b7ec894cd3f197afb6f9591b023)@@ -658,7 +658,7 @@ static unsigned int bch\_root\_usage(struct cache\_set \*c) unsigned int bytes = 0; struct bkey \*k; struct btree \*b;- struct btree\_iter iter;+ struct btree\_iter\_stack iter;  goto lock\_root; diff --git a/drivers/md/bcache/writeback.c b/drivers/md/bcache/writeback.cindex 1e96679afcf4a8..142eaf0ff9aea9 100644--- a/[drivers/md/bcache/writeback.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/writeback.c?id=d999d28e24d04635736be176175058c23a9254a7)+++ b/[drivers/md/bcache/writeback.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/writeback.c?id=5a1922adc5798b7ec894cd3f197afb6f9591b023)@@ -898,15 +898,15 @@ static int bch\_dirty\_init\_thread(void \*arg) struct dirty\_init\_thrd\_info \*info = arg; struct bch\_dirty\_init\_state \*state = info->state; struct cache\_set \*c = state->c;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bkey \*k, \*p; int cur\_idx, prev\_idx, skip\_nr;  k = p = NULL; prev\_idx = 0; - bch\_btree\_iter\_init(&c->root->keys, &iter, NULL);- k = bch\_btree\_iter\_next\_filter(&iter, &c->root->keys, bch\_ptr\_bad);+ bch\_btree\_iter\_stack\_init(&c->root->keys, &iter, NULL);+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &c->root->keys, bch\_ptr\_bad); BUG\_ON(!k);  p = k;@@ -920,7 +920,7 @@ static int bch\_dirty\_init\_thread(void \*arg) skip\_nr = cur\_idx - prev\_idx;  while (skip\_nr) {- k = bch\_btree\_iter\_next\_filter(&iter,+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &c->root->keys, bch\_ptr\_bad); if (k)@@ -969,7 +969,7 @@ void bch\_sectors\_dirty\_init(struct bcache\_device \*d) int i; struct btree \*b = NULL; struct bkey \*k = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct sectors\_dirty\_init op; struct cache\_set \*c = d->c; struct bch\_dirty\_init\_state state; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 14:29:48 +0000



=== Content from git.kernel.org_48da287e_20250110_143111.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=3a861560ccb35f2a4f0a4b8207fa7c2a35fc7f31)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=3a861560ccb35f2a4f0a4b8207fa7c2a35fc7f31)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3a861560ccb35f2a4f0a4b8207fa7c2a35fc7f31)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3a861560ccb35f2a4f0a4b8207fa7c2a35fc7f31)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Matthew Mirvish <matthew@mm12.xyz> | 2024-05-09 09:11:17 +0800 |
| --- | --- | --- |
| committer | Jens Axboe <axboe@kernel.dk> | 2024-05-08 19:15:01 -0600 |
| commit | [3a861560ccb35f2a4f0a4b8207fa7c2a35fc7f31](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3a861560ccb35f2a4f0a4b8207fa7c2a35fc7f31) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=3a861560ccb35f2a4f0a4b8207fa7c2a35fc7f31)) | |
| tree | [abaed8a75822748de1e372b1ae2a828a8545468d](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=3a861560ccb35f2a4f0a4b8207fa7c2a35fc7f31) | |
| parent | [2abd9a197d828ed5c2cbe922368eb28d02861a28](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=2abd9a197d828ed5c2cbe922368eb28d02861a28) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3a861560ccb35f2a4f0a4b8207fa7c2a35fc7f31&id2=2abd9a197d828ed5c2cbe922368eb28d02861a28)) | |
| download | [linux-3a861560ccb35f2a4f0a4b8207fa7c2a35fc7f31.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-3a861560ccb35f2a4f0a4b8207fa7c2a35fc7f31.tar.gz) | |

bcache: fix variable length array abuse in btree\_iterbtree\_iter is used in two ways: either allocated on the stack with a
fixed size MAX\_BSETS, or from a mempool with a dynamic size based on the
specific cache set. Previously, the struct had a fixed-length array of
size MAX\_BSETS which was indexed out-of-bounds for the dynamically-sized
iterators, which causes UBSAN to complain.
This patch uses the same approach as in bcachefs's sort\_iter and splits
the iterator into a btree\_iter with a flexible array member and a
btree\_iter\_stack which embeds a btree\_iter as well as a fixed-length
data array.
Cc: stable@vger.kernel.org
Closes: https://bugs.launchpad.net/ubuntu/+source/linux/+bug/2039368
Signed-off-by: Matthew Mirvish <matthew@mm12.xyz>
Signed-off-by: Coly Li <colyli@suse.de>
Link: [https://lore.kernel.org/r/20240509011117.2697-3-colyli@suse.de](https://lore.kernel.org/r/20240509011117.2697-3-colyli%40suse.de)
Signed-off-by: Jens Axboe <axboe@kernel.dk>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=3a861560ccb35f2a4f0a4b8207fa7c2a35fc7f31)

| -rw-r--r-- | [drivers/md/bcache/bset.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/bset.c?id=3a861560ccb35f2a4f0a4b8207fa7c2a35fc7f31) | 44 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/md/bcache/bset.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/bset.h?id=3a861560ccb35f2a4f0a4b8207fa7c2a35fc7f31) | 28 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/md/bcache/btree.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/btree.c?id=3a861560ccb35f2a4f0a4b8207fa7c2a35fc7f31) | 40 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/md/bcache/super.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/super.c?id=3a861560ccb35f2a4f0a4b8207fa7c2a35fc7f31) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/md/bcache/sysfs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/sysfs.c?id=3a861560ccb35f2a4f0a4b8207fa7c2a35fc7f31) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/md/bcache/writeback.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/writeback.c?id=3a861560ccb35f2a4f0a4b8207fa7c2a35fc7f31) | 10 | |  |  |  | | --- | --- | --- | |

6 files changed, 70 insertions, 59 deletions

| diff --git a/drivers/md/bcache/bset.c b/drivers/md/bcache/bset.cindex 2bba4d6aaaa28c..463eb13bd0b2a7 100644--- a/[drivers/md/bcache/bset.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/bset.c?id=2abd9a197d828ed5c2cbe922368eb28d02861a28)+++ b/[drivers/md/bcache/bset.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/bset.c?id=3a861560ccb35f2a4f0a4b8207fa7c2a35fc7f31)@@ -54,7 +54,7 @@ void bch\_dump\_bucket(struct btree\_keys \*b) int \_\_bch\_count\_data(struct btree\_keys \*b) { unsigned int ret = 0;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bkey \*k;  if (b->ops->is\_extents)@@ -67,7 +67,7 @@ void \_\_bch\_check\_keys(struct btree\_keys \*b, const char \*fmt, ...) { va\_list args; struct bkey \*k, \*p = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; const char \*err;  for\_each\_key(b, k, &iter) {@@ -879,7 +879,7 @@ unsigned int bch\_btree\_insert\_key(struct btree\_keys \*b, struct bkey \*k, unsigned int status = BTREE\_INSERT\_STATUS\_NO\_INSERT; struct bset \*i = bset\_tree\_last(b)->data; struct bkey \*m, \*prev = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bkey preceding\_key\_on\_stack = ZERO\_KEY; struct bkey \*preceding\_key\_p = &preceding\_key\_on\_stack; @@ -895,9 +895,9 @@ unsigned int bch\_btree\_insert\_key(struct btree\_keys \*b, struct bkey \*k, else preceding\_key(k, &preceding\_key\_p); - m = bch\_btree\_iter\_init(b, &iter, preceding\_key\_p);+ m = bch\_btree\_iter\_stack\_init(b, &iter, preceding\_key\_p); - if (b->ops->insert\_fixup(b, k, &iter, replace\_key))+ if (b->ops->insert\_fixup(b, k, &iter.iter, replace\_key)) return status;  status = BTREE\_INSERT\_STATUS\_INSERT;@@ -1100,33 +1100,33 @@ void bch\_btree\_iter\_push(struct btree\_iter \*iter, struct bkey \*k, btree\_iter\_cmp)); } -static struct bkey \*\_\_bch\_btree\_iter\_init(struct btree\_keys \*b,- struct btree\_iter \*iter,- struct bkey \*search,- struct bset\_tree \*start)+static struct bkey \*\_\_bch\_btree\_iter\_stack\_init(struct btree\_keys \*b,+ struct btree\_iter\_stack \*iter,+ struct bkey \*search,+ struct bset\_tree \*start) { struct bkey \*ret = NULL; - iter->size = ARRAY\_SIZE(iter->data);- iter->used = 0;+ iter->iter.size = ARRAY\_SIZE(iter->stack\_data);+ iter->iter.used = 0;  #ifdef CONFIG\_BCACHE\_DEBUG- iter->b = b;+ iter->iter.b = b; #endif  for (; start <= bset\_tree\_last(b); start++) { ret = bch\_bset\_search(b, start, search);- bch\_btree\_iter\_push(iter, ret, bset\_bkey\_last(start->data));+ bch\_btree\_iter\_push(&iter->iter, ret, bset\_bkey\_last(start->data)); }  return ret; } -struct bkey \*bch\_btree\_iter\_init(struct btree\_keys \*b,- struct btree\_iter \*iter,+struct bkey \*bch\_btree\_iter\_stack\_init(struct btree\_keys \*b,+ struct btree\_iter\_stack \*iter, struct bkey \*search) {- return \_\_bch\_btree\_iter\_init(b, iter, search, b->set);+ return \_\_bch\_btree\_iter\_stack\_init(b, iter, search, b->set); }  static inline struct bkey \*\_\_bch\_btree\_iter\_next(struct btree\_iter \*iter,@@ -1293,10 +1293,10 @@ void bch\_btree\_sort\_partial(struct btree\_keys \*b, unsigned int start, struct bset\_sort\_state \*state) { size\_t order = b->page\_order, keys = 0;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; int oldsize = bch\_count\_data(b); - \_\_bch\_btree\_iter\_init(b, &iter, NULL, &b->set[start]);+ \_\_bch\_btree\_iter\_stack\_init(b, &iter, NULL, &b->set[start]);  if (start) { unsigned int i;@@ -1307,7 +1307,7 @@ void bch\_btree\_sort\_partial(struct btree\_keys \*b, unsigned int start, order = get\_order(\_\_set\_bytes(b->set->data, keys)); } - \_\_btree\_sort(b, &iter, start, order, false, state);+ \_\_btree\_sort(b, &iter.iter, start, order, false, state);  EBUG\_ON(oldsize >= 0 && bch\_count\_data(b) != oldsize); }@@ -1323,11 +1323,11 @@ void bch\_btree\_sort\_into(struct btree\_keys \*b, struct btree\_keys \*new, struct bset\_sort\_state \*state) { uint64\_t start\_time = local\_clock();- struct btree\_iter iter;+ struct btree\_iter\_stack iter; - bch\_btree\_iter\_init(b, &iter, NULL);+ bch\_btree\_iter\_stack\_init(b, &iter, NULL); - btree\_mergesort(b, new->set->data, &iter, false, true);+ btree\_mergesort(b, new->set->data, &iter.iter, false, true);  bch\_time\_stats\_update(&state->time, start\_time); diff --git a/drivers/md/bcache/bset.h b/drivers/md/bcache/bset.hindex d795c84246b018..011f6062c4c04f 100644--- a/[drivers/md/bcache/bset.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/bset.h?id=2abd9a197d828ed5c2cbe922368eb28d02861a28)+++ b/[drivers/md/bcache/bset.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/bset.h?id=3a861560ccb35f2a4f0a4b8207fa7c2a35fc7f31)@@ -321,7 +321,14 @@ struct btree\_iter { #endif struct btree\_iter\_set { struct bkey \*k, \*end;- } data[MAX\_BSETS];+ } data[];+};++/\* Fixed-size btree\_iter that can be allocated on the stack \*/++struct btree\_iter\_stack {+ struct btree\_iter iter;+ struct btree\_iter\_set stack\_data[MAX\_BSETS]; };  typedef bool (\*ptr\_filter\_fn)(struct btree\_keys \*b, const struct bkey \*k);@@ -333,9 +340,9 @@ struct bkey \*bch\_btree\_iter\_next\_filter(struct btree\_iter \*iter,  void bch\_btree\_iter\_push(struct btree\_iter \*iter, struct bkey \*k, struct bkey \*end);-struct bkey \*bch\_btree\_iter\_init(struct btree\_keys \*b,- struct btree\_iter \*iter,- struct bkey \*search);+struct bkey \*bch\_btree\_iter\_stack\_init(struct btree\_keys \*b,+ struct btree\_iter\_stack \*iter,+ struct bkey \*search);  struct bkey \*\_\_bch\_bset\_search(struct btree\_keys \*b, struct bset\_tree \*t, const struct bkey \*search);@@ -350,13 +357,14 @@ static inline struct bkey \*bch\_bset\_search(struct btree\_keys \*b, return search ? \_\_bch\_bset\_search(b, t, search) : t->data->start; } -#define for\_each\_key\_filter(b, k, iter, filter) \- for (bch\_btree\_iter\_init((b), (iter), NULL); \- ((k) = bch\_btree\_iter\_next\_filter((iter), (b), filter));)+#define for\_each\_key\_filter(b, k, stack\_iter, filter) \+ for (bch\_btree\_iter\_stack\_init((b), (stack\_iter), NULL); \+ ((k) = bch\_btree\_iter\_next\_filter(&((stack\_iter)->iter), (b), \+ filter));) -#define for\_each\_key(b, k, iter) \- for (bch\_btree\_iter\_init((b), (iter), NULL); \- ((k) = bch\_btree\_iter\_next(iter));)+#define for\_each\_key(b, k, stack\_iter) \+ for (bch\_btree\_iter\_stack\_init((b), (stack\_iter), NULL); \+ ((k) = bch\_btree\_iter\_next(&((stack\_iter)->iter)));)  /\* Sorting \*/ diff --git a/drivers/md/bcache/btree.c b/drivers/md/bcache/btree.cindex 196cdacce38f25..d011a7154d3304 100644--- a/[drivers/md/bcache/btree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/btree.c?id=2abd9a197d828ed5c2cbe922368eb28d02861a28)+++ b/[drivers/md/bcache/btree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/btree.c?id=3a861560ccb35f2a4f0a4b8207fa7c2a35fc7f31)@@ -1309,7 +1309,7 @@ static bool btree\_gc\_mark\_node(struct btree \*b, struct gc\_stat \*gc) uint8\_t stale = 0; unsigned int keys = 0, good\_keys = 0; struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bset\_tree \*t;  gc->nodes++;@@ -1570,7 +1570,7 @@ static int btree\_gc\_rewrite\_node(struct btree \*b, struct btree\_op \*op, static unsigned int btree\_gc\_count\_keys(struct btree \*b) { struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; unsigned int ret = 0;  for\_each\_key\_filter(&b->keys, k, &iter, bch\_ptr\_bad)@@ -1611,17 +1611,18 @@ static int btree\_gc\_recurse(struct btree \*b, struct btree\_op \*op, int ret = 0; bool should\_rewrite; struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct gc\_merge\_info r[GC\_MERGE\_NODES]; struct gc\_merge\_info \*i, \*last = r + ARRAY\_SIZE(r) - 1; - bch\_btree\_iter\_init(&b->keys, &iter, &b->c->gc\_done);+ bch\_btree\_iter\_stack\_init(&b->keys, &iter, &b->c->gc\_done);  for (i = r; i < r + ARRAY\_SIZE(r); i++) i->b = ERR\_PTR(-EINTR);  while (1) {- k = bch\_btree\_iter\_next\_filter(&iter, &b->keys, bch\_ptr\_bad);+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &b->keys,+ bch\_ptr\_bad); if (k) { r->b = bch\_btree\_node\_get(b->c, op, k, b->level - 1, true, b);@@ -1911,7 +1912,7 @@ static int bch\_btree\_check\_recurse(struct btree \*b, struct btree\_op \*op) { int ret = 0; struct bkey \*k, \*p = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter;  for\_each\_key\_filter(&b->keys, k, &iter, bch\_ptr\_invalid) bch\_initial\_mark\_key(b->c, b->level, k);@@ -1919,10 +1920,10 @@ static int bch\_btree\_check\_recurse(struct btree \*b, struct btree\_op \*op) bch\_initial\_mark\_key(b->c, b->level + 1, &b->key);  if (b->level) {- bch\_btree\_iter\_init(&b->keys, &iter, NULL);+ bch\_btree\_iter\_stack\_init(&b->keys, &iter, NULL);  do {- k = bch\_btree\_iter\_next\_filter(&iter, &b->keys,+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &b->keys, bch\_ptr\_bad); if (k) { btree\_node\_prefetch(b, k);@@ -1950,7 +1951,7 @@ static int bch\_btree\_check\_thread(void \*arg) struct btree\_check\_info \*info = arg; struct btree\_check\_state \*check\_state = info->state; struct cache\_set \*c = check\_state->c;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bkey \*k, \*p; int cur\_idx, prev\_idx, skip\_nr; @@ -1959,8 +1960,8 @@ static int bch\_btree\_check\_thread(void \*arg) ret = 0;  /\* root node keys are checked before thread created \*/- bch\_btree\_iter\_init(&c->root->keys, &iter, NULL);- k = bch\_btree\_iter\_next\_filter(&iter, &c->root->keys, bch\_ptr\_bad);+ bch\_btree\_iter\_stack\_init(&c->root->keys, &iter, NULL);+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &c->root->keys, bch\_ptr\_bad); BUG\_ON(!k);  p = k;@@ -1978,7 +1979,7 @@ static int bch\_btree\_check\_thread(void \*arg) skip\_nr = cur\_idx - prev\_idx;  while (skip\_nr) {- k = bch\_btree\_iter\_next\_filter(&iter,+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &c->root->keys, bch\_ptr\_bad); if (k)@@ -2051,7 +2052,7 @@ int bch\_btree\_check(struct cache\_set \*c) int ret = 0; int i; struct bkey \*k = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct btree\_check\_state check\_state;  /\* check and mark root node keys \*/@@ -2547,11 +2548,11 @@ static int bch\_btree\_map\_nodes\_recurse(struct btree \*b, struct btree\_op \*op,  if (b->level) { struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; - bch\_btree\_iter\_init(&b->keys, &iter, from);+ bch\_btree\_iter\_stack\_init(&b->keys, &iter, from); - while ((k = bch\_btree\_iter\_next\_filter(&iter, &b->keys,+ while ((k = bch\_btree\_iter\_next\_filter(&iter.iter, &b->keys, bch\_ptr\_bad))) { ret = bcache\_btree(map\_nodes\_recurse, k, b, op, from, fn, flags);@@ -2580,11 +2581,12 @@ int bch\_btree\_map\_keys\_recurse(struct btree \*b, struct btree\_op \*op, { int ret = MAP\_CONTINUE; struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; - bch\_btree\_iter\_init(&b->keys, &iter, from);+ bch\_btree\_iter\_stack\_init(&b->keys, &iter, from); - while ((k = bch\_btree\_iter\_next\_filter(&iter, &b->keys, bch\_ptr\_bad))) {+ while ((k = bch\_btree\_iter\_next\_filter(&iter.iter, &b->keys,+ bch\_ptr\_bad))) { ret = !b->level ? fn(op, b, k) : bcache\_btree(map\_keys\_recurse, k,diff --git a/drivers/md/bcache/super.c b/drivers/md/bcache/super.cindex 38e41039edb8c9..cba09660148a92 100644--- a/[drivers/md/bcache/super.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/super.c?id=2abd9a197d828ed5c2cbe922368eb28d02861a28)+++ b/[drivers/md/bcache/super.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/super.c?id=3a861560ccb35f2a4f0a4b8207fa7c2a35fc7f31)@@ -1914,8 +1914,9 @@ struct cache\_set \*bch\_cache\_set\_alloc(struct cache\_sb \*sb) INIT\_LIST\_HEAD(&c->btree\_cache\_freed); INIT\_LIST\_HEAD(&c->data\_buckets); - iter\_size = ((meta\_bucket\_pages(sb) \* PAGE\_SECTORS) / sb->block\_size + 1) \*- sizeof(struct btree\_iter\_set);+ iter\_size = sizeof(struct btree\_iter) ++ ((meta\_bucket\_pages(sb) \* PAGE\_SECTORS) / sb->block\_size) \*+ sizeof(struct btree\_iter\_set);  c->devices = kcalloc(c->nr\_uuids, sizeof(void \*), GFP\_KERNEL); if (!c->devices)diff --git a/drivers/md/bcache/sysfs.c b/drivers/md/bcache/sysfs.cindex 6956beb55326f5..826b14cae4e58e 100644--- a/[drivers/md/bcache/sysfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/sysfs.c?id=2abd9a197d828ed5c2cbe922368eb28d02861a28)+++ b/[drivers/md/bcache/sysfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/sysfs.c?id=3a861560ccb35f2a4f0a4b8207fa7c2a35fc7f31)@@ -660,7 +660,7 @@ static unsigned int bch\_root\_usage(struct cache\_set \*c) unsigned int bytes = 0; struct bkey \*k; struct btree \*b;- struct btree\_iter iter;+ struct btree\_iter\_stack iter;  goto lock\_root; diff --git a/drivers/md/bcache/writeback.c b/drivers/md/bcache/writeback.cindex 8827a6f130ad7f..792e070ccf38ba 100644--- a/[drivers/md/bcache/writeback.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/writeback.c?id=2abd9a197d828ed5c2cbe922368eb28d02861a28)+++ b/[drivers/md/bcache/writeback.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/writeback.c?id=3a861560ccb35f2a4f0a4b8207fa7c2a35fc7f31)@@ -908,15 +908,15 @@ static int bch\_dirty\_init\_thread(void \*arg) struct dirty\_init\_thrd\_info \*info = arg; struct bch\_dirty\_init\_state \*state = info->state; struct cache\_set \*c = state->c;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bkey \*k, \*p; int cur\_idx, prev\_idx, skip\_nr;  k = p = NULL; prev\_idx = 0; - bch\_btree\_iter\_init(&c->root->keys, &iter, NULL);- k = bch\_btree\_iter\_next\_filter(&iter, &c->root->keys, bch\_ptr\_bad);+ bch\_btree\_iter\_stack\_init(&c->root->keys, &iter, NULL);+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &c->root->keys, bch\_ptr\_bad); BUG\_ON(!k);  p = k;@@ -930,7 +930,7 @@ static int bch\_dirty\_init\_thread(void \*arg) skip\_nr = cur\_idx - prev\_idx;  while (skip\_nr) {- k = bch\_btree\_iter\_next\_filter(&iter,+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &c->root->keys, bch\_ptr\_bad); if (k)@@ -979,7 +979,7 @@ void bch\_sectors\_dirty\_init(struct bcache\_device \*d) int i; struct btree \*b = NULL; struct bkey \*k = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct sectors\_dirty\_init op; struct cache\_set \*c = d->c; struct bch\_dirty\_init\_state state; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 14:29:48 +0000



=== Content from git.kernel.org_03679842_20250110_143113.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=934e1e4331859183a861f396d7dfaf33cb5afb02)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=934e1e4331859183a861f396d7dfaf33cb5afb02)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=934e1e4331859183a861f396d7dfaf33cb5afb02)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=934e1e4331859183a861f396d7dfaf33cb5afb02)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Matthew Mirvish <matthew@mm12.xyz> | 2024-05-09 09:11:17 +0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-06-16 13:41:33 +0200 |
| commit | [934e1e4331859183a861f396d7dfaf33cb5afb02](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=934e1e4331859183a861f396d7dfaf33cb5afb02) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=934e1e4331859183a861f396d7dfaf33cb5afb02)) | |
| tree | [e30c66f278a2ab1b62442281e08b93969a7c1f5a](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=934e1e4331859183a861f396d7dfaf33cb5afb02) | |
| parent | [011552f29f20842c9a7a21bffe1f6a2d6457ba46](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=011552f29f20842c9a7a21bffe1f6a2d6457ba46) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=934e1e4331859183a861f396d7dfaf33cb5afb02&id2=011552f29f20842c9a7a21bffe1f6a2d6457ba46)) | |
| download | [linux-934e1e4331859183a861f396d7dfaf33cb5afb02.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-934e1e4331859183a861f396d7dfaf33cb5afb02.tar.gz) | |

bcache: fix variable length array abuse in btree\_itercommit 3a861560ccb35f2a4f0a4b8207fa7c2a35fc7f31 upstream.
btree\_iter is used in two ways: either allocated on the stack with a
fixed size MAX\_BSETS, or from a mempool with a dynamic size based on the
specific cache set. Previously, the struct had a fixed-length array of
size MAX\_BSETS which was indexed out-of-bounds for the dynamically-sized
iterators, which causes UBSAN to complain.
This patch uses the same approach as in bcachefs's sort\_iter and splits
the iterator into a btree\_iter with a flexible array member and a
btree\_iter\_stack which embeds a btree\_iter as well as a fixed-length
data array.
Cc: stable@vger.kernel.org
Closes: https://bugs.launchpad.net/ubuntu/+source/linux/+bug/2039368
Signed-off-by: Matthew Mirvish <matthew@mm12.xyz>
Signed-off-by: Coly Li <colyli@suse.de>
Link: [https://lore.kernel.org/r/20240509011117.2697-3-colyli@suse.de](https://lore.kernel.org/r/20240509011117.2697-3-colyli%40suse.de)
Signed-off-by: Jens Axboe <axboe@kernel.dk>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=934e1e4331859183a861f396d7dfaf33cb5afb02)

| -rw-r--r-- | [drivers/md/bcache/bset.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/bset.c?id=934e1e4331859183a861f396d7dfaf33cb5afb02) | 44 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/md/bcache/bset.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/bset.h?id=934e1e4331859183a861f396d7dfaf33cb5afb02) | 28 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/md/bcache/btree.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/btree.c?id=934e1e4331859183a861f396d7dfaf33cb5afb02) | 40 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/md/bcache/super.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/super.c?id=934e1e4331859183a861f396d7dfaf33cb5afb02) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/md/bcache/sysfs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/sysfs.c?id=934e1e4331859183a861f396d7dfaf33cb5afb02) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/md/bcache/writeback.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/writeback.c?id=934e1e4331859183a861f396d7dfaf33cb5afb02) | 10 | |  |  |  | | --- | --- | --- | |

6 files changed, 70 insertions, 59 deletions

| diff --git a/drivers/md/bcache/bset.c b/drivers/md/bcache/bset.cindex 2bba4d6aaaa28c..463eb13bd0b2a7 100644--- a/[drivers/md/bcache/bset.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/bset.c?id=011552f29f20842c9a7a21bffe1f6a2d6457ba46)+++ b/[drivers/md/bcache/bset.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/bset.c?id=934e1e4331859183a861f396d7dfaf33cb5afb02)@@ -54,7 +54,7 @@ void bch\_dump\_bucket(struct btree\_keys \*b) int \_\_bch\_count\_data(struct btree\_keys \*b) { unsigned int ret = 0;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bkey \*k;  if (b->ops->is\_extents)@@ -67,7 +67,7 @@ void \_\_bch\_check\_keys(struct btree\_keys \*b, const char \*fmt, ...) { va\_list args; struct bkey \*k, \*p = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; const char \*err;  for\_each\_key(b, k, &iter) {@@ -879,7 +879,7 @@ unsigned int bch\_btree\_insert\_key(struct btree\_keys \*b, struct bkey \*k, unsigned int status = BTREE\_INSERT\_STATUS\_NO\_INSERT; struct bset \*i = bset\_tree\_last(b)->data; struct bkey \*m, \*prev = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bkey preceding\_key\_on\_stack = ZERO\_KEY; struct bkey \*preceding\_key\_p = &preceding\_key\_on\_stack; @@ -895,9 +895,9 @@ unsigned int bch\_btree\_insert\_key(struct btree\_keys \*b, struct bkey \*k, else preceding\_key(k, &preceding\_key\_p); - m = bch\_btree\_iter\_init(b, &iter, preceding\_key\_p);+ m = bch\_btree\_iter\_stack\_init(b, &iter, preceding\_key\_p); - if (b->ops->insert\_fixup(b, k, &iter, replace\_key))+ if (b->ops->insert\_fixup(b, k, &iter.iter, replace\_key)) return status;  status = BTREE\_INSERT\_STATUS\_INSERT;@@ -1100,33 +1100,33 @@ void bch\_btree\_iter\_push(struct btree\_iter \*iter, struct bkey \*k, btree\_iter\_cmp)); } -static struct bkey \*\_\_bch\_btree\_iter\_init(struct btree\_keys \*b,- struct btree\_iter \*iter,- struct bkey \*search,- struct bset\_tree \*start)+static struct bkey \*\_\_bch\_btree\_iter\_stack\_init(struct btree\_keys \*b,+ struct btree\_iter\_stack \*iter,+ struct bkey \*search,+ struct bset\_tree \*start) { struct bkey \*ret = NULL; - iter->size = ARRAY\_SIZE(iter->data);- iter->used = 0;+ iter->iter.size = ARRAY\_SIZE(iter->stack\_data);+ iter->iter.used = 0;  #ifdef CONFIG\_BCACHE\_DEBUG- iter->b = b;+ iter->iter.b = b; #endif  for (; start <= bset\_tree\_last(b); start++) { ret = bch\_bset\_search(b, start, search);- bch\_btree\_iter\_push(iter, ret, bset\_bkey\_last(start->data));+ bch\_btree\_iter\_push(&iter->iter, ret, bset\_bkey\_last(start->data)); }  return ret; } -struct bkey \*bch\_btree\_iter\_init(struct btree\_keys \*b,- struct btree\_iter \*iter,+struct bkey \*bch\_btree\_iter\_stack\_init(struct btree\_keys \*b,+ struct btree\_iter\_stack \*iter, struct bkey \*search) {- return \_\_bch\_btree\_iter\_init(b, iter, search, b->set);+ return \_\_bch\_btree\_iter\_stack\_init(b, iter, search, b->set); }  static inline struct bkey \*\_\_bch\_btree\_iter\_next(struct btree\_iter \*iter,@@ -1293,10 +1293,10 @@ void bch\_btree\_sort\_partial(struct btree\_keys \*b, unsigned int start, struct bset\_sort\_state \*state) { size\_t order = b->page\_order, keys = 0;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; int oldsize = bch\_count\_data(b); - \_\_bch\_btree\_iter\_init(b, &iter, NULL, &b->set[start]);+ \_\_bch\_btree\_iter\_stack\_init(b, &iter, NULL, &b->set[start]);  if (start) { unsigned int i;@@ -1307,7 +1307,7 @@ void bch\_btree\_sort\_partial(struct btree\_keys \*b, unsigned int start, order = get\_order(\_\_set\_bytes(b->set->data, keys)); } - \_\_btree\_sort(b, &iter, start, order, false, state);+ \_\_btree\_sort(b, &iter.iter, start, order, false, state);  EBUG\_ON(oldsize >= 0 && bch\_count\_data(b) != oldsize); }@@ -1323,11 +1323,11 @@ void bch\_btree\_sort\_into(struct btree\_keys \*b, struct btree\_keys \*new, struct bset\_sort\_state \*state) { uint64\_t start\_time = local\_clock();- struct btree\_iter iter;+ struct btree\_iter\_stack iter; - bch\_btree\_iter\_init(b, &iter, NULL);+ bch\_btree\_iter\_stack\_init(b, &iter, NULL); - btree\_mergesort(b, new->set->data, &iter, false, true);+ btree\_mergesort(b, new->set->data, &iter.iter, false, true);  bch\_time\_stats\_update(&state->time, start\_time); diff --git a/drivers/md/bcache/bset.h b/drivers/md/bcache/bset.hindex d795c84246b018..011f6062c4c04f 100644--- a/[drivers/md/bcache/bset.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/bset.h?id=011552f29f20842c9a7a21bffe1f6a2d6457ba46)+++ b/[drivers/md/bcache/bset.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/bset.h?id=934e1e4331859183a861f396d7dfaf33cb5afb02)@@ -321,7 +321,14 @@ struct btree\_iter { #endif struct btree\_iter\_set { struct bkey \*k, \*end;- } data[MAX\_BSETS];+ } data[];+};++/\* Fixed-size btree\_iter that can be allocated on the stack \*/++struct btree\_iter\_stack {+ struct btree\_iter iter;+ struct btree\_iter\_set stack\_data[MAX\_BSETS]; };  typedef bool (\*ptr\_filter\_fn)(struct btree\_keys \*b, const struct bkey \*k);@@ -333,9 +340,9 @@ struct bkey \*bch\_btree\_iter\_next\_filter(struct btree\_iter \*iter,  void bch\_btree\_iter\_push(struct btree\_iter \*iter, struct bkey \*k, struct bkey \*end);-struct bkey \*bch\_btree\_iter\_init(struct btree\_keys \*b,- struct btree\_iter \*iter,- struct bkey \*search);+struct bkey \*bch\_btree\_iter\_stack\_init(struct btree\_keys \*b,+ struct btree\_iter\_stack \*iter,+ struct bkey \*search);  struct bkey \*\_\_bch\_bset\_search(struct btree\_keys \*b, struct bset\_tree \*t, const struct bkey \*search);@@ -350,13 +357,14 @@ static inline struct bkey \*bch\_bset\_search(struct btree\_keys \*b, return search ? \_\_bch\_bset\_search(b, t, search) : t->data->start; } -#define for\_each\_key\_filter(b, k, iter, filter) \- for (bch\_btree\_iter\_init((b), (iter), NULL); \- ((k) = bch\_btree\_iter\_next\_filter((iter), (b), filter));)+#define for\_each\_key\_filter(b, k, stack\_iter, filter) \+ for (bch\_btree\_iter\_stack\_init((b), (stack\_iter), NULL); \+ ((k) = bch\_btree\_iter\_next\_filter(&((stack\_iter)->iter), (b), \+ filter));) -#define for\_each\_key(b, k, iter) \- for (bch\_btree\_iter\_init((b), (iter), NULL); \- ((k) = bch\_btree\_iter\_next(iter));)+#define for\_each\_key(b, k, stack\_iter) \+ for (bch\_btree\_iter\_stack\_init((b), (stack\_iter), NULL); \+ ((k) = bch\_btree\_iter\_next(&((stack\_iter)->iter)));)  /\* Sorting \*/ diff --git a/drivers/md/bcache/btree.c b/drivers/md/bcache/btree.cindex 6a2f57ae0f3c2d..d680c810e5e128 100644--- a/[drivers/md/bcache/btree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/btree.c?id=011552f29f20842c9a7a21bffe1f6a2d6457ba46)+++ b/[drivers/md/bcache/btree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/btree.c?id=934e1e4331859183a861f396d7dfaf33cb5afb02)@@ -1283,7 +1283,7 @@ static bool btree\_gc\_mark\_node(struct btree \*b, struct gc\_stat \*gc) uint8\_t stale = 0; unsigned int keys = 0, good\_keys = 0; struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bset\_tree \*t;  gc->nodes++;@@ -1544,7 +1544,7 @@ static int btree\_gc\_rewrite\_node(struct btree \*b, struct btree\_op \*op, static unsigned int btree\_gc\_count\_keys(struct btree \*b) { struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; unsigned int ret = 0;  for\_each\_key\_filter(&b->keys, k, &iter, bch\_ptr\_bad)@@ -1585,17 +1585,18 @@ static int btree\_gc\_recurse(struct btree \*b, struct btree\_op \*op, int ret = 0; bool should\_rewrite; struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct gc\_merge\_info r[GC\_MERGE\_NODES]; struct gc\_merge\_info \*i, \*last = r + ARRAY\_SIZE(r) - 1; - bch\_btree\_iter\_init(&b->keys, &iter, &b->c->gc\_done);+ bch\_btree\_iter\_stack\_init(&b->keys, &iter, &b->c->gc\_done);  for (i = r; i < r + ARRAY\_SIZE(r); i++) i->b = ERR\_PTR(-EINTR);  while (1) {- k = bch\_btree\_iter\_next\_filter(&iter, &b->keys, bch\_ptr\_bad);+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &b->keys,+ bch\_ptr\_bad); if (k) { r->b = bch\_btree\_node\_get(b->c, op, k, b->level - 1, true, b);@@ -1885,7 +1886,7 @@ static int bch\_btree\_check\_recurse(struct btree \*b, struct btree\_op \*op) { int ret = 0; struct bkey \*k, \*p = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter;  for\_each\_key\_filter(&b->keys, k, &iter, bch\_ptr\_invalid) bch\_initial\_mark\_key(b->c, b->level, k);@@ -1893,10 +1894,10 @@ static int bch\_btree\_check\_recurse(struct btree \*b, struct btree\_op \*op) bch\_initial\_mark\_key(b->c, b->level + 1, &b->key);  if (b->level) {- bch\_btree\_iter\_init(&b->keys, &iter, NULL);+ bch\_btree\_iter\_stack\_init(&b->keys, &iter, NULL);  do {- k = bch\_btree\_iter\_next\_filter(&iter, &b->keys,+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &b->keys, bch\_ptr\_bad); if (k) { btree\_node\_prefetch(b, k);@@ -1924,7 +1925,7 @@ static int bch\_btree\_check\_thread(void \*arg) struct btree\_check\_info \*info = arg; struct btree\_check\_state \*check\_state = info->state; struct cache\_set \*c = check\_state->c;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bkey \*k, \*p; int cur\_idx, prev\_idx, skip\_nr; @@ -1933,8 +1934,8 @@ static int bch\_btree\_check\_thread(void \*arg) ret = 0;  /\* root node keys are checked before thread created \*/- bch\_btree\_iter\_init(&c->root->keys, &iter, NULL);- k = bch\_btree\_iter\_next\_filter(&iter, &c->root->keys, bch\_ptr\_bad);+ bch\_btree\_iter\_stack\_init(&c->root->keys, &iter, NULL);+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &c->root->keys, bch\_ptr\_bad); BUG\_ON(!k);  p = k;@@ -1952,7 +1953,7 @@ static int bch\_btree\_check\_thread(void \*arg) skip\_nr = cur\_idx - prev\_idx;  while (skip\_nr) {- k = bch\_btree\_iter\_next\_filter(&iter,+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &c->root->keys, bch\_ptr\_bad); if (k)@@ -2025,7 +2026,7 @@ int bch\_btree\_check(struct cache\_set \*c) int ret = 0; int i; struct bkey \*k = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct btree\_check\_state check\_state;  /\* check and mark root node keys \*/@@ -2521,11 +2522,11 @@ static int bch\_btree\_map\_nodes\_recurse(struct btree \*b, struct btree\_op \*op,  if (b->level) { struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; - bch\_btree\_iter\_init(&b->keys, &iter, from);+ bch\_btree\_iter\_stack\_init(&b->keys, &iter, from); - while ((k = bch\_btree\_iter\_next\_filter(&iter, &b->keys,+ while ((k = bch\_btree\_iter\_next\_filter(&iter.iter, &b->keys, bch\_ptr\_bad))) { ret = bcache\_btree(map\_nodes\_recurse, k, b, op, from, fn, flags);@@ -2554,11 +2555,12 @@ int bch\_btree\_map\_keys\_recurse(struct btree \*b, struct btree\_op \*op, { int ret = MAP\_CONTINUE; struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; - bch\_btree\_iter\_init(&b->keys, &iter, from);+ bch\_btree\_iter\_stack\_init(&b->keys, &iter, from); - while ((k = bch\_btree\_iter\_next\_filter(&iter, &b->keys, bch\_ptr\_bad))) {+ while ((k = bch\_btree\_iter\_next\_filter(&iter.iter, &b->keys,+ bch\_ptr\_bad))) { ret = !b->level ? fn(op, b, k) : bcache\_btree(map\_keys\_recurse, k,diff --git a/drivers/md/bcache/super.c b/drivers/md/bcache/super.cindex 70e5bd8961d2f6..659f6777b97377 100644--- a/[drivers/md/bcache/super.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/super.c?id=011552f29f20842c9a7a21bffe1f6a2d6457ba46)+++ b/[drivers/md/bcache/super.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/super.c?id=934e1e4331859183a861f396d7dfaf33cb5afb02)@@ -1915,8 +1915,9 @@ struct cache\_set \*bch\_cache\_set\_alloc(struct cache\_sb \*sb) INIT\_LIST\_HEAD(&c->btree\_cache\_freed); INIT\_LIST\_HEAD(&c->data\_buckets); - iter\_size = ((meta\_bucket\_pages(sb) \* PAGE\_SECTORS) / sb->block\_size + 1) \*- sizeof(struct btree\_iter\_set);+ iter\_size = sizeof(struct btree\_iter) ++ ((meta\_bucket\_pages(sb) \* PAGE\_SECTORS) / sb->block\_size) \*+ sizeof(struct btree\_iter\_set);  c->devices = kcalloc(c->nr\_uuids, sizeof(void \*), GFP\_KERNEL); if (!c->devices)diff --git a/drivers/md/bcache/sysfs.c b/drivers/md/bcache/sysfs.cindex 025fe6479bb68b..15749ba958c80d 100644--- a/[drivers/md/bcache/sysfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/sysfs.c?id=011552f29f20842c9a7a21bffe1f6a2d6457ba46)+++ b/[drivers/md/bcache/sysfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/sysfs.c?id=934e1e4331859183a861f396d7dfaf33cb5afb02)@@ -660,7 +660,7 @@ static unsigned int bch\_root\_usage(struct cache\_set \*c) unsigned int bytes = 0; struct bkey \*k; struct btree \*b;- struct btree\_iter iter;+ struct btree\_iter\_stack iter;  goto lock\_root; diff --git a/drivers/md/bcache/writeback.c b/drivers/md/bcache/writeback.cindex 18c6e0d2877b5f..6081dc6fd01326 100644--- a/[drivers/md/bcache/writeback.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/writeback.c?id=011552f29f20842c9a7a21bffe1f6a2d6457ba46)+++ b/[drivers/md/bcache/writeback.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/writeback.c?id=934e1e4331859183a861f396d7dfaf33cb5afb02)@@ -908,15 +908,15 @@ static int bch\_dirty\_init\_thread(void \*arg) struct dirty\_init\_thrd\_info \*info = arg; struct bch\_dirty\_init\_state \*state = info->state; struct cache\_set \*c = state->c;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bkey \*k, \*p; int cur\_idx, prev\_idx, skip\_nr;  k = p = NULL; prev\_idx = 0; - bch\_btree\_iter\_init(&c->root->keys, &iter, NULL);- k = bch\_btree\_iter\_next\_filter(&iter, &c->root->keys, bch\_ptr\_bad);+ bch\_btree\_iter\_stack\_init(&c->root->keys, &iter, NULL);+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &c->root->keys, bch\_ptr\_bad); BUG\_ON(!k);  p = k;@@ -930,7 +930,7 @@ static int bch\_dirty\_init\_thread(void \*arg) skip\_nr = cur\_idx - prev\_idx;  while (skip\_nr) {- k = bch\_btree\_iter\_next\_filter(&iter,+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &c->root->keys, bch\_ptr\_bad); if (k)@@ -979,7 +979,7 @@ void bch\_sectors\_dirty\_init(struct bcache\_device \*d) int i; struct btree \*b = NULL; struct bkey \*k = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct sectors\_dirty\_init op; struct cache\_set \*c = d->c; struct bch\_dirty\_init\_state state; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 14:29:50 +0000



=== Content from git.kernel.org_bf887559_20250110_143110.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=2c3d7b03b658dc8bfa6112b194b67b92a87e081b)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=2c3d7b03b658dc8bfa6112b194b67b92a87e081b)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=2c3d7b03b658dc8bfa6112b194b67b92a87e081b)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=2c3d7b03b658dc8bfa6112b194b67b92a87e081b)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Matthew Mirvish <matthew@mm12.xyz> | 2024-05-09 09:11:17 +0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-07-05 09:12:43 +0200 |
| commit | [2c3d7b03b658dc8bfa6112b194b67b92a87e081b](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=2c3d7b03b658dc8bfa6112b194b67b92a87e081b) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=2c3d7b03b658dc8bfa6112b194b67b92a87e081b)) | |
| tree | [d867104fdd5368d01c7c26951132d4f2dd26cbd7](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=2c3d7b03b658dc8bfa6112b194b67b92a87e081b) | |
| parent | [6337072467296defa7d1b0160c03de3d39b1d318](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6337072467296defa7d1b0160c03de3d39b1d318) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=2c3d7b03b658dc8bfa6112b194b67b92a87e081b&id2=6337072467296defa7d1b0160c03de3d39b1d318)) | |
| download | [linux-2c3d7b03b658dc8bfa6112b194b67b92a87e081b.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-2c3d7b03b658dc8bfa6112b194b67b92a87e081b.tar.gz) | |

bcache: fix variable length array abuse in btree\_iter[ Upstream commit 3a861560ccb35f2a4f0a4b8207fa7c2a35fc7f31 ]
btree\_iter is used in two ways: either allocated on the stack with a
fixed size MAX\_BSETS, or from a mempool with a dynamic size based on the
specific cache set. Previously, the struct had a fixed-length array of
size MAX\_BSETS which was indexed out-of-bounds for the dynamically-sized
iterators, which causes UBSAN to complain.
This patch uses the same approach as in bcachefs's sort\_iter and splits
the iterator into a btree\_iter with a flexible array member and a
btree\_iter\_stack which embeds a btree\_iter as well as a fixed-length
data array.
Cc: stable@vger.kernel.org
Closes: https://bugs.launchpad.net/ubuntu/+source/linux/+bug/2039368
Signed-off-by: Matthew Mirvish <matthew@mm12.xyz>
Signed-off-by: Coly Li <colyli@suse.de>
Link: [https://lore.kernel.org/r/20240509011117.2697-3-colyli@suse.de](https://lore.kernel.org/r/20240509011117.2697-3-colyli%40suse.de)
Signed-off-by: Jens Axboe <axboe@kernel.dk>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=2c3d7b03b658dc8bfa6112b194b67b92a87e081b)

| -rw-r--r-- | [drivers/md/bcache/bset.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/bset.c?id=2c3d7b03b658dc8bfa6112b194b67b92a87e081b) | 44 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/md/bcache/bset.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/bset.h?id=2c3d7b03b658dc8bfa6112b194b67b92a87e081b) | 28 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/md/bcache/btree.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/btree.c?id=2c3d7b03b658dc8bfa6112b194b67b92a87e081b) | 40 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/md/bcache/super.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/super.c?id=2c3d7b03b658dc8bfa6112b194b67b92a87e081b) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/md/bcache/sysfs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/sysfs.c?id=2c3d7b03b658dc8bfa6112b194b67b92a87e081b) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/md/bcache/writeback.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/bcache/writeback.c?id=2c3d7b03b658dc8bfa6112b194b67b92a87e081b) | 10 | |  |  |  | | --- | --- | --- | |

6 files changed, 70 insertions, 59 deletions

| diff --git a/drivers/md/bcache/bset.c b/drivers/md/bcache/bset.cindex 67a2c47f4201ae..f006c780dd4bf0 100644--- a/[drivers/md/bcache/bset.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/bset.c?id=6337072467296defa7d1b0160c03de3d39b1d318)+++ b/[drivers/md/bcache/bset.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/bset.c?id=2c3d7b03b658dc8bfa6112b194b67b92a87e081b)@@ -54,7 +54,7 @@ void bch\_dump\_bucket(struct btree\_keys \*b) int \_\_bch\_count\_data(struct btree\_keys \*b) { unsigned int ret = 0;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bkey \*k;  if (b->ops->is\_extents)@@ -67,7 +67,7 @@ void \_\_bch\_check\_keys(struct btree\_keys \*b, const char \*fmt, ...) { va\_list args; struct bkey \*k, \*p = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; const char \*err;  for\_each\_key(b, k, &iter) {@@ -877,7 +877,7 @@ unsigned int bch\_btree\_insert\_key(struct btree\_keys \*b, struct bkey \*k, unsigned int status = BTREE\_INSERT\_STATUS\_NO\_INSERT; struct bset \*i = bset\_tree\_last(b)->data; struct bkey \*m, \*prev = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bkey preceding\_key\_on\_stack = ZERO\_KEY; struct bkey \*preceding\_key\_p = &preceding\_key\_on\_stack; @@ -893,9 +893,9 @@ unsigned int bch\_btree\_insert\_key(struct btree\_keys \*b, struct bkey \*k, else preceding\_key(k, &preceding\_key\_p); - m = bch\_btree\_iter\_init(b, &iter, preceding\_key\_p);+ m = bch\_btree\_iter\_stack\_init(b, &iter, preceding\_key\_p); - if (b->ops->insert\_fixup(b, k, &iter, replace\_key))+ if (b->ops->insert\_fixup(b, k, &iter.iter, replace\_key)) return status;  status = BTREE\_INSERT\_STATUS\_INSERT;@@ -1096,33 +1096,33 @@ void bch\_btree\_iter\_push(struct btree\_iter \*iter, struct bkey \*k, btree\_iter\_cmp)); } -static struct bkey \*\_\_bch\_btree\_iter\_init(struct btree\_keys \*b,- struct btree\_iter \*iter,- struct bkey \*search,- struct bset\_tree \*start)+static struct bkey \*\_\_bch\_btree\_iter\_stack\_init(struct btree\_keys \*b,+ struct btree\_iter\_stack \*iter,+ struct bkey \*search,+ struct bset\_tree \*start) { struct bkey \*ret = NULL; - iter->size = ARRAY\_SIZE(iter->data);- iter->used = 0;+ iter->iter.size = ARRAY\_SIZE(iter->stack\_data);+ iter->iter.used = 0;  #ifdef CONFIG\_BCACHE\_DEBUG- iter->b = b;+ iter->iter.b = b; #endif  for (; start <= bset\_tree\_last(b); start++) { ret = bch\_bset\_search(b, start, search);- bch\_btree\_iter\_push(iter, ret, bset\_bkey\_last(start->data));+ bch\_btree\_iter\_push(&iter->iter, ret, bset\_bkey\_last(start->data)); }  return ret; } -struct bkey \*bch\_btree\_iter\_init(struct btree\_keys \*b,- struct btree\_iter \*iter,+struct bkey \*bch\_btree\_iter\_stack\_init(struct btree\_keys \*b,+ struct btree\_iter\_stack \*iter, struct bkey \*search) {- return \_\_bch\_btree\_iter\_init(b, iter, search, b->set);+ return \_\_bch\_btree\_iter\_stack\_init(b, iter, search, b->set); }  static inline struct bkey \*\_\_bch\_btree\_iter\_next(struct btree\_iter \*iter,@@ -1289,10 +1289,10 @@ void bch\_btree\_sort\_partial(struct btree\_keys \*b, unsigned int start, struct bset\_sort\_state \*state) { size\_t order = b->page\_order, keys = 0;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; int oldsize = bch\_count\_data(b); - \_\_bch\_btree\_iter\_init(b, &iter, NULL, &b->set[start]);+ \_\_bch\_btree\_iter\_stack\_init(b, &iter, NULL, &b->set[start]);  if (start) { unsigned int i;@@ -1303,7 +1303,7 @@ void bch\_btree\_sort\_partial(struct btree\_keys \*b, unsigned int start, order = get\_order(\_\_set\_bytes(b->set->data, keys)); } - \_\_btree\_sort(b, &iter, start, order, false, state);+ \_\_btree\_sort(b, &iter.iter, start, order, false, state);  EBUG\_ON(oldsize >= 0 && bch\_count\_data(b) != oldsize); }@@ -1319,11 +1319,11 @@ void bch\_btree\_sort\_into(struct btree\_keys \*b, struct btree\_keys \*new, struct bset\_sort\_state \*state) { uint64\_t start\_time = local\_clock();- struct btree\_iter iter;+ struct btree\_iter\_stack iter; - bch\_btree\_iter\_init(b, &iter, NULL);+ bch\_btree\_iter\_stack\_init(b, &iter, NULL); - btree\_mergesort(b, new->set->data, &iter, false, true);+ btree\_mergesort(b, new->set->data, &iter.iter, false, true);  bch\_time\_stats\_update(&state->time, start\_time); diff --git a/drivers/md/bcache/bset.h b/drivers/md/bcache/bset.hindex a50dcfda656f5f..2ed6dbd35d6e5e 100644--- a/[drivers/md/bcache/bset.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/bset.h?id=6337072467296defa7d1b0160c03de3d39b1d318)+++ b/[drivers/md/bcache/bset.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/bset.h?id=2c3d7b03b658dc8bfa6112b194b67b92a87e081b)@@ -321,7 +321,14 @@ struct btree\_iter { #endif struct btree\_iter\_set { struct bkey \*k, \*end;- } data[MAX\_BSETS];+ } data[];+};++/\* Fixed-size btree\_iter that can be allocated on the stack \*/++struct btree\_iter\_stack {+ struct btree\_iter iter;+ struct btree\_iter\_set stack\_data[MAX\_BSETS]; };  typedef bool (\*ptr\_filter\_fn)(struct btree\_keys \*b, const struct bkey \*k);@@ -333,9 +340,9 @@ struct bkey \*bch\_btree\_iter\_next\_filter(struct btree\_iter \*iter,  void bch\_btree\_iter\_push(struct btree\_iter \*iter, struct bkey \*k, struct bkey \*end);-struct bkey \*bch\_btree\_iter\_init(struct btree\_keys \*b,- struct btree\_iter \*iter,- struct bkey \*search);+struct bkey \*bch\_btree\_iter\_stack\_init(struct btree\_keys \*b,+ struct btree\_iter\_stack \*iter,+ struct bkey \*search);  struct bkey \*\_\_bch\_bset\_search(struct btree\_keys \*b, struct bset\_tree \*t, const struct bkey \*search);@@ -350,13 +357,14 @@ static inline struct bkey \*bch\_bset\_search(struct btree\_keys \*b, return search ? \_\_bch\_bset\_search(b, t, search) : t->data->start; } -#define for\_each\_key\_filter(b, k, iter, filter) \- for (bch\_btree\_iter\_init((b), (iter), NULL); \- ((k) = bch\_btree\_iter\_next\_filter((iter), (b), filter));)+#define for\_each\_key\_filter(b, k, stack\_iter, filter) \+ for (bch\_btree\_iter\_stack\_init((b), (stack\_iter), NULL); \+ ((k) = bch\_btree\_iter\_next\_filter(&((stack\_iter)->iter), (b), \+ filter));) -#define for\_each\_key(b, k, iter) \- for (bch\_btree\_iter\_init((b), (iter), NULL); \- ((k) = bch\_btree\_iter\_next(iter));)+#define for\_each\_key(b, k, stack\_iter) \+ for (bch\_btree\_iter\_stack\_init((b), (stack\_iter), NULL); \+ ((k) = bch\_btree\_iter\_next(&((stack\_iter)->iter)));)  /\* Sorting \*/ diff --git a/drivers/md/bcache/btree.c b/drivers/md/bcache/btree.cindex 1a1a9554474ae3..2768b4b4302d68 100644--- a/[drivers/md/bcache/btree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/btree.c?id=6337072467296defa7d1b0160c03de3d39b1d318)+++ b/[drivers/md/bcache/btree.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/btree.c?id=2c3d7b03b658dc8bfa6112b194b67b92a87e081b)@@ -1283,7 +1283,7 @@ static bool btree\_gc\_mark\_node(struct btree \*b, struct gc\_stat \*gc) uint8\_t stale = 0; unsigned int keys = 0, good\_keys = 0; struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bset\_tree \*t;  gc->nodes++;@@ -1544,7 +1544,7 @@ static int btree\_gc\_rewrite\_node(struct btree \*b, struct btree\_op \*op, static unsigned int btree\_gc\_count\_keys(struct btree \*b) { struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; unsigned int ret = 0;  for\_each\_key\_filter(&b->keys, k, &iter, bch\_ptr\_bad)@@ -1585,17 +1585,18 @@ static int btree\_gc\_recurse(struct btree \*b, struct btree\_op \*op, int ret = 0; bool should\_rewrite; struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct gc\_merge\_info r[GC\_MERGE\_NODES]; struct gc\_merge\_info \*i, \*last = r + ARRAY\_SIZE(r) - 1; - bch\_btree\_iter\_init(&b->keys, &iter, &b->c->gc\_done);+ bch\_btree\_iter\_stack\_init(&b->keys, &iter, &b->c->gc\_done);  for (i = r; i < r + ARRAY\_SIZE(r); i++) i->b = ERR\_PTR(-EINTR);  while (1) {- k = bch\_btree\_iter\_next\_filter(&iter, &b->keys, bch\_ptr\_bad);+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &b->keys,+ bch\_ptr\_bad); if (k) { r->b = bch\_btree\_node\_get(b->c, op, k, b->level - 1, true, b);@@ -1885,7 +1886,7 @@ static int bch\_btree\_check\_recurse(struct btree \*b, struct btree\_op \*op) { int ret = 0; struct bkey \*k, \*p = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter;  for\_each\_key\_filter(&b->keys, k, &iter, bch\_ptr\_invalid) bch\_initial\_mark\_key(b->c, b->level, k);@@ -1893,10 +1894,10 @@ static int bch\_btree\_check\_recurse(struct btree \*b, struct btree\_op \*op) bch\_initial\_mark\_key(b->c, b->level + 1, &b->key);  if (b->level) {- bch\_btree\_iter\_init(&b->keys, &iter, NULL);+ bch\_btree\_iter\_stack\_init(&b->keys, &iter, NULL);  do {- k = bch\_btree\_iter\_next\_filter(&iter, &b->keys,+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &b->keys, bch\_ptr\_bad); if (k) { btree\_node\_prefetch(b, k);@@ -1924,7 +1925,7 @@ static int bch\_btree\_check\_thread(void \*arg) struct btree\_check\_info \*info = arg; struct btree\_check\_state \*check\_state = info->state; struct cache\_set \*c = check\_state->c;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bkey \*k, \*p; int cur\_idx, prev\_idx, skip\_nr; @@ -1933,8 +1934,8 @@ static int bch\_btree\_check\_thread(void \*arg) ret = 0;  /\* root node keys are checked before thread created \*/- bch\_btree\_iter\_init(&c->root->keys, &iter, NULL);- k = bch\_btree\_iter\_next\_filter(&iter, &c->root->keys, bch\_ptr\_bad);+ bch\_btree\_iter\_stack\_init(&c->root->keys, &iter, NULL);+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &c->root->keys, bch\_ptr\_bad); BUG\_ON(!k);  p = k;@@ -1952,7 +1953,7 @@ static int bch\_btree\_check\_thread(void \*arg) skip\_nr = cur\_idx - prev\_idx;  while (skip\_nr) {- k = bch\_btree\_iter\_next\_filter(&iter,+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &c->root->keys, bch\_ptr\_bad); if (k)@@ -2025,7 +2026,7 @@ int bch\_btree\_check(struct cache\_set \*c) int ret = 0; int i; struct bkey \*k = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct btree\_check\_state check\_state;  /\* check and mark root node keys \*/@@ -2521,11 +2522,11 @@ static int bch\_btree\_map\_nodes\_recurse(struct btree \*b, struct btree\_op \*op,  if (b->level) { struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; - bch\_btree\_iter\_init(&b->keys, &iter, from);+ bch\_btree\_iter\_stack\_init(&b->keys, &iter, from); - while ((k = bch\_btree\_iter\_next\_filter(&iter, &b->keys,+ while ((k = bch\_btree\_iter\_next\_filter(&iter.iter, &b->keys, bch\_ptr\_bad))) { ret = bcache\_btree(map\_nodes\_recurse, k, b, op, from, fn, flags);@@ -2554,11 +2555,12 @@ int bch\_btree\_map\_keys\_recurse(struct btree \*b, struct btree\_op \*op, { int ret = MAP\_CONTINUE; struct bkey \*k;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; - bch\_btree\_iter\_init(&b->keys, &iter, from);+ bch\_btree\_iter\_stack\_init(&b->keys, &iter, from); - while ((k = bch\_btree\_iter\_next\_filter(&iter, &b->keys, bch\_ptr\_bad))) {+ while ((k = bch\_btree\_iter\_next\_filter(&iter.iter, &b->keys,+ bch\_ptr\_bad))) { ret = !b->level ? fn(op, b, k) : bcache\_btree(map\_keys\_recurse, k,diff --git a/drivers/md/bcache/super.c b/drivers/md/bcache/super.cindex 04ddaa4bbd77fb..14336fd5410203 100644--- a/[drivers/md/bcache/super.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/super.c?id=6337072467296defa7d1b0160c03de3d39b1d318)+++ b/[drivers/md/bcache/super.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/super.c?id=2c3d7b03b658dc8bfa6112b194b67b92a87e081b)@@ -1939,8 +1939,9 @@ struct cache\_set \*bch\_cache\_set\_alloc(struct cache\_sb \*sb) INIT\_LIST\_HEAD(&c->btree\_cache\_freed); INIT\_LIST\_HEAD(&c->data\_buckets); - iter\_size = ((meta\_bucket\_pages(sb) \* PAGE\_SECTORS) / sb->block\_size + 1) \*- sizeof(struct btree\_iter\_set);+ iter\_size = sizeof(struct btree\_iter) ++ ((meta\_bucket\_pages(sb) \* PAGE\_SECTORS) / sb->block\_size) \*+ sizeof(struct btree\_iter\_set);  c->devices = kcalloc(c->nr\_uuids, sizeof(void \*), GFP\_KERNEL); if (!c->devices)diff --git a/drivers/md/bcache/sysfs.c b/drivers/md/bcache/sysfs.cindex ca3e2f000cd4db..a31108625f463a 100644--- a/[drivers/md/bcache/sysfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/sysfs.c?id=6337072467296defa7d1b0160c03de3d39b1d318)+++ b/[drivers/md/bcache/sysfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/sysfs.c?id=2c3d7b03b658dc8bfa6112b194b67b92a87e081b)@@ -639,7 +639,7 @@ static unsigned int bch\_root\_usage(struct cache\_set \*c) unsigned int bytes = 0; struct bkey \*k; struct btree \*b;- struct btree\_iter iter;+ struct btree\_iter\_stack iter;  goto lock\_root; diff --git a/drivers/md/bcache/writeback.c b/drivers/md/bcache/writeback.cindex 8e3f5f004c397b..9a2aac59f6bcb6 100644--- a/[drivers/md/bcache/writeback.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/writeback.c?id=6337072467296defa7d1b0160c03de3d39b1d318)+++ b/[drivers/md/bcache/writeback.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/bcache/writeback.c?id=2c3d7b03b658dc8bfa6112b194b67b92a87e081b)@@ -852,15 +852,15 @@ static int bch\_dirty\_init\_thread(void \*arg) struct dirty\_init\_thrd\_info \*info = arg; struct bch\_dirty\_init\_state \*state = info->state; struct cache\_set \*c = state->c;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct bkey \*k, \*p; int cur\_idx, prev\_idx, skip\_nr;  k = p = NULL; prev\_idx = 0; - bch\_btree\_iter\_init(&c->root->keys, &iter, NULL);- k = bch\_btree\_iter\_next\_filter(&iter, &c->root->keys, bch\_ptr\_bad);+ bch\_btree\_iter\_stack\_init(&c->root->keys, &iter, NULL);+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &c->root->keys, bch\_ptr\_bad); BUG\_ON(!k);  p = k;@@ -874,7 +874,7 @@ static int bch\_dirty\_init\_thread(void \*arg) skip\_nr = cur\_idx - prev\_idx;  while (skip\_nr) {- k = bch\_btree\_iter\_next\_filter(&iter,+ k = bch\_btree\_iter\_next\_filter(&iter.iter, &c->root->keys, bch\_ptr\_bad); if (k)@@ -923,7 +923,7 @@ void bch\_sectors\_dirty\_init(struct bcache\_device \*d) int i; struct btree \*b = NULL; struct bkey \*k = NULL;- struct btree\_iter iter;+ struct btree\_iter\_stack iter; struct sectors\_dirty\_init op; struct cache\_set \*c = d->c; struct bch\_dirty\_init\_state state; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 14:29:47 +0000


