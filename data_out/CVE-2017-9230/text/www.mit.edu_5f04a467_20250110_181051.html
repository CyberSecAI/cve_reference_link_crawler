The Problem with ASICBOOST

Jeremy Rubin

April 11, 2017

1

Intro

Recently there has been a lot of interesting material coming out regarding ASIC-
BOOST. ASICBOOST is a mining optimization that allows one to mine many
times faster by taking advantage of a quirk of SHA-256. There are multiple
ways of implementing ASICBOOST, and recent claims are that one which is
incompatible with upgrading Bitcoin is being used.

I thought it was a bit confusing, so I hand wrote some notes for myself. They

became somewhat popular, so I decide (by popular request) to LATEX them.

Enjoy!

Update Log:

• April 11th: Correct diagram in 3.2.

• April 10th: Some corrections thanks to Gregory Maxwell (who ﬁrst brought
these issues to light). Made clear that replacement is better than permu-
tation. Added a brief mention on Amdahl’s law for speedups.

• April 9th: Fixed a few typos/formatting errors. Clariﬁed witness commit-

ment diagram to be more accurate.

• April 9th: Posted LATEX Notes.

• April 6th: Posted Original Handwritten Notes.

1

2 Basics

A Bitcoin Header looks like this:

0

4

36

68

72

76

80

V
E
R
S
I
O
N

0

PREVIOUS BLOCK

MERKLE ROOT

T
I
M
E

N
B
I
T
S

N
O
N
C
E

A SHA-256 Hash of 80-Bytes looks like this:

64

Data

Chunk 1

Data

padding: 0x80. . . 00

Chunk 2

128

S
I
Z
E

The Hash computation has the following control ﬂow:

S0

Chunk 1

Chunk 2

Preprocess
Chunk 1

S1

S2

Preprocess
Chunk 2

2

3 Reduced Work Updates

ASICBOOST takes advantage of the following reductions in work if you modify
the ﬁrst or second half of the header only. In the following diagrams, I’ve blacked
out parts that aren’t recomputed.

Modifying Chunk 1 Only Modifying only chunk 1 gives a small improve-
ment.

S0

Chunk 1

Chunk 2

Preprocess
Chunk 1

S1

S2

Preprocess
Chunk 2

Modifying Chunk 2 Only Modifying only chunk 2 gives a huge improve-
ment.

S0

Chunk 1

Chunk 2

Preprocess
Chunk 1

S1

S2

Preprocess
Chunk 2

3

3.1 How do headers get hashed?

Let’s juxtapose the header and hash alignment.

0

4

36

64

68

72

76

80

128

Chunk 1

Chunk 2

Data

Data

padding: 0x80. . . 00

S
I
Z
E

V
E
R
S
I
O
N

PREVIOUS BLOCK

MERKLE ROOT

T
I
M
E

N
B
I
T
S

N
O
N
C
E

The Merkle root commitment is in both chunk 1 and chunk 2. The ﬁrst 28

Bytes are in chunk 1, the remaining 4 bytes are in chunk 2.

3.1.1 What is in the Merkle root?

At each level, the hash of the concatenated strings is computed. Each letter
A . . . H is the hash of a transaction. The node ABCDEF GH is called the
merkle root.

ABCD
EFGH

AB
CD

EF
GH

AB

CD

EF

GH

A

B

C

D

E

F

G

H

If any of the underlying data A . . . H are either modiﬁed or reordered, the

4

Merkle root will have a diﬀerent value (uniformly random).

3.2 What if we ﬁnd two merkle roots with the same last

4 bytes?

Now we can run our very eﬃcient algorithm to only modify chunk 2 on many
precomputed chunk 1s.

Chunk 1 A

Chunk 2

Chunk 1 B

Preprocess
Chunk 1 A

Preprocess
Chunk 2

Preprocess
Chunk 1 B

S0

SA,1

SA,2

SB,2

SB,1

S0

So now for a little extra setup work, we get a 2× hash rate multiplier for every
nonce we try in chunk 2. The below diagram shows the part that doesn’t need
to be recomputed.

Chunk 1 A

Chunk 2

Chunk 1 A

Preprocess
Chunk 1 A

Preprocess
Chunk 2

Preprocess
Chunk 1 B

S0

SA,1

SA,2

SB,2

SB,1

s0

If we ﬁnd N chunk 1s, we can use the same trick for an N × hash rate

multiplier.

As explained by Amdahl’s Law1 and due to Bitcoin’s Proof-of-Work being
double-SHA-256, the actual measured hash rate increase using this technique
will not be as pronounced.

1Speedup =

(cid:16)

(1 − % Parallelizable) + % Parallelizable

# Workers

(cid:17)−1

5

4 Practical Collision Generation

How do we generate colliding (in the last 4 bytes) transaction tree Merkle com-
mitments eﬃciently?

4.1 Birthday Paradox

The Birthday Paradox says that if 23 people are in a room, there is a 50%
chance that at least two people share a birthday.

This is the same problem as our tree collision, but with diﬀerent numbers.
It works because as the number of people increases, the number of indepen-

dent chances of sharing a birthday increases more quickly.

You can visualize this as counting the number of connections in the following
graphs. These represent independent chances to share a birthday between nodes.

The closed form for the number of connections for n nodes is (cid:0)n

(cid:1) = n!

2·(n−2)! =

2

n·(n−1)
2

= O(n2) chances

4.1.1 Generalized Birthday Paradox

A general closed formula for computing the number E of entries of T types
needed to be P probable to have a C-way collision is hard to ﬁnd, but the
following approximation works well as an upper bound2.

P ≈ 1 − e−(E

C)T −C+1

For instance, for the standard birthday paradox problem:

P ≈ 0.5 ≈ 1 − e−(23

2 )365−2+1

4.2 Summary

It’s clear that the key in collision hunting is to store and generate a large number
of potential matches to compare against. The probability of a collision becomes
very likely even with a large set of possible “birthdays” (T ), and relatively small
numbers of “people” (E).

Using our formula, for 4 bytes of potential “birthdays”, at 110k “people”,

the probability of a shared “birthday” is more than 75%.

1 − e−(110k

2 )(232)−1

> 0.75

2It should over-count. See

https://math.stackexchange.com/questions/25876/probability-of-3-people-in-a-room-of-30-having-the-same-birthday

6

Creating a last 4 bytes colliding Merkle tree commitments is now reduced
to a problem of generating 110k unique transaction commitment merkle roots.

5 Generating N Unique Merkle Trees

5.1 Naive Algorithm

We can generate a unique Merkle tree by changing one of the base nodes.

ABCD
EFGH

AB
CD

EF
GH

AB

CD

EF

GH

A

B

C

D

E

F

G

H

ABC’D
EFGH

AB
C’D

EF
GH

AB

C’D

EF

GH

A

B

C

D

E

F

G

H

The non-blacked out boxes all need to be recomputed when changing C →
C (cid:48). Let m be the number of leaf nodes, the naive algorithm requires O(N log m)
hashes.

7

5.2 Higher Order Permutations

Instead, we could do higher-order permutations

EFGH
ABCD

EF
GH

AB
CD

EF

GH

AB

CD

E

F

G

H

A

B

C

D

Now we only need to do one re-computation to get a second potential match.
If we black out the ones that don’t need recomputing we see clearly this is better

EFGH
ABCD

EF
GH

AB
CD

EF

GH

AB

CD

E

F

G

H

A

B

C

D

In the naive version, each new potential match is expensive to compute. In
the smarter version, we can recursively apply this principle to very eﬃciently
generate potential matches.

There are several strategies for generating candidates, not just swapping.
Swapping isn’t optimal because Bitcoin transactions have order dependen-
cies. Most likely, miners are not using permutation. Permutation is demonstra-
tive of the principles at play. The next section covers a more eﬃcient algorithm.

8

5.3 Eﬃcient Algorithm

Let’s say we want to generate R collisions, and the birthday paradox says it is
likely with N hashes.
First, we generate

N unique right hand

√

√

sides (i.e., Aα, Bβ where α, β ∈ 1 · · ·

N unique left hand sides and
N ).

√

AαAαAαAαAαAαAαAα

BβBβBβBβBβBβBβBβ

√

With our

N Aαs and Bβs, we can generate N candidates by combining
each Aα with each Bβ. The diagram below illustrates the combination process.

Merkle
Root
Candidates

Merkle
Root
Candidates

AαAαAα−5

AαAαAαAαAα

BβBβBβBβBβBβBβ−1

AαAαAα−5

Bβ

AαAαAαAαAα

BβBβBβBβBβBβ−2

BβBβ

√

(cid:112)√

We can apply this recursvely: to generate

N
left hand sides and right hand sides. In the base case, we can modify a single
transaction or swap two trivially independent transactions to generate a unique
parent.

N Aαs, we generate

This algorithm uses Θ(N ) work. This is optimal (for this component of the

algorithm), because we need to produce N hashes.

9

5.3.1 Complexity Proof

For the interested:

At each step we must do n work to create the outputs, and we recurse on 2

times the square root of the output size. Therefore, our recurrence is:

Let

Substitute n with 2p

T (n) = 2 · T (

√

n) + n

n = 2p

T (2p) = 2 · T (

√

p
2

) + 2p

T (2p) = 2 · T (2p/2) + 2p

S(p) = T (2p)

S(p) = 2 · S(p/2) + 2p

This is Case 3 of Master Theorem:

S(p) = Θ(2p)

S(p) = T (2p)

T (2p) = Θ(2p)

p = log n

T (n) = Θ(n)

This algorithm is also “Embarrassingly Parallel”, so can get eﬃciency gains

using multiple cores.

5.4 N -Way Hit

Our earlier approximation predicts that in order to be likely to produce a 4-way
collision we need to generate around 225 hashes, and store them for collision
detection. This is about a gigabytes worth, so most computers should be able
to generate this quickly.

0.49 ≈ 1 − e−(225

4 )(232)−3

A 5-way and greater, the amount of time required to generate a collision will
increase markedly, but I would imagine that miners with ASICBOOST would
not want to use that, and prefer to generate many 4-way collisions with rolled
coinbase extra-nonces.

10

6 What does Segregated Witness (SegWit) have

to do with it?

In SegWit we generate an additional commitment of all the signatures and we
put it into the coinbase transaction.

This commits to which transactions are present in the block and in what
order they appear, which means no more easy generation of unique Merkle
roots; the commitment is in the leftmost transaction, so modifying the order or
contents of any transaction triggers a full a factor of log m rehash.

The ﬁgures below demonstrates this. A commits to BCDEF GH. Any
change in the order or contents of the tree triggers the update to A’s nested
commitment, which also triggers an update to ABCDEF GH. Note the direc-
tion of the arrows for the witness commitment3.

ABCD
EFGH

AB
CD

EF
GH

AB

CD

EF

GH

A

B

C

D

E

F

G

H

CD

BCD

GH

EF

EF
GH

Witness
Commit

3Technically, A is put into the witness tree with a zero value so the structure of the tree
is identical. Representing this would make this diagram less clear, because no data from A is
committed to.

11

7 Are SegWit and ASICBOOST are fundamen-

tally incompatible?

No.

Recall our header format. . .

0

4

36

68

72

76

80

V
E
R
S
I
O
N

PREVIOUS BLOCK

MERKLE ROOT

T
I
M
E

N
B
I
T
S

N
O
N
C
E

The version ﬁeld can be used to make “collisions” trivialy!
Simply set it to a diﬀerent value.

7.1 Why go through the trouble of ﬁnding non-trivial col-

lisions?

• Changing versions is easy to detect.

• Version is already used for. . . versions.

12

8 How can we ﬁx this?

There are a few options:

1. Don’t do anything

• Pro: Any changes to Bitcoin are dangerous.

• Con: Status Quo is obviously harming Bitcoin.

2. Change SegWit to be compatible with ASICBOOST

• Pro: If we could start over, it would be easy to do.

• Con: Segwit is already written, reviewed, and adopted in industry.

3. Block just undetectable ASICBOOST

• Pro: Solves the immediate problem.

• Con: We wouldn’t be blocking it because undetectable optimization
is wrong, but because this speciﬁc optimization intereferes with pro-
tocol development. The propensity to conﬂate the two is dangerous.

4. Block all ASICBOOST

• Pro: ASICBOOST is not available to all miners, this levels the ﬁeld.

• Con: A dangerous precedent to set. Picking winners and losers.

5. Hard fork Bitcoin to a new header format

• Pro: Could leave ASICBOOST intact, put SegWit commitment in
header, and everything else on the Bitcoin Hard-Fork Wish List.

• Con: Dangerous precedent, risk to split network.

13

