=== Content from git.kernel.org_97210dc1_20250111_175014.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=1b6de5e6575b56502665c65cf93b0ae6aa0f51ab)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=1b6de5e6575b56502665c65cf93b0ae6aa0f51ab)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=1b6de5e6575b56502665c65cf93b0ae6aa0f51ab)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=1b6de5e6575b56502665c65cf93b0ae6aa0f51ab)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Florian Westphal <fw@strlen.de> | 2024-03-26 11:18:41 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-11-08 16:20:26 +0100 |
| commit | [1b6de5e6575b56502665c65cf93b0ae6aa0f51ab](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=1b6de5e6575b56502665c65cf93b0ae6aa0f51ab) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=1b6de5e6575b56502665c65cf93b0ae6aa0f51ab)) | |
| tree | [1a6ac480dfb11dfa5f529f3033330ec83e55a88f](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=1b6de5e6575b56502665c65cf93b0ae6aa0f51ab) | |
| parent | [9ae2d8e75b741dbcb0da374753f972410e83b5f3](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9ae2d8e75b741dbcb0da374753f972410e83b5f3) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=1b6de5e6575b56502665c65cf93b0ae6aa0f51ab&id2=9ae2d8e75b741dbcb0da374753f972410e83b5f3)) | |
| download | [linux-1b6de5e6575b56502665c65cf93b0ae6aa0f51ab.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-1b6de5e6575b56502665c65cf93b0ae6aa0f51ab.tar.gz) | |

inet: inet\_defrag: prevent sk release while still in usecommit 18685451fc4e546fc0e718580d32df3c0e5c8272 upstream.
ip\_local\_out() and other functions can pass skb->sk as function argument.
If the skb is a fragment and reassembly happens before such function call
returns, the sk must not be released.
This affects skb fragments reassembled via netfilter or similar
modules, e.g. openvswitch or ct\_act.c, when run as part of tx pipeline.
Eric Dumazet made an initial analysis of this bug. Quoting Eric:
Calling ip\_defrag() in output path is also implying skb\_orphan(),
which is buggy because output path relies on sk not disappearing.
A relevant old patch about the issue was :
8282f27449bf ("inet: frag: Always orphan skbs inside ip\_defrag()")
[..]
net/ipv4/ip\_output.c depends on skb->sk being set, and probably to an
inet socket, not an arbitrary one.
If we orphan the packet in ipvlan, then downstream things like FQ
packet scheduler will not work properly.
We need to change ip\_defrag() to only use skb\_orphan() when really
needed, ie whenever frag\_list is going to be used.
Eric suggested to stash sk in fragment queue and made an initial patch.
However there is a problem with this:
If skb is refragmented again right after, ip\_do\_fragment() will copy
head->sk to the new fragments, and sets up destructor to sock\_wfree.
IOW, we have no choice but to fix up sk\_wmem accouting to reflect the
fully reassembled skb, else wmem will underflow.
This change moves the orphan down into the core, to last possible moment.
As ip\_defrag\_offset is aliased with sk\_buff->sk member, we must move the
offset into the FRAG\_CB, else skb->sk gets clobbered.
This allows to delay the orphaning long enough to learn if the skb has
to be queued or if the skb is completing the reasm queue.
In the former case, things work as before, skb is orphaned. This is
safe because skb gets queued/stolen and won't continue past reasm engine.
In the latter case, we will steal the skb->sk reference, reattach it to
the head skb, and fix up wmem accouting when inet\_frag inflates truesize.
Fixes: 7026b1ddb6b8 ("netfilter: Pass socket pointer down through okfn().")
Diagnosed-by: Eric Dumazet <edumazet@google.com>
Reported-by: xingwei lee <xrivendell7@gmail.com>
Reported-by: yue sun <samsun1006219@gmail.com>
Reported-by: syzbot+e5167d7144a62715044c@syzkaller.appspotmail.com
Signed-off-by: Florian Westphal <fw@strlen.de>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Link: [https://lore.kernel.org/r/20240326101845.30836-1-fw@strlen.de](https://lore.kernel.org/r/20240326101845.30836-1-fw%40strlen.de)
Signed-off-by: Paolo Abeni <pabeni@redhat.com>
Signed-off-by: Saeed Mirzamohammadi <saeed.mirzamohammadi@oracle.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=1b6de5e6575b56502665c65cf93b0ae6aa0f51ab)

| -rw-r--r-- | [include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/skbuff.h?id=1b6de5e6575b56502665c65cf93b0ae6aa0f51ab) | 5 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/core/sock\_destructor.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/core/sock_destructor.h?id=1b6de5e6575b56502665c65cf93b0ae6aa0f51ab) | 12 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/ipv4/inet\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv4/inet_fragment.c?id=1b6de5e6575b56502665c65cf93b0ae6aa0f51ab) | 70 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/ipv4/ip\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv4/ip_fragment.c?id=1b6de5e6575b56502665c65cf93b0ae6aa0f51ab) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/ipv6/netfilter/nf\_conntrack\_reasm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv6/netfilter/nf_conntrack_reasm.c?id=1b6de5e6575b56502665c65cf93b0ae6aa0f51ab) | 2 | |  |  |  | | --- | --- | --- | |

5 files changed, 72 insertions, 19 deletions

| diff --git a/include/linux/skbuff.h b/include/linux/skbuff.hindex 29ccc33a1c6270..3191d0ffc6e9a3 100644--- a/[include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/skbuff.h?id=9ae2d8e75b741dbcb0da374753f972410e83b5f3)+++ b/[include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/skbuff.h?id=1b6de5e6575b56502665c65cf93b0ae6aa0f51ab)@@ -704,10 +704,7 @@ struct sk\_buff { struct list\_head list; }; - union {- struct sock \*sk;- int ip\_defrag\_offset;- };+ struct sock \*sk;  union { ktime\_t tstamp;diff --git a/net/core/sock\_destructor.h b/net/core/sock\_destructor.hnew file mode 100644index 00000000000000..2f396e6bfba5a3--- /dev/null+++ b/[net/core/sock\_destructor.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/sock_destructor.h?id=1b6de5e6575b56502665c65cf93b0ae6aa0f51ab)@@ -0,0 +1,12 @@+/\* SPDX-License-Identifier: GPL-2.0-or-later \*/+#ifndef \_NET\_CORE\_SOCK\_DESTRUCTOR\_H+#define \_NET\_CORE\_SOCK\_DESTRUCTOR\_H+#include <net/tcp.h>++static inline bool is\_skb\_wmem(const struct sk\_buff \*skb)+{+ return skb->destructor == sock\_wfree ||+ skb->destructor == \_\_sock\_wfree ||+ (IS\_ENABLED(CONFIG\_INET) && skb->destructor == tcp\_wfree);+}+#endifdiff --git a/net/ipv4/inet\_fragment.c b/net/ipv4/inet\_fragment.cindex e0e8a65d561ec6..12ef3cb26676d2 100644--- a/[net/ipv4/inet\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/inet_fragment.c?id=9ae2d8e75b741dbcb0da374753f972410e83b5f3)+++ b/[net/ipv4/inet\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/inet_fragment.c?id=1b6de5e6575b56502665c65cf93b0ae6aa0f51ab)@@ -24,6 +24,8 @@ #include <net/ip.h> #include <net/ipv6.h> +#include "../core/sock\_destructor.h"+ /\* Use skb->cb to track consecutive/adjacent fragments coming at \* the end of the queue. Nodes in the rb-tree queue will \* contain "runs" of one or more adjacent fragments.@@ -39,6 +41,7 @@ struct ipfrag\_skb\_cb { }; struct sk\_buff \*next\_frag; int frag\_run\_len;+ int ip\_defrag\_offset; };  #define FRAG\_CB(skb) ((struct ipfrag\_skb\_cb \*)((skb)->cb))@@ -359,12 +362,12 @@ int inet\_frag\_queue\_insert(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, \*/ if (!last) fragrun\_create(q, skb); /\* First fragment. \*/- else if (last->ip\_defrag\_offset + last->len < end) {+ else if (FRAG\_CB(last)->ip\_defrag\_offset + last->len < end) { /\* This is the common case: skb goes to the end. \*/ /\* Detect and discard overlaps. \*/- if (offset < last->ip\_defrag\_offset + last->len)+ if (offset < FRAG\_CB(last)->ip\_defrag\_offset + last->len) return IPFRAG\_OVERLAP;- if (offset == last->ip\_defrag\_offset + last->len)+ if (offset == FRAG\_CB(last)->ip\_defrag\_offset + last->len) fragrun\_append\_to\_last(q, skb); else fragrun\_create(q, skb);@@ -381,13 +384,13 @@ int inet\_frag\_queue\_insert(struct inet\_frag\_queue \*q, struct sk\_buff \*skb,  parent = \*rbn; curr = rb\_to\_skb(parent);- curr\_run\_end = curr->ip\_defrag\_offset ++ curr\_run\_end = FRAG\_CB(curr)->ip\_defrag\_offset + FRAG\_CB(curr)->frag\_run\_len;- if (end <= curr->ip\_defrag\_offset)+ if (end <= FRAG\_CB(curr)->ip\_defrag\_offset) rbn = &parent->rb\_left; else if (offset >= curr\_run\_end) rbn = &parent->rb\_right;- else if (offset >= curr->ip\_defrag\_offset &&+ else if (offset >= FRAG\_CB(curr)->ip\_defrag\_offset && end <= curr\_run\_end) return IPFRAG\_DUP; else@@ -401,7 +404,7 @@ int inet\_frag\_queue\_insert(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, rb\_insert\_color(&skb->rbnode, &q->rb\_fragments); } - skb->ip\_defrag\_offset = offset;+ FRAG\_CB(skb)->ip\_defrag\_offset = offset;  return IPFRAG\_OK; }@@ -411,13 +414,28 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, struct sk\_buff \*parent) { struct sk\_buff \*fp, \*head = skb\_rb\_first(&q->rb\_fragments);- struct sk\_buff \*\*nextp;+ void (\*destructor)(struct sk\_buff \*);+ unsigned int orig\_truesize = 0;+ struct sk\_buff \*\*nextp = NULL;+ struct sock \*sk = skb->sk; int delta; + if (sk && is\_skb\_wmem(skb)) {+ /\* TX: skb->sk might have been passed as argument to+ \* dst->output and must remain valid until tx completes.+ \*+ \* Move sk to reassembled skb and fix up wmem accounting.+ \*/+ orig\_truesize = skb->truesize;+ destructor = skb->destructor;+ }+ if (head != skb) { fp = skb\_clone(skb, GFP\_ATOMIC);- if (!fp)- return NULL;+ if (!fp) {+ head = skb;+ goto out\_restore\_sk;+ } FRAG\_CB(fp)->next\_frag = FRAG\_CB(skb)->next\_frag; if (RB\_EMPTY\_NODE(&skb->rbnode)) FRAG\_CB(parent)->next\_frag = fp;@@ -426,6 +444,12 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, &q->rb\_fragments); if (q->fragments\_tail == skb) q->fragments\_tail = fp;++ if (orig\_truesize) {+ /\* prevent skb\_morph from releasing sk \*/+ skb->sk = NULL;+ skb->destructor = NULL;+ } skb\_morph(skb, head); FRAG\_CB(skb)->next\_frag = FRAG\_CB(head)->next\_frag; rb\_replace\_node(&head->rbnode, &skb->rbnode,@@ -433,13 +457,13 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, consume\_skb(head); head = skb; }- WARN\_ON(head->ip\_defrag\_offset != 0);+ WARN\_ON(FRAG\_CB(head)->ip\_defrag\_offset != 0);  delta = -head->truesize;  /\* Head of list must not be cloned. \*/ if (skb\_unclone(head, GFP\_ATOMIC))- return NULL;+ goto out\_restore\_sk;  delta += head->truesize; if (delta)@@ -455,7 +479,7 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb,  clone = alloc\_skb(0, GFP\_ATOMIC); if (!clone)- return NULL;+ goto out\_restore\_sk; skb\_shinfo(clone)->frag\_list = skb\_shinfo(head)->frag\_list; skb\_frag\_list\_init(head); for (i = 0; i < skb\_shinfo(head)->nr\_frags; i++)@@ -472,6 +496,21 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, nextp = &skb\_shinfo(head)->frag\_list; } +out\_restore\_sk:+ if (orig\_truesize) {+ int ts\_delta = head->truesize - orig\_truesize;++ /\* if this reassembled skb is fragmented later,+ \* fraglist skbs will get skb->sk assigned from head->sk,+ \* and each frag skb will be released via sock\_wfree.+ \*+ \* Update sk\_wmem\_alloc.+ \*/+ head->sk = sk;+ head->destructor = destructor;+ refcount\_add(ts\_delta, &sk->sk\_wmem\_alloc);+ }+ return nextp; } EXPORT\_SYMBOL(inet\_frag\_reasm\_prepare);@@ -479,6 +518,8 @@ EXPORT\_SYMBOL(inet\_frag\_reasm\_prepare); void inet\_frag\_reasm\_finish(struct inet\_frag\_queue \*q, struct sk\_buff \*head, void \*reasm\_data, bool try\_coalesce) {+ struct sock \*sk = is\_skb\_wmem(head) ? head->sk : NULL;+ const unsigned int head\_truesize = head->truesize; struct sk\_buff \*\*nextp = (struct sk\_buff \*\*)reasm\_data; struct rb\_node \*rbn; struct sk\_buff \*fp;@@ -541,6 +582,9 @@ void inet\_frag\_reasm\_finish(struct inet\_frag\_queue \*q, struct sk\_buff \*head, skb\_mark\_not\_on\_list(head); head->prev = NULL; head->tstamp = q->stamp;++ if (sk)+ refcount\_add(sum\_truesize - head\_truesize, &sk->sk\_wmem\_alloc); } EXPORT\_SYMBOL(inet\_frag\_reasm\_finish); diff --git a/net/ipv4/ip\_fragment.c b/net/ipv4/ip\_fragment.cindex fad803d2d711ef..ec2264adf2a6a5 100644--- a/[net/ipv4/ip\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/ip_fragment.c?id=9ae2d8e75b741dbcb0da374753f972410e83b5f3)+++ b/[net/ipv4/ip\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/ip_fragment.c?id=1b6de5e6575b56502665c65cf93b0ae6aa0f51ab)@@ -377,6 +377,7 @@ static int ip\_frag\_queue(struct ipq \*qp, struct sk\_buff \*skb) }  skb\_dst\_drop(skb);+ skb\_orphan(skb); return -EINPROGRESS;  insert\_error:@@ -479,7 +480,6 @@ int ip\_defrag(struct net \*net, struct sk\_buff \*skb, u32 user) struct ipq \*qp;  \_\_IP\_INC\_STATS(net, IPSTATS\_MIB\_REASMREQDS);- skb\_orphan(skb);  /\* Lookup (or create) queue header \*/ qp = ip\_find(net, ip\_hdr(skb), user, vif);diff --git a/net/ipv6/netfilter/nf\_conntrack\_reasm.c b/net/ipv6/netfilter/nf\_conntrack\_reasm.cindex fed9666a2f7da1..cab68c63ea65e7 100644--- a/[net/ipv6/netfilter/nf\_conntrack\_reasm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/netfilter/nf_conntrack_reasm.c?id=9ae2d8e75b741dbcb0da374753f972410e83b5f3)+++ b/[net/ipv6/netfilter/nf\_conntrack\_reasm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/netfilter/nf_conntrack_reasm.c?id=1b6de5e6575b56502665c65cf93b0ae6aa0f51ab)@@ -296,6 +296,7 @@ static int nf\_ct\_frag6\_queue(struct frag\_queue \*fq, struct sk\_buff \*skb, }  skb\_dst\_drop(skb);+ skb\_orphan(skb); return -EINPROGRESS;  insert\_error:@@ -461,7 +462,6 @@ int nf\_ct\_frag6\_gather(struct net \*net, struct sk\_buff \*skb, u32 user) hdr = ipv6\_hdr(skb); fhdr = (struct frag\_hdr \*)skb\_transport\_header(skb); - skb\_orphan(skb); fq = fq\_find(net, fhdr->identification, user, hdr, skb->dev ? skb->dev->ifindex : 0); if (fq == NULL) { |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 17:48:51 +0000



=== Content from git.kernel.org_5766027b_20250111_175016.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=f4877225313d474659ee53150ccc3d553a978727)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f4877225313d474659ee53150ccc3d553a978727)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f4877225313d474659ee53150ccc3d553a978727)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f4877225313d474659ee53150ccc3d553a978727)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Florian Westphal <fw@strlen.de> | 2024-03-26 11:18:41 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-04-10 16:35:44 +0200 |
| commit | [f4877225313d474659ee53150ccc3d553a978727](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f4877225313d474659ee53150ccc3d553a978727) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=f4877225313d474659ee53150ccc3d553a978727)) | |
| tree | [66bcbde576604635d1de12f2eb4ce8ef600c9ef3](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f4877225313d474659ee53150ccc3d553a978727) | |
| parent | [54720f68c4ad0ffb5a776e7a14b25f02242068cb](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=54720f68c4ad0ffb5a776e7a14b25f02242068cb) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f4877225313d474659ee53150ccc3d553a978727&id2=54720f68c4ad0ffb5a776e7a14b25f02242068cb)) | |
| download | [linux-f4877225313d474659ee53150ccc3d553a978727.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-f4877225313d474659ee53150ccc3d553a978727.tar.gz) | |

inet: inet\_defrag: prevent sk release while still in use[ Upstream commit 18685451fc4e546fc0e718580d32df3c0e5c8272 ]
ip\_local\_out() and other functions can pass skb->sk as function argument.
If the skb is a fragment and reassembly happens before such function call
returns, the sk must not be released.
This affects skb fragments reassembled via netfilter or similar
modules, e.g. openvswitch or ct\_act.c, when run as part of tx pipeline.
Eric Dumazet made an initial analysis of this bug. Quoting Eric:
Calling ip\_defrag() in output path is also implying skb\_orphan(),
which is buggy because output path relies on sk not disappearing.
A relevant old patch about the issue was :
8282f27449bf ("inet: frag: Always orphan skbs inside ip\_defrag()")
[..]
net/ipv4/ip\_output.c depends on skb->sk being set, and probably to an
inet socket, not an arbitrary one.
If we orphan the packet in ipvlan, then downstream things like FQ
packet scheduler will not work properly.
We need to change ip\_defrag() to only use skb\_orphan() when really
needed, ie whenever frag\_list is going to be used.
Eric suggested to stash sk in fragment queue and made an initial patch.
However there is a problem with this:
If skb is refragmented again right after, ip\_do\_fragment() will copy
head->sk to the new fragments, and sets up destructor to sock\_wfree.
IOW, we have no choice but to fix up sk\_wmem accouting to reflect the
fully reassembled skb, else wmem will underflow.
This change moves the orphan down into the core, to last possible moment.
As ip\_defrag\_offset is aliased with sk\_buff->sk member, we must move the
offset into the FRAG\_CB, else skb->sk gets clobbered.
This allows to delay the orphaning long enough to learn if the skb has
to be queued or if the skb is completing the reasm queue.
In the former case, things work as before, skb is orphaned. This is
safe because skb gets queued/stolen and won't continue past reasm engine.
In the latter case, we will steal the skb->sk reference, reattach it to
the head skb, and fix up wmem accouting when inet\_frag inflates truesize.
Fixes: 7026b1ddb6b8 ("netfilter: Pass socket pointer down through okfn().")
Diagnosed-by: Eric Dumazet <edumazet@google.com>
Reported-by: xingwei lee <xrivendell7@gmail.com>
Reported-by: yue sun <samsun1006219@gmail.com>
Reported-by: syzbot+e5167d7144a62715044c@syzkaller.appspotmail.com
Signed-off-by: Florian Westphal <fw@strlen.de>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Link: [https://lore.kernel.org/r/20240326101845.30836-1-fw@strlen.de](https://lore.kernel.org/r/20240326101845.30836-1-fw%40strlen.de)
Signed-off-by: Paolo Abeni <pabeni@redhat.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f4877225313d474659ee53150ccc3d553a978727)

| -rw-r--r-- | [include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/skbuff.h?id=f4877225313d474659ee53150ccc3d553a978727) | 7 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/ipv4/inet\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv4/inet_fragment.c?id=f4877225313d474659ee53150ccc3d553a978727) | 70 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/ipv4/ip\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv4/ip_fragment.c?id=f4877225313d474659ee53150ccc3d553a978727) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/ipv6/netfilter/nf\_conntrack\_reasm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv6/netfilter/nf_conntrack_reasm.c?id=f4877225313d474659ee53150ccc3d553a978727) | 2 | |  |  |  | | --- | --- | --- | |

4 files changed, 60 insertions, 21 deletions

| diff --git a/include/linux/skbuff.h b/include/linux/skbuff.hindex 2922059908cc57..9e61f6df6bc55f 100644--- a/[include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/skbuff.h?id=54720f68c4ad0ffb5a776e7a14b25f02242068cb)+++ b/[include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/skbuff.h?id=f4877225313d474659ee53150ccc3d553a978727)@@ -736,8 +736,6 @@ typedef unsigned char \*sk\_buff\_data\_t; \* @list: queue head \* @ll\_node: anchor in an llist (eg socket defer\_list) \* @sk: Socket we are owned by- \* @ip\_defrag\_offset: (aka @sk) alternate use of @sk, used in- \* fragmentation management \* @dev: Device we arrived on/are leaving by \* @dev\_scratch: (aka @dev) alternate use of @dev when @dev would be %NULL \* @cb: Control buffer. Free for use by every layer. Put private vars here@@ -860,10 +858,7 @@ struct sk\_buff { struct llist\_node ll\_node; }; - union {- struct sock \*sk;- int ip\_defrag\_offset;- };+ struct sock \*sk;  union { ktime\_t tstamp;diff --git a/net/ipv4/inet\_fragment.c b/net/ipv4/inet\_fragment.cindex 7072fc0783ef56..c88c9034d63004 100644--- a/[net/ipv4/inet\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/inet_fragment.c?id=54720f68c4ad0ffb5a776e7a14b25f02242068cb)+++ b/[net/ipv4/inet\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/inet_fragment.c?id=f4877225313d474659ee53150ccc3d553a978727)@@ -24,6 +24,8 @@ #include <net/ip.h> #include <net/ipv6.h> +#include "../core/sock\_destructor.h"+ /\* Use skb->cb to track consecutive/adjacent fragments coming at \* the end of the queue. Nodes in the rb-tree queue will \* contain "runs" of one or more adjacent fragments.@@ -39,6 +41,7 @@ struct ipfrag\_skb\_cb { }; struct sk\_buff \*next\_frag; int frag\_run\_len;+ int ip\_defrag\_offset; };  #define FRAG\_CB(skb) ((struct ipfrag\_skb\_cb \*)((skb)->cb))@@ -396,12 +399,12 @@ int inet\_frag\_queue\_insert(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, \*/ if (!last) fragrun\_create(q, skb); /\* First fragment. \*/- else if (last->ip\_defrag\_offset + last->len < end) {+ else if (FRAG\_CB(last)->ip\_defrag\_offset + last->len < end) { /\* This is the common case: skb goes to the end. \*/ /\* Detect and discard overlaps. \*/- if (offset < last->ip\_defrag\_offset + last->len)+ if (offset < FRAG\_CB(last)->ip\_defrag\_offset + last->len) return IPFRAG\_OVERLAP;- if (offset == last->ip\_defrag\_offset + last->len)+ if (offset == FRAG\_CB(last)->ip\_defrag\_offset + last->len) fragrun\_append\_to\_last(q, skb); else fragrun\_create(q, skb);@@ -418,13 +421,13 @@ int inet\_frag\_queue\_insert(struct inet\_frag\_queue \*q, struct sk\_buff \*skb,  parent = \*rbn; curr = rb\_to\_skb(parent);- curr\_run\_end = curr->ip\_defrag\_offset ++ curr\_run\_end = FRAG\_CB(curr)->ip\_defrag\_offset + FRAG\_CB(curr)->frag\_run\_len;- if (end <= curr->ip\_defrag\_offset)+ if (end <= FRAG\_CB(curr)->ip\_defrag\_offset) rbn = &parent->rb\_left; else if (offset >= curr\_run\_end) rbn = &parent->rb\_right;- else if (offset >= curr->ip\_defrag\_offset &&+ else if (offset >= FRAG\_CB(curr)->ip\_defrag\_offset && end <= curr\_run\_end) return IPFRAG\_DUP; else@@ -438,7 +441,7 @@ int inet\_frag\_queue\_insert(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, rb\_insert\_color(&skb->rbnode, &q->rb\_fragments); } - skb->ip\_defrag\_offset = offset;+ FRAG\_CB(skb)->ip\_defrag\_offset = offset;  return IPFRAG\_OK; }@@ -448,13 +451,28 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, struct sk\_buff \*parent) { struct sk\_buff \*fp, \*head = skb\_rb\_first(&q->rb\_fragments);- struct sk\_buff \*\*nextp;+ void (\*destructor)(struct sk\_buff \*);+ unsigned int orig\_truesize = 0;+ struct sk\_buff \*\*nextp = NULL;+ struct sock \*sk = skb->sk; int delta; + if (sk && is\_skb\_wmem(skb)) {+ /\* TX: skb->sk might have been passed as argument to+ \* dst->output and must remain valid until tx completes.+ \*+ \* Move sk to reassembled skb and fix up wmem accounting.+ \*/+ orig\_truesize = skb->truesize;+ destructor = skb->destructor;+ }+ if (head != skb) { fp = skb\_clone(skb, GFP\_ATOMIC);- if (!fp)- return NULL;+ if (!fp) {+ head = skb;+ goto out\_restore\_sk;+ } FRAG\_CB(fp)->next\_frag = FRAG\_CB(skb)->next\_frag; if (RB\_EMPTY\_NODE(&skb->rbnode)) FRAG\_CB(parent)->next\_frag = fp;@@ -463,6 +481,12 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, &q->rb\_fragments); if (q->fragments\_tail == skb) q->fragments\_tail = fp;++ if (orig\_truesize) {+ /\* prevent skb\_morph from releasing sk \*/+ skb->sk = NULL;+ skb->destructor = NULL;+ } skb\_morph(skb, head); FRAG\_CB(skb)->next\_frag = FRAG\_CB(head)->next\_frag; rb\_replace\_node(&head->rbnode, &skb->rbnode,@@ -470,13 +494,13 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, consume\_skb(head); head = skb; }- WARN\_ON(head->ip\_defrag\_offset != 0);+ WARN\_ON(FRAG\_CB(head)->ip\_defrag\_offset != 0);  delta = -head->truesize;  /\* Head of list must not be cloned. \*/ if (skb\_unclone(head, GFP\_ATOMIC))- return NULL;+ goto out\_restore\_sk;  delta += head->truesize; if (delta)@@ -492,7 +516,7 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb,  clone = alloc\_skb(0, GFP\_ATOMIC); if (!clone)- return NULL;+ goto out\_restore\_sk; skb\_shinfo(clone)->frag\_list = skb\_shinfo(head)->frag\_list; skb\_frag\_list\_init(head); for (i = 0; i < skb\_shinfo(head)->nr\_frags; i++)@@ -509,6 +533,21 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, nextp = &skb\_shinfo(head)->frag\_list; } +out\_restore\_sk:+ if (orig\_truesize) {+ int ts\_delta = head->truesize - orig\_truesize;++ /\* if this reassembled skb is fragmented later,+ \* fraglist skbs will get skb->sk assigned from head->sk,+ \* and each frag skb will be released via sock\_wfree.+ \*+ \* Update sk\_wmem\_alloc.+ \*/+ head->sk = sk;+ head->destructor = destructor;+ refcount\_add(ts\_delta, &sk->sk\_wmem\_alloc);+ }+ return nextp; } EXPORT\_SYMBOL(inet\_frag\_reasm\_prepare);@@ -516,6 +555,8 @@ EXPORT\_SYMBOL(inet\_frag\_reasm\_prepare); void inet\_frag\_reasm\_finish(struct inet\_frag\_queue \*q, struct sk\_buff \*head, void \*reasm\_data, bool try\_coalesce) {+ struct sock \*sk = is\_skb\_wmem(head) ? head->sk : NULL;+ const unsigned int head\_truesize = head->truesize; struct sk\_buff \*\*nextp = reasm\_data; struct rb\_node \*rbn; struct sk\_buff \*fp;@@ -579,6 +620,9 @@ void inet\_frag\_reasm\_finish(struct inet\_frag\_queue \*q, struct sk\_buff \*head, head->prev = NULL; head->tstamp = q->stamp; head->mono\_delivery\_time = q->mono\_delivery\_time;++ if (sk)+ refcount\_add(sum\_truesize - head\_truesize, &sk->sk\_wmem\_alloc); } EXPORT\_SYMBOL(inet\_frag\_reasm\_finish); diff --git a/net/ipv4/ip\_fragment.c b/net/ipv4/ip\_fragment.cindex a4941f53b52372..fb947d1613fe2b 100644--- a/[net/ipv4/ip\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/ip_fragment.c?id=54720f68c4ad0ffb5a776e7a14b25f02242068cb)+++ b/[net/ipv4/ip\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/ip_fragment.c?id=f4877225313d474659ee53150ccc3d553a978727)@@ -384,6 +384,7 @@ static int ip\_frag\_queue(struct ipq \*qp, struct sk\_buff \*skb) }  skb\_dst\_drop(skb);+ skb\_orphan(skb); return -EINPROGRESS;  insert\_error:@@ -487,7 +488,6 @@ int ip\_defrag(struct net \*net, struct sk\_buff \*skb, u32 user) struct ipq \*qp;  \_\_IP\_INC\_STATS(net, IPSTATS\_MIB\_REASMREQDS);- skb\_orphan(skb);  /\* Lookup (or create) queue header \*/ qp = ip\_find(net, ip\_hdr(skb), user, vif);diff --git a/net/ipv6/netfilter/nf\_conntrack\_reasm.c b/net/ipv6/netfilter/nf\_conntrack\_reasm.cindex b2dd48911c8d62..efbec7ee27d0a0 100644--- a/[net/ipv6/netfilter/nf\_conntrack\_reasm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/netfilter/nf_conntrack_reasm.c?id=54720f68c4ad0ffb5a776e7a14b25f02242068cb)+++ b/[net/ipv6/netfilter/nf\_conntrack\_reasm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/netfilter/nf_conntrack_reasm.c?id=f4877225313d474659ee53150ccc3d553a978727)@@ -294,6 +294,7 @@ static int nf\_ct\_frag6\_queue(struct frag\_queue \*fq, struct sk\_buff \*skb, }  skb\_dst\_drop(skb);+ skb\_orphan(skb); return -EINPROGRESS;  insert\_error:@@ -469,7 +470,6 @@ int nf\_ct\_frag6\_gather(struct net \*net, struct sk\_buff \*skb, u32 user) hdr = ipv6\_hdr(skb); fhdr = (struct frag\_hdr \*)skb\_transport\_header(skb); - skb\_orphan(skb); fq = fq\_find(net, fhdr->identification, user, hdr, skb->dev ? skb->dev->ifindex : 0); if (fq == NULL) { |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 17:48:54 +0000



=== Content from git.kernel.org_344b298d_20250111_175014.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=4318608dc28ef184158b4045896740716bea23f0)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=4318608dc28ef184158b4045896740716bea23f0)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=4318608dc28ef184158b4045896740716bea23f0)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=4318608dc28ef184158b4045896740716bea23f0)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Florian Westphal <fw@strlen.de> | 2024-03-26 11:18:41 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-10-17 15:10:41 +0200 |
| commit | [4318608dc28ef184158b4045896740716bea23f0](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=4318608dc28ef184158b4045896740716bea23f0) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=4318608dc28ef184158b4045896740716bea23f0)) | |
| tree | [ca76da76128b7aca1ff59dad61e5e33153274669](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=4318608dc28ef184158b4045896740716bea23f0) | |
| parent | [c65ab97efcd438cb4e9f299400f2ea55251f3a67](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=c65ab97efcd438cb4e9f299400f2ea55251f3a67) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=4318608dc28ef184158b4045896740716bea23f0&id2=c65ab97efcd438cb4e9f299400f2ea55251f3a67)) | |
| download | [linux-4318608dc28ef184158b4045896740716bea23f0.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-4318608dc28ef184158b4045896740716bea23f0.tar.gz) | |

inet: inet\_defrag: prevent sk release while still in usecommit 18685451fc4e546fc0e718580d32df3c0e5c8272 upstream.
ip\_local\_out() and other functions can pass skb->sk as function argument.
If the skb is a fragment and reassembly happens before such function call
returns, the sk must not be released.
This affects skb fragments reassembled via netfilter or similar
modules, e.g. openvswitch or ct\_act.c, when run as part of tx pipeline.
Eric Dumazet made an initial analysis of this bug. Quoting Eric:
Calling ip\_defrag() in output path is also implying skb\_orphan(),
which is buggy because output path relies on sk not disappearing.
A relevant old patch about the issue was :
8282f27449bf ("inet: frag: Always orphan skbs inside ip\_defrag()")
[..]
net/ipv4/ip\_output.c depends on skb->sk being set, and probably to an
inet socket, not an arbitrary one.
If we orphan the packet in ipvlan, then downstream things like FQ
packet scheduler will not work properly.
We need to change ip\_defrag() to only use skb\_orphan() when really
needed, ie whenever frag\_list is going to be used.
Eric suggested to stash sk in fragment queue and made an initial patch.
However there is a problem with this:
If skb is refragmented again right after, ip\_do\_fragment() will copy
head->sk to the new fragments, and sets up destructor to sock\_wfree.
IOW, we have no choice but to fix up sk\_wmem accouting to reflect the
fully reassembled skb, else wmem will underflow.
This change moves the orphan down into the core, to last possible moment.
As ip\_defrag\_offset is aliased with sk\_buff->sk member, we must move the
offset into the FRAG\_CB, else skb->sk gets clobbered.
This allows to delay the orphaning long enough to learn if the skb has
to be queued or if the skb is completing the reasm queue.
In the former case, things work as before, skb is orphaned. This is
safe because skb gets queued/stolen and won't continue past reasm engine.
In the latter case, we will steal the skb->sk reference, reattach it to
the head skb, and fix up wmem accouting when inet\_frag inflates truesize.
Fixes: 7026b1ddb6b8 ("netfilter: Pass socket pointer down through okfn().")
Diagnosed-by: Eric Dumazet <edumazet@google.com>
Reported-by: xingwei lee <xrivendell7@gmail.com>
Reported-by: yue sun <samsun1006219@gmail.com>
Reported-by: syzbot+e5167d7144a62715044c@syzkaller.appspotmail.com
Signed-off-by: Florian Westphal <fw@strlen.de>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Link: [https://lore.kernel.org/r/20240326101845.30836-1-fw@strlen.de](https://lore.kernel.org/r/20240326101845.30836-1-fw%40strlen.de)
Signed-off-by: Paolo Abeni <pabeni@redhat.com>
Signed-off-by: Saeed Mirzamohammadi <saeed.mirzamohammadi@oracle.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=4318608dc28ef184158b4045896740716bea23f0)

| -rw-r--r-- | [include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/skbuff.h?id=4318608dc28ef184158b4045896740716bea23f0) | 7 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/ipv4/inet\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv4/inet_fragment.c?id=4318608dc28ef184158b4045896740716bea23f0) | 70 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/ipv4/ip\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv4/ip_fragment.c?id=4318608dc28ef184158b4045896740716bea23f0) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/ipv6/netfilter/nf\_conntrack\_reasm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv6/netfilter/nf_conntrack_reasm.c?id=4318608dc28ef184158b4045896740716bea23f0) | 2 | |  |  |  | | --- | --- | --- | |

4 files changed, 60 insertions, 21 deletions

| diff --git a/include/linux/skbuff.h b/include/linux/skbuff.hindex b230c422dc3b92..7f52562fac19ce 100644--- a/[include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/skbuff.h?id=c65ab97efcd438cb4e9f299400f2ea55251f3a67)+++ b/[include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/skbuff.h?id=4318608dc28ef184158b4045896740716bea23f0)@@ -660,8 +660,6 @@ typedef unsigned char \*sk\_buff\_data\_t; \* @rbnode: RB tree node, alternative to next/prev for netem/tcp \* @list: queue head \* @sk: Socket we are owned by- \* @ip\_defrag\_offset: (aka @sk) alternate use of @sk, used in- \* fragmentation management \* @dev: Device we arrived on/are leaving by \* @dev\_scratch: (aka @dev) alternate use of @dev when @dev would be %NULL \* @cb: Control buffer. Free for use by every layer. Put private vars here@@ -778,10 +776,7 @@ struct sk\_buff { struct list\_head list; }; - union {- struct sock \*sk;- int ip\_defrag\_offset;- };+ struct sock \*sk;  union { ktime\_t tstamp;diff --git a/net/ipv4/inet\_fragment.c b/net/ipv4/inet\_fragment.cindex 341096807100cd..7e381701119998 100644--- a/[net/ipv4/inet\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/inet_fragment.c?id=c65ab97efcd438cb4e9f299400f2ea55251f3a67)+++ b/[net/ipv4/inet\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/inet_fragment.c?id=4318608dc28ef184158b4045896740716bea23f0)@@ -24,6 +24,8 @@ #include <net/ip.h> #include <net/ipv6.h> +#include "../core/sock\_destructor.h"+ /\* Use skb->cb to track consecutive/adjacent fragments coming at \* the end of the queue. Nodes in the rb-tree queue will \* contain "runs" of one or more adjacent fragments.@@ -39,6 +41,7 @@ struct ipfrag\_skb\_cb { }; struct sk\_buff \*next\_frag; int frag\_run\_len;+ int ip\_defrag\_offset; };  #define FRAG\_CB(skb) ((struct ipfrag\_skb\_cb \*)((skb)->cb))@@ -390,12 +393,12 @@ int inet\_frag\_queue\_insert(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, \*/ if (!last) fragrun\_create(q, skb); /\* First fragment. \*/- else if (last->ip\_defrag\_offset + last->len < end) {+ else if (FRAG\_CB(last)->ip\_defrag\_offset + last->len < end) { /\* This is the common case: skb goes to the end. \*/ /\* Detect and discard overlaps. \*/- if (offset < last->ip\_defrag\_offset + last->len)+ if (offset < FRAG\_CB(last)->ip\_defrag\_offset + last->len) return IPFRAG\_OVERLAP;- if (offset == last->ip\_defrag\_offset + last->len)+ if (offset == FRAG\_CB(last)->ip\_defrag\_offset + last->len) fragrun\_append\_to\_last(q, skb); else fragrun\_create(q, skb);@@ -412,13 +415,13 @@ int inet\_frag\_queue\_insert(struct inet\_frag\_queue \*q, struct sk\_buff \*skb,  parent = \*rbn; curr = rb\_to\_skb(parent);- curr\_run\_end = curr->ip\_defrag\_offset ++ curr\_run\_end = FRAG\_CB(curr)->ip\_defrag\_offset + FRAG\_CB(curr)->frag\_run\_len;- if (end <= curr->ip\_defrag\_offset)+ if (end <= FRAG\_CB(curr)->ip\_defrag\_offset) rbn = &parent->rb\_left; else if (offset >= curr\_run\_end) rbn = &parent->rb\_right;- else if (offset >= curr->ip\_defrag\_offset &&+ else if (offset >= FRAG\_CB(curr)->ip\_defrag\_offset && end <= curr\_run\_end) return IPFRAG\_DUP; else@@ -432,7 +435,7 @@ int inet\_frag\_queue\_insert(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, rb\_insert\_color(&skb->rbnode, &q->rb\_fragments); } - skb->ip\_defrag\_offset = offset;+ FRAG\_CB(skb)->ip\_defrag\_offset = offset;  return IPFRAG\_OK; }@@ -442,13 +445,28 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, struct sk\_buff \*parent) { struct sk\_buff \*fp, \*head = skb\_rb\_first(&q->rb\_fragments);- struct sk\_buff \*\*nextp;+ void (\*destructor)(struct sk\_buff \*);+ unsigned int orig\_truesize = 0;+ struct sk\_buff \*\*nextp = NULL;+ struct sock \*sk = skb->sk; int delta; + if (sk && is\_skb\_wmem(skb)) {+ /\* TX: skb->sk might have been passed as argument to+ \* dst->output and must remain valid until tx completes.+ \*+ \* Move sk to reassembled skb and fix up wmem accounting.+ \*/+ orig\_truesize = skb->truesize;+ destructor = skb->destructor;+ }+ if (head != skb) { fp = skb\_clone(skb, GFP\_ATOMIC);- if (!fp)- return NULL;+ if (!fp) {+ head = skb;+ goto out\_restore\_sk;+ } FRAG\_CB(fp)->next\_frag = FRAG\_CB(skb)->next\_frag; if (RB\_EMPTY\_NODE(&skb->rbnode)) FRAG\_CB(parent)->next\_frag = fp;@@ -457,6 +475,12 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, &q->rb\_fragments); if (q->fragments\_tail == skb) q->fragments\_tail = fp;++ if (orig\_truesize) {+ /\* prevent skb\_morph from releasing sk \*/+ skb->sk = NULL;+ skb->destructor = NULL;+ } skb\_morph(skb, head); FRAG\_CB(skb)->next\_frag = FRAG\_CB(head)->next\_frag; rb\_replace\_node(&head->rbnode, &skb->rbnode,@@ -464,13 +488,13 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, consume\_skb(head); head = skb; }- WARN\_ON(head->ip\_defrag\_offset != 0);+ WARN\_ON(FRAG\_CB(head)->ip\_defrag\_offset != 0);  delta = -head->truesize;  /\* Head of list must not be cloned. \*/ if (skb\_unclone(head, GFP\_ATOMIC))- return NULL;+ goto out\_restore\_sk;  delta += head->truesize; if (delta)@@ -486,7 +510,7 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb,  clone = alloc\_skb(0, GFP\_ATOMIC); if (!clone)- return NULL;+ goto out\_restore\_sk; skb\_shinfo(clone)->frag\_list = skb\_shinfo(head)->frag\_list; skb\_frag\_list\_init(head); for (i = 0; i < skb\_shinfo(head)->nr\_frags; i++)@@ -503,6 +527,21 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, nextp = &skb\_shinfo(head)->frag\_list; } +out\_restore\_sk:+ if (orig\_truesize) {+ int ts\_delta = head->truesize - orig\_truesize;++ /\* if this reassembled skb is fragmented later,+ \* fraglist skbs will get skb->sk assigned from head->sk,+ \* and each frag skb will be released via sock\_wfree.+ \*+ \* Update sk\_wmem\_alloc.+ \*/+ head->sk = sk;+ head->destructor = destructor;+ refcount\_add(ts\_delta, &sk->sk\_wmem\_alloc);+ }+ return nextp; } EXPORT\_SYMBOL(inet\_frag\_reasm\_prepare);@@ -510,6 +549,8 @@ EXPORT\_SYMBOL(inet\_frag\_reasm\_prepare); void inet\_frag\_reasm\_finish(struct inet\_frag\_queue \*q, struct sk\_buff \*head, void \*reasm\_data, bool try\_coalesce) {+ struct sock \*sk = is\_skb\_wmem(head) ? head->sk : NULL;+ const unsigned int head\_truesize = head->truesize; struct sk\_buff \*\*nextp = (struct sk\_buff \*\*)reasm\_data; struct rb\_node \*rbn; struct sk\_buff \*fp;@@ -572,6 +613,9 @@ void inet\_frag\_reasm\_finish(struct inet\_frag\_queue \*q, struct sk\_buff \*head, skb\_mark\_not\_on\_list(head); head->prev = NULL; head->tstamp = q->stamp;++ if (sk)+ refcount\_add(sum\_truesize - head\_truesize, &sk->sk\_wmem\_alloc); } EXPORT\_SYMBOL(inet\_frag\_reasm\_finish); diff --git a/net/ipv4/ip\_fragment.c b/net/ipv4/ip\_fragment.cindex fad803d2d711ef..ec2264adf2a6a5 100644--- a/[net/ipv4/ip\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/ip_fragment.c?id=c65ab97efcd438cb4e9f299400f2ea55251f3a67)+++ b/[net/ipv4/ip\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/ip_fragment.c?id=4318608dc28ef184158b4045896740716bea23f0)@@ -377,6 +377,7 @@ static int ip\_frag\_queue(struct ipq \*qp, struct sk\_buff \*skb) }  skb\_dst\_drop(skb);+ skb\_orphan(skb); return -EINPROGRESS;  insert\_error:@@ -479,7 +480,6 @@ int ip\_defrag(struct net \*net, struct sk\_buff \*skb, u32 user) struct ipq \*qp;  \_\_IP\_INC\_STATS(net, IPSTATS\_MIB\_REASMREQDS);- skb\_orphan(skb);  /\* Lookup (or create) queue header \*/ qp = ip\_find(net, ip\_hdr(skb), user, vif);diff --git a/net/ipv6/netfilter/nf\_conntrack\_reasm.c b/net/ipv6/netfilter/nf\_conntrack\_reasm.cindex 2e5b090d7c89fb..0ec5ec5a5b45ae 100644--- a/[net/ipv6/netfilter/nf\_conntrack\_reasm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/netfilter/nf_conntrack_reasm.c?id=c65ab97efcd438cb4e9f299400f2ea55251f3a67)+++ b/[net/ipv6/netfilter/nf\_conntrack\_reasm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/netfilter/nf_conntrack_reasm.c?id=4318608dc28ef184158b4045896740716bea23f0)@@ -297,6 +297,7 @@ static int nf\_ct\_frag6\_queue(struct frag\_queue \*fq, struct sk\_buff \*skb, }  skb\_dst\_drop(skb);+ skb\_orphan(skb); return -EINPROGRESS;  insert\_error:@@ -472,7 +473,6 @@ int nf\_ct\_frag6\_gather(struct net \*net, struct sk\_buff \*skb, u32 user) hdr = ipv6\_hdr(skb); fhdr = (struct frag\_hdr \*)skb\_transport\_header(skb); - skb\_orphan(skb); fq = fq\_find(net, fhdr->identification, user, hdr, skb->dev ? skb->dev->ifindex : 0); if (fq == NULL) { |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 17:48:51 +0000



=== Content from git.kernel.org_4920901c_20250111_175016.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=e09cbe017311508c21e0739e97198a8388b98981)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=e09cbe017311508c21e0739e97198a8388b98981)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e09cbe017311508c21e0739e97198a8388b98981)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e09cbe017311508c21e0739e97198a8388b98981)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Florian Westphal <fw@strlen.de> | 2024-03-26 11:18:41 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-04-10 16:37:59 +0200 |
| commit | [e09cbe017311508c21e0739e97198a8388b98981](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e09cbe017311508c21e0739e97198a8388b98981) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=e09cbe017311508c21e0739e97198a8388b98981)) | |
| tree | [d286e5dd618eb68fa29966fbee8d094010817221](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=e09cbe017311508c21e0739e97198a8388b98981) | |
| parent | [a3c01747df7cce3a0edf13b7c01e5057b34510c7](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a3c01747df7cce3a0edf13b7c01e5057b34510c7) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e09cbe017311508c21e0739e97198a8388b98981&id2=a3c01747df7cce3a0edf13b7c01e5057b34510c7)) | |
| download | [linux-e09cbe017311508c21e0739e97198a8388b98981.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-e09cbe017311508c21e0739e97198a8388b98981.tar.gz) | |

inet: inet\_defrag: prevent sk release while still in use[ Upstream commit 18685451fc4e546fc0e718580d32df3c0e5c8272 ]
ip\_local\_out() and other functions can pass skb->sk as function argument.
If the skb is a fragment and reassembly happens before such function call
returns, the sk must not be released.
This affects skb fragments reassembled via netfilter or similar
modules, e.g. openvswitch or ct\_act.c, when run as part of tx pipeline.
Eric Dumazet made an initial analysis of this bug. Quoting Eric:
Calling ip\_defrag() in output path is also implying skb\_orphan(),
which is buggy because output path relies on sk not disappearing.
A relevant old patch about the issue was :
8282f27449bf ("inet: frag: Always orphan skbs inside ip\_defrag()")
[..]
net/ipv4/ip\_output.c depends on skb->sk being set, and probably to an
inet socket, not an arbitrary one.
If we orphan the packet in ipvlan, then downstream things like FQ
packet scheduler will not work properly.
We need to change ip\_defrag() to only use skb\_orphan() when really
needed, ie whenever frag\_list is going to be used.
Eric suggested to stash sk in fragment queue and made an initial patch.
However there is a problem with this:
If skb is refragmented again right after, ip\_do\_fragment() will copy
head->sk to the new fragments, and sets up destructor to sock\_wfree.
IOW, we have no choice but to fix up sk\_wmem accouting to reflect the
fully reassembled skb, else wmem will underflow.
This change moves the orphan down into the core, to last possible moment.
As ip\_defrag\_offset is aliased with sk\_buff->sk member, we must move the
offset into the FRAG\_CB, else skb->sk gets clobbered.
This allows to delay the orphaning long enough to learn if the skb has
to be queued or if the skb is completing the reasm queue.
In the former case, things work as before, skb is orphaned. This is
safe because skb gets queued/stolen and won't continue past reasm engine.
In the latter case, we will steal the skb->sk reference, reattach it to
the head skb, and fix up wmem accouting when inet\_frag inflates truesize.
Fixes: 7026b1ddb6b8 ("netfilter: Pass socket pointer down through okfn().")
Diagnosed-by: Eric Dumazet <edumazet@google.com>
Reported-by: xingwei lee <xrivendell7@gmail.com>
Reported-by: yue sun <samsun1006219@gmail.com>
Reported-by: syzbot+e5167d7144a62715044c@syzkaller.appspotmail.com
Signed-off-by: Florian Westphal <fw@strlen.de>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Link: [https://lore.kernel.org/r/20240326101845.30836-1-fw@strlen.de](https://lore.kernel.org/r/20240326101845.30836-1-fw%40strlen.de)
Signed-off-by: Paolo Abeni <pabeni@redhat.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e09cbe017311508c21e0739e97198a8388b98981)

| -rw-r--r-- | [include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/skbuff.h?id=e09cbe017311508c21e0739e97198a8388b98981) | 7 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/ipv4/inet\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv4/inet_fragment.c?id=e09cbe017311508c21e0739e97198a8388b98981) | 70 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/ipv4/ip\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv4/ip_fragment.c?id=e09cbe017311508c21e0739e97198a8388b98981) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/ipv6/netfilter/nf\_conntrack\_reasm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv6/netfilter/nf_conntrack_reasm.c?id=e09cbe017311508c21e0739e97198a8388b98981) | 2 | |  |  |  | | --- | --- | --- | |

4 files changed, 60 insertions, 21 deletions

| diff --git a/include/linux/skbuff.h b/include/linux/skbuff.hindex d9a1ccfb570807..227f4514476b1a 100644--- a/[include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/skbuff.h?id=a3c01747df7cce3a0edf13b7c01e5057b34510c7)+++ b/[include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/skbuff.h?id=e09cbe017311508c21e0739e97198a8388b98981)@@ -748,8 +748,6 @@ typedef unsigned char \*sk\_buff\_data\_t; \* @list: queue head \* @ll\_node: anchor in an llist (eg socket defer\_list) \* @sk: Socket we are owned by- \* @ip\_defrag\_offset: (aka @sk) alternate use of @sk, used in- \* fragmentation management \* @dev: Device we arrived on/are leaving by \* @dev\_scratch: (aka @dev) alternate use of @dev when @dev would be %NULL \* @cb: Control buffer. Free for use by every layer. Put private vars here@@ -870,10 +868,7 @@ struct sk\_buff { struct llist\_node ll\_node; }; - union {- struct sock \*sk;- int ip\_defrag\_offset;- };+ struct sock \*sk;  union { ktime\_t tstamp;diff --git a/net/ipv4/inet\_fragment.c b/net/ipv4/inet\_fragment.cindex 7072fc0783ef56..c88c9034d63004 100644--- a/[net/ipv4/inet\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/inet_fragment.c?id=a3c01747df7cce3a0edf13b7c01e5057b34510c7)+++ b/[net/ipv4/inet\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/inet_fragment.c?id=e09cbe017311508c21e0739e97198a8388b98981)@@ -24,6 +24,8 @@ #include <net/ip.h> #include <net/ipv6.h> +#include "../core/sock\_destructor.h"+ /\* Use skb->cb to track consecutive/adjacent fragments coming at \* the end of the queue. Nodes in the rb-tree queue will \* contain "runs" of one or more adjacent fragments.@@ -39,6 +41,7 @@ struct ipfrag\_skb\_cb { }; struct sk\_buff \*next\_frag; int frag\_run\_len;+ int ip\_defrag\_offset; };  #define FRAG\_CB(skb) ((struct ipfrag\_skb\_cb \*)((skb)->cb))@@ -396,12 +399,12 @@ int inet\_frag\_queue\_insert(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, \*/ if (!last) fragrun\_create(q, skb); /\* First fragment. \*/- else if (last->ip\_defrag\_offset + last->len < end) {+ else if (FRAG\_CB(last)->ip\_defrag\_offset + last->len < end) { /\* This is the common case: skb goes to the end. \*/ /\* Detect and discard overlaps. \*/- if (offset < last->ip\_defrag\_offset + last->len)+ if (offset < FRAG\_CB(last)->ip\_defrag\_offset + last->len) return IPFRAG\_OVERLAP;- if (offset == last->ip\_defrag\_offset + last->len)+ if (offset == FRAG\_CB(last)->ip\_defrag\_offset + last->len) fragrun\_append\_to\_last(q, skb); else fragrun\_create(q, skb);@@ -418,13 +421,13 @@ int inet\_frag\_queue\_insert(struct inet\_frag\_queue \*q, struct sk\_buff \*skb,  parent = \*rbn; curr = rb\_to\_skb(parent);- curr\_run\_end = curr->ip\_defrag\_offset ++ curr\_run\_end = FRAG\_CB(curr)->ip\_defrag\_offset + FRAG\_CB(curr)->frag\_run\_len;- if (end <= curr->ip\_defrag\_offset)+ if (end <= FRAG\_CB(curr)->ip\_defrag\_offset) rbn = &parent->rb\_left; else if (offset >= curr\_run\_end) rbn = &parent->rb\_right;- else if (offset >= curr->ip\_defrag\_offset &&+ else if (offset >= FRAG\_CB(curr)->ip\_defrag\_offset && end <= curr\_run\_end) return IPFRAG\_DUP; else@@ -438,7 +441,7 @@ int inet\_frag\_queue\_insert(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, rb\_insert\_color(&skb->rbnode, &q->rb\_fragments); } - skb->ip\_defrag\_offset = offset;+ FRAG\_CB(skb)->ip\_defrag\_offset = offset;  return IPFRAG\_OK; }@@ -448,13 +451,28 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, struct sk\_buff \*parent) { struct sk\_buff \*fp, \*head = skb\_rb\_first(&q->rb\_fragments);- struct sk\_buff \*\*nextp;+ void (\*destructor)(struct sk\_buff \*);+ unsigned int orig\_truesize = 0;+ struct sk\_buff \*\*nextp = NULL;+ struct sock \*sk = skb->sk; int delta; + if (sk && is\_skb\_wmem(skb)) {+ /\* TX: skb->sk might have been passed as argument to+ \* dst->output and must remain valid until tx completes.+ \*+ \* Move sk to reassembled skb and fix up wmem accounting.+ \*/+ orig\_truesize = skb->truesize;+ destructor = skb->destructor;+ }+ if (head != skb) { fp = skb\_clone(skb, GFP\_ATOMIC);- if (!fp)- return NULL;+ if (!fp) {+ head = skb;+ goto out\_restore\_sk;+ } FRAG\_CB(fp)->next\_frag = FRAG\_CB(skb)->next\_frag; if (RB\_EMPTY\_NODE(&skb->rbnode)) FRAG\_CB(parent)->next\_frag = fp;@@ -463,6 +481,12 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, &q->rb\_fragments); if (q->fragments\_tail == skb) q->fragments\_tail = fp;++ if (orig\_truesize) {+ /\* prevent skb\_morph from releasing sk \*/+ skb->sk = NULL;+ skb->destructor = NULL;+ } skb\_morph(skb, head); FRAG\_CB(skb)->next\_frag = FRAG\_CB(head)->next\_frag; rb\_replace\_node(&head->rbnode, &skb->rbnode,@@ -470,13 +494,13 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, consume\_skb(head); head = skb; }- WARN\_ON(head->ip\_defrag\_offset != 0);+ WARN\_ON(FRAG\_CB(head)->ip\_defrag\_offset != 0);  delta = -head->truesize;  /\* Head of list must not be cloned. \*/ if (skb\_unclone(head, GFP\_ATOMIC))- return NULL;+ goto out\_restore\_sk;  delta += head->truesize; if (delta)@@ -492,7 +516,7 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb,  clone = alloc\_skb(0, GFP\_ATOMIC); if (!clone)- return NULL;+ goto out\_restore\_sk; skb\_shinfo(clone)->frag\_list = skb\_shinfo(head)->frag\_list; skb\_frag\_list\_init(head); for (i = 0; i < skb\_shinfo(head)->nr\_frags; i++)@@ -509,6 +533,21 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, nextp = &skb\_shinfo(head)->frag\_list; } +out\_restore\_sk:+ if (orig\_truesize) {+ int ts\_delta = head->truesize - orig\_truesize;++ /\* if this reassembled skb is fragmented later,+ \* fraglist skbs will get skb->sk assigned from head->sk,+ \* and each frag skb will be released via sock\_wfree.+ \*+ \* Update sk\_wmem\_alloc.+ \*/+ head->sk = sk;+ head->destructor = destructor;+ refcount\_add(ts\_delta, &sk->sk\_wmem\_alloc);+ }+ return nextp; } EXPORT\_SYMBOL(inet\_frag\_reasm\_prepare);@@ -516,6 +555,8 @@ EXPORT\_SYMBOL(inet\_frag\_reasm\_prepare); void inet\_frag\_reasm\_finish(struct inet\_frag\_queue \*q, struct sk\_buff \*head, void \*reasm\_data, bool try\_coalesce) {+ struct sock \*sk = is\_skb\_wmem(head) ? head->sk : NULL;+ const unsigned int head\_truesize = head->truesize; struct sk\_buff \*\*nextp = reasm\_data; struct rb\_node \*rbn; struct sk\_buff \*fp;@@ -579,6 +620,9 @@ void inet\_frag\_reasm\_finish(struct inet\_frag\_queue \*q, struct sk\_buff \*head, head->prev = NULL; head->tstamp = q->stamp; head->mono\_delivery\_time = q->mono\_delivery\_time;++ if (sk)+ refcount\_add(sum\_truesize - head\_truesize, &sk->sk\_wmem\_alloc); } EXPORT\_SYMBOL(inet\_frag\_reasm\_finish); diff --git a/net/ipv4/ip\_fragment.c b/net/ipv4/ip\_fragment.cindex a4941f53b52372..fb947d1613fe2b 100644--- a/[net/ipv4/ip\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/ip_fragment.c?id=a3c01747df7cce3a0edf13b7c01e5057b34510c7)+++ b/[net/ipv4/ip\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/ip_fragment.c?id=e09cbe017311508c21e0739e97198a8388b98981)@@ -384,6 +384,7 @@ static int ip\_frag\_queue(struct ipq \*qp, struct sk\_buff \*skb) }  skb\_dst\_drop(skb);+ skb\_orphan(skb); return -EINPROGRESS;  insert\_error:@@ -487,7 +488,6 @@ int ip\_defrag(struct net \*net, struct sk\_buff \*skb, u32 user) struct ipq \*qp;  \_\_IP\_INC\_STATS(net, IPSTATS\_MIB\_REASMREQDS);- skb\_orphan(skb);  /\* Lookup (or create) queue header \*/ qp = ip\_find(net, ip\_hdr(skb), user, vif);diff --git a/net/ipv6/netfilter/nf\_conntrack\_reasm.c b/net/ipv6/netfilter/nf\_conntrack\_reasm.cindex b2dd48911c8d62..efbec7ee27d0a0 100644--- a/[net/ipv6/netfilter/nf\_conntrack\_reasm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/netfilter/nf_conntrack_reasm.c?id=a3c01747df7cce3a0edf13b7c01e5057b34510c7)+++ b/[net/ipv6/netfilter/nf\_conntrack\_reasm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/netfilter/nf_conntrack_reasm.c?id=e09cbe017311508c21e0739e97198a8388b98981)@@ -294,6 +294,7 @@ static int nf\_ct\_frag6\_queue(struct frag\_queue \*fq, struct sk\_buff \*skb, }  skb\_dst\_drop(skb);+ skb\_orphan(skb); return -EINPROGRESS;  insert\_error:@@ -469,7 +470,6 @@ int nf\_ct\_frag6\_gather(struct net \*net, struct sk\_buff \*skb, u32 user) hdr = ipv6\_hdr(skb); fhdr = (struct frag\_hdr \*)skb\_transport\_header(skb); - skb\_orphan(skb); fq = fq\_find(net, fhdr->identification, user, hdr, skb->dev ? skb->dev->ifindex : 0); if (fq == NULL) { |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 17:48:53 +0000



=== Content from git.kernel.org_308ccebd_20250111_175015.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=7d0567842b78390dd9b60f00f1d8f838d540e325)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=7d0567842b78390dd9b60f00f1d8f838d540e325)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7d0567842b78390dd9b60f00f1d8f838d540e325)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7d0567842b78390dd9b60f00f1d8f838d540e325)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Florian Westphal <fw@strlen.de> | 2024-03-26 11:18:41 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-04-10 16:28:23 +0200 |
| commit | [7d0567842b78390dd9b60f00f1d8f838d540e325](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7d0567842b78390dd9b60f00f1d8f838d540e325) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=7d0567842b78390dd9b60f00f1d8f838d540e325)) | |
| tree | [8e164f1a4389ec9161d9d3daf670e031bc24f923](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=7d0567842b78390dd9b60f00f1d8f838d540e325) | |
| parent | [06426737653357e65661b6fb039f535c677fa306](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=06426737653357e65661b6fb039f535c677fa306) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7d0567842b78390dd9b60f00f1d8f838d540e325&id2=06426737653357e65661b6fb039f535c677fa306)) | |
| download | [linux-7d0567842b78390dd9b60f00f1d8f838d540e325.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-7d0567842b78390dd9b60f00f1d8f838d540e325.tar.gz) | |

inet: inet\_defrag: prevent sk release while still in use[ Upstream commit 18685451fc4e546fc0e718580d32df3c0e5c8272 ]
ip\_local\_out() and other functions can pass skb->sk as function argument.
If the skb is a fragment and reassembly happens before such function call
returns, the sk must not be released.
This affects skb fragments reassembled via netfilter or similar
modules, e.g. openvswitch or ct\_act.c, when run as part of tx pipeline.
Eric Dumazet made an initial analysis of this bug. Quoting Eric:
Calling ip\_defrag() in output path is also implying skb\_orphan(),
which is buggy because output path relies on sk not disappearing.
A relevant old patch about the issue was :
8282f27449bf ("inet: frag: Always orphan skbs inside ip\_defrag()")
[..]
net/ipv4/ip\_output.c depends on skb->sk being set, and probably to an
inet socket, not an arbitrary one.
If we orphan the packet in ipvlan, then downstream things like FQ
packet scheduler will not work properly.
We need to change ip\_defrag() to only use skb\_orphan() when really
needed, ie whenever frag\_list is going to be used.
Eric suggested to stash sk in fragment queue and made an initial patch.
However there is a problem with this:
If skb is refragmented again right after, ip\_do\_fragment() will copy
head->sk to the new fragments, and sets up destructor to sock\_wfree.
IOW, we have no choice but to fix up sk\_wmem accouting to reflect the
fully reassembled skb, else wmem will underflow.
This change moves the orphan down into the core, to last possible moment.
As ip\_defrag\_offset is aliased with sk\_buff->sk member, we must move the
offset into the FRAG\_CB, else skb->sk gets clobbered.
This allows to delay the orphaning long enough to learn if the skb has
to be queued or if the skb is completing the reasm queue.
In the former case, things work as before, skb is orphaned. This is
safe because skb gets queued/stolen and won't continue past reasm engine.
In the latter case, we will steal the skb->sk reference, reattach it to
the head skb, and fix up wmem accouting when inet\_frag inflates truesize.
Fixes: 7026b1ddb6b8 ("netfilter: Pass socket pointer down through okfn().")
Diagnosed-by: Eric Dumazet <edumazet@google.com>
Reported-by: xingwei lee <xrivendell7@gmail.com>
Reported-by: yue sun <samsun1006219@gmail.com>
Reported-by: syzbot+e5167d7144a62715044c@syzkaller.appspotmail.com
Signed-off-by: Florian Westphal <fw@strlen.de>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Link: [https://lore.kernel.org/r/20240326101845.30836-1-fw@strlen.de](https://lore.kernel.org/r/20240326101845.30836-1-fw%40strlen.de)
Signed-off-by: Paolo Abeni <pabeni@redhat.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7d0567842b78390dd9b60f00f1d8f838d540e325)

| -rw-r--r-- | [include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/skbuff.h?id=7d0567842b78390dd9b60f00f1d8f838d540e325) | 7 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/ipv4/inet\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv4/inet_fragment.c?id=7d0567842b78390dd9b60f00f1d8f838d540e325) | 70 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/ipv4/ip\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv4/ip_fragment.c?id=7d0567842b78390dd9b60f00f1d8f838d540e325) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/ipv6/netfilter/nf\_conntrack\_reasm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv6/netfilter/nf_conntrack_reasm.c?id=7d0567842b78390dd9b60f00f1d8f838d540e325) | 2 | |  |  |  | | --- | --- | --- | |

4 files changed, 60 insertions, 21 deletions

| diff --git a/include/linux/skbuff.h b/include/linux/skbuff.hindex c30d419ebf5457..c4a8520dc748ff 100644--- a/[include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/skbuff.h?id=06426737653357e65661b6fb039f535c677fa306)+++ b/[include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/skbuff.h?id=7d0567842b78390dd9b60f00f1d8f838d540e325)@@ -745,8 +745,6 @@ typedef unsigned char \*sk\_buff\_data\_t; \* @list: queue head \* @ll\_node: anchor in an llist (eg socket defer\_list) \* @sk: Socket we are owned by- \* @ip\_defrag\_offset: (aka @sk) alternate use of @sk, used in- \* fragmentation management \* @dev: Device we arrived on/are leaving by \* @dev\_scratch: (aka @dev) alternate use of @dev when @dev would be %NULL \* @cb: Control buffer. Free for use by every layer. Put private vars here@@ -870,10 +868,7 @@ struct sk\_buff { struct llist\_node ll\_node; }; - union {- struct sock \*sk;- int ip\_defrag\_offset;- };+ struct sock \*sk;  union { ktime\_t tstamp;diff --git a/net/ipv4/inet\_fragment.c b/net/ipv4/inet\_fragment.cindex c9f9ac5013a717..834cdc57755f7f 100644--- a/[net/ipv4/inet\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/inet_fragment.c?id=06426737653357e65661b6fb039f535c677fa306)+++ b/[net/ipv4/inet\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/inet_fragment.c?id=7d0567842b78390dd9b60f00f1d8f838d540e325)@@ -24,6 +24,8 @@ #include <net/ip.h> #include <net/ipv6.h> +#include "../core/sock\_destructor.h"+ /\* Use skb->cb to track consecutive/adjacent fragments coming at \* the end of the queue. Nodes in the rb-tree queue will \* contain "runs" of one or more adjacent fragments.@@ -39,6 +41,7 @@ struct ipfrag\_skb\_cb { }; struct sk\_buff \*next\_frag; int frag\_run\_len;+ int ip\_defrag\_offset; };  #define FRAG\_CB(skb) ((struct ipfrag\_skb\_cb \*)((skb)->cb))@@ -390,12 +393,12 @@ int inet\_frag\_queue\_insert(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, \*/ if (!last) fragrun\_create(q, skb); /\* First fragment. \*/- else if (last->ip\_defrag\_offset + last->len < end) {+ else if (FRAG\_CB(last)->ip\_defrag\_offset + last->len < end) { /\* This is the common case: skb goes to the end. \*/ /\* Detect and discard overlaps. \*/- if (offset < last->ip\_defrag\_offset + last->len)+ if (offset < FRAG\_CB(last)->ip\_defrag\_offset + last->len) return IPFRAG\_OVERLAP;- if (offset == last->ip\_defrag\_offset + last->len)+ if (offset == FRAG\_CB(last)->ip\_defrag\_offset + last->len) fragrun\_append\_to\_last(q, skb); else fragrun\_create(q, skb);@@ -412,13 +415,13 @@ int inet\_frag\_queue\_insert(struct inet\_frag\_queue \*q, struct sk\_buff \*skb,  parent = \*rbn; curr = rb\_to\_skb(parent);- curr\_run\_end = curr->ip\_defrag\_offset ++ curr\_run\_end = FRAG\_CB(curr)->ip\_defrag\_offset + FRAG\_CB(curr)->frag\_run\_len;- if (end <= curr->ip\_defrag\_offset)+ if (end <= FRAG\_CB(curr)->ip\_defrag\_offset) rbn = &parent->rb\_left; else if (offset >= curr\_run\_end) rbn = &parent->rb\_right;- else if (offset >= curr->ip\_defrag\_offset &&+ else if (offset >= FRAG\_CB(curr)->ip\_defrag\_offset && end <= curr\_run\_end) return IPFRAG\_DUP; else@@ -432,7 +435,7 @@ int inet\_frag\_queue\_insert(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, rb\_insert\_color(&skb->rbnode, &q->rb\_fragments); } - skb->ip\_defrag\_offset = offset;+ FRAG\_CB(skb)->ip\_defrag\_offset = offset;  return IPFRAG\_OK; }@@ -442,13 +445,28 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, struct sk\_buff \*parent) { struct sk\_buff \*fp, \*head = skb\_rb\_first(&q->rb\_fragments);- struct sk\_buff \*\*nextp;+ void (\*destructor)(struct sk\_buff \*);+ unsigned int orig\_truesize = 0;+ struct sk\_buff \*\*nextp = NULL;+ struct sock \*sk = skb->sk; int delta; + if (sk && is\_skb\_wmem(skb)) {+ /\* TX: skb->sk might have been passed as argument to+ \* dst->output and must remain valid until tx completes.+ \*+ \* Move sk to reassembled skb and fix up wmem accounting.+ \*/+ orig\_truesize = skb->truesize;+ destructor = skb->destructor;+ }+ if (head != skb) { fp = skb\_clone(skb, GFP\_ATOMIC);- if (!fp)- return NULL;+ if (!fp) {+ head = skb;+ goto out\_restore\_sk;+ } FRAG\_CB(fp)->next\_frag = FRAG\_CB(skb)->next\_frag; if (RB\_EMPTY\_NODE(&skb->rbnode)) FRAG\_CB(parent)->next\_frag = fp;@@ -457,6 +475,12 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, &q->rb\_fragments); if (q->fragments\_tail == skb) q->fragments\_tail = fp;++ if (orig\_truesize) {+ /\* prevent skb\_morph from releasing sk \*/+ skb->sk = NULL;+ skb->destructor = NULL;+ } skb\_morph(skb, head); FRAG\_CB(skb)->next\_frag = FRAG\_CB(head)->next\_frag; rb\_replace\_node(&head->rbnode, &skb->rbnode,@@ -464,13 +488,13 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, consume\_skb(head); head = skb; }- WARN\_ON(head->ip\_defrag\_offset != 0);+ WARN\_ON(FRAG\_CB(head)->ip\_defrag\_offset != 0);  delta = -head->truesize;  /\* Head of list must not be cloned. \*/ if (skb\_unclone(head, GFP\_ATOMIC))- return NULL;+ goto out\_restore\_sk;  delta += head->truesize; if (delta)@@ -486,7 +510,7 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb,  clone = alloc\_skb(0, GFP\_ATOMIC); if (!clone)- return NULL;+ goto out\_restore\_sk; skb\_shinfo(clone)->frag\_list = skb\_shinfo(head)->frag\_list; skb\_frag\_list\_init(head); for (i = 0; i < skb\_shinfo(head)->nr\_frags; i++)@@ -503,6 +527,21 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, nextp = &skb\_shinfo(head)->frag\_list; } +out\_restore\_sk:+ if (orig\_truesize) {+ int ts\_delta = head->truesize - orig\_truesize;++ /\* if this reassembled skb is fragmented later,+ \* fraglist skbs will get skb->sk assigned from head->sk,+ \* and each frag skb will be released via sock\_wfree.+ \*+ \* Update sk\_wmem\_alloc.+ \*/+ head->sk = sk;+ head->destructor = destructor;+ refcount\_add(ts\_delta, &sk->sk\_wmem\_alloc);+ }+ return nextp; } EXPORT\_SYMBOL(inet\_frag\_reasm\_prepare);@@ -510,6 +549,8 @@ EXPORT\_SYMBOL(inet\_frag\_reasm\_prepare); void inet\_frag\_reasm\_finish(struct inet\_frag\_queue \*q, struct sk\_buff \*head, void \*reasm\_data, bool try\_coalesce) {+ struct sock \*sk = is\_skb\_wmem(head) ? head->sk : NULL;+ const unsigned int head\_truesize = head->truesize; struct sk\_buff \*\*nextp = reasm\_data; struct rb\_node \*rbn; struct sk\_buff \*fp;@@ -573,6 +614,9 @@ void inet\_frag\_reasm\_finish(struct inet\_frag\_queue \*q, struct sk\_buff \*head, head->prev = NULL; head->tstamp = q->stamp; head->mono\_delivery\_time = q->mono\_delivery\_time;++ if (sk)+ refcount\_add(sum\_truesize - head\_truesize, &sk->sk\_wmem\_alloc); } EXPORT\_SYMBOL(inet\_frag\_reasm\_finish); diff --git a/net/ipv4/ip\_fragment.c b/net/ipv4/ip\_fragment.cindex fb153569889ecc..6c309c1ec3b0fa 100644--- a/[net/ipv4/ip\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/ip_fragment.c?id=06426737653357e65661b6fb039f535c677fa306)+++ b/[net/ipv4/ip\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/ip_fragment.c?id=7d0567842b78390dd9b60f00f1d8f838d540e325)@@ -378,6 +378,7 @@ static int ip\_frag\_queue(struct ipq \*qp, struct sk\_buff \*skb) }  skb\_dst\_drop(skb);+ skb\_orphan(skb); return -EINPROGRESS;  insert\_error:@@ -480,7 +481,6 @@ int ip\_defrag(struct net \*net, struct sk\_buff \*skb, u32 user) struct ipq \*qp;  \_\_IP\_INC\_STATS(net, IPSTATS\_MIB\_REASMREQDS);- skb\_orphan(skb);  /\* Lookup (or create) queue header \*/ qp = ip\_find(net, ip\_hdr(skb), user, vif);diff --git a/net/ipv6/netfilter/nf\_conntrack\_reasm.c b/net/ipv6/netfilter/nf\_conntrack\_reasm.cindex 38db0064d6613a..87a394179092c4 100644--- a/[net/ipv6/netfilter/nf\_conntrack\_reasm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/netfilter/nf_conntrack_reasm.c?id=06426737653357e65661b6fb039f535c677fa306)+++ b/[net/ipv6/netfilter/nf\_conntrack\_reasm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/netfilter/nf_conntrack_reasm.c?id=7d0567842b78390dd9b60f00f1d8f838d540e325)@@ -293,6 +293,7 @@ static int nf\_ct\_frag6\_queue(struct frag\_queue \*fq, struct sk\_buff \*skb, }  skb\_dst\_drop(skb);+ skb\_orphan(skb); return -EINPROGRESS;  insert\_error:@@ -468,7 +469,6 @@ int nf\_ct\_frag6\_gather(struct net \*net, struct sk\_buff \*skb, u32 user) hdr = ipv6\_hdr(skb); fhdr = (struct frag\_hdr \*)skb\_transport\_header(skb); - skb\_orphan(skb); fq = fq\_find(net, fhdr->identification, user, hdr, skb->dev ? skb->dev->ifindex : 0); if (fq == NULL) { |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 17:48:52 +0000



=== Content from git.kernel.org_f5ce222a_20250111_175015.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=9705f447bf9a6cd088300ad2c407b5e1c6591091)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=9705f447bf9a6cd088300ad2c407b5e1c6591091)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9705f447bf9a6cd088300ad2c407b5e1c6591091)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9705f447bf9a6cd088300ad2c407b5e1c6591091)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Florian Westphal <fw@strlen.de> | 2024-03-26 11:18:41 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-10-17 15:07:37 +0200 |
| commit | [9705f447bf9a6cd088300ad2c407b5e1c6591091](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9705f447bf9a6cd088300ad2c407b5e1c6591091) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=9705f447bf9a6cd088300ad2c407b5e1c6591091)) | |
| tree | [d605ece2ce96bf7d994536f826d6c6831b5761fb](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=9705f447bf9a6cd088300ad2c407b5e1c6591091) | |
| parent | [0e7814b028cd50b3ff79659d23dfa9da6a1e75e1](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=0e7814b028cd50b3ff79659d23dfa9da6a1e75e1) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9705f447bf9a6cd088300ad2c407b5e1c6591091&id2=0e7814b028cd50b3ff79659d23dfa9da6a1e75e1)) | |
| download | [linux-9705f447bf9a6cd088300ad2c407b5e1c6591091.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-9705f447bf9a6cd088300ad2c407b5e1c6591091.tar.gz) | |

inet: inet\_defrag: prevent sk release while still in usecommit 18685451fc4e546fc0e718580d32df3c0e5c8272 upstream.
ip\_local\_out() and other functions can pass skb->sk as function argument.
If the skb is a fragment and reassembly happens before such function call
returns, the sk must not be released.
This affects skb fragments reassembled via netfilter or similar
modules, e.g. openvswitch or ct\_act.c, when run as part of tx pipeline.
Eric Dumazet made an initial analysis of this bug. Quoting Eric:
Calling ip\_defrag() in output path is also implying skb\_orphan(),
which is buggy because output path relies on sk not disappearing.
A relevant old patch about the issue was :
8282f27449bf ("inet: frag: Always orphan skbs inside ip\_defrag()")
[..]
net/ipv4/ip\_output.c depends on skb->sk being set, and probably to an
inet socket, not an arbitrary one.
If we orphan the packet in ipvlan, then downstream things like FQ
packet scheduler will not work properly.
We need to change ip\_defrag() to only use skb\_orphan() when really
needed, ie whenever frag\_list is going to be used.
Eric suggested to stash sk in fragment queue and made an initial patch.
However there is a problem with this:
If skb is refragmented again right after, ip\_do\_fragment() will copy
head->sk to the new fragments, and sets up destructor to sock\_wfree.
IOW, we have no choice but to fix up sk\_wmem accouting to reflect the
fully reassembled skb, else wmem will underflow.
This change moves the orphan down into the core, to last possible moment.
As ip\_defrag\_offset is aliased with sk\_buff->sk member, we must move the
offset into the FRAG\_CB, else skb->sk gets clobbered.
This allows to delay the orphaning long enough to learn if the skb has
to be queued or if the skb is completing the reasm queue.
In the former case, things work as before, skb is orphaned. This is
safe because skb gets queued/stolen and won't continue past reasm engine.
In the latter case, we will steal the skb->sk reference, reattach it to
the head skb, and fix up wmem accouting when inet\_frag inflates truesize.
Fixes: 7026b1ddb6b8 ("netfilter: Pass socket pointer down through okfn().")
Diagnosed-by: Eric Dumazet <edumazet@google.com>
Reported-by: xingwei lee <xrivendell7@gmail.com>
Reported-by: yue sun <samsun1006219@gmail.com>
Reported-by: syzbot+e5167d7144a62715044c@syzkaller.appspotmail.com
Signed-off-by: Florian Westphal <fw@strlen.de>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Link: [https://lore.kernel.org/r/20240326101845.30836-1-fw@strlen.de](https://lore.kernel.org/r/20240326101845.30836-1-fw%40strlen.de)
Signed-off-by: Paolo Abeni <pabeni@redhat.com>
Signed-off-by: Saeed Mirzamohammadi <saeed.mirzamohammadi@oracle.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9705f447bf9a6cd088300ad2c407b5e1c6591091)

| -rw-r--r-- | [include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/skbuff.h?id=9705f447bf9a6cd088300ad2c407b5e1c6591091) | 5 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/core/sock\_destructor.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/core/sock_destructor.h?id=9705f447bf9a6cd088300ad2c407b5e1c6591091) | 12 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/ipv4/inet\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv4/inet_fragment.c?id=9705f447bf9a6cd088300ad2c407b5e1c6591091) | 70 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/ipv4/ip\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv4/ip_fragment.c?id=9705f447bf9a6cd088300ad2c407b5e1c6591091) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/ipv6/netfilter/nf\_conntrack\_reasm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv6/netfilter/nf_conntrack_reasm.c?id=9705f447bf9a6cd088300ad2c407b5e1c6591091) | 2 | |  |  |  | | --- | --- | --- | |

5 files changed, 72 insertions, 19 deletions

| diff --git a/include/linux/skbuff.h b/include/linux/skbuff.hindex 31755d496b01d9..31ae4b74d43522 100644--- a/[include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/skbuff.h?id=0e7814b028cd50b3ff79659d23dfa9da6a1e75e1)+++ b/[include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/skbuff.h?id=9705f447bf9a6cd088300ad2c407b5e1c6591091)@@ -733,10 +733,7 @@ struct sk\_buff { struct list\_head list; }; - union {- struct sock \*sk;- int ip\_defrag\_offset;- };+ struct sock \*sk;  union { ktime\_t tstamp;diff --git a/net/core/sock\_destructor.h b/net/core/sock\_destructor.hnew file mode 100644index 00000000000000..2f396e6bfba5a3--- /dev/null+++ b/[net/core/sock\_destructor.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/sock_destructor.h?id=9705f447bf9a6cd088300ad2c407b5e1c6591091)@@ -0,0 +1,12 @@+/\* SPDX-License-Identifier: GPL-2.0-or-later \*/+#ifndef \_NET\_CORE\_SOCK\_DESTRUCTOR\_H+#define \_NET\_CORE\_SOCK\_DESTRUCTOR\_H+#include <net/tcp.h>++static inline bool is\_skb\_wmem(const struct sk\_buff \*skb)+{+ return skb->destructor == sock\_wfree ||+ skb->destructor == \_\_sock\_wfree ||+ (IS\_ENABLED(CONFIG\_INET) && skb->destructor == tcp\_wfree);+}+#endifdiff --git a/net/ipv4/inet\_fragment.c b/net/ipv4/inet\_fragment.cindex e0e8a65d561ec6..12ef3cb26676d2 100644--- a/[net/ipv4/inet\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/inet_fragment.c?id=0e7814b028cd50b3ff79659d23dfa9da6a1e75e1)+++ b/[net/ipv4/inet\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/inet_fragment.c?id=9705f447bf9a6cd088300ad2c407b5e1c6591091)@@ -24,6 +24,8 @@ #include <net/ip.h> #include <net/ipv6.h> +#include "../core/sock\_destructor.h"+ /\* Use skb->cb to track consecutive/adjacent fragments coming at \* the end of the queue. Nodes in the rb-tree queue will \* contain "runs" of one or more adjacent fragments.@@ -39,6 +41,7 @@ struct ipfrag\_skb\_cb { }; struct sk\_buff \*next\_frag; int frag\_run\_len;+ int ip\_defrag\_offset; };  #define FRAG\_CB(skb) ((struct ipfrag\_skb\_cb \*)((skb)->cb))@@ -359,12 +362,12 @@ int inet\_frag\_queue\_insert(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, \*/ if (!last) fragrun\_create(q, skb); /\* First fragment. \*/- else if (last->ip\_defrag\_offset + last->len < end) {+ else if (FRAG\_CB(last)->ip\_defrag\_offset + last->len < end) { /\* This is the common case: skb goes to the end. \*/ /\* Detect and discard overlaps. \*/- if (offset < last->ip\_defrag\_offset + last->len)+ if (offset < FRAG\_CB(last)->ip\_defrag\_offset + last->len) return IPFRAG\_OVERLAP;- if (offset == last->ip\_defrag\_offset + last->len)+ if (offset == FRAG\_CB(last)->ip\_defrag\_offset + last->len) fragrun\_append\_to\_last(q, skb); else fragrun\_create(q, skb);@@ -381,13 +384,13 @@ int inet\_frag\_queue\_insert(struct inet\_frag\_queue \*q, struct sk\_buff \*skb,  parent = \*rbn; curr = rb\_to\_skb(parent);- curr\_run\_end = curr->ip\_defrag\_offset ++ curr\_run\_end = FRAG\_CB(curr)->ip\_defrag\_offset + FRAG\_CB(curr)->frag\_run\_len;- if (end <= curr->ip\_defrag\_offset)+ if (end <= FRAG\_CB(curr)->ip\_defrag\_offset) rbn = &parent->rb\_left; else if (offset >= curr\_run\_end) rbn = &parent->rb\_right;- else if (offset >= curr->ip\_defrag\_offset &&+ else if (offset >= FRAG\_CB(curr)->ip\_defrag\_offset && end <= curr\_run\_end) return IPFRAG\_DUP; else@@ -401,7 +404,7 @@ int inet\_frag\_queue\_insert(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, rb\_insert\_color(&skb->rbnode, &q->rb\_fragments); } - skb->ip\_defrag\_offset = offset;+ FRAG\_CB(skb)->ip\_defrag\_offset = offset;  return IPFRAG\_OK; }@@ -411,13 +414,28 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, struct sk\_buff \*parent) { struct sk\_buff \*fp, \*head = skb\_rb\_first(&q->rb\_fragments);- struct sk\_buff \*\*nextp;+ void (\*destructor)(struct sk\_buff \*);+ unsigned int orig\_truesize = 0;+ struct sk\_buff \*\*nextp = NULL;+ struct sock \*sk = skb->sk; int delta; + if (sk && is\_skb\_wmem(skb)) {+ /\* TX: skb->sk might have been passed as argument to+ \* dst->output and must remain valid until tx completes.+ \*+ \* Move sk to reassembled skb and fix up wmem accounting.+ \*/+ orig\_truesize = skb->truesize;+ destructor = skb->destructor;+ }+ if (head != skb) { fp = skb\_clone(skb, GFP\_ATOMIC);- if (!fp)- return NULL;+ if (!fp) {+ head = skb;+ goto out\_restore\_sk;+ } FRAG\_CB(fp)->next\_frag = FRAG\_CB(skb)->next\_frag; if (RB\_EMPTY\_NODE(&skb->rbnode)) FRAG\_CB(parent)->next\_frag = fp;@@ -426,6 +444,12 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, &q->rb\_fragments); if (q->fragments\_tail == skb) q->fragments\_tail = fp;++ if (orig\_truesize) {+ /\* prevent skb\_morph from releasing sk \*/+ skb->sk = NULL;+ skb->destructor = NULL;+ } skb\_morph(skb, head); FRAG\_CB(skb)->next\_frag = FRAG\_CB(head)->next\_frag; rb\_replace\_node(&head->rbnode, &skb->rbnode,@@ -433,13 +457,13 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, consume\_skb(head); head = skb; }- WARN\_ON(head->ip\_defrag\_offset != 0);+ WARN\_ON(FRAG\_CB(head)->ip\_defrag\_offset != 0);  delta = -head->truesize;  /\* Head of list must not be cloned. \*/ if (skb\_unclone(head, GFP\_ATOMIC))- return NULL;+ goto out\_restore\_sk;  delta += head->truesize; if (delta)@@ -455,7 +479,7 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb,  clone = alloc\_skb(0, GFP\_ATOMIC); if (!clone)- return NULL;+ goto out\_restore\_sk; skb\_shinfo(clone)->frag\_list = skb\_shinfo(head)->frag\_list; skb\_frag\_list\_init(head); for (i = 0; i < skb\_shinfo(head)->nr\_frags; i++)@@ -472,6 +496,21 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, nextp = &skb\_shinfo(head)->frag\_list; } +out\_restore\_sk:+ if (orig\_truesize) {+ int ts\_delta = head->truesize - orig\_truesize;++ /\* if this reassembled skb is fragmented later,+ \* fraglist skbs will get skb->sk assigned from head->sk,+ \* and each frag skb will be released via sock\_wfree.+ \*+ \* Update sk\_wmem\_alloc.+ \*/+ head->sk = sk;+ head->destructor = destructor;+ refcount\_add(ts\_delta, &sk->sk\_wmem\_alloc);+ }+ return nextp; } EXPORT\_SYMBOL(inet\_frag\_reasm\_prepare);@@ -479,6 +518,8 @@ EXPORT\_SYMBOL(inet\_frag\_reasm\_prepare); void inet\_frag\_reasm\_finish(struct inet\_frag\_queue \*q, struct sk\_buff \*head, void \*reasm\_data, bool try\_coalesce) {+ struct sock \*sk = is\_skb\_wmem(head) ? head->sk : NULL;+ const unsigned int head\_truesize = head->truesize; struct sk\_buff \*\*nextp = (struct sk\_buff \*\*)reasm\_data; struct rb\_node \*rbn; struct sk\_buff \*fp;@@ -541,6 +582,9 @@ void inet\_frag\_reasm\_finish(struct inet\_frag\_queue \*q, struct sk\_buff \*head, skb\_mark\_not\_on\_list(head); head->prev = NULL; head->tstamp = q->stamp;++ if (sk)+ refcount\_add(sum\_truesize - head\_truesize, &sk->sk\_wmem\_alloc); } EXPORT\_SYMBOL(inet\_frag\_reasm\_finish); diff --git a/net/ipv4/ip\_fragment.c b/net/ipv4/ip\_fragment.cindex fad803d2d711ef..ec2264adf2a6a5 100644--- a/[net/ipv4/ip\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/ip_fragment.c?id=0e7814b028cd50b3ff79659d23dfa9da6a1e75e1)+++ b/[net/ipv4/ip\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/ip_fragment.c?id=9705f447bf9a6cd088300ad2c407b5e1c6591091)@@ -377,6 +377,7 @@ static int ip\_frag\_queue(struct ipq \*qp, struct sk\_buff \*skb) }  skb\_dst\_drop(skb);+ skb\_orphan(skb); return -EINPROGRESS;  insert\_error:@@ -479,7 +480,6 @@ int ip\_defrag(struct net \*net, struct sk\_buff \*skb, u32 user) struct ipq \*qp;  \_\_IP\_INC\_STATS(net, IPSTATS\_MIB\_REASMREQDS);- skb\_orphan(skb);  /\* Lookup (or create) queue header \*/ qp = ip\_find(net, ip\_hdr(skb), user, vif);diff --git a/net/ipv6/netfilter/nf\_conntrack\_reasm.c b/net/ipv6/netfilter/nf\_conntrack\_reasm.cindex c129ad334eb392..8c2163f95711ce 100644--- a/[net/ipv6/netfilter/nf\_conntrack\_reasm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/netfilter/nf_conntrack_reasm.c?id=0e7814b028cd50b3ff79659d23dfa9da6a1e75e1)+++ b/[net/ipv6/netfilter/nf\_conntrack\_reasm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/netfilter/nf_conntrack_reasm.c?id=9705f447bf9a6cd088300ad2c407b5e1c6591091)@@ -296,6 +296,7 @@ static int nf\_ct\_frag6\_queue(struct frag\_queue \*fq, struct sk\_buff \*skb, }  skb\_dst\_drop(skb);+ skb\_orphan(skb); return -EINPROGRESS;  insert\_error:@@ -471,7 +472,6 @@ int nf\_ct\_frag6\_gather(struct net \*net, struct sk\_buff \*skb, u32 user) hdr = ipv6\_hdr(skb); fhdr = (struct frag\_hdr \*)skb\_transport\_header(skb); - skb\_orphan(skb); fq = fq\_find(net, fhdr->identification, user, hdr, skb->dev ? skb->dev->ifindex : 0); if (fq == NULL) { |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 17:48:52 +0000



=== Content from git.kernel.org_253c29b8_20250111_175013.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=18685451fc4e546fc0e718580d32df3c0e5c8272)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=18685451fc4e546fc0e718580d32df3c0e5c8272)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=18685451fc4e546fc0e718580d32df3c0e5c8272)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=18685451fc4e546fc0e718580d32df3c0e5c8272)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Florian Westphal <fw@strlen.de> | 2024-03-26 11:18:41 +0100 |
| --- | --- | --- |
| committer | Paolo Abeni <pabeni@redhat.com> | 2024-03-28 12:06:22 +0100 |
| commit | [18685451fc4e546fc0e718580d32df3c0e5c8272](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=18685451fc4e546fc0e718580d32df3c0e5c8272) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=18685451fc4e546fc0e718580d32df3c0e5c8272)) | |
| tree | [94e2d8bc0bc524b1956b4ecd2c9a9ca714039f69](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=18685451fc4e546fc0e718580d32df3c0e5c8272) | |
| parent | [40d4b4807cadd83fb3f46cc8cd67a945b5b25461](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=40d4b4807cadd83fb3f46cc8cd67a945b5b25461) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=18685451fc4e546fc0e718580d32df3c0e5c8272&id2=40d4b4807cadd83fb3f46cc8cd67a945b5b25461)) | |
| download | [linux-18685451fc4e546fc0e718580d32df3c0e5c8272.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-18685451fc4e546fc0e718580d32df3c0e5c8272.tar.gz) | |

inet: inet\_defrag: prevent sk release while still in useip\_local\_out() and other functions can pass skb->sk as function argument.
If the skb is a fragment and reassembly happens before such function call
returns, the sk must not be released.
This affects skb fragments reassembled via netfilter or similar
modules, e.g. openvswitch or ct\_act.c, when run as part of tx pipeline.
Eric Dumazet made an initial analysis of this bug. Quoting Eric:
Calling ip\_defrag() in output path is also implying skb\_orphan(),
which is buggy because output path relies on sk not disappearing.
A relevant old patch about the issue was :
8282f27449bf ("inet: frag: Always orphan skbs inside ip\_defrag()")
[..]
net/ipv4/ip\_output.c depends on skb->sk being set, and probably to an
inet socket, not an arbitrary one.
If we orphan the packet in ipvlan, then downstream things like FQ
packet scheduler will not work properly.
We need to change ip\_defrag() to only use skb\_orphan() when really
needed, ie whenever frag\_list is going to be used.
Eric suggested to stash sk in fragment queue and made an initial patch.
However there is a problem with this:
If skb is refragmented again right after, ip\_do\_fragment() will copy
head->sk to the new fragments, and sets up destructor to sock\_wfree.
IOW, we have no choice but to fix up sk\_wmem accouting to reflect the
fully reassembled skb, else wmem will underflow.
This change moves the orphan down into the core, to last possible moment.
As ip\_defrag\_offset is aliased with sk\_buff->sk member, we must move the
offset into the FRAG\_CB, else skb->sk gets clobbered.
This allows to delay the orphaning long enough to learn if the skb has
to be queued or if the skb is completing the reasm queue.
In the former case, things work as before, skb is orphaned. This is
safe because skb gets queued/stolen and won't continue past reasm engine.
In the latter case, we will steal the skb->sk reference, reattach it to
the head skb, and fix up wmem accouting when inet\_frag inflates truesize.
Fixes: 7026b1ddb6b8 ("netfilter: Pass socket pointer down through okfn().")
Diagnosed-by: Eric Dumazet <edumazet@google.com>
Reported-by: xingwei lee <xrivendell7@gmail.com>
Reported-by: yue sun <samsun1006219@gmail.com>
Reported-by: syzbot+e5167d7144a62715044c@syzkaller.appspotmail.com
Signed-off-by: Florian Westphal <fw@strlen.de>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Link: [https://lore.kernel.org/r/20240326101845.30836-1-fw@strlen.de](https://lore.kernel.org/r/20240326101845.30836-1-fw%40strlen.de)
Signed-off-by: Paolo Abeni <pabeni@redhat.com>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=18685451fc4e546fc0e718580d32df3c0e5c8272)

| -rw-r--r-- | [include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/skbuff.h?id=18685451fc4e546fc0e718580d32df3c0e5c8272) | 7 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/ipv4/inet\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv4/inet_fragment.c?id=18685451fc4e546fc0e718580d32df3c0e5c8272) | 70 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/ipv4/ip\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv4/ip_fragment.c?id=18685451fc4e546fc0e718580d32df3c0e5c8272) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/ipv6/netfilter/nf\_conntrack\_reasm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv6/netfilter/nf_conntrack_reasm.c?id=18685451fc4e546fc0e718580d32df3c0e5c8272) | 2 | |  |  |  | | --- | --- | --- | |

4 files changed, 60 insertions, 21 deletions

| diff --git a/include/linux/skbuff.h b/include/linux/skbuff.hindex 0c7c67b3a87b23..9d24aec064e888 100644--- a/[include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/skbuff.h?id=40d4b4807cadd83fb3f46cc8cd67a945b5b25461)+++ b/[include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/skbuff.h?id=18685451fc4e546fc0e718580d32df3c0e5c8272)@@ -753,8 +753,6 @@ typedef unsigned char \*sk\_buff\_data\_t; \* @list: queue head \* @ll\_node: anchor in an llist (eg socket defer\_list) \* @sk: Socket we are owned by- \* @ip\_defrag\_offset: (aka @sk) alternate use of @sk, used in- \* fragmentation management \* @dev: Device we arrived on/are leaving by \* @dev\_scratch: (aka @dev) alternate use of @dev when @dev would be %NULL \* @cb: Control buffer. Free for use by every layer. Put private vars here@@ -875,10 +873,7 @@ struct sk\_buff { struct llist\_node ll\_node; }; - union {- struct sock \*sk;- int ip\_defrag\_offset;- };+ struct sock \*sk;  union { ktime\_t tstamp;diff --git a/net/ipv4/inet\_fragment.c b/net/ipv4/inet\_fragment.cindex 7072fc0783ef56..c88c9034d63004 100644--- a/[net/ipv4/inet\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/inet_fragment.c?id=40d4b4807cadd83fb3f46cc8cd67a945b5b25461)+++ b/[net/ipv4/inet\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/inet_fragment.c?id=18685451fc4e546fc0e718580d32df3c0e5c8272)@@ -24,6 +24,8 @@ #include <net/ip.h> #include <net/ipv6.h> +#include "../core/sock\_destructor.h"+ /\* Use skb->cb to track consecutive/adjacent fragments coming at \* the end of the queue. Nodes in the rb-tree queue will \* contain "runs" of one or more adjacent fragments.@@ -39,6 +41,7 @@ struct ipfrag\_skb\_cb { }; struct sk\_buff \*next\_frag; int frag\_run\_len;+ int ip\_defrag\_offset; };  #define FRAG\_CB(skb) ((struct ipfrag\_skb\_cb \*)((skb)->cb))@@ -396,12 +399,12 @@ int inet\_frag\_queue\_insert(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, \*/ if (!last) fragrun\_create(q, skb); /\* First fragment. \*/- else if (last->ip\_defrag\_offset + last->len < end) {+ else if (FRAG\_CB(last)->ip\_defrag\_offset + last->len < end) { /\* This is the common case: skb goes to the end. \*/ /\* Detect and discard overlaps. \*/- if (offset < last->ip\_defrag\_offset + last->len)+ if (offset < FRAG\_CB(last)->ip\_defrag\_offset + last->len) return IPFRAG\_OVERLAP;- if (offset == last->ip\_defrag\_offset + last->len)+ if (offset == FRAG\_CB(last)->ip\_defrag\_offset + last->len) fragrun\_append\_to\_last(q, skb); else fragrun\_create(q, skb);@@ -418,13 +421,13 @@ int inet\_frag\_queue\_insert(struct inet\_frag\_queue \*q, struct sk\_buff \*skb,  parent = \*rbn; curr = rb\_to\_skb(parent);- curr\_run\_end = curr->ip\_defrag\_offset ++ curr\_run\_end = FRAG\_CB(curr)->ip\_defrag\_offset + FRAG\_CB(curr)->frag\_run\_len;- if (end <= curr->ip\_defrag\_offset)+ if (end <= FRAG\_CB(curr)->ip\_defrag\_offset) rbn = &parent->rb\_left; else if (offset >= curr\_run\_end) rbn = &parent->rb\_right;- else if (offset >= curr->ip\_defrag\_offset &&+ else if (offset >= FRAG\_CB(curr)->ip\_defrag\_offset && end <= curr\_run\_end) return IPFRAG\_DUP; else@@ -438,7 +441,7 @@ int inet\_frag\_queue\_insert(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, rb\_insert\_color(&skb->rbnode, &q->rb\_fragments); } - skb->ip\_defrag\_offset = offset;+ FRAG\_CB(skb)->ip\_defrag\_offset = offset;  return IPFRAG\_OK; }@@ -448,13 +451,28 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, struct sk\_buff \*parent) { struct sk\_buff \*fp, \*head = skb\_rb\_first(&q->rb\_fragments);- struct sk\_buff \*\*nextp;+ void (\*destructor)(struct sk\_buff \*);+ unsigned int orig\_truesize = 0;+ struct sk\_buff \*\*nextp = NULL;+ struct sock \*sk = skb->sk; int delta; + if (sk && is\_skb\_wmem(skb)) {+ /\* TX: skb->sk might have been passed as argument to+ \* dst->output and must remain valid until tx completes.+ \*+ \* Move sk to reassembled skb and fix up wmem accounting.+ \*/+ orig\_truesize = skb->truesize;+ destructor = skb->destructor;+ }+ if (head != skb) { fp = skb\_clone(skb, GFP\_ATOMIC);- if (!fp)- return NULL;+ if (!fp) {+ head = skb;+ goto out\_restore\_sk;+ } FRAG\_CB(fp)->next\_frag = FRAG\_CB(skb)->next\_frag; if (RB\_EMPTY\_NODE(&skb->rbnode)) FRAG\_CB(parent)->next\_frag = fp;@@ -463,6 +481,12 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, &q->rb\_fragments); if (q->fragments\_tail == skb) q->fragments\_tail = fp;++ if (orig\_truesize) {+ /\* prevent skb\_morph from releasing sk \*/+ skb->sk = NULL;+ skb->destructor = NULL;+ } skb\_morph(skb, head); FRAG\_CB(skb)->next\_frag = FRAG\_CB(head)->next\_frag; rb\_replace\_node(&head->rbnode, &skb->rbnode,@@ -470,13 +494,13 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, consume\_skb(head); head = skb; }- WARN\_ON(head->ip\_defrag\_offset != 0);+ WARN\_ON(FRAG\_CB(head)->ip\_defrag\_offset != 0);  delta = -head->truesize;  /\* Head of list must not be cloned. \*/ if (skb\_unclone(head, GFP\_ATOMIC))- return NULL;+ goto out\_restore\_sk;  delta += head->truesize; if (delta)@@ -492,7 +516,7 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb,  clone = alloc\_skb(0, GFP\_ATOMIC); if (!clone)- return NULL;+ goto out\_restore\_sk; skb\_shinfo(clone)->frag\_list = skb\_shinfo(head)->frag\_list; skb\_frag\_list\_init(head); for (i = 0; i < skb\_shinfo(head)->nr\_frags; i++)@@ -509,6 +533,21 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, nextp = &skb\_shinfo(head)->frag\_list; } +out\_restore\_sk:+ if (orig\_truesize) {+ int ts\_delta = head->truesize - orig\_truesize;++ /\* if this reassembled skb is fragmented later,+ \* fraglist skbs will get skb->sk assigned from head->sk,+ \* and each frag skb will be released via sock\_wfree.+ \*+ \* Update sk\_wmem\_alloc.+ \*/+ head->sk = sk;+ head->destructor = destructor;+ refcount\_add(ts\_delta, &sk->sk\_wmem\_alloc);+ }+ return nextp; } EXPORT\_SYMBOL(inet\_frag\_reasm\_prepare);@@ -516,6 +555,8 @@ EXPORT\_SYMBOL(inet\_frag\_reasm\_prepare); void inet\_frag\_reasm\_finish(struct inet\_frag\_queue \*q, struct sk\_buff \*head, void \*reasm\_data, bool try\_coalesce) {+ struct sock \*sk = is\_skb\_wmem(head) ? head->sk : NULL;+ const unsigned int head\_truesize = head->truesize; struct sk\_buff \*\*nextp = reasm\_data; struct rb\_node \*rbn; struct sk\_buff \*fp;@@ -579,6 +620,9 @@ void inet\_frag\_reasm\_finish(struct inet\_frag\_queue \*q, struct sk\_buff \*head, head->prev = NULL; head->tstamp = q->stamp; head->mono\_delivery\_time = q->mono\_delivery\_time;++ if (sk)+ refcount\_add(sum\_truesize - head\_truesize, &sk->sk\_wmem\_alloc); } EXPORT\_SYMBOL(inet\_frag\_reasm\_finish); diff --git a/net/ipv4/ip\_fragment.c b/net/ipv4/ip\_fragment.cindex a4941f53b52372..fb947d1613fe2b 100644--- a/[net/ipv4/ip\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/ip_fragment.c?id=40d4b4807cadd83fb3f46cc8cd67a945b5b25461)+++ b/[net/ipv4/ip\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/ip_fragment.c?id=18685451fc4e546fc0e718580d32df3c0e5c8272)@@ -384,6 +384,7 @@ static int ip\_frag\_queue(struct ipq \*qp, struct sk\_buff \*skb) }  skb\_dst\_drop(skb);+ skb\_orphan(skb); return -EINPROGRESS;  insert\_error:@@ -487,7 +488,6 @@ int ip\_defrag(struct net \*net, struct sk\_buff \*skb, u32 user) struct ipq \*qp;  \_\_IP\_INC\_STATS(net, IPSTATS\_MIB\_REASMREQDS);- skb\_orphan(skb);  /\* Lookup (or create) queue header \*/ qp = ip\_find(net, ip\_hdr(skb), user, vif);diff --git a/net/ipv6/netfilter/nf\_conntrack\_reasm.c b/net/ipv6/netfilter/nf\_conntrack\_reasm.cindex 1a51a44571c372..d0dcbaca19943a 100644--- a/[net/ipv6/netfilter/nf\_conntrack\_reasm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/netfilter/nf_conntrack_reasm.c?id=40d4b4807cadd83fb3f46cc8cd67a945b5b25461)+++ b/[net/ipv6/netfilter/nf\_conntrack\_reasm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/netfilter/nf_conntrack_reasm.c?id=18685451fc4e546fc0e718580d32df3c0e5c8272)@@ -294,6 +294,7 @@ static int nf\_ct\_frag6\_queue(struct frag\_queue \*fq, struct sk\_buff \*skb, }  skb\_dst\_drop(skb);+ skb\_orphan(skb); return -EINPROGRESS;  insert\_error:@@ -469,7 +470,6 @@ int nf\_ct\_frag6\_gather(struct net \*net, struct sk\_buff \*skb, u32 user) hdr = ipv6\_hdr(skb); fhdr = (struct frag\_hdr \*)skb\_transport\_header(skb); - skb\_orphan(skb); fq = fq\_find(net, fhdr->identification, user, hdr, skb->dev ? skb->dev->ifindex : 0); if (fq == NULL) { |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 17:48:50 +0000


