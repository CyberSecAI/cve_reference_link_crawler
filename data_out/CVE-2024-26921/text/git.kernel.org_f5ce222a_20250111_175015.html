

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=9705f447bf9a6cd088300ad2c407b5e1c6591091)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=9705f447bf9a6cd088300ad2c407b5e1c6591091)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9705f447bf9a6cd088300ad2c407b5e1c6591091)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9705f447bf9a6cd088300ad2c407b5e1c6591091)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Florian Westphal <fw@strlen.de> | 2024-03-26 11:18:41 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-10-17 15:07:37 +0200 |
| commit | [9705f447bf9a6cd088300ad2c407b5e1c6591091](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9705f447bf9a6cd088300ad2c407b5e1c6591091) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=9705f447bf9a6cd088300ad2c407b5e1c6591091)) | |
| tree | [d605ece2ce96bf7d994536f826d6c6831b5761fb](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=9705f447bf9a6cd088300ad2c407b5e1c6591091) | |
| parent | [0e7814b028cd50b3ff79659d23dfa9da6a1e75e1](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=0e7814b028cd50b3ff79659d23dfa9da6a1e75e1) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9705f447bf9a6cd088300ad2c407b5e1c6591091&id2=0e7814b028cd50b3ff79659d23dfa9da6a1e75e1)) | |
| download | [linux-9705f447bf9a6cd088300ad2c407b5e1c6591091.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-9705f447bf9a6cd088300ad2c407b5e1c6591091.tar.gz) | |

inet: inet\_defrag: prevent sk release while still in usecommit 18685451fc4e546fc0e718580d32df3c0e5c8272 upstream.
ip\_local\_out() and other functions can pass skb->sk as function argument.
If the skb is a fragment and reassembly happens before such function call
returns, the sk must not be released.
This affects skb fragments reassembled via netfilter or similar
modules, e.g. openvswitch or ct\_act.c, when run as part of tx pipeline.
Eric Dumazet made an initial analysis of this bug. Quoting Eric:
Calling ip\_defrag() in output path is also implying skb\_orphan(),
which is buggy because output path relies on sk not disappearing.
A relevant old patch about the issue was :
8282f27449bf ("inet: frag: Always orphan skbs inside ip\_defrag()")
[..]
net/ipv4/ip\_output.c depends on skb->sk being set, and probably to an
inet socket, not an arbitrary one.
If we orphan the packet in ipvlan, then downstream things like FQ
packet scheduler will not work properly.
We need to change ip\_defrag() to only use skb\_orphan() when really
needed, ie whenever frag\_list is going to be used.
Eric suggested to stash sk in fragment queue and made an initial patch.
However there is a problem with this:
If skb is refragmented again right after, ip\_do\_fragment() will copy
head->sk to the new fragments, and sets up destructor to sock\_wfree.
IOW, we have no choice but to fix up sk\_wmem accouting to reflect the
fully reassembled skb, else wmem will underflow.
This change moves the orphan down into the core, to last possible moment.
As ip\_defrag\_offset is aliased with sk\_buff->sk member, we must move the
offset into the FRAG\_CB, else skb->sk gets clobbered.
This allows to delay the orphaning long enough to learn if the skb has
to be queued or if the skb is completing the reasm queue.
In the former case, things work as before, skb is orphaned. This is
safe because skb gets queued/stolen and won't continue past reasm engine.
In the latter case, we will steal the skb->sk reference, reattach it to
the head skb, and fix up wmem accouting when inet\_frag inflates truesize.
Fixes: 7026b1ddb6b8 ("netfilter: Pass socket pointer down through okfn().")
Diagnosed-by: Eric Dumazet <edumazet@google.com>
Reported-by: xingwei lee <xrivendell7@gmail.com>
Reported-by: yue sun <samsun1006219@gmail.com>
Reported-by: syzbot+e5167d7144a62715044c@syzkaller.appspotmail.com
Signed-off-by: Florian Westphal <fw@strlen.de>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Link: [https://lore.kernel.org/r/20240326101845.30836-1-fw@strlen.de](https://lore.kernel.org/r/20240326101845.30836-1-fw%40strlen.de)
Signed-off-by: Paolo Abeni <pabeni@redhat.com>
Signed-off-by: Saeed Mirzamohammadi <saeed.mirzamohammadi@oracle.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=9705f447bf9a6cd088300ad2c407b5e1c6591091)

| -rw-r--r-- | [include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/skbuff.h?id=9705f447bf9a6cd088300ad2c407b5e1c6591091) | 5 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/core/sock\_destructor.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/core/sock_destructor.h?id=9705f447bf9a6cd088300ad2c407b5e1c6591091) | 12 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/ipv4/inet\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv4/inet_fragment.c?id=9705f447bf9a6cd088300ad2c407b5e1c6591091) | 70 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/ipv4/ip\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv4/ip_fragment.c?id=9705f447bf9a6cd088300ad2c407b5e1c6591091) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/ipv6/netfilter/nf\_conntrack\_reasm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv6/netfilter/nf_conntrack_reasm.c?id=9705f447bf9a6cd088300ad2c407b5e1c6591091) | 2 | |  |  |  | | --- | --- | --- | |

5 files changed, 72 insertions, 19 deletions

| diff --git a/include/linux/skbuff.h b/include/linux/skbuff.hindex 31755d496b01d9..31ae4b74d43522 100644--- a/[include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/skbuff.h?id=0e7814b028cd50b3ff79659d23dfa9da6a1e75e1)+++ b/[include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/skbuff.h?id=9705f447bf9a6cd088300ad2c407b5e1c6591091)@@ -733,10 +733,7 @@ struct sk\_buff { struct list\_head list; }; - union {- struct sock \*sk;- int ip\_defrag\_offset;- };+ struct sock \*sk;  union { ktime\_t tstamp;diff --git a/net/core/sock\_destructor.h b/net/core/sock\_destructor.hnew file mode 100644index 00000000000000..2f396e6bfba5a3--- /dev/null+++ b/[net/core/sock\_destructor.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/sock_destructor.h?id=9705f447bf9a6cd088300ad2c407b5e1c6591091)@@ -0,0 +1,12 @@+/\* SPDX-License-Identifier: GPL-2.0-or-later \*/+#ifndef \_NET\_CORE\_SOCK\_DESTRUCTOR\_H+#define \_NET\_CORE\_SOCK\_DESTRUCTOR\_H+#include <net/tcp.h>++static inline bool is\_skb\_wmem(const struct sk\_buff \*skb)+{+ return skb->destructor == sock\_wfree ||+ skb->destructor == \_\_sock\_wfree ||+ (IS\_ENABLED(CONFIG\_INET) && skb->destructor == tcp\_wfree);+}+#endifdiff --git a/net/ipv4/inet\_fragment.c b/net/ipv4/inet\_fragment.cindex e0e8a65d561ec6..12ef3cb26676d2 100644--- a/[net/ipv4/inet\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/inet_fragment.c?id=0e7814b028cd50b3ff79659d23dfa9da6a1e75e1)+++ b/[net/ipv4/inet\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/inet_fragment.c?id=9705f447bf9a6cd088300ad2c407b5e1c6591091)@@ -24,6 +24,8 @@ #include <net/ip.h> #include <net/ipv6.h> +#include "../core/sock\_destructor.h"+ /\* Use skb->cb to track consecutive/adjacent fragments coming at \* the end of the queue. Nodes in the rb-tree queue will \* contain "runs" of one or more adjacent fragments.@@ -39,6 +41,7 @@ struct ipfrag\_skb\_cb { }; struct sk\_buff \*next\_frag; int frag\_run\_len;+ int ip\_defrag\_offset; };  #define FRAG\_CB(skb) ((struct ipfrag\_skb\_cb \*)((skb)->cb))@@ -359,12 +362,12 @@ int inet\_frag\_queue\_insert(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, \*/ if (!last) fragrun\_create(q, skb); /\* First fragment. \*/- else if (last->ip\_defrag\_offset + last->len < end) {+ else if (FRAG\_CB(last)->ip\_defrag\_offset + last->len < end) { /\* This is the common case: skb goes to the end. \*/ /\* Detect and discard overlaps. \*/- if (offset < last->ip\_defrag\_offset + last->len)+ if (offset < FRAG\_CB(last)->ip\_defrag\_offset + last->len) return IPFRAG\_OVERLAP;- if (offset == last->ip\_defrag\_offset + last->len)+ if (offset == FRAG\_CB(last)->ip\_defrag\_offset + last->len) fragrun\_append\_to\_last(q, skb); else fragrun\_create(q, skb);@@ -381,13 +384,13 @@ int inet\_frag\_queue\_insert(struct inet\_frag\_queue \*q, struct sk\_buff \*skb,  parent = \*rbn; curr = rb\_to\_skb(parent);- curr\_run\_end = curr->ip\_defrag\_offset ++ curr\_run\_end = FRAG\_CB(curr)->ip\_defrag\_offset + FRAG\_CB(curr)->frag\_run\_len;- if (end <= curr->ip\_defrag\_offset)+ if (end <= FRAG\_CB(curr)->ip\_defrag\_offset) rbn = &parent->rb\_left; else if (offset >= curr\_run\_end) rbn = &parent->rb\_right;- else if (offset >= curr->ip\_defrag\_offset &&+ else if (offset >= FRAG\_CB(curr)->ip\_defrag\_offset && end <= curr\_run\_end) return IPFRAG\_DUP; else@@ -401,7 +404,7 @@ int inet\_frag\_queue\_insert(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, rb\_insert\_color(&skb->rbnode, &q->rb\_fragments); } - skb->ip\_defrag\_offset = offset;+ FRAG\_CB(skb)->ip\_defrag\_offset = offset;  return IPFRAG\_OK; }@@ -411,13 +414,28 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, struct sk\_buff \*parent) { struct sk\_buff \*fp, \*head = skb\_rb\_first(&q->rb\_fragments);- struct sk\_buff \*\*nextp;+ void (\*destructor)(struct sk\_buff \*);+ unsigned int orig\_truesize = 0;+ struct sk\_buff \*\*nextp = NULL;+ struct sock \*sk = skb->sk; int delta; + if (sk && is\_skb\_wmem(skb)) {+ /\* TX: skb->sk might have been passed as argument to+ \* dst->output and must remain valid until tx completes.+ \*+ \* Move sk to reassembled skb and fix up wmem accounting.+ \*/+ orig\_truesize = skb->truesize;+ destructor = skb->destructor;+ }+ if (head != skb) { fp = skb\_clone(skb, GFP\_ATOMIC);- if (!fp)- return NULL;+ if (!fp) {+ head = skb;+ goto out\_restore\_sk;+ } FRAG\_CB(fp)->next\_frag = FRAG\_CB(skb)->next\_frag; if (RB\_EMPTY\_NODE(&skb->rbnode)) FRAG\_CB(parent)->next\_frag = fp;@@ -426,6 +444,12 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, &q->rb\_fragments); if (q->fragments\_tail == skb) q->fragments\_tail = fp;++ if (orig\_truesize) {+ /\* prevent skb\_morph from releasing sk \*/+ skb->sk = NULL;+ skb->destructor = NULL;+ } skb\_morph(skb, head); FRAG\_CB(skb)->next\_frag = FRAG\_CB(head)->next\_frag; rb\_replace\_node(&head->rbnode, &skb->rbnode,@@ -433,13 +457,13 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, consume\_skb(head); head = skb; }- WARN\_ON(head->ip\_defrag\_offset != 0);+ WARN\_ON(FRAG\_CB(head)->ip\_defrag\_offset != 0);  delta = -head->truesize;  /\* Head of list must not be cloned. \*/ if (skb\_unclone(head, GFP\_ATOMIC))- return NULL;+ goto out\_restore\_sk;  delta += head->truesize; if (delta)@@ -455,7 +479,7 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb,  clone = alloc\_skb(0, GFP\_ATOMIC); if (!clone)- return NULL;+ goto out\_restore\_sk; skb\_shinfo(clone)->frag\_list = skb\_shinfo(head)->frag\_list; skb\_frag\_list\_init(head); for (i = 0; i < skb\_shinfo(head)->nr\_frags; i++)@@ -472,6 +496,21 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, nextp = &skb\_shinfo(head)->frag\_list; } +out\_restore\_sk:+ if (orig\_truesize) {+ int ts\_delta = head->truesize - orig\_truesize;++ /\* if this reassembled skb is fragmented later,+ \* fraglist skbs will get skb->sk assigned from head->sk,+ \* and each frag skb will be released via sock\_wfree.+ \*+ \* Update sk\_wmem\_alloc.+ \*/+ head->sk = sk;+ head->destructor = destructor;+ refcount\_add(ts\_delta, &sk->sk\_wmem\_alloc);+ }+ return nextp; } EXPORT\_SYMBOL(inet\_frag\_reasm\_prepare);@@ -479,6 +518,8 @@ EXPORT\_SYMBOL(inet\_frag\_reasm\_prepare); void inet\_frag\_reasm\_finish(struct inet\_frag\_queue \*q, struct sk\_buff \*head, void \*reasm\_data, bool try\_coalesce) {+ struct sock \*sk = is\_skb\_wmem(head) ? head->sk : NULL;+ const unsigned int head\_truesize = head->truesize; struct sk\_buff \*\*nextp = (struct sk\_buff \*\*)reasm\_data; struct rb\_node \*rbn; struct sk\_buff \*fp;@@ -541,6 +582,9 @@ void inet\_frag\_reasm\_finish(struct inet\_frag\_queue \*q, struct sk\_buff \*head, skb\_mark\_not\_on\_list(head); head->prev = NULL; head->tstamp = q->stamp;++ if (sk)+ refcount\_add(sum\_truesize - head\_truesize, &sk->sk\_wmem\_alloc); } EXPORT\_SYMBOL(inet\_frag\_reasm\_finish); diff --git a/net/ipv4/ip\_fragment.c b/net/ipv4/ip\_fragment.cindex fad803d2d711ef..ec2264adf2a6a5 100644--- a/[net/ipv4/ip\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/ip_fragment.c?id=0e7814b028cd50b3ff79659d23dfa9da6a1e75e1)+++ b/[net/ipv4/ip\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/ip_fragment.c?id=9705f447bf9a6cd088300ad2c407b5e1c6591091)@@ -377,6 +377,7 @@ static int ip\_frag\_queue(struct ipq \*qp, struct sk\_buff \*skb) }  skb\_dst\_drop(skb);+ skb\_orphan(skb); return -EINPROGRESS;  insert\_error:@@ -479,7 +480,6 @@ int ip\_defrag(struct net \*net, struct sk\_buff \*skb, u32 user) struct ipq \*qp;  \_\_IP\_INC\_STATS(net, IPSTATS\_MIB\_REASMREQDS);- skb\_orphan(skb);  /\* Lookup (or create) queue header \*/ qp = ip\_find(net, ip\_hdr(skb), user, vif);diff --git a/net/ipv6/netfilter/nf\_conntrack\_reasm.c b/net/ipv6/netfilter/nf\_conntrack\_reasm.cindex c129ad334eb392..8c2163f95711ce 100644--- a/[net/ipv6/netfilter/nf\_conntrack\_reasm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/netfilter/nf_conntrack_reasm.c?id=0e7814b028cd50b3ff79659d23dfa9da6a1e75e1)+++ b/[net/ipv6/netfilter/nf\_conntrack\_reasm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/netfilter/nf_conntrack_reasm.c?id=9705f447bf9a6cd088300ad2c407b5e1c6591091)@@ -296,6 +296,7 @@ static int nf\_ct\_frag6\_queue(struct frag\_queue \*fq, struct sk\_buff \*skb, }  skb\_dst\_drop(skb);+ skb\_orphan(skb); return -EINPROGRESS;  insert\_error:@@ -471,7 +472,6 @@ int nf\_ct\_frag6\_gather(struct net \*net, struct sk\_buff \*skb, u32 user) hdr = ipv6\_hdr(skb); fhdr = (struct frag\_hdr \*)skb\_transport\_header(skb); - skb\_orphan(skb); fq = fq\_find(net, fhdr->identification, user, hdr, skb->dev ? skb->dev->ifindex : 0); if (fq == NULL) { |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 17:48:52 +0000

