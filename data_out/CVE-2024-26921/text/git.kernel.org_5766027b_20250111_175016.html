

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=f4877225313d474659ee53150ccc3d553a978727)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f4877225313d474659ee53150ccc3d553a978727)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f4877225313d474659ee53150ccc3d553a978727)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f4877225313d474659ee53150ccc3d553a978727)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Florian Westphal <fw@strlen.de> | 2024-03-26 11:18:41 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-04-10 16:35:44 +0200 |
| commit | [f4877225313d474659ee53150ccc3d553a978727](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f4877225313d474659ee53150ccc3d553a978727) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=f4877225313d474659ee53150ccc3d553a978727)) | |
| tree | [66bcbde576604635d1de12f2eb4ce8ef600c9ef3](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f4877225313d474659ee53150ccc3d553a978727) | |
| parent | [54720f68c4ad0ffb5a776e7a14b25f02242068cb](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=54720f68c4ad0ffb5a776e7a14b25f02242068cb) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f4877225313d474659ee53150ccc3d553a978727&id2=54720f68c4ad0ffb5a776e7a14b25f02242068cb)) | |
| download | [linux-f4877225313d474659ee53150ccc3d553a978727.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-f4877225313d474659ee53150ccc3d553a978727.tar.gz) | |

inet: inet\_defrag: prevent sk release while still in use[ Upstream commit 18685451fc4e546fc0e718580d32df3c0e5c8272 ]
ip\_local\_out() and other functions can pass skb->sk as function argument.
If the skb is a fragment and reassembly happens before such function call
returns, the sk must not be released.
This affects skb fragments reassembled via netfilter or similar
modules, e.g. openvswitch or ct\_act.c, when run as part of tx pipeline.
Eric Dumazet made an initial analysis of this bug. Quoting Eric:
Calling ip\_defrag() in output path is also implying skb\_orphan(),
which is buggy because output path relies on sk not disappearing.
A relevant old patch about the issue was :
8282f27449bf ("inet: frag: Always orphan skbs inside ip\_defrag()")
[..]
net/ipv4/ip\_output.c depends on skb->sk being set, and probably to an
inet socket, not an arbitrary one.
If we orphan the packet in ipvlan, then downstream things like FQ
packet scheduler will not work properly.
We need to change ip\_defrag() to only use skb\_orphan() when really
needed, ie whenever frag\_list is going to be used.
Eric suggested to stash sk in fragment queue and made an initial patch.
However there is a problem with this:
If skb is refragmented again right after, ip\_do\_fragment() will copy
head->sk to the new fragments, and sets up destructor to sock\_wfree.
IOW, we have no choice but to fix up sk\_wmem accouting to reflect the
fully reassembled skb, else wmem will underflow.
This change moves the orphan down into the core, to last possible moment.
As ip\_defrag\_offset is aliased with sk\_buff->sk member, we must move the
offset into the FRAG\_CB, else skb->sk gets clobbered.
This allows to delay the orphaning long enough to learn if the skb has
to be queued or if the skb is completing the reasm queue.
In the former case, things work as before, skb is orphaned. This is
safe because skb gets queued/stolen and won't continue past reasm engine.
In the latter case, we will steal the skb->sk reference, reattach it to
the head skb, and fix up wmem accouting when inet\_frag inflates truesize.
Fixes: 7026b1ddb6b8 ("netfilter: Pass socket pointer down through okfn().")
Diagnosed-by: Eric Dumazet <edumazet@google.com>
Reported-by: xingwei lee <xrivendell7@gmail.com>
Reported-by: yue sun <samsun1006219@gmail.com>
Reported-by: syzbot+e5167d7144a62715044c@syzkaller.appspotmail.com
Signed-off-by: Florian Westphal <fw@strlen.de>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Link: [https://lore.kernel.org/r/20240326101845.30836-1-fw@strlen.de](https://lore.kernel.org/r/20240326101845.30836-1-fw%40strlen.de)
Signed-off-by: Paolo Abeni <pabeni@redhat.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f4877225313d474659ee53150ccc3d553a978727)

| -rw-r--r-- | [include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/skbuff.h?id=f4877225313d474659ee53150ccc3d553a978727) | 7 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/ipv4/inet\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv4/inet_fragment.c?id=f4877225313d474659ee53150ccc3d553a978727) | 70 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/ipv4/ip\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv4/ip_fragment.c?id=f4877225313d474659ee53150ccc3d553a978727) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/ipv6/netfilter/nf\_conntrack\_reasm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv6/netfilter/nf_conntrack_reasm.c?id=f4877225313d474659ee53150ccc3d553a978727) | 2 | |  |  |  | | --- | --- | --- | |

4 files changed, 60 insertions, 21 deletions

| diff --git a/include/linux/skbuff.h b/include/linux/skbuff.hindex 2922059908cc57..9e61f6df6bc55f 100644--- a/[include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/skbuff.h?id=54720f68c4ad0ffb5a776e7a14b25f02242068cb)+++ b/[include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/skbuff.h?id=f4877225313d474659ee53150ccc3d553a978727)@@ -736,8 +736,6 @@ typedef unsigned char \*sk\_buff\_data\_t; \* @list: queue head \* @ll\_node: anchor in an llist (eg socket defer\_list) \* @sk: Socket we are owned by- \* @ip\_defrag\_offset: (aka @sk) alternate use of @sk, used in- \* fragmentation management \* @dev: Device we arrived on/are leaving by \* @dev\_scratch: (aka @dev) alternate use of @dev when @dev would be %NULL \* @cb: Control buffer. Free for use by every layer. Put private vars here@@ -860,10 +858,7 @@ struct sk\_buff { struct llist\_node ll\_node; }; - union {- struct sock \*sk;- int ip\_defrag\_offset;- };+ struct sock \*sk;  union { ktime\_t tstamp;diff --git a/net/ipv4/inet\_fragment.c b/net/ipv4/inet\_fragment.cindex 7072fc0783ef56..c88c9034d63004 100644--- a/[net/ipv4/inet\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/inet_fragment.c?id=54720f68c4ad0ffb5a776e7a14b25f02242068cb)+++ b/[net/ipv4/inet\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/inet_fragment.c?id=f4877225313d474659ee53150ccc3d553a978727)@@ -24,6 +24,8 @@ #include <net/ip.h> #include <net/ipv6.h> +#include "../core/sock\_destructor.h"+ /\* Use skb->cb to track consecutive/adjacent fragments coming at \* the end of the queue. Nodes in the rb-tree queue will \* contain "runs" of one or more adjacent fragments.@@ -39,6 +41,7 @@ struct ipfrag\_skb\_cb { }; struct sk\_buff \*next\_frag; int frag\_run\_len;+ int ip\_defrag\_offset; };  #define FRAG\_CB(skb) ((struct ipfrag\_skb\_cb \*)((skb)->cb))@@ -396,12 +399,12 @@ int inet\_frag\_queue\_insert(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, \*/ if (!last) fragrun\_create(q, skb); /\* First fragment. \*/- else if (last->ip\_defrag\_offset + last->len < end) {+ else if (FRAG\_CB(last)->ip\_defrag\_offset + last->len < end) { /\* This is the common case: skb goes to the end. \*/ /\* Detect and discard overlaps. \*/- if (offset < last->ip\_defrag\_offset + last->len)+ if (offset < FRAG\_CB(last)->ip\_defrag\_offset + last->len) return IPFRAG\_OVERLAP;- if (offset == last->ip\_defrag\_offset + last->len)+ if (offset == FRAG\_CB(last)->ip\_defrag\_offset + last->len) fragrun\_append\_to\_last(q, skb); else fragrun\_create(q, skb);@@ -418,13 +421,13 @@ int inet\_frag\_queue\_insert(struct inet\_frag\_queue \*q, struct sk\_buff \*skb,  parent = \*rbn; curr = rb\_to\_skb(parent);- curr\_run\_end = curr->ip\_defrag\_offset ++ curr\_run\_end = FRAG\_CB(curr)->ip\_defrag\_offset + FRAG\_CB(curr)->frag\_run\_len;- if (end <= curr->ip\_defrag\_offset)+ if (end <= FRAG\_CB(curr)->ip\_defrag\_offset) rbn = &parent->rb\_left; else if (offset >= curr\_run\_end) rbn = &parent->rb\_right;- else if (offset >= curr->ip\_defrag\_offset &&+ else if (offset >= FRAG\_CB(curr)->ip\_defrag\_offset && end <= curr\_run\_end) return IPFRAG\_DUP; else@@ -438,7 +441,7 @@ int inet\_frag\_queue\_insert(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, rb\_insert\_color(&skb->rbnode, &q->rb\_fragments); } - skb->ip\_defrag\_offset = offset;+ FRAG\_CB(skb)->ip\_defrag\_offset = offset;  return IPFRAG\_OK; }@@ -448,13 +451,28 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, struct sk\_buff \*parent) { struct sk\_buff \*fp, \*head = skb\_rb\_first(&q->rb\_fragments);- struct sk\_buff \*\*nextp;+ void (\*destructor)(struct sk\_buff \*);+ unsigned int orig\_truesize = 0;+ struct sk\_buff \*\*nextp = NULL;+ struct sock \*sk = skb->sk; int delta; + if (sk && is\_skb\_wmem(skb)) {+ /\* TX: skb->sk might have been passed as argument to+ \* dst->output and must remain valid until tx completes.+ \*+ \* Move sk to reassembled skb and fix up wmem accounting.+ \*/+ orig\_truesize = skb->truesize;+ destructor = skb->destructor;+ }+ if (head != skb) { fp = skb\_clone(skb, GFP\_ATOMIC);- if (!fp)- return NULL;+ if (!fp) {+ head = skb;+ goto out\_restore\_sk;+ } FRAG\_CB(fp)->next\_frag = FRAG\_CB(skb)->next\_frag; if (RB\_EMPTY\_NODE(&skb->rbnode)) FRAG\_CB(parent)->next\_frag = fp;@@ -463,6 +481,12 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, &q->rb\_fragments); if (q->fragments\_tail == skb) q->fragments\_tail = fp;++ if (orig\_truesize) {+ /\* prevent skb\_morph from releasing sk \*/+ skb->sk = NULL;+ skb->destructor = NULL;+ } skb\_morph(skb, head); FRAG\_CB(skb)->next\_frag = FRAG\_CB(head)->next\_frag; rb\_replace\_node(&head->rbnode, &skb->rbnode,@@ -470,13 +494,13 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, consume\_skb(head); head = skb; }- WARN\_ON(head->ip\_defrag\_offset != 0);+ WARN\_ON(FRAG\_CB(head)->ip\_defrag\_offset != 0);  delta = -head->truesize;  /\* Head of list must not be cloned. \*/ if (skb\_unclone(head, GFP\_ATOMIC))- return NULL;+ goto out\_restore\_sk;  delta += head->truesize; if (delta)@@ -492,7 +516,7 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb,  clone = alloc\_skb(0, GFP\_ATOMIC); if (!clone)- return NULL;+ goto out\_restore\_sk; skb\_shinfo(clone)->frag\_list = skb\_shinfo(head)->frag\_list; skb\_frag\_list\_init(head); for (i = 0; i < skb\_shinfo(head)->nr\_frags; i++)@@ -509,6 +533,21 @@ void \*inet\_frag\_reasm\_prepare(struct inet\_frag\_queue \*q, struct sk\_buff \*skb, nextp = &skb\_shinfo(head)->frag\_list; } +out\_restore\_sk:+ if (orig\_truesize) {+ int ts\_delta = head->truesize - orig\_truesize;++ /\* if this reassembled skb is fragmented later,+ \* fraglist skbs will get skb->sk assigned from head->sk,+ \* and each frag skb will be released via sock\_wfree.+ \*+ \* Update sk\_wmem\_alloc.+ \*/+ head->sk = sk;+ head->destructor = destructor;+ refcount\_add(ts\_delta, &sk->sk\_wmem\_alloc);+ }+ return nextp; } EXPORT\_SYMBOL(inet\_frag\_reasm\_prepare);@@ -516,6 +555,8 @@ EXPORT\_SYMBOL(inet\_frag\_reasm\_prepare); void inet\_frag\_reasm\_finish(struct inet\_frag\_queue \*q, struct sk\_buff \*head, void \*reasm\_data, bool try\_coalesce) {+ struct sock \*sk = is\_skb\_wmem(head) ? head->sk : NULL;+ const unsigned int head\_truesize = head->truesize; struct sk\_buff \*\*nextp = reasm\_data; struct rb\_node \*rbn; struct sk\_buff \*fp;@@ -579,6 +620,9 @@ void inet\_frag\_reasm\_finish(struct inet\_frag\_queue \*q, struct sk\_buff \*head, head->prev = NULL; head->tstamp = q->stamp; head->mono\_delivery\_time = q->mono\_delivery\_time;++ if (sk)+ refcount\_add(sum\_truesize - head\_truesize, &sk->sk\_wmem\_alloc); } EXPORT\_SYMBOL(inet\_frag\_reasm\_finish); diff --git a/net/ipv4/ip\_fragment.c b/net/ipv4/ip\_fragment.cindex a4941f53b52372..fb947d1613fe2b 100644--- a/[net/ipv4/ip\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/ip_fragment.c?id=54720f68c4ad0ffb5a776e7a14b25f02242068cb)+++ b/[net/ipv4/ip\_fragment.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/ip_fragment.c?id=f4877225313d474659ee53150ccc3d553a978727)@@ -384,6 +384,7 @@ static int ip\_frag\_queue(struct ipq \*qp, struct sk\_buff \*skb) }  skb\_dst\_drop(skb);+ skb\_orphan(skb); return -EINPROGRESS;  insert\_error:@@ -487,7 +488,6 @@ int ip\_defrag(struct net \*net, struct sk\_buff \*skb, u32 user) struct ipq \*qp;  \_\_IP\_INC\_STATS(net, IPSTATS\_MIB\_REASMREQDS);- skb\_orphan(skb);  /\* Lookup (or create) queue header \*/ qp = ip\_find(net, ip\_hdr(skb), user, vif);diff --git a/net/ipv6/netfilter/nf\_conntrack\_reasm.c b/net/ipv6/netfilter/nf\_conntrack\_reasm.cindex b2dd48911c8d62..efbec7ee27d0a0 100644--- a/[net/ipv6/netfilter/nf\_conntrack\_reasm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/netfilter/nf_conntrack_reasm.c?id=54720f68c4ad0ffb5a776e7a14b25f02242068cb)+++ b/[net/ipv6/netfilter/nf\_conntrack\_reasm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/netfilter/nf_conntrack_reasm.c?id=f4877225313d474659ee53150ccc3d553a978727)@@ -294,6 +294,7 @@ static int nf\_ct\_frag6\_queue(struct frag\_queue \*fq, struct sk\_buff \*skb, }  skb\_dst\_drop(skb);+ skb\_orphan(skb); return -EINPROGRESS;  insert\_error:@@ -469,7 +470,6 @@ int nf\_ct\_frag6\_gather(struct net \*net, struct sk\_buff \*skb, u32 user) hdr = ipv6\_hdr(skb); fhdr = (struct frag\_hdr \*)skb\_transport\_header(skb); - skb\_orphan(skb); fq = fq\_find(net, fhdr->identification, user, hdr, skb->dev ? skb->dev->ifindex : 0); if (fq == NULL) { |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 17:48:54 +0000

