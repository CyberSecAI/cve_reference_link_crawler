
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fquinn-rs%2Fquinn%2Fblob%2Fbb02a12a8435a7732a1d762783eeacbb7e50418e%2Fquinn-proto%2Fsrc%2Fendpoint.rs)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fquinn-rs%2Fquinn%2Fblob%2Fbb02a12a8435a7732a1d762783eeacbb7e50418e%2Fquinn-proto%2Fsrc%2Fendpoint.rs)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=quinn-rs%2Fquinn)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[quinn-rs](/quinn-rs)
/
**[quinn](/quinn-rs/quinn)**
Public

* [Notifications](/login?return_to=%2Fquinn-rs%2Fquinn) You must be signed in to change notification settings
* [Fork
  404](/login?return_to=%2Fquinn-rs%2Fquinn)
* [Star
   4k](/login?return_to=%2Fquinn-rs%2Fquinn)

* [Code](/quinn-rs/quinn)
* [Issues
  100](/quinn-rs/quinn/issues)
* [Pull requests
  18](/quinn-rs/quinn/pulls)
* [Actions](/quinn-rs/quinn/actions)
* [Projects
  0](/quinn-rs/quinn/projects)
* [Security](/quinn-rs/quinn/security)
* [Insights](/quinn-rs/quinn/pulse)

Additional navigation options

* [Code](/quinn-rs/quinn)
* [Issues](/quinn-rs/quinn/issues)
* [Pull requests](/quinn-rs/quinn/pulls)
* [Actions](/quinn-rs/quinn/actions)
* [Projects](/quinn-rs/quinn/projects)
* [Security](/quinn-rs/quinn/security)
* [Insights](/quinn-rs/quinn/pulse)

## Files

 bb02a12
## Breadcrumbs

1. [quinn](/quinn-rs/quinn/tree/bb02a12a8435a7732a1d762783eeacbb7e50418e)
2. /[quinn-proto](/quinn-rs/quinn/tree/bb02a12a8435a7732a1d762783eeacbb7e50418e/quinn-proto)
3. /[src](/quinn-rs/quinn/tree/bb02a12a8435a7732a1d762783eeacbb7e50418e/quinn-proto/src)
/
# endpoint.rs

 Blame  Blame
## Latest commit

## History

[History](/quinn-rs/quinn/commits/bb02a12a8435a7732a1d762783eeacbb7e50418e/quinn-proto/src/endpoint.rs)1333 lines (1220 loc) · 47 KB bb02a12
## Breadcrumbs

1. [quinn](/quinn-rs/quinn/tree/bb02a12a8435a7732a1d762783eeacbb7e50418e)
2. /[quinn-proto](/quinn-rs/quinn/tree/bb02a12a8435a7732a1d762783eeacbb7e50418e/quinn-proto)
3. /[src](/quinn-rs/quinn/tree/bb02a12a8435a7732a1d762783eeacbb7e50418e/quinn-proto/src)
/
# endpoint.rs

Top
## File metadata and controls

* Code
* Blame

1333 lines (1220 loc) · 47 KB[Raw](https://github.com/quinn-rs/quinn/raw/bb02a12a8435a7732a1d762783eeacbb7e50418e/quinn-proto/src/endpoint.rs)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000use std::{ collections::{hash\_map, HashMap}, convert::TryFrom, fmt, mem, net::{IpAddr, SocketAddr}, ops::{Index, IndexMut}, sync::Arc, time::{Instant, SystemTime},};
use bytes::{BufMut, Bytes, BytesMut};use rand::{rngs::StdRng, Rng, RngCore, SeedableRng};use rustc\_hash::FxHashMap;use slab::Slab;use thiserror::Error;use tracing::{debug, error, trace, warn};
use crate::{ cid\_generator::ConnectionIdGenerator, coding::BufMutExt, config::{ClientConfig, EndpointConfig, ServerConfig}, connection::{Connection, ConnectionError}, crypto::{self, Keys, UnsupportedVersion}, frame, packet::{ FixedLengthConnectionIdParser, Header, InitialHeader, InitialPacket, Packet, PacketDecodeError, PacketNumber, PartialDecode, ProtectedInitialHeader, }, shared::{ ConnectionEvent, ConnectionEventInner, ConnectionId, DatagramConnectionEvent, EcnCodepoint, EndpointEvent, EndpointEventInner, IssuedCid, }, token::TokenDecodeError, transport\_parameters::{PreferredAddress, TransportParameters}, ResetToken, RetryToken, Side, Transmit, TransportConfig, TransportError, INITIAL\_MTU, MAX\_CID\_SIZE, MIN\_INITIAL\_SIZE, RESET\_TOKEN\_SIZE,};
/// The main entry point to the library////// This object performs no I/O whatsoever. Instead, it consumes incoming packets and/// connection-generated events via `handle` and `handle\_event`.pub struct Endpoint { rng: StdRng, index: ConnectionIndex, connections: Slab<ConnectionMeta>, local\_cid\_generator: Box<dyn ConnectionIdGenerator>, config: Arc<EndpointConfig>, server\_config: Option<Arc<ServerConfig>>, /// Whether the underlying UDP socket promises not to fragment packets allow\_mtud: bool, /// Time at which a stateless reset was most recently sent last\_stateless\_reset: Option<Instant>, /// Buffered Initial and 0-RTT messages for pending incoming connections incoming\_buffers: Slab<IncomingBuffer>, all\_incoming\_buffers\_total\_bytes: u64,}
impl Endpoint { /// Create a new endpoint /// /// `allow\_mtud` enables path MTU detection when requested by `Connection` configuration for /// better performance. This requires that outgoing packets are never fragmented, which can be /// achieved via e.g. the `IPV6\_DONTFRAG` socket option. /// /// If `rng\_seed` is provided, it will be used to initialize the endpoint's rng (having priority /// over the rng seed configured in [`EndpointConfig`]). Note that the `rng\_seed` parameter will /// be removed in a future release, so prefer setting it to `None` and configuring rng seeds /// using [`EndpointConfig::rng\_seed`]. pub fn new( config: Arc<EndpointConfig>, server\_config: Option<Arc<ServerConfig>>, allow\_mtud: bool, rng\_seed: Option<[u8; 32]>, ) -> Self { let rng\_seed = rng\_seed.or(config.rng\_seed); Self { rng: rng\_seed.map\_or(StdRng::from\_entropy(), StdRng::from\_seed), index: ConnectionIndex::default(), connections: Slab::new(), local\_cid\_generator: (config.connection\_id\_generator\_factory.as\_ref())(), config, server\_config, allow\_mtud, last\_stateless\_reset: None, incoming\_buffers: Slab::new(), all\_incoming\_buffers\_total\_bytes: 0, } }
 /// Replace the server configuration, affecting new incoming connections only pub fn set\_server\_config(&mut self, server\_config: Option<Arc<ServerConfig>>) { self.server\_config = server\_config; }
 /// Process `EndpointEvent`s emitted from related `Connection`s /// /// In turn, processing this event may return a `ConnectionEvent` for the same `Connection`. pub fn handle\_event( &mut self, ch: ConnectionHandle, event: EndpointEvent, ) -> Option<ConnectionEvent> { use EndpointEventInner::\*; match event.0 { NeedIdentifiers(now, n) => { return Some(self.send\_new\_identifiers(now, ch, n)); } ResetToken(remote, token) => { if let Some(old) = self.connections[ch].reset\_token.replace((remote, token)) { self.index.connection\_reset\_tokens.remove(old.0, old.1); } if self.index.connection\_reset\_tokens.insert(remote, token, ch) { warn!("duplicate reset token"); } } RetireConnectionId(now, seq, allow\_more\_cids) => { if let Some(cid) = self.connections[ch].loc\_cids.remove(&seq) { trace!("peer retired CID {}: {}", seq, cid); self.index.retire(&cid); if allow\_more\_cids { return Some(self.send\_new\_identifiers(now, ch, 1)); } } } Drained => { if let Some(conn) = self.connections.try\_remove(ch.0) { self.index.remove(&conn); } else { // This indicates a bug in downstream code, which could cause spurious // connection loss instead of this error if the CID was (re)allocated prior to // the illegal call. error!(id = ch.0, "unknown connection drained"); } } } None }
 /// Process an incoming UDP datagram pub fn handle( &mut self, now: Instant, remote: SocketAddr, local\_ip: Option<IpAddr>, ecn: Option<EcnCodepoint>, data: BytesMut, buf: &mut Vec<u8>, ) -> Option<DatagramEvent> { let datagram\_len = data.len(); let (first\_decode, remaining) = match PartialDecode::new( data, &FixedLengthConnectionIdParser::new(self.local\_cid\_generator.cid\_len()), &self.config.supported\_versions, self.config.grease\_quic\_bit, ) { Ok(x) => x, Err(PacketDecodeError::UnsupportedVersion { src\_cid, dst\_cid, version, }) => { if self.server\_config.is\_none() { debug!("dropping packet with unsupported version"); return None; } trace!("sending version negotiation"); // Negotiate versions Header::VersionNegotiate { random: self.rng.gen::<u8>() | 0x40, src\_cid: dst\_cid, dst\_cid: src\_cid, } .encode(buf); // Grease with a reserved version if version != 0x0a1a\_2a3a { buf.write::<u32>(0x0a1a\_2a3a); } else { buf.write::<u32>(0x0a1a\_2a4a); } for &version in &self.config.supported\_versions { buf.write(version); } return Some(DatagramEvent::Response(Transmit { destination: remote, ecn: None, size: buf.len(), segment\_size: None, src\_ip: local\_ip, })); } Err(e) => { trace!("malformed header: {}", e); return None; } };
 // // Handle packet on existing connection, if any //
 let addresses = FourTuple { remote, local\_ip }; if let Some(route\_to) = self.index.get(&addresses, &first\_decode) { let event = DatagramConnectionEvent { now, remote: addresses.remote, ecn, first\_decode, remaining, }; match route\_to { RouteDatagramTo::Incoming(incoming\_idx) => { let incoming\_buffer = &mut self.incoming\_buffers[incoming\_idx]; let config = &self.server\_config.as\_ref().unwrap();
 if incoming\_buffer .total\_bytes .checked\_add(datagram\_len as u64) .map\_or(false, |n| n <= config.incoming\_buffer\_size) && self .all\_incoming\_buffers\_total\_bytes .checked\_add(datagram\_len as u64) .map\_or(false, |n| n <= config.incoming\_buffer\_size\_total) { incoming\_buffer.datagrams.push(event); incoming\_buffer.total\_bytes += datagram\_len as u64; self.all\_incoming\_buffers\_total\_bytes += datagram\_len as u64; }
 return None; } RouteDatagramTo::Connection(ch) => { return Some(DatagramEvent::ConnectionEvent( ch, ConnectionEvent(ConnectionEventInner::Datagram(event)), )) } } }
 // // Potentially create a new connection //
 let dst\_cid = first\_decode.dst\_cid(); let server\_config = match &self.server\_config { Some(config) => config, None => { debug!("packet for unrecognized connection {}", dst\_cid); return self .stateless\_reset(now, datagram\_len, addresses, dst\_cid, buf) .map(DatagramEvent::Response); } };
 if let Some(header) = first\_decode.initial\_header() { if datagram\_len < MIN\_INITIAL\_SIZE as usize { debug!("ignoring short initial for connection {}", dst\_cid); return None; }
 let crypto = match server\_config.crypto.initial\_keys(header.version, dst\_cid) { Ok(keys) => keys, Err(UnsupportedVersion) => { // This probably indicates that the user set supported\_versions incorrectly in // `EndpointConfig`. debug!( "ignoring initial packet version {:#x} unsupported by cryptographic layer", header.version ); return None; } };
 if let Err(reason) = self.early\_validate\_first\_packet(header) { return Some(DatagramEvent::Response(self.initial\_close( header.version, addresses, &crypto, &header.src\_cid, reason, buf, ))); }
 return match first\_decode.finish(Some(&\*crypto.header.remote)) { Ok(packet) => { self.handle\_first\_packet(addresses, ecn, packet, remaining, crypto, buf) } Err(e) => { trace!("unable to decode initial packet: {}", e); None } }; } else if first\_decode.has\_long\_header() { debug!( "ignoring non-initial packet for unknown connection {}", dst\_cid ); return None; }
 // // If we got this far, we're a server receiving a seemingly valid packet for an unknown // connection. Send a stateless reset if possible. //
 if !first\_decode.is\_initial() && self .local\_cid\_generator .validate(first\_decode.dst\_cid()) .is\_err() { debug!("dropping packet with invalid CID"); return None; }
 if !dst\_cid.is\_empty() { return self .stateless\_reset(now, datagram\_len, addresses, dst\_cid, buf) .map(DatagramEvent::Response); }
 trace!("dropping unrecognized short packet without ID"); None }
 fn stateless\_reset( &mut self, now: Instant, inciting\_dgram\_len: usize, addresses: FourTuple, dst\_cid: &ConnectionId, buf: &mut Vec<u8>, ) -> Option<Transmit> { if self .last\_stateless\_reset .map\_or(false, |last| last + self.config.min\_reset\_interval > now) { debug!("ignoring unexpected packet within minimum stateless reset interval"); return None; }
 /// Minimum amount of padding for the stateless reset to look like a short-header packet const MIN\_PADDING\_LEN: usize = 5;
 // Prevent amplification attacks and reset loops by ensuring we pad to at most 1 byte // smaller than the inciting packet. let max\_padding\_len = match inciting\_dgram\_len.checked\_sub(RESET\_TOKEN\_SIZE) { Some(headroom) if headroom > MIN\_PADDING\_LEN => headroom - 1, \_ => { debug!("ignoring unexpected {} byte packet: not larger than minimum stateless reset size", inciting\_dgram\_len); return None; } };
 debug!( "sending stateless reset for {} to {}", dst\_cid, addresses.remote ); self.last\_stateless\_reset = Some(now); // Resets with at least this much padding can't possibly be distinguished from real packets const IDEAL\_MIN\_PADDING\_LEN: usize = MIN\_PADDING\_LEN + MAX\_CID\_SIZE; let padding\_len = if max\_padding\_len <= IDEAL\_MIN\_PADDING\_LEN { max\_padding\_len } else { self.rng.gen\_range(IDEAL\_MIN\_PADDING\_LEN..max\_padding\_len) }; buf.reserve(padding\_len + RESET\_TOKEN\_SIZE); buf.resize(padding\_len, 0); self.rng.fill\_bytes(&mut buf[0..padding\_len]); buf[0] = 0b0100\_0000 | buf[0] >> 2; buf.extend\_from\_slice(&ResetToken::new(&\*self.config.reset\_key, dst\_cid));
 debug\_assert!(buf.len() < inciting\_dgram\_len);
 Some(Transmit { destination: addresses.remote, ecn: None, size: buf.len(), segment\_size: None, src\_ip: addresses.local\_ip, }) }
 /// Initiate a connection pub fn connect( &mut self, now: Instant, config: ClientConfig, remote: SocketAddr, server\_name: &str, ) -> Result<(ConnectionHandle, Connection), ConnectError> { if self.cids\_exhausted() { return Err(ConnectError::CidsExhausted); } if remote.port() == 0 || remote.ip().is\_unspecified() { return Err(ConnectError::InvalidRemoteAddress(remote)); } if !self.config.supported\_versions.contains(&config.version) { return Err(ConnectError::UnsupportedVersion); }
 let remote\_id = (config.initial\_dst\_cid\_provider)(); trace!(initial\_dcid = %remote\_id);
 let ch = ConnectionHandle(self.connections.vacant\_key()); let loc\_cid = self.new\_cid(ch); let params = TransportParameters::new( &config.transport, &self.config, self.local\_cid\_generator.as\_ref(), loc\_cid, None, ); let tls = config .crypto .start\_session(config.version, server\_name, &params)?;
 let conn = self.add\_connection( ch, config.version, remote\_id, loc\_cid, remote\_id, None, FourTuple { remote, local\_ip: None, }, now, tls, None, config.transport, true, ); Ok((ch, conn)) }
 fn send\_new\_identifiers( &mut self, now: Instant, ch: ConnectionHandle, num: u64, ) -> ConnectionEvent { let mut ids = vec![]; for \_ in 0..num { let id = self.new\_cid(ch); let meta = &mut self.connections[ch]; let sequence = meta.cids\_issued; meta.cids\_issued += 1; meta.loc\_cids.insert(sequence, id); ids.push(IssuedCid { sequence, id, reset\_token: ResetToken::new(&\*self.config.reset\_key, &id), }); } ConnectionEvent(ConnectionEventInner::NewIdentifiers(ids, now)) }
 /// Generate a connection ID for `ch` fn new\_cid(&mut self, ch: ConnectionHandle) -> ConnectionId { loop { let cid = self.local\_cid\_generator.generate\_cid(); if cid.len() == 0 { // Zero-length CID; nothing to track debug\_assert\_eq!(self.local\_cid\_generator.cid\_len(), 0); return cid; } if let hash\_map::Entry::Vacant(e) = self.index.connection\_ids.entry(cid) { e.insert(ch); break cid; } } }
 fn handle\_first\_packet( &mut self, addresses: FourTuple, ecn: Option<EcnCodepoint>, packet: Packet, rest: Option<BytesMut>, crypto: Keys, buf: &mut Vec<u8>, ) -> Option<DatagramEvent> { if !packet.reserved\_bits\_valid() { debug!("dropping connection attempt with invalid reserved bits"); return None; }
 let Header::Initial(header) = packet.header else { panic!("non-initial packet in handle\_first\_packet()"); };
 let server\_config = self.server\_config.as\_ref().unwrap().clone();
 let (retry\_src\_cid, orig\_dst\_cid) = if header.token.is\_empty() { (None, header.dst\_cid) } else { match RetryToken::from\_bytes( &\*server\_config.token\_key, &addresses.remote, &header.dst\_cid, &header.token, ) { Ok(token) if token.issued + server\_config.retry\_token\_lifetime > SystemTime::now() => { (Some(header.dst\_cid), token.orig\_dst\_cid) } Err(TokenDecodeError::UnknownToken) => { // Token may have been generated by an incompatible endpoint, e.g. a // different version or a neighbor behind the same load balancer. We // can't interpret it, so we proceed as if there was no token. (None, header.dst\_cid) } \_ => { debug!("rejecting invalid stateless retry token"); return Some(DatagramEvent::Response(self.initial\_close( header.version, addresses, &crypto, &header.src\_cid, TransportError::INVALID\_TOKEN(""), buf, ))); } } };
 let incoming\_idx = self.incoming\_buffers.insert(IncomingBuffer::default()); self.index .insert\_initial\_incoming(header.dst\_cid, incoming\_idx);
 Some(DatagramEvent::NewConnection(Incoming { addresses, ecn, packet: InitialPacket { header, header\_data: packet.header\_data, payload: packet.payload, }, rest, crypto, retry\_src\_cid, orig\_dst\_cid, incoming\_idx, improper\_drop\_warner: IncomingImproperDropWarner, })) }
 /// Attempt to accept this incoming connection (an error may still occur) pub fn accept( &mut self, mut incoming: Incoming, now: Instant, buf: &mut Vec<u8>, server\_config: Option<Arc<ServerConfig>>, ) -> Result<(ConnectionHandle, Connection), AcceptError> { let remote\_address\_validated = incoming.remote\_address\_validated(); incoming.improper\_drop\_warner.dismiss(); let incoming\_buffer = self.incoming\_buffers.remove(incoming.incoming\_idx); self.all\_incoming\_buffers\_total\_bytes -= incoming\_buffer.total\_bytes;
 let packet\_number = incoming.packet.header.number.expand(0); let InitialHeader { src\_cid, dst\_cid, version, .. } = incoming.packet.header;
 if self.cids\_exhausted() { debug!("refusing connection"); self.index.remove\_initial(incoming.orig\_dst\_cid); return Err(AcceptError { cause: ConnectionError::CidsExhausted, response: Some(self.initial\_close( version, incoming.addresses, &incoming.crypto, &src\_cid, TransportError::CONNECTION\_REFUSED(""), buf, )), }); }
 let server\_config = server\_config.unwrap\_or\_else(|| self.server\_config.as\_ref().unwrap().clone());
 if incoming .crypto .packet .remote .decrypt( packet\_number, &incoming.packet.header\_data, &mut incoming.packet.payload, ) .is\_err() { debug!(packet\_number, "failed to authenticate initial packet"); self.index.remove\_initial(incoming.orig\_dst\_cid); return Err(AcceptError { cause: TransportError::PROTOCOL\_VIOLATION("authentication failed").into(), response: None, }); };
 let ch = ConnectionHandle(self.connections.vacant\_key()); let loc\_cid = self.new\_cid(ch); let mut params = TransportParameters::new( &server\_config.transport, &self.config, self.local\_cid\_generator.as\_ref(), loc\_cid, Some(&server\_config), ); params.stateless\_reset\_token = Some(ResetToken::new(&\*self.config.reset\_key, &loc\_cid)); params.original\_dst\_cid = Some(incoming.orig\_dst\_cid); params.retry\_src\_cid = incoming.retry\_src\_cid; let mut pref\_addr\_cid = None; if server\_config.preferred\_address\_v4.is\_some() || server\_config.preferred\_address\_v6.is\_some() { let cid = self.new\_cid(ch); pref\_addr\_cid = Some(cid); params.preferred\_address = Some(PreferredAddress { address\_v4: server\_config.preferred\_address\_v4, address\_v6: server\_config.preferred\_address\_v6, connection\_id: cid, stateless\_reset\_token: ResetToken::new(&\*self.config.reset\_key, &cid), }); }
 let tls = server\_config.crypto.clone().start\_session(version, &params); let transport\_config = server\_config.transport.clone(); let mut conn = self.add\_connection( ch, version, dst\_cid, loc\_cid, src\_cid, pref\_addr\_cid, incoming.addresses, now, tls, Some(server\_config), transport\_config, remote\_address\_validated, ); if dst\_cid.len() != 0 { self.index.insert\_initial(dst\_cid, ch); }
 match conn.handle\_first\_packet( now, incoming.addresses.remote, incoming.ecn, packet\_number, incoming.packet, incoming.rest, ) { Ok(()) => { trace!(id = ch.0, icid = %dst\_cid, "new connection");
 for event in incoming\_buffer.datagrams { conn.handle\_event(ConnectionEvent(ConnectionEventInner::Datagram(event))) }
 Ok((ch, conn)) } Err(e) => { debug!("handshake failed: {}", e); self.handle\_event(ch, EndpointEvent(EndpointEventInner::Drained)); let response = match e { ConnectionError::TransportError(ref e) => Some(self.initial\_close( version, incoming.addresses, &incoming.crypto, &src\_cid, e.clone(), buf, )), \_ => None, }; Err(AcceptError { cause: e, response }) } } }
 /// Check if we should refuse a connection attempt regardless of the packet's contents fn early\_validate\_first\_packet( &mut self, header: &ProtectedInitialHeader, ) -> Result<(), TransportError> { let config = &self.server\_config.as\_ref().unwrap(); if self.cids\_exhausted() || self.incoming\_buffers.len() >= config.max\_incoming { return Err(TransportError::CONNECTION\_REFUSED("")); }
 // RFC9000 §7.2 dictates that initial (client-chosen) destination CIDs must be at least 8 // bytes. If this is a Retry packet, then the length must instead match our usual CID // length. If we ever issue non-Retry address validation tokens via `NEW\_TOKEN`, then we'll // also need to validate CID length for those after decoding the token. if header.dst\_cid.len() < 8 && (!header.token\_pos.is\_empty() && header.dst\_cid.len() != self.local\_cid\_generator.cid\_len()) { debug!( "rejecting connection due to invalid DCID length {}", header.dst\_cid.len() ); return Err(TransportError::PROTOCOL\_VIOLATION( "invalid destination CID length", )); }
 Ok(()) }
 /// Reject this incoming connection attempt pub fn refuse(&mut self, incoming: Incoming, buf: &mut Vec<u8>) -> Transmit { self.clean\_up\_incoming(&incoming); incoming.improper\_drop\_warner.dismiss();
 self.initial\_close( incoming.packet.header.version, incoming.addresses, &incoming.crypto, &incoming.packet.header.src\_cid, TransportError::CONNECTION\_REFUSED(""), buf, ) }
 /// Respond with a retry packet, requiring the client to retry with address validation /// /// Errors if `incoming.remote\_address\_validated()` is true. pub fn retry(&mut self, incoming: Incoming, buf: &mut Vec<u8>) -> Result<Transmit, RetryError> { if incoming.remote\_address\_validated() { return Err(RetryError(incoming)); }
 self.clean\_up\_incoming(&incoming); incoming.improper\_drop\_warner.dismiss();
 let server\_config = self.server\_config.as\_ref().unwrap();
 // First Initial // The peer will use this as the DCID of its following Initials. Initial DCIDs are // looked up separately from Handshake/Data DCIDs, so there is no risk of collision // with established connections. In the unlikely event that a collision occurs // between two connections in the initial phase, both will fail fast and may be // retried by the application layer. let loc\_cid = self.local\_cid\_generator.generate\_cid();
 let token = RetryToken { orig\_dst\_cid: incoming.packet.header.dst\_cid, issued: SystemTime::now(), } .encode( &\*server\_config.token\_key, &incoming.addresses.remote, &loc\_cid, );
 let header = Header::Retry { src\_cid: loc\_cid, dst\_cid: incoming.packet.header.src\_cid, version: incoming.packet.header.version, };
 let encode = header.encode(buf); buf.put\_slice(&token); buf.extend\_from\_slice(&server\_config.crypto.retry\_tag( incoming.packet.header.version, &incoming.packet.header.dst\_cid, buf, )); encode.finish(buf, &\*incoming.crypto.header.local, None);
 Ok(Transmit { destination: incoming.addresses.remote, ecn: None, size: buf.len(), segment\_size: None, src\_ip: incoming.addresses.local\_ip, }) }
 /// Ignore this incoming connection attempt, not sending any packet in response /// /// Doing this actively, rather than merely dropping the [`Incoming`], is necessary to prevent /// memory leaks due to state within [`Endpoint`] tracking the incoming connection. pub fn ignore(&mut self, incoming: Incoming) { self.clean\_up\_incoming(&incoming); incoming.improper\_drop\_warner.dismiss(); }
 /// Clean up endpoint data structures associated with an `Incoming`. fn clean\_up\_incoming(&mut self, incoming: &Incoming) { self.index.remove\_initial(incoming.orig\_dst\_cid); let incoming\_buffer = self.incoming\_buffers.remove(incoming.incoming\_idx); self.all\_incoming\_buffers\_total\_bytes -= incoming\_buffer.total\_bytes; }
 fn add\_connection( &mut self, ch: ConnectionHandle, version: u32, init\_cid: ConnectionId, loc\_cid: ConnectionId, rem\_cid: ConnectionId, pref\_addr\_cid: Option<ConnectionId>, addresses: FourTuple, now: Instant, tls: Box<dyn crypto::Session>, server\_config: Option<Arc<ServerConfig>>, transport\_config: Arc<TransportConfig>, path\_validated: bool, ) -> Connection { let mut rng\_seed = [0; 32]; self.rng.fill\_bytes(&mut rng\_seed); let side = match server\_config.is\_some() { true => Side::Server, false => Side::Client, }; let conn = Connection::new( self.config.clone(), server\_config, transport\_config, init\_cid, loc\_cid, rem\_cid, pref\_addr\_cid, addresses.remote, addresses.local\_ip, tls, self.local\_cid\_generator.as\_ref(), now, version, self.allow\_mtud, rng\_seed, path\_validated, );
 let mut cids\_issued = 0; let mut loc\_cids = FxHashMap::default();
 loc\_cids.insert(cids\_issued, loc\_cid); cids\_issued += 1;
 if let Some(cid) = pref\_addr\_cid { debug\_assert\_eq!(cids\_issued, 1, "preferred address cid seq must be 1"); loc\_cids.insert(cids\_issued, cid); cids\_issued += 1; }
 let id = self.connections.insert(ConnectionMeta { init\_cid, cids\_issued, loc\_cids, addresses, reset\_token: None, }); debug\_assert\_eq!(id, ch.0, "connection handle allocation out of sync");
 self.index.insert\_conn(addresses, loc\_cid, ch, side);
 conn }
 fn initial\_close( &mut self, version: u32, addresses: FourTuple, crypto: &Keys, remote\_id: &ConnectionId, reason: TransportError, buf: &mut Vec<u8>, ) -> Transmit { // We don't need to worry about CID collisions in initial closes because the peer // shouldn't respond, and if it does, and the CID collides, we'll just drop the // unexpected response. let local\_id = self.local\_cid\_generator.generate\_cid(); let number = PacketNumber::U8(0); let header = Header::Initial(InitialHeader { dst\_cid: \*remote\_id, src\_cid: local\_id, number, token: Bytes::new(), version, });
 let partial\_encode = header.encode(buf); let max\_len = INITIAL\_MTU as usize - partial\_encode.header\_len - crypto.packet.local.tag\_len(); frame::Close::from(reason).encode(buf, max\_len); buf.resize(buf.len() + crypto.packet.local.tag\_len(), 0); partial\_encode.finish(buf, &\*crypto.header.local, Some((0, &\*crypto.packet.local))); Transmit { destination: addresses.remote, ecn: None, size: buf.len(), segment\_size: None, src\_ip: addresses.local\_ip, } }
 /// Access the configuration used by this endpoint pub fn config(&self) -> &EndpointConfig { &self.config }
 /// Number of connections that are currently open pub fn open\_connections(&self) -> usize { self.connections.len() }
 /// Counter for the number of bytes currently used /// in the buffers for Initial and 0-RTT messages for pending incoming connections pub fn incoming\_buffer\_bytes(&self) -> u64 { self.all\_incoming\_buffers\_total\_bytes }
 #[cfg(test)] pub(crate) fn known\_connections(&self) -> usize { let x = self.connections.len(); debug\_assert\_eq!(x, self.index.connection\_ids\_initial.len()); // Not all connections have known reset tokens debug\_assert!(x >= self.index.connection\_reset\_tokens.0.len()); // Not all connections have unique remotes, and 0-length CIDs might not be in use. debug\_assert!(x >= self.index.incoming\_connection\_remotes.len()); debug\_assert!(x >= self.index.outgoing\_connection\_remotes.len()); x }
 #[cfg(test)] pub(crate) fn known\_cids(&self) -> usize { self.index.connection\_ids.len() }
 /// Whether we've used up 3/4 of the available CID space /// /// We leave some space unused so that `new\_cid` can be relied upon to finish quickly. We don't /// bother to check when CID longer than 4 bytes are used because 2^40 connections is a lot. fn cids\_exhausted(&self) -> bool { self.local\_cid\_generator.cid\_len() <= 4 && self.local\_cid\_generator.cid\_len() != 0 && (2usize.pow(self.local\_cid\_generator.cid\_len() as u32 \* 8) - self.index.connection\_ids.len()) < 2usize.pow(self.local\_cid\_generator.cid\_len() as u32 \* 8 - 2) }}
impl fmt::Debug for Endpoint { fn fmt(&self, fmt: &mut fmt::Formatter<'\_>) -> fmt::Result { fmt.debug\_struct("Endpoint") .field("rng", &self.rng) .field("index", &self.index) .field("connections", &self.connections) .field("config", &self.config) .field("server\_config", &self.server\_config) // incoming\_buffers too large .field("incoming\_buffers.len", &self.incoming\_buffers.len()) .field( "all\_incoming\_buffers\_total\_bytes", &self.all\_incoming\_buffers\_total\_bytes, ) .finish() }}
/// Buffered Initial and 0-RTT messages for a pending incoming connection#[derive(Default)]struct IncomingBuffer { datagrams: Vec<DatagramConnectionEvent>, total\_bytes: u64,}
/// Part of protocol state incoming datagrams can be routed to#[derive(Copy, Clone, Debug)]enum RouteDatagramTo { Incoming(usize), Connection(ConnectionHandle),}
/// Maps packets to existing connections#[derive(Default, Debug)]struct ConnectionIndex { /// Identifies connections based on the initial DCID the peer utilized /// /// Uses a standard `HashMap` to protect against hash collision attacks. connection\_ids\_initial: HashMap<ConnectionId, RouteDatagramTo>, /// Identifies connections based on locally created CIDs /// /// Uses a cheaper hash function since keys are locally created[View remainder of file in raw view](https://github.com/quinn-rs/quinn/raw/bb02a12a8435a7732a1d762783eeacbb7e50418e/quinn-proto/src/endpoint.rs)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

