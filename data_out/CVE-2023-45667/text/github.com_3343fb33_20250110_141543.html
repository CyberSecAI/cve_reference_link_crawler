
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fnothings%2Fstb%2Fblob%2F5736b15f7ea0ffb08dd38af21067c314d6a3aae9%2Fstb_image.h)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fnothings%2Fstb%2Fblob%2F5736b15f7ea0ffb08dd38af21067c314d6a3aae9%2Fstb_image.h)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=nothings%2Fstb)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[nothings](/nothings)
/
**[stb](/nothings/stb)**
Public

* [Notifications](/login?return_to=%2Fnothings%2Fstb) You must be signed in to change notification settings
* [Fork
  7.7k](/login?return_to=%2Fnothings%2Fstb)
* [Star
   27.5k](/login?return_to=%2Fnothings%2Fstb)

* [Code](/nothings/stb)
* [Issues
  158](/nothings/stb/issues)
* [Pull requests
  131](/nothings/stb/pulls)
* [Discussions](/nothings/stb/discussions)
* [Actions](/nothings/stb/actions)
* [Projects
  0](/nothings/stb/projects)
* [Security](/nothings/stb/security)
* [Insights](/nothings/stb/pulse)

Additional navigation options

* [Code](/nothings/stb)
* [Issues](/nothings/stb/issues)
* [Pull requests](/nothings/stb/pulls)
* [Discussions](/nothings/stb/discussions)
* [Actions](/nothings/stb/actions)
* [Projects](/nothings/stb/projects)
* [Security](/nothings/stb/security)
* [Insights](/nothings/stb/pulse)

## Files

 5736b15
## Breadcrumbs

1. [stb](/nothings/stb/tree/5736b15f7ea0ffb08dd38af21067c314d6a3aae9)
/
# stb\_image.h

 Blame  Blame
## Latest commit

## History

[History](/nothings/stb/commits/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_image.h)7987 lines (7103 loc) · 278 KB 5736b15
## Breadcrumbs

1. [stb](/nothings/stb/tree/5736b15f7ea0ffb08dd38af21067c314d6a3aae9)
/
# stb\_image.h

Top
## File metadata and controls

* Code
* Blame

7987 lines (7103 loc) · 278 KB[Raw](https://github.com/nothings/stb/raw/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_image.h)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\* stb\_image - v2.28 - public domain image loader - http://nothings.org/stb no warranty implied; use at your own risk
 Do this: #define STB\_IMAGE\_IMPLEMENTATION before you include this file in \*one\* C or C++ file to create the implementation.
 // i.e. it should look like this: #include ... #include ... #include ... #define STB\_IMAGE\_IMPLEMENTATION #include "stb\_image.h"
 You can #define STBI\_ASSERT(x) before the #include to avoid using assert.h. And #define STBI\_MALLOC, STBI\_REALLOC, and STBI\_FREE to avoid using malloc,realloc,free
 QUICK NOTES: Primarily of interest to game developers and other people who can avoid problematic images and only need the trivial interface
 JPEG baseline & progressive (12 bpc/arithmetic not supported, same as stock IJG lib) PNG 1/2/4/8/16-bit-per-channel
 TGA (not sure what subset, if a subset) BMP non-1bpp, non-RLE PSD (composited view only, no extra channels, 8/16 bit-per-channel)
 GIF (\*comp always reports as 4-channel) HDR (radiance rgbE format) PIC (Softimage PIC) PNM (PPM and PGM binary only)
 Animated GIF still needs a proper API, but here's one way to do it: http://gist.github.com/urraka/685d9a6340b26b830d49
 - decode from memory or through FILE (define STBI\_NO\_STDIO to remove code) - decode from arbitrary I/O callbacks - SIMD acceleration on x86/x64 (SSE2) and ARM (NEON)
 Full documentation under "DOCUMENTATION" below.
LICENSE
 See end of file for license information.
RECENT REVISION HISTORY:
 2.28 (2023-01-29) many error fixes, security errors, just tons of stuff 2.27 (2021-07-11) document stbi\_info better, 16-bit PNM support, bug fixes 2.26 (2020-07-13) many minor fixes 2.25 (2020-02-02) fix warnings 2.24 (2020-02-02) fix warnings; thread-local failure\_reason and flip\_vertically 2.23 (2019-08-11) fix clang static analysis warning 2.22 (2019-03-04) gif fixes, fix warnings 2.21 (2019-02-25) fix typo in comment 2.20 (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs 2.19 (2018-02-11) fix warning 2.18 (2018-01-30) fix warnings 2.17 (2018-01-29) bugfix, 1-bit BMP, 16-bitness query, fix warnings 2.16 (2017-07-23) all functions have 16-bit variants; optimizations; bugfixes 2.15 (2017-03-18) fix png-1,2,4; all Imagenet JPGs; no runtime SSE detection on GCC 2.14 (2017-03-03) remove deprecated STBI\_JPEG\_OLD; fixes for Imagenet JPGs 2.13 (2016-12-04) experimental 16-bit API, only for PNG so far; fixes 2.12 (2016-04-02) fix typo in 2.11 PSD fix that caused crashes 2.11 (2016-04-02) 16-bit PNGS; enable SSE2 in non-gcc x64 RGB-format JPEG; remove white matting in PSD; allocate large structures on the stack; correct channel count for PNG & BMP 2.10 (2016-01-22) avoid warning introduced in 2.09 2.09 (2016-01-16) 16-bit TGA; comments in PNM files; STBI\_REALLOC\_SIZED
 See end of file for full revision history.
 ============================ Contributors =========================
 Image formats Extensions, features Sean Barrett (jpeg, png, bmp) Jetro Lauha (stbi\_info) Nicolas Schulz (hdr, psd) Martin "SpartanJ" Golini (stbi\_info) Jonathan Dummer (tga) James "moose2000" Brown (iPhone PNG) Jean-Marc Lienher (gif) Ben "Disch" Wenger (io callbacks) Tom Seddon (pic) Omar Cornut (1/2/4-bit PNG) Thatcher Ulrich (psd) Nicolas Guillemot (vertical flip) Ken Miller (pgm, ppm) Richard Mitton (16-bit PSD) github:urraka (animated gif) Junggon Kim (PNM comments) Christopher Forseth (animated gif) Daniel Gibson (16-bit TGA) socks-the-fox (16-bit PNG) Jeremy Sawicki (handle all ImageNet JPGs) Optimizations & bugfixes Mikhail Morozov (1-bit BMP) Fabian "ryg" Giesen Anael Seghezzi (is-16-bit query) Arseny Kapoulkine Simon Breuss (16-bit PNM) John-Mark Allen Carmelo J Fdez-Aguera
 Bug & warning fixes Marc LeBlanc David Woo Guillaume George Martins Mozeiko Christpher Lloyd Jerry Jansson Joseph Thomson Blazej Dariusz Roszkowski Phil Jordan Dave Moore Roy Eltham Hayaki Saito Nathan Reed Won Chun Luke Graham Johan Duparc Nick Verigakis the Horde3D community Thomas Ruf Ronny Chevalier github:rlyeh Janez Zemva John Bartholomew Michal Cichon github:romigrou Jonathan Blow Ken Hamada Tero Hanninen github:svdijk Eugene Golushkov Laurent Gomila Cort Stratton github:snagar Aruelien Pocheville Sergio Gonzalez Thibault Reuille github:Zelex Cass Everitt Ryamond Barbiero github:grim210 Paul Du Bois Engin Manap Aldo Culquicondor github:sammyhw Philipp Wiesemann Dale Weiler Oriol Ferrer Mesia github:phprus Josh Tobin Neil Bickford Matthew Gregan github:poppolopoppo Julian Raschke Gregory Mullen Christian Floisand github:darealshinji Baldur Karlsson Kevin Schmidt JR Smith github:Michaelangel007 Brad Weinberger Matvey Cherevko github:mosra Luca Sas Alexander Veselov Zack Middleton [reserved] Ryan C. Gordon [reserved] [reserved] DO NOT ADD YOUR NAME HERE
 Jacko Dirks
 To add your name to the credits, pick a random blank space in the middle and fill it. 80% of merge conflicts on stb PRs are due to people adding their name at the end of the credits.\*/
#ifndef STBI\_INCLUDE\_STB\_IMAGE\_H#define STBI\_INCLUDE\_STB\_IMAGE\_H
// DOCUMENTATION//// Limitations:// - no 12-bit-per-channel JPEG// - no JPEGs with arithmetic coding// - GIF always returns \*comp=4//// Basic usage (see HDR discussion below for HDR usage):// int x,y,n;// unsigned char \*data = stbi\_load(filename, &x, &y, &n, 0);// // ... process data if not NULL ...// // ... x = width, y = height, n = # 8-bit components per pixel ...// // ... replace '0' with '1'..'4' to force that many components per pixel// // ... but 'n' will always be the number that it would have been if you said 0// stbi\_image\_free(data);//// Standard parameters:// int \*x -- outputs image width in pixels// int \*y -- outputs image height in pixels// int \*channels\_in\_file -- outputs # of image components in image file// int desired\_channels -- if non-zero, # of image components requested in result//// The return value from an image loader is an 'unsigned char \*' which points// to the pixel data, or NULL on an allocation failure or if the image is// corrupt or invalid. The pixel data consists of \*y scanlines of \*x pixels,// with each pixel consisting of N interleaved 8-bit components; the first// pixel pointed to is top-left-most in the image. There is no padding between// image scanlines or between pixels, regardless of format. The number of// components N is 'desired\_channels' if desired\_channels is non-zero, or// \*channels\_in\_file otherwise. If desired\_channels is non-zero,// \*channels\_in\_file has the number of components that \_would\_ have been// output otherwise. E.g. if you set desired\_channels to 4, you will always// get RGBA output, but you can check \*channels\_in\_file to see if it's trivially// opaque because e.g. there were only 3 channels in the source image.//// An output image with N components has the following components interleaved// in this order in each pixel://// N=#comp components// 1 grey// 2 grey, alpha// 3 red, green, blue// 4 red, green, blue, alpha//// If image loading fails for any reason, the return value will be NULL,// and \*x, \*y, \*channels\_in\_file will be unchanged. The function// stbi\_failure\_reason() can be queried for an extremely brief, end-user// unfriendly explanation of why the load failed. Define STBI\_NO\_FAILURE\_STRINGS// to avoid compiling these strings at all, and STBI\_FAILURE\_USERMSG to get slightly// more user-friendly ones.//// Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.//// To query the width, height and component count of an image without having to// decode the full file, you can use the stbi\_info family of functions://// int x,y,n,ok;// ok = stbi\_info(filename, &x, &y, &n);// // returns ok=1 and sets x, y, n if image is a supported format,// // 0 otherwise.//// Note that stb\_image pervasively uses ints in its public API for sizes,// including sizes of memory buffers. This is now part of the API and thus// hard to change without causing breakage. As a result, the various image// loaders all have certain limits on image size; these differ somewhat// by format but generally boil down to either just under 2GB or just under// 1GB. When the decoded image would be larger than this, stb\_image decoding// will fail.//// Additionally, stb\_image will reject image files that have any of their// dimensions set to a larger value than the configurable STBI\_MAX\_DIMENSIONS,// which defaults to 2\*\*24 = 16777216 pixels. Due to the above memory limit,// the only way to have an image with such dimensions load correctly// is for it to have a rather extreme aspect ratio. Either way, the// assumption here is that such larger images are likely to be malformed// or malicious. If you do need to load an image with individual dimensions// larger than that, and it still fits in the overall size limit, you can// #define STBI\_MAX\_DIMENSIONS on your own to be something larger.//// ===========================================================================//// UNICODE://// If compiling for Windows and you wish to use Unicode filenames, compile// with// #define STBI\_WINDOWS\_UTF8// and pass utf8-encoded filenames. Call stbi\_convert\_wchar\_to\_utf8 to convert// Windows wchar\_t filenames to utf8.//// ===========================================================================//// Philosophy//// stb libraries are designed with the following priorities://// 1. easy to use// 2. easy to maintain// 3. good performance//// Sometimes I let "good performance" creep up in priority over "easy to maintain",// and for best performance I may provide less-easy-to-use APIs that give higher// performance, in addition to the easy-to-use ones. Nevertheless, it's important// to keep in mind that from the standpoint of you, a client of this library,// all you care about is #1 and #3, and stb libraries DO NOT emphasize #3 above all.//// Some secondary priorities arise directly from the first two, some of which// provide more explicit reasons why performance can't be emphasized.//// - Portable ("ease of use")// - Small source code footprint ("easy to maintain")// - No dependencies ("ease of use")//// ===========================================================================//// I/O callbacks//// I/O callbacks allow you to read from arbitrary sources, like packaged// files or some other source. Data read from callbacks are processed// through a small internal buffer (currently 128 bytes) to try to reduce// overhead.//// The three functions you must define are "read" (reads some bytes of data),// "skip" (skips some bytes of data), "eof" (reports if the stream is at the end).//// ===========================================================================//// SIMD support//// The JPEG decoder will try to automatically use SIMD kernels on x86 when// supported by the compiler. For ARM Neon support, you must explicitly// request it.//// (The old do-it-yourself SIMD API is no longer supported in the current// code.)//// On x86, SSE2 will automatically be used when available based on a run-time// test; if not, the generic C versions are used as a fall-back. On ARM targets,// the typical path is to have separate builds for NEON and non-NEON devices// (at least this is true for iOS and Android). Therefore, the NEON support is// toggled by a build flag: define STBI\_NEON to get NEON loops.//// If for some reason you do not want to use any of SIMD code, or if// you have issues compiling it, you can disable it entirely by// defining STBI\_NO\_SIMD.//// ===========================================================================//// HDR image support (disable by defining STBI\_NO\_HDR)//// stb\_image supports loading HDR images in general, and currently the Radiance// .HDR file format specifically. You can still load any file through the existing// interface; if you attempt to load an HDR file, it will be automatically remapped// to LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;// both of these constants can be reconfigured through this interface://// stbi\_hdr\_to\_ldr\_gamma(2.2f);// stbi\_hdr\_to\_ldr\_scale(1.0f);//// (note, do not use \_inverse\_ constants; stbi\_image will invert them// appropriately).//// Additionally, there is a new, parallel interface for loading files as// (linear) floats to preserve the full dynamic range://// float \*data = stbi\_loadf(filename, &x, &y, &n, 0);//// If you load LDR images through this interface, those images will// be promoted to floating point values, run through the inverse of// constants corresponding to the above://// stbi\_ldr\_to\_hdr\_scale(1.0f);// stbi\_ldr\_to\_hdr\_gamma(2.2f);//// Finally, given a filename (or an open file or memory block--see header// file for details) containing image data, you can query for the "most// appropriate" interface to use (that is, whether the image is HDR or// not), using://// stbi\_is\_hdr(char \*filename);//// ===========================================================================//// iPhone PNG support://// We optionally support converting iPhone-formatted PNGs (which store// premultiplied BGRA) back to RGB, even though they're internally encoded// differently. To enable this conversion, call// stbi\_convert\_iphone\_png\_to\_rgb(1).//// Call stbi\_set\_unpremultiply\_on\_load(1) as well to force a divide per// pixel to remove any premultiplied alpha \*only\* if the image file explicitly// says there's premultiplied data (currently only happens in iPhone images,// and only if iPhone convert-to-rgb processing is on).//// ===========================================================================//// ADDITIONAL CONFIGURATION//// - You can suppress implementation of any of the decoders to reduce// your code footprint by #defining one or more of the following// symbols before creating the implementation.//// STBI\_NO\_JPEG// STBI\_NO\_PNG// STBI\_NO\_BMP// STBI\_NO\_PSD// STBI\_NO\_TGA// STBI\_NO\_GIF// STBI\_NO\_HDR// STBI\_NO\_PIC// STBI\_NO\_PNM (.ppm and .pgm)//// - You can request \*only\* certain decoders and suppress all other ones// (this will be more forward-compatible, as addition of new decoders// doesn't require you to disable them explicitly)://// STBI\_ONLY\_JPEG// STBI\_ONLY\_PNG// STBI\_ONLY\_BMP// STBI\_ONLY\_PSD// STBI\_ONLY\_TGA// STBI\_ONLY\_GIF// STBI\_ONLY\_HDR// STBI\_ONLY\_PIC// STBI\_ONLY\_PNM (.ppm and .pgm)//// - If you use STBI\_NO\_PNG (or \_ONLY\_ without PNG), and you still// want the zlib decoder to be available, #define STBI\_SUPPORT\_ZLIB//// - If you define STBI\_MAX\_DIMENSIONS, stb\_image will reject images greater// than that size (in either width or height) without further processing.// This is to let programs in the wild set an upper bound to prevent// denial-of-service attacks on untrusted data, as one could generate a// valid image of gigantic dimensions and force stb\_image to allocate a// huge block of memory and spend disproportionate time decoding it. By// default this is set to (1 << 24), which is 16777216, but that's still// very big.
#ifndef STBI\_NO\_STDIO#include <stdio.h>#endif // STBI\_NO\_STDIO
#define STBI\_VERSION 1
enum{ STBI\_default = 0, // only used for desired\_channels
 STBI\_grey = 1, STBI\_grey\_alpha = 2, STBI\_rgb = 3, STBI\_rgb\_alpha = 4};
#include <stdlib.h>typedef unsigned char stbi\_uc;typedef unsigned short stbi\_us;
#ifdef \_\_cplusplusextern "C" {#endif
#ifndef STBIDEF#ifdef STB\_IMAGE\_STATIC#define STBIDEF static#else#define STBIDEF extern#endif#endif
////////////////////////////////////////////////////////////////////////////////// PRIMARY API - works on images of any type//
//// load image by filename, open file, or memory buffer//
typedef struct{ int (\*read) (void \*user,char \*data,int size); // fill 'data' with 'size' bytes. return number of bytes actually read void (\*skip) (void \*user,int n); // skip the next 'n' bytes, or 'unget' the last -n bytes if negative int (\*eof) (void \*user); // returns nonzero if we are at end of file/data} stbi\_io\_callbacks;
//////////////////////////////////////// 8-bits-per-channel interface//
STBIDEF stbi\_uc \*stbi\_load\_from\_memory (stbi\_uc const \*buffer, int len , int \*x, int \*y, int \*channels\_in\_file, int desired\_channels);STBIDEF stbi\_uc \*stbi\_load\_from\_callbacks(stbi\_io\_callbacks const \*clbk , void \*user, int \*x, int \*y, int \*channels\_in\_file, int desired\_channels);
#ifndef STBI\_NO\_STDIOSTBIDEF stbi\_uc \*stbi\_load (char const \*filename, int \*x, int \*y, int \*channels\_in\_file, int desired\_channels);STBIDEF stbi\_uc \*stbi\_load\_from\_file (FILE \*f, int \*x, int \*y, int \*channels\_in\_file, int desired\_channels);// for stbi\_load\_from\_file, file pointer is left pointing immediately after image#endif
#ifndef STBI\_NO\_GIFSTBIDEF stbi\_uc \*stbi\_load\_gif\_from\_memory(stbi\_uc const \*buffer, int len, int \*\*delays, int \*x, int \*y, int \*z, int \*comp, int req\_comp);#endif
#ifdef STBI\_WINDOWS\_UTF8STBIDEF int stbi\_convert\_wchar\_to\_utf8(char \*buffer, size\_t bufferlen, const wchar\_t\* input);#endif
//////////////////////////////////////// 16-bits-per-channel interface//
STBIDEF stbi\_us \*stbi\_load\_16\_from\_memory (stbi\_uc const \*buffer, int len, int \*x, int \*y, int \*channels\_in\_file, int desired\_channels);STBIDEF stbi\_us \*stbi\_load\_16\_from\_callbacks(stbi\_io\_callbacks const \*clbk, void \*user, int \*x, int \*y, int \*channels\_in\_file, int desired\_channels);
#ifndef STBI\_NO\_STDIOSTBIDEF stbi\_us \*stbi\_load\_16 (char const \*filename, int \*x, int \*y, int \*channels\_in\_file, int desired\_channels);STBIDEF stbi\_us \*stbi\_load\_from\_file\_16(FILE \*f, int \*x, int \*y, int \*channels\_in\_file, int desired\_channels);#endif
//////////////////////////////////////// float-per-channel interface//#ifndef STBI\_NO\_LINEAR STBIDEF float \*stbi\_loadf\_from\_memory (stbi\_uc const \*buffer, int len, int \*x, int \*y, int \*channels\_in\_file, int desired\_channels); STBIDEF float \*stbi\_loadf\_from\_callbacks (stbi\_io\_callbacks const \*clbk, void \*user, int \*x, int \*y, int \*channels\_in\_file, int desired\_channels);
 #ifndef STBI\_NO\_STDIO STBIDEF float \*stbi\_loadf (char const \*filename, int \*x, int \*y, int \*channels\_in\_file, int desired\_channels); STBIDEF float \*stbi\_loadf\_from\_file (FILE \*f, int \*x, int \*y, int \*channels\_in\_file, int desired\_channels); #endif#endif
#ifndef STBI\_NO\_HDR STBIDEF void stbi\_hdr\_to\_ldr\_gamma(float gamma); STBIDEF void stbi\_hdr\_to\_ldr\_scale(float scale);#endif // STBI\_NO\_HDR
#ifndef STBI\_NO\_LINEAR STBIDEF void stbi\_ldr\_to\_hdr\_gamma(float gamma); STBIDEF void stbi\_ldr\_to\_hdr\_scale(float scale);#endif // STBI\_NO\_LINEAR
// stbi\_is\_hdr is always defined, but always returns false if STBI\_NO\_HDRSTBIDEF int stbi\_is\_hdr\_from\_callbacks(stbi\_io\_callbacks const \*clbk, void \*user);STBIDEF int stbi\_is\_hdr\_from\_memory(stbi\_uc const \*buffer, int len);#ifndef STBI\_NO\_STDIOSTBIDEF int stbi\_is\_hdr (char const \*filename);STBIDEF int stbi\_is\_hdr\_from\_file(FILE \*f);#endif // STBI\_NO\_STDIO
// get a VERY brief reason for failure// on most compilers (and ALL modern mainstream compilers) this is threadsafeSTBIDEF const char \*stbi\_failure\_reason (void);
// free the loaded image -- this is just free()STBIDEF void stbi\_image\_free (void \*retval\_from\_stbi\_load);
// get image dimensions & components without fully decodingSTBIDEF int stbi\_info\_from\_memory(stbi\_uc const \*buffer, int len, int \*x, int \*y, int \*comp);STBIDEF int stbi\_info\_from\_callbacks(stbi\_io\_callbacks const \*clbk, void \*user, int \*x, int \*y, int \*comp);STBIDEF int stbi\_is\_16\_bit\_from\_memory(stbi\_uc const \*buffer, int len);STBIDEF int stbi\_is\_16\_bit\_from\_callbacks(stbi\_io\_callbacks const \*clbk, void \*user);
#ifndef STBI\_NO\_STDIOSTBIDEF int stbi\_info (char const \*filename, int \*x, int \*y, int \*comp);STBIDEF int stbi\_info\_from\_file (FILE \*f, int \*x, int \*y, int \*comp);STBIDEF int stbi\_is\_16\_bit (char const \*filename);STBIDEF int stbi\_is\_16\_bit\_from\_file(FILE \*f);#endif
// for image formats that explicitly notate that they have premultiplied alpha,// we just return the colors as stored in the file. set this flag to force// unpremultiplication. results are undefined if the unpremultiply overflow.STBIDEF void stbi\_set\_unpremultiply\_on\_load(int flag\_true\_if\_should\_unpremultiply);
// indicate whether we should process iphone images back to canonical format,// or just pass them through "as-is"STBIDEF void stbi\_convert\_iphone\_png\_to\_rgb(int flag\_true\_if\_should\_convert);
// flip the image vertically, so the first pixel in the output array is the bottom leftSTBIDEF void stbi\_set\_flip\_vertically\_on\_load(int flag\_true\_if\_should\_flip);
// as above, but only applies to images loaded on the thread that calls the function// this function is only available if your compiler supports thread-local variables;// calling it will fail to link if your compiler doesn'tSTBIDEF void stbi\_set\_unpremultiply\_on\_load\_thread(int flag\_true\_if\_should\_unpremultiply);STBIDEF void stbi\_convert\_iphone\_png\_to\_rgb\_thread(int flag\_true\_if\_should\_convert);STBIDEF void stbi\_set\_flip\_vertically\_on\_load\_thread(int flag\_true\_if\_should\_flip);
// ZLIB client - used by PNG, available for other purposes
STBIDEF char \*stbi\_zlib\_decode\_malloc\_guesssize(const char \*buffer, int len, int initial\_size, int \*outlen);STBIDEF char \*stbi\_zlib\_decode\_malloc\_guesssize\_headerflag(const char \*buffer, int len, int initial\_size, int \*outlen, int parse\_header);STBIDEF char \*stbi\_zlib\_decode\_malloc(const char \*buffer, int len, int \*outlen);STBIDEF int stbi\_zlib\_decode\_buffer(char \*obuffer, int olen, const char \*ibuffer, int ilen);
STBIDEF char \*stbi\_zlib\_decode\_noheader\_malloc(const char \*buffer, int len, int \*outlen);STBIDEF int stbi\_zlib\_decode\_noheader\_buffer(char \*obuffer, int olen, const char \*ibuffer, int ilen);
#ifdef \_\_cplusplus}#endif
//////// end header file /////////////////////////////////////////////////////#endif // STBI\_INCLUDE\_STB\_IMAGE\_H
#ifdef STB\_IMAGE\_IMPLEMENTATION
#if defined(STBI\_ONLY\_JPEG) || defined(STBI\_ONLY\_PNG) || defined(STBI\_ONLY\_BMP) \ || defined(STBI\_ONLY\_TGA) || defined(STBI\_ONLY\_GIF) || defined(STBI\_ONLY\_PSD) \ || defined(STBI\_ONLY\_HDR) || defined(STBI\_ONLY\_PIC) || defined(STBI\_ONLY\_PNM) \ || defined(STBI\_ONLY\_ZLIB) #ifndef STBI\_ONLY\_JPEG #define STBI\_NO\_JPEG #endif #ifndef STBI\_ONLY\_PNG #define STBI\_NO\_PNG #endif #ifndef STBI\_ONLY\_BMP #define STBI\_NO\_BMP #endif #ifndef STBI\_ONLY\_PSD #define STBI\_NO\_PSD #endif #ifndef STBI\_ONLY\_TGA #define STBI\_NO\_TGA #endif #ifndef STBI\_ONLY\_GIF #define STBI\_NO\_GIF #endif #ifndef STBI\_ONLY\_HDR #define STBI\_NO\_HDR #endif #ifndef STBI\_ONLY\_PIC #define STBI\_NO\_PIC #endif #ifndef STBI\_ONLY\_PNM #define STBI\_NO\_PNM #endif#endif
#if defined(STBI\_NO\_PNG) && !defined(STBI\_SUPPORT\_ZLIB) && !defined(STBI\_NO\_ZLIB)#define STBI\_NO\_ZLIB#endif
#include <stdarg.h>#include <stddef.h> // ptrdiff\_t on osx#include <stdlib.h>#include <string.h>#include <limits.h>
#if !defined(STBI\_NO\_LINEAR) || !defined(STBI\_NO\_HDR)#include <math.h> // ldexp, pow#endif
#ifndef STBI\_NO\_STDIO#include <stdio.h>#endif
#ifndef STBI\_ASSERT#include <assert.h>#define STBI\_ASSERT(x) assert(x)#endif
#ifdef \_\_cplusplus#define STBI\_EXTERN extern "C"#else#define STBI\_EXTERN extern#endif
#ifndef \_MSC\_VER #ifdef \_\_cplusplus #define stbi\_inline inline #else #define stbi\_inline #endif#else #define stbi\_inline \_\_forceinline#endif
#ifndef STBI\_NO\_THREAD\_LOCALS #if defined(\_\_cplusplus) && \_\_cplusplus >= 201103L #define STBI\_THREAD\_LOCAL thread\_local #elif defined(\_\_GNUC\_\_) && \_\_GNUC\_\_ < 5 #define STBI\_THREAD\_LOCAL \_\_thread #elif defined(\_MSC\_VER) #define STBI\_THREAD\_LOCAL \_\_declspec(thread) #elif defined (\_\_STDC\_VERSION\_\_) && \_\_STDC\_VERSION\_\_ >= 201112L && !defined(\_\_STDC\_NO\_THREADS\_\_) #define STBI\_THREAD\_LOCAL \_Thread\_local #endif
 #ifndef STBI\_THREAD\_LOCAL #if defined(\_\_GNUC\_\_) #define STBI\_THREAD\_LOCAL \_\_thread #endif #endif#endif
#if defined(\_MSC\_VER) || defined(\_\_SYMBIAN32\_\_)typedef unsigned short stbi\_\_uint16;typedef signed short stbi\_\_int16;typedef unsigned int stbi\_\_uint32;typedef signed int stbi\_\_int32;#else#include <stdint.h>typedef uint16\_t stbi\_\_uint16;typedef int16\_t stbi\_\_int16;typedef uint32\_t stbi\_\_uint32;typedef int32\_t stbi\_\_int32;#endif
// should produce compiler error if size is wrongtypedef unsigned char validate\_uint32[sizeof(stbi\_\_uint32)==4 ? 1 : -1];
#ifdef \_MSC\_VER#define STBI\_NOTUSED(v) (void)(v)#else#define STBI\_NOTUSED(v) (void)sizeof(v)#endif
#ifdef \_MSC\_VER#define STBI\_HAS\_LROTL#endif
#ifdef STBI\_HAS\_LROTL #define stbi\_lrot(x,y) \_lrotl(x,y)#else #define stbi\_lrot(x,y) (((x) << (y)) | ((x) >> (-(y) & 31)))#endif
#if defined(STBI\_MALLOC) && defined(STBI\_FREE) && (defined(STBI\_REALLOC) || defined(STBI\_REALLOC\_SIZED))// ok#elif !defined(STBI\_MALLOC) && !defined(STBI\_FREE) && !defined(STBI\_REALLOC) && !defined(STBI\_REALLOC\_SIZED)// ok#else#error "Must define all or none of STBI\_MALLOC, STBI\_FREE, and STBI\_REALLOC (or STBI\_REALLOC\_SIZED)."#endif
#ifndef STBI\_MALLOC#define STBI\_MALLOC(sz) malloc(sz)#define STBI\_REALLOC(p,newsz) realloc(p,newsz)#define STBI\_FREE(p) free(p)#endif
#ifndef STBI\_REALLOC\_SIZED#define STBI\_REALLOC\_SIZED(p,oldsz,newsz) STBI\_REALLOC(p,newsz)#endif
// x86/x64 detection#if defined(\_\_x86\_64\_\_) || defined(\_M\_X64)#define STBI\_\_X64\_TARGET#elif defined(\_\_i386) || defined(\_M\_IX86)#define STBI\_\_X86\_TARGET#endif
#if defined(\_\_GNUC\_\_) && defined(STBI\_\_X86\_TARGET) && !defined(\_\_SSE2\_\_) && !defined(STBI\_NO\_SIMD)// gcc doesn't support sse2 intrinsics unless you compile with -msse2,// which in turn means it gets to use SSE2 everywhere. This is unfortunate,// but previous attempts to provide the SSE2 functions with runtime// detection caused numerous issues. The way architecture extensions are// exposed in GCC/Clang is, sadly, not really suited for one-file libs.// New behavior: if compiled with -msse2, we use SSE2 without any// detection; if not, we don't use it at all.#define STBI\_NO\_SIMD#endif
#if defined(\_\_MINGW32\_\_) && defined(STBI\_\_X86\_TARGET) && !defined(STBI\_MINGW\_ENABLE\_SSE2) && !defined(STBI\_NO\_SIMD)// Note that \_\_MINGW32\_\_ doesn't actually mean 32-bit, so we have to avoid STBI\_\_X64\_TARGET//// 32-bit MinGW wants ESP to be 16-byte aligned, but this is not in the// Windows ABI and VC++ as well as Windows DLLs don't maintain that invariant.// As a result, enabling SSE2 on 32-bit MinGW is dangerous when not// simultaneously enabling "-mstackrealign".//// See https://github.com/nothings/stb/issues/81 for more information.//// So default to no SSE2 on 32-bit MinGW. If you've read this far and added// -mstackrealign to your build settings, feel free to #define STBI\_MINGW\_ENABLE\_SSE2.#define STBI\_NO\_SIMD#endif
#if !defined(STBI\_NO\_SIMD) && (defined(STBI\_\_X86\_TARGET) || defined(STBI\_\_X64\_TARGET))#define STBI\_SSE2#include <emmintrin.h>
#ifdef \_MSC\_VER
#if \_MSC\_VER >= 1400 // not VC6#include <intrin.h> // \_\_cpuidstatic int stbi\_\_cpuid3(void){ int info[4]; \_\_cpuid(info,1); return info[3];}#elsestatic int stbi\_\_cpuid3(void){ int res; \_\_asm { mov eax,1 cpuid mov res,edx } return res;}#endif
#define STBI\_SIMD\_ALIGN(type, name) \_\_declspec(align(16)) type name
#if !defined(STBI\_NO\_JPEG) && defined(STBI\_SSE2)static int stbi\_\_sse2\_available(void){ int info3 = stbi\_\_cpuid3(); return ((info3 >> 26) & 1) != 0;}#endif
#else // assume GCC-style if not VC++#define STBI\_SIMD\_ALIGN(type, name) type name \_\_attribute\_\_((aligned(16)))
#if !defined(STBI\_NO\_JPEG) && defined(STBI\_SSE2)static int stbi\_\_sse2\_available(void){ // If we're even attempting to compile this on GCC/Clang, that means // -msse2 is on, which means the compiler is allowed to use SSE2 // instructions at will, and so are we. return 1;}#endif
#endif#endif
// ARM NEON#if defined(STBI\_NO\_SIMD) && defined(STBI\_NEON)#undef STBI\_NEON#endif
#ifdef STBI\_NEON#include <arm\_neon.h>#ifdef \_MSC\_VER#define STBI\_SIMD\_ALIGN(type, name) \_\_declspec(align(16)) type name#else#define STBI\_SIMD\_ALIGN(type, name) type name \_\_attribute\_\_((aligned(16)))#endif#endif
#ifndef STBI\_SIMD\_ALIGN#define STBI\_SIMD\_ALIGN(type, name) type name#endif
#ifndef STBI\_MAX\_DIMENSIONS#define STBI\_MAX\_DIMENSIONS (1 << 24)#endif
/////////////////////////////////////////////////// stbi\_\_context struct and start\_xxx functions
// stbi\_\_context structure is our basic context used by all images, so it// contains all the IO context, plus some basic image informationtypedef struct{ stbi\_\_uint32 img\_x, img\_y; int img\_n, img\_out\_n;
 stbi\_io\_callbacks io; void \*io\_user\_data;
 int read\_from\_callbacks; int buflen; stbi\_uc buffer\_start[128]; int callback\_already\_read;
 stbi\_uc \*img\_buffer, \*img\_buffer\_end; stbi\_uc \*img\_buffer\_original, \*img\_buffer\_original\_end;} stbi\_\_context;
static void stbi\_\_refill\_buffer(stbi\_\_context \*s);
// initialize a memory-decode contextstatic void stbi\_\_start\_mem(stbi\_\_context \*s, stbi\_uc const \*buffer, int len){ s->io.read = NULL; s->read\_from\_callbacks = 0; s->callback\_already\_read = 0; s->img\_buffer = s->img\_buffer\_original = (stbi\_uc \*) buffer; s->img\_buffer\_end = s->img\_buffer\_original\_end = (stbi\_uc \*) buffer+len;}
// initialize a callback-based contextstatic void stbi\_\_start\_callbacks(stbi\_\_context \*s, stbi\_io\_callbacks \*c, void \*user){ s->io = \*c; s->io\_user\_data = user; s->buflen = sizeof(s->buffer\_start); s->read\_from\_callbacks = 1; s->callback\_already\_read = 0; s->img\_buffer = s->img\_buffer\_original = s->buffer\_start; stbi\_\_refill\_buffer(s); s->img\_buffer\_original\_end = s->img\_buffer\_end;}
#ifndef STBI\_NO\_STDIO
static int stbi\_\_stdio\_read(void \*user, char \*data, int size){ return (int) fread(data,1,size,(FILE\*) user);}
static void stbi\_\_stdio\_skip(void \*user, int n){ int ch; fseek((FILE\*) user, n, SEEK\_CUR); ch = fgetc((FILE\*) user); /\* have to read a byte to reset feof()'s flag \*/ if (ch != EOF) { ungetc(ch, (FILE \*) user); /\* push byte back onto stream if valid. \*/ }}
static int stbi\_\_stdio\_eof(void \*user){ return feof((FILE\*) user) || ferror((FILE \*) user);}
static stbi\_io\_callbacks stbi\_\_stdio\_callbacks ={ stbi\_\_stdio\_read, stbi\_\_stdio\_skip, stbi\_\_stdio\_eof,};
static void stbi\_\_start\_file(stbi\_\_context \*s, FILE \*f){ stbi\_\_start\_callbacks(s, &stbi\_\_stdio\_callbacks, (void \*) f);}
//static void stop\_file(stbi\_\_context \*s) { }
#endif // !STBI\_NO\_STDIO
static void stbi\_\_rewind(stbi\_\_context \*s){ // conceptually rewind SHOULD rewind to the beginning of the stream, // but we just rewind to the beginning of the initial buffer, because // we only use it after doing 'test', which only ever looks at at most 92 bytes s->img\_buffer = s->img\_buffer\_original; s->img\_buffer\_end = s->img\_buffer\_original\_end;}
enum{ STBI\_ORDER\_RGB, STBI\_ORDER\_BGR};
typedef struct{ int bits\_per\_channel; int num\_channels; int channel\_order;} stbi\_\_result\_info;
#ifndef STBI\_NO\_JPEGstatic int stbi\_\_jpeg\_test(stbi\_\_context \*s);static void \*stbi\_\_jpeg\_load(stbi\_\_context \*s, int \*x, int \*y, int \*comp, int req\_comp, stbi\_\_result\_info \*ri);static int stbi\_\_jpeg\_info(stbi\_\_context \*s, int \*x, int \*y, int \*comp);#endif
#ifndef STBI\_NO\_PNGstatic int stbi\_\_png\_test(stbi\_\_context \*s);static void \*stbi\_\_png\_load(stbi\_\_context \*s, int \*x, int \*y, int \*comp, int req\_comp, stbi\_\_result\_info \*ri);static int stbi\_\_png\_info(stbi\_\_context \*s, int \*x, int \*y, int \*comp);static int stbi\_\_png\_is16(stbi\_\_context \*s);#endif
#ifndef STBI\_NO\_BMPstatic int stbi\_\_bmp\_test(stbi\_\_context \*s);static void \*stbi\_\_bmp\_load(stbi\_\_context \*s, int \*x, int \*y, int \*comp, int req\_comp, stbi\_\_result\_info \*ri);static int stbi\_\_bmp\_info(stbi\_\_context \*s, int \*x, int \*y, int \*comp);#endif
#ifndef STBI\_NO\_TGAstatic int stbi\_\_tga\_test(stbi\_\_context \*s);static void \*stbi\_\_tga\_load(stbi\_\_context \*s, int \*x, int \*y, int \*comp, int req\_comp, stbi\_\_result\_info \*ri);static int stbi\_\_tga\_info(stbi\_\_context \*s, int \*x, int \*y, int \*comp);#endif
#ifndef STBI\_NO\_PSDstatic int stbi\_\_psd\_test(stbi\_\_context \*s);static void \*stbi\_\_psd\_load(stbi\_\_context \*s, int \*x, int \*y, int \*comp, int req\_comp, stbi\_\_result\_info \*ri, int bpc);static int stbi\_\_psd\_info(stbi\_\_context \*s, int \*x, int \*y, int \*comp);static int stbi\_\_psd\_is16(stbi\_\_context \*s);#endif
#ifndef STBI\_NO\_HDRstatic int stbi\_\_hdr\_test(stbi\_\_context \*s);static float \*stbi\_\_hdr\_load(stbi\_\_context \*s, int \*x, int \*y, int \*comp, int req\_comp, stbi\_\_result\_info \*ri);static int stbi\_\_hdr\_info(stbi\_\_context \*s, int \*x, int \*y, int \*comp);#endif
#ifndef STBI\_NO\_PICstatic int stbi\_\_pic\_test(stbi\_\_context \*s);static void \*stbi\_\_pic\_load(stbi\_\_context \*s, int \*x, int \*y, int \*comp, int req\_comp, stbi\_\_result\_info \*ri);static int stbi\_\_pic\_info(stbi\_\_context \*s, int \*x, int \*y, int \*comp);#endif
#ifndef STBI\_NO\_GIFstatic int stbi\_\_gif\_test(stbi\_\_context \*s);static void \*stbi\_\_gif\_load(stbi\_\_context \*s, int \*x, int \*y, int \*comp, int req\_comp, stbi\_\_result\_info \*ri);static void \*stbi\_\_load\_gif\_main(stbi\_\_context \*s, int \*\*delays, int \*x, int \*y, int \*z, int \*comp, int req\_comp);static int stbi\_\_gif\_info(stbi\_\_context \*s, int \*x, int \*y, int \*comp);#endif
#ifndef STBI\_NO\_PNMstatic int stbi\_\_pnm\_test(stbi\_\_context \*s);static void \*stbi\_\_pnm\_load(stbi\_\_context \*s, int \*x, int \*y, int \*comp, int req\_comp, stbi\_\_result\_info \*ri);static int stbi\_\_pnm\_info(stbi\_\_context \*s, int \*x, int \*y, int \*comp);static int stbi\_\_pnm\_is16(stbi\_\_context \*s);#endif
static#ifdef STBI\_THREAD\_LOCALSTBI\_THREAD\_LOCAL#endifconst char \*stbi\_\_g\_failure\_reason;
STBIDEF const char \*stbi\_failure\_reason(void){ return stbi\_\_g\_failure\_reason;}
#ifndef STBI\_NO\_FAILURE\_STRINGSstatic int stbi\_\_err(const char \*str){ stbi\_\_g\_failure\_reason = str; return 0;}#endif
static void \*stbi\_\_malloc(size\_t size){ return STBI\_MALLOC(size);}
// stb\_image uses ints pervasively, including for offset calculations.// therefore the largest decoded image size we can support with the// current code, even on 64-bit targets, is INT\_MAX. this is not a// significant limitation for the intended use case.//// we do, however, need to make sure our size calculations don't// overflow. hence a few helper functions for size calculations that// multiply integers together, making sure that they're non-negative// and no overflow occurs.
// return 1 if the sum is valid, 0 on overflow.// negative terms are considered invalid.static int stbi\_\_addsizes\_valid(int a, int b)[View remainder of file in raw view](https://github.com/nothings/stb/raw/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/stb_image.h)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

