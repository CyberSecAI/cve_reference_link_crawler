=== Content from git.kernel.org_e539b15b_20250111_190018.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=76569e3819e0bb59fc19b1b8688b017e627c268a)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=76569e3819e0bb59fc19b1b8688b017e627c268a)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=76569e3819e0bb59fc19b1b8688b017e627c268a)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=76569e3819e0bb59fc19b1b8688b017e627c268a)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Zhang Xiaoxu <zhangxiaoxu5@huawei.com> | 2023-09-19 13:38:04 -0500 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2023-10-06 13:15:59 +0200 |
| commit | [76569e3819e0bb59fc19b1b8688b017e627c268a](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=76569e3819e0bb59fc19b1b8688b017e627c268a) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=76569e3819e0bb59fc19b1b8688b017e627c268a)) | |
| tree | [8a413f628f7cf95df92e2f529728db198057cb70](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=76569e3819e0bb59fc19b1b8688b017e627c268a) | |
| parent | [674a8a9f78483777f521c94ddde1ab8110257281](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=674a8a9f78483777f521c94ddde1ab8110257281) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=76569e3819e0bb59fc19b1b8688b017e627c268a&id2=674a8a9f78483777f521c94ddde1ab8110257281)) | |
| download | [linux-76569e3819e0bb59fc19b1b8688b017e627c268a.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-76569e3819e0bb59fc19b1b8688b017e627c268a.tar.gz) | |

cifs: Fix UAF in cifs\_demultiplex\_thread()[ Upstream commit d527f51331cace562393a8038d870b3e9916686f ]
There is a UAF when xfstests on cifs:
BUG: KASAN: use-after-free in smb2\_is\_network\_name\_deleted+0x27/0x160
Read of size 4 at addr ffff88810103fc08 by task cifsd/923
CPU: 1 PID: 923 Comm: cifsd Not tainted 6.1.0-rc4+ #45
...
Call Trace:
<TASK>
dump\_stack\_lvl+0x34/0x44
print\_report+0x171/0x472
kasan\_report+0xad/0x130
kasan\_check\_range+0x145/0x1a0
smb2\_is\_network\_name\_deleted+0x27/0x160
cifs\_demultiplex\_thread.cold+0x172/0x5a4
kthread+0x165/0x1a0
ret\_from\_fork+0x1f/0x30
</TASK>
Allocated by task 923:
kasan\_save\_stack+0x1e/0x40
kasan\_set\_track+0x21/0x30
\_\_kasan\_slab\_alloc+0x54/0x60
kmem\_cache\_alloc+0x147/0x320
mempool\_alloc+0xe1/0x260
cifs\_small\_buf\_get+0x24/0x60
allocate\_buffers+0xa1/0x1c0
cifs\_demultiplex\_thread+0x199/0x10d0
kthread+0x165/0x1a0
ret\_from\_fork+0x1f/0x30
Freed by task 921:
kasan\_save\_stack+0x1e/0x40
kasan\_set\_track+0x21/0x30
kasan\_save\_free\_info+0x2a/0x40
\_\_\_\_kasan\_slab\_free+0x143/0x1b0
kmem\_cache\_free+0xe3/0x4d0
cifs\_small\_buf\_release+0x29/0x90
SMB2\_negotiate+0x8b7/0x1c60
smb2\_negotiate+0x51/0x70
cifs\_negotiate\_protocol+0xf0/0x160
cifs\_get\_smb\_ses+0x5fa/0x13c0
mount\_get\_conns+0x7a/0x750
cifs\_mount+0x103/0xd00
cifs\_smb3\_do\_mount+0x1dd/0xcb0
smb3\_get\_tree+0x1d5/0x300
vfs\_get\_tree+0x41/0xf0
path\_mount+0x9b3/0xdd0
\_\_x64\_sys\_mount+0x190/0x1d0
do\_syscall\_64+0x35/0x80
entry\_SYSCALL\_64\_after\_hwframe+0x46/0xb0
The UAF is because:
mount(pid: 921) | cifsd(pid: 923)
-------------------------------|-------------------------------
| cifs\_demultiplex\_thread
SMB2\_negotiate |
cifs\_send\_recv |
compound\_send\_recv |
smb\_send\_rqst |
wait\_for\_response |
wait\_event\_state [1] |
| standard\_receive3
| cifs\_handle\_standard
| handle\_mid
| mid->resp\_buf = buf; [2]
| dequeue\_mid [3]
KILL the process [4] |
resp\_iov[i].iov\_base = buf |
free\_rsp\_buf [5] |
| is\_network\_name\_deleted [6]
| callback
1. After send request to server, wait the response until
mid->mid\_state != SUBMITTED;
2. Receive response from server, and set it to mid;
3. Set the mid state to RECEIVED;
4. Kill the process, the mid state already RECEIVED, get 0;
5. Handle and release the negotiate response;
6. UAF.
It can be easily reproduce with add some delay in [3] - [6].
Only sync call has the problem since async call's callback is
executed in cifsd process.
Add an extra state to mark the mid state to READY before wakeup the
waitter, then it can get the resp safely.
Fixes: ec637e3ffb6b ("[CIFS] Avoid extra large buffer allocation (and memcpy) in cifs\_readpages")
Reviewed-by: Paulo Alcantara (SUSE) <pc@manguebit.com>
Signed-off-by: Zhang Xiaoxu <zhangxiaoxu5@huawei.com>
Signed-off-by: Steve French <stfrench@microsoft.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=76569e3819e0bb59fc19b1b8688b017e627c268a)

| -rw-r--r-- | [fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/cifsglob.h?id=76569e3819e0bb59fc19b1b8688b017e627c268a) | 1 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/smb/client/transport.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/transport.c?id=76569e3819e0bb59fc19b1b8688b017e627c268a) | 34 | |  |  |  | | --- | --- | --- | |

2 files changed, 24 insertions, 11 deletions

| diff --git a/fs/smb/client/cifsglob.h b/fs/smb/client/cifsglob.hindex 051f15b9d6078b..35782a6bede0bf 100644--- a/[fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsglob.h?id=674a8a9f78483777f521c94ddde1ab8110257281)+++ b/[fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsglob.h?id=76569e3819e0bb59fc19b1b8688b017e627c268a)@@ -1776,6 +1776,7 @@ static inline bool is\_retryable\_error(int error) #define MID\_RETRY\_NEEDED 8 /\* session closed while this request out \*/ #define MID\_RESPONSE\_MALFORMED 0x10 #define MID\_SHUTDOWN 0x20+#define MID\_RESPONSE\_READY 0x40 /\* ready for other process handle the rsp \*/  /\* Flags \*/ #define MID\_WAIT\_CANCELLED 1 /\* Cancelled while waiting for response \*/diff --git a/fs/smb/client/transport.c b/fs/smb/client/transport.cindex f280502a2aee88..2b9a2ed45a652d 100644--- a/[fs/smb/client/transport.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/transport.c?id=674a8a9f78483777f521c94ddde1ab8110257281)+++ b/[fs/smb/client/transport.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/transport.c?id=76569e3819e0bb59fc19b1b8688b017e627c268a)@@ -35,6 +35,8 @@ void cifs\_wake\_up\_task(struct mid\_q\_entry \*mid) {+ if (mid->mid\_state == MID\_RESPONSE\_RECEIVED)+ mid->mid\_state = MID\_RESPONSE\_READY; wake\_up\_process(mid->callback\_data); } @@ -87,7 +89,8 @@ static void \_\_release\_mid(struct kref \*refcount) struct TCP\_Server\_Info \*server = midEntry->server;  if (midEntry->resp\_buf && (midEntry->mid\_flags & MID\_WAIT\_CANCELLED) &&- midEntry->mid\_state == MID\_RESPONSE\_RECEIVED &&+ (midEntry->mid\_state == MID\_RESPONSE\_RECEIVED ||+ midEntry->mid\_state == MID\_RESPONSE\_READY) && server->ops->handle\_cancelled\_mid) server->ops->handle\_cancelled\_mid(midEntry, server); @@ -732,7 +735,8 @@ wait\_for\_response(struct TCP\_Server\_Info \*server, struct mid\_q\_entry \*midQ) int error;  error = wait\_event\_state(server->response\_q,- midQ->mid\_state != MID\_REQUEST\_SUBMITTED,+ midQ->mid\_state != MID\_REQUEST\_SUBMITTED &&+ midQ->mid\_state != MID\_RESPONSE\_RECEIVED, (TASK\_KILLABLE|TASK\_FREEZABLE\_UNSAFE)); if (error < 0) return -ERESTARTSYS;@@ -885,7 +889,7 @@ cifs\_sync\_mid\_result(struct mid\_q\_entry \*mid, struct TCP\_Server\_Info \*server)  spin\_lock(&server->mid\_lock); switch (mid->mid\_state) {- case MID\_RESPONSE\_RECEIVED:+ case MID\_RESPONSE\_READY: spin\_unlock(&server->mid\_lock); return rc; case MID\_RETRY\_NEEDED:@@ -984,6 +988,9 @@ cifs\_compound\_callback(struct mid\_q\_entry \*mid) credits.instance = server->reconnect\_instance;  add\_credits(server, &credits, mid->optype);++ if (mid->mid\_state == MID\_RESPONSE\_RECEIVED)+ mid->mid\_state = MID\_RESPONSE\_READY; }  static void@@ -1204,7 +1211,8 @@ compound\_send\_recv(const unsigned int xid, struct cifs\_ses \*ses, send\_cancel(server, &rqst[i], midQ[i]); spin\_lock(&server->mid\_lock); midQ[i]->mid\_flags |= MID\_WAIT\_CANCELLED;- if (midQ[i]->mid\_state == MID\_REQUEST\_SUBMITTED) {+ if (midQ[i]->mid\_state == MID\_REQUEST\_SUBMITTED ||+ midQ[i]->mid\_state == MID\_RESPONSE\_RECEIVED) { midQ[i]->callback = cifs\_cancelled\_callback; cancelled\_mid[i] = true; credits[i].value = 0;@@ -1225,7 +1233,7 @@ compound\_send\_recv(const unsigned int xid, struct cifs\_ses \*ses, }  if (!midQ[i]->resp\_buf ||- midQ[i]->mid\_state != MID\_RESPONSE\_RECEIVED) {+ midQ[i]->mid\_state != MID\_RESPONSE\_READY) { rc = -EIO; cifs\_dbg(FYI, "Bad MID state?\n"); goto out;@@ -1412,7 +1420,8 @@ SendReceive(const unsigned int xid, struct cifs\_ses \*ses, if (rc != 0) { send\_cancel(server, &rqst, midQ); spin\_lock(&server->mid\_lock);- if (midQ->mid\_state == MID\_REQUEST\_SUBMITTED) {+ if (midQ->mid\_state == MID\_REQUEST\_SUBMITTED ||+ midQ->mid\_state == MID\_RESPONSE\_RECEIVED) { /\* no longer considered to be "in-flight" \*/ midQ->callback = release\_mid; spin\_unlock(&server->mid\_lock);@@ -1429,7 +1438,7 @@ SendReceive(const unsigned int xid, struct cifs\_ses \*ses, }  if (!midQ->resp\_buf || !out\_buf ||- midQ->mid\_state != MID\_RESPONSE\_RECEIVED) {+ midQ->mid\_state != MID\_RESPONSE\_READY) { rc = -EIO; cifs\_server\_dbg(VFS, "Bad MID state?\n"); goto out;@@ -1553,14 +1562,16 @@ SendReceiveBlockingLock(const unsigned int xid, struct cifs\_tcon \*tcon,  /\* Wait for a reply - allow signals to interrupt. \*/ rc = wait\_event\_interruptible(server->response\_q,- (!(midQ->mid\_state == MID\_REQUEST\_SUBMITTED)) ||+ (!(midQ->mid\_state == MID\_REQUEST\_SUBMITTED ||+ midQ->mid\_state == MID\_RESPONSE\_RECEIVED)) || ((server->tcpStatus != CifsGood) && (server->tcpStatus != CifsNew)));  /\* Were we interrupted by a signal ? \*/ spin\_lock(&server->srv\_lock); if ((rc == -ERESTARTSYS) &&- (midQ->mid\_state == MID\_REQUEST\_SUBMITTED) &&+ (midQ->mid\_state == MID\_REQUEST\_SUBMITTED ||+ midQ->mid\_state == MID\_RESPONSE\_RECEIVED) && ((server->tcpStatus == CifsGood) || (server->tcpStatus == CifsNew))) { spin\_unlock(&server->srv\_lock);@@ -1591,7 +1602,8 @@ SendReceiveBlockingLock(const unsigned int xid, struct cifs\_tcon \*tcon, if (rc) { send\_cancel(server, &rqst, midQ); spin\_lock(&server->mid\_lock);- if (midQ->mid\_state == MID\_REQUEST\_SUBMITTED) {+ if (midQ->mid\_state == MID\_REQUEST\_SUBMITTED ||+ midQ->mid\_state == MID\_RESPONSE\_RECEIVED) { /\* no longer considered to be "in-flight" \*/ midQ->callback = release\_mid; spin\_unlock(&server->mid\_lock);@@ -1611,7 +1623,7 @@ SendReceiveBlockingLock(const unsigned int xid, struct cifs\_tcon \*tcon, return rc;  /\* rcvd frame is ok \*/- if (out\_buf == NULL || midQ->mid\_state != MID\_RESPONSE\_RECEIVED) {+ if (out\_buf == NULL || midQ->mid\_state != MID\_RESPONSE\_READY) { rc = -EIO; cifs\_tcon\_dbg(VFS, "Bad MID state?\n"); goto out; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 18:58:56 +0000



=== Content from git.kernel.org_b5b5c1f3_20250111_190019.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=908b3b5e97d25e879de3d1f172a255665491c2c3)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=908b3b5e97d25e879de3d1f172a255665491c2c3)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=908b3b5e97d25e879de3d1f172a255665491c2c3)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=908b3b5e97d25e879de3d1f172a255665491c2c3)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Zhang Xiaoxu <zhangxiaoxu5@huawei.com> | 2023-09-19 13:38:04 -0500 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2023-10-06 14:56:42 +0200 |
| commit | [908b3b5e97d25e879de3d1f172a255665491c2c3](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=908b3b5e97d25e879de3d1f172a255665491c2c3) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=908b3b5e97d25e879de3d1f172a255665491c2c3)) | |
| tree | [d391425b8bc18c790493d0e7b3ec567c286dfb0c](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=908b3b5e97d25e879de3d1f172a255665491c2c3) | |
| parent | [7e4f49cd2bd7ded92c33f975fe2ad5e7c7d77f72](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7e4f49cd2bd7ded92c33f975fe2ad5e7c7d77f72) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=908b3b5e97d25e879de3d1f172a255665491c2c3&id2=7e4f49cd2bd7ded92c33f975fe2ad5e7c7d77f72)) | |
| download | [linux-908b3b5e97d25e879de3d1f172a255665491c2c3.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-908b3b5e97d25e879de3d1f172a255665491c2c3.tar.gz) | |

cifs: Fix UAF in cifs\_demultiplex\_thread()[ Upstream commit d527f51331cace562393a8038d870b3e9916686f ]
There is a UAF when xfstests on cifs:
BUG: KASAN: use-after-free in smb2\_is\_network\_name\_deleted+0x27/0x160
Read of size 4 at addr ffff88810103fc08 by task cifsd/923
CPU: 1 PID: 923 Comm: cifsd Not tainted 6.1.0-rc4+ #45
...
Call Trace:
<TASK>
dump\_stack\_lvl+0x34/0x44
print\_report+0x171/0x472
kasan\_report+0xad/0x130
kasan\_check\_range+0x145/0x1a0
smb2\_is\_network\_name\_deleted+0x27/0x160
cifs\_demultiplex\_thread.cold+0x172/0x5a4
kthread+0x165/0x1a0
ret\_from\_fork+0x1f/0x30
</TASK>
Allocated by task 923:
kasan\_save\_stack+0x1e/0x40
kasan\_set\_track+0x21/0x30
\_\_kasan\_slab\_alloc+0x54/0x60
kmem\_cache\_alloc+0x147/0x320
mempool\_alloc+0xe1/0x260
cifs\_small\_buf\_get+0x24/0x60
allocate\_buffers+0xa1/0x1c0
cifs\_demultiplex\_thread+0x199/0x10d0
kthread+0x165/0x1a0
ret\_from\_fork+0x1f/0x30
Freed by task 921:
kasan\_save\_stack+0x1e/0x40
kasan\_set\_track+0x21/0x30
kasan\_save\_free\_info+0x2a/0x40
\_\_\_\_kasan\_slab\_free+0x143/0x1b0
kmem\_cache\_free+0xe3/0x4d0
cifs\_small\_buf\_release+0x29/0x90
SMB2\_negotiate+0x8b7/0x1c60
smb2\_negotiate+0x51/0x70
cifs\_negotiate\_protocol+0xf0/0x160
cifs\_get\_smb\_ses+0x5fa/0x13c0
mount\_get\_conns+0x7a/0x750
cifs\_mount+0x103/0xd00
cifs\_smb3\_do\_mount+0x1dd/0xcb0
smb3\_get\_tree+0x1d5/0x300
vfs\_get\_tree+0x41/0xf0
path\_mount+0x9b3/0xdd0
\_\_x64\_sys\_mount+0x190/0x1d0
do\_syscall\_64+0x35/0x80
entry\_SYSCALL\_64\_after\_hwframe+0x46/0xb0
The UAF is because:
mount(pid: 921) | cifsd(pid: 923)
-------------------------------|-------------------------------
| cifs\_demultiplex\_thread
SMB2\_negotiate |
cifs\_send\_recv |
compound\_send\_recv |
smb\_send\_rqst |
wait\_for\_response |
wait\_event\_state [1] |
| standard\_receive3
| cifs\_handle\_standard
| handle\_mid
| mid->resp\_buf = buf; [2]
| dequeue\_mid [3]
KILL the process [4] |
resp\_iov[i].iov\_base = buf |
free\_rsp\_buf [5] |
| is\_network\_name\_deleted [6]
| callback
1. After send request to server, wait the response until
mid->mid\_state != SUBMITTED;
2. Receive response from server, and set it to mid;
3. Set the mid state to RECEIVED;
4. Kill the process, the mid state already RECEIVED, get 0;
5. Handle and release the negotiate response;
6. UAF.
It can be easily reproduce with add some delay in [3] - [6].
Only sync call has the problem since async call's callback is
executed in cifsd process.
Add an extra state to mark the mid state to READY before wakeup the
waitter, then it can get the resp safely.
Fixes: ec637e3ffb6b ("[CIFS] Avoid extra large buffer allocation (and memcpy) in cifs\_readpages")
Reviewed-by: Paulo Alcantara (SUSE) <pc@manguebit.com>
Signed-off-by: Zhang Xiaoxu <zhangxiaoxu5@huawei.com>
Signed-off-by: Steve French <stfrench@microsoft.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=908b3b5e97d25e879de3d1f172a255665491c2c3)

| -rw-r--r-- | [fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/cifsglob.h?id=908b3b5e97d25e879de3d1f172a255665491c2c3) | 1 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/smb/client/transport.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/transport.c?id=908b3b5e97d25e879de3d1f172a255665491c2c3) | 34 | |  |  |  | | --- | --- | --- | |

2 files changed, 24 insertions, 11 deletions

| diff --git a/fs/smb/client/cifsglob.h b/fs/smb/client/cifsglob.hindex 03f34ec63e10dd..39602f39aea8fe 100644--- a/[fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsglob.h?id=7e4f49cd2bd7ded92c33f975fe2ad5e7c7d77f72)+++ b/[fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsglob.h?id=908b3b5e97d25e879de3d1f172a255665491c2c3)@@ -1776,6 +1776,7 @@ static inline bool is\_retryable\_error(int error) #define MID\_RETRY\_NEEDED 8 /\* session closed while this request out \*/ #define MID\_RESPONSE\_MALFORMED 0x10 #define MID\_SHUTDOWN 0x20+#define MID\_RESPONSE\_READY 0x40 /\* ready for other process handle the rsp \*/  /\* Flags \*/ #define MID\_WAIT\_CANCELLED 1 /\* Cancelled while waiting for response \*/diff --git a/fs/smb/client/transport.c b/fs/smb/client/transport.cindex e03ffcf7e201c9..87aea456ee9033 100644--- a/[fs/smb/client/transport.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/transport.c?id=7e4f49cd2bd7ded92c33f975fe2ad5e7c7d77f72)+++ b/[fs/smb/client/transport.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/transport.c?id=908b3b5e97d25e879de3d1f172a255665491c2c3)@@ -35,6 +35,8 @@ void cifs\_wake\_up\_task(struct mid\_q\_entry \*mid) {+ if (mid->mid\_state == MID\_RESPONSE\_RECEIVED)+ mid->mid\_state = MID\_RESPONSE\_READY; wake\_up\_process(mid->callback\_data); } @@ -87,7 +89,8 @@ static void \_\_release\_mid(struct kref \*refcount) struct TCP\_Server\_Info \*server = midEntry->server;  if (midEntry->resp\_buf && (midEntry->mid\_flags & MID\_WAIT\_CANCELLED) &&- midEntry->mid\_state == MID\_RESPONSE\_RECEIVED &&+ (midEntry->mid\_state == MID\_RESPONSE\_RECEIVED ||+ midEntry->mid\_state == MID\_RESPONSE\_READY) && server->ops->handle\_cancelled\_mid) server->ops->handle\_cancelled\_mid(midEntry, server); @@ -759,7 +762,8 @@ wait\_for\_response(struct TCP\_Server\_Info \*server, struct mid\_q\_entry \*midQ) int error;  error = wait\_event\_state(server->response\_q,- midQ->mid\_state != MID\_REQUEST\_SUBMITTED,+ midQ->mid\_state != MID\_REQUEST\_SUBMITTED &&+ midQ->mid\_state != MID\_RESPONSE\_RECEIVED, (TASK\_KILLABLE|TASK\_FREEZABLE\_UNSAFE)); if (error < 0) return -ERESTARTSYS;@@ -912,7 +916,7 @@ cifs\_sync\_mid\_result(struct mid\_q\_entry \*mid, struct TCP\_Server\_Info \*server)  spin\_lock(&server->mid\_lock); switch (mid->mid\_state) {- case MID\_RESPONSE\_RECEIVED:+ case MID\_RESPONSE\_READY: spin\_unlock(&server->mid\_lock); return rc; case MID\_RETRY\_NEEDED:@@ -1011,6 +1015,9 @@ cifs\_compound\_callback(struct mid\_q\_entry \*mid) credits.instance = server->reconnect\_instance;  add\_credits(server, &credits, mid->optype);++ if (mid->mid\_state == MID\_RESPONSE\_RECEIVED)+ mid->mid\_state = MID\_RESPONSE\_READY; }  static void@@ -1206,7 +1213,8 @@ compound\_send\_recv(const unsigned int xid, struct cifs\_ses \*ses, send\_cancel(server, &rqst[i], midQ[i]); spin\_lock(&server->mid\_lock); midQ[i]->mid\_flags |= MID\_WAIT\_CANCELLED;- if (midQ[i]->mid\_state == MID\_REQUEST\_SUBMITTED) {+ if (midQ[i]->mid\_state == MID\_REQUEST\_SUBMITTED ||+ midQ[i]->mid\_state == MID\_RESPONSE\_RECEIVED) { midQ[i]->callback = cifs\_cancelled\_callback; cancelled\_mid[i] = true; credits[i].value = 0;@@ -1227,7 +1235,7 @@ compound\_send\_recv(const unsigned int xid, struct cifs\_ses \*ses, }  if (!midQ[i]->resp\_buf ||- midQ[i]->mid\_state != MID\_RESPONSE\_RECEIVED) {+ midQ[i]->mid\_state != MID\_RESPONSE\_READY) { rc = -EIO; cifs\_dbg(FYI, "Bad MID state?\n"); goto out;@@ -1414,7 +1422,8 @@ SendReceive(const unsigned int xid, struct cifs\_ses \*ses, if (rc != 0) { send\_cancel(server, &rqst, midQ); spin\_lock(&server->mid\_lock);- if (midQ->mid\_state == MID\_REQUEST\_SUBMITTED) {+ if (midQ->mid\_state == MID\_REQUEST\_SUBMITTED ||+ midQ->mid\_state == MID\_RESPONSE\_RECEIVED) { /\* no longer considered to be "in-flight" \*/ midQ->callback = release\_mid; spin\_unlock(&server->mid\_lock);@@ -1431,7 +1440,7 @@ SendReceive(const unsigned int xid, struct cifs\_ses \*ses, }  if (!midQ->resp\_buf || !out\_buf ||- midQ->mid\_state != MID\_RESPONSE\_RECEIVED) {+ midQ->mid\_state != MID\_RESPONSE\_READY) { rc = -EIO; cifs\_server\_dbg(VFS, "Bad MID state?\n"); goto out;@@ -1555,14 +1564,16 @@ SendReceiveBlockingLock(const unsigned int xid, struct cifs\_tcon \*tcon,  /\* Wait for a reply - allow signals to interrupt. \*/ rc = wait\_event\_interruptible(server->response\_q,- (!(midQ->mid\_state == MID\_REQUEST\_SUBMITTED)) ||+ (!(midQ->mid\_state == MID\_REQUEST\_SUBMITTED ||+ midQ->mid\_state == MID\_RESPONSE\_RECEIVED)) || ((server->tcpStatus != CifsGood) && (server->tcpStatus != CifsNew)));  /\* Were we interrupted by a signal ? \*/ spin\_lock(&server->srv\_lock); if ((rc == -ERESTARTSYS) &&- (midQ->mid\_state == MID\_REQUEST\_SUBMITTED) &&+ (midQ->mid\_state == MID\_REQUEST\_SUBMITTED ||+ midQ->mid\_state == MID\_RESPONSE\_RECEIVED) && ((server->tcpStatus == CifsGood) || (server->tcpStatus == CifsNew))) { spin\_unlock(&server->srv\_lock);@@ -1593,7 +1604,8 @@ SendReceiveBlockingLock(const unsigned int xid, struct cifs\_tcon \*tcon, if (rc) { send\_cancel(server, &rqst, midQ); spin\_lock(&server->mid\_lock);- if (midQ->mid\_state == MID\_REQUEST\_SUBMITTED) {+ if (midQ->mid\_state == MID\_REQUEST\_SUBMITTED ||+ midQ->mid\_state == MID\_RESPONSE\_RECEIVED) { /\* no longer considered to be "in-flight" \*/ midQ->callback = release\_mid; spin\_unlock(&server->mid\_lock);@@ -1613,7 +1625,7 @@ SendReceiveBlockingLock(const unsigned int xid, struct cifs\_tcon \*tcon, return rc;  /\* rcvd frame is ok \*/- if (out\_buf == NULL || midQ->mid\_state != MID\_RESPONSE\_RECEIVED) {+ if (out\_buf == NULL || midQ->mid\_state != MID\_RESPONSE\_READY) { rc = -EIO; cifs\_tcon\_dbg(VFS, "Bad MID state?\n"); goto out; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 18:58:56 +0000



=== Content from git.kernel.org_615b7ce5_20250111_190020.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=d527f51331cace562393a8038d870b3e9916686f)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d527f51331cace562393a8038d870b3e9916686f)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d527f51331cace562393a8038d870b3e9916686f)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d527f51331cace562393a8038d870b3e9916686f)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Zhang Xiaoxu <zhangxiaoxu5@huawei.com> | 2023-09-19 13:38:04 -0500 |
| --- | --- | --- |
| committer | Steve French <stfrench@microsoft.com> | 2023-09-19 22:02:54 -0500 |
| commit | [d527f51331cace562393a8038d870b3e9916686f](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d527f51331cace562393a8038d870b3e9916686f) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=d527f51331cace562393a8038d870b3e9916686f)) | |
| tree | [2af9ff98a4614a24f354431be3948d97a0872c39](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d527f51331cace562393a8038d870b3e9916686f) | |
| parent | [2da338ff752a2789470d733111a5241f30026675](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=2da338ff752a2789470d733111a5241f30026675) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d527f51331cace562393a8038d870b3e9916686f&id2=2da338ff752a2789470d733111a5241f30026675)) | |
| download | [linux-d527f51331cace562393a8038d870b3e9916686f.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-d527f51331cace562393a8038d870b3e9916686f.tar.gz) | |

cifs: Fix UAF in cifs\_demultiplex\_thread()There is a UAF when xfstests on cifs:
BUG: KASAN: use-after-free in smb2\_is\_network\_name\_deleted+0x27/0x160
Read of size 4 at addr ffff88810103fc08 by task cifsd/923
CPU: 1 PID: 923 Comm: cifsd Not tainted 6.1.0-rc4+ #45
...
Call Trace:
<TASK>
dump\_stack\_lvl+0x34/0x44
print\_report+0x171/0x472
kasan\_report+0xad/0x130
kasan\_check\_range+0x145/0x1a0
smb2\_is\_network\_name\_deleted+0x27/0x160
cifs\_demultiplex\_thread.cold+0x172/0x5a4
kthread+0x165/0x1a0
ret\_from\_fork+0x1f/0x30
</TASK>
Allocated by task 923:
kasan\_save\_stack+0x1e/0x40
kasan\_set\_track+0x21/0x30
\_\_kasan\_slab\_alloc+0x54/0x60
kmem\_cache\_alloc+0x147/0x320
mempool\_alloc+0xe1/0x260
cifs\_small\_buf\_get+0x24/0x60
allocate\_buffers+0xa1/0x1c0
cifs\_demultiplex\_thread+0x199/0x10d0
kthread+0x165/0x1a0
ret\_from\_fork+0x1f/0x30
Freed by task 921:
kasan\_save\_stack+0x1e/0x40
kasan\_set\_track+0x21/0x30
kasan\_save\_free\_info+0x2a/0x40
\_\_\_\_kasan\_slab\_free+0x143/0x1b0
kmem\_cache\_free+0xe3/0x4d0
cifs\_small\_buf\_release+0x29/0x90
SMB2\_negotiate+0x8b7/0x1c60
smb2\_negotiate+0x51/0x70
cifs\_negotiate\_protocol+0xf0/0x160
cifs\_get\_smb\_ses+0x5fa/0x13c0
mount\_get\_conns+0x7a/0x750
cifs\_mount+0x103/0xd00
cifs\_smb3\_do\_mount+0x1dd/0xcb0
smb3\_get\_tree+0x1d5/0x300
vfs\_get\_tree+0x41/0xf0
path\_mount+0x9b3/0xdd0
\_\_x64\_sys\_mount+0x190/0x1d0
do\_syscall\_64+0x35/0x80
entry\_SYSCALL\_64\_after\_hwframe+0x46/0xb0
The UAF is because:
mount(pid: 921) | cifsd(pid: 923)
-------------------------------|-------------------------------
| cifs\_demultiplex\_thread
SMB2\_negotiate |
cifs\_send\_recv |
compound\_send\_recv |
smb\_send\_rqst |
wait\_for\_response |
wait\_event\_state [1] |
| standard\_receive3
| cifs\_handle\_standard
| handle\_mid
| mid->resp\_buf = buf; [2]
| dequeue\_mid [3]
KILL the process [4] |
resp\_iov[i].iov\_base = buf |
free\_rsp\_buf [5] |
| is\_network\_name\_deleted [6]
| callback
1. After send request to server, wait the response until
mid->mid\_state != SUBMITTED;
2. Receive response from server, and set it to mid;
3. Set the mid state to RECEIVED;
4. Kill the process, the mid state already RECEIVED, get 0;
5. Handle and release the negotiate response;
6. UAF.
It can be easily reproduce with add some delay in [3] - [6].
Only sync call has the problem since async call's callback is
executed in cifsd process.
Add an extra state to mark the mid state to READY before wakeup the
waitter, then it can get the resp safely.
Fixes: ec637e3ffb6b ("[CIFS] Avoid extra large buffer allocation (and memcpy) in cifs\_readpages")
Reviewed-by: Paulo Alcantara (SUSE) <pc@manguebit.com>
Signed-off-by: Zhang Xiaoxu <zhangxiaoxu5@huawei.com>
Signed-off-by: Steve French <stfrench@microsoft.com>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d527f51331cace562393a8038d870b3e9916686f)

| -rw-r--r-- | [fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/cifsglob.h?id=d527f51331cace562393a8038d870b3e9916686f) | 1 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/smb/client/transport.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/smb/client/transport.c?id=d527f51331cace562393a8038d870b3e9916686f) | 34 | |  |  |  | | --- | --- | --- | |

2 files changed, 24 insertions, 11 deletions

| diff --git a/fs/smb/client/cifsglob.h b/fs/smb/client/cifsglob.hindex f594fcc0e889d9..02082621d8e07a 100644--- a/[fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsglob.h?id=2da338ff752a2789470d733111a5241f30026675)+++ b/[fs/smb/client/cifsglob.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/cifsglob.h?id=d527f51331cace562393a8038d870b3e9916686f)@@ -1807,6 +1807,7 @@ static inline bool is\_retryable\_error(int error) #define MID\_RETRY\_NEEDED 8 /\* session closed while this request out \*/ #define MID\_RESPONSE\_MALFORMED 0x10 #define MID\_SHUTDOWN 0x20+#define MID\_RESPONSE\_READY 0x40 /\* ready for other process handle the rsp \*/  /\* Flags \*/ #define MID\_WAIT\_CANCELLED 1 /\* Cancelled while waiting for response \*/diff --git a/fs/smb/client/transport.c b/fs/smb/client/transport.cindex d52057a511ee30..14710afdc2a36c 100644--- a/[fs/smb/client/transport.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/transport.c?id=2da338ff752a2789470d733111a5241f30026675)+++ b/[fs/smb/client/transport.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/smb/client/transport.c?id=d527f51331cace562393a8038d870b3e9916686f)@@ -35,6 +35,8 @@ void cifs\_wake\_up\_task(struct mid\_q\_entry \*mid) {+ if (mid->mid\_state == MID\_RESPONSE\_RECEIVED)+ mid->mid\_state = MID\_RESPONSE\_READY; wake\_up\_process(mid->callback\_data); } @@ -87,7 +89,8 @@ static void \_\_release\_mid(struct kref \*refcount) struct TCP\_Server\_Info \*server = midEntry->server;  if (midEntry->resp\_buf && (midEntry->mid\_flags & MID\_WAIT\_CANCELLED) &&- midEntry->mid\_state == MID\_RESPONSE\_RECEIVED &&+ (midEntry->mid\_state == MID\_RESPONSE\_RECEIVED ||+ midEntry->mid\_state == MID\_RESPONSE\_READY) && server->ops->handle\_cancelled\_mid) server->ops->handle\_cancelled\_mid(midEntry, server); @@ -737,7 +740,8 @@ wait\_for\_response(struct TCP\_Server\_Info \*server, struct mid\_q\_entry \*midQ) int error;  error = wait\_event\_state(server->response\_q,- midQ->mid\_state != MID\_REQUEST\_SUBMITTED,+ midQ->mid\_state != MID\_REQUEST\_SUBMITTED &&+ midQ->mid\_state != MID\_RESPONSE\_RECEIVED, (TASK\_KILLABLE|TASK\_FREEZABLE\_UNSAFE)); if (error < 0) return -ERESTARTSYS;@@ -890,7 +894,7 @@ cifs\_sync\_mid\_result(struct mid\_q\_entry \*mid, struct TCP\_Server\_Info \*server)  spin\_lock(&server->mid\_lock); switch (mid->mid\_state) {- case MID\_RESPONSE\_RECEIVED:+ case MID\_RESPONSE\_READY: spin\_unlock(&server->mid\_lock); return rc; case MID\_RETRY\_NEEDED:@@ -989,6 +993,9 @@ cifs\_compound\_callback(struct mid\_q\_entry \*mid) credits.instance = server->reconnect\_instance;  add\_credits(server, &credits, mid->optype);++ if (mid->mid\_state == MID\_RESPONSE\_RECEIVED)+ mid->mid\_state = MID\_RESPONSE\_READY; }  static void@@ -1209,7 +1216,8 @@ compound\_send\_recv(const unsigned int xid, struct cifs\_ses \*ses, send\_cancel(server, &rqst[i], midQ[i]); spin\_lock(&server->mid\_lock); midQ[i]->mid\_flags |= MID\_WAIT\_CANCELLED;- if (midQ[i]->mid\_state == MID\_REQUEST\_SUBMITTED) {+ if (midQ[i]->mid\_state == MID\_REQUEST\_SUBMITTED ||+ midQ[i]->mid\_state == MID\_RESPONSE\_RECEIVED) { midQ[i]->callback = cifs\_cancelled\_callback; cancelled\_mid[i] = true; credits[i].value = 0;@@ -1230,7 +1238,7 @@ compound\_send\_recv(const unsigned int xid, struct cifs\_ses \*ses, }  if (!midQ[i]->resp\_buf ||- midQ[i]->mid\_state != MID\_RESPONSE\_RECEIVED) {+ midQ[i]->mid\_state != MID\_RESPONSE\_READY) { rc = -EIO; cifs\_dbg(FYI, "Bad MID state?\n"); goto out;@@ -1417,7 +1425,8 @@ SendReceive(const unsigned int xid, struct cifs\_ses \*ses, if (rc != 0) { send\_cancel(server, &rqst, midQ); spin\_lock(&server->mid\_lock);- if (midQ->mid\_state == MID\_REQUEST\_SUBMITTED) {+ if (midQ->mid\_state == MID\_REQUEST\_SUBMITTED ||+ midQ->mid\_state == MID\_RESPONSE\_RECEIVED) { /\* no longer considered to be "in-flight" \*/ midQ->callback = release\_mid; spin\_unlock(&server->mid\_lock);@@ -1434,7 +1443,7 @@ SendReceive(const unsigned int xid, struct cifs\_ses \*ses, }  if (!midQ->resp\_buf || !out\_buf ||- midQ->mid\_state != MID\_RESPONSE\_RECEIVED) {+ midQ->mid\_state != MID\_RESPONSE\_READY) { rc = -EIO; cifs\_server\_dbg(VFS, "Bad MID state?\n"); goto out;@@ -1558,14 +1567,16 @@ SendReceiveBlockingLock(const unsigned int xid, struct cifs\_tcon \*tcon,  /\* Wait for a reply - allow signals to interrupt. \*/ rc = wait\_event\_interruptible(server->response\_q,- (!(midQ->mid\_state == MID\_REQUEST\_SUBMITTED)) ||+ (!(midQ->mid\_state == MID\_REQUEST\_SUBMITTED ||+ midQ->mid\_state == MID\_RESPONSE\_RECEIVED)) || ((server->tcpStatus != CifsGood) && (server->tcpStatus != CifsNew)));  /\* Were we interrupted by a signal ? \*/ spin\_lock(&server->srv\_lock); if ((rc == -ERESTARTSYS) &&- (midQ->mid\_state == MID\_REQUEST\_SUBMITTED) &&+ (midQ->mid\_state == MID\_REQUEST\_SUBMITTED ||+ midQ->mid\_state == MID\_RESPONSE\_RECEIVED) && ((server->tcpStatus == CifsGood) || (server->tcpStatus == CifsNew))) { spin\_unlock(&server->srv\_lock);@@ -1596,7 +1607,8 @@ SendReceiveBlockingLock(const unsigned int xid, struct cifs\_tcon \*tcon, if (rc) { send\_cancel(server, &rqst, midQ); spin\_lock(&server->mid\_lock);- if (midQ->mid\_state == MID\_REQUEST\_SUBMITTED) {+ if (midQ->mid\_state == MID\_REQUEST\_SUBMITTED ||+ midQ->mid\_state == MID\_RESPONSE\_RECEIVED) { /\* no longer considered to be "in-flight" \*/ midQ->callback = release\_mid; spin\_unlock(&server->mid\_lock);@@ -1616,7 +1628,7 @@ SendReceiveBlockingLock(const unsigned int xid, struct cifs\_tcon \*tcon, return rc;  /\* rcvd frame is ok \*/- if (out\_buf == NULL || midQ->mid\_state != MID\_RESPONSE\_RECEIVED) {+ if (out\_buf == NULL || midQ->mid\_state != MID\_RESPONSE\_READY) { rc = -EIO; cifs\_tcon\_dbg(VFS, "Bad MID state?\n"); goto out; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 18:58:57 +0000


