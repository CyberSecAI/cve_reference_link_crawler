
 [UEFI Specification](index.html)
2.9A

* [List of Tables](Frontmatter/List_of_Tables.html)
* [List of Figures](Frontmatter/List_of_Figures.html)
* [Revision History](Frontmatter/Revision_History.html)

* [1. Introduction](01_Introduction.html)
* [2. Overview](02_Overview.html)
* [3. Boot Manager](03_Boot_Manager.html)
* [4. EFI System Table](04_EFI_System_Table.html)
* [5. GUID Partition Table (GPT) Disk Layout](05_GUID_Partition_Table_Format.html)
* [6. Block Translation Table (BTT) Layout](06_Block_Transition_Table_Layout.html)
* [7. Services â Boot Services](07_Services_Boot_Services.html)
* [8. Services â Runtime Services](08_Services_Runtime_Services.html)
* [9. Protocols - EFI Loaded Image](09_Protocols_EFI_Loaded_Image.html)
* [10. Protocols â Device Path Protocol](10_Protocols_Device_Path_Protocol.html)
* [11. Protocols â UEFI Driver Model](11_Protocols_UEFI_Driver_Model.html)
* [12. Protocols â Console Support](12_Protocols_Console_Support.html)
* [13. Protocols â Media Access](13_Protocols_Media_Access.html)
* [14. Protocols â PCI Bus Support](14_Protocols_PCI_Bus_Support.html)
* [15. Protocols â SCSI Driver Models and Bus Support](15_Protocols_SCSI_Driver_Models_and_Bus_Support.html)
* [16. Protocols â iSCSI Boot](16_Protocols_iSCSI_Boot.html)
* [17. Protocols â USB Support](17_Protocols_USB_Support.html)
* [18. Protocols â Debugger Support](18_Protocols_Debugger_Support.html)
* [19. Protocols â Compression Algorithm Specification](19_Protocols_Compression_Algorithm_Specification.html)
* [20. Protocols â ACPI Protocols](20_Protocols_ACPI_Protocols.html)
* [21. Protocols â String Services](21_Protocols_String_Services.html)
* [22. EFI Byte Code Virtual Machine](22_EFI_Byte_Code_Virtual_Machine.html)
* [23. Firmware Update and Reporting](23_Firmware_Update_and_Reporting.html)
* [24. Network Protocols â SNP, PXE, BIS and HTTP Boot](24_Network_Protocols_SNP_PXE_BIS.html)
* [25. Network Protocols - Managed Network](25_Network_Protocols_Managed_Network.html)
* [26. Network Protocols â Bluetooth](26_Network_Protocols_Bluetooth.html)
* [27. Network Protocols â VLAN, EAP, Wi-Fi and Supplicant](27_Network_Protocols_VLAN_and_EAP.html)
* [28. Network Protocols â TCP, IP, IPsec, FTP, TLS and Configurations](28_Network_Protocols_TCP_IP_and_Configuration.html)
* [29. Network Protocols â ARP, DHCP, DNS, HTTP and REST](29_Network_Protocols_ARP_and_DHCP.html)
* [30. Network Protocols â UDP and MTFTP](30_Network_Protocols_UDP_and_MTFTP.html)
* [31. EFI Redfish Service Support](31_EFI_Redfish_Service_Support.html)
* 32. Secure Boot and Driver Signing
  + [32.1. Secure Boot](#secure-boot)
    - [32.1.1. EFI\_AUTHENTICATION\_INFO\_PROTOCOL](#efi-authentication-info-protocol)
    - [32.1.2. EFI\_AUTHENTICATION\_INFO\_PROTOCOL.Get()](#efi-authentication-info-protocol-get)
    - [32.1.3. EFI\_AUTHENTICATION\_INFO\_PROTOCOL.Set()](#efi-authentication-info-protocol-set)
    - [32.1.4. Authentication Nodes](#authentication-nodes)
    - [32.1.5. Generic Authentication Node Structures](#generic-authentication-node-structures)
    - [32.1.6. CHAP (using RADIUS) Authentication Node](#chap-using-radius-authentication-node)
  + [32.2. UEFI Driver Signing Overview](#uefi-driver-signing-overview)
    - [32.2.1. Digital Signatures](#digital-signatures)
    - [32.2.2. Embedded Signatures](#embedded-signatures)
    - [32.2.3. Creating Image Digests from Images](#creating-image-digests-from-images)
    - [32.2.4. Code Definitions](#code-definitions)
      * [32.2.4.1. WIN\_CERTIFICATE](#win-certificate)
      * [32.2.4.2. WIN\_CERTIFICATE\_EFI\_PKCS1\_15](#win-certificate-efi-pkcs1-15)
      * [32.2.4.3. WIN\_CERTIFICATE\_UEFI\_GUID](#win-certificate-uefi-guid)
  + [32.3. Firmware/OS Key Exchange: Creating Trust Relationships](#firmware-os-key-exchange-creating-trust-relationships)
    - [32.3.1. Enrolling The Platform Key](#enrolling-the-platform-key)
    - [32.3.2. Clearing The Platform Key](#clearing-the-platform-key)
    - [32.3.3. Transitioning to Audit Mode](#transitioning-to-audit-mode)
    - [32.3.4. Transitioning to Deployed Mode](#transitioning-to-deployed-mode)
    - [32.3.5. Enrolling Key Exchange Keys](#enrolling-key-exchange-keys)
    - [32.3.6. Platform Firmware Key Storage Requirements](#platform-firmware-key-storage-requirements)
  + [32.4. Firmware/OS Key Exchange: Passing Public Keys](#firmware-os-key-exchange-passing-public-keys)
    - [32.4.1. Signature Database](#signature-database)
      * [32.4.1.1. EFI\_SIGNATURE\_DATA](#efi-signature-data)
    - [32.4.2. Image Execution Information Table](#image-execution-information-table)
  + [32.5. UEFI Image Validation](#uefi-image-validation)
    - [32.5.1. Overview](#overview)
    - [32.5.2. Authorized User](#authorized-user)
    - [32.5.3. Signature Database Update](#signature-database-update)
      * [32.5.3.1. Using The Image Execution Information Table](#using-the-image-execution-information-table)
      * [32.5.3.2. Firmware Policy](#firmware-policy)
      * [32.5.3.3. Authorization Process](#authorization-process)
  + [32.6. Code Definitions](#secure-boot-and-driver-signing-code-definitions)
    - [32.6.1. UEFI Image Variable GUID & Variable Name](#uefi-image-variable-guid-variable-name)
* [33. Human Interface Infrastructure Overview](33_Human_Interface_Infrastructure.html)
* [34. HII Protocols](34_HII_Protocols.html)
* [35. HII Configuration Processing and Browser Protocol](35_HII_Configuration_Processing_and_Browser_Protocol.html)
* [36. User Identification](36_User_Identification.html)
* [37. Secure Technologies](37_Secure_Technologies.html)
* [38. Miscellaneous Protocols](38_Micellaneous_Protocols.html)

* [A. Appendix A â GUID and Time Formats](Apx_A_GUID_and_Time_Formats.html)
* [B. Appendix B â Console](Apx_B_Console.html)
* [C. Appendix C â Device Path Examples](Apx_C_Device_Path_Examples.html)
* [D. Appendix D â Status Codes](Apx_D_Status_Codes.html)
* [E. Appendix E â Universal Network Driver Interfaces](Apx_E_Universal_Network_Driver_Interfaces.html)
* [F. APPPENDIX F â Using the Simple Pointer Protocol](Apx_F_Using_the_Simple_Pointer_Protocol.html)
* [G. Appendix G â Using the EFI Extended SCSI Pass Thru Protocol](Apx_G_Using_the_EFI_Extended_SCSI_Pass_Thru_Protocol.html)
* [H. Appendix H â Compression Source Code](Apx_H_Compression_Source_Code.html)
* [I. Appendix I â Decompression Source Code](Apx_I_Decompression_Source_Code.html)
* [J. Appendix J â EFI Byte Code Virtual Machine Opcode List](Apx_J_EFI_Byte_Code_Virtual_Machine_Opcode_List.html)
* [K. Appendix K â Alphabetic Function Lists](Apx_K_Alphabetic_Function_Lists.html)
* [L. Appendix L â EFI 1.10 Protocol Changes and Deprecation List](Apx_L_EFI_1.10_Protocol_Changes_and_Deprecation_List.html)
* [M. Appendix M â Formats â Language Codes and Language Code Arrays](Apx_M_Formats_Language_Codes_and_Language_Code_Arrays.html)
* [N. Appendix N - Common Platform Error Record (CPER)](Apx_N_Common_Platform_Error_Record.html)
* [O. Appendix O â UEFI ACPI Data Table](Apx_O_UEFI_ACPI_Data_Table.html)
* [P. Appendix P â Hardware Error Record Persistence Usage](Apx_P_Hardware_Error_Record_Persistence_Usage.html)
* [Q. Appendix Q â References](Apx_Q_References.html)
* [R. Appendix R â Glossary](Apx_R_Glossary.html)

[Index](genindex.html)

[UEFI Specification](index.html)

* [Docs](index.html) »
* 32. Secure Boot and Driver Signing

---

# 32. Secure Boot and Driver Signing[Â¶](#secure-boot-and-driver-signing "Permalink to this headline")

## 32.1. Secure Boot[Â¶](#secure-boot "Permalink to this headline")

This protocol is intended to provide access for generic authentication information associated with specific device paths. The authentication information is configurable using the defined interfaces. Successive configuration of the authentication information will overwrite the previously configured information. Once overwritten, the previous authentication information will not be retrievable.

### 32.1.1. EFI\_AUTHENTICATION\_INFO\_PROTOCOL[Â¶](#efi-authentication-info-protocol "Permalink to this headline")

**Summary**

This protocol is used on any device handle to obtain authentication information associated with the physical or logical device.

**GUID**

```
#define EFI_AUTHENTICATION_INFO_PROTOCOL_GUID \
{0x7671d9d0,0x53db,0x4173,\
{0xaa,0x69,0x23,0x27,0xf2,0x1f,0x0b,0xc7}}

```

**Protocol Interface Structure**

```
typedef struct _EFI_AUTHENTICATION_INFO_PROTOCOL {
  EFI_AUTHENTICATION_INFO_PROTOCOL_GET            Get;
  EFI_AUTHENTICATION_INFO_PROTOCOL_SET            Set;
}   EFI_AUTHENTICATION_INFO_PROTOCOL;

```

**Parameters**

Get()

Used to retrieve the Authentication Information associated with the controller handle

Set()

Used to set the Authentication information associated with the controller handle

**Description**

The *EFI\_AUTHENTICATION\_INFO\_PROTOCOL* provides the ability to get and set the authentication information associated with the controller handle.

### 32.1.2. EFI\_AUTHENTICATION\_INFO\_PROTOCOL.Get()[Â¶](#efi-authentication-info-protocol-get "Permalink to this headline")

**Summary**

Retrieves the Authentication information associated with a particular controller handle.

**Prototype**

```
typedef
EFI_STATUS
(EFIAPI *EFI_AUTHENTICATION_INFO_PROTOCOL_GET) (
  IN EFI_AUTHENTICATION_INFO_PROTOCOL        *This,
  IN EFI_HANDLE                              ControllerHandle,
  OUT VOID                                   **Buffer
  );

```

**Parameters**

This

Pointer to the *EFI\_AUTHENTICATION\_INFO\_PROTOCOL*

ControllerHandle

Handle to the Controller

Buffer

Pointer to the authentication information. This function is responsible for allocating the buffer and it is the callerâs responsibility to free buffer when the caller is finished with buffer.

**Description**

This function retrieves the Authentication Node for a given controller handle.

**Status Codes Returned**

| EFI\_SUCCESS | Successfully retrieved Authentication information for the given *ControllerHandle* |
| --- | --- |
| EFI\_INVALID\_PARAMETER | No matching Authentication information found for the given *ControllerHandle* |
| EFI\_DEVICE\_ERROR | The authentication information could not be retrieved due to a hardware error. |

### 32.1.3. EFI\_AUTHENTICATION\_INFO\_PROTOCOL.Set()[Â¶](#efi-authentication-info-protocol-set "Permalink to this headline")

**Summary**

Set the Authentication information for a given controller handle.

**Prototype**

```
typedef
EFI_STATUS
(EFIAPI *EFI_AUTHENTICATION_INFO_PROTOCOL_SET) (
IN EFI_AUTHENTICATION_INFO_PROTOCOL **This,
IN EFI_HANDLE *ControllerHandle
IN VOID **Buffer
);

```

**Parameters**

This

Pointer to the *EFI\_AUTHENTICATION\_INFO\_PROTOCOL*

ControllerHandle

Handle to the controller.

Buffer

Pointer to the authentication information.

**Description**

This function sets the authentication information for a given controller handle. If the authentication node exists corresponding to the given controller handle this function overwrites the previously present authentication information.

**Status Codes Returned**

| EFI\_SUCCESS | Successfully set the Authentication node information for the given *ControllerHandle*. |
| --- | --- |
| EFI\_UNSUPPORTED | If the platform policies do not allow setting of the Authentication information. |
| EFI\_DEVICE\_ERROR | The authentication node information could not be configured due to a hardware error. |
| EFI\_OUT\_OF\_RESOURCES | Not enough storage is available to hold the data. |

### 32.1.4. Authentication Nodes[Â¶](#authentication-nodes "Permalink to this headline")

The authentication node is associated with specific controller paths. There can be various types of authentication nodes, each describing a particular authentication method and associated properties.

### 32.1.5. Generic Authentication Node Structures[Â¶](#generic-authentication-node-structures "Permalink to this headline")

An authentication node is a variable length binary structure that is made up of variable length authentication information. The Table below defines the generic structure. The Authentication type GUID defines the corresponding authentication node.

Table 32.1 Generic Authentication Node Structure[Â¶](#generic-authentication-node-structure "Permalink to this table")

| Mnemonic | Byte Offset | Byte Length | Description |
| --- | --- | --- | --- |
| Type GUID | 0 | 16 | Authentication Type GUID |
| Length | 16 | 2 | Length of this structure in bytes. |
| Specific Authentication Data | 18 | n | Specific Authentication Data. Type defines the authentication method and associated type of data. Size of the data is included in the length. |

All Authentication Nodes are byte-packed data structures that may appear on any byte boundary. All code references to Authentication Nodes must assume all fields are UNALIGNED. Since every Authentication Node contains a length field in a known place, it is possible to traverse Authentication Node of unknown type.

### 32.1.6. CHAP (using RADIUS) Authentication Node[Â¶](#chap-using-radius-authentication-node "Permalink to this headline")

This Authentication Node type defines the CHAP authentication using RADIUS information.

**GUID**

```
#define EFI_AUTHENTICATION_CHAP_RADIUS_GUID \
{0xd6062b50,0x15ca,0x11da,\
{0x92,0x19,0x00,0x10,0x83,0xff,0xca,0x4d}}

```

**Node Definition**

Table 32.2 CHAP Authentication Node Structure using RADIUS
:widths:15 15 15 45[Â¶](#chap-authentication-node-structure-using-radius "Permalink to this table")

| **Mnemonic** | **Byte Offset** | **Byte Length** | **Description** |
| --- | --- | --- | --- |
| Type | 0 | 16 | EFI\_A UTHENTICATION\_C HAP\_RADIUS\_GUID |
| Length | 16 | 2 | Length of this structure in bytes. Total length is 58+P+Q+R+S+T |
| RADIUS IP Address | 18 | 16 | Radius IPv4 or IPv6 Address |
| Reserved | 34 | 2 | Reserved |
| NAS IP Address | 36 | 16 | NAS IPv4 or IPv6 Address |
| NAS Secret Length | 52 | 2 | NAS Secret LengthP |
| NAS Secret | 54 | p | NAS Secret |
| CHAP Secret Length | 54+P | 2 | CHAP Secret Length Q |
| CHAP Secret | 56+P | q | CHAP Secret |
| CHAP Name Length | 56 +Q | 2 | CHAP Name Length R |
| CHAP Name | 58+P+Q | r | CHAP Name String |
| Reverse CHAP Name Length | 58+P+Q+R | 2 | Reverse CHAP Name length |
| Reverse CHAP Name | 60+P+Q+R | S | Reverse CHAP Name |
| Reverse CHAP Secret Length | 60+P+Q+R+S | 2 | Reverse CHAP Length |
| Reverse CHAP Secret | 62+P+Q+R+S | T | Reverse CHAP Secret |

**Summary**

RADIUS IP Addressâ¦RADIUS Server IPv4 or IPv6 Address
NAS IP Addressâ¦Network Access Server IPv4 or IPv6 Address (OPTIONAL)
NAS Secret Lengthâ¦Network Access Server Secret Length in bytes (OPTIONAL)
NAS Secretâ¦Network Access Server secret (OPTIONAL)
CHAP Secret Lengthâ¦CHAP Initiator Secret length in bytes
CHAP Secretâ¦CHAP Initiator Secret
CHAP Nameâ¦Length CHAP Initiator Name Length in bytes
CHAP Name CHAP Initiator Name
Reverse CHAP name length Reverse CHAP name length
Reverse CHAP Name Reverse CHAP name
Reverse CHAP Secret Length Reverse CHAP secret length
Reverse CHAP Secret Reverse CHAP secret

**CHAP (using local database)Authentication Node**

This Authentication Node type defines CHAP using local database information.

**GUID**

```
#define EFI_AUTHENTICATION_CHAP_LOCAL_GUID \
{0xc280c73e,0x15ca,0x11da,\
{0xb0,0xca,0x00,0x10,0x83,0xff,0xca,0x4d}}

```

**Node Definition**

Table 32.3 CHAP Authentication Node Structure using Local Database[Â¶](#chap-authentication-node-structure-using-local-database "Permalink to this table")

| Mnemonic | Byte Offset | Byte Length | Description |
| --- | --- | --- | --- |
| Type | 0 | 16 | EFI\_AUTHENTICATION\_CHAP\_LOCAL\_GUID |
| Length | 16 | 2 | Length of this structure in bytes. Total length is 58+P+Q+R+S+T |
| Reserved | 18 | 2 | Reserved for future use |
| User Secret Length | 20 | 2 | User Secret Length |
| User Secret | 22 | p | User Secret |
| User Name Length | 22+p | 2 | User Name Length |
| User Name | 24+p | q | User Name |
| CHAP Secret Length | 24+p+q | 2 | CHAP Secret Length |
| CHAP Secret | 26+p+q | r | CHAP Secret |
| CHAP Name Length | 26+p+q+r | 2 | CHAP Name Length |
| CHAP Name | 28+p+q+r | s | CHAP Name String |
| Reverse CHAP Name Length | 58+P+Q+R | 2 | Reverse CHAP Name length |
| Reverse CHAP Name | 60+P+Q+R | S | Reverse CHAP Name |
| Reverse CHAP Secret Length | 60+P+Q+R+S | 2 | Reverse CHAP Length |
| Reverse CHAP Secret | 62+P+Q+R+S | T | Reverse CHAP Secret |

**Summary**

User Secret Lengthâ¦User Secret Length in bytes
User Secretâ¦User Secret
User Name Lengthâ¦User Name Length in bytes
User Nameâ¦User Name
CHAP Secret Lengthâ¦CHAP Initiator Secret length in bytes
CHAP Secretâ¦CHAP Initiator Secret
CHAP Name Lengthâ¦CHAP Initiator Name Length in bytes
CHAP Nameâ¦CHAP Initiator Name
Reverse CHAP name length Reverse CHAP name length
Reverse CHAP Name Reverse CHAP name
Reverse CHAP Secret Length Reverse CHAP secret length
Reverse CHAP Secret Reverse CHAP secret

## 32.2. UEFI Driver Signing Overview[Â¶](#uefi-driver-signing-overview "Permalink to this headline")

This section describes a means of generating a digital signature for a UEFI executable, embedding that digital signature within the UEFI executable and verifying that the digital signature is from an authorized source. The UEFI specification provides a standard format for executables. These executables may be located on un-secured media (such as a hard drive or unprotected flash device) or may be delivered via a un-secured transport layer (such as a network) or originate from a un-secured port (such as ExpressCard device or USB device). In each of these cases, the system provider may decide to authenticate either the origin of the executable or its integrity (i.e., it has not been tampered with). This section describes a means of doing so.

### 32.2.1. Digital Signatures[Â¶](#digital-signatures "Permalink to this headline")

As a rule, digital signatures require two pieces: the data (often referred to as the message) and a public/private key pair. In order to create a digital signature, the message is processed by a hashing algorithm to create a hash value. This hash value is, in turn, encrypted using a signature algorithm and the private key to create the digital signature.

[![_images/Secure_Boot_and_Driver_Signing-2.png](_images/Secure_Boot_and_Driver_Signing-2.png)](_images/Secure_Boot_and_Driver_Signing-2.png)

Fig. 32.1 Creating A Digital Signature[Â¶](#creating-a-digital-signature "Permalink to this image")

In order to verify a signature, two pieces of data are required: the original message and the public key. First, the hash must be calculated exactly as it was calculated when the signature was created. Then the digital signature is decoded using the public key and the result is compared against the computed hash. If the two are identical, then you can be sure that message data is the one originally signed and it has not been tampered with.

[![_images/Secure_Boot_and_Driver_Signing-3.png](_images/Secure_Boot_and_Driver_Signing-3.png)](_images/Secure_Boot_and_Driver_Signing-3.png)

Fig. 32.2 Veriying a Digital Signature[Â¶](#veriying-a-digital-signature "Permalink to this image")

### 32.2.2. Embedded Signatures[Â¶](#embedded-signatures "Permalink to this headline")

The signatures used for digital signing of UEFI executables are embedded directly within the executable itself. Within the header is an array of directory entries. Each of these entries points to interesting places within the executable image. The fifth data directory entry contains a pointer to a list of certificates along with the length of the certificate areas. Each certificate may contain a digital signature used for validating the driver. The following diagram illustrates how certificates are embedded in the PE/COFF file:

[![_images/Secure_Boot_and_Driver_Signing-4.png](_images/Secure_Boot_and_Driver_Signing-4.png)](_images/Secure_Boot_and_Driver_Signing-4.png)

Fig. 32.3 Embedded Digital Certificates[Â¶](#embedded-digital-certificates "Permalink to this image")

Within the PE/COFF optional header is a data directory. The 5th entry, if filled, points to a list of certificates. Normally, these certificates are appended to the end of the file.

### 32.2.3. Creating Image Digests from Images[Â¶](#creating-image-digests-from-images "Permalink to this headline")

One of the pieces required for creating a digital signature is the image digest. For a detailed description on how to create image digests from PE/COFF images, refer to the âCreating the PE Image Hashâ section of the Microsoft Authenticode Format specification (see References).

### 32.2.4. Code Definitions[Â¶](#code-definitions "Permalink to this headline")

This section describes data structures used for signing UEFI executables.

#### 32.2.4.1. WIN\_CERTIFICATE[Â¶](#win-certificate "Permalink to this headline")

**Summary**

The *WIN\_CERTIFICATE* structure is part of the PE/COFF specification.

**Prototype**

```
typedef struct _WIN_CERTIFICATE {
  UINT32             dwLength;
  UINT16             wRevision;
  UINT16             wCertificateType;
  //UINT8            bCertificate[ANYSIZE_ARRAY];
} WIN_CERTIFICATE;

```

dwLength

The length of the entire certificate, including the length of the header, in bytes.

wRevision

The revision level of the *WIN\_CERTIFICATE* structure. The current revision level is 0x0200.

wCertificateType

The certificate type. See *WIN\_CERT\_TYPE\_xxx* for the UEFI certificate types. The UEFI specification reserves the range of certificate type values from 0x0EF0 to 0x0EFF.

bCertificate

The actual certificate. The format of the certificate depends on *wCertificateType*. The format of the UEFI certificates is defined below.

**Related Definitions**

```
#define WIN_CERT_TYPE_PKCS_SIGNED_DATA    0x0002
#define WIN_CERT_TYPE_EFI_PKCS115         0x0EF0
#define WIN_CERT_TYPE_EFI_GUID            0x0EF1

```

**Description**

This structure is the certificate header. There may be zero or more certificates.

* If the wCertificateType field is set to *WIN\_CERT\_TYPE\_EFI\_PKCS115,* then the certificate follows the format described in *WIN\_CERTIFICATE\_EFI\_PKCS1\_15*.
* If the *wCertificateType* field is set to *WIN\_CERT\_TYPE\_EFI\_GUID,* then the certificate follows the format described in *WIN\_CERTIFICATE\_UEFI\_GUID*.
* If the *wCertificateType* field is set to *WIN\_CERT\_TYPE\_PKCS\_SIGNED\_DATA* then the certificate is formatted as described in the Authenticode specification.

These certificates can be validated using the contents of the signature database described in [Signature Database](#id22) . The following table illustrates the relationship between the certificates and the signature types in the database.

**NOTE**: *In the case of a* WIN\_CERT\_TYPE\_PKCS\_SIGNED\_DATA (*or* WIN\_CERT\_TYPE\_EFI\_GUID *where* CertType = EFI\_CERT\_TYPE\_PKCS7\_GUID) *certificate, a match can occur against an entry in the authorized signature database (or the forbidden signature database;* [UEFI Image Variable GUID & Variable Name](#id31) ) *at any level of the chain of X.509 certificates present in the certificate, and matches can occur against any of the applicable signature types defined in* ( [Firmware/OS Key Exchange: Passing Public Keys](#firmware-os-key-exchange-passing-public-keys) .

Table 32.4 PE/COFF Certificates Types and UEFI Signature Database Certificate Types[Â¶](#pe-coff-certificates-types-and-uefi-signature-database-certificate-types "Permalink to this table")

| Image Certificate Type | Verified Using Signature Database Type |
| --- | --- |
| *WIN\_CERT\_TYPE\_EFI\_PKCS115* (*Signature* Size = 256 bytes) | *EFI\_CERT\_RSA2048\_GUID* (public key) |
| *WIN\_CERT\_TYPE\_EFI\_GUID* (*CertType* = E FI\_CERT\_TYPE\_RSA2048\_SHA256\_GUID\*) | *EFI\_CERT\_RSA2048\_GUID* (public key). |
| *WIN\_CERT\_TYPE\_EFI\_GUID* (CertType = EFI\_CERT\_TYPE\_PKCS7\_GUID)\* | *EFI\_CERT\_X509\_GUID* *EFI\_CERT\_RSA2048\_GUID* (when applicable) *EFI\_CERT\_X509\_SHA256\_GUID* (when applicable) *EFI\_CERT\_X509\_SHA384\_GUID* (when applicable) *EFI\_CERT\_X509\_SHA512\_GUID* (when applicable) |
| *WIN\_CERT\_TYPE\_PKCS\_SIGNED\_DATA* | *EFI\_CERT\_X509\_GUID* *EFI\_CERT\_RSA2048\_GUID* (when applicable) *EFI\_CERT\_X509\_SHA256\_GUID* (when applicable) *EFI\_CERT\_X509\_SHA384\_GUID* (when applicable) *EFI\_CERT\_X509\_SHA512\_GUID* (when applicable) |
| (Always applicable regardless of whether a certificate is present or not) | *EFI\_CERT\_SHA1\_GUID*, *EFI\_CERT\_SHA224\_GUID*, *EFI\_CERT\_SHA256\_GUID*, *EFI\_CERT\_SHA384\_GUID*, *EFI\_CERT\_SHA512\_GUID* In this case, the database contains the hash of the image. |

#### 32.2.4.2. WIN\_CERTIFICATE\_EFI\_PKCS1\_15[Â¶](#win-certificate-efi-pkcs1-15 "Permalink to this headline")

**Summary**

Certificate which encapsulates the RSASSA\_PKCS1-v1\_5 digital signature.

**Prototype**

```
typedef struct _WIN_CERTIFICATE_EFI_PKCS1_15 {
   WIN_CERTIFICATE            Hdr;
   EFI_GUID                   HashAlgorithm;
// UINT8                      Signature[ANYSIZE_ARRAY];
} WIN_CERTIFICATE_EFI_PKCS1_15;

```

Hdr

This is the standard *WIN\_CERTIFICATE* header, where *wCertificateType* is set to *WIN\_CERT\_TYPE\_EFI\_PKCS1\_15*.

HashAlgorithm

This is the hashing algorithm which was performed on the UEFI executable when creating the digital signature. It is one of the enumerated values pre-defined in [EFI Hash Algorithms](37_Secure_Technologies.html#efi-hash-algorithms). See *EFI\_HASH\_ALGORITHM\_x*.

Signature

This is the actual digital signature. The size of the signature is the same size as the key (2048-bit key is 256 bytes) and can be determined by subtracting the length of the other parts of this header from the total length of the certificate as found in *Hdr.dwLength*.

**Description**

The *WIN\_CERTIFICATE\_UEFI\_PKCS1\_15* structure is derived from *WIN\_CERTIFICATE* and encapsulates the information needed to implement the RSASSA-PKCS1-v1\_5 digital signature algorithm as specified in RFC2437, sections 8-9.

#### 32.2.4.3. WIN\_CERTIFICATE\_UEFI\_GUID[Â¶](#win-certificate-uefi-guid "Permalink to this headline")

**Summary**

Certificate which encapsulates a GUID-specific digital signature.

**Prototype**

```
typedef struct _WIN_CERTIFICATE_UEFI_GUID {
  WIN_CERTIFICATE             Hdr;
  EFI_GUID                    CertType;
  UINT8                       CertData[ANYSIZE_ARRAY];
}   WIN_CERTIFICATE_UEFI_GUID;

```

Hdr

This is the standard *WIN\_CERTIFICATE* header, where *wCertificateType* is set to *WIN\_CERT\_TYPE\_EFI\_GUID*.

CertType

This is the unique id which determines the format of the *CertData*.

CertData

This is the certificate data. The format of the data is determined by the *CertType*.

**Related Definitions**

```
#define EFI_CERT_TYPE_RSA2048_SHA256_GUID
    {0xa7717414, 0xc616, 0x4977, \
  {0x94, 0x20, 0x84, 0x47, 0x12, 0xa7, 0x35, 0xbf}}
#define EFI_CERT_TYPE_PKCS7_GUID
  {0x4aafd29d, 0x68df, 0x49ee, \
  {0x8a, 0xa9, 0x34, 0x7d, 0x37, 0x56, 0x65, 0xa7}}
typedef struct _EFI_CERT_BLOCK_RSA_2048_SHA256 {
  EFI_GUID                 HashType;
  UINT8                    PublicKey[256];
  UINT8                    Signature[256];
} EFI_CERT_BLOCK_RSA_2048_SHA256;

```

PublicKey

The RSA exponent e for this structure is 0x10001.

Signature

This signature block is PKCS 1 version 1.5 formatted.

**Description**

The *WIN\_CERTIFICATE\_UEFI\_GUID* certificate type allows new types of certificates to be developed for driver authentication without requiring a new certificate type. The *CertType* defines the format of the *CertData,* which length is defined by the size of the certificate less the fixed size of the *WIN\_CERTIFICATE\_UEFI\_GUID* structure.

* If *CertType* is *EFI\_CERT\_TYPE\_RSA2048\_SHA256\_GUID* then the structure which follows has the format specified by *EFI\_CERT\_BLOCK\_RSA\_2048\_SHA256*.
* If *CertType* is *EFI\_CERT\_TYPE\_PKCS7\_GUID* then the *CertData* component shall contain a DER-encoded PKCS #7 version 1.5 [RFC2315] *SignedData* value.

## 32.3. Firmware/OS Key Exchange: Creating Trust Relationships[Â¶](#firmware-os-key-exchange-creating-trust-relationships "Permalink to this headline")

This section describes a means of creating a trust relationship between the platform owner, the platform firmware, and an operating system. This trust relationship enables the platform firmware and one or more operating systems to exchange information in a secure manner. The trust relationship uses two types of asymmetric key pairs:

**Platform Key (PK)**

The platform key establishes a trust relationship between the platform owner
and the platform firmware. The platform owner enrolls the public half of the key (PKpub) into the platform firmware. The platform owner can later use the private half of the key (PKpriv) to change platform ownership or to enroll a Key Exchange Key. For UEFI, the recommended Platform Key format is RSA-2048. See âEnrolling The Platform Keyâ and âClearing The Platform Keyâ for more information.

**Key Exchange Key (KEK)**

Key exchange keys establish a trust relationship between the operating system and the platform firmware. Each operating system (and potentially, each 3rd party application which need to communicate with platform firmware) enrolls a public key (KEKpub) into the platform firmware. See âEnrolling Key Exchange Keysâ for more information.

While no Platform Key is enrolled, the SetupMode variable *shall* be equal to 1. While SetupMode == 1, the platform firmware *shall not* require authentication in order to modify the Platform Key, Key Enrollment Key, OsRecoveryOrder, OsRecovery####, and image security databases.

After the Platform Key is enrolled, the SetupMode variable shall be equal to 0. While SetupMode == 0, the platform firmware *shall* require authentication in order to modify the Platform Key, Key Enrollment Key, OsRecoveryOrder, OsRecovery####, and image security databases.

While no Platform Key is enrolled, and while the variable AuditMode == 0, the platform is said to be operating in setup mode.

After the Platform Key is enrolled, and while the variable AuditMode == 0, the platform is operating in user mode. The platform will continue to operate in user mode until the Platform Key is cleared, or the system is transitioned to either Audit or Deployed Modes. See âClearing The Platform Key,â âTransitioning to Audit Mode,â and âTransitioning to Deployed Modeâ for more information.

Audit Mode enables programmatic discovery of signature list combinations that successfully authenticate installed EFI images without the risk of rendering a system unbootable. Chosen signature lists configurations can be tested to ensure the system will continue to boot after the system is transitioned out of Audit Mode. Details on how to transition to Audit Mode are detailed below in the section âTransitioning to Audit Mode.â After transitioning to Audit Mode, signature enforcement is disabled such that all images are initialized and enhanced Image Execution Information Table (IEIT) logging is performed including recursive validation for multi-signed images.

Deployed Mode is the most secure mode. For details on transitioning to Deployed Mode see the section âTransitioning to Deployed Modeâ below. By design, both User Mode and Audit Mode support unauthenticated transitions to Deployed Mode. However, to move from Deployed Mode to any other mode requires a secure platform-specific method, or deleting the PK, which is authenticated.

Secure Boot Mode transitions to User Mode or Deployed Mode shall take effect immediately. Mode transitions to Setup Mode or Audit Mode may either take effect immediately (recommended) or after a reset. For implementations that require a reset, the mode transition shall be processed prior to the initialization of the SecureBoot variable, and the SetVariable() workflow shall be as follows:

1. If the variable has an authenticated attribute, it shall be authenticated as specified, and failure will result in immediate termination of this workflow by returning the appropriate error.
2. Check secure storage to determine if a Secure Boot Mode transition is already queued. If a transition is already queued, terminate this workflow by returning EFI\_ALREADY\_STARTED
3. Queue the request to secure storage
4. The Secure Boot Mode and Policy variables SHALL remain unchanged
5. Return EFI\_WARN\_RESET\_REQUIRED.
6. After reboot, if the transition is successful, Secure Boot Mode and Policy variables will change accordingly. If the transition to lower security modes is rejected or fail, the workflow is terminated and the Secure Boot Mode and Policy variables remain unchanged

[![_images/Secure_Boot_and_Driver_Signing-5.png](_images/Secure_Boot_and_Driver_Signing-5.png)](_images/Secure_Boot_and_Driver_Signing-5.png)

Fig. 32.4 Secure Boot Modes[Â¶](#secure-boot-modes "Permalink to this image")

### 32.3.1. Enrolling The Platform Key[Â¶](#enrolling-the-platform-key "Permalink to this headline")

The platform owner enrolls the public half of the Platform Key (PKpub) by calling the UEFI Boot Service *SetVariable()* as specified in [Using the EFI\_VARIABLE\_AUTHENTICATION\_3 descriptor](08_Services_Runtime_Services.html#using-the-efi-variable-authentication-3-descriptor). If the platform is in setup mode, then the new PKpub may be signed with its PKpriv counterpart. If the platform is in user mode, then the new PKpub must be signed with the current PKpriv. When the platform is in setup mode, a successful enrollment of a Platform Key shall cause the platform to immediately transition to user mode.

The authenticated PK variable can always be read but can only be written if the platform is in setup mode, or if the platform is in user mode and the provided PKpub is signed with the current PKpriv.

The name and GUID of the Platform Key variable are specified in [Globally Defined Variables](03_Boot_Manager.html#globally-defined-variables-boot-manager) âGlobally Defined Variablesâ The variable has the format of a signature database as described in âSignature Databaseâ below, with exactly one entry.

The platform vendor may provide a default PKpub in the PKDefault variable described in [Globally Defined Variables](03_Boot_Manager.html#globally-defined-variables-boot-manager). This variable is formatted identically to the Platform Key variable. If present, this key may optionally be used as the public half of the Platform Key when transitioning from setup mode to user mode. If so, it may be read, placed within an *EFI\_VARIABLE\_AUTHENTICATION2* structure and copied to the Platform Key variable using the *SetVariable()* call.

### 32.3.2. Clearing The Platform Key[Â¶](#clearing-the-platform-key "Permalink to this headline")

The platform owner clears the public half of the Platform Key (PKpub) by deleting the Platform Key variable using UEFI Runtime Service *SetVariable()*. The data buffer submitted to the *SetVariable()* must be signed with the current PKpriv; [Exception for Machine Check, INIT, and NMI](08_Services_Runtime_Services.html#exception-for-machine-check-init-and-nmi) for details. The name and GUID of the Platform Key variable are specified in [Globally Defined Variables](03_Boot_Manager.html#globally-defined-variables-boot-manager), âGlobally Defined Variablesâ The platform key may also be cleared using a secure platform-specific method. When platform key is cleared, the global variable SetupMode must also be updated to 1.

### 32.3.3. Transitioning to Audit Mode[Â¶](#transitioning-to-audit-mode "Permalink to this headline")

To enter Audit Mode, a new UEFI variable AuditMode is set to 1. Entering Audit Mode has the side effect of changing SetupMode == 1, PK is cleared, and the new DeployedMode == 0.

**NOTE**: *The AuditMode variable is only writable before* ExitBootServices() *is called when the system is* **not** *in Deployed Mode*. See [Secure Boot Modes](#secure-boot-modes) *for more details.*

### 32.3.4. Transitioning to Deployed Mode[Â¶](#transitioning-to-deployed-mode "Permalink to this headline")

To enter Deployed Mode from Audit Mode, set the variable PK. To enter Deployed Mode from User Mode, set the variable DeployedMode to 1. This transition takes effect immediately with no reset required. Entering Deployed Mode has the side effect of changing SetupMode == 0, AuditMode == 0 and is made read-only, and DeployedMode == 1 and is made read-only. See [Secure Boot Modes](#secure-boot-modes) for more details.

### 32.3.5. Enrolling Key Exchange Keys[Â¶](#enrolling-key-exchange-keys "Permalink to this headline")

Key exchange keys are stored in a signature database as described in âSignature Databaseâ below. The signature database is stored as an authenticated UEFI variable.

The platform owner enrolls the key exchange keys by either calling *SetVariable()* as specified in [Using the EFI\_VARIABLE\_AUTHENTICATION\_3 descriptor](08_Services_Runtime_Services.html#using-the-efi-variable-authentication-3-descriptor) with the *EFI\_VARIABLE\_APPEND\_WRITE* attribute set and the *Data* parameter containing the new key(s), or by reading the database using *GetVariable(),* appending the new key exchange key to the existing keys and then writing the database using *SetVariable()* as specified in [Using the EFI\_VARIABLE\_AUTHENTICATION\_3 descriptor](08_Services_Runtime_Services.html#using-the-efi-variable-authentication-3-descriptor) without the *EFI\_VARIABLE\_APPEND\_WRITE* attribute set.

The authenticated UEFI variable that stores the key exchange keys (KEKs) can always be read but only be written if:

* The platform is in user mode and the provided variable data is signed with the current PKpriv; *or* if
* The platform is in setup mode (in this case the variable can be written without a signature validation, but the *SetVariable()* call needs to be formatted in accordance with the procedure for authenticated variables in [Using the EFI\_VARIABLE\_AUTHENTICATION\_3 descriptor](08_Services_Runtime_Services.html#using-the-efi-variable-authentication-3-descriptor))

The name and GUID of the Key Exchange Key variable are specified in [Globally Defined Variables](03_Boot_Manager.html#globally-defined-variables-boot-manager), âGlobally Defined Variables.â The platform vendor may provide a default set of Key Exchange Keys in the KEKDefault variable described in [Globally Defined Variables](03_Boot_Manager.html#globally-defined-variables-boot-manager). If present, these keys (or a subset) may optionally be used when performing the initial enrollment of Key Exchange Keys. If any are to be used, they may be parsed from the variable and enrolled as described above.

### 32.3.6. Platform Firmware Key Storage Requirements[Â¶](#platform-firmware-key-storage-requirements "Permalink to this headline")

This section describes the platform firmware storage
requirements of the different types of keys.

Platform Keys:

The public key must be stored in non-volatile storage which
is tamper and delete resistant.

Key Exchange Keys:

The public key must be stored in non-volatile storage which
is tamper resistant.
Careful consideration should be given to the security and
configuration of any out-of-band management agent (e.g.
hypervisor or service processor) such that the platform
cannot exploit the management agent in order to circumvent
Secure Boot.

## 32.4. Firmware/OS Key Exchange: Passing Public Keys[Â¶](#firmware-os-key-exchange-passing-public-keys "Permalink to this headline")

This section describes a means of passing public keys
from the OS to the platform firmware so that these keys
can be used to securely pass information between the OS
and the platform firmware.
Typically, the OS has been unable to communicate
sensitive information or enforce any sort of policy
because of the possibility of spoofing by a malicious
software agent. That is, the platform firmware has been
unable to trust the OS. By enrolling these public keys,
authorized by the platform owner, the platform firmware
can now check the signature of data passed by the
operating system.
Of course if the malicious software agent is running as
part of the OS, such as a rootkit, then any communication
between the firmware and operating system still remains
the subject of spoofing as the malicious code has access
to the key exchange key.

### 32.4.1. Signature Database[Â¶](#signature-database "Permalink to this headline")

#### 32.4.1.1. EFI\_SIGNATURE\_DATA[Â¶](#efi-signature-data "Permalink to this headline")

**Summary**

The format of a signature database.

**Prototype**

```
#pragma pack(1)
typedef struct _EFI_SIGNATURE_DATA {
  EFI_GUID                 SignatureOwner;
  UINT8                    SignatureData [_];
}   EFI_SIGNATURE_DATA;

typedef struct _EFI_SIGNATURE_LIST {
  EFI_GUID                 SignatureType;
  UINT32                   SignatureListSize;
  UINT32                   SignatureHeaderSize;
  UINT32                   SignatureSize;
//   UINT8                 SignatureHeader [SignatureHeaderSize];
//   EFI_SIGNATURE_DATA    Signatures [__][SignatureSize];
}   EFI_SIGNATURE_LIST;
#pragma pack()

```

**Members**

SignatureListSize

Total size of the signature list, including this header.

SignatureType

Type of the signature. GUID signature types are defined in âRelated Definitionsâ below.

SignatureHeaderSize

Size of the signature header which precedes the array of signatures.

SignatureSize

Size of each signature. Must be at least the size of *EFI\_SIGNATURE\_DATA*.

SignatureHeader

Header before the array of signatures. The format of this header is specified by the *SignatureType*.

Signatures

An array of signatures. Each signature is *SignatureSize* bytes in length. The format of the signature is defined by the *SignatureType*.

SignatureOwner

An identifier which identifies the agent which added the signature to the list.

**Description**

The signature database consists of zero or more signature lists. The size of the signature database can be determined by examining the size of the UEFI variable.

Each signature list is a list of signatures of one type, identified by *SignatureType*. The signature list contains a header and then an array of zero or more signatures in the format specified by the header. The size of each signature in the signature list is specified by *SignatureSize*.

Each signature has an owner *SignatureOwner,* which is a GUID identifying the agent which inserted the signature in the database. Agents might include the operating system or an OEM-supplied driver or application. Agents may examine this field to understand whether they should manage the signature or not.

[![_images/Secure_Boot_and_Driver_Signing-6.png](_images/Secure_Boot_and_Driver_Signing-6.png)](_images/Secure_Boot_and_Driver_Signing-6.png)

Fig. 32.5 Signature Lists[Â¶](#signature-lists "Permalink to this image")

**Related Definitions**

```
#define EFI_CERT_SHA256_GUID \
  { 0xc1c41626, 0x504c, 0x4092, \
  { 0xac, 0xa9, 0x41, 0xf9, 0x36, 0x93, 0x43, 0x28 } };

```

This identifies a signature containing a SHA-256 hash. The *SignatureHeader* size shall always be 0. The *SignatureSize* shall always be 16 (size of *SignatureOwner* component) + 32 bytes.

```
#define EFI_CERT_RSA2048_GUID \
  { 0x3c5766e8, 0x269c, 0x4e34, \
  { 0xaa, 0x14, 0xed, 0x77, 0x6e, 0x85, 0xb3, 0xb6 } };

```

This identifies a signature containing an RSA-2048 key. The key (only the modulus since the public key exponent is known to be 0x10001) shall be stored in big-endian order.

The *SignatureHeader* size shall always be 0. The *SignatureSize* shall always be 16 (size of *SignatureOwner* component) + 256 bytes.

```
#define EFI_CERT_RSA2048_SHA256_GUID \
  { 0xe2b36190, 0x879b, 0x4a3d, \
  { 0xad, 0x8d, 0xf2, 0xe7, 0xbb, 0xa3, 0x27, 0x84 } };

```

This identifies a signature containing a RSA-2048 signature of a SHA-256 hash. The *SignatureHeader* size shall always be 0. The *SignatureSize* shall always be 16 (size of *SignatureOwner* component) + 256 bytes.

```
#define EFI_CERT_SHA1_GUID \
  { 0x826ca512, 0xcf10, 0x4ac9, \
  { 0xb1, 0x87, 0xbe, 0x01, 0x49, 0x66, 0x31, 0xbd } };

```

This identifies a signature containing a SHA-1 hash. The *SignatureSize* shall always be 16 (size of *SignatureOwner* component) + 20 bytes.

```
#define EFI_CERT_RSA2048_SHA1_GUID \
  { 0x67f8444f, 0x8743, 0x48f1, \
  { 0xa3, 0x28, 0x1e, 0xaa, 0xb8, 0x73, 0x60, 0x80 } };

```

This identifies a signature containing a RSA-2048 signature of a SHA-1 hash. The *SignatureHeader* size shall always be 0. The *SignatureSize* shall always be 16 (size of *SignatureOwner* component) + 256 bytes.

```
#define *EFI_CERT_X509_GUID* \
  { 0xa5c059a1, 0x94e4, 0x4aa7, \
  { 0x87, 0xb5, 0xab, 0x15, 0x5c, 0x2b, 0xf0, 0x72 } };

```

This identifies a signature based on a DER-encoded X.509 certificate. If the signature is an X.509 certificate then verification of the signature of an image should validate the public key certificate in the image using certificate path verification, up to this X.509 certificate as a trusted root. The *SignatureHeader* size shall always be 0. The *SignatureSize* may vary but shall always be 16 (size of the *SignatureOwner* component) + the size of the certificate itself.

**NOTE**: *This means that each certificate will normally be in a separate* EFI\_SIGNATURE\_LIST.

```
#define EFI_CERT_SHA224_GUID \
  { 0xb6e5233, 0xa65c, 0x44c9, \
  {0x94, 0x07, 0xd9, 0xab, 0x83, 0xbf, 0xc8, 0xbd} };

```

This identifies a signature containing a SHA-224 hash. The *SignatureHeader* size shall always be 0. The *SignatureSize* shall always be 16 (size of *SignatureOwner* component) + 28 bytes.

```
#define EFI_CERT_SHA384_GUID \
  { 0xff3e5307, 0x9fd0, 0x48c9, \
  {0x85, 0xf1, 0x8a, 0xd5, 0x6c, 0x70, 0x1e, 0x01}};

```

This identifies a signature containing a SHA-384 hash. The *SignatureHeader* size shall always be 0. The *SignatureSize* shall always be 16 (size of *SignatureOwner* component) + 48 bytes.

```
#define EFI_CERT_SHA512_GUID \
  { 0x93e0fae, 0xa6c4, 0x4f50, \
  {0x9f, 0x1b, 0xd4, 0x1e, 0x2b, 0x89, 0xc1, 0x9a}}

```

This identifies a signature containing a SHA-512 hash. The *SignatureHeader* size shall always be 0. The *SignatureSize* shall always be 16 (size of *SignatureOwner* component) + 64 bytes.

```
#define EFI_CERT_X509_SHA256_GUID \
  { 0x3bd2a492, 0x96c0, 0x4079, \
  { 0xb4, 0x20, 0xfc, 0xf9, 0x8e, 0xf1, 0x03, 0xed } };

```

**Prototype**

```
#pragma pack(1)
typedef struct _EFI_CERT_X509_SHA256 {
  EFI_SHA256_HASH          ToBeSignedHash;
  EFI_TIME                 TimeOfRevocation;
}   EFI_CERT_X509_SHA256;
#pragma pack()

```

**Members**

ToBeSignedHash

The SHA256 hash of an X.509 certificateâs To-Be-Signed contents.

TimeOfRevocation

The time that the certificate shall be considered to be revoked.

This identifies a signature containing the SHA256 hash of an X.509 certificateâs To-Be-Signed contents, and a time of revocation. The *SignatureHeader* size shall always be 0. The *SignatureSize* shall always be 16 (size of the *SignatureOwner* component) + 48 bytes for an *EFI\_CERT\_X509\_SHA256* structure. If the *TimeOfRevocation* is non-zero, the certificate should be considered to be revoked from that time and onwards, and otherwise the certificate shall be considered to always be revoked.

```
#define EFI_CERT_X509_SHA384_GUID \
  { 0x7076876e, 0x80c2, 0x4ee6, \
  { 0xaa, 0xd2, 0x28, 0xb3, 0x49, 0xa6, 0x86, 0x5b } };

```

**Prototype**

```
#pragma pack(1)
typedef struct _EFI_CERT_X509_SHA384 {
  EFI_SHA384_HASH             ToBeSignedHash;
  EFI_TIME                    TimeOfRevocation;
}   EFI_CERT_X509_SHA384;
#pragma pack()

```

**Members**

ToBeSignedHash

The SHA384 hash of an X.509 certificateâs To-Be-Signed contents.

TimeOfRevocation

The time that the certificate shall be considered to be revoked.

This identifies a signature containing the SHA384 hash of an X.509 certificateâs To-Be-Signed contents, and a time of revocation. The *SignatureHeader* size shall always be 0. The *SignatureSize* shall always be 16 (size of the *SignatureOwner* component) + 64 bytes for an *EFI\_CERT\_X509\_SHA384* structure. If the *TimeOfRevocation* is non-zero, the certificate should be considered to be revoked from that time and onwards, and otherwise the certificate shall be considered to always be revoked.

```
#define EFI_CERT_X509_SHA512_GUID \
  { 0x446dbf63, 0x2502, 0x4cda, \
  { 0xbc, 0xfa, 0x24, 0x65, 0xd2, 0xb0, 0xfe, 0x9d } };

```

**Prototype**

```
#pragma pack(1)
typedef struct _EFI_CERT_X509_SHA512 {
  EFI_SHA512_HASH             ToBeSignedHash;
  EFI_TIME                    TimeOfRevocation;
}   EFI_CERT_X509_SHA512;
#pragma pack()

```

**Members**

ToBeSignedHash

The SHA512 hash of an X.509 certificateâs To-Be-Signed contents.

TimeOfRevocation

The time that the certificate shall be considered to be revoked.

This identifies a signature containing the SHA512 hash of an X.509 certificateâs To-Be-Signed contents, and a time of revocation. The *SignatureHeader* size shall always be 0. The *SignatureSize* shall always be 16 (size of the *SignatureOwner* component) + 80 bytes for an *EFI\_CERT\_X509\_SHA512* structure. If the *TimeOfRevocation* is non-zero, the certificate should be considered to be revoked from that time and onwards, and otherwise the certificate shall be considered to always be revoked.

```
#define EFI_CERT_EXTERNAL_MANAGEMENT_GUID \
  { 0x452e8ced, 0xdfff, 0x4b8c, \
  { 0xae, 0x01, 0x51, 0x18, 0x86, 0x2e, 0x68, 0x2c } };

```

This *SignatureType* describes a pseudo-signature which will not facilitate authentication. It is only meaningful within a signature list used for authenticating writes through *SetVariable(),* and is only effective if it is the only signature present in that signature list. It allows a signature list to be populated without providing any means for *SetVariable()* to succeed. This signature type is intended for use on a platform with an external out-of-band management agent (e.g. hypervisor or service processor). When a platform is configured such that only signatures of this *SignatureType* are available for authenticating writes to a variable, that variable may only be modified by the external management agent using a platform-specific interface.

When a write may be authenticated using any signature from multiple signature lists, the presence of this signature in one of those signature lists does not inhibit the use of signatures present in the other signature lists. For example, if this signature is placed in PK, an attempt to write to db using *SetVariable()* will still succeed if it is signed by a valid KEKpriv, but a write to PK or KEK through *SetVariable()* cannot succeed because no PKpriv exists.

The *SignatureHeader* size shall always be 0. The *SignatureSize* shall always be 16 (size of *SignatureOwner* component) + 1 byte. The one byte of *SignatureData* exists only for compatibility reasons; It should be written as zero, and any value read should be ignored.

### 32.4.2. Image Execution Information Table[Â¶](#image-execution-information-table "Permalink to this headline")

**Summary**

When *AuditMode==0,* if the imageâs signature is not found in the authorized database, or is found in the forbidden database, the image will not be started and instead, information about it will be placed in the EFI\_IMAGE\_EXECUTION\_INFO\_TABLE (see section 32.5.3.1). {cross-reference needed}

When *AuditMode==1,* *an* *EFI\_IMAGE\_EXECUTION\_INFO* *element is created in the* *EFI\_IMAGE\_EXECUTION\_INFO\_TABLE* *for every certificate found in the certificate table of every image that is validated.*

Additionally for every image, an element will be created in the table for every EFI\_CERT\_SHAXXX that is supported by the platform. The contents of\* *Action* *for each element are determined by comparing that specific elementâs* *Signature* *(which will contain exactly 1* *EFI\_SIGNATURE\_DATA* *) to the currently-configured image security databases and policies, and shall be either \*EFI\_IMAGE\_EXECUTION\_AUTH\_SIG\_PASSED* , *EFI\_IMAGE\_EXECUTION\_AUTH\_SIG\_FAILED* ,
EFI\_iMAGE)EXECUTION\_AUTH\_SIG\_NOT\_FOUND, EFI\_IMAGE\_EXECUTION\_AUTH\_SIG\_FOUND, or *EFI\_IMAGE\_EXECUTION\_POLICY\_FAILED*.

Finally, because the system is in Audit Mode, all modules are initialized even if they fail to authenticate, and the *EFI\_IMAGE\_EXECUTION\_INITIALIZED* bit shall be set in *Action* for all elements.

**Prototype**

```
typedef struct {
  EFI_IMAGE_EXECUTION_ACTION     Action;
  UINT32                         InfoSize;
// CHAR16                        Name [__];
// EFI_DEVICE_PATH_PROTOCOL      DevicePath;
// EFI_SIGNATURE_LIST            Signature;
} EFI_IMAGE_EXECUTION_INFO;

```

**Parameters**

Action

Describes the action taken by the firmware regarding this image. Type EFI\_IMAGE\_EXECUTION\_ACTION is described in âRelated Definitionsâ below.

InfoSize

Size of all of the entire structure.

Name

If this image was a UEFI device driver (for option ROM, for example) this is the null-terminated, user-friendly name for the device. If the image was for an application, then this is the name of the application. If this cannot be determined, then a simple NULL character should be put in this position.

DevicePath

Image device path. The image device path typically comes from the Loaded Image Device Path Protocol installed on the image handle. If image device path cannot be determined, a simple end-of-path device node should be put in this position.

Signature

Zero or more image signatures. If the image contained no signatures, then this field is empty.The type *WIN\_CERTIFICATE* is defined in chapter 26.

**Prototype**

```
typedef struct {
  UINTN                       NumberOfImages;
  EFI_IMAGE_EXECUTION_INFO    InformationInfo[__]
}   EFI_IMAGE_EXECUTION_INFO_TABLE;

```

NumberOfImages

Number of *EFI\_IMAGE\_EXECUTION\_INFO* structures.

InformationInfo

*NumberOfImages* instances of *EFI\_IMAGE\_EXECUTION\_INFO* structures.

**Related Definitions**

```
typedef UINT32 EFI_IMAGE_EXECUTION_ACTION;

#define EFI_IMAGE_EXECUTION_AUTHENTICATION      0x00000007
#define EFI_IMAGE_EXECUTION_AUTH_UNTESTED       0x00000000
#define EFI_IMAGE_EXECUTION_AUTH_SIG_FAILED     0x00000001
#define EFI_IMAGE_EXECUTION_AUTH_SIG_PASSED     0x00000002
#define EFI_IMAGE_EXECUTION_AUTH_SIG_NOT_FOUND  0x00000003
#define EFI_IMAGE_EXECUTION_AUTH_SIG_FOUND      0x00000004
#define EFI_IMAGE_EXECUTION_POLICY_FAILED       0x00000005

#define EFI_IMAGE_EXECUTION_INITIALIZED         0x00000008

```

**Description**

This structure describes an image in the EFI System Configuration Table. It is only required in the case where image signatures are being checked and the image was not initialized because its signature failed, when AuditMode==1, or was not found in the signature database *and* an authorized user or the owner would not authorize its execution. It may be used in other cases as well.

In these cases, the information about the image is copied into the EFI System Configuration Table. Information about other images which were successfully initialized may also be included as well, but this is not required.

The *Action* field describes what action the firmware took with regard to the image and what other information it has about the image, including the device which it is related to.

First, this field describes the results of the firmwareâs attempt to authenticate the image.

Table 32.5 Authentication Attempt Status Codes[Â¶](#authentication-attempt-status-codes "Permalink to this table")
| Authentication attempt status | Condition met |
| --- | --- |
| *EFI\_IMAGE\_EXECUTION\_AUTH\_UNTESTED* | The image contained no certificates |
| *EFI\_IMAGE\_EXECUTION\_AUTH\_SIG\_FAILED* | The image has at least one certificate, and either:  * An image certificate is in the forbidden database, **or** * A digest of an image certifcate is in the forbidden database, **or** * The image signature check failed. |
| *EFI\_IMAGE\_EXECUTION\_AUTH\_SIG\_PASSED* | The image has at least one certificate, and either:  * An image certifcate is in authroized database. * The image digest is in the authorized database. |
| *EFI\_IMAGE\_EXECUTION\_AUTH\_SIG\_NOT\_FOUND* | The image has at least one certifcate, and:  * the image certificate is not found in the authorized database, **and** * the image digest is not in the authorized database. |
| *EFI\_IMAGE\_EXECUTION\_AUTH\_SIG\_FOUND* | The image has at least one certificate, and the image digest is in the forbidden database. |
| *EFI\_IMAGE\_EXECUTION\_POLICY\_FAILED* | Authentication failed because of (unspecified) firmware security policy. |

Second, this field describes whether the image was initialized or not.

This table can be used by an agent which executes later to audit which images were not loaded and perhaps query other sources to discover whether the image should be authorized. If so, the agent can use the method described in âSignature Database Updateâ to update the Signature Database with the imageâs signature. Switching the system into Audit Mode generates a more verbose table which provides additional insights to this agent.

If an attempt to boot a legacy non-UEFI OS takes place when the system is in User Mode, the OS load shall fail and a corresponding *EFI\_IMAGE\_EXECUTION\_INFO* entry shall be created with Action set to *EFI\_IMAGE\_EXECUTION\_AUTH\_UNTESTED,* Name set to the NULL-terminated âDescription Stringâ from the BIOS Boot Specification Device Path and DevicePath set to the BIOS Boot Specification Device Path ( [BIOS Boot Specification Device Path](10_Protocols_Device_Path_Protocol.html#bios-boot-specification-device-path) ).

## 32.5. UEFI Image Validation[Â¶](#uefi-image-validation "Permalink to this headline")

### 32.5.1. Overview[Â¶](#overview "Permalink to this headline")

This section describes a way to use the platform ownership model described in the previous section and the key exchange mechanism to allow the firmware to authenticate a UEFI image, such as an OS loader or an option ROM, using the digital signing mechanisms described here.

The hand-off between the platform firmware and the operating system is a critical part of ensuring secure boot. Since there are large numbers of operating systems and a large number of minor variations in the loaders for those operating systems, it is difficult to carry all possible keys or signatures within the firmware as it ships. This requires some sort of update mechanism, to identify the proper loader. But, as with any update mechanism, there is the risk of allowing malicious software to âauthenticateâ itself, posing as the real operating system.

Likewise, there are a large number of potential 3rd-party UEFI applications, drivers and option ROMs and it is difficult to carry all possible keys or signatures within the firmware as it ships.

The mechanism described here requires that the platform firmware maintain a signature database, with entries for each authorized UEFI image (the authorized UEFI signature database). The signature database is a single UEFI Variable.

It also requires that the platform firmware maintain a signature database with entries for each forbidden UEFI image. This signature database is also a single UEFI variable.

The signature database is checked when the UEFI Boot Manager is about to start a UEFI image. If the UEFI imageâs signature is not found in the authorized database, or is found in the forbidden database, the UEFI image will be deferred and information placed in the Image Execution Information Table. In the case of OS Loaders, the next boot option will be selected. The signature databases may be updated by the firmware, by a pre-OS application or by an OS application or driver.

If a firmware supports the *EFI\_CERT\_X509\_SHA\*\_GUID* signature types, it should support the RFC3161 timestamp specification. Images whose signature matches one of these types in the forbidden signature database shall only be considered forbidden if the firmware either does not support timestamp verification, or the signature type has a time of revocation equal to zero, or the timestamp does not pass verification against the authorized timestamp and forbidden signature databases, or finally the signature typeâs time of revocation is less than or equal to the time recorded in the image signatureâs timestamp. If the timestampâs signature is authorized by the authorized timestamp database and the time recorded in the timestamp is less than the time of revocation, the image shall not be considered forbidden provided it is not forbidden by any other entry in the forbidden signature database. Finally, this requires that firmware supporting timestamp verification must support the authorized timestamp database and have a suitable time stamping authority certificate in that database.

### 32.5.2. Authorized User[Â¶](#authorized-user "Permalink to this headline")

An *authorized user* (for the purposes of UEFI image security) is one who possesses a key exchange key (KEKpriv). This key is used to sign updates to the signature databases.

### 32.5.3. Signature Database Update[Â¶](#signature-database-update "Permalink to this headline")

The Authorized, Forbidden, Timestamp, and Recovery signature databases are stored as UEFI authenticated variables (see Variable Services in [Exception for Machine Check, INIT, and NMI](08_Services_Runtime_Services.html#exception-for-machine-check-init-and-nmi)) with the GUID

*EFI\_IMAGE\_SECURITY\_DATABASE\_GUID* and the names
*EFI\_IMAGE\_SECURITY\_DATABASE,*
*EFI\_IMAGE\_SECURITY\_DATABASE1,*
*EFI\_IMAGE\_SECURITY\_DATABASE2,* and
*EFI\_IMAGE\_SECURITY\_DATABASE3,* respectively.

These authenticated UEFI variables that store the signature databases (db, dbx, dbr, or dbt) can always be read but can only be written if:

* The platform is in user mode and the provided variable data is signed with the private half of a previously enrolled key exchange key (KEKpriv \*), or the platform private key (PKpriv);

  or if
* The platform is in setup mode (in this case the variables can be written without a signature validation, but the *SetVariable()* call needs to be formatted in accordance with the procedure for authenticated variables in [Using the EFI\_VARIABLE\_AUTHENTICATION\_3 descriptor](08_Services_Runtime_Services.html#using-the-efi-variable-authentication-3-descriptor))

The signature databases are in the form of Signature Databases, as described in âSignature Databaseâ above.

The platform vendor may provide a default set of entries for the Signature Database in the dbDefault, dbxDefault, dbtDefault, and dbrDefault variables described in [Globally Defined Variables](03_Boot_Manager.html#globally-defined-variables-boot-manager). If present, these keys (or a subset) may optionally be used when performing the initial enrollment of signature database entries. If any are to be used, they may be parsed from the variable and enrolled as described below.

If, when adding a signature to the signature database, *SetVariable()* returns *EFI\_OUT\_OF\_RESOURCES,* indicating there is no more room, the updater may discard the new signature or it may decide to discard one of the database entries. These authenticated UEFI variables that store the signature databases (db, or dbx, dbt, or dbr) can always be read but can only be written if:

The following diagram illustrates the process for adding a new signature by the OS or an application that has access to a previously enrolled key exchange key using *SetVariable()*. In the diagram, the *EFI\_VARIABLE\_APPEND\_WRITE* attribute is not used. If *EFI\_VARIABLE\_APPEND\_WRITE* had been used, then steps 2 and 3 could have been omitted and step 7 would have included setting the *EFI\_VARIABLE\_APPEND\_WRITE* attribute.

1. The procedure begins by generating a new signature, in the format described by the Signature Database.
2. Call *GetVariable()* using *EFI\_IMAGE\_SECURITY\_DATABASE\_GUID* for the\*VendorGuid\* parameter and *EFI\_IMAGE\_SECURITY\_DATABASE* for the VariableName parameter.
3. If the variable exists, go to step 5.
4. Create an empty authorized signature database.
5. Create a new buffer which contains the authorized signature database, along with the new signature appended to the end.
6. Sign the new signature database using the private half of the Key Exchange Key as described in *SetVariable()*.
7. Update the authorized signature database using the UEFI Runtime Service *SetVariable()*.
8. If there was no error, go to step 11.
9. If there was an error because of no more resources, determine whether the database can be shrunk any more. The algorithm by which an agent decides which signatures may be safely removed is agent-specific. In most cases, agents should not remove signatures where the SignatureOwner field is not the agentâs. If not, then go to step 11, discarding the new signature.
10. If the signature database could be shrunk further, then remove the entries and go to step 6.
11. Exit.

[![_images/Secure_Boot_and_Driver_Signing-7.png](_images/Secure_Boot_and_Driver_Signing-7.png)](_images/Secure_Boot_and_Driver_Signing-7.png)

Fig. 32.6 Process for Adding a New Signature by the OS[Â¶](#process-for-adding-a-new-signature-by-the-os "Permalink to this image")

#### 32.5.3.1. Using The Image Execution Information Table[Â¶](#using-the-image-execution-information-table "Permalink to this headline")

During the process of loading UEFI images, the firmware must gather information about which UEFI images were not started. The firmware may additionally gather information about UEFI images which were started. The information is used to create the IEFI\_IMAGE\_EXECUTION\_INFO\_TABLE, which is added to the EFI System Configuration Table and assigned the GUID *EFI\_IMAGE\_SECURITY\_DATABASE\_GUID.*

For each UEFI image, the following information is collected:

* The image hash.
* The user-friendly name of the UEFI image (if known)
* The device path
* The action taken on the device (was it initialized or why was it rejected).

For more information, see the Image Execution Information Table definition above ( [Image Execution Information Table](#image-execution-information-table)).

#### 32.5.3.2. Firmware Policy[Â¶](#firmware-policy "Permalink to this headline")

The firmware may approve UEFI images for other reasons than those specified here. For example: whether the image is in the system flash, whether the device providing the UEFI image is secured (in a case, etc.) or whether the image contains another type of platform-supported digital signature.

#### 32.5.3.3. Authorization Process[Â¶](#authorization-process "Permalink to this headline")

This section describes the process by which an unknown UEFI image might be authorized to run. Implementations are not required to support all portions of this. For example, an implementation might defer all UEFI image or none.

[![_images/Secure_Boot_and_Driver_Signing-8.png](_images/Secure_Boot_and_Driver_Signing-8.png)](_images/Secure_Boot_and_Driver_Signing-8.png)

Fig. 32.7 Authorization Process Flow[Â¶](#authorization-process-flow "Permalink to this image")

1. Reset. This is when the platform begins initialization during boot.
2. Key Store Initialization. During the firmware initialization and before any signed UEFI images are initialized, the platform firmware must validate the signature database.
3. UEFI Image Validation Succeeded? During initialization of an UEFI image, the UEFI Boot Manager decides whether or not the UEFI image should be initialized. By comparing the calculated UEFI image signature against that in one of the signature databases, the firmware can determine if there is a match.

The security database *db* must either contain an entry with a hash value of the image (with a supported hash type), or it must contain an entry with a certificate against which an entry in the imageâs certificate table can be verified. In either case verification must not succeed if the security database dbx contains any record with:

â A. Any entry with *SignatureListType* of *EFI\_CERT\_SHA256\_GUID* with any
*SignatureData* containing the SHA-256 hash of the binary.

â B. Any entry with *SignatureListType* of *EFI\_CERT\_X509\_SHA256,* *EFI\_CERT\_X509\_SHA384,* or *EFI\_CERT\_X509\_SHA512,* with any SignatureData which reflects the To-Be-Signed hash included in any certificate in the signing chain of the signature being verified.

â C. Any entry with *SignatureListType* of *EFI\_CERT\_X509\_GUID,* with *SignatureData* which contains a certificate with the same Issuer, Serial Number, and To-Be-Signed hash included in any certificate in the signing chain of the signature being verified.

Multiple signatures are allowed to exist in the binaryâs certificate table (as per PE/COFF Section âAttribute Certificate Tableâ). Only one hash or signature is required to be present in *db* in order to pass validation, so long as neither the SHA-256 hash of the binary nor any present signature is reflected in dbx.

Then, based on this match or its own policy, the firmware can decide whether or not to launch the UEFI image.

4. Start UEFI Image. If the UEFI Image is approved, then it is launched normally.
5. UEFI Image Not Approved. If the UEFI image was not approved the platform firmware may use other methods to discover if the UEFI image is authorized, such as consult a disk-based catalog or ask an authorized user. The result can be one of three responses: Yes, No or Defer.
6. UEFI Image Signature Added To Signature Database. If the user approves of the UEFI image, then the UEFI imageâs signature is saved in the firmwareâs signature database. If user approval is supported, then the firmware be able to update of the Signature Database. For more information, see Signature Database Update.
7. Go To Next Boot Option. If an UEFI image is rejected, then the next boot option is selected normally and go to step 3. This is in the case where the image is listed as a boot option.
8. UEFI Image Signature Passed In System Configuration Table. If user defers, then the UEFI image signature is copied into the Image Execution Information Table in the EFI System Configuration Table which is available to the operating system.
9. OS Application Validates UEFI Image. An OS application determines whether the image is valid.
10. UEFI Image Signature Added To Signature Database. For more information, see Signature Database Update.
11. End.

## 32.6. Code Definitions[Â¶](#secure-boot-and-driver-signing-code-definitions "Permalink to this headline")

### 32.6.1. UEFI Image Variable GUID & Variable Name[Â¶](#uefi-image-variable-guid-variable-name "Permalink to this headline")

**Summary**

Constants used for UEFI signature database variable access.

**Prototype**

```
#define EFI_IMAGE_SECURITY_DATABASE_GUID \
  { 0xd719b2cb, 0x3d3a, 0x4596, \
  { 0xa3, 0xbc, 0xda, 0xd0, 0x0e, 0x67, 0x65, 0x6f }}
#define EFI_IMAGE_SECURITY_DATABASE L"db"
#define EFI_IMAGE_SECURITY_DATABASE1 L"dbx"
#define EFI_IMAGE_SECURITY_DATABASE2 L"dbt"
#define EFI_IMAGE_SECURITY_DATABASE3 L"dbr"

```

**Description**

* This GUID and name are used when calling the EFI Runtime Services *GetVariable()* and *SetVariable()*.
* The *EFI\_IMAGE\_SECURITY\_DATABASE\_GUID* and *EFI\_IMAGE\_SECURITY\_DATABASE* are used to retrieve and change the authorized signature database.
* The *EFI\_IMAGE\_SECURITY\_DATABASE\_GUID* and *EFI\_IMAGE\_SECURITY\_DATABASE1* are used to retrieve and change the forbidden signature database.
* The *EFI\_IMAGE\_SECURITY\_DATABASE\_GUID* and *EFI\_IMAGE\_SECURITY\_DATABASE2* are used to retrieve and change the authorized timestamp signature database.
* The *EFI\_IMAGE\_SECURITY\_DATABASE\_GUID* and *EFI\_IMAGE\_SECURITY\_DATABASE3* are used to retrieve and change the authorized recovery signature database.
* Firmware shall support the *EFI\_VARIABLE\_APPEND\_WRITE* flag () [Exception for Machine Check, INIT, and NMI](08_Services_Runtime_Services.html#exception-for-machine-check-init-and-nmi) ) for the UEFI signature database variables.
* The signature database variables db, dbt, dbx, and dbr must be stored in tamper-resistant non-volatile storage.

[Next](33_Human_Interface_Infrastructure.html "33. Human Interface Infrastructure Overview")
 [Previous](31_EFI_Redfish_Service_Support.html "31. EFI Redfish Service Support")

---

© Copyright 2021, UEFI Forum, Inc.

Built with [Sphinx](http://sphinx-doc.org/) using a [theme](https://github.com/rtfd/sphinx_rtd_theme) provided by [Read the Docs](https://readthedocs.org).

