

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=92424801261d1564a0bb759da3cf3ccd69fdf5a2)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=92424801261d1564a0bb759da3cf3ccd69fdf5a2)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=92424801261d1564a0bb759da3cf3ccd69fdf5a2)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=92424801261d1564a0bb759da3cf3ccd69fdf5a2)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Daniel Borkmann <daniel@iogearbox.net> | 2024-06-13 13:53:08 +0200 |
| --- | --- | --- |
| committer | Alexei Starovoitov <ast@kernel.org> | 2024-06-13 11:16:01 -0700 |
| commit | [92424801261d1564a0bb759da3cf3ccd69fdf5a2](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=92424801261d1564a0bb759da3cf3ccd69fdf5a2) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=92424801261d1564a0bb759da3cf3ccd69fdf5a2)) | |
| tree | [654062646ac86c1f6322806b02e95326852c5e3d](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=92424801261d1564a0bb759da3cf3ccd69fdf5a2) | |
| parent | [26ba7c3f139f843bf46ed0779e30d84641767959](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=26ba7c3f139f843bf46ed0779e30d84641767959) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=92424801261d1564a0bb759da3cf3ccd69fdf5a2&id2=26ba7c3f139f843bf46ed0779e30d84641767959)) | |
| download | [linux-92424801261d1564a0bb759da3cf3ccd69fdf5a2.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-92424801261d1564a0bb759da3cf3ccd69fdf5a2.tar.gz) | |

bpf: Fix reg\_set\_min\_max corruption of fake\_regJuan reported that after doing some changes to buzzer [0] and implementing
a new fuzzing strategy guided by coverage, they noticed the following in
one of the probes:
[...]
13: (79) r6 = \*(u64 \*)(r0 +0) ; R0=map\_value(ks=4,vs=8) R6\_w=scalar()
14: (b7) r0 = 0 ; R0\_w=0
15: (b4) w0 = -1 ; R0\_w=0xffffffff
16: (74) w0 >>= 1 ; R0\_w=0x7fffffff
17: (5c) w6 &= w0 ; R0\_w=0x7fffffff R6\_w=scalar(smin=smin32=0,smax=umax=umax32=0x7fffffff,var\_off=(0x0; 0x7fffffff))
18: (44) w6 |= 2 ; R6\_w=scalar(smin=umin=smin32=umin32=2,smax=umax=umax32=0x7fffffff,var\_off=(0x2; 0x7ffffffd))
19: (56) if w6 != 0x7ffffffd goto pc+1
REG INVARIANTS VIOLATION (true\_reg2): range bounds violation u64=[0x7fffffff, 0x7ffffffd] s64=[0x7fffffff, 0x7ffffffd] u32=[0x7fffffff, 0x7ffffffd] s32=[0x7fffffff, 0x7ffffffd] var\_off=(0x7fffffff, 0x0)
REG INVARIANTS VIOLATION (false\_reg1): range bounds violation u64=[0x7fffffff, 0x7ffffffd] s64=[0x7fffffff, 0x7ffffffd] u32=[0x7fffffff, 0x7ffffffd] s32=[0x7fffffff, 0x7ffffffd] var\_off=(0x7fffffff, 0x0)
REG INVARIANTS VIOLATION (false\_reg2): const tnum out of sync with range bounds u64=[0x0, 0xffffffffffffffff] s64=[0x8000000000000000, 0x7fffffffffffffff] u32=[0x0, 0xffffffff] s32=[0x80000000, 0x7fffffff] var\_off=(0x7fffffff, 0x0)
19: R6\_w=0x7fffffff
20: (95) exit
from 19 to 21: R0=0x7fffffff R6=scalar(smin=umin=smin32=umin32=2,smax=umax=smax32=umax32=0x7ffffffe,var\_off=(0x2; 0x7ffffffd)) R7=map\_ptr(ks=4,vs=8) R9=ctx() R10=fp0 fp-24=map\_ptr(ks=4,vs=8) fp-40=mmmmmmmm
21: R0=0x7fffffff R6=scalar(smin=umin=smin32=umin32=2,smax=umax=smax32=umax32=0x7ffffffe,var\_off=(0x2; 0x7ffffffd)) R7=map\_ptr(ks=4,vs=8) R9=ctx() R10=fp0 fp-24=map\_ptr(ks=4,vs=8) fp-40=mmmmmmmm
21: (14) w6 -= 2147483632 ; R6\_w=scalar(smin=umin=umin32=2,smax=umax=0xffffffff,smin32=0x80000012,smax32=14,var\_off=(0x2; 0xfffffffd))
22: (76) if w6 s>= 0xe goto pc+1 ; R6\_w=scalar(smin=umin=umin32=2,smax=umax=0xffffffff,smin32=0x80000012,smax32=13,var\_off=(0x2; 0xfffffffd))
23: (95) exit
from 22 to 24: R0=0x7fffffff R6\_w=14 R7=map\_ptr(ks=4,vs=8) R9=ctx() R10=fp0 fp-24=map\_ptr(ks=4,vs=8) fp-40=mmmmmmmm
24: R0=0x7fffffff R6\_w=14 R7=map\_ptr(ks=4,vs=8) R9=ctx() R10=fp0 fp-24=map\_ptr(ks=4,vs=8) fp-40=mmmmmmmm
24: (14) w6 -= 14 ; R6\_w=0
[...]
What can be seen here is a register invariant violation on line 19. After
the binary-or in line 18, the verifier knows that bit 2 is set but knows
nothing about the rest of the content which was loaded from a map value,
meaning, range is [2,0x7fffffff] with var\_off=(0x2; 0x7ffffffd). When in
line 19 the verifier analyzes the branch, it splits the register states
in reg\_set\_min\_max() into the registers of the true branch (true\_reg1,
true\_reg2) and the registers of the false branch (false\_reg1, false\_reg2).
Since the test is w6 != 0x7ffffffd, the src\_reg is a known constant.
Internally, the verifier creates a "fake" register initialized as scalar
to the value of 0x7ffffffd, and then passes it onto reg\_set\_min\_max(). Now,
for line 19, it is mathematically impossible to take the false branch of
this program, yet the verifier analyzes it. It is impossible because the
second bit of r6 will be set due to the prior or operation and the
constant in the condition has that bit unset (hex(fd) == binary(1111 1101).
When the verifier first analyzes the false / fall-through branch, it will
compute an intersection between the var\_off of r6 and of the constant. This
is because the verifier creates a "fake" register initialized to the value
of the constant. The intersection result later refines both registers in
regs\_refine\_cond\_op():
[...]
t = tnum\_intersect(tnum\_subreg(reg1->var\_off), tnum\_subreg(reg2->var\_off));
reg1->var\_off = tnum\_with\_subreg(reg1->var\_off, t);
reg2->var\_off = tnum\_with\_subreg(reg2->var\_off, t);
[...]
Since the verifier is analyzing the false branch of the conditional jump,
reg1 is equal to false\_reg1 and reg2 is equal to false\_reg2, i.e. the reg2
is the "fake" register that was meant to hold a constant value. The resulting
var\_off of the intersection says that both registers now hold a known value
of var\_off=(0x7fffffff, 0x0) or in other words: this operation manages to
make the verifier think that the "constant" value that was passed in the
jump operation now holds a different value.
Normally this would not be an issue since it should not influence the true
branch, however, false\_reg2 and true\_reg2 are pointers to the same "fake"
register. Meaning, the false branch can influence the results of the true
branch. In line 24, the verifier assumes R6\_w=0, but the actual runtime
value in this case is 1. The fix is simply not passing in the same "fake"
register location as inputs to reg\_set\_min\_max(), but instead making a
copy. Moving the fake\_reg into the env also reduces stack consumption by
120 bytes. With this, the verifier successfully rejects invalid accesses
from the test program.
[0] https://github.com/google/buzzer
Fixes: 67420501e868 ("bpf: generalize reg\_set\_min\_max() to handle non-const register comparisons")
Reported-by: Juan José López Jaimez <jjlopezjaimez@google.com>
Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Reviewed-by: John Fastabend <john.fastabend@gmail.com>
Link: [https://lore.kernel.org/r/20240613115310.25383-1-daniel@iogearbox.net](https://lore.kernel.org/r/20240613115310.25383-1-daniel%40iogearbox.net)
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=92424801261d1564a0bb759da3cf3ccd69fdf5a2)

| -rw-r--r-- | [include/linux/bpf\_verifier.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/bpf_verifier.h?id=92424801261d1564a0bb759da3cf3ccd69fdf5a2) | 2 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/bpf/verifier.c?id=92424801261d1564a0bb759da3cf3ccd69fdf5a2) | 14 | |  |  |  | | --- | --- | --- | |

2 files changed, 12 insertions, 4 deletions

| diff --git a/include/linux/bpf\_verifier.h b/include/linux/bpf\_verifier.hindex 50aa87f8d77ff6..e4070fb02b1100 100644--- a/[include/linux/bpf\_verifier.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/bpf_verifier.h?id=26ba7c3f139f843bf46ed0779e30d84641767959)+++ b/[include/linux/bpf\_verifier.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/bpf_verifier.h?id=92424801261d1564a0bb759da3cf3ccd69fdf5a2)@@ -746,6 +746,8 @@ struct bpf\_verifier\_env { /\* Same as scratched\_regs but for stack slots \*/ u64 scratched\_stack\_slots; u64 prev\_log\_pos, prev\_insn\_print\_pos;+ /\* buffer used to temporary hold constants as scalar registers \*/+ struct bpf\_reg\_state fake\_reg[2]; /\* buffer used to generate temporary string representations, \* e.g., in reg\_type\_str() to generate reg\_type string \*/diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.cindex 36ef8e96787ed5..f455548ba46c98 100644--- a/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/verifier.c?id=26ba7c3f139f843bf46ed0779e30d84641767959)+++ b/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/verifier.c?id=92424801261d1564a0bb759da3cf3ccd69fdf5a2)@@ -15113,7 +15113,6 @@ static int check\_cond\_jmp\_op(struct bpf\_verifier\_env \*env, struct bpf\_reg\_state \*regs = this\_branch->frame[this\_branch->curframe]->regs; struct bpf\_reg\_state \*dst\_reg, \*other\_branch\_regs, \*src\_reg = NULL; struct bpf\_reg\_state \*eq\_branch\_regs;- struct bpf\_reg\_state fake\_reg = {}; u8 opcode = BPF\_OP(insn->code); bool is\_jmp32; int pred = -1;@@ -15179,7 +15178,8 @@ static int check\_cond\_jmp\_op(struct bpf\_verifier\_env \*env, verbose(env, "BPF\_JMP/JMP32 uses reserved fields\n"); return -EINVAL; }- src\_reg = &fake\_reg;+ src\_reg = &env->fake\_reg[0];+ memset(src\_reg, 0, sizeof(\*src\_reg)); src\_reg->type = SCALAR\_VALUE; \_\_mark\_reg\_known(src\_reg, insn->imm); }@@ -15239,10 +15239,16 @@ static int check\_cond\_jmp\_op(struct bpf\_verifier\_env \*env, &other\_branch\_regs[insn->src\_reg], dst\_reg, src\_reg, opcode, is\_jmp32); } else /\* BPF\_SRC(insn->code) == BPF\_K \*/ {+ /\* reg\_set\_min\_max() can mangle the fake\_reg. Make a copy+ \* so that these are two different memory locations. The+ \* src\_reg is not used beyond here in context of K.+ \*/+ memcpy(&env->fake\_reg[1], &env->fake\_reg[0],+ sizeof(env->fake\_reg[0])); err = reg\_set\_min\_max(env, &other\_branch\_regs[insn->dst\_reg],- src\_reg /\* fake one \*/,- dst\_reg, src\_reg /\* same fake one \*/,+ &env->fake\_reg[0],+ dst\_reg, &env->fake\_reg[1], opcode, is\_jmp32); } if (err) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 19:32:04 +0000

