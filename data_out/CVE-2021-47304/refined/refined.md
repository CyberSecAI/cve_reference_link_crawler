The provided content relates to CVE-2021-47304.

**Root cause of vulnerability:**
The vulnerability stems from a flaw in the `tcp_init_transfer()` function within the Linux kernel's TCP implementation. Specifically, the function unconditionally resets the `icsk_ca_initialized` flag to 0, potentially leading to double initialization of congestion control modules. This flag is intended to prevent redundant initializations, but the reset within `tcp_init_transfer()` can bypass this protection.

**Weaknesses/vulnerabilities present:**
- Unconditional reset of `icsk_ca_initialized` in `tcp_init_transfer()`: This action can cause congestion control modules to be initialized multiple times without a corresponding release, leading to resource leaks, particularly memory leaks.
- Double Initialization: If a congestion control module allocates resources during initialization, multiple initializations without proper deallocation can lead to resource leaks.

**Impact of exploitation:**
- Memory leaks: Congestion control modules that allocate memory during initialization can leak memory if they are initialized multiple times without releasing previously allocated resources. This could lead to system instability or denial-of-service.
- Other issues: Modules other than CDG that use similar initialization patterns can also be impacted.

**Attack vectors:**
- Network connection establishment: The vulnerability is triggered during the establishment of a TCP connection.
- `setsockopt()` syscall: The `setsockopt(TCP_CONGESTION)` syscall is used to set a custom congestion control module. It is used in conjunction with a TFO connection attempt, which can cause `tcp_init_congestion_control()` to be called during the `TCP_SYN_SENT` state.

**Required attacker capabilities/position:**
- The attacker needs the ability to create a TCP socket.
- The attacker needs to initiate a TFO connect via sendto().
- The attacker can also trigger the vulnerability while the socket is in `TCP_SYN_SENT` state by calling `setsockopt(TCP_CONGESTION)`

**Technical details:**
The vulnerability is triggered by the following sequence of operations:
1. Create a TCP socket.
2. Initiate a TCP Fast Open (TFO) connection using sendto().
3. While the socket is in `TCP_SYN_SENT` state, call `setsockopt(TCP_CONGESTION)` which triggers `tcp_init_congestion_control()`.
4. When the connection is established, `tcp_init_transfer()` is called. This function incorrectly sets `icsk_ca_initialized` to 0 again, which will cause `tcp_init_congestion_control()` to be called a second time, without releasing previously allocated resources.

The fix involves checking if `icsk_ca_initialized` is already set before initializing the congestion control module in `tcp_init_transfer()`.
The fix ensures that `tcp_init_congestion_control()` is called only if it has not been initialized.
```diff
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -5922,8 +5922,8 @@
 	tp->snd_cwnd = tcp_init_cwnd(tp, __sk_dst_get(sk));
 	tp->snd_cwnd_stamp = tcp_jiffies32;
 
-	icsk->icsk_ca_initialized = 0;
 	bpf_skops_established(sk, bpf_op, skb);
+	/* Initialize congestion control unless BPF initialized it already: */
+	if (!icsk->icsk_ca_initialized)
+		tcp_init_congestion_control(sk);
 	tcp_init_buffer_space(sk);
```