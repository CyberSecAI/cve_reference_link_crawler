

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=4af115f1a20a3d9093586079206ee37c2ac55123)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=4af115f1a20a3d9093586079206ee37c2ac55123)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=4af115f1a20a3d9093586079206ee37c2ac55123)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=4af115f1a20a3d9093586079206ee37c2ac55123)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Stephen Boyd <sboyd@kernel.org> | 2024-03-25 11:41:58 -0700 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-05-02 16:23:38 +0200 |
| commit | [4af115f1a20a3d9093586079206ee37c2ac55123](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=4af115f1a20a3d9093586079206ee37c2ac55123) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=4af115f1a20a3d9093586079206ee37c2ac55123)) | |
| tree | [98436b2ffdad3958ba090bbee5393764282c2adc](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=4af115f1a20a3d9093586079206ee37c2ac55123) | |
| parent | [d339ce273962e7b232a759e437206cfdb0bdfad8](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d339ce273962e7b232a759e437206cfdb0bdfad8) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=4af115f1a20a3d9093586079206ee37c2ac55123&id2=d339ce273962e7b232a759e437206cfdb0bdfad8)) | |
| download | [linux-4af115f1a20a3d9093586079206ee37c2ac55123.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-4af115f1a20a3d9093586079206ee37c2ac55123.tar.gz) | |

clk: Get runtime PM before walking tree during disable\_unused[ Upstream commit e581cf5d216289ef292d1a4036d53ce90e122469 ]
Doug reported [1] the following hung task:
INFO: task swapper/0:1 blocked for more than 122 seconds.
Not tainted 5.15.149-21875-gf795ebc40eb8 #1
"echo 0 > /proc/sys/kernel/hung\_task\_timeout\_secs" disables this message.
task:swapper/0 state:D stack: 0 pid: 1 ppid: 0 flags:0x00000008
Call trace:
\_\_switch\_to+0xf4/0x1f4
\_\_schedule+0x418/0xb80
schedule+0x5c/0x10c
rpm\_resume+0xe0/0x52c
rpm\_resume+0x178/0x52c
\_\_pm\_runtime\_resume+0x58/0x98
clk\_pm\_runtime\_get+0x30/0xb0
clk\_disable\_unused\_subtree+0x58/0x208
clk\_disable\_unused\_subtree+0x38/0x208
clk\_disable\_unused\_subtree+0x38/0x208
clk\_disable\_unused\_subtree+0x38/0x208
clk\_disable\_unused\_subtree+0x38/0x208
clk\_disable\_unused+0x4c/0xe4
do\_one\_initcall+0xcc/0x2d8
do\_initcall\_level+0xa4/0x148
do\_initcalls+0x5c/0x9c
do\_basic\_setup+0x24/0x30
kernel\_init\_freeable+0xec/0x164
kernel\_init+0x28/0x120
ret\_from\_fork+0x10/0x20
INFO: task kworker/u16:0:9 blocked for more than 122 seconds.
Not tainted 5.15.149-21875-gf795ebc40eb8 #1
"echo 0 > /proc/sys/kernel/hung\_task\_timeout\_secs" disables this message.
task:kworker/u16:0 state:D stack: 0 pid: 9 ppid: 2 flags:0x00000008
Workqueue: events\_unbound deferred\_probe\_work\_func
Call trace:
\_\_switch\_to+0xf4/0x1f4
\_\_schedule+0x418/0xb80
schedule+0x5c/0x10c
schedule\_preempt\_disabled+0x2c/0x48
\_\_mutex\_lock+0x238/0x488
\_\_mutex\_lock\_slowpath+0x1c/0x28
mutex\_lock+0x50/0x74
clk\_prepare\_lock+0x7c/0x9c
clk\_core\_prepare\_lock+0x20/0x44
clk\_prepare+0x24/0x30
clk\_bulk\_prepare+0x40/0xb0
mdss\_runtime\_resume+0x54/0x1c8
pm\_generic\_runtime\_resume+0x30/0x44
\_\_genpd\_runtime\_resume+0x68/0x7c
genpd\_runtime\_resume+0x108/0x1f4
\_\_rpm\_callback+0x84/0x144
rpm\_callback+0x30/0x88
rpm\_resume+0x1f4/0x52c
rpm\_resume+0x178/0x52c
\_\_pm\_runtime\_resume+0x58/0x98
\_\_device\_attach+0xe0/0x170
device\_initial\_probe+0x1c/0x28
bus\_probe\_device+0x3c/0x9c
device\_add+0x644/0x814
mipi\_dsi\_device\_register\_full+0xe4/0x170
devm\_mipi\_dsi\_device\_register\_full+0x28/0x70
ti\_sn\_bridge\_probe+0x1dc/0x2c0
auxiliary\_bus\_probe+0x4c/0x94
really\_probe+0xcc/0x2c8
\_\_driver\_probe\_device+0xa8/0x130
driver\_probe\_device+0x48/0x110
\_\_device\_attach\_driver+0xa4/0xcc
bus\_for\_each\_drv+0x8c/0xd8
\_\_device\_attach+0xf8/0x170
device\_initial\_probe+0x1c/0x28
bus\_probe\_device+0x3c/0x9c
deferred\_probe\_work\_func+0x9c/0xd8
process\_one\_work+0x148/0x518
worker\_thread+0x138/0x350
kthread+0x138/0x1e0
ret\_from\_fork+0x10/0x20
The first thread is walking the clk tree and calling
clk\_pm\_runtime\_get() to power on devices required to read the clk
hardware via struct clk\_ops::is\_enabled(). This thread holds the clk
prepare\_lock, and is trying to runtime PM resume a device, when it finds
that the device is in the process of resuming so the thread schedule()s
away waiting for the device to finish resuming before continuing. The
second thread is runtime PM resuming the same device, but the runtime
resume callback is calling clk\_prepare(), trying to grab the
prepare\_lock waiting on the first thread.
This is a classic ABBA deadlock. To properly fix the deadlock, we must
never runtime PM resume or suspend a device with the clk prepare\_lock
held. Actually doing that is near impossible today because the global
prepare\_lock would have to be dropped in the middle of the tree, the
device runtime PM resumed/suspended, and then the prepare\_lock grabbed
again to ensure consistency of the clk tree topology. If anything
changes with the clk tree in the meantime, we've lost and will need to
start the operation all over again.
Luckily, most of the time we're simply incrementing or decrementing the
runtime PM count on an active device, so we don't have the chance to
schedule away with the prepare\_lock held. Let's fix this immediate
problem that can be triggered more easily by simply booting on Qualcomm
sc7180.
Introduce a list of clk\_core structures that have been registered, or
are in the process of being registered, that require runtime PM to
operate. Iterate this list and call clk\_pm\_runtime\_get() on each of them
without holding the prepare\_lock during clk\_disable\_unused(). This way
we can be certain that the runtime PM state of the devices will be
active and resumed so we can't schedule away while walking the clk tree
with the prepare\_lock held. Similarly, call clk\_pm\_runtime\_put() without
the prepare\_lock held to properly drop the runtime PM reference. We
remove the calls to clk\_pm\_runtime\_{get,put}() in this path because
they're superfluous now that we know the devices are runtime resumed.
Reported-by: Douglas Anderson <dianders@chromium.org>
Closes: https://lore.kernel.org/all/20220922084322.RFC.2.I375b6b9e0a0a5348962f004beb3dafee6a12dfbb@changeid/ [1]
Closes: https://issuetracker.google.com/328070191
Cc: Marek Szyprowski <m.szyprowski@samsung.com>
Cc: Ulf Hansson <ulf.hansson@linaro.org>
Cc: Krzysztof Kozlowski <krzk@kernel.org>
Fixes: 9a34b45397e5 ("clk: Add support for runtime PM")
Signed-off-by: Stephen Boyd <sboyd@kernel.org>
Link: [https://lore.kernel.org/r/20240325184204.745706-5-sboyd@kernel.org](https://lore.kernel.org/r/20240325184204.745706-5-sboyd%40kernel.org)
Reviewed-by: Douglas Anderson <dianders@chromium.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=4af115f1a20a3d9093586079206ee37c2ac55123)

| -rw-r--r-- | [drivers/clk/clk.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/clk/clk.c?id=4af115f1a20a3d9093586079206ee37c2ac55123) | 117 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 105 insertions, 12 deletions

| diff --git a/drivers/clk/clk.c b/drivers/clk/clk.cindex d2b6c374c3f958..a0927c7f83d606 100644--- a/[drivers/clk/clk.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/clk/clk.c?id=d339ce273962e7b232a759e437206cfdb0bdfad8)+++ b/[drivers/clk/clk.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/clk/clk.c?id=4af115f1a20a3d9093586079206ee37c2ac55123)@@ -37,6 +37,10 @@ static HLIST\_HEAD(clk\_root\_list); static HLIST\_HEAD(clk\_orphan\_list); static LIST\_HEAD(clk\_notifier\_list); +/\* List of registered clks that use runtime PM \*/+static HLIST\_HEAD(clk\_rpm\_list);+static DEFINE\_MUTEX(clk\_rpm\_list\_lock);+ static const struct hlist\_head \*all\_lists[] = { &clk\_root\_list, &clk\_orphan\_list,@@ -59,6 +63,7 @@ struct clk\_core { struct clk\_hw \*hw; struct module \*owner; struct device \*dev;+ struct hlist\_node rpm\_node; struct device\_node \*of\_node; struct clk\_core \*parent; struct clk\_parent\_map \*parents;@@ -129,6 +134,89 @@ static void clk\_pm\_runtime\_put(struct clk\_core \*core) pm\_runtime\_put\_sync(core->dev); } +/\*\*+ \* clk\_pm\_runtime\_get\_all() - Runtime "get" all clk provider devices+ \*+ \* Call clk\_pm\_runtime\_get() on all runtime PM enabled clks in the clk tree so+ \* that disabling unused clks avoids a deadlock where a device is runtime PM+ \* resuming/suspending and the runtime PM callback is trying to grab the+ \* prepare\_lock for something like clk\_prepare\_enable() while+ \* clk\_disable\_unused\_subtree() holds the prepare\_lock and is trying to runtime+ \* PM resume/suspend the device as well.+ \*+ \* Context: Acquires the 'clk\_rpm\_list\_lock' and returns with the lock held on+ \* success. Otherwise the lock is released on failure.+ \*+ \* Return: 0 on success, negative errno otherwise.+ \*/+static int clk\_pm\_runtime\_get\_all(void)+{+ int ret;+ struct clk\_core \*core, \*failed;++ /\*+ \* Grab the list lock to prevent any new clks from being registered+ \* or unregistered until clk\_pm\_runtime\_put\_all().+ \*/+ mutex\_lock(&clk\_rpm\_list\_lock);++ /\*+ \* Runtime PM "get" all the devices that are needed for the clks+ \* currently registered. Do this without holding the prepare\_lock, to+ \* avoid the deadlock.+ \*/+ hlist\_for\_each\_entry(core, &clk\_rpm\_list, rpm\_node) {+ ret = clk\_pm\_runtime\_get(core);+ if (ret) {+ failed = core;+ pr\_err("clk: Failed to runtime PM get '%s' for clk '%s'\n",+ dev\_name(failed->dev), failed->name);+ goto err;+ }+ }++ return 0;++err:+ hlist\_for\_each\_entry(core, &clk\_rpm\_list, rpm\_node) {+ if (core == failed)+ break;++ clk\_pm\_runtime\_put(core);+ }+ mutex\_unlock(&clk\_rpm\_list\_lock);++ return ret;+}++/\*\*+ \* clk\_pm\_runtime\_put\_all() - Runtime "put" all clk provider devices+ \*+ \* Put the runtime PM references taken in clk\_pm\_runtime\_get\_all() and release+ \* the 'clk\_rpm\_list\_lock'.+ \*/+static void clk\_pm\_runtime\_put\_all(void)+{+ struct clk\_core \*core;++ hlist\_for\_each\_entry(core, &clk\_rpm\_list, rpm\_node)+ clk\_pm\_runtime\_put(core);+ mutex\_unlock(&clk\_rpm\_list\_lock);+}++static void clk\_pm\_runtime\_init(struct clk\_core \*core)+{+ struct device \*dev = core->dev;++ if (dev && pm\_runtime\_enabled(dev)) {+ core->rpm\_enabled = true;++ mutex\_lock(&clk\_rpm\_list\_lock);+ hlist\_add\_head(&core->rpm\_node, &clk\_rpm\_list);+ mutex\_unlock(&clk\_rpm\_list\_lock);+ }+}+ /\*\*\* locking \*\*\*/ static void clk\_prepare\_lock(void) {@@ -1231,9 +1319,6 @@ static void \_\_init clk\_unprepare\_unused\_subtree(struct clk\_core \*core) if (core->flags & CLK\_IGNORE\_UNUSED) return; - if (clk\_pm\_runtime\_get(core))- return;- if (clk\_core\_is\_prepared(core)) { trace\_clk\_unprepare(core); if (core->ops->unprepare\_unused)@@ -1242,8 +1327,6 @@ static void \_\_init clk\_unprepare\_unused\_subtree(struct clk\_core \*core) core->ops->unprepare(core->hw); trace\_clk\_unprepare\_complete(core); }-- clk\_pm\_runtime\_put(core); }  static void \_\_init clk\_disable\_unused\_subtree(struct clk\_core \*core)@@ -1259,9 +1342,6 @@ static void \_\_init clk\_disable\_unused\_subtree(struct clk\_core \*core) if (core->flags & CLK\_OPS\_PARENT\_ENABLE) clk\_core\_prepare\_enable(core->parent); - if (clk\_pm\_runtime\_get(core))- goto unprepare\_out;- flags = clk\_enable\_lock();  if (core->enable\_count)@@ -1286,8 +1366,6 @@ static void \_\_init clk\_disable\_unused\_subtree(struct clk\_core \*core)  unlock\_out: clk\_enable\_unlock(flags);- clk\_pm\_runtime\_put(core);-unprepare\_out: if (core->flags & CLK\_OPS\_PARENT\_ENABLE) clk\_core\_disable\_unprepare(core->parent); }@@ -1303,6 +1381,7 @@ \_\_setup("clk\_ignore\_unused", clk\_ignore\_unused\_setup); static int \_\_init clk\_disable\_unused(void) { struct clk\_core \*core;+ int ret;  if (clk\_ignore\_unused) { pr\_warn("clk: Not disabling unused clocks\n");@@ -1311,6 +1390,13 @@ static int \_\_init clk\_disable\_unused(void)  pr\_info("clk: Disabling unused clocks\n"); + ret = clk\_pm\_runtime\_get\_all();+ if (ret)+ return ret;+ /\*+ \* Grab the prepare lock to keep the clk topology stable while iterating+ \* over clks.+ \*/ clk\_prepare\_lock();  hlist\_for\_each\_entry(core, &clk\_root\_list, child\_node)@@ -1327,6 +1413,8 @@ static int \_\_init clk\_disable\_unused(void)  clk\_prepare\_unlock(); + clk\_pm\_runtime\_put\_all();+ return 0; } late\_initcall\_sync(clk\_disable\_unused);@@ -3846,6 +3934,12 @@ static void \_\_clk\_release(struct kref \*ref) { struct clk\_core \*core = container\_of(ref, struct clk\_core, ref); + if (core->rpm\_enabled) {+ mutex\_lock(&clk\_rpm\_list\_lock);+ hlist\_del(&core->rpm\_node);+ mutex\_unlock(&clk\_rpm\_list\_lock);+ }+ clk\_core\_free\_parent\_map(core); kfree\_const(core->name); kfree(core);@@ -3885,9 +3979,8 @@ \_\_clk\_register(struct device \*dev, struct device\_node \*np, struct clk\_hw \*hw) } core->ops = init->ops; - if (dev && pm\_runtime\_enabled(dev))- core->rpm\_enabled = true; core->dev = dev;+ clk\_pm\_runtime\_init(core); core->of\_node = np; if (dev && dev->driver) core->owner = dev->driver->owner; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 12:13:16 +0000

