

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=59b2626dd8c8a2e13f18054b3530e0c00073d79f)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=59b2626dd8c8a2e13f18054b3530e0c00073d79f)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=59b2626dd8c8a2e13f18054b3530e0c00073d79f)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=59b2626dd8c8a2e13f18054b3530e0c00073d79f)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Janusz Krzysztofik <janusz.krzysztofik@linux.intel.com> | 2024-03-05 15:35:06 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-04-03 15:32:42 +0200 |
| commit | [59b2626dd8c8a2e13f18054b3530e0c00073d79f](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=59b2626dd8c8a2e13f18054b3530e0c00073d79f) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=59b2626dd8c8a2e13f18054b3530e0c00073d79f)) | |
| tree | [6e429d28281b7343ca36336571b02ee47c51f59e](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=59b2626dd8c8a2e13f18054b3530e0c00073d79f) | |
| parent | [1db004dfac22ab80d07c1b680f25fe38917aff02](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=1db004dfac22ab80d07c1b680f25fe38917aff02) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=59b2626dd8c8a2e13f18054b3530e0c00073d79f&id2=1db004dfac22ab80d07c1b680f25fe38917aff02)) | |
| download | [linux-59b2626dd8c8a2e13f18054b3530e0c00073d79f.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-59b2626dd8c8a2e13f18054b3530e0c00073d79f.tar.gz) | |

drm/i915/vma: Fix UAF on destroy against retire racecommit 0e45882ca829b26b915162e8e86dbb1095768e9e upstream.
Object debugging tools were sporadically reporting illegal attempts to
free a still active i915 VMA object when parking a GT believed to be idle.
[161.359441] ODEBUG: free active (active state 0) object: ffff88811643b958 object type: i915\_active hint: \_\_i915\_vma\_active+0x0/0x50 [i915]
[161.360082] WARNING: CPU: 5 PID: 276 at lib/debugobjects.c:514 debug\_print\_object+0x80/0xb0
...
[161.360304] CPU: 5 PID: 276 Comm: kworker/5:2 Not tainted 6.5.0-rc1-CI\_DRM\_13375-g003f860e5577+ #1
[161.360314] Hardware name: Intel Corporation Rocket Lake Client Platform/RocketLake S UDIMM 6L RVP, BIOS RKLSFWI1.R00.3173.A03.2204210138 04/21/2022
[161.360322] Workqueue: i915-unordered \_\_intel\_wakeref\_put\_work [i915]
[161.360592] RIP: 0010:debug\_print\_object+0x80/0xb0
...
[161.361347] debug\_object\_free+0xeb/0x110
[161.361362] i915\_active\_fini+0x14/0x130 [i915]
[161.361866] release\_references+0xfe/0x1f0 [i915]
[161.362543] i915\_vma\_parked+0x1db/0x380 [i915]
[161.363129] \_\_gt\_park+0x121/0x230 [i915]
[161.363515] \_\_\_\_intel\_wakeref\_put\_last+0x1f/0x70 [i915]
That has been tracked down to be happening when another thread is
deactivating the VMA inside \_\_active\_retire() helper, after the VMA's
active counter has been already decremented to 0, but before deactivation
of the VMA's object is reported to the object debugging tool.
We could prevent from that race by serializing i915\_active\_fini() with
\_\_active\_retire() via ref->tree\_lock, but that wouldn't stop the VMA from
being used, e.g. from \_\_i915\_vma\_retire() called at the end of
\_\_active\_retire(), after that VMA has been already freed by a concurrent
i915\_vma\_destroy() on return from the i915\_active\_fini(). Then, we should
rather fix the issue at the VMA level, not in i915\_active.
Since \_\_i915\_vma\_parked() is called from \_\_gt\_park() on last put of the
GT's wakeref, the issue could be addressed by holding the GT wakeref long
enough for \_\_active\_retire() to complete before that wakeref is released
and the GT parked.
I believe the issue was introduced by commit d93939730347 ("drm/i915:
Remove the vma refcount") which moved a call to i915\_active\_fini() from
a dropped i915\_vma\_release(), called on last put of the removed VMA kref,
to i915\_vma\_parked() processing path called on last put of a GT wakeref.
However, its visibility to the object debugging tool was suppressed by a
bug in i915\_active that was fixed two weeks later with commit e92eb246feb9
("drm/i915/active: Fix missing debug object activation").
A VMA associated with a request doesn't acquire a GT wakeref by itself.
Instead, it depends on a wakeref held directly by the request's active
intel\_context for a GT associated with its VM, and indirectly on that
intel\_context's engine wakeref if the engine belongs to the same GT as the
VMA's VM. Those wakerefs are released asynchronously to VMA deactivation.
Fix the issue by getting a wakeref for the VMA's GT when activating it,
and putting that wakeref only after the VMA is deactivated. However,
exclude global GTT from that processing path, otherwise the GPU never goes
idle. Since \_\_i915\_vma\_retire() may be called from atomic contexts, use
async variant of wakeref put. Also, to avoid circular locking dependency,
take care of acquiring the wakeref before VM mutex when both are needed.
v7: Add inline comments with justifications for:
- using untracked variants of intel\_gt\_pm\_get/put() (Nirmoy),
- using async variant of \_put(),
- not getting the wakeref in case of a global GTT,
- always getting the first wakeref outside vm->mutex.
v6: Since \_\_i915\_vma\_active/retire() callbacks are not serialized, storing
a wakeref tracking handle inside struct i915\_vma is not safe, and
there is no other good place for that. Use untracked variants of
intel\_gt\_pm\_get/put\_async().
v5: Replace "tile" with "GT" across commit description (Rodrigo),
- avoid mentioning multi-GT case in commit description (Rodrigo),
- explain why we need to take a temporary wakeref unconditionally inside
i915\_vma\_pin\_ww() (Rodrigo).
v4: Refresh on top of commit 5e4e06e4087e ("drm/i915: Track gt pm
wakerefs") (Andi),
- for more easy backporting, split out removal of former insufficient
workarounds and move them to separate patches (Nirmoy).
- clean up commit message and description a bit.
v3: Identify root cause more precisely, and a commit to blame,
- identify and drop former workarounds,
- update commit message and description.
v2: Get the wakeref before VM mutex to avoid circular locking dependency,
- drop questionable Fixes: tag.
Fixes: d93939730347 ("drm/i915: Remove the vma refcount")
Closes: https://gitlab.freedesktop.org/drm/intel/issues/8875
Signed-off-by: Janusz Krzysztofik <janusz.krzysztofik@linux.intel.com>
Cc: Thomas Hellstr√∂m <thomas.hellstrom@linux.intel.com>
Cc: Nirmoy Das <nirmoy.das@intel.com>
Cc: Andi Shyti <andi.shyti@linux.intel.com>
Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
Cc: stable@vger.kernel.org # v5.19+
Reviewed-by: Nirmoy Das <nirmoy.das@intel.com>
Signed-off-by: Andi Shyti <andi.shyti@linux.intel.com>
Link: [https://patchwork.freedesktop.org/patch/msgid/20240305143747.335367-6-janusz.krzysztofik@linux.intel.com](https://patchwork.freedesktop.org/patch/msgid/20240305143747.335367-6-janusz.krzysztofik%40linux.intel.com)
(cherry picked from commit f3c71b2ded5c4367144a810ef25f998fd1d6c381)
Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=59b2626dd8c8a2e13f18054b3530e0c00073d79f)

| -rw-r--r-- | [drivers/gpu/drm/i915/i915\_vma.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/gpu/drm/i915/i915_vma.c?id=59b2626dd8c8a2e13f18054b3530e0c00073d79f) | 50 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 43 insertions, 7 deletions

| diff --git a/drivers/gpu/drm/i915/i915\_vma.c b/drivers/gpu/drm/i915/i915\_vma.cindex d09aad34ba37fa..b70715b1411d67 100644--- a/[drivers/gpu/drm/i915/i915\_vma.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/gpu/drm/i915/i915_vma.c?id=1db004dfac22ab80d07c1b680f25fe38917aff02)+++ b/[drivers/gpu/drm/i915/i915\_vma.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/gpu/drm/i915/i915_vma.c?id=59b2626dd8c8a2e13f18054b3530e0c00073d79f)@@ -34,6 +34,7 @@ #include "gt/intel\_engine.h" #include "gt/intel\_engine\_heartbeat.h" #include "gt/intel\_gt.h"+#include "gt/intel\_gt\_pm.h" #include "gt/intel\_gt\_requests.h" #include "gt/intel\_tlb.h" @@ -103,12 +104,42 @@ static inline struct i915\_vma \*active\_to\_vma(struct i915\_active \*ref)  static int \_\_i915\_vma\_active(struct i915\_active \*ref) {- return i915\_vma\_tryget(active\_to\_vma(ref)) ? 0 : -ENOENT;+ struct i915\_vma \*vma = active\_to\_vma(ref);++ if (!i915\_vma\_tryget(vma))+ return -ENOENT;++ /\*+ \* Exclude global GTT VMA from holding a GT wakeref+ \* while active, otherwise GPU never goes idle.+ \*/+ if (!i915\_vma\_is\_ggtt(vma)) {+ /\*+ \* Since we and our \_retire() counterpart can be+ \* called asynchronously, storing a wakeref tracking+ \* handle inside struct i915\_vma is not safe, and+ \* there is no other good place for that. Hence,+ \* use untracked variants of intel\_gt\_pm\_get/put().+ \*/+ intel\_gt\_pm\_get\_untracked(vma->vm->gt);+ }++ return 0; }  static void \_\_i915\_vma\_retire(struct i915\_active \*ref) {- i915\_vma\_put(active\_to\_vma(ref));+ struct i915\_vma \*vma = active\_to\_vma(ref);++ if (!i915\_vma\_is\_ggtt(vma)) {+ /\*+ \* Since we can be called from atomic contexts,+ \* use an async variant of intel\_gt\_pm\_put().+ \*/+ intel\_gt\_pm\_put\_async\_untracked(vma->vm->gt);+ }++ i915\_vma\_put(vma); }  static struct i915\_vma \*@@ -1404,7 +1435,7 @@ int i915\_vma\_pin\_ww(struct i915\_vma \*vma, struct i915\_gem\_ww\_ctx \*ww, struct i915\_vma\_work \*work = NULL; struct dma\_fence \*moving = NULL; struct i915\_vma\_resource \*vma\_res = NULL;- intel\_wakeref\_t wakeref = 0;+ intel\_wakeref\_t wakeref; unsigned int bound; int err; @@ -1424,8 +1455,14 @@ int i915\_vma\_pin\_ww(struct i915\_vma \*vma, struct i915\_gem\_ww\_ctx \*ww, if (err) return err; - if (flags & PIN\_GLOBAL)- wakeref = intel\_runtime\_pm\_get(&vma->vm->i915->runtime\_pm);+ /\*+ \* In case of a global GTT, we must hold a runtime-pm wakeref+ \* while global PTEs are updated. In other cases, we hold+ \* the rpm reference while the VMA is active. Since runtime+ \* resume may require allocations, which are forbidden inside+ \* vm->mutex, get the first rpm wakeref outside of the mutex.+ \*/+ wakeref = intel\_runtime\_pm\_get(&vma->vm->i915->runtime\_pm);  if (flags & vma->vm->bind\_async\_flags) { /\* lock VM \*/@@ -1561,8 +1598,7 @@ err\_fence: if (work) dma\_fence\_work\_commit\_imm(&work->base); err\_rpm:- if (wakeref)- intel\_runtime\_pm\_put(&vma->vm->i915->runtime\_pm, wakeref);+ intel\_runtime\_pm\_put(&vma->vm->i915->runtime\_pm, wakeref);  if (moving) dma\_fence\_put(moving); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 19:20:18 +0000

