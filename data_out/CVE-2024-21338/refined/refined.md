```
{
  "vulnerability_details": {
    "root_cause": "The vulnerability exists in the IOCTL dispatcher of the `appid.sys` driver, specifically in the handler for control code `0x22A018`. This handler is designed to compute a smart hash of an executable image file. It expects two kernel function pointers as callbacks in the IOCTL's input buffer, one to query file size and the other to read file data.  User-mode attackers can abuse this by providing arbitrary kernel function pointers, leading to arbitrary kernel function calls.",
    "weaknesses": [
      "The appid.sys driver exposes an IOCTL designed for kernel-mode usage to user-mode, allowing user-mode attackers to invoke it.",
      "The IOCTL handler accepts kernel function pointers from user-controlled input, which are then invoked without proper validation.",
	  "Lack of proper access control on the IOCTL, allowing local service to call it.",
	  "The vulnerable IOCTL does not check the `PreviousMode` of the caller."
    ],
    "impact": "Successful exploitation allows an attacker to achieve arbitrary kernel code execution, granting complete control over the system. This enables the attacker to perform various malicious activities, including: disrupting security software, concealing infection indicators, disabling kernel-mode telemetry, turning off mitigations, and tampering with protected processes. The attacker can also gain the ability to read and write arbitrary kernel memory.",
    "attack_vectors": "The vulnerability is exploited through a specially crafted IOCTL call to the `\Device\AppId` device object using the vulnerable control code `0x22A018`. The attacker provides arbitrary kernel function pointers and controlled data through the IOCTL input buffer.",
    "attacker_capabilities": "The attacker needs to have local service privileges on the target system. This is achieved by impersonating the local service account before making the IOCTL call. The attacker needs to craft a specific input buffer to reach the vulnerable code path, bypass checks, and execute arbitrary code by overwriting the `PreviousMode` of the current thread.  They must have the capability to send IOCTL calls to device drivers and perform memory manipulation in kernel space."
  },
  "additional_details": {
     "more_details": "The vulnerability is a local service to kernel privilege escalation and was exploited by the Lazarus group in a zero-day attack. The attack chain included using the vulnerability to create a kernel read/write primitive that enabled a data-only rootkit called FudModule.",
     "exploitation_details": "The exploit crafted the IOCTL input buffer to call a kCFG-compliant gadget, which performed a 64-bit copy from the IOCTL input buffer to an arbitrary address. This was used to overwrite the `PreviousMode` of the current thread.  By setting the corresponding source byte in the IOCTL input buffer to zero, the copy operation cleared the `PreviousMode` field, making its value effectively interpreted as `KernelMode`, enabling the attacker to read and write arbitrary kernel memory using Nt(Read|Write)VirtualMemory calls.",
     "fudmodule_details": "FudModule is a data-only rootkit, meaning it executes entirely from user space, using the kernel read/write primitive gained via the vulnerability to perform direct kernel object manipulation (DKOM). It employs multiple techniques to disrupt various security mechanisms. FudModule implements 9 rootkit techniques: registry callbacks, object callbacks, process/thread/image callbacks, minifilter drivers, Windows Filtering Platform, Event Tracing for Windows: system loggers, Event Tracing for Windows: provider GUIDs, image verification callbacks, and direct attacks on security software. Notably it was enhanced with a handle table entry manipulation technique to suspend protected processes.",
     "target_versions": "The vulnerability affects Windows versions from Win10 1703 (RS2/15063) up to the latest builds, including Win11 23H2. The Lazarus exploit specifically targets Windows versions newer than Win10 1809 (RS5/17763)."
  }
}
```