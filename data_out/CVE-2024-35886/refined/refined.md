```
{
  "vulnerability": {
    "root_cause": "The `fib6_dump_done()` function was being called recursively due to a flaw in how the netlink callback's destructor was being set and then overwritten during the dump process. Specifically, the destructor was set before memory allocation for the walker struct, and if the allocation failed, it could lead to an infinite recursion when the netlink socket was destroyed.",
    "weaknesses": [
      "Improper handling of netlink callback functions",
      "Incorrect timing of destructor assignment",
      "Potential for stack exhaustion due to infinite recursion"
    ],
    "impact": "Denial of service due to stack exhaustion. The infinite recursion caused the kernel to hit the stack guard page, resulting in a crash.",
    "attack_vectors": [
      "Sending an AF_UNSPEC RTM_GETROUTE message via a netlink socket",
      "Triggering a fault injection during memory allocation for the IPv6 routing table dump"
    ],
    "required_capabilities": "An attacker would need to be able to create a netlink socket and send specific routing messages. They also would need to have a way of triggering a fault during memory allocation to reproduce the error."
  },
  "patch": "The fix involves moving the setting of the `fib6_dump_done()` callback function to after the `kzalloc()` call. This ensures that the destructor is only set if the allocation succeeds, preventing the infinite recursion.",
    "cve": "CVE-2024-35886"
}
```