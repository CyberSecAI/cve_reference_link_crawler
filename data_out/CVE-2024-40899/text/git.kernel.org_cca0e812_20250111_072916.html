

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=99e9c5bd27ddefa0f9db88625bf5e31c1e833d62)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=99e9c5bd27ddefa0f9db88625bf5e31c1e833d62)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=99e9c5bd27ddefa0f9db88625bf5e31c1e833d62)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=99e9c5bd27ddefa0f9db88625bf5e31c1e833d62)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Baokun Li <libaokun1@huawei.com> | 2024-05-22 19:42:59 +0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-06-21 14:35:46 +0200 |
| commit | [99e9c5bd27ddefa0f9db88625bf5e31c1e833d62](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=99e9c5bd27ddefa0f9db88625bf5e31c1e833d62) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=99e9c5bd27ddefa0f9db88625bf5e31c1e833d62)) | |
| tree | [49cc53bc4416c17ad620dce57266ca1078698fcb](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=99e9c5bd27ddefa0f9db88625bf5e31c1e833d62) | |
| parent | [a0cc87f86698174aacc083c4652d2606007dd902](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a0cc87f86698174aacc083c4652d2606007dd902) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=99e9c5bd27ddefa0f9db88625bf5e31c1e833d62&id2=a0cc87f86698174aacc083c4652d2606007dd902)) | |
| download | [linux-99e9c5bd27ddefa0f9db88625bf5e31c1e833d62.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-99e9c5bd27ddefa0f9db88625bf5e31c1e833d62.tar.gz) | |

cachefiles: fix slab-use-after-free in cachefiles\_ondemand\_get\_fd()[ Upstream commit de3e26f9e5b76fc628077578c001c4a51bf54d06 ]
We got the following issue in a fuzz test of randomly issuing the restore
command:
==================================================================
BUG: KASAN: slab-use-after-free in cachefiles\_ondemand\_daemon\_read+0x609/0xab0
Write of size 4 at addr ffff888109164a80 by task ondemand-04-dae/4962
CPU: 11 PID: 4962 Comm: ondemand-04-dae Not tainted 6.8.0-rc7-dirty #542
Call Trace:
kasan\_report+0x94/0xc0
cachefiles\_ondemand\_daemon\_read+0x609/0xab0
vfs\_read+0x169/0xb50
ksys\_read+0xf5/0x1e0
Allocated by task 626:
\_\_kmalloc+0x1df/0x4b0
cachefiles\_ondemand\_send\_req+0x24d/0x690
cachefiles\_create\_tmpfile+0x249/0xb30
cachefiles\_create\_file+0x6f/0x140
cachefiles\_look\_up\_object+0x29c/0xa60
cachefiles\_lookup\_cookie+0x37d/0xca0
fscache\_cookie\_state\_machine+0x43c/0x1230
[...]
Freed by task 626:
kfree+0xf1/0x2c0
cachefiles\_ondemand\_send\_req+0x568/0x690
cachefiles\_create\_tmpfile+0x249/0xb30
cachefiles\_create\_file+0x6f/0x140
cachefiles\_look\_up\_object+0x29c/0xa60
cachefiles\_lookup\_cookie+0x37d/0xca0
fscache\_cookie\_state\_machine+0x43c/0x1230
[...]
==================================================================
Following is the process that triggers the issue:
mount | daemon\_thread1 | daemon\_thread2
------------------------------------------------------------
cachefiles\_ondemand\_init\_object
cachefiles\_ondemand\_send\_req
REQ\_A = kzalloc(sizeof(\*req) + data\_len)
wait\_for\_completion(&REQ\_A->done)
cachefiles\_daemon\_read
cachefiles\_ondemand\_daemon\_read
REQ\_A = cachefiles\_ondemand\_select\_req
cachefiles\_ondemand\_get\_fd
copy\_to\_user(\_buffer, msg, n)
process\_open\_req(REQ\_A)
------ restore ------
cachefiles\_ondemand\_restore
xas\_for\_each(&xas, req, ULONG\_MAX)
xas\_set\_mark(&xas, CACHEFILES\_REQ\_NEW);
cachefiles\_daemon\_read
cachefiles\_ondemand\_daemon\_read
REQ\_A = cachefiles\_ondemand\_select\_req
write(devfd, ("copen %u,%llu", msg->msg\_id, size));
cachefiles\_ondemand\_copen
xa\_erase(&cache->reqs, id)
complete(&REQ\_A->done)
kfree(REQ\_A)
cachefiles\_ondemand\_get\_fd(REQ\_A)
fd = get\_unused\_fd\_flags
file = anon\_inode\_getfile
fd\_install(fd, file)
load = (void \*)REQ\_A->msg.data;
load->fd = fd;
// load UAF !!!
This issue is caused by issuing a restore command when the daemon is still
alive, which results in a request being processed multiple times thus
triggering a UAF. So to avoid this problem, add an additional reference
count to cachefiles\_req, which is held while waiting and reading, and then
released when the waiting and reading is over.
Note that since there is only one reference count for waiting, we need to
avoid the same request being completed multiple times, so we can only
complete the request if it is successfully removed from the xarray.
Fixes: e73fa11a356c ("cachefiles: add restore command to recover inflight ondemand read requests")
Suggested-by: Hou Tao <houtao1@huawei.com>
Signed-off-by: Baokun Li <libaokun1@huawei.com>
Link: [https://lore.kernel.org/r/20240522114308.2402121-4-libaokun@huaweicloud.com](https://lore.kernel.org/r/20240522114308.2402121-4-libaokun%40huaweicloud.com)
Acked-by: Jeff Layton <jlayton@kernel.org>
Reviewed-by: Jia Zhu <zhujia.zj@bytedance.com>
Reviewed-by: Jingbo Xu <jefflexu@linux.alibaba.com>
Signed-off-by: Christian Brauner <brauner@kernel.org>
Stable-dep-of: 4b4391e77a6b ("cachefiles: defer exposing anon\_fd until after copy\_to\_user() succeeds")
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=99e9c5bd27ddefa0f9db88625bf5e31c1e833d62)

| -rw-r--r-- | [fs/cachefiles/internal.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/cachefiles/internal.h?id=99e9c5bd27ddefa0f9db88625bf5e31c1e833d62) | 1 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/cachefiles/ondemand.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/cachefiles/ondemand.c?id=99e9c5bd27ddefa0f9db88625bf5e31c1e833d62) | 23 | |  |  |  | | --- | --- | --- | |

2 files changed, 20 insertions, 4 deletions

| diff --git a/fs/cachefiles/internal.h b/fs/cachefiles/internal.hindex 361356d0e866a8..28799c8e2c6f66 100644--- a/[fs/cachefiles/internal.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/cachefiles/internal.h?id=a0cc87f86698174aacc083c4652d2606007dd902)+++ b/[fs/cachefiles/internal.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/cachefiles/internal.h?id=99e9c5bd27ddefa0f9db88625bf5e31c1e833d62)@@ -139,6 +139,7 @@ static inline bool cachefiles\_in\_ondemand\_mode(struct cachefiles\_cache \*cache) struct cachefiles\_req { struct cachefiles\_object \*object; struct completion done;+ refcount\_t ref; int error; struct cachefiles\_msg msg; };diff --git a/fs/cachefiles/ondemand.c b/fs/cachefiles/ondemand.cindex 6d8f7f01a73acb..f8d0a017957021 100644--- a/[fs/cachefiles/ondemand.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/cachefiles/ondemand.c?id=a0cc87f86698174aacc083c4652d2606007dd902)+++ b/[fs/cachefiles/ondemand.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/cachefiles/ondemand.c?id=99e9c5bd27ddefa0f9db88625bf5e31c1e833d62)@@ -4,6 +4,12 @@ #include <linux/uio.h> #include "internal.h" +static inline void cachefiles\_req\_put(struct cachefiles\_req \*req)+{+ if (refcount\_dec\_and\_test(&req->ref))+ kfree(req);+}+ static int cachefiles\_ondemand\_fd\_release(struct inode \*inode, struct file \*file) {@@ -362,6 +368,7 @@ ssize\_t cachefiles\_ondemand\_daemon\_read(struct cachefiles\_cache \*cache,  xas\_clear\_mark(&xas, CACHEFILES\_REQ\_NEW); cache->req\_id\_next = xas.xa\_index + 1;+ refcount\_inc(&req->ref); xa\_unlock(&cache->reqs);  id = xas.xa\_index;@@ -388,15 +395,22 @@ ssize\_t cachefiles\_ondemand\_daemon\_read(struct cachefiles\_cache \*cache, complete(&req->done); } + cachefiles\_req\_put(req); return n;  err\_put\_fd: if (msg->opcode == CACHEFILES\_OP\_OPEN) close\_fd(((struct cachefiles\_open \*)msg->data)->fd); error:- xa\_erase(&cache->reqs, id);- req->error = ret;- complete(&req->done);+ xas\_reset(&xas);+ xas\_lock(&xas);+ if (xas\_load(&xas) == req) {+ req->error = ret;+ complete(&req->done);+ xas\_store(&xas, NULL);+ }+ xas\_unlock(&xas);+ cachefiles\_req\_put(req); return ret; } @@ -427,6 +441,7 @@ static int cachefiles\_ondemand\_send\_req(struct cachefiles\_object \*object, goto out; } + refcount\_set(&req->ref, 1); req->object = object; init\_completion(&req->done); req->msg.opcode = opcode;@@ -488,7 +503,7 @@ static int cachefiles\_ondemand\_send\_req(struct cachefiles\_object \*object, wake\_up\_all(&cache->daemon\_pollwq); wait\_for\_completion(&req->done); ret = req->error;- kfree(req);+ cachefiles\_req\_put(req); return ret; out: /\* Reset the object to close state in error handling path. |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 07:27:54 +0000

