

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=def054b01a867822254e1dda13d587f5c7a99e2a)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=def054b01a867822254e1dda13d587f5c7a99e2a)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=def054b01a867822254e1dda13d587f5c7a99e2a)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=def054b01a867822254e1dda13d587f5c7a99e2a)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Lu Baolu <baolu.lu@linux.intel.com> | 2024-02-27 10:14:41 +0800 |
| --- | --- | --- |
| committer | Joerg Roedel <jroedel@suse.de> | 2024-03-01 13:51:21 +0100 |
| commit | [def054b01a867822254e1dda13d587f5c7a99e2a](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=def054b01a867822254e1dda13d587f5c7a99e2a) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=def054b01a867822254e1dda13d587f5c7a99e2a)) | |
| tree | [5d2c0eca919c6caa0e759d9dc93f79078e07d76a](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=def054b01a867822254e1dda13d587f5c7a99e2a) | |
| parent | [1a75cc710b956010137b4fe1d1fa3282bfd8f86c](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=1a75cc710b956010137b4fe1d1fa3282bfd8f86c) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=def054b01a867822254e1dda13d587f5c7a99e2a&id2=1a75cc710b956010137b4fe1d1fa3282bfd8f86c)) | |
| download | [linux-def054b01a867822254e1dda13d587f5c7a99e2a.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-def054b01a867822254e1dda13d587f5c7a99e2a.tar.gz) | |

iommu/vt-d: Use device rbtree in iopf reporting pathThe existing I/O page fault handler currently locates the PCI device by
calling pci\_get\_domain\_bus\_and\_slot(). This function searches the list
of all PCI devices until the desired device is found. To improve lookup
efficiency, replace it with device\_rbtree\_find() to search the device
within the probed device rbtree.
The I/O page fault is initiated by the device, which does not have any
synchronization mechanism with the software to ensure that the device
stays in the probed device tree. Theoretically, a device could be released
by the IOMMU subsystem after device\_rbtree\_find() and before
iopf\_get\_dev\_fault\_param(), which would cause a use-after-free problem.
Add a mutex to synchronize the I/O page fault reporting path and the IOMMU
release device path. This lock doesn't introduce any performance overhead,
as the conflict between I/O page fault reporting and device releasing is
very rare.
Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
Reviewed-by: Jason Gunthorpe <jgg@nvidia.com>
Link: [https://lore.kernel.org/r/20240220065939.121116-3-baolu.lu@linux.intel.com](https://lore.kernel.org/r/20240220065939.121116-3-baolu.lu%40linux.intel.com)
Signed-off-by: Joerg Roedel <jroedel@suse.de>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=def054b01a867822254e1dda13d587f5c7a99e2a)

| -rw-r--r-- | [drivers/iommu/intel/dmar.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/iommu/intel/dmar.c?id=def054b01a867822254e1dda13d587f5c7a99e2a) | 1 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/iommu/intel/iommu.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/iommu/intel/iommu.c?id=def054b01a867822254e1dda13d587f5c7a99e2a) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/iommu/intel/iommu.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/iommu/intel/iommu.h?id=def054b01a867822254e1dda13d587f5c7a99e2a) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/iommu/intel/svm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/iommu/intel/svm.c?id=def054b01a867822254e1dda13d587f5c7a99e2a) | 17 | |  |  |  | | --- | --- | --- | |

4 files changed, 15 insertions, 8 deletions

| diff --git a/drivers/iommu/intel/dmar.c b/drivers/iommu/intel/dmar.cindex f9b63c2875f715..d14797aabb7ad6 100644--- a/[drivers/iommu/intel/dmar.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/iommu/intel/dmar.c?id=1a75cc710b956010137b4fe1d1fa3282bfd8f86c)+++ b/[drivers/iommu/intel/dmar.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/iommu/intel/dmar.c?id=def054b01a867822254e1dda13d587f5c7a99e2a)@@ -1097,6 +1097,7 @@ static int alloc\_iommu(struct dmar\_drhd\_unit \*drhd) iommu->segment = drhd->segment; iommu->device\_rbtree = RB\_ROOT; spin\_lock\_init(&iommu->device\_rbtree\_lock);+ mutex\_init(&iommu->iopf\_lock); iommu->node = NUMA\_NO\_NODE;  ver = readl(iommu->reg + DMAR\_VER\_REG);diff --git a/drivers/iommu/intel/iommu.c b/drivers/iommu/intel/iommu.cindex 025d7385cf5813..60aa2dce32ef69 100644--- a/[drivers/iommu/intel/iommu.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/iommu/intel/iommu.c?id=1a75cc710b956010137b4fe1d1fa3282bfd8f86c)+++ b/[drivers/iommu/intel/iommu.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/iommu/intel/iommu.c?id=def054b01a867822254e1dda13d587f5c7a99e2a)@@ -4362,8 +4362,11 @@ free: static void intel\_iommu\_release\_device(struct device \*dev) { struct device\_domain\_info \*info = dev\_iommu\_priv\_get(dev);+ struct intel\_iommu \*iommu = info->iommu; + mutex\_lock(&iommu->iopf\_lock); device\_rbtree\_remove(info);+ mutex\_unlock(&iommu->iopf\_lock); dmar\_remove\_one\_dev\_info(dev); intel\_pasid\_free\_table(dev); intel\_iommu\_debugfs\_remove\_dev(info);diff --git a/drivers/iommu/intel/iommu.h b/drivers/iommu/intel/iommu.hindex 50d1e196db52ca..a0feab099f1209 100644--- a/[drivers/iommu/intel/iommu.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/iommu/intel/iommu.h?id=1a75cc710b956010137b4fe1d1fa3282bfd8f86c)+++ b/[drivers/iommu/intel/iommu.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/iommu/intel/iommu.h?id=def054b01a867822254e1dda13d587f5c7a99e2a)@@ -713,6 +713,8 @@ struct intel\_iommu { #endif struct iopf\_queue \*iopf\_queue; unsigned char iopfq\_name[16];+ /\* Synchronization between fault report and iommu device release. \*/+ struct mutex iopf\_lock; struct q\_inval \*qi; /\* Queued invalidation info \*/ u32 iommu\_state[MAX\_SR\_DMAR\_REGS]; /\* Store iommu states between suspend and resume.\*/ diff --git a/drivers/iommu/intel/svm.c b/drivers/iommu/intel/svm.cindex 1dd56d4eb88c5e..bdf3584ca0af74 100644--- a/[drivers/iommu/intel/svm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/iommu/intel/svm.c?id=1a75cc710b956010137b4fe1d1fa3282bfd8f86c)+++ b/[drivers/iommu/intel/svm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/iommu/intel/svm.c?id=def054b01a867822254e1dda13d587f5c7a99e2a)@@ -643,7 +643,7 @@ static irqreturn\_t prq\_event\_thread(int irq, void \*d) struct intel\_iommu \*iommu = d; struct page\_req\_dsc \*req; int head, tail, handled;- struct pci\_dev \*pdev;+ struct device \*dev; u64 address;  /\*@@ -689,23 +689,24 @@ bad\_req: if (unlikely(req->lpig && !req->rd\_req && !req->wr\_req)) goto prq\_advance; - pdev = pci\_get\_domain\_bus\_and\_slot(iommu->segment,- PCI\_BUS\_NUM(req->rid),- req->rid & 0xff); /\* \* If prq is to be handled outside iommu driver via receiver of \* the fault notifiers, we skip the page response here. \*/- if (!pdev)+ mutex\_lock(&iommu->iopf\_lock);+ dev = device\_rbtree\_find(iommu, req->rid);+ if (!dev) {+ mutex\_unlock(&iommu->iopf\_lock); goto bad\_req;+ } - if (intel\_svm\_prq\_report(iommu, &pdev->dev, req))+ if (intel\_svm\_prq\_report(iommu, dev, req)) handle\_bad\_prq\_event(iommu, req, QI\_RESP\_INVALID); else- trace\_prq\_report(iommu, &pdev->dev, req->qw\_0, req->qw\_1,+ trace\_prq\_report(iommu, dev, req->qw\_0, req->qw\_1, req->priv\_data[0], req->priv\_data[1], iommu->prq\_seq\_number++);- pci\_dev\_put(pdev);+ mutex\_unlock(&iommu->iopf\_lock); prq\_advance: head = (head + sizeof(\*req)) & PRQ\_RING\_MASK; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 18:12:08 +0000

