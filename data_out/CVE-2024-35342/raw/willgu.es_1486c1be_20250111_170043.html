<!DOCTYPE html>
<html>

  <head>
   <title>Anpviz / ANJVision IP Camera Vulnerabilities</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      body {
        font-family: Arial, sans-serif;
        line-height: 1.6;
        margin: 0;
        padding: 0;
	background-color: #afafaf;
      }
      h1 {
        font-size: 32px;
        margin: 16px 0;
	margin-bottom: 35px;
      }
      h2 {
        font-size: 24px;
        margin: 16px 0;
	margin-bottom: 35px;
	margin-top: 35px;
      }
      p {
        font-size: 16px;
        margin: 16px 0;
      }
      a {
        color: #2e8b57;
        text-decoration: none;
      }
      a:hover {
        text-decoration: underline;
      }
      #content {
        margin:  0 auto;
	max-width: 1000px;
        padding: 20px;
        background-color: #fff;
        border: 1px solid #ccc;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
	border-radius: 10px;
      }
      #bannerimage {
        width: 100%;
        background-image: url(/resources/banner.png);
        height: 350px;
        background-color: #2e8b57;
        background-repeat: no-repeat;
        background-position: center;
        box-shadow: 0 0 50px rgba(0, 0, 0, 0.9);
      }
      #git {
        position: absolute; top: 0; right: 0;
      }
      #git p {
	position: absolute;
	top: 45px;
	right: 0;
	font-size: 20px;
	color: black;
      }
      #git p:hover {
        text-decoration: underline;
      }
      #home {
        position: absolute; top: 0; left: 0;
      }
      #home p {
	position: absolute;
	top: 45px;
	left: 0;
	font-size: 20px;
	color: black;
      }
      #home p:hover {
        text-decoration: underline;
      }
      code {
        display: block;
        white-space: pre-wrap;
        background-color: #1d1f21;
        padding: 10px;
        border-radius: 5px;
        color: #c5c8c6;
        margin-right: 10px;
        width: calc(100% - 20px);
        margin-top: 35px;
        margin-bottom: 35px;
    }
      img {
        margin-bottom: 35px;
      }

    </style>
  </head>
  <body>
    <a href="/index.html">
    <div id="home"><img src="/resources/home.png" width=60 height=65 />
    <p><b>Home</b></p>
    </div>
    </a>
    <a href="https://github.com/gwillgues">
    <div id="git"><img src="/resources/git.png" />
    <p><b>Github</b></p>
    </div>
    </a>
    <center><h1>Willgues Security Blog</h1></center>
    <div id=content>
    <div id="bannerimage"></div>

    <h2>Anpviz IP Camera Vulnerabilities</h2>
    <p>Affected Products: Anpviz IPC-D250, IPC-D260, IPC-B850 IPC-D850, IPC-D350, IPC-D3150, IPC-D4250, IPC-D380, IPC-D880, IPC-D280, IPC-D3180, MC800N, YM500L, YM800N_N2, YMF50B, YM800SV2, YM500L8, YM200E10 and possibly more models. Firmware appears developed by ANJVision, so ANJVision cameras likely vulnerable. GWSecurity cameras appear to be a rebranded version of Anpviz, so are also likely vulnerable</p>
    <p>Affected Firmware Versions: V3.2.2.2 and lower</p>
    <p>Vulnerability Types:</p>
    <p>CWE-200: Exposure of Sensitive Information to an Unauthorized Actor</p>
    <p>CWE-306: Missing Authentication for Critical Function</p>
    <p>CWE-321: Use of Hard-coded Cryptographic Key</p>
    <p>CWE-552: Files or Directories Accessible to External Parties</p>
    <p>CWE-331: Insufficient Entropy</p>


    <p>Descriptions: </p>
    <p><b>CVE-2024-35344</b> - There is a hardcoded cryptographic key stored in the firmware of the device. Additionally, this key is insufficiently random, as it appears to have been generated by hand due to patterns such as "12 34 57 98" present in the key. This affects Anpviz IPC-D250, IPC-D260, IPC-B850 IPC-D850, IPC-D350, IPC-D3150, IPC-D4250, IPC-D380, IPC-D880, IPC-D280, IPC-D3180, MC800N, YM500L, YM800N_N2, YMF50B, YM800SV2, YM500L8, YM200E10 and possibly more models of IP camera. The key is shared across all firmware versions and devices.</p>

    <p><b>CVE-2024-35342</b> - Unauthenticated users are able to modify or disable camera related settings such as microphone volume, speaker volume, LED lighting, NTP, motion detection, and more. This affects Anpviz IPC-D250, IPC-D260, IPC-B850 IPC-D850, IPC-D350, IPC-D3150, IPC-D4250, IPC-D380, IPC-D880, IPC-D280, IPC-D3180, MC800N, YM500L, YM800N_N2, YMF50B, YM800SV2, YM500L8, YM200E10 and possibly more models of IP camera.</p>

    <p><b>CVE-2024-35341</b> - Unauthenticated users are able to download the running configuration of the device via a HTTP GET request to /ConfigFile.ini or /config.xml URIs. This configuration file contains usernames and encrypted passwords (encrypted with a hardcoded key common to all devices). This affects Anpviz IPC-D250, IPC-D260, IPC-B850 IPC-D850, IPC-D350, IPC-D3150, IPC-D4250, IPC-D380, IPC-D880, IPC-D280, IPC-D3180, MC800N, YM500L, YM800N_N2, YMF50B, YM800SV2, YM500L8, YM200E10 and possibly more models of IP camera.</p>

    <p><b>CVE-2024-35343</b> - Unauthenticated users are able to download arbitrary files from the device's filesystem via a HTTP GET request to the /playback/ URI. This affects Anpviz IPC-D250, IPC-D260, IPC-B850 IPC-D850, IPC-D350, IPC-D3150, IPC-D4250, IPC-D380, IPC-D880, IPC-D280, IPC-D3180, MC800N, YM500L, YM800N_N2, YMF50B, YM800SV2, YM500L8, YM200E10 and possibly more models of IP camera.</p>
    <br/><br/>

    <p>I recently purchased an Anpviz IPC-D250SE IP camera, and I began analyzing the device to assess its security. I decided to primarily focus on the web interface of the device.</p>
    <p>In this model of Anpviz camera, there is functionality that is not visible or accessible by an administrator, but is still present in the web_server binary. Many of these hidden functionalities require no authentication, and allow things such as configuration modification, downloading the running config of the device (with usernames and encrypted passwords), and downloading of arbitrary files on disk via HTTP. I was also able to ascertain that there is an AES encryption key hard coded into binaries on the device, which is the same for all customers and is used to encrypt passwords stored in the running config. </p>

    <p>First, I started by extracting the firmware using commonly available firmware analysis tools. This gave me access to the binaries that run on the device. In the /opt/ch directory, there are several binaries, including <b>web_server, comm_server, danale_server, hik_server, mainctrl</b>, among others. These server binaries import critical functionality from the <b>libtools.so</b> library also located in <b>/opt/ch</b>. Most of these server binaries appear to have been developed in house.</p>

    <img src="/resources/anpviz1.png" />

    <p>Using the file command, we can see these are 32 bit ARM binaries, which is expected from an embedded device.</p>

    <p>We can surmise based on the binary name that web_server is likely responsible for the HTTP functionality of the device. However, we can confirm this by analyzing the behavior of the web server (such as unique strings), and searching for those artifacts in these binaries. If we send a GET request to the device, we can see the device responds with a Server HTTP header containing â<b>gSOAP/2.8</b>â.</p>

    <img src="/resources/anpviz2.png" />

    <p>If we perform a recursive grep for âgSOAPâ in the /opt/ch directory, we can see that the binary file <b>web_server</b> matches.</p>

    <img src="/resources/anpviz3.png" />

    <p>Therefore, we have confirmed that the HTTP server functionality of the device is most likely handled by the web_server binary.</p>

    <p>We can now open the web_server binary in a disassembler like Ghidra and analyze the various code paths of the web server. The primary function that handles HTTP GET requests is named by the vendor <b>http_get_handler</b>. In the http_get_handler function, there are various other functions called which, depending on the URI in the GET request, will perform various actions. The first function that is called, I dubbed <b>secondary_cgi_handler</b>, as it handles requests to some CGI URIs, but most of the endpoints handled by this function are not accessible via the web interface by a valid administrator, most do not require authentication to access, and some do not have âCGIâ anywhere in the URI string.</p>
    
    <p>In contrast, the <b>http_cgi_handle</b> function, which is actually called after secondary_cgi_handler, handles URIs that are mostly in the format /cgi-bin/&lt;name&gt;.cgi. In addition, the endpoints managed by http_cgi_handle all require authentication, and some of the endpoints are used by the admin web interface. There are also more total URI endpoints handled by this function. It appears the http_cgi_handle endpoints utilize authentication properly. Based upon this, I consider this the primary CGI handler function, even though it is called after the âsecondary_cgi_handlerâ.</p>

    <p>It is worth noting, my naming of secondary_cgi_handler (As well as some other functions) was arbitrarily determined as there was no indication of the vendorâs original function name via disassembly for some functions in the web_server binary.</p>

    <img src="/resources/anpviz4.png" />

    <p>Before http_cgi_handle is called directly, a wrapper function is called which then calls http_cgi_handle.</p>

    <p>After the http_cgi_handle and secondary_cgi_handler functions are called, a function named copy_file is called several times, with an integer, the URI string supplied, and the MIME type to be returned to the clientâs browser as arguments.</p>

    <img src="/resources/anpviz5.png" />
    <img src="/resources/anpviz6.png" />

    <p>The functions http_cgi_handle, secondary_cgi_handler, and copy_file are where the vulnerabilities reside.</p>

    <p>If we take a look at http_cgi_handle, we can see it call various sub functions which check if the URI string supplied by the user contains a particular CGI endpoint, and if there is a match, one of the sub functions will perform the actions of the requested CGI script (these are not real CGI scripts, it is simply functionality embedded into the web_server binary itself).</p>

    <img src="/resources/anpviz7.png" />

    <p>We can see towards the end of the http_cgi_handle function, that if none of the sub functions find a match for the supplied URI string, the function prints âno such cgi interfaceâ, and returns 404.</p>

    <img src="/resources/anpviz8.png" />

    <p>Most of the functions in http_cgi_handle call a <b>cgi_is_valid_uid</b> function, which checks a username and password supplied via HTTP GET parameters, and returns a value based on the validity of the username and password supplied. This is the authentication method used to ensure only an authorized user can call these endpoints. For example, in the /cgi-bin/rtsp function:</p>

    <img src="/resources/anpviz9.png" />

    <p>The only URI which does not require a username and password in the http_cgi_handle function, is /cgi-bin/connect_check, which simply sends an ICMP ping request to a specified IP address or hostname. To call this endpoint, we can send a GET request to the cameraâs web interface with the following URL:</p>

    <i>http://&lt;IP Address&gt;/cgi-bin/connect_check?addr=8.8.8.8</i>

    <p>This is a relatively inconsequential function to have no authentication, so lets move on to the secondary_cgi_handler function and see what it provides.</p>

    <img src="/resources/anpviz10.png" />

    <p>The <b>rebootipc</b>, <b>factoryipc</b>, <b>kernVersion+fsVersion+serialNumber</b>, <b>/settings/system/device_info/device_type</b>, and <b>&setdoorbroardcast=</b> sub functions are the only functions that require authentication in the secondary_cgi_handler function.</p>

    <p>Starting with <b>getptzport</b>, we can see in the code it checks for if â/getptzportâ is in the URI string. Sending a GET request to this URI returns a port number associated with PTZ operations, which are used to move where the camera is pointing (if the camera supports it):</p>

    <img src="/resources/anpviz11.png" />

    <p>This port number corresponds to the âControl Portâ which is visible in the admin interface under âNetwork â Service Ports â Control Protocolâ:</p>

    <img src="/resources/anpviz12.png" width=95% height=auto />

    <p>Next, we can see the <b>getmacaddr_eth0.cgi</b> looks for the string â/getmacaddr_eth0.cgiâ URI string in the userâs GET request.</p>

    <img src="/resources/anpviz13.png" />

    <p>When we send the GET request to the camera, we can see it returns the eth0 MAC Address of the device:</p>

    <img src="/resources/anpviz14.png" />

    <p>If we look at the code for the /settings/audio/VolumePlay= and /settings/audio/VolumeMic= functions, it appears to allow an unauthenticated user to modify the audio playback and audio input (microphone) volume for the camera:</p>

    <img src="/resources/anpviz15.png" width=95% height=auto />

    <p>If we look at the current audio settings in the admin interface, we can see the microphone and audio output are both set to max volume:</p>

    <img src="/resources/anpviz16.png" width=95% height=auto />

    <p>If we send a GET request to the <b>/settings/audio/VolumePlay=</b> and <b>/settings/audio/VolumeMic=</b> URIs with a value between 1 and 99 appended, we can successfully change the audio output and input volumes without authentication. Note the HTTP server responds with âokâ</p>

    <img src="/resources/anpviz17.png" width=95% height=auto />

    <p>Now, if we check the admin interface, we can see the âAudio Input Volumeâ and âAudio Output Volumeâ have been set to 1. This appears to allow disabling audio without authentication, possibly giving rise to some Hollywood style attacks on the camera (if it supports audio recording/audio playback)</p>

    <img src="/resources/anpviz18.png" />

    <p>The /settings/platform/ endpoint appears to allow some sort of functionality involving a remote server. This endpoint allows an unauthenticated user to enable this functionality, setting the server, port, username, password and MAC address associated with it.</p>

    <img src="/resources/anpviz19.png" />

    <p>This setting can be enabled by sending a GET request to the server with the following URL, and the server will return âokâ if the request is made successfully</p>

    <i>http://&lt;IPAddress&gt;/settings/platform/&enable=1&server=10.1.2.3&port=1337&user=testuser&password=1337</i>

    <img src="/resources/anpviz20.png" width=95% height=auto />

    <p>It appears we can dump the same information set via the previous query (/settings/platform/) via a GET request to the URI <b>/&queryPlatformSetup</b> . It is not known what this functionality is used for, but it appears to not be used in this particular model camera, so it may be used in other models.</p>

    <img src="/resources/anpviz21.png" />

    <p>The <b>/settings/ntp/</b> URI endpoint allows unauthenticated modification of the NTP settings on the device, including disabling NTP.</p>

    <img src="/resources/anpviz22.png" />

    <p>We can set the NTP config by sending a GET request to the device with the following URI</p>

    <i>http://&lt;IPAddress&gt;/settings/ntp/&enable=1&server=notarealNTPserver.nist.gov&port=123</i>

    <img src="/resources/anpviz23.png" width=95% height=auto />

    <p>If we now check the admin interface for the date and time settings, we can see the NTP server has been changed:</p>

    <img src="/resources/anpviz24.png" />

    <p>The &wallpadmac&doormac function appears to implement some sort of MAC address setting functionality related to the previous /settings/platform/ and &queryPlatformSetup endpoints, based on the JSON format of the output and similar terms such as âpacketrevâ and âack_syncâ. It also contains a DebugPrint statement that indicates the function name is â<b>ko_door_get_request</b>â</p>

    <img src="/resources/anpviz25.png" />

    <img src="/resources/anpviz26.png" width=95% height=auto />

    <p>The /&ledlight= URI endpoint appears to allow enabling or disabling the LED light functionality of the device without authentication.</p>

    <img src="/resources/anpviz27.png" />

    <p>Note that if the character after â=â is 0 or 1, it writes this out via the io_out_write function.</p>
    <p>This can be used by sending a GET request with the following URI to the device:</p>
    <i>http://&lt;IPAddress&gt;/&ledlight=0</i>
    <p>However, I could not disable LED lighting via sending this GET request, although it does accept the request without authentication.</p>

    <img src="/resources/anpviz28.png" />

    <p>The <b>/settings/motiondetect</b> endpoint appears to allow enabling and disabling of the motion detection alarm feature of these devices.</p>

    <img src="/resources/anpviz29.png" />

    <p>If we look in the admin interface under the âEventâ section, there is a section dedicated to various motion detection settings.</p>
    
    <img src="/resources/anpviz30.png" />

    <p>If we send a GET request to the device with the following URI , it will disable the motion detection functionality without authentication.</p>
    <i>http://&lt;IPAddress&gt;/settings/motiondetect/&enable=0&blockcount=0&blockconfig=0</i>

    <img src="/resources/anpviz31.png" width=95% height=auto />

    <p>Now, if we check the admin interface for the motion detection settings, we can see it was disabled via the previously supplied curl command.</p>

    <img src="/resources/anpviz32.png"/>

    <p>The <b>/settings/getspecific</b> endpoint reveals some version/firmware information about the device, as well as some networking information.</p>

    <img src="/resources/anpviz33.png"/>

    <p>By sending a GET request to the following URI, we can retrieve this information without authentication.</p>
    <i>http://&lt;IPAddress&gt;/settings/getspecific</i>

    <img src="/resources/anpviz34.png"/>

    <p>This ability to modify various camera related settings without authentication has been assigned CVE-2024-35342</p>

    <h2>Unauthenticated Configuration File Download / Unauthenticated Arbitrary File Download : CVE-2024-35341 / CVE-2024-35343</h2>

    <p>Now that we have covered the operations available without authentication via the secondary_cgi_handler function, we can focus on copy_file and usage of the copy_file function, which is where things become more serious.</p>

    <p>Firstly, if we look at the code around where copy_file is called in the original http_get_handler function, we can see it is called in many situations, depending on the URI string. The most interesting calls are if the URI string contains â<b>/playback/</b>â, â<b>ConfigFile.ini</b>â, or â<b>config.xml</b>â.</p>


    <img src="/resources/anpviz35.png"/>

    <p>Note the â<b>helloworld</b>â MIME type returned by the server on line 242 if the URI string contains âConfigFile.iniâ. This is particularly interesting, perhaps it is a note from the developers.</p>

    <p>Now, lets take a look at the code inside the copy_file function and see what it actually does when these strings are present in the URI.</p>
    
    <img src="/resources/anpviz36.png"/>

    <p>In the top highlighted snippet, we can see that if the URI does not contain âplayback/â, but if it contains âConfigFile.iniâ or âconfig.xmlâ, it will do a call to popen, starting a subprocess that executes â<b>cp /mnt/nand/config.xml /mnt/nand/ConfigFile.ini</b>â. It then jumps to <b>LAB_0001e57c</b>, which opens the file at <b>/mnt/nand/ConfigFile.ini</b>, reads the bytes from it, then jumps to <b>LAB_0001e5b0</b>, which writes the contents of that file in response to the HTTP GET request.</p>

    <p>Based upon this code, we should be able to download the config file stored at <b>/mnt/nand/config.xml</b> without authentication, simply by being able to access the web interface of the device. We should be able to do this with any URI string that contains either â<b>config.xml</b>â or â<b>ConfigFile.ini</b>â.</p>

    <p>In the bottom highlighted snippet, we can see that if none of the previous gotos or jumps are called (no matches for ConfigFile.ini or config.xml), it will copy everything after the first <b>8</b> bytes (exactly matches â<b>playback</b>â) of the URI into <b>acStack_118</b>, and open and read a fileâs bytes, with the file name based on the contents of <b>acStack_118</b>. It will then jump to <b>LAB_0001e5b0</b>, which as previously noted, writes the output of that file in response to the HTTP GET request. Based upon this code, Upon specifying a URI containing "<b>/playback</b>" followed by additional characters, <b>those subsequent characters will be treated as a complete filepath and subsequently utilized by fopen() function. The resulting resource obtained via fopen() will then be transmitted as the response payload for an incoming HTTP GET request.</b> </p>

    <p>This means we can arbitrarily read any file on the filesystem that is readable by the user the web_server binary is running under the context of.</p>

    <p>First, lets test the downloading of the /mnt/nand/config.xml file, by using both â<b>config.xml</b>â and â<b>ConfigFile.ini</b>â in our GET request.</p>

    <p>First, <i>http://&lt;IPAddress&gt;/config.xml</i>:
    
    <img src="/resources/anpviz37.png"/>

    <p>As we can see, an XML config file is returned.</p>

    <p>Now lets try <i>http://&lt;IPAddress&gt;/ConfigFile.ini</i> :</p>

    <img src="/resources/anpviz38.png"/>

    <p>Now if we save and analyze the contents of these XML files, we can determine that these appear to be the running config of the device. This includes encrypted passwords.</p>

    <img src="/resources/anpviz39.png"/>

    <p>Now, lets test the /playback/ URI and attempt to download arbitrary files from the filesystem. Based on firmware analysis, we know the actual password for these devices is stored at <b>/etc/passwd_sys</b>.</p>

    <p>So lets try <i>http://&lt;IPAddress&gt;/playback/etc/passwd_sys</i></p>

    <img src="/resources/anpviz40.png"/>

    <p>As we can see, we have successfully extracted an arbitrary file from the filesystem. Using this, we can even dump /dev/mtd volumes and dump the entire root filesystem image, as well as many other things.</p>

    <p>You might be wondering how the password encryption is implemented in the config file that is able to be extracted. Based on the string â<b>EncryptPwd</b>â being in the config file, we can search for this string and see where it is utilized, in order to look for the encryption function.</p>

    <p>If we grep for â<b>EncryptPwd</b>â in the /opt/ch directory, we can see the binary file <b>libtools.so</b> matches.</p>

    <img src="/resources/anpviz41.png"/>

    <h2>Use of Hardcoded Weak Cryptographic Key: CVE-2024-35344</h2>

    <p>Lets open up the libtools.so in Ghidra and analyze which function uses that particular string.</p>

    <p>Here is a function which uses the â<b>EncryptPwd=%s</b>â string in a call to snprintf(), and the text that is placed into â%sâ is a var local_450, which shortly before is passed to a function called <b>StringEncrypt()</b></p>

    <img src="/resources/anpviz42.png"/>

    <p>Based on this contextual information, we can surmise that the StringEncrypt function is the function responsible for encrypting passwords stored in /mnt/nand/config.xml.</p>

    <p>We can assume the input string is auStack_410 (param_1), the output is local_450 (param_2), and a length (64, param_3) is supplied as the third argument.</p>
    
    <img src="/resources/anpviz43.png"/>

    <p>In the <b>StringEncrypt()</b> function, we can see local_224 is initialized with the first 16 characters of the input string (line 35). These first 16 characters are passed as the input to a <b>crypto_aes_expand_key()</b> function, which has 3 arguments; an output variable (auStack_1fc), an encryption key (memory location <b>DAT_000b3adc</b>), and a key size (32 bytes, or 256 bits).</p>

    <p>The expanded key is then passed to <b>aes_encrypt_()</b>, which takes the expanded key, an output variable, and the string to be encrypted (first 16 characters of the input string).</p>
    <p>After encryption, the encrypted data is passed to a <b>hexdataToHexStr()</b> function, which hex encodes the encrypted string.</p>

    <p>Lets take a look at the data stored at DAT_000b3adc, and see if there is a discernible encryption key.</p>

    <img src="/resources/anpviz44.png"/>

    <p>We can see the data stored at DAT_000b3adc appears to contain 32 bytes of data, with each byte separated by a null byte (00). This is because it is stored as an array of uint_32t, and on most CPUs, the size of a uint32_t variable is 4 bytes, so padding bytes are inserted by the compiler.</p>

    <p>We can extract the full 32 byte (or 256 bit) encryption key by removing the padding bytes, so the full encryption key (in hex bytes) is as follows:</p>

    <p><code>19 42 50 15 53 88 ab cd 88 77 66 55 44 33 de ef 12 34 57 98 0a ba cd fe dd cc 99 55 66 88 3f fe</code></p>

    <p>Based on the pattern âab cd 88 77 66 55 44 33 de ef 12 34 57 98â included in the key, it appears this key was not randomly generated, but typed by hand. The fact that this key is embedded directly within every libtools.so binary on all devices implies that attackers could potentially extract and utilize this key to decrypt the saved passwords present in the running config of any device, given they manage to obtain access to the binary.</p>

    <p>Combined with the previous unauthenticated config file download vulnerability, an attacker could gain administrative access to every device that contains these issues.</p>
    
    <p>I was able to analyze multiple different firmware images from different camera models, as well as extracting the libtools.so binary from a live device, and was able to confirm the same key is hardcoded across all devices.</p>

    <h2>Enabling of Debug Server / Telnet Server</h2>

    <p>In the secondary_cgi_handler() function, the first sub function that is called is /openslog(), 	which appears to allow enabling of some sort of syslog functionality. However, there is an authenticated component of this function that searches for the URI string â<b>/cgi-bin/console.cgi?</b>â. If this URI string is present, along with a valid username, password, and âenableâ value supplied via the GET request, a user can enable whats known as the âdebug serverâ, which is a separate binary located at /opt/ch/dbg_server. When this debug server is running, it listens on port 9999, and can be accessed via netcat.</p>

    <p>First, lets check to see if port 9999 is listening on the device via netcat:</p>

    <img src="/resources/anpviz45.png"/>

    <p>As shown, the connection was refused on that port.</p>

    <p>Now, if we send the following GET request (note these are the default credentials, but this is an authenticated CGI endpoint), we can enable the debug server on port 9999:</p>

    <p><i>http://&lt;IPAddress&gt;/cgi-bin/console.cgi?enable=1&username=admin&password=123456</i></p>

    <img src="/resources/anpviz46.png" width=95% height=auto/>

    <p>Now, if we run a netcat command to connect to that port, we can interact with the debug server. There are many different functions available in the debug server, lets first try running âhelpâ to see what commands are available.</p>

    <img src="/resources/anpviz47.png"/>

    <p>If we type in â<b>telnet</b>â into the debug server, it accepts the command and indicates a return code of 0x00000000 (0), which typically indicates success.</p>

    <img src="/resources/anpviz48.png"/>

    <p>Now, we can try to telnet to the device.</p>

    <img src="/resources/anpviz49.png"/>

    <p>The credentials used for the admin interface are not accepted, so the credentials used here are presumably for root, and whatever the MD5 hash corresponds to that is available from /etc/passwd_sys. Based on open source research of the hash <b>$1$yFuJ6yns$33Bk0I91Ji0QMujkR/DPi1</b> , this hash is used in multiple devices. </p>

    <h2>Conclusion</h2>

    <p>Based on these findings, an unauthenticated attacker who has unrestricted network access to a device could download the running configuration of the device, use the knowledge of the hardcoded key and AES implementation to decrypt the admin password, which would then allow enabling of the debug server and telnet. Then, the attacker could use the unauthenticated arbitrary file download vulnerability to retrieve the root password hash, crack the hash, and then log into the device as root via telnet, allowing full compromise of the affected devices.</p>

    <p> I attempted to report this vulnerability to Anpviz, ANJVision, and GWSecurity. After multiple attempts to reach out, I only received a response from one ANJVision employee, who simply asked if I reverse engineered the firmware. I requested a timeline for when a patch would be available to end users on numerous occasions, and that I wished to coordinate responsible disclosure when a patch was available. I continued to receive no response</p>

    <p> February 19 - Initial email to Anpviz, ANJVision, and GWSecurity with vulnerability details</p>

    <p> February 20 - Follow up email to Anpviz, ANJVision, and GWSecurity, asking for confirmation that they had received the report</p>

    <p> Feburary 21 - Second follow up email to Anpviz, ANJVision, and GWSecurity, asking for confirmation that they had received the report, and that I planned on coordinating with US-CERT if I was unable to make contact</p>

    <p> February 21 - Received email from ANJVision employee, asking if I decompiled the firmware. The individual also asked me to provide a firmware image, because some of the issues may have been fixed in a new version. I provded answers to the questions, and provided the links to firmware images.</p>

    <p> March 24 - Followed up again and requested a timeline for patched firmware, and that I planned to disclose the issues after new firmware was available</p>

    <p> March 26 - Followed up again and requested a timeline for patched firmware, and that I planned to disclose the issues after new firmware was available</p>

    <p> April 4 - Followed up again and requested a timeline for patched firmware, and that I planned to disclose the issues after new firmware was available</p>

    <p> April 22 - Opened report with US-CERT about vulnerability </p>

    <p> May 4 - Disclosed </p>


    </div>
  </body>
</html>

