=== Content from git.kernel.org_d5db9327_20250111_065120.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=64a7ce76fb901bf9f9c36cf5d681328fc0fd4b5a)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=64a7ce76fb901bf9f9c36cf5d681328fc0fd4b5a)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=64a7ce76fb901bf9f9c36cf5d681328fc0fd4b5a)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=64a7ce76fb901bf9f9c36cf5d681328fc0fd4b5a)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | yangerkun <yangerkun@huawei.com> | 2024-07-31 12:38:35 +0800 |
| --- | --- | --- |
| committer | Christian Brauner <brauner@kernel.org> | 2024-08-12 22:03:26 +0200 |
| commit | [64a7ce76fb901bf9f9c36cf5d681328fc0fd4b5a](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=64a7ce76fb901bf9f9c36cf5d681328fc0fd4b5a) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=64a7ce76fb901bf9f9c36cf5d681328fc0fd4b5a)) | |
| tree | [927a5c290181b2ad04d17d951fba09096256eebe](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=64a7ce76fb901bf9f9c36cf5d681328fc0fd4b5a) | |
| parent | [42b0f8da3acc87953161baeb24f756936eb4d4b2](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=42b0f8da3acc87953161baeb24f756936eb4d4b2) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=64a7ce76fb901bf9f9c36cf5d681328fc0fd4b5a&id2=42b0f8da3acc87953161baeb24f756936eb4d4b2)) | |
| download | [linux-64a7ce76fb901bf9f9c36cf5d681328fc0fd4b5a.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-64a7ce76fb901bf9f9c36cf5d681328fc0fd4b5a.tar.gz) | |

libfs: fix infinite directory reads for offset dirAfter we switch tmpfs dir operations from simple\_dir\_operations to
simple\_offset\_dir\_operations, every rename happened will fill new dentry
to dest dir's maple tree(&SHMEM\_I(inode)->dir\_offsets->mt) with a free
key starting with octx->newx\_offset, and then set newx\_offset equals to
free key + 1. This will lead to infinite readdir combine with rename
happened at the same time, which fail generic/736 in xfstests(detail show
as below).
1. create 5000 files(1 2 3...) under one dir
2. call readdir(man 3 readdir) once, and get one entry
3. rename(entry, "TEMPFILE"), then rename("TEMPFILE", entry)
4. loop 2~3, until readdir return nothing or we loop too many
times(tmpfs break test with the second condition)
We choose the same logic what commit 9b378f6ad48cf ("btrfs: fix infinite
directory reads") to fix it, record the last\_index when we open dir, and
do not emit the entry which index >= last\_index. The file->private\_data
now used in offset dir can use directly to do this, and we also update
the last\_index when we llseek the dir file.
Fixes: a2e459555c5f ("shmem: stable directory offsets")
Signed-off-by: yangerkun <yangerkun@huawei.com>
Link: [https://lore.kernel.org/r/20240731043835.1828697-1-yangerkun@huawei.com](https://lore.kernel.org/r/20240731043835.1828697-1-yangerkun%40huawei.com)
Reviewed-by: Chuck Lever <chuck.lever@oracle.com>
[brauner: only update last\_index after seek when offset is zero like Jan suggested]
Signed-off-by: Christian Brauner <brauner@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=64a7ce76fb901bf9f9c36cf5d681328fc0fd4b5a)

| -rw-r--r-- | [fs/libfs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/libfs.c?id=64a7ce76fb901bf9f9c36cf5d681328fc0fd4b5a) | 35 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 24 insertions, 11 deletions

| diff --git a/fs/libfs.c b/fs/libfs.cindex 8aa34870449fe1..02602d00939e96 100644--- a/[fs/libfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/libfs.c?id=42b0f8da3acc87953161baeb24f756936eb4d4b2)+++ b/[fs/libfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/libfs.c?id=64a7ce76fb901bf9f9c36cf5d681328fc0fd4b5a)@@ -450,6 +450,14 @@ void simple\_offset\_destroy(struct offset\_ctx \*octx) mtree\_destroy(&octx->mt); } +static int offset\_dir\_open(struct inode \*inode, struct file \*file)+{+ struct offset\_ctx \*ctx = inode->i\_op->get\_offset\_ctx(inode);++ file->private\_data = (void \*)ctx->next\_offset;+ return 0;+}+ /\*\* \* offset\_dir\_llseek - Advance the read position of a directory descriptor \* @file: an open directory whose position is to be updated@@ -463,6 +471,9 @@ void simple\_offset\_destroy(struct offset\_ctx \*octx) \*/ static loff\_t offset\_dir\_llseek(struct file \*file, loff\_t offset, int whence) {+ struct inode \*inode = file->f\_inode;+ struct offset\_ctx \*ctx = inode->i\_op->get\_offset\_ctx(inode);+ switch (whence) { case SEEK\_CUR: offset += file->f\_pos;@@ -476,7 +487,8 @@ static loff\_t offset\_dir\_llseek(struct file \*file, loff\_t offset, int whence) }  /\* In this case, ->private\_data is protected by f\_pos\_lock \*/- file->private\_data = NULL;+ if (!offset)+ file->private\_data = (void \*)ctx->next\_offset; return vfs\_setpos(file, offset, LONG\_MAX); } @@ -507,7 +519,7 @@ static bool offset\_dir\_emit(struct dir\_context \*ctx, struct dentry \*dentry) inode->i\_ino, fs\_umode\_to\_dtype(inode->i\_mode)); } -static void \*offset\_iterate\_dir(struct inode \*inode, struct dir\_context \*ctx)+static void offset\_iterate\_dir(struct inode \*inode, struct dir\_context \*ctx, long last\_index) { struct offset\_ctx \*octx = inode->i\_op->get\_offset\_ctx(inode); struct dentry \*dentry;@@ -515,17 +527,21 @@ static void \*offset\_iterate\_dir(struct inode \*inode, struct dir\_context \*ctx) while (true) { dentry = offset\_find\_next(octx, ctx->pos); if (!dentry)- return ERR\_PTR(-ENOENT);+ return;++ if (dentry2offset(dentry) >= last\_index) {+ dput(dentry);+ return;+ }  if (!offset\_dir\_emit(ctx, dentry)) { dput(dentry);- break;+ return; }  ctx->pos = dentry2offset(dentry) + 1; dput(dentry); }- return NULL; }  /\*\*@@ -552,22 +568,19 @@ static void \*offset\_iterate\_dir(struct inode \*inode, struct dir\_context \*ctx) static int offset\_readdir(struct file \*file, struct dir\_context \*ctx) { struct dentry \*dir = file->f\_path.dentry;+ long last\_index = (long)file->private\_data;  lockdep\_assert\_held(&d\_inode(dir)->i\_rwsem);  if (!dir\_emit\_dots(file, ctx)) return 0; - /\* In this case, ->private\_data is protected by f\_pos\_lock \*/- if (ctx->pos == DIR\_OFFSET\_MIN)- file->private\_data = NULL;- else if (file->private\_data == ERR\_PTR(-ENOENT))- return 0;- file->private\_data = offset\_iterate\_dir(d\_inode(dir), ctx);+ offset\_iterate\_dir(d\_inode(dir), ctx, last\_index); return 0; }  const struct file\_operations simple\_offset\_dir\_operations = {+ .open = offset\_dir\_open, .llseek = offset\_dir\_llseek, .iterate\_shared = offset\_readdir, .read = generic\_read\_dir, |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 06:49:57 +0000



=== Content from git.kernel.org_193cb65f_20250111_065119.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=308b4fc2403b335894592ee9dc212a5e58bb309f)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=308b4fc2403b335894592ee9dc212a5e58bb309f)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=308b4fc2403b335894592ee9dc212a5e58bb309f)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=308b4fc2403b335894592ee9dc212a5e58bb309f)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | yangerkun <yangerkun@huawei.com> | 2024-07-31 12:38:35 +0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-08-29 17:35:45 +0200 |
| commit | [308b4fc2403b335894592ee9dc212a5e58bb309f](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=308b4fc2403b335894592ee9dc212a5e58bb309f) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=308b4fc2403b335894592ee9dc212a5e58bb309f)) | |
| tree | [f6ce4099cc96a0b724cab5dfaead79225d565530](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=308b4fc2403b335894592ee9dc212a5e58bb309f) | |
| parent | [b87479dee8702c6bdab7bcdb0d9c3c72ea69e9d3](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b87479dee8702c6bdab7bcdb0d9c3c72ea69e9d3) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=308b4fc2403b335894592ee9dc212a5e58bb309f&id2=b87479dee8702c6bdab7bcdb0d9c3c72ea69e9d3)) | |
| download | [linux-308b4fc2403b335894592ee9dc212a5e58bb309f.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-308b4fc2403b335894592ee9dc212a5e58bb309f.tar.gz) | |

libfs: fix infinite directory reads for offset dir[ Upstream commit 64a7ce76fb901bf9f9c36cf5d681328fc0fd4b5a ]
After we switch tmpfs dir operations from simple\_dir\_operations to
simple\_offset\_dir\_operations, every rename happened will fill new dentry
to dest dir's maple tree(&SHMEM\_I(inode)->dir\_offsets->mt) with a free
key starting with octx->newx\_offset, and then set newx\_offset equals to
free key + 1. This will lead to infinite readdir combine with rename
happened at the same time, which fail generic/736 in xfstests(detail show
as below).
1. create 5000 files(1 2 3...) under one dir
2. call readdir(man 3 readdir) once, and get one entry
3. rename(entry, "TEMPFILE"), then rename("TEMPFILE", entry)
4. loop 2~3, until readdir return nothing or we loop too many
times(tmpfs break test with the second condition)
We choose the same logic what commit 9b378f6ad48cf ("btrfs: fix infinite
directory reads") to fix it, record the last\_index when we open dir, and
do not emit the entry which index >= last\_index. The file->private\_data
now used in offset dir can use directly to do this, and we also update
the last\_index when we llseek the dir file.
Fixes: a2e459555c5f ("shmem: stable directory offsets")
Signed-off-by: yangerkun <yangerkun@huawei.com>
Link: [https://lore.kernel.org/r/20240731043835.1828697-1-yangerkun@huawei.com](https://lore.kernel.org/r/20240731043835.1828697-1-yangerkun%40huawei.com)
Reviewed-by: Chuck Lever <chuck.lever@oracle.com>
[brauner: only update last\_index after seek when offset is zero like Jan suggested]
Signed-off-by: Christian Brauner <brauner@kernel.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=308b4fc2403b335894592ee9dc212a5e58bb309f)

| -rw-r--r-- | [fs/libfs.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/libfs.c?id=308b4fc2403b335894592ee9dc212a5e58bb309f) | 35 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 24 insertions, 11 deletions

| diff --git a/fs/libfs.c b/fs/libfs.cindex b635ee5adbcced..65279e53fbf27c 100644--- a/[fs/libfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/libfs.c?id=b87479dee8702c6bdab7bcdb0d9c3c72ea69e9d3)+++ b/[fs/libfs.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/libfs.c?id=308b4fc2403b335894592ee9dc212a5e58bb309f)@@ -450,6 +450,14 @@ void simple\_offset\_destroy(struct offset\_ctx \*octx) mtree\_destroy(&octx->mt); } +static int offset\_dir\_open(struct inode \*inode, struct file \*file)+{+ struct offset\_ctx \*ctx = inode->i\_op->get\_offset\_ctx(inode);++ file->private\_data = (void \*)ctx->next\_offset;+ return 0;+}+ /\*\* \* offset\_dir\_llseek - Advance the read position of a directory descriptor \* @file: an open directory whose position is to be updated@@ -463,6 +471,9 @@ void simple\_offset\_destroy(struct offset\_ctx \*octx) \*/ static loff\_t offset\_dir\_llseek(struct file \*file, loff\_t offset, int whence) {+ struct inode \*inode = file->f\_inode;+ struct offset\_ctx \*ctx = inode->i\_op->get\_offset\_ctx(inode);+ switch (whence) { case SEEK\_CUR: offset += file->f\_pos;@@ -476,7 +487,8 @@ static loff\_t offset\_dir\_llseek(struct file \*file, loff\_t offset, int whence) }  /\* In this case, ->private\_data is protected by f\_pos\_lock \*/- file->private\_data = NULL;+ if (!offset)+ file->private\_data = (void \*)ctx->next\_offset; return vfs\_setpos(file, offset, LONG\_MAX); } @@ -507,7 +519,7 @@ static bool offset\_dir\_emit(struct dir\_context \*ctx, struct dentry \*dentry) inode->i\_ino, fs\_umode\_to\_dtype(inode->i\_mode)); } -static void \*offset\_iterate\_dir(struct inode \*inode, struct dir\_context \*ctx)+static void offset\_iterate\_dir(struct inode \*inode, struct dir\_context \*ctx, long last\_index) { struct offset\_ctx \*octx = inode->i\_op->get\_offset\_ctx(inode); struct dentry \*dentry;@@ -515,17 +527,21 @@ static void \*offset\_iterate\_dir(struct inode \*inode, struct dir\_context \*ctx) while (true) { dentry = offset\_find\_next(octx, ctx->pos); if (!dentry)- return ERR\_PTR(-ENOENT);+ return;++ if (dentry2offset(dentry) >= last\_index) {+ dput(dentry);+ return;+ }  if (!offset\_dir\_emit(ctx, dentry)) { dput(dentry);- break;+ return; }  ctx->pos = dentry2offset(dentry) + 1; dput(dentry); }- return NULL; }  /\*\*@@ -552,22 +568,19 @@ static void \*offset\_iterate\_dir(struct inode \*inode, struct dir\_context \*ctx) static int offset\_readdir(struct file \*file, struct dir\_context \*ctx) { struct dentry \*dir = file->f\_path.dentry;+ long last\_index = (long)file->private\_data;  lockdep\_assert\_held(&d\_inode(dir)->i\_rwsem);  if (!dir\_emit\_dots(file, ctx)) return 0; - /\* In this case, ->private\_data is protected by f\_pos\_lock \*/- if (ctx->pos == DIR\_OFFSET\_MIN)- file->private\_data = NULL;- else if (file->private\_data == ERR\_PTR(-ENOENT))- return 0;- file->private\_data = offset\_iterate\_dir(d\_inode(dir), ctx);+ offset\_iterate\_dir(d\_inode(dir), ctx, last\_index); return 0; }  const struct file\_operations simple\_offset\_dir\_operations = {+ .open = offset\_dir\_open, .llseek = offset\_dir\_llseek, .iterate\_shared = offset\_readdir, .read = generic\_read\_dir, |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 06:49:57 +0000


