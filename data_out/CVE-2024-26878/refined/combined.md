=== Content from lists.debian.org_2d5de243_20250111_032950.html ===


---

[[Date Prev](msg00016.html)][[Date Next](msg00018.html)]
[[Thread Prev](msg00016.html)][[Thread Next](msg00018.html)]
[[Date Index](maillist.html#00017)]
[[Thread Index](threads.html#00017)]

# [SECURITY] [DLA 3842-1] linux-5.10 security update

---

* *To*: debian-lts-announce@lists.debian.org
* *Subject*: [SECURITY] [DLA 3842-1] linux-5.10 security update
* *From*: Ben Hutchings <benh@debian.org>
* *Date*: Tue, 25 Jun 2024 21:41:47 +0200
* *Message-id*: <[[ðŸ”Ž]](/msgid-search/Znsdeycap_uaG_xM%40decadent.org.uk)Â [Znsdeycap\_uaG\_xM@decadent.org.uk](msg00017.html)>
* *Mail-followup-to*: debian-lts@lists.debian.org
* *Reply-to*: debian-lts@lists.debian.org

---

```
-------------------------------------------------------------------------
Debian LTS Advisory DLA-3842-1                debian-lts@lists.debian.org
<https://www.debian.org/lts/security/>                        Ben Hutchings
June 25, 2024                                 <https://wiki.debian.org/LTS>
-------------------------------------------------------------------------

Package        : linux-5.10
Version        : 5.10.216-1~deb10u1
CVE ID         : CVE-2022-38096 CVE-2023-6270 CVE-2023-7042 CVE-2023-28746
                 CVE-2023-47233 CVE-2023-52429 CVE-2023-52434 CVE-2023-52435
                 CVE-2023-52447 CVE-2023-52458 CVE-2023-52482 CVE-2023-52486
                 CVE-2023-52488 CVE-2023-52489 CVE-2023-52491 CVE-2023-52492
                 CVE-2023-52493 CVE-2023-52497 CVE-2023-52498 CVE-2023-52583
                 CVE-2023-52587 CVE-2023-52594 CVE-2023-52595 CVE-2023-52597
                 CVE-2023-52598 CVE-2023-52599 CVE-2023-52600 CVE-2023-52601
                 CVE-2023-52602 CVE-2023-52603 CVE-2023-52604 CVE-2023-52606
                 CVE-2023-52607 CVE-2023-52614 CVE-2023-52615 CVE-2023-52616
                 CVE-2023-52617 CVE-2023-52618 CVE-2023-52619 CVE-2023-52620
                 CVE-2023-52622 CVE-2023-52623 CVE-2023-52627 CVE-2023-52635
                 CVE-2023-52637 CVE-2023-52642 CVE-2023-52644 CVE-2023-52650
                 CVE-2023-52656 CVE-2023-52669 CVE-2023-52670 CVE-2023-52672
                 CVE-2023-52699 CVE-2023-52880 CVE-2024-0340 CVE-2024-0565
                 CVE-2024-0607 CVE-2024-0841 CVE-2024-1151 CVE-2024-22099
                 CVE-2024-23849 CVE-2024-23850 CVE-2024-23851 CVE-2024-24857
                 CVE-2024-24858 CVE-2024-24861 CVE-2024-25739 CVE-2024-26581
                 CVE-2024-26593 CVE-2024-26600 CVE-2024-26601 CVE-2024-26602
                 CVE-2024-26606 CVE-2024-26610 CVE-2024-26614 CVE-2024-26615
                 CVE-2024-26622 CVE-2024-26625 CVE-2024-26627 CVE-2024-26635
                 CVE-2024-26636 CVE-2024-26640 CVE-2024-26641 CVE-2024-26642
                 CVE-2024-26643 CVE-2024-26644 CVE-2024-26645 CVE-2024-26651
                 CVE-2024-26654 CVE-2024-26659 CVE-2024-26663 CVE-2024-26664
                 CVE-2024-26665 CVE-2024-26671 CVE-2024-26673 CVE-2024-26675
                 CVE-2024-26679 CVE-2024-26684 CVE-2024-26685 CVE-2024-26687
                 CVE-2024-26688 CVE-2024-26689 CVE-2024-26695 CVE-2024-26696
                 CVE-2024-26697 CVE-2024-26698 CVE-2024-26702 CVE-2024-26704
                 CVE-2024-26707 CVE-2024-26712 CVE-2024-26720 CVE-2024-26722
                 CVE-2024-26727 CVE-2024-26733 CVE-2024-26735 CVE-2024-26736
                 CVE-2024-26743 CVE-2024-26744 CVE-2024-26747 CVE-2024-26748
                 CVE-2024-26749 CVE-2024-26751 CVE-2024-26752 CVE-2024-26753
                 CVE-2024-26754 CVE-2024-26763 CVE-2024-26764 CVE-2024-26766
                 CVE-2024-26771 CVE-2024-26772 CVE-2024-26773 CVE-2024-26776
                 CVE-2024-26777 CVE-2024-26778 CVE-2024-26779 CVE-2024-26781
                 CVE-2024-26782 CVE-2024-26787 CVE-2024-26788 CVE-2024-26790
                 CVE-2024-26791 CVE-2024-26793 CVE-2024-26795 CVE-2024-26801
                 CVE-2024-26804 CVE-2024-26805 CVE-2024-26808 CVE-2024-26809
                 CVE-2024-26810 CVE-2024-26812 CVE-2024-26813 CVE-2024-26814
                 CVE-2024-26816 CVE-2024-26817 CVE-2024-26820 CVE-2024-26825
                 CVE-2024-26833 CVE-2024-26835 CVE-2024-26839 CVE-2024-26840
                 CVE-2024-26843 CVE-2024-26845 CVE-2024-26846 CVE-2024-26848
                 CVE-2024-26851 CVE-2024-26852 CVE-2024-26855 CVE-2024-26857
                 CVE-2024-26859 CVE-2024-26861 CVE-2024-26862 CVE-2024-26863
                 CVE-2024-26870 CVE-2024-26872 CVE-2024-26874 CVE-2024-26875
                 CVE-2024-26877 CVE-2024-26878 CVE-2024-26880 CVE-2024-26882
                 CVE-2024-26883 CVE-2024-26884 CVE-2024-26885 CVE-2024-26889
                 CVE-2024-26891 CVE-2024-26894 CVE-2024-26895 CVE-2024-26897
                 CVE-2024-26898 CVE-2024-26901 CVE-2024-26903 CVE-2024-26906
                 CVE-2024-26907 CVE-2024-26910 CVE-2024-26917 CVE-2024-26922
                 CVE-2024-26923 CVE-2024-26924 CVE-2024-26925 CVE-2024-26926
                 CVE-2024-26931 CVE-2024-26934 CVE-2024-26935 CVE-2024-26937
                 CVE-2024-26950 CVE-2024-26951 CVE-2024-26955 CVE-2024-26956
                 CVE-2024-26957 CVE-2024-26958 CVE-2024-26960 CVE-2024-26961
                 CVE-2024-26965 CVE-2024-26966 CVE-2024-26969 CVE-2024-26970
                 CVE-2024-26973 CVE-2024-26974 CVE-2024-26976 CVE-2024-26978
                 CVE-2024-26981 CVE-2024-26984 CVE-2024-26988 CVE-2024-26993
                 CVE-2024-26994 CVE-2024-26997 CVE-2024-26999 CVE-2024-27000
                 CVE-2024-27001 CVE-2024-27004 CVE-2024-27008 CVE-2024-27013
                 CVE-2024-27020 CVE-2024-27024 CVE-2024-27025 CVE-2024-27028
                 CVE-2024-27030 CVE-2024-27038 CVE-2024-27043 CVE-2024-27044
                 CVE-2024-27045 CVE-2024-27046 CVE-2024-27047 CVE-2024-27051
                 CVE-2024-27052 CVE-2024-27053 CVE-2024-27059 CVE-2024-27065
                 CVE-2024-27073 CVE-2024-27074 CVE-2024-27075 CVE-2024-27076
                 CVE-2024-27077 CVE-2024-27078 CVE-2024-27388 CVE-2024-27395
                 CVE-2024-27396 CVE-2024-27405 CVE-2024-27410 CVE-2024-27412
                 CVE-2024-27413 CVE-2024-27414 CVE-2024-27416 CVE-2024-27417
                 CVE-2024-27419 CVE-2024-27431 CVE-2024-27436 CVE-2024-27437
                 CVE-2024-35785 CVE-2024-35789 CVE-2024-35791 CVE-2024-35796
                 CVE-2024-35805 CVE-2024-35806 CVE-2024-35807 CVE-2024-35809
                 CVE-2024-35811 CVE-2024-35813 CVE-2024-35815 CVE-2024-35819
                 CVE-2024-35821 CVE-2024-35822 CVE-2024-35823 CVE-2024-35825
                 CVE-2024-35828 CVE-2024-35829 CVE-2024-35830 CVE-2024-35833
                 CVE-2024-35835 CVE-2024-35837 CVE-2024-35845 CVE-2024-35847
                 CVE-2024-35849 CVE-2024-35852 CVE-2024-35853 CVE-2024-35854
                 CVE-2024-35855 CVE-2024-35871 CVE-2024-35877 CVE-2024-35879
                 CVE-2024-35884 CVE-2024-35886 CVE-2024-35888 CVE-2024-35893
                 CVE-2024-35895 CVE-2024-35896 CVE-2024-35897 CVE-2024-35898
                 CVE-2024-35899 CVE-2024-35900 CVE-2024-35902 CVE-2024-35905
                 CVE-2024-35910 CVE-2024-35915 CVE-2024-35922 CVE-2024-35925
                 CVE-2024-35930 CVE-2024-35933 CVE-2024-35934 CVE-2024-35935
                 CVE-2024-35936 CVE-2024-35940 CVE-2024-35944 CVE-2024-35950
                 CVE-2024-35955 CVE-2024-35958 CVE-2024-35960 CVE-2024-35962
                 CVE-2024-35967 CVE-2024-35969 CVE-2024-35973 CVE-2024-35976
                 CVE-2024-35978 CVE-2024-35982 CVE-2024-35983 CVE-2024-35984
                 CVE-2024-35988 CVE-2024-35990 CVE-2024-35996 CVE-2024-35997
                 CVE-2024-36004 CVE-2024-36005 CVE-2024-36006 CVE-2024-36007
                 CVE-2024-36008 CVE-2024-36020
Debian Bug     : 1064035

Several vulnerabilities were discovered in the Linux kernel that may
lead to a privilege escalation, denial of service or information
leaks.

For Debian 10 buster, these problems were fixed earlier in version
5.10.216-1~deb10u1.  This update also fixed a regression in kernel
documentation generation, and included many more bug fixes from stable
updates 5.10.210-5.10.216 inclusive.

For the detailed security status of linux-5.10 please refer to
its security tracker page at:
<https://security-tracker.debian.org/tracker/linux-5.10>

Further information about Debian LTS security advisories, how to apply
these updates to your system and frequently asked questions can be
found at: <https://wiki.debian.org/LTS>

```

**Attachment:
[signature.asc](pgpvh8SL4z3oF.pgp)**

*Description:* PGP signature

---



=== Content from git.kernel.org_45e94582_20250111_032950.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=f2649d98aa9ca8623149b3cb8df00c944f5655c7)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f2649d98aa9ca8623149b3cb8df00c944f5655c7)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f2649d98aa9ca8623149b3cb8df00c944f5655c7)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f2649d98aa9ca8623149b3cb8df00c944f5655c7)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Wang Jianjian <wangjianjian3@huawei.com> | 2024-02-02 16:18:52 +0800 |
| --- | --- | --- |
| committer | Sasha Levin <sashal@kernel.org> | 2024-03-26 18:18:32 -0400 |
| commit | [f2649d98aa9ca8623149b3cb8df00c944f5655c7](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f2649d98aa9ca8623149b3cb8df00c944f5655c7) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=f2649d98aa9ca8623149b3cb8df00c944f5655c7)) | |
| tree | [1becbd5ceb35119156198d3cf27c6eff340bc37f](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f2649d98aa9ca8623149b3cb8df00c944f5655c7) | |
| parent | [8b9e27cbd7af2e996d57349be35cd2d379e4e7d6](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=8b9e27cbd7af2e996d57349be35cd2d379e4e7d6) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f2649d98aa9ca8623149b3cb8df00c944f5655c7&id2=8b9e27cbd7af2e996d57349be35cd2d379e4e7d6)) | |
| download | [linux-f2649d98aa9ca8623149b3cb8df00c944f5655c7.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-f2649d98aa9ca8623149b3cb8df00c944f5655c7.tar.gz) | |

quota: Fix potential NULL pointer dereference[ Upstream commit d0aa72604fbd80c8aabb46eda00535ed35570f1f ]
Below race may cause NULL pointer dereference
P1 P2
dquot\_free\_inode quota\_off
drop\_dquot\_ref
remove\_dquot\_ref
dquots = i\_dquot(inode)
dquots = i\_dquot(inode)
srcu\_read\_lock
dquots[cnt]) != NULL (1)
dquots[type] = NULL (2)
spin\_lock(&dquots[cnt]->dq\_dqb\_lock) (3)
....
If dquot\_free\_inode(or other routines) checks inode's quota pointers (1)
before quota\_off sets it to NULL(2) and use it (3) after that, NULL pointer
dereference will be triggered.
So let's fix it by using a temporary pointer to avoid this issue.
Signed-off-by: Wang Jianjian <wangjianjian3@huawei.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Message-Id: <20240202081852.2514092-1-wangjianjian3@huawei.com>
Stable-dep-of: 179b8c97ebf6 ("quota: Fix rcu annotations of inode dquot pointers")
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f2649d98aa9ca8623149b3cb8df00c944f5655c7)

| -rw-r--r-- | [fs/quota/dquot.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/quota/dquot.c?id=f2649d98aa9ca8623149b3cb8df00c944f5655c7) | 98 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 57 insertions, 41 deletions

| diff --git a/fs/quota/dquot.c b/fs/quota/dquot.cindex 58b5de081b5714..86597a03a8733e 100644--- a/[fs/quota/dquot.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/quota/dquot.c?id=8b9e27cbd7af2e996d57349be35cd2d379e4e7d6)+++ b/[fs/quota/dquot.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/quota/dquot.c?id=f2649d98aa9ca8623149b3cb8df00c944f5655c7)@@ -399,15 +399,17 @@ int dquot\_mark\_dquot\_dirty(struct dquot \*dquot) EXPORT\_SYMBOL(dquot\_mark\_dquot\_dirty);  /\* Dirtify all the dquots - this can block when journalling \*/-static inline int mark\_all\_dquot\_dirty(struct dquot \* const \*dquot)+static inline int mark\_all\_dquot\_dirty(struct dquot \* const \*dquots) { int ret, err, cnt;+ struct dquot \*dquot;  ret = err = 0; for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (dquot[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (dquot) /\* Even in case of error we have to continue \*/- ret = mark\_dquot\_dirty(dquot[cnt]);+ ret = mark\_dquot\_dirty(dquot); if (!err) err = ret; }@@ -1678,6 +1680,7 @@ int \_\_dquot\_alloc\_space(struct inode \*inode, qsize\_t number, int flags) struct dquot\_warn warn[MAXQUOTAS]; int reserve = flags & DQUOT\_SPACE\_RESERVE; struct dquot \*\*dquots;+ struct dquot \*dquot;  if (!inode\_quota\_active(inode)) { if (reserve) {@@ -1697,27 +1700,26 @@ int \_\_dquot\_alloc\_space(struct inode \*inode, qsize\_t number, int flags) index = srcu\_read\_lock(&dquot\_srcu); spin\_lock(&inode->i\_lock); for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue; if (reserve) {- ret = dquot\_add\_space(dquots[cnt], 0, number, flags,- &warn[cnt]);+ ret = dquot\_add\_space(dquot, 0, number, flags, &warn[cnt]); } else {- ret = dquot\_add\_space(dquots[cnt], number, 0, flags,- &warn[cnt]);+ ret = dquot\_add\_space(dquot, number, 0, flags, &warn[cnt]); } if (ret) { /\* Back out changes we already did \*/ for (cnt--; cnt >= 0; cnt--) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);+ spin\_lock(&dquot->dq\_dqb\_lock); if (reserve)- dquot\_free\_reserved\_space(dquots[cnt],- number);+ dquot\_free\_reserved\_space(dquot, number); else- dquot\_decr\_space(dquots[cnt], number);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ dquot\_decr\_space(dquot, number);+ spin\_unlock(&dquot->dq\_dqb\_lock); } spin\_unlock(&inode->i\_lock); goto out\_flush\_warn;@@ -1748,6 +1750,7 @@ int dquot\_alloc\_inode(struct inode \*inode) int cnt, ret = 0, index; struct dquot\_warn warn[MAXQUOTAS]; struct dquot \* const \*dquots;+ struct dquot \*dquot;  if (!inode\_quota\_active(inode)) return 0;@@ -1758,17 +1761,19 @@ int dquot\_alloc\_inode(struct inode \*inode) index = srcu\_read\_lock(&dquot\_srcu); spin\_lock(&inode->i\_lock); for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- ret = dquot\_add\_inodes(dquots[cnt], 1, &warn[cnt]);+ ret = dquot\_add\_inodes(dquot, 1, &warn[cnt]); if (ret) { for (cnt--; cnt >= 0; cnt--) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue; /\* Back out changes we already did \*/- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);- dquot\_decr\_inodes(dquots[cnt], 1);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ spin\_lock(&dquot->dq\_dqb\_lock);+ dquot\_decr\_inodes(dquot, 1);+ spin\_unlock(&dquot->dq\_dqb\_lock); } goto warn\_put\_all; }@@ -1790,6 +1795,7 @@ EXPORT\_SYMBOL(dquot\_alloc\_inode); int dquot\_claim\_space\_nodirty(struct inode \*inode, qsize\_t number) { struct dquot \*\*dquots;+ struct dquot \*dquot; int cnt, index;  if (!inode\_quota\_active(inode)) {@@ -1805,9 +1811,8 @@ int dquot\_claim\_space\_nodirty(struct inode \*inode, qsize\_t number) spin\_lock(&inode->i\_lock); /\* Claim reserved quotas to allocated quotas \*/ for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (dquots[cnt]) {- struct dquot \*dquot = dquots[cnt];-+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (dquot) { spin\_lock(&dquot->dq\_dqb\_lock); if (WARN\_ON\_ONCE(dquot->dq\_dqb.dqb\_rsvspace < number)) number = dquot->dq\_dqb.dqb\_rsvspace;@@ -1832,6 +1837,7 @@ EXPORT\_SYMBOL(dquot\_claim\_space\_nodirty); void dquot\_reclaim\_space\_nodirty(struct inode \*inode, qsize\_t number) { struct dquot \*\*dquots;+ struct dquot \*dquot; int cnt, index;  if (!inode\_quota\_active(inode)) {@@ -1847,9 +1853,8 @@ void dquot\_reclaim\_space\_nodirty(struct inode \*inode, qsize\_t number) spin\_lock(&inode->i\_lock); /\* Claim reserved quotas to allocated quotas \*/ for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (dquots[cnt]) {- struct dquot \*dquot = dquots[cnt];-+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (dquot) { spin\_lock(&dquot->dq\_dqb\_lock); if (WARN\_ON\_ONCE(dquot->dq\_dqb.dqb\_curspace < number)) number = dquot->dq\_dqb.dqb\_curspace;@@ -1876,6 +1881,7 @@ void \_\_dquot\_free\_space(struct inode \*inode, qsize\_t number, int flags) unsigned int cnt; struct dquot\_warn warn[MAXQUOTAS]; struct dquot \*\*dquots;+ struct dquot \*dquot; int reserve = flags & DQUOT\_SPACE\_RESERVE, index;  if (!inode\_quota\_active(inode)) {@@ -1896,17 +1902,18 @@ void \_\_dquot\_free\_space(struct inode \*inode, qsize\_t number, int flags) int wtype;  warn[cnt].w\_type = QUOTA\_NL\_NOWARN;- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);- wtype = info\_bdq\_free(dquots[cnt], number);+ spin\_lock(&dquot->dq\_dqb\_lock);+ wtype = info\_bdq\_free(dquot, number); if (wtype != QUOTA\_NL\_NOWARN)- prepare\_warning(&warn[cnt], dquots[cnt], wtype);+ prepare\_warning(&warn[cnt], dquot, wtype); if (reserve)- dquot\_free\_reserved\_space(dquots[cnt], number);+ dquot\_free\_reserved\_space(dquot, number); else- dquot\_decr\_space(dquots[cnt], number);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ dquot\_decr\_space(dquot, number);+ spin\_unlock(&dquot->dq\_dqb\_lock); } if (reserve) \*inode\_reserved\_space(inode) -= number;@@ -1931,6 +1938,7 @@ void dquot\_free\_inode(struct inode \*inode) unsigned int cnt; struct dquot\_warn warn[MAXQUOTAS]; struct dquot \* const \*dquots;+ struct dquot \*dquot; int index;  if (!inode\_quota\_active(inode))@@ -1941,16 +1949,16 @@ void dquot\_free\_inode(struct inode \*inode) spin\_lock(&inode->i\_lock); for (cnt = 0; cnt < MAXQUOTAS; cnt++) { int wtype;- warn[cnt].w\_type = QUOTA\_NL\_NOWARN;- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);- wtype = info\_idq\_free(dquots[cnt], 1);+ spin\_lock(&dquot->dq\_dqb\_lock);+ wtype = info\_idq\_free(dquot, 1); if (wtype != QUOTA\_NL\_NOWARN)- prepare\_warning(&warn[cnt], dquots[cnt], wtype);- dquot\_decr\_inodes(dquots[cnt], 1);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ prepare\_warning(&warn[cnt], dquot, wtype);+ dquot\_decr\_inodes(dquot, 1);+ spin\_unlock(&dquot->dq\_dqb\_lock); } spin\_unlock(&inode->i\_lock); mark\_all\_dquot\_dirty(dquots);@@ -1977,7 +1985,7 @@ int \_\_dquot\_transfer(struct inode \*inode, struct dquot \*\*transfer\_to) qsize\_t rsv\_space = 0; qsize\_t inode\_usage = 1; struct dquot \*transfer\_from[MAXQUOTAS] = {};- int cnt, ret = 0;+ int cnt, index, ret = 0; char is\_valid[MAXQUOTAS] = {}; struct dquot\_warn warn\_to[MAXQUOTAS]; struct dquot\_warn warn\_from\_inodes[MAXQUOTAS];@@ -2066,8 +2074,16 @@ int \_\_dquot\_transfer(struct inode \*inode, struct dquot \*\*transfer\_to) spin\_unlock(&inode->i\_lock); spin\_unlock(&dq\_data\_lock); + /\*+ \* These arrays are local and we hold dquot references so we don't need+ \* the srcu protection but still take dquot\_srcu to avoid warning in+ \* mark\_all\_dquot\_dirty().+ \*/+ index = srcu\_read\_lock(&dquot\_srcu); mark\_all\_dquot\_dirty(transfer\_from); mark\_all\_dquot\_dirty(transfer\_to);+ srcu\_read\_unlock(&dquot\_srcu, index);+ flush\_warnings(warn\_to); flush\_warnings(warn\_from\_inodes); flush\_warnings(warn\_from\_space); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 03:28:27 +0000



=== Content from git.kernel.org_c2f1a9c2_20250111_032946.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=49669f8e7eb053f91d239df7b1bfb4500255a9d0)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=49669f8e7eb053f91d239df7b1bfb4500255a9d0)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=49669f8e7eb053f91d239df7b1bfb4500255a9d0)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=49669f8e7eb053f91d239df7b1bfb4500255a9d0)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Wang Jianjian <wangjianjian3@huawei.com> | 2024-02-02 16:18:52 +0800 |
| --- | --- | --- |
| committer | Sasha Levin <sashal@kernel.org> | 2024-03-26 18:22:20 -0400 |
| commit | [49669f8e7eb053f91d239df7b1bfb4500255a9d0](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=49669f8e7eb053f91d239df7b1bfb4500255a9d0) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=49669f8e7eb053f91d239df7b1bfb4500255a9d0)) | |
| tree | [e213ad21f49b463b693542cc6a02818d15a559d9](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=49669f8e7eb053f91d239df7b1bfb4500255a9d0) | |
| parent | [ff29b5f9f019a5eb7a767f4df954bb1061a2619e](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ff29b5f9f019a5eb7a767f4df954bb1061a2619e) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=49669f8e7eb053f91d239df7b1bfb4500255a9d0&id2=ff29b5f9f019a5eb7a767f4df954bb1061a2619e)) | |
| download | [linux-49669f8e7eb053f91d239df7b1bfb4500255a9d0.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-49669f8e7eb053f91d239df7b1bfb4500255a9d0.tar.gz) | |

quota: Fix potential NULL pointer dereference[ Upstream commit d0aa72604fbd80c8aabb46eda00535ed35570f1f ]
Below race may cause NULL pointer dereference
P1 P2
dquot\_free\_inode quota\_off
drop\_dquot\_ref
remove\_dquot\_ref
dquots = i\_dquot(inode)
dquots = i\_dquot(inode)
srcu\_read\_lock
dquots[cnt]) != NULL (1)
dquots[type] = NULL (2)
spin\_lock(&dquots[cnt]->dq\_dqb\_lock) (3)
....
If dquot\_free\_inode(or other routines) checks inode's quota pointers (1)
before quota\_off sets it to NULL(2) and use it (3) after that, NULL pointer
dereference will be triggered.
So let's fix it by using a temporary pointer to avoid this issue.
Signed-off-by: Wang Jianjian <wangjianjian3@huawei.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Message-Id: <20240202081852.2514092-1-wangjianjian3@huawei.com>
Stable-dep-of: 179b8c97ebf6 ("quota: Fix rcu annotations of inode dquot pointers")
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=49669f8e7eb053f91d239df7b1bfb4500255a9d0)

| -rw-r--r-- | [fs/quota/dquot.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/quota/dquot.c?id=49669f8e7eb053f91d239df7b1bfb4500255a9d0) | 98 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 57 insertions, 41 deletions

| diff --git a/fs/quota/dquot.c b/fs/quota/dquot.cindex 08ca5b1a5fba5b..c4726a18955825 100644--- a/[fs/quota/dquot.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/quota/dquot.c?id=ff29b5f9f019a5eb7a767f4df954bb1061a2619e)+++ b/[fs/quota/dquot.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/quota/dquot.c?id=49669f8e7eb053f91d239df7b1bfb4500255a9d0)@@ -399,15 +399,17 @@ int dquot\_mark\_dquot\_dirty(struct dquot \*dquot) EXPORT\_SYMBOL(dquot\_mark\_dquot\_dirty);  /\* Dirtify all the dquots - this can block when journalling \*/-static inline int mark\_all\_dquot\_dirty(struct dquot \* const \*dquot)+static inline int mark\_all\_dquot\_dirty(struct dquot \* const \*dquots) { int ret, err, cnt;+ struct dquot \*dquot;  ret = err = 0; for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (dquot[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (dquot) /\* Even in case of error we have to continue \*/- ret = mark\_dquot\_dirty(dquot[cnt]);+ ret = mark\_dquot\_dirty(dquot); if (!err) err = ret; }@@ -1675,6 +1677,7 @@ int \_\_dquot\_alloc\_space(struct inode \*inode, qsize\_t number, int flags) struct dquot\_warn warn[MAXQUOTAS]; int reserve = flags & DQUOT\_SPACE\_RESERVE; struct dquot \*\*dquots;+ struct dquot \*dquot;  if (!inode\_quota\_active(inode)) { if (reserve) {@@ -1694,27 +1697,26 @@ int \_\_dquot\_alloc\_space(struct inode \*inode, qsize\_t number, int flags) index = srcu\_read\_lock(&dquot\_srcu); spin\_lock(&inode->i\_lock); for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue; if (reserve) {- ret = dquot\_add\_space(dquots[cnt], 0, number, flags,- &warn[cnt]);+ ret = dquot\_add\_space(dquot, 0, number, flags, &warn[cnt]); } else {- ret = dquot\_add\_space(dquots[cnt], number, 0, flags,- &warn[cnt]);+ ret = dquot\_add\_space(dquot, number, 0, flags, &warn[cnt]); } if (ret) { /\* Back out changes we already did \*/ for (cnt--; cnt >= 0; cnt--) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);+ spin\_lock(&dquot->dq\_dqb\_lock); if (reserve)- dquot\_free\_reserved\_space(dquots[cnt],- number);+ dquot\_free\_reserved\_space(dquot, number); else- dquot\_decr\_space(dquots[cnt], number);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ dquot\_decr\_space(dquot, number);+ spin\_unlock(&dquot->dq\_dqb\_lock); } spin\_unlock(&inode->i\_lock); goto out\_flush\_warn;@@ -1745,6 +1747,7 @@ int dquot\_alloc\_inode(struct inode \*inode) int cnt, ret = 0, index; struct dquot\_warn warn[MAXQUOTAS]; struct dquot \* const \*dquots;+ struct dquot \*dquot;  if (!inode\_quota\_active(inode)) return 0;@@ -1755,17 +1758,19 @@ int dquot\_alloc\_inode(struct inode \*inode) index = srcu\_read\_lock(&dquot\_srcu); spin\_lock(&inode->i\_lock); for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- ret = dquot\_add\_inodes(dquots[cnt], 1, &warn[cnt]);+ ret = dquot\_add\_inodes(dquot, 1, &warn[cnt]); if (ret) { for (cnt--; cnt >= 0; cnt--) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue; /\* Back out changes we already did \*/- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);- dquot\_decr\_inodes(dquots[cnt], 1);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ spin\_lock(&dquot->dq\_dqb\_lock);+ dquot\_decr\_inodes(dquot, 1);+ spin\_unlock(&dquot->dq\_dqb\_lock); } goto warn\_put\_all; }@@ -1787,6 +1792,7 @@ EXPORT\_SYMBOL(dquot\_alloc\_inode); int dquot\_claim\_space\_nodirty(struct inode \*inode, qsize\_t number) { struct dquot \*\*dquots;+ struct dquot \*dquot; int cnt, index;  if (!inode\_quota\_active(inode)) {@@ -1802,9 +1808,8 @@ int dquot\_claim\_space\_nodirty(struct inode \*inode, qsize\_t number) spin\_lock(&inode->i\_lock); /\* Claim reserved quotas to allocated quotas \*/ for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (dquots[cnt]) {- struct dquot \*dquot = dquots[cnt];-+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (dquot) { spin\_lock(&dquot->dq\_dqb\_lock); if (WARN\_ON\_ONCE(dquot->dq\_dqb.dqb\_rsvspace < number)) number = dquot->dq\_dqb.dqb\_rsvspace;@@ -1829,6 +1834,7 @@ EXPORT\_SYMBOL(dquot\_claim\_space\_nodirty); void dquot\_reclaim\_space\_nodirty(struct inode \*inode, qsize\_t number) { struct dquot \*\*dquots;+ struct dquot \*dquot; int cnt, index;  if (!inode\_quota\_active(inode)) {@@ -1844,9 +1850,8 @@ void dquot\_reclaim\_space\_nodirty(struct inode \*inode, qsize\_t number) spin\_lock(&inode->i\_lock); /\* Claim reserved quotas to allocated quotas \*/ for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (dquots[cnt]) {- struct dquot \*dquot = dquots[cnt];-+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (dquot) { spin\_lock(&dquot->dq\_dqb\_lock); if (WARN\_ON\_ONCE(dquot->dq\_dqb.dqb\_curspace < number)) number = dquot->dq\_dqb.dqb\_curspace;@@ -1873,6 +1878,7 @@ void \_\_dquot\_free\_space(struct inode \*inode, qsize\_t number, int flags) unsigned int cnt; struct dquot\_warn warn[MAXQUOTAS]; struct dquot \*\*dquots;+ struct dquot \*dquot; int reserve = flags & DQUOT\_SPACE\_RESERVE, index;  if (!inode\_quota\_active(inode)) {@@ -1893,17 +1899,18 @@ void \_\_dquot\_free\_space(struct inode \*inode, qsize\_t number, int flags) int wtype;  warn[cnt].w\_type = QUOTA\_NL\_NOWARN;- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);- wtype = info\_bdq\_free(dquots[cnt], number);+ spin\_lock(&dquot->dq\_dqb\_lock);+ wtype = info\_bdq\_free(dquot, number); if (wtype != QUOTA\_NL\_NOWARN)- prepare\_warning(&warn[cnt], dquots[cnt], wtype);+ prepare\_warning(&warn[cnt], dquot, wtype); if (reserve)- dquot\_free\_reserved\_space(dquots[cnt], number);+ dquot\_free\_reserved\_space(dquot, number); else- dquot\_decr\_space(dquots[cnt], number);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ dquot\_decr\_space(dquot, number);+ spin\_unlock(&dquot->dq\_dqb\_lock); } if (reserve) \*inode\_reserved\_space(inode) -= number;@@ -1928,6 +1935,7 @@ void dquot\_free\_inode(struct inode \*inode) unsigned int cnt; struct dquot\_warn warn[MAXQUOTAS]; struct dquot \* const \*dquots;+ struct dquot \*dquot; int index;  if (!inode\_quota\_active(inode))@@ -1938,16 +1946,16 @@ void dquot\_free\_inode(struct inode \*inode) spin\_lock(&inode->i\_lock); for (cnt = 0; cnt < MAXQUOTAS; cnt++) { int wtype;- warn[cnt].w\_type = QUOTA\_NL\_NOWARN;- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);- wtype = info\_idq\_free(dquots[cnt], 1);+ spin\_lock(&dquot->dq\_dqb\_lock);+ wtype = info\_idq\_free(dquot, 1); if (wtype != QUOTA\_NL\_NOWARN)- prepare\_warning(&warn[cnt], dquots[cnt], wtype);- dquot\_decr\_inodes(dquots[cnt], 1);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ prepare\_warning(&warn[cnt], dquot, wtype);+ dquot\_decr\_inodes(dquot, 1);+ spin\_unlock(&dquot->dq\_dqb\_lock); } spin\_unlock(&inode->i\_lock); mark\_all\_dquot\_dirty(dquots);@@ -1974,7 +1982,7 @@ int \_\_dquot\_transfer(struct inode \*inode, struct dquot \*\*transfer\_to) qsize\_t rsv\_space = 0; qsize\_t inode\_usage = 1; struct dquot \*transfer\_from[MAXQUOTAS] = {};- int cnt, ret = 0;+ int cnt, index, ret = 0; char is\_valid[MAXQUOTAS] = {}; struct dquot\_warn warn\_to[MAXQUOTAS]; struct dquot\_warn warn\_from\_inodes[MAXQUOTAS];@@ -2063,8 +2071,16 @@ int \_\_dquot\_transfer(struct inode \*inode, struct dquot \*\*transfer\_to) spin\_unlock(&inode->i\_lock); spin\_unlock(&dq\_data\_lock); + /\*+ \* These arrays are local and we hold dquot references so we don't need+ \* the srcu protection but still take dquot\_srcu to avoid warning in+ \* mark\_all\_dquot\_dirty().+ \*/+ index = srcu\_read\_lock(&dquot\_srcu); mark\_all\_dquot\_dirty(transfer\_from); mark\_all\_dquot\_dirty(transfer\_to);+ srcu\_read\_unlock(&dquot\_srcu, index);+ flush\_warnings(warn\_to); flush\_warnings(warn\_from\_inodes); flush\_warnings(warn\_from\_space); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 03:28:23 +0000



=== Content from git.kernel.org_82097165_20250111_032948.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=7f9e833fc0f9b47be503af012eb5903086939754)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=7f9e833fc0f9b47be503af012eb5903086939754)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7f9e833fc0f9b47be503af012eb5903086939754)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7f9e833fc0f9b47be503af012eb5903086939754)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Wang Jianjian <wangjianjian3@huawei.com> | 2024-02-02 16:18:52 +0800 |
| --- | --- | --- |
| committer | Sasha Levin <sashal@kernel.org> | 2024-03-26 18:20:47 -0400 |
| commit | [7f9e833fc0f9b47be503af012eb5903086939754](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7f9e833fc0f9b47be503af012eb5903086939754) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=7f9e833fc0f9b47be503af012eb5903086939754)) | |
| tree | [8f357e600851720593b2abc52ff562f83d8db4c1](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=7f9e833fc0f9b47be503af012eb5903086939754) | |
| parent | [fd14781b30215672c09826f666ed65339885a358](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=fd14781b30215672c09826f666ed65339885a358) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7f9e833fc0f9b47be503af012eb5903086939754&id2=fd14781b30215672c09826f666ed65339885a358)) | |
| download | [linux-7f9e833fc0f9b47be503af012eb5903086939754.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-7f9e833fc0f9b47be503af012eb5903086939754.tar.gz) | |

quota: Fix potential NULL pointer dereference[ Upstream commit d0aa72604fbd80c8aabb46eda00535ed35570f1f ]
Below race may cause NULL pointer dereference
P1 P2
dquot\_free\_inode quota\_off
drop\_dquot\_ref
remove\_dquot\_ref
dquots = i\_dquot(inode)
dquots = i\_dquot(inode)
srcu\_read\_lock
dquots[cnt]) != NULL (1)
dquots[type] = NULL (2)
spin\_lock(&dquots[cnt]->dq\_dqb\_lock) (3)
....
If dquot\_free\_inode(or other routines) checks inode's quota pointers (1)
before quota\_off sets it to NULL(2) and use it (3) after that, NULL pointer
dereference will be triggered.
So let's fix it by using a temporary pointer to avoid this issue.
Signed-off-by: Wang Jianjian <wangjianjian3@huawei.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Message-Id: <20240202081852.2514092-1-wangjianjian3@huawei.com>
Stable-dep-of: 179b8c97ebf6 ("quota: Fix rcu annotations of inode dquot pointers")
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=7f9e833fc0f9b47be503af012eb5903086939754)

| -rw-r--r-- | [fs/quota/dquot.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/quota/dquot.c?id=7f9e833fc0f9b47be503af012eb5903086939754) | 98 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 57 insertions, 41 deletions

| diff --git a/fs/quota/dquot.c b/fs/quota/dquot.cindex 730d8ffc4928a6..44c4da364c994a 100644--- a/[fs/quota/dquot.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/quota/dquot.c?id=fd14781b30215672c09826f666ed65339885a358)+++ b/[fs/quota/dquot.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/quota/dquot.c?id=7f9e833fc0f9b47be503af012eb5903086939754)@@ -399,15 +399,17 @@ int dquot\_mark\_dquot\_dirty(struct dquot \*dquot) EXPORT\_SYMBOL(dquot\_mark\_dquot\_dirty);  /\* Dirtify all the dquots - this can block when journalling \*/-static inline int mark\_all\_dquot\_dirty(struct dquot \* const \*dquot)+static inline int mark\_all\_dquot\_dirty(struct dquot \* const \*dquots) { int ret, err, cnt;+ struct dquot \*dquot;  ret = err = 0; for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (dquot[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (dquot) /\* Even in case of error we have to continue \*/- ret = mark\_dquot\_dirty(dquot[cnt]);+ ret = mark\_dquot\_dirty(dquot); if (!err) err = ret; }@@ -1684,6 +1686,7 @@ int \_\_dquot\_alloc\_space(struct inode \*inode, qsize\_t number, int flags) struct dquot\_warn warn[MAXQUOTAS]; int reserve = flags & DQUOT\_SPACE\_RESERVE; struct dquot \*\*dquots;+ struct dquot \*dquot;  if (!inode\_quota\_active(inode)) { if (reserve) {@@ -1703,27 +1706,26 @@ int \_\_dquot\_alloc\_space(struct inode \*inode, qsize\_t number, int flags) index = srcu\_read\_lock(&dquot\_srcu); spin\_lock(&inode->i\_lock); for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue; if (reserve) {- ret = dquot\_add\_space(dquots[cnt], 0, number, flags,- &warn[cnt]);+ ret = dquot\_add\_space(dquot, 0, number, flags, &warn[cnt]); } else {- ret = dquot\_add\_space(dquots[cnt], number, 0, flags,- &warn[cnt]);+ ret = dquot\_add\_space(dquot, number, 0, flags, &warn[cnt]); } if (ret) { /\* Back out changes we already did \*/ for (cnt--; cnt >= 0; cnt--) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);+ spin\_lock(&dquot->dq\_dqb\_lock); if (reserve)- dquot\_free\_reserved\_space(dquots[cnt],- number);+ dquot\_free\_reserved\_space(dquot, number); else- dquot\_decr\_space(dquots[cnt], number);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ dquot\_decr\_space(dquot, number);+ spin\_unlock(&dquot->dq\_dqb\_lock); } spin\_unlock(&inode->i\_lock); goto out\_flush\_warn;@@ -1754,6 +1756,7 @@ int dquot\_alloc\_inode(struct inode \*inode) int cnt, ret = 0, index; struct dquot\_warn warn[MAXQUOTAS]; struct dquot \* const \*dquots;+ struct dquot \*dquot;  if (!inode\_quota\_active(inode)) return 0;@@ -1764,17 +1767,19 @@ int dquot\_alloc\_inode(struct inode \*inode) index = srcu\_read\_lock(&dquot\_srcu); spin\_lock(&inode->i\_lock); for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- ret = dquot\_add\_inodes(dquots[cnt], 1, &warn[cnt]);+ ret = dquot\_add\_inodes(dquot, 1, &warn[cnt]); if (ret) { for (cnt--; cnt >= 0; cnt--) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue; /\* Back out changes we already did \*/- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);- dquot\_decr\_inodes(dquots[cnt], 1);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ spin\_lock(&dquot->dq\_dqb\_lock);+ dquot\_decr\_inodes(dquot, 1);+ spin\_unlock(&dquot->dq\_dqb\_lock); } goto warn\_put\_all; }@@ -1796,6 +1801,7 @@ EXPORT\_SYMBOL(dquot\_alloc\_inode); int dquot\_claim\_space\_nodirty(struct inode \*inode, qsize\_t number) { struct dquot \*\*dquots;+ struct dquot \*dquot; int cnt, index;  if (!inode\_quota\_active(inode)) {@@ -1811,9 +1817,8 @@ int dquot\_claim\_space\_nodirty(struct inode \*inode, qsize\_t number) spin\_lock(&inode->i\_lock); /\* Claim reserved quotas to allocated quotas \*/ for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (dquots[cnt]) {- struct dquot \*dquot = dquots[cnt];-+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (dquot) { spin\_lock(&dquot->dq\_dqb\_lock); if (WARN\_ON\_ONCE(dquot->dq\_dqb.dqb\_rsvspace < number)) number = dquot->dq\_dqb.dqb\_rsvspace;@@ -1838,6 +1843,7 @@ EXPORT\_SYMBOL(dquot\_claim\_space\_nodirty); void dquot\_reclaim\_space\_nodirty(struct inode \*inode, qsize\_t number) { struct dquot \*\*dquots;+ struct dquot \*dquot; int cnt, index;  if (!inode\_quota\_active(inode)) {@@ -1853,9 +1859,8 @@ void dquot\_reclaim\_space\_nodirty(struct inode \*inode, qsize\_t number) spin\_lock(&inode->i\_lock); /\* Claim reserved quotas to allocated quotas \*/ for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (dquots[cnt]) {- struct dquot \*dquot = dquots[cnt];-+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (dquot) { spin\_lock(&dquot->dq\_dqb\_lock); if (WARN\_ON\_ONCE(dquot->dq\_dqb.dqb\_curspace < number)) number = dquot->dq\_dqb.dqb\_curspace;@@ -1882,6 +1887,7 @@ void \_\_dquot\_free\_space(struct inode \*inode, qsize\_t number, int flags) unsigned int cnt; struct dquot\_warn warn[MAXQUOTAS]; struct dquot \*\*dquots;+ struct dquot \*dquot; int reserve = flags & DQUOT\_SPACE\_RESERVE, index;  if (!inode\_quota\_active(inode)) {@@ -1902,17 +1908,18 @@ void \_\_dquot\_free\_space(struct inode \*inode, qsize\_t number, int flags) int wtype;  warn[cnt].w\_type = QUOTA\_NL\_NOWARN;- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);- wtype = info\_bdq\_free(dquots[cnt], number);+ spin\_lock(&dquot->dq\_dqb\_lock);+ wtype = info\_bdq\_free(dquot, number); if (wtype != QUOTA\_NL\_NOWARN)- prepare\_warning(&warn[cnt], dquots[cnt], wtype);+ prepare\_warning(&warn[cnt], dquot, wtype); if (reserve)- dquot\_free\_reserved\_space(dquots[cnt], number);+ dquot\_free\_reserved\_space(dquot, number); else- dquot\_decr\_space(dquots[cnt], number);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ dquot\_decr\_space(dquot, number);+ spin\_unlock(&dquot->dq\_dqb\_lock); } if (reserve) \*inode\_reserved\_space(inode) -= number;@@ -1937,6 +1944,7 @@ void dquot\_free\_inode(struct inode \*inode) unsigned int cnt; struct dquot\_warn warn[MAXQUOTAS]; struct dquot \* const \*dquots;+ struct dquot \*dquot; int index;  if (!inode\_quota\_active(inode))@@ -1947,16 +1955,16 @@ void dquot\_free\_inode(struct inode \*inode) spin\_lock(&inode->i\_lock); for (cnt = 0; cnt < MAXQUOTAS; cnt++) { int wtype;- warn[cnt].w\_type = QUOTA\_NL\_NOWARN;- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);- wtype = info\_idq\_free(dquots[cnt], 1);+ spin\_lock(&dquot->dq\_dqb\_lock);+ wtype = info\_idq\_free(dquot, 1); if (wtype != QUOTA\_NL\_NOWARN)- prepare\_warning(&warn[cnt], dquots[cnt], wtype);- dquot\_decr\_inodes(dquots[cnt], 1);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ prepare\_warning(&warn[cnt], dquot, wtype);+ dquot\_decr\_inodes(dquot, 1);+ spin\_unlock(&dquot->dq\_dqb\_lock); } spin\_unlock(&inode->i\_lock); mark\_all\_dquot\_dirty(dquots);@@ -1983,7 +1991,7 @@ int \_\_dquot\_transfer(struct inode \*inode, struct dquot \*\*transfer\_to) qsize\_t rsv\_space = 0; qsize\_t inode\_usage = 1; struct dquot \*transfer\_from[MAXQUOTAS] = {};- int cnt, ret = 0;+ int cnt, index, ret = 0; char is\_valid[MAXQUOTAS] = {}; struct dquot\_warn warn\_to[MAXQUOTAS]; struct dquot\_warn warn\_from\_inodes[MAXQUOTAS];@@ -2072,8 +2080,16 @@ int \_\_dquot\_transfer(struct inode \*inode, struct dquot \*\*transfer\_to) spin\_unlock(&inode->i\_lock); spin\_unlock(&dq\_data\_lock); + /\*+ \* These arrays are local and we hold dquot references so we don't need+ \* the srcu protection but still take dquot\_srcu to avoid warning in+ \* mark\_all\_dquot\_dirty().+ \*/+ index = srcu\_read\_lock(&dquot\_srcu); mark\_all\_dquot\_dirty(transfer\_from); mark\_all\_dquot\_dirty(transfer\_to);+ srcu\_read\_unlock(&dquot\_srcu, index);+ flush\_warnings(warn\_to); flush\_warnings(warn\_from\_inodes); flush\_warnings(warn\_from\_space); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 03:28:25 +0000



=== Content from lists.debian.org_e047c9ff_20250111_032950.html ===


---

[[Date Prev](msg00019.html)][[Date Next](msg00021.html)]
[[Thread Prev](msg00019.html)][[Thread Next](msg00021.html)]
[[Date Index](maillist.html#00020)]
[[Thread Index](threads.html#00020)]

# [SECURITY] [DLA 3840-1] linux security update

---

* *To*: debian-lts-announce@lists.debian.org
* *Subject*: [SECURITY] [DLA 3840-1] linux security update
* *From*: Ben Hutchings <benh@debian.org>
* *Date*: Thu, 27 Jun 2024 13:30:44 +0200
* *Message-id*: <[[ðŸ”Ž]](/msgid-search/Zn1NZBWeoEHK3cXd%40decadent.org.uk)Â [Zn1NZBWeoEHK3cXd@decadent.org.uk](msg00020.html)>
* *Mail-followup-to*: debian-lts@lists.debian.org
* *Reply-to*: debian-lts@lists.debian.org

---

```
-------------------------------------------------------------------------
Debian LTS Advisory DLA-3840-1                debian-lts@lists.debian.org
<https://www.debian.org/lts/security/>                        Ben Hutchings
June 25, 2024                                 <https://wiki.debian.org/LTS>
-------------------------------------------------------------------------

Package        : linux
Version        : 4.19.316-1
CVE ID         : CVE-2021-33630 CVE-2022-48627 CVE-2023-0386 CVE-2023-6040
                 CVE-2023-6270 CVE-2023-7042 CVE-2023-46838 CVE-2023-47233
                 CVE-2023-52340 CVE-2023-52429 CVE-2023-52436 CVE-2023-52439
                 CVE-2023-52443 CVE-2023-52444 CVE-2023-52445 CVE-2023-52449
                 CVE-2023-52464 CVE-2023-52469 CVE-2023-52470 CVE-2023-52486
                 CVE-2023-52583 CVE-2023-52587 CVE-2023-52594 CVE-2023-52599
                 CVE-2023-52600 CVE-2023-52601 CVE-2023-52602 CVE-2023-52603
                 CVE-2023-52604 CVE-2023-52609 CVE-2023-52612 CVE-2023-52615
                 CVE-2023-52619 CVE-2023-52620 CVE-2023-52622 CVE-2023-52623
                 CVE-2023-52628 CVE-2023-52644 CVE-2023-52650 CVE-2023-52670
                 CVE-2023-52679 CVE-2023-52683 CVE-2023-52691 CVE-2023-52693
                 CVE-2023-52698 CVE-2023-52699 CVE-2023-52880 CVE-2024-0340
                 CVE-2024-0607 CVE-2024-1086 CVE-2024-22099 CVE-2024-23849
                 CVE-2024-23851 CVE-2024-24857 CVE-2024-24858 CVE-2024-24861
                 CVE-2024-25739 CVE-2024-26597 CVE-2024-26600 CVE-2024-26602
                 CVE-2024-26606 CVE-2024-26615 CVE-2024-26625 CVE-2024-26633
                 CVE-2024-26635 CVE-2024-26636 CVE-2024-26642 CVE-2024-26645
                 CVE-2024-26651 CVE-2024-26663 CVE-2024-26664 CVE-2024-26671
                 CVE-2024-26675 CVE-2024-26679 CVE-2024-26685 CVE-2024-26696
                 CVE-2024-26697 CVE-2024-26704 CVE-2024-26720 CVE-2024-26722
                 CVE-2024-26735 CVE-2024-26744 CVE-2024-26752 CVE-2024-26754
                 CVE-2024-26763 CVE-2024-26764 CVE-2024-26766 CVE-2024-26772
                 CVE-2024-26773 CVE-2024-26777 CVE-2024-26778 CVE-2024-26779
                 CVE-2024-26791 CVE-2024-26793 CVE-2024-26801 CVE-2024-26805
                 CVE-2024-26816 CVE-2024-26817 CVE-2024-26820 CVE-2024-26825
                 CVE-2024-26839 CVE-2024-26840 CVE-2024-26845 CVE-2024-26851
                 CVE-2024-26852 CVE-2024-26857 CVE-2024-26859 CVE-2024-26863
                 CVE-2024-26874 CVE-2024-26875 CVE-2024-26878 CVE-2024-26880
                 CVE-2024-26883 CVE-2024-26884 CVE-2024-26889 CVE-2024-26894
                 CVE-2024-26898 CVE-2024-26901 CVE-2024-26903 CVE-2024-26917
                 CVE-2024-26922 CVE-2024-26923 CVE-2024-26931 CVE-2024-26934
                 CVE-2024-26955 CVE-2024-26956 CVE-2024-26965 CVE-2024-26966
                 CVE-2024-26969 CVE-2024-26973 CVE-2024-26974 CVE-2024-26976
                 CVE-2024-26981 CVE-2024-26984 CVE-2024-26993 CVE-2024-26994
                 CVE-2024-26997 CVE-2024-27001 CVE-2024-27008 CVE-2024-27013
                 CVE-2024-27020 CVE-2024-27024 CVE-2024-27028 CVE-2024-27043
                 CVE-2024-27046 CVE-2024-27059 CVE-2024-27074 CVE-2024-27075
                 CVE-2024-27077 CVE-2024-27078 CVE-2024-27388 CVE-2024-27395
                 CVE-2024-27396 CVE-2024-27398 CVE-2024-27399 CVE-2024-27401
                 CVE-2024-27405 CVE-2024-27410 CVE-2024-27412 CVE-2024-27413
                 CVE-2024-27416 CVE-2024-27419 CVE-2024-27436 CVE-2024-31076
                 CVE-2024-33621 CVE-2024-35789 CVE-2024-35806 CVE-2024-35807
                 CVE-2024-35809 CVE-2024-35811 CVE-2024-35815 CVE-2024-35819
                 CVE-2024-35821 CVE-2024-35822 CVE-2024-35823 CVE-2024-35825
                 CVE-2024-35828 CVE-2024-35830 CVE-2024-35835 CVE-2024-35847
                 CVE-2024-35849 CVE-2024-35877 CVE-2024-35886 CVE-2024-35888
                 CVE-2024-35893 CVE-2024-35898 CVE-2024-35902 CVE-2024-35910
                 CVE-2024-35915 CVE-2024-35922 CVE-2024-35925 CVE-2024-35930
                 CVE-2024-35933 CVE-2024-35935 CVE-2024-35936 CVE-2024-35944
                 CVE-2024-35947 CVE-2024-35955 CVE-2024-35960 CVE-2024-35969
                 CVE-2024-35973 CVE-2024-35978 CVE-2024-35982 CVE-2024-35984
                 CVE-2024-35997 CVE-2024-36004 CVE-2024-36014 CVE-2024-36015
                 CVE-2024-36016 CVE-2024-36017 CVE-2024-36020 CVE-2024-36286
                 CVE-2024-36288 CVE-2024-36883 CVE-2024-36886 CVE-2024-36902
                 CVE-2024-36904 CVE-2024-36905 CVE-2024-36919 CVE-2024-36933
                 CVE-2024-36934 CVE-2024-36940 CVE-2024-36941 CVE-2024-36946
                 CVE-2024-36950 CVE-2024-36954 CVE-2024-36959 CVE-2024-36960
                 CVE-2024-36964 CVE-2024-36971 CVE-2024-37353 CVE-2024-37356
                 CVE-2024-38381 CVE-2024-38549 CVE-2024-38552 CVE-2024-38558
                 CVE-2024-38559 CVE-2024-38560 CVE-2024-38565 CVE-2024-38567
                 CVE-2024-38578 CVE-2024-38579 CVE-2024-38582 CVE-2024-38583
                 CVE-2024-38587 CVE-2024-38589 CVE-2024-38596 CVE-2024-38598
                 CVE-2024-38599 CVE-2024-38601 CVE-2024-38612 CVE-2024-38618
                 CVE-2024-38621 CVE-2024-38627 CVE-2024-38633 CVE-2024-38634
                 CVE-2024-38637 CVE-2024-38659 CVE-2024-38780 CVE-2024-39292

Several vulnerabilities have been discovered in the Linux kernel that
may lead to a privilege escalation, denial of service or information
leaks.

For Debian 10 buster, these problems have been fixed in version
4.19.316-1.

We recommend that you upgrade your linux packages.

For the detailed security status of linux please refer to
its security tracker page at:
<https://security-tracker.debian.org/tracker/linux>

Further information about Debian LTS security advisories, how to apply
these updates to your system and frequently asked questions can be
found at: <https://wiki.debian.org/LTS>

```

**Attachment:
[signature.asc](pgpg1YwLnofmR.pgp)**

*Description:* PGP signature

---



=== Content from git.kernel.org_29d81a1b_20250111_032946.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=61380537aa6dd32d8a723d98b8f1bd1b11d8fee0)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=61380537aa6dd32d8a723d98b8f1bd1b11d8fee0)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=61380537aa6dd32d8a723d98b8f1bd1b11d8fee0)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=61380537aa6dd32d8a723d98b8f1bd1b11d8fee0)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Wang Jianjian <wangjianjian3@huawei.com> | 2024-02-02 16:18:52 +0800 |
| --- | --- | --- |
| committer | Sasha Levin <sashal@kernel.org> | 2024-03-26 18:21:56 -0400 |
| commit | [61380537aa6dd32d8a723d98b8f1bd1b11d8fee0](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=61380537aa6dd32d8a723d98b8f1bd1b11d8fee0) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=61380537aa6dd32d8a723d98b8f1bd1b11d8fee0)) | |
| tree | [9d81e882ed173ed1da3e39ed2bf64871c938f682](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=61380537aa6dd32d8a723d98b8f1bd1b11d8fee0) | |
| parent | [00684e9328390da8d230730221054cb727627be5](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=00684e9328390da8d230730221054cb727627be5) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=61380537aa6dd32d8a723d98b8f1bd1b11d8fee0&id2=00684e9328390da8d230730221054cb727627be5)) | |
| download | [linux-61380537aa6dd32d8a723d98b8f1bd1b11d8fee0.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-61380537aa6dd32d8a723d98b8f1bd1b11d8fee0.tar.gz) | |

quota: Fix potential NULL pointer dereference[ Upstream commit d0aa72604fbd80c8aabb46eda00535ed35570f1f ]
Below race may cause NULL pointer dereference
P1 P2
dquot\_free\_inode quota\_off
drop\_dquot\_ref
remove\_dquot\_ref
dquots = i\_dquot(inode)
dquots = i\_dquot(inode)
srcu\_read\_lock
dquots[cnt]) != NULL (1)
dquots[type] = NULL (2)
spin\_lock(&dquots[cnt]->dq\_dqb\_lock) (3)
....
If dquot\_free\_inode(or other routines) checks inode's quota pointers (1)
before quota\_off sets it to NULL(2) and use it (3) after that, NULL pointer
dereference will be triggered.
So let's fix it by using a temporary pointer to avoid this issue.
Signed-off-by: Wang Jianjian <wangjianjian3@huawei.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Message-Id: <20240202081852.2514092-1-wangjianjian3@huawei.com>
Stable-dep-of: 179b8c97ebf6 ("quota: Fix rcu annotations of inode dquot pointers")
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=61380537aa6dd32d8a723d98b8f1bd1b11d8fee0)

| -rw-r--r-- | [fs/quota/dquot.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/quota/dquot.c?id=61380537aa6dd32d8a723d98b8f1bd1b11d8fee0) | 98 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 57 insertions, 41 deletions

| diff --git a/fs/quota/dquot.c b/fs/quota/dquot.cindex 77578332e35ae2..3f19ef2cc186db 100644--- a/[fs/quota/dquot.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/quota/dquot.c?id=00684e9328390da8d230730221054cb727627be5)+++ b/[fs/quota/dquot.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/quota/dquot.c?id=61380537aa6dd32d8a723d98b8f1bd1b11d8fee0)@@ -401,15 +401,17 @@ int dquot\_mark\_dquot\_dirty(struct dquot \*dquot) EXPORT\_SYMBOL(dquot\_mark\_dquot\_dirty);  /\* Dirtify all the dquots - this can block when journalling \*/-static inline int mark\_all\_dquot\_dirty(struct dquot \* const \*dquot)+static inline int mark\_all\_dquot\_dirty(struct dquot \* const \*dquots) { int ret, err, cnt;+ struct dquot \*dquot;  ret = err = 0; for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (dquot[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (dquot) /\* Even in case of error we have to continue \*/- ret = mark\_dquot\_dirty(dquot[cnt]);+ ret = mark\_dquot\_dirty(dquot); if (!err) err = ret; }@@ -1686,6 +1688,7 @@ int \_\_dquot\_alloc\_space(struct inode \*inode, qsize\_t number, int flags) struct dquot\_warn warn[MAXQUOTAS]; int reserve = flags & DQUOT\_SPACE\_RESERVE; struct dquot \*\*dquots;+ struct dquot \*dquot;  if (!inode\_quota\_active(inode)) { if (reserve) {@@ -1705,27 +1708,26 @@ int \_\_dquot\_alloc\_space(struct inode \*inode, qsize\_t number, int flags) index = srcu\_read\_lock(&dquot\_srcu); spin\_lock(&inode->i\_lock); for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue; if (reserve) {- ret = dquot\_add\_space(dquots[cnt], 0, number, flags,- &warn[cnt]);+ ret = dquot\_add\_space(dquot, 0, number, flags, &warn[cnt]); } else {- ret = dquot\_add\_space(dquots[cnt], number, 0, flags,- &warn[cnt]);+ ret = dquot\_add\_space(dquot, number, 0, flags, &warn[cnt]); } if (ret) { /\* Back out changes we already did \*/ for (cnt--; cnt >= 0; cnt--) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);+ spin\_lock(&dquot->dq\_dqb\_lock); if (reserve)- dquot\_free\_reserved\_space(dquots[cnt],- number);+ dquot\_free\_reserved\_space(dquot, number); else- dquot\_decr\_space(dquots[cnt], number);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ dquot\_decr\_space(dquot, number);+ spin\_unlock(&dquot->dq\_dqb\_lock); } spin\_unlock(&inode->i\_lock); goto out\_flush\_warn;@@ -1756,6 +1758,7 @@ int dquot\_alloc\_inode(struct inode \*inode) int cnt, ret = 0, index; struct dquot\_warn warn[MAXQUOTAS]; struct dquot \* const \*dquots;+ struct dquot \*dquot;  if (!inode\_quota\_active(inode)) return 0;@@ -1766,17 +1769,19 @@ int dquot\_alloc\_inode(struct inode \*inode) index = srcu\_read\_lock(&dquot\_srcu); spin\_lock(&inode->i\_lock); for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- ret = dquot\_add\_inodes(dquots[cnt], 1, &warn[cnt]);+ ret = dquot\_add\_inodes(dquot, 1, &warn[cnt]); if (ret) { for (cnt--; cnt >= 0; cnt--) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue; /\* Back out changes we already did \*/- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);- dquot\_decr\_inodes(dquots[cnt], 1);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ spin\_lock(&dquot->dq\_dqb\_lock);+ dquot\_decr\_inodes(dquot, 1);+ spin\_unlock(&dquot->dq\_dqb\_lock); } goto warn\_put\_all; }@@ -1798,6 +1803,7 @@ EXPORT\_SYMBOL(dquot\_alloc\_inode); int dquot\_claim\_space\_nodirty(struct inode \*inode, qsize\_t number) { struct dquot \*\*dquots;+ struct dquot \*dquot; int cnt, index;  if (!inode\_quota\_active(inode)) {@@ -1813,9 +1819,8 @@ int dquot\_claim\_space\_nodirty(struct inode \*inode, qsize\_t number) spin\_lock(&inode->i\_lock); /\* Claim reserved quotas to allocated quotas \*/ for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (dquots[cnt]) {- struct dquot \*dquot = dquots[cnt];-+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (dquot) { spin\_lock(&dquot->dq\_dqb\_lock); if (WARN\_ON\_ONCE(dquot->dq\_dqb.dqb\_rsvspace < number)) number = dquot->dq\_dqb.dqb\_rsvspace;@@ -1840,6 +1845,7 @@ EXPORT\_SYMBOL(dquot\_claim\_space\_nodirty); void dquot\_reclaim\_space\_nodirty(struct inode \*inode, qsize\_t number) { struct dquot \*\*dquots;+ struct dquot \*dquot; int cnt, index;  if (!inode\_quota\_active(inode)) {@@ -1855,9 +1861,8 @@ void dquot\_reclaim\_space\_nodirty(struct inode \*inode, qsize\_t number) spin\_lock(&inode->i\_lock); /\* Claim reserved quotas to allocated quotas \*/ for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (dquots[cnt]) {- struct dquot \*dquot = dquots[cnt];-+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (dquot) { spin\_lock(&dquot->dq\_dqb\_lock); if (WARN\_ON\_ONCE(dquot->dq\_dqb.dqb\_curspace < number)) number = dquot->dq\_dqb.dqb\_curspace;@@ -1884,6 +1889,7 @@ void \_\_dquot\_free\_space(struct inode \*inode, qsize\_t number, int flags) unsigned int cnt; struct dquot\_warn warn[MAXQUOTAS]; struct dquot \*\*dquots;+ struct dquot \*dquot; int reserve = flags & DQUOT\_SPACE\_RESERVE, index;  if (!inode\_quota\_active(inode)) {@@ -1904,17 +1910,18 @@ void \_\_dquot\_free\_space(struct inode \*inode, qsize\_t number, int flags) int wtype;  warn[cnt].w\_type = QUOTA\_NL\_NOWARN;- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);- wtype = info\_bdq\_free(dquots[cnt], number);+ spin\_lock(&dquot->dq\_dqb\_lock);+ wtype = info\_bdq\_free(dquot, number); if (wtype != QUOTA\_NL\_NOWARN)- prepare\_warning(&warn[cnt], dquots[cnt], wtype);+ prepare\_warning(&warn[cnt], dquot, wtype); if (reserve)- dquot\_free\_reserved\_space(dquots[cnt], number);+ dquot\_free\_reserved\_space(dquot, number); else- dquot\_decr\_space(dquots[cnt], number);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ dquot\_decr\_space(dquot, number);+ spin\_unlock(&dquot->dq\_dqb\_lock); } if (reserve) \*inode\_reserved\_space(inode) -= number;@@ -1939,6 +1946,7 @@ void dquot\_free\_inode(struct inode \*inode) unsigned int cnt; struct dquot\_warn warn[MAXQUOTAS]; struct dquot \* const \*dquots;+ struct dquot \*dquot; int index;  if (!inode\_quota\_active(inode))@@ -1949,16 +1957,16 @@ void dquot\_free\_inode(struct inode \*inode) spin\_lock(&inode->i\_lock); for (cnt = 0; cnt < MAXQUOTAS; cnt++) { int wtype;- warn[cnt].w\_type = QUOTA\_NL\_NOWARN;- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);- wtype = info\_idq\_free(dquots[cnt], 1);+ spin\_lock(&dquot->dq\_dqb\_lock);+ wtype = info\_idq\_free(dquot, 1); if (wtype != QUOTA\_NL\_NOWARN)- prepare\_warning(&warn[cnt], dquots[cnt], wtype);- dquot\_decr\_inodes(dquots[cnt], 1);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ prepare\_warning(&warn[cnt], dquot, wtype);+ dquot\_decr\_inodes(dquot, 1);+ spin\_unlock(&dquot->dq\_dqb\_lock); } spin\_unlock(&inode->i\_lock); mark\_all\_dquot\_dirty(dquots);@@ -1985,7 +1993,7 @@ int \_\_dquot\_transfer(struct inode \*inode, struct dquot \*\*transfer\_to) qsize\_t rsv\_space = 0; qsize\_t inode\_usage = 1; struct dquot \*transfer\_from[MAXQUOTAS] = {};- int cnt, ret = 0;+ int cnt, index, ret = 0; char is\_valid[MAXQUOTAS] = {}; struct dquot\_warn warn\_to[MAXQUOTAS]; struct dquot\_warn warn\_from\_inodes[MAXQUOTAS];@@ -2074,8 +2082,16 @@ int \_\_dquot\_transfer(struct inode \*inode, struct dquot \*\*transfer\_to) spin\_unlock(&inode->i\_lock); spin\_unlock(&dq\_data\_lock); + /\*+ \* These arrays are local and we hold dquot references so we don't need+ \* the srcu protection but still take dquot\_srcu to avoid warning in+ \* mark\_all\_dquot\_dirty().+ \*/+ index = srcu\_read\_lock(&dquot\_srcu); mark\_all\_dquot\_dirty(transfer\_from); mark\_all\_dquot\_dirty(transfer\_to);+ srcu\_read\_unlock(&dquot\_srcu, index);+ flush\_warnings(warn\_to); flush\_warnings(warn\_from\_inodes); flush\_warnings(warn\_from\_space); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 03:28:24 +0000



=== Content from git.kernel.org_d27cddfc_20250111_032944.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=1ca72a3de915f87232c9a4cb9bebbd3af8ed3e25)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=1ca72a3de915f87232c9a4cb9bebbd3af8ed3e25)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=1ca72a3de915f87232c9a4cb9bebbd3af8ed3e25)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=1ca72a3de915f87232c9a4cb9bebbd3af8ed3e25)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Wang Jianjian <wangjianjian3@huawei.com> | 2024-02-02 16:18:52 +0800 |
| --- | --- | --- |
| committer | Sasha Levin <sashal@kernel.org> | 2024-03-26 18:21:26 -0400 |
| commit | [1ca72a3de915f87232c9a4cb9bebbd3af8ed3e25](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=1ca72a3de915f87232c9a4cb9bebbd3af8ed3e25) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=1ca72a3de915f87232c9a4cb9bebbd3af8ed3e25)) | |
| tree | [4bf134f3d7f227bc6e5b8099b62045fb5ad2bba1](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=1ca72a3de915f87232c9a4cb9bebbd3af8ed3e25) | |
| parent | [f2ddd8103f00af3fe6b892780aef7400942f62a2](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f2ddd8103f00af3fe6b892780aef7400942f62a2) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=1ca72a3de915f87232c9a4cb9bebbd3af8ed3e25&id2=f2ddd8103f00af3fe6b892780aef7400942f62a2)) | |
| download | [linux-1ca72a3de915f87232c9a4cb9bebbd3af8ed3e25.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-1ca72a3de915f87232c9a4cb9bebbd3af8ed3e25.tar.gz) | |

quota: Fix potential NULL pointer dereference[ Upstream commit d0aa72604fbd80c8aabb46eda00535ed35570f1f ]
Below race may cause NULL pointer dereference
P1 P2
dquot\_free\_inode quota\_off
drop\_dquot\_ref
remove\_dquot\_ref
dquots = i\_dquot(inode)
dquots = i\_dquot(inode)
srcu\_read\_lock
dquots[cnt]) != NULL (1)
dquots[type] = NULL (2)
spin\_lock(&dquots[cnt]->dq\_dqb\_lock) (3)
....
If dquot\_free\_inode(or other routines) checks inode's quota pointers (1)
before quota\_off sets it to NULL(2) and use it (3) after that, NULL pointer
dereference will be triggered.
So let's fix it by using a temporary pointer to avoid this issue.
Signed-off-by: Wang Jianjian <wangjianjian3@huawei.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Message-Id: <20240202081852.2514092-1-wangjianjian3@huawei.com>
Stable-dep-of: 179b8c97ebf6 ("quota: Fix rcu annotations of inode dquot pointers")
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=1ca72a3de915f87232c9a4cb9bebbd3af8ed3e25)

| -rw-r--r-- | [fs/quota/dquot.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/quota/dquot.c?id=1ca72a3de915f87232c9a4cb9bebbd3af8ed3e25) | 98 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 57 insertions, 41 deletions

| diff --git a/fs/quota/dquot.c b/fs/quota/dquot.cindex b7d8cd84df5764..041459526abcf4 100644--- a/[fs/quota/dquot.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/quota/dquot.c?id=f2ddd8103f00af3fe6b892780aef7400942f62a2)+++ b/[fs/quota/dquot.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/quota/dquot.c?id=1ca72a3de915f87232c9a4cb9bebbd3af8ed3e25)@@ -399,15 +399,17 @@ int dquot\_mark\_dquot\_dirty(struct dquot \*dquot) EXPORT\_SYMBOL(dquot\_mark\_dquot\_dirty);  /\* Dirtify all the dquots - this can block when journalling \*/-static inline int mark\_all\_dquot\_dirty(struct dquot \* const \*dquot)+static inline int mark\_all\_dquot\_dirty(struct dquot \* const \*dquots) { int ret, err, cnt;+ struct dquot \*dquot;  ret = err = 0; for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (dquot[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (dquot) /\* Even in case of error we have to continue \*/- ret = mark\_dquot\_dirty(dquot[cnt]);+ ret = mark\_dquot\_dirty(dquot); if (!err) err = ret; }@@ -1684,6 +1686,7 @@ int \_\_dquot\_alloc\_space(struct inode \*inode, qsize\_t number, int flags) struct dquot\_warn warn[MAXQUOTAS]; int reserve = flags & DQUOT\_SPACE\_RESERVE; struct dquot \*\*dquots;+ struct dquot \*dquot;  if (!inode\_quota\_active(inode)) { if (reserve) {@@ -1703,27 +1706,26 @@ int \_\_dquot\_alloc\_space(struct inode \*inode, qsize\_t number, int flags) index = srcu\_read\_lock(&dquot\_srcu); spin\_lock(&inode->i\_lock); for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue; if (reserve) {- ret = dquot\_add\_space(dquots[cnt], 0, number, flags,- &warn[cnt]);+ ret = dquot\_add\_space(dquot, 0, number, flags, &warn[cnt]); } else {- ret = dquot\_add\_space(dquots[cnt], number, 0, flags,- &warn[cnt]);+ ret = dquot\_add\_space(dquot, number, 0, flags, &warn[cnt]); } if (ret) { /\* Back out changes we already did \*/ for (cnt--; cnt >= 0; cnt--) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);+ spin\_lock(&dquot->dq\_dqb\_lock); if (reserve)- dquot\_free\_reserved\_space(dquots[cnt],- number);+ dquot\_free\_reserved\_space(dquot, number); else- dquot\_decr\_space(dquots[cnt], number);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ dquot\_decr\_space(dquot, number);+ spin\_unlock(&dquot->dq\_dqb\_lock); } spin\_unlock(&inode->i\_lock); goto out\_flush\_warn;@@ -1754,6 +1756,7 @@ int dquot\_alloc\_inode(struct inode \*inode) int cnt, ret = 0, index; struct dquot\_warn warn[MAXQUOTAS]; struct dquot \* const \*dquots;+ struct dquot \*dquot;  if (!inode\_quota\_active(inode)) return 0;@@ -1764,17 +1767,19 @@ int dquot\_alloc\_inode(struct inode \*inode) index = srcu\_read\_lock(&dquot\_srcu); spin\_lock(&inode->i\_lock); for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- ret = dquot\_add\_inodes(dquots[cnt], 1, &warn[cnt]);+ ret = dquot\_add\_inodes(dquot, 1, &warn[cnt]); if (ret) { for (cnt--; cnt >= 0; cnt--) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue; /\* Back out changes we already did \*/- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);- dquot\_decr\_inodes(dquots[cnt], 1);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ spin\_lock(&dquot->dq\_dqb\_lock);+ dquot\_decr\_inodes(dquot, 1);+ spin\_unlock(&dquot->dq\_dqb\_lock); } goto warn\_put\_all; }@@ -1796,6 +1801,7 @@ EXPORT\_SYMBOL(dquot\_alloc\_inode); int dquot\_claim\_space\_nodirty(struct inode \*inode, qsize\_t number) { struct dquot \*\*dquots;+ struct dquot \*dquot; int cnt, index;  if (!inode\_quota\_active(inode)) {@@ -1811,9 +1817,8 @@ int dquot\_claim\_space\_nodirty(struct inode \*inode, qsize\_t number) spin\_lock(&inode->i\_lock); /\* Claim reserved quotas to allocated quotas \*/ for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (dquots[cnt]) {- struct dquot \*dquot = dquots[cnt];-+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (dquot) { spin\_lock(&dquot->dq\_dqb\_lock); if (WARN\_ON\_ONCE(dquot->dq\_dqb.dqb\_rsvspace < number)) number = dquot->dq\_dqb.dqb\_rsvspace;@@ -1838,6 +1843,7 @@ EXPORT\_SYMBOL(dquot\_claim\_space\_nodirty); void dquot\_reclaim\_space\_nodirty(struct inode \*inode, qsize\_t number) { struct dquot \*\*dquots;+ struct dquot \*dquot; int cnt, index;  if (!inode\_quota\_active(inode)) {@@ -1853,9 +1859,8 @@ void dquot\_reclaim\_space\_nodirty(struct inode \*inode, qsize\_t number) spin\_lock(&inode->i\_lock); /\* Claim reserved quotas to allocated quotas \*/ for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (dquots[cnt]) {- struct dquot \*dquot = dquots[cnt];-+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (dquot) { spin\_lock(&dquot->dq\_dqb\_lock); if (WARN\_ON\_ONCE(dquot->dq\_dqb.dqb\_curspace < number)) number = dquot->dq\_dqb.dqb\_curspace;@@ -1882,6 +1887,7 @@ void \_\_dquot\_free\_space(struct inode \*inode, qsize\_t number, int flags) unsigned int cnt; struct dquot\_warn warn[MAXQUOTAS]; struct dquot \*\*dquots;+ struct dquot \*dquot; int reserve = flags & DQUOT\_SPACE\_RESERVE, index;  if (!inode\_quota\_active(inode)) {@@ -1902,17 +1908,18 @@ void \_\_dquot\_free\_space(struct inode \*inode, qsize\_t number, int flags) int wtype;  warn[cnt].w\_type = QUOTA\_NL\_NOWARN;- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);- wtype = info\_bdq\_free(dquots[cnt], number);+ spin\_lock(&dquot->dq\_dqb\_lock);+ wtype = info\_bdq\_free(dquot, number); if (wtype != QUOTA\_NL\_NOWARN)- prepare\_warning(&warn[cnt], dquots[cnt], wtype);+ prepare\_warning(&warn[cnt], dquot, wtype); if (reserve)- dquot\_free\_reserved\_space(dquots[cnt], number);+ dquot\_free\_reserved\_space(dquot, number); else- dquot\_decr\_space(dquots[cnt], number);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ dquot\_decr\_space(dquot, number);+ spin\_unlock(&dquot->dq\_dqb\_lock); } if (reserve) \*inode\_reserved\_space(inode) -= number;@@ -1937,6 +1944,7 @@ void dquot\_free\_inode(struct inode \*inode) unsigned int cnt; struct dquot\_warn warn[MAXQUOTAS]; struct dquot \* const \*dquots;+ struct dquot \*dquot; int index;  if (!inode\_quota\_active(inode))@@ -1947,16 +1955,16 @@ void dquot\_free\_inode(struct inode \*inode) spin\_lock(&inode->i\_lock); for (cnt = 0; cnt < MAXQUOTAS; cnt++) { int wtype;- warn[cnt].w\_type = QUOTA\_NL\_NOWARN;- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);- wtype = info\_idq\_free(dquots[cnt], 1);+ spin\_lock(&dquot->dq\_dqb\_lock);+ wtype = info\_idq\_free(dquot, 1); if (wtype != QUOTA\_NL\_NOWARN)- prepare\_warning(&warn[cnt], dquots[cnt], wtype);- dquot\_decr\_inodes(dquots[cnt], 1);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ prepare\_warning(&warn[cnt], dquot, wtype);+ dquot\_decr\_inodes(dquot, 1);+ spin\_unlock(&dquot->dq\_dqb\_lock); } spin\_unlock(&inode->i\_lock); mark\_all\_dquot\_dirty(dquots);@@ -1983,7 +1991,7 @@ int \_\_dquot\_transfer(struct inode \*inode, struct dquot \*\*transfer\_to) qsize\_t rsv\_space = 0; qsize\_t inode\_usage = 1; struct dquot \*transfer\_from[MAXQUOTAS] = {};- int cnt, ret = 0;+ int cnt, index, ret = 0; char is\_valid[MAXQUOTAS] = {}; struct dquot\_warn warn\_to[MAXQUOTAS]; struct dquot\_warn warn\_from\_inodes[MAXQUOTAS];@@ -2072,8 +2080,16 @@ int \_\_dquot\_transfer(struct inode \*inode, struct dquot \*\*transfer\_to) spin\_unlock(&inode->i\_lock); spin\_unlock(&dq\_data\_lock); + /\*+ \* These arrays are local and we hold dquot references so we don't need+ \* the srcu protection but still take dquot\_srcu to avoid warning in+ \* mark\_all\_dquot\_dirty().+ \*/+ index = srcu\_read\_lock(&dquot\_srcu); mark\_all\_dquot\_dirty(transfer\_from); mark\_all\_dquot\_dirty(transfer\_to);+ srcu\_read\_unlock(&dquot\_srcu, index);+ flush\_warnings(warn\_to); flush\_warnings(warn\_from\_inodes); flush\_warnings(warn\_from\_space); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 03:28:21 +0000



=== Content from git.kernel.org_3381ef48_20250111_032949.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=d0aa72604fbd80c8aabb46eda00535ed35570f1f)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d0aa72604fbd80c8aabb46eda00535ed35570f1f)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d0aa72604fbd80c8aabb46eda00535ed35570f1f)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d0aa72604fbd80c8aabb46eda00535ed35570f1f)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Wang Jianjian <wangjianjian3@huawei.com> | 2024-02-02 16:18:52 +0800 |
| --- | --- | --- |
| committer | Jan Kara <jack@suse.cz> | 2024-02-05 15:57:34 +0100 |
| commit | [d0aa72604fbd80c8aabb46eda00535ed35570f1f](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d0aa72604fbd80c8aabb46eda00535ed35570f1f) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=d0aa72604fbd80c8aabb46eda00535ed35570f1f)) | |
| tree | [8cccd6c0659e4113f3b21dc4f3900ee4b5d85a1e](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d0aa72604fbd80c8aabb46eda00535ed35570f1f) | |
| parent | [a1e1b2becab7c0b23f18b7999a3b48f76210d3a6](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a1e1b2becab7c0b23f18b7999a3b48f76210d3a6) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d0aa72604fbd80c8aabb46eda00535ed35570f1f&id2=a1e1b2becab7c0b23f18b7999a3b48f76210d3a6)) | |
| download | [linux-d0aa72604fbd80c8aabb46eda00535ed35570f1f.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-d0aa72604fbd80c8aabb46eda00535ed35570f1f.tar.gz) | |

quota: Fix potential NULL pointer dereferenceBelow race may cause NULL pointer dereference
P1 P2
dquot\_free\_inode quota\_off
drop\_dquot\_ref
remove\_dquot\_ref
dquots = i\_dquot(inode)
dquots = i\_dquot(inode)
srcu\_read\_lock
dquots[cnt]) != NULL (1)
dquots[type] = NULL (2)
spin\_lock(&dquots[cnt]->dq\_dqb\_lock) (3)
....
If dquot\_free\_inode(or other routines) checks inode's quota pointers (1)
before quota\_off sets it to NULL(2) and use it (3) after that, NULL pointer
dereference will be triggered.
So let's fix it by using a temporary pointer to avoid this issue.
Signed-off-by: Wang Jianjian <wangjianjian3@huawei.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Message-Id: <20240202081852.2514092-1-wangjianjian3@huawei.com>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d0aa72604fbd80c8aabb46eda00535ed35570f1f)

| -rw-r--r-- | [fs/quota/dquot.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/quota/dquot.c?id=d0aa72604fbd80c8aabb46eda00535ed35570f1f) | 98 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 57 insertions, 41 deletions

| diff --git a/fs/quota/dquot.c b/fs/quota/dquot.cindex 5f5481c43d9843..106800ce1252e5 100644--- a/[fs/quota/dquot.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/quota/dquot.c?id=a1e1b2becab7c0b23f18b7999a3b48f76210d3a6)+++ b/[fs/quota/dquot.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/quota/dquot.c?id=d0aa72604fbd80c8aabb46eda00535ed35570f1f)@@ -399,15 +399,17 @@ int dquot\_mark\_dquot\_dirty(struct dquot \*dquot) EXPORT\_SYMBOL(dquot\_mark\_dquot\_dirty);  /\* Dirtify all the dquots - this can block when journalling \*/-static inline int mark\_all\_dquot\_dirty(struct dquot \* const \*dquot)+static inline int mark\_all\_dquot\_dirty(struct dquot \* const \*dquots) { int ret, err, cnt;+ struct dquot \*dquot;  ret = err = 0; for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (dquot[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (dquot) /\* Even in case of error we have to continue \*/- ret = mark\_dquot\_dirty(dquot[cnt]);+ ret = mark\_dquot\_dirty(dquot); if (!err) err = ret; }@@ -1674,6 +1676,7 @@ int \_\_dquot\_alloc\_space(struct inode \*inode, qsize\_t number, int flags) struct dquot\_warn warn[MAXQUOTAS]; int reserve = flags & DQUOT\_SPACE\_RESERVE; struct dquot \*\*dquots;+ struct dquot \*dquot;  if (!inode\_quota\_active(inode)) { if (reserve) {@@ -1693,27 +1696,26 @@ int \_\_dquot\_alloc\_space(struct inode \*inode, qsize\_t number, int flags) index = srcu\_read\_lock(&dquot\_srcu); spin\_lock(&inode->i\_lock); for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue; if (reserve) {- ret = dquot\_add\_space(dquots[cnt], 0, number, flags,- &warn[cnt]);+ ret = dquot\_add\_space(dquot, 0, number, flags, &warn[cnt]); } else {- ret = dquot\_add\_space(dquots[cnt], number, 0, flags,- &warn[cnt]);+ ret = dquot\_add\_space(dquot, number, 0, flags, &warn[cnt]); } if (ret) { /\* Back out changes we already did \*/ for (cnt--; cnt >= 0; cnt--) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);+ spin\_lock(&dquot->dq\_dqb\_lock); if (reserve)- dquot\_free\_reserved\_space(dquots[cnt],- number);+ dquot\_free\_reserved\_space(dquot, number); else- dquot\_decr\_space(dquots[cnt], number);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ dquot\_decr\_space(dquot, number);+ spin\_unlock(&dquot->dq\_dqb\_lock); } spin\_unlock(&inode->i\_lock); goto out\_flush\_warn;@@ -1744,6 +1746,7 @@ int dquot\_alloc\_inode(struct inode \*inode) int cnt, ret = 0, index; struct dquot\_warn warn[MAXQUOTAS]; struct dquot \* const \*dquots;+ struct dquot \*dquot;  if (!inode\_quota\_active(inode)) return 0;@@ -1754,17 +1757,19 @@ int dquot\_alloc\_inode(struct inode \*inode) index = srcu\_read\_lock(&dquot\_srcu); spin\_lock(&inode->i\_lock); for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- ret = dquot\_add\_inodes(dquots[cnt], 1, &warn[cnt]);+ ret = dquot\_add\_inodes(dquot, 1, &warn[cnt]); if (ret) { for (cnt--; cnt >= 0; cnt--) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue; /\* Back out changes we already did \*/- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);- dquot\_decr\_inodes(dquots[cnt], 1);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ spin\_lock(&dquot->dq\_dqb\_lock);+ dquot\_decr\_inodes(dquot, 1);+ spin\_unlock(&dquot->dq\_dqb\_lock); } goto warn\_put\_all; }@@ -1786,6 +1791,7 @@ EXPORT\_SYMBOL(dquot\_alloc\_inode); void dquot\_claim\_space\_nodirty(struct inode \*inode, qsize\_t number) { struct dquot \*\*dquots;+ struct dquot \*dquot; int cnt, index;  if (!inode\_quota\_active(inode)) {@@ -1801,9 +1807,8 @@ void dquot\_claim\_space\_nodirty(struct inode \*inode, qsize\_t number) spin\_lock(&inode->i\_lock); /\* Claim reserved quotas to allocated quotas \*/ for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (dquots[cnt]) {- struct dquot \*dquot = dquots[cnt];-+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (dquot) { spin\_lock(&dquot->dq\_dqb\_lock); if (WARN\_ON\_ONCE(dquot->dq\_dqb.dqb\_rsvspace < number)) number = dquot->dq\_dqb.dqb\_rsvspace;@@ -1828,6 +1833,7 @@ EXPORT\_SYMBOL(dquot\_claim\_space\_nodirty); void dquot\_reclaim\_space\_nodirty(struct inode \*inode, qsize\_t number) { struct dquot \*\*dquots;+ struct dquot \*dquot; int cnt, index;  if (!inode\_quota\_active(inode)) {@@ -1843,9 +1849,8 @@ void dquot\_reclaim\_space\_nodirty(struct inode \*inode, qsize\_t number) spin\_lock(&inode->i\_lock); /\* Claim reserved quotas to allocated quotas \*/ for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (dquots[cnt]) {- struct dquot \*dquot = dquots[cnt];-+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (dquot) { spin\_lock(&dquot->dq\_dqb\_lock); if (WARN\_ON\_ONCE(dquot->dq\_dqb.dqb\_curspace < number)) number = dquot->dq\_dqb.dqb\_curspace;@@ -1872,6 +1877,7 @@ void \_\_dquot\_free\_space(struct inode \*inode, qsize\_t number, int flags) unsigned int cnt; struct dquot\_warn warn[MAXQUOTAS]; struct dquot \*\*dquots;+ struct dquot \*dquot; int reserve = flags & DQUOT\_SPACE\_RESERVE, index;  if (!inode\_quota\_active(inode)) {@@ -1892,17 +1898,18 @@ void \_\_dquot\_free\_space(struct inode \*inode, qsize\_t number, int flags) int wtype;  warn[cnt].w\_type = QUOTA\_NL\_NOWARN;- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);- wtype = info\_bdq\_free(dquots[cnt], number);+ spin\_lock(&dquot->dq\_dqb\_lock);+ wtype = info\_bdq\_free(dquot, number); if (wtype != QUOTA\_NL\_NOWARN)- prepare\_warning(&warn[cnt], dquots[cnt], wtype);+ prepare\_warning(&warn[cnt], dquot, wtype); if (reserve)- dquot\_free\_reserved\_space(dquots[cnt], number);+ dquot\_free\_reserved\_space(dquot, number); else- dquot\_decr\_space(dquots[cnt], number);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ dquot\_decr\_space(dquot, number);+ spin\_unlock(&dquot->dq\_dqb\_lock); } if (reserve) \*inode\_reserved\_space(inode) -= number;@@ -1927,6 +1934,7 @@ void dquot\_free\_inode(struct inode \*inode) unsigned int cnt; struct dquot\_warn warn[MAXQUOTAS]; struct dquot \* const \*dquots;+ struct dquot \*dquot; int index;  if (!inode\_quota\_active(inode))@@ -1937,16 +1945,16 @@ void dquot\_free\_inode(struct inode \*inode) spin\_lock(&inode->i\_lock); for (cnt = 0; cnt < MAXQUOTAS; cnt++) { int wtype;- warn[cnt].w\_type = QUOTA\_NL\_NOWARN;- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);- wtype = info\_idq\_free(dquots[cnt], 1);+ spin\_lock(&dquot->dq\_dqb\_lock);+ wtype = info\_idq\_free(dquot, 1); if (wtype != QUOTA\_NL\_NOWARN)- prepare\_warning(&warn[cnt], dquots[cnt], wtype);- dquot\_decr\_inodes(dquots[cnt], 1);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ prepare\_warning(&warn[cnt], dquot, wtype);+ dquot\_decr\_inodes(dquot, 1);+ spin\_unlock(&dquot->dq\_dqb\_lock); } spin\_unlock(&inode->i\_lock); mark\_all\_dquot\_dirty(dquots);@@ -1973,7 +1981,7 @@ int \_\_dquot\_transfer(struct inode \*inode, struct dquot \*\*transfer\_to) qsize\_t rsv\_space = 0; qsize\_t inode\_usage = 1; struct dquot \*transfer\_from[MAXQUOTAS] = {};- int cnt, ret = 0;+ int cnt, index, ret = 0; char is\_valid[MAXQUOTAS] = {}; struct dquot\_warn warn\_to[MAXQUOTAS]; struct dquot\_warn warn\_from\_inodes[MAXQUOTAS];@@ -2062,8 +2070,16 @@ int \_\_dquot\_transfer(struct inode \*inode, struct dquot \*\*transfer\_to) spin\_unlock(&inode->i\_lock); spin\_unlock(&dq\_data\_lock); + /\*+ \* These arrays are local and we hold dquot references so we don't need+ \* the srcu protection but still take dquot\_srcu to avoid warning in+ \* mark\_all\_dquot\_dirty().+ \*/+ index = srcu\_read\_lock(&dquot\_srcu); mark\_all\_dquot\_dirty(transfer\_from); mark\_all\_dquot\_dirty(transfer\_to);+ srcu\_read\_unlock(&dquot\_srcu, index);+ flush\_warnings(warn\_to); flush\_warnings(warn\_from\_inodes); flush\_warnings(warn\_from\_space); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 03:28:26 +0000



=== Content from git.kernel.org_e375c9b3_20250111_032945.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=40a673b4b07efd6f74ff3ab60f38b26aa91ee5d5)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=40a673b4b07efd6f74ff3ab60f38b26aa91ee5d5)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=40a673b4b07efd6f74ff3ab60f38b26aa91ee5d5)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=40a673b4b07efd6f74ff3ab60f38b26aa91ee5d5)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Wang Jianjian <wangjianjian3@huawei.com> | 2024-02-02 16:18:52 +0800 |
| --- | --- | --- |
| committer | Sasha Levin <sashal@kernel.org> | 2024-03-26 18:19:46 -0400 |
| commit | [40a673b4b07efd6f74ff3ab60f38b26aa91ee5d5](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=40a673b4b07efd6f74ff3ab60f38b26aa91ee5d5) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=40a673b4b07efd6f74ff3ab60f38b26aa91ee5d5)) | |
| tree | [d1c77518ff79a4f6eb629f2adf5b4a446795e906](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=40a673b4b07efd6f74ff3ab60f38b26aa91ee5d5) | |
| parent | [cfa7009c18af654fc2dc6566b23b8907414bd570](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=cfa7009c18af654fc2dc6566b23b8907414bd570) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=40a673b4b07efd6f74ff3ab60f38b26aa91ee5d5&id2=cfa7009c18af654fc2dc6566b23b8907414bd570)) | |
| download | [linux-40a673b4b07efd6f74ff3ab60f38b26aa91ee5d5.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-40a673b4b07efd6f74ff3ab60f38b26aa91ee5d5.tar.gz) | |

quota: Fix potential NULL pointer dereference[ Upstream commit d0aa72604fbd80c8aabb46eda00535ed35570f1f ]
Below race may cause NULL pointer dereference
P1 P2
dquot\_free\_inode quota\_off
drop\_dquot\_ref
remove\_dquot\_ref
dquots = i\_dquot(inode)
dquots = i\_dquot(inode)
srcu\_read\_lock
dquots[cnt]) != NULL (1)
dquots[type] = NULL (2)
spin\_lock(&dquots[cnt]->dq\_dqb\_lock) (3)
....
If dquot\_free\_inode(or other routines) checks inode's quota pointers (1)
before quota\_off sets it to NULL(2) and use it (3) after that, NULL pointer
dereference will be triggered.
So let's fix it by using a temporary pointer to avoid this issue.
Signed-off-by: Wang Jianjian <wangjianjian3@huawei.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Message-Id: <20240202081852.2514092-1-wangjianjian3@huawei.com>
Stable-dep-of: 179b8c97ebf6 ("quota: Fix rcu annotations of inode dquot pointers")
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=40a673b4b07efd6f74ff3ab60f38b26aa91ee5d5)

| -rw-r--r-- | [fs/quota/dquot.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/quota/dquot.c?id=40a673b4b07efd6f74ff3ab60f38b26aa91ee5d5) | 98 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 57 insertions, 41 deletions

| diff --git a/fs/quota/dquot.c b/fs/quota/dquot.cindex 023b91b4e1f0ab..9707aa34f52e7a 100644--- a/[fs/quota/dquot.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/quota/dquot.c?id=cfa7009c18af654fc2dc6566b23b8907414bd570)+++ b/[fs/quota/dquot.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/quota/dquot.c?id=40a673b4b07efd6f74ff3ab60f38b26aa91ee5d5)@@ -399,15 +399,17 @@ int dquot\_mark\_dquot\_dirty(struct dquot \*dquot) EXPORT\_SYMBOL(dquot\_mark\_dquot\_dirty);  /\* Dirtify all the dquots - this can block when journalling \*/-static inline int mark\_all\_dquot\_dirty(struct dquot \* const \*dquot)+static inline int mark\_all\_dquot\_dirty(struct dquot \* const \*dquots) { int ret, err, cnt;+ struct dquot \*dquot;  ret = err = 0; for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (dquot[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (dquot) /\* Even in case of error we have to continue \*/- ret = mark\_dquot\_dirty(dquot[cnt]);+ ret = mark\_dquot\_dirty(dquot); if (!err) err = ret; }@@ -1684,6 +1686,7 @@ int \_\_dquot\_alloc\_space(struct inode \*inode, qsize\_t number, int flags) struct dquot\_warn warn[MAXQUOTAS]; int reserve = flags & DQUOT\_SPACE\_RESERVE; struct dquot \*\*dquots;+ struct dquot \*dquot;  if (!inode\_quota\_active(inode)) { if (reserve) {@@ -1703,27 +1706,26 @@ int \_\_dquot\_alloc\_space(struct inode \*inode, qsize\_t number, int flags) index = srcu\_read\_lock(&dquot\_srcu); spin\_lock(&inode->i\_lock); for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue; if (reserve) {- ret = dquot\_add\_space(dquots[cnt], 0, number, flags,- &warn[cnt]);+ ret = dquot\_add\_space(dquot, 0, number, flags, &warn[cnt]); } else {- ret = dquot\_add\_space(dquots[cnt], number, 0, flags,- &warn[cnt]);+ ret = dquot\_add\_space(dquot, number, 0, flags, &warn[cnt]); } if (ret) { /\* Back out changes we already did \*/ for (cnt--; cnt >= 0; cnt--) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);+ spin\_lock(&dquot->dq\_dqb\_lock); if (reserve)- dquot\_free\_reserved\_space(dquots[cnt],- number);+ dquot\_free\_reserved\_space(dquot, number); else- dquot\_decr\_space(dquots[cnt], number);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ dquot\_decr\_space(dquot, number);+ spin\_unlock(&dquot->dq\_dqb\_lock); } spin\_unlock(&inode->i\_lock); goto out\_flush\_warn;@@ -1754,6 +1756,7 @@ int dquot\_alloc\_inode(struct inode \*inode) int cnt, ret = 0, index; struct dquot\_warn warn[MAXQUOTAS]; struct dquot \* const \*dquots;+ struct dquot \*dquot;  if (!inode\_quota\_active(inode)) return 0;@@ -1764,17 +1767,19 @@ int dquot\_alloc\_inode(struct inode \*inode) index = srcu\_read\_lock(&dquot\_srcu); spin\_lock(&inode->i\_lock); for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- ret = dquot\_add\_inodes(dquots[cnt], 1, &warn[cnt]);+ ret = dquot\_add\_inodes(dquot, 1, &warn[cnt]); if (ret) { for (cnt--; cnt >= 0; cnt--) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue; /\* Back out changes we already did \*/- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);- dquot\_decr\_inodes(dquots[cnt], 1);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ spin\_lock(&dquot->dq\_dqb\_lock);+ dquot\_decr\_inodes(dquot, 1);+ spin\_unlock(&dquot->dq\_dqb\_lock); } goto warn\_put\_all; }@@ -1796,6 +1801,7 @@ EXPORT\_SYMBOL(dquot\_alloc\_inode); int dquot\_claim\_space\_nodirty(struct inode \*inode, qsize\_t number) { struct dquot \*\*dquots;+ struct dquot \*dquot; int cnt, index;  if (!inode\_quota\_active(inode)) {@@ -1811,9 +1817,8 @@ int dquot\_claim\_space\_nodirty(struct inode \*inode, qsize\_t number) spin\_lock(&inode->i\_lock); /\* Claim reserved quotas to allocated quotas \*/ for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (dquots[cnt]) {- struct dquot \*dquot = dquots[cnt];-+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (dquot) { spin\_lock(&dquot->dq\_dqb\_lock); if (WARN\_ON\_ONCE(dquot->dq\_dqb.dqb\_rsvspace < number)) number = dquot->dq\_dqb.dqb\_rsvspace;@@ -1838,6 +1843,7 @@ EXPORT\_SYMBOL(dquot\_claim\_space\_nodirty); void dquot\_reclaim\_space\_nodirty(struct inode \*inode, qsize\_t number) { struct dquot \*\*dquots;+ struct dquot \*dquot; int cnt, index;  if (!inode\_quota\_active(inode)) {@@ -1853,9 +1859,8 @@ void dquot\_reclaim\_space\_nodirty(struct inode \*inode, qsize\_t number) spin\_lock(&inode->i\_lock); /\* Claim reserved quotas to allocated quotas \*/ for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (dquots[cnt]) {- struct dquot \*dquot = dquots[cnt];-+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (dquot) { spin\_lock(&dquot->dq\_dqb\_lock); if (WARN\_ON\_ONCE(dquot->dq\_dqb.dqb\_curspace < number)) number = dquot->dq\_dqb.dqb\_curspace;@@ -1882,6 +1887,7 @@ void \_\_dquot\_free\_space(struct inode \*inode, qsize\_t number, int flags) unsigned int cnt; struct dquot\_warn warn[MAXQUOTAS]; struct dquot \*\*dquots;+ struct dquot \*dquot; int reserve = flags & DQUOT\_SPACE\_RESERVE, index;  if (!inode\_quota\_active(inode)) {@@ -1902,17 +1908,18 @@ void \_\_dquot\_free\_space(struct inode \*inode, qsize\_t number, int flags) int wtype;  warn[cnt].w\_type = QUOTA\_NL\_NOWARN;- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);- wtype = info\_bdq\_free(dquots[cnt], number);+ spin\_lock(&dquot->dq\_dqb\_lock);+ wtype = info\_bdq\_free(dquot, number); if (wtype != QUOTA\_NL\_NOWARN)- prepare\_warning(&warn[cnt], dquots[cnt], wtype);+ prepare\_warning(&warn[cnt], dquot, wtype); if (reserve)- dquot\_free\_reserved\_space(dquots[cnt], number);+ dquot\_free\_reserved\_space(dquot, number); else- dquot\_decr\_space(dquots[cnt], number);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ dquot\_decr\_space(dquot, number);+ spin\_unlock(&dquot->dq\_dqb\_lock); } if (reserve) \*inode\_reserved\_space(inode) -= number;@@ -1937,6 +1944,7 @@ void dquot\_free\_inode(struct inode \*inode) unsigned int cnt; struct dquot\_warn warn[MAXQUOTAS]; struct dquot \* const \*dquots;+ struct dquot \*dquot; int index;  if (!inode\_quota\_active(inode))@@ -1947,16 +1955,16 @@ void dquot\_free\_inode(struct inode \*inode) spin\_lock(&inode->i\_lock); for (cnt = 0; cnt < MAXQUOTAS; cnt++) { int wtype;- warn[cnt].w\_type = QUOTA\_NL\_NOWARN;- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);- wtype = info\_idq\_free(dquots[cnt], 1);+ spin\_lock(&dquot->dq\_dqb\_lock);+ wtype = info\_idq\_free(dquot, 1); if (wtype != QUOTA\_NL\_NOWARN)- prepare\_warning(&warn[cnt], dquots[cnt], wtype);- dquot\_decr\_inodes(dquots[cnt], 1);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ prepare\_warning(&warn[cnt], dquot, wtype);+ dquot\_decr\_inodes(dquot, 1);+ spin\_unlock(&dquot->dq\_dqb\_lock); } spin\_unlock(&inode->i\_lock); mark\_all\_dquot\_dirty(dquots);@@ -1983,7 +1991,7 @@ int \_\_dquot\_transfer(struct inode \*inode, struct dquot \*\*transfer\_to) qsize\_t rsv\_space = 0; qsize\_t inode\_usage = 1; struct dquot \*transfer\_from[MAXQUOTAS] = {};- int cnt, ret = 0;+ int cnt, index, ret = 0; char is\_valid[MAXQUOTAS] = {}; struct dquot\_warn warn\_to[MAXQUOTAS]; struct dquot\_warn warn\_from\_inodes[MAXQUOTAS];@@ -2072,8 +2080,16 @@ int \_\_dquot\_transfer(struct inode \*inode, struct dquot \*\*transfer\_to) spin\_unlock(&inode->i\_lock); spin\_unlock(&dq\_data\_lock); + /\*+ \* These arrays are local and we hold dquot references so we don't need+ \* the srcu protection but still take dquot\_srcu to avoid warning in+ \* mark\_all\_dquot\_dirty().+ \*/+ index = srcu\_read\_lock(&dquot\_srcu); mark\_all\_dquot\_dirty(transfer\_from); mark\_all\_dquot\_dirty(transfer\_to);+ srcu\_read\_unlock(&dquot\_srcu, index);+ flush\_warnings(warn\_to); flush\_warnings(warn\_from\_inodes); flush\_warnings(warn\_from\_space); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 03:28:22 +0000



=== Content from git.kernel.org_728c8600_20250111_032949.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=8514899c1a4edf802f03c408db901063aa3f05a1)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=8514899c1a4edf802f03c408db901063aa3f05a1)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=8514899c1a4edf802f03c408db901063aa3f05a1)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=8514899c1a4edf802f03c408db901063aa3f05a1)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Wang Jianjian <wangjianjian3@huawei.com> | 2024-02-02 16:18:52 +0800 |
| --- | --- | --- |
| committer | Sasha Levin <sashal@kernel.org> | 2024-03-26 18:22:39 -0400 |
| commit | [8514899c1a4edf802f03c408db901063aa3f05a1](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=8514899c1a4edf802f03c408db901063aa3f05a1) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=8514899c1a4edf802f03c408db901063aa3f05a1)) | |
| tree | [4e1b71e11e532eb66d13cb2552d8a9ef82ec3bc9](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=8514899c1a4edf802f03c408db901063aa3f05a1) | |
| parent | [248699a705f31211c0d7cc9e0d79cbbabbc9c791](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=248699a705f31211c0d7cc9e0d79cbbabbc9c791) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=8514899c1a4edf802f03c408db901063aa3f05a1&id2=248699a705f31211c0d7cc9e0d79cbbabbc9c791)) | |
| download | [linux-8514899c1a4edf802f03c408db901063aa3f05a1.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-8514899c1a4edf802f03c408db901063aa3f05a1.tar.gz) | |

quota: Fix potential NULL pointer dereference[ Upstream commit d0aa72604fbd80c8aabb46eda00535ed35570f1f ]
Below race may cause NULL pointer dereference
P1 P2
dquot\_free\_inode quota\_off
drop\_dquot\_ref
remove\_dquot\_ref
dquots = i\_dquot(inode)
dquots = i\_dquot(inode)
srcu\_read\_lock
dquots[cnt]) != NULL (1)
dquots[type] = NULL (2)
spin\_lock(&dquots[cnt]->dq\_dqb\_lock) (3)
....
If dquot\_free\_inode(or other routines) checks inode's quota pointers (1)
before quota\_off sets it to NULL(2) and use it (3) after that, NULL pointer
dereference will be triggered.
So let's fix it by using a temporary pointer to avoid this issue.
Signed-off-by: Wang Jianjian <wangjianjian3@huawei.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Message-Id: <20240202081852.2514092-1-wangjianjian3@huawei.com>
Stable-dep-of: 179b8c97ebf6 ("quota: Fix rcu annotations of inode dquot pointers")
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=8514899c1a4edf802f03c408db901063aa3f05a1)

| -rw-r--r-- | [fs/quota/dquot.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/quota/dquot.c?id=8514899c1a4edf802f03c408db901063aa3f05a1) | 98 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 57 insertions, 41 deletions

| diff --git a/fs/quota/dquot.c b/fs/quota/dquot.cindex dd9c381b874fd2..133ca865de9763 100644--- a/[fs/quota/dquot.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/quota/dquot.c?id=248699a705f31211c0d7cc9e0d79cbbabbc9c791)+++ b/[fs/quota/dquot.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/quota/dquot.c?id=8514899c1a4edf802f03c408db901063aa3f05a1)@@ -399,15 +399,17 @@ int dquot\_mark\_dquot\_dirty(struct dquot \*dquot) EXPORT\_SYMBOL(dquot\_mark\_dquot\_dirty);  /\* Dirtify all the dquots - this can block when journalling \*/-static inline int mark\_all\_dquot\_dirty(struct dquot \* const \*dquot)+static inline int mark\_all\_dquot\_dirty(struct dquot \* const \*dquots) { int ret, err, cnt;+ struct dquot \*dquot;  ret = err = 0; for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (dquot[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (dquot) /\* Even in case of error we have to continue \*/- ret = mark\_dquot\_dirty(dquot[cnt]);+ ret = mark\_dquot\_dirty(dquot); if (!err) err = ret; }@@ -1674,6 +1676,7 @@ int \_\_dquot\_alloc\_space(struct inode \*inode, qsize\_t number, int flags) struct dquot\_warn warn[MAXQUOTAS]; int reserve = flags & DQUOT\_SPACE\_RESERVE; struct dquot \*\*dquots;+ struct dquot \*dquot;  if (!inode\_quota\_active(inode)) { if (reserve) {@@ -1693,27 +1696,26 @@ int \_\_dquot\_alloc\_space(struct inode \*inode, qsize\_t number, int flags) index = srcu\_read\_lock(&dquot\_srcu); spin\_lock(&inode->i\_lock); for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue; if (reserve) {- ret = dquot\_add\_space(dquots[cnt], 0, number, flags,- &warn[cnt]);+ ret = dquot\_add\_space(dquot, 0, number, flags, &warn[cnt]); } else {- ret = dquot\_add\_space(dquots[cnt], number, 0, flags,- &warn[cnt]);+ ret = dquot\_add\_space(dquot, number, 0, flags, &warn[cnt]); } if (ret) { /\* Back out changes we already did \*/ for (cnt--; cnt >= 0; cnt--) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);+ spin\_lock(&dquot->dq\_dqb\_lock); if (reserve)- dquot\_free\_reserved\_space(dquots[cnt],- number);+ dquot\_free\_reserved\_space(dquot, number); else- dquot\_decr\_space(dquots[cnt], number);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ dquot\_decr\_space(dquot, number);+ spin\_unlock(&dquot->dq\_dqb\_lock); } spin\_unlock(&inode->i\_lock); goto out\_flush\_warn;@@ -1744,6 +1746,7 @@ int dquot\_alloc\_inode(struct inode \*inode) int cnt, ret = 0, index; struct dquot\_warn warn[MAXQUOTAS]; struct dquot \* const \*dquots;+ struct dquot \*dquot;  if (!inode\_quota\_active(inode)) return 0;@@ -1754,17 +1757,19 @@ int dquot\_alloc\_inode(struct inode \*inode) index = srcu\_read\_lock(&dquot\_srcu); spin\_lock(&inode->i\_lock); for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- ret = dquot\_add\_inodes(dquots[cnt], 1, &warn[cnt]);+ ret = dquot\_add\_inodes(dquot, 1, &warn[cnt]); if (ret) { for (cnt--; cnt >= 0; cnt--) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue; /\* Back out changes we already did \*/- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);- dquot\_decr\_inodes(dquots[cnt], 1);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ spin\_lock(&dquot->dq\_dqb\_lock);+ dquot\_decr\_inodes(dquot, 1);+ spin\_unlock(&dquot->dq\_dqb\_lock); } goto warn\_put\_all; }@@ -1786,6 +1791,7 @@ EXPORT\_SYMBOL(dquot\_alloc\_inode); int dquot\_claim\_space\_nodirty(struct inode \*inode, qsize\_t number) { struct dquot \*\*dquots;+ struct dquot \*dquot; int cnt, index;  if (!inode\_quota\_active(inode)) {@@ -1801,9 +1807,8 @@ int dquot\_claim\_space\_nodirty(struct inode \*inode, qsize\_t number) spin\_lock(&inode->i\_lock); /\* Claim reserved quotas to allocated quotas \*/ for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (dquots[cnt]) {- struct dquot \*dquot = dquots[cnt];-+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (dquot) { spin\_lock(&dquot->dq\_dqb\_lock); if (WARN\_ON\_ONCE(dquot->dq\_dqb.dqb\_rsvspace < number)) number = dquot->dq\_dqb.dqb\_rsvspace;@@ -1828,6 +1833,7 @@ EXPORT\_SYMBOL(dquot\_claim\_space\_nodirty); void dquot\_reclaim\_space\_nodirty(struct inode \*inode, qsize\_t number) { struct dquot \*\*dquots;+ struct dquot \*dquot; int cnt, index;  if (!inode\_quota\_active(inode)) {@@ -1843,9 +1849,8 @@ void dquot\_reclaim\_space\_nodirty(struct inode \*inode, qsize\_t number) spin\_lock(&inode->i\_lock); /\* Claim reserved quotas to allocated quotas \*/ for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (dquots[cnt]) {- struct dquot \*dquot = dquots[cnt];-+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (dquot) { spin\_lock(&dquot->dq\_dqb\_lock); if (WARN\_ON\_ONCE(dquot->dq\_dqb.dqb\_curspace < number)) number = dquot->dq\_dqb.dqb\_curspace;@@ -1872,6 +1877,7 @@ void \_\_dquot\_free\_space(struct inode \*inode, qsize\_t number, int flags) unsigned int cnt; struct dquot\_warn warn[MAXQUOTAS]; struct dquot \*\*dquots;+ struct dquot \*dquot; int reserve = flags & DQUOT\_SPACE\_RESERVE, index;  if (!inode\_quota\_active(inode)) {@@ -1892,17 +1898,18 @@ void \_\_dquot\_free\_space(struct inode \*inode, qsize\_t number, int flags) int wtype;  warn[cnt].w\_type = QUOTA\_NL\_NOWARN;- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);- wtype = info\_bdq\_free(dquots[cnt], number);+ spin\_lock(&dquot->dq\_dqb\_lock);+ wtype = info\_bdq\_free(dquot, number); if (wtype != QUOTA\_NL\_NOWARN)- prepare\_warning(&warn[cnt], dquots[cnt], wtype);+ prepare\_warning(&warn[cnt], dquot, wtype); if (reserve)- dquot\_free\_reserved\_space(dquots[cnt], number);+ dquot\_free\_reserved\_space(dquot, number); else- dquot\_decr\_space(dquots[cnt], number);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ dquot\_decr\_space(dquot, number);+ spin\_unlock(&dquot->dq\_dqb\_lock); } if (reserve) \*inode\_reserved\_space(inode) -= number;@@ -1927,6 +1934,7 @@ void dquot\_free\_inode(struct inode \*inode) unsigned int cnt; struct dquot\_warn warn[MAXQUOTAS]; struct dquot \* const \*dquots;+ struct dquot \*dquot; int index;  if (!inode\_quota\_active(inode))@@ -1937,16 +1945,16 @@ void dquot\_free\_inode(struct inode \*inode) spin\_lock(&inode->i\_lock); for (cnt = 0; cnt < MAXQUOTAS; cnt++) { int wtype;- warn[cnt].w\_type = QUOTA\_NL\_NOWARN;- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);- wtype = info\_idq\_free(dquots[cnt], 1);+ spin\_lock(&dquot->dq\_dqb\_lock);+ wtype = info\_idq\_free(dquot, 1); if (wtype != QUOTA\_NL\_NOWARN)- prepare\_warning(&warn[cnt], dquots[cnt], wtype);- dquot\_decr\_inodes(dquots[cnt], 1);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ prepare\_warning(&warn[cnt], dquot, wtype);+ dquot\_decr\_inodes(dquot, 1);+ spin\_unlock(&dquot->dq\_dqb\_lock); } spin\_unlock(&inode->i\_lock); mark\_all\_dquot\_dirty(dquots);@@ -1973,7 +1981,7 @@ int \_\_dquot\_transfer(struct inode \*inode, struct dquot \*\*transfer\_to) qsize\_t rsv\_space = 0; qsize\_t inode\_usage = 1; struct dquot \*transfer\_from[MAXQUOTAS] = {};- int cnt, ret = 0;+ int cnt, index, ret = 0; char is\_valid[MAXQUOTAS] = {}; struct dquot\_warn warn\_to[MAXQUOTAS]; struct dquot\_warn warn\_from\_inodes[MAXQUOTAS];@@ -2062,8 +2070,16 @@ int \_\_dquot\_transfer(struct inode \*inode, struct dquot \*\*transfer\_to) spin\_unlock(&inode->i\_lock); spin\_unlock(&dq\_data\_lock); + /\*+ \* These arrays are local and we hold dquot references so we don't need+ \* the srcu protection but still take dquot\_srcu to avoid warning in+ \* mark\_all\_dquot\_dirty().+ \*/+ index = srcu\_read\_lock(&dquot\_srcu); mark\_all\_dquot\_dirty(transfer\_from); mark\_all\_dquot\_dirty(transfer\_to);+ srcu\_read\_unlock(&dquot\_srcu, index);+ flush\_warnings(warn\_to); flush\_warnings(warn\_from\_inodes); flush\_warnings(warn\_from\_space); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 03:28:26 +0000



=== Content from git.kernel.org_d2fc1ca8_20250111_032947.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=6afc9f4434fa8063aa768c2bf5bf98583aee0877)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=6afc9f4434fa8063aa768c2bf5bf98583aee0877)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6afc9f4434fa8063aa768c2bf5bf98583aee0877)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=6afc9f4434fa8063aa768c2bf5bf98583aee0877)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Wang Jianjian <wangjianjian3@huawei.com> | 2024-02-02 16:18:52 +0800 |
| --- | --- | --- |
| committer | Sasha Levin <sashal@kernel.org> | 2024-03-26 18:17:03 -0400 |
| commit | [6afc9f4434fa8063aa768c2bf5bf98583aee0877](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6afc9f4434fa8063aa768c2bf5bf98583aee0877) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=6afc9f4434fa8063aa768c2bf5bf98583aee0877)) | |
| tree | [60188dd39cb853efae65fa4832646da042b0c1b8](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=6afc9f4434fa8063aa768c2bf5bf98583aee0877) | |
| parent | [29635d12291023b249834bce0a4756f329ee15a5](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=29635d12291023b249834bce0a4756f329ee15a5) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=6afc9f4434fa8063aa768c2bf5bf98583aee0877&id2=29635d12291023b249834bce0a4756f329ee15a5)) | |
| download | [linux-6afc9f4434fa8063aa768c2bf5bf98583aee0877.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-6afc9f4434fa8063aa768c2bf5bf98583aee0877.tar.gz) | |

quota: Fix potential NULL pointer dereference[ Upstream commit d0aa72604fbd80c8aabb46eda00535ed35570f1f ]
Below race may cause NULL pointer dereference
P1 P2
dquot\_free\_inode quota\_off
drop\_dquot\_ref
remove\_dquot\_ref
dquots = i\_dquot(inode)
dquots = i\_dquot(inode)
srcu\_read\_lock
dquots[cnt]) != NULL (1)
dquots[type] = NULL (2)
spin\_lock(&dquots[cnt]->dq\_dqb\_lock) (3)
....
If dquot\_free\_inode(or other routines) checks inode's quota pointers (1)
before quota\_off sets it to NULL(2) and use it (3) after that, NULL pointer
dereference will be triggered.
So let's fix it by using a temporary pointer to avoid this issue.
Signed-off-by: Wang Jianjian <wangjianjian3@huawei.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Message-Id: <20240202081852.2514092-1-wangjianjian3@huawei.com>
Stable-dep-of: 179b8c97ebf6 ("quota: Fix rcu annotations of inode dquot pointers")
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=6afc9f4434fa8063aa768c2bf5bf98583aee0877)

| -rw-r--r-- | [fs/quota/dquot.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/quota/dquot.c?id=6afc9f4434fa8063aa768c2bf5bf98583aee0877) | 98 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 57 insertions, 41 deletions

| diff --git a/fs/quota/dquot.c b/fs/quota/dquot.cindex 1f0c754416b64c..cafe65a03f6dcd 100644--- a/[fs/quota/dquot.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/quota/dquot.c?id=29635d12291023b249834bce0a4756f329ee15a5)+++ b/[fs/quota/dquot.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/quota/dquot.c?id=6afc9f4434fa8063aa768c2bf5bf98583aee0877)@@ -399,15 +399,17 @@ int dquot\_mark\_dquot\_dirty(struct dquot \*dquot) EXPORT\_SYMBOL(dquot\_mark\_dquot\_dirty);  /\* Dirtify all the dquots - this can block when journalling \*/-static inline int mark\_all\_dquot\_dirty(struct dquot \* const \*dquot)+static inline int mark\_all\_dquot\_dirty(struct dquot \* const \*dquots) { int ret, err, cnt;+ struct dquot \*dquot;  ret = err = 0; for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (dquot[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (dquot) /\* Even in case of error we have to continue \*/- ret = mark\_dquot\_dirty(dquot[cnt]);+ ret = mark\_dquot\_dirty(dquot); if (!err) err = ret; }@@ -1678,6 +1680,7 @@ int \_\_dquot\_alloc\_space(struct inode \*inode, qsize\_t number, int flags) struct dquot\_warn warn[MAXQUOTAS]; int reserve = flags & DQUOT\_SPACE\_RESERVE; struct dquot \*\*dquots;+ struct dquot \*dquot;  if (!inode\_quota\_active(inode)) { if (reserve) {@@ -1697,27 +1700,26 @@ int \_\_dquot\_alloc\_space(struct inode \*inode, qsize\_t number, int flags) index = srcu\_read\_lock(&dquot\_srcu); spin\_lock(&inode->i\_lock); for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue; if (reserve) {- ret = dquot\_add\_space(dquots[cnt], 0, number, flags,- &warn[cnt]);+ ret = dquot\_add\_space(dquot, 0, number, flags, &warn[cnt]); } else {- ret = dquot\_add\_space(dquots[cnt], number, 0, flags,- &warn[cnt]);+ ret = dquot\_add\_space(dquot, number, 0, flags, &warn[cnt]); } if (ret) { /\* Back out changes we already did \*/ for (cnt--; cnt >= 0; cnt--) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);+ spin\_lock(&dquot->dq\_dqb\_lock); if (reserve)- dquot\_free\_reserved\_space(dquots[cnt],- number);+ dquot\_free\_reserved\_space(dquot, number); else- dquot\_decr\_space(dquots[cnt], number);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ dquot\_decr\_space(dquot, number);+ spin\_unlock(&dquot->dq\_dqb\_lock); } spin\_unlock(&inode->i\_lock); goto out\_flush\_warn;@@ -1748,6 +1750,7 @@ int dquot\_alloc\_inode(struct inode \*inode) int cnt, ret = 0, index; struct dquot\_warn warn[MAXQUOTAS]; struct dquot \* const \*dquots;+ struct dquot \*dquot;  if (!inode\_quota\_active(inode)) return 0;@@ -1758,17 +1761,19 @@ int dquot\_alloc\_inode(struct inode \*inode) index = srcu\_read\_lock(&dquot\_srcu); spin\_lock(&inode->i\_lock); for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- ret = dquot\_add\_inodes(dquots[cnt], 1, &warn[cnt]);+ ret = dquot\_add\_inodes(dquot, 1, &warn[cnt]); if (ret) { for (cnt--; cnt >= 0; cnt--) {- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue; /\* Back out changes we already did \*/- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);- dquot\_decr\_inodes(dquots[cnt], 1);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ spin\_lock(&dquot->dq\_dqb\_lock);+ dquot\_decr\_inodes(dquot, 1);+ spin\_unlock(&dquot->dq\_dqb\_lock); } goto warn\_put\_all; }@@ -1790,6 +1795,7 @@ EXPORT\_SYMBOL(dquot\_alloc\_inode); void dquot\_claim\_space\_nodirty(struct inode \*inode, qsize\_t number) { struct dquot \*\*dquots;+ struct dquot \*dquot; int cnt, index;  if (!inode\_quota\_active(inode)) {@@ -1805,9 +1811,8 @@ void dquot\_claim\_space\_nodirty(struct inode \*inode, qsize\_t number) spin\_lock(&inode->i\_lock); /\* Claim reserved quotas to allocated quotas \*/ for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (dquots[cnt]) {- struct dquot \*dquot = dquots[cnt];-+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (dquot) { spin\_lock(&dquot->dq\_dqb\_lock); if (WARN\_ON\_ONCE(dquot->dq\_dqb.dqb\_rsvspace < number)) number = dquot->dq\_dqb.dqb\_rsvspace;@@ -1832,6 +1837,7 @@ EXPORT\_SYMBOL(dquot\_claim\_space\_nodirty); void dquot\_reclaim\_space\_nodirty(struct inode \*inode, qsize\_t number) { struct dquot \*\*dquots;+ struct dquot \*dquot; int cnt, index;  if (!inode\_quota\_active(inode)) {@@ -1847,9 +1853,8 @@ void dquot\_reclaim\_space\_nodirty(struct inode \*inode, qsize\_t number) spin\_lock(&inode->i\_lock); /\* Claim reserved quotas to allocated quotas \*/ for (cnt = 0; cnt < MAXQUOTAS; cnt++) {- if (dquots[cnt]) {- struct dquot \*dquot = dquots[cnt];-+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (dquot) { spin\_lock(&dquot->dq\_dqb\_lock); if (WARN\_ON\_ONCE(dquot->dq\_dqb.dqb\_curspace < number)) number = dquot->dq\_dqb.dqb\_curspace;@@ -1876,6 +1881,7 @@ void \_\_dquot\_free\_space(struct inode \*inode, qsize\_t number, int flags) unsigned int cnt; struct dquot\_warn warn[MAXQUOTAS]; struct dquot \*\*dquots;+ struct dquot \*dquot; int reserve = flags & DQUOT\_SPACE\_RESERVE, index;  if (!inode\_quota\_active(inode)) {@@ -1896,17 +1902,18 @@ void \_\_dquot\_free\_space(struct inode \*inode, qsize\_t number, int flags) int wtype;  warn[cnt].w\_type = QUOTA\_NL\_NOWARN;- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);- wtype = info\_bdq\_free(dquots[cnt], number);+ spin\_lock(&dquot->dq\_dqb\_lock);+ wtype = info\_bdq\_free(dquot, number); if (wtype != QUOTA\_NL\_NOWARN)- prepare\_warning(&warn[cnt], dquots[cnt], wtype);+ prepare\_warning(&warn[cnt], dquot, wtype); if (reserve)- dquot\_free\_reserved\_space(dquots[cnt], number);+ dquot\_free\_reserved\_space(dquot, number); else- dquot\_decr\_space(dquots[cnt], number);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ dquot\_decr\_space(dquot, number);+ spin\_unlock(&dquot->dq\_dqb\_lock); } if (reserve) \*inode\_reserved\_space(inode) -= number;@@ -1931,6 +1938,7 @@ void dquot\_free\_inode(struct inode \*inode) unsigned int cnt; struct dquot\_warn warn[MAXQUOTAS]; struct dquot \* const \*dquots;+ struct dquot \*dquot; int index;  if (!inode\_quota\_active(inode))@@ -1941,16 +1949,16 @@ void dquot\_free\_inode(struct inode \*inode) spin\_lock(&inode->i\_lock); for (cnt = 0; cnt < MAXQUOTAS; cnt++) { int wtype;- warn[cnt].w\_type = QUOTA\_NL\_NOWARN;- if (!dquots[cnt])+ dquot = srcu\_dereference(dquots[cnt], &dquot\_srcu);+ if (!dquot) continue;- spin\_lock(&dquots[cnt]->dq\_dqb\_lock);- wtype = info\_idq\_free(dquots[cnt], 1);+ spin\_lock(&dquot->dq\_dqb\_lock);+ wtype = info\_idq\_free(dquot, 1); if (wtype != QUOTA\_NL\_NOWARN)- prepare\_warning(&warn[cnt], dquots[cnt], wtype);- dquot\_decr\_inodes(dquots[cnt], 1);- spin\_unlock(&dquots[cnt]->dq\_dqb\_lock);+ prepare\_warning(&warn[cnt], dquot, wtype);+ dquot\_decr\_inodes(dquot, 1);+ spin\_unlock(&dquot->dq\_dqb\_lock); } spin\_unlock(&inode->i\_lock); mark\_all\_dquot\_dirty(dquots);@@ -1977,7 +1985,7 @@ int \_\_dquot\_transfer(struct inode \*inode, struct dquot \*\*transfer\_to) qsize\_t rsv\_space = 0; qsize\_t inode\_usage = 1; struct dquot \*transfer\_from[MAXQUOTAS] = {};- int cnt, ret = 0;+ int cnt, index, ret = 0; char is\_valid[MAXQUOTAS] = {}; struct dquot\_warn warn\_to[MAXQUOTAS]; struct dquot\_warn warn\_from\_inodes[MAXQUOTAS];@@ -2066,8 +2074,16 @@ int \_\_dquot\_transfer(struct inode \*inode, struct dquot \*\*transfer\_to) spin\_unlock(&inode->i\_lock); spin\_unlock(&dq\_data\_lock); + /\*+ \* These arrays are local and we hold dquot references so we don't need+ \* the srcu protection but still take dquot\_srcu to avoid warning in+ \* mark\_all\_dquot\_dirty().+ \*/+ index = srcu\_read\_lock(&dquot\_srcu); mark\_all\_dquot\_dirty(transfer\_from); mark\_all\_dquot\_dirty(transfer\_to);+ srcu\_read\_unlock(&dquot\_srcu, index);+ flush\_warnings(warn\_to); flush\_warnings(warn\_from\_inodes); flush\_warnings(warn\_from\_space); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 03:28:24 +0000


