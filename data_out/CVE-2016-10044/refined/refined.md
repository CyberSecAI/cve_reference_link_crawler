```
{
  "CVE-2016-10044": {
    "status": "relevant",
    "details": {
      "Root cause": "An elevation of privilege vulnerability in the kernel file system could enable a local malicious application to bypass protections that prevent an escalation of privileges.",
      "Weaknesses/vulnerabilities": "The vulnerability allows a local malicious application to bypass protections and gain elevated privileges.",
      "Impact of exploitation": "A local attacker could potentially bypass security measures.",
      "Attack vectors": "The vulnerability is exploited by a local malicious application.",
      "Required attacker capabilities/position": "Local access and the ability to execute code on the target system are required."
    }
  },
    "CVE-2016-10044_Additional_context": {
      "source": "source.android.com_3827c524_20250111_104911.html",
      "description": "This CVE is listed in the Android Security Bulletinâ€”February 2017 as a moderate elevation of privilege vulnerability in the kernel file system. The update is contained in the latest binary drivers for Nexus devices.",
      "affected_components": "Kernel File System, Nexus devices using Android OS"

    },
    "CVE-2016-10044_Content_from_www.kernel.org": {
      "source": "www.kernel.org_1d63d493_20250111_104913.html",
      "commits": [
        {
          "commit_id": "03f8e90de1365975ea21fee41b0c16f558c466a8",
          "description": "usb: misc: legousbtower: Fix NULL pointer deference\n\nThis patch fixes a NULL pointer dereference caused by a race codition in\nthe probe function of the legousbtower driver. It re-structures the\nprobe function to only register the interface after successfully reading\nthe board's firmware ID.\n\nThe probe function does not deregister the usb interface after an error\nreceiving the devices firmware ID. The device file registered\n(/dev/usb/legousbtower%d) may be read/written globally before the probe\nfunction returns. When tower_delete is called in the probe function\n(after an r/w has been initiated), core dev structures are deleted while\nthe file operation functions are still running. If the 0 address is\nmappable on the machine, this vulnerability can be used to create a\nLocal Priviege Escalation exploit via a write-what-where condition by\nremapping dev->interrupt_out_buffer in tower_write. A forged USB device\nand local program execution would be required for LPE. The USB device\nwould have to delay the control message in tower_probe and accept\nthe control urb in tower_open whilst guest code initiated a write to the\ndevice file as tower_delete is called from the error in tower_probe.\nThis bug has existed since 2003. Patch tested by emulated device."
          ,
          "vulnerability": {
           "root_cause": "Race condition in legousbtower driver's probe function leading to a NULL pointer dereference",
            "weaknesses": "The driver's probe function does not properly deregister the USB interface on error, leading to a race condition where core structures are deleted while file operations are still running. This allows for a write-what-where condition using remapping of dev->interrupt_out_buffer in tower_write.",
            "impact": "Local Privilege Escalation (LPE) through a write-what-where condition.",
            "attack_vector": "A forged USB device and local program execution are required. The USB device needs to delay the control message in tower_probe and accept the control urb in tower_open while guest code initiates a write to the device file while tower_delete is called.",
            "required_capabilities": "Local program execution and a forged USB device that can delay control messages."

          }
        }
      ]
    },
    "CVE-2016-10044_Content_from_github.com": {
      "source": "github.com_b7bc5699_20250111_104914.html",
      "commits": [
        {
          "commit_id": "22f6b4d34fcf039c63a94e7670e0da24f8575a5a",
          "description": "aio: mark AIO pseudo-fs noexec\n\nThis ensures that do_mmap() won't implicitly make AIO memory mappings\nexecutable if the READ_IMPLIES_EXEC personality flag is set. Such\nbehavior is problematic because the security_mmap_file LSM hook doesn't\ncatch this case, potentially permitting an attacker to bypass a W^X\npolicy enforced by SELinux."
          ,
           "vulnerability": {
                "root_cause": "AIO memory mappings implicitly become executable with READ_IMPLIES_EXEC, bypassing security_mmap_file LSM checks.",
                "weaknesses": "The do_mmap() function does not prevent the creation of executable memory mappings, even when a W^X policy is enforced by SELinux when the READ_IMPLIES_EXEC flag is set. The security_mmap_file LSM hook does not catch this case.",
                "impact": "An attacker can bypass a W^X policy enforced by SELinux, potentially allowing for code execution.",
                "attack_vector":"Local exploitation via AIO memory mappings when READ_IMPLIES_EXEC is set.",
                "required_capabilities": "Local access with the ability to trigger mmap and set the READ_IMPLIES_EXEC flag."
            }

        }
      ]
    },
      "CVE-2016-10044_Content_from_git.kernel.org": {
      "source": "git.kernel.org_c5d906ff_20250111_104909.html",
      "commits": [
        {
          "commit_id": "22f6b4d34fcf039c63a94e7670e0da24f8575a5a",
          "description": "aio: mark AIO pseudo-fs noexec\n\nThis ensures that do_mmap() won't implicitly make AIO memory mappings\nexecutable if the READ_IMPLIES_EXEC personality flag is set. Such\nbehavior is problematic because the security_mmap_file LSM hook doesn't\ncatch this case, potentially permitting an attacker to bypass a W^X\npolicy enforced by SELinux."
          ,
           "vulnerability": {
                "root_cause": "AIO memory mappings implicitly become executable with READ_IMPLIES_EXEC, bypassing security_mmap_file LSM checks.",
                "weaknesses": "The do_mmap() function does not prevent the creation of executable memory mappings, even when a W^X policy is enforced by SELinux when the READ_IMPLIES_EXEC flag is set. The security_mmap_file LSM hook does not catch this case.",
                "impact": "An attacker can bypass a W^X policy enforced by SELinux, potentially allowing for code execution.",
                "attack_vector":"Local exploitation via AIO memory mappings when READ_IMPLIES_EXEC is set.",
                "required_capabilities": "Local access with the ability to trigger mmap and set the READ_IMPLIES_EXEC flag."
            }

        }
      ]
    }
  }
```