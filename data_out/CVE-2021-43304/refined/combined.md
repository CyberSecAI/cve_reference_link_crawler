=== Content from github.com_f998ccd2_20250108_145306.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FClickHouse%2FClickHouse%2Fblob%2F6951e8147d7a25f7bb4f7d43738793cff239db6d%2Fsrc%2FCompression%2FLZ4_decompress_faster.cpp)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FClickHouse%2FClickHouse%2Fblob%2F6951e8147d7a25f7bb4f7d43738793cff239db6d%2Fsrc%2FCompression%2FLZ4_decompress_faster.cpp)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=ClickHouse%2FClickHouse)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[ClickHouse](/ClickHouse)
/
**[ClickHouse](/ClickHouse/ClickHouse)**
Public

* [Notifications](/login?return_to=%2FClickHouse%2FClickHouse) You must be signed in to change notification settings
* [Fork
  7k](/login?return_to=%2FClickHouse%2FClickHouse)
* [Star
   38.4k](/login?return_to=%2FClickHouse%2FClickHouse)

* [Code](/ClickHouse/ClickHouse)
* [Issues
  3.7k](/ClickHouse/ClickHouse/issues)
* [Pull requests
  386](/ClickHouse/ClickHouse/pulls)
* [Discussions](/ClickHouse/ClickHouse/discussions)
* [Actions](/ClickHouse/ClickHouse/actions)
* [Projects
  0](/ClickHouse/ClickHouse/projects)
* [Wiki](/ClickHouse/ClickHouse/wiki)
* [Security](/ClickHouse/ClickHouse/security)
* [Insights](/ClickHouse/ClickHouse/pulse)

Additional navigation options

* [Code](/ClickHouse/ClickHouse)
* [Issues](/ClickHouse/ClickHouse/issues)
* [Pull requests](/ClickHouse/ClickHouse/pulls)
* [Discussions](/ClickHouse/ClickHouse/discussions)
* [Actions](/ClickHouse/ClickHouse/actions)
* [Projects](/ClickHouse/ClickHouse/projects)
* [Wiki](/ClickHouse/ClickHouse/wiki)
* [Security](/ClickHouse/ClickHouse/security)
* [Insights](/ClickHouse/ClickHouse/pulse)

## Files

 6951e81
## Breadcrumbs

1. [ClickHouse](/ClickHouse/ClickHouse/tree/6951e8147d7a25f7bb4f7d43738793cff239db6d)
2. /[src](/ClickHouse/ClickHouse/tree/6951e8147d7a25f7bb4f7d43738793cff239db6d/src)
3. /[Compression](/ClickHouse/ClickHouse/tree/6951e8147d7a25f7bb4f7d43738793cff239db6d/src/Compression)
/
# LZ4\_decompress\_faster.cpp

 Blame  Blame
## Latest commit

## History

[History](/ClickHouse/ClickHouse/commits/6951e8147d7a25f7bb4f7d43738793cff239db6d/src/Compression/LZ4_decompress_faster.cpp)646 lines (521 loc) · 19.6 KB 6951e81
## Breadcrumbs

1. [ClickHouse](/ClickHouse/ClickHouse/tree/6951e8147d7a25f7bb4f7d43738793cff239db6d)
2. /[src](/ClickHouse/ClickHouse/tree/6951e8147d7a25f7bb4f7d43738793cff239db6d/src)
3. /[Compression](/ClickHouse/ClickHouse/tree/6951e8147d7a25f7bb4f7d43738793cff239db6d/src/Compression)
/
# LZ4\_decompress\_faster.cpp

Top
## File metadata and controls

* Code
* Blame

646 lines (521 loc) · 19.6 KB[Raw](https://github.com/ClickHouse/ClickHouse/raw/6951e8147d7a25f7bb4f7d43738793cff239db6d/src/Compression/LZ4_decompress_faster.cpp)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646#include "LZ4\_decompress\_faster.h"
#include <string.h>#include <iostream>#include <Core/Defines.h>#include <Common/Stopwatch.h>#include <common/types.h>#include <common/unaligned.h>
#ifdef \_\_SSE2\_\_#include <emmintrin.h>#endif
#ifdef \_\_SSSE3\_\_#include <tmmintrin.h>#endif
#ifdef \_\_aarch64\_\_#include <arm\_neon.h>#endif
namespace LZ4{
namespace{
template <size\_t N> [[maybe\_unused]] void copy(UInt8 \* dst, const UInt8 \* src);template <size\_t N> [[maybe\_unused]] void wildCopy(UInt8 \* dst, const UInt8 \* src, UInt8 \* dst\_end);template <size\_t N, bool USE\_SHUFFLE> [[maybe\_unused]] void copyOverlap(UInt8 \* op, const UInt8 \*& match, size\_t offset);
inline void copy8(UInt8 \* dst, const UInt8 \* src){ memcpy(dst, src, 8);}
inline void wildCopy8(UInt8 \* dst, const UInt8 \* src, const UInt8 \* dst\_end){ /// Unrolling with clang is doing >10% performance degrade.#if defined(\_\_clang\_\_) #pragma nounroll#endif do { copy8(dst, src); dst += 8; src += 8; } while (dst < dst\_end);}
inline void copyOverlap8(UInt8 \* op, const UInt8 \*& match, size\_t offset){ /// 4 % n. /// Or if 4 % n is zero, we use n. /// It gives equivalent result, but is better CPU friendly for unknown reason. static constexpr int shift1[] = { 0, 1, 2, 1, 4, 4, 4, 4 };
 /// 8 % n - 4 % n static constexpr int shift2[] = { 0, 0, 0, 1, 0, -1, -2, -3 };
 op[0] = match[0]; op[1] = match[1]; op[2] = match[2]; op[3] = match[3];
 match += shift1[offset]; memcpy(op + 4, match, 4); match += shift2[offset];}
#if defined(\_\_x86\_64\_\_) || defined(\_\_PPC\_\_)
/\*\* We use 'xmm' (128bit SSE) registers here to shuffle 16 bytes. \* \* It is possible to use 'mm' (64bit MMX) registers to shuffle just 8 bytes as we need. \* \* There is corresponding version of 'pshufb' instruction that operates on 'mm' registers, \* (it operates on MMX registers although it is available in SSSE3) \* and compiler library has the corresponding intrinsic: '\_mm\_shuffle\_pi8'. \* \* It can be done like this: \* \* unalignedStore(op, \_mm\_shuffle\_pi8( \* unalignedLoad<\_\_m64>(match), \* unalignedLoad<\_\_m64>(masks + 8 \* offset))); \* \* This is perfectly correct and this code have the same or even better performance. \* \* But if we write code this way, it will lead to \* extremely weird and extremely non obvious \* effects in completely unrelated parts of code. \* \* Because using MMX registers alters the mode of operation of x87 FPU, \* and then operations with FPU become broken. \* \* Example 1. \* Compile this code without optimizations: \* #include <vector> #include <unordered\_set> #include <iostream> #include <tmmintrin.h>
 int main(int, char \*\*) { [[maybe\_unused]] \_\_m64 shuffled = \_mm\_shuffle\_pi8(\_\_m64{}, \_\_m64{});
 std::vector<int> vec; std::unordered\_set<int> set(vec.begin(), vec.end());
 std::cerr << set.size() << "\n"; return 0; }
 $ g++ -g -O0 -mssse3 -std=c++17 mmx\_bug1.cpp && ./a.out terminate called after throwing an instance of 'std::bad\_alloc' what(): std::bad\_alloc
 Also reproduced with clang. But only with libstdc++, not with libc++.
 \* Example 2.
 #include <math.h> #include <iostream> #include <tmmintrin.h>
 int main(int, char \*\*) { double max\_fill = 1;
 std::cerr << (long double)max\_fill << "\n"; [[maybe\_unused]] \_\_m64 shuffled = \_mm\_shuffle\_pi8(\_\_m64{}, \_\_m64{}); std::cerr << (long double)max\_fill << "\n";
 return 0; }
 $ g++ -g -O0 -mssse3 -std=c++17 mmx\_bug2.cpp && ./a.out 1 -nan
 \* Explanation: \* \* https://stackoverflow.com/questions/33692969/assembler-mmx-errors \* https://software.intel.com/en-us/node/524274 \* \* Actually it's possible to use 'emms' instruction after decompression routine. \* But it's more easy to just use 'xmm' registers and avoid using 'mm' registers. \*/inline void copyOverlap8Shuffle(UInt8 \* op, const UInt8 \*& match, const size\_t offset){#if defined(\_\_SSSE3\_\_) && !defined(MEMORY\_SANITIZER)
 static constexpr UInt8 \_\_attribute\_\_((\_\_aligned\_\_(8))) masks[] = { 0, 1, 2, 2, 4, 3, 2, 1, /\* offset = 0, not used as mask, but for shift amount instead \*/ 0, 0, 0, 0, 0, 0, 0, 0, /\* offset = 1 \*/ 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 2, 0, 1, 2, 0, 1, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 4, 0, 1, 2, 0, 1, 2, 3, 4, 5, 0, 1, 0, 1, 2, 3, 4, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, /\* this row is not used: padding to allow read 16 bytes starting at previous row \*/ };
 \_mm\_storeu\_si128(reinterpret\_cast<\_\_m128i \*>(op), \_mm\_shuffle\_epi8( \_mm\_loadu\_si128(reinterpret\_cast<const \_\_m128i \*>(match)), \_mm\_loadu\_si128(reinterpret\_cast<const \_\_m128i \*>(masks + 8 \* offset))));
 match += masks[offset];
#else copyOverlap8(op, match, offset);#endif}
#endif
#ifdef \_\_aarch64\_\_
inline void copyOverlap8Shuffle(UInt8 \* op, const UInt8 \*& match, const size\_t offset){ static constexpr UInt8 \_\_attribute\_\_((\_\_aligned\_\_(8))) masks[] = { 0, 1, 2, 2, 4, 3, 2, 1, /\* offset = 0, not used as mask, but for shift amount instead \*/ 0, 0, 0, 0, 0, 0, 0, 0, /\* offset = 1 \*/ 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 2, 0, 1, 2, 0, 1, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 4, 0, 1, 2, 0, 1, 2, 3, 4, 5, 0, 1, 0, 1, 2, 3, 4, 5, 6, 0, };
 unalignedStore<uint8x8\_t>(op, vtbl1\_u8(unalignedLoad<uint8x8\_t>(match), unalignedLoad<uint8x8\_t>(masks + 8 \* offset))); match += masks[offset];}
#endif
template <> void inline copy<8>(UInt8 \* dst, const UInt8 \* src) { copy8(dst, src); }template <> void inline wildCopy<8>(UInt8 \* dst, const UInt8 \* src, UInt8 \* dst\_end) { wildCopy8(dst, src, dst\_end); }template <> void inline copyOverlap<8, false>(UInt8 \* op, const UInt8 \*& match, const size\_t offset) { copyOverlap8(op, match, offset); }template <> void inline copyOverlap<8, true>(UInt8 \* op, const UInt8 \*& match, const size\_t offset) { copyOverlap8Shuffle(op, match, offset); }
inline void copy16(UInt8 \* dst, const UInt8 \* src){#ifdef \_\_SSE2\_\_ \_mm\_storeu\_si128(reinterpret\_cast<\_\_m128i \*>(dst), \_mm\_loadu\_si128(reinterpret\_cast<const \_\_m128i \*>(src)));#else memcpy(dst, src, 16);#endif}
inline void wildCopy16(UInt8 \* dst, const UInt8 \* src, const UInt8 \* dst\_end){ /// Unrolling with clang is doing >10% performance degrade.#if defined(\_\_clang\_\_) #pragma nounroll#endif do { copy16(dst, src); dst += 16; src += 16; } while (dst < dst\_end);}
inline void copyOverlap16(UInt8 \* op, const UInt8 \*& match, const size\_t offset){ /// 4 % n. static constexpr int shift1[] = { 0, 1, 2, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };
 /// 8 % n - 4 % n static constexpr int shift2[] = { 0, 0, 0, 1, 0, -1, -2, -3, -4, 4, 4, 4, 4, 4, 4, 4 };
 /// 16 % n - 8 % n static constexpr int shift3[] = { 0, 0, 0, -1, 0, -2, 2, 1, 8, -1, -2, -3, -4, -5, -6, -7 };
 op[0] = match[0]; op[1] = match[1]; op[2] = match[2]; op[3] = match[3];
 match += shift1[offset]; memcpy(op + 4, match, 4); match += shift2[offset]; memcpy(op + 8, match, 8); match += shift3[offset];}
#if defined(\_\_x86\_64\_\_) || defined(\_\_PPC\_\_)
inline void copyOverlap16Shuffle(UInt8 \* op, const UInt8 \*& match, const size\_t offset){#if defined(\_\_SSSE3\_\_) && !defined(MEMORY\_SANITIZER)
 static constexpr UInt8 \_\_attribute\_\_((\_\_aligned\_\_(16))) masks[] = { 0, 1, 2, 1, 4, 1, 4, 2, 8, 7, 6, 5, 4, 3, 2, 1, /\* offset = 0, not used as mask, but for shift amount instead \*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /\* offset = 1 \*/ 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1, 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 8, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 0, 1, 2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 0, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 0, };
 \_mm\_storeu\_si128(reinterpret\_cast<\_\_m128i \*>(op), \_mm\_shuffle\_epi8( \_mm\_loadu\_si128(reinterpret\_cast<const \_\_m128i \*>(match)), \_mm\_load\_si128(reinterpret\_cast<const \_\_m128i \*>(masks) + offset)));
 match += masks[offset];
#else copyOverlap16(op, match, offset);#endif}
#endif
#ifdef \_\_aarch64\_\_
inline void copyOverlap16Shuffle(UInt8 \* op, const UInt8 \*& match, const size\_t offset){ static constexpr UInt8 \_\_attribute\_\_((\_\_aligned\_\_(16))) masks[] = { 0, 1, 2, 1, 4, 1, 4, 2, 8, 7, 6, 5, 4, 3, 2, 1, /\* offset = 0, not used as mask, but for shift amount instead \*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /\* offset = 1 \*/ 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1, 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 8, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 0, 1, 2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 0, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 0, };
 unalignedStore<uint8x8\_t>(op, vtbl2\_u8(unalignedLoad<uint8x8x2\_t>(match), unalignedLoad<uint8x8\_t>(masks + 16 \* offset)));
 unalignedStore<uint8x8\_t>(op + 8, vtbl2\_u8(unalignedLoad<uint8x8x2\_t>(match), unalignedLoad<uint8x8\_t>(masks + 16 \* offset + 8)));
 match += masks[offset];}
#endif
template <> void inline copy<16>(UInt8 \* dst, const UInt8 \* src) { copy16(dst, src); }template <> void inline wildCopy<16>(UInt8 \* dst, const UInt8 \* src, UInt8 \* dst\_end) { wildCopy16(dst, src, dst\_end); }template <> void inline copyOverlap<16, false>(UInt8 \* op, const UInt8 \*& match, const size\_t offset) { copyOverlap16(op, match, offset); }template <> void inline copyOverlap<16, true>(UInt8 \* op, const UInt8 \*& match, const size\_t offset) { copyOverlap16Shuffle(op, match, offset); }
inline void copy32(UInt8 \* dst, const UInt8 \* src){ /// There was an AVX here but with mash with SSE instructions, we got a big slowdown.#if defined(\_\_SSE2\_\_) \_mm\_storeu\_si128(reinterpret\_cast<\_\_m128i \*>(dst), \_mm\_loadu\_si128(reinterpret\_cast<const \_\_m128i \*>(src))); \_mm\_storeu\_si128(reinterpret\_cast<\_\_m128i \*>(dst + 16), \_mm\_loadu\_si128(reinterpret\_cast<const \_\_m128i \*>(src + 16)));#else memcpy(dst, src, 16); memcpy(dst + 16, src + 16, 16);#endif}
inline void wildCopy32(UInt8 \* dst, const UInt8 \* src, const UInt8 \* dst\_end){ /// Unrolling with clang is doing >10% performance degrade.#if defined(\_\_clang\_\_) #pragma nounroll#endif do { copy32(dst, src); dst += 32; src += 32; } while (dst < dst\_end);}
inline void copyOverlap32(UInt8 \* op, const UInt8 \*& match, const size\_t offset){ /// 4 % n. static constexpr int shift1[] = { 0, 1, 2, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };
 /// 8 % n - 4 % n static constexpr int shift2[] = { 0, 0, 0, 1, 0, -1, -2, -3, -4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };
 /// 16 % n - 8 % n static constexpr int shift3[] = { 0, 0, 0, -1, 0, -2, 2, 1, 8, -1, -2, -3, -4, -5, -6, -7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 };
 /// 32 % n - 16 % n static constexpr int shift4[] = { 0, 0, 0, 1, 0, 1, -2, 2, 0, -2, -4, 5, 4, 3, 2, 1, 0, -1, -2, -3, -4, -5, -6, -7, -8, -9,-10,-11,-12,-13,-14,-15 };
 op[0] = match[0]; op[1] = match[1]; op[2] = match[2]; op[3] = match[3];
 match += shift1[offset]; memcpy(op + 4, match, 4); match += shift2[offset]; memcpy(op + 8, match, 8); match += shift3[offset]; memcpy(op + 16, match, 16); match += shift4[offset];}
template <> void inline copy<32>(UInt8 \* dst, const UInt8 \* src) { copy32(dst, src); }template <> void inline wildCopy<32>(UInt8 \* dst, const UInt8 \* src, UInt8 \* dst\_end) { wildCopy32(dst, src, dst\_end); }template <> void inline copyOverlap<32, false>(UInt8 \* op, const UInt8 \*& match, const size\_t offset) { copyOverlap32(op, match, offset); }
/// See also https://stackoverflow.com/a/30669632
template <size\_t copy\_amount, bool use\_shuffle>void NO\_INLINE decompressImpl( const char \* const source, char \* const dest, size\_t dest\_size){ const UInt8 \* ip = reinterpret\_cast<const UInt8 \*>(source); UInt8 \* op = reinterpret\_cast<UInt8 \*>(dest); UInt8 \* const output\_end = op + dest\_size;
 /// Unrolling with clang is doing >10% performance degrade.#if defined(\_\_clang\_\_) #pragma nounroll#endif while (true) { size\_t length;
 auto continue\_read\_length = [&] { unsigned s; do { s = \*ip++; length += s; } while (unlikely(s == 255)); };
 /// Get literal length.
 const unsigned token = \*ip++; length = token >> 4; if (length == 0x0F) continue\_read\_length();
 /// Copy literals.
 UInt8 \* copy\_end = op + length;
 /// input: Hello, world /// ^-ip /// output: xyz /// ^-op ^-copy\_end /// output: xyzHello, w /// ^- excessive copied bytes due to "wildCopy" /// input: Hello, world /// ^-ip /// output: xyzHello, w /// ^-op (we will overwrite excessive bytes on next iteration)
 wildCopy<copy\_amount>(op, ip, copy\_end); /// Here we can write up to copy\_amount - 1 bytes after buffer.
 ip += length; op = copy\_end;
 if (copy\_end >= output\_end) return;
 /// Get match offset.
 size\_t offset = unalignedLoad<UInt16>(ip); ip += 2; const UInt8 \* match = op - offset;
 /// Get match length.
 length = token & 0x0F; if (length == 0x0F) continue\_read\_length(); length += 4;
 /// Copy match within block, that produce overlapping pattern. Match may replicate itself.
 copy\_end = op + length;
 /\*\* Here we can write up to copy\_amount - 1 - 4 \* 2 bytes after buffer. \* The worst case when offset = 1 and length = 4 \*/
 if (unlikely(offset < copy\_amount)) { /// output: Hello /// ^-op /// ^-match; offset = 5 /// /// output: Hello /// [------] - copy\_amount bytes /// [------] - copy them here /// /// output: HelloHelloHel /// ^-match ^-op
 copyOverlap<copy\_amount, use\_shuffle>(op, match, offset); } else { copy<copy\_amount>(op, match); match += copy\_amount; }
 op += copy\_amount;
 copy<copy\_amount>(op, match); /// copy\_amount + copy\_amount - 1 - 4 \* 2 bytes after buffer. if (length > copy\_amount \* 2) wildCopy<copy\_amount>(op + copy\_amount, match + copy\_amount, copy\_end);
 op = copy\_end; }}
}
void decompress( const char \* const source, char \* const dest, size\_t source\_size, size\_t dest\_size, PerformanceStatistics & statistics [[maybe\_unused]]){ if (source\_size == 0 || dest\_size == 0) return;
 /// Don't run timer if the block is too small. if (dest\_size >= 32768) { size\_t best\_variant = statistics.select();
 /// Run the selected method and measure time.
 Stopwatch watch; if (best\_variant == 0) decompressImpl<16, true>(source, dest, dest\_size); if (best\_variant == 1) decompressImpl<16, false>(source, dest, dest\_size); if (best\_variant == 2) decompressImpl<8, true>(source, dest, dest\_size); if (best\_variant == 3) decompressImpl<32, false>(source, dest, dest\_size);
 watch.stop();
 /// Update performance statistics.
 statistics.data[best\_variant].update(watch.elapsedSeconds(), dest\_size); } else { decompressImpl<8, false>(source, dest, dest\_size); }}
void StreamStatistics::literal(size\_t length){ ++num\_tokens; sum\_literal\_lengths += length;}
void StreamStatistics::match(size\_t length, size\_t offset){ ++num\_tokens; sum\_match\_lengths += length; sum\_match\_offsets += offset; count\_match\_offset\_less\_8 += offset < 8; count\_match\_offset\_less\_16 += offset < 16; count\_match\_replicate\_itself += offset < length;}
void StreamStatistics::print() const{ std::cerr << "Num tokens: " << num\_tokens << ", Avg literal length: " << double(sum\_literal\_lengths) / num\_tokens << ", Avg match length: " << double(sum\_match\_lengths) / num\_tokens << ", Avg match offset: " << double(sum\_match\_offsets) / num\_tokens << ", Offset < 8 ratio: " << double(count\_match\_offset\_less\_8) / num\_tokens << ", Offset < 16 ratio: " << double(count\_match\_offset\_less\_16) / num\_tokens << ", Match replicate itself: " << double(count\_match\_replicate\_itself) / num\_tokens << "\n";}
void statistics( const char \* const source, char \* const dest, size\_t dest\_size, StreamStatistics & stat){ const UInt8 \* ip = reinterpret\_cast<const UInt8 \*>(source); UInt8 \* op = reinterpret\_cast<UInt8 \*>(dest); UInt8 \* const output\_end = op + dest\_size; while (true) { size\_t length;
 auto continue\_read\_length = [&] { unsigned s; do { s = \*ip++; length += s; } while (unlikely(s == 255)); };
 auto token = \*ip++; length = token >> 4; if (length == 0x0F) continue\_read\_length();
 stat.literal(length);
 ip += length; op += length;
 if (op > output\_end) return;
 size\_t offset = unalignedLoad<UInt16>(ip); ip += 2;
 length = token & 0x0F; if (length == 0x0F) continue\_read\_length(); length += 4;
 stat.match(length, offset);
 op += length; }}
}

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from jfrog.com_480306fe_20250108_110008.html ===


[![JFrog banner](https://speedmedia.jfrog.com/08612fe1-9391-4cf3-ac1a-6dd49c36b276/media.jfrog.com/wp-content/uploads/2024/10/10144003/Group-97223.png)](https://github.com/marketplace/jfrog/?utm_campaign=github-copilot)
[![JFrog banner](https://speedmedia.jfrog.com/08612fe1-9391-4cf3-ac1a-6dd49c36b276/media.jfrog.com/wp-content/uploads/2024/10/10143852/homepage-banner-mobile-360x53-1.jpg)](https://github.com/marketplace/jfrog/?utm_campaign=github-copilot)

[![](https://speedmedia.jfrog.com/08612fe1-9391-4cf3-ac1a-6dd49c36b276/media.jfrog.com/wp-content/uploads/2024/08/08132607/jfrog-logo-2022.svg "JFrog logo")
![](https://speedmedia.jfrog.com/08612fe1-9391-4cf3-ac1a-6dd49c36b276/media.jfrog.com/wp-content/uploads/2024/08/08132607/jfrog-logo-2022.svg "JFrog logo")](https://jfrog.com/)

* [Products](#products "Products")
* [Solutions](#solutions "Solutions")
* [Pricing](https://jfrog.com/pricing/ "Pricing")
* [Developers](#developers "Developers")
* [Resources](#resources "Resources")
* [Partners](#partners "Partners")

* [Discover Our Partner Ecosystem  >](https://jfrog.com/partners/)
* [Find a JFrog Partner  >](https://partnerfinder.jfrog.com/)
* [Explore Partner Integrations  >](https://jfrog.com/integrations/)

* [Community  >](https://jfrog.com/community/)
* [Documentation  >](https://jfrog.com/help/)
* [Integrations  >](https://jfrog.com/integration/)
* [Applications  >](https://docs.jfrog-applications.jfrog.io/)

Use Case

* Cloud Solutions
  + [Flexible Cloud Deployment Solutions](https://jfrog.com/cloud/)
* AI/ML
  + [Model Lifecycle Management (MLOps)](https://jfrog.com/jfrog-ml/mlops/)
  + [Data Engineering & Feature Management (DataOps)](https://jfrog.com/jfrog-ml/dataops/)
  + [AI/ML Development and Deployment](https://jfrog.com/mlops/)
  + [MLSecOps](https://jfrog.com/mlsecops/)
* DevOps
  + [Artifact Management](https://jfrog.com/artifact-management/)
  + [Tool Consolidation](https://jfrog.com/tool-consolidation/)
  + [Release Lifecycle Management](https://jfrog.com/rlm/)
* DevSecOps
  + [Holistic Software Supply Chain Security](https://jfrog.com/xray/)
  + [Curate Open-Source Packages](https://jfrog.com/curation/)
  + [Source Code Scanning (SAST)](https://jfrog.com/sast/)
  + [Software Composition Analysis (SCA)](https://jfrog.com/xray/sca-scan/)
  + [Secrets Detection](https://jfrog.com/xray/secrets-detection-source-binaries/)
  + [Infrastructure as Code (IaC) Security](https://jfrog.com/xray/iac-security-check/)
* Device/IoT
  + [Connected Device Management](https://jfrog.com/connect/)

Integrations

* [GitHub  >](https://jfrog.com/jfrog-and-github/)
* [NVIDIA  >](/jfrog-and-nvidia/)
* [Docker  >](https://jfrog.com/integration/docker-registry/)
* [Maven  >](https://jfrog.com/integration/maven-repository/)
* [See all integrations  >](https://jfrog.com/integration/)

Industry

* [Financial Services  >](https://jfrog.com/industry/financial-services/)
* [Public Sector  >](https://jfrog.com/industry/public-sector/)
* [Technology  >](https://jfrog.com/technology-software-services/)
* [Healthcare  >](https://jfrog.com/healthcare-services/)
* [Gaming  >](https://jfrog.com/gaming/)
* [Automotive  >](https://jfrog.com/automotive-services/)

Learning & Guides

* [JFrog Help Center  >](https://jfrog.com/help/)
* [Security Research  >](https://research.jfrog.com/)
* [JFrog Academy  >](https://academy.jfrog.com/)
* [Events  >](https://jfrog.com/about/events/)
* [Webinars & Workshops  >](https://jfrog.com/webinar/)
* [DevOps Consulting Services  >](https://jfrog.com/devops-consulting-services/)
* [DevOps Certification  >](https://jfrog.com/certification/)
* [State of Union Report  >](https://jfrog.com/software-supply-chain-state-of-union/)
* [Software Supply Chain Topics  >](https://jfrog.com/learn/)

Collateral

* [Resource Center  >](https://jfrog.com/resource-center/)
* [JFrog Blog  >](https://jfrog.com/blog/)
* [Customer Stories  >](https://jfrog.com/about/customers/)

Customer Zone

* [Support  >

  Customer support, tickets and community](https://jfrog.com/support/)
* [Manage & Troubleshoot  >

  Renew, retrieve licenses, legal and more](https://jfrog.com/customer-zone/)
* [MyJFrog  >

  Cloud customer portal](https://my.jfrog.com/login/)
* [Cloud Status  >

  Service status & event subscription](https://status.jfrog.io/)
* [JFrog Trust  >

  How we protect you & your data](https://jfrog.com/trust/)

[The JFrog Platform
Deliver Trusted Software with Speed

The only software supply chain platform to give you end-to-end visibility, security, and control for automating delivery of trusted releases. Bring together DevOps, DevSecOps and MLOps teams in a single source of truth.
View Platform](https://jfrog.com/platform/)

DevOps

![](https://speedmedia.jfrog.com/08612fe1-9391-4cf3-ac1a-6dd49c36b276/media.jfrog.com/wp-content/uploads/2017/08/22132304/jfrog-artifactory.svg "jfrog-artifactory")
[JFrog Artifactory
Universal Artifact & ML Model Repository Manager](https://jfrog.com/artifactory/)

![](https://speedmedia.jfrog.com/08612fe1-9391-4cf3-ac1a-6dd49c36b276/media.jfrog.com/wp-content/uploads/2017/08/22132437/jfrog-distribution.svg "jfrog-distribution")
[JFrog Distribution
Secure Distribution Across Consumption Points](https://jfrog.com/distribution/)

![JFrog Connect](https://speedmedia.jfrog.com/08612fe1-9391-4cf3-ac1a-6dd49c36b276/media.jfrog.com/wp-content/uploads/2017/08/09231026/icon-jfrog-connect.svg "icon-jfrog-connect")

[JFrog Connect
IoT Device Management with DevOps Agility](https://jfrog.com/connect/)

DevSecOps

![](https://speedmedia.jfrog.com/08612fe1-9391-4cf3-ac1a-6dd49c36b276/media.jfrog.com/wp-content/uploads/2017/08/22132519/jfrog-curation.svg "jfrog-curation")

[JFrog Curation
Seamlessly Curate Software Packages & ML Models](https://jfrog.com/curation/)

![](https://speedmedia.jfrog.com/08612fe1-9391-4cf3-ac1a-6dd49c36b276/media.jfrog.com/wp-content/uploads/2017/08/22132556/jfrog-xray.svg "jfrog-xray")

[JFrog Security Essentials (Xray)
Integrated SCA for Software & AI Artifacts](https://jfrog.com/xray/)

![](https://speedmedia.jfrog.com/08612fe1-9391-4cf3-ac1a-6dd49c36b276/media.jfrog.com/wp-content/uploads/2017/08/22132556/jfrog-xray.svg "jfrog-xray")

[JFrog Advanced Security
Supply Chain Exposure Scanning & Impact Analysis](https://jfrog.com/devops-native-security/)

![](https://speedmedia.jfrog.com/08612fe1-9391-4cf3-ac1a-6dd49c36b276/media.jfrog.com/wp-content/uploads/2017/08/10145634/JFrog_Runtime.svg "JFrog_Runtime")

[JFrog Runtime
Real-time visibility into runtime vulnerabilities](https://jfrog.com/runtime/)

AI/ML

![](https://speedmedia.jfrog.com/08612fe1-9391-4cf3-ac1a-6dd49c36b276/media.jfrog.com/wp-content/uploads/2017/08/29162205/ml-nav-icon.svg "ml-nav-icon")

[JFrog ML
Build, Train, Secure, Deploy, Serve and Monitor ML Models and GenAI](https://jfrog.com/jfrog-ml/)

[Contact Us](https://jfrog.com/contact-us/)[Start Free](https://jfrog.com/start-free/)

* Products

  The JFrog Platform
  Deliver Trusted Software with Speed

  The only software supply chain platform to give you end-to-end visibility, security, and control for automating delivery of trusted releases. Bring together DevOps, DevSecOps and MLOps teams in a single source of truth.
  [View Platform](https://jfrog.com/platform/)

  + DevOps
    - [![](https://speedmedia.jfrog.com/08612fe1-9391-4cf3-ac1a-6dd49c36b276/media.jfrog.com/wp-content/uploads/2017/08/22132304/jfrog-artifactory.svg)

       JFrog Artifactory
      Universal Artifact & ML Model Repository Manager](https://jfrog.com/artifactory/)
    - [![](https://speedmedia.jfrog.com/08612fe1-9391-4cf3-ac1a-6dd49c36b276/media.jfrog.com/wp-content/uploads/2017/08/22132437/jfrog-distribution.svg)

       JFrog Distribution
      Secure Distribution Across Consumption Points](https://jfrog.com/distribution/)
    - [![JFrog Connect](https://speedmedia.jfrog.com/08612fe1-9391-4cf3-ac1a-6dd49c36b276/media.jfrog.com/wp-content/uploads/2017/08/09231026/icon-jfrog-connect.svg)

       JFrog Connect
      IoT Device Management with DevOps Agility](https://jfrog.com/connect/)
  + DevSecOps
    - [![](https://speedmedia.jfrog.com/08612fe1-9391-4cf3-ac1a-6dd49c36b276/media.jfrog.com/wp-content/uploads/2017/08/22132519/jfrog-curation.svg)

       JFrog Curation
      Seamlessly Curate Software Packages & ML Models](https://jfrog.com/curation/)
    - [![](https://speedmedia.jfrog.com/08612fe1-9391-4cf3-ac1a-6dd49c36b276/media.jfrog.com/wp-content/uploads/2017/08/22132556/jfrog-xray.svg)

       JFrog Security Essentials (Xray)
      Integrated SCA for Software & AI Artifacts](https://jfrog.com/xray/)
    - [![](https://speedmedia.jfrog.com/08612fe1-9391-4cf3-ac1a-6dd49c36b276/media.jfrog.com/wp-content/uploads/2017/08/22132556/jfrog-xray.svg)

       JFrog Advanced Security
      Supply Chain Exposure Scanning & Impact Analysis](https://jfrog.com/devops-native-security/)
    - [![](https://speedmedia.jfrog.com/08612fe1-9391-4cf3-ac1a-6dd49c36b276/media.jfrog.com/wp-content/uploads/2017/08/10145634/JFrog_Runtime.svg)

       JFrog Runtime
      Real-time visibility into runtime vulnerabilities](https://jfrog.com/runtime/)
  + AI/ML
    - [![](https://speedmedia.jfrog.com/08612fe1-9391-4cf3-ac1a-6dd49c36b276/media.jfrog.com/wp-content/uploads/2017/08/29162205/ml-nav-icon.svg)

       JFrog ML
      Build, Train, Secure, Deploy, Serve and Monitor ML Models and GenAI](https://jfrog.com/jfrog-ml/)
* Solutions

  + Use Case
    - Cloud Solutions
      * [Flexible Cloud Deployment Solutions](https://jfrog.com/cloud/)
    - AI/ML
      * [Model Lifecycle Management (MLOps)](https://jfrog.com/jfrog-ml/mlops/)
      * [Data Engineering & Feature Management (DataOps)](https://jfrog.com/jfrog-ml/dataops/)
      * [AI/ML Development and Deployment](https://jfrog.com/mlops/)
      * [MLSecOps](https://jfrog.com/mlsecops/)
    - DevOps
      * [Artifact Management](https://jfrog.com/artifact-management/)
      * [Tool Consolidation](https://jfrog.com/tool-consolidation/)
      * [Release Lifecycle Management](https://jfrog.com/rlm/)
    - DevSecOps
      * [Holistic Software Supply Chain Security](https://jfrog.com/xray/)
      * [Curate Open-Source Packages](https://jfrog.com/curation/)
      * [Source Code Scanning (SAST)](https://jfrog.com/sast/)
      * [Software Composition Analysis (SCA)](https://jfrog.com/xray/sca-scan/)
      * [Secrets Detection](https://jfrog.com/xray/secrets-detection-source-binaries/)
      * [Infrastructure as Code (IaC) Security](https://jfrog.com/xray/iac-security-check/)
    - Device/IoT
      * [Connected Device Management](https://jfrog.com/connect/)
  + Integrations
    - [GitHub](https://jfrog.com/jfrog-and-github/)
    - [NVIDIA](/jfrog-and-nvidia/)
    - [Docker](https://jfrog.com/integration/docker-registry/)
    - [Maven](https://jfrog.com/integration/maven-repository/)
    - [See all integrations](https://jfrog.com/integration/)
  + Industry
    - [Financial Services](https://jfrog.com/industry/financial-services/)
    - [Public Sector](https://jfrog.com/industry/public-sector/)
    - [Technology](https://jfrog.com/technology-software-services/)
    - [Healthcare](https://jfrog.com/healthcare-services/)
    - [Gaming](https://jfrog.com/gaming/)
    - [Automotive](https://jfrog.com/automotive-services/)
* [Pricing](https://jfrog.com/pricing/)
* Developers

  + - [Community](https://jfrog.com/community/)
    - [Documentation](https://jfrog.com/help/)
    - [Integrations](https://jfrog.com/integration/)
    - [Applications](https://docs.jfrog-applications.jfrog.io/)
* Resources

  + Learning & Guides
    - [JFrog Help Center](https://jfrog.com/help/)
    - [Security Research](https://research.jfrog.com/)
    - [JFrog Academy](https://academy.jfrog.com/)
    - [Events](https://jfrog.com/about/events/)
    - [Webinars & Workshops](https://jfrog.com/webinar/)
    - [DevOps Consulting Services](https://jfrog.com/devops-consulting-services/)
    - [DevOps Certification](https://jfrog.com/certification/)
    - [State of Union Report](https://jfrog.com/software-supply-chain-state-of-union/)
    - [Software Supply Chain Topics](https://jfrog.com/learn/)
  + Collateral
    - [Resource Center](https://jfrog.com/resource-center/)
    - [JFrog Blog](https://jfrog.com/blog/)
    - [Customer Stories](https://jfrog.com/about/customers/)
  + Customer Zone
    - [Support
      Customer support, tickets and community](https://jfrog.com/support/)
    - [Manage & Troubleshoot
      Renew, retrieve licenses, legal and more](https://jfrog.com/customer-zone/)
    - [MyJFrog
      Cloud customer portal](https://my.jfrog.com/login/)
    - [Cloud Status
      Service status & event subscription](https://status.jfrog.io/)
    - [JFrog Trust
      How we protect you & your data](https://jfrog.com/trust/)
* Partners

  + - [Discover Our Partner Ecosystem](https://jfrog.com/partners/)
    - [Find a JFrog Partner](https://partnerfinder.jfrog.com/)
    - [Explore Partner Integrations](https://jfrog.com/integrations/)

[Blog Home](/blog/)

# 7 RCE and DoS vulnerabilities Found in ClickHouse DBMS

![Uriya Yavnieli](data:image/svg+xml... "Uriya Yavnieli")![Uriya Yavnieli](https://speedmedia.jfrog.com/08612fe1-9391-4cf3-ac1a-6dd49c36b276/media.jfrog.com/wp-content/uploads/2024/08/19141403/Uriya-Yavnieli.png "Uriya Yavnieli")

By
[Uriya Yavnieli,  JFrog Security Researcher](https://jfrog.com/blog-author/uriya-yavnieli/)

Or Peles, JFrog Vulnerability Research Team Leader

March 15, 2022

  10 min read

SHARE:

![ClickHouse DBMS](data:image/svg+xml...)![ClickHouse DBMS](https://speedmedia.jfrog.com/08612fe1-9391-4cf3-ac1a-6dd49c36b276/media.jfrog.com/wp-content/uploads/2022/02/09164005/ClickHouse-DBMS-863x300-1.png)

The JFrog Security research team constantly monitors open-source projects to find new vulnerabilities or malicious packages and share them with the wider community to help improve their overall security posture. As part of this effort, the team recently discovered seven new [security vulnerabilities](https://jfrog.com/knowledge-base/understanding-security-vulnerabilities/) in [ClickHouse](https://clickhouse.tech/), a widely used open-source Database Management System (DBMS) dedicated to online analytical processing (OLAP). ClickHouse was developed by Yandex for the Yandex.Metrica, a web analytics tool often used to get visual reports and video recordings of user actions, as well as track traffic sources to help evaluate the effectiveness of online and offline advertising. The JFrog Security team responsibly disclosed these vulnerabilities and worked with ClickHouse’s maintainers on verifying the fixes.

The vulnerabilities require authentication, but can be triggered by any user with read permissions. This means the attacker must perform reconnaissance on the specific ClickHouse server target to obtain valid credentials. Any set of credentials would do, since even a user with the lowest privileges can trigger all of the vulnerabilities. By triggering the vulnerabilities, an attacker can crash the ClickHouse server, leak memory contents or even cause remote code execution (RCE).

Following are the seven vulnerabilities the JFrog Security team discovered:

* **CVE-2021-43304** and **CVE-2021-43305** – heap buffer overflow vulnerabilities in LZ4 compression codec
* **CVE-2021-42387** and **CVE-2021-42388** – heap out-of-bounds read vulnerabilities in LZ4 compression codec
* **CVE-2021-42389** – divide by zero in Delta compression codec
* **CVE-2021-42390** – divide by zero in Delta-Double compression codec
* **CVE-2021-42391** – divide by zero in Gorilla compression codec

| **CVE ID** | **Description** | **Potential Impact** | **CVSSv3.1 Score** |
| --- | --- | --- | --- |
| CVE-2021-43304 | Heap buffer overflow in LZ4 compression codec when parsing a malicious query | RCE | 8.8 |
| CVE-2021-43305 | Heap buffer overflow in LZ4 compression codec when parsing a malicious query | RCE | 8.8 |
| CVE-2021-42387 | Heap out-of-bounds read in LZ4 compression codec when parsing a malicious query | Denial of Service or Information Leakage | 7.1 |
| CVE-2021-42388 | Heap out-of-bounds read in LZ4 compression codec when parsing a malicious query | Denial of Service or Information Leakage | 7.1 |
| CVE-2021-42389 | Divide-by-zero in Delta compression codec when parsing a malicious query | Denial of Service | 6.5 |
| CVE-2021-42390 | Divide-by-zero in DeltaDouble compression codec when parsing a malicious query | Denial of Service | 6.5 |
| CVE-2021-42391 | Divide-by-zero in Gorilla compression codec when parsing a malicious query | Denial of Service | 6.5 |

## Technical Background

The ClickHouse server allows a user to compress its queries. A user can pass a compressed query by supplying the **decompress=1** URL query string parameter to its web interface, like so:

```
cat query.bin | curl -sS --data-binary @- 'http://serverIP:8123/?user=guest1&password=1234&decompress=1'
```

Where serverIP is the IP address of the ClickHouse server that has a user “guest1” with password “1234” set up. This user can also be configured with a “readonly” policy.

The query’s content (query.bin) should be in the following format:

```
struct {
    uint128_t hash; // Google’s CityHash128
    uint8_t compress_method;
    uint32_t size_compressed_without_checksum; // the length (in bytes) of the entire struct (including compressed_data contents) minus the first 16bytes hash field.
    uint32_t decompressed_size; // the expected decompressed output size
    char compressed_data[0]; // the compressed data bytes (variable length)
};
```

The client supplies the entire struct to the server and thus controls all of its contents.

The compressed data is consumed by constructing a [CompressedReadBuffer](https://github.com/ClickHouse/ClickHouse/blob/6951e8147d7a25f7bb4f7d43738793cff239db6d/src/Compression/CompressedReadBuffer.cpp) instance with the struct as its input.

CompressedReadBuffer’s code [calls readCompressedData](https://github.com/ClickHouse/ClickHouse/blob/6951e8147d7a25f7bb4f7d43738793cff239db6d/src/Compression/CompressedReadBuffer.cpp#L12) which reads the struct and extracts its length values, calculates the CityHash128 over the struct contents (excluding the hash field), and verifies it against the struct’s hash field. It then [resizes](https://github.com/ClickHouse/ClickHouse/blob/6951e8147d7a25f7bb4f7d43738793cff239db6d/src/Compression/CompressedReadBuffer.cpp#L21) (basically [realloc()’s](https://github.com/ClickHouse/ClickHouse/blob/6951e8147d7a25f7bb4f7d43738793cff239db6d/src/IO/BufferWithOwnMemory.h#L88)) the initially [allocated](https://github.com/ClickHouse/ClickHouse/blob/6951e8147d7a25f7bb4f7d43738793cff239db6d/src/IO/BufferWithOwnMemory.h#L117) memory buffer used to hold the decompressed data. Then, through ICompressionCodec::decompress, the selected codec’s [doDecompressData](https://github.com/ClickHouse/ClickHouse/blob/6951e8147d7a25f7bb4f7d43738793cff239db6d/src/Compression/ICompressionCodec.cpp#L109) is called.

In **CVE-2021-42387**, **CVE-2021-43304**, **CVE-2021-42388** and **CVE-2021-43305** the LZ4 codec calls [LZ4::decompress(source, dest, source\_size, dest\_size, ..)](https://github.com/ClickHouse/ClickHouse/blob/6951e8147d7a25f7bb4f7d43738793cff239db6d/src/Compression/LZ4_decompress_faster.cpp#L527) with the ‘compressed\_data’ as source, its length as source\_size, the resized memory buffer as dest, and the struct’s ‘decompressed\_size’ value as dest\_size. LZ4::decompress eventually calls [LZ4::decompressImpl(source, dest, dest\_size)](https://github.com/ClickHouse/ClickHouse/blob/6951e8147d7a25f7bb4f7d43738793cff239db6d/src/Compression/LZ4_decompress_faster.cpp#L415) that does the actual LZ4 decompression in a loop –copying different parts of the compressed input in user-controlled lengths and offsets (supplied as part of the compressed\_data bytes) to the decompressed output memory buffer. It defines pointer variables for tracking the current location in the source (ip) and the dest (op).

### CVE-2021-43304  – a heap buffer overflow vulnerability

Here is the code of LZ4::decompressImpl() that is relevant for CVE-2021-43304:

```
template
void NO_INLINE decompressImpl(
     const char * const source,
     char * const dest,
     size_t dest_size)
{
    ...
    while (true)
    {
        ...
        wildCopy(op, ip, copy_end);    /// Here we can write up to copy_amount - 1 bytes after buffer.

        ip += length;
        op = copy_end;

        if (copy_end >= output_end)
            return;
        ...
    }
}
```

**ip** is a pointer that points to the compressed buffer and **op** is a pointer that points to the allocated destination buffer, which is allocated with a size of the given decompressed\_size that is passed in the header. **copy\_end** is a pointer that points to the end of the copy area.

**copy\_amount** is the parameter of the template, which can be 8, 16 or 32. The copy area is being copied in chunks that each one of them is in size of **copy\_amount**. For example, this is the implementation of wildCopy16:

```
inline void wildCopy16(UInt8 * dst, const UInt8 * src, const UInt8 * dst_end)
{
    /// Unrolling with clang is doing >10% performance degrade.
#if defined(__clang__)
    #pragma nounroll
#endif
    do
    {
        copy16(dst, src);
        dst += 16;
        src += 16;
    } while (dst < dst_end);
}

```

Since the user controls **decompressed\_size** and the compressed buffer, an attacker can take advantage of this situation by preparing compressed data with a header that contains a decompressed\_size which is smaller than the actual size of the compressed data. Note that the lengths of the overflow, as well as source’s allocation size and the overflowing byte contents are fully controlled by the user, which greatly facilitates exploitation.

Also note that the existing size check of “if (copy\_end >= output\_end)” does not prevent this vulnerability as it appears after the copy operation. CVE-2021-43305 is similar to CVE-2021-43304, but [involves](https://github.com/ClickHouse/ClickHouse/blob/master/src/Compression/LZ4_decompress_faster.cpp#L518) a different copy operation (whose source is a controlled offset of the destination buffer).

## Exploiting CVE-2021-43304

In order to prove the exploitability of CVE-2021-43304, we created a specially crafted compressed file and sent it as previously explained. The query.bin file is comprised of the following header:

* hash = the matching calculated Cityhash
* compress\_method = 0x82 (LZ4 method)
* size\_compressed\_without\_checksum = 0xc80a
* decompressed\_size = 0x1

And for the compressed data we’ve used ‘\xff’ (repeating 200 times) ‘A’ (repeating 5100 times). These are arbitrary values. The resulting malformed compressed file:

`00000000 26 fc 61 db c0 83 bb 0a db 58 5a f0 34 e1 30 f6 |&.a......XZ.4.0.|

00000010 82 0a c8 00 00 01 00 00 00 f0 ff ff ff ff ff ff |................|

00000020 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff |................|

*

000000e0 ff ff 41 41 41 41 41 41 41 41 41 41 41 41 41 41 |..AAAAAAAAAAAAAA|

000000f0 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 |AAAAAAAAAAAAAAAA|

*

0000c81a`

The 200 0xff’s are being used in the loop inside LZ4::decompressImpl():

```
template
void NO_INLINE decompressImpl(
     const char * const source,
     char * const dest,
     size_t dest_size)
{
    ...
    while (true)
    {
        ...
        size_t length;

        auto continue_read_length = [&]
        {
            unsigned s;
            do
            {
                s = *ip++;
                length += s;
            } while (unlikely(s == 255));
        };

        /// Get literal length.

        const unsigned token = *ip++;
        length = token >> 4;
        if (length == 0x0F)
            continue_read_length();

        /// Copy literals.

        UInt8 * copy_end = op + length;

        ...

        wildCopy(op, ip, copy_end);    /// Here we can write up to copy_amount - 1 bytes after buffer.
        ...
    }
}
```

That will increase **length** by 0xff \* 200 = 51000, which is exactly the size of the rest of the data.

So although the decompressed size is 1, a much larger size will be copied to the destination.

By sending the query to a vulnerable ClickHouse server, while debugging the server’s process, we managed to periodically get the following crash, proving control of the instruction pointer register, since the code branches to an address taken from the RAX register, which has been overwritten with our “A” values:

![debugging the server process](data:image/svg+xml...)![debugging the server process](https://speedmedia.jfrog.com/08612fe1-9391-4cf3-ac1a-6dd49c36b276/media.jfrog.com/wp-content/uploads/2022/02/09170754/debugging-the-server-process.png)

Although this specific crash is statistical, we believe that with proper heap shaping techniques, a stable exploit can be developed.

### CVE-2021-42388 and CVE-2021-42387 – heap OOB read vulnerabilities

In LZ4::decompressImpl():

```
template
void NO_INLINE decompressImpl(
     const char * const source,
     char * const dest,
     size_t dest_size)
{
    ...
    while (true)
    {
        ...
        const UInt8 * match = op - offset;
        ...
        if (length > copy_amount * 2)
            wildCopy(op + copy_amount, match + copy_amount, copy_end);
        ...
    }
}
```

As part of the LZ4::decompressImpl() loop, a 16-bit unsigned user-supplied value (‘offset’) is read from the compressed\_data. it is subtracted from the current op and stored in **match** pointer (**op** is a pointer that starts as **dest** and moves forward). There is no verification that the **match** pointer is not smaller than **dest**. Later, there’s a copy operation from match to output pointer – possibly **copying out of bounds memory from before the ‘dest’ memory buffer**. Accessing memory outside of the buffer’s bounds can expose sensitive information or lead in certain cases to a crash of the application due to segmentation fault.

CVE-2021-42387 is a similar vulnerability to CVE-2021-42388, which exceeds the upper bounds of the compressed buffer (source) as part of the copy operation.

## CVE-2021-42389, CVE-2021-42390 and CVE-2021-42391 – Divide by zero vulnerabilities

These are divide-by-zero vulnerabilities in various codecs supported by ClickHouse. They are based on setting the first byte of the compressed buffer (described in the “Technical Background” section above) to zero. The decompression code reads the first byte of the compressed buffer and performs a modulo operation with it to get the remainder:

```
UInt8 bytes_size = source[0];
UInt8 bytes_to_skip = uncompressed_size % bytes_size;
```

In most of the cases the modulo operation in Intel x86-64 is performed by a DIV instruction, which, apart from dividing the numbers, also keeps the remainder in a register. So in case bytes\_size is 0, it will end up dividing by zero.

These vulnerabilities were found by “smart fuzzing” the decompression mechanism. Smart fuzzing leverages the knowledge of the input format for generating input data which (relatively) adheres to the expected protocol schema, instead of completely random data.

## Fixes and Workarounds

In order to fix the issues, update ClickHouse to the [v21.10.2.15-stable](https://github.com/ClickHouse/ClickHouse/releases/tag/v21.10.2.15-stable) version or later.

If upgrading is not possible, add firewall rules in the server that will restrict the access to the web port (8123) and the TCP server’s port (9000) to specific clients only.

## Are JFrog products vulnerable?

JFrog products are not vulnerable to this issue, since they do not use the ClickHouse DBMS

## Acknowledgement

We would like to thank the ClickHouse Inc. team for promptly and professionally handling this issue.

## Learn More

In addition to exposing new security vulnerabilities and threats, JFrog provides developers and security teams easy access to the latest relevant information for their software with automated security scanning. Explore how [JFrog Xray can be of help to you.](https://jfrog.com/xray)

*Questions? Thoughts?* Contact us at **research@jfrog.com** for any inquiries.

 Tags:
[security-research](/blog/tag/security-research/)
[vulnerability disclosure](/blog/tag/vulnerability-disclosure/)

[Start a Trial](https://jfrog.com/start-free/)

SHARE:

Sign up for blog updates

I agree that JFrog may use my information in accordance with the [JFrog Privacy Notice](/privacy-notice/)

Subscribe

### Popular Tags

* [CI/CD](https://jfrog.com/blog/tag/ci-cd/)
* [Artifactory](https://jfrog.com/blog/tag/artifactory/)
* [Best Practices](https://jfrog.com/blog/tag/best-practices/)
* [DevOps](https://jfrog.com/blog/tag/devops/)
* [Xray](https://jfrog.com/blog/tag/xray/)

## See what JFrog & GitHub can do together

![](https://speedmedia.jfrog.com/08612fe1-9391-4cf3-ac1a-6dd49c36b276/media.jfrog.com/wp-content/uploads/2024/08/22165740/jfrog_github_asset.png)

[Learn More](https://jfrog.com/jfrog-and-github/)

## Thank You!

Full Name\*

Email\*

I have read and agree to the [Privacy Policy](/privacy-policy/)

Proceed

Products

* [Artifactory](https://jfrog.com/artifactory/)
* [Xray](https://jfrog.com/xray/)
* [Curation](https://jfrog.com/curation/)
* [Distribution](https://jfrog.com/distribution/)
* [Container Registry](https://jfrog.com/container-registry/)
* [Connect](https://jfrog.com/connect/)
* [JFrog ML](https://jfrog.com/jfrog-ml/)

* [JFrog Platform](https://jfrog.com/platform/)

* [Start Free](https://jfrog.com/start-free/)

Resources

* [Blog](https://jfrog.com/blog/)
* [Security Research](https://research.jfrog.com/)
* [Events](https://jfrog.com/about/events/)
* [Integrations](https://jfrog.com/integration/)
* [JFrog Help Center](https://jfrog.com/help/)
* [Software Supply Chain Topics](https://jfrog.com/learn/)
* [Open Source](https://jfrog.com/community/open-source/)
* [JFrog Trust](https://jfrog.com/trust/)
* [Compare JFrog](https://jfrog.com/compare/)

Company

* [About](https://jfrog.com/about/)
* [Management](https://jfrog.com/about/management/)
* [Investor Relations](https://investors.jfrog.com/overview/default.aspx)
* [Partners](https://jfrog.com/partners/)
* [Customers](https://jfrog.com/about/customers/)
* [Careers](https://join.jfrog.com/)

* [Press](https://jfrog.com/press-room/)
* [Contact Us](https://jfrog.com/contact-us/)
* [Brand Guidelines](https://jfrog.com/brand-guidelines/)

Developer

* [Community](https://jfrog.com/community/)
* [Downloads](https://jfrog.com/community/open-source/)
* [Community Events](https://jfrog.com/community/events/)
* [Community Forum](https://stackoverflow.com/questions/tagged/artifactory)
* [Applications](https://docs.jfrog-applications.jfrog.io/)

 Follow Us

© 2025 JFrog Ltd All Rights Reserved

Discover More

* [The JNDI Strikes Back – Unauthenticated RCE in H2 Database Console](https://jfrog.com/blog/the-jndi-strikes-back-unauthenticated-rce-in-h2-database-console/)
* [What is a Software Supply Chain?](https://jfrog.com/learn/software-supply-chain/)
* [Use Case: Security Tools Consolidation](https://jfrog.com/usecase/security-tool-consolidation/)

[![JFrog Logo](data:image/svg+xml... "JFrog Logo")![JFrog Logo](https://speedmedia.jfrog.com/08612fe1-9391-4cf3-ac1a-6dd49c36b276/media.jfrog.com/wp-content/uploads/2021/12/29113553/jfrog-logo-2022.svg "JFrog Logo")](https://jfrog.com/)
[Terms of Use](/terms-of-use/)
| [Privacy Notice](https://jfrog.com/privacy-notice/)
| [Cookies Policy](https://jfrog.com/jfrog-cookies-policy/)
|
Cookies Settings
![Privacy Options](data:image/svg+xml...)![Privacy Options](https://jfrog.com/wp-content/themes/jfrog.com/assets/images/general/privacyoptions.svg)

|
[Accessibility Notice](https://jfrog.com/jfrog-accessibility-notice/)
|
Accessibility Mode

## Thank You!

Your submission has been recieved.

We will contact you soon!

OK

x

## Oops... Something went wrong

Please try again later

Continue

![close](data:image/svg+xml...)![close](https://speedmedia.jfrog.com/08612fe1-9391-4cf3-ac1a-6dd49c36b276/media.jfrog.com/wp-content/uploads/2019/12/20130026/close.png)

## Information

![frog hand](data:image/svg+xml...)

![close](https://speedmedia.jfrog.com/08612fe1-9391-4cf3-ac1a-6dd49c36b276/media.jfrog.com/wp-content/uploads/2019/12/20130026/close.png)

![US Flag](data:image/svg+xml... "flag_us")

![JFrog Logo](data:image/svg+xml... "jfrog-logo")
[![Chinese Flag](data:image/svg+xml... "flag_chinese")](https://jfrogchina.com/)



=== Content from github.com_8b1c1f79_20250108_145305.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FClickHouse%2FClickHouse%2Fblob%2F6951e8147d7a25f7bb4f7d43738793cff239db6d%2Fsrc%2FCompression%2FLZ4_decompress_faster.cpp)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FClickHouse%2FClickHouse%2Fblob%2F6951e8147d7a25f7bb4f7d43738793cff239db6d%2Fsrc%2FCompression%2FLZ4_decompress_faster.cpp)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=ClickHouse%2FClickHouse)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[ClickHouse](/ClickHouse)
/
**[ClickHouse](/ClickHouse/ClickHouse)**
Public

* [Notifications](/login?return_to=%2FClickHouse%2FClickHouse) You must be signed in to change notification settings
* [Fork
  7k](/login?return_to=%2FClickHouse%2FClickHouse)
* [Star
   38.4k](/login?return_to=%2FClickHouse%2FClickHouse)

* [Code](/ClickHouse/ClickHouse)
* [Issues
  3.7k](/ClickHouse/ClickHouse/issues)
* [Pull requests
  386](/ClickHouse/ClickHouse/pulls)
* [Discussions](/ClickHouse/ClickHouse/discussions)
* [Actions](/ClickHouse/ClickHouse/actions)
* [Projects
  0](/ClickHouse/ClickHouse/projects)
* [Wiki](/ClickHouse/ClickHouse/wiki)
* [Security](/ClickHouse/ClickHouse/security)
* [Insights](/ClickHouse/ClickHouse/pulse)

Additional navigation options

* [Code](/ClickHouse/ClickHouse)
* [Issues](/ClickHouse/ClickHouse/issues)
* [Pull requests](/ClickHouse/ClickHouse/pulls)
* [Discussions](/ClickHouse/ClickHouse/discussions)
* [Actions](/ClickHouse/ClickHouse/actions)
* [Projects](/ClickHouse/ClickHouse/projects)
* [Wiki](/ClickHouse/ClickHouse/wiki)
* [Security](/ClickHouse/ClickHouse/security)
* [Insights](/ClickHouse/ClickHouse/pulse)

## Files

 6951e81
## Breadcrumbs

1. [ClickHouse](/ClickHouse/ClickHouse/tree/6951e8147d7a25f7bb4f7d43738793cff239db6d)
2. /[src](/ClickHouse/ClickHouse/tree/6951e8147d7a25f7bb4f7d43738793cff239db6d/src)
3. /[Compression](/ClickHouse/ClickHouse/tree/6951e8147d7a25f7bb4f7d43738793cff239db6d/src/Compression)
/
# LZ4\_decompress\_faster.cpp

 Blame  Blame
## Latest commit

## History

[History](/ClickHouse/ClickHouse/commits/6951e8147d7a25f7bb4f7d43738793cff239db6d/src/Compression/LZ4_decompress_faster.cpp)646 lines (521 loc) · 19.6 KB 6951e81
## Breadcrumbs

1. [ClickHouse](/ClickHouse/ClickHouse/tree/6951e8147d7a25f7bb4f7d43738793cff239db6d)
2. /[src](/ClickHouse/ClickHouse/tree/6951e8147d7a25f7bb4f7d43738793cff239db6d/src)
3. /[Compression](/ClickHouse/ClickHouse/tree/6951e8147d7a25f7bb4f7d43738793cff239db6d/src/Compression)
/
# LZ4\_decompress\_faster.cpp

Top
## File metadata and controls

* Code
* Blame

646 lines (521 loc) · 19.6 KB[Raw](https://github.com/ClickHouse/ClickHouse/raw/6951e8147d7a25f7bb4f7d43738793cff239db6d/src/Compression/LZ4_decompress_faster.cpp)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646#include "LZ4\_decompress\_faster.h"
#include <string.h>#include <iostream>#include <Core/Defines.h>#include <Common/Stopwatch.h>#include <common/types.h>#include <common/unaligned.h>
#ifdef \_\_SSE2\_\_#include <emmintrin.h>#endif
#ifdef \_\_SSSE3\_\_#include <tmmintrin.h>#endif
#ifdef \_\_aarch64\_\_#include <arm\_neon.h>#endif
namespace LZ4{
namespace{
template <size\_t N> [[maybe\_unused]] void copy(UInt8 \* dst, const UInt8 \* src);template <size\_t N> [[maybe\_unused]] void wildCopy(UInt8 \* dst, const UInt8 \* src, UInt8 \* dst\_end);template <size\_t N, bool USE\_SHUFFLE> [[maybe\_unused]] void copyOverlap(UInt8 \* op, const UInt8 \*& match, size\_t offset);
inline void copy8(UInt8 \* dst, const UInt8 \* src){ memcpy(dst, src, 8);}
inline void wildCopy8(UInt8 \* dst, const UInt8 \* src, const UInt8 \* dst\_end){ /// Unrolling with clang is doing >10% performance degrade.#if defined(\_\_clang\_\_) #pragma nounroll#endif do { copy8(dst, src); dst += 8; src += 8; } while (dst < dst\_end);}
inline void copyOverlap8(UInt8 \* op, const UInt8 \*& match, size\_t offset){ /// 4 % n. /// Or if 4 % n is zero, we use n. /// It gives equivalent result, but is better CPU friendly for unknown reason. static constexpr int shift1[] = { 0, 1, 2, 1, 4, 4, 4, 4 };
 /// 8 % n - 4 % n static constexpr int shift2[] = { 0, 0, 0, 1, 0, -1, -2, -3 };
 op[0] = match[0]; op[1] = match[1]; op[2] = match[2]; op[3] = match[3];
 match += shift1[offset]; memcpy(op + 4, match, 4); match += shift2[offset];}
#if defined(\_\_x86\_64\_\_) || defined(\_\_PPC\_\_)
/\*\* We use 'xmm' (128bit SSE) registers here to shuffle 16 bytes. \* \* It is possible to use 'mm' (64bit MMX) registers to shuffle just 8 bytes as we need. \* \* There is corresponding version of 'pshufb' instruction that operates on 'mm' registers, \* (it operates on MMX registers although it is available in SSSE3) \* and compiler library has the corresponding intrinsic: '\_mm\_shuffle\_pi8'. \* \* It can be done like this: \* \* unalignedStore(op, \_mm\_shuffle\_pi8( \* unalignedLoad<\_\_m64>(match), \* unalignedLoad<\_\_m64>(masks + 8 \* offset))); \* \* This is perfectly correct and this code have the same or even better performance. \* \* But if we write code this way, it will lead to \* extremely weird and extremely non obvious \* effects in completely unrelated parts of code. \* \* Because using MMX registers alters the mode of operation of x87 FPU, \* and then operations with FPU become broken. \* \* Example 1. \* Compile this code without optimizations: \* #include <vector> #include <unordered\_set> #include <iostream> #include <tmmintrin.h>
 int main(int, char \*\*) { [[maybe\_unused]] \_\_m64 shuffled = \_mm\_shuffle\_pi8(\_\_m64{}, \_\_m64{});
 std::vector<int> vec; std::unordered\_set<int> set(vec.begin(), vec.end());
 std::cerr << set.size() << "\n"; return 0; }
 $ g++ -g -O0 -mssse3 -std=c++17 mmx\_bug1.cpp && ./a.out terminate called after throwing an instance of 'std::bad\_alloc' what(): std::bad\_alloc
 Also reproduced with clang. But only with libstdc++, not with libc++.
 \* Example 2.
 #include <math.h> #include <iostream> #include <tmmintrin.h>
 int main(int, char \*\*) { double max\_fill = 1;
 std::cerr << (long double)max\_fill << "\n"; [[maybe\_unused]] \_\_m64 shuffled = \_mm\_shuffle\_pi8(\_\_m64{}, \_\_m64{}); std::cerr << (long double)max\_fill << "\n";
 return 0; }
 $ g++ -g -O0 -mssse3 -std=c++17 mmx\_bug2.cpp && ./a.out 1 -nan
 \* Explanation: \* \* https://stackoverflow.com/questions/33692969/assembler-mmx-errors \* https://software.intel.com/en-us/node/524274 \* \* Actually it's possible to use 'emms' instruction after decompression routine. \* But it's more easy to just use 'xmm' registers and avoid using 'mm' registers. \*/inline void copyOverlap8Shuffle(UInt8 \* op, const UInt8 \*& match, const size\_t offset){#if defined(\_\_SSSE3\_\_) && !defined(MEMORY\_SANITIZER)
 static constexpr UInt8 \_\_attribute\_\_((\_\_aligned\_\_(8))) masks[] = { 0, 1, 2, 2, 4, 3, 2, 1, /\* offset = 0, not used as mask, but for shift amount instead \*/ 0, 0, 0, 0, 0, 0, 0, 0, /\* offset = 1 \*/ 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 2, 0, 1, 2, 0, 1, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 4, 0, 1, 2, 0, 1, 2, 3, 4, 5, 0, 1, 0, 1, 2, 3, 4, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, /\* this row is not used: padding to allow read 16 bytes starting at previous row \*/ };
 \_mm\_storeu\_si128(reinterpret\_cast<\_\_m128i \*>(op), \_mm\_shuffle\_epi8( \_mm\_loadu\_si128(reinterpret\_cast<const \_\_m128i \*>(match)), \_mm\_loadu\_si128(reinterpret\_cast<const \_\_m128i \*>(masks + 8 \* offset))));
 match += masks[offset];
#else copyOverlap8(op, match, offset);#endif}
#endif
#ifdef \_\_aarch64\_\_
inline void copyOverlap8Shuffle(UInt8 \* op, const UInt8 \*& match, const size\_t offset){ static constexpr UInt8 \_\_attribute\_\_((\_\_aligned\_\_(8))) masks[] = { 0, 1, 2, 2, 4, 3, 2, 1, /\* offset = 0, not used as mask, but for shift amount instead \*/ 0, 0, 0, 0, 0, 0, 0, 0, /\* offset = 1 \*/ 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 2, 0, 1, 2, 0, 1, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 4, 0, 1, 2, 0, 1, 2, 3, 4, 5, 0, 1, 0, 1, 2, 3, 4, 5, 6, 0, };
 unalignedStore<uint8x8\_t>(op, vtbl1\_u8(unalignedLoad<uint8x8\_t>(match), unalignedLoad<uint8x8\_t>(masks + 8 \* offset))); match += masks[offset];}
#endif
template <> void inline copy<8>(UInt8 \* dst, const UInt8 \* src) { copy8(dst, src); }template <> void inline wildCopy<8>(UInt8 \* dst, const UInt8 \* src, UInt8 \* dst\_end) { wildCopy8(dst, src, dst\_end); }template <> void inline copyOverlap<8, false>(UInt8 \* op, const UInt8 \*& match, const size\_t offset) { copyOverlap8(op, match, offset); }template <> void inline copyOverlap<8, true>(UInt8 \* op, const UInt8 \*& match, const size\_t offset) { copyOverlap8Shuffle(op, match, offset); }
inline void copy16(UInt8 \* dst, const UInt8 \* src){#ifdef \_\_SSE2\_\_ \_mm\_storeu\_si128(reinterpret\_cast<\_\_m128i \*>(dst), \_mm\_loadu\_si128(reinterpret\_cast<const \_\_m128i \*>(src)));#else memcpy(dst, src, 16);#endif}
inline void wildCopy16(UInt8 \* dst, const UInt8 \* src, const UInt8 \* dst\_end){ /// Unrolling with clang is doing >10% performance degrade.#if defined(\_\_clang\_\_) #pragma nounroll#endif do { copy16(dst, src); dst += 16; src += 16; } while (dst < dst\_end);}
inline void copyOverlap16(UInt8 \* op, const UInt8 \*& match, const size\_t offset){ /// 4 % n. static constexpr int shift1[] = { 0, 1, 2, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };
 /// 8 % n - 4 % n static constexpr int shift2[] = { 0, 0, 0, 1, 0, -1, -2, -3, -4, 4, 4, 4, 4, 4, 4, 4 };
 /// 16 % n - 8 % n static constexpr int shift3[] = { 0, 0, 0, -1, 0, -2, 2, 1, 8, -1, -2, -3, -4, -5, -6, -7 };
 op[0] = match[0]; op[1] = match[1]; op[2] = match[2]; op[3] = match[3];
 match += shift1[offset]; memcpy(op + 4, match, 4); match += shift2[offset]; memcpy(op + 8, match, 8); match += shift3[offset];}
#if defined(\_\_x86\_64\_\_) || defined(\_\_PPC\_\_)
inline void copyOverlap16Shuffle(UInt8 \* op, const UInt8 \*& match, const size\_t offset){#if defined(\_\_SSSE3\_\_) && !defined(MEMORY\_SANITIZER)
 static constexpr UInt8 \_\_attribute\_\_((\_\_aligned\_\_(16))) masks[] = { 0, 1, 2, 1, 4, 1, 4, 2, 8, 7, 6, 5, 4, 3, 2, 1, /\* offset = 0, not used as mask, but for shift amount instead \*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /\* offset = 1 \*/ 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1, 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 8, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 0, 1, 2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 0, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 0, };
 \_mm\_storeu\_si128(reinterpret\_cast<\_\_m128i \*>(op), \_mm\_shuffle\_epi8( \_mm\_loadu\_si128(reinterpret\_cast<const \_\_m128i \*>(match)), \_mm\_load\_si128(reinterpret\_cast<const \_\_m128i \*>(masks) + offset)));
 match += masks[offset];
#else copyOverlap16(op, match, offset);#endif}
#endif
#ifdef \_\_aarch64\_\_
inline void copyOverlap16Shuffle(UInt8 \* op, const UInt8 \*& match, const size\_t offset){ static constexpr UInt8 \_\_attribute\_\_((\_\_aligned\_\_(16))) masks[] = { 0, 1, 2, 1, 4, 1, 4, 2, 8, 7, 6, 5, 4, 3, 2, 1, /\* offset = 0, not used as mask, but for shift amount instead \*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /\* offset = 1 \*/ 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1, 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 8, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 0, 1, 2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 0, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 0, };
 unalignedStore<uint8x8\_t>(op, vtbl2\_u8(unalignedLoad<uint8x8x2\_t>(match), unalignedLoad<uint8x8\_t>(masks + 16 \* offset)));
 unalignedStore<uint8x8\_t>(op + 8, vtbl2\_u8(unalignedLoad<uint8x8x2\_t>(match), unalignedLoad<uint8x8\_t>(masks + 16 \* offset + 8)));
 match += masks[offset];}
#endif
template <> void inline copy<16>(UInt8 \* dst, const UInt8 \* src) { copy16(dst, src); }template <> void inline wildCopy<16>(UInt8 \* dst, const UInt8 \* src, UInt8 \* dst\_end) { wildCopy16(dst, src, dst\_end); }template <> void inline copyOverlap<16, false>(UInt8 \* op, const UInt8 \*& match, const size\_t offset) { copyOverlap16(op, match, offset); }template <> void inline copyOverlap<16, true>(UInt8 \* op, const UInt8 \*& match, const size\_t offset) { copyOverlap16Shuffle(op, match, offset); }
inline void copy32(UInt8 \* dst, const UInt8 \* src){ /// There was an AVX here but with mash with SSE instructions, we got a big slowdown.#if defined(\_\_SSE2\_\_) \_mm\_storeu\_si128(reinterpret\_cast<\_\_m128i \*>(dst), \_mm\_loadu\_si128(reinterpret\_cast<const \_\_m128i \*>(src))); \_mm\_storeu\_si128(reinterpret\_cast<\_\_m128i \*>(dst + 16), \_mm\_loadu\_si128(reinterpret\_cast<const \_\_m128i \*>(src + 16)));#else memcpy(dst, src, 16); memcpy(dst + 16, src + 16, 16);#endif}
inline void wildCopy32(UInt8 \* dst, const UInt8 \* src, const UInt8 \* dst\_end){ /// Unrolling with clang is doing >10% performance degrade.#if defined(\_\_clang\_\_) #pragma nounroll#endif do { copy32(dst, src); dst += 32; src += 32; } while (dst < dst\_end);}
inline void copyOverlap32(UInt8 \* op, const UInt8 \*& match, const size\_t offset){ /// 4 % n. static constexpr int shift1[] = { 0, 1, 2, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };
 /// 8 % n - 4 % n static constexpr int shift2[] = { 0, 0, 0, 1, 0, -1, -2, -3, -4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };
 /// 16 % n - 8 % n static constexpr int shift3[] = { 0, 0, 0, -1, 0, -2, 2, 1, 8, -1, -2, -3, -4, -5, -6, -7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 };
 /// 32 % n - 16 % n static constexpr int shift4[] = { 0, 0, 0, 1, 0, 1, -2, 2, 0, -2, -4, 5, 4, 3, 2, 1, 0, -1, -2, -3, -4, -5, -6, -7, -8, -9,-10,-11,-12,-13,-14,-15 };
 op[0] = match[0]; op[1] = match[1]; op[2] = match[2]; op[3] = match[3];
 match += shift1[offset]; memcpy(op + 4, match, 4); match += shift2[offset]; memcpy(op + 8, match, 8); match += shift3[offset]; memcpy(op + 16, match, 16); match += shift4[offset];}
template <> void inline copy<32>(UInt8 \* dst, const UInt8 \* src) { copy32(dst, src); }template <> void inline wildCopy<32>(UInt8 \* dst, const UInt8 \* src, UInt8 \* dst\_end) { wildCopy32(dst, src, dst\_end); }template <> void inline copyOverlap<32, false>(UInt8 \* op, const UInt8 \*& match, const size\_t offset) { copyOverlap32(op, match, offset); }
/// See also https://stackoverflow.com/a/30669632
template <size\_t copy\_amount, bool use\_shuffle>void NO\_INLINE decompressImpl( const char \* const source, char \* const dest, size\_t dest\_size){ const UInt8 \* ip = reinterpret\_cast<const UInt8 \*>(source); UInt8 \* op = reinterpret\_cast<UInt8 \*>(dest); UInt8 \* const output\_end = op + dest\_size;
 /// Unrolling with clang is doing >10% performance degrade.#if defined(\_\_clang\_\_) #pragma nounroll#endif while (true) { size\_t length;
 auto continue\_read\_length = [&] { unsigned s; do { s = \*ip++; length += s; } while (unlikely(s == 255)); };
 /// Get literal length.
 const unsigned token = \*ip++; length = token >> 4; if (length == 0x0F) continue\_read\_length();
 /// Copy literals.
 UInt8 \* copy\_end = op + length;
 /// input: Hello, world /// ^-ip /// output: xyz /// ^-op ^-copy\_end /// output: xyzHello, w /// ^- excessive copied bytes due to "wildCopy" /// input: Hello, world /// ^-ip /// output: xyzHello, w /// ^-op (we will overwrite excessive bytes on next iteration)
 wildCopy<copy\_amount>(op, ip, copy\_end); /// Here we can write up to copy\_amount - 1 bytes after buffer.
 ip += length; op = copy\_end;
 if (copy\_end >= output\_end) return;
 /// Get match offset.
 size\_t offset = unalignedLoad<UInt16>(ip); ip += 2; const UInt8 \* match = op - offset;
 /// Get match length.
 length = token & 0x0F; if (length == 0x0F) continue\_read\_length(); length += 4;
 /// Copy match within block, that produce overlapping pattern. Match may replicate itself.
 copy\_end = op + length;
 /\*\* Here we can write up to copy\_amount - 1 - 4 \* 2 bytes after buffer. \* The worst case when offset = 1 and length = 4 \*/
 if (unlikely(offset < copy\_amount)) { /// output: Hello /// ^-op /// ^-match; offset = 5 /// /// output: Hello /// [------] - copy\_amount bytes /// [------] - copy them here /// /// output: HelloHelloHel /// ^-match ^-op
 copyOverlap<copy\_amount, use\_shuffle>(op, match, offset); } else { copy<copy\_amount>(op, match); match += copy\_amount; }
 op += copy\_amount;
 copy<copy\_amount>(op, match); /// copy\_amount + copy\_amount - 1 - 4 \* 2 bytes after buffer. if (length > copy\_amount \* 2) wildCopy<copy\_amount>(op + copy\_amount, match + copy\_amount, copy\_end);
 op = copy\_end; }}
}
void decompress( const char \* const source, char \* const dest, size\_t source\_size, size\_t dest\_size, PerformanceStatistics & statistics [[maybe\_unused]]){ if (source\_size == 0 || dest\_size == 0) return;
 /// Don't run timer if the block is too small. if (dest\_size >= 32768) { size\_t best\_variant = statistics.select();
 /// Run the selected method and measure time.
 Stopwatch watch; if (best\_variant == 0) decompressImpl<16, true>(source, dest, dest\_size); if (best\_variant == 1) decompressImpl<16, false>(source, dest, dest\_size); if (best\_variant == 2) decompressImpl<8, true>(source, dest, dest\_size); if (best\_variant == 3) decompressImpl<32, false>(source, dest, dest\_size);
 watch.stop();
 /// Update performance statistics.
 statistics.data[best\_variant].update(watch.elapsedSeconds(), dest\_size); } else { decompressImpl<8, false>(source, dest, dest\_size); }}
void StreamStatistics::literal(size\_t length){ ++num\_tokens; sum\_literal\_lengths += length;}
void StreamStatistics::match(size\_t length, size\_t offset){ ++num\_tokens; sum\_match\_lengths += length; sum\_match\_offsets += offset; count\_match\_offset\_less\_8 += offset < 8; count\_match\_offset\_less\_16 += offset < 16; count\_match\_replicate\_itself += offset < length;}
void StreamStatistics::print() const{ std::cerr << "Num tokens: " << num\_tokens << ", Avg literal length: " << double(sum\_literal\_lengths) / num\_tokens << ", Avg match length: " << double(sum\_match\_lengths) / num\_tokens << ", Avg match offset: " << double(sum\_match\_offsets) / num\_tokens << ", Offset < 8 ratio: " << double(count\_match\_offset\_less\_8) / num\_tokens << ", Offset < 16 ratio: " << double(count\_match\_offset\_less\_16) / num\_tokens << ", Match replicate itself: " << double(count\_match\_replicate\_itself) / num\_tokens << "\n";}
void statistics( const char \* const source, char \* const dest, size\_t dest\_size, StreamStatistics & stat){ const UInt8 \* ip = reinterpret\_cast<const UInt8 \*>(source); UInt8 \* op = reinterpret\_cast<UInt8 \*>(dest); UInt8 \* const output\_end = op + dest\_size; while (true) { size\_t length;
 auto continue\_read\_length = [&] { unsigned s; do { s = \*ip++; length += s; } while (unlikely(s == 255)); };
 auto token = \*ip++; length = token >> 4; if (length == 0x0F) continue\_read\_length();
 stat.literal(length);
 ip += length; op += length;
 if (op > output\_end) return;
 size\_t offset = unalignedLoad<UInt16>(ip); ip += 2;
 length = token & 0x0F; if (length == 0x0F) continue\_read\_length(); length += 4;
 stat.match(length, offset);
 op += length; }}
}

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_b2e272f5_20250108_145306.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FClickHouse%2FClickHouse%2Fblob%2Fmaster%2Fsrc%2FCompression%2FLZ4_decompress_faster.cpp)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FClickHouse%2FClickHouse%2Fblob%2Fmaster%2Fsrc%2FCompression%2FLZ4_decompress_faster.cpp)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=ClickHouse%2FClickHouse)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[ClickHouse](/ClickHouse)
/
**[ClickHouse](/ClickHouse/ClickHouse)**
Public

* [Notifications](/login?return_to=%2FClickHouse%2FClickHouse) You must be signed in to change notification settings
* [Fork
  7k](/login?return_to=%2FClickHouse%2FClickHouse)
* [Star
   38.4k](/login?return_to=%2FClickHouse%2FClickHouse)

* [Code](/ClickHouse/ClickHouse)
* [Issues
  3.7k](/ClickHouse/ClickHouse/issues)
* [Pull requests
  386](/ClickHouse/ClickHouse/pulls)
* [Discussions](/ClickHouse/ClickHouse/discussions)
* [Actions](/ClickHouse/ClickHouse/actions)
* [Projects
  0](/ClickHouse/ClickHouse/projects)
* [Wiki](/ClickHouse/ClickHouse/wiki)
* [Security](/ClickHouse/ClickHouse/security)
* [Insights](/ClickHouse/ClickHouse/pulse)

Additional navigation options

* [Code](/ClickHouse/ClickHouse)
* [Issues](/ClickHouse/ClickHouse/issues)
* [Pull requests](/ClickHouse/ClickHouse/pulls)
* [Discussions](/ClickHouse/ClickHouse/discussions)
* [Actions](/ClickHouse/ClickHouse/actions)
* [Projects](/ClickHouse/ClickHouse/projects)
* [Wiki](/ClickHouse/ClickHouse/wiki)
* [Security](/ClickHouse/ClickHouse/security)
* [Insights](/ClickHouse/ClickHouse/pulse)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from lists.debian.org_adcdad6b_20250108_110008.html ===


---

[[Date Prev](msg00001.html)][[Date Next](msg00003.html)]
[[Thread Prev](msg00001.html)][[Thread Next](msg00003.html)]
[[Date Index](maillist.html#00002)]
[[Thread Index](threads.html#00002)]

# [SECURITY] [DLA 3176-1] clickhouse security update

---

* *To*: debian-lts-announce@lists.debian.org
* *Subject*: [SECURITY] [DLA 3176-1] clickhouse security update
* *From*: Tobias Frost <tobi@debian.org>
* *Date*: Fri, 4 Nov 2022 07:11:35 +0100
* *Message-id*: <[[🔎]](/msgid-search/Y2StF5yFLEfoMdZX%40isildor.loewenhoehle.ip) [Y2StF5yFLEfoMdZX@isildor.loewenhoehle.ip](msg00002.html)>
* *Mail-followup-to*: debian-lts@lists.debian.org
* *Reply-to*: debian-lts@lists.debian.org

---

```
-------------------------------------------------------------------------
Debian LTS Advisory DLA-3176-1                debian-lts@lists.debian.org
<https://www.debian.org/lts/security/>                         Tobias Frost
November 03, 2022                             <https://wiki.debian.org/LTS>
-------------------------------------------------------------------------

Package        : clickhouse
Version        : 18.16.1+ds-4+deb10u1
CVE ID         : CVE-2021-42387 CVE-2021-42388 CVE-2021-43304 CVE-2021-43305
Debian Bug     : 1008216

Several security vulnerabilities were discovered in clickhouse, a
column-oriented database system.

The vulnerabilities require authentication, but can be triggered by any user
with read permissions. This means the attacker must perform reconnaissance on
the specific ClickHouse server target to obtain valid credentials. Any set of
credentials would do, since even a user with the lowest privileges can trigger
all of the vulnerabilities. By triggering the vulnerabilities, an attacker can
crash the ClickHouse server, leak memory contents or even cause remote code
execution.

CVE-2021-42387:
  Heap out-of-bounds read in Clickhouse's LZ4 compression codec when
  parsing a malicious query. As part of the LZ4::decompressImpl() loop,
  a 16-bit unsigned user-supplied value ('offset') is read from the
  compressed data. The offset is later used in the length of a copy
  operation, without checking the upper bounds of the source of the copy
  operation.

CVE-2021-42388:
  Heap out-of-bounds read in Clickhouse's LZ4 compression codec when
  parsing a malicious query. As part of the LZ4::decompressImpl() loop,
  a 16-bit unsigned user-supplied value ('offset') is read from the
  compressed data. The offset is later used in the length of a copy
  operation, without checking the lower bounds of the source of the copy
  operation.

CVE-2021-43304:
  Heap buffer overflow in Clickhouse's LZ4 compression codec when
  parsing a malicious query. There is no verification that the copy
  operations in the LZ4::decompressImpl loop and especially the
  arbitrary copy operation wildCopy&lt;copy_amount&gt;(op, ip,
  copy_end), don&amp;#8217;t exceed the destination buffer&amp;#8217;s
  limits.

CVE-2021-43305:
  Heap buffer overflow in Clickhouse's LZ4 compression codec when
  parsing a malicious query. There is no verification that the copy
  operations in the LZ4::decompressImpl loop and especially the
  arbitrary copy operation wildCopy&lt;copy_amount&gt;(op, ip,
  copy_end), don&amp;#8217;t exceed the destination buffer&amp;#8217;s
  limits. This issue is very similar to CVE-2021-43304, but the
  vulnerable copy operation is in a different wildCopy call.

For Debian 10 buster, these problems have been fixed in version
18.16.1+ds-4+deb10u1.

We recommend that you upgrade your clickhouse packages.

For the detailed security status of clickhouse please refer to
its security tracker page at:
<https://security-tracker.debian.org/tracker/clickhouse>

Further information about Debian LTS security advisories, how to apply
these updates to your system and frequently asked questions can be
found at: <https://wiki.debian.org/LTS>

```

**Attachment:
[signature.asc](pgpuJEJ9zi1NA.pgp)**

*Description:* PGP signature

---


