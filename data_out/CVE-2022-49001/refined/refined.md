The provided content relates to a race condition fix in the RISC-V architecture of the Linux kernel, specifically when handling vmap stack overflows. This fix is associated with the commit ID `7e1864332fbc1b993659eab7974da9fe8bf8c128` and backported to stable branches with commits `879fabc5a95401d9bce357e4b1d24ae4a360a81f` and `ac00301adb19df54f2eae1efc4bad7447c0156ce`.

Here's a breakdown of the vulnerability and its fix:

**Root cause of vulnerability:**

- When a vmap stack overflow is detected on RISC-V, the kernel switches to a "shadow stack."
- This shadow stack is then used to call `get_overflow_stack()` to obtain the overflow stack.
- A race condition exists if multiple harts (hardware threads/cores) try to use the *same* shadow stack simultaneously.

**Weaknesses/vulnerabilities present:**

- **Race condition:** Multiple harts can concurrently attempt to utilize the same shadow stack during a vmap stack overflow, leading to data corruption and undefined behavior.

**Impact of exploitation:**

- If the race condition occurs, it can lead to kernel panics, data corruption, or other unpredictable behavior. It's likely to destabilize the system, although the content does not describe the exact outcome of the race.

**Attack vectors:**

- An attacker could trigger a vmap stack overflow, potentially by allocating large amounts of memory within the kernel address space. This would need to be done in a way that causes stack overflow on multiple cores simultaneously.

**Required attacker capabilities/position:**

- The attacker would need to have the ability to execute code that can trigger a vmap stack overflow on a multi-hart (multi-core/thread) RISC-V system. This might require root or other privileged access to cause allocation of a large amount of kernel memory.

**The fix:**

- The fix introduces a pseudo spinlock, `spin_shadow_stack`, an atomic variable.
- When a hart detects a stack overflow it attempts to atomically swap its own address into the `spin_shadow_stack`.
    - If the result of the swap is 0 it proceeds, because no other hart is currently using the shadow stack, and the atomic swap has effectively claimed the shadow stack for the current hart.
    - If the result is not 0, then another hart is already using the shadow stack and the current hart will retry.
- Once finished with the shadow stack the hart uses `smp_store_release` to clear `spin_shadow_stack` and signal that another hart may use it.
- This ensures that only one hart at a time uses the shadow stack, preventing the race condition.

The provided information gives more detail than the standard CVE description, describing the mechanism and impact of the race condition and the implementation of its fix.