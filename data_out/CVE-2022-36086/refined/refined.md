The provided content is related to CVE-2022-36086.

**Root cause of vulnerability:**
The `linked-list-allocator` crate had insufficient size checks during heap initialization and within the `Heap::extend` method, leading to potential out-of-bounds writes and other issues.

**Weaknesses/vulnerabilities present:**
- **Out-of-bounds writes during initialization:** The heap initialization functions (`Heap::new`, `Heap::init`, `Heap::init_from_slice`, and `LockedHeap::new`) did not check for a minimum size. If the provided heap size was too small (less than `3 * size_of::<usize>`), metadata writes could lead to out-of-bounds memory access.
- **Out-of-bounds writes in `Heap::extend`:**
    - When `Heap::extend` was called with a size smaller than two `usize`s, the size was rounded up incorrectly, leading to potential out-of-bounds writes.
    - Calling `Heap::extend` on an empty heap would attempt to construct a heap at address 0, causing an out-of-bounds write.
    - Calling `Heap::extend` with a non-multiple of `2 * size_of::<usize>` would result in *unaligned writes*, and leave the heap in an inconsistent state.

**Impact of exploitation:**
- Out-of-bounds writes can lead to memory corruption, potentially causing crashes or allowing arbitrary code execution.
- Unaligned writes could result in a denial of service on platforms that fault on unaligned memory access.
- Inconsistent heap state could lead to subsequent issues or unexpected behavior.

**Attack vectors:**
- Attackers can exploit the initialization issues by providing a small heap size.
- Attackers can exploit `Heap::extend` issues by calling the method with small sizes, or by calling it on an empty heap, or by calling it with non-multiple of `2 * size_of::<usize>`.

**Required attacker capabilities/position:**
- Attackers need the ability to control the heap size during initialization.
- Attackers must be able to call the vulnerable `Heap::extend` method with specific size inputs or on an empty heap.

**Additional Details**
The patch for this vulnerability (version `0.10.2`) includes the following changes:
- Initialization functions now panic if the given size is insufficient for metadata. The minimum size requirement is `2 * size_of::<usize>` and `3 * size_of::<usize>`, depending on alignment.
- The `extend` method panics when trying to extend an uninitialized heap.
- Extend calls with sizes less than `size_of::<usize>() * 2` are buffered internally.
- The `size()` method now returns the *usable* size of the heap.