
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fqemu%2Fqemu%2Fblob%2Fv6.1.0-rc4%2Fhw%2Fide%2Fahci.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fqemu%2Fqemu%2Fblob%2Fv6.1.0-rc4%2Fhw%2Fide%2Fahci.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=qemu%2Fqemu)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[qemu](/qemu)
/
**[qemu](/qemu/qemu)**
Public

* [Notifications](/login?return_to=%2Fqemu%2Fqemu) You must be signed in to change notification settings
* [Fork
  5.7k](/login?return_to=%2Fqemu%2Fqemu)
* [Star
   10.7k](/login?return_to=%2Fqemu%2Fqemu)

* [Code](/qemu/qemu/tree/v6.1.0-rc4)
* [Pull requests
  0](/qemu/qemu/pulls)
* [Actions](/qemu/qemu/actions)
* [Projects
  0](/qemu/qemu/projects)
* [Security](/qemu/qemu/security)
* [Insights](/qemu/qemu/pulse)

Additional navigation options

* [Code](/qemu/qemu/tree/v6.1.0-rc4)
* [Pull requests](/qemu/qemu/pulls)
* [Actions](/qemu/qemu/actions)
* [Projects](/qemu/qemu/projects)
* [Security](/qemu/qemu/security)
* [Insights](/qemu/qemu/pulse)

## Files

 v6.1.0-rc4
## Breadcrumbs

1. [qemu](/qemu/qemu/tree/v6.1.0-rc4)
2. /[hw](/qemu/qemu/tree/v6.1.0-rc4/hw)
3. /[ide](/qemu/qemu/tree/v6.1.0-rc4/hw/ide)
/
# ahci.c

 Blame  Blame
## Latest commit

## History

[History](/qemu/qemu/commits/v6.1.0-rc4/hw/ide/ahci.c)1843 lines (1605 loc) · 56.2 KB v6.1.0-rc4
## Breadcrumbs

1. [qemu](/qemu/qemu/tree/v6.1.0-rc4)
2. /[hw](/qemu/qemu/tree/v6.1.0-rc4/hw)
3. /[ide](/qemu/qemu/tree/v6.1.0-rc4/hw/ide)
/
# ahci.c

Top
## File metadata and controls

* Code
* Blame

1843 lines (1605 loc) · 56.2 KB[Raw](https://github.com/qemu/qemu/raw/refs/tags/v6.1.0-rc4/hw/ide/ahci.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\* \* QEMU AHCI Emulation \* \* Copyright (c) 2010 qiaochong@loongson.cn \* Copyright (c) 2010 Roland Elek <elek.roland@gmail.com> \* Copyright (c) 2010 Sebastian Herbszt <herbszt@gmx.de> \* Copyright (c) 2010 Alexander Graf <agraf@suse.de> \* \* This library is free software; you can redistribute it and/or \* modify it under the terms of the GNU Lesser General Public \* License as published by the Free Software Foundation; either \* version 2.1 of the License, or (at your option) any later version. \* \* This library is distributed in the hope that it will be useful, \* but WITHOUT ANY WARRANTY; without even the implied warranty of \* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU \* Lesser General Public License for more details. \* \* You should have received a copy of the GNU Lesser General Public \* License along with this library; if not, see <http://www.gnu.org/licenses/>. \* \*/
#include "qemu/osdep.h"#include "hw/pci/msi.h"#include "hw/pci/pci.h"#include "hw/qdev-properties.h"#include "migration/vmstate.h"
#include "qemu/error-report.h"#include "qemu/log.h"#include "qemu/main-loop.h"#include "qemu/module.h"#include "sysemu/block-backend.h"#include "sysemu/dma.h"#include "hw/ide/internal.h"#include "hw/ide/pci.h"#include "ahci\_internal.h"
#include "trace.h"
static void check\_cmd(AHCIState \*s, int port);static int handle\_cmd(AHCIState \*s, int port, uint8\_t slot);static void ahci\_reset\_port(AHCIState \*s, int port);static bool ahci\_write\_fis\_d2h(AHCIDevice \*ad);static void ahci\_init\_d2h(AHCIDevice \*ad);static int ahci\_dma\_prepare\_buf(const IDEDMA \*dma, int32\_t limit);static bool ahci\_map\_clb\_address(AHCIDevice \*ad);static bool ahci\_map\_fis\_address(AHCIDevice \*ad);static void ahci\_unmap\_clb\_address(AHCIDevice \*ad);static void ahci\_unmap\_fis\_address(AHCIDevice \*ad);
static const char \*AHCIHostReg\_lookup[AHCI\_HOST\_REG\_\_COUNT] = { [AHCI\_HOST\_REG\_CAP] = "CAP", [AHCI\_HOST\_REG\_CTL] = "GHC", [AHCI\_HOST\_REG\_IRQ\_STAT] = "IS", [AHCI\_HOST\_REG\_PORTS\_IMPL] = "PI", [AHCI\_HOST\_REG\_VERSION] = "VS", [AHCI\_HOST\_REG\_CCC\_CTL] = "CCC\_CTL", [AHCI\_HOST\_REG\_CCC\_PORTS] = "CCC\_PORTS", [AHCI\_HOST\_REG\_EM\_LOC] = "EM\_LOC", [AHCI\_HOST\_REG\_EM\_CTL] = "EM\_CTL", [AHCI\_HOST\_REG\_CAP2] = "CAP2", [AHCI\_HOST\_REG\_BOHC] = "BOHC",};
static const char \*AHCIPortReg\_lookup[AHCI\_PORT\_REG\_\_COUNT] = { [AHCI\_PORT\_REG\_LST\_ADDR] = "PxCLB", [AHCI\_PORT\_REG\_LST\_ADDR\_HI] = "PxCLBU", [AHCI\_PORT\_REG\_FIS\_ADDR] = "PxFB", [AHCI\_PORT\_REG\_FIS\_ADDR\_HI] = "PxFBU", [AHCI\_PORT\_REG\_IRQ\_STAT] = "PxIS", [AHCI\_PORT\_REG\_IRQ\_MASK] = "PXIE", [AHCI\_PORT\_REG\_CMD] = "PxCMD", [7] = "Reserved", [AHCI\_PORT\_REG\_TFDATA] = "PxTFD", [AHCI\_PORT\_REG\_SIG] = "PxSIG", [AHCI\_PORT\_REG\_SCR\_STAT] = "PxSSTS", [AHCI\_PORT\_REG\_SCR\_CTL] = "PxSCTL", [AHCI\_PORT\_REG\_SCR\_ERR] = "PxSERR", [AHCI\_PORT\_REG\_SCR\_ACT] = "PxSACT", [AHCI\_PORT\_REG\_CMD\_ISSUE] = "PxCI", [AHCI\_PORT\_REG\_SCR\_NOTIF] = "PxSNTF", [AHCI\_PORT\_REG\_FIS\_CTL] = "PxFBS", [AHCI\_PORT\_REG\_DEV\_SLEEP] = "PxDEVSLP", [18 ... 27] = "Reserved", [AHCI\_PORT\_REG\_VENDOR\_1 ... AHCI\_PORT\_REG\_VENDOR\_4] = "PxVS",};
static const char \*AHCIPortIRQ\_lookup[AHCI\_PORT\_IRQ\_\_COUNT] = { [AHCI\_PORT\_IRQ\_BIT\_DHRS] = "DHRS", [AHCI\_PORT\_IRQ\_BIT\_PSS] = "PSS", [AHCI\_PORT\_IRQ\_BIT\_DSS] = "DSS", [AHCI\_PORT\_IRQ\_BIT\_SDBS] = "SDBS", [AHCI\_PORT\_IRQ\_BIT\_UFS] = "UFS", [AHCI\_PORT\_IRQ\_BIT\_DPS] = "DPS", [AHCI\_PORT\_IRQ\_BIT\_PCS] = "PCS", [AHCI\_PORT\_IRQ\_BIT\_DMPS] = "DMPS", [8 ... 21] = "RESERVED", [AHCI\_PORT\_IRQ\_BIT\_PRCS] = "PRCS", [AHCI\_PORT\_IRQ\_BIT\_IPMS] = "IPMS", [AHCI\_PORT\_IRQ\_BIT\_OFS] = "OFS", [25] = "RESERVED", [AHCI\_PORT\_IRQ\_BIT\_INFS] = "INFS", [AHCI\_PORT\_IRQ\_BIT\_IFS] = "IFS", [AHCI\_PORT\_IRQ\_BIT\_HBDS] = "HBDS", [AHCI\_PORT\_IRQ\_BIT\_HBFS] = "HBFS", [AHCI\_PORT\_IRQ\_BIT\_TFES] = "TFES", [AHCI\_PORT\_IRQ\_BIT\_CPDS] = "CPDS"};
static uint32\_t ahci\_port\_read(AHCIState \*s, int port, int offset){ uint32\_t val; AHCIPortRegs \*pr = &s->dev[port].port\_regs; enum AHCIPortReg regnum = offset / sizeof(uint32\_t); assert(regnum < (AHCI\_PORT\_ADDR\_OFFSET\_LEN / sizeof(uint32\_t)));
 switch (regnum) { case AHCI\_PORT\_REG\_LST\_ADDR: val = pr->lst\_addr; break; case AHCI\_PORT\_REG\_LST\_ADDR\_HI: val = pr->lst\_addr\_hi; break; case AHCI\_PORT\_REG\_FIS\_ADDR: val = pr->fis\_addr; break; case AHCI\_PORT\_REG\_FIS\_ADDR\_HI: val = pr->fis\_addr\_hi; break; case AHCI\_PORT\_REG\_IRQ\_STAT: val = pr->irq\_stat; break; case AHCI\_PORT\_REG\_IRQ\_MASK: val = pr->irq\_mask; break; case AHCI\_PORT\_REG\_CMD: val = pr->cmd; break; case AHCI\_PORT\_REG\_TFDATA: val = pr->tfdata; break; case AHCI\_PORT\_REG\_SIG: val = pr->sig; break; case AHCI\_PORT\_REG\_SCR\_STAT: if (s->dev[port].port.ifs[0].blk) { val = SATA\_SCR\_SSTATUS\_DET\_DEV\_PRESENT\_PHY\_UP | SATA\_SCR\_SSTATUS\_SPD\_GEN1 | SATA\_SCR\_SSTATUS\_IPM\_ACTIVE; } else { val = SATA\_SCR\_SSTATUS\_DET\_NODEV; } break; case AHCI\_PORT\_REG\_SCR\_CTL: val = pr->scr\_ctl; break; case AHCI\_PORT\_REG\_SCR\_ERR: val = pr->scr\_err; break; case AHCI\_PORT\_REG\_SCR\_ACT: val = pr->scr\_act; break; case AHCI\_PORT\_REG\_CMD\_ISSUE: val = pr->cmd\_issue; break; default: trace\_ahci\_port\_read\_default(s, port, AHCIPortReg\_lookup[regnum], offset); val = 0; }
 trace\_ahci\_port\_read(s, port, AHCIPortReg\_lookup[regnum], offset, val); return val;}
static void ahci\_irq\_raise(AHCIState \*s){ DeviceState \*dev\_state = s->container; PCIDevice \*pci\_dev = (PCIDevice \*) object\_dynamic\_cast(OBJECT(dev\_state), TYPE\_PCI\_DEVICE);
 trace\_ahci\_irq\_raise(s);
 if (pci\_dev && msi\_enabled(pci\_dev)) { msi\_notify(pci\_dev, 0); } else { qemu\_irq\_raise(s->irq); }}
static void ahci\_irq\_lower(AHCIState \*s){ DeviceState \*dev\_state = s->container; PCIDevice \*pci\_dev = (PCIDevice \*) object\_dynamic\_cast(OBJECT(dev\_state), TYPE\_PCI\_DEVICE);
 trace\_ahci\_irq\_lower(s);
 if (!pci\_dev || !msi\_enabled(pci\_dev)) { qemu\_irq\_lower(s->irq); }}
static void ahci\_check\_irq(AHCIState \*s){ int i; uint32\_t old\_irq = s->control\_regs.irqstatus;
 s->control\_regs.irqstatus = 0; for (i = 0; i < s->ports; i++) { AHCIPortRegs \*pr = &s->dev[i].port\_regs; if (pr->irq\_stat & pr->irq\_mask) { s->control\_regs.irqstatus |= (1 << i); } } trace\_ahci\_check\_irq(s, old\_irq, s->control\_regs.irqstatus); if (s->control\_regs.irqstatus && (s->control\_regs.ghc & HOST\_CTL\_IRQ\_EN)) { ahci\_irq\_raise(s); } else { ahci\_irq\_lower(s); }}
static void ahci\_trigger\_irq(AHCIState \*s, AHCIDevice \*d, enum AHCIPortIRQ irqbit){ g\_assert((unsigned)irqbit < 32); uint32\_t irq = 1U << irqbit; uint32\_t irqstat = d->port\_regs.irq\_stat | irq;
 trace\_ahci\_trigger\_irq(s, d->port\_no, AHCIPortIRQ\_lookup[irqbit], irq, d->port\_regs.irq\_stat, irqstat, irqstat & d->port\_regs.irq\_mask);
 d->port\_regs.irq\_stat = irqstat; ahci\_check\_irq(s);}
static void map\_page(AddressSpace \*as, uint8\_t \*\*ptr, uint64\_t addr, uint32\_t wanted){ hwaddr len = wanted;
 if (\*ptr) { dma\_memory\_unmap(as, \*ptr, len, DMA\_DIRECTION\_FROM\_DEVICE, len); }
 \*ptr = dma\_memory\_map(as, addr, &len, DMA\_DIRECTION\_FROM\_DEVICE); if (len < wanted && \*ptr) { dma\_memory\_unmap(as, \*ptr, len, DMA\_DIRECTION\_FROM\_DEVICE, len); \*ptr = NULL; }}
/\*\* \* Check the cmd register to see if we should start or stop \* the DMA or FIS RX engines. \* \* @ad: Device to dis/engage. \* \* @return 0 on success, -1 on error. \*/static int ahci\_cond\_start\_engines(AHCIDevice \*ad){ AHCIPortRegs \*pr = &ad->port\_regs; bool cmd\_start = pr->cmd & PORT\_CMD\_START; bool cmd\_on = pr->cmd & PORT\_CMD\_LIST\_ON; bool fis\_start = pr->cmd & PORT\_CMD\_FIS\_RX; bool fis\_on = pr->cmd & PORT\_CMD\_FIS\_ON;
 if (cmd\_start && !cmd\_on) { if (!ahci\_map\_clb\_address(ad)) { pr->cmd &= ~PORT\_CMD\_START; error\_report("AHCI: Failed to start DMA engine: " "bad command list buffer address"); return -1; } } else if (!cmd\_start && cmd\_on) { ahci\_unmap\_clb\_address(ad); }
 if (fis\_start && !fis\_on) { if (!ahci\_map\_fis\_address(ad)) { pr->cmd &= ~PORT\_CMD\_FIS\_RX; error\_report("AHCI: Failed to start FIS receive engine: " "bad FIS receive buffer address"); return -1; } } else if (!fis\_start && fis\_on) { ahci\_unmap\_fis\_address(ad); }
 return 0;}
static void ahci\_port\_write(AHCIState \*s, int port, int offset, uint32\_t val){ AHCIPortRegs \*pr = &s->dev[port].port\_regs; enum AHCIPortReg regnum = offset / sizeof(uint32\_t); assert(regnum < (AHCI\_PORT\_ADDR\_OFFSET\_LEN / sizeof(uint32\_t))); trace\_ahci\_port\_write(s, port, AHCIPortReg\_lookup[regnum], offset, val);
 switch (regnum) { case AHCI\_PORT\_REG\_LST\_ADDR: pr->lst\_addr = val; break; case AHCI\_PORT\_REG\_LST\_ADDR\_HI: pr->lst\_addr\_hi = val; break; case AHCI\_PORT\_REG\_FIS\_ADDR: pr->fis\_addr = val; break; case AHCI\_PORT\_REG\_FIS\_ADDR\_HI: pr->fis\_addr\_hi = val; break; case AHCI\_PORT\_REG\_IRQ\_STAT: pr->irq\_stat &= ~val; ahci\_check\_irq(s); break; case AHCI\_PORT\_REG\_IRQ\_MASK: pr->irq\_mask = val & 0xfdc000ff; ahci\_check\_irq(s); break; case AHCI\_PORT\_REG\_CMD: /\* Block any Read-only fields from being set; \* including LIST\_ON and FIS\_ON. \* The spec requires to set ICC bits to zero after the ICC change \* is done. We don't support ICC state changes, therefore always \* force the ICC bits to zero. \*/ pr->cmd = (pr->cmd & PORT\_CMD\_RO\_MASK) | (val & ~(PORT\_CMD\_RO\_MASK | PORT\_CMD\_ICC\_MASK));
 /\* Check FIS RX and CLB engines \*/ ahci\_cond\_start\_engines(&s->dev[port]);
 /\* XXX usually the FIS would be pending on the bus here and issuing deferred until the OS enables FIS receival. Instead, we only submit it once - which works in most cases, but is a hack. \*/ if ((pr->cmd & PORT\_CMD\_FIS\_ON) && !s->dev[port].init\_d2h\_sent) { ahci\_init\_d2h(&s->dev[port]); }
 check\_cmd(s, port); break; case AHCI\_PORT\_REG\_TFDATA: case AHCI\_PORT\_REG\_SIG: case AHCI\_PORT\_REG\_SCR\_STAT: /\* Read Only \*/ break; case AHCI\_PORT\_REG\_SCR\_CTL: if (((pr->scr\_ctl & AHCI\_SCR\_SCTL\_DET) == 1) && ((val & AHCI\_SCR\_SCTL\_DET) == 0)) { ahci\_reset\_port(s, port); } pr->scr\_ctl = val; break; case AHCI\_PORT\_REG\_SCR\_ERR: pr->scr\_err &= ~val; break; case AHCI\_PORT\_REG\_SCR\_ACT: /\* RW1 \*/ pr->scr\_act |= val; break; case AHCI\_PORT\_REG\_CMD\_ISSUE: pr->cmd\_issue |= val; check\_cmd(s, port); break; default: trace\_ahci\_port\_write\_unimpl(s, port, AHCIPortReg\_lookup[regnum], offset, val); qemu\_log\_mask(LOG\_UNIMP, "Attempted write to unimplemented register: " "AHCI port %d register %s, offset 0x%x: 0x%"PRIx32, port, AHCIPortReg\_lookup[regnum], offset, val); break; }}
static uint64\_t ahci\_mem\_read\_32(void \*opaque, hwaddr addr){ AHCIState \*s = opaque; uint32\_t val = 0;
 if (addr < AHCI\_GENERIC\_HOST\_CONTROL\_REGS\_MAX\_ADDR) { enum AHCIHostReg regnum = addr / 4; assert(regnum < AHCI\_HOST\_REG\_\_COUNT);
 switch (regnum) { case AHCI\_HOST\_REG\_CAP: val = s->control\_regs.cap; break; case AHCI\_HOST\_REG\_CTL: val = s->control\_regs.ghc; break; case AHCI\_HOST\_REG\_IRQ\_STAT: val = s->control\_regs.irqstatus; break; case AHCI\_HOST\_REG\_PORTS\_IMPL: val = s->control\_regs.impl; break; case AHCI\_HOST\_REG\_VERSION: val = s->control\_regs.version; break; default: trace\_ahci\_mem\_read\_32\_host\_default(s, AHCIHostReg\_lookup[regnum], addr); } trace\_ahci\_mem\_read\_32\_host(s, AHCIHostReg\_lookup[regnum], addr, val); } else if ((addr >= AHCI\_PORT\_REGS\_START\_ADDR) && (addr < (AHCI\_PORT\_REGS\_START\_ADDR + (s->ports \* AHCI\_PORT\_ADDR\_OFFSET\_LEN)))) { val = ahci\_port\_read(s, (addr - AHCI\_PORT\_REGS\_START\_ADDR) >> 7, addr & AHCI\_PORT\_ADDR\_OFFSET\_MASK); } else { trace\_ahci\_mem\_read\_32\_default(s, addr, val); }
 trace\_ahci\_mem\_read\_32(s, addr, val); return val;}
/\*\* \* AHCI 1.3 section 3 ("HBA Memory Registers") \* Support unaligned 8/16/32 bit reads, and 64 bit aligned reads. \* Caller is responsible for masking unwanted higher order bytes. \*/static uint64\_t ahci\_mem\_read(void \*opaque, hwaddr addr, unsigned size){ hwaddr aligned = addr & ~0x3; int ofst = addr - aligned; uint64\_t lo = ahci\_mem\_read\_32(opaque, aligned); uint64\_t hi; uint64\_t val;
 /\* if < 8 byte read does not cross 4 byte boundary \*/ if (ofst + size <= 4) { val = lo >> (ofst \* 8); } else { g\_assert(size > 1);
 /\* If the 64bit read is unaligned, we will produce undefined \* results. AHCI does not support unaligned 64bit reads. \*/ hi = ahci\_mem\_read\_32(opaque, aligned + 4); val = (hi << 32 | lo) >> (ofst \* 8); }
 trace\_ahci\_mem\_read(opaque, size, addr, val); return val;}
static void ahci\_mem\_write(void \*opaque, hwaddr addr, uint64\_t val, unsigned size){ AHCIState \*s = opaque;
 trace\_ahci\_mem\_write(s, size, addr, val);
 /\* Only aligned reads are allowed on AHCI \*/ if (addr & 3) { qemu\_log\_mask(LOG\_GUEST\_ERROR, "ahci: Mis-aligned write to addr 0x%03" HWADDR\_PRIX "\n", addr); return; }
 if (addr < AHCI\_GENERIC\_HOST\_CONTROL\_REGS\_MAX\_ADDR) { enum AHCIHostReg regnum = addr / 4; assert(regnum < AHCI\_HOST\_REG\_\_COUNT);
 switch (regnum) { case AHCI\_HOST\_REG\_CAP: /\* R/WO, RO \*/ /\* FIXME handle R/WO \*/ break; case AHCI\_HOST\_REG\_CTL: /\* R/W \*/ if (val & HOST\_CTL\_RESET) { ahci\_reset(s); } else { s->control\_regs.ghc = (val & 0x3) | HOST\_CTL\_AHCI\_EN; ahci\_check\_irq(s); } break; case AHCI\_HOST\_REG\_IRQ\_STAT: /\* R/WC, RO \*/ s->control\_regs.irqstatus &= ~val; ahci\_check\_irq(s); break; case AHCI\_HOST\_REG\_PORTS\_IMPL: /\* R/WO, RO \*/ /\* FIXME handle R/WO \*/ break; case AHCI\_HOST\_REG\_VERSION: /\* RO \*/ /\* FIXME report write? \*/ break; default: qemu\_log\_mask(LOG\_UNIMP, "Attempted write to unimplemented register: " "AHCI host register %s, " "offset 0x%"PRIx64": 0x%"PRIx64, AHCIHostReg\_lookup[regnum], addr, val); trace\_ahci\_mem\_write\_host\_unimpl(s, size, AHCIHostReg\_lookup[regnum], addr); } trace\_ahci\_mem\_write\_host(s, size, AHCIHostReg\_lookup[regnum], addr, val); } else if ((addr >= AHCI\_PORT\_REGS\_START\_ADDR) && (addr < (AHCI\_PORT\_REGS\_START\_ADDR + (s->ports \* AHCI\_PORT\_ADDR\_OFFSET\_LEN)))) { ahci\_port\_write(s, (addr - AHCI\_PORT\_REGS\_START\_ADDR) >> 7, addr & AHCI\_PORT\_ADDR\_OFFSET\_MASK, val); } else { qemu\_log\_mask(LOG\_UNIMP, "Attempted write to unimplemented register: " "AHCI global register at offset 0x%"PRIx64": 0x%"PRIx64, addr, val); trace\_ahci\_mem\_write\_unimpl(s, size, addr, val); }}
static const MemoryRegionOps ahci\_mem\_ops = { .read = ahci\_mem\_read, .write = ahci\_mem\_write, .endianness = DEVICE\_LITTLE\_ENDIAN,};
static uint64\_t ahci\_idp\_read(void \*opaque, hwaddr addr, unsigned size){ AHCIState \*s = opaque;
 if (addr == s->idp\_offset) { /\* index register \*/ return s->idp\_index; } else if (addr == s->idp\_offset + 4) { /\* data register - do memory read at location selected by index \*/ return ahci\_mem\_read(opaque, s->idp\_index, size); } else { return 0; }}
static void ahci\_idp\_write(void \*opaque, hwaddr addr, uint64\_t val, unsigned size){ AHCIState \*s = opaque;
 if (addr == s->idp\_offset) { /\* index register - mask off reserved bits \*/ s->idp\_index = (uint32\_t)val & ((AHCI\_MEM\_BAR\_SIZE - 1) & ~3); } else if (addr == s->idp\_offset + 4) { /\* data register - do memory write at location selected by index \*/ ahci\_mem\_write(opaque, s->idp\_index, val, size); }}
static const MemoryRegionOps ahci\_idp\_ops = { .read = ahci\_idp\_read, .write = ahci\_idp\_write, .endianness = DEVICE\_LITTLE\_ENDIAN,};
static void ahci\_reg\_init(AHCIState \*s){ int i;
 s->control\_regs.cap = (s->ports - 1) | (AHCI\_NUM\_COMMAND\_SLOTS << 8) | (AHCI\_SUPPORTED\_SPEED\_GEN1 << AHCI\_SUPPORTED\_SPEED) | HOST\_CAP\_NCQ | HOST\_CAP\_AHCI | HOST\_CAP\_64;
 s->control\_regs.impl = (1 << s->ports) - 1;
 s->control\_regs.version = AHCI\_VERSION\_1\_0;
 for (i = 0; i < s->ports; i++) { s->dev[i].port\_state = STATE\_RUN; }}
static void check\_cmd(AHCIState \*s, int port){ AHCIPortRegs \*pr = &s->dev[port].port\_regs; uint8\_t slot;
 if ((pr->cmd & PORT\_CMD\_START) && pr->cmd\_issue) { for (slot = 0; (slot < 32) && pr->cmd\_issue; slot++) { if ((pr->cmd\_issue & (1U << slot)) && !handle\_cmd(s, port, slot)) { pr->cmd\_issue &= ~(1U << slot); } } }}
static void ahci\_check\_cmd\_bh(void \*opaque){ AHCIDevice \*ad = opaque;
 qemu\_bh\_delete(ad->check\_bh); ad->check\_bh = NULL;
 check\_cmd(ad->hba, ad->port\_no);}
static void ahci\_init\_d2h(AHCIDevice \*ad){ IDEState \*ide\_state = &ad->port.ifs[0]; AHCIPortRegs \*pr = &ad->port\_regs;
 if (ad->init\_d2h\_sent) { return; }
 if (ahci\_write\_fis\_d2h(ad)) { ad->init\_d2h\_sent = true; /\* We're emulating receiving the first Reg H2D Fis from the device; \* Update the SIG register, but otherwise proceed as normal. \*/ pr->sig = ((uint32\_t)ide\_state->hcyl << 24) | (ide\_state->lcyl << 16) | (ide\_state->sector << 8) | (ide\_state->nsector & 0xFF); }}
static void ahci\_set\_signature(AHCIDevice \*ad, uint32\_t sig){ IDEState \*s = &ad->port.ifs[0]; s->hcyl = sig >> 24 & 0xFF; s->lcyl = sig >> 16 & 0xFF; s->sector = sig >> 8 & 0xFF; s->nsector = sig & 0xFF;
 trace\_ahci\_set\_signature(ad->hba, ad->port\_no, s->nsector, s->sector, s->lcyl, s->hcyl, sig);}
static void ahci\_reset\_port(AHCIState \*s, int port){ AHCIDevice \*d = &s->dev[port]; AHCIPortRegs \*pr = &d->port\_regs; IDEState \*ide\_state = &d->port.ifs[0]; int i;
 trace\_ahci\_reset\_port(s, port);
 ide\_bus\_reset(&d->port); ide\_state->ncq\_queues = AHCI\_MAX\_CMDS;
 pr->scr\_stat = 0; pr->scr\_err = 0; pr->scr\_act = 0; pr->tfdata = 0x7F; pr->sig = 0xFFFFFFFF; d->busy\_slot = -1; d->init\_d2h\_sent = false;
 ide\_state = &s->dev[port].port.ifs[0]; if (!ide\_state->blk) { return; }
 /\* reset ncq queue \*/ for (i = 0; i < AHCI\_MAX\_CMDS; i++) { NCQTransferState \*ncq\_tfs = &s->dev[port].ncq\_tfs[i]; ncq\_tfs->halt = false; if (!ncq\_tfs->used) { continue; }
 if (ncq\_tfs->aiocb) { blk\_aio\_cancel(ncq\_tfs->aiocb); ncq\_tfs->aiocb = NULL; }
 /\* Maybe we just finished the request thanks to blk\_aio\_cancel() \*/ if (!ncq\_tfs->used) { continue; }
 qemu\_sglist\_destroy(&ncq\_tfs->sglist); ncq\_tfs->used = 0; }
 s->dev[port].port\_state = STATE\_RUN; if (ide\_state->drive\_kind == IDE\_CD) { ahci\_set\_signature(d, SATA\_SIGNATURE\_CDROM);\ ide\_state->status = SEEK\_STAT | WRERR\_STAT | READY\_STAT; } else { ahci\_set\_signature(d, SATA\_SIGNATURE\_DISK); ide\_state->status = SEEK\_STAT | WRERR\_STAT; }
 ide\_state->error = 1; ahci\_init\_d2h(d);}
/\* Buffer pretty output based on a raw FIS structure. \*/static char \*ahci\_pretty\_buffer\_fis(const uint8\_t \*fis, int cmd\_len){ int i; GString \*s = g\_string\_new("FIS:");
 for (i = 0; i < cmd\_len; i++) { if ((i & 0xf) == 0) { g\_string\_append\_printf(s, "\n0x%02x: ", i); } g\_string\_append\_printf(s, "%02x ", fis[i]); } g\_string\_append\_c(s, '\n');
 return g\_string\_free(s, FALSE);}
static bool ahci\_map\_fis\_address(AHCIDevice \*ad){ AHCIPortRegs \*pr = &ad->port\_regs; map\_page(ad->hba->as, &ad->res\_fis, ((uint64\_t)pr->fis\_addr\_hi << 32) | pr->fis\_addr, 256); if (ad->res\_fis != NULL) { pr->cmd |= PORT\_CMD\_FIS\_ON; return true; }
 pr->cmd &= ~PORT\_CMD\_FIS\_ON; return false;}
static void ahci\_unmap\_fis\_address(AHCIDevice \*ad){ if (ad->res\_fis == NULL) { trace\_ahci\_unmap\_fis\_address\_null(ad->hba, ad->port\_no); return; } ad->port\_regs.cmd &= ~PORT\_CMD\_FIS\_ON; dma\_memory\_unmap(ad->hba->as, ad->res\_fis, 256, DMA\_DIRECTION\_FROM\_DEVICE, 256); ad->res\_fis = NULL;}
static bool ahci\_map\_clb\_address(AHCIDevice \*ad){ AHCIPortRegs \*pr = &ad->port\_regs; ad->cur\_cmd = NULL; map\_page(ad->hba->as, &ad->lst, ((uint64\_t)pr->lst\_addr\_hi << 32) | pr->lst\_addr, 1024); if (ad->lst != NULL) { pr->cmd |= PORT\_CMD\_LIST\_ON; return true; }
 pr->cmd &= ~PORT\_CMD\_LIST\_ON; return false;}
static void ahci\_unmap\_clb\_address(AHCIDevice \*ad){ if (ad->lst == NULL) { trace\_ahci\_unmap\_clb\_address\_null(ad->hba, ad->port\_no); return; } ad->port\_regs.cmd &= ~PORT\_CMD\_LIST\_ON; dma\_memory\_unmap(ad->hba->as, ad->lst, 1024, DMA\_DIRECTION\_FROM\_DEVICE, 1024); ad->lst = NULL;}
static void ahci\_write\_fis\_sdb(AHCIState \*s, NCQTransferState \*ncq\_tfs){ AHCIDevice \*ad = ncq\_tfs->drive; AHCIPortRegs \*pr = &ad->port\_regs; IDEState \*ide\_state; SDBFIS \*sdb\_fis;
 if (!ad->res\_fis || !(pr->cmd & PORT\_CMD\_FIS\_RX)) { return; }
 sdb\_fis = (SDBFIS \*)&ad->res\_fis[RES\_FIS\_SDBFIS]; ide\_state = &ad->port.ifs[0];
 sdb\_fis->type = SATA\_FIS\_TYPE\_SDB; /\* Interrupt pending & Notification bit \*/ sdb\_fis->flags = 0x40; /\* Interrupt bit, always 1 for NCQ \*/ sdb\_fis->status = ide\_state->status & 0x77; sdb\_fis->error = ide\_state->error; /\* update SAct field in SDB\_FIS \*/ sdb\_fis->payload = cpu\_to\_le32(ad->finished);
 /\* Update shadow registers (except BSY 0x80 and DRQ 0x08) \*/ pr->tfdata = (ad->port.ifs[0].error << 8) | (ad->port.ifs[0].status & 0x77) | (pr->tfdata & 0x88); pr->scr\_act &= ~ad->finished; ad->finished = 0;
 /\* Trigger IRQ if interrupt bit is set (which currently, it always is) \*/ if (sdb\_fis->flags & 0x40) { ahci\_trigger\_irq(s, ad, AHCI\_PORT\_IRQ\_BIT\_SDBS); }}
static void ahci\_write\_fis\_pio(AHCIDevice \*ad, uint16\_t len, bool pio\_fis\_i){ AHCIPortRegs \*pr = &ad->port\_regs; uint8\_t \*pio\_fis; IDEState \*s = &ad->port.ifs[0];
 if (!ad->res\_fis || !(pr->cmd & PORT\_CMD\_FIS\_RX)) { return; }
 pio\_fis = &ad->res\_fis[RES\_FIS\_PSFIS];
 pio\_fis[0] = SATA\_FIS\_TYPE\_PIO\_SETUP; pio\_fis[1] = (pio\_fis\_i ? (1 << 6) : 0); pio\_fis[2] = s->status; pio\_fis[3] = s->error;
 pio\_fis[4] = s->sector; pio\_fis[5] = s->lcyl; pio\_fis[6] = s->hcyl; pio\_fis[7] = s->select; pio\_fis[8] = s->hob\_sector; pio\_fis[9] = s->hob\_lcyl; pio\_fis[10] = s->hob\_hcyl; pio\_fis[11] = 0; pio\_fis[12] = s->nsector & 0xFF; pio\_fis[13] = (s->nsector >> 8) & 0xFF; pio\_fis[14] = 0; pio\_fis[15] = s->status; pio\_fis[16] = len & 255; pio\_fis[17] = len >> 8; pio\_fis[18] = 0; pio\_fis[19] = 0;
 /\* Update shadow registers: \*/ pr->tfdata = (ad->port.ifs[0].error << 8) | ad->port.ifs[0].status;
 if (pio\_fis[2] & ERR\_STAT) { ahci\_trigger\_irq(ad->hba, ad, AHCI\_PORT\_IRQ\_BIT\_TFES); }}
static bool ahci\_write\_fis\_d2h(AHCIDevice \*ad){ AHCIPortRegs \*pr = &ad->port\_regs; uint8\_t \*d2h\_fis; int i; IDEState \*s = &ad->port.ifs[0];
 if (!ad->res\_fis || !(pr->cmd & PORT\_CMD\_FIS\_RX)) { return false; }
 d2h\_fis = &ad->res\_fis[RES\_FIS\_RFIS];
 d2h\_fis[0] = SATA\_FIS\_TYPE\_REGISTER\_D2H; d2h\_fis[1] = (1 << 6); /\* interrupt bit \*/ d2h\_fis[2] = s->status; d2h\_fis[3] = s->error;
 d2h\_fis[4] = s->sector; d2h\_fis[5] = s->lcyl; d2h\_fis[6] = s->hcyl; d2h\_fis[7] = s->select; d2h\_fis[8] = s->hob\_sector; d2h\_fis[9] = s->hob\_lcyl; d2h\_fis[10] = s->hob\_hcyl; d2h\_fis[11] = 0; d2h\_fis[12] = s->nsector & 0xFF; d2h\_fis[13] = (s->nsector >> 8) & 0xFF; for (i = 14; i < 20; i++) { d2h\_fis[i] = 0; }
 /\* Update shadow registers: \*/ pr->tfdata = (ad->port.ifs[0].error << 8) | ad->port.ifs[0].status;
 if (d2h\_fis[2] & ERR\_STAT) { ahci\_trigger\_irq(ad->hba, ad, AHCI\_PORT\_IRQ\_BIT\_TFES); }
 ahci\_trigger\_irq(ad->hba, ad, AHCI\_PORT\_IRQ\_BIT\_DHRS); return true;}
static int prdt\_tbl\_entry\_size(const AHCI\_SG \*tbl){ /\* flags\_size is zero-based \*/ return (le32\_to\_cpu(tbl->flags\_size) & AHCI\_PRDT\_SIZE\_MASK) + 1;}
/\*\* \* Fetch entries in a guest-provided PRDT and convert it into a QEMU SGlist. \* @ad: The AHCIDevice for whom we are building the SGList. \* @sglist: The SGList target to add PRD entries to. \* @cmd: The AHCI Command Header that describes where the PRDT is. \* @limit: The remaining size of the S/ATA transaction, in bytes. \* @offset: The number of bytes already transferred, in bytes. \* \* The AHCI PRDT can describe up to 256GiB. S/ATA only support transactions of \* up to 32MiB as of ATA8-ACS3 rev 1b, assuming a 512 byte sector size. We stop \* building the sglist from the PRDT as soon as we hit @limit bytes, \* which is <= INT32\_MAX/2GiB. \*/static int ahci\_populate\_sglist(AHCIDevice \*ad, QEMUSGList \*sglist, AHCICmdHdr \*cmd, int64\_t limit, uint64\_t offset){ uint16\_t opts = le16\_to\_cpu(cmd->opts); uint16\_t prdtl = le16\_to\_cpu(cmd->prdtl); uint64\_t cfis\_addr = le64\_to\_cpu(cmd->tbl\_addr); uint64\_t prdt\_addr = cfis\_addr + 0x80; dma\_addr\_t prdt\_len = (prdtl \* sizeof(AHCI\_SG)); dma\_addr\_t real\_prdt\_len = prdt\_len; uint8\_t \*prdt; int i; int r = 0; uint64\_t sum = 0; int off\_idx = -1; int64\_t off\_pos = -1; int tbl\_entry\_size; IDEBus \*bus = &ad->port; BusState \*qbus = BUS(bus);
 trace\_ahci\_populate\_sglist(ad->hba, ad->port\_no);
 if (!prdtl) { trace\_ahci\_populate\_sglist\_no\_prdtl(ad->hba, ad->port\_no, opts); return -1; }
 /\* map PRDT \*/ if (!(prdt = dma\_memory\_map(ad->hba->as, prdt\_addr, &prdt\_len, DMA\_DIRECTION\_TO\_DEVICE))){ trace\_ahci\_populate\_sglist\_no\_map(ad->hba, ad->port\_no); return -1; }
 if (prdt\_len < real\_prdt\_len) { trace\_ahci\_populate\_sglist\_short\_map(ad->hba, ad->port\_no); r = -1; goto out; }
 /\* Get entries in the PRDT, init a qemu sglist accordingly \*/ if (prdtl > 0) { AHCI\_SG \*tbl = (AHCI\_SG \*)prdt; sum = 0; for (i = 0; i < prdtl; i++) { tbl\_entry\_size = prdt\_tbl\_entry\_size(&tbl[i]); if (offset < (sum + tbl\_entry\_size)) { off\_idx = i; off\_pos = offset - sum; break; } sum += tbl\_entry\_size; } if ((off\_idx == -1) || (off\_pos < 0) || (off\_pos > tbl\_entry\_size)) { trace\_ahci\_populate\_sglist\_bad\_offset(ad->hba, ad->port\_no, off\_idx, off\_pos); r = -1; goto out; }
 qemu\_sglist\_init(sglist, qbus->parent, (prdtl - off\_idx), ad->hba->as); qemu\_sglist\_add(sglist, le64\_to\_cpu(tbl[off\_idx].addr) + off\_pos, MIN(prdt\_tbl\_entry\_size(&tbl[off\_idx]) - off\_pos, limit));
 for (i = off\_idx + 1; i < prdtl && sglist->size < limit; i++) { qemu\_sglist\_add(sglist, le64\_to\_cpu(tbl[i].addr), MIN(prdt\_tbl\_entry\_size(&tbl[i]), limit - sglist->size)); } }
out: dma\_memory\_unmap(ad->hba->as, prdt, prdt\_len, DMA\_DIRECTION\_TO\_DEVICE, prdt\_len); return r;}
static void ncq\_err(NCQTransferState \*ncq\_tfs){ IDEState \*ide\_state = &ncq\_tfs->drive->port.ifs[0];
 ide\_state->error = ABRT\_ERR; ide\_state->status = READY\_STAT | ERR\_STAT; ncq\_tfs->drive->port\_regs.scr\_err |= (1 << ncq\_tfs->tag); qemu\_sglist\_destroy(&ncq\_tfs->sglist); ncq\_tfs->used = 0;[View remainder of file in raw view](https://github.com/qemu/qemu/raw/refs/tags/v6.1.0-rc4/hw/ide/ahci.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

