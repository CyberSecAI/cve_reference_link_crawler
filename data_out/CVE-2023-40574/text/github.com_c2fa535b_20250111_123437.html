
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FFreeRDP%2FFreeRDP%2Fblob%2F5be5553e0da72178a4b94cc1ffbdace9ceb153e5%2Flibfreerdp%2Fprimitives%2Fprim_YUV.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FFreeRDP%2FFreeRDP%2Fblob%2F5be5553e0da72178a4b94cc1ffbdace9ceb153e5%2Flibfreerdp%2Fprimitives%2Fprim_YUV.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=FreeRDP%2FFreeRDP)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[FreeRDP](/FreeRDP)
/
**[FreeRDP](/FreeRDP/FreeRDP)**
Public

* [Notifications](/login?return_to=%2FFreeRDP%2FFreeRDP) You must be signed in to change notification settings
* [Fork
  14.9k](/login?return_to=%2FFreeRDP%2FFreeRDP)
* [Star
   11.2k](/login?return_to=%2FFreeRDP%2FFreeRDP)

* [Code](/FreeRDP/FreeRDP)
* [Issues
  228](/FreeRDP/FreeRDP/issues)
* [Pull requests
  22](/FreeRDP/FreeRDP/pulls)
* [Discussions](/FreeRDP/FreeRDP/discussions)
* [Actions](/FreeRDP/FreeRDP/actions)
* [Projects
  0](/FreeRDP/FreeRDP/projects)
* [Wiki](/FreeRDP/FreeRDP/wiki)
* [Security](/FreeRDP/FreeRDP/security)
* [Insights](/FreeRDP/FreeRDP/pulse)

Additional navigation options

* [Code](/FreeRDP/FreeRDP)
* [Issues](/FreeRDP/FreeRDP/issues)
* [Pull requests](/FreeRDP/FreeRDP/pulls)
* [Discussions](/FreeRDP/FreeRDP/discussions)
* [Actions](/FreeRDP/FreeRDP/actions)
* [Projects](/FreeRDP/FreeRDP/projects)
* [Wiki](/FreeRDP/FreeRDP/wiki)
* [Security](/FreeRDP/FreeRDP/security)
* [Insights](/FreeRDP/FreeRDP/pulse)

## Files

 5be5553
## Breadcrumbs

1. [FreeRDP](/FreeRDP/FreeRDP/tree/5be5553e0da72178a4b94cc1ffbdace9ceb153e5)
2. /[libfreerdp](/FreeRDP/FreeRDP/tree/5be5553e0da72178a4b94cc1ffbdace9ceb153e5/libfreerdp)
3. /[primitives](/FreeRDP/FreeRDP/tree/5be5553e0da72178a4b94cc1ffbdace9ceb153e5/libfreerdp/primitives)
/
# prim\_YUV.c

Copy path Blame  Blame
## Latest commit

## History

[History](/FreeRDP/FreeRDP/commits/5be5553e0da72178a4b94cc1ffbdace9ceb153e5/libfreerdp/primitives/prim_YUV.c)1755 lines (1557 loc) · 47.1 KB 5be5553
## Breadcrumbs

1. [FreeRDP](/FreeRDP/FreeRDP/tree/5be5553e0da72178a4b94cc1ffbdace9ceb153e5)
2. /[libfreerdp](/FreeRDP/FreeRDP/tree/5be5553e0da72178a4b94cc1ffbdace9ceb153e5/libfreerdp)
3. /[primitives](/FreeRDP/FreeRDP/tree/5be5553e0da72178a4b94cc1ffbdace9ceb153e5/libfreerdp/primitives)
/
# prim\_YUV.c

Top
## File metadata and controls

* Code
* Blame

1755 lines (1557 loc) · 47.1 KB[Raw](https://github.com/FreeRDP/FreeRDP/raw/5be5553e0da72178a4b94cc1ffbdace9ceb153e5/libfreerdp/primitives/prim_YUV.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\*\* \* FreeRDP: A Remote Desktop Protocol Implementation \* Generic YUV/RGB conversion operations \* \* Copyright 2014 Marc-Andre Moreau <marcandre.moreau@gmail.com> \* Copyright 2015-2017 Armin Novak <armin.novak@thincast.com> \* Copyright 2015-2017 Norbert Federa <norbert.federa@thincast.com> \* Copyright 2015-2017 Vic Lee \* Copyright 2015-2017 Thincast Technologies GmbH \* \* Licensed under the Apache License, Version 2.0 (the "License"); \* you may not use this file except in compliance with the License. \* You may obtain a copy of the License at \* \* http://www.apache.org/licenses/LICENSE-2.0 \* \* Unless required by applicable law or agreed to in writing, software \* distributed under the License is distributed on an "AS IS" BASIS, \* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \* See the License for the specific language governing permissions and \* limitations under the License. \*/
#include <freerdp/config.h>
#include <freerdp/types.h>#include <freerdp/primitives.h>#include <freerdp/codec/color.h>#include "prim\_internal.h"
static pstatus\_t general\_LumaToYUV444(const BYTE\* const pSrcRaw[3], const UINT32 srcStep[3], BYTE\* pDstRaw[3], const UINT32 dstStep[3], const RECTANGLE\_16\* roi){ const UINT32 nWidth = roi->right - roi->left; const UINT32 nHeight = roi->bottom - roi->top; const UINT32 halfWidth = (nWidth + 1) / 2; const UINT32 halfHeight = (nHeight + 1) / 2; const UINT32 oddY = 1; const UINT32 evenY = 0; const UINT32 oddX = 1; const UINT32 evenX = 0; const BYTE\* pSrc[3] = { pSrcRaw[0] + roi->top \* srcStep[0] + roi->left, pSrcRaw[1] + roi->top / 2 \* srcStep[1] + roi->left / 2, pSrcRaw[2] + roi->top / 2 \* srcStep[2] + roi->left / 2 }; BYTE\* pDst[3] = { pDstRaw[0] + roi->top \* dstStep[0] + roi->left, pDstRaw[1] + roi->top \* dstStep[1] + roi->left, pDstRaw[2] + roi->top \* dstStep[2] + roi->left };
 /\* Y data is already here... \*/ /\* B1 \*/ for (UINT32 y = 0; y < nHeight; y++) { const BYTE\* Ym = pSrc[0] + srcStep[0] \* y; BYTE\* pY = pDst[0] + dstStep[0] \* y; memcpy(pY, Ym, nWidth); }
 /\* The first half of U, V are already here part of this frame. \*/ /\* B2 and B3 \*/ for (UINT32 y = 0; y < halfHeight; y++) { const UINT32 val2y = (2 \* y + evenY); const UINT32 val2y1 = val2y + oddY; const BYTE\* Um = pSrc[1] + srcStep[1] \* y; const BYTE\* Vm = pSrc[2] + srcStep[2] \* y; BYTE\* pU = pDst[1] + dstStep[1] \* val2y; BYTE\* pV = pDst[2] + dstStep[2] \* val2y; BYTE\* pU1 = pDst[1] + dstStep[1] \* val2y1; BYTE\* pV1 = pDst[2] + dstStep[2] \* val2y1;
 for (UINT32 x = 0; x < halfWidth; x++) { const UINT32 val2x = 2 \* x + evenX; const UINT32 val2x1 = val2x + oddX; pU[val2x] = Um[x]; pV[val2x] = Vm[x]; pU[val2x1] = Um[x]; pV[val2x1] = Vm[x]; pU1[val2x] = Um[x]; pV1[val2x] = Vm[x]; pU1[val2x1] = Um[x]; pV1[val2x1] = Vm[x]; } }
 return PRIMITIVES\_SUCCESS;}
static pstatus\_t general\_ChromaFilter(BYTE\* pDst[3], const UINT32 dstStep[3], const RECTANGLE\_16\* roi){ const UINT32 oddY = 1; const UINT32 evenY = 0; const UINT32 nWidth = roi->right - roi->left; const UINT32 nHeight = roi->bottom - roi->top; const UINT32 halfHeight = (nHeight + 1) / 2; const UINT32 halfWidth = (nWidth + 1) / 2; UINT32 x, y;
 /\* Filter \*/ for (y = roi->top; y < halfHeight + roi->top; y++) { const UINT32 val2y = (y \* 2 + evenY); const UINT32 val2y1 = val2y + oddY; BYTE\* pU1 = pDst[1] + dstStep[1] \* val2y1; BYTE\* pV1 = pDst[2] + dstStep[2] \* val2y1; BYTE\* pU = pDst[1] + dstStep[1] \* val2y; BYTE\* pV = pDst[2] + dstStep[2] \* val2y;
 if (val2y1 > nHeight) continue;
 for (x = roi->left; x < halfWidth + roi->left; x++) { const UINT32 val2x = (x \* 2); const UINT32 val2x1 = val2x + 1; const BYTE inU = pU[val2x]; const BYTE inV = pV[val2x]; const INT32 up = inU \* 4; const INT32 vp = inV \* 4; INT32 u2020; INT32 v2020;
 if (val2x1 > nWidth) continue;
 u2020 = up - pU[val2x1] - pU1[val2x] - pU1[val2x1]; v2020 = vp - pV[val2x1] - pV1[val2x] - pV1[val2x1];
 pU[val2x] = CONDITIONAL\_CLIP(u2020, inU); pV[val2x] = CONDITIONAL\_CLIP(v2020, inV); } }
 return PRIMITIVES\_SUCCESS;}
static pstatus\_t general\_ChromaV1ToYUV444(const BYTE\* const pSrcRaw[3], const UINT32 srcStep[3], BYTE\* pDstRaw[3], const UINT32 dstStep[3], const RECTANGLE\_16\* roi){ const UINT32 mod = 16; UINT32 uY = 0; UINT32 vY = 0; UINT32 x, y; const UINT32 nWidth = roi->right - roi->left; const UINT32 nHeight = roi->bottom - roi->top; const UINT32 halfWidth = (nWidth) / 2; const UINT32 halfHeight = (nHeight) / 2; const UINT32 oddY = 1; const UINT32 evenY = 0; const UINT32 oddX = 1; /\* The auxilary frame is aligned to multiples of 16x16. \* We need the padded height for B4 and B5 conversion. \*/ const UINT32 padHeigth = nHeight + 16 - nHeight % 16; const BYTE\* pSrc[3] = { pSrcRaw[0] + roi->top \* srcStep[0] + roi->left, pSrcRaw[1] + roi->top / 2 \* srcStep[1] + roi->left / 2, pSrcRaw[2] + roi->top / 2 \* srcStep[2] + roi->left / 2 }; BYTE\* pDst[3] = { pDstRaw[0] + roi->top \* dstStep[0] + roi->left, pDstRaw[1] + roi->top \* dstStep[1] + roi->left, pDstRaw[2] + roi->top \* dstStep[2] + roi->left };
 /\* The second half of U and V is a bit more tricky... \*/ /\* B4 and B5 \*/ for (y = 0; y < padHeigth; y++) { const BYTE\* Ya = pSrc[0] + srcStep[0] \* y; BYTE\* pX;
 if ((y) % mod < (mod + 1) / 2) { const UINT32 pos = (2 \* uY++ + oddY);
 if (pos >= nHeight) continue;
 pX = pDst[1] + dstStep[1] \* pos; } else { const UINT32 pos = (2 \* vY++ + oddY);
 if (pos >= nHeight) continue;
 pX = pDst[2] + dstStep[2] \* pos; }
 memcpy(pX, Ya, nWidth); }
 /\* B6 and B7 \*/ for (y = 0; y < halfHeight; y++) { const UINT32 val2y = (y \* 2 + evenY); const BYTE\* Ua = pSrc[1] + srcStep[1] \* y; const BYTE\* Va = pSrc[2] + srcStep[2] \* y; BYTE\* pU = pDst[1] + dstStep[1] \* val2y; BYTE\* pV = pDst[2] + dstStep[2] \* val2y;
 for (x = 0; x < halfWidth; x++) { const UINT32 val2x1 = (x \* 2 + oddX); pU[val2x1] = Ua[x]; pV[val2x1] = Va[x]; } }
 /\* Filter \*/ return general\_ChromaFilter(pDst, dstStep, roi);}
static pstatus\_t general\_ChromaV2ToYUV444(const BYTE\* const pSrc[3], const UINT32 srcStep[3], UINT32 nTotalWidth, UINT32 nTotalHeight, BYTE\* pDst[3], const UINT32 dstStep[3], const RECTANGLE\_16\* roi){ UINT32 x, y; const UINT32 nWidth = roi->right - roi->left; const UINT32 nHeight = roi->bottom - roi->top; const UINT32 halfWidth = (nWidth + 1) / 2; const UINT32 halfHeight = (nHeight + 1) / 2; const UINT32 quaterWidth = (nWidth + 3) / 4;
 /\* B4 and B5: odd UV values for width/2, height \*/ for (y = 0; y < nHeight; y++) { const UINT32 yTop = y + roi->top; const BYTE\* pYaU = pSrc[0] + srcStep[0] \* yTop + roi->left / 2; const BYTE\* pYaV = pYaU + nTotalWidth / 2; BYTE\* pU = pDst[1] + dstStep[1] \* yTop + roi->left; BYTE\* pV = pDst[2] + dstStep[2] \* yTop + roi->left;
 for (x = 0; x < halfWidth; x++) { const UINT32 odd = 2 \* x + 1; pU[odd] = \*pYaU++; pV[odd] = \*pYaV++; } }
 /\* B6 - B9 \*/ for (y = 0; y < halfHeight; y++) { const BYTE\* pUaU = pSrc[1] + srcStep[1] \* (y + roi->top / 2) + roi->left / 4; const BYTE\* pUaV = pUaU + nTotalWidth / 4; const BYTE\* pVaU = pSrc[2] + srcStep[2] \* (y + roi->top / 2) + roi->left / 4; const BYTE\* pVaV = pVaU + nTotalWidth / 4; BYTE\* pU = pDst[1] + dstStep[1] \* (2 \* y + 1 + roi->top) + roi->left; BYTE\* pV = pDst[2] + dstStep[2] \* (2 \* y + 1 + roi->top) + roi->left;
 for (x = 0; x < quaterWidth; x++) { pU[4 \* x + 0] = \*pUaU++; pV[4 \* x + 0] = \*pUaV++; pU[4 \* x + 2] = \*pVaU++; pV[4 \* x + 2] = \*pVaV++; } }
 return general\_ChromaFilter(pDst, dstStep, roi);}
static pstatus\_t general\_YUV420CombineToYUV444(avc444\_frame\_type type, const BYTE\* const pSrc[3], const UINT32 srcStep[3], UINT32 nWidth, UINT32 nHeight, BYTE\* pDst[3], const UINT32 dstStep[3], const RECTANGLE\_16\* roi){ if (!pSrc || !pSrc[0] || !pSrc[1] || !pSrc[2]) return -1;
 if (!pDst || !pDst[0] || !pDst[1] || !pDst[2]) return -1;
 if (!roi) return -1;
 switch (type) { case AVC444\_LUMA: return general\_LumaToYUV444(pSrc, srcStep, pDst, dstStep, roi);
 case AVC444\_CHROMAv1: return general\_ChromaV1ToYUV444(pSrc, srcStep, pDst, dstStep, roi);
 case AVC444\_CHROMAv2: return general\_ChromaV2ToYUV444(pSrc, srcStep, nWidth, nHeight, pDst, dstStep, roi);
 default: return -1; }}
static pstatus\_t general\_YUV444SplitToYUV420(const BYTE\* const pSrc[3], const UINT32 srcStep[3], BYTE\* pMainDst[3], const UINT32 dstMainStep[3], BYTE\* pAuxDst[3], const UINT32 dstAuxStep[3], const prim\_size\_t\* roi){ UINT32 x, y, uY = 0, vY = 0; UINT32 halfWidth, halfHeight; /\* The auxilary frame is aligned to multiples of 16x16. \* We need the padded height for B4 and B5 conversion. \*/ const UINT32 padHeigth = roi->height + 16 - roi->height % 16; halfWidth = (roi->width + 1) / 2; halfHeight = (roi->height + 1) / 2;
 /\* B1 \*/ for (y = 0; y < roi->height; y++) { const BYTE\* pSrcY = pSrc[0] + y \* srcStep[0]; BYTE\* pY = pMainDst[0] + y \* dstMainStep[0]; memcpy(pY, pSrcY, roi->width); }
 /\* B2 and B3 \*/ for (y = 0; y < halfHeight; y++) { const BYTE\* pSrcU = pSrc[1] + 2 \* y \* srcStep[1]; const BYTE\* pSrcV = pSrc[2] + 2 \* y \* srcStep[2]; const BYTE\* pSrcU1 = pSrc[1] + (2 \* y + 1) \* srcStep[1]; const BYTE\* pSrcV1 = pSrc[2] + (2 \* y + 1) \* srcStep[2]; BYTE\* pU = pMainDst[1] + y \* dstMainStep[1]; BYTE\* pV = pMainDst[2] + y \* dstMainStep[2];
 for (x = 0; x < halfWidth; x++) { /\* Filter \*/ const INT32 u = pSrcU[2 \* x] + pSrcU[2 \* x + 1] + pSrcU1[2 \* x] + pSrcU1[2 \* x + 1]; const INT32 v = pSrcV[2 \* x] + pSrcV[2 \* x + 1] + pSrcV1[2 \* x] + pSrcV1[2 \* x + 1]; pU[x] = CLIP(u / 4L); pV[x] = CLIP(v / 4L); } }
 /\* B4 and B5 \*/ for (y = 0; y < padHeigth; y++) { BYTE\* pY = pAuxDst[0] + y \* dstAuxStep[0];
 if (y % 16 < 8) { const UINT32 pos = (2 \* uY++ + 1); const BYTE\* pSrcU = pSrc[1] + pos \* srcStep[1];
 if (pos >= roi->height) continue;
 memcpy(pY, pSrcU, roi->width); } else { const UINT32 pos = (2 \* vY++ + 1); const BYTE\* pSrcV = pSrc[2] + pos \* srcStep[2];
 if (pos >= roi->height) continue;
 memcpy(pY, pSrcV, roi->width); } }
 /\* B6 and B7 \*/ for (y = 0; y < halfHeight; y++) { const BYTE\* pSrcU = pSrc[1] + 2 \* y \* srcStep[1]; const BYTE\* pSrcV = pSrc[2] + 2 \* y \* srcStep[2]; BYTE\* pU = pAuxDst[1] + y \* dstAuxStep[1]; BYTE\* pV = pAuxDst[2] + y \* dstAuxStep[2];
 for (x = 0; x < halfWidth; x++) { pU[x] = pSrcU[2 \* x + 1]; pV[x] = pSrcV[2 \* x + 1]; } }
 return PRIMITIVES\_SUCCESS;}
static pstatus\_t general\_YUV444ToRGB\_8u\_P3AC4R\_general(const BYTE\* const pSrc[3], const UINT32 srcStep[3], BYTE\* pDst, UINT32 dstStep, UINT32 DstFormat, const prim\_size\_t\* roi){ UINT32 x, y; UINT32 nWidth, nHeight; const DWORD formatSize = FreeRDPGetBytesPerPixel(DstFormat); fkt\_writePixel writePixel = getPixelWriteFunction(DstFormat, FALSE); nWidth = roi->width; nHeight = roi->height;
 for (y = 0; y < nHeight; y++) { const BYTE\* pY = pSrc[0] + y \* srcStep[0]; const BYTE\* pU = pSrc[1] + y \* srcStep[1]; const BYTE\* pV = pSrc[2] + y \* srcStep[2]; BYTE\* pRGB = pDst + y \* dstStep;
 for (x = 0; x < nWidth; x++) { const BYTE Y = pY[x]; const BYTE U = pU[x]; const BYTE V = pV[x]; const BYTE r = YUV2R(Y, U, V); const BYTE g = YUV2G(Y, U, V); const BYTE b = YUV2B(Y, U, V); pRGB = writePixel(pRGB, formatSize, DstFormat, r, g, b, 0); } }
 return PRIMITIVES\_SUCCESS;}
static pstatus\_t general\_YUV444ToRGB\_8u\_P3AC4R\_BGRX(const BYTE\* const pSrc[3], const UINT32 srcStep[3], BYTE\* pDst, UINT32 dstStep, UINT32 DstFormat, const prim\_size\_t\* roi){ UINT32 x, y; UINT32 nWidth, nHeight; const DWORD formatSize = FreeRDPGetBytesPerPixel(DstFormat); nWidth = roi->width; nHeight = roi->height;
 for (y = 0; y < nHeight; y++) { const BYTE\* pY = pSrc[0] + y \* srcStep[0]; const BYTE\* pU = pSrc[1] + y \* srcStep[1]; const BYTE\* pV = pSrc[2] + y \* srcStep[2]; BYTE\* pRGB = pDst + y \* dstStep;
 for (x = 0; x < nWidth; x++) { const BYTE Y = pY[x]; const BYTE U = pU[x]; const BYTE V = pV[x]; const BYTE r = YUV2R(Y, U, V); const BYTE g = YUV2G(Y, U, V); const BYTE b = YUV2B(Y, U, V); pRGB = writePixelBGRX(pRGB, formatSize, DstFormat, r, g, b, 0); } }
 return PRIMITIVES\_SUCCESS;}
static pstatus\_t general\_YUV444ToRGB\_8u\_P3AC4R(const BYTE\* const pSrc[3], const UINT32 srcStep[3], BYTE\* pDst, UINT32 dstStep, UINT32 DstFormat, const prim\_size\_t\* roi){ switch (DstFormat) { case PIXEL\_FORMAT\_BGRA32: case PIXEL\_FORMAT\_BGRX32: return general\_YUV444ToRGB\_8u\_P3AC4R\_BGRX(pSrc, srcStep, pDst, dstStep, DstFormat, roi);
 default: return general\_YUV444ToRGB\_8u\_P3AC4R\_general(pSrc, srcStep, pDst, dstStep, DstFormat, roi); }}/\*\* \* | R | ( | 256 0 403 | | Y | ) \* | G | = ( | 256 -48 -120 | | U - 128 | ) >> 8 \* | B | ( | 256 475 0 | | V - 128 | ) \*/static pstatus\_t general\_YUV420ToRGB\_8u\_P3AC4R(const BYTE\* const pSrc[3], const UINT32 srcStep[3], BYTE\* pDst, UINT32 dstStep, UINT32 DstFormat, const prim\_size\_t\* roi){ UINT32 x, y; UINT32 dstPad; UINT32 srcPad[3]; BYTE Y, U, V; UINT32 halfWidth; UINT32 halfHeight; const BYTE\* pY; const BYTE\* pU; const BYTE\* pV; BYTE\* pRGB = pDst; UINT32 nWidth, nHeight; UINT32 lastRow, lastCol; const DWORD formatSize = FreeRDPGetBytesPerPixel(DstFormat); fkt\_writePixel writePixel = getPixelWriteFunction(DstFormat, FALSE); pY = pSrc[0]; pU = pSrc[1]; pV = pSrc[2]; lastCol = roi->width & 0x01; lastRow = roi->height & 0x01; nWidth = (roi->width + 1) & ~0x0001; nHeight = (roi->height + 1) & ~0x0001; halfWidth = nWidth / 2; halfHeight = nHeight / 2; srcPad[0] = (srcStep[0] - nWidth); srcPad[1] = (srcStep[1] - halfWidth); srcPad[2] = (srcStep[2] - halfWidth); dstPad = (dstStep - (nWidth \* 4));
 for (y = 0; y < halfHeight;) { if (++y == halfHeight) lastRow <<= 1;
 for (x = 0; x < halfWidth;) { BYTE r; BYTE g; BYTE b;
 if (++x == halfWidth) lastCol <<= 1;
 U = \*pU++; V = \*pV++; /\* 1st pixel \*/ Y = \*pY++; r = YUV2R(Y, U, V); g = YUV2G(Y, U, V); b = YUV2B(Y, U, V); pRGB = writePixel(pRGB, formatSize, DstFormat, r, g, b, 0);
 /\* 2nd pixel \*/ if (!(lastCol & 0x02)) { Y = \*pY++; r = YUV2R(Y, U, V); g = YUV2G(Y, U, V); b = YUV2B(Y, U, V); pRGB = writePixel(pRGB, formatSize, DstFormat, r, g, b, 0); } else { pY++; pRGB += formatSize; lastCol >>= 1; } }
 pY += srcPad[0]; pU -= halfWidth; pV -= halfWidth; pRGB += dstPad;
 if (lastRow & 0x02) break;
 for (x = 0; x < halfWidth;) { BYTE r; BYTE g; BYTE b;
 if (++x == halfWidth) lastCol <<= 1;
 U = \*pU++; V = \*pV++; /\* 3rd pixel \*/ Y = \*pY++; r = YUV2R(Y, U, V); g = YUV2G(Y, U, V); b = YUV2B(Y, U, V); pRGB = writePixel(pRGB, formatSize, DstFormat, r, g, b, 0);
 /\* 4th pixel \*/ if (!(lastCol & 0x02)) { Y = \*pY++; r = YUV2R(Y, U, V); g = YUV2G(Y, U, V); b = YUV2B(Y, U, V); pRGB = writePixel(pRGB, formatSize, DstFormat, r, g, b, 0); } else { pY++; pRGB += formatSize; lastCol >>= 1; } }
 pY += srcPad[0]; pU += srcPad[1]; pV += srcPad[2]; pRGB += dstPad; }
 return PRIMITIVES\_SUCCESS;}
/\*\* \* | Y | ( | 54 183 18 | | R | ) | 0 | \* | U | = ( | -29 -99 128 | | G | ) >> 8 + | 128 | \* | V | ( | 128 -116 -12 | | B | ) | 128 | \*/static INLINE BYTE RGB2Y(BYTE R, BYTE G, BYTE B){ return (54 \* R + 183 \* G + 18 \* B) >> 8;}
static INLINE BYTE RGB2U(BYTE R, BYTE G, BYTE B){ return ((-29 \* R - 99 \* G + 128 \* B) >> 8) + 128;}
static INLINE BYTE RGB2V(INT32 R, INT32 G, INT32 B){ return ((128 \* R - 116 \* G - 12 \* B) >> 8) + 128;}
static pstatus\_t general\_RGBToYUV444\_8u\_P3AC4R(const BYTE\* pSrc, UINT32 SrcFormat, const UINT32 srcStep, BYTE\* pDst[3], UINT32 dstStep[3], const prim\_size\_t\* roi){ const UINT32 bpp = FreeRDPGetBytesPerPixel(SrcFormat); UINT32 x, y; UINT32 nWidth, nHeight; nWidth = roi->width; nHeight = roi->height;
 for (y = 0; y < nHeight; y++) { const BYTE\* pRGB = pSrc + y \* srcStep; BYTE\* pY = pDst[0] + y \* dstStep[0]; BYTE\* pU = pDst[1] + y \* dstStep[1]; BYTE\* pV = pDst[2] + y \* dstStep[2];
 for (x = 0; x < nWidth; x++) { BYTE B, G, R; const UINT32 color = FreeRDPReadColor(&pRGB[x \* bpp], SrcFormat); FreeRDPSplitColor(color, SrcFormat, &R, &G, &B, NULL, NULL); pY[x] = RGB2Y(R, G, B); pU[x] = RGB2U(R, G, B); pV[x] = RGB2V(R, G, B); } }
 return PRIMITIVES\_SUCCESS;}
static INLINE pstatus\_t general\_RGBToYUV420\_BGRX(const BYTE\* pSrc, UINT32 srcStep, BYTE\* pDst[3], const UINT32 dstStep[3], const prim\_size\_t\* roi){ UINT32 x, y, i; size\_t x1 = 0, x2 = 4, x3 = srcStep, x4 = srcStep + 4; size\_t y1 = 0, y2 = 1, y3 = dstStep[0], y4 = dstStep[0] + 1; UINT32 max\_x = roi->width - 1; UINT32 max\_y = roi->height - 1;
 for (y = i = 0; y < roi->height; y += 2, i++) { const BYTE\* src = pSrc + y \* srcStep; BYTE\* ydst = pDst[0] + y \* dstStep[0]; BYTE\* udst = pDst[1] + i \* dstStep[1]; BYTE\* vdst = pDst[2] + i \* dstStep[2];
 for (x = 0; x < roi->width; x += 2) { BYTE R, G, B; INT32 Ra, Ga, Ba; /\* row 1, pixel 1 \*/ Ba = B = \*(src + x1 + 0); Ga = G = \*(src + x1 + 1); Ra = R = \*(src + x1 + 2); ydst[y1] = RGB2Y(R, G, B);
 if (x < max\_x) { /\* row 1, pixel 2 \*/ Ba += B = \*(src + x2 + 0); Ga += G = \*(src + x2 + 1); Ra += R = \*(src + x2 + 2); ydst[y2] = RGB2Y(R, G, B); }
 if (y < max\_y) { /\* row 2, pixel 1 \*/ Ba += B = \*(src + x3 + 0); Ga += G = \*(src + x3 + 1); Ra += R = \*(src + x3 + 2); ydst[y3] = RGB2Y(R, G, B);
 if (x < max\_x) { /\* row 2, pixel 2 \*/ Ba += B = \*(src + x4 + 0); Ga += G = \*(src + x4 + 1); Ra += R = \*(src + x4 + 2); ydst[y4] = RGB2Y(R, G, B); } }
 Ba >>= 2; Ga >>= 2; Ra >>= 2; \*udst++ = RGB2U(Ra, Ga, Ba); \*vdst++ = RGB2V(Ra, Ga, Ba); ydst += 2; src += 8; } }
 return PRIMITIVES\_SUCCESS;}
static INLINE pstatus\_t general\_RGBToYUV420\_RGBX(const BYTE\* pSrc, UINT32 srcStep, BYTE\* pDst[3], const UINT32 dstStep[3], const prim\_size\_t\* roi){ UINT32 x, y, i; size\_t x1 = 0, x2 = 4, x3 = srcStep, x4 = srcStep + 4; size\_t y1 = 0, y2 = 1, y3 = dstStep[0], y4 = dstStep[0] + 1; UINT32 max\_x = roi->width - 1; UINT32 max\_y = roi->height - 1;
 for (y = i = 0; y < roi->height; y += 2, i++) { const BYTE\* src = pSrc + y \* srcStep; BYTE\* ydst = pDst[0] + y \* dstStep[0]; BYTE\* udst = pDst[1] + i \* dstStep[1]; BYTE\* vdst = pDst[2] + i \* dstStep[2];
 for (x = 0; x < roi->width; x += 2) { BYTE R, G, B; INT32 Ra, Ga, Ba; /\* row 1, pixel 1 \*/ Ra = R = \*(src + x1 + 0); Ga = G = \*(src + x1 + 1); Ba = B = \*(src + x1 + 2); ydst[y1] = RGB2Y(R, G, B);
 if (x < max\_x) { /\* row 1, pixel 2 \*/ Ra += R = \*(src + x2 + 0); Ga += G = \*(src + x2 + 1); Ba += B = \*(src + x2 + 2); ydst[y2] = RGB2Y(R, G, B); }
 if (y < max\_y) { /\* row 2, pixel 1 \*/ Ra += R = \*(src + x3 + 0); Ga += G = \*(src + x3 + 1); Ba += B = \*(src + x3 + 2); ydst[y3] = RGB2Y(R, G, B);
 if (x < max\_x) { /\* row 2, pixel 2 \*/ Ra += R = \*(src + x4 + 0); Ga += G = \*(src + x4 + 1); Ba += B = \*(src + x4 + 2); ydst[y4] = RGB2Y(R, G, B); } }
 Ba >>= 2; Ga >>= 2; Ra >>= 2; \*udst++ = RGB2U(Ra, Ga, Ba); \*vdst++ = RGB2V(Ra, Ga, Ba); ydst += 2; src += 8; } }
 return PRIMITIVES\_SUCCESS;}
static INLINE pstatus\_t general\_RGBToYUV420\_ANY(const BYTE\* pSrc, UINT32 srcFormat, UINT32 srcStep, BYTE\* pDst[3], const UINT32 dstStep[3], const prim\_size\_t\* roi){ const UINT32 bpp = FreeRDPGetBytesPerPixel(srcFormat); UINT32 x, y, i; size\_t x1 = 0, x2 = bpp, x3 = srcStep, x4 = srcStep + bpp; size\_t y1 = 0, y2 = 1, y3 = dstStep[0], y4 = dstStep[0] + 1; UINT32 max\_x = roi->width - 1; UINT32 max\_y = roi->height - 1;
 for (y = i = 0; y < roi->height; y += 2, i++) { const BYTE\* src = pSrc + y \* srcStep; BYTE\* ydst = pDst[0] + y \* dstStep[0]; BYTE\* udst = pDst[1] + i \* dstStep[1]; BYTE\* vdst = pDst[2] + i \* dstStep[2];
 for (x = 0; x < roi->width; x += 2) { BYTE R, G, B; INT32 Ra, Ga, Ba; UINT32 color; /\* row 1, pixel 1 \*/ color = FreeRDPReadColor(src + x1, srcFormat); FreeRDPSplitColor(color, srcFormat, &R, &G, &B, NULL, NULL); Ra = R; Ga = G; Ba = B; ydst[y1] = RGB2Y(R, G, B);
 if (x < max\_x) { /\* row 1, pixel 2 \*/ color = FreeRDPReadColor(src + x2, srcFormat); FreeRDPSplitColor(color, srcFormat, &R, &G, &B, NULL, NULL); Ra += R; Ga += G; Ba += B; ydst[y2] = RGB2Y(R, G, B); }
 if (y < max\_y) { /\* row 2, pixel 1 \*/ color = FreeRDPReadColor(src + x3, srcFormat); FreeRDPSplitColor(color, srcFormat, &R, &G, &B, NULL, NULL); Ra += R; Ga += G; Ba += B; ydst[y3] = RGB2Y(R, G, B);
 if (x < max\_x) { /\* row 2, pixel 2 \*/ color = FreeRDPReadColor(src + x4, srcFormat); FreeRDPSplitColor(color, srcFormat, &R, &G, &B, NULL, NULL); Ra += R; Ga += G; Ba += B; ydst[y4] = RGB2Y(R, G, B); } }
 Ra >>= 2; Ga >>= 2; Ba >>= 2; \*udst++ = RGB2U(Ra, Ga, Ba); \*vdst++ = RGB2V(Ra, Ga, Ba); ydst += 2; src += 2 \* bpp; } }
 return PRIMITIVES\_SUCCESS;}
static pstatus\_t general\_RGBToYUV420\_8u\_P3AC4R(const BYTE\* pSrc, UINT32 srcFormat, UINT32 srcStep, BYTE\* pDst[3], const UINT32 dstStep[3], const prim\_size\_t\* roi){ switch (srcFormat) { case PIXEL\_FORMAT\_BGRA32: case PIXEL\_FORMAT\_BGRX32: return general\_RGBToYUV420\_BGRX(pSrc, srcStep, pDst, dstStep, roi);
 case PIXEL\_FORMAT\_RGBA32: case PIXEL\_FORMAT\_RGBX32: return general\_RGBToYUV420\_RGBX(pSrc, srcStep, pDst, dstStep, roi);
 default: return general\_RGBToYUV420\_ANY(pSrc, srcFormat, srcStep, pDst, dstStep, roi); }}
static INLINE void general\_RGBToAVC444YUV\_BGRX\_DOUBLE\_ROW(const BYTE\* srcEven, const BYTE\* srcOdd, BYTE\* b1Even, BYTE\* b1Odd, BYTE\* b2, BYTE\* b3, BYTE\* b4, BYTE\* b5, BYTE\* b6, BYTE\* b7, UINT32 width){ UINT32 x;
 for (x = 0; x < width; x += 2) { const BOOL lastX = (x + 1) >= width; BYTE Y1e, Y2e, U1e, V1e, U2e, V2e; BYTE Y1o, Y2o, U1o, V1o, U2o, V2o; /\* Read 4 pixels, 2 from even, 2 from odd lines \*/ { const BYTE b = \*srcEven++; const BYTE g = \*srcEven++; const BYTE r = \*srcEven++; srcEven++; Y1e = Y2e = Y1o = Y2o = RGB2Y(r, g, b); U1e = U2e = U1o = U2o = RGB2U(r, g, b); V1e = V2e = V1o = V2o = RGB2V(r, g, b); }
 if (!lastX) { const BYTE b = \*srcEven++; const BYTE g = \*srcEven++; const BYTE r = \*srcEven++; srcEven++; Y2e = RGB2Y(r, g, b); U2e = RGB2U(r, g, b); V2e = RGB2V(r, g, b); }
 if (b1Odd) { const BYTE b = \*srcOdd++; const BYTE g = \*srcOdd++; const BYTE r = \*srcOdd++; srcOdd++; Y1o = Y2o = RGB2Y(r, g, b); U1o = U2o = RGB2U(r, g, b); V1o = V2o = RGB2V(r, g, b); }
 if (b1Odd && !lastX) { const BYTE b = \*srcOdd++; const BYTE g = \*srcOdd++; const BYTE r = \*srcOdd++; srcOdd++; Y2o = RGB2Y(r, g, b); U2o = RGB2U(r, g, b); V2o = RGB2V(r, g, b); }
 /\* We have 4 Y pixels, so store them. \*/ \*b1Even++ = Y1e; \*b1Even++ = Y2e;
 if (b1Odd) { \*b1Odd++ = Y1o; \*b1Odd++ = Y2o; }
 /\* 2x 2y pixel in luma UV plane use averaging \*/ { const BYTE Uavg = ((UINT16)U1e + (UINT16)U2e + (UINT16)U1o + (UINT16)U2o) / 4; const BYTE Vavg = ((UINT16)V1e + (UINT16)V2e + (UINT16)V1o + (UINT16)V2o) / 4; \*b2++ = Uavg; \*b3++ = Vavg; }
 /\* UV from 2x, 2y+1 \*/ if (b1Odd) { \*b4++ = U1o; \*b5++ = V1o;
 if (!lastX) { \*b4++ = U2o; \*b5++ = V2o; } }
 /\* UV from 2x+1, 2y \*/ if (!lastX) { \*b6++ = U2e; \*b7++ = V2e; } }}
static INLINE pstatus\_t general\_RGBToAVC444YUV\_BGRX(const BYTE\* pSrc, UINT32 srcStep, BYTE\* pDst1[3], const UINT32 dst1Step[3], BYTE\* pDst2[3], const UINT32 dst2Step[3], const prim\_size\_t\* roi){ /\*\* \* Note: \* Read information in function general\_RGBToAVC444YUV\_ANY below ! \*/ UINT32 y; const BYTE\* pMaxSrc = pSrc + (roi->height - 1) \* srcStep;
 for (y = 0; y < roi->height; y += 2) { const BOOL last = (y >= (roi->height - 1)); const BYTE\* srcEven = y < roi->height ? pSrc + y \* srcStep : pMaxSrc; const BYTE\* srcOdd = !last ? pSrc + (y + 1) \* srcStep : pMaxSrc; const UINT32 i = y >> 1; const UINT32 n = (i & ~7) + i; BYTE\* b1Even = pDst1[0] + y \* dst1Step[0]; BYTE\* b1Odd = !last ? (b1Even + dst1Step[0]) : NULL; BYTE\* b2 = pDst1[1] + (y / 2) \* dst1Step[1]; BYTE\* b3 = pDst1[2] + (y / 2) \* dst1Step[2]; BYTE\* b4 = pDst2[0] + dst2Step[0] \* n; BYTE\* b5 = b4 + 8 \* dst2Step[0]; BYTE\* b6 = pDst2[1] + (y / 2) \* dst2Step[1]; BYTE\* b7 = pDst2[2] + (y / 2) \* dst2Step[2]; general\_RGBToAVC444YUV\_BGRX\_DOUBLE\_ROW(srcEven, srcOdd, b1Even, b1Odd, b2, b3, b4, b5, b6, b7, roi->width); }
 return PRIMITIVES\_SUCCESS;}
[View remainder of file in raw view](https://github.com/FreeRDP/FreeRDP/raw/5be5553e0da72178a4b94cc1ffbdace9ceb153e5/libfreerdp/primitives/prim_YUV.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

