

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=c0761d1f1ce1d5b85b5e82bbb714df12de1aa8c3)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=c0761d1f1ce1d5b85b5e82bbb714df12de1aa8c3)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=c0761d1f1ce1d5b85b5e82bbb714df12de1aa8c3)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=c0761d1f1ce1d5b85b5e82bbb714df12de1aa8c3)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jozsef Kadlecsik <kadlec@netfilter.org> | 2024-06-04 15:58:03 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-07-05 09:08:17 +0200 |
| commit | [c0761d1f1ce1d5b85b5e82bbb714df12de1aa8c3](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=c0761d1f1ce1d5b85b5e82bbb714df12de1aa8c3) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=c0761d1f1ce1d5b85b5e82bbb714df12de1aa8c3)) | |
| tree | [01233147479c8627f6b52ba2ee86266b744fb0e7](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=c0761d1f1ce1d5b85b5e82bbb714df12de1aa8c3) | |
| parent | [cd41a24ab463b8fe17999b3b6694a1e5ff77ae7f](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=cd41a24ab463b8fe17999b3b6694a1e5ff77ae7f) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=c0761d1f1ce1d5b85b5e82bbb714df12de1aa8c3&id2=cd41a24ab463b8fe17999b3b6694a1e5ff77ae7f)) | |
| download | [linux-c0761d1f1ce1d5b85b5e82bbb714df12de1aa8c3.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-c0761d1f1ce1d5b85b5e82bbb714df12de1aa8c3.tar.gz) | |

netfilter: ipset: Fix race between namespace cleanup and gc in the list:set type[ Upstream commit 4e7aaa6b82d63e8ddcbfb56b4fd3d014ca586f10 ]
Lion Ackermann reported that there is a race condition between namespace cleanup
in ipset and the garbage collection of the list:set type. The namespace
cleanup can destroy the list:set type of sets while the gc of the set type is
waiting to run in rcu cleanup. The latter uses data from the destroyed set which
thus leads use after free. The patch contains the following parts:
- When destroying all sets, first remove the garbage collectors, then wait
if needed and then destroy the sets.
- Fix the badly ordered "wait then remove gc" for the destroy a single set
case.
- Fix the missing rcu locking in the list:set type in the userspace test
case.
- Use proper RCU list handlings in the list:set type.
The patch depends on c1193d9bbbd3 (netfilter: ipset: Add list flush to cancel\_gc).
Fixes: 97f7cf1cd80e (netfilter: ipset: fix performance regression in swap operation)
Reported-by: Lion Ackermann <nnamrec@gmail.com>
Tested-by: Lion Ackermann <nnamrec@gmail.com>
Signed-off-by: Jozsef Kadlecsik <kadlec@netfilter.org>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=c0761d1f1ce1d5b85b5e82bbb714df12de1aa8c3)

| -rw-r--r-- | [net/netfilter/ipset/ip\_set\_core.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/ipset/ip_set_core.c?id=c0761d1f1ce1d5b85b5e82bbb714df12de1aa8c3) | 81 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/netfilter/ipset/ip\_set\_list\_set.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/ipset/ip_set_list_set.c?id=c0761d1f1ce1d5b85b5e82bbb714df12de1aa8c3) | 30 | |  |  |  | | --- | --- | --- | |

2 files changed, 60 insertions, 51 deletions

| diff --git a/net/netfilter/ipset/ip\_set\_core.c b/net/netfilter/ipset/ip\_set\_core.cindex 544106475d4f61..04273f94504fb2 100644--- a/[net/netfilter/ipset/ip\_set\_core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/ipset/ip_set_core.c?id=cd41a24ab463b8fe17999b3b6694a1e5ff77ae7f)+++ b/[net/netfilter/ipset/ip\_set\_core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/ipset/ip_set_core.c?id=c0761d1f1ce1d5b85b5e82bbb714df12de1aa8c3)@@ -1024,23 +1024,50 @@ ip\_set\_setname\_policy[IPSET\_ATTR\_CMD\_MAX + 1] = { .len = IPSET\_MAXNAMELEN - 1 }, }; +/\* In order to return quickly when destroying a single set, it is split+ \* into two stages:+ \* - Cancel garbage collector+ \* - Destroy the set itself via call\_rcu()+ \*/+ static void-ip\_set\_destroy\_set(struct ip\_set \*set)+ip\_set\_destroy\_set\_rcu(struct rcu\_head \*head) {- pr\_debug("set: %s\n", set->name);+ struct ip\_set \*set = container\_of(head, struct ip\_set, rcu); - /\* Must call it without holding any lock \*/ set->variant->destroy(set); module\_put(set->type->me); kfree(set); }  static void-ip\_set\_destroy\_set\_rcu(struct rcu\_head \*head)+\_destroy\_all\_sets(struct ip\_set\_net \*inst) {- struct ip\_set \*set = container\_of(head, struct ip\_set, rcu);+ struct ip\_set \*set;+ ip\_set\_id\_t i;+ bool need\_wait = false; - ip\_set\_destroy\_set(set);+ /\* First cancel gc's: set:list sets are flushed as well \*/+ for (i = 0; i < inst->ip\_set\_max; i++) {+ set = ip\_set(inst, i);+ if (set) {+ set->variant->cancel\_gc(set);+ if (set->type->features & IPSET\_TYPE\_NAME)+ need\_wait = true;+ }+ }+ /\* Must wait for flush to be really finished \*/+ if (need\_wait)+ rcu\_barrier();+ for (i = 0; i < inst->ip\_set\_max; i++) {+ set = ip\_set(inst, i);+ if (set) {+ ip\_set(inst, i) = NULL;+ set->variant->destroy(set);+ module\_put(set->type->me);+ kfree(set);+ }+ } }  static int ip\_set\_destroy(struct net \*net, struct sock \*ctnl,@@ -1056,11 +1083,10 @@ static int ip\_set\_destroy(struct net \*net, struct sock \*ctnl, if (unlikely(protocol\_min\_failed(attr))) return -IPSET\_ERR\_PROTOCOL; - /\* Commands are serialized and references are \* protected by the ip\_set\_ref\_lock. \* External systems (i.e. xt\_set) must call- \* ip\_set\_put|get\_nfnl\_\* functions, that way we+ \* ip\_set\_nfnl\_get\_\* functions, that way we \* can safely check references here. \* \* list:set timer can only decrement the reference@@ -1068,8 +1094,6 @@ static int ip\_set\_destroy(struct net \*net, struct sock \*ctnl, \* without holding the lock. \*/ if (!attr[IPSET\_ATTR\_SETNAME]) {- /\* Must wait for flush to be really finished in list:set \*/- rcu\_barrier(); read\_lock\_bh(&ip\_set\_ref\_lock); for (i = 0; i < inst->ip\_set\_max; i++) { s = ip\_set(inst, i);@@ -1080,15 +1104,7 @@ static int ip\_set\_destroy(struct net \*net, struct sock \*ctnl, } inst->is\_destroyed = true; read\_unlock\_bh(&ip\_set\_ref\_lock);- for (i = 0; i < inst->ip\_set\_max; i++) {- s = ip\_set(inst, i);- if (s) {- ip\_set(inst, i) = NULL;- /\* Must cancel garbage collectors \*/- s->variant->cancel\_gc(s);- ip\_set\_destroy\_set(s);- }- }+ \_destroy\_all\_sets(inst); /\* Modified by ip\_set\_destroy() only, which is serialized \*/ inst->is\_destroyed = false; } else {@@ -1107,12 +1123,12 @@ static int ip\_set\_destroy(struct net \*net, struct sock \*ctnl, features = s->type->features; ip\_set(inst, i) = NULL; read\_unlock\_bh(&ip\_set\_ref\_lock);+ /\* Must cancel garbage collectors \*/+ s->variant->cancel\_gc(s); if (features & IPSET\_TYPE\_NAME) { /\* Must wait for flush to be really finished \*/ rcu\_barrier(); }- /\* Must cancel garbage collectors \*/- s->variant->cancel\_gc(s); call\_rcu(&s->rcu, ip\_set\_destroy\_set\_rcu); } return 0;@@ -2223,30 +2239,25 @@ ip\_set\_net\_init(struct net \*net) }  static void \_\_net\_exit-ip\_set\_net\_exit(struct net \*net)+ip\_set\_net\_pre\_exit(struct net \*net) { struct ip\_set\_net \*inst = ip\_set\_pernet(net); - struct ip\_set \*set = NULL;- ip\_set\_id\_t i;- inst->is\_deleted = true; /\* flag for ip\_set\_nfnl\_put \*/+} - nfnl\_lock(NFNL\_SUBSYS\_IPSET);- for (i = 0; i < inst->ip\_set\_max; i++) {- set = ip\_set(inst, i);- if (set) {- ip\_set(inst, i) = NULL;- set->variant->cancel\_gc(set);- ip\_set\_destroy\_set(set);- }- }- nfnl\_unlock(NFNL\_SUBSYS\_IPSET);+static void \_\_net\_exit+ip\_set\_net\_exit(struct net \*net)+{+ struct ip\_set\_net \*inst = ip\_set\_pernet(net);++ \_destroy\_all\_sets(inst); kvfree(rcu\_dereference\_protected(inst->ip\_set\_list, 1)); }  static struct pernet\_operations ip\_set\_net\_ops = { .init = ip\_set\_net\_init,+ .pre\_exit = ip\_set\_net\_pre\_exit, .exit = ip\_set\_net\_exit, .id = &ip\_set\_net\_id, .size = sizeof(struct ip\_set\_net),diff --git a/net/netfilter/ipset/ip\_set\_list\_set.c b/net/netfilter/ipset/ip\_set\_list\_set.cindex 64cc3e2131f3f3..9f4f0126d6ed5b 100644--- a/[net/netfilter/ipset/ip\_set\_list\_set.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/ipset/ip_set_list_set.c?id=cd41a24ab463b8fe17999b3b6694a1e5ff77ae7f)+++ b/[net/netfilter/ipset/ip\_set\_list\_set.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/ipset/ip_set_list_set.c?id=c0761d1f1ce1d5b85b5e82bbb714df12de1aa8c3)@@ -79,7 +79,7 @@ list\_set\_kadd(struct ip\_set \*set, const struct sk\_buff \*skb, struct set\_elem \*e; int ret; - list\_for\_each\_entry(e, &map->members, list) {+ list\_for\_each\_entry\_rcu(e, &map->members, list) { if (SET\_WITH\_TIMEOUT(set) && ip\_set\_timeout\_expired(ext\_timeout(e, set))) continue;@@ -99,7 +99,7 @@ list\_set\_kdel(struct ip\_set \*set, const struct sk\_buff \*skb, struct set\_elem \*e; int ret; - list\_for\_each\_entry(e, &map->members, list) {+ list\_for\_each\_entry\_rcu(e, &map->members, list) { if (SET\_WITH\_TIMEOUT(set) && ip\_set\_timeout\_expired(ext\_timeout(e, set))) continue;@@ -188,9 +188,10 @@ list\_set\_utest(struct ip\_set \*set, void \*value, const struct ip\_set\_ext \*ext, struct list\_set \*map = set->data; struct set\_adt\_elem \*d = value; struct set\_elem \*e, \*next, \*prev = NULL;- int ret;+ int ret = 0; - list\_for\_each\_entry(e, &map->members, list) {+ rcu\_read\_lock();+ list\_for\_each\_entry\_rcu(e, &map->members, list) { if (SET\_WITH\_TIMEOUT(set) && ip\_set\_timeout\_expired(ext\_timeout(e, set))) continue;@@ -201,6 +202,7 @@ list\_set\_utest(struct ip\_set \*set, void \*value, const struct ip\_set\_ext \*ext,  if (d->before == 0) { ret = 1;+ goto out; } else if (d->before > 0) { next = list\_next\_entry(e, list); ret = !list\_is\_last(&e->list, &map->members) &&@@ -208,9 +210,11 @@ list\_set\_utest(struct ip\_set \*set, void \*value, const struct ip\_set\_ext \*ext, } else { ret = prev && prev->id == d->refid; }- return ret;+ goto out; }- return 0;+out:+ rcu\_read\_unlock();+ return ret; }  static void@@ -239,7 +243,7 @@ list\_set\_uadd(struct ip\_set \*set, void \*value, const struct ip\_set\_ext \*ext,  /\* Find where to add the new entry \*/ n = prev = next = NULL;- list\_for\_each\_entry(e, &map->members, list) {+ list\_for\_each\_entry\_rcu(e, &map->members, list) { if (SET\_WITH\_TIMEOUT(set) && ip\_set\_timeout\_expired(ext\_timeout(e, set))) continue;@@ -316,9 +320,9 @@ list\_set\_udel(struct ip\_set \*set, void \*value, const struct ip\_set\_ext \*ext, { struct list\_set \*map = set->data; struct set\_adt\_elem \*d = value;- struct set\_elem \*e, \*next, \*prev = NULL;+ struct set\_elem \*e, \*n, \*next, \*prev = NULL; - list\_for\_each\_entry(e, &map->members, list) {+ list\_for\_each\_entry\_safe(e, n, &map->members, list) { if (SET\_WITH\_TIMEOUT(set) && ip\_set\_timeout\_expired(ext\_timeout(e, set))) continue;@@ -424,14 +428,8 @@ static void list\_set\_destroy(struct ip\_set \*set) { struct list\_set \*map = set->data;- struct set\_elem \*e, \*n; - list\_for\_each\_entry\_safe(e, n, &map->members, list) {- list\_del(&e->list);- ip\_set\_put\_byindex(map->net, e->id);- ip\_set\_ext\_destroy(set, e);- kfree(e);- }+ WARN\_ON\_ONCE(!list\_empty(&map->members)); kfree(map);  set->data = NULL; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 16:36:59 +0000

