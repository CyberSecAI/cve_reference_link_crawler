

| [cgit logo](/) | [index](/) : [kernel/git/torvalds/linux.git](/pub/scm/linux/kernel/git/torvalds/linux.git/) | for-next master vsnprintf |
| --- | --- | --- |
| Linux kernel source tree | Linus Torvalds |

| [about](/pub/scm/linux/kernel/git/torvalds/linux.git/about/)[summary](/pub/scm/linux/kernel/git/torvalds/linux.git/)[refs](/pub/scm/linux/kernel/git/torvalds/linux.git/refs/?id=f90497a16e434c2211c66e3de8e77b17868382b8)[log](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)[tree](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=f90497a16e434c2211c66e3de8e77b17868382b8)[commit](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f90497a16e434c2211c66e3de8e77b17868382b8)[diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=f90497a16e434c2211c66e3de8e77b17868382b8)[stats](/pub/scm/linux/kernel/git/torvalds/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Linus Torvalds <torvalds@linux-foundation.org> | 2022-10-03 20:07:15 -0700 |
| --- | --- | --- |
| committer | Linus Torvalds <torvalds@linux-foundation.org> | 2022-10-03 20:07:15 -0700 |
| commit | [f90497a16e434c2211c66e3de8e77b17868382b8](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f90497a16e434c2211c66e3de8e77b17868382b8) ([patch](/pub/scm/linux/kernel/git/torvalds/linux.git/patch/?id=f90497a16e434c2211c66e3de8e77b17868382b8)) | |
| tree | [915424e5c0b7aab66773af2dc7bd8557028ef535](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=f90497a16e434c2211c66e3de8e77b17868382b8) | |
| parent | [3497640a80d77cd098d45c9f3ab235b1aa472dbc](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=f90497a16e434c2211c66e3de8e77b17868382b8&id2=3497640a80d77cd098d45c9f3ab235b1aa472dbc)) | |
| parent | [895ddf5ed4c54ea9e3533606d7a8b4e4f27f95ef](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=895ddf5ed4c54ea9e3533606d7a8b4e4f27f95ef) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=f90497a16e434c2211c66e3de8e77b17868382b8&id2=895ddf5ed4c54ea9e3533606d7a8b4e4f27f95ef)) | |
| download | [linux-f90497a16e434c2211c66e3de8e77b17868382b8.tar.gz](/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-f90497a16e434c2211c66e3de8e77b17868382b8.tar.gz) | |

Merge tag 'nfsd-6.1' of git://git.kernel.org/pub/scm/linux/kernel/git/cel/linuxPull nfsd updates from Chuck Lever:
"This release is mostly bug fixes, clean-ups, and optimizations.
One notable set of fixes addresses a subtle buffer overflow issue that
occurs if a small RPC Call message arrives in an oversized RPC record.
This is only possible on a framed RPC transport such as TCP.
Because NFSD shares the receive and send buffers in one set of pages,
an oversized RPC record steals pages from the send buffer that will be
used to construct the RPC Reply message. NFSD must not assume that a
full-sized buffer is always available to it; otherwise, it will walk
off the end of the send buffer while constructing its reply.
In this release, we also introduce the ability for the server to wait
a moment for clients to return delegations before it responds with
NFS4ERR\_DELAY. This saves a retransmit and a network round- trip when
a delegation recall is needed. This work will be built upon in future
releases.
The NFS server adds another shrinker to its collection. Because
courtesy clients can linger for quite some time, they might be
freeable when the server host comes under memory pressure. A new
shrinker has been added that releases courtesy client resources during
low memory scenarios.
Lastly, of note: the maximum number of operations per NFSv4 COMPOUND
that NFSD can handle is increased from 16 to 50. There are NFSv4
client implementations that need more than 16 to successfully perform
a mount operation that uses a pathname with many components"
\* tag 'nfsd-6.1' of git://git.kernel.org/pub/scm/linux/kernel/git/cel/linux: (53 commits)
nfsd: extra checks when freeing delegation stateids
nfsd: make nfsd4\_run\_cb a bool return function
nfsd: fix comments about spinlock handling with delegations
nfsd: only fill out return pointer on success in nfsd4\_lookup\_stateid
NFSD: fix use-after-free on source server when doing inter-server copy
NFSD: Cap rsize\_bop result based on send buffer size
NFSD: Rename the fields in copy\_stateid\_t
nfsd: use DEFINE\_SHOW\_ATTRIBUTE to define nfsd\_file\_cache\_stats\_fops
nfsd: use DEFINE\_SHOW\_ATTRIBUTE to define nfsd\_reply\_cache\_stats\_fops
nfsd: use DEFINE\_SHOW\_ATTRIBUTE to define client\_info\_fops
nfsd: use DEFINE\_SHOW\_ATTRIBUTE to define export\_features\_fops and supported\_enctypes\_fops
nfsd: use DEFINE\_PROC\_SHOW\_ATTRIBUTE to define nfsd\_proc\_ops
NFSD: Pack struct nfsd4\_compoundres
NFSD: Remove unused nfsd4\_compoundargs::cachetype field
NFSD: Remove "inline" directives on op\_rsize\_bop helpers
NFSD: Clean up nfs4svc\_encode\_compoundres()
SUNRPC: Fix typo in xdr\_buf\_subsegment's kdoc comment
NFSD: Clean up WRITE arg decoders
NFSD: Use xdr\_inline\_decode() to decode NFSv3 symlinks
NFSD: Refactor common code out of dirlist helpers
...
[Diffstat](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=f90497a16e434c2211c66e3de8e77b17868382b8)

| -rw-r--r-- | [fs/lockd/host.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/lockd/host.c?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 2 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/lockd/svc4proc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/lockd/svc4proc.c?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 24 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/lockd/svcproc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/lockd/svcproc.c?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 24 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfs/callback\_xdr.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfs/callback_xdr.c?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/cache.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/cache.h?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/filecache.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/filecache.c?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 7 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/filecache.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/filecache.h?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/netns.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/netns.h?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/nfs2acl.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/nfs2acl.c?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/nfs3acl.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/nfs3acl.c?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/nfs3proc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/nfs3proc.c?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 43 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/nfs3xdr.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/nfs3xdr.c?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 18 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/nfs4callback.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/nfs4callback.c?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 14 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/nfs4idmap.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/nfs4idmap.c?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/nfs4layouts.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/nfs4layouts.c?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/nfs4proc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/nfs4proc.c?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 226 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/nfs4recover.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/nfs4recover.c?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 14 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/nfs4state.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/nfs4state.c?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 218 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/nfs4xdr.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/nfs4xdr.c?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 102 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/nfscache.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/nfscache.c?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 13 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/nfsctl.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/nfsctl.c?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 54 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/nfsd.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/nfsd.h?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 13 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/nfsfh.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/nfsfh.c?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/nfsproc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/nfsproc.c?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 39 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/nfssvc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/nfssvc.c?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/nfsxdr.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/nfsxdr.c?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/state.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/state.h?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 11 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/stats.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/stats.c?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 14 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/trace.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/trace.h?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 131 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/vfs.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/vfs.c?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 128 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/vfs.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/vfs.h?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/nfsd/xdr4.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/fs/nfsd/xdr4.h?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 9 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/sunrpc/svc.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/linux/sunrpc/svc.h?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 20 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/sunrpc/xdr.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/linux/sunrpc/xdr.h?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sunrpc/svc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/net/sunrpc/svc.c?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 34 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/sunrpc/xdr.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/net/sunrpc/xdr.c?id=f90497a16e434c2211c66e3de8e77b17868382b8) | 24 | |  |  |  | | --- | --- | --- | |

36 files changed, 829 insertions, 400 deletions

| diff --git a/fs/lockd/host.c b/fs/lockd/host.cindex f802223e71abe5..cdc8e12cdac44e 100644--- a/[fs/lockd/host.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/lockd/host.c?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/lockd/host.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/lockd/host.c?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -164,7 +164,7 @@ static struct nlm\_host \*nlm\_alloc\_host(struct nlm\_lookup\_host\_info \*ni, host->h\_addrbuf = nsm->sm\_addrbuf; host->net = ni->net; host->h\_cred = get\_cred(ni->cred);- strlcpy(host->nodename, utsname()->nodename, sizeof(host->nodename));+ strscpy(host->nodename, utsname()->nodename, sizeof(host->nodename));  out: return host;diff --git a/fs/lockd/svc4proc.c b/fs/lockd/svc4proc.cindex bf274f23969b30..284b019cb6529b 100644--- a/[fs/lockd/svc4proc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/lockd/svc4proc.c?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/lockd/svc4proc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/lockd/svc4proc.c?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -521,6 +521,7 @@ const struct svc\_procedure nlmsvc\_procedures4[24] = { .pc\_decode = nlm4svc\_decode\_void, .pc\_encode = nlm4svc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_void),+ .pc\_argzero = sizeof(struct nlm\_void), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = St, .pc\_name = "NULL",@@ -530,6 +531,7 @@ const struct svc\_procedure nlmsvc\_procedures4[24] = { .pc\_decode = nlm4svc\_decode\_testargs, .pc\_encode = nlm4svc\_encode\_testres, .pc\_argsize = sizeof(struct nlm\_args),+ .pc\_argzero = sizeof(struct nlm\_args), .pc\_ressize = sizeof(struct nlm\_res), .pc\_xdrressize = Ck+St+2+No+Rg, .pc\_name = "TEST",@@ -539,6 +541,7 @@ const struct svc\_procedure nlmsvc\_procedures4[24] = { .pc\_decode = nlm4svc\_decode\_lockargs, .pc\_encode = nlm4svc\_encode\_res, .pc\_argsize = sizeof(struct nlm\_args),+ .pc\_argzero = sizeof(struct nlm\_args), .pc\_ressize = sizeof(struct nlm\_res), .pc\_xdrressize = Ck+St, .pc\_name = "LOCK",@@ -548,6 +551,7 @@ const struct svc\_procedure nlmsvc\_procedures4[24] = { .pc\_decode = nlm4svc\_decode\_cancargs, .pc\_encode = nlm4svc\_encode\_res, .pc\_argsize = sizeof(struct nlm\_args),+ .pc\_argzero = sizeof(struct nlm\_args), .pc\_ressize = sizeof(struct nlm\_res), .pc\_xdrressize = Ck+St, .pc\_name = "CANCEL",@@ -557,6 +561,7 @@ const struct svc\_procedure nlmsvc\_procedures4[24] = { .pc\_decode = nlm4svc\_decode\_unlockargs, .pc\_encode = nlm4svc\_encode\_res, .pc\_argsize = sizeof(struct nlm\_args),+ .pc\_argzero = sizeof(struct nlm\_args), .pc\_ressize = sizeof(struct nlm\_res), .pc\_xdrressize = Ck+St, .pc\_name = "UNLOCK",@@ -566,6 +571,7 @@ const struct svc\_procedure nlmsvc\_procedures4[24] = { .pc\_decode = nlm4svc\_decode\_testargs, .pc\_encode = nlm4svc\_encode\_res, .pc\_argsize = sizeof(struct nlm\_args),+ .pc\_argzero = sizeof(struct nlm\_args), .pc\_ressize = sizeof(struct nlm\_res), .pc\_xdrressize = Ck+St, .pc\_name = "GRANTED",@@ -575,6 +581,7 @@ const struct svc\_procedure nlmsvc\_procedures4[24] = { .pc\_decode = nlm4svc\_decode\_testargs, .pc\_encode = nlm4svc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_args),+ .pc\_argzero = sizeof(struct nlm\_args), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = St, .pc\_name = "TEST\_MSG",@@ -584,6 +591,7 @@ const struct svc\_procedure nlmsvc\_procedures4[24] = { .pc\_decode = nlm4svc\_decode\_lockargs, .pc\_encode = nlm4svc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_args),+ .pc\_argzero = sizeof(struct nlm\_args), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = St, .pc\_name = "LOCK\_MSG",@@ -593,6 +601,7 @@ const struct svc\_procedure nlmsvc\_procedures4[24] = { .pc\_decode = nlm4svc\_decode\_cancargs, .pc\_encode = nlm4svc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_args),+ .pc\_argzero = sizeof(struct nlm\_args), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = St, .pc\_name = "CANCEL\_MSG",@@ -602,6 +611,7 @@ const struct svc\_procedure nlmsvc\_procedures4[24] = { .pc\_decode = nlm4svc\_decode\_unlockargs, .pc\_encode = nlm4svc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_args),+ .pc\_argzero = sizeof(struct nlm\_args), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = St, .pc\_name = "UNLOCK\_MSG",@@ -611,6 +621,7 @@ const struct svc\_procedure nlmsvc\_procedures4[24] = { .pc\_decode = nlm4svc\_decode\_testargs, .pc\_encode = nlm4svc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_args),+ .pc\_argzero = sizeof(struct nlm\_args), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = St, .pc\_name = "GRANTED\_MSG",@@ -620,6 +631,7 @@ const struct svc\_procedure nlmsvc\_procedures4[24] = { .pc\_decode = nlm4svc\_decode\_void, .pc\_encode = nlm4svc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_res),+ .pc\_argzero = sizeof(struct nlm\_res), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = St, .pc\_name = "TEST\_RES",@@ -629,6 +641,7 @@ const struct svc\_procedure nlmsvc\_procedures4[24] = { .pc\_decode = nlm4svc\_decode\_void, .pc\_encode = nlm4svc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_res),+ .pc\_argzero = sizeof(struct nlm\_res), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = St, .pc\_name = "LOCK\_RES",@@ -638,6 +651,7 @@ const struct svc\_procedure nlmsvc\_procedures4[24] = { .pc\_decode = nlm4svc\_decode\_void, .pc\_encode = nlm4svc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_res),+ .pc\_argzero = sizeof(struct nlm\_res), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = St, .pc\_name = "CANCEL\_RES",@@ -647,6 +661,7 @@ const struct svc\_procedure nlmsvc\_procedures4[24] = { .pc\_decode = nlm4svc\_decode\_void, .pc\_encode = nlm4svc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_res),+ .pc\_argzero = sizeof(struct nlm\_res), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = St, .pc\_name = "UNLOCK\_RES",@@ -656,6 +671,7 @@ const struct svc\_procedure nlmsvc\_procedures4[24] = { .pc\_decode = nlm4svc\_decode\_res, .pc\_encode = nlm4svc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_res),+ .pc\_argzero = sizeof(struct nlm\_res), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = St, .pc\_name = "GRANTED\_RES",@@ -665,6 +681,7 @@ const struct svc\_procedure nlmsvc\_procedures4[24] = { .pc\_decode = nlm4svc\_decode\_reboot, .pc\_encode = nlm4svc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_reboot),+ .pc\_argzero = sizeof(struct nlm\_reboot), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = St, .pc\_name = "SM\_NOTIFY",@@ -674,6 +691,7 @@ const struct svc\_procedure nlmsvc\_procedures4[24] = { .pc\_decode = nlm4svc\_decode\_void, .pc\_encode = nlm4svc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_void),+ .pc\_argzero = sizeof(struct nlm\_void), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = 0, .pc\_name = "UNUSED",@@ -683,6 +701,7 @@ const struct svc\_procedure nlmsvc\_procedures4[24] = { .pc\_decode = nlm4svc\_decode\_void, .pc\_encode = nlm4svc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_void),+ .pc\_argzero = sizeof(struct nlm\_void), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = 0, .pc\_name = "UNUSED",@@ -692,6 +711,7 @@ const struct svc\_procedure nlmsvc\_procedures4[24] = { .pc\_decode = nlm4svc\_decode\_void, .pc\_encode = nlm4svc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_void),+ .pc\_argzero = sizeof(struct nlm\_void), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = 0, .pc\_name = "UNUSED",@@ -701,6 +721,7 @@ const struct svc\_procedure nlmsvc\_procedures4[24] = { .pc\_decode = nlm4svc\_decode\_shareargs, .pc\_encode = nlm4svc\_encode\_shareres, .pc\_argsize = sizeof(struct nlm\_args),+ .pc\_argzero = sizeof(struct nlm\_args), .pc\_ressize = sizeof(struct nlm\_res), .pc\_xdrressize = Ck+St+1, .pc\_name = "SHARE",@@ -710,6 +731,7 @@ const struct svc\_procedure nlmsvc\_procedures4[24] = { .pc\_decode = nlm4svc\_decode\_shareargs, .pc\_encode = nlm4svc\_encode\_shareres, .pc\_argsize = sizeof(struct nlm\_args),+ .pc\_argzero = sizeof(struct nlm\_args), .pc\_ressize = sizeof(struct nlm\_res), .pc\_xdrressize = Ck+St+1, .pc\_name = "UNSHARE",@@ -719,6 +741,7 @@ const struct svc\_procedure nlmsvc\_procedures4[24] = { .pc\_decode = nlm4svc\_decode\_lockargs, .pc\_encode = nlm4svc\_encode\_res, .pc\_argsize = sizeof(struct nlm\_args),+ .pc\_argzero = sizeof(struct nlm\_args), .pc\_ressize = sizeof(struct nlm\_res), .pc\_xdrressize = Ck+St, .pc\_name = "NM\_LOCK",@@ -728,6 +751,7 @@ const struct svc\_procedure nlmsvc\_procedures4[24] = { .pc\_decode = nlm4svc\_decode\_notify, .pc\_encode = nlm4svc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_args),+ .pc\_argzero = sizeof(struct nlm\_args), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = St, .pc\_name = "FREE\_ALL",diff --git a/fs/lockd/svcproc.c b/fs/lockd/svcproc.cindex b09ca35b527cc0..e35c05e2780618 100644--- a/[fs/lockd/svcproc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/lockd/svcproc.c?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/lockd/svcproc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/lockd/svcproc.c?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -555,6 +555,7 @@ const struct svc\_procedure nlmsvc\_procedures[24] = { .pc\_decode = nlmsvc\_decode\_void, .pc\_encode = nlmsvc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_void),+ .pc\_argzero = sizeof(struct nlm\_void), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = St, .pc\_name = "NULL",@@ -564,6 +565,7 @@ const struct svc\_procedure nlmsvc\_procedures[24] = { .pc\_decode = nlmsvc\_decode\_testargs, .pc\_encode = nlmsvc\_encode\_testres, .pc\_argsize = sizeof(struct nlm\_args),+ .pc\_argzero = sizeof(struct nlm\_args), .pc\_ressize = sizeof(struct nlm\_res), .pc\_xdrressize = Ck+St+2+No+Rg, .pc\_name = "TEST",@@ -573,6 +575,7 @@ const struct svc\_procedure nlmsvc\_procedures[24] = { .pc\_decode = nlmsvc\_decode\_lockargs, .pc\_encode = nlmsvc\_encode\_res, .pc\_argsize = sizeof(struct nlm\_args),+ .pc\_argzero = sizeof(struct nlm\_args), .pc\_ressize = sizeof(struct nlm\_res), .pc\_xdrressize = Ck+St, .pc\_name = "LOCK",@@ -582,6 +585,7 @@ const struct svc\_procedure nlmsvc\_procedures[24] = { .pc\_decode = nlmsvc\_decode\_cancargs, .pc\_encode = nlmsvc\_encode\_res, .pc\_argsize = sizeof(struct nlm\_args),+ .pc\_argzero = sizeof(struct nlm\_args), .pc\_ressize = sizeof(struct nlm\_res), .pc\_xdrressize = Ck+St, .pc\_name = "CANCEL",@@ -591,6 +595,7 @@ const struct svc\_procedure nlmsvc\_procedures[24] = { .pc\_decode = nlmsvc\_decode\_unlockargs, .pc\_encode = nlmsvc\_encode\_res, .pc\_argsize = sizeof(struct nlm\_args),+ .pc\_argzero = sizeof(struct nlm\_args), .pc\_ressize = sizeof(struct nlm\_res), .pc\_xdrressize = Ck+St, .pc\_name = "UNLOCK",@@ -600,6 +605,7 @@ const struct svc\_procedure nlmsvc\_procedures[24] = { .pc\_decode = nlmsvc\_decode\_testargs, .pc\_encode = nlmsvc\_encode\_res, .pc\_argsize = sizeof(struct nlm\_args),+ .pc\_argzero = sizeof(struct nlm\_args), .pc\_ressize = sizeof(struct nlm\_res), .pc\_xdrressize = Ck+St, .pc\_name = "GRANTED",@@ -609,6 +615,7 @@ const struct svc\_procedure nlmsvc\_procedures[24] = { .pc\_decode = nlmsvc\_decode\_testargs, .pc\_encode = nlmsvc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_args),+ .pc\_argzero = sizeof(struct nlm\_args), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = St, .pc\_name = "TEST\_MSG",@@ -618,6 +625,7 @@ const struct svc\_procedure nlmsvc\_procedures[24] = { .pc\_decode = nlmsvc\_decode\_lockargs, .pc\_encode = nlmsvc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_args),+ .pc\_argzero = sizeof(struct nlm\_args), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = St, .pc\_name = "LOCK\_MSG",@@ -627,6 +635,7 @@ const struct svc\_procedure nlmsvc\_procedures[24] = { .pc\_decode = nlmsvc\_decode\_cancargs, .pc\_encode = nlmsvc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_args),+ .pc\_argzero = sizeof(struct nlm\_args), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = St, .pc\_name = "CANCEL\_MSG",@@ -636,6 +645,7 @@ const struct svc\_procedure nlmsvc\_procedures[24] = { .pc\_decode = nlmsvc\_decode\_unlockargs, .pc\_encode = nlmsvc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_args),+ .pc\_argzero = sizeof(struct nlm\_args), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = St, .pc\_name = "UNLOCK\_MSG",@@ -645,6 +655,7 @@ const struct svc\_procedure nlmsvc\_procedures[24] = { .pc\_decode = nlmsvc\_decode\_testargs, .pc\_encode = nlmsvc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_args),+ .pc\_argzero = sizeof(struct nlm\_args), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = St, .pc\_name = "GRANTED\_MSG",@@ -654,6 +665,7 @@ const struct svc\_procedure nlmsvc\_procedures[24] = { .pc\_decode = nlmsvc\_decode\_void, .pc\_encode = nlmsvc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_res),+ .pc\_argzero = sizeof(struct nlm\_res), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = St, .pc\_name = "TEST\_RES",@@ -663,6 +675,7 @@ const struct svc\_procedure nlmsvc\_procedures[24] = { .pc\_decode = nlmsvc\_decode\_void, .pc\_encode = nlmsvc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_res),+ .pc\_argzero = sizeof(struct nlm\_res), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = St, .pc\_name = "LOCK\_RES",@@ -672,6 +685,7 @@ const struct svc\_procedure nlmsvc\_procedures[24] = { .pc\_decode = nlmsvc\_decode\_void, .pc\_encode = nlmsvc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_res),+ .pc\_argzero = sizeof(struct nlm\_res), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = St, .pc\_name = "CANCEL\_RES",@@ -681,6 +695,7 @@ const struct svc\_procedure nlmsvc\_procedures[24] = { .pc\_decode = nlmsvc\_decode\_void, .pc\_encode = nlmsvc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_res),+ .pc\_argzero = sizeof(struct nlm\_res), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = St, .pc\_name = "UNLOCK\_RES",@@ -690,6 +705,7 @@ const struct svc\_procedure nlmsvc\_procedures[24] = { .pc\_decode = nlmsvc\_decode\_res, .pc\_encode = nlmsvc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_res),+ .pc\_argzero = sizeof(struct nlm\_res), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = St, .pc\_name = "GRANTED\_RES",@@ -699,6 +715,7 @@ const struct svc\_procedure nlmsvc\_procedures[24] = { .pc\_decode = nlmsvc\_decode\_reboot, .pc\_encode = nlmsvc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_reboot),+ .pc\_argzero = sizeof(struct nlm\_reboot), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = St, .pc\_name = "SM\_NOTIFY",@@ -708,6 +725,7 @@ const struct svc\_procedure nlmsvc\_procedures[24] = { .pc\_decode = nlmsvc\_decode\_void, .pc\_encode = nlmsvc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_void),+ .pc\_argzero = sizeof(struct nlm\_void), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = St, .pc\_name = "UNUSED",@@ -717,6 +735,7 @@ const struct svc\_procedure nlmsvc\_procedures[24] = { .pc\_decode = nlmsvc\_decode\_void, .pc\_encode = nlmsvc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_void),+ .pc\_argzero = sizeof(struct nlm\_void), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = St, .pc\_name = "UNUSED",@@ -726,6 +745,7 @@ const struct svc\_procedure nlmsvc\_procedures[24] = { .pc\_decode = nlmsvc\_decode\_void, .pc\_encode = nlmsvc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_void),+ .pc\_argzero = sizeof(struct nlm\_void), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = St, .pc\_name = "UNUSED",@@ -735,6 +755,7 @@ const struct svc\_procedure nlmsvc\_procedures[24] = { .pc\_decode = nlmsvc\_decode\_shareargs, .pc\_encode = nlmsvc\_encode\_shareres, .pc\_argsize = sizeof(struct nlm\_args),+ .pc\_argzero = sizeof(struct nlm\_args), .pc\_ressize = sizeof(struct nlm\_res), .pc\_xdrressize = Ck+St+1, .pc\_name = "SHARE",@@ -744,6 +765,7 @@ const struct svc\_procedure nlmsvc\_procedures[24] = { .pc\_decode = nlmsvc\_decode\_shareargs, .pc\_encode = nlmsvc\_encode\_shareres, .pc\_argsize = sizeof(struct nlm\_args),+ .pc\_argzero = sizeof(struct nlm\_args), .pc\_ressize = sizeof(struct nlm\_res), .pc\_xdrressize = Ck+St+1, .pc\_name = "UNSHARE",@@ -753,6 +775,7 @@ const struct svc\_procedure nlmsvc\_procedures[24] = { .pc\_decode = nlmsvc\_decode\_lockargs, .pc\_encode = nlmsvc\_encode\_res, .pc\_argsize = sizeof(struct nlm\_args),+ .pc\_argzero = sizeof(struct nlm\_args), .pc\_ressize = sizeof(struct nlm\_res), .pc\_xdrressize = Ck+St, .pc\_name = "NM\_LOCK",@@ -762,6 +785,7 @@ const struct svc\_procedure nlmsvc\_procedures[24] = { .pc\_decode = nlmsvc\_decode\_notify, .pc\_encode = nlmsvc\_encode\_void, .pc\_argsize = sizeof(struct nlm\_args),+ .pc\_argzero = sizeof(struct nlm\_args), .pc\_ressize = sizeof(struct nlm\_void), .pc\_xdrressize = 0, .pc\_name = "FREE\_ALL",diff --git a/fs/nfs/callback\_xdr.c b/fs/nfs/callback\_xdr.cindex 8dcb08e1a885d6..d0cccddb7d0885 100644--- a/[fs/nfs/callback\_xdr.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfs/callback_xdr.c?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/nfs/callback\_xdr.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfs/callback_xdr.c?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -1065,6 +1065,7 @@ static const struct svc\_procedure nfs4\_callback\_procedures1[] = { .pc\_func = nfs4\_callback\_compound, .pc\_encode = nfs4\_encode\_void, .pc\_argsize = 256,+ .pc\_argzero = 256, .pc\_ressize = 256, .pc\_xdrressize = NFS4\_CALLBACK\_BUFSIZE, .pc\_name = "COMPOUND",diff --git a/fs/nfsd/cache.h b/fs/nfsd/cache.hindex 65c331f75e9c7b..f21259ead64bb3 100644--- a/[fs/nfsd/cache.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/cache.h?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/nfsd/cache.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/cache.h?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -84,6 +84,6 @@ int nfsd\_reply\_cache\_init(struct nfsd\_net \*); void nfsd\_reply\_cache\_shutdown(struct nfsd\_net \*); int nfsd\_cache\_lookup(struct svc\_rqst \*); void nfsd\_cache\_update(struct svc\_rqst \*, int, \_\_be32 \*);-int nfsd\_reply\_cache\_stats\_open(struct inode \*, struct file \*);+int nfsd\_reply\_cache\_stats\_show(struct seq\_file \*m, void \*v);  #endif /\* NFSCACHE\_H \*/diff --git a/fs/nfsd/filecache.c b/fs/nfsd/filecache.cindex eeed4ae5b4ad90..d5c57360b4182e 100644--- a/[fs/nfsd/filecache.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/filecache.c?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/nfsd/filecache.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/filecache.c?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -1212,7 +1212,7 @@ nfsd\_file\_create(struct svc\_rqst \*rqstp, struct svc\_fh \*fhp, \* scraping this file for info should test the labels to ensure they're \* getting the correct field. \*/-static int nfsd\_file\_cache\_stats\_show(struct seq\_file \*m, void \*v)+int nfsd\_file\_cache\_stats\_show(struct seq\_file \*m, void \*v) { unsigned long releases = 0, pages\_flushed = 0, evictions = 0; unsigned long hits = 0, acquisitions = 0;@@ -1259,8 +1259,3 @@ static int nfsd\_file\_cache\_stats\_show(struct seq\_file \*m, void \*v) seq\_printf(m, "pages flushed: %lu\n", pages\_flushed); return 0; }--int nfsd\_file\_cache\_stats\_open(struct inode \*inode, struct file \*file)-{- return single\_open(file, nfsd\_file\_cache\_stats\_show, NULL);-}diff --git a/fs/nfsd/filecache.h b/fs/nfsd/filecache.hindex 8e8c0c47d67df4..357832bac736b8 100644--- a/[fs/nfsd/filecache.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/filecache.h?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/nfsd/filecache.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/filecache.h?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -60,5 +60,5 @@ \_\_be32 nfsd\_file\_acquire(struct svc\_rqst \*rqstp, struct svc\_fh \*fhp, unsigned int may\_flags, struct nfsd\_file \*\*nfp); \_\_be32 nfsd\_file\_create(struct svc\_rqst \*rqstp, struct svc\_fh \*fhp, unsigned int may\_flags, struct nfsd\_file \*\*nfp);-int nfsd\_file\_cache\_stats\_open(struct inode \*, struct file \*);+int nfsd\_file\_cache\_stats\_show(struct seq\_file \*m, void \*v); #endif /\* \_FS\_NFSD\_FILECACHE\_H \*/diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.hindex ffe17743cc74be..8c854ba3285bbc 100644--- a/[fs/nfsd/netns.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/netns.h?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/nfsd/netns.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/netns.h?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -192,6 +192,10 @@ struct nfsd\_net {  atomic\_t nfs4\_client\_count; int nfs4\_max\_clients;++ atomic\_t nfsd\_courtesy\_clients;+ struct shrinker nfsd\_client\_shrinker;+ struct delayed\_work nfsd\_shrinker\_work; };  /\* Simple check to find out if a given net was properly initialized \*/diff --git a/fs/nfsd/nfs2acl.c b/fs/nfsd/nfs2acl.cindex 9edd3c1a30fb10..13e6e6897f6cf3 100644--- a/[fs/nfsd/nfs2acl.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs2acl.c?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/nfsd/nfs2acl.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs2acl.c?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -331,6 +331,7 @@ static const struct svc\_procedure nfsd\_acl\_procedures2[5] = { .pc\_decode = nfssvc\_decode\_voidarg, .pc\_encode = nfssvc\_encode\_voidres, .pc\_argsize = sizeof(struct nfsd\_voidargs),+ .pc\_argzero = sizeof(struct nfsd\_voidargs), .pc\_ressize = sizeof(struct nfsd\_voidres), .pc\_cachetype = RC\_NOCACHE, .pc\_xdrressize = ST,@@ -342,6 +343,7 @@ static const struct svc\_procedure nfsd\_acl\_procedures2[5] = { .pc\_encode = nfsaclsvc\_encode\_getaclres, .pc\_release = nfsaclsvc\_release\_getacl, .pc\_argsize = sizeof(struct nfsd3\_getaclargs),+ .pc\_argzero = sizeof(struct nfsd3\_getaclargs), .pc\_ressize = sizeof(struct nfsd3\_getaclres), .pc\_cachetype = RC\_NOCACHE, .pc\_xdrressize = ST+1+2\*(1+ACL),@@ -353,6 +355,7 @@ static const struct svc\_procedure nfsd\_acl\_procedures2[5] = { .pc\_encode = nfssvc\_encode\_attrstatres, .pc\_release = nfssvc\_release\_attrstat, .pc\_argsize = sizeof(struct nfsd3\_setaclargs),+ .pc\_argzero = sizeof(struct nfsd3\_setaclargs), .pc\_ressize = sizeof(struct nfsd\_attrstat), .pc\_cachetype = RC\_NOCACHE, .pc\_xdrressize = ST+AT,@@ -364,6 +367,7 @@ static const struct svc\_procedure nfsd\_acl\_procedures2[5] = { .pc\_encode = nfssvc\_encode\_attrstatres, .pc\_release = nfssvc\_release\_attrstat, .pc\_argsize = sizeof(struct nfsd\_fhandle),+ .pc\_argzero = sizeof(struct nfsd\_fhandle), .pc\_ressize = sizeof(struct nfsd\_attrstat), .pc\_cachetype = RC\_NOCACHE, .pc\_xdrressize = ST+AT,@@ -375,6 +379,7 @@ static const struct svc\_procedure nfsd\_acl\_procedures2[5] = { .pc\_encode = nfsaclsvc\_encode\_accessres, .pc\_release = nfsaclsvc\_release\_access, .pc\_argsize = sizeof(struct nfsd3\_accessargs),+ .pc\_argzero = sizeof(struct nfsd3\_accessargs), .pc\_ressize = sizeof(struct nfsd3\_accessres), .pc\_cachetype = RC\_NOCACHE, .pc\_xdrressize = ST+AT+1,diff --git a/fs/nfsd/nfs3acl.c b/fs/nfsd/nfs3acl.cindex 9446c67436649c..2fb9ee3564558e 100644--- a/[fs/nfsd/nfs3acl.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs3acl.c?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/nfsd/nfs3acl.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs3acl.c?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -252,6 +252,7 @@ static const struct svc\_procedure nfsd\_acl\_procedures3[3] = { .pc\_decode = nfssvc\_decode\_voidarg, .pc\_encode = nfssvc\_encode\_voidres, .pc\_argsize = sizeof(struct nfsd\_voidargs),+ .pc\_argzero = sizeof(struct nfsd\_voidargs), .pc\_ressize = sizeof(struct nfsd\_voidres), .pc\_cachetype = RC\_NOCACHE, .pc\_xdrressize = ST,@@ -263,6 +264,7 @@ static const struct svc\_procedure nfsd\_acl\_procedures3[3] = { .pc\_encode = nfs3svc\_encode\_getaclres, .pc\_release = nfs3svc\_release\_getacl, .pc\_argsize = sizeof(struct nfsd3\_getaclargs),+ .pc\_argzero = sizeof(struct nfsd3\_getaclargs), .pc\_ressize = sizeof(struct nfsd3\_getaclres), .pc\_cachetype = RC\_NOCACHE, .pc\_xdrressize = ST+1+2\*(1+ACL),@@ -274,6 +276,7 @@ static const struct svc\_procedure nfsd\_acl\_procedures3[3] = { .pc\_encode = nfs3svc\_encode\_setaclres, .pc\_release = nfs3svc\_release\_fhandle, .pc\_argsize = sizeof(struct nfsd3\_setaclargs),+ .pc\_argzero = sizeof(struct nfsd3\_setaclargs), .pc\_ressize = sizeof(struct nfsd3\_attrstat), .pc\_cachetype = RC\_NOCACHE, .pc\_xdrressize = ST+pAT,diff --git a/fs/nfsd/nfs3proc.c b/fs/nfsd/nfs3proc.cindex a41cca619338db..923d9a80df92cd 100644--- a/[fs/nfsd/nfs3proc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs3proc.c?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/nfsd/nfs3proc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs3proc.c?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -150,7 +150,6 @@ nfsd3\_proc\_read(struct svc\_rqst \*rqstp) { struct nfsd3\_readargs \*argp = rqstp->rq\_argp; struct nfsd3\_readres \*resp = rqstp->rq\_resp;- u32 max\_blocksize = svc\_max\_payload(rqstp); unsigned int len; int v; @@ -159,7 +158,8 @@ nfsd3\_proc\_read(struct svc\_rqst \*rqstp) (unsigned long) argp->count, (unsigned long long) argp->offset); - argp->count = min\_t(u32, argp->count, max\_blocksize);+ argp->count = min\_t(u32, argp->count, svc\_max\_payload(rqstp));+ argp->count = min\_t(u32, argp->count, rqstp->rq\_res.buflen); if (argp->offset > (u64)OFFSET\_MAX) argp->offset = (u64)OFFSET\_MAX; if (argp->offset + argp->count > (u64)OFFSET\_MAX)@@ -563,25 +563,18 @@ static void nfsd3\_init\_dirlist\_pages(struct svc\_rqst \*rqstp, { struct xdr\_buf \*buf = &resp->dirlist; struct xdr\_stream \*xdr = &resp->xdr;-- count = clamp(count, (u32)(XDR\_UNIT \* 2), svc\_max\_payload(rqstp));+ unsigned int sendbuf = min\_t(unsigned int, rqstp->rq\_res.buflen,+ svc\_max\_payload(rqstp));  memset(buf, 0, sizeof(\*buf));  /\* Reserve room for the NULL ptr & eof flag (-2 words) \*/- buf->buflen = count - XDR\_UNIT \* 2;+ buf->buflen = clamp(count, (u32)(XDR\_UNIT \* 2), sendbuf);+ buf->buflen -= XDR\_UNIT \* 2; buf->pages = rqstp->rq\_next\_page; rqstp->rq\_next\_page += (buf->buflen + PAGE\_SIZE - 1) >> PAGE\_SHIFT; - /\* This is xdr\_init\_encode(), but it assumes that- \* the head kvec has already been consumed. \*/- xdr\_set\_scratch\_buffer(xdr, NULL, 0);- xdr->buf = buf;- xdr->page\_ptr = buf->pages;- xdr->iov = NULL;- xdr->p = page\_address(\*buf->pages);- xdr->end = (void \*)xdr->p + min\_t(u32, buf->buflen, PAGE\_SIZE);- xdr->rqst = NULL;+ xdr\_init\_encode\_pages(xdr, buf, buf->pages, NULL); }  /\*@@ -808,6 +801,7 @@ static const struct svc\_procedure nfsd\_procedures3[22] = { .pc\_decode = nfssvc\_decode\_voidarg, .pc\_encode = nfssvc\_encode\_voidres, .pc\_argsize = sizeof(struct nfsd\_voidargs),+ .pc\_argzero = sizeof(struct nfsd\_voidargs), .pc\_ressize = sizeof(struct nfsd\_voidres), .pc\_cachetype = RC\_NOCACHE, .pc\_xdrressize = ST,@@ -819,6 +813,7 @@ static const struct svc\_procedure nfsd\_procedures3[22] = { .pc\_encode = nfs3svc\_encode\_getattrres, .pc\_release = nfs3svc\_release\_fhandle, .pc\_argsize = sizeof(struct nfsd\_fhandle),+ .pc\_argzero = sizeof(struct nfsd\_fhandle), .pc\_ressize = sizeof(struct nfsd3\_attrstatres), .pc\_cachetype = RC\_NOCACHE, .pc\_xdrressize = ST+AT,@@ -830,6 +825,7 @@ static const struct svc\_procedure nfsd\_procedures3[22] = { .pc\_encode = nfs3svc\_encode\_wccstatres, .pc\_release = nfs3svc\_release\_fhandle, .pc\_argsize = sizeof(struct nfsd3\_sattrargs),+ .pc\_argzero = sizeof(struct nfsd3\_sattrargs), .pc\_ressize = sizeof(struct nfsd3\_wccstatres), .pc\_cachetype = RC\_REPLBUFF, .pc\_xdrressize = ST+WC,@@ -841,6 +837,7 @@ static const struct svc\_procedure nfsd\_procedures3[22] = { .pc\_encode = nfs3svc\_encode\_lookupres, .pc\_release = nfs3svc\_release\_fhandle2, .pc\_argsize = sizeof(struct nfsd3\_diropargs),+ .pc\_argzero = sizeof(struct nfsd3\_diropargs), .pc\_ressize = sizeof(struct nfsd3\_diropres), .pc\_cachetype = RC\_NOCACHE, .pc\_xdrressize = ST+FH+pAT+pAT,@@ -852,6 +849,7 @@ static const struct svc\_procedure nfsd\_procedures3[22] = { .pc\_encode = nfs3svc\_encode\_accessres, .pc\_release = nfs3svc\_release\_fhandle, .pc\_argsize = sizeof(struct nfsd3\_accessargs),+ .pc\_argzero = sizeof(struct nfsd3\_accessargs), .pc\_ressize = sizeof(struct nfsd3\_accessres), .pc\_cachetype = RC\_NOCACHE, .pc\_xdrressize = ST+pAT+1,@@ -863,6 +861,7 @@ static const struct svc\_procedure nfsd\_procedures3[22] = { .pc\_encode = nfs3svc\_encode\_readlinkres, .pc\_release = nfs3svc\_release\_fhandle, .pc\_argsize = sizeof(struct nfsd\_fhandle),+ .pc\_argzero = sizeof(struct nfsd\_fhandle), .pc\_ressize = sizeof(struct nfsd3\_readlinkres), .pc\_cachetype = RC\_NOCACHE, .pc\_xdrressize = ST+pAT+1+NFS3\_MAXPATHLEN/4,@@ -874,6 +873,7 @@ static const struct svc\_procedure nfsd\_procedures3[22] = { .pc\_encode = nfs3svc\_encode\_readres, .pc\_release = nfs3svc\_release\_fhandle, .pc\_argsize = sizeof(struct nfsd3\_readargs),+ .pc\_argzero = sizeof(struct nfsd3\_readargs), .pc\_ressize = sizeof(struct nfsd3\_readres), .pc\_cachetype = RC\_NOCACHE, .pc\_xdrressize = ST+pAT+4+NFSSVC\_MAXBLKSIZE/4,@@ -885,6 +885,7 @@ static const struct svc\_procedure nfsd\_procedures3[22] = { .pc\_encode = nfs3svc\_encode\_writeres, .pc\_release = nfs3svc\_release\_fhandle, .pc\_argsize = sizeof(struct nfsd3\_writeargs),+ .pc\_argzero = sizeof(struct nfsd3\_writeargs), .pc\_ressize = sizeof(struct nfsd3\_writeres), .pc\_cachetype = RC\_REPLBUFF, .pc\_xdrressize = ST+WC+4,@@ -896,6 +897,7 @@ static const struct svc\_procedure nfsd\_procedures3[22] = { .pc\_encode = nfs3svc\_encode\_createres, .pc\_release = nfs3svc\_release\_fhandle2, .pc\_argsize = sizeof(struct nfsd3\_createargs),+ .pc\_argzero = sizeof(struct nfsd3\_createargs), .pc\_ressize = sizeof(struct nfsd3\_createres), .pc\_cachetype = RC\_REPLBUFF, .pc\_xdrressize = ST+(1+FH+pAT)+WC,@@ -907,6 +909,7 @@ static const struct svc\_procedure nfsd\_procedures3[22] = { .pc\_encode = nfs3svc\_encode\_createres, .pc\_release = nfs3svc\_release\_fhandle2, .pc\_argsize = sizeof(struct nfsd3\_mkdirargs),+ .pc\_argzero = sizeof(struct nfsd3\_mkdirargs), .pc\_ressize = sizeof(struct nfsd3\_createres), .pc\_cachetype = RC\_REPLBUFF, .pc\_xdrressize = ST+(1+FH+pAT)+WC,@@ -918,6 +921,7 @@ static const struct svc\_procedure nfsd\_procedures3[22] = { .pc\_encode = nfs3svc\_encode\_createres, .pc\_release = nfs3svc\_release\_fhandle2, .pc\_argsize = sizeof(struct nfsd3\_symlinkargs),+ .pc\_argzero = sizeof(struct nfsd3\_symlinkargs), .pc\_ressize = sizeof(struct nfsd3\_createres), .pc\_cachetype = RC\_REPLBUFF, .pc\_xdrressize = ST+(1+FH+pAT)+WC,@@ -929,6 +933,7 @@ static const struct svc\_procedure nfsd\_procedures3[22] = { .pc\_encode = nfs3svc\_encode\_createres, .pc\_release = nfs3svc\_release\_fhandle2, .pc\_argsize = sizeof(struct nfsd3\_mknodargs),+ .pc\_argzero = sizeof(struct nfsd3\_mknodargs), .pc\_ressize = sizeof(struct nfsd3\_createres), .pc\_cachetype = RC\_REPLBUFF, .pc\_xdrressize = ST+(1+FH+pAT)+WC,@@ -940,6 +945,7 @@ static const struct svc\_procedure nfsd\_procedures3[22] = { .pc\_encode = nfs3svc\_encode\_wccstatres, .pc\_release = nfs3svc\_release\_fhandle, .pc\_argsize = sizeof(struct nfsd3\_diropargs),+ .pc\_argzero = sizeof(struct nfsd3\_diropargs), .pc\_ressize = sizeof(struct nfsd3\_wccstatres), .pc\_cachetype = RC\_REPLBUFF, .pc\_xdrressize = ST+WC,@@ -951,6 +957,7 @@ static const struct svc\_procedure nfsd\_procedures3[22] = { .pc\_encode = nfs3svc\_encode\_wccstatres, .pc\_release = nfs3svc\_release\_fhandle, .pc\_argsize = sizeof(struct nfsd3\_diropargs),+ .pc\_argzero = sizeof(struct nfsd3\_diropargs), .pc\_ressize = sizeof(struct nfsd3\_wccstatres), .pc\_cachetype = RC\_REPLBUFF, .pc\_xdrressize = ST+WC,@@ -962,6 +969,7 @@ static const struct svc\_procedure nfsd\_procedures3[22] = { .pc\_encode = nfs3svc\_encode\_renameres, .pc\_release = nfs3svc\_release\_fhandle2, .pc\_argsize = sizeof(struct nfsd3\_renameargs),+ .pc\_argzero = sizeof(struct nfsd3\_renameargs), .pc\_ressize = sizeof(struct nfsd3\_renameres), .pc\_cachetype = RC\_REPLBUFF, .pc\_xdrressize = ST+WC+WC,@@ -973,6 +981,7 @@ static const struct svc\_procedure nfsd\_procedures3[22] = { .pc\_encode = nfs3svc\_encode\_linkres, .pc\_release = nfs3svc\_release\_fhandle2, .pc\_argsize = sizeof(struct nfsd3\_linkargs),+ .pc\_argzero = sizeof(struct nfsd3\_linkargs), .pc\_ressize = sizeof(struct nfsd3\_linkres), .pc\_cachetype = RC\_REPLBUFF, .pc\_xdrressize = ST+pAT+WC,@@ -984,6 +993,7 @@ static const struct svc\_procedure nfsd\_procedures3[22] = { .pc\_encode = nfs3svc\_encode\_readdirres, .pc\_release = nfs3svc\_release\_fhandle, .pc\_argsize = sizeof(struct nfsd3\_readdirargs),+ .pc\_argzero = sizeof(struct nfsd3\_readdirargs), .pc\_ressize = sizeof(struct nfsd3\_readdirres), .pc\_cachetype = RC\_NOCACHE, .pc\_name = "READDIR",@@ -994,6 +1004,7 @@ static const struct svc\_procedure nfsd\_procedures3[22] = { .pc\_encode = nfs3svc\_encode\_readdirres, .pc\_release = nfs3svc\_release\_fhandle, .pc\_argsize = sizeof(struct nfsd3\_readdirplusargs),+ .pc\_argzero = sizeof(struct nfsd3\_readdirplusargs), .pc\_ressize = sizeof(struct nfsd3\_readdirres), .pc\_cachetype = RC\_NOCACHE, .pc\_name = "READDIRPLUS",@@ -1003,6 +1014,7 @@ static const struct svc\_procedure nfsd\_procedures3[22] = { .pc\_decode = nfs3svc\_decode\_fhandleargs, .pc\_encode = nfs3svc\_encode\_fsstatres, .pc\_argsize = sizeof(struct nfsd3\_fhandleargs),+ .pc\_argzero = sizeof(struct nfsd3\_fhandleargs), .pc\_ressize = sizeof(struct nfsd3\_fsstatres), .pc\_cachetype = RC\_NOCACHE, .pc\_xdrressize = ST+pAT+2\*6+1,@@ -1013,6 +1025,7 @@ static const struct svc\_procedure nfsd\_procedures3[22] = { .pc\_decode = nfs3svc\_decode\_fhandleargs, .pc\_encode = nfs3svc\_encode\_fsinfores, .pc\_argsize = sizeof(struct nfsd3\_fhandleargs),+ .pc\_argzero = sizeof(struct nfsd3\_fhandleargs), .pc\_ressize = sizeof(struct nfsd3\_fsinfores), .pc\_cachetype = RC\_NOCACHE, .pc\_xdrressize = ST+pAT+12,@@ -1023,6 +1036,7 @@ static const struct svc\_procedure nfsd\_procedures3[22] = { .pc\_decode = nfs3svc\_decode\_fhandleargs, .pc\_encode = nfs3svc\_encode\_pathconfres, .pc\_argsize = sizeof(struct nfsd3\_fhandleargs),+ .pc\_argzero = sizeof(struct nfsd3\_fhandleargs), .pc\_ressize = sizeof(struct nfsd3\_pathconfres), .pc\_cachetype = RC\_NOCACHE, .pc\_xdrressize = ST+pAT+6,@@ -1034,6 +1048,7 @@ static const struct svc\_procedure nfsd\_procedures3[22] = { .pc\_encode = nfs3svc\_encode\_commitres, .pc\_release = nfs3svc\_release\_fhandle, .pc\_argsize = sizeof(struct nfsd3\_commitargs),+ .pc\_argzero = sizeof(struct nfsd3\_commitargs), .pc\_ressize = sizeof(struct nfsd3\_commitres), .pc\_cachetype = RC\_NOCACHE, .pc\_xdrressize = ST+WC+2,diff --git a/fs/nfsd/nfs3xdr.c b/fs/nfsd/nfs3xdr.cindex 0293b8d65f10fc..3308dd671ef0b8 100644--- a/[fs/nfsd/nfs3xdr.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs3xdr.c?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/nfsd/nfs3xdr.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs3xdr.c?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -571,10 +571,8 @@ nfs3svc\_decode\_writeargs(struct svc\_rqst \*rqstp, struct xdr\_stream \*xdr) args->count = max\_blocksize; args->len = max\_blocksize; }- if (!xdr\_stream\_subsegment(xdr, &args->payload, args->count))- return false; - return true;+ return xdr\_stream\_subsegment(xdr, &args->payload, args->count); }  bool@@ -616,8 +614,6 @@ nfs3svc\_decode\_symlinkargs(struct svc\_rqst \*rqstp, struct xdr\_stream \*xdr) { struct nfsd3\_symlinkargs \*args = rqstp->rq\_argp; struct kvec \*head = rqstp->rq\_arg.head;- struct kvec \*tail = rqstp->rq\_arg.tail;- size\_t remaining;  if (!svcxdr\_decode\_diropargs3(xdr, &args->ffh, &args->fname, &args->flen)) return false;@@ -626,16 +622,10 @@ nfs3svc\_decode\_symlinkargs(struct svc\_rqst \*rqstp, struct xdr\_stream \*xdr) if (xdr\_stream\_decode\_u32(xdr, &args->tlen) < 0) return false; - /\* request sanity \*/- remaining = head->iov\_len + rqstp->rq\_arg.page\_len + tail->iov\_len;- remaining -= xdr\_stream\_pos(xdr);- if (remaining < xdr\_align\_size(args->tlen))- return false;-- args->first.iov\_base = xdr->p;+ /\* symlink\_data \*/ args->first.iov\_len = head->iov\_len - xdr\_stream\_pos(xdr);-- return true;+ args->first.iov\_base = xdr\_inline\_decode(xdr, args->tlen);+ return args->first.iov\_base != NULL; }  booldiff --git a/fs/nfsd/nfs4callback.c b/fs/nfsd/nfs4callback.cindex 4ce328209f6140..f0e69edf5f0f1c 100644--- a/[fs/nfsd/nfs4callback.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs4callback.c?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/nfsd/nfs4callback.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs4callback.c?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -1371,11 +1371,21 @@ void nfsd4\_init\_cb(struct nfsd4\_callback \*cb, struct nfs4\_client \*clp, cb->cb\_holds\_slot = false; } -void nfsd4\_run\_cb(struct nfsd4\_callback \*cb)+/\*\*+ \* nfsd4\_run\_cb - queue up a callback job to run+ \* @cb: callback to queue+ \*+ \* Kick off a callback to do its thing. Returns false if it was already+ \* on a queue, true otherwise.+ \*/+bool nfsd4\_run\_cb(struct nfsd4\_callback \*cb) { struct nfs4\_client \*clp = cb->cb\_clp;+ bool queued;  nfsd41\_cb\_inflight\_begin(clp);- if (!nfsd4\_queue\_cb(cb))+ queued = nfsd4\_queue\_cb(cb);+ if (!queued) nfsd41\_cb\_inflight\_end(clp);+ return queued; }diff --git a/fs/nfsd/nfs4idmap.c b/fs/nfsd/nfs4idmap.cindex f92161ce1f97dd..e70a1a2999b7b4 100644--- a/[fs/nfsd/nfs4idmap.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs4idmap.c?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/nfsd/nfs4idmap.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs4idmap.c?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -82,8 +82,8 @@ ent\_init(struct cache\_head \*cnew, struct cache\_head \*citm) new->id = itm->id; new->type = itm->type; - strlcpy(new->name, itm->name, sizeof(new->name));- strlcpy(new->authname, itm->authname, sizeof(new->authname));+ strscpy(new->name, itm->name, sizeof(new->name));+ strscpy(new->authname, itm->authname, sizeof(new->authname)); }  static void@@ -548,7 +548,7 @@ idmap\_name\_to\_id(struct svc\_rqst \*rqstp, int type, const char \*name, u32 namelen return nfserr\_badowner; memcpy(key.name, name, namelen); key.name[namelen] = '\0';- strlcpy(key.authname, rqst\_authname(rqstp), sizeof(key.authname));+ strscpy(key.authname, rqst\_authname(rqstp), sizeof(key.authname)); ret = idmap\_lookup(rqstp, nametoid\_lookup, &key, nn->nametoid\_cache, &item); if (ret == -ENOENT) return nfserr\_badowner;@@ -584,7 +584,7 @@ static \_\_be32 idmap\_id\_to\_name(struct xdr\_stream \*xdr, int ret; struct nfsd\_net \*nn = net\_generic(SVC\_NET(rqstp), nfsd\_net\_id); - strlcpy(key.authname, rqst\_authname(rqstp), sizeof(key.authname));+ strscpy(key.authname, rqst\_authname(rqstp), sizeof(key.authname)); ret = idmap\_lookup(rqstp, idtoname\_lookup, &key, nn->idtoname\_cache, &item); if (ret == -ENOENT) return encode\_ascii\_id(xdr, id);diff --git a/fs/nfsd/nfs4layouts.c b/fs/nfsd/nfs4layouts.cindex 2c05692a9abf1a..3564d1c6f61042 100644--- a/[fs/nfsd/nfs4layouts.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs4layouts.c?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/nfsd/nfs4layouts.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs4layouts.c?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -658,7 +658,7 @@ nfsd4\_cb\_layout\_done(struct nfsd4\_callback \*cb, struct rpc\_task \*task) ktime\_t now, cutoff; const struct nfsd4\_layout\_ops \*ops; -+ trace\_nfsd\_cb\_layout\_done(&ls->ls\_stid.sc\_stateid, task); switch (task->tk\_status) { case 0: case -NFS4ERR\_DELAY:diff --git a/fs/nfsd/nfs4proc.c b/fs/nfsd/nfs4proc.cindex a72ab97f77efe2..8beb2bc4c328f5 100644--- a/[fs/nfsd/nfs4proc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs4proc.c?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/nfsd/nfs4proc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs4proc.c?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -141,7 +141,6 @@ fh\_dup2(struct svc\_fh \*dst, struct svc\_fh \*src) static \_\_be32 do\_open\_permission(struct svc\_rqst \*rqstp, struct svc\_fh \*current\_fh, struct nfsd4\_open \*open, int accmode) {- \_\_be32 status;  if (open->op\_truncate && !(open->op\_share\_access & NFS4\_SHARE\_ACCESS\_WRITE))@@ -156,9 +155,7 @@ do\_open\_permission(struct svc\_rqst \*rqstp, struct svc\_fh \*current\_fh, struct nfs if (open->op\_share\_deny & NFS4\_SHARE\_DENY\_READ) accmode |= NFSD\_MAY\_WRITE; - status = fh\_verify(rqstp, current\_fh, S\_IFREG, accmode);-- return status;+ return fh\_verify(rqstp, current\_fh, S\_IFREG, accmode); }  static \_\_be32 nfsd\_check\_obj\_isreg(struct svc\_fh \*fh)@@ -454,7 +451,6 @@ static \_\_be32 do\_open\_fhandle(struct svc\_rqst \*rqstp, struct nfsd4\_compound\_state \*cstate, struct nfsd4\_open \*open) { struct svc\_fh \*current\_fh = &cstate->current\_fh;- \_\_be32 status; int accmode = 0;  /\* We don't know the target directory, and therefore can not@@ -479,9 +475,7 @@ do\_open\_fhandle(struct svc\_rqst \*rqstp, struct nfsd4\_compound\_state \*cstate, str if (open->op\_claim\_type == NFS4\_OPEN\_CLAIM\_DELEG\_CUR\_FH) accmode = NFSD\_MAY\_OWNER\_OVERRIDE; - status = do\_open\_permission(rqstp, current\_fh, open, accmode);-- return status;+ return do\_open\_permission(rqstp, current\_fh, open, accmode); }  static void@@ -668,11 +662,9 @@ static \_\_be32 nfsd4\_putrootfh(struct svc\_rqst \*rqstp, struct nfsd4\_compound\_state \*cstate, union nfsd4\_op\_u \*u) {- \_\_be32 status;- fh\_put(&cstate->current\_fh);- status = exp\_pseudoroot(rqstp, &cstate->current\_fh);- return status;++ return exp\_pseudoroot(rqstp, &cstate->current\_fh); }  static \_\_be32@@ -1343,7 +1335,7 @@ try\_again: return 0; } if (work) {- strlcpy(work->nsui\_ipaddr, ipaddr, sizeof(work->nsui\_ipaddr) - 1);+ strscpy(work->nsui\_ipaddr, ipaddr, sizeof(work->nsui\_ipaddr) - 1); refcount\_set(&work->nsui\_refcnt, 2); work->nsui\_busy = true; list\_add\_tail(&work->nsui\_list, &nn->nfsd\_ssc\_mount\_list);@@ -1621,6 +1613,10 @@ static void nfsd4\_cb\_offload\_release(struct nfsd4\_callback \*cb) static int nfsd4\_cb\_offload\_done(struct nfsd4\_callback \*cb, struct rpc\_task \*task) {+ struct nfsd4\_cb\_offload \*cbo =+ container\_of(cb, struct nfsd4\_cb\_offload, co\_cb);++ trace\_nfsd\_cb\_offload\_done(&cbo->co\_res.cb\_stateid, task); return 1; } @@ -1768,7 +1764,13 @@ static int nfsd4\_do\_async\_copy(void \*data) filp = nfs42\_ssc\_open(copy->ss\_mnt, &copy->c\_fh, &copy->stateid); if (IS\_ERR(filp)) {- nfserr = nfserr\_offload\_denied;+ switch (PTR\_ERR(filp)) {+ case -EBADF:+ nfserr = nfserr\_wrong\_type;+ break;+ default:+ nfserr = nfserr\_offload\_denied;+ } nfsd4\_interssc\_disconnect(copy->ss\_mnt); goto do\_callback; }@@ -1826,7 +1828,7 @@ nfsd4\_copy(struct svc\_rqst \*rqstp, struct nfsd4\_compound\_state \*cstate, if (!nfs4\_init\_copy\_state(nn, copy)) goto out\_err; refcount\_set(&async\_copy->refcount, 1);- memcpy(&copy->cp\_res.cb\_stateid, &copy->cp\_stateid.stid,+ memcpy(&copy->cp\_res.cb\_stateid, &copy->cp\_stateid.cs\_stid, sizeof(copy->cp\_res.cb\_stateid)); dup\_copy\_fields(copy, async\_copy); async\_copy->copy\_task = kthread\_create(nfsd4\_do\_async\_copy,@@ -1862,7 +1864,7 @@ find\_async\_copy(struct nfs4\_client \*clp, stateid\_t \*stateid)  spin\_lock(&clp->async\_lock); list\_for\_each\_entry(copy, &clp->async\_copies, copies) {- if (memcmp(&copy->cp\_stateid.stid, stateid, NFS4\_STATEID\_SIZE))+ if (memcmp(&copy->cp\_stateid.cs\_stid, stateid, NFS4\_STATEID\_SIZE)) continue; refcount\_inc(&copy->refcount); spin\_unlock(&clp->async\_lock);@@ -1916,7 +1918,7 @@ nfsd4\_copy\_notify(struct svc\_rqst \*rqstp, struct nfsd4\_compound\_state \*cstate, cps = nfs4\_alloc\_init\_cpntf\_state(nn, stid); if (!cps) goto out;- memcpy(&cn->cpn\_cnr\_stateid, &cps->cp\_stateid.stid, sizeof(stateid\_t));+ memcpy(&cn->cpn\_cnr\_stateid, &cps->cp\_stateid.cs\_stid, sizeof(stateid\_t)); memcpy(&cps->cp\_p\_stateid, &stid->sc\_stateid, sizeof(stateid\_t)); memcpy(&cps->cp\_p\_clid, &clp->cl\_clientid, sizeof(clientid\_t)); @@ -2633,9 +2635,6 @@ nfsd4\_proc\_compound(struct svc\_rqst \*rqstp) status = nfserr\_minor\_vers\_mismatch; if (nfsd\_minorversion(nn, args->minorversion, NFSD\_TEST) <= 0) goto out;- status = nfserr\_resource;- if (args->opcnt > NFSD\_MAX\_OPS\_PER\_COMPOUND)- goto out;  status = nfs41\_check\_op\_ordering(args); if (status) {@@ -2648,10 +2647,20 @@ nfsd4\_proc\_compound(struct svc\_rqst \*rqstp)  rqstp->rq\_lease\_breaker = (void \*\*)&cstate->clp; - trace\_nfsd\_compound(rqstp, args->opcnt);+ trace\_nfsd\_compound(rqstp, args->tag, args->taglen, args->client\_opcnt); while (!status && resp->opcnt < args->opcnt) { op = &args->ops[resp->opcnt++]; + if (unlikely(resp->opcnt == NFSD\_MAX\_OPS\_PER\_COMPOUND)) {+ /\* If there are still more operations to process,+ \* stop here and report NFS4ERR\_RESOURCE. \*/+ if (cstate->minorversion == 0 &&+ args->client\_opcnt > resp->opcnt) {+ op->status = nfserr\_resource;+ goto encode\_op;+ }+ }+ /\* \* The XDR decode routines may have pre-set op->status; \* for example, if there is a miscellaneous XDR error@@ -2727,8 +2736,8 @@ encode\_op: status = op->status; } - trace\_nfsd\_compound\_status(args->opcnt, resp->opcnt, status,- nfsd4\_op\_name(op->opnum));+ trace\_nfsd\_compound\_status(args->client\_opcnt, resp->opcnt,+ status, nfsd4\_op\_name(op->opnum));  nfsd4\_cstate\_clear\_replay(cstate); nfsd4\_increment\_op\_stats(op->opnum);@@ -2762,28 +2771,49 @@ out:  #define op\_encode\_channel\_attrs\_maxsz (6 + 1 + 1) -static inline u32 nfsd4\_only\_status\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op)+/\*+ \* The \_rsize() helpers are invoked by the NFSv4 COMPOUND decoder, which+ \* is called before sunrpc sets rq\_res.buflen. Thus we have to compute+ \* the maximum payload size here, based on transport limits and the size+ \* of the remaining space in the rq\_pages array.+ \*/+static u32 nfsd4\_max\_payload(const struct svc\_rqst \*rqstp)+{+ u32 buflen;++ buflen = (rqstp->rq\_page\_end - rqstp->rq\_next\_page) \* PAGE\_SIZE;+ buflen -= rqstp->rq\_auth\_slack;+ buflen -= rqstp->rq\_res.head[0].iov\_len;+ return min\_t(u32, buflen, svc\_max\_payload(rqstp));+}++static u32 nfsd4\_only\_status\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { return (op\_encode\_hdr\_size) \* sizeof(\_\_be32); } -static inline u32 nfsd4\_status\_stateid\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op)+static u32 nfsd4\_status\_stateid\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { return (op\_encode\_hdr\_size + op\_encode\_stateid\_maxsz)\* sizeof(\_\_be32); } -static inline u32 nfsd4\_access\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op)+static u32 nfsd4\_access\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { /\* ac\_supported, ac\_resp\_access \*/ return (op\_encode\_hdr\_size + 2)\* sizeof(\_\_be32); } -static inline u32 nfsd4\_commit\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op)+static u32 nfsd4\_commit\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { return (op\_encode\_hdr\_size + op\_encode\_verifier\_maxsz) \* sizeof(\_\_be32); } -static inline u32 nfsd4\_create\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op)+static u32 nfsd4\_create\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { return (op\_encode\_hdr\_size + op\_encode\_change\_info\_maxsz + nfs4\_fattr\_bitmap\_maxsz) \* sizeof(\_\_be32);@@ -2794,17 +2824,17 @@ static inline u32 nfsd4\_create\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op \* the op prematurely if the estimate is too large. We may turn off splice \* reads unnecessarily. \*/-static inline u32 nfsd4\_getattr\_rsize(struct svc\_rqst \*rqstp,- struct nfsd4\_op \*op)+static u32 nfsd4\_getattr\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) {- u32 \*bmap = op->u.getattr.ga\_bmval;+ const u32 \*bmap = op->u.getattr.ga\_bmval; u32 bmap0 = bmap[0], bmap1 = bmap[1], bmap2 = bmap[2]; u32 ret = 0;  if (bmap0 & FATTR4\_WORD0\_ACL)- return svc\_max\_payload(rqstp);+ return nfsd4\_max\_payload(rqstp); if (bmap0 & FATTR4\_WORD0\_FS\_LOCATIONS)- return svc\_max\_payload(rqstp);+ return nfsd4\_max\_payload(rqstp);  if (bmap1 & FATTR4\_WORD1\_OWNER) { ret += IDMAP\_NAMESZ + 4;@@ -2832,24 +2862,28 @@ static inline u32 nfsd4\_getattr\_rsize(struct svc\_rqst \*rqstp, return ret; } -static inline u32 nfsd4\_getfh\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op)+static u32 nfsd4\_getfh\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { return (op\_encode\_hdr\_size + 1) \* sizeof(\_\_be32) + NFS4\_FHSIZE; } -static inline u32 nfsd4\_link\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op)+static u32 nfsd4\_link\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { return (op\_encode\_hdr\_size + op\_encode\_change\_info\_maxsz) \* sizeof(\_\_be32); } -static inline u32 nfsd4\_lock\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op)+static u32 nfsd4\_lock\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { return (op\_encode\_hdr\_size + op\_encode\_lock\_denied\_maxsz) \* sizeof(\_\_be32); } -static inline u32 nfsd4\_open\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op)+static u32 nfsd4\_open\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { return (op\_encode\_hdr\_size + op\_encode\_stateid\_maxsz + op\_encode\_change\_info\_maxsz + 1@@ -2857,20 +2891,18 @@ static inline u32 nfsd4\_open\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op) + op\_encode\_delegation\_maxsz) \* sizeof(\_\_be32); } -static inline u32 nfsd4\_read\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op)+static u32 nfsd4\_read\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) {- u32 maxcount = 0, rlen = 0;-- maxcount = svc\_max\_payload(rqstp);- rlen = min(op->u.read.rd\_length, maxcount);+ u32 rlen = min(op->u.read.rd\_length, nfsd4\_max\_payload(rqstp));  return (op\_encode\_hdr\_size + 2 + XDR\_QUADLEN(rlen)) \* sizeof(\_\_be32); } -static inline u32 nfsd4\_read\_plus\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op)+static u32 nfsd4\_read\_plus\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) {- u32 maxcount = svc\_max\_payload(rqstp);- u32 rlen = min(op->u.read.rd\_length, maxcount);+ u32 rlen = min(op->u.read.rd\_length, nfsd4\_max\_payload(rqstp)); /\* \* If we detect that the file changed during hole encoding, then we \* recover by encoding the remaining reply as data. This means we need@@ -2881,70 +2913,77 @@ static inline u32 nfsd4\_read\_plus\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op return (op\_encode\_hdr\_size + 2 + seg\_len + XDR\_QUADLEN(rlen)) \* sizeof(\_\_be32); } -static inline u32 nfsd4\_readdir\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op)+static u32 nfsd4\_readdir\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) {- u32 maxcount = 0, rlen = 0;-- maxcount = svc\_max\_payload(rqstp);- rlen = min(op->u.readdir.rd\_maxcount, maxcount);+ u32 rlen = min(op->u.readdir.rd\_maxcount, nfsd4\_max\_payload(rqstp));  return (op\_encode\_hdr\_size + op\_encode\_verifier\_maxsz + XDR\_QUADLEN(rlen)) \* sizeof(\_\_be32); } -static inline u32 nfsd4\_readlink\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op)+static u32 nfsd4\_readlink\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { return (op\_encode\_hdr\_size + 1) \* sizeof(\_\_be32) + PAGE\_SIZE; } -static inline u32 nfsd4\_remove\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op)+static u32 nfsd4\_remove\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { return (op\_encode\_hdr\_size + op\_encode\_change\_info\_maxsz) \* sizeof(\_\_be32); } -static inline u32 nfsd4\_rename\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op)+static u32 nfsd4\_rename\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { return (op\_encode\_hdr\_size + op\_encode\_change\_info\_maxsz + op\_encode\_change\_info\_maxsz) \* sizeof(\_\_be32); } -static inline u32 nfsd4\_sequence\_rsize(struct svc\_rqst \*rqstp,- struct nfsd4\_op \*op)+static u32 nfsd4\_sequence\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { return (op\_encode\_hdr\_size + XDR\_QUADLEN(NFS4\_MAX\_SESSIONID\_LEN) + 5) \* sizeof(\_\_be32); } -static inline u32 nfsd4\_test\_stateid\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op)+static u32 nfsd4\_test\_stateid\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { return (op\_encode\_hdr\_size + 1 + op->u.test\_stateid.ts\_num\_ids) \* sizeof(\_\_be32); } -static inline u32 nfsd4\_setattr\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op)+static u32 nfsd4\_setattr\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { return (op\_encode\_hdr\_size + nfs4\_fattr\_bitmap\_maxsz) \* sizeof(\_\_be32); } -static inline u32 nfsd4\_secinfo\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op)+static u32 nfsd4\_secinfo\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { return (op\_encode\_hdr\_size + RPC\_AUTH\_MAXFLAVOR \* (4 + XDR\_QUADLEN(GSS\_OID\_MAX\_LEN))) \* sizeof(\_\_be32); } -static inline u32 nfsd4\_setclientid\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op)+static u32 nfsd4\_setclientid\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { return (op\_encode\_hdr\_size + 2 + XDR\_QUADLEN(NFS4\_VERIFIER\_SIZE)) \* sizeof(\_\_be32); } -static inline u32 nfsd4\_write\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op)+static u32 nfsd4\_write\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { return (op\_encode\_hdr\_size + 2 + op\_encode\_verifier\_maxsz) \* sizeof(\_\_be32); } -static inline u32 nfsd4\_exchange\_id\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op)+static u32 nfsd4\_exchange\_id\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { return (op\_encode\_hdr\_size + 2 + 1 + /\* eir\_clientid, eir\_sequenceid \*/\ 1 + 1 + /\* eir\_flags, spr\_how \*/\@@ -2958,14 +2997,16 @@ static inline u32 nfsd4\_exchange\_id\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_o 0 /\* ignored eir\_server\_impl\_id contents \*/) \* sizeof(\_\_be32); } -static inline u32 nfsd4\_bind\_conn\_to\_session\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op)+static u32 nfsd4\_bind\_conn\_to\_session\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { return (op\_encode\_hdr\_size + \ XDR\_QUADLEN(NFS4\_MAX\_SESSIONID\_LEN) + /\* bctsr\_sessid \*/\ 2 /\* bctsr\_dir, use\_conn\_in\_rdma\_mode \*/) \* sizeof(\_\_be32); } -static inline u32 nfsd4\_create\_session\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op)+static u32 nfsd4\_create\_session\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { return (op\_encode\_hdr\_size + \ XDR\_QUADLEN(NFS4\_MAX\_SESSIONID\_LEN) + /\* sessionid \*/\@@ -2974,7 +3015,8 @@ static inline u32 nfsd4\_create\_session\_rsize(struct svc\_rqst \*rqstp, struct nfsd op\_encode\_channel\_attrs\_maxsz) \* sizeof(\_\_be32); } -static inline u32 nfsd4\_copy\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op)+static u32 nfsd4\_copy\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { return (op\_encode\_hdr\_size + 1 /\* wr\_callback \*/ +@@ -2986,16 +3028,16 @@ static inline u32 nfsd4\_copy\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op) 1 /\* cr\_synchronous \*/) \* sizeof(\_\_be32); } -static inline u32 nfsd4\_offload\_status\_rsize(struct svc\_rqst \*rqstp,- struct nfsd4\_op \*op)+static u32 nfsd4\_offload\_status\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { return (op\_encode\_hdr\_size + 2 /\* osr\_count \*/ + 1 /\* osr\_complete<1> optional 0 for now \*/) \* sizeof(\_\_be32); } -static inline u32 nfsd4\_copy\_notify\_rsize(struct svc\_rqst \*rqstp,- struct nfsd4\_op \*op)+static u32 nfsd4\_copy\_notify\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { return (op\_encode\_hdr\_size + 3 /\* cnr\_lease\_time \*/ +@@ -3010,12 +3052,10 @@ static inline u32 nfsd4\_copy\_notify\_rsize(struct svc\_rqst \*rqstp, }  #ifdef CONFIG\_NFSD\_PNFS-static inline u32 nfsd4\_getdeviceinfo\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op)+static u32 nfsd4\_getdeviceinfo\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) {- u32 maxcount = 0, rlen = 0;-- maxcount = svc\_max\_payload(rqstp);- rlen = min(op->u.getdeviceinfo.gd\_maxcount, maxcount);+ u32 rlen = min(op->u.getdeviceinfo.gd\_maxcount, nfsd4\_max\_payload(rqstp));  return (op\_encode\_hdr\_size + 1 /\* gd\_layout\_type\*/ +@@ -3028,7 +3068,8 @@ static inline u32 nfsd4\_getdeviceinfo\_rsize(struct svc\_rqst \*rqstp, struct nfsd4 \* so we need to define an arbitrary upper bound here. \*/ #define MAX\_LAYOUT\_SIZE 128-static inline u32 nfsd4\_layoutget\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op)+static u32 nfsd4\_layoutget\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { return (op\_encode\_hdr\_size + 1 /\* logr\_return\_on\_close \*/ +@@ -3037,14 +3078,16 @@ static inline u32 nfsd4\_layoutget\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op MAX\_LAYOUT\_SIZE) \* sizeof(\_\_be32); } -static inline u32 nfsd4\_layoutcommit\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op)+static u32 nfsd4\_layoutcommit\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { return (op\_encode\_hdr\_size + 1 /\* locr\_newsize \*/ + 2 /\* ns\_size \*/) \* sizeof(\_\_be32); } -static inline u32 nfsd4\_layoutreturn\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op)+static u32 nfsd4\_layoutreturn\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { return (op\_encode\_hdr\_size + 1 /\* lrs\_stateid \*/ +@@ -3053,41 +3096,36 @@ static inline u32 nfsd4\_layoutreturn\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_ #endif /\* CONFIG\_NFSD\_PNFS \*/  -static inline u32 nfsd4\_seek\_rsize(struct svc\_rqst \*rqstp, struct nfsd4\_op \*op)+static u32 nfsd4\_seek\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { return (op\_encode\_hdr\_size + 3) \* sizeof(\_\_be32); } -static inline u32 nfsd4\_getxattr\_rsize(struct svc\_rqst \*rqstp,- struct nfsd4\_op \*op)+static u32 nfsd4\_getxattr\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) {- u32 maxcount, rlen;-- maxcount = svc\_max\_payload(rqstp);- rlen = min\_t(u32, XATTR\_SIZE\_MAX, maxcount);+ u32 rlen = min\_t(u32, XATTR\_SIZE\_MAX, nfsd4\_max\_payload(rqstp));  return (op\_encode\_hdr\_size + 1 + XDR\_QUADLEN(rlen)) \* sizeof(\_\_be32); } -static inline u32 nfsd4\_setxattr\_rsize(struct svc\_rqst \*rqstp,- struct nfsd4\_op \*op)+static u32 nfsd4\_setxattr\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { return (op\_encode\_hdr\_size + op\_encode\_change\_info\_maxsz) \* sizeof(\_\_be32); }-static inline u32 nfsd4\_listxattrs\_rsize(struct svc\_rqst \*rqstp,- struct nfsd4\_op \*op)+static u32 nfsd4\_listxattrs\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) {- u32 maxcount, rlen;-- maxcount = svc\_max\_payload(rqstp);- rlen = min(op->u.listxattrs.lsxa\_maxcount, maxcount);+ u32 rlen = min(op->u.listxattrs.lsxa\_maxcount, nfsd4\_max\_payload(rqstp));  return (op\_encode\_hdr\_size + 4 + XDR\_QUADLEN(rlen)) \* sizeof(\_\_be32); } -static inline u32 nfsd4\_removexattr\_rsize(struct svc\_rqst \*rqstp,- struct nfsd4\_op \*op)+static u32 nfsd4\_removexattr\_rsize(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op) { return (op\_encode\_hdr\_size + op\_encode\_change\_info\_maxsz) \* sizeof(\_\_be32);@@ -3576,6 +3614,7 @@ static const struct svc\_procedure nfsd\_procedures4[2] = { .pc\_decode = nfssvc\_decode\_voidarg, .pc\_encode = nfssvc\_encode\_voidres, .pc\_argsize = sizeof(struct nfsd\_voidargs),+ .pc\_argzero = sizeof(struct nfsd\_voidargs), .pc\_ressize = sizeof(struct nfsd\_voidres), .pc\_cachetype = RC\_NOCACHE, .pc\_xdrressize = 1,@@ -3586,6 +3625,7 @@ static const struct svc\_procedure nfsd\_procedures4[2] = { .pc\_decode = nfs4svc\_decode\_compoundargs, .pc\_encode = nfs4svc\_encode\_compoundres, .pc\_argsize = sizeof(struct nfsd4\_compoundargs),+ .pc\_argzero = offsetof(struct nfsd4\_compoundargs, iops), .pc\_ressize = sizeof(struct nfsd4\_compoundres), .pc\_release = nfsd4\_release\_compoundargs, .pc\_cachetype = RC\_NOCACHE,diff --git a/fs/nfsd/nfs4recover.c b/fs/nfsd/nfs4recover.cindex c634483d85d2a3..5d680045fa2c7f 100644--- a/[fs/nfsd/nfs4recover.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs4recover.c?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/nfsd/nfs4recover.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs4recover.c?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -807,16 +807,18 @@ \_\_cld\_pipe\_inprogress\_downcall(const struct cld\_msg\_v2 \_\_user \*cmsg, if (get\_user(namelen, &ci->cc\_name.cn\_len)) return -EFAULT; name.data = memdup\_user(&ci->cc\_name.cn\_id, namelen);- if (IS\_ERR\_OR\_NULL(name.data))- return -EFAULT;+ if (IS\_ERR(name.data))+ return PTR\_ERR(name.data); name.len = namelen; get\_user(princhashlen, &ci->cc\_princhash.cp\_len); if (princhashlen > 0) { princhash.data = memdup\_user( &ci->cc\_princhash.cp\_data, princhashlen);- if (IS\_ERR\_OR\_NULL(princhash.data))- return -EFAULT;+ if (IS\_ERR(princhash.data)) {+ kfree(name.data);+ return PTR\_ERR(princhash.data);+ } princhash.len = princhashlen; } else princhash.len = 0;@@ -827,8 +829,8 @@ \_\_cld\_pipe\_inprogress\_downcall(const struct cld\_msg\_v2 \_\_user \*cmsg, if (get\_user(namelen, &cnm->cn\_len)) return -EFAULT; name.data = memdup\_user(&cnm->cn\_id, namelen);- if (IS\_ERR\_OR\_NULL(name.data))- return -EFAULT;+ if (IS\_ERR(name.data))+ return PTR\_ERR(name.data); name.len = namelen; } if (name.len > 5 && memcmp(name.data, "hash:", 5) == 0) {diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.cindex c5d199d7e6b4e2..198d7abf34e451 100644--- a/[fs/nfsd/nfs4state.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs4state.c?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/nfsd/nfs4state.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs4state.c?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -160,6 +160,13 @@ static bool is\_client\_expired(struct nfs4\_client \*clp) return clp->cl\_time == 0; } +static void nfsd4\_dec\_courtesy\_client\_count(struct nfsd\_net \*nn,+ struct nfs4\_client \*clp)+{+ if (clp->cl\_state != NFSD4\_ACTIVE)+ atomic\_add\_unless(&nn->nfsd\_courtesy\_clients, -1, 0);+}+ static \_\_be32 get\_client\_locked(struct nfs4\_client \*clp) { struct nfsd\_net \*nn = net\_generic(clp->net, nfsd\_net\_id);@@ -169,6 +176,7 @@ static \_\_be32 get\_client\_locked(struct nfs4\_client \*clp) if (is\_client\_expired(clp)) return nfserr\_expired; atomic\_inc(&clp->cl\_rpc\_users);+ nfsd4\_dec\_courtesy\_client\_count(nn, clp); clp->cl\_state = NFSD4\_ACTIVE; return nfs\_ok; }@@ -190,6 +198,7 @@ renew\_client\_locked(struct nfs4\_client \*clp)  list\_move\_tail(&clp->cl\_lru, &nn->client\_lru); clp->cl\_time = ktime\_get\_boottime\_seconds();+ nfsd4\_dec\_courtesy\_client\_count(nn, clp); clp->cl\_state = NFSD4\_ACTIVE; } @@ -357,6 +366,8 @@ nfsd4\_cb\_notify\_lock\_prepare(struct nfsd4\_callback \*cb) static int nfsd4\_cb\_notify\_lock\_done(struct nfsd4\_callback \*cb, struct rpc\_task \*task) {+ trace\_nfsd\_cb\_notify\_lock\_done(&zero\_stateid, task);+ /\* \* Since this is just an optimization, we don't try very hard if it \* turns out not to succeed. We'll requeue it on NFS4ERR\_DELAY, and@@ -963,19 +974,19 @@ out\_free: \* Create a unique stateid\_t to represent each COPY. \*/ static int nfs4\_init\_cp\_state(struct nfsd\_net \*nn, copy\_stateid\_t \*stid,- unsigned char sc\_type)+ unsigned char cs\_type) { int new\_id; - stid->stid.si\_opaque.so\_clid.cl\_boot = (u32)nn->boot\_time;- stid->stid.si\_opaque.so\_clid.cl\_id = nn->s2s\_cp\_cl\_id;- stid->sc\_type = sc\_type;+ stid->cs\_stid.si\_opaque.so\_clid.cl\_boot = (u32)nn->boot\_time;+ stid->cs\_stid.si\_opaque.so\_clid.cl\_id = nn->s2s\_cp\_cl\_id;+ stid->cs\_type = cs\_type;  idr\_preload(GFP\_KERNEL); spin\_lock(&nn->s2s\_cp\_lock); new\_id = idr\_alloc\_cyclic(&nn->s2s\_cp\_stateids, stid, 0, 0, GFP\_NOWAIT);- stid->stid.si\_opaque.so\_id = new\_id;- stid->stid.si\_generation = 1;+ stid->cs\_stid.si\_opaque.so\_id = new\_id;+ stid->cs\_stid.si\_generation = 1; spin\_unlock(&nn->s2s\_cp\_lock); idr\_preload\_end(); if (new\_id < 0)@@ -997,7 +1008,7 @@ struct nfs4\_cpntf\_state \*nfs4\_alloc\_init\_cpntf\_state(struct nfsd\_net \*nn, if (!cps) return NULL; cps->cpntf\_time = ktime\_get\_boottime\_seconds();- refcount\_set(&cps->cp\_stateid.sc\_count, 1);+ refcount\_set(&cps->cp\_stateid.cs\_count, 1); if (!nfs4\_init\_cp\_state(nn, &cps->cp\_stateid, NFS4\_COPYNOTIFY\_STID)) goto out\_free; spin\_lock(&nn->s2s\_cp\_lock);@@ -1013,11 +1024,11 @@ void nfs4\_free\_copy\_state(struct nfsd4\_copy \*copy) { struct nfsd\_net \*nn; - WARN\_ON\_ONCE(copy->cp\_stateid.sc\_type != NFS4\_COPY\_STID);+ WARN\_ON\_ONCE(copy->cp\_stateid.cs\_type != NFS4\_COPY\_STID); nn = net\_generic(copy->cp\_clp->net, nfsd\_net\_id); spin\_lock(&nn->s2s\_cp\_lock); idr\_remove(&nn->s2s\_cp\_stateids,- copy->cp\_stateid.stid.si\_opaque.so\_id);+ copy->cp\_stateid.cs\_stid.si\_opaque.so\_id); spin\_unlock(&nn->s2s\_cp\_lock); } @@ -1049,6 +1060,12 @@ static struct nfs4\_ol\_stateid \* nfs4\_alloc\_open\_stateid(struct nfs4\_client \*clp)  static void nfs4\_free\_deleg(struct nfs4\_stid \*stid) {+ struct nfs4\_delegation \*dp = delegstateid(stid);++ WARN\_ON\_ONCE(!list\_empty(&stid->sc\_cp\_list));+ WARN\_ON\_ONCE(!list\_empty(&dp->dl\_perfile));+ WARN\_ON\_ONCE(!list\_empty(&dp->dl\_perclnt));+ WARN\_ON\_ONCE(!list\_empty(&dp->dl\_recall\_lru)); kmem\_cache\_free(deleg\_slab, stid); atomic\_long\_dec(&num\_delegations); }@@ -1462,6 +1479,7 @@ static void nfs4\_free\_ol\_stateid(struct nfs4\_stid \*stid) release\_all\_access(stp); if (stp->st\_stateowner) nfs4\_put\_stateowner(stp->st\_stateowner);+ WARN\_ON(!list\_empty(&stid->sc\_cp\_list)); kmem\_cache\_free(stateid\_slab, stid); } @@ -2233,6 +2251,7 @@ \_\_destroy\_client(struct nfs4\_client \*clp) if (clp->cl\_cb\_conn.cb\_xprt) svc\_xprt\_put(clp->cl\_cb\_conn.cb\_xprt); atomic\_add\_unless(&nn->nfs4\_client\_count, -1, 0);+ nfsd4\_dec\_courtesy\_client\_count(nn, clp); free\_client(clp); wake\_up\_all(&expiry\_wq); }@@ -2478,7 +2497,7 @@ static const char \*cb\_state2str(int state)  static int client\_info\_show(struct seq\_file \*m, void \*v) {- struct inode \*inode = m->private;+ struct inode \*inode = file\_inode(m->file); struct nfs4\_client \*clp; u64 clid; @@ -2518,17 +2537,7 @@ static int client\_info\_show(struct seq\_file \*m, void \*v) return 0; } -static int client\_info\_open(struct inode \*inode, struct file \*file)-{- return single\_open(file, client\_info\_show, inode);-}--static const struct file\_operations client\_info\_fops = {- .open = client\_info\_open,- .read = seq\_read,- .llseek = seq\_lseek,- .release = single\_release,-};+DEFINE\_SHOW\_ATTRIBUTE(client\_info);  static void \*states\_start(struct seq\_file \*s, loff\_t \*pos) \_\_acquires(&clp->cl\_lock)@@ -4337,7 +4346,27 @@ out: return -ENOMEM; } -void nfsd4\_init\_leases\_net(struct nfsd\_net \*nn)+static unsigned long+nfsd\_courtesy\_client\_count(struct shrinker \*shrink, struct shrink\_control \*sc)+{+ int cnt;+ struct nfsd\_net \*nn = container\_of(shrink,+ struct nfsd\_net, nfsd\_client\_shrinker);++ cnt = atomic\_read(&nn->nfsd\_courtesy\_clients);+ if (cnt > 0)+ mod\_delayed\_work(laundry\_wq, &nn->nfsd\_shrinker\_work, 0);+ return (unsigned long)cnt;+}++static unsigned long+nfsd\_courtesy\_client\_scan(struct shrinker \*shrink, struct shrink\_control \*sc)+{+ return SHRINK\_STOP;+}++int+nfsd4\_init\_leases\_net(struct nfsd\_net \*nn) { struct sysinfo si; u64 max\_clients;@@ -4356,6 +4385,18 @@ void nfsd4\_init\_leases\_net(struct nfsd\_net \*nn) max\_clients = (u64)si.totalram \* si.mem\_unit / (1024 \* 1024 \* 1024); max\_clients \*= NFS4\_CLIENTS\_PER\_GB; nn->nfs4\_max\_clients = max\_t(int, max\_clients, NFS4\_CLIENTS\_PER\_GB);++ atomic\_set(&nn->nfsd\_courtesy\_clients, 0);+ nn->nfsd\_client\_shrinker.scan\_objects = nfsd\_courtesy\_client\_scan;+ nn->nfsd\_client\_shrinker.count\_objects = nfsd\_courtesy\_client\_count;+ nn->nfsd\_client\_shrinker.seeks = DEFAULT\_SEEKS;+ return register\_shrinker(&nn->nfsd\_client\_shrinker, "nfsd-client");+}++void+nfsd4\_leases\_net\_shutdown(struct nfsd\_net \*nn)+{+ unregister\_shrinker(&nn->nfsd\_client\_shrinker); }  static void init\_nfs4\_replay(struct nfs4\_replay \*rp)@@ -4715,6 +4756,35 @@ nfs4\_share\_conflict(struct svc\_fh \*current\_fh, unsigned int deny\_type) return ret; } +static bool nfsd4\_deleg\_present(const struct inode \*inode)+{+ struct file\_lock\_context \*ctx = smp\_load\_acquire(&inode->i\_flctx);++ return ctx && !list\_empty\_careful(&ctx->flc\_lease);+}++/\*\*+ \* nfsd\_wait\_for\_delegreturn - wait for delegations to be returned+ \* @rqstp: the RPC transaction being executed+ \* @inode: in-core inode of the file being waited for+ \*+ \* The timeout prevents deadlock if all nfsd threads happen to be+ \* tied up waiting for returning delegations.+ \*+ \* Return values:+ \* %true: delegation was returned+ \* %false: timed out waiting for delegreturn+ \*/+bool nfsd\_wait\_for\_delegreturn(struct svc\_rqst \*rqstp, struct inode \*inode)+{+ long \_\_maybe\_unused timeo;++ timeo = wait\_var\_event\_timeout(inode, !nfsd4\_deleg\_present(inode),+ NFSD\_DELEGRETURN\_TIMEOUT);+ trace\_nfsd\_delegret\_wakeup(rqstp, inode, timeo);+ return timeo > 0;+}+ static void nfsd4\_cb\_recall\_prepare(struct nfsd4\_callback \*cb) { struct nfs4\_delegation \*dp = cb\_to\_delegation(cb);@@ -4743,6 +4813,8 @@ static int nfsd4\_cb\_recall\_done(struct nfsd4\_callback \*cb, { struct nfs4\_delegation \*dp = cb\_to\_delegation(cb); + trace\_nfsd\_cb\_recall\_done(&dp->dl\_stid.sc\_stateid, task);+ if (dp->dl\_stid.sc\_type == NFS4\_CLOSED\_DELEG\_STID || dp->dl\_stid.sc\_type == NFS4\_REVOKED\_DELEG\_STID) return 1;@@ -4788,18 +4860,17 @@ static void nfsd\_break\_one\_deleg(struct nfs4\_delegation \*dp) \* We're assuming the state code never drops its reference \* without first removing the lease. Since we're in this lease \* callback (and since the lease code is serialized by the- \* i\_lock) we know the server hasn't removed the lease yet, and+ \* flc\_lock) we know the server hasn't removed the lease yet, and \* we know it's safe to take a reference. \*/ refcount\_inc(&dp->dl\_stid.sc\_count);- nfsd4\_run\_cb(&dp->dl\_recall);+ WARN\_ON\_ONCE(!nfsd4\_run\_cb(&dp->dl\_recall)); } -/\* Called from break\_lease() with i\_lock held. \*/+/\* Called from break\_lease() with flc\_lock held. \*/ static bool nfsd\_break\_deleg\_cb(struct file\_lock \*fl) {- bool ret = false; struct nfs4\_delegation \*dp = (struct nfs4\_delegation \*)fl->fl\_owner; struct nfs4\_file \*fp = dp->dl\_stid.sc\_file; struct nfs4\_client \*clp = dp->dl\_stid.sc\_client;@@ -4825,7 +4896,7 @@ nfsd\_break\_deleg\_cb(struct file\_lock \*fl) fp->fi\_had\_conflict = true; nfsd\_break\_one\_deleg(dp); spin\_unlock(&fp->fi\_lock);- return ret;+ return false; }  /\*\*@@ -5878,8 +5949,11 @@ nfs4\_get\_client\_reaplist(struct nfsd\_net \*nn, struct list\_head \*reaplist, goto exp\_client; if (!state\_expired(lt, clp->cl\_time)) break;- if (!atomic\_read(&clp->cl\_rpc\_users))+ if (!atomic\_read(&clp->cl\_rpc\_users)) {+ if (clp->cl\_state == NFSD4\_ACTIVE)+ atomic\_inc(&nn->nfsd\_courtesy\_clients); clp->cl\_state = NFSD4\_COURTESY;+ } if (!client\_has\_state(clp)) goto exp\_client; if (!nfs4\_anylock\_blockers(clp))@@ -5894,10 +5968,49 @@ exp\_client: spin\_unlock(&nn->client\_lock); } +static void+nfs4\_get\_courtesy\_client\_reaplist(struct nfsd\_net \*nn,+ struct list\_head \*reaplist)+{+ unsigned int maxreap = 0, reapcnt = 0;+ struct list\_head \*pos, \*next;+ struct nfs4\_client \*clp;++ maxreap = NFSD\_CLIENT\_MAX\_TRIM\_PER\_RUN;+ INIT\_LIST\_HEAD(reaplist);++ spin\_lock(&nn->client\_lock);+ list\_for\_each\_safe(pos, next, &nn->client\_lru) {+ clp = list\_entry(pos, struct nfs4\_client, cl\_lru);+ if (clp->cl\_state == NFSD4\_ACTIVE)+ break;+ if (reapcnt >= maxreap)+ break;+ if (!mark\_client\_expired\_locked(clp)) {+ list\_add(&clp->cl\_lru, reaplist);+ reapcnt++;+ }+ }+ spin\_unlock(&nn->client\_lock);+}++static void+nfs4\_process\_client\_reaplist(struct list\_head \*reaplist)+{+ struct list\_head \*pos, \*next;+ struct nfs4\_client \*clp;++ list\_for\_each\_safe(pos, next, reaplist) {+ clp = list\_entry(pos, struct nfs4\_client, cl\_lru);+ trace\_nfsd\_clid\_purged(&clp->cl\_clientid);+ list\_del\_init(&clp->cl\_lru);+ expire\_client(clp);+ }+}+ static time64\_t nfs4\_laundromat(struct nfsd\_net \*nn) {- struct nfs4\_client \*clp; struct nfs4\_openowner \*oo; struct nfs4\_delegation \*dp; struct nfs4\_ol\_stateid \*stp;@@ -5920,18 +6033,14 @@ nfs4\_laundromat(struct nfsd\_net \*nn) spin\_lock(&nn->s2s\_cp\_lock); idr\_for\_each\_entry(&nn->s2s\_cp\_stateids, cps\_t, i) { cps = container\_of(cps\_t, struct nfs4\_cpntf\_state, cp\_stateid);- if (cps->cp\_stateid.sc\_type == NFS4\_COPYNOTIFY\_STID &&+ if (cps->cp\_stateid.cs\_type == NFS4\_COPYNOTIFY\_STID && state\_expired(&lt, cps->cpntf\_time)) \_free\_cpntf\_state\_locked(nn, cps); } spin\_unlock(&nn->s2s\_cp\_lock); nfs4\_get\_client\_reaplist(nn, &reaplist, &lt);- list\_for\_each\_safe(pos, next, &reaplist) {- clp = list\_entry(pos, struct nfs4\_client, cl\_lru);- trace\_nfsd\_clid\_purged(&clp->cl\_clientid);- list\_del\_init(&clp->cl\_lru);- expire\_client(clp);- }+ nfs4\_process\_client\_reaplist(&reaplist);+ spin\_lock(&state\_lock); list\_for\_each\_safe(pos, next, &nn->del\_recall\_lru) { dp = list\_entry (pos, struct nfs4\_delegation, dl\_recall\_lru);@@ -6014,6 +6123,18 @@ laundromat\_main(struct work\_struct \*laundry) queue\_delayed\_work(laundry\_wq, &nn->laundromat\_work, t\*HZ); } +static void+courtesy\_client\_reaper(struct work\_struct \*reaper)+{+ struct list\_head reaplist;+ struct delayed\_work \*dwork = to\_delayed\_work(reaper);+ struct nfsd\_net \*nn = container\_of(dwork, struct nfsd\_net,+ nfsd\_shrinker\_work);++ nfs4\_get\_courtesy\_client\_reaplist(nn, &reaplist);+ nfs4\_process\_client\_reaplist(&reaplist);+}+ static inline \_\_be32 nfs4\_check\_fh(struct svc\_fh \*fhp, struct nfs4\_stid \*stp) { if (!fh\_match(&fhp->fh\_handle, &stp->sc\_file->fi\_fhandle))@@ -6149,6 +6270,7 @@ nfsd4\_lookup\_stateid(struct nfsd4\_compound\_state \*cstate, struct nfs4\_stid \*\*s, struct nfsd\_net \*nn) { \_\_be32 status;+ struct nfs4\_stid \*stid; bool return\_revoked = false;  /\*@@ -6171,15 +6293,16 @@ nfsd4\_lookup\_stateid(struct nfsd4\_compound\_state \*cstate, } if (status) return status;- \*s = find\_stateid\_by\_type(cstate->clp, stateid, typemask);- if (!\*s)+ stid = find\_stateid\_by\_type(cstate->clp, stateid, typemask);+ if (!stid) return nfserr\_bad\_stateid;- if (((\*s)->sc\_type == NFS4\_REVOKED\_DELEG\_STID) && !return\_revoked) {- nfs4\_put\_stid(\*s);+ if ((stid->sc\_type == NFS4\_REVOKED\_DELEG\_STID) && !return\_revoked) {+ nfs4\_put\_stid(stid); if (cstate->minorversion) return nfserr\_deleg\_revoked; return nfserr\_bad\_stateid; }+ \*s = stid; return nfs\_ok; } @@ -6244,12 +6367,12 @@ out: static void \_free\_cpntf\_state\_locked(struct nfsd\_net \*nn, struct nfs4\_cpntf\_state \*cps) {- WARN\_ON\_ONCE(cps->cp\_stateid.sc\_type != NFS4\_COPYNOTIFY\_STID);- if (!refcount\_dec\_and\_test(&cps->cp\_stateid.sc\_count))+ WARN\_ON\_ONCE(cps->cp\_stateid.cs\_type != NFS4\_COPYNOTIFY\_STID);+ if (!refcount\_dec\_and\_test(&cps->cp\_stateid.cs\_count)) return; list\_del(&cps->cp\_list); idr\_remove(&nn->s2s\_cp\_stateids,- cps->cp\_stateid.stid.si\_opaque.so\_id);+ cps->cp\_stateid.cs\_stid.si\_opaque.so\_id); kfree(cps); } /\*@@ -6271,12 +6394,12 @@ \_\_be32 manage\_cpntf\_state(struct nfsd\_net \*nn, stateid\_t \*st, if (cps\_t) { state = container\_of(cps\_t, struct nfs4\_cpntf\_state, cp\_stateid);- if (state->cp\_stateid.sc\_type != NFS4\_COPYNOTIFY\_STID) {+ if (state->cp\_stateid.cs\_type != NFS4\_COPYNOTIFY\_STID) { state = NULL; goto unlock; } if (!clp)- refcount\_inc(&state->cp\_stateid.sc\_count);+ refcount\_inc(&state->cp\_stateid.cs\_count); else \_free\_cpntf\_state\_locked(nn, state); }@@ -6684,6 +6807,7 @@ static void nfsd4\_close\_open\_stateid(struct nfs4\_ol\_stateid \*s) struct nfs4\_client \*clp = s->st\_stid.sc\_client; bool unhashed; LIST\_HEAD(reaplist);+ struct nfs4\_ol\_stateid \*stp;  spin\_lock(&clp->cl\_lock); unhashed = unhash\_open\_stateid(s, &reaplist);@@ -6692,6 +6816,8 @@ static void nfsd4\_close\_open\_stateid(struct nfs4\_ol\_stateid \*s) if (unhashed) put\_ol\_stateid\_locked(s, &reaplist); spin\_unlock(&clp->cl\_lock);+ list\_for\_each\_entry(stp, &reaplist, st\_locks)+ nfs4\_free\_cpntf\_statelist(clp->net, &stp->st\_stid); free\_ol\_stateid\_reaplist(&reaplist); } else { spin\_unlock(&clp->cl\_lock);@@ -6775,6 +6901,7 @@ nfsd4\_delegreturn(struct svc\_rqst \*rqstp, struct nfsd4\_compound\_state \*cstate, if (status) goto put\_stateid; + wake\_up\_var(d\_inode(cstate->current\_fh.fh\_dentry)); destroy\_delegation(dp); put\_stateid: nfs4\_put\_stid(&dp->dl\_stid);@@ -7830,6 +7957,7 @@ static int nfs4\_state\_create\_net(struct net \*net) INIT\_LIST\_HEAD(&nn->blocked\_locks\_lru);  INIT\_DELAYED\_WORK(&nn->laundromat\_work, laundromat\_main);+ INIT\_DELAYED\_WORK(&nn->nfsd\_shrinker\_work, courtesy\_client\_reaper); get\_net(net);  return 0;diff --git a/fs/nfsd/nfs4xdr.c b/fs/nfsd/nfs4xdr.cindex 1e9690a061eca2..bcfeb1a922c0d3 100644--- a/[fs/nfsd/nfs4xdr.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs4xdr.c?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/nfsd/nfs4xdr.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfs4xdr.c?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -42,6 +42,8 @@ #include <linux/sunrpc/svcauth\_gss.h> #include <linux/sunrpc/addr.h> #include <linux/xattr.h>+#include <linux/vmalloc.h>+ #include <uapi/linux/xattr.h>  #include "idmap.h"@@ -791,6 +793,7 @@ nfsd4\_decode\_commit(struct nfsd4\_compoundargs \*argp, struct nfsd4\_commit \*commit return nfserr\_bad\_xdr; if (xdr\_stream\_decode\_u32(argp->xdr, &commit->co\_count) < 0) return nfserr\_bad\_xdr;+ memset(&commit->co\_verf, 0, sizeof(commit->co\_verf)); return nfs\_ok; } @@ -799,6 +802,7 @@ nfsd4\_decode\_create(struct nfsd4\_compoundargs \*argp, struct nfsd4\_create \*create { \_\_be32 \*p, status; + memset(create, 0, sizeof(\*create)); if (xdr\_stream\_decode\_u32(argp->xdr, &create->cr\_type) < 0) return nfserr\_bad\_xdr; switch (create->cr\_type) {@@ -848,6 +852,7 @@ nfsd4\_decode\_delegreturn(struct nfsd4\_compoundargs \*argp, struct nfsd4\_delegretu static inline \_\_be32 nfsd4\_decode\_getattr(struct nfsd4\_compoundargs \*argp, struct nfsd4\_getattr \*getattr) {+ memset(getattr, 0, sizeof(\*getattr)); return nfsd4\_decode\_bitmap4(argp, getattr->ga\_bmval, ARRAY\_SIZE(getattr->ga\_bmval)); }@@ -855,6 +860,7 @@ nfsd4\_decode\_getattr(struct nfsd4\_compoundargs \*argp, struct nfsd4\_getattr \*geta static \_\_be32 nfsd4\_decode\_link(struct nfsd4\_compoundargs \*argp, struct nfsd4\_link \*link) {+ memset(link, 0, sizeof(\*link)); return nfsd4\_decode\_component4(argp, &link->li\_name, &link->li\_namelen); } @@ -903,6 +909,7 @@ nfsd4\_decode\_locker4(struct nfsd4\_compoundargs \*argp, struct nfsd4\_lock \*lock) static \_\_be32 nfsd4\_decode\_lock(struct nfsd4\_compoundargs \*argp, struct nfsd4\_lock \*lock) {+ memset(lock, 0, sizeof(\*lock)); if (xdr\_stream\_decode\_u32(argp->xdr, &lock->lk\_type) < 0) return nfserr\_bad\_xdr; if ((lock->lk\_type < NFS4\_READ\_LT) || (lock->lk\_type > NFS4\_WRITEW\_LT))@@ -919,6 +926,7 @@ nfsd4\_decode\_lock(struct nfsd4\_compoundargs \*argp, struct nfsd4\_lock \*lock) static \_\_be32 nfsd4\_decode\_lockt(struct nfsd4\_compoundargs \*argp, struct nfsd4\_lockt \*lockt) {+ memset(lockt, 0, sizeof(\*lockt)); if (xdr\_stream\_decode\_u32(argp->xdr, &lockt->lt\_type) < 0) return nfserr\_bad\_xdr; if ((lockt->lt\_type < NFS4\_READ\_LT) || (lockt->lt\_type > NFS4\_WRITEW\_LT))@@ -1140,11 +1148,8 @@ nfsd4\_decode\_open(struct nfsd4\_compoundargs \*argp, struct nfsd4\_open \*open) \_\_be32 status; u32 dummy; - memset(open->op\_bmval, 0, sizeof(open->op\_bmval));- open->op\_iattr.ia\_valid = 0;- open->op\_openowner = NULL;+ memset(open, 0, sizeof(\*open)); - open->op\_xdr\_error = 0; if (xdr\_stream\_decode\_u32(argp->xdr, &open->op\_seqid) < 0) return nfserr\_bad\_xdr; /\* deleg\_want is ignored \*/@@ -1179,6 +1184,8 @@ nfsd4\_decode\_open\_confirm(struct nfsd4\_compoundargs \*argp, struct nfsd4\_open\_con if (xdr\_stream\_decode\_u32(argp->xdr, &open\_conf->oc\_seqid) < 0) return nfserr\_bad\_xdr; + memset(&open\_conf->oc\_resp\_stateid, 0,+ sizeof(open\_conf->oc\_resp\_stateid)); return nfs\_ok; } @@ -1187,6 +1194,7 @@ nfsd4\_decode\_open\_downgrade(struct nfsd4\_compoundargs \*argp, struct nfsd4\_open\_d { \_\_be32 status; + memset(open\_down, 0, sizeof(\*open\_down)); status = nfsd4\_decode\_stateid4(argp, &open\_down->od\_stateid); if (status) return status;@@ -1216,6 +1224,7 @@ nfsd4\_decode\_putfh(struct nfsd4\_compoundargs \*argp, struct nfsd4\_putfh \*putfh) if (!putfh->pf\_fhval) return nfserr\_jukebox; + putfh->no\_verify = false; return nfs\_ok; } @@ -1232,6 +1241,7 @@ nfsd4\_decode\_read(struct nfsd4\_compoundargs \*argp, struct nfsd4\_read \*read) { \_\_be32 status; + memset(read, 0, sizeof(\*read)); status = nfsd4\_decode\_stateid4(argp, &read->rd\_stateid); if (status) return status;@@ -1248,6 +1258,7 @@ nfsd4\_decode\_readdir(struct nfsd4\_compoundargs \*argp, struct nfsd4\_readdir \*read { \_\_be32 status; + memset(readdir, 0, sizeof(\*readdir)); if (xdr\_stream\_decode\_u64(argp->xdr, &readdir->rd\_cookie) < 0) return nfserr\_bad\_xdr; status = nfsd4\_decode\_verifier4(argp, &readdir->rd\_verf);@@ -1267,6 +1278,7 @@ nfsd4\_decode\_readdir(struct nfsd4\_compoundargs \*argp, struct nfsd4\_readdir \*read static \_\_be32 nfsd4\_decode\_remove(struct nfsd4\_compoundargs \*argp, struct nfsd4\_remove \*remove) {+ memset(&remove->rm\_cinfo, 0, sizeof(remove->rm\_cinfo)); return nfsd4\_decode\_component4(argp, &remove->rm\_name, &remove->rm\_namelen); } @@ -1275,6 +1287,7 @@ nfsd4\_decode\_rename(struct nfsd4\_compoundargs \*argp, struct nfsd4\_rename \*rename { \_\_be32 status; + memset(rename, 0, sizeof(\*rename)); status = nfsd4\_decode\_component4(argp, &rename->rn\_sname, &rename->rn\_snamelen); if (status) return status;@@ -1291,6 +1304,7 @@ static \_\_be32 nfsd4\_decode\_secinfo(struct nfsd4\_compoundargs \*argp, struct nfsd4\_secinfo \*secinfo) {+ secinfo->si\_exp = NULL; return nfsd4\_decode\_component4(argp, &secinfo->si\_name, &secinfo->si\_namelen); } @@ -1299,6 +1313,7 @@ nfsd4\_decode\_setattr(struct nfsd4\_compoundargs \*argp, struct nfsd4\_setattr \*seta { \_\_be32 status; + memset(setattr, 0, sizeof(\*setattr)); status = nfsd4\_decode\_stateid4(argp, &setattr->sa\_stateid); if (status) return status;@@ -1313,6 +1328,8 @@ nfsd4\_decode\_setclientid(struct nfsd4\_compoundargs \*argp, struct nfsd4\_setclient { \_\_be32 \*p, status; + memset(setclientid, 0, sizeof(\*setclientid));+ if (argp->minorversion >= 1) return nfserr\_notsupp; @@ -1369,6 +1386,8 @@ nfsd4\_decode\_verify(struct nfsd4\_compoundargs \*argp, struct nfsd4\_verify \*verify { \_\_be32 \*p, status; + memset(verify, 0, sizeof(\*verify));+ status = nfsd4\_decode\_bitmap4(argp, verify->ve\_bmval, ARRAY\_SIZE(verify->ve\_bmval)); if (status)@@ -1408,6 +1427,9 @@ nfsd4\_decode\_write(struct nfsd4\_compoundargs \*argp, struct nfsd4\_write \*write) if (!xdr\_stream\_subsegment(argp->xdr, &write->wr\_payload, write->wr\_buflen)) return nfserr\_bad\_xdr; + write->wr\_bytes\_written = 0;+ write->wr\_how\_written = 0;+ memset(&write->wr\_verifier, 0, sizeof(write->wr\_verifier)); return nfs\_ok; } @@ -1432,6 +1454,7 @@ nfsd4\_decode\_release\_lockowner(struct nfsd4\_compoundargs \*argp, struct nfsd4\_rel  static \_\_be32 nfsd4\_decode\_backchannel\_ctl(struct nfsd4\_compoundargs \*argp, struct nfsd4\_backchannel\_ctl \*bc) {+ memset(bc, 0, sizeof(\*bc)); if (xdr\_stream\_decode\_u32(argp->xdr, &bc->bc\_cb\_program) < 0) return nfserr\_bad\_xdr; return nfsd4\_decode\_cb\_sec(argp, &bc->bc\_cb\_sec);@@ -1442,6 +1465,7 @@ static \_\_be32 nfsd4\_decode\_bind\_conn\_to\_session(struct nfsd4\_compoundargs \*argp, u32 use\_conn\_in\_rdma\_mode; \_\_be32 status; + memset(bcts, 0, sizeof(\*bcts)); status = nfsd4\_decode\_sessionid4(argp, &bcts->sessionid); if (status) return status;@@ -1583,6 +1607,7 @@ nfsd4\_decode\_exchange\_id(struct nfsd4\_compoundargs \*argp, { \_\_be32 status; + memset(exid, 0, sizeof(\*exid)); status = nfsd4\_decode\_verifier4(argp, &exid->verifier); if (status) return status;@@ -1635,6 +1660,7 @@ nfsd4\_decode\_create\_session(struct nfsd4\_compoundargs \*argp, { \_\_be32 status; + memset(sess, 0, sizeof(\*sess)); status = nfsd4\_decode\_clientid4(argp, &sess->clientid); if (status) return status;@@ -1650,11 +1676,7 @@ nfsd4\_decode\_create\_session(struct nfsd4\_compoundargs \*argp, return status; if (xdr\_stream\_decode\_u32(argp->xdr, &sess->callback\_prog) < 0) return nfserr\_bad\_xdr;- status = nfsd4\_decode\_cb\_sec(argp, &sess->cb\_sec);- if (status)- return status;-- return nfs\_ok;+ return nfsd4\_decode\_cb\_sec(argp, &sess->cb\_sec); }  static \_\_be32@@ -1678,6 +1700,7 @@ nfsd4\_decode\_getdeviceinfo(struct nfsd4\_compoundargs \*argp, { \_\_be32 status; + memset(gdev, 0, sizeof(\*gdev)); status = nfsd4\_decode\_deviceid4(argp, &gdev->gd\_devid); if (status) return status;@@ -1698,6 +1721,7 @@ nfsd4\_decode\_layoutcommit(struct nfsd4\_compoundargs \*argp, { \_\_be32 \*p, status; + memset(lcp, 0, sizeof(\*lcp)); if (xdr\_stream\_decode\_u64(argp->xdr, &lcp->lc\_seg.offset) < 0) return nfserr\_bad\_xdr; if (xdr\_stream\_decode\_u64(argp->xdr, &lcp->lc\_seg.length) < 0)@@ -1733,6 +1757,7 @@ nfsd4\_decode\_layoutget(struct nfsd4\_compoundargs \*argp, { \_\_be32 status; + memset(lgp, 0, sizeof(\*lgp)); if (xdr\_stream\_decode\_u32(argp->xdr, &lgp->lg\_signal) < 0) return nfserr\_bad\_xdr; if (xdr\_stream\_decode\_u32(argp->xdr, &lgp->lg\_layout\_type) < 0)@@ -1758,6 +1783,7 @@ static \_\_be32 nfsd4\_decode\_layoutreturn(struct nfsd4\_compoundargs \*argp, struct nfsd4\_layoutreturn \*lrp) {+ memset(lrp, 0, sizeof(\*lrp)); if (xdr\_stream\_decode\_bool(argp->xdr, &lrp->lr\_reclaim) < 0) return nfserr\_bad\_xdr; if (xdr\_stream\_decode\_u32(argp->xdr, &lrp->lr\_layout\_type) < 0)@@ -1773,6 +1799,8 @@ static \_\_be32 nfsd4\_decode\_secinfo\_no\_name(struct nfsd4\_compoundargs \*argp, { if (xdr\_stream\_decode\_u32(argp->xdr, &sin->sin\_style) < 0) return nfserr\_bad\_xdr;++ sin->sin\_exp = NULL; return nfs\_ok; } @@ -1793,6 +1821,7 @@ nfsd4\_decode\_sequence(struct nfsd4\_compoundargs \*argp, seq->maxslots = be32\_to\_cpup(p++); seq->cachethis = be32\_to\_cpup(p); + seq->status\_flags = 0; return nfs\_ok; } @@ -1803,6 +1832,7 @@ nfsd4\_decode\_test\_stateid(struct nfsd4\_compoundargs \*argp, struct nfsd4\_test\_sta \_\_be32 status; u32 i; + memset(test\_stateid, 0, sizeof(\*test\_stateid)); if (xdr\_stream\_decode\_u32(argp->xdr, &test\_stateid->ts\_num\_ids) < 0) return nfserr\_bad\_xdr; @@ -1900,6 +1930,7 @@ nfsd4\_decode\_copy(struct nfsd4\_compoundargs \*argp, struct nfsd4\_copy \*copy) struct nl4\_server \*ns\_dummy; \_\_be32 status; + memset(copy, 0, sizeof(\*copy)); status = nfsd4\_decode\_stateid4(argp, &copy->cp\_src\_stateid); if (status) return status;@@ -1955,6 +1986,7 @@ nfsd4\_decode\_copy\_notify(struct nfsd4\_compoundargs \*argp, { \_\_be32 status; + memset(cn, 0, sizeof(\*cn)); cn->cpn\_src = svcxdr\_tmpalloc(argp, sizeof(\*cn->cpn\_src)); if (cn->cpn\_src == NULL) return nfserr\_jukebox;@@ -1972,6 +2004,8 @@ static \_\_be32 nfsd4\_decode\_offload\_status(struct nfsd4\_compoundargs \*argp, struct nfsd4\_offload\_status \*os) {+ os->count = 0;+ os->status = 0; return nfsd4\_decode\_stateid4(argp, &os->stateid); } @@ -1988,6 +2022,8 @@ nfsd4\_decode\_seek(struct nfsd4\_compoundargs \*argp, struct nfsd4\_seek \*seek) if (xdr\_stream\_decode\_u32(argp->xdr, &seek->seek\_whence) < 0) return nfserr\_bad\_xdr; + seek->seek\_eof = 0;+ seek->seek\_pos = 0; return nfs\_ok; } @@ -2123,6 +2159,7 @@ nfsd4\_decode\_getxattr(struct nfsd4\_compoundargs \*argp, \_\_be32 status; u32 maxcount; + memset(getxattr, 0, sizeof(\*getxattr)); status = nfsd4\_decode\_xattr\_name(argp, &getxattr->getxa\_name); if (status) return status;@@ -2131,8 +2168,7 @@ nfsd4\_decode\_getxattr(struct nfsd4\_compoundargs \*argp, maxcount = min\_t(u32, XATTR\_SIZE\_MAX, maxcount);  getxattr->getxa\_len = maxcount;-- return status;+ return nfs\_ok; }  static \_\_be32@@ -2142,6 +2178,8 @@ nfsd4\_decode\_setxattr(struct nfsd4\_compoundargs \*argp, u32 flags, maxcount, size; \_\_be32 status; + memset(setxattr, 0, sizeof(\*setxattr));+ if (xdr\_stream\_decode\_u32(argp->xdr, &flags) < 0) return nfserr\_bad\_xdr; @@ -2180,6 +2218,8 @@ nfsd4\_decode\_listxattrs(struct nfsd4\_compoundargs \*argp, { u32 maxcount; + memset(listxattrs, 0, sizeof(\*listxattrs));+ if (xdr\_stream\_decode\_u64(argp->xdr, &listxattrs->lsxa\_cookie) < 0) return nfserr\_bad\_xdr; @@ -2207,6 +2247,7 @@ static \_\_be32 nfsd4\_decode\_removexattr(struct nfsd4\_compoundargs \*argp, struct nfsd4\_removexattr \*removexattr) {+ memset(removexattr, 0, sizeof(\*removexattr)); return nfsd4\_decode\_xattr\_name(argp, &removexattr->rmxa\_name); } @@ -2357,22 +2398,15 @@ nfsd4\_decode\_compound(struct nfsd4\_compoundargs \*argp)  if (xdr\_stream\_decode\_u32(argp->xdr, &argp->minorversion) < 0) return false;- if (xdr\_stream\_decode\_u32(argp->xdr, &argp->opcnt) < 0)+ if (xdr\_stream\_decode\_u32(argp->xdr, &argp->client\_opcnt) < 0) return false;-- /\*- \* NFS4ERR\_RESOURCE is a more helpful error than GARBAGE\_ARGS- \* here, so we return success at the xdr level so that- \* nfsd4\_proc can handle this is an NFS-level error.- \*/- if (argp->opcnt > NFSD\_MAX\_OPS\_PER\_COMPOUND)- return true;+ argp->opcnt = min\_t(u32, argp->client\_opcnt,+ NFSD\_MAX\_OPS\_PER\_COMPOUND);  if (argp->opcnt > ARRAY\_SIZE(argp->iops)) {- argp->ops = kzalloc(argp->opcnt \* sizeof(\*argp->ops), GFP\_KERNEL);+ argp->ops = vcalloc(argp->opcnt, sizeof(\*argp->ops)); if (!argp->ops) { argp->ops = argp->iops;- dprintk("nfsd: couldn't allocate room for COMPOUND\n"); return false; } }@@ -2774,9 +2808,10 @@ static \_\_be32 fattr\_handle\_absent\_fs(u32 \*bmval0, u32 \*bmval1, u32 \*bmval2, u32 }  -static int get\_parent\_attributes(struct svc\_export \*exp, struct kstat \*stat)+static int nfsd4\_get\_mounted\_on\_ino(struct svc\_export \*exp, u64 \*pino) { struct path path = exp->ex\_path;+ struct kstat stat; int err;  path\_get(&path);@@ -2784,8 +2819,10 @@ static int get\_parent\_attributes(struct svc\_export \*exp, struct kstat \*stat) if (path.dentry != path.mnt->mnt\_root) break; }- err = vfs\_getattr(&path, stat, STATX\_BASIC\_STATS, AT\_STATX\_SYNC\_AS\_STAT);+ err = vfs\_getattr(&path, &stat, STATX\_INO, AT\_STATX\_SYNC\_AS\_STAT); path\_put(&path);+ if (!err)+ \*pino = stat.ino; return err; } @@ -3282,22 +3319,21 @@ out\_acl: \*p++ = cpu\_to\_be32(stat.btime.tv\_nsec); } if (bmval1 & FATTR4\_WORD1\_MOUNTED\_ON\_FILEID) {- struct kstat parent\_stat; u64 ino = stat.ino;  p = xdr\_reserve\_space(xdr, 8); if (!p) goto out\_resource; /\*- \* Get parent's attributes if not ignoring crossmount- \* and this is the root of a cross-mounted filesystem.+ \* Get ino of mountpoint in parent filesystem, if not ignoring+ \* crossmount and this is the root of a cross-mounted+ \* filesystem. \*/ if (ignore\_crossmnt == 0 && dentry == exp->ex\_path.mnt->mnt\_root) {- err = get\_parent\_attributes(exp, &parent\_stat);+ err = nfsd4\_get\_mounted\_on\_ino(exp, &ino); if (err) goto out\_nfserr;- ino = parent\_stat.ino; } p = xdr\_encode\_hyper(p, ino); }@@ -3994,7 +4030,7 @@ nfsd4\_encode\_read(struct nfsd4\_compoundres \*resp, \_\_be32 nfserr, } if (resp->xdr->buf->page\_len && splice\_ok) { WARN\_ON\_ONCE(1);- return nfserr\_resource;+ return nfserr\_serverfault; } xdr\_commit\_encode(xdr); @@ -5394,7 +5430,7 @@ void nfsd4\_release\_compoundargs(struct svc\_rqst \*rqstp) struct nfsd4\_compoundargs \*args = rqstp->rq\_argp;  if (args->ops != args->iops) {- kfree(args->ops);+ vfree(args->ops); args->ops = args->iops; } while (args->to\_free) {@@ -5423,12 +5459,8 @@ bool nfs4svc\_encode\_compoundres(struct svc\_rqst \*rqstp, struct xdr\_stream \*xdr) { struct nfsd4\_compoundres \*resp = rqstp->rq\_resp;- struct xdr\_buf \*buf = xdr->buf; \_\_be32 \*p; - WARN\_ON\_ONCE(buf->len != buf->head[0].iov\_len + buf->page\_len +- buf->tail[0].iov\_len);- /\* \* Send buffer space for the following items is reserved \* at the top of nfsd4\_proc\_compound().diff --git a/fs/nfsd/nfscache.c b/fs/nfsd/nfscache.cindex 9b31e1103e7b1d..3e64a3d50a1c52 100644--- a/[fs/nfsd/nfscache.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfscache.c?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/nfsd/nfscache.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfscache.c?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -604,9 +604,10 @@ nfsd\_cache\_append(struct svc\_rqst \*rqstp, struct kvec \*data) \* scraping this file for info should test the labels to ensure they're \* getting the correct field. \*/-static int nfsd\_reply\_cache\_stats\_show(struct seq\_file \*m, void \*v)+int nfsd\_reply\_cache\_stats\_show(struct seq\_file \*m, void \*v) {- struct nfsd\_net \*nn = m->private;+ struct nfsd\_net \*nn = net\_generic(file\_inode(m->file)->i\_sb->s\_fs\_info,+ nfsd\_net\_id);  seq\_printf(m, "max entries: %u\n", nn->max\_drc\_entries); seq\_printf(m, "num entries: %u\n",@@ -626,11 +627,3 @@ static int nfsd\_reply\_cache\_stats\_show(struct seq\_file \*m, void \*v) seq\_printf(m, "cachesize at longest: %u\n", nn->longest\_chain\_cachesize); return 0; }--int nfsd\_reply\_cache\_stats\_open(struct inode \*inode, struct file \*file)-{- struct nfsd\_net \*nn = net\_generic(file\_inode(file)->i\_sb->s\_fs\_info,- nfsd\_net\_id);-- return single\_open(file, nfsd\_reply\_cache\_stats\_show, nn);-}diff --git a/fs/nfsd/nfsctl.c b/fs/nfsd/nfsctl.cindex 917fa1892fd2d5..6a29bcfc93909d 100644--- a/[fs/nfsd/nfsctl.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfsctl.c?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/nfsd/nfsctl.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfsctl.c?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -185,17 +185,7 @@ static int export\_features\_show(struct seq\_file \*m, void \*v) return 0; } -static int export\_features\_open(struct inode \*inode, struct file \*file)-{- return single\_open(file, export\_features\_show, NULL);-}--static const struct file\_operations export\_features\_operations = {- .open = export\_features\_open,- .read = seq\_read,- .llseek = seq\_lseek,- .release = single\_release,-};+DEFINE\_SHOW\_ATTRIBUTE(export\_features);  #if defined(CONFIG\_SUNRPC\_GSS) || defined(CONFIG\_SUNRPC\_GSS\_MODULE) static int supported\_enctypes\_show(struct seq\_file \*m, void \*v)@@ -204,17 +194,7 @@ static int supported\_enctypes\_show(struct seq\_file \*m, void \*v) return 0; } -static int supported\_enctypes\_open(struct inode \*inode, struct file \*file)-{- return single\_open(file, supported\_enctypes\_show, NULL);-}--static const struct file\_operations supported\_enctypes\_ops = {- .open = supported\_enctypes\_open,- .read = seq\_read,- .llseek = seq\_lseek,- .release = single\_release,-};+DEFINE\_SHOW\_ATTRIBUTE(supported\_enctypes); #endif /\* CONFIG\_SUNRPC\_GSS or CONFIG\_SUNRPC\_GSS\_MODULE \*/  static const struct file\_operations pool\_stats\_operations = {@@ -224,19 +204,9 @@ static const struct file\_operations pool\_stats\_operations = { .release = nfsd\_pool\_stats\_release, }; -static const struct file\_operations reply\_cache\_stats\_operations = {- .open = nfsd\_reply\_cache\_stats\_open,- .read = seq\_read,- .llseek = seq\_lseek,- .release = single\_release,-};+DEFINE\_SHOW\_ATTRIBUTE(nfsd\_reply\_cache\_stats); -static const struct file\_operations filecache\_ops = {- .open = nfsd\_file\_cache\_stats\_open,- .read = seq\_read,- .llseek = seq\_lseek,- .release = single\_release,-};+DEFINE\_SHOW\_ATTRIBUTE(nfsd\_file\_cache\_stats);  /\*----------------------------------------------------------------------------\*/ /\*@@ -1365,7 +1335,7 @@ static int nfsd\_fill\_super(struct super\_block \*sb, struct fs\_context \*fc) /\* Per-export io stats use same ops as exports file \*/ [NFSD\_Export\_Stats] = {"export\_stats", &exports\_nfsd\_operations, S\_IRUGO}, [NFSD\_Export\_features] = {"export\_features",- &export\_features\_operations, S\_IRUGO},+ &export\_features\_fops, S\_IRUGO}, [NFSD\_FO\_UnlockIP] = {"unlock\_ip", &transaction\_ops, S\_IWUSR|S\_IRUSR}, [NFSD\_FO\_UnlockFS] = {"unlock\_filesystem",@@ -1374,14 +1344,16 @@ static int nfsd\_fill\_super(struct super\_block \*sb, struct fs\_context \*fc) [NFSD\_Threads] = {"threads", &transaction\_ops, S\_IWUSR|S\_IRUSR}, [NFSD\_Pool\_Threads] = {"pool\_threads", &transaction\_ops, S\_IWUSR|S\_IRUSR}, [NFSD\_Pool\_Stats] = {"pool\_stats", &pool\_stats\_operations, S\_IRUGO},- [NFSD\_Reply\_Cache\_Stats] = {"reply\_cache\_stats", &reply\_cache\_stats\_operations, S\_IRUGO},+ [NFSD\_Reply\_Cache\_Stats] = {"reply\_cache\_stats",+ &nfsd\_reply\_cache\_stats\_fops, S\_IRUGO}, [NFSD\_Versions] = {"versions", &transaction\_ops, S\_IWUSR|S\_IRUSR}, [NFSD\_Ports] = {"portlist", &transaction\_ops, S\_IWUSR|S\_IRUGO}, [NFSD\_MaxBlkSize] = {"max\_block\_size", &transaction\_ops, S\_IWUSR|S\_IRUGO}, [NFSD\_MaxConnections] = {"max\_connections", &transaction\_ops, S\_IWUSR|S\_IRUGO},- [NFSD\_Filecache] = {"filecache", &filecache\_ops, S\_IRUGO},+ [NFSD\_Filecache] = {"filecache", &nfsd\_file\_cache\_stats\_fops, S\_IRUGO}, #if defined(CONFIG\_SUNRPC\_GSS) || defined(CONFIG\_SUNRPC\_GSS\_MODULE)- [NFSD\_SupportedEnctypes] = {"supported\_krb5\_enctypes", &supported\_enctypes\_ops, S\_IRUGO},+ [NFSD\_SupportedEnctypes] = {"supported\_krb5\_enctypes",+ &supported\_enctypes\_fops, S\_IRUGO}, #endif /\* CONFIG\_SUNRPC\_GSS or CONFIG\_SUNRPC\_GSS\_MODULE \*/ #ifdef CONFIG\_NFSD\_V4 [NFSD\_Leasetime] = {"nfsv4leasetime", &transaction\_ops, S\_IWUSR|S\_IRUSR},@@ -1481,11 +1453,12 @@ static \_\_net\_init int nfsd\_init\_net(struct net \*net) goto out\_idmap\_error; nn->nfsd\_versions = NULL; nn->nfsd4\_minorversions = NULL;+ retval = nfsd4\_init\_leases\_net(nn);+ if (retval)+ goto out\_drc\_error; retval = nfsd\_reply\_cache\_init(nn); if (retval) goto out\_drc\_error;- nfsd4\_init\_leases\_net(nn);- get\_random\_bytes(&nn->siphash\_key, sizeof(nn->siphash\_key)); seqlock\_init(&nn->writeverf\_lock); @@ -1507,6 +1480,7 @@ static \_\_net\_exit void nfsd\_exit\_net(struct net \*net) nfsd\_idmap\_shutdown(net); nfsd\_export\_shutdown(net); nfsd\_netns\_free\_versions(net\_generic(net, nfsd\_net\_id));+ nfsd4\_leases\_net\_shutdown(nn); }  static struct pernet\_operations nfsd\_net\_ops = {diff --git a/fs/nfsd/nfsd.h b/fs/nfsd/nfsd.hindex 57a468ed85c358..09726c5b9a317b 100644--- a/[fs/nfsd/nfsd.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfsd.h?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/nfsd/nfsd.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfsd.h?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -164,6 +164,7 @@ char \* nfs4\_recoverydir(void); bool nfsd4\_spo\_must\_allow(struct svc\_rqst \*rqstp); int nfsd4\_create\_laundry\_wq(void); void nfsd4\_destroy\_laundry\_wq(void);+bool nfsd\_wait\_for\_delegreturn(struct svc\_rqst \*rqstp, struct inode \*inode); #else static inline int nfsd4\_init\_slabs(void) { return 0; } static inline void nfsd4\_free\_slabs(void) { }@@ -179,6 +180,11 @@ static inline bool nfsd4\_spo\_must\_allow(struct svc\_rqst \*rqstp) } static inline int nfsd4\_create\_laundry\_wq(void) { return 0; }; static inline void nfsd4\_destroy\_laundry\_wq(void) {};+static inline bool nfsd\_wait\_for\_delegreturn(struct svc\_rqst \*rqstp,+ struct inode \*inode)+{+ return false;+} #endif  /\*@@ -343,6 +349,7 @@ void nfsd\_lockd\_shutdown(void); #define NFSD\_COURTESY\_CLIENT\_TIMEOUT (24 \* 60 \* 60) /\* seconds \*/ #define NFSD\_CLIENT\_MAX\_TRIM\_PER\_RUN 128 #define NFS4\_CLIENTS\_PER\_GB 1024+#define NFSD\_DELEGRETURN\_TIMEOUT (HZ / 34) /\* 30ms \*/  /\* \* The following attributes are currently not supported by the NFSv4 server:@@ -498,7 +505,8 @@ extern void unregister\_cld\_notifier(void); extern void nfsd4\_ssc\_init\_umount\_work(struct nfsd\_net \*nn); #endif -extern void nfsd4\_init\_leases\_net(struct nfsd\_net \*nn);+extern int nfsd4\_init\_leases\_net(struct nfsd\_net \*nn);+extern void nfsd4\_leases\_net\_shutdown(struct nfsd\_net \*nn);  #else /\* CONFIG\_NFSD\_V4 \*/ static inline int nfsd4\_is\_junction(struct dentry \*dentry)@@ -506,7 +514,8 @@ static inline int nfsd4\_is\_junction(struct dentry \*dentry) return 0; } -static inline void nfsd4\_init\_leases\_net(struct nfsd\_net \*nn) {};+static inline int nfsd4\_init\_leases\_net(struct nfsd\_net \*nn) { return 0; };+static inline void nfsd4\_leases\_net\_shutdown(struct nfsd\_net \*nn) {};  #define register\_cld\_notifier() 0 #define unregister\_cld\_notifier() do { } while(0)diff --git a/fs/nfsd/nfsfh.c b/fs/nfsd/nfsfh.cindex a5b71526cee0fa..d73434200df989 100644--- a/[fs/nfsd/nfsfh.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfsfh.c?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/nfsd/nfsfh.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfsfh.c?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -392,13 +392,7 @@ fh\_verify(struct svc\_rqst \*rqstp, struct svc\_fh \*fhp, umode\_t type, int access) skip\_pseudoflavor\_check: /\* Finally, check access permissions. \*/ error = nfsd\_permission(rqstp, exp, dentry, access);-- if (error) {- dprintk("fh\_verify: %pd2 permission failure, "- "acc=%x, error=%d\n",- dentry,- access, ntohl(error));- }+ trace\_nfsd\_fh\_verify\_err(rqstp, fhp, type, access, error); out: if (error == nfserr\_stale) nfsd\_stats\_fh\_stale\_inc(exp);diff --git a/fs/nfsd/nfsproc.c b/fs/nfsd/nfsproc.cindex 7381972f167749..82b3ddeacc338a 100644--- a/[fs/nfsd/nfsproc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfsproc.c?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/nfsd/nfsproc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfsproc.c?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -185,6 +185,7 @@ nfsd\_proc\_read(struct svc\_rqst \*rqstp) argp->count, argp->offset);  argp->count = min\_t(u32, argp->count, NFSSVC\_MAXBLKSIZE\_V2);+ argp->count = min\_t(u32, argp->count, rqstp->rq\_res.buflen);  v = 0; len = argp->count;@@ -390,9 +391,8 @@ nfsd\_proc\_create(struct svc\_rqst \*rqstp) resp->status = nfs\_ok; if (!inode) { /\* File doesn't exist. Create it and set attrs \*/- resp->status = nfsd\_create\_locked(rqstp, dirfhp, argp->name,- argp->len, &attrs, type, rdev,- newfhp);+ resp->status = nfsd\_create\_locked(rqstp, dirfhp, &attrs, type,+ rdev, newfhp); } else if (type == S\_IFREG) { dprintk("nfsd: existing %s, valid=%x, size=%ld\n", argp->name, attr->ia\_valid, (long) attr->ia\_size);@@ -567,24 +567,15 @@ static void nfsd\_init\_dirlist\_pages(struct svc\_rqst \*rqstp, struct xdr\_buf \*buf = &resp->dirlist; struct xdr\_stream \*xdr = &resp->xdr; - count = clamp(count, (u32)(XDR\_UNIT \* 2), svc\_max\_payload(rqstp));- memset(buf, 0, sizeof(\*buf));  /\* Reserve room for the NULL ptr & eof flag (-2 words) \*/- buf->buflen = count - XDR\_UNIT \* 2;+ buf->buflen = clamp(count, (u32)(XDR\_UNIT \* 2), (u32)PAGE\_SIZE);+ buf->buflen -= XDR\_UNIT \* 2; buf->pages = rqstp->rq\_next\_page; rqstp->rq\_next\_page++; - /\* This is xdr\_init\_encode(), but it assumes that- \* the head kvec has already been consumed. \*/- xdr\_set\_scratch\_buffer(xdr, NULL, 0);- xdr->buf = buf;- xdr->page\_ptr = buf->pages;- xdr->iov = NULL;- xdr->p = page\_address(\*buf->pages);- xdr->end = (void \*)xdr->p + min\_t(u32, buf->buflen, PAGE\_SIZE);- xdr->rqst = NULL;+ xdr\_init\_encode\_pages(xdr, buf, buf->pages, NULL); }  /\*@@ -646,6 +637,7 @@ static const struct svc\_procedure nfsd\_procedures2[18] = { .pc\_decode = nfssvc\_decode\_voidarg, .pc\_encode = nfssvc\_encode\_voidres, .pc\_argsize = sizeof(struct nfsd\_voidargs),+ .pc\_argzero = sizeof(struct nfsd\_voidargs), .pc\_ressize = sizeof(struct nfsd\_voidres), .pc\_cachetype = RC\_NOCACHE, .pc\_xdrressize = 0,@@ -657,6 +649,7 @@ static const struct svc\_procedure nfsd\_procedures2[18] = { .pc\_encode = nfssvc\_encode\_attrstatres, .pc\_release = nfssvc\_release\_attrstat, .pc\_argsize = sizeof(struct nfsd\_fhandle),+ .pc\_argzero = sizeof(struct nfsd\_fhandle), .pc\_ressize = sizeof(struct nfsd\_attrstat), .pc\_cachetype = RC\_NOCACHE, .pc\_xdrressize = ST+AT,@@ -668,6 +661,7 @@ static const struct svc\_procedure nfsd\_procedures2[18] = { .pc\_encode = nfssvc\_encode\_attrstatres, .pc\_release = nfssvc\_release\_attrstat, .pc\_argsize = sizeof(struct nfsd\_sattrargs),+ .pc\_argzero = sizeof(struct nfsd\_sattrargs), .pc\_ressize = sizeof(struct nfsd\_attrstat), .pc\_cachetype = RC\_REPLBUFF, .pc\_xdrressize = ST+AT,@@ -678,6 +672,7 @@ static const struct svc\_procedure nfsd\_procedures2[18] = { .pc\_decode = nfssvc\_decode\_voidarg, .pc\_encode = nfssvc\_encode\_voidres, .pc\_argsize = sizeof(struct nfsd\_voidargs),+ .pc\_argzero = sizeof(struct nfsd\_voidargs), .pc\_ressize = sizeof(struct nfsd\_voidres), .pc\_cachetype = RC\_NOCACHE, .pc\_xdrressize = 0,@@ -689,6 +684,7 @@ static const struct svc\_procedure nfsd\_procedures2[18] = { .pc\_encode = nfssvc\_encode\_diropres, .pc\_release = nfssvc\_release\_diropres, .pc\_argsize = sizeof(struct nfsd\_diropargs),+ .pc\_argzero = sizeof(struct nfsd\_diropargs), .pc\_ressize = sizeof(struct nfsd\_diropres), .pc\_cachetype = RC\_NOCACHE, .pc\_xdrressize = ST+FH+AT,@@ -699,6 +695,7 @@ static const struct svc\_procedure nfsd\_procedures2[18] = { .pc\_decode = nfssvc\_decode\_fhandleargs, .pc\_encode = nfssvc\_encode\_readlinkres, .pc\_argsize = sizeof(struct nfsd\_fhandle),+ .pc\_argzero = sizeof(struct nfsd\_fhandle), .pc\_ressize = sizeof(struct nfsd\_readlinkres), .pc\_cachetype = RC\_NOCACHE, .pc\_xdrressize = ST+1+NFS\_MAXPATHLEN/4,@@ -710,6 +707,7 @@ static const struct svc\_procedure nfsd\_procedures2[18] = { .pc\_encode = nfssvc\_encode\_readres, .pc\_release = nfssvc\_release\_readres, .pc\_argsize = sizeof(struct nfsd\_readargs),+ .pc\_argzero = sizeof(struct nfsd\_readargs), .pc\_ressize = sizeof(struct nfsd\_readres), .pc\_cachetype = RC\_NOCACHE, .pc\_xdrressize = ST+AT+1+NFSSVC\_MAXBLKSIZE\_V2/4,@@ -720,6 +718,7 @@ static const struct svc\_procedure nfsd\_procedures2[18] = { .pc\_decode = nfssvc\_decode\_voidarg, .pc\_encode = nfssvc\_encode\_voidres, .pc\_argsize = sizeof(struct nfsd\_voidargs),+ .pc\_argzero = sizeof(struct nfsd\_voidargs), .pc\_ressize = sizeof(struct nfsd\_voidres), .pc\_cachetype = RC\_NOCACHE, .pc\_xdrressize = 0,@@ -731,6 +730,7 @@ static const struct svc\_procedure nfsd\_procedures2[18] = { .pc\_encode = nfssvc\_encode\_attrstatres, .pc\_release = nfssvc\_release\_attrstat, .pc\_argsize = sizeof(struct nfsd\_writeargs),+ .pc\_argzero = sizeof(struct nfsd\_writeargs), .pc\_ressize = sizeof(struct nfsd\_attrstat), .pc\_cachetype = RC\_REPLBUFF, .pc\_xdrressize = ST+AT,@@ -742,6 +742,7 @@ static const struct svc\_procedure nfsd\_procedures2[18] = { .pc\_encode = nfssvc\_encode\_diropres, .pc\_release = nfssvc\_release\_diropres, .pc\_argsize = sizeof(struct nfsd\_createargs),+ .pc\_argzero = sizeof(struct nfsd\_createargs), .pc\_ressize = sizeof(struct nfsd\_diropres), .pc\_cachetype = RC\_REPLBUFF, .pc\_xdrressize = ST+FH+AT,@@ -752,6 +753,7 @@ static const struct svc\_procedure nfsd\_procedures2[18] = { .pc\_decode = nfssvc\_decode\_diropargs, .pc\_encode = nfssvc\_encode\_statres, .pc\_argsize = sizeof(struct nfsd\_diropargs),+ .pc\_argzero = sizeof(struct nfsd\_diropargs), .pc\_ressize = sizeof(struct nfsd\_stat), .pc\_cachetype = RC\_REPLSTAT, .pc\_xdrressize = ST,@@ -762,6 +764,7 @@ static const struct svc\_procedure nfsd\_procedures2[18] = { .pc\_decode = nfssvc\_decode\_renameargs, .pc\_encode = nfssvc\_encode\_statres, .pc\_argsize = sizeof(struct nfsd\_renameargs),+ .pc\_argzero = sizeof(struct nfsd\_renameargs), .pc\_ressize = sizeof(struct nfsd\_stat), .pc\_cachetype = RC\_REPLSTAT, .pc\_xdrressize = ST,@@ -772,6 +775,7 @@ static const struct svc\_procedure nfsd\_procedures2[18] = { .pc\_decode = nfssvc\_decode\_linkargs, .pc\_encode = nfssvc\_encode\_statres, .pc\_argsize = sizeof(struct nfsd\_linkargs),+ .pc\_argzero = sizeof(struct nfsd\_linkargs), .pc\_ressize = sizeof(struct nfsd\_stat), .pc\_cachetype = RC\_REPLSTAT, .pc\_xdrressize = ST,@@ -782,6 +786,7 @@ static const struct svc\_procedure nfsd\_procedures2[18] = { .pc\_decode = nfssvc\_decode\_symlinkargs, .pc\_encode = nfssvc\_encode\_statres, .pc\_argsize = sizeof(struct nfsd\_symlinkargs),+ .pc\_argzero = sizeof(struct nfsd\_symlinkargs), .pc\_ressize = sizeof(struct nfsd\_stat), .pc\_cachetype = RC\_REPLSTAT, .pc\_xdrressize = ST,@@ -793,6 +798,7 @@ static const struct svc\_procedure nfsd\_procedures2[18] = { .pc\_encode = nfssvc\_encode\_diropres, .pc\_release = nfssvc\_release\_diropres, .pc\_argsize = sizeof(struct nfsd\_createargs),+ .pc\_argzero = sizeof(struct nfsd\_createargs), .pc\_ressize = sizeof(struct nfsd\_diropres), .pc\_cachetype = RC\_REPLBUFF, .pc\_xdrressize = ST+FH+AT,@@ -803,6 +809,7 @@ static const struct svc\_procedure nfsd\_procedures2[18] = { .pc\_decode = nfssvc\_decode\_diropargs, .pc\_encode = nfssvc\_encode\_statres, .pc\_argsize = sizeof(struct nfsd\_diropargs),+ .pc\_argzero = sizeof(struct nfsd\_diropargs), .pc\_ressize = sizeof(struct nfsd\_stat), .pc\_cachetype = RC\_REPLSTAT, .pc\_xdrressize = ST,@@ -813,6 +820,7 @@ static const struct svc\_procedure nfsd\_procedures2[18] = { .pc\_decode = nfssvc\_decode\_readdirargs, .pc\_encode = nfssvc\_encode\_readdirres, .pc\_argsize = sizeof(struct nfsd\_readdirargs),+ .pc\_argzero = sizeof(struct nfsd\_readdirargs), .pc\_ressize = sizeof(struct nfsd\_readdirres), .pc\_cachetype = RC\_NOCACHE, .pc\_name = "READDIR",@@ -822,6 +830,7 @@ static const struct svc\_procedure nfsd\_procedures2[18] = { .pc\_decode = nfssvc\_decode\_fhandleargs, .pc\_encode = nfssvc\_encode\_statfsres, .pc\_argsize = sizeof(struct nfsd\_fhandle),+ .pc\_argzero = sizeof(struct nfsd\_fhandle), .pc\_ressize = sizeof(struct nfsd\_statfsres), .pc\_cachetype = RC\_NOCACHE, .pc\_xdrressize = ST+5,diff --git a/fs/nfsd/nfssvc.c b/fs/nfsd/nfssvc.cindex 4bb5baa17040fc..bfbd9f672f59e2 100644--- a/[fs/nfsd/nfssvc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfssvc.c?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/nfsd/nfssvc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfssvc.c?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -799,7 +799,7 @@ nfsd\_svc(int nrservs, struct net \*net, const struct cred \*cred) if (nrservs == 0 && nn->nfsd\_serv == NULL) goto out; - strlcpy(nn->nfsd\_name, utsname()->nodename,+ strscpy(nn->nfsd\_name, utsname()->nodename, sizeof(nn->nfsd\_name));  error = nfsd\_create\_serv(net);diff --git a/fs/nfsd/nfsxdr.c b/fs/nfsd/nfsxdr.cindex aba8520b4b8b6b..caf6355b18fa99 100644--- a/[fs/nfsd/nfsxdr.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfsxdr.c?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/nfsd/nfsxdr.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/nfsxdr.c?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -338,10 +338,8 @@ nfssvc\_decode\_writeargs(struct svc\_rqst \*rqstp, struct xdr\_stream \*xdr) return false; if (args->len > NFSSVC\_MAXBLKSIZE\_V2) return false;- if (!xdr\_stream\_subsegment(xdr, &args->payload, args->len))- return false; - return true;+ return xdr\_stream\_subsegment(xdr, &args->payload, args->len); }  booldiff --git a/fs/nfsd/state.h b/fs/nfsd/state.hindex ae596dbf866755..e2daef3cc0034b 100644--- a/[fs/nfsd/state.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/state.h?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/nfsd/state.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/state.h?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -57,11 +57,11 @@ typedef struct { } stateid\_t;  typedef struct {- stateid\_t stid;+ stateid\_t cs\_stid; #define NFS4\_COPY\_STID 1 #define NFS4\_COPYNOTIFY\_STID 2- unsigned char sc\_type;- refcount\_t sc\_count;+ unsigned char cs\_type;+ refcount\_t cs\_count; } copy\_stateid\_t;  struct nfsd4\_callback {@@ -175,7 +175,7 @@ static inline struct nfs4\_delegation \*delegstateid(struct nfs4\_stid \*s) /\* Maximum number of slots per session. 160 is useful for long haul TCP \*/ #define NFSD\_MAX\_SLOTS\_PER\_SESSION 160 /\* Maximum number of operations per session compound \*/-#define NFSD\_MAX\_OPS\_PER\_COMPOUND 16+#define NFSD\_MAX\_OPS\_PER\_COMPOUND 50 /\* Maximum session per slot cache size \*/ #define NFSD\_SLOT\_CACHE\_SIZE 2048 /\* Maximum number of NFSD\_SLOT\_CACHE\_SIZE slots per session \*/@@ -692,12 +692,11 @@ extern void nfsd4\_probe\_callback\_sync(struct nfs4\_client \*clp); extern void nfsd4\_change\_callback(struct nfs4\_client \*clp, struct nfs4\_cb\_conn \*); extern void nfsd4\_init\_cb(struct nfsd4\_callback \*cb, struct nfs4\_client \*clp, const struct nfsd4\_callback\_ops \*ops, enum nfsd4\_cb\_op op);-extern void nfsd4\_run\_cb(struct nfsd4\_callback \*cb);+extern bool nfsd4\_run\_cb(struct nfsd4\_callback \*cb); extern int nfsd4\_create\_callback\_queue(void); extern void nfsd4\_destroy\_callback\_queue(void); extern void nfsd4\_shutdown\_callback(struct nfs4\_client \*); extern void nfsd4\_shutdown\_copy(struct nfs4\_client \*clp);-extern void nfsd4\_prepare\_cb\_recall(struct nfs4\_delegation \*dp); extern struct nfs4\_client\_reclaim \*nfs4\_client\_to\_reclaim(struct xdr\_netobj name, struct xdr\_netobj princhash, struct nfsd\_net \*nn); extern bool nfs4\_has\_reclaimed\_state(struct xdr\_netobj name, struct nfsd\_net \*nn);diff --git a/fs/nfsd/stats.c b/fs/nfsd/stats.cindex a8c5a02a84f044..777e24e5da33bd 100644--- a/[fs/nfsd/stats.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/stats.c?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/nfsd/stats.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/stats.c?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -32,7 +32,7 @@ struct svc\_stat nfsd\_svcstats = { .program = &nfsd\_program, }; -static int nfsd\_proc\_show(struct seq\_file \*seq, void \*v)+static int nfsd\_show(struct seq\_file \*seq, void \*v) { int i; @@ -72,17 +72,7 @@ static int nfsd\_proc\_show(struct seq\_file \*seq, void \*v) return 0; } -static int nfsd\_proc\_open(struct inode \*inode, struct file \*file)-{- return single\_open(file, nfsd\_proc\_show, NULL);-}--static const struct proc\_ops nfsd\_proc\_ops = {- .proc\_open = nfsd\_proc\_open,- .proc\_read = seq\_read,- .proc\_lseek = seq\_lseek,- .proc\_release = single\_release,-};+DEFINE\_PROC\_SHOW\_ATTRIBUTE(nfsd);  int nfsd\_percpu\_counters\_init(struct percpu\_counter counters[], int num) {diff --git a/fs/nfsd/trace.h b/fs/nfsd/trace.hindex 9ebd67d461f9ee..06a96e955bd00d 100644--- a/[fs/nfsd/trace.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/trace.h?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/nfsd/trace.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/trace.h?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -84,19 +84,26 @@ DEFINE\_NFSD\_XDR\_ERR\_EVENT(cant\_encode); { NFSD\_MAY\_64BIT\_COOKIE, "64BIT\_COOKIE" })  TRACE\_EVENT(nfsd\_compound,- TP\_PROTO(const struct svc\_rqst \*rqst,- u32 args\_opcnt),- TP\_ARGS(rqst, args\_opcnt),+ TP\_PROTO(+ const struct svc\_rqst \*rqst,+ const char \*tag,+ u32 taglen,+ u32 opcnt+ ),+ TP\_ARGS(rqst, tag, taglen, opcnt), TP\_STRUCT\_\_entry( \_\_field(u32, xid)- \_\_field(u32, args\_opcnt)+ \_\_field(u32, opcnt)+ \_\_string\_len(tag, tag, taglen) ), TP\_fast\_assign( \_\_entry->xid = be32\_to\_cpu(rqst->rq\_xid);- \_\_entry->args\_opcnt = args\_opcnt;+ \_\_entry->opcnt = opcnt;+ \_\_assign\_str\_len(tag, tag, taglen); ),- TP\_printk("xid=0x%08x opcnt=%u",- \_\_entry->xid, \_\_entry->args\_opcnt)+ TP\_printk("xid=0x%08x opcnt=%u tag=%s",+ \_\_entry->xid, \_\_entry->opcnt, \_\_get\_str(tag)+ ) )  TRACE\_EVENT(nfsd\_compound\_status,@@ -195,7 +202,7 @@ TRACE\_EVENT(nfsd\_fh\_verify, \_\_sockaddr(client, rqstp->rq\_xprt->xpt\_remotelen) \_\_field(u32, xid) \_\_field(u32, fh\_hash)- \_\_field(void \*, inode)+ \_\_field(const void \*, inode) \_\_field(unsigned long, type) \_\_field(unsigned long, access) ),@@ -211,13 +218,55 @@ TRACE\_EVENT(nfsd\_fh\_verify, \_\_entry->type = type; \_\_entry->access = access; ),- TP\_printk("xid=0x%08x fh\_hash=0x%08x inode=%p type=%s access=%s",- \_\_entry->xid, \_\_entry->fh\_hash, \_\_entry->inode,+ TP\_printk("xid=0x%08x fh\_hash=0x%08x type=%s access=%s",+ \_\_entry->xid, \_\_entry->fh\_hash, show\_fs\_file\_type(\_\_entry->type), show\_nfsd\_may\_flags(\_\_entry->access) ) ); +TRACE\_EVENT\_CONDITION(nfsd\_fh\_verify\_err,+ TP\_PROTO(+ const struct svc\_rqst \*rqstp,+ const struct svc\_fh \*fhp,+ umode\_t type,+ int access,+ \_\_be32 error+ ),+ TP\_ARGS(rqstp, fhp, type, access, error),+ TP\_CONDITION(error),+ TP\_STRUCT\_\_entry(+ \_\_field(unsigned int, netns\_ino)+ \_\_sockaddr(server, rqstp->rq\_xprt->xpt\_remotelen)+ \_\_sockaddr(client, rqstp->rq\_xprt->xpt\_remotelen)+ \_\_field(u32, xid)+ \_\_field(u32, fh\_hash)+ \_\_field(const void \*, inode)+ \_\_field(unsigned long, type)+ \_\_field(unsigned long, access)+ \_\_field(int, error)+ ),+ TP\_fast\_assign(+ \_\_entry->netns\_ino = SVC\_NET(rqstp)->ns.inum;+ \_\_assign\_sockaddr(server, &rqstp->rq\_xprt->xpt\_local,+ rqstp->rq\_xprt->xpt\_locallen);+ \_\_assign\_sockaddr(client, &rqstp->rq\_xprt->xpt\_remote,+ rqstp->rq\_xprt->xpt\_remotelen);+ \_\_entry->xid = be32\_to\_cpu(rqstp->rq\_xid);+ \_\_entry->fh\_hash = knfsd\_fh\_hash(&fhp->fh\_handle);+ \_\_entry->inode = d\_inode(fhp->fh\_dentry);+ \_\_entry->type = type;+ \_\_entry->access = access;+ \_\_entry->error = be32\_to\_cpu(error);+ ),+ TP\_printk("xid=0x%08x fh\_hash=0x%08x type=%s access=%s error=%d",+ \_\_entry->xid, \_\_entry->fh\_hash,+ show\_fs\_file\_type(\_\_entry->type),+ show\_nfsd\_may\_flags(\_\_entry->access),+ \_\_entry->error+ )+);+ DECLARE\_EVENT\_CLASS(nfsd\_fh\_err\_class, TP\_PROTO(struct svc\_rqst \*rqstp, struct svc\_fh \*fhp,@@ -489,6 +538,29 @@ DEFINE\_NFSD\_COPY\_ERR\_EVENT(clone\_file\_range\_err); #include "filecache.h" #include "vfs.h" +TRACE\_EVENT(nfsd\_delegret\_wakeup,+ TP\_PROTO(+ const struct svc\_rqst \*rqstp,+ const struct inode \*inode,+ long timeo+ ),+ TP\_ARGS(rqstp, inode, timeo),+ TP\_STRUCT\_\_entry(+ \_\_field(u32, xid)+ \_\_field(const void \*, inode)+ \_\_field(long, timeo)+ ),+ TP\_fast\_assign(+ \_\_entry->xid = be32\_to\_cpu(rqstp->rq\_xid);+ \_\_entry->inode = inode;+ \_\_entry->timeo = timeo;+ ),+ TP\_printk("xid=0x%08x inode=%p%s",+ \_\_entry->xid, \_\_entry->inode,+ \_\_entry->timeo == 0 ? " (timed out)" : ""+ )+);+ DECLARE\_EVENT\_CLASS(nfsd\_stateid\_class, TP\_PROTO(stateid\_t \*stp), TP\_ARGS(stp),@@ -1399,6 +1471,45 @@ TRACE\_EVENT(nfsd\_cb\_offload, \_\_entry->fh\_hash, \_\_entry->count, \_\_entry->status) ); +DECLARE\_EVENT\_CLASS(nfsd\_cb\_done\_class,+ TP\_PROTO(+ const stateid\_t \*stp,+ const struct rpc\_task \*task+ ),+ TP\_ARGS(stp, task),+ TP\_STRUCT\_\_entry(+ \_\_field(u32, cl\_boot)+ \_\_field(u32, cl\_id)+ \_\_field(u32, si\_id)+ \_\_field(u32, si\_generation)+ \_\_field(int, status)+ ),+ TP\_fast\_assign(+ \_\_entry->cl\_boot = stp->si\_opaque.so\_clid.cl\_boot;+ \_\_entry->cl\_id = stp->si\_opaque.so\_clid.cl\_id;+ \_\_entry->si\_id = stp->si\_opaque.so\_id;+ \_\_entry->si\_generation = stp->si\_generation;+ \_\_entry->status = task->tk\_status;+ ),+ TP\_printk("client %08x:%08x stateid %08x:%08x status=%d",+ \_\_entry->cl\_boot, \_\_entry->cl\_id, \_\_entry->si\_id,+ \_\_entry->si\_generation, \_\_entry->status+ )+);++#define DEFINE\_NFSD\_CB\_DONE\_EVENT(name) \+DEFINE\_EVENT(nfsd\_cb\_done\_class, name, \+ TP\_PROTO( \+ const stateid\_t \*stp, \+ const struct rpc\_task \*task \+ ), \+ TP\_ARGS(stp, task))++DEFINE\_NFSD\_CB\_DONE\_EVENT(nfsd\_cb\_recall\_done);+DEFINE\_NFSD\_CB\_DONE\_EVENT(nfsd\_cb\_notify\_lock\_done);+DEFINE\_NFSD\_CB\_DONE\_EVENT(nfsd\_cb\_layout\_done);+DEFINE\_NFSD\_CB\_DONE\_EVENT(nfsd\_cb\_offload\_done);+ #endif /\* \_NFSD\_TRACE\_H \*/  #undef TRACE\_INCLUDE\_PATHdiff --git a/fs/nfsd/vfs.c b/fs/nfsd/vfs.cindex fc17b0ac872979..83be89905cbf29 100644--- a/[fs/nfsd/vfs.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/vfs.c?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/nfsd/vfs.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/vfs.c?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -343,8 +343,61 @@ nfsd\_get\_write\_access(struct svc\_rqst \*rqstp, struct svc\_fh \*fhp, return nfserrno(get\_write\_access(inode)); } -/\*- \* Set various file attributes. After this call fhp needs an fh\_put.+static int \_\_nfsd\_setattr(struct dentry \*dentry, struct iattr \*iap)+{+ int host\_err;++ if (iap->ia\_valid & ATTR\_SIZE) {+ /\*+ \* RFC5661, Section 18.30.4:+ \* Changing the size of a file with SETATTR indirectly+ \* changes the time\_modify and change attributes.+ \*+ \* (and similar for the older RFCs)+ \*/+ struct iattr size\_attr = {+ .ia\_valid = ATTR\_SIZE | ATTR\_CTIME | ATTR\_MTIME,+ .ia\_size = iap->ia\_size,+ };++ if (iap->ia\_size < 0)+ return -EFBIG;++ host\_err = notify\_change(&init\_user\_ns, dentry, &size\_attr, NULL);+ if (host\_err)+ return host\_err;+ iap->ia\_valid &= ~ATTR\_SIZE;++ /\*+ \* Avoid the additional setattr call below if the only other+ \* attribute that the client sends is the mtime, as we update+ \* it as part of the size change above.+ \*/+ if ((iap->ia\_valid & ~ATTR\_MTIME) == 0)+ return 0;+ }++ if (!iap->ia\_valid)+ return 0;++ iap->ia\_valid |= ATTR\_CTIME;+ return notify\_change(&init\_user\_ns, dentry, iap, NULL);+}++/\*\*+ \* nfsd\_setattr - Set various file attributes.+ \* @rqstp: controlling RPC transaction+ \* @fhp: filehandle of target+ \* @attr: attributes to set+ \* @check\_guard: set to 1 if guardtime is a valid timestamp+ \* @guardtime: do not act if ctime.tv\_sec does not match this timestamp+ \*+ \* This call may adjust the contents of @attr (in particular, this+ \* call may change the bits in the na\_iattr.ia\_valid field).+ \*+ \* Returns nfs\_ok on success, otherwise an NFS status code is+ \* returned. Caller must release @fhp by calling fh\_put in either+ \* case. \*/ \_\_be32 nfsd\_setattr(struct svc\_rqst \*rqstp, struct svc\_fh \*fhp,@@ -357,9 +410,10 @@ nfsd\_setattr(struct svc\_rqst \*rqstp, struct svc\_fh \*fhp, int accmode = NFSD\_MAY\_SATTR; umode\_t ftype = 0; \_\_be32 err;- int host\_err = 0;+ int host\_err; bool get\_write\_count; bool size\_change = (iap->ia\_valid & ATTR\_SIZE);+ int retries;  if (iap->ia\_valid & ATTR\_SIZE) { accmode |= NFSD\_MAY\_WRITE|NFSD\_MAY\_OWNER\_OVERRIDE;@@ -414,43 +468,13 @@ nfsd\_setattr(struct svc\_rqst \*rqstp, struct svc\_fh \*fhp, }  inode\_lock(inode);- if (size\_change) {- /\*- \* RFC5661, Section 18.30.4:- \* Changing the size of a file with SETATTR indirectly- \* changes the time\_modify and change attributes.- \*- \* (and similar for the older RFCs)- \*/- struct iattr size\_attr = {- .ia\_valid = ATTR\_SIZE | ATTR\_CTIME | ATTR\_MTIME,- .ia\_size = iap->ia\_size,- };-- host\_err = -EFBIG;- if (iap->ia\_size < 0)- goto out\_unlock;-- host\_err = notify\_change(&init\_user\_ns, dentry, &size\_attr, NULL);- if (host\_err)- goto out\_unlock;- iap->ia\_valid &= ~ATTR\_SIZE;-- /\*- \* Avoid the additional setattr call below if the only other- \* attribute that the client sends is the mtime, as we update- \* it as part of the size change above.- \*/- if ((iap->ia\_valid & ~ATTR\_MTIME) == 0)- goto out\_unlock;- }-- if (iap->ia\_valid) {- iap->ia\_valid |= ATTR\_CTIME;- host\_err = notify\_change(&init\_user\_ns, dentry, iap, NULL);+ for (retries = 1;;) {+ host\_err = \_\_nfsd\_setattr(dentry, iap);+ if (host\_err != -EAGAIN || !retries--)+ break;+ if (!nfsd\_wait\_for\_delegreturn(rqstp, inode))+ break; }--out\_unlock: if (attr->na\_seclabel && attr->na\_seclabel->len) attr->na\_labelerr = security\_inode\_setsecctx(dentry, attr->na\_seclabel->data, attr->na\_seclabel->len);@@ -1255,7 +1279,7 @@ nfsd\_check\_ignore\_resizing(struct iattr \*iap) /\* The parent directory should already be locked: \*/ \_\_be32 nfsd\_create\_locked(struct svc\_rqst \*rqstp, struct svc\_fh \*fhp,- char \*fname, int flen, struct nfsd\_attrs \*attrs,+ struct nfsd\_attrs \*attrs, int type, dev\_t rdev, struct svc\_fh \*resfhp) { struct dentry \*dentry, \*dchild;@@ -1382,8 +1406,7 @@ nfsd\_create(struct svc\_rqst \*rqstp, struct svc\_fh \*fhp, if (err) goto out\_unlock; fh\_fill\_pre\_attrs(fhp);- err = nfsd\_create\_locked(rqstp, fhp, fname, flen, attrs, type,- rdev, resfhp);+ err = nfsd\_create\_locked(rqstp, fhp, attrs, type, rdev, resfhp); fh\_fill\_post\_attrs(fhp); out\_unlock: inode\_unlock(dentry->d\_inode);@@ -1673,7 +1696,15 @@ retry: .new\_dir = tdir, .new\_dentry = ndentry, };- host\_err = vfs\_rename(&rd);+ int retries;++ for (retries = 1;;) {+ host\_err = vfs\_rename(&rd);+ if (host\_err != -EAGAIN || !retries--)+ break;+ if (!nfsd\_wait\_for\_delegreturn(rqstp, d\_inode(odentry)))+ break;+ } if (!host\_err) { host\_err = commit\_metadata(tfhp); if (!host\_err)@@ -1757,9 +1788,18 @@ nfsd\_unlink(struct svc\_rqst \*rqstp, struct svc\_fh \*fhp, int type,  fh\_fill\_pre\_attrs(fhp); if (type != S\_IFDIR) {+ int retries;+ if (rdentry->d\_sb->s\_export\_op->flags & EXPORT\_OP\_CLOSE\_BEFORE\_UNLINK) nfsd\_close\_cached\_files(rdentry);- host\_err = vfs\_unlink(&init\_user\_ns, dirp, rdentry, NULL);++ for (retries = 1;;) {+ host\_err = vfs\_unlink(&init\_user\_ns, dirp, rdentry, NULL);+ if (host\_err != -EAGAIN || !retries--)+ break;+ if (!nfsd\_wait\_for\_delegreturn(rqstp, rinode))+ break;+ } } else { host\_err = vfs\_rmdir(&init\_user\_ns, dirp, rdentry); }diff --git a/fs/nfsd/vfs.h b/fs/nfsd/vfs.hindex c95cd414b4bb01..120521bc7b2476 100644--- a/[fs/nfsd/vfs.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/vfs.h?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/nfsd/vfs.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/vfs.h?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -79,8 +79,8 @@ \_\_be32 nfsd4\_clone\_file\_range(struct svc\_rqst \*rqstp, u64 count, bool sync); #endif /\* CONFIG\_NFSD\_V4 \*/ \_\_be32 nfsd\_create\_locked(struct svc\_rqst \*, struct svc\_fh \*,- char \*name, int len, struct nfsd\_attrs \*attrs,- int type, dev\_t rdev, struct svc\_fh \*res);+ struct nfsd\_attrs \*attrs, int type, dev\_t rdev,+ struct svc\_fh \*res); \_\_be32 nfsd\_create(struct svc\_rqst \*, struct svc\_fh \*, char \*name, int len, struct nfsd\_attrs \*attrs, int type, dev\_t rdev, struct svc\_fh \*res);diff --git a/fs/nfsd/xdr4.h b/fs/nfsd/xdr4.hindex 96267258e62910..0eb00105d845b6 100644--- a/[fs/nfsd/xdr4.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/xdr4.h?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[fs/nfsd/xdr4.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/nfsd/xdr4.h?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -717,13 +717,13 @@ struct nfsd4\_compoundargs { struct svcxdr\_tmpbuf \*to\_free; struct svc\_rqst \*rqstp; - u32 taglen; char \* tag;+ u32 taglen; u32 minorversion;+ u32 client\_opcnt; u32 opcnt; struct nfsd4\_op \*ops; struct nfsd4\_op iops[8];- int cachetype; };  struct nfsd4\_compoundres {@@ -732,8 +732,8 @@ struct nfsd4\_compoundres { struct svc\_rqst \* rqstp;  \_\_be32 \*statusp;- u32 taglen; char \* tag;+ u32 taglen; u32 opcnt;  struct nfsd4\_compound\_state cstate;@@ -888,7 +888,8 @@ struct nfsd4\_operation { u32 op\_flags; char \*op\_name; /\* Try to get response size before operation \*/- u32 (\*op\_rsize\_bop)(struct svc\_rqst \*, struct nfsd4\_op \*);+ u32 (\*op\_rsize\_bop)(const struct svc\_rqst \*rqstp,+ const struct nfsd4\_op \*op); void (\*op\_get\_currentstateid)(struct nfsd4\_compound\_state \*, union nfsd4\_op\_u \*); void (\*op\_set\_currentstateid)(struct nfsd4\_compound\_state \*,diff --git a/include/linux/sunrpc/svc.h b/include/linux/sunrpc/svc.hindex daecb009c05b56..88de45491376a6 100644--- a/[include/linux/sunrpc/svc.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/sunrpc/svc.h?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[include/linux/sunrpc/svc.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/sunrpc/svc.h?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -472,6 +472,7 @@ struct svc\_procedure { /\* XDR free result: \*/ void (\*pc\_release)(struct svc\_rqst \*); unsigned int pc\_argsize; /\* argument struct size \*/+ unsigned int pc\_argzero; /\* how much of argument to clear \*/ unsigned int pc\_ressize; /\* result struct size \*/ unsigned int pc\_cachetype; /\* cache info (NFS) \*/ unsigned int pc\_xdrressize; /\* maximum size of XDR reply \*/@@ -544,16 +545,27 @@ static inline void svc\_reserve\_auth(struct svc\_rqst \*rqstp, int space) }  /\*\*- \* svcxdr\_init\_decode - Prepare an xdr\_stream for svc Call decoding+ \* svcxdr\_init\_decode - Prepare an xdr\_stream for Call decoding \* @rqstp: controlling server RPC transaction context \*+ \* This function currently assumes the RPC header in rq\_arg has+ \* already been decoded. Upon return, xdr->p points to the+ \* location of the upper layer header. \*/ static inline void svcxdr\_init\_decode(struct svc\_rqst \*rqstp) { struct xdr\_stream \*xdr = &rqstp->rq\_arg\_stream;- struct kvec \*argv = rqstp->rq\_arg.head;+ struct xdr\_buf \*buf = &rqstp->rq\_arg;+ struct kvec \*argv = buf->head; - xdr\_init\_decode(xdr, &rqstp->rq\_arg, argv->iov\_base, NULL);+ /\*+ \* svc\_getnl() and friends do not keep the xdr\_buf's ::len+ \* field up to date. Refresh that field before initializing+ \* the argument decoding stream.+ \*/+ buf->len = buf->head->iov\_len + buf->page\_len + buf->tail->iov\_len;++ xdr\_init\_decode(xdr, buf, argv->iov\_base, NULL); xdr\_set\_scratch\_page(xdr, rqstp->rq\_scratch\_page); } @@ -576,7 +588,7 @@ static inline void svcxdr\_init\_encode(struct svc\_rqst \*rqstp) xdr->end = resv->iov\_base + PAGE\_SIZE - rqstp->rq\_auth\_slack; buf->len = resv->iov\_len; xdr->page\_ptr = buf->pages - 1;- buf->buflen = PAGE\_SIZE \* (1 + rqstp->rq\_page\_end - buf->pages);+ buf->buflen = PAGE\_SIZE \* (rqstp->rq\_page\_end - buf->pages); buf->buflen -= rqstp->rq\_auth\_slack; xdr->rqst = NULL; }diff --git a/include/linux/sunrpc/xdr.h b/include/linux/sunrpc/xdr.hindex 69175029abbbf5..f84e2a1358e170 100644--- a/[include/linux/sunrpc/xdr.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/sunrpc/xdr.h?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[include/linux/sunrpc/xdr.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/sunrpc/xdr.h?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -240,6 +240,8 @@ typedef int (\*kxdrdproc\_t)(struct rpc\_rqst \*rqstp, struct xdr\_stream \*xdr,  extern void xdr\_init\_encode(struct xdr\_stream \*xdr, struct xdr\_buf \*buf, \_\_be32 \*p, struct rpc\_rqst \*rqst);+extern void xdr\_init\_encode\_pages(struct xdr\_stream \*xdr, struct xdr\_buf \*buf,+ struct page \*\*pages, struct rpc\_rqst \*rqst); extern \_\_be32 \*xdr\_reserve\_space(struct xdr\_stream \*xdr, size\_t nbytes); extern int xdr\_reserve\_space\_vec(struct xdr\_stream \*xdr, struct kvec \*vec, size\_t nbytes);diff --git a/net/sunrpc/svc.c b/net/sunrpc/svc.cindex 7c9a0d0b123004..149171774bc631 100644--- a/[net/sunrpc/svc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/sunrpc/svc.c?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[net/sunrpc/svc.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/sunrpc/svc.c?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -1205,7 +1205,7 @@ svc\_generic\_init\_request(struct svc\_rqst \*rqstp, goto err\_bad\_proc;  /\* Initialize storage for argp and resp \*/- memset(rqstp->rq\_argp, 0, procp->pc\_argsize);+ memset(rqstp->rq\_argp, 0, procp->pc\_argzero); memset(rqstp->rq\_resp, 0, procp->pc\_ressize);  /\* Bump per-procedure stats counter \*/@@ -1434,8 +1434,7 @@ svc\_process(struct svc\_rqst \*rqstp) { struct kvec \*argv = &rqstp->rq\_arg.head[0]; struct kvec \*resv = &rqstp->rq\_res.head[0];- struct svc\_serv \*serv = rqstp->rq\_server;- u32 dir;+ \_\_be32 dir;  #if IS\_ENABLED(CONFIG\_FAIL\_SUNRPC) if (!fail\_sunrpc.ignore\_server\_disconnect &&@@ -1450,7 +1449,7 @@ svc\_process(struct svc\_rqst \*rqstp) rqstp->rq\_next\_page = &rqstp->rq\_respages[1]; resv->iov\_base = page\_address(rqstp->rq\_respages[0]); resv->iov\_len = 0;- rqstp->rq\_res.pages = rqstp->rq\_respages + 1;+ rqstp->rq\_res.pages = rqstp->rq\_next\_page; rqstp->rq\_res.len = 0; rqstp->rq\_res.page\_base = 0; rqstp->rq\_res.page\_len = 0;@@ -1458,18 +1457,17 @@ svc\_process(struct svc\_rqst \*rqstp) rqstp->rq\_res.tail[0].iov\_base = NULL; rqstp->rq\_res.tail[0].iov\_len = 0; - dir = svc\_getnl(argv);- if (dir != 0) {- /\* direction != CALL \*/- svc\_printk(rqstp, "bad direction %d, dropping request\n", dir);- serv->sv\_stats->rpcbadfmt++;+ dir = svc\_getu32(argv);+ if (dir != rpc\_call)+ goto out\_baddir;+ if (!svc\_process\_common(rqstp, argv, resv)) goto out\_drop;- }-- /\* Returns 1 for send, 0 for drop \*/- if (likely(svc\_process\_common(rqstp, argv, resv)))- return svc\_send(rqstp);+ return svc\_send(rqstp); +out\_baddir:+ svc\_printk(rqstp, "bad direction 0x%08x, dropping request\n",+ be32\_to\_cpu(dir));+ rqstp->rq\_server->sv\_stats->rpcbadfmt++; out\_drop: svc\_drop(rqstp); return 0;@@ -1556,8 +1554,12 @@ out: EXPORT\_SYMBOL\_GPL(bc\_svc\_process); #endif /\* CONFIG\_SUNRPC\_BACKCHANNEL \*/ -/\*- \* Return (transport-specific) limit on the rpc payload.+/\*\*+ \* svc\_max\_payload - Return transport-specific limit on the RPC payload+ \* @rqstp: RPC transaction context+ \*+ \* Returns the maximum number of payload bytes the current transport+ \* allows. \*/ u32 svc\_max\_payload(const struct svc\_rqst \*rqstp) {diff --git a/net/sunrpc/xdr.c b/net/sunrpc/xdr.cindex 482586c23fdd5d..336a7c7833e497 100644--- a/[net/sunrpc/xdr.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/sunrpc/xdr.c?id=3497640a80d77cd098d45c9f3ab235b1aa472dbc)+++ b/[net/sunrpc/xdr.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/sunrpc/xdr.c?id=f90497a16e434c2211c66e3de8e77b17868382b8)@@ -947,6 +947,28 @@ void xdr\_init\_encode(struct xdr\_stream \*xdr, struct xdr\_buf \*buf, \_\_be32 \*p, EXPORT\_SYMBOL\_GPL(xdr\_init\_encode);  /\*\*+ \* xdr\_init\_encode\_pages - Initialize an xdr\_stream for encoding into pages+ \* @xdr: pointer to xdr\_stream struct+ \* @buf: pointer to XDR buffer into which to encode data+ \* @pages: list of pages to decode into+ \* @rqst: pointer to controlling rpc\_rqst, for debugging+ \*+ \*/+void xdr\_init\_encode\_pages(struct xdr\_stream \*xdr, struct xdr\_buf \*buf,+ struct page \*\*pages, struct rpc\_rqst \*rqst)+{+ xdr\_reset\_scratch\_buffer(xdr);++ xdr->buf = buf;+ xdr->page\_ptr = pages;+ xdr->iov = NULL;+ xdr->p = page\_address(\*pages);+ xdr->end = (void \*)xdr->p + min\_t(u32, buf->buflen, PAGE\_SIZE);+ xdr->rqst = rqst;+}+EXPORT\_SYMBOL\_GPL(xdr\_init\_encode\_pages);++/\*\* \* \_\_xdr\_commit\_encode - Ensure all data is written to buffer \* @xdr: pointer to xdr\_stream \*@@ -1575,7 +1597,7 @@ EXPORT\_SYMBOL\_GPL(xdr\_buf\_from\_iov); \* \* @buf and @subbuf may be pointers to the same struct xdr\_buf. \*- \* Returns -1 if base of length are out of bounds.+ \* Returns -1 if base or length are out of bounds. \*/ int xdr\_buf\_subsegment(const struct xdr\_buf \*buf, struct xdr\_buf \*subbuf, unsigned int base, unsigned int len) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-08 14:00:27 +0000

