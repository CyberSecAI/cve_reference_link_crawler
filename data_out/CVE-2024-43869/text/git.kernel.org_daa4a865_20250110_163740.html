

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=f34d8307a73a18de5320fcc6f40403146d061891)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f34d8307a73a18de5320fcc6f40403146d061891)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f34d8307a73a18de5320fcc6f40403146d061891)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f34d8307a73a18de5320fcc6f40403146d061891)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Frederic Weisbecker <frederic@kernel.org> | 2024-06-21 11:16:01 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-08-03 09:00:52 +0200 |
| commit | [f34d8307a73a18de5320fcc6f40403146d061891](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f34d8307a73a18de5320fcc6f40403146d061891) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=f34d8307a73a18de5320fcc6f40403146d061891)) | |
| tree | [c11e91702a37a027843557449fc616d46dd0f20b](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f34d8307a73a18de5320fcc6f40403146d061891) | |
| parent | [3d7a63352a93bdb8a1cdf29606bf617d3ac1c22a](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3d7a63352a93bdb8a1cdf29606bf617d3ac1c22a) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f34d8307a73a18de5320fcc6f40403146d061891&id2=3d7a63352a93bdb8a1cdf29606bf617d3ac1c22a)) | |
| download | [linux-f34d8307a73a18de5320fcc6f40403146d061891.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-f34d8307a73a18de5320fcc6f40403146d061891.tar.gz) | |

perf: Fix event leak upon exec and file releasecommit 3a5465418f5fd970e86a86c7f4075be262682840 upstream.
The perf pending task work is never waited upon the matching event
release. In the case of a child event, released via free\_event()
directly, this can potentially result in a leaked event, such as in the
following scenario that doesn't even require a weak IRQ work
implementation to trigger:
schedule()
prepare\_task\_switch()
=======> <NMI>
perf\_event\_overflow()
event->pending\_sigtrap = ...
irq\_work\_queue(&event->pending\_irq)
<======= </NMI>
perf\_event\_task\_sched\_out()
event\_sched\_out()
event->pending\_sigtrap = 0;
atomic\_long\_inc\_not\_zero(&event->refcount)
task\_work\_add(&event->pending\_task)
finish\_lock\_switch()
=======> <IRQ>
perf\_pending\_irq()
//do nothing, rely on pending task work
<======= </IRQ>
begin\_new\_exec()
perf\_event\_exit\_task()
perf\_event\_exit\_event()
// If is child event
free\_event()
WARN(atomic\_long\_cmpxchg(&event->refcount, 1, 0) != 1)
// event is leaked
Similar scenarios can also happen with perf\_event\_remove\_on\_exec() or
simply against concurrent perf\_event\_release().
Fix this with synchonizing against the possibly remaining pending task
work while freeing the event, just like is done with remaining pending
IRQ work. This means that the pending task callback neither need nor
should hold a reference to the event, preventing it from ever beeing
freed.
Fixes: 517e6a301f34 ("perf: Fix perf\_pending\_task() UaF")
Signed-off-by: Frederic Weisbecker <frederic@kernel.org>
Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Cc: stable@vger.kernel.org
Link: [https://lore.kernel.org/r/20240621091601.18227-5-frederic@kernel.org](https://lore.kernel.org/r/20240621091601.18227-5-frederic%40kernel.org)
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f34d8307a73a18de5320fcc6f40403146d061891)

| -rw-r--r-- | [include/linux/perf\_event.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/perf_event.h?id=f34d8307a73a18de5320fcc6f40403146d061891) | 1 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [kernel/events/core.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/events/core.c?id=f34d8307a73a18de5320fcc6f40403146d061891) | 38 | |  |  |  | | --- | --- | --- | |

2 files changed, 35 insertions, 4 deletions

| diff --git a/include/linux/perf\_event.h b/include/linux/perf\_event.hindex a5304ae8c654f0..393fb13733b024 100644--- a/[include/linux/perf\_event.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/perf_event.h?id=3d7a63352a93bdb8a1cdf29606bf617d3ac1c22a)+++ b/[include/linux/perf\_event.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/perf_event.h?id=f34d8307a73a18de5320fcc6f40403146d061891)@@ -786,6 +786,7 @@ struct perf\_event { struct irq\_work pending\_irq; struct callback\_head pending\_task; unsigned int pending\_work;+ struct rcuwait pending\_work\_wait;  atomic\_t event\_limit; diff --git a/kernel/events/core.c b/kernel/events/core.cindex 554d8ba93b8a40..037a2d266674ac 100644--- a/[kernel/events/core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/events/core.c?id=3d7a63352a93bdb8a1cdf29606bf617d3ac1c22a)+++ b/[kernel/events/core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/events/core.c?id=f34d8307a73a18de5320fcc6f40403146d061891)@@ -2288,7 +2288,6 @@ event\_sched\_out(struct perf\_event \*event, struct perf\_event\_context \*ctx) if (state != PERF\_EVENT\_STATE\_OFF && !event->pending\_work && !task\_work\_add(current, &event->pending\_task, TWA\_RESUME)) {- WARN\_ON\_ONCE(!atomic\_long\_inc\_not\_zero(&event->refcount)); event->pending\_work = 1; } else { local\_dec(&event->ctx->nr\_pending);@@ -5203,9 +5202,35 @@ static bool exclusive\_event\_installable(struct perf\_event \*event, static void perf\_addr\_filters\_splice(struct perf\_event \*event, struct list\_head \*head); +static void perf\_pending\_task\_sync(struct perf\_event \*event)+{+ struct callback\_head \*head = &event->pending\_task;++ if (!event->pending\_work)+ return;+ /\*+ \* If the task is queued to the current task's queue, we+ \* obviously can't wait for it to complete. Simply cancel it.+ \*/+ if (task\_work\_cancel(current, head)) {+ event->pending\_work = 0;+ local\_dec(&event->ctx->nr\_pending);+ return;+ }++ /\*+ \* All accesses related to the event are within the same+ \* non-preemptible section in perf\_pending\_task(). The RCU+ \* grace period before the event is freed will make sure all+ \* those accesses are complete by then.+ \*/+ rcuwait\_wait\_event(&event->pending\_work\_wait, !event->pending\_work, TASK\_UNINTERRUPTIBLE);+}+ static void \_free\_event(struct perf\_event \*event) { irq\_work\_sync(&event->pending\_irq);+ perf\_pending\_task\_sync(event);  unaccount\_event(event); @@ -6831,23 +6856,27 @@ static void perf\_pending\_task(struct callback\_head \*head) int rctx;  /\*+ \* All accesses to the event must belong to the same implicit RCU read-side+ \* critical section as the ->pending\_work reset. See comment in+ \* perf\_pending\_task\_sync().+ \*/+ preempt\_disable\_notrace();+ /\* \* If we 'fail' here, that's OK, it means recursion is already disabled \* and we won't recurse 'further'. \*/- preempt\_disable\_notrace(); rctx = perf\_swevent\_get\_recursion\_context();  if (event->pending\_work) { event->pending\_work = 0; perf\_sigtrap(event); local\_dec(&event->ctx->nr\_pending);+ rcuwait\_wake\_up(&event->pending\_work\_wait); }  if (rctx >= 0) perf\_swevent\_put\_recursion\_context(rctx); preempt\_enable\_notrace();-- put\_event(event); }  #ifdef CONFIG\_GUEST\_PERF\_EVENTS@@ -11961,6 +11990,7 @@ perf\_event\_alloc(struct perf\_event\_attr \*attr, int cpu, init\_waitqueue\_head(&event->waitq); init\_irq\_work(&event->pending\_irq, perf\_pending\_irq); init\_task\_work(&event->pending\_task, perf\_pending\_task);+ rcuwait\_init(&event->pending\_work\_wait);  mutex\_init(&event->mmap\_mutex); raw\_spin\_lock\_init(&event->addr\_filters.lock); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 16:36:17 +0000

