

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=2a5dc090b92cfa5270e20056074241c6db5c9cdd)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=2a5dc090b92cfa5270e20056074241c6db5c9cdd)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=2a5dc090b92cfa5270e20056074241c6db5c9cdd)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=2a5dc090b92cfa5270e20056074241c6db5c9cdd)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Larysa Zaremba <larysa.zaremba@intel.com> | 2024-08-23 11:59:26 +0200 |
| --- | --- | --- |
| committer | Tony Nguyen <anthony.l.nguyen@intel.com> | 2024-09-03 08:48:16 -0700 |
| commit | [2a5dc090b92cfa5270e20056074241c6db5c9cdd](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=2a5dc090b92cfa5270e20056074241c6db5c9cdd) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=2a5dc090b92cfa5270e20056074241c6db5c9cdd)) | |
| tree | [4954f7521457bbb6625a630a5191b72016c75083](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=2a5dc090b92cfa5270e20056074241c6db5c9cdd) | |
| parent | [cfd433cecef929b4d92685f570f1a480762ec260](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=cfd433cecef929b4d92685f570f1a480762ec260) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=2a5dc090b92cfa5270e20056074241c6db5c9cdd&id2=cfd433cecef929b4d92685f570f1a480762ec260)) | |
| download | [linux-2a5dc090b92cfa5270e20056074241c6db5c9cdd.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-2a5dc090b92cfa5270e20056074241c6db5c9cdd.tar.gz) | |

ice: move netif\_queue\_set\_napi to rtnl-protected sectionsCurrently, netif\_queue\_set\_napi() is called from ice\_vsi\_rebuild() that is
not rtnl-locked when called from the reset. This creates the need to take
the rtnl\_lock just for a single function and complicates the
synchronization with .ndo\_bpf. At the same time, there no actual need to
fill napi-to-queue information at this exact point.
Fill napi-to-queue information when opening the VSI and clear it when the
VSI is being closed. Those routines are already rtnl-locked.
Also, rewrite napi-to-queue assignment in a way that prevents inclusion of
XDP queues, as this leads to out-of-bounds writes, such as one below.
[ +0.000004] BUG: KASAN: slab-out-of-bounds in netif\_queue\_set\_napi+0x1c2/0x1e0
[ +0.000012] Write of size 8 at addr ffff889881727c80 by task bash/7047
[ +0.000006] CPU: 24 PID: 7047 Comm: bash Not tainted 6.10.0-rc2+ #2
[ +0.000004] Hardware name: Intel Corporation S2600WFT/S2600WFT, BIOS SE5C620.86B.02.01.0014.082620210524 08/26/2021
[ +0.000003] Call Trace:
[ +0.000003] <TASK>
[ +0.000002] dump\_stack\_lvl+0x60/0x80
[ +0.000007] print\_report+0xce/0x630
[ +0.000007] ? \_\_pfx\_\_raw\_spin\_lock\_irqsave+0x10/0x10
[ +0.000007] ? \_\_virt\_addr\_valid+0x1c9/0x2c0
[ +0.000005] ? netif\_queue\_set\_napi+0x1c2/0x1e0
[ +0.000003] kasan\_report+0xe9/0x120
[ +0.000004] ? netif\_queue\_set\_napi+0x1c2/0x1e0
[ +0.000004] netif\_queue\_set\_napi+0x1c2/0x1e0
[ +0.000005] ice\_vsi\_close+0x161/0x670 [ice]
[ +0.000114] ice\_dis\_vsi+0x22f/0x270 [ice]
[ +0.000095] ice\_pf\_dis\_all\_vsi.constprop.0+0xae/0x1c0 [ice]
[ +0.000086] ice\_prepare\_for\_reset+0x299/0x750 [ice]
[ +0.000087] pci\_dev\_save\_and\_disable+0x82/0xd0
[ +0.000006] pci\_reset\_function+0x12d/0x230
[ +0.000004] reset\_store+0xa0/0x100
[ +0.000006] ? \_\_pfx\_reset\_store+0x10/0x10
[ +0.000002] ? \_\_pfx\_mutex\_lock+0x10/0x10
[ +0.000004] ? \_\_check\_object\_size+0x4c1/0x640
[ +0.000007] kernfs\_fop\_write\_iter+0x30b/0x4a0
[ +0.000006] vfs\_write+0x5d6/0xdf0
[ +0.000005] ? fd\_install+0x180/0x350
[ +0.000005] ? \_\_pfx\_vfs\_write+0x10/0xA10
[ +0.000004] ? do\_fcntl+0x52c/0xcd0
[ +0.000004] ? kasan\_save\_track+0x13/0x60
[ +0.000003] ? kasan\_save\_free\_info+0x37/0x60
[ +0.000006] ksys\_write+0xfa/0x1d0
[ +0.000003] ? \_\_pfx\_ksys\_write+0x10/0x10
[ +0.000002] ? \_\_x64\_sys\_fcntl+0x121/0x180
[ +0.000004] ? \_raw\_spin\_lock+0x87/0xe0
[ +0.000005] do\_syscall\_64+0x80/0x170
[ +0.000007] ? \_raw\_spin\_lock+0x87/0xe0
[ +0.000004] ? \_\_pfx\_\_raw\_spin\_lock+0x10/0x10
[ +0.000003] ? file\_close\_fd\_locked+0x167/0x230
[ +0.000005] ? syscall\_exit\_to\_user\_mode+0x7d/0x220
[ +0.000005] ? do\_syscall\_64+0x8c/0x170
[ +0.000004] ? do\_syscall\_64+0x8c/0x170
[ +0.000003] ? do\_syscall\_64+0x8c/0x170
[ +0.000003] ? fput+0x1a/0x2c0
[ +0.000004] ? filp\_close+0x19/0x30
[ +0.000004] ? do\_dup2+0x25a/0x4c0
[ +0.000004] ? \_\_x64\_sys\_dup2+0x6e/0x2e0
[ +0.000002] ? syscall\_exit\_to\_user\_mode+0x7d/0x220
[ +0.000004] ? do\_syscall\_64+0x8c/0x170
[ +0.000003] ? \_\_count\_memcg\_events+0x113/0x380
[ +0.000005] ? handle\_mm\_fault+0x136/0x820
[ +0.000005] ? do\_user\_addr\_fault+0x444/0xa80
[ +0.000004] ? clear\_bhb\_loop+0x25/0x80
[ +0.000004] ? clear\_bhb\_loop+0x25/0x80
[ +0.000002] entry\_SYSCALL\_64\_after\_hwframe+0x76/0x7e
[ +0.000005] RIP: 0033:0x7f2033593154
Fixes: 080b0c8d6d26 ("ice: Fix ASSERT\_RTNL() warning during certain scenarios")
Fixes: 91fdbce7e8d6 ("ice: Add support in the driver for associating queue with napi")
Reviewed-by: Wojciech Drewek <wojciech.drewek@intel.com>
Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
Reviewed-by: Amritha Nambiar <amritha.nambiar@intel.com>
Signed-off-by: Larysa Zaremba <larysa.zaremba@intel.com>
Reviewed-by: Maciej Fijalkowski <maciej.fijalkowski@intel.com>
Tested-by: George Kuruvinakunnel <george.kuruvinakunnel@intel.com>
Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=2a5dc090b92cfa5270e20056074241c6db5c9cdd)

| -rw-r--r-- | [drivers/net/ethernet/intel/ice/ice\_base.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/intel/ice/ice_base.c?id=2a5dc090b92cfa5270e20056074241c6db5c9cdd) | 11 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/net/ethernet/intel/ice/ice\_lib.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/intel/ice/ice_lib.c?id=2a5dc090b92cfa5270e20056074241c6db5c9cdd) | 129 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/net/ethernet/intel/ice/ice\_lib.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/intel/ice/ice_lib.h?id=2a5dc090b92cfa5270e20056074241c6db5c9cdd) | 10 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/net/ethernet/intel/ice/ice\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/intel/ice/ice_main.c?id=2a5dc090b92cfa5270e20056074241c6db5c9cdd) | 17 | |  |  |  | | --- | --- | --- | |

4 files changed, 49 insertions, 118 deletions

| diff --git a/drivers/net/ethernet/intel/ice/ice\_base.c b/drivers/net/ethernet/intel/ice/ice\_base.cindex f448d3a8456425..c158749a80e05a 100644--- a/[drivers/net/ethernet/intel/ice/ice\_base.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice_base.c?id=cfd433cecef929b4d92685f570f1a480762ec260)+++ b/[drivers/net/ethernet/intel/ice/ice\_base.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice_base.c?id=2a5dc090b92cfa5270e20056074241c6db5c9cdd)@@ -190,16 +190,11 @@ static void ice\_free\_q\_vector(struct ice\_vsi \*vsi, int v\_idx) } q\_vector = vsi->q\_vectors[v\_idx]; - ice\_for\_each\_tx\_ring(tx\_ring, q\_vector->tx) {- ice\_queue\_set\_napi(vsi, tx\_ring->q\_index, NETDEV\_QUEUE\_TYPE\_TX,- NULL);+ ice\_for\_each\_tx\_ring(tx\_ring, vsi->q\_vectors[v\_idx]->tx) tx\_ring->q\_vector = NULL;- }- ice\_for\_each\_rx\_ring(rx\_ring, q\_vector->rx) {- ice\_queue\_set\_napi(vsi, rx\_ring->q\_index, NETDEV\_QUEUE\_TYPE\_RX,- NULL);++ ice\_for\_each\_rx\_ring(rx\_ring, vsi->q\_vectors[v\_idx]->rx) rx\_ring->q\_vector = NULL;- }  /\* only VSI with an associated netdev is set up with NAPI \*/ if (vsi->netdev)diff --git a/drivers/net/ethernet/intel/ice/ice\_lib.c b/drivers/net/ethernet/intel/ice/ice\_lib.cindex f559e60992fa5c..6676596df88b0f 100644--- a/[drivers/net/ethernet/intel/ice/ice\_lib.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice_lib.c?id=cfd433cecef929b4d92685f570f1a480762ec260)+++ b/[drivers/net/ethernet/intel/ice/ice\_lib.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice_lib.c?id=2a5dc090b92cfa5270e20056074241c6db5c9cdd)@@ -2286,9 +2286,6 @@ static int ice\_vsi\_cfg\_def(struct ice\_vsi \*vsi)  ice\_vsi\_map\_rings\_to\_vectors(vsi); - /\* Associate q\_vector rings to napi \*/- ice\_vsi\_set\_napi\_queues(vsi);- vsi->stat\_offsets\_loaded = false;  /\* ICE\_VSI\_CTRL does not need RSS so skip RSS processing \*/@@ -2628,6 +2625,7 @@ void ice\_vsi\_close(struct ice\_vsi \*vsi) if (!test\_and\_set\_bit(ICE\_VSI\_DOWN, vsi->state)) ice\_down(vsi); + ice\_vsi\_clear\_napi\_queues(vsi); ice\_vsi\_free\_irq(vsi); ice\_vsi\_free\_tx\_rings(vsi); ice\_vsi\_free\_rx\_rings(vsi);@@ -2694,120 +2692,55 @@ void ice\_dis\_vsi(struct ice\_vsi \*vsi, bool locked) }  /\*\*- \* \_\_ice\_queue\_set\_napi - Set the napi instance for the queue- \* @dev: device to which NAPI and queue belong- \* @queue\_index: Index of queue- \* @type: queue type as RX or TX- \* @napi: NAPI context- \* @locked: is the rtnl\_lock already held- \*- \* Set the napi instance for the queue. Caller indicates the lock status.- \*/-static void-\_\_ice\_queue\_set\_napi(struct net\_device \*dev, unsigned int queue\_index,- enum netdev\_queue\_type type, struct napi\_struct \*napi,- bool locked)-{- if (!locked)- rtnl\_lock();- netif\_queue\_set\_napi(dev, queue\_index, type, napi);- if (!locked)- rtnl\_unlock();-}--/\*\*- \* ice\_queue\_set\_napi - Set the napi instance for the queue- \* @vsi: VSI being configured- \* @queue\_index: Index of queue- \* @type: queue type as RX or TX- \* @napi: NAPI context+ \* ice\_vsi\_set\_napi\_queues - associate netdev queues with napi+ \* @vsi: VSI pointer \*- \* Set the napi instance for the queue. The rtnl lock state is derived from the- \* execution path.+ \* Associate queue[s] with napi for all vectors.+ \* The caller must hold rtnl\_lock. \*/-void-ice\_queue\_set\_napi(struct ice\_vsi \*vsi, unsigned int queue\_index,- enum netdev\_queue\_type type, struct napi\_struct \*napi)+void ice\_vsi\_set\_napi\_queues(struct ice\_vsi \*vsi) {- struct ice\_pf \*pf = vsi->back;+ struct net\_device \*netdev = vsi->netdev;+ int q\_idx, v\_idx; - if (!vsi->netdev)+ if (!netdev) return; - if (current\_work() == &pf->serv\_task ||- test\_bit(ICE\_PREPARED\_FOR\_RESET, pf->state) ||- test\_bit(ICE\_DOWN, pf->state) ||- test\_bit(ICE\_SUSPENDED, pf->state))- \_\_ice\_queue\_set\_napi(vsi->netdev, queue\_index, type, napi,- false);- else- \_\_ice\_queue\_set\_napi(vsi->netdev, queue\_index, type, napi,- true);-}+ ice\_for\_each\_rxq(vsi, q\_idx)+ netif\_queue\_set\_napi(netdev, q\_idx, NETDEV\_QUEUE\_TYPE\_RX,+ &vsi->rx\_rings[q\_idx]->q\_vector->napi); -/\*\*- \* \_\_ice\_q\_vector\_set\_napi\_queues - Map queue[s] associated with the napi- \* @q\_vector: q\_vector pointer- \* @locked: is the rtnl\_lock already held- \*- \* Associate the q\_vector napi with all the queue[s] on the vector.- \* Caller indicates the lock status.- \*/-void \_\_ice\_q\_vector\_set\_napi\_queues(struct ice\_q\_vector \*q\_vector, bool locked)-{- struct ice\_rx\_ring \*rx\_ring;- struct ice\_tx\_ring \*tx\_ring;-- ice\_for\_each\_rx\_ring(rx\_ring, q\_vector->rx)- \_\_ice\_queue\_set\_napi(q\_vector->vsi->netdev, rx\_ring->q\_index,- NETDEV\_QUEUE\_TYPE\_RX, &q\_vector->napi,- locked);-- ice\_for\_each\_tx\_ring(tx\_ring, q\_vector->tx)- \_\_ice\_queue\_set\_napi(q\_vector->vsi->netdev, tx\_ring->q\_index,- NETDEV\_QUEUE\_TYPE\_TX, &q\_vector->napi,- locked);+ ice\_for\_each\_txq(vsi, q\_idx)+ netif\_queue\_set\_napi(netdev, q\_idx, NETDEV\_QUEUE\_TYPE\_TX,+ &vsi->tx\_rings[q\_idx]->q\_vector->napi); /\* Also set the interrupt number for the NAPI \*/- netif\_napi\_set\_irq(&q\_vector->napi, q\_vector->irq.virq);-}+ ice\_for\_each\_q\_vector(vsi, v\_idx) {+ struct ice\_q\_vector \*q\_vector = vsi->q\_vectors[v\_idx]; -/\*\*- \* ice\_q\_vector\_set\_napi\_queues - Map queue[s] associated with the napi- \* @q\_vector: q\_vector pointer- \*- \* Associate the q\_vector napi with all the queue[s] on the vector- \*/-void ice\_q\_vector\_set\_napi\_queues(struct ice\_q\_vector \*q\_vector)-{- struct ice\_rx\_ring \*rx\_ring;- struct ice\_tx\_ring \*tx\_ring;-- ice\_for\_each\_rx\_ring(rx\_ring, q\_vector->rx)- ice\_queue\_set\_napi(q\_vector->vsi, rx\_ring->q\_index,- NETDEV\_QUEUE\_TYPE\_RX, &q\_vector->napi);-- ice\_for\_each\_tx\_ring(tx\_ring, q\_vector->tx)- ice\_queue\_set\_napi(q\_vector->vsi, tx\_ring->q\_index,- NETDEV\_QUEUE\_TYPE\_TX, &q\_vector->napi);- /\* Also set the interrupt number for the NAPI \*/- netif\_napi\_set\_irq(&q\_vector->napi, q\_vector->irq.virq);+ netif\_napi\_set\_irq(&q\_vector->napi, q\_vector->irq.virq);+ } }  /\*\*- \* ice\_vsi\_set\_napi\_queues+ \* ice\_vsi\_clear\_napi\_queues - dissociate netdev queues from napi \* @vsi: VSI pointer \*- \* Associate queue[s] with napi for all vectors+ \* Clear the association between all VSI queues queue[s] and napi.+ \* The caller must hold rtnl\_lock. \*/-void ice\_vsi\_set\_napi\_queues(struct ice\_vsi \*vsi)+void ice\_vsi\_clear\_napi\_queues(struct ice\_vsi \*vsi) {- int i;+ struct net\_device \*netdev = vsi->netdev;+ int q\_idx; - if (!vsi->netdev)+ if (!netdev) return; - ice\_for\_each\_q\_vector(vsi, i)- ice\_q\_vector\_set\_napi\_queues(vsi->q\_vectors[i]);+ ice\_for\_each\_txq(vsi, q\_idx)+ netif\_queue\_set\_napi(netdev, q\_idx, NETDEV\_QUEUE\_TYPE\_TX, NULL);++ ice\_for\_each\_rxq(vsi, q\_idx)+ netif\_queue\_set\_napi(netdev, q\_idx, NETDEV\_QUEUE\_TYPE\_RX, NULL); }  /\*\*diff --git a/drivers/net/ethernet/intel/ice/ice\_lib.h b/drivers/net/ethernet/intel/ice/ice\_lib.hindex 94ce8964dda66e..36d86535695dd5 100644--- a/[drivers/net/ethernet/intel/ice/ice\_lib.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice_lib.h?id=cfd433cecef929b4d92685f570f1a480762ec260)+++ b/[drivers/net/ethernet/intel/ice/ice\_lib.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice_lib.h?id=2a5dc090b92cfa5270e20056074241c6db5c9cdd)@@ -44,16 +44,10 @@ void ice\_vsi\_cfg\_netdev\_tc(struct ice\_vsi \*vsi, u8 ena\_tc); struct ice\_vsi \* ice\_vsi\_setup(struct ice\_pf \*pf, struct ice\_vsi\_cfg\_params \*params); -void-ice\_queue\_set\_napi(struct ice\_vsi \*vsi, unsigned int queue\_index,- enum netdev\_queue\_type type, struct napi\_struct \*napi);--void \_\_ice\_q\_vector\_set\_napi\_queues(struct ice\_q\_vector \*q\_vector, bool locked);--void ice\_q\_vector\_set\_napi\_queues(struct ice\_q\_vector \*q\_vector);- void ice\_vsi\_set\_napi\_queues(struct ice\_vsi \*vsi); +void ice\_vsi\_clear\_napi\_queues(struct ice\_vsi \*vsi);+ int ice\_vsi\_release(struct ice\_vsi \*vsi);  void ice\_vsi\_close(struct ice\_vsi \*vsi);diff --git a/drivers/net/ethernet/intel/ice/ice\_main.c b/drivers/net/ethernet/intel/ice/ice\_main.cindex 46d3c5a34d6afe..263833346d3a66 100644--- a/[drivers/net/ethernet/intel/ice/ice\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice_main.c?id=cfd433cecef929b4d92685f570f1a480762ec260)+++ b/[drivers/net/ethernet/intel/ice/ice\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice_main.c?id=2a5dc090b92cfa5270e20056074241c6db5c9cdd)@@ -3558,11 +3558,9 @@ static void ice\_napi\_add(struct ice\_vsi \*vsi) if (!vsi->netdev) return; - ice\_for\_each\_q\_vector(vsi, v\_idx) {+ ice\_for\_each\_q\_vector(vsi, v\_idx) netif\_napi\_add(vsi->netdev, &vsi->q\_vectors[v\_idx]->napi, ice\_napi\_poll);- \_\_ice\_q\_vector\_set\_napi\_queues(vsi->q\_vectors[v\_idx], false);- } }  /\*\*@@ -5540,7 +5538,9 @@ static int ice\_reinit\_interrupt\_scheme(struct ice\_pf \*pf) if (ret) goto err\_reinit; ice\_vsi\_map\_rings\_to\_vectors(pf->vsi[v]);+ rtnl\_lock(); ice\_vsi\_set\_napi\_queues(pf->vsi[v]);+ rtnl\_unlock(); }  ret = ice\_req\_irq\_msix\_misc(pf);@@ -5554,8 +5554,12 @@ static int ice\_reinit\_interrupt\_scheme(struct ice\_pf \*pf)  err\_reinit: while (v--)- if (pf->vsi[v])+ if (pf->vsi[v]) {+ rtnl\_lock();+ ice\_vsi\_clear\_napi\_queues(pf->vsi[v]);+ rtnl\_unlock(); ice\_vsi\_free\_q\_vectors(pf->vsi[v]);+ }  return ret; }@@ -5620,6 +5624,9 @@ static int ice\_suspend(struct device \*dev) ice\_for\_each\_vsi(pf, v) { if (!pf->vsi[v]) continue;+ rtnl\_lock();+ ice\_vsi\_clear\_napi\_queues(pf->vsi[v]);+ rtnl\_unlock(); ice\_vsi\_free\_q\_vectors(pf->vsi[v]); } ice\_clear\_interrupt\_scheme(pf);@@ -7455,6 +7462,8 @@ int ice\_vsi\_open(struct ice\_vsi \*vsi) err = netif\_set\_real\_num\_rx\_queues(vsi->netdev, vsi->num\_rxq); if (err) goto err\_set\_qs;++ ice\_vsi\_set\_napi\_queues(vsi); }  err = ice\_up\_complete(vsi); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 21:43:19 +0000

